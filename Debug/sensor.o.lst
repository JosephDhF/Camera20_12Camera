   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"sensor.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  18              	SensorI2CAccessDelay.part.0:
  19              	.LFB12:
  20              		.file 1 "../sensor.c"
   1:../sensor.c   **** /*
   2:../sensor.c   ****  ## Cypress FX3 Camera Kit source file (sensor.c)
   3:../sensor.c   ****  ## ===========================
   4:../sensor.c   ****  ##
   5:../sensor.c   ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../sensor.c   ****  ##  All Rights Reserved
   7:../sensor.c   ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../sensor.c   ****  ##
   9:../sensor.c   ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../sensor.c   ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../sensor.c   ****  ##
  12:../sensor.c   ****  ##  Use of this file is governed
  13:../sensor.c   ****  ##  by the license agreement included in the file
  14:../sensor.c   ****  ##
  15:../sensor.c   ****  ##     <install>/license/license.txt
  16:../sensor.c   ****  ##
  17:../sensor.c   ****  ##  where <install> is the Cypress software
  18:../sensor.c   ****  ##  installation root directory path.
  19:../sensor.c   ****  ##
  20:../sensor.c   ****  ## ===========================
  21:../sensor.c   ****  */
  22:../sensor.c   **** 
  23:../sensor.c   **** /* This file implements the I2C based driver for an image sensor that uses I2C
  24:../sensor.c   ****  for control in the FX3 HD 720p camera kit.
  25:../sensor.c   ****  */
  26:../sensor.c   **** 
  27:../sensor.c   **** #include <cyu3system.h>
  28:../sensor.c   **** #include <cyu3os.h>
  29:../sensor.c   **** #include <cyu3dma.h>
  30:../sensor.c   **** #include <cyu3error.h>
  31:../sensor.c   **** #include <cyu3uart.h>
  32:../sensor.c   **** #include <cyu3i2c.h>
  33:../sensor.c   **** #include <cyu3types.h>
  34:../sensor.c   **** #include <cyu3gpio.h>
  35:../sensor.c   **** #include <cyu3utils.h>
  36:../sensor.c   **** #include "sensor.h"
  37:../sensor.c   **** #include "uvc.h"
  38:../sensor.c   **** 
  39:../sensor.c   **** /* This function inserts a delay between successful I2C transfers to prevent
  40:../sensor.c   ****  false errors due to the slave being busy.
  41:../sensor.c   ****  */
  42:../sensor.c   **** static void SensorI2CAccessDelay(CyU3PReturnStatus_t status, CyBool_t isRead) {//add a read flag fo
  21              		.loc 1 42 0
  22              		.cfi_startproc
  23              		@ args = 0, pretend = 0, frame = 0
  24              		@ frame_needed = 0, uses_anonymous_args = 0
  25              	.LVL0:
  26 0000 10402DE9 		stmfd	sp!, {r4, lr}
  27              	.LCFI0:
  28              		.cfi_def_cfa_offset 8
  29              		.cfi_offset 4, -8
  30              		.cfi_offset 14, -4
  43:../sensor.c   **** 	/* Add a 10us delay if the I2C operation that preceded this call was successful. */
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
  45:../sensor.c   **** 	{
  46:../sensor.c   **** 		if(isRead){
  47:../sensor.c   **** 			CyU3PBusyWait(40000); // 40ms delay.
  31              		.loc 1 47 0
  32 0004 10409FE5 		ldr	r4, .L2
  33 0008 0400A0E1 		mov	r0, r4
  34 000c FEFFFFEB 		bl	CyFx3BusyWait
  35              	.LVL1:
  48:../sensor.c   **** 			CyU3PBusyWait(40000); // 40ms delay.
  36              		.loc 1 48 0
  37 0010 0400A0E1 		mov	r0, r4
  49:../sensor.c   **** 		}
  50:../sensor.c   **** 		else
  51:../sensor.c   **** 			CyU3PBusyWait(2000); //change into 2ms org is 100us (100).
  52:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
  53:../sensor.c   **** 	{
  54:../sensor.c   **** 		//CyFxUVCApplnI2CInit ();
  55:../sensor.c   **** 		//CyU3PBusyWait(1000);
  56:../sensor.c   **** 	}
  57:../sensor.c   **** }
  38              		.loc 1 57 0
  39 0014 1040BDE8 		ldmfd	sp!, {r4, lr}
  48:../sensor.c   **** 			CyU3PBusyWait(40000); // 40ms delay.
  40              		.loc 1 48 0
  41 0018 FEFFFFEA 		b	CyFx3BusyWait
  42              	.LVL2:
  43              	.L3:
  44              		.align	2
  45              	.L2:
  46 001c 409C0000 		.word	40000
  47              		.cfi_endproc
  48              	.LFE12:
  50              		.align	2
  51              		.global	SensorWrite2B
  53              	SensorWrite2B:
  54              	.LFB1:
  58:../sensor.c   **** 
  59:../sensor.c   **** /* Write to an I2C slave with two bytes of data. */
  60:../sensor.c   **** CyU3PReturnStatus_t SensorWrite2B(
  61:../sensor.c   **** 	uint8_t slaveAddr,
  62:../sensor.c   **** 	uint8_t boradAddr,
  63:../sensor.c   **** 	uint8_t highAddr,
  64:../sensor.c   **** 	uint8_t lowAddr, 
  65:../sensor.c   **** 	uint8_t numData,
  66:../sensor.c   **** 	uint8_t *buf) {
  55              		.loc 1 66 0
  56              		.cfi_startproc
  57              		@ args = 8, pretend = 0, frame = 24
  58              		@ frame_needed = 0, uses_anonymous_args = 0
  59              	.LVL3:
  60 0020 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
  61              	.LCFI1:
  62              		.cfi_def_cfa_offset 24
  63              		.cfi_offset 4, -24
  64              		.cfi_offset 5, -20
  65              		.cfi_offset 6, -16
  66              		.cfi_offset 7, -12
  67              		.cfi_offset 8, -8
  68              		.cfi_offset 14, -4
  67:../sensor.c   **** 	
  68:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  69:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
  70:../sensor.c   **** 	uint8_t inbuf[2];
  71:../sensor.c   **** 
  72:../sensor.c   **** 	/* Validate the I2C slave address. */
  73:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
  69              		.loc 1 73 0
  70 0024 A00050E3 		cmp	r0, #160
  71 0028 70005013 		cmpne	r0, #112
  66:../sensor.c   **** 	
  72              		.loc 1 66 0
  73 002c 18D04DE2 		sub	sp, sp, #24
  74              	.LCFI2:
  75              		.cfi_def_cfa_offset 48
  66:../sensor.c   **** 	
  76              		.loc 1 66 0
  77 0030 00C0A0E1 		mov	ip, r0
  78              		.loc 1 73 0
  79 0034 00E0A003 		moveq	lr, #0
  80 0038 01E0A013 		movne	lr, #1
  66:../sensor.c   **** 	
  81              		.loc 1 66 0
  82 003c 0170A0E1 		mov	r7, r1
  83 0040 0260A0E1 		mov	r6, r2
  84 0044 0350A0E1 		mov	r5, r3
  85 0048 3040DDE5 		ldrb	r4, [sp, #48]	@ zero_extendqisi2
  86              	.LVL4:
  87              		.loc 1 73 0
  88 004c 2000001A 		bne	.L10
  74:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
  75:../sensor.c   **** 		return 1;
  76:../sensor.c   **** 	}
  77:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;						/************** command block *******************************
  78:../sensor.c   **** 	preamble.buffer[1] = boradAddr;
  79:../sensor.c   **** 	preamble.buffer[2] = highAddr;
  80:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
  81:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
  82:../sensor.c   **** 	inbuf[0] = lowAddr;
  83:../sensor.c   **** 
  84:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, inbuf, 1, 0);
  89              		.loc 1 84 0
  90 0050 0E30A0E1 		mov	r3, lr
  91              	.LVL5:
  92 0054 08008DE2 		add	r0, sp, #8
  93              	.LVL6:
  81:../sensor.c   **** 	inbuf[0] = lowAddr;
  94              		.loc 1 81 0
  95 0058 0380A0E3 		mov	r8, #3
  96              		.loc 1 84 0
  97 005c 0D10A0E1 		mov	r1, sp
  98              	.LVL7:
  99 0060 0120A0E3 		mov	r2, #1
 100              	.LVL8:
  77:../sensor.c   **** 	preamble.buffer[1] = boradAddr;
 101              		.loc 1 77 0
 102 0064 08C0CDE5 		strb	ip, [sp, #8]
  78:../sensor.c   **** 	preamble.buffer[2] = highAddr;
 103              		.loc 1 78 0
 104 0068 0970CDE5 		strb	r7, [sp, #9]
  79:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 105              		.loc 1 79 0
 106 006c 0A60CDE5 		strb	r6, [sp, #10]
  80:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 107              		.loc 1 80 0
 108 0070 B2E1CDE1 		strh	lr, [sp, #18]	@ movhi
  82:../sensor.c   **** 
 109              		.loc 1 82 0
 110 0074 0050CDE5 		strb	r5, [sp]
  81:../sensor.c   **** 	inbuf[0] = lowAddr;
 111              		.loc 1 81 0
 112 0078 1080CDE5 		strb	r8, [sp, #16]
 113              		.loc 1 84 0
 114 007c FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 115              	.LVL9:
 116              	.LBB8:
 117              	.LBB9:
  44:../sensor.c   **** 	{
 118              		.loc 1 44 0
 119 0080 000050E3 		cmp	r0, #0
 120 0084 0100001A 		bne	.L7
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 121              		.loc 1 51 0
 122 0088 7D0EA0E3 		mov	r0, #2000
 123              	.LVL10:
 124 008c FEFFFFEB 		bl	CyFx3BusyWait
 125              	.LVL11:
 126              	.L7:
 127              	.LBE9:
 128              	.LBE8:
  85:../sensor.c   **** #ifdef DbgInfo
  86:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor write2B(0) %d %d %d\r\n", lowAddr, buf[0], lowData); //additional debug
  87:../sensor.c   **** #endif
  88:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus, 0);
  89:../sensor.c   **** 
  90:../sensor.c   **** 	//buf[0] = lowData;								/****************** data block ****************************************
  91:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 129              		.loc 1 91 0
 130 0090 00C0A0E3 		mov	ip, #0
  92:../sensor.c   **** 	preamble.length = 1;
  93:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, numData, 0);
 131              		.loc 1 93 0
 132 0094 0420A0E1 		mov	r2, r4
  92:../sensor.c   **** 	preamble.length = 1;
 133              		.loc 1 92 0
 134 0098 01E0A0E3 		mov	lr, #1
 135              		.loc 1 93 0
 136 009c 08008DE2 		add	r0, sp, #8
 137 00a0 0C30A0E1 		mov	r3, ip
 138 00a4 34109DE5 		ldr	r1, [sp, #52]
  91:../sensor.c   **** 	preamble.length = 1;
 139              		.loc 1 91 0
 140 00a8 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
  92:../sensor.c   **** 	preamble.length = 1;
 141              		.loc 1 92 0
 142 00ac 10E0CDE5 		strb	lr, [sp, #16]
 143              		.loc 1 93 0
 144 00b0 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 145              	.LVL12:
 146              	.LBB10:
 147              	.LBB11:
  44:../sensor.c   **** 	{
 148              		.loc 1 44 0
 149 00b4 004050E2 		subs	r4, r0, #0
 150 00b8 0400A011 		movne	r0, r4
 151              	.LVL13:
 152 00bc 0200001A 		bne	.L6
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 153              		.loc 1 51 0
 154 00c0 7D0EA0E3 		mov	r0, #2000
 155 00c4 FEFFFFEB 		bl	CyFx3BusyWait
 156              	.LVL14:
 157 00c8 0400A0E1 		mov	r0, r4
 158              	.L6:
 159              	.LBE11:
 160              	.LBE10:
  94:../sensor.c   **** #ifdef DbgInfo
  95:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor write2B(1) %d %d %d\r\n", lowAddr, buf[0], buf[1]); //additional debug
  96:../sensor.c   **** #endif
  97:../sensor.c   **** 	/* Set the parameters for the I2C API access and then call the write API. */
  98:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus, 0);
  99:../sensor.c   **** 	return apiRetStatus;
 100:../sensor.c   **** }
 161              		.loc 1 100 0
 162 00cc 18D08DE2 		add	sp, sp, #24
 163              		@ sp needed
 164 00d0 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 165              	.LVL15:
 166              	.L10:
 167              	.LBB12:
 168              	.LBB13:
  74:../sensor.c   **** 		return 1;
 169              		.loc 1 74 0
 170 00d4 10109FE5 		ldr	r1, .L11
 171              	.LVL16:
 172 00d8 0400A0E3 		mov	r0, #4
 173              	.LVL17:
 174 00dc FEFFFFEB 		bl	CyU3PDebugPrint
 175              	.LVL18:
 176 00e0 0100A0E3 		mov	r0, #1
 177              	.LBE13:
 178              	.LBE12:
 179              		.loc 1 100 0
 180 00e4 18D08DE2 		add	sp, sp, #24
 181              		@ sp needed
 182 00e8 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 183              	.LVL19:
 184              	.L12:
 185              		.align	2
 186              	.L11:
 187 00ec 00000000 		.word	.LC0
 188              		.cfi_endproc
 189              	.LFE1:
 191              		.align	2
 192              		.global	SensorWrite
 194              	SensorWrite:
 195              	.LFB2:
 101:../sensor.c   **** 
 102:../sensor.c   **** CyU3PReturnStatus_t SensorWrite(uint8_t slaveAddr, uint8_t highAddr,
 103:../sensor.c   **** 		uint8_t lowAddr, uint8_t count, uint8_t *buf) {
 196              		.loc 1 103 0
 197              		.cfi_startproc
 198              		@ args = 4, pretend = 0, frame = 16
 199              		@ frame_needed = 0, uses_anonymous_args = 0
 200              	.LVL20:
 104:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 105:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
 106:../sensor.c   **** 
 107:../sensor.c   **** 	/* Validate the I2C slave address. */
 108:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
 201              		.loc 1 108 0
 202 00f0 A00050E3 		cmp	r0, #160
 203 00f4 70005013 		cmpne	r0, #112
 103:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 204              		.loc 1 103 0
 205 00f8 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 206              	.LCFI3:
 207              		.cfi_def_cfa_offset 16
 208              		.cfi_offset 4, -16
 209              		.cfi_offset 5, -12
 210              		.cfi_offset 6, -8
 211              		.cfi_offset 14, -4
 212 00fc 00C0A0E1 		mov	ip, r0
 213 0100 10D04DE2 		sub	sp, sp, #16
 214              	.LCFI4:
 215              		.cfi_def_cfa_offset 32
 216              		.loc 1 108 0
 217 0104 00E0A003 		moveq	lr, #0
 218 0108 01E0A013 		movne	lr, #1
 219 010c 1C00001A 		bne	.L18
 109:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 110:../sensor.c   **** 		return 1;
 111:../sensor.c   **** 	}
 112:../sensor.c   **** 
 113:../sensor.c   **** 	if (count > 64) {
 220              		.loc 1 113 0
 221 0110 400053E3 		cmp	r3, #64
 222 0114 1400008A 		bhi	.L19
 114:../sensor.c   **** 		CyU3PDebugPrint(4, "ERROR: SensorWrite count > 64\n");
 115:../sensor.c   **** 		return 1;
 116:../sensor.c   **** 	}
 117:../sensor.c   **** 
 118:../sensor.c   **** 	/* Set up the I2C control parameters and invoke the write API. */
 119:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;
 120:../sensor.c   **** 	preamble.buffer[1] = 0xab;//highAddr;
 121:../sensor.c   **** 	preamble.buffer[2] = 0xcd;//lowAddr;
 122:../sensor.c   **** 	preamble.length = 3;
 123:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 124:../sensor.c   **** 
 125:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, count, 0);
 223              		.loc 1 125 0
 224 0118 0320A0E1 		mov	r2, r3
 225              	.LVL21:
 122:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 226              		.loc 1 122 0
 227 011c 0340A0E3 		mov	r4, #3
 228              		.loc 1 125 0
 229 0120 0E30A0E1 		mov	r3, lr
 230              	.LVL22:
 120:../sensor.c   **** 	preamble.buffer[2] = 0xcd;//lowAddr;
 231              		.loc 1 120 0
 232 0124 5460E0E3 		mvn	r6, #84
 121:../sensor.c   **** 	preamble.length = 3;
 233              		.loc 1 121 0
 234 0128 3250E0E3 		mvn	r5, #50
 235              		.loc 1 125 0
 236 012c 0D00A0E1 		mov	r0, sp
 237              	.LVL23:
 238 0130 20109DE5 		ldr	r1, [sp, #32]
 239              	.LVL24:
 122:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 240              		.loc 1 122 0
 241 0134 0840CDE5 		strb	r4, [sp, #8]
 119:../sensor.c   **** 	preamble.buffer[1] = 0xab;//highAddr;
 242              		.loc 1 119 0
 243 0138 00C0CDE5 		strb	ip, [sp]
 123:../sensor.c   **** 
 244              		.loc 1 123 0
 245 013c BAE0CDE1 		strh	lr, [sp, #10]	@ movhi
 120:../sensor.c   **** 	preamble.buffer[2] = 0xcd;//lowAddr;
 246              		.loc 1 120 0
 247 0140 0160CDE5 		strb	r6, [sp, #1]
 121:../sensor.c   **** 	preamble.length = 3;
 248              		.loc 1 121 0
 249 0144 0250CDE5 		strb	r5, [sp, #2]
 250              		.loc 1 125 0
 251 0148 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 252              	.LVL25:
 253              	.LBB16:
 254              	.LBB17:
  44:../sensor.c   **** 	{
 255              		.loc 1 44 0
 256 014c 004050E2 		subs	r4, r0, #0
 257 0150 0400A011 		movne	r0, r4
 258              	.LVL26:
 259 0154 0200001A 		bne	.L15
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 260              		.loc 1 51 0
 261 0158 7D0EA0E3 		mov	r0, #2000
 262 015c FEFFFFEB 		bl	CyFx3BusyWait
 263              	.LVL27:
 264 0160 0400A0E1 		mov	r0, r4
 265              	.L15:
 266              	.LBE17:
 267              	.LBE16:
 126:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus, 0);
 127:../sensor.c   **** 
 128:../sensor.c   **** 	return apiRetStatus;
 129:../sensor.c   **** }
 268              		.loc 1 129 0
 269 0164 10D08DE2 		add	sp, sp, #16
 270              		@ sp needed
 271 0168 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 272              	.LVL28:
 273              	.L19:
 114:../sensor.c   **** 		return 1;
 274              		.loc 1 114 0
 275 016c 28109FE5 		ldr	r1, .L20
 276              	.LVL29:
 277 0170 0400A0E3 		mov	r0, #4
 278              	.LVL30:
 279 0174 FEFFFFEB 		bl	CyU3PDebugPrint
 280              	.LVL31:
 115:../sensor.c   **** 	}
 281              		.loc 1 115 0
 282 0178 0100A0E3 		mov	r0, #1
 283              		.loc 1 129 0
 284 017c 10D08DE2 		add	sp, sp, #16
 285              		@ sp needed
 286 0180 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 287              	.LVL32:
 288              	.L18:
 109:../sensor.c   **** 		return 1;
 289              		.loc 1 109 0
 290 0184 14109FE5 		ldr	r1, .L20+4
 291              	.LVL33:
 292 0188 0400A0E3 		mov	r0, #4
 293              	.LVL34:
 294 018c FEFFFFEB 		bl	CyU3PDebugPrint
 295              	.LVL35:
 110:../sensor.c   **** 	}
 296              		.loc 1 110 0
 297 0190 0100A0E3 		mov	r0, #1
 298              		.loc 1 129 0
 299 0194 10D08DE2 		add	sp, sp, #16
 300              		@ sp needed
 301 0198 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 302              	.L21:
 303              		.align	2
 304              	.L20:
 305 019c 24000000 		.word	.LC1
 306 01a0 00000000 		.word	.LC0
 307              		.cfi_endproc
 308              	.LFE2:
 310              		.align	2
 311              		.global	SensorRead2B
 313              	SensorRead2B:
 314              	.LFB3:
 130:../sensor.c   **** 
 131:../sensor.c   **** CyU3PReturnStatus_t SensorRead2B(
 132:../sensor.c   **** 		uint8_t slaveAddr, 
 133:../sensor.c   **** 		uint8_t highAddr,
 134:../sensor.c   **** 		uint8_t lowAddr, 
 135:../sensor.c   **** 		uint8_t RegAdd,
 136:../sensor.c   **** 		uint8_t numData,
 137:../sensor.c   **** 		uint8_t *buf) {
 315              		.loc 1 137 0
 316              		.cfi_startproc
 317              		@ args = 8, pretend = 0, frame = 16
 318              		@ frame_needed = 0, uses_anonymous_args = 0
 319              	.LVL36:
 320 01a4 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 321              	.LCFI5:
 322              		.cfi_def_cfa_offset 28
 323              		.cfi_offset 4, -28
 324              		.cfi_offset 5, -24
 325              		.cfi_offset 6, -20
 326              		.cfi_offset 7, -16
 327              		.cfi_offset 8, -12
 328              		.cfi_offset 9, -8
 329              		.cfi_offset 14, -4
 138:../sensor.c   **** 	
 139:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 140:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
 141:../sensor.c   **** 
 142:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_RD) && (slaveAddr != I2C_MEMORY_ADDR_RD)) {
 330              		.loc 1 142 0
 331 01a8 A10050E3 		cmp	r0, #161
 332 01ac 71005013 		cmpne	r0, #113
 137:../sensor.c   **** 	
 333              		.loc 1 137 0
 334 01b0 1CD04DE2 		sub	sp, sp, #28
 335              	.LCFI6:
 336              		.cfi_def_cfa_offset 56
 137:../sensor.c   **** 	
 337              		.loc 1 137 0
 338 01b4 0040A0E1 		mov	r4, r0
 339              		.loc 1 142 0
 340 01b8 00C0A003 		moveq	ip, #0
 341 01bc 01C0A013 		movne	ip, #1
 137:../sensor.c   **** 	
 342              		.loc 1 137 0
 343 01c0 0170A0E1 		mov	r7, r1
 344 01c4 02E0A0E1 		mov	lr, r2
 345 01c8 3860DDE5 		ldrb	r6, [sp, #56]	@ zero_extendqisi2
 346 01cc 3C509DE5 		ldr	r5, [sp, #60]
 347              		.loc 1 142 0
 348 01d0 2300001A 		bne	.L30
 349              	.LVL37:
 350              	.LBB26:
 351              	.LBB27:
 143:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 144:../sensor.c   **** 		return 1;
 145:../sensor.c   **** 	}
 146:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 147:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 148:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 149:../sensor.c   **** 	preamble.length = 3;
 150:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 151:../sensor.c   **** 	buf[0] = RegAdd;
 352              		.loc 1 151 0
 353 01d4 0030C5E5 		strb	r3, [r5]
 152:../sensor.c   **** #ifdef DbgInfo
 153:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor read2B(0) %d %d %d %d %d\r\n", lowAddr, RegAdd, numData, buf[0], buf[1]
 154:../sensor.c   **** #endif
 155:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0); //send command block to prepare for re
 354              		.loc 1 155 0
 355 01d8 0120A0E3 		mov	r2, #1
 356              	.LVL38:
 357 01dc 0C30A0E1 		mov	r3, ip
 358              	.LVL39:
 359 01e0 08008DE2 		add	r0, sp, #8
 360              	.LVL40:
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 361              		.loc 1 146 0
 362 01e4 0190C4E3 		bic	r9, r4, #1
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 363              		.loc 1 149 0
 364 01e8 0380A0E3 		mov	r8, #3
 365              		.loc 1 155 0
 366 01ec 0510A0E1 		mov	r1, r5
 367              	.LVL41:
 147:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 368              		.loc 1 147 0
 369 01f0 0970CDE5 		strb	r7, [sp, #9]
 148:../sensor.c   **** 	preamble.length = 3;
 370              		.loc 1 148 0
 371 01f4 0AE0CDE5 		strb	lr, [sp, #10]
 150:../sensor.c   **** 	buf[0] = RegAdd;
 372              		.loc 1 150 0
 373 01f8 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 374              		.loc 1 146 0
 375 01fc 0890CDE5 		strb	r9, [sp, #8]
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 376              		.loc 1 149 0
 377 0200 1080CDE5 		strb	r8, [sp, #16]
 378              		.loc 1 155 0
 379 0204 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 380              	.LVL42:
 156:../sensor.c   **** 	/*** test I2C bus ready ****/
 157:../sensor.c   **** 	if(apiRetStatus != CY_U3P_SUCCESS){
 381              		.loc 1 157 0
 382 0208 002050E2 		subs	r2, r0, #0
 383 020c 1A00001A 		bne	.L31
 384              	.LVL43:
 385              	.LBB28:
 386              	.LBB29:
 387              	.LBB30:
  47:../sensor.c   **** 			CyU3PBusyWait(40000); // 40ms delay.
 388              		.loc 1 47 0
 389 0210 A0009FE5 		ldr	r0, .L33
 390              	.LVL44:
 391 0214 FEFFFFEB 		bl	CyFx3BusyWait
 392              	.LVL45:
  48:../sensor.c   **** 		}
 393              		.loc 1 48 0
 394 0218 98009FE5 		ldr	r0, .L33
 395 021c FEFFFFEB 		bl	CyFx3BusyWait
 396              	.LVL46:
 397              	.L27:
 398              	.LBE30:
 399              	.LBE29:
 400              	.LBE28:
 158:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(T) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 159:../sensor.c   **** 	}
 160:../sensor.c   **** 
 161:../sensor.c   **** #ifdef DbgInfo
 162:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor read2B(1) %d %d %d\r\n", lowAddr, buf[0], buf[1]); //additional debug
 163:../sensor.c   **** #endif
 164:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus, 1);
 165:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;
 166:../sensor.c   **** 	preamble.length = 1;
 167:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 401              		.loc 1 167 0
 402 0220 00C0A0E3 		mov	ip, #0
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 403              		.loc 1 166 0
 404 0224 01E0A0E3 		mov	lr, #1
 168:../sensor.c   **** 
 169:../sensor.c   **** 	apiRetStatus = CyU3PI2cReceiveBytes(&preamble, buf, numData, 0);//send data block read one byte
 405              		.loc 1 169 0
 406 0228 08008DE2 		add	r0, sp, #8
 407 022c 0620A0E1 		mov	r2, r6
 408 0230 0C30A0E1 		mov	r3, ip
 409 0234 0510A0E1 		mov	r1, r5
 165:../sensor.c   **** 	preamble.length = 1;
 410              		.loc 1 165 0
 411 0238 0840CDE5 		strb	r4, [sp, #8]
 167:../sensor.c   **** 
 412              		.loc 1 167 0
 413 023c B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 414              		.loc 1 166 0
 415 0240 10E0CDE5 		strb	lr, [sp, #16]
 416              		.loc 1 169 0
 417 0244 FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 418              	.LVL47:
 170:../sensor.c   **** 	/*** test I2C bus ready ****/
 171:../sensor.c   **** 	if(apiRetStatus != CY_U3P_SUCCESS){
 419              		.loc 1 171 0
 420 0248 004050E2 		subs	r4, r0, #0
 421              	.LVL48:
 422 024c 1100001A 		bne	.L32
 423              	.LVL49:
 424              	.LBB31:
 425              	.LBB32:
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 426              		.loc 1 51 0
 427 0250 7D0EA0E3 		mov	r0, #2000
 428              	.LVL50:
 429 0254 FEFFFFEB 		bl	CyFx3BusyWait
 430              	.LVL51:
 431              	.L28:
 432              	.LBE32:
 433              	.LBE31:
 169:../sensor.c   **** 	/*** test I2C bus ready ****/
 434              		.loc 1 169 0
 435 0258 0400A0E1 		mov	r0, r4
 436              	.LBE27:
 437              	.LBE26:
 172:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 173:../sensor.c   **** 	}
 174:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus, 0);
 175:../sensor.c   **** #ifdef DbgInfo
 176:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor read2B(2) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]); //additional de
 177:../sensor.c   **** #endif
 178:../sensor.c   **** 	return apiRetStatus;
 179:../sensor.c   **** }
 438              		.loc 1 179 0
 439 025c 1CD08DE2 		add	sp, sp, #28
 440              		@ sp needed
 441 0260 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 442              	.LVL52:
 443              	.L30:
 143:../sensor.c   **** 		return 1;
 444              		.loc 1 143 0
 445 0264 50109FE5 		ldr	r1, .L33+4
 446              	.LVL53:
 447 0268 0400A0E3 		mov	r0, #4
 448              	.LVL54:
 449 026c FEFFFFEB 		bl	CyU3PDebugPrint
 450              	.LVL55:
 144:../sensor.c   **** 	}
 451              		.loc 1 144 0
 452 0270 0100A0E3 		mov	r0, #1
 453              		.loc 1 179 0
 454 0274 1CD08DE2 		add	sp, sp, #28
 455              		@ sp needed
 456 0278 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 457              	.LVL56:
 458              	.L31:
 459              	.LBB34:
 460              	.LBB33:
 158:../sensor.c   **** 	}
 461              		.loc 1 158 0
 462 027c 0110D5E5 		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 463 0280 0030D5E5 		ldrb	r3, [r5]	@ zero_extendqisi2
 464 0284 0400A0E3 		mov	r0, #4
 465              	.LVL57:
 466 0288 00108DE5 		str	r1, [sp]
 467 028c 2C109FE5 		ldr	r1, .L33+8
 468 0290 FEFFFFEB 		bl	CyU3PDebugPrint
 469              	.LVL58:
 470 0294 E1FFFFEA 		b	.L27
 471              	.LVL59:
 472              	.L32:
 172:../sensor.c   **** 	}
 473              		.loc 1 172 0
 474 0298 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 475 029c 0030D5E5 		ldrb	r3, [r5]	@ zero_extendqisi2
 476 02a0 1C109FE5 		ldr	r1, .L33+12
 477 02a4 00208DE5 		str	r2, [sp]
 478 02a8 0400A0E3 		mov	r0, #4
 479              	.LVL60:
 480 02ac 0420A0E1 		mov	r2, r4
 481 02b0 FEFFFFEB 		bl	CyU3PDebugPrint
 482              	.LVL61:
 483 02b4 E7FFFFEA 		b	.L28
 484              	.L34:
 485              		.align	2
 486              	.L33:
 487 02b8 409C0000 		.word	40000
 488 02bc 00000000 		.word	.LC0
 489 02c0 44000000 		.word	.LC2
 490 02c4 60000000 		.word	.LC3
 491              	.LBE33:
 492              	.LBE34:
 493              		.cfi_endproc
 494              	.LFE3:
 496              		.align	2
 497              		.global	SensorRead
 499              	SensorRead:
 500              	.LFB4:
 180:../sensor.c   **** 
 181:../sensor.c   **** CyU3PReturnStatus_t SensorRead(uint8_t slaveAddr, uint8_t highAddr,
 182:../sensor.c   **** 		uint8_t lowAddr, uint8_t count, uint8_t *buf) {
 501              		.loc 1 182 0
 502              		.cfi_startproc
 503              		@ args = 4, pretend = 0, frame = 16
 504              		@ frame_needed = 0, uses_anonymous_args = 0
 505              	.LVL62:
 183:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 184:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
 185:../sensor.c   **** 
 186:../sensor.c   **** 	/* Validate the parameters. */
 187:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_RD) && (slaveAddr != I2C_MEMORY_ADDR_RD)) {
 506              		.loc 1 187 0
 507 02c8 A10050E3 		cmp	r0, #161
 508 02cc 71005013 		cmpne	r0, #113
 182:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 509              		.loc 1 182 0
 510 02d0 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 511              	.LCFI7:
 512              		.cfi_def_cfa_offset 16
 513              		.cfi_offset 4, -16
 514              		.cfi_offset 5, -12
 515              		.cfi_offset 6, -8
 516              		.cfi_offset 14, -4
 517 02d4 00C0A0E1 		mov	ip, r0
 518 02d8 10D04DE2 		sub	sp, sp, #16
 519              	.LCFI8:
 520              		.cfi_def_cfa_offset 32
 521              		.loc 1 187 0
 522 02dc 0010A003 		moveq	r1, #0
 523 02e0 0110A013 		movne	r1, #1
 524              	.LVL63:
 525 02e4 1E00001A 		bne	.L40
 188:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 189:../sensor.c   **** 		return 1;
 190:../sensor.c   **** 	}
 191:../sensor.c   **** 	if (count > 64) {
 526              		.loc 1 191 0
 527 02e8 400053E3 		cmp	r3, #64
 528 02ec 1600008A 		bhi	.L41
 192:../sensor.c   **** 		CyU3PDebugPrint(4, "ERROR: SensorWrite count > 64\n");
 193:../sensor.c   **** 		return 1;
 194:../sensor.c   **** 	}
 195:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 196:../sensor.c   **** 	preamble.buffer[1] = 0x55;//highAddr;
 197:../sensor.c   **** 	preamble.buffer[2] = 0xaa;//lowAddr;
 198:../sensor.c   **** 	preamble.buffer[3] = slaveAddr;
 199:../sensor.c   **** 	preamble.length = 4;
 529              		.loc 1 199 0
 530 02f0 04E0A0E3 		mov	lr, #4
 200:../sensor.c   **** 	preamble.ctrlMask = 0x0004; /*  Send start bit after third byte of preamble. */
 201:../sensor.c   **** 
 202:../sensor.c   **** 	apiRetStatus = CyU3PI2cReceiveBytes(&preamble, buf, count, 0);
 531              		.loc 1 202 0
 532 02f4 0320A0E1 		mov	r2, r3
 533              	.LVL64:
 195:../sensor.c   **** 	preamble.buffer[1] = 0x55;//highAddr;
 534              		.loc 1 195 0
 535 02f8 0160C0E3 		bic	r6, r0, #1
 536              		.loc 1 202 0
 537 02fc 0130A0E1 		mov	r3, r1
 538              	.LVL65:
 197:../sensor.c   **** 	preamble.buffer[3] = slaveAddr;
 539              		.loc 1 197 0
 540 0300 5540E0E3 		mvn	r4, #85
 196:../sensor.c   **** 	preamble.buffer[2] = 0xaa;//lowAddr;
 541              		.loc 1 196 0
 542 0304 5550A0E3 		mov	r5, #85
 543              		.loc 1 202 0
 544 0308 0D00A0E1 		mov	r0, sp
 545              	.LVL66:
 546 030c 20109DE5 		ldr	r1, [sp, #32]
 197:../sensor.c   **** 	preamble.buffer[3] = slaveAddr;
 547              		.loc 1 197 0
 548 0310 0240CDE5 		strb	r4, [sp, #2]
 198:../sensor.c   **** 	preamble.length = 4;
 549              		.loc 1 198 0
 550 0314 03C0CDE5 		strb	ip, [sp, #3]
 195:../sensor.c   **** 	preamble.buffer[1] = 0x55;//highAddr;
 551              		.loc 1 195 0
 552 0318 0060CDE5 		strb	r6, [sp]
 196:../sensor.c   **** 	preamble.buffer[2] = 0xaa;//lowAddr;
 553              		.loc 1 196 0
 554 031c 0150CDE5 		strb	r5, [sp, #1]
 199:../sensor.c   **** 	preamble.ctrlMask = 0x0004; /*  Send start bit after third byte of preamble. */
 555              		.loc 1 199 0
 556 0320 08E0CDE5 		strb	lr, [sp, #8]
 200:../sensor.c   **** 
 557              		.loc 1 200 0
 558 0324 BAE0CDE1 		strh	lr, [sp, #10]	@ movhi
 559              		.loc 1 202 0
 560 0328 FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 561              	.LVL67:
 562              	.LBB37:
 563              	.LBB38:
  44:../sensor.c   **** 	{
 564              		.loc 1 44 0
 565 032c 004050E2 		subs	r4, r0, #0
 566 0330 0400A011 		movne	r0, r4
 567              	.LVL68:
 568 0334 0200001A 		bne	.L37
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 569              		.loc 1 51 0
 570 0338 7D0EA0E3 		mov	r0, #2000
 571 033c FEFFFFEB 		bl	CyFx3BusyWait
 572              	.LVL69:
 573 0340 0400A0E1 		mov	r0, r4
 574              	.L37:
 575              	.LBE38:
 576              	.LBE37:
 203:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus, 0);
 204:../sensor.c   **** 
 205:../sensor.c   **** 	return apiRetStatus;
 206:../sensor.c   **** }
 577              		.loc 1 206 0
 578 0344 10D08DE2 		add	sp, sp, #16
 579              		@ sp needed
 580 0348 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 581              	.LVL70:
 582              	.L41:
 192:../sensor.c   **** 		return 1;
 583              		.loc 1 192 0
 584 034c 28109FE5 		ldr	r1, .L42
 585 0350 0400A0E3 		mov	r0, #4
 586              	.LVL71:
 587 0354 FEFFFFEB 		bl	CyU3PDebugPrint
 588              	.LVL72:
 193:../sensor.c   **** 	}
 589              		.loc 1 193 0
 590 0358 0100A0E3 		mov	r0, #1
 591              		.loc 1 206 0
 592 035c 10D08DE2 		add	sp, sp, #16
 593              		@ sp needed
 594 0360 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 595              	.LVL73:
 596              	.L40:
 188:../sensor.c   **** 		return 1;
 597              		.loc 1 188 0
 598 0364 14109FE5 		ldr	r1, .L42+4
 599 0368 0400A0E3 		mov	r0, #4
 600              	.LVL74:
 601 036c FEFFFFEB 		bl	CyU3PDebugPrint
 602              	.LVL75:
 189:../sensor.c   **** 	}
 603              		.loc 1 189 0
 604 0370 0100A0E3 		mov	r0, #1
 605              		.loc 1 206 0
 606 0374 10D08DE2 		add	sp, sp, #16
 607              		@ sp needed
 608 0378 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 609              	.L43:
 610              		.align	2
 611              	.L42:
 612 037c 24000000 		.word	.LC1
 613 0380 00000000 		.word	.LC0
 614              		.cfi_endproc
 615              	.LFE4:
 617              		.align	2
 618              		.global	SensorReset
 620              	SensorReset:
 621              	.LFB5:
 207:../sensor.c   **** 
 208:../sensor.c   **** /*
 209:../sensor.c   ****  * Reset the image sensor using GPIO.
 210:../sensor.c   ****  */
 211:../sensor.c   **** void SensorReset(void) {
 622              		.loc 1 211 0
 623              		.cfi_startproc
 624              		@ args = 0, pretend = 0, frame = 0
 625              		@ frame_needed = 0, uses_anonymous_args = 0
 626 0384 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 627              	.LCFI9:
 628              		.cfi_def_cfa_offset 16
 629              		.cfi_offset 3, -16
 630              		.cfi_offset 4, -12
 631              		.cfi_offset 5, -8
 632              		.cfi_offset 14, -4
 212:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus;
 213:../sensor.c   **** 	uint16_t preTick, posTick;
 214:../sensor.c   **** 	/* Drive the GPIO low to reset the sensor. */
 215:../sensor.c   **** 	//apiRetStatus = CyU3PGpioSetValue(SENSOR_POWER_GPIO, CyFalse);
 216:../sensor.c   **** 	apiRetStatus = CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
 633              		.loc 1 216 0
 634 0388 1600A0E3 		mov	r0, #22
 635 038c 0010A0E3 		mov	r1, #0
 636 0390 FEFFFFEB 		bl	CyU3PGpioSetValue
 637              	.LVL76:
 217:../sensor.c   **** 	if (apiRetStatus != CY_U3P_SUCCESS) {
 638              		.loc 1 217 0
 639 0394 002050E2 		subs	r2, r0, #0
 218:../sensor.c   **** 		CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n",
 640              		.loc 1 218 0
 641 0398 0400A0E3 		mov	r0, #4
 642              	.LVL77:
 217:../sensor.c   **** 	if (apiRetStatus != CY_U3P_SUCCESS) {
 643              		.loc 1 217 0
 644 039c 1A00001A 		bne	.L49
 219:../sensor.c   **** 				apiRetStatus);
 220:../sensor.c   **** 		return;
 221:../sensor.c   **** 	}
 222:../sensor.c   **** 	CyU3PDebugPrint(4, "GPIO Set Value\r\n");
 645              		.loc 1 222 0
 646 03a0 70109FE5 		ldr	r1, .L50
 647 03a4 FEFFFFEB 		bl	CyU3PDebugPrint
 648              	.LVL78:
 649 03a8 0240A0E3 		mov	r4, #2
 650              	.LVL79:
 651              	.L47:
 223:../sensor.c   **** 	/* Wait for some time to allow proper reset. */
 224:../sensor.c   **** 	uint8_t i = 0;
 225:../sensor.c   **** 	while (i++ < 2){
 226:../sensor.c   **** 		preTick = CyU3PGetTime();
 652              		.loc 1 226 0
 653 03ac FEFFFFEB 		bl	_tx_time_get
 654              	.LVL80:
 655 03b0 0050A0E1 		mov	r5, r0
 656              	.LVL81:
 227:../sensor.c   **** 		CyU3PThreadSleep(500);  // change the value into 100 from 10.
 657              		.loc 1 227 0
 658 03b4 7D0FA0E3 		mov	r0, #500
 659              	.LVL82:
 660 03b8 FEFFFFEB 		bl	_tx_thread_sleep
 661              	.LVL83:
 228:../sensor.c   **** 		posTick = CyU3PGetTime();
 662              		.loc 1 228 0
 663 03bc FEFFFFEB 		bl	_tx_time_get
 664              	.LVL84:
 665 03c0 0528A0E1 		mov	r2, r5, asl #16
 229:../sensor.c   **** 		CyU3PDebugPrint(4, "The ticks %d %d \r\n", preTick, posTick); //additional debug
 666              		.loc 1 229 0
 667 03c4 2228A0E1 		mov	r2, r2, lsr #16
 668 03c8 4C109FE5 		ldr	r1, .L50+4
 669 03cc 0038A0E1 		mov	r3, r0, asl #16
 670 03d0 2338A0E1 		mov	r3, r3, lsr #16
 671 03d4 0400A0E3 		mov	r0, #4
 672              	.LVL85:
 673 03d8 FEFFFFEB 		bl	CyU3PDebugPrint
 674              	.LVL86:
 675 03dc 013044E2 		sub	r3, r4, #1
 225:../sensor.c   **** 		preTick = CyU3PGetTime();
 676              		.loc 1 225 0
 677 03e0 FF4013E2 		ands	r4, r3, #255
 678 03e4 F0FFFF1A 		bne	.L47
 230:../sensor.c   **** 		//;//CyU3PDebugPrint(4, "cpu pause \r\n");
 231:../sensor.c   **** 	}
 232:../sensor.c   **** 
 233:../sensor.c   **** 	/* Drive the GPIO high to bring the sensor out of reset. */
 234:../sensor.c   **** 	//apiRetStatus = CyU3PGpioSetValue(SENSOR_POWER_GPIO, CyTrue);
 235:../sensor.c   **** 	apiRetStatus = CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
 679              		.loc 1 235 0
 680 03e8 1600A0E3 		mov	r0, #22
 681 03ec 0110A0E3 		mov	r1, #1
 682 03f0 FEFFFFEB 		bl	CyU3PGpioSetValue
 683              	.LVL87:
 236:../sensor.c   **** 	if (apiRetStatus != CY_U3P_SUCCESS) {
 684              		.loc 1 236 0
 685 03f4 002050E2 		subs	r2, r0, #0
 686 03f8 0200001A 		bne	.L48
 687              	.LVL88:
 237:../sensor.c   **** 		CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n",
 238:../sensor.c   **** 				apiRetStatus);
 239:../sensor.c   **** 		return;
 240:../sensor.c   **** 	}
 241:../sensor.c   **** /* pause the cpu */
 242:../sensor.c   **** 	while (i++ < 4){
 243:../sensor.c   **** 		CyU3PThreadSleep(600);  // change the value into 100 from 10.
 688              		.loc 1 243 0 discriminator 1
 689 03fc 960FA0E3 		mov	r0, #600
 690              	.LVL89:
 244:../sensor.c   **** 		//;//CyU3PDebugPrint(4, "cpu pause \r\n");
 245:../sensor.c   **** 	}
 246:../sensor.c   **** 
 247:../sensor.c   **** 	return;
 248:../sensor.c   **** }
 691              		.loc 1 248 0 discriminator 1
 692 0400 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 693              	.LVL90:
 243:../sensor.c   **** 		//;//CyU3PDebugPrint(4, "cpu pause \r\n");
 694              		.loc 1 243 0 discriminator 1
 695 0404 FEFFFFEA 		b	_tx_thread_sleep
 696              	.LVL91:
 697              	.L48:
 237:../sensor.c   **** 		CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n",
 698              		.loc 1 237 0
 699 0408 0400A0E3 		mov	r0, #4
 700              	.LVL92:
 701              	.L49:
 702 040c 0C109FE5 		ldr	r1, .L50+8
 703              		.loc 1 248 0
 704 0410 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 237:../sensor.c   **** 		CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n",
 705              		.loc 1 237 0
 706 0414 FEFFFFEA 		b	CyU3PDebugPrint
 707              	.LVL93:
 708              	.L51:
 709              		.align	2
 710              	.L50:
 711 0418 A4000000 		.word	.LC5
 712 041c B8000000 		.word	.LC6
 713 0420 7C000000 		.word	.LC4
 714              		.cfi_endproc
 715              	.LFE5:
 717              		.align	2
 718              		.global	SensorInit
 720              	SensorInit:
 721              	.LFB6:
 249:../sensor.c   **** 
 250:../sensor.c   **** /* Image sensor initialization sequence. */
 251:../sensor.c   **** void SensorInit(void) {
 722              		.loc 1 251 0
 723              		.cfi_startproc
 724              		@ args = 0, pretend = 0, frame = 24
 725              		@ frame_needed = 0, uses_anonymous_args = 0
 726              	.LVL94:
 727 0424 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 728              	.LCFI10:
 729              		.cfi_def_cfa_offset 20
 730              		.cfi_offset 4, -20
 731              		.cfi_offset 5, -16
 732              		.cfi_offset 6, -12
 733              		.cfi_offset 7, -8
 734              		.cfi_offset 14, -4
 735              	.LBB51:
 736              	.LBB52:
 737              	.LBB53:
 738              	.LBB54:
 739              	.LBB55:
 740              	.LBB56:
 150:../sensor.c   **** 	buf[0] = RegAdd;
 741              		.loc 1 150 0
 742 0428 00C0A0E3 		mov	ip, #0
 743              	.LBE56:
 744              	.LBE55:
 745              	.LBE54:
 746              	.LBE53:
 747              	.LBE52:
 748              	.LBE51:
 749              		.loc 1 251 0
 750 042c 24D04DE2 		sub	sp, sp, #36
 751              	.LCFI11:
 752              		.cfi_def_cfa_offset 56
 753              	.LVL95:
 754              	.LBB72:
 755              	.LBB70:
 756              	.LBB68:
 757              	.LBB66:
 758              	.LBB64:
 759              	.LBB62:
 151:../sensor.c   **** #ifdef DbgInfo
 760              		.loc 1 151 0
 761 0430 0DE0E0E3 		mvn	lr, #13
 155:../sensor.c   **** 	/*** test I2C bus ready ****/
 762              		.loc 1 155 0
 763 0434 0120A0E3 		mov	r2, #1
 764 0438 0C30A0E1 		mov	r3, ip
 765 043c 10008DE2 		add	r0, sp, #16
 766 0440 08108DE2 		add	r1, sp, #8
 767              	.LVL96:
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 768              		.loc 1 146 0
 769 0444 7070A0E3 		mov	r7, #112
 147:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 770              		.loc 1 147 0
 771 0448 5260A0E3 		mov	r6, #82
 148:../sensor.c   **** 	preamble.length = 3;
 772              		.loc 1 148 0
 773 044c 3050A0E3 		mov	r5, #48
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 774              		.loc 1 149 0
 775 0450 0340A0E3 		mov	r4, #3
 150:../sensor.c   **** 	buf[0] = RegAdd;
 776              		.loc 1 150 0
 777 0454 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 778              		.loc 1 146 0
 779 0458 1070CDE5 		strb	r7, [sp, #16]
 147:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 780              		.loc 1 147 0
 781 045c 1160CDE5 		strb	r6, [sp, #17]
 148:../sensor.c   **** 	preamble.length = 3;
 782              		.loc 1 148 0
 783 0460 1250CDE5 		strb	r5, [sp, #18]
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 784              		.loc 1 149 0
 785 0464 1840CDE5 		strb	r4, [sp, #24]
 151:../sensor.c   **** #ifdef DbgInfo
 786              		.loc 1 151 0
 787 0468 08E0CDE5 		strb	lr, [sp, #8]
 155:../sensor.c   **** 	/*** test I2C bus ready ****/
 788              		.loc 1 155 0
 789 046c FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 790              	.LVL97:
 157:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(T) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 791              		.loc 1 157 0
 792 0470 002050E2 		subs	r2, r0, #0
 793 0474 2100001A 		bne	.L62
 794              	.LVL98:
 795              	.LBB57:
 796              	.LBB58:
 797              	.LBB59:
  47:../sensor.c   **** 			CyU3PBusyWait(40000); // 40ms delay.
 798              		.loc 1 47 0
 799 0478 9C009FE5 		ldr	r0, .L64
 800              	.LVL99:
 801 047c FEFFFFEB 		bl	CyFx3BusyWait
 802              	.LVL100:
  48:../sensor.c   **** 		}
 803              		.loc 1 48 0
 804 0480 94009FE5 		ldr	r0, .L64
 805 0484 FEFFFFEB 		bl	CyFx3BusyWait
 806              	.LVL101:
 807              	.L56:
 808              	.LBE59:
 809              	.LBE58:
 810              	.LBE57:
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 811              		.loc 1 166 0
 812 0488 01E0A0E3 		mov	lr, #1
 167:../sensor.c   **** 
 813              		.loc 1 167 0
 814 048c 00C0A0E3 		mov	ip, #0
 169:../sensor.c   **** 	/*** test I2C bus ready ****/
 815              		.loc 1 169 0
 816 0490 0E20A0E1 		mov	r2, lr
 817 0494 10008DE2 		add	r0, sp, #16
 818 0498 08108DE2 		add	r1, sp, #8
 819              	.LVL102:
 820 049c 0C30A0E1 		mov	r3, ip
 165:../sensor.c   **** 	preamble.length = 1;
 821              		.loc 1 165 0
 822 04a0 7140A0E3 		mov	r4, #113
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 823              		.loc 1 166 0
 824 04a4 18E0CDE5 		strb	lr, [sp, #24]
 167:../sensor.c   **** 
 825              		.loc 1 167 0
 826 04a8 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
 165:../sensor.c   **** 	preamble.length = 1;
 827              		.loc 1 165 0
 828 04ac 1040CDE5 		strb	r4, [sp, #16]
 169:../sensor.c   **** 	/*** test I2C bus ready ****/
 829              		.loc 1 169 0
 830 04b0 FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 831              	.LVL103:
 171:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 832              		.loc 1 171 0
 833 04b4 002050E2 		subs	r2, r0, #0
 834 04b8 0900001A 		bne	.L63
 835              	.LVL104:
 836              	.LBB60:
 837              	.LBB61:
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 838              		.loc 1 51 0
 839 04bc 7D0EA0E3 		mov	r0, #2000
 840              	.LVL105:
 841 04c0 FEFFFFEB 		bl	CyFx3BusyWait
 842              	.LVL106:
 843              	.LBE61:
 844              	.LBE60:
 845              	.LBE62:
 846              	.LBE64:
 847              	.LBE66:
 848              	.LBE68:
 252:../sensor.c   **** 	if (SensorI2cBusTest() != CY_U3P_SUCCESS) /* Verify that the sensor is connected. */
 253:../sensor.c   **** 	{
 254:../sensor.c   **** 		CyU3PDebugPrint(4, "Error: Reading Sensor ID failed!\r\n");
 255:../sensor.c   **** 		return;
 256:../sensor.c   **** 	}
 257:../sensor.c   **** 
 258:../sensor.c   **** 	/* Generic settings (which are common for all resolutions) for bringing up the image sensor to str
 259:../sensor.c   **** 	 video data should be populated here.
 260:../sensor.c   **** 	 */
 261:../sensor.c   **** 
 262:../sensor.c   **** 	/* Update sensor configuration based on desired video stream parameters. Using 720p 30fps as defau
 263:../sensor.c   **** 	//SensorScaling_HD720p_30fps();
 264:../sensor.c   **** }
 265:../sensor.c   **** 
 266:../sensor.c   **** /*
 267:../sensor.c   ****    Verify that the sensor can be accessed over the I2C bus from FX3.
 268:../sensor.c   ****  */
 269:../sensor.c   **** uint8_t SensorI2cBusTest(void) {
 270:../sensor.c   **** 	/* The sensor ID register can be read here to verify sensor connectivity. */
 271:../sensor.c   **** 	uint8_t buf[2];
 272:../sensor.c   **** 
 273:../sensor.c   **** 	/* Reading sensor ID */
 274:../sensor.c   **** 	if (SensorRead2B(SENSOR_ADDR_RD, I2C_DSPBOARD_ADDR_WR, I2C_EAGLESDP_ADDR, 0xf2, 1, buf) == CY_U3P_
 275:../sensor.c   **** 		if ((buf[0] == 0x56) /*&& (buf[1] == 0x02)*/) {
 849              		.loc 1 275 0
 850 04c4 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 851 04c8 560053E3 		cmp	r3, #86
 852 04cc 0200000A 		beq	.L52
 853              	.LVL107:
 854              	.L55:
 855              	.LBE70:
 856              	.LBE72:
 254:../sensor.c   **** 		return;
 857              		.loc 1 254 0
 858 04d0 0400A0E3 		mov	r0, #4
 859 04d4 44109FE5 		ldr	r1, .L64+4
 860 04d8 FEFFFFEB 		bl	CyU3PDebugPrint
 861              	.LVL108:
 862              	.L52:
 264:../sensor.c   **** 
 863              		.loc 1 264 0
 864 04dc 24D08DE2 		add	sp, sp, #36
 865              		@ sp needed
 866 04e0 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 867              	.LVL109:
 868              	.L63:
 869              	.LBB73:
 870              	.LBB71:
 871              	.LBB69:
 872              	.LBB67:
 873              	.LBB65:
 874              	.LBB63:
 172:../sensor.c   **** 	}
 875              		.loc 1 172 0
 876 04e4 0910DDE5 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 877 04e8 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 878 04ec 00108DE5 		str	r1, [sp]
 879 04f0 0400A0E3 		mov	r0, #4
 880              	.LVL110:
 881 04f4 28109FE5 		ldr	r1, .L64+8
 882 04f8 FEFFFFEB 		bl	CyU3PDebugPrint
 883              	.LVL111:
 884 04fc F3FFFFEA 		b	.L55
 885              	.LVL112:
 886              	.L62:
 158:../sensor.c   **** 	}
 887              		.loc 1 158 0
 888 0500 0910DDE5 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 889 0504 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 890 0508 00108DE5 		str	r1, [sp]
 891 050c 0400A0E3 		mov	r0, #4
 892              	.LVL113:
 893 0510 10109FE5 		ldr	r1, .L64+12
 894 0514 FEFFFFEB 		bl	CyU3PDebugPrint
 895              	.LVL114:
 896 0518 DAFFFFEA 		b	.L56
 897              	.L65:
 898              		.align	2
 899              	.L64:
 900 051c 409C0000 		.word	40000
 901 0520 CC000000 		.word	.LC7
 902 0524 60000000 		.word	.LC3
 903 0528 44000000 		.word	.LC2
 904              	.LBE63:
 905              	.LBE65:
 906              	.LBE67:
 907              	.LBE69:
 908              	.LBE71:
 909              	.LBE73:
 910              		.cfi_endproc
 911              	.LFE6:
 913              		.align	2
 914              		.global	SensorI2cBusTest
 916              	SensorI2cBusTest:
 917              	.LFB7:
 269:../sensor.c   **** 	/* The sensor ID register can be read here to verify sensor connectivity. */
 918              		.loc 1 269 0
 919              		.cfi_startproc
 920              		@ args = 0, pretend = 0, frame = 24
 921              		@ frame_needed = 0, uses_anonymous_args = 0
 922              	.LVL115:
 923 052c F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 924              	.LCFI12:
 925              		.cfi_def_cfa_offset 20
 926              		.cfi_offset 4, -20
 927              		.cfi_offset 5, -16
 928              		.cfi_offset 6, -12
 929              		.cfi_offset 7, -8
 930              		.cfi_offset 14, -4
 931              	.LBB84:
 932              	.LBB85:
 933              	.LBB86:
 934              	.LBB87:
 150:../sensor.c   **** 	buf[0] = RegAdd;
 935              		.loc 1 150 0
 936 0530 00C0A0E3 		mov	ip, #0
 937              	.LBE87:
 938              	.LBE86:
 939              	.LBE85:
 940              	.LBE84:
 269:../sensor.c   **** 	/* The sensor ID register can be read here to verify sensor connectivity. */
 941              		.loc 1 269 0
 942 0534 24D04DE2 		sub	sp, sp, #36
 943              	.LCFI13:
 944              		.cfi_def_cfa_offset 56
 945              	.LVL116:
 946              	.LBB99:
 947              	.LBB97:
 948              	.LBB95:
 949              	.LBB93:
 151:../sensor.c   **** #ifdef DbgInfo
 950              		.loc 1 151 0
 951 0538 0DE0E0E3 		mvn	lr, #13
 155:../sensor.c   **** 	/*** test I2C bus ready ****/
 952              		.loc 1 155 0
 953 053c 0120A0E3 		mov	r2, #1
 954 0540 0C30A0E1 		mov	r3, ip
 955 0544 10008DE2 		add	r0, sp, #16
 956 0548 08108DE2 		add	r1, sp, #8
 957              	.LVL117:
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 958              		.loc 1 146 0
 959 054c 7070A0E3 		mov	r7, #112
 147:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 960              		.loc 1 147 0
 961 0550 5260A0E3 		mov	r6, #82
 148:../sensor.c   **** 	preamble.length = 3;
 962              		.loc 1 148 0
 963 0554 3050A0E3 		mov	r5, #48
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 964              		.loc 1 149 0
 965 0558 0340A0E3 		mov	r4, #3
 150:../sensor.c   **** 	buf[0] = RegAdd;
 966              		.loc 1 150 0
 967 055c BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 968              		.loc 1 146 0
 969 0560 1070CDE5 		strb	r7, [sp, #16]
 147:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 970              		.loc 1 147 0
 971 0564 1160CDE5 		strb	r6, [sp, #17]
 148:../sensor.c   **** 	preamble.length = 3;
 972              		.loc 1 148 0
 973 0568 1250CDE5 		strb	r5, [sp, #18]
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 974              		.loc 1 149 0
 975 056c 1840CDE5 		strb	r4, [sp, #24]
 151:../sensor.c   **** #ifdef DbgInfo
 976              		.loc 1 151 0
 977 0570 08E0CDE5 		strb	lr, [sp, #8]
 155:../sensor.c   **** 	/*** test I2C bus ready ****/
 978              		.loc 1 155 0
 979 0574 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 980              	.LVL118:
 157:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(T) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 981              		.loc 1 157 0
 982 0578 002050E2 		subs	r2, r0, #0
 983 057c 2000001A 		bne	.L74
 984              	.LVL119:
 985              	.LBB88:
 986              	.LBB89:
 987              	.LBB90:
  47:../sensor.c   **** 			CyU3PBusyWait(40000); // 40ms delay.
 988              		.loc 1 47 0
 989 0580 A0009FE5 		ldr	r0, .L77
 990              	.LVL120:
 991 0584 FEFFFFEB 		bl	CyFx3BusyWait
 992              	.LVL121:
  48:../sensor.c   **** 		}
 993              		.loc 1 48 0
 994 0588 98009FE5 		ldr	r0, .L77
 995 058c FEFFFFEB 		bl	CyFx3BusyWait
 996              	.LVL122:
 997              	.L69:
 998              	.LBE90:
 999              	.LBE89:
 1000              	.LBE88:
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1001              		.loc 1 166 0
 1002 0590 01E0A0E3 		mov	lr, #1
 167:../sensor.c   **** 
 1003              		.loc 1 167 0
 1004 0594 00C0A0E3 		mov	ip, #0
 165:../sensor.c   **** 	preamble.length = 1;
 1005              		.loc 1 165 0
 1006 0598 7140A0E3 		mov	r4, #113
 169:../sensor.c   **** 	/*** test I2C bus ready ****/
 1007              		.loc 1 169 0
 1008 059c 10008DE2 		add	r0, sp, #16
 1009 05a0 08108DE2 		add	r1, sp, #8
 1010              	.LVL123:
 1011 05a4 0E20A0E1 		mov	r2, lr
 1012 05a8 0C30A0E1 		mov	r3, ip
 165:../sensor.c   **** 	preamble.length = 1;
 1013              		.loc 1 165 0
 1014 05ac 1040CDE5 		strb	r4, [sp, #16]
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1015              		.loc 1 166 0
 1016 05b0 18E0CDE5 		strb	lr, [sp, #24]
 167:../sensor.c   **** 
 1017              		.loc 1 167 0
 1018 05b4 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
 169:../sensor.c   **** 	/*** test I2C bus ready ****/
 1019              		.loc 1 169 0
 1020 05b8 FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 1021              	.LVL124:
 171:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 1022              		.loc 1 171 0
 1023 05bc 004050E2 		subs	r4, r0, #0
 1024 05c0 0700001A 		bne	.L75
 1025              	.LVL125:
 1026              	.LBB91:
 1027              	.LBB92:
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 1028              		.loc 1 51 0
 1029 05c4 7D0EA0E3 		mov	r0, #2000
 1030              	.LVL126:
 1031 05c8 FEFFFFEB 		bl	CyFx3BusyWait
 1032              	.LVL127:
 1033              	.LBE92:
 1034              	.LBE91:
 1035              	.LBE93:
 1036              	.LBE95:
 1037              	.LBE97:
 1038              	.LBE99:
 1039              		.loc 1 275 0
 1040 05cc 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1041 05d0 560053E3 		cmp	r3, #86
 1042 05d4 1100000A 		beq	.L76
 1043              	.LVL128:
 1044              	.L71:
 276:../sensor.c   **** 			return CY_U3P_SUCCESS;
 277:../sensor.c   **** 		}
 278:../sensor.c   **** 	}
 279:../sensor.c   **** #ifdef USB_DEBUG_PRINT
 280:../sensor.c   **** 	CyU3PDebugPrint (4, "The Sensor test 0x%x 0x%x\r\n", buf[0], buf[1]); // additional debug
 281:../sensor.c   **** #endif
 282:../sensor.c   **** 	return 1;
 1045              		.loc 1 282 0
 1046 05d8 0100A0E3 		mov	r0, #1
 1047              	.L73:
 283:../sensor.c   **** }
 1048              		.loc 1 283 0
 1049 05dc 24D08DE2 		add	sp, sp, #36
 1050              		@ sp needed
 1051 05e0 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 1052              	.LVL129:
 1053              	.L75:
 1054              	.LBB100:
 1055              	.LBB98:
 1056              	.LBB96:
 1057              	.LBB94:
 172:../sensor.c   **** 	}
 1058              		.loc 1 172 0
 1059 05e4 0910DDE5 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 1060 05e8 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1061 05ec 00108DE5 		str	r1, [sp]
 1062 05f0 0420A0E1 		mov	r2, r4
 1063 05f4 30109FE5 		ldr	r1, .L77+4
 1064 05f8 0400A0E3 		mov	r0, #4
 1065              	.LVL130:
 1066 05fc FEFFFFEB 		bl	CyU3PDebugPrint
 1067              	.LVL131:
 1068 0600 F4FFFFEA 		b	.L71
 1069              	.LVL132:
 1070              	.L74:
 158:../sensor.c   **** 	}
 1071              		.loc 1 158 0
 1072 0604 0910DDE5 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 1073 0608 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1074 060c 00108DE5 		str	r1, [sp]
 1075 0610 0400A0E3 		mov	r0, #4
 1076              	.LVL133:
 1077 0614 14109FE5 		ldr	r1, .L77+8
 1078 0618 FEFFFFEB 		bl	CyU3PDebugPrint
 1079              	.LVL134:
 1080 061c DBFFFFEA 		b	.L69
 1081              	.LVL135:
 1082              	.L76:
 1083              	.LBE94:
 1084              	.LBE96:
 1085              	.LBE98:
 1086              	.LBE100:
 276:../sensor.c   **** 		}
 1087              		.loc 1 276 0
 1088 0620 0400A0E1 		mov	r0, r4
 1089 0624 ECFFFFEA 		b	.L73
 1090              	.L78:
 1091              		.align	2
 1092              	.L77:
 1093 0628 409C0000 		.word	40000
 1094 062c 60000000 		.word	.LC3
 1095 0630 44000000 		.word	.LC2
 1096              		.cfi_endproc
 1097              	.LFE7:
 1099              		.align	2
 1100              		.global	SensorGetControl
 1102              	SensorGetControl:
 1103              	.LFB8:
 284:../sensor.c   **** 
 285:../sensor.c   **** /*************************************************************
 286:../sensor.c   ****  *  the modularized control get routine. IDext is the control ID.
 287:../sensor.c   ****  *
 288:../sensor.c   ****  * ********************************************************* */
 289:../sensor.c   **** 
 290:../sensor.c   **** uint8_t SensorGetControl(uint8_t IDext, uint8_t devAdd)  //for register w/r, the IDext is Reg. addr
 291:../sensor.c   **** {
 1104              		.loc 1 291 0
 1105              		.cfi_startproc
 1106              		@ args = 0, pretend = 0, frame = 24
 1107              		@ frame_needed = 0, uses_anonymous_args = 0
 1108              	.LVL136:
 1109 0634 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1110              	.LCFI14:
 1111              		.cfi_def_cfa_offset 16
 1112              		.cfi_offset 4, -16
 1113              		.cfi_offset 5, -12
 1114              		.cfi_offset 6, -8
 1115              		.cfi_offset 14, -4
 1116              	.LBB111:
 1117              	.LBB112:
 1118              	.LBB113:
 1119              	.LBB114:
 150:../sensor.c   **** 	buf[0] = RegAdd;
 1120              		.loc 1 150 0
 1121 0638 00C0A0E3 		mov	ip, #0
 1122              	.LBE114:
 1123              	.LBE113:
 1124              	.LBE112:
 1125              	.LBE111:
 1126              		.loc 1 291 0
 1127 063c 20D04DE2 		sub	sp, sp, #32
 1128              	.LCFI15:
 1129              		.cfi_def_cfa_offset 48
 1130              		.loc 1 291 0
 1131 0640 0040A0E1 		mov	r4, r0
 1132              	.LVL137:
 1133              	.LBB126:
 1134              	.LBB124:
 1135              	.LBB122:
 1136              	.LBB120:
 148:../sensor.c   **** 	preamble.length = 3;
 1137              		.loc 1 148 0
 1138 0644 1210CDE5 		strb	r1, [sp, #18]
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 1139              		.loc 1 149 0
 1140 0648 03E0A0E3 		mov	lr, #3
 155:../sensor.c   **** 	/*** test I2C bus ready ****/
 1141              		.loc 1 155 0
 1142 064c 0120A0E3 		mov	r2, #1
 1143 0650 0C30A0E1 		mov	r3, ip
 1144 0654 10008DE2 		add	r0, sp, #16
 1145              	.LVL138:
 1146 0658 08108DE2 		add	r1, sp, #8
 1147              	.LVL139:
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 1148              		.loc 1 146 0
 1149 065c 7060A0E3 		mov	r6, #112
 147:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 1150              		.loc 1 147 0
 1151 0660 5350A0E3 		mov	r5, #83
 151:../sensor.c   **** #ifdef DbgInfo
 1152              		.loc 1 151 0
 1153 0664 0840CDE5 		strb	r4, [sp, #8]
 150:../sensor.c   **** 	buf[0] = RegAdd;
 1154              		.loc 1 150 0
 1155 0668 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 1156              		.loc 1 146 0
 1157 066c 1060CDE5 		strb	r6, [sp, #16]
 147:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 1158              		.loc 1 147 0
 1159 0670 1150CDE5 		strb	r5, [sp, #17]
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 1160              		.loc 1 149 0
 1161 0674 18E0CDE5 		strb	lr, [sp, #24]
 155:../sensor.c   **** 	/*** test I2C bus ready ****/
 1162              		.loc 1 155 0
 1163 0678 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1164              	.LVL140:
 157:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(T) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 1165              		.loc 1 157 0
 1166 067c 002050E2 		subs	r2, r0, #0
 1167 0680 2100001A 		bne	.L85
 1168              	.LVL141:
 1169              	.LBB115:
 1170              	.LBB116:
 1171              	.LBB117:
  47:../sensor.c   **** 			CyU3PBusyWait(40000); // 40ms delay.
 1172              		.loc 1 47 0
 1173 0684 9C009FE5 		ldr	r0, .L87
 1174              	.LVL142:
 1175 0688 FEFFFFEB 		bl	CyFx3BusyWait
 1176              	.LVL143:
  48:../sensor.c   **** 		}
 1177              		.loc 1 48 0
 1178 068c 94009FE5 		ldr	r0, .L87
 1179 0690 FEFFFFEB 		bl	CyFx3BusyWait
 1180              	.LVL144:
 1181              	.L82:
 1182              	.LBE117:
 1183              	.LBE116:
 1184              	.LBE115:
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1185              		.loc 1 166 0
 1186 0694 01E0A0E3 		mov	lr, #1
 167:../sensor.c   **** 
 1187              		.loc 1 167 0
 1188 0698 00C0A0E3 		mov	ip, #0
 169:../sensor.c   **** 	/*** test I2C bus ready ****/
 1189              		.loc 1 169 0
 1190 069c 0E20A0E1 		mov	r2, lr
 1191 06a0 10008DE2 		add	r0, sp, #16
 1192 06a4 08108DE2 		add	r1, sp, #8
 1193              	.LVL145:
 1194 06a8 0C30A0E1 		mov	r3, ip
 165:../sensor.c   **** 	preamble.length = 1;
 1195              		.loc 1 165 0
 1196 06ac 7150A0E3 		mov	r5, #113
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1197              		.loc 1 166 0
 1198 06b0 18E0CDE5 		strb	lr, [sp, #24]
 167:../sensor.c   **** 
 1199              		.loc 1 167 0
 1200 06b4 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
 165:../sensor.c   **** 	preamble.length = 1;
 1201              		.loc 1 165 0
 1202 06b8 1050CDE5 		strb	r5, [sp, #16]
 169:../sensor.c   **** 	/*** test I2C bus ready ****/
 1203              		.loc 1 169 0
 1204 06bc FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 1205              	.LVL146:
 171:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 1206              		.loc 1 171 0
 1207 06c0 002050E2 		subs	r2, r0, #0
 1208 06c4 0900001A 		bne	.L86
 1209              	.LVL147:
 1210              	.LBB118:
 1211              	.LBB119:
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 1212              		.loc 1 51 0
 1213 06c8 7D0EA0E3 		mov	r0, #2000
 1214              	.LVL148:
 1215 06cc FEFFFFEB 		bl	CyFx3BusyWait
 1216              	.LVL149:
 1217              	.L83:
 1218              	.LBE119:
 1219              	.LBE118:
 1220              	.LBE120:
 1221              	.LBE122:
 1222              	.LBE124:
 1223              	.LBE126:
 292:../sensor.c   **** 	uint8_t buf[2];
 293:../sensor.c   **** 	SensorRead2B(SENSOR_ADDR_RD, I2C_DSPBOARD_ADDR_RD, devAdd, IDext, 1, buf);
 294:../sensor.c   **** //#ifdef USB_DEBUG_PRINT
 295:../sensor.c   **** 	CyU3PDebugPrint (4, "The Get control ID 0x%x %d\r\n", IDext, buf[0]); // additional debug
 1224              		.loc 1 295 0
 1225 06d0 0420A0E1 		mov	r2, r4
 1226 06d4 50109FE5 		ldr	r1, .L87+4
 1227 06d8 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1228 06dc 0400A0E3 		mov	r0, #4
 1229 06e0 FEFFFFEB 		bl	CyU3PDebugPrint
 1230              	.LVL150:
 296:../sensor.c   **** //#endif
 297:../sensor.c   **** 	return buf[0];
 1231              		.loc 1 297 0
 1232 06e4 0800DDE5 		ldrb	r0, [sp, #8]	@ zero_extendqisi2
 298:../sensor.c   **** };
 1233              		.loc 1 298 0
 1234 06e8 20D08DE2 		add	sp, sp, #32
 1235              		@ sp needed
 1236 06ec 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1237              	.LVL151:
 1238              	.L86:
 1239              	.LBB127:
 1240              	.LBB125:
 1241              	.LBB123:
 1242              	.LBB121:
 172:../sensor.c   **** 	}
 1243              		.loc 1 172 0
 1244 06f0 0910DDE5 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 1245 06f4 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1246 06f8 00108DE5 		str	r1, [sp]
 1247 06fc 0400A0E3 		mov	r0, #4
 1248              	.LVL152:
 1249 0700 28109FE5 		ldr	r1, .L87+8
 1250 0704 FEFFFFEB 		bl	CyU3PDebugPrint
 1251              	.LVL153:
 1252 0708 F0FFFFEA 		b	.L83
 1253              	.LVL154:
 1254              	.L85:
 158:../sensor.c   **** 	}
 1255              		.loc 1 158 0
 1256 070c 0910DDE5 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 1257 0710 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1258 0714 00108DE5 		str	r1, [sp]
 1259 0718 0400A0E3 		mov	r0, #4
 1260              	.LVL155:
 1261 071c 10109FE5 		ldr	r1, .L87+12
 1262 0720 FEFFFFEB 		bl	CyU3PDebugPrint
 1263              	.LVL156:
 1264 0724 DAFFFFEA 		b	.L82
 1265              	.L88:
 1266              		.align	2
 1267              	.L87:
 1268 0728 409C0000 		.word	40000
 1269 072c F0000000 		.word	.LC8
 1270 0730 60000000 		.word	.LC3
 1271 0734 44000000 		.word	.LC2
 1272              	.LBE121:
 1273              	.LBE123:
 1274              	.LBE125:
 1275              	.LBE127:
 1276              		.cfi_endproc
 1277              	.LFE8:
 1279              		.align	2
 1280              		.global	SensorSetControl
 1282              	SensorSetControl:
 1283              	.LFB9:
 299:../sensor.c   **** 
 300:../sensor.c   **** /* *********************************************************
 301:../sensor.c   ****  * the modularized control Set routine. IDuvc: the control ID;
 302:../sensor.c   ****  * value: set value, range check.
 303:../sensor.c   ****  *
 304:../sensor.c   ****  ************************************************************ */
 305:../sensor.c   **** 
 306:../sensor.c   **** uint8_t SensorSetControl(uint8_t IDext, uint8_t devAdd, uint8_t value) //for register w/r, the IDex
 307:../sensor.c   **** {
 1284              		.loc 1 307 0
 1285              		.cfi_startproc
 1286              		@ args = 0, pretend = 0, frame = 32
 1287              		@ frame_needed = 0, uses_anonymous_args = 0
 1288              	.LVL157:
 1289 0738 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 1290              	.LCFI16:
 1291              		.cfi_def_cfa_offset 20
 1292              		.cfi_offset 4, -20
 1293              		.cfi_offset 5, -16
 1294              		.cfi_offset 6, -12
 1295              		.cfi_offset 7, -8
 1296              		.cfi_offset 14, -4
 1297              	.LBB136:
 1298              	.LBB137:
  80:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 1299              		.loc 1 80 0
 1300 073c 00C0A0E3 		mov	ip, #0
 1301              	.LBE137:
 1302              	.LBE136:
 1303              		.loc 1 307 0
 1304 0740 24D04DE2 		sub	sp, sp, #36
 1305              	.LCFI17:
 1306              		.cfi_def_cfa_offset 56
 1307              		.loc 1 307 0
 1308 0744 0050A0E1 		mov	r5, r0
 1309 0748 0240A0E1 		mov	r4, r2
 1310              	.LBB144:
 1311              	.LBB142:
  79:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1312              		.loc 1 79 0
 1313 074c 1210CDE5 		strb	r1, [sp, #18]
  81:../sensor.c   **** 	inbuf[0] = lowAddr;
 1314              		.loc 1 81 0
 1315 0750 03E0A0E3 		mov	lr, #3
  84:../sensor.c   **** #ifdef DbgInfo
 1316              		.loc 1 84 0
 1317 0754 0C30A0E1 		mov	r3, ip
 1318 0758 10008DE2 		add	r0, sp, #16
 1319              	.LVL158:
  77:../sensor.c   **** 	preamble.buffer[1] = boradAddr;
 1320              		.loc 1 77 0
 1321 075c 7070A0E3 		mov	r7, #112
  78:../sensor.c   **** 	preamble.buffer[2] = highAddr;
 1322              		.loc 1 78 0
 1323 0760 5260A0E3 		mov	r6, #82
  84:../sensor.c   **** #ifdef DbgInfo
 1324              		.loc 1 84 0
 1325 0764 08108DE2 		add	r1, sp, #8
 1326              	.LVL159:
 1327 0768 0120A0E3 		mov	r2, #1
 1328              	.LVL160:
  82:../sensor.c   **** 
 1329              		.loc 1 82 0
 1330 076c 0850CDE5 		strb	r5, [sp, #8]
 1331              	.LBE142:
 1332              	.LBE144:
 308:../sensor.c   **** 	uint8_t buf[2];
 309:../sensor.c   **** 	buf[0] = value;
 1333              		.loc 1 309 0
 1334 0770 0040CDE5 		strb	r4, [sp]
 1335              	.LVL161:
 1336              	.LBB145:
 1337              	.LBB143:
  80:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 1338              		.loc 1 80 0
 1339 0774 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
  77:../sensor.c   **** 	preamble.buffer[1] = boradAddr;
 1340              		.loc 1 77 0
 1341 0778 1070CDE5 		strb	r7, [sp, #16]
  78:../sensor.c   **** 	preamble.buffer[2] = highAddr;
 1342              		.loc 1 78 0
 1343 077c 1160CDE5 		strb	r6, [sp, #17]
  81:../sensor.c   **** 	inbuf[0] = lowAddr;
 1344              		.loc 1 81 0
 1345 0780 18E0CDE5 		strb	lr, [sp, #24]
  84:../sensor.c   **** #ifdef DbgInfo
 1346              		.loc 1 84 0
 1347 0784 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1348              	.LVL162:
 1349              	.LBB138:
 1350              	.LBB139:
  44:../sensor.c   **** 	{
 1351              		.loc 1 44 0
 1352 0788 000050E3 		cmp	r0, #0
 1353 078c 0100001A 		bne	.L90
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 1354              		.loc 1 51 0
 1355 0790 7D0EA0E3 		mov	r0, #2000
 1356              	.LVL163:
 1357 0794 FEFFFFEB 		bl	CyFx3BusyWait
 1358              	.LVL164:
 1359              	.L90:
 1360              	.LBE139:
 1361              	.LBE138:
  91:../sensor.c   **** 	preamble.length = 1;
 1362              		.loc 1 91 0
 1363 0798 00E0A0E3 		mov	lr, #0
  92:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, numData, 0);
 1364              		.loc 1 92 0
 1365 079c 01C0A0E3 		mov	ip, #1
  93:../sensor.c   **** #ifdef DbgInfo
 1366              		.loc 1 93 0
 1367 07a0 10008DE2 		add	r0, sp, #16
 1368 07a4 0E30A0E1 		mov	r3, lr
 1369 07a8 0C20A0E1 		mov	r2, ip
 1370 07ac 0D10A0E1 		mov	r1, sp
  91:../sensor.c   **** 	preamble.length = 1;
 1371              		.loc 1 91 0
 1372 07b0 BAE1CDE1 		strh	lr, [sp, #26]	@ movhi
  92:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, numData, 0);
 1373              		.loc 1 92 0
 1374 07b4 18C0CDE5 		strb	ip, [sp, #24]
  93:../sensor.c   **** #ifdef DbgInfo
 1375              		.loc 1 93 0
 1376 07b8 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1377              	.LVL165:
 1378              	.LBB140:
 1379              	.LBB141:
  44:../sensor.c   **** 	{
 1380              		.loc 1 44 0
 1381 07bc 000050E3 		cmp	r0, #0
 1382 07c0 0100001A 		bne	.L91
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 1383              		.loc 1 51 0
 1384 07c4 7D0EA0E3 		mov	r0, #2000
 1385              	.LVL166:
 1386 07c8 FEFFFFEB 		bl	CyFx3BusyWait
 1387              	.LVL167:
 1388              	.L91:
 1389              	.LBE141:
 1390              	.LBE140:
 1391              	.LBE143:
 1392              	.LBE145:
 310:../sensor.c   **** 	SensorWrite2B(SENSOR_ADDR_WR, I2C_DSPBOARD_ADDR_WR, devAdd, IDext, 1, buf);
 311:../sensor.c   **** //#ifdef USB_DEBUG_PRINT
 312:../sensor.c   **** 	CyU3PDebugPrint (4, "The Set control regAdd 0x%x 0x%x\r\n", IDext, value); // additional debug
 1393              		.loc 1 312 0
 1394 07cc 0520A0E1 		mov	r2, r5
 1395 07d0 0430A0E1 		mov	r3, r4
 1396 07d4 10109FE5 		ldr	r1, .L92
 1397 07d8 0400A0E3 		mov	r0, #4
 1398 07dc FEFFFFEB 		bl	CyU3PDebugPrint
 1399              	.LVL168:
 313:../sensor.c   **** //#endif
 314:../sensor.c   **** 	return 0;
 315:../sensor.c   **** };
 1400              		.loc 1 315 0
 1401 07e0 0000A0E3 		mov	r0, #0
 1402 07e4 24D08DE2 		add	sp, sp, #36
 1403              	.LVL169:
 1404              		@ sp needed
 1405 07e8 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 1406              	.LVL170:
 1407              	.L93:
 1408              		.align	2
 1409              	.L92:
 1410 07ec 10010000 		.word	.LC9
 1411              		.cfi_endproc
 1412              	.LFE9:
 1414              		.align	2
 1415              		.global	SensorGetIrisControl
 1417              	SensorGetIrisControl:
 1418              	.LFB10:
 316:../sensor.c   **** /*************************************************************
 317:../sensor.c   ****  *  the Iris control get routine. IDext is the control ID, boardID: the Iris control board address.
 318:../sensor.c   ****  *
 319:../sensor.c   ****  * ********************************************************* */
 320:../sensor.c   **** 
 321:../sensor.c   **** uint8_t SensorGetIrisControl(uint8_t IDext, uint8_t devAdd, uint8_t boardID)  //for register w/r, t
 322:../sensor.c   **** {
 1419              		.loc 1 322 0
 1420              		.cfi_startproc
 1421              		@ args = 0, pretend = 0, frame = 24
 1422              		@ frame_needed = 0, uses_anonymous_args = 0
 1423              	.LVL171:
 1424 07f0 10402DE9 		stmfd	sp!, {r4, lr}
 1425              	.LCFI18:
 1426              		.cfi_def_cfa_offset 8
 1427              		.cfi_offset 4, -8
 1428              		.cfi_offset 14, -4
 1429              	.LBB156:
 1430              	.LBB157:
 1431              	.LBB158:
 1432              	.LBB159:
 150:../sensor.c   **** 	buf[0] = RegAdd;
 1433              		.loc 1 150 0
 1434 07f4 00C0A0E3 		mov	ip, #0
 1435              	.LBE159:
 1436              	.LBE158:
 1437              	.LBE157:
 1438              	.LBE156:
 1439              		.loc 1 322 0
 1440 07f8 20D04DE2 		sub	sp, sp, #32
 1441              	.LCFI19:
 1442              		.cfi_def_cfa_offset 40
 1443              	.LVL172:
 1444              	.LBB174:
 1445              	.LBB171:
 1446              	.LBB168:
 1447              	.LBB165:
 147:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 1448              		.loc 1 147 0
 1449 07fc 1120CDE5 		strb	r2, [sp, #17]
 148:../sensor.c   **** 	preamble.length = 3;
 1450              		.loc 1 148 0
 1451 0800 1210CDE5 		strb	r1, [sp, #18]
 151:../sensor.c   **** #ifdef DbgInfo
 1452              		.loc 1 151 0
 1453 0804 0800CDE5 		strb	r0, [sp, #8]
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 1454              		.loc 1 149 0
 1455 0808 03E0A0E3 		mov	lr, #3
 155:../sensor.c   **** 	/*** test I2C bus ready ****/
 1456              		.loc 1 155 0
 1457 080c 0120A0E3 		mov	r2, #1
 1458              	.LVL173:
 1459 0810 0C30A0E1 		mov	r3, ip
 1460 0814 10008DE2 		add	r0, sp, #16
 1461              	.LVL174:
 1462 0818 08108DE2 		add	r1, sp, #8
 1463              	.LVL175:
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 1464              		.loc 1 146 0
 1465 081c 7040A0E3 		mov	r4, #112
 150:../sensor.c   **** 	buf[0] = RegAdd;
 1466              		.loc 1 150 0
 1467 0820 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
 146:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 1468              		.loc 1 146 0
 1469 0824 1040CDE5 		strb	r4, [sp, #16]
 149:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 1470              		.loc 1 149 0
 1471 0828 18E0CDE5 		strb	lr, [sp, #24]
 155:../sensor.c   **** 	/*** test I2C bus ready ****/
 1472              		.loc 1 155 0
 1473 082c FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1474              	.LVL176:
 157:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(T) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 1475              		.loc 1 157 0
 1476 0830 002050E2 		subs	r2, r0, #0
 1477 0834 1E00001A 		bne	.L100
 1478              	.LVL177:
 1479              	.LBB160:
 1480              	.LBB161:
 1481              	.LBB162:
  47:../sensor.c   **** 			CyU3PBusyWait(40000); // 40ms delay.
 1482              		.loc 1 47 0
 1483 0838 90009FE5 		ldr	r0, .L102
 1484              	.LVL178:
 1485 083c FEFFFFEB 		bl	CyFx3BusyWait
 1486              	.LVL179:
  48:../sensor.c   **** 		}
 1487              		.loc 1 48 0
 1488 0840 88009FE5 		ldr	r0, .L102
 1489 0844 FEFFFFEB 		bl	CyFx3BusyWait
 1490              	.LVL180:
 1491              	.L97:
 1492              	.LBE162:
 1493              	.LBE161:
 1494              	.LBE160:
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1495              		.loc 1 166 0
 1496 0848 01E0A0E3 		mov	lr, #1
 167:../sensor.c   **** 
 1497              		.loc 1 167 0
 1498 084c 00C0A0E3 		mov	ip, #0
 169:../sensor.c   **** 	/*** test I2C bus ready ****/
 1499              		.loc 1 169 0
 1500 0850 0E20A0E1 		mov	r2, lr
 1501 0854 10008DE2 		add	r0, sp, #16
 1502 0858 08108DE2 		add	r1, sp, #8
 1503              	.LVL181:
 1504 085c 0C30A0E1 		mov	r3, ip
 165:../sensor.c   **** 	preamble.length = 1;
 1505              		.loc 1 165 0
 1506 0860 7140A0E3 		mov	r4, #113
 166:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1507              		.loc 1 166 0
 1508 0864 18E0CDE5 		strb	lr, [sp, #24]
 167:../sensor.c   **** 
 1509              		.loc 1 167 0
 1510 0868 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
 165:../sensor.c   **** 	preamble.length = 1;
 1511              		.loc 1 165 0
 1512 086c 1040CDE5 		strb	r4, [sp, #16]
 169:../sensor.c   **** 	/*** test I2C bus ready ****/
 1513              		.loc 1 169 0
 1514 0870 FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 1515              	.LVL182:
 171:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 1516              		.loc 1 171 0
 1517 0874 002050E2 		subs	r2, r0, #0
 1518 0878 0400001A 		bne	.L101
 1519              	.LVL183:
 1520              	.LBB163:
 1521              	.LBB164:
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 1522              		.loc 1 51 0
 1523 087c 7D0EA0E3 		mov	r0, #2000
 1524              	.LVL184:
 1525 0880 FEFFFFEB 		bl	CyFx3BusyWait
 1526              	.LVL185:
 1527              	.LBE164:
 1528              	.LBE163:
 1529              	.LBE165:
 1530              	.LBE168:
 1531              	.LBE171:
 1532              	.LBE174:
 323:../sensor.c   **** 	uint8_t buf[2];
 324:../sensor.c   **** 	SensorRead2B(SENSOR_ADDR_RD, boardID, devAdd, IDext, 1, buf);
 325:../sensor.c   **** #ifdef USB_DEBUG_PRINT
 326:../sensor.c   **** 	CyU3PDebugPrint (4, "The Get control ID 0x%x 0x%x %d\r\n", boardID, IDext, buf[0]); // additional 
 327:../sensor.c   **** #endif
 328:../sensor.c   **** 	return buf[0];
 1533              		.loc 1 328 0
 1534 0884 0800DDE5 		ldrb	r0, [sp, #8]	@ zero_extendqisi2
 329:../sensor.c   **** };
 1535              		.loc 1 329 0
 1536 0888 20D08DE2 		add	sp, sp, #32
 1537              		@ sp needed
 1538 088c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1539              	.LVL186:
 1540              	.L101:
 1541              	.LBB175:
 1542              	.LBB172:
 1543              	.LBB169:
 1544              	.LBB166:
 172:../sensor.c   **** 	}
 1545              		.loc 1 172 0
 1546 0890 0910DDE5 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 1547 0894 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1548 0898 00108DE5 		str	r1, [sp]
 1549 089c 0400A0E3 		mov	r0, #4
 1550              	.LVL187:
 1551 08a0 2C109FE5 		ldr	r1, .L102+4
 1552 08a4 FEFFFFEB 		bl	CyU3PDebugPrint
 1553              	.LVL188:
 1554              	.LBE166:
 1555              	.LBE169:
 1556              	.LBE172:
 1557              	.LBE175:
 328:../sensor.c   **** };
 1558              		.loc 1 328 0
 1559 08a8 0800DDE5 		ldrb	r0, [sp, #8]	@ zero_extendqisi2
 1560              		.loc 1 329 0
 1561 08ac 20D08DE2 		add	sp, sp, #32
 1562              		@ sp needed
 1563 08b0 1080BDE8 		ldmfd	sp!, {r4, pc}
 1564              	.LVL189:
 1565              	.L100:
 1566              	.LBB176:
 1567              	.LBB173:
 1568              	.LBB170:
 1569              	.LBB167:
 158:../sensor.c   **** 	}
 1570              		.loc 1 158 0
 1571 08b4 0910DDE5 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 1572 08b8 0830DDE5 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1573 08bc 00108DE5 		str	r1, [sp]
 1574 08c0 0400A0E3 		mov	r0, #4
 1575              	.LVL190:
 1576 08c4 0C109FE5 		ldr	r1, .L102+8
 1577 08c8 FEFFFFEB 		bl	CyU3PDebugPrint
 1578              	.LVL191:
 1579 08cc DDFFFFEA 		b	.L97
 1580              	.L103:
 1581              		.align	2
 1582              	.L102:
 1583 08d0 409C0000 		.word	40000
 1584 08d4 60000000 		.word	.LC3
 1585 08d8 44000000 		.word	.LC2
 1586              	.LBE167:
 1587              	.LBE170:
 1588              	.LBE173:
 1589              	.LBE176:
 1590              		.cfi_endproc
 1591              	.LFE10:
 1593              		.align	2
 1594              		.global	SensorSetIrisControl
 1596              	SensorSetIrisControl:
 1597              	.LFB11:
 330:../sensor.c   **** 
 331:../sensor.c   **** /* *********************************************************
 332:../sensor.c   ****  * the Iris control Set routine. IDuvc: the control ID, boardID: the Iris control board address;
 333:../sensor.c   ****  * value: set value, range check.
 334:../sensor.c   ****  *
 335:../sensor.c   ****  ************************************************************ */
 336:../sensor.c   **** 
 337:../sensor.c   **** uint8_t SensorSetIrisControl(uint8_t IDext, uint8_t devAdd, uint8_t value, uint8_t boardID) //for r
 338:../sensor.c   **** {
 1598              		.loc 1 338 0
 1599              		.cfi_startproc
 1600              		@ args = 0, pretend = 0, frame = 32
 1601              		@ frame_needed = 0, uses_anonymous_args = 0
 1602              	.LVL192:
 1603 08dc 10402DE9 		stmfd	sp!, {r4, lr}
 1604              	.LCFI20:
 1605              		.cfi_def_cfa_offset 8
 1606              		.cfi_offset 4, -8
 1607              		.cfi_offset 14, -4
 1608              	.LBB185:
 1609              	.LBB186:
  80:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 1610              		.loc 1 80 0
 1611 08e0 00C0A0E3 		mov	ip, #0
 1612              	.LBE186:
 1613              	.LBE185:
 1614              		.loc 1 338 0
 1615 08e4 20D04DE2 		sub	sp, sp, #32
 1616              	.LCFI21:
 1617              		.cfi_def_cfa_offset 40
 339:../sensor.c   **** 	uint8_t buf[2];
 340:../sensor.c   **** 	buf[0] = value;
 1618              		.loc 1 340 0
 1619 08e8 0020CDE5 		strb	r2, [sp]
 1620              	.LVL193:
 1621              	.LBB192:
 1622              	.LBB191:
  78:../sensor.c   **** 	preamble.buffer[2] = highAddr;
 1623              		.loc 1 78 0
 1624 08ec 1130CDE5 		strb	r3, [sp, #17]
  79:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1625              		.loc 1 79 0
 1626 08f0 1210CDE5 		strb	r1, [sp, #18]
  82:../sensor.c   **** 
 1627              		.loc 1 82 0
 1628 08f4 0800CDE5 		strb	r0, [sp, #8]
  81:../sensor.c   **** 	inbuf[0] = lowAddr;
 1629              		.loc 1 81 0
 1630 08f8 03E0A0E3 		mov	lr, #3
  84:../sensor.c   **** #ifdef DbgInfo
 1631              		.loc 1 84 0
 1632 08fc 0C30A0E1 		mov	r3, ip
 1633              	.LVL194:
 1634 0900 10008DE2 		add	r0, sp, #16
 1635              	.LVL195:
  77:../sensor.c   **** 	preamble.buffer[1] = boradAddr;
 1636              		.loc 1 77 0
 1637 0904 7040A0E3 		mov	r4, #112
  84:../sensor.c   **** #ifdef DbgInfo
 1638              		.loc 1 84 0
 1639 0908 08108DE2 		add	r1, sp, #8
 1640              	.LVL196:
 1641 090c 0120A0E3 		mov	r2, #1
 1642              	.LVL197:
  80:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 1643              		.loc 1 80 0
 1644 0910 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
  77:../sensor.c   **** 	preamble.buffer[1] = boradAddr;
 1645              		.loc 1 77 0
 1646 0914 1040CDE5 		strb	r4, [sp, #16]
  81:../sensor.c   **** 	inbuf[0] = lowAddr;
 1647              		.loc 1 81 0
 1648 0918 18E0CDE5 		strb	lr, [sp, #24]
  84:../sensor.c   **** #ifdef DbgInfo
 1649              		.loc 1 84 0
 1650 091c FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1651              	.LVL198:
 1652              	.LBB187:
 1653              	.LBB188:
  44:../sensor.c   **** 	{
 1654              		.loc 1 44 0
 1655 0920 000050E3 		cmp	r0, #0
 1656 0924 0100001A 		bne	.L105
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 1657              		.loc 1 51 0
 1658 0928 7D0EA0E3 		mov	r0, #2000
 1659              	.LVL199:
 1660 092c FEFFFFEB 		bl	CyFx3BusyWait
 1661              	.LVL200:
 1662              	.L105:
 1663              	.LBE188:
 1664              	.LBE187:
  91:../sensor.c   **** 	preamble.length = 1;
 1665              		.loc 1 91 0
 1666 0930 00E0A0E3 		mov	lr, #0
  92:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, numData, 0);
 1667              		.loc 1 92 0
 1668 0934 01C0A0E3 		mov	ip, #1
  93:../sensor.c   **** #ifdef DbgInfo
 1669              		.loc 1 93 0
 1670 0938 10008DE2 		add	r0, sp, #16
 1671 093c 0E30A0E1 		mov	r3, lr
 1672 0940 0C20A0E1 		mov	r2, ip
 1673 0944 0D10A0E1 		mov	r1, sp
  91:../sensor.c   **** 	preamble.length = 1;
 1674              		.loc 1 91 0
 1675 0948 BAE1CDE1 		strh	lr, [sp, #26]	@ movhi
  92:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, numData, 0);
 1676              		.loc 1 92 0
 1677 094c 18C0CDE5 		strb	ip, [sp, #24]
  93:../sensor.c   **** #ifdef DbgInfo
 1678              		.loc 1 93 0
 1679 0950 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1680              	.LVL201:
 1681              	.LBB189:
 1682              	.LBB190:
  44:../sensor.c   **** 	{
 1683              		.loc 1 44 0
 1684 0954 000050E3 		cmp	r0, #0
 1685 0958 0100001A 		bne	.L106
  51:../sensor.c   **** 	}else //if I2C operation is not success reconfig the I2C
 1686              		.loc 1 51 0
 1687 095c 7D0EA0E3 		mov	r0, #2000
 1688              	.LVL202:
 1689 0960 FEFFFFEB 		bl	CyFx3BusyWait
 1690              	.LVL203:
 1691              	.L106:
 1692              	.LBE190:
 1693              	.LBE189:
 1694              	.LBE191:
 1695              	.LBE192:
 341:../sensor.c   **** 	SensorWrite2B(SENSOR_ADDR_WR, boardID, devAdd, IDext, 1, buf);
 342:../sensor.c   **** #ifdef USB_DEBUG_PRINT
 343:../sensor.c   **** 	CyU3PDebugPrint (4, "The Set control ID 0x%x 0x%x 0x%x\r\n", boardID, IDext, value); // additional
 344:../sensor.c   **** #endif
 345:../sensor.c   **** 	return 0;
 346:../sensor.c   **** };
 1696              		.loc 1 346 0
 1697 0964 0000A0E3 		mov	r0, #0
 1698 0968 20D08DE2 		add	sp, sp, #32
 1699              	.LVL204:
 1700              		@ sp needed
 1701 096c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1702              		.cfi_endproc
 1703              	.LFE11:
 1705              		.section	.rodata.str1.4,"aMS",%progbits,1
 1706              		.align	2
 1707              	.LC0:
 1708 0000 49324320 		.ascii	"I2C Slave address is not valid!\012\000"
 1708      536C6176 
 1708      65206164 
 1708      64726573 
 1708      73206973 
 1709 0021 000000   		.space	3
 1710              	.LC1:
 1711 0024 4552524F 		.ascii	"ERROR: SensorWrite count > 64\012\000"
 1711      523A2053 
 1711      656E736F 
 1711      72577269 
 1711      74652063 
 1712 0043 00       		.space	1
 1713              	.LC2:
 1714 0044 73656E73 		.ascii	"sensor read2B(T) %d %d %d\015\012\000"
 1714      6F722072 
 1714      65616432 
 1714      42285429 
 1714      20256420 
 1715              	.LC3:
 1716 0060 73656E73 		.ascii	"sensor read2B(R) %d %d %d\015\012\000"
 1716      6F722072 
 1716      65616432 
 1716      42285229 
 1716      20256420 
 1717              	.LC4:
 1718 007c 4750494F 		.ascii	"GPIO Set Value Error, Error Code = %d\012\000"
 1718      20536574 
 1718      2056616C 
 1718      75652045 
 1718      72726F72 
 1719 00a3 00       		.space	1
 1720              	.LC5:
 1721 00a4 4750494F 		.ascii	"GPIO Set Value\015\012\000"
 1721      20536574 
 1721      2056616C 
 1721      75650D0A 
 1721      00
 1722 00b5 000000   		.space	3
 1723              	.LC6:
 1724 00b8 54686520 		.ascii	"The ticks %d %d \015\012\000"
 1724      7469636B 
 1724      73202564 
 1724      20256420 
 1724      0D0A00
 1725 00cb 00       		.space	1
 1726              	.LC7:
 1727 00cc 4572726F 		.ascii	"Error: Reading Sensor ID failed!\015\012\000"
 1727      723A2052 
 1727      65616469 
 1727      6E672053 
 1727      656E736F 
 1728 00ef 00       		.space	1
 1729              	.LC8:
 1730 00f0 54686520 		.ascii	"The Get control ID 0x%x %d\015\012\000"
 1730      47657420 
 1730      636F6E74 
 1730      726F6C20 
 1730      49442030 
 1731 010d 000000   		.space	3
 1732              	.LC9:
 1733 0110 54686520 		.ascii	"The Set control regAdd 0x%x 0x%x\015\012\000"
 1733      53657420 
 1733      636F6E74 
 1733      726F6C20 
 1733      72656741 
 1734 0133 00       		.text
 1735              	.Letext0:
 1736              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 1737              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 1738              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 1739              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 1740              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 1741              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 1742              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 1743              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 1744              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 sensor.c
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:18     .text:00000000 SensorI2CAccessDelay.part.0
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:46     .text:0000001c $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:50     .text:00000020 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:53     .text:00000020 SensorWrite2B
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:187    .text:000000ec $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:191    .text:000000f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:194    .text:000000f0 SensorWrite
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:305    .text:0000019c $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:310    .text:000001a4 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:313    .text:000001a4 SensorRead2B
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:487    .text:000002b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:496    .text:000002c8 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:499    .text:000002c8 SensorRead
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:612    .text:0000037c $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:617    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:620    .text:00000384 SensorReset
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:711    .text:00000418 $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:717    .text:00000424 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:720    .text:00000424 SensorInit
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:900    .text:0000051c $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:913    .text:0000052c $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:916    .text:0000052c SensorI2cBusTest
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1093   .text:00000628 $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1099   .text:00000634 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1102   .text:00000634 SensorGetControl
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1268   .text:00000728 $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1279   .text:00000738 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1282   .text:00000738 SensorSetControl
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1410   .text:000007ec $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1414   .text:000007f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1417   .text:000007f0 SensorGetIrisControl
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1583   .text:000008d0 $d
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1593   .text:000008dc $a
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1596   .text:000008dc SensorSetIrisControl
C:\Users\wcheng\AppData\Local\Temp\ccz4cWHX.s:1706   .rodata.str1.4:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyFx3BusyWait
CyU3PI2cTransmitBytes
CyU3PDebugPrint
CyU3PI2cReceiveBytes
CyU3PGpioSetValue
_tx_time_get
_tx_thread_sleep
