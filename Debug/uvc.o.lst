   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** 
 105:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 106:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 107:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 108:../uvc.c      ****                                                            received. */
 109:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 110:../uvc.c      **** #ifdef BACKFLOW_DETECT
 111:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 112:../uvc.c      **** #endif
 113:../uvc.c      **** 
 114:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 115:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 116:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 117:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 118:../uvc.c      **** #endif
 119:../uvc.c      **** 
 120:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 121:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 122:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 123:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 125:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 126:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 127:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 128:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 129:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 131:../uvc.c      ****                                    with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 133:../uvc.c      ****                                    streaming with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 135:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 136:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 137:../uvc.c      **** };
 138:../uvc.c      **** 
 139:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 140:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 141:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 143:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 144:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 145:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 146:../uvc.c      **** };
 147:../uvc.c      **** 
 148:../uvc.c      **** 
 149:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 150:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 151:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 152:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 154:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 155:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 156:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 157:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 158:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 159:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 160:../uvc.c      ****                                    with adjustable compression parameters */
 161:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 162:../uvc.c      ****                                    streaming with adjustable compression parameters */
 163:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 164:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 169:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 170:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 171:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 172:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 173:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 174:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 175:../uvc.c      **** };
 176:../uvc.c      **** 
 177:../uvc.c      **** 
 178:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 179:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 180:../uvc.c      **** 
 181:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 182:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 183:../uvc.c      **** {
 184:../uvc.c      ****     0x0C,                               /* Header Length */
 185:../uvc.c      ****     0x8C,                               /* Bit field header field */
 186:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 188:../uvc.c      **** };
 189:../uvc.c      **** 
 190:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 191:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 192:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 193:../uvc.c      ****                                                            the current video frame. */
 194:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 195:../uvc.c      **** #ifndef CAM720
 196:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 197:../uvc.c      **** #else
 198:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 199:../uvc.c      **** #endif
 200:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 201:../uvc.c      **** 
 202:../uvc.c      **** /************ control parameters array ***********
 203:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 204:../uvc.c      ****  *    e.g.
 205:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 206:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 207:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 208:../uvc.c      ****  **************************************************/
 209:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 210:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 211:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 212:../uvc.c      **** #ifndef CAM720
 213:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   3,
 214:../uvc.c      **** #else
 215:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 216:../uvc.c      **** #endif
 217:../uvc.c      **** 		{BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0, 118,
 218:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 219:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 220:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 221:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 222:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 223:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 224:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 225:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 226:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 227:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 228:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 229:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 230:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 231:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 232:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 233:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 234:../uvc.c      **** #ifndef CAM720
 235:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   3,
 236:../uvc.c      **** #else
 237:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 238:../uvc.c      **** #endif
 239:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 240:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 241:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 242:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 244:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 245:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 246:../uvc.c      **** 		{AExReferleveReg0    , AExReferleveReg1     , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 247:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 248:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0,   0,
 249:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 250:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 251:../uvc.c      **** 		/**********************************
 252:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 253:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 254:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 255:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 256:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 257:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 258:../uvc.c      **** 		 *
 259:../uvc.c      **** 		 *********************************/
 260:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 261:../uvc.c      **** };
 262:../uvc.c      **** 
 263:../uvc.c      **** #ifndef CAM720
 264:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 265:../uvc.c      **** #else
 266:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 267:../uvc.c      **** #endif
 268:../uvc.c      **** 
 269:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 270:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 271:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 272:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 273:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 274:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 275:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 276:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 277:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 278:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 279:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 280:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 281:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 282:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 283:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 284:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 285:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 286:../uvc.c      **** };
 287:../uvc.c      **** 
 288:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 289:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 290:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 291:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 292:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 293:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 294:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 295:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 296:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 297:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 298:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 299:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 300:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 302:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 303:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 304:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** };
 308:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 309:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 310:../uvc.c      **** /*
 311:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 312:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 313:../uvc.c      ****  */
 314:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 315:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 316:../uvc.c      **** };
 317:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 318:../uvc.c      **** 		0
 319:../uvc.c      **** };
 320:../uvc.c      **** 
 321:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 322:../uvc.c      **** 
 323:../uvc.c      **** void I2CCmdHandler(){
 324:../uvc.c      **** 	uint8_t buf[2];
 325:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 327:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 329:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 330:../uvc.c      **** 
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 332:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 333:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 334:../uvc.c      **** 
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 336:../uvc.c      **** 	{
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 338:../uvc.c      **** #if 0 //for debugging
 339:../uvc.c      **** 		/* test still image operation */
 340:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 341:../uvc.c      **** 			snapButFlag = 0; //press
 342:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 343:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 344:../uvc.c      **** 			snapButFlag = 0xf; //release
 345:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 346:../uvc.c      **** 		}
 347:../uvc.c      **** 
 348:../uvc.c      **** 		/* end of the test */
 349:../uvc.c      **** #endif
 350:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 355:../uvc.c      **** 			}
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 357:../uvc.c      **** 		}else{//not support currently
 358:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 359:../uvc.c      **** 		}
 360:../uvc.c      **** 	}else if(CmdType == 1){
 361:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 362:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 363:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 364:../uvc.c      **** 				cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 365:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 366:../uvc.c      **** 			}
 367:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 368:../uvc.c      **** 		}else{//not support currently
 369:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 370:../uvc.c      **** 		}
 371:../uvc.c      **** 
 372:../uvc.c      **** 	}
 373:../uvc.c      **** }
 374:../uvc.c      **** 
 375:../uvc.c      **** /************************************
 376:../uvc.c      ****  * set Iris mode
 377:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 378:../uvc.c      ****  */
 379:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 380:../uvc.c      **** 	uint8_t dataIdx;
 381:../uvc.c      **** 	  dataIdx = 0;
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 386:../uvc.c      **** }
 387:../uvc.c      **** 
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 389:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 390:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 391:../uvc.c      ****     uint16_t readCount;
 392:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 393:../uvc.c      ****     uint8_t devAdd;
 394:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 395:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 396:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 397:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 398:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 399:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 400:../uvc.c      ****     }else{
 401:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 402:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 403:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 404:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 405:../uvc.c      ****     }
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 407:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 408:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 409:../uvc.c      **** #endif
 410:../uvc.c      ****     reqData = bRequest;
 411:../uvc.c      ****     /*
 412:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 413:../uvc.c      ****      */
 414:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 415:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 416:../uvc.c      ****     	goto EndofSet;
 417:../uvc.c      ****     }
 418:../uvc.c      ****     switch (bRequest)
 419:../uvc.c      **** 		 {
 420:../uvc.c      **** 
 421:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 422:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 423:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 424:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 425:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 426:../uvc.c      **** 			  break;
 427:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 428:../uvc.c      **** 
 429:../uvc.c      **** 			 switch(CtrlID)
 430:../uvc.c      **** 			 {
 431:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 432:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 433:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 434:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 435:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 436:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 437:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 438:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 439:../uvc.c      **** 			 	 		 break;
 440:../uvc.c      **** 			 	 }
 441:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 442:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 443:../uvc.c      **** 					 if(CamMode == 1){//720p
 444:../uvc.c      **** 						if(sendData >= 3){
 445:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 446:../uvc.c      **** 							sendData = 0; //set back to default
 447:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 448:../uvc.c      **** 						}
 449:../uvc.c      **** 						sendData += 4;
 450:../uvc.c      **** 					 }
 451:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 452:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 453:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 454:../uvc.c      **** 					 break;
 455:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 456:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 457:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 458:../uvc.c      **** 			 		 }
 459:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 460:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 461:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 462:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 463:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 464:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 465:../uvc.c      **** #endif
 466:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 467:../uvc.c      **** 			 		 {
 468:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 469:../uvc.c      **** 			 		 }
 470:../uvc.c      **** 			 		 break;
 471:../uvc.c      **** 				 case ExtAexModCtlID9:
 472:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 474:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 475:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 476:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 477:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 478:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 479:../uvc.c      **** 					 break;
 480:../uvc.c      **** 
 481:../uvc.c      **** 			 	 case BrgtCtlID1:
 482:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 483:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 484:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 485:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 486:../uvc.c      **** 					 }else{
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 488:../uvc.c      **** 					 }
 489:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 490:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 491:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 492:../uvc.c      **** 					 break;
 493:../uvc.c      **** 				 case HueCtlID5:
 494:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 495:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 497:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 498:../uvc.c      **** 					 break;
 499:../uvc.c      **** 				 case WBTLevCtlID11:
 500:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 502:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 503:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 504:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 505:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 506:../uvc.c      **** 					 break;
 507:../uvc.c      **** 				 case SaturCtlID6:
 508:../uvc.c      **** 				 default:
 509:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 510:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 511:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 512:../uvc.c      **** 					 break;
 513:../uvc.c      **** 			 }
 514:../uvc.c      **** 
 515:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 516:../uvc.c      **** 
 517:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 518:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 519:../uvc.c      **** #endif
 520:../uvc.c      **** 			  break;
 521:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 522:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 523:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 524:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 525:../uvc.c      **** 		 	 }
 526:../uvc.c      **** 
 527:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 528:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 529:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 530:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 531:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 532:../uvc.c      **** 			 }else
 533:../uvc.c      **** 			 {
 534:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 535:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 536:../uvc.c      **** 			 }
 537:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 538:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 539:../uvc.c      **** 			  break;
 540:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 541:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 542:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 543:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 544:../uvc.c      **** 		 	 }
 545:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 546:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 547:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 548:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 549:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 550:../uvc.c      **** 			 }else
 551:../uvc.c      **** 			 {
 552:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 553:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 554:../uvc.c      **** 			 }
 555:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 556:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 557:../uvc.c      **** 			  break;
 558:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 559:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 561:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 562:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 563:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 564:../uvc.c      **** 		 	 }
 565:../uvc.c      **** 		 	 else{
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 567:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 568:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 569:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 570:../uvc.c      **** 		 	 }
 571:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 572:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 573:../uvc.c      **** 			  break;
 574:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 575:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 577:../uvc.c      **** 		 	 }
 578:../uvc.c      **** 		 	 else{
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 580:../uvc.c      **** 		 	 }
 581:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 582:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 583:../uvc.c      **** 			  Len = 1;
 584:../uvc.c      **** 			  break;
 585:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 586:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 589:../uvc.c      **** 		 	 }
 590:../uvc.c      **** 
 591:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 593:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 594:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 595:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 596:../uvc.c      **** 			 }else{
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 598:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 599:../uvc.c      **** 			 }
 600:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 601:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 602:../uvc.c      **** 			  break;
 603:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 604:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 605:../uvc.c      **** 				  glEp0Buffer, &readCount);
 606:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 607:../uvc.c      **** 			   {
 608:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 609:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 610:../uvc.c      **** 				  getData = glEp0Buffer[0];
 611:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 612:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 613:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 614:../uvc.c      **** #endif
 615:../uvc.c      **** 				  switch(CtrlID)
 616:../uvc.c      **** 					 {
 617:../uvc.c      **** 						 case ExtShutCtlID0:
 618:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 619:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 620:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 621:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 622:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 623:../uvc.c      **** 									 }else{
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 625:../uvc.c      **** 									 }
 626:../uvc.c      **** 								 }
 627:../uvc.c      **** 							 }else{
 628:../uvc.c      **** 								 Data1 = Data0 - 1;
 629:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 630:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 631:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 632:../uvc.c      **** 									 }else{
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 634:../uvc.c      **** 									 }
 635:../uvc.c      **** 								 }
 636:../uvc.c      **** 								 if(Data1 < 8){
 637:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 638:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 639:../uvc.c      **** 								 }else{
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 641:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 642:../uvc.c      **** 								 }
 643:../uvc.c      **** 							 }
 644:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 645:../uvc.c      **** 							 dataIdx = 0;
 646:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 647:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 648:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 649:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 650:../uvc.c      **** 							 break;
 651:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 652:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 653:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 655:../uvc.c      **** 							 dataIdx = 0;
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 657:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 658:../uvc.c      **** 							 if(getData != 0){
 659:../uvc.c      **** 								 dataIdx++;
 660:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 661:../uvc.c      **** 							 }
 662:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 663:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 664:../uvc.c      **** 							 break;
 665:../uvc.c      **** 						 case ExtExRefCtlID10:
 666:../uvc.c      **** 							 dataIdx = 0;
 667:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 668:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 669:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 670:../uvc.c      **** 							 if(WDRflag)
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 672:../uvc.c      **** 							 else
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 674:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 675:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 676:../uvc.c      **** 						 case ExtCamMCtlID12:
 677:../uvc.c      **** 							 /*
 678:../uvc.c      **** 							 dataIdx = 0;
 679:../uvc.c      **** 							 if(Data0 <= 3){
 680:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 681:../uvc.c      **** 								 Data1 = Data0;
 682:../uvc.c      **** 							 }else{
 683:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 684:../uvc.c      **** 								 Data1 = Data0-4;
 685:../uvc.c      **** 							 }
 686:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 687:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 688:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 689:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 690:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 691:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 692:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 693:../uvc.c      **** 							 */
 694:../uvc.c      **** 							 break;
 695:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 696:../uvc.c      **** 							 dataIdx = 0;
 697:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 698:../uvc.c      **** 								 Data0 = 1;
 699:../uvc.c      **** 							 }else{ //save current sensor parameters.
 700:../uvc.c      **** 								 Data0 = 0;
 701:../uvc.c      **** 							 }
 702:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 703:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 704:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 705:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 706:../uvc.c      **** 							 break;
 707:../uvc.c      **** 						 case ExtI2CCtlID15:
 708:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 709:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 710:../uvc.c      **** 					 		 }
 711:../uvc.c      **** 					 		I2CCmdHandler();
 712:../uvc.c      **** 							 break;
 713:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 714:../uvc.c      **** 							 dataIdx = 0;
 715:../uvc.c      **** #if 0 //seperate version
 716:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 717:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 718:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 719:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 720:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 721:../uvc.c      **** 							 }else{ //disable BLD window
 722:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 723:../uvc.c      **** 							 }
 724:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 725:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 726:../uvc.c      **** 							 dataIdx++;
 727:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 728:../uvc.c      **** 							 dataIdx++;
 729:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 730:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 731:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 732:../uvc.c      **** 							 dataIdx++;
 733:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 734:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 735:../uvc.c      **** #else //combination version
 736:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 737:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 738:../uvc.c      **** 						     /* end test */
 739:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 740:../uvc.c      **** 							 dataIdx++;
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 742:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 743:../uvc.c      **** 							 getData1 = Data1;
 744:../uvc.c      **** #endif
 745:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 746:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 748:../uvc.c      **** 							 break;
 749:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 750:../uvc.c      **** 							 dataIdx = 0;
 751:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 752:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 753:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 754:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 755:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 756:../uvc.c      **** 							 break;
 757:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 758:../uvc.c      **** 							 dataIdx = 0;
 759:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 760:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 761:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 762:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 764:../uvc.c      **** 							 break;
 765:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 766:../uvc.c      **** 							 dataIdx = 0;
 767:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 768:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 769:../uvc.c      **** 							  if(Data0&0x80){
 770:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 771:../uvc.c      **** 							  }else{
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 773:../uvc.c      **** 							  }
 774:../uvc.c      **** 							 Data1 |= ~0x03;
 775:../uvc.c      **** 							 Data1 &= 0xC7;
 776:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 777:../uvc.c      **** 						  	 dataIdx++;
 778:../uvc.c      **** 
 779:../uvc.c      **** 							 Data0 = (Data0 << 2);
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 781:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 782:../uvc.c      **** 
 783:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 784:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 786:../uvc.c      **** 
 787:../uvc.c      **** 							 break;
 788:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 789:../uvc.c      **** 							 dataIdx = 0;
 790:../uvc.c      **** 
 791:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 792:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 793:../uvc.c      **** 							 dataIdx++;
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 795:../uvc.c      **** 							 dataIdx++;
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 797:../uvc.c      **** 							 dataIdx++;
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 799:../uvc.c      **** 							 dataIdx++;
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 801:../uvc.c      **** 							 dataIdx++;
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 803:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 804:../uvc.c      **** 
 805:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 806:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 807:../uvc.c      **** 							 break;
 808:../uvc.c      **** 						 case SaturCtlID6:
 809:../uvc.c      **** 							 dataIdx = 0;
 810:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 811:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 812:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 813:../uvc.c      **** 							 dataIdx++;
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 816:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 818:../uvc.c      **** 							 break;
 819:../uvc.c      **** 
 820:../uvc.c      **** 						 case WBTLevCtlID11:
 821:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 822:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 823:../uvc.c      **** 							 dataIdx = 0;
 824:../uvc.c      **** 
 825:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 826:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 827:../uvc.c      **** 							 dataIdx++;
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 830:../uvc.c      **** 
 831:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 832:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 833:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 834:../uvc.c      **** 							 break;
 835:../uvc.c      **** 						 case MFreqCtlID4:
 836:../uvc.c      **** 							 dataIdx = 0;
 837:../uvc.c      **** 							 Data0 = Data0 - 1;
 838:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 839:../uvc.c      **** 								 Data0 = 0;
 840:../uvc.c      **** 							 else if(Data0 >2)
 841:../uvc.c      **** 								 Data0 = 1;
 842:../uvc.c      **** 
 843:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 845:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 846:../uvc.c      **** 
 847:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 849:../uvc.c      **** 							 break;
 850:../uvc.c      **** 					 	 case BLCCtlID0:
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 852:../uvc.c      **** 							 if(Data0 == 3)
 853:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 854:../uvc.c      **** 							 else
 855:../uvc.c      **** 								 WDRflag = CyFalse;
 856:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 857:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 858:../uvc.c      **** 							 {
 859:../uvc.c      **** 								 if(Data0 < 2){
 860:../uvc.c      **** 					 				 ;//Data0 += 4;
 861:../uvc.c      **** 					 			 }else{
 862:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 863:../uvc.c      **** 									Data0 = 0; //set to default.
 864:../uvc.c      **** 					 			 }
 865:../uvc.c      **** 					 		 }
 866:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 867:../uvc.c      **** 							 dataIdx = 0;
 868:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 869:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 870:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 871:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 872:../uvc.c      **** 
 873:../uvc.c      **** 					 		 break;
 874:../uvc.c      **** 						 default:
 875:../uvc.c      **** 							 dataIdx = 0;
 876:../uvc.c      **** 
 877:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 878:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 879:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 880:../uvc.c      **** 
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 883:../uvc.c      **** 							 break;
 884:../uvc.c      **** 					 }
 885:../uvc.c      **** 			   }else{
 886:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 887:../uvc.c      **** 			   }
 888:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 889:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 890:../uvc.c      **** #endif
 891:../uvc.c      **** 
 892:../uvc.c      **** 			  break;
 893:../uvc.c      **** 		  default:
 894:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 895:../uvc.c      **** 			  break;
 896:../uvc.c      **** 		 }
 897:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 898:../uvc.c      **** }
 899:../uvc.c      **** /************** CT control requests handler *************************/
 900:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 901:../uvc.c      **** 
 902:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 903:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 904:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 905:../uvc.c      ****     uint16_t readCount;
 906:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 907:../uvc.c      ****     uint16_t diff, value, diffRd;
 908:../uvc.c      ****     uint8_t i, shutter, index;
 909:../uvc.c      ****     diff = 0xffff;
 910:../uvc.c      ****     shutter = 1;
 911:../uvc.c      ****     index = 1;
 912:../uvc.c      **** 
 913:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 914:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 915:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 916:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 917:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 918:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 919:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 920:../uvc.c      **** #endif
 921:../uvc.c      ****     reqData = bRequest;
 922:../uvc.c      **** 
 923:../uvc.c      ****     switch (bRequest)
 924:../uvc.c      **** 		 {
 925:../uvc.c      **** 
 926:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 927:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 928:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 929:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 930:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 931:../uvc.c      **** 			  break;
 932:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 933:../uvc.c      **** 
 934:../uvc.c      **** 			 switch(CtrlID)
 935:../uvc.c      **** 			 {
 936:../uvc.c      **** 				 default:
 937:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 938:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 939:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 940:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 941:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 942:../uvc.c      **** 					 break;
 943:../uvc.c      **** 			 }
 944:../uvc.c      **** 
 945:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 946:../uvc.c      **** 
 947:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 948:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 949:../uvc.c      **** #endif
 950:../uvc.c      **** 			  break;
 951:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 952:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 953:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 954:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 955:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 956:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 957:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 958:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 959:../uvc.c      **** 			  break;
 960:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 961:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 962:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 963:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 964:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 965:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 966:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 967:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 968:../uvc.c      **** 			  break;
 969:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 970:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 971:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 972:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 973:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 974:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 975:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 976:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 977:../uvc.c      **** 			  break;
 978:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 979:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 981:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 982:../uvc.c      **** 			  Len = 1;
 983:../uvc.c      **** 			  break;
 984:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 985:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 986:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 987:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 988:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 989:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 990:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 991:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 992:../uvc.c      **** 			  break;
 993:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 994:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 995:../uvc.c      **** 			  glEp0Buffer, &readCount);
 996:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 997:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 998:../uvc.c      **** 			  value = Data1;
 999:../uvc.c      **** 
1000:../uvc.c      **** 			  switch(CtrlID)
1001:../uvc.c      **** 			  {
1002:../uvc.c      **** 		  	      case AutoExMCtlID1:
1003:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1004:../uvc.c      **** 
1005:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1006:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1007:../uvc.c      **** 				    getData = glEp0Buffer[0];
1008:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1009:../uvc.c      **** 		  		    switch (getData){
1010:../uvc.c      **** 						case 1:
1011:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1012:../uvc.c      **** 							break;
1013:../uvc.c      **** 						case 2:
1014:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1015:../uvc.c      **** 							dataIdx = 0;
1016:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1017:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1018:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1019:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1020:../uvc.c      **** 
1021:../uvc.c      **** 							break;
1022:../uvc.c      **** 						case 4:
1023:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1024:../uvc.c      **** 							break;
1025:../uvc.c      **** 						case 8:
1026:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1027:../uvc.c      **** 			  		    	dataIdx = 0;
1028:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1029:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1030:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1031:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1032:../uvc.c      **** 							break;
1033:../uvc.c      **** 		  		    }
1034:../uvc.c      **** #if 0
1035:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1036:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1037:../uvc.c      **** 						  dataIdx = 0;
1038:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1039:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1040:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1041:../uvc.c      **** 		  		    }
1042:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1043:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1044:../uvc.c      **** 		  		    }
1045:../uvc.c      **** #endif
1046:../uvc.c      **** 				    break;
1047:../uvc.c      **** 
1048:../uvc.c      **** 			  	  case ExTmACtlID3:
1049:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1050:../uvc.c      **** 
1051:../uvc.c      **** 					  value = (value << 8)|Data0;
1052:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1053:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1054:../uvc.c      **** 					  {
1055:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1056:../uvc.c      **** 						  {
1057:../uvc.c      **** 							if(value > ShutValueArry[i]){
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1059:../uvc.c      **** 							}else{
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1061:../uvc.c      **** 							}
1062:../uvc.c      **** 							  if(diff > diffRd){
1063:../uvc.c      **** 								  diff = diffRd;
1064:../uvc.c      **** 								  index = i;
1065:../uvc.c      **** 							  }
1066:../uvc.c      **** 						  }
1067:../uvc.c      **** 						  shutter = shutter+index;
1068:../uvc.c      **** 
1069:../uvc.c      **** 						  dataIdx = 0;
1070:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1071:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1072:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1073:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1074:../uvc.c      **** 
1075:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1076:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1078:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1079:../uvc.c      **** 					  }else{
1080:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1081:../uvc.c      **** 					  }
1082:../uvc.c      **** 					  getData = glEp0Buffer[0];
1083:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1084:../uvc.c      **** 					  break;
1085:../uvc.c      **** 			  	  case IriACtlID7:
1086:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1087:../uvc.c      **** 					  {
1088:../uvc.c      **** 							 dataIdx = 0;
1089:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1090:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1091:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1092:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1093:../uvc.c      **** 
1094:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1095:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1097:../uvc.c      **** 					  }else{
1098:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1099:../uvc.c      **** 					  }
1100:../uvc.c      **** 					  getData = glEp0Buffer[0];
1101:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1102:../uvc.c      **** 
1103:../uvc.c      **** 					  break;
1104:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1105:../uvc.c      **** 					  getData = glEp0Buffer[0];
1106:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1107:../uvc.c      **** #if 1
1108:../uvc.c      **** 					  dataIdx = 0;
1109:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1110:../uvc.c      **** 					  if(getData == 1)
1111:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1112:../uvc.c      **** 					  else if(getData == 0xff)
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1114:../uvc.c      **** 					  else
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1116:../uvc.c      **** 					  //dataIdx++;
1117:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1118:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1119:../uvc.c      **** #endif
1120:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1121:../uvc.c      **** 					  break;
1122:../uvc.c      **** 
1123:../uvc.c      **** 			  	  default:
1124:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1125:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1126:../uvc.c      **** 			  		 break;
1127:../uvc.c      **** 			  }
1128:../uvc.c      **** 			  break;
1129:../uvc.c      **** 		  default:
1130:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1131:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1132:../uvc.c      **** 			  break;
1133:../uvc.c      **** 		 }
1134:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1135:../uvc.c      **** 
1136:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1137:../uvc.c      **** }
1138:../uvc.c      **** 
1139:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1140:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1141:../uvc.c      **** {
1142:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1143:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1144:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1145:../uvc.c      **** 
1146:../uvc.c      ****     CtrlID = BrgtCtlID1;
1147:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1148:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1149:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1150:../uvc.c      ****     Data1 = Data0;
1151:../uvc.c      **** 
1152:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1153:../uvc.c      ****     if(Data1&0x80){
1154:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1155:../uvc.c      ****     }else{
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1157:../uvc.c      ****     }
1158:../uvc.c      ****     Data0 = (Data0 << 2);
1159:../uvc.c      **** 
1160:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1161:../uvc.c      **** 
1162:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1164:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1165:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1167:../uvc.c      **** 
1168:../uvc.c      ****     CtrlID = ConsCtlID2;
1169:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1170:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1171:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1172:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1173:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1174:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1175:../uvc.c      **** 
1176:../uvc.c      ****     CtrlID = HueCtlID5;
1177:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1178:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1179:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1186:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1187:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1188:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1189:../uvc.c      **** 
1190:../uvc.c      ****     CtrlID = SaturCtlID6;
1191:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1192:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1193:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1194:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1195:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1196:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1197:../uvc.c      **** 
1198:../uvc.c      ****     CtrlID = ShapCtlID7;
1199:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1200:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1201:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1202:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1203:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1204:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1205:../uvc.c      **** 
1206:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1207:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1208:../uvc.c      **** 	return;
1209:../uvc.c      **** }
1210:../uvc.c      **** 
1211:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1212:../uvc.c      **** void
1213:../uvc.c      **** CyFxUVCAddHeader (
1214:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1215:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1216:../uvc.c      ****         )
1217:../uvc.c      **** {
1218:../uvc.c      ****     /* Copy header to buffer */
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1220:../uvc.c      **** 
1221:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1222:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1223:../uvc.c      ****     {
1224:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1225:../uvc.c      ****     }
1226:../uvc.c      **** }
1227:../uvc.c      **** 
1228:../uvc.c      **** 
1229:../uvc.c      **** /* Application Error Handler */
1230:../uvc.c      **** void
1231:../uvc.c      **** CyFxAppErrorHandler (
1232:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1233:../uvc.c      ****         )
1234:../uvc.c      **** {
1235:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1236:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1237:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1238:../uvc.c      **** 
1239:../uvc.c      ****        This function can be modified to take additional error handling actions such
1240:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1241:../uvc.c      ****      */
1242:../uvc.c      ****     for (;;)
1243:../uvc.c      ****     {
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
1246:../uvc.c      ****     }
1247:../uvc.c      **** }
1248:../uvc.c      **** 
1249:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1250:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1251:../uvc.c      ****  */
1252:../uvc.c      **** static void
1253:../uvc.c      **** CyFxUVCApplnAbortHandler (
1254:../uvc.c      ****         void)
1255:../uvc.c      **** {
1256:../uvc.c      **** 	uint32_t flag;
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1258:../uvc.c      **** 	{
1259:../uvc.c      ****         /* Clear the Video Stream Request Event */
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1261:../uvc.c      **** 
1262:../uvc.c      ****         /* Set Video Stream Abort Event */
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1264:../uvc.c      **** 	}
1265:../uvc.c      **** }
1266:../uvc.c      **** 
1267:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1268:../uvc.c      **** static void
1269:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1270:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1271:../uvc.c      ****         uint16_t             evdata  /* Event data */
1272:../uvc.c      ****         )
1273:../uvc.c      **** {
1274:../uvc.c      ****     switch (evtype)
1275:../uvc.c      ****     {
1276:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1277:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1278:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1279:../uvc.c      ****             gpif_initialized = 0;
1280:../uvc.c      ****             streamingStarted = CyFalse;
1281:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1282:../uvc.c      ****             break;
1283:../uvc.c      **** 
1284:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1285:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1286:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1287:../uvc.c      ****             gpif_initialized = 0;
1288:../uvc.c      ****             streamingStarted = CyFalse;
1289:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1290:../uvc.c      ****             break;
1291:../uvc.c      **** 
1292:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1293:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1294:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1295:../uvc.c      ****             gpif_initialized = 0;
1296:../uvc.c      ****             isUsbConnected = CyFalse;
1297:../uvc.c      ****             streamingStarted = CyFalse;
1298:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1299:../uvc.c      ****             break;
1300:../uvc.c      **** 
1301:../uvc.c      **** #ifdef BACKFLOW_DETECT
1302:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1303:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1304:../uvc.c      ****             break;
1305:../uvc.c      **** #endif
1306:../uvc.c      **** 
1307:../uvc.c      ****         default:
1308:../uvc.c      ****             break;
1309:../uvc.c      ****     }
1310:../uvc.c      **** }
1311:../uvc.c      **** 
1312:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1313:../uvc.c      **** static CyBool_t
1314:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1315:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1316:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1317:../uvc.c      ****         )
1318:../uvc.c      **** {
1319:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1320:../uvc.c      ****     uint32_t status;
1321:../uvc.c      **** 
1322:../uvc.c      ****     /* Obtain Request Type and Request */
1323:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1325:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1327:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1328:../uvc.c      **** 
1329:../uvc.c      ****     /* Check for UVC Class Requests */
1330:../uvc.c      ****     switch (bmReqType)
1331:../uvc.c      ****     {
1332:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1333:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1334:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1335:../uvc.c      ****             switch (wIndex & 0xFF)
1336:../uvc.c      ****             {
1337:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1338:../uvc.c      ****                     {
1339:../uvc.c      ****                         uvcHandleReq = CyTrue;
1340:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1341:../uvc.c      ****                                 CYU3P_EVENT_OR);
1342:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1343:../uvc.c      ****                         {
1344:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1345:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1346:../uvc.c      ****                         }
1347:../uvc.c      ****                     }
1348:../uvc.c      ****                     break;
1349:../uvc.c      **** 
1350:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1351:../uvc.c      ****                     {
1352:../uvc.c      ****                         uvcHandleReq = CyTrue;
1353:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1354:../uvc.c      ****                                 CYU3P_EVENT_OR);
1355:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1356:../uvc.c      ****                         {
1357:../uvc.c      ****                             /* Error handling */
1358:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1359:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1360:../uvc.c      ****                         }
1361:../uvc.c      ****                     }
1362:../uvc.c      ****                     break;
1363:../uvc.c      **** 
1364:../uvc.c      ****                 default:
1365:../uvc.c      ****                     break;
1366:../uvc.c      ****             }
1367:../uvc.c      ****             break;
1368:../uvc.c      **** 
1369:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1370:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1371:../uvc.c      ****             {
1372:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1373:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1374:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1375:../uvc.c      ****                 {
1376:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1377:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1378:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1379:../uvc.c      ****                     gpif_initialized = 0;
1380:../uvc.c      ****                     streamingStarted = CyFalse;
1381:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1382:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1383:../uvc.c      ****                     CyU3PBusyWait (100);
1384:../uvc.c      **** 
1385:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1386:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1387:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1388:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1389:../uvc.c      ****                     CyU3PBusyWait (100);
1390:../uvc.c      **** 
1391:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1392:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1393:../uvc.c      ****                     uvcHandleReq = CyTrue;
1394:../uvc.c      ****                     /* Complete Control request handshake */
1395:../uvc.c      ****                     CyU3PUsbAckSetup ();
1396:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1397:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1398:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1399:../uvc.c      **** 
1400:../uvc.c      ****                 }
1401:../uvc.c      ****             }
1402:../uvc.c      ****             break;
1403:../uvc.c      **** 
1404:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1405:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1406:../uvc.c      ****             {
1407:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1408:../uvc.c      ****                 {
1409:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1410:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1411:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1412:../uvc.c      ****                 	 * has started. */
1413:../uvc.c      ****                     if (streamingStarted == CyTrue)
1414:../uvc.c      ****                     {
1415:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1416:../uvc.c      **** 
1417:../uvc.c      ****                         /* Disable the GPIF state machine. */
1418:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1419:../uvc.c      ****                         gpif_initialized = 0;
1420:../uvc.c      ****                         streamingStarted = CyFalse;
1421:../uvc.c      **** 
1422:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1423:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1424:../uvc.c      ****                         CyU3PBusyWait (100);
1425:../uvc.c      **** 
1426:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1427:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1428:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1429:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1430:../uvc.c      ****                         CyU3PBusyWait (100);
1431:../uvc.c      **** 
1432:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1433:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1434:../uvc.c      **** 
1435:../uvc.c      ****                         uvcHandleReq = CyTrue;
1436:../uvc.c      ****                         /* Complete Control request handshake */
1437:../uvc.c      ****                         CyU3PUsbAckSetup ();
1438:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1439:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1440:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1441:../uvc.c      ****                     }
1442:../uvc.c      ****                     else
1443:../uvc.c      ****                     {
1444:../uvc.c      ****                         uvcHandleReq = CyTrue;
1445:../uvc.c      ****                         CyU3PUsbAckSetup ();
1446:../uvc.c      ****                     }
1447:../uvc.c      ****                 }
1448:../uvc.c      ****             }
1449:../uvc.c      ****             break;
1450:../uvc.c      **** 
1451:../uvc.c      ****         default:
1452:../uvc.c      ****             break;
1453:../uvc.c      ****     }
1454:../uvc.c      **** 
1455:../uvc.c      ****     /* Return status of request handling to the USB driver */
1456:../uvc.c      ****     return uvcHandleReq;
1457:../uvc.c      **** }
1458:../uvc.c      **** 
1459:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1460:../uvc.c      **** 
1461:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1462:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1463:../uvc.c      ****  */
1464:../uvc.c      **** void
1465:../uvc.c      **** CyFxUvcApplnDmaCallback (
1466:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1467:../uvc.c      ****         CyU3PDmaCbType_t      type,
1468:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1469:../uvc.c      ****         )
1470:../uvc.c      **** {
1471:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1472:../uvc.c      **** #if 1
1473:../uvc.c      ****     CyU3PReturnStatus_t status;
1474:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1475:../uvc.c      ****     {
1476:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1477:../uvc.c      ****             {
1478:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1479:../uvc.c      ****                 fb++;
1480:../uvc.c      ****             }
1481:../uvc.c      ****             else
1482:../uvc.c      ****             {
1483:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1484:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1485:../uvc.c      ****                 pb++;
1486:../uvc.c      ****                 pbc = input->buffer_p.count;
1487:../uvc.c      ****                // hitFV = CyTrue;
1488:../uvc.c      ****             }
1489:../uvc.c      **** 
1490:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1491:../uvc.c      ****             prodCount++;
1492:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1493:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1494:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1495:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1496:../uvc.c      ****             {
1497:../uvc.c      ****                 prodCount--;
1498:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1499:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1500:../uvc.c      ****             }
1501:../uvc.c      ****     }
1502:../uvc.c      **** #endif
1503:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1504:../uvc.c      ****     {
1505:../uvc.c      ****         consCount++;
1506:../uvc.c      ****         streamingStarted = CyTrue;
1507:../uvc.c      ****     }
1508:../uvc.c      **** }
1509:../uvc.c      **** 
1510:../uvc.c      **** /*
1511:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1512:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1513:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1514:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1515:../uvc.c      ****  * to commit the buffer.
1516:../uvc.c      ****  */
1517:../uvc.c      **** static uint8_t
1518:../uvc.c      **** CyFxUvcAppCommitEOF (
1519:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1520:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1521:../uvc.c      ****         )
1522:../uvc.c      **** {
1523:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1524:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1525:../uvc.c      **** 
1526:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1527:../uvc.c      **** 
1528:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1529:../uvc.c      ****     {
1530:../uvc.c      ****         switch (stateId)
1531:../uvc.c      ****         {
1532:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1533:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1534:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1535:../uvc.c      ****                 break;
1536:../uvc.c      **** 
1537:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1538:../uvc.c      ****                 socket = 0;
1539:../uvc.c      ****                 break;
1540:../uvc.c      **** 
1541:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1542:../uvc.c      ****                 socket = 1;
1543:../uvc.c      ****                 break;
1544:../uvc.c      **** 
1545:../uvc.c      ****             default:
1546:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1547:../uvc.c      ****                 /* Unexpected current state. Return error. */
1548:../uvc.c      ****                 return 1;
1549:../uvc.c      ****         }
1550:../uvc.c      ****     }
1551:../uvc.c      **** 
1552:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1553:../uvc.c      ****     {
1554:../uvc.c      ****         switch (stateId)
1555:../uvc.c      ****         {
1556:../uvc.c      **** #ifndef CAM720
1557:../uvc.c      **** #ifdef GPIFIIM
1558:../uvc.c      ****             case 13:
1559:../uvc.c      ****             case 24:
1560:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1561:../uvc.c      ****                 break;
1562:../uvc.c      **** 
1563:../uvc.c      ****             case 8:
1564:../uvc.c      ****                 socket = 0;
1565:../uvc.c      ****                 break;
1566:../uvc.c      **** 
1567:../uvc.c      ****             case 20:
1568:../uvc.c      ****                 socket = 1;
1569:../uvc.c      ****                 break;
1570:../uvc.c      **** #else
1571:../uvc.c      ****             case 11:
1572:../uvc.c      ****             case 18:
1573:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1574:../uvc.c      ****                 break;
1575:../uvc.c      **** 
1576:../uvc.c      ****             case 8:
1577:../uvc.c      ****                 socket = 0;
1578:../uvc.c      ****                 break;
1579:../uvc.c      **** 
1580:../uvc.c      ****             case 15:
1581:../uvc.c      ****                 socket = 1;
1582:../uvc.c      ****                 break;
1583:../uvc.c      **** #endif
1584:../uvc.c      **** #else
1585:../uvc.c      ****             case 11:
1586:../uvc.c      ****             case 18:
1587:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1588:../uvc.c      ****                 break;
1589:../uvc.c      **** 
1590:../uvc.c      ****             case 8:
1591:../uvc.c      ****                 socket = 0;
1592:../uvc.c      ****                 break;
1593:../uvc.c      **** 
1594:../uvc.c      ****             case 15:
1595:../uvc.c      ****                 socket = 1;
1596:../uvc.c      ****                 break;
1597:../uvc.c      **** 
1598:../uvc.c      **** #endif
1599:../uvc.c      ****              default:
1600:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1601:../uvc.c      ****                 /* Unexpected current state. Return error. */
1602:../uvc.c      ****                return 1;
1603:../uvc.c      ****         }
1604:../uvc.c      ****     }
1605:../uvc.c      **** 
1606:../uvc.c      ****     if (socket != 0xFF)
1607:../uvc.c      ****     {
1608:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1609:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1610:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1611:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1612:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1613:../uvc.c      ****         {
1614:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1615:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1616:../uvc.c      ****         }
1617:../uvc.c      ****     }
1618:../uvc.c      **** 
1619:../uvc.c      ****     return 0;
1620:../uvc.c      **** }
1621:../uvc.c      **** 
1622:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1623:../uvc.c      **** void
1624:../uvc.c      **** CyFxGpifCB (
1625:../uvc.c      ****         CyU3PGpifEventType event,
1626:../uvc.c      ****         uint8_t currentState
1627:../uvc.c      ****         )
1628:../uvc.c      **** {
1629:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1630:../uvc.c      ****     {
1631:../uvc.c      ****         hitFV = CyTrue;
1632:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1633:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1634:../uvc.c      ****     }
1635:../uvc.c      **** }
1636:../uvc.c      **** 
1637:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1638:../uvc.c      **** static void
1639:../uvc.c      **** CyFxUVCApplnDebugInit (
1640:../uvc.c      ****         void)
1641:../uvc.c      **** {
1642:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1643:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1644:../uvc.c      **** 
1645:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1646:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1647:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1648:../uvc.c      ****     {
1649:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1650:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1651:../uvc.c      ****     }
1652:../uvc.c      **** 
1653:../uvc.c      ****     /* Set UART Configuration */
1654:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1655:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1656:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1657:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1658:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1659:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1660:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1661:../uvc.c      **** 
1662:../uvc.c      ****     /* Set the UART configuration */
1663:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1664:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1665:../uvc.c      ****     {
1666:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1667:../uvc.c      ****     }
1668:../uvc.c      **** 
1669:../uvc.c      ****     /* Set the UART transfer */
1670:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1671:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1672:../uvc.c      ****     {
1673:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1674:../uvc.c      ****     }
1675:../uvc.c      **** 
1676:../uvc.c      ****     /* Initialize the Debug logger module. */
1677:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1678:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1679:../uvc.c      ****     {
1680:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1681:../uvc.c      ****     }
1682:../uvc.c      **** 
1683:../uvc.c      ****     /* Disable log message headers. */
1684:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1685:../uvc.c      **** }
1686:../uvc.c      **** 
1687:../uvc.c      **** /* I2C initialization. */
1688:../uvc.c      **** //static void
1689:../uvc.c      **** void
1690:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1691:../uvc.c      **** {
1692:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1693:../uvc.c      ****     CyU3PReturnStatus_t status;
1694:../uvc.c      **** 
1695:../uvc.c      ****     status = CyU3PI2cInit ();
1696:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1697:../uvc.c      ****     {
1698:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1699:../uvc.c      ****         CyFxAppErrorHandler (status);
1700:../uvc.c      ****     }
1701:../uvc.c      **** 
1702:../uvc.c      ****     /*  Set I2C Configuration */
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1704:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1705:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1706:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1707:../uvc.c      **** 
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1709:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1710:../uvc.c      ****     {
1711:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1712:../uvc.c      ****         CyFxAppErrorHandler (status);
1713:../uvc.c      ****     }
1714:../uvc.c      **** }
1715:../uvc.c      **** 
1716:../uvc.c      **** #ifdef BACKFLOW_DETECT
1717:../uvc.c      **** static void CyFxUvcAppPibCallback (
1718:../uvc.c      ****         CyU3PPibIntrType cbType,
1719:../uvc.c      ****         uint16_t cbArg)
1720:../uvc.c      **** {
1721:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1722:../uvc.c      ****     {
1723:../uvc.c      ****         if (!back_flow_detected)
1724:../uvc.c      ****         {
1725:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1726:../uvc.c      ****             back_flow_detected = 1;
1727:../uvc.c      ****         }
1728:../uvc.c      ****     }
1729:../uvc.c      **** }
1730:../uvc.c      **** #endif
1731:../uvc.c      **** 
1732:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1733:../uvc.c      **** static void
1734:../uvc.c      **** CyFxUvcAppDebugCallback (
1735:../uvc.c      ****         CyU3PDmaChannel   *handle,
1736:../uvc.c      ****         CyU3PDmaCbType_t   type,
1737:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1738:../uvc.c      **** {
1739:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1740:../uvc.c      ****     {
1741:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1742:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1743:../uvc.c      ****     }
1744:../uvc.c      **** }
1745:../uvc.c      **** #endif
1746:../uvc.c      **** 
1747:../uvc.c      **** #if 0
1748:../uvc.c      **** static void CyFxAppIntEpCb(
1749:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1750:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1751:../uvc.c      **** 		uint8_t  ebNum)
1752:../uvc.c      **** 		{
1753:../uvc.c      **** 			//CyBool_t value;
1754:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1755:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1756:../uvc.c      **** 
1757:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1758:../uvc.c      **** 		}
1759:../uvc.c      **** #endif
1760:../uvc.c      **** 
1761:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1762:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1763:../uvc.c      ****    configures the DMA module for the UVC Application */
1764:../uvc.c      **** static void
1765:../uvc.c      **** CyFxUVCApplnInit (void)
1766:../uvc.c      **** {
1767:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1768:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1769:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1770:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1771:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1772:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1773:../uvc.c      **** 
1774:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1775:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1776:../uvc.c      **** 
1777:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1778:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1779:../uvc.c      **** #endif
1780:../uvc.c      **** 
1781:../uvc.c      ****     /* Create UVC event group */
1782:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1783:../uvc.c      ****     if (apiRetStatus != 0)
1784:../uvc.c      ****     {
1785:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1786:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1787:../uvc.c      ****     }
1788:../uvc.c      **** 
1789:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1790:../uvc.c      ****     CyFxUvcAppPTZInit ();
1791:../uvc.c      **** #endif
1792:../uvc.c      **** 
1793:../uvc.c      ****     isUsbConnected = CyFalse;
1794:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1795:../uvc.c      **** 
1796:../uvc.c      ****     /* Init the GPIO module */
1797:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1798:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1799:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1800:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1801:../uvc.c      ****     gpioClock.halfDiv    = 0;
1802:../uvc.c      **** 
1803:../uvc.c      ****     /* Initialize Gpio interface */
1804:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1805:../uvc.c      ****     if (apiRetStatus != 0)
1806:../uvc.c      ****     {
1807:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1808:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1809:../uvc.c      ****     }
1810:../uvc.c      **** 
1811:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1812:../uvc.c      ****      * must use GpioOverride to configure it */
1813:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1814:../uvc.c      ****     if (apiRetStatus != 0)
1815:../uvc.c      ****     {
1816:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1817:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1818:../uvc.c      ****     }
1819:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1820:../uvc.c      ****     if (apiRetStatus != 0)
1821:../uvc.c      ****     {
1822:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1823:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1824:../uvc.c      ****     }
1825:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1826:../uvc.c      ****     if (apiRetStatus != 0)
1827:../uvc.c      ****     {
1828:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1829:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1830:../uvc.c      ****     }
1831:../uvc.c      **** 
1832:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1833:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1834:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1835:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1836:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1837:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1838:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1839:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1840:../uvc.c      ****     {
1841:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1842:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1843:../uvc.c      ****     }
1844:../uvc.c      **** 
1845:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1846:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1847:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1848:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1849:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1850:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1851:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1852:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1853:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1854:../uvc.c      ****     {
1855:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1856:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1857:../uvc.c      ****     }
1858:../uvc.c      **** 
1859:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1860:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1861:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1862:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1863:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1864:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1865:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1866:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1867:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1868:../uvc.c      ****     {
1869:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1870:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1871:../uvc.c      ****     }
1872:../uvc.c      **** 
1873:../uvc.c      ****     /* Initialize the P-port. */
1874:../uvc.c      ****     pibclock.clkDiv      = 2;
1875:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1876:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1877:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1878:../uvc.c      **** 
1879:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1881:../uvc.c      ****     {
1882:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1884:../uvc.c      ****     }
1885:../uvc.c      **** 
1886:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1887:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1888:../uvc.c      **** 
1889:../uvc.c      **** #ifdef BACKFLOW_DETECT
1890:../uvc.c      ****     back_flow_detected = 0;
1891:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1892:../uvc.c      **** #endif
1893:../uvc.c      **** 
1894:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1895:../uvc.c      ****     SensorReset ();
1896:../uvc.c      ****     SensorInit ();
1897:../uvc.c      **** 
1898:../uvc.c      ****     /* USB initialization. */
1899:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1900:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1901:../uvc.c      ****     {
1902:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1903:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1904:../uvc.c      ****     }
1905:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1906:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1907:../uvc.c      **** 
1908:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1909:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1910:../uvc.c      **** 
1911:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1912:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1913:../uvc.c      **** 
1914:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1915:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1916:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1917:../uvc.c      **** 
1918:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1919:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1920:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1921:../uvc.c      **** 
1922:../uvc.c      ****     /* Configuration descriptors. */
1923:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1924:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1926:../uvc.c      **** 
1927:../uvc.c      ****     /* String Descriptors */
1928:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1929:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1931:../uvc.c      **** 
1932:../uvc.c      ****     /* Configure the status interrupt endpoint.
1933:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1934:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1935:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1936:../uvc.c      ****      */
1937:../uvc.c      ****     endPointConfig.enable   = 1;
1938:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1939:../uvc.c      ****     endPointConfig.pcktSize = 64;
1940:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1941:../uvc.c      ****     endPointConfig.streams  = 0;
1942:../uvc.c      ****     endPointConfig.burstLen = 1;
1943:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1944:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1945:../uvc.c      ****     {
1946:../uvc.c      ****         /* Error Handling */
1947:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1948:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1949:../uvc.c      ****     }
1950:../uvc.c      **** 
1951:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1952:../uvc.c      ****     dmaInterConfig.size           = 1024;
1953:../uvc.c      ****     dmaInterConfig.count          = 1;
1954:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1955:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1956:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1957:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1958:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1959:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1960:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1961:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1962:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1963:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1964:../uvc.c      ****             &dmaInterConfig);
1965:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1966:../uvc.c      ****     {
1967:../uvc.c      ****         /* Error handling */
1968:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1969:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1970:../uvc.c      ****     }
1971:../uvc.c      **** 
1972:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1973:../uvc.c      ****     if (glInterStaBuffer == 0)
1974:../uvc.c      ****     {
1975:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1976:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1977:../uvc.c      ****     }
1978:../uvc.c      **** 
1979:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1980:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1981:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1982:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1983:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1984:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1985:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1986:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1987:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1988:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
1989:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1990:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1991:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1992:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1993:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
1994:../uvc.c      ****             &dmaMultiConfig);
1995:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1996:../uvc.c      ****     {
1997:../uvc.c      ****         /* Error handling */
1998:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
1999:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2000:../uvc.c      ****     }
2001:../uvc.c      **** 
2002:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2003:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2004:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2005:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2006:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2007:../uvc.c      ****      */
2008:../uvc.c      **** 
2009:../uvc.c      ****     endPointConfig.enable   = 1;
2010:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2011:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2012:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2013:../uvc.c      ****     endPointConfig.streams  = 0;
2014:../uvc.c      ****     endPointConfig.burstLen = 1;
2015:../uvc.c      **** 
2016:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2017:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2018:../uvc.c      ****     {
2019:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2020:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2021:../uvc.c      ****     }
2022:../uvc.c      **** 
2023:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2024:../uvc.c      **** 
2025:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2026:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2027:../uvc.c      ****     {
2028:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2029:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2030:../uvc.c      ****     }
2031:../uvc.c      **** 
2032:../uvc.c      ****     channelConfig.size           = 1024;
2033:../uvc.c      ****     channelConfig.count          = 1;
2034:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2035:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2036:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2037:../uvc.c      ****     channelConfig.prodHeader     = 0;
2038:../uvc.c      ****     channelConfig.prodFooter     = 0;
2039:../uvc.c      ****     channelConfig.consHeader     = 0;
2040:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2041:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2042:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2043:../uvc.c      **** 
2044:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2045:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2046:../uvc.c      ****     {
2047:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2048:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2049:../uvc.c      ****     }
2050:../uvc.c      **** 
2051:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2052:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2053:../uvc.c      ****     {
2054:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2055:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2056:../uvc.c      ****     }
2057:../uvc.c      **** 
2058:../uvc.c      ****     channelConfig.size           = 1024;
2059:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2060:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2061:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2062:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2063:../uvc.c      ****     channelConfig.prodHeader     = 0;
2064:../uvc.c      ****     channelConfig.prodFooter     = 0;
2065:../uvc.c      ****     channelConfig.consHeader     = 0;
2066:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2067:../uvc.c      ****     channelConfig.notification   = 0;
2068:../uvc.c      ****     channelConfig.cb             = 0;
2069:../uvc.c      **** 
2070:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2071:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2072:../uvc.c      ****     {
2073:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2074:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2075:../uvc.c      ****     }
2076:../uvc.c      **** 
2077:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2078:../uvc.c      ****     if (glDebugRspBuffer == 0)
2079:../uvc.c      ****     {
2080:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2081:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2082:../uvc.c      ****     }
2083:../uvc.c      **** #endif
2084:../uvc.c      **** 
2085:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2086:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2087:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2088:../uvc.c      ****     {
2089:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2090:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2091:../uvc.c      ****     }
2092:../uvc.c      **** 
2093:../uvc.c      ****     CyU3PBusyWait(100);
2094:../uvc.c      **** 
2095:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2096:../uvc.c      **** 
2097:../uvc.c      ****     endPointConfig.enable   = 1;
2098:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2099:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2100:../uvc.c      ****     {
2101:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2102:../uvc.c      ****     	endPointConfig.burstLen = 16;
2103:../uvc.c      ****     }
2104:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2105:../uvc.c      ****     {
2106:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2107:../uvc.c      ****     	endPointConfig.burstLen = 1;
2108:../uvc.c      ****     }
2109:../uvc.c      ****     endPointConfig.streams  = 0;
2110:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2111:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2112:../uvc.c      ****     {
2113:../uvc.c      ****         /* Error Handling */
2114:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2115:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2116:../uvc.c      ****     }
2117:../uvc.c      **** #if 0    //for still image method 3 using
2118:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2119:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2120:../uvc.c      ****     {
2121:../uvc.c      ****         /* Error Handling */
2122:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2123:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2124:../uvc.c      ****     }
2125:../uvc.c      **** #endif
2126:../uvc.c      **** 
2127:../uvc.c      **** }
2128:../uvc.c      **** 
2129:../uvc.c      **** /*
2130:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2131:../uvc.c      ****  * streaming session is started.
2132:../uvc.c      ****  */
2133:../uvc.c      **** static void
2134:../uvc.c      **** CyFxUvcAppGpifInit (
2135:../uvc.c      ****         void)
2136:../uvc.c      **** {
2137:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2138:../uvc.c      **** 
2139:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2140:../uvc.c      ****     {
2141:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2142:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2143:../uvc.c      ****     }
2144:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2145:../uvc.c      ****     {
2146:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2147:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2148:../uvc.c      ****     }
2149:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2150:../uvc.c      ****     {
2151:../uvc.c      ****         /* Error Handling */
2152:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2153:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2154:../uvc.c      ****     }
2155:../uvc.c      **** 
2156:../uvc.c      ****     /* Start the state machine from the designated start state. */
2157:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2158:../uvc.c      ****     {
2159:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2160:../uvc.c      ****     }
2161:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2162:../uvc.c      ****     {
2163:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2164:../uvc.c      ****     }
2165:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2166:../uvc.c      ****     {
2167:../uvc.c      ****         /* Error Handling */
2168:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2169:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2170:../uvc.c      ****     }
2171:../uvc.c      **** }
2172:../uvc.c      **** 
2173:../uvc.c      **** /*
2174:../uvc.c      ****  * Entry function for the UVC Application Thread
2175:../uvc.c      ****  */
2176:../uvc.c      **** 
2177:../uvc.c      **** uint32_t posTick;
2178:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2179:../uvc.c      **** 
2180:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2181:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2182:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2183:../uvc.c      **** }
2184:../uvc.c      **** 
2185:../uvc.c      **** 
2186:../uvc.c      **** void
2187:../uvc.c      **** UVCAppThread_Entry (
2188:../uvc.c      ****         uint32_t input)
2189:../uvc.c      **** {
2190:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2191:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2192:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2193:../uvc.c      ****     uint8_t i = 0;
2194:../uvc.c      ****     uint32_t flag;
2195:../uvc.c      ****     uint32_t prinflag = 0;
2196:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2197:../uvc.c      ****     uint32_t frameCnt = 0;
2198:../uvc.c      **** #endif
2199:../uvc.c      ****     /* Initialize the Uart Debug Module */
2200:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2201:../uvc.c      **** 
2202:../uvc.c      ****     /* Initialize the I2C interface */
2203:../uvc.c      **** 	while (i++ < 6){
2204:../uvc.c      **** 		CyU3PThreadSleep(500);
2205:../uvc.c      **** 	}
2206:../uvc.c      **** 
2207:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2208:../uvc.c      **** 
2209:../uvc.c      ****     /* Initialize the UVC Application */
2210:../uvc.c      ****     CyFxUVCApplnInit ();
2211:../uvc.c      **** 
2212:../uvc.c      ****     /*
2213:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2214:../uvc.c      **** 
2215:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2216:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2217:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2218:../uvc.c      **** 
2219:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2220:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2221:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2222:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2223:../uvc.c      **** 
2224:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2225:../uvc.c      ****        of handling the abort request.
2226:../uvc.c      ****      */
2227:../uvc.c      **** 
2228:../uvc.c      ****     for (;;)
2229:../uvc.c      ****     {
2230:../uvc.c      ****         /* Waiting for the Video Stream Event */
2231:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2232:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2233:../uvc.c      ****         {
2234:../uvc.c      **** #if 0 //test for new firmware no video bring up
2235:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2236:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2237:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2238:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2239:../uvc.c      ****             {
2240:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2241:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2242:../uvc.c      ****                 {
2243:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2244:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2245:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2246:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2247:../uvc.c      **** #endif
2248:../uvc.c      **** #endif
2249:../uvc.c      ****                     }
2250:../uvc.c      ****                 else
2251:../uvc.c      ****                 {
2252:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2253:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2254:../uvc.c      **** #ifdef USB_LOWRES_IMG
2255:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2256:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2257:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2258:../uvc.c      **** #endif
2259:../uvc.c      **** #endif
2260:../uvc.c      ****                 }
2261:../uvc.c      **** 
2262:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2263:../uvc.c      ****                 prodCount++;
2264:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2265:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2266:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2267:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2268:../uvc.c      ****                 {
2269:../uvc.c      ****                     prodCount--;
2270:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2271:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2272:../uvc.c      ****                 }
2273:../uvc.c      ****             }
2274:../uvc.c      **** #endif
2275:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2276:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2277:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2278:../uvc.c      ****             {
2279:../uvc.c      ****             	if(0&&(prinflag == 0)){
2280:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2281:../uvc.c      ****             		prinflag = 1;
2282:../uvc.c      ****             	}
2283:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2284:../uvc.c      ****             	fb=0;
2285:../uvc.c      ****             	pb=0;
2286:../uvc.c      ****             	pbc=0;
2287:../uvc.c      ****                 prodCount = 0;
2288:../uvc.c      ****                 consCount = 0;
2289:../uvc.c      ****                 hitFV     = CyFalse;
2290:../uvc.c      **** 
2291:../uvc.c      **** #ifdef BACKFLOW_DETECT
2292:../uvc.c      ****                 back_flow_detected = 0;
2293:../uvc.c      **** #endif
2294:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2295:../uvc.c      ****                 frameCnt++;
2296:../uvc.c      **** #endif
2297:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2298:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2299:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2300:../uvc.c      ****                 //}
2301:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2302:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2303:../uvc.c      ****                 if(stiflag){
2304:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
2305:../uvc.c      ****                 	stiflag = CyFalse;
2306:../uvc.c      ****                 }else{
2307:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2308:../uvc.c      ****                 }
2309:../uvc.c      ****                 /* Reset the DMA channel. */
2310:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2311:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2312:../uvc.c      ****                 {
2313:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2314:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2315:../uvc.c      ****                 }
2316:../uvc.c      **** 
2317:../uvc.c      ****                 /* Start Channel Immediately */
2318:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2319:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2320:../uvc.c      ****                 {
2321:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2322:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2323:../uvc.c      ****                 }
2324:../uvc.c      **** 
2325:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2326:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2327:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2328:../uvc.c      ****                 }
2329:../uvc.c      ****         }
2330:../uvc.c      ****         else
2331:../uvc.c      ****         {
2332:../uvc.c      ****             /* If we have a stream abort request pending. */
2333:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2334:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2335:../uvc.c      ****             {
2336:../uvc.c      ****                 hitFV     = CyFalse;
2337:../uvc.c      ****                 prodCount = 0;
2338:../uvc.c      ****                 consCount = 0;
2339:../uvc.c      ****                 if(0&&(prinflag == 0)){
2340:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2341:../uvc.c      ****                 	prinflag = 1;
2342:../uvc.c      ****                 }
2343:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2344:../uvc.c      ****                 fb=0;
2345:../uvc.c      ****                 pb=0;
2346:../uvc.c      ****                 pbc=0;
2347:../uvc.c      **** 
2348:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2349:../uvc.c      ****                 {
2350:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2351:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2352:../uvc.c      ****                     {
2353:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2354:../uvc.c      ****                     }
2355:../uvc.c      **** 
2356:../uvc.c      ****                     /* Flush the Endpoint memory */
2357:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2358:../uvc.c      ****                 }
2359:../uvc.c      **** 
2360:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2361:../uvc.c      ****             }
2362:../uvc.c      ****             else
2363:../uvc.c      ****             {
2364:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2365:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2366:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2367:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2368:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2369:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2370:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2371:../uvc.c      ****                 {
2372:../uvc.c      ****                     /* Error handling */
2373:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2374:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2375:../uvc.c      ****                 }
2376:../uvc.c      **** 
2377:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2378:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2379:../uvc.c      ****                 {
2380:../uvc.c      ****                     //for start up of the AF Lens
2381:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2382:../uvc.c      ****                     CyU3PThreadSleep(500);
2383:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
2385:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2386:../uvc.c      ****                    	CyU3PThreadSleep(300);
2387:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2388:../uvc.c      ****                     CyU3PThreadSleep(500);
2389:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
2391:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2392:../uvc.c      ****                     gpif_initialized = CyTrue;
2393:../uvc.c      ****                     CyU3PThreadSleep(200);
2394:../uvc.c      ****                     
2395:../uvc.c      ****                 }
2396:../uvc.c      ****                 else
2397:../uvc.c      ****                 {
2398:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2399:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2401:../uvc.c      ****                 }
2402:../uvc.c      ****             }
2403:../uvc.c      ****         }
2404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2405:../uvc.c      **** 
2406:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2407:../uvc.c      ****         CyU3PThreadRelinquish ();
2408:../uvc.c      ****     }
2409:../uvc.c      **** }
2410:../uvc.c      **** 
2411:../uvc.c      **** /*
2412:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2413:../uvc.c      ****  */
2414:../uvc.c      **** 
2415:../uvc.c      **** static void
2416:../uvc.c      **** UVCHandleProcessingUnitRqts (
2417:../uvc.c      ****         void)
2418:../uvc.c      **** {
2419:../uvc.c      ****     uint8_t CtrlAdd;
2420:../uvc.c      **** #ifdef DbgInfo
2421:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2422:../uvc.c      **** #endif
2423:../uvc.c      ****     switch (wValue)
2424:../uvc.c      ****     {
2425:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2426:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2428:../uvc.c      ****     		break;
2429:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2430:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2432:../uvc.c      ****     		break;
2433:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2434:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2436:../uvc.c      **** 			break;
2437:../uvc.c      **** 
2438:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2439:../uvc.c      **** 
2440:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2441:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2443:../uvc.c      ****       		break;
2444:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2445:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2446:../uvc.c      ****      		ControlHandle(HueCtlID5);
2447:../uvc.c      ****      		break;
2448:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2449:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2451:../uvc.c      ****           		break;
2452:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2453:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2455:../uvc.c      ****           		break;
2456:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2457:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2458:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2459:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2461:../uvc.c      ****     		break;
2462:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2463:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2465:../uvc.c      ****     		break;
2466:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2467:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2469:../uvc.c      ****     		break;
2470:../uvc.c      **** 
2471:../uvc.c      ****         default:
2472:../uvc.c      ****             /*
2473:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2474:../uvc.c      ****              * other controls.
2475:../uvc.c      ****              */
2476:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2477:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2478:../uvc.c      ****             break;
2479:../uvc.c      ****     }
2480:../uvc.c      **** }
2481:../uvc.c      **** 
2482:../uvc.c      **** /*
2483:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2484:../uvc.c      ****  */
2485:../uvc.c      **** static void
2486:../uvc.c      **** UVCHandleCameraTerminalRqts (
2487:../uvc.c      ****         void)
2488:../uvc.c      **** {
2489:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2490:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2491:../uvc.c      ****     uint16_t readCount;
2492:../uvc.c      ****     uint16_t zoomVal;
2493:../uvc.c      ****     int32_t  panVal, tiltVal;
2494:../uvc.c      ****     CyBool_t sendData = CyFalse;
2495:../uvc.c      **** #endif
2496:../uvc.c      ****     uint8_t CtrlAdd;
2497:../uvc.c      **** 
2498:../uvc.c      ****     switch (wValue)
2499:../uvc.c      ****     {
2500:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2501:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2503:../uvc.c      ****     		break;
2504:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2505:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2507:../uvc.c      ****     		break;
2508:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2509:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2511:../uvc.c      **** 			break;
2512:../uvc.c      **** 
2513:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2514:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2516:../uvc.c      **** 			break;
2517:../uvc.c      **** 
2518:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2519:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2521:../uvc.c      ****       		break;
2522:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2523:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2525:../uvc.c      ****      		break;
2526:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2527:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2529:../uvc.c      ****           		break;
2530:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2531:../uvc.c      ****           		break;
2532:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2533:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2535:../uvc.c      ****      		break;
2536:../uvc.c      **** 
2537:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2538:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2540:../uvc.c      ****     		break;
2541:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2542:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2544:../uvc.c      ****     		break;
2545:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2546:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2548:../uvc.c      ****     		break;
2549:../uvc.c      **** 
2550:../uvc.c      ****         default:
2551:../uvc.c      ****             /*
2552:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2553:../uvc.c      ****              * other controls.
2554:../uvc.c      ****              */
2555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2556:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2557:../uvc.c      ****             break;
2558:../uvc.c      ****     }
2559:../uvc.c      **** 
2560:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2561:../uvc.c      ****     switch (wValue)
2562:../uvc.c      ****     {
2563:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2564:../uvc.c      ****             switch (bRequest)
2565:../uvc.c      ****             {
2566:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2567:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2568:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2569:../uvc.c      ****                     break;
2570:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2571:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2572:../uvc.c      ****                     sendData = CyTrue;
2573:../uvc.c      ****                     break;
2574:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2575:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2576:../uvc.c      ****                     sendData = CyTrue;
2577:../uvc.c      ****                     break;
2578:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2579:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2580:../uvc.c      ****                     sendData = CyTrue;
2581:../uvc.c      ****                     break;
2582:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2583:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2584:../uvc.c      ****                     sendData = CyTrue;
2585:../uvc.c      ****                     break;
2586:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2587:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2588:../uvc.c      ****                     sendData = CyTrue;
2589:../uvc.c      ****                     break;
2590:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2591:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2592:../uvc.c      ****                             glEp0Buffer, &readCount);
2593:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2594:../uvc.c      ****                     {
2595:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2596:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2597:../uvc.c      ****                     }
2598:../uvc.c      ****                     break;
2599:../uvc.c      ****                 default:
2600:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2601:../uvc.c      ****                     break;
2602:../uvc.c      ****             }
2603:../uvc.c      **** 
2604:../uvc.c      ****             if (sendData)
2605:../uvc.c      ****             {
2606:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2607:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2608:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2609:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2610:../uvc.c      ****             }
2611:../uvc.c      ****             break;
2612:../uvc.c      **** 
2613:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2614:../uvc.c      ****             switch (bRequest)
2615:../uvc.c      ****             {
2616:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2617:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2618:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2619:../uvc.c      ****                     break;
2620:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2621:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2622:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2623:../uvc.c      ****                     sendData = CyTrue;
2624:../uvc.c      ****                     break;
2625:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2626:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2627:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2628:../uvc.c      ****                     sendData = CyTrue;
2629:../uvc.c      ****                     break;
2630:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2631:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2632:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2633:../uvc.c      ****                     sendData = CyTrue;
2634:../uvc.c      ****                     break;
2635:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2636:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2637:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2638:../uvc.c      ****                     sendData = CyTrue;
2639:../uvc.c      ****                     break;
2640:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2641:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2642:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2643:../uvc.c      ****                     sendData = CyTrue;
2644:../uvc.c      ****                     break;
2645:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2646:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2647:../uvc.c      ****                             glEp0Buffer, &readCount);
2648:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2649:../uvc.c      ****                     {
2650:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2651:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2652:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2653:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2654:../uvc.c      **** 
2655:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2656:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2657:../uvc.c      ****                     }
2658:../uvc.c      ****                     break;
2659:../uvc.c      ****                 default:
2660:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2661:../uvc.c      ****                     break;
2662:../uvc.c      ****             }
2663:../uvc.c      **** 
2664:../uvc.c      ****             if (sendData)
2665:../uvc.c      ****             {
2666:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2667:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2668:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2669:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2670:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2671:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2672:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2673:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2674:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2675:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2676:../uvc.c      ****             }
2677:../uvc.c      ****             break;
2678:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2679:../uvc.c      ****         default:
2680:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2681:../uvc.c      ****             break;
2682:../uvc.c      ****     }
2683:../uvc.c      **** #endif
2684:../uvc.c      **** }
2685:../uvc.c      **** 
2686:../uvc.c      **** /*
2687:../uvc.c      ****  * Handler for UVC Interface control requests.
2688:../uvc.c      ****  */
2689:../uvc.c      **** static void
2690:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2691:../uvc.c      ****         void)
2692:../uvc.c      **** {
2693:../uvc.c      **** 
2694:../uvc.c      ****     switch (wValue)
2695:../uvc.c      ****     {
2696:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2697:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2698:../uvc.c      ****     		break;
2699:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2700:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2701:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2702:../uvc.c      ****     		break;
2703:../uvc.c      ****     	default:
2704:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2705:../uvc.c      ****      		break;
2706:../uvc.c      ****     }
2707:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2708:../uvc.c      **** 
2709:../uvc.c      **** }
2710:../uvc.c      **** 
2711:../uvc.c      **** /*
2712:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2713:../uvc.c      ****  */
2714:../uvc.c      **** static void
2715:../uvc.c      **** UVCHandleExtensionUnitRqts (
2716:../uvc.c      ****         void)
2717:../uvc.c      **** {
2718:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2719:../uvc.c      **** 
2720:../uvc.c      **** #ifdef DbgInfo
2721:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2722:../uvc.c      **** #endif
2723:../uvc.c      ****     switch (wValue)
2724:../uvc.c      ****     {
2725:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2726:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2727:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2728:../uvc.c      ****     		break;
2729:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2730:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2731:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2732:../uvc.c      ****     		break;
2733:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2734:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2735:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2736:../uvc.c      ****      		break;
2737:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2738:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2739:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2740:../uvc.c      ****     		break;
2741:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2742:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2743:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2744:../uvc.c      ****     		break;
2745:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2746:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2747:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2748:../uvc.c      ****      		break;
2749:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2750:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2751:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2752:../uvc.c      ****     		break;
2753:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2754:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2755:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2756:../uvc.c      ****     		break;
2757:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2758:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2759:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2760:../uvc.c      ****      		break;
2761:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2762:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2763:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2764:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2765:../uvc.c      ****     		}else/* no support for 1080p camera */
2766:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2767:../uvc.c      ****     		break;
2768:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2769:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2770:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2771:../uvc.c      ****     		break;
2772:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2773:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2774:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2775:../uvc.c      ****     		break;
2776:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2777:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2778:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2779:../uvc.c      ****     		//break;
2780:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2781:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2782:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2783:../uvc.c      ****     		break;
2784:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2785:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2786:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2787:../uvc.c      ****     		break;
2788:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2789:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2790:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2791:../uvc.c      ****     		break;
2792:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2793:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2794:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2795:../uvc.c      ****     		break;
2796:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2797:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2798:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2799:../uvc.c      ****     		break;
2800:../uvc.c      ****    	default:
2801:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2802:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2803:../uvc.c      ****     		break;
2804:../uvc.c      ****     }
2805:../uvc.c      **** 
2806:../uvc.c      **** }
2807:../uvc.c      **** 
2808:../uvc.c      **** /*
2809:../uvc.c      ****  * Handler for the video streaming control requests.
2810:../uvc.c      ****  */
2811:../uvc.c      **** static void
2812:../uvc.c      **** UVCHandleVideoStreamingRqts (
2813:../uvc.c      ****         void)
2814:../uvc.c      **** {
2815:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2816:../uvc.c      ****     uint16_t readCount;
2817:../uvc.c      **** 
2818:../uvc.c      ****     switch (wValue)
2819:../uvc.c      ****     {
2820:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2821:../uvc.c      ****             switch (bRequest)
2822:../uvc.c      ****             {
2823:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2824:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2825:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2826:../uvc.c      ****                     break;
2827:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2828:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2829:../uvc.c      ****                     glEp0Buffer[1] = 0;
2830:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2831:../uvc.c      ****                     break;
2832:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2833:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2834:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2835:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2836:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2837:../uvc.c      ****                     {
2838:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2839:../uvc.c      ****                     }
2840:../uvc.c      ****                     else
2841:../uvc.c      ****                     {
2842:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2843:../uvc.c      ****                     }
2844:../uvc.c      ****                     break;
2845:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2846:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2847:../uvc.c      ****                             glCommitCtrl, &readCount);
2848:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2849:../uvc.c      ****                     {
2850:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2851:../uvc.c      ****                         {
2852:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2853:../uvc.c      ****                                active data structure. */
2854:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2855:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2856:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2857:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2858:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2859:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2860:../uvc.c      ****                         }
2861:../uvc.c      ****                     }
2862:../uvc.c      ****                     break;
2863:../uvc.c      ****                 default:
2864:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2865:../uvc.c      ****                     break;
2866:../uvc.c      ****             }
2867:../uvc.c      ****             break;
2868:../uvc.c      **** 
2869:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2870:../uvc.c      ****             switch (bRequest)
2871:../uvc.c      ****             {
2872:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2873:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2874:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2875:../uvc.c      ****                     break;
2876:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2877:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2878:../uvc.c      ****                     glEp0Buffer[1] = 0;
2879:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2880:../uvc.c      ****                     break;
2881:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2882:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2883:../uvc.c      ****                     {
2884:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2885:../uvc.c      ****                     }
2886:../uvc.c      ****                     else
2887:../uvc.c      ****                     {
2888:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2889:../uvc.c      ****                     }
2890:../uvc.c      ****                     break;
2891:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2892:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2893:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2894:../uvc.c      ****                        */
2895:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2896:../uvc.c      ****                             glCommitCtrl, &readCount);
2897:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2898:../uvc.c      ****                     {
2899:../uvc.c      **** #if 0
2900:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2901:../uvc.c      ****                         {
2902:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2903:../uvc.c      ****                         }
2904:../uvc.c      ****                         else
2905:../uvc.c      ****                         {
2906:../uvc.c      ****                             SensorScaling_VGA ();
2907:../uvc.c      ****                         }
2908:../uvc.c      **** #endif
2909:../uvc.c      ****                         /* We can start streaming video now. */
2910:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2911:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2912:../uvc.c      ****                         {
2913:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2914:../uvc.c      ****                         }
2915:../uvc.c      ****                     }
2916:../uvc.c      ****                     break;
2917:../uvc.c      **** 
2918:../uvc.c      ****                 default:
2919:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2920:../uvc.c      ****                     break;
2921:../uvc.c      ****             }
2922:../uvc.c      ****             break;
2923:../uvc.c      **** 
2924:../uvc.c      **** /* still image streaming handler */
2925:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2926:../uvc.c      ****                 switch (bRequest)
2927:../uvc.c      ****                 {
2928:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2929:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2930:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2931:../uvc.c      ****                         break;
2932:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2933:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2934:../uvc.c      ****                         glEp0Buffer[1] = 0;
2935:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2936:../uvc.c      ****                         break;
2937:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2938:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2939:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2940:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2941:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2942:../uvc.c      ****                         {
2943:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2944:../uvc.c      ****                         }
2945:../uvc.c      ****                         else
2946:../uvc.c      ****                         {
2947:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2948:../uvc.c      ****                         }
2949:../uvc.c      ****                         break;
2950:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2951:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2952:../uvc.c      ****                                 glCommitCtrl, &readCount);
2953:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2954:../uvc.c      ****                         {
2955:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
2956:../uvc.c      ****                             {
2957:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2958:../uvc.c      ****                                    active data structure. */
2959:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
2960:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
2961:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
2962:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
2963:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
2964:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
2965:../uvc.c      ****                             }
2966:../uvc.c      ****                         }
2967:../uvc.c      ****                         break;
2968:../uvc.c      ****                     default:
2969:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2970:../uvc.c      ****                         break;
2971:../uvc.c      ****                 }
2972:../uvc.c      ****                 break;
2973:../uvc.c      **** 
2974:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
2975:../uvc.c      ****                 switch (bRequest)
2976:../uvc.c      ****                 {
2977:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2978:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2979:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2980:../uvc.c      ****                         break;
2981:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2982:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2983:../uvc.c      ****                         glEp0Buffer[1] = 0;
2984:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2985:../uvc.c      ****                         break;
2986:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2987:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2988:../uvc.c      ****                         {
2989:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2990:../uvc.c      ****                         }
2991:../uvc.c      ****                         else
2992:../uvc.c      ****                         {
2993:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2994:../uvc.c      ****                         }
2995:../uvc.c      ****                         break;
2996:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2997:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
2998:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
2999:../uvc.c      ****                            */
3000:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3001:../uvc.c      ****                                 glCommitCtrl, &readCount);
3002:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3003:../uvc.c      ****                         {
3004:../uvc.c      ****     #if 0
3005:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3006:../uvc.c      ****                             {
3007:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3008:../uvc.c      ****                             }
3009:../uvc.c      ****                             else
3010:../uvc.c      ****                             {
3011:../uvc.c      ****                                 SensorScaling_VGA ();
3012:../uvc.c      ****                             }
3013:../uvc.c      ****     #endif
3014:../uvc.c      ****                             /* We can start streaming video now. */
3015:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3016:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3017:../uvc.c      ****                             {
3018:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3019:../uvc.c      ****                             }
3020:../uvc.c      ****                         }
3021:../uvc.c      ****                         break;
3022:../uvc.c      **** 
3023:../uvc.c      ****                     default:
3024:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3025:../uvc.c      ****                         break;
3026:../uvc.c      ****                 }
3027:../uvc.c      ****                 break;
3028:../uvc.c      **** 
3029:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3030:../uvc.c      ****                 switch (bRequest)
3031:../uvc.c      ****                 {
3032:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3033:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3034:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3035:../uvc.c      ****                         break;
3036:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3037:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3038:../uvc.c      ****                         glEp0Buffer[1] = 0;
3039:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3040:../uvc.c      ****                         break;
3041:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3042:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3043:../uvc.c      ****                         {
3044:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3045:../uvc.c      ****                         }
3046:../uvc.c      ****                         else
3047:../uvc.c      ****                         {
3048:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3049:../uvc.c      ****                         }
3050:../uvc.c      ****                         break;
3051:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3052:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3053:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3054:../uvc.c      ****                            */
3055:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3056:../uvc.c      ****                                 glCommitCtrl, &readCount);
3057:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3058:../uvc.c      ****                         {
3059:../uvc.c      ****     #if 0
3060:../uvc.c      ****                             /* We can start streaming video now. */
3061:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3062:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3063:../uvc.c      ****                             {
3064:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3065:../uvc.c      ****                             }
3066:../uvc.c      ****     #endif
3067:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3068:../uvc.c      ****                         }else{
3069:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3070:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3071:../uvc.c      ****                         }
3072:../uvc.c      ****                         break;
3073:../uvc.c      **** 
3074:../uvc.c      ****                     default:
3075:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3076:../uvc.c      ****                         break;
3077:../uvc.c      ****                 }
3078:../uvc.c      ****                 break;
3079:../uvc.c      **** 
3080:../uvc.c      ****         default:
3081:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3082:../uvc.c      ****             break;
3083:../uvc.c      ****     }
3084:../uvc.c      **** }
3085:../uvc.c      **** 
3086:../uvc.c      **** /*
3087:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3088:../uvc.c      ****  */
3089:../uvc.c      **** void
3090:../uvc.c      **** UVCAppEP0Thread_Entry (
3091:../uvc.c      ****         uint32_t input)
3092:../uvc.c      **** {
3093:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3094:../uvc.c      ****     uint32_t eventFlag;
3095:../uvc.c      **** 	CyBool_t value;
3096:../uvc.c      **** 	CyBool_t *valueptr = &value;
3097:../uvc.c      **** 
3098:../uvc.c      **** 
3099:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3100:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3101:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3102:../uvc.c      **** 
3103:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3104:../uvc.c      **** #endif
3105:../uvc.c      **** 
3106:../uvc.c      ****     /* for interrupt status test */
3107:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3108:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3109:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3110:../uvc.c      **** 
3111:../uvc.c      ****     for (;;)
3112:../uvc.c      ****     {
3113:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3114:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3115:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3116:../uvc.c      ****         {
3117:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3118:../uvc.c      ****             if (!isUsbConnected)
3119:../uvc.c      ****             {
3120:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3121:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3122:../uvc.c      ****                 {
3123:../uvc.c      ****                     isUsbConnected = CyTrue;
3124:../uvc.c      ****                 }
3125:../uvc.c      ****             }
3126:../uvc.c      **** //#ifdef DbgInfo
3127:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3128:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3129:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3130:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3131:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3132:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3133:../uvc.c      **** //#endif
3134:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3135:../uvc.c      ****             {
3136:../uvc.c      ****             	switch ((wIndex >> 8))
3137:../uvc.c      ****                 {
3138:../uvc.c      **** 
3139:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3140:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3141:../uvc.c      ****                         break;
3142:../uvc.c      **** 
3143:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3144:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3145:../uvc.c      ****                         break;
3146:../uvc.c      **** 
3147:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3148:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3149:../uvc.c      ****                         break;
3150:../uvc.c      **** 
3151:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3152:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3153:../uvc.c      ****                         break;
3154:../uvc.c      **** 
3155:../uvc.c      ****                     default:
3156:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3157:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3158:../uvc.c      ****                         break;
3159:../uvc.c      ****                 }
3160:../uvc.c      ****             }
3161:../uvc.c      **** 
3162:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3163:../uvc.c      ****             {
3164:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3165:../uvc.c      **** 
3166:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3167:../uvc.c      ****                 {
3168:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3169:../uvc.c      ****                 }
3170:../uvc.c      ****                 else
3171:../uvc.c      ****                 {
3172:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3173:../uvc.c      ****                 }
3174:../uvc.c      ****             }
3175:../uvc.c      **** 
3176:../uvc.c      ****             /* handle interrupt status event */
3177:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3178:../uvc.c      ****             {
3179:../uvc.c      **** 
3180:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3181:../uvc.c      ****             	/** preparing interrupt status data **/
3182:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3183:../uvc.c      **** 
3184:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3185:../uvc.c      **** 
3186:../uvc.c      **** #if 1 //for real button
3187:../uvc.c      **** 				if(value&&(!snapButFlag)){
3188:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3189:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3190:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3191:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3192:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3193:../uvc.c      **** 
3194:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3195:../uvc.c      **** 					interStabuf.size   = 1024;
3196:../uvc.c      **** 					interStabuf.status = 0;
3197:../uvc.c      **** 
3198:../uvc.c      **** 					interStabuf.count = 4;
3199:../uvc.c      **** 
3200:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3202:../uvc.c      **** 
3203:../uvc.c      **** 					/** send a interrupt status data **/
3204:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3205:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3206:../uvc.c      **** 					{
3207:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3208:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3209:../uvc.c      **** 					}
3210:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3211:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3212:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3213:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3214:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3215:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3216:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3217:../uvc.c      **** 
3218:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3219:../uvc.c      **** 					interStabuf.size   = 1024;
3220:../uvc.c      **** 					interStabuf.status = 0;
3221:../uvc.c      **** 
3222:../uvc.c      **** 					interStabuf.count = 4;
3223:../uvc.c      **** 
3224:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3225:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3226:../uvc.c      **** 
3227:../uvc.c      **** 					/** send a interrupt status data **/
3228:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3229:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3230:../uvc.c      **** 					{
3231:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3232:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3233:../uvc.c      **** 					}
3234:../uvc.c      **** 
3235:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3236:../uvc.c      **** 					stiflag = CyTrue;
3237:../uvc.c      **** 				}
3238:../uvc.c      **** #else			//for botton simulation
3239:../uvc.c      **** 				if(snapButFlag == 0x0f){
3240:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3241:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3242:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3243:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3244:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3245:../uvc.c      **** 
3246:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3247:../uvc.c      **** 					interStabuf.size   = 1024;
3248:../uvc.c      **** 					interStabuf.status = 0;
3249:../uvc.c      **** 
3250:../uvc.c      **** 					interStabuf.count = 4;
3251:../uvc.c      **** 
3252:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3253:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3254:../uvc.c      **** 
3255:../uvc.c      **** 					/** send a interrupt status data **/
3256:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3257:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3258:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3259:../uvc.c      **** 					{
3260:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3261:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3262:../uvc.c      **** 					}
3263:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3264:../uvc.c      **** 
3265:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3266:../uvc.c      **** 				}else if(!snapButFlag){
3267:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3268:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3269:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3270:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3271:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3272:../uvc.c      **** 
3273:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3274:../uvc.c      **** 					interStabuf.size   = 1024;
3275:../uvc.c      **** 					interStabuf.status = 0;
3276:../uvc.c      **** 
3277:../uvc.c      **** 					interStabuf.count = 4;
3278:../uvc.c      **** 
3279:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3280:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3281:../uvc.c      **** 
3282:../uvc.c      **** 					/** send a interrupt status data **/
3283:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3284:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3285:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3286:../uvc.c      **** 					{
3287:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3288:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3289:../uvc.c      **** 					}
3290:../uvc.c      **** 
3291:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3292:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3293:../uvc.c      **** 				}
3294:../uvc.c      **** #endif
3295:../uvc.c      **** 
3296:../uvc.c      ****             }
3297:../uvc.c      **** 
3298:../uvc.c      **** 
3299:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3300:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3301:../uvc.c      ****             {
3302:../uvc.c      ****                 /* Get the command buffer */
3303:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3304:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3305:../uvc.c      ****                 {
3306:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3307:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3308:../uvc.c      ****                 }
3309:../uvc.c      **** 
3310:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3311:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3312:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3313:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3314:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3315:../uvc.c      ****                  * register value high byte and register value low byte.
3316:../uvc.c      ****                  */
3317:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3318:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3319:../uvc.c      ****                 {
3320:../uvc.c      ****                     if (dmaInfo.count == 3)
3321:../uvc.c      ****                     {
3322:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3323:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3324:../uvc.c      ****                         dmaInfo.count = 3;
3325:../uvc.c      ****                     }
3326:../uvc.c      ****                     else if (dmaInfo.count == 4)
3327:../uvc.c      ****                     {
3328:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3329:../uvc.c      ****                         {
3330:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3331:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3332:../uvc.c      ****                         }
3333:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3334:../uvc.c      ****                     }
3335:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3336:../uvc.c      ****                 }
3337:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3338:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3339:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3340:../uvc.c      ****                  */
3341:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3342:../uvc.c      ****                 {
3343:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3344:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3345:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3346:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3347:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3348:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3349:../uvc.c      ****                         	break;
3350:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3351:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3352:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3353:../uvc.c      ****                         	break;*/
3354:../uvc.c      ****                     dmaInfo.count -= 2;
3355:../uvc.c      ****                 }
3356:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3357:../uvc.c      ****                 else
3358:../uvc.c      ****                 {
3359:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3360:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3361:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3362:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3363:../uvc.c      ****                 }
3364:../uvc.c      **** 
3365:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3366:../uvc.c      ****                 dmaInfo.size   = 1024;
3367:../uvc.c      ****                 dmaInfo.status = 0;
3368:../uvc.c      **** 
3369:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3370:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3371:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3372:../uvc.c      ****                 {
3373:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3374:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3375:../uvc.c      ****                 }
3376:../uvc.c      **** 
3377:../uvc.c      ****                 /* Wait until the response has gone out. */
3378:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3379:../uvc.c      **** 
3380:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3381:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3382:../uvc.c      ****                 {
3383:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3384:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3385:../uvc.c      ****                 }
3386:../uvc.c      ****             }
3387:../uvc.c      **** #endif
3388:../uvc.c      ****         }
3389:../uvc.c      ****         /* Allow other ready threads to run. */
3390:../uvc.c      ****         CyU3PThreadRelinquish ();
3391:../uvc.c      ****     }
3392:../uvc.c      **** }
3393:../uvc.c      **** 
3394:../uvc.c      **** /*
3395:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3396:../uvc.c      ****  * added 10/2013
3397:../uvc.c      ****  */
3398:../uvc.c      **** /*
3399:../uvc.c      **** static uint8_t timeDelay[64] = {
3400:../uvc.c      **** 
3401:../uvc.c      **** };
3402:../uvc.c      **** */
3403:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3403 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3404:../uvc.c      **** 
3405:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3406:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3407:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3408:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3409:../uvc.c      **** 	VdstateDes *lcStaDes;
3410:../uvc.c      **** 	uint32_t flag = 0;
3411:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3412:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3413:../uvc.c      **** 	uint8_t i;
3414:../uvc.c      **** 	uint16_t delaytime;
3415:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3416:../uvc.c      **** 
3417:../uvc.c      **** #if 0 //for test the command queue
3418:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3419:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3420:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3421:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3422:../uvc.c      **** 		lcCmdDes += 1;
3423:../uvc.c      **** 	}
3424:../uvc.c      **** #endif
3425:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3426:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3426 0
  36 0004 10229FE5 		ldr	r2, .L22
3410:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3410 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3403:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3403 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3426 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3410:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3410 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3426 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3427:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3427 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3428:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3428 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3429:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3429 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3430:../uvc.c      **** 
3431:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3431 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3432:../uvc.c      ****         /* Allow other ready threads to run. */
3433:../uvc.c      **** 
3434:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3434 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3431:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3431 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3435:../uvc.c      **** 	}
3436:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3436 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3437:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3438:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3439:../uvc.c      **** 	//CyU3PThreadSleep(100);
3440:../uvc.c      **** 	//SetCurCmd();
3441:../uvc.c      **** 	/*********** the loop of the thread ***********/
3442:../uvc.c      **** 	for(;;){
3443:../uvc.c      **** 
3444:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3444 0
 101 0098 0060E0E3 		mvn	r6, #0
3445:../uvc.c      **** /*  // for test GPIO output
3446:../uvc.c      **** 		if(trigger)
3447:../uvc.c      **** 		{
3448:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3449:../uvc.c      **** 			{
3450:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3451:../uvc.c      **** 			}
3452:../uvc.c      **** 
3453:../uvc.c      **** 		}else{
3454:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3455:../uvc.c      **** 			{
3456:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3457:../uvc.c      **** 			}
3458:../uvc.c      **** 
3459:../uvc.c      **** 		}
3460:../uvc.c      **** */
3461:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3462:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3463:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3464:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3465:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3466:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3467:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3468:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3469:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3470:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3471:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3472:../uvc.c      **** #endif
3473:../uvc.c      **** 				}
3474:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3475:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3476:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3477:../uvc.c      **** 			}
3478:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3479:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3480:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3481:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3482:../uvc.c      **** 
3483:../uvc.c      **** 				/*
3484:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3485:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3486:../uvc.c      **** 				*/
3487:../uvc.c      **** 
3488:../uvc.c      **** 				/* find a available command */
3489:../uvc.c      **** 				i = 0;
3490:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3490 0
 103 009c 0090A0E3 		mov	r9, #0
3491:../uvc.c      **** 					i++;
3492:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3493:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3494:../uvc.c      **** 				}
3495:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3496:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3497:../uvc.c      **** 					i = lcCmdDes->curNum;
3498:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3499:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3500:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3501:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3502:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3503:../uvc.c      **** 						case 20:
3504:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3505:../uvc.c      **** 							delaytime = 500;
3506:../uvc.c      **** 							break;
3507:../uvc.c      **** 						case 21:
3508:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3509:../uvc.c      **** 							delaytime = 500;
3510:../uvc.c      **** 							break;
3511:../uvc.c      **** 						case 22:
3512:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3513:../uvc.c      **** 							delaytime = 300;
3514:../uvc.c      **** 							break;
3515:../uvc.c      **** 						case 23:
3516:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3517:../uvc.c      **** 							delaytime = 300;
3518:../uvc.c      **** 							break;
3519:../uvc.c      **** 						default:
3520:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3521:../uvc.c      **** 							break;
3522:../uvc.c      **** 					}
3523:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3524:../uvc.c      **** 					/** timer's ticket modify **/
3525:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3526:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3527:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3528:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3529:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3530:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3531:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3532:../uvc.c      **** #endif
3533:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3534:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3535:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3536:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3537:../uvc.c      **** 						}else{
3538:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3539:../uvc.c      **** 						}
3540:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3541:../uvc.c      **** 					}else{
3542:../uvc.c      **** 						lcCmdDes->curNum ++;
3543:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3543 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3444:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3444 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3461:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3461 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3478:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3478 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3480:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3480 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3481:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3481 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3490:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3490 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3492:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3492 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3491:../uvc.c      **** 					i++;
 140              		.loc 1 3491 0
 141 00f4 011083E2 		add	r1, r3, #1
3490:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3490 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3491:../uvc.c      **** 					i++;
 144              		.loc 1 3491 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3490:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3490 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3496:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3496 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3498:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3498 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3502:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3502 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3498:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3498 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3502:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3502 0
 166 0128 14C042E2 		sub	ip, r2, #20
3498:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3498 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3499:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3499 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3500:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3500 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3501:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3501 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3502:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3502 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
3516:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 3516 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3518:../uvc.c      **** 							break;
 193              		.loc 1 3518 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
3525:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3525 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3526:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3526 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3533:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3533 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3542:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3542 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3543 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3533:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3533 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3544:../uvc.c      **** 					}
3545:../uvc.c      **** 				}else{
3546:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3547:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3548:../uvc.c      **** 				}
3549:../uvc.c      **** 			}
3550:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3550 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3551:../uvc.c      **** /*
3552:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3553:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3554:../uvc.c      **** */
3555:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3556:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3557:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3558:../uvc.c      **** #endif
3559:../uvc.c      **** 
3560:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3561:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3562:../uvc.c      **** #if 0
3563:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3564:../uvc.c      **** 
3565:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3566:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3567:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3568:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3569:../uvc.c      **** 			    i = 0;
3570:../uvc.c      **** 				 switch(cmdCopyIdx)
3571:../uvc.c      **** 				 {
3572:../uvc.c      **** 					 case BrgtCtlID1:
3573:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3574:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3575:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3576:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3577:../uvc.c      **** 							 i++;
3578:../uvc.c      **** 						 }
3579:../uvc.c      **** 						 else{
3580:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3581:../uvc.c      **** 						 }
3582:../uvc.c      **** 
3583:../uvc.c      **** 						 CyU3PBusyWait(500);
3584:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3585:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3586:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3587:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3588:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3589:../uvc.c      **** 						 }
3590:../uvc.c      **** 						 else{
3591:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3592:../uvc.c      **** 						 }
3593:../uvc.c      **** 						 break;
3594:../uvc.c      **** 					 case HueCtlID5:
3595:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3596:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3597:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3598:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3599:../uvc.c      **** 						 }
3600:../uvc.c      **** 						 else{
3601:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3602:../uvc.c      **** 						 }
3603:../uvc.c      **** 						 break;
3604:../uvc.c      **** 					 case SaturCtlID6:
3605:../uvc.c      **** 					 case WBTLevCtlID10:
3606:../uvc.c      **** 					 default:
3607:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3608:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3609:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3610:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3611:../uvc.c      **** 						 }
3612:../uvc.c      **** 						 else{
3613:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3614:../uvc.c      **** 						 }
3615:../uvc.c      **** 						 break;
3616:../uvc.c      **** 				 }
3617:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3618:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3619:../uvc.c      **** 			}
3620:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3621:../uvc.c      **** #endif
3622:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3623:../uvc.c      **** 		/* Allow other ready threads to run. */
3624:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3625:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3625 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3626:../uvc.c      **** 		}
 224              		.loc 1 3626 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
3508:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 3508 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3510:../uvc.c      **** 							break;
 232              		.loc 1 3510 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3520:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3520 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3521:../uvc.c      **** 							break;
 241              		.loc 1 3521 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
3504:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 3504 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
3506:../uvc.c      **** 							break;
 249              		.loc 1 3506 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
3546:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 3546 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
3547:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 3547 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
3535:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 3535 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3534:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 3534 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
3535:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 3535 0
 269 01f0 1F005CE3 		cmp	ip, #31
3536:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 3536 0
 271 01f4 20C04C82 		subhi	ip, ip, #32
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3538:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3538 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3536:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 3536 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3538:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 3538 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3536:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 3536 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
3538:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 3538 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
3540:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 3540 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE25:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB17:
2180:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2180 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2182:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2182 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2183:../uvc.c      **** }
 318              		.loc 1 2183 0
2182:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2182 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE17:
 328              		.align	2
 329              		.global	CyFxUvcApplnDmaCallback
 331              	CyFxUvcApplnDmaCallback:
 332              	.LFB10:
1470:../uvc.c      **** {
 333              		.loc 1 1470 0
 334              		.cfi_startproc
 335              		@ args = 0, pretend = 0, frame = 0
 336              		@ frame_needed = 0, uses_anonymous_args = 0
 337              	.LVL31:
1474:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 338              		.loc 1 1474 0
 339 0250 080051E3 		cmp	r1, #8
1470:../uvc.c      **** {
 340              		.loc 1 1470 0
 341 0254 30402DE9 		stmfd	sp!, {r4, r5, lr}
 342              	.LCFI2:
 343              		.cfi_def_cfa_offset 12
 344 0258 0240A0E1 		mov	r4, r2
 345              		.cfi_offset 14, -4
 346              		.cfi_offset 5, -8
 347              		.cfi_offset 4, -12
 348 025c 0CD04DE2 		sub	sp, sp, #12
 349              	.LCFI3:
 350              		.cfi_def_cfa_offset 24
1474:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 351              		.loc 1 1474 0
 352 0260 0B00000A 		beq	.L32
1503:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 353              		.loc 1 1503 0
 354 0264 100051E3 		cmp	r1, #16
 355 0268 0700001A 		bne	.L27
1505:../uvc.c      ****         consCount++;
 356              		.loc 1 1505 0
 357 026c 04319FE5 		ldr	r3, .L34
1506:../uvc.c      ****         streamingStarted = CyTrue;
 358              		.loc 1 1506 0
 359 0270 0120A0E3 		mov	r2, #1
 360              	.LVL32:
1505:../uvc.c      ****         consCount++;
 361              		.loc 1 1505 0
 362 0274 B0C3D3E1 		ldrh	ip, [r3, #48]
1506:../uvc.c      ****         streamingStarted = CyTrue;
 363              		.loc 1 1506 0
 364 0278 342083E5 		str	r2, [r3, #52]
1505:../uvc.c      ****         consCount++;
 365              		.loc 1 1505 0
 366 027c 02008CE0 		add	r0, ip, r2
 367              	.LVL33:
 368 0280 0018A0E1 		mov	r1, r0, asl #16
 369              	.LVL34:
 370 0284 2128A0E1 		mov	r2, r1, lsr #16
 371 0288 B023C3E1 		strh	r2, [r3, #48]	@ movhi
 372              	.L27:
1508:../uvc.c      **** }
 373              		.loc 1 1508 0
 374 028c 0CD08DE2 		add	sp, sp, #12
 375 0290 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 376              	.LVL35:
 377              	.L32:
1476:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 378              		.loc 1 1476 0
 379 0294 B420D2E1 		ldrh	r2, [r2, #4]
 380 0298 DC309FE5 		ldr	r3, .L34+4
 381 029c 030052E1 		cmp	r2, r3
 382 02a0 2900000A 		beq	.L33
1484:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 383              		.loc 1 1484 0
 384 02a4 005094E5 		ldr	r5, [r4, #0]
 385              	.LVL36:
 386              	.LBB12:
 387              	.LBB13:
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 388              		.loc 1 1219 0
 389 02a8 D0109FE5 		ldr	r1, .L34+8
 390              	.LVL37:
 391 02ac 0C0045E2 		sub	r0, r5, #12
 392              	.LVL38:
 393 02b0 0C20A0E3 		mov	r2, #12
 394 02b4 FEFFFFEB 		bl	CyU3PMemCopy
 395              	.LVL39:
1224:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 396              		.loc 1 1224 0
 397 02b8 0BC055E5 		ldrb	ip, [r5, #-11]	@ zero_extendqisi2
 398              	.LBE13:
 399              	.LBE12:
1485:../uvc.c      ****                 pb++;
 400              		.loc 1 1485 0
 401 02bc B4309FE5 		ldr	r3, .L34
 402              	.LBB15:
 403              	.LBB14:
1224:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 404              		.loc 1 1224 0
 405 02c0 02108CE3 		orr	r1, ip, #2
 406 02c4 0B1045E5 		strb	r1, [r5, #-11]
 407              	.LBE14:
 408              	.LBE15:
1485:../uvc.c      ****                 pb++;
 409              		.loc 1 1485 0
 410 02c8 BA02D3E1 		ldrh	r0, [r3, #42]
1486:../uvc.c      ****                 pbc = input->buffer_p.count;
 411              		.loc 1 1486 0
 412 02cc B410D4E1 		ldrh	r1, [r4, #4]
1485:../uvc.c      ****                 pb++;
 413              		.loc 1 1485 0
 414 02d0 012080E2 		add	r2, r0, #1
 415 02d4 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
1486:../uvc.c      ****                 pbc = input->buffer_p.count;
 416              		.loc 1 1486 0
 417 02d8 BC12C3E1 		strh	r1, [r3, #44]	@ movhi
 418              	.LVL40:
 419              	.L30:
1491:../uvc.c      ****             prodCount++;
 420              		.loc 1 1491 0
 421 02dc BEE2D3E1 		ldrh	lr, [r3, #46]
1492:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 422              		.loc 1 1492 0
 423 02e0 0C1081E2 		add	r1, r1, #12
1491:../uvc.c      ****             prodCount++;
 424              		.loc 1 1491 0
 425 02e4 01C08EE2 		add	ip, lr, #1
 426 02e8 0C08A0E1 		mov	r0, ip, asl #16
 427 02ec 20E8A0E1 		mov	lr, r0, lsr #16
1492:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 428              		.loc 1 1492 0
 429 02f0 0128A0E1 		mov	r2, r1, asl #16
 430 02f4 2218A0E1 		mov	r1, r2, lsr #16
 431 02f8 84009FE5 		ldr	r0, .L34+12
 432 02fc 0020A0E3 		mov	r2, #0
1491:../uvc.c      ****             prodCount++;
 433              		.loc 1 1491 0
 434 0300 BEE2C3E1 		strh	lr, [r3, #46]	@ movhi
1492:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 435              		.loc 1 1492 0
 436 0304 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 437              	.LVL41:
1491:../uvc.c      ****             prodCount++;
 438              		.loc 1 1491 0
 439 0308 68109FE5 		ldr	r1, .L34
1495:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 440              		.loc 1 1495 0
 441 030c 002050E2 		subs	r2, r0, #0
 442 0310 DDFFFF0A 		beq	.L27
1497:../uvc.c      ****                 prodCount--;
 443              		.loc 1 1497 0
 444 0314 BEC2D1E1 		ldrh	ip, [r1, #46]
1498:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 445              		.loc 1 1498 0
 446 0318 B430D4E1 		ldrh	r3, [r4, #4]
1497:../uvc.c      ****                 prodCount--;
 447              		.loc 1 1497 0
 448 031c 01004CE2 		sub	r0, ip, #1
 449              	.LVL42:
 450 0320 00E8A0E1 		mov	lr, r0, asl #16
 451 0324 2EC8A0E1 		mov	ip, lr, lsr #16
 452 0328 BEC2C1E1 		strh	ip, [r1, #46]	@ movhi
1498:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 453              		.loc 1 1498 0
 454 032c BEE2D1E1 		ldrh	lr, [r1, #46]
 455 0330 B003D1E1 		ldrh	r0, [r1, #48]
 456 0334 4C109FE5 		ldr	r1, .L34+16
 457 0338 0EC060E0 		rsb	ip, r0, lr
 458 033c 0400A0E3 		mov	r0, #4
 459 0340 00C08DE5 		str	ip, [sp, #0]
 460 0344 FEFFFFEB 		bl	CyU3PDebugPrint
 461              	.LVL43:
 462 0348 CFFFFFEA 		b	.L27
 463              	.LVL44:
 464              	.L33:
1478:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 465              		.loc 1 1478 0
 466 034c 00E094E5 		ldr	lr, [r4, #0]
 467              	.LBB16:
 468              	.LBB17:
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 469              		.loc 1 1219 0
 470 0350 28109FE5 		ldr	r1, .L34+8
 471              	.LVL45:
 472 0354 0C004EE2 		sub	r0, lr, #12
 473              	.LVL46:
 474 0358 0C20A0E3 		mov	r2, #12
 475 035c FEFFFFEB 		bl	CyU3PMemCopy
 476              	.LVL47:
 477              	.LBE17:
 478              	.LBE16:
1479:../uvc.c      ****                 fb++;
 479              		.loc 1 1479 0
 480 0360 10309FE5 		ldr	r3, .L34
 481 0364 B410D4E1 		ldrh	r1, [r4, #4]
 482 0368 B8C2D3E1 		ldrh	ip, [r3, #40]
 483 036c 01008CE2 		add	r0, ip, #1
 484 0370 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 485 0374 D8FFFFEA 		b	.L30
 486              	.L35:
 487              		.align	2
 488              	.L34:
 489 0378 00000000 		.word	.LANCHOR0
 490 037c F03F0000 		.word	16368
 491 0380 80040000 		.word	.LANCHOR1+1152
 492 0384 00000000 		.word	glChHandleUVCStream
 493 0388 38000000 		.word	.LC2
 494              		.cfi_endproc
 495              	.LFE10:
 497              		.align	2
 499              	CyFxUVCApplnUSBEventCB:
 500              	.LFB8:
1273:../uvc.c      **** {
 501              		.loc 1 1273 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 8
 504              		@ frame_needed = 0, uses_anonymous_args = 0
 505              	.LVL48:
1274:../uvc.c      ****     switch (evtype)
 506              		.loc 1 1274 0
 507 038c 020050E3 		cmp	r0, #2
1273:../uvc.c      **** {
 508              		.loc 1 1273 0
 509 0390 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 510              	.LCFI4:
 511              		.cfi_def_cfa_offset 16
 512 0394 0130A0E1 		mov	r3, r1
 513 0398 10D04DE2 		sub	sp, sp, #16
 514              	.LCFI5:
 515              		.cfi_def_cfa_offset 32
1273:../uvc.c      **** {
 516              		.loc 1 1273 0
 517 039c 0040A0E1 		mov	r4, r0
 518              		.cfi_offset 14, -4
 519              		.cfi_offset 6, -8
 520              		.cfi_offset 5, -12
 521              		.cfi_offset 4, -16
1274:../uvc.c      ****     switch (evtype)
 522              		.loc 1 1274 0
 523 03a0 3600000A 		beq	.L39
 524 03a4 040050E3 		cmp	r0, #4
 525 03a8 1F00000A 		beq	.L40
 526 03ac 010050E3 		cmp	r0, #1
 527 03b0 0100000A 		beq	.L42
 528              	.LVL49:
 529              	.L36:
1310:../uvc.c      **** }
 530              		.loc 1 1310 0
 531 03b4 10D08DE2 		add	sp, sp, #16
 532 03b8 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 533              	.LVL50:
 534              	.L42:
1295:../uvc.c      ****             gpif_initialized = 0;
 535              		.loc 1 1295 0
 536 03bc 28519FE5 		ldr	r5, .L43
1293:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 537              		.loc 1 1293 0
 538 03c0 0020A0E1 		mov	r2, r0
 539 03c4 24119FE5 		ldr	r1, .L43+4
 540              	.LVL51:
 541 03c8 0400A0E3 		mov	r0, #4
 542              	.LVL52:
 543 03cc FEFFFFEB 		bl	CyU3PDebugPrint
1294:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 544              		.loc 1 1294 0
 545 03d0 0400A0E1 		mov	r0, r4
 546 03d4 FEFFFFEB 		bl	CyU3PGpifDisable
1295:../uvc.c      ****             gpif_initialized = 0;
 547              		.loc 1 1295 0
 548 03d8 00C0A0E3 		mov	ip, #0
 549              	.LBB24:
 550              	.LBB25:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 551              		.loc 1 1257 0
 552 03dc 0410A0E1 		mov	r1, r4
 553 03e0 0500A0E1 		mov	r0, r5
 554 03e4 0220A0E3 		mov	r2, #2
 555 03e8 0C308DE2 		add	r3, sp, #12
 556              	.LBE25:
 557              	.LBE24:
1295:../uvc.c      ****             gpif_initialized = 0;
 558              		.loc 1 1295 0
 559 03ec 38C085E5 		str	ip, [r5, #56]
1296:../uvc.c      ****             isUsbConnected = CyFalse;
 560              		.loc 1 1296 0
 561 03f0 3CC085E5 		str	ip, [r5, #60]
1297:../uvc.c      ****             streamingStarted = CyFalse;
 562              		.loc 1 1297 0
 563 03f4 34C085E5 		str	ip, [r5, #52]
 564              	.LBB27:
 565              	.LBB26:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 566              		.loc 1 1257 0
 567 03f8 00C08DE5 		str	ip, [sp, #0]
 568 03fc FEFFFFEB 		bl	_txe_event_flags_get
 569 0400 004050E2 		subs	r4, r0, #0
 570 0404 EAFFFF1A 		bne	.L36
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 571              		.loc 1 1260 0
 572 0408 0110E0E3 		mvn	r1, #1
 573 040c 0220A0E3 		mov	r2, #2
 574 0410 0500A0E1 		mov	r0, r5
 575              	.L41:
 576 0414 FEFFFFEB 		bl	_txe_event_flags_set
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 577              		.loc 1 1263 0
 578 0418 0500A0E1 		mov	r0, r5
 579 041c 0210A0E3 		mov	r1, #2
 580 0420 0420A0E1 		mov	r2, r4
 581 0424 FEFFFFEB 		bl	_txe_event_flags_set
 582 0428 E1FFFFEA 		b	.L36
 583              	.LVL53:
 584              	.L40:
 585              	.LBE26:
 586              	.LBE27:
1279:../uvc.c      ****             gpif_initialized = 0;
 587              		.loc 1 1279 0
 588 042c B8509FE5 		ldr	r5, .L43
1277:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 589              		.loc 1 1277 0
 590 0430 BC109FE5 		ldr	r1, .L43+8
 591              	.LVL54:
 592 0434 0020A0E1 		mov	r2, r0
 593 0438 FEFFFFEB 		bl	CyU3PDebugPrint
 594              	.LVL55:
1278:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 595              		.loc 1 1278 0
 596 043c 0100A0E3 		mov	r0, #1
 597 0440 FEFFFFEB 		bl	CyU3PGpifDisable
1279:../uvc.c      ****             gpif_initialized = 0;
 598              		.loc 1 1279 0
 599 0444 00C0A0E3 		mov	ip, #0
 600              	.LBB28:
 601              	.LBB29:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 602              		.loc 1 1257 0
 603 0448 0110A0E3 		mov	r1, #1
 604 044c 0220A0E3 		mov	r2, #2
 605 0450 0500A0E1 		mov	r0, r5
 606 0454 0C308DE2 		add	r3, sp, #12
 607              	.LBE29:
 608              	.LBE28:
1279:../uvc.c      ****             gpif_initialized = 0;
 609              		.loc 1 1279 0
 610 0458 38C085E5 		str	ip, [r5, #56]
1280:../uvc.c      ****             streamingStarted = CyFalse;
 611              		.loc 1 1280 0
 612 045c 34C085E5 		str	ip, [r5, #52]
 613              	.LBB31:
 614              	.LBB30:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 615              		.loc 1 1257 0
 616 0460 00C08DE5 		str	ip, [sp, #0]
 617 0464 FEFFFFEB 		bl	_txe_event_flags_get
 618 0468 004050E2 		subs	r4, r0, #0
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 619              		.loc 1 1260 0
 620 046c 0500A001 		moveq	r0, r5
 621 0470 0110E003 		mvneq	r1, #1
 622 0474 0220A003 		moveq	r2, #2
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 623              		.loc 1 1257 0
 624 0478 CDFFFF1A 		bne	.L36
 625 047c E4FFFFEA 		b	.L41
 626              	.LVL56:
 627              	.L39:
 628              	.LBE30:
 629              	.LBE31:
1287:../uvc.c      ****             gpif_initialized = 0;
 630              		.loc 1 1287 0
 631 0480 64509FE5 		ldr	r5, .L43
1285:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 632              		.loc 1 1285 0
 633 0484 0020A0E1 		mov	r2, r0
 634 0488 68109FE5 		ldr	r1, .L43+12
 635              	.LVL57:
 636 048c 0400A0E3 		mov	r0, #4
 637              	.LVL58:
 638 0490 FEFFFFEB 		bl	CyU3PDebugPrint
1286:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 639              		.loc 1 1286 0
 640 0494 0100A0E3 		mov	r0, #1
 641 0498 FEFFFFEB 		bl	CyU3PGpifDisable
1287:../uvc.c      ****             gpif_initialized = 0;
 642              		.loc 1 1287 0
 643 049c 0060A0E3 		mov	r6, #0
 644              	.LBB32:
 645              	.LBB33:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 646              		.loc 1 1257 0
 647 04a0 0500A0E1 		mov	r0, r5
 648 04a4 0110A0E3 		mov	r1, #1
 649 04a8 0420A0E1 		mov	r2, r4
 650 04ac 0C308DE2 		add	r3, sp, #12
 651              	.LBE33:
 652              	.LBE32:
1287:../uvc.c      ****             gpif_initialized = 0;
 653              		.loc 1 1287 0
 654 04b0 386085E5 		str	r6, [r5, #56]
1288:../uvc.c      ****             streamingStarted = CyFalse;
 655              		.loc 1 1288 0
 656 04b4 346085E5 		str	r6, [r5, #52]
 657              	.LBB35:
 658              	.LBB34:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 659              		.loc 1 1257 0
 660 04b8 00608DE5 		str	r6, [sp, #0]
 661 04bc FEFFFFEB 		bl	_txe_event_flags_get
 662 04c0 006050E2 		subs	r6, r0, #0
 663 04c4 BAFFFF1A 		bne	.L36
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 664              		.loc 1 1260 0
 665 04c8 0420A0E1 		mov	r2, r4
 666 04cc 0500A0E1 		mov	r0, r5
 667 04d0 0110E0E3 		mvn	r1, #1
 668 04d4 FEFFFFEB 		bl	_txe_event_flags_set
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 669              		.loc 1 1263 0
 670 04d8 0500A0E1 		mov	r0, r5
 671 04dc 0410A0E1 		mov	r1, r4
 672 04e0 0620A0E1 		mov	r2, r6
 673 04e4 FEFFFFEB 		bl	_txe_event_flags_set
 674 04e8 B1FFFFEA 		b	.L36
 675              	.L44:
 676              		.align	2
 677              	.L43:
 678 04ec 00000000 		.word	.LANCHOR0
 679 04f0 C4000000 		.word	.LC5
 680 04f4 80000000 		.word	.LC3
 681 04f8 A0000000 		.word	.LC4
 682              	.LBE34:
 683              	.LBE35:
 684              		.cfi_endproc
 685              	.LFE8:
 687              		.align	2
 689              	CyFxUVCApplnUSBSetupCB:
 690              	.LFB9:
1318:../uvc.c      **** {
 691              		.loc 1 1318 0
 692              		.cfi_startproc
 693              		@ args = 0, pretend = 0, frame = 8
 694              		@ frame_needed = 0, uses_anonymous_args = 0
 695              	.LVL59:
1323:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 696              		.loc 1 1323 0
 697 04fc C0329FE5 		ldr	r3, .L70
1318:../uvc.c      **** {
 698              		.loc 1 1318 0
 699 0500 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 700              	.LCFI6:
 701              		.cfi_def_cfa_offset 24
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 702              		.loc 1 1324 0
 703 0504 BCC29FE5 		ldr	ip, .L70+4
1323:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 704              		.loc 1 1323 0
 705 0508 FF4000E2 		and	r4, r0, #255
 706              		.cfi_offset 14, -4
 707              		.cfi_offset 8, -8
 708              		.cfi_offset 7, -12
 709              		.cfi_offset 6, -16
 710              		.cfi_offset 5, -20
 711              		.cfi_offset 4, -24
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 712              		.loc 1 1324 0
 713 050c FF8C00E2 		and	r8, r0, #65280
1325:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 714              		.loc 1 1325 0
 715 0510 2078A0E1 		mov	r7, r0, lsr #16
1323:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 716              		.loc 1 1323 0
 717 0514 0040C3E5 		strb	r4, [r3, #0]
1325:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 718              		.loc 1 1325 0
 719 0518 AC229FE5 		ldr	r2, .L70+8
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 720              		.loc 1 1326 0
 721 051c AC029FE5 		ldr	r0, .L70+12
 722              	.LVL60:
1327:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 723              		.loc 1 1327 0
 724 0520 AC329FE5 		ldr	r3, .L70+16
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 725              		.loc 1 1326 0
 726 0524 0158A0E1 		mov	r5, r1, asl #16
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 727              		.loc 1 1324 0
 728 0528 2884A0E1 		mov	r8, r8, lsr #8
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 729              		.loc 1 1326 0
 730 052c 2558A0E1 		mov	r5, r5, lsr #16
1327:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 731              		.loc 1 1327 0
 732 0530 2118A0E1 		mov	r1, r1, lsr #16
 733              	.LVL61:
1330:../uvc.c      ****     switch (bmReqType)
 734              		.loc 1 1330 0
 735 0534 020054E3 		cmp	r4, #2
1318:../uvc.c      **** {
 736              		.loc 1 1318 0
 737 0538 10D04DE2 		sub	sp, sp, #16
 738              	.LCFI7:
 739              		.cfi_def_cfa_offset 40
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 740              		.loc 1 1324 0
 741 053c 0080CCE5 		strb	r8, [ip, #0]
1325:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 742              		.loc 1 1325 0
 743 0540 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 744              		.loc 1 1326 0
 745 0544 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1327:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 746              		.loc 1 1327 0
 747 0548 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1330:../uvc.c      ****     switch (bmReqType)
 748              		.loc 1 1330 0
 749 054c 4F00000A 		beq	.L48
 750 0550 0600009A 		bls	.L66
 751 0554 210054E3 		cmp	r4, #33
 752 0558 3A00000A 		beq	.L49
 753 055c A10054E3 		cmp	r4, #161
 754 0560 3800000A 		beq	.L49
 755              	.L63:
1319:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 756              		.loc 1 1319 0
 757 0564 0000A0E3 		mov	r0, #0
 758              	.LVL62:
 759              	.L46:
1457:../uvc.c      **** }
 760              		.loc 1 1457 0
 761 0568 10D08DE2 		add	sp, sp, #16
 762 056c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 763              	.LVL63:
 764              	.L66:
1330:../uvc.c      ****     switch (bmReqType)
 765              		.loc 1 1330 0
 766 0570 010054E3 		cmp	r4, #1
 767 0574 FAFFFF1A 		bne	.L63
1370:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 768              		.loc 1 1370 0
 769 0578 0B0058E3 		cmp	r8, #11
 770 057c F8FFFF1A 		bne	.L63
1374:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 771              		.loc 1 1374 0
 772 0580 010055E3 		cmp	r5, #1
 773 0584 F6FFFF1A 		bne	.L63
1374:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 774              		.loc 1 1374 0 is_stmt 0 discriminator 1
 775 0588 000057E3 		cmp	r7, #0
 776 058c F4FFFF1A 		bne	.L63
1379:../uvc.c      ****                     gpif_initialized = 0;
 777              		.loc 1 1379 0 is_stmt 1
 778 0590 40429FE5 		ldr	r4, .L70+20
1377:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 779              		.loc 1 1377 0
 780 0594 40129FE5 		ldr	r1, .L70+24
 781 0598 0400A0E3 		mov	r0, #4
 782 059c FEFFFFEB 		bl	CyU3PDebugPrint
1378:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 783              		.loc 1 1378 0
 784 05a0 0500A0E1 		mov	r0, r5
 785 05a4 FEFFFFEB 		bl	CyU3PGpifDisable
1382:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 786              		.loc 1 1382 0
 787 05a8 0510A0E1 		mov	r1, r5
 788 05ac 8300A0E3 		mov	r0, #131
1379:../uvc.c      ****                     gpif_initialized = 0;
 789              		.loc 1 1379 0
 790 05b0 387084E5 		str	r7, [r4, #56]
1380:../uvc.c      ****                     streamingStarted = CyFalse;
 791              		.loc 1 1380 0
 792 05b4 347084E5 		str	r7, [r4, #52]
1382:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 793              		.loc 1 1382 0
 794 05b8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1383:../uvc.c      ****                     CyU3PBusyWait (100);
 795              		.loc 1 1383 0
 796 05bc 6400A0E3 		mov	r0, #100
 797 05c0 FEFFFFEB 		bl	CyU3PBusyWait
1386:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 798              		.loc 1 1386 0
 799 05c4 14029FE5 		ldr	r0, .L70+28
 800 05c8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1387:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 801              		.loc 1 1387 0
 802 05cc 8300A0E3 		mov	r0, #131
 803 05d0 FEFFFFEB 		bl	CyU3PUsbFlushEp
1388:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 804              		.loc 1 1388 0
 805 05d4 0710A0E1 		mov	r1, r7
 806 05d8 8300A0E3 		mov	r0, #131
 807 05dc FEFFFFEB 		bl	CyU3PUsbSetEpNak
1389:../uvc.c      ****                     CyU3PBusyWait (100);
 808              		.loc 1 1389 0
 809 05e0 6400A0E3 		mov	r0, #100
 810 05e4 FEFFFFEB 		bl	CyU3PBusyWait
1392:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 811              		.loc 1 1392 0
 812 05e8 0710A0E1 		mov	r1, r7
 813 05ec 0520A0E1 		mov	r2, r5
 814 05f0 8300A0E3 		mov	r0, #131
 815 05f4 FEFFFFEB 		bl	CyU3PUsbStall
 816              	.LVL64:
1395:../uvc.c      ****                     CyU3PUsbAckSetup ();
 817              		.loc 1 1395 0
 818 05f8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1397:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 819              		.loc 1 1397 0
 820 05fc 405084E5 		str	r5, [r4, #64]
 821              	.LBB40:
 822              	.LBB41:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 823              		.loc 1 1257 0
 824 0600 0400A0E1 		mov	r0, r4
 825 0604 0510A0E1 		mov	r1, r5
 826 0608 0220A0E3 		mov	r2, #2
 827 060c 0C308DE2 		add	r3, sp, #12
 828 0610 00708DE5 		str	r7, [sp, #0]
 829 0614 FEFFFFEB 		bl	_txe_event_flags_get
 830 0618 006050E2 		subs	r6, r0, #0
 831 061c 2E00001A 		bne	.L61
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 832              		.loc 1 1260 0
 833 0620 0110E0E3 		mvn	r1, #1
 834 0624 0220A0E3 		mov	r2, #2
 835 0628 0400A0E1 		mov	r0, r4
 836 062c FEFFFFEB 		bl	_txe_event_flags_set
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 837              		.loc 1 1263 0
 838 0630 0400A0E1 		mov	r0, r4
 839 0634 0210A0E3 		mov	r1, #2
 840 0638 0620A0E1 		mov	r2, r6
 841 063c FEFFFFEB 		bl	_txe_event_flags_set
1393:../uvc.c      ****                     uvcHandleReq = CyTrue;
 842              		.loc 1 1393 0
 843 0640 0500A0E1 		mov	r0, r5
 844 0644 C7FFFFEA 		b	.L46
 845              	.LVL65:
 846              	.L49:
 847              	.LBE41:
 848              	.LBE40:
1335:../uvc.c      ****             switch (wIndex & 0xFF)
 849              		.loc 1 1335 0
 850 0648 FF5015E2 		ands	r5, r5, #255
 851 064c 1A00001A 		bne	.L67
 852              	.LVL66:
1340:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 853              		.loc 1 1340 0
 854 0650 0520A0E1 		mov	r2, r5
 855 0654 7C019FE5 		ldr	r0, .L70+20
 856 0658 0410A0E3 		mov	r1, #4
 857 065c FEFFFFEB 		bl	_txe_event_flags_set
 858              	.LVL67:
1342:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 859              		.loc 1 1342 0
 860 0660 002050E2 		subs	r2, r0, #0
1339:../uvc.c      ****                         uvcHandleReq = CyTrue;
 861              		.loc 1 1339 0
 862 0664 0100A003 		moveq	r0, #1
 863              	.LVL68:
1342:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 864              		.loc 1 1342 0
 865 0668 BEFFFF0A 		beq	.L46
1344:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 866              		.loc 1 1344 0
 867 066c 70119FE5 		ldr	r1, .L70+32
 868 0670 0400A0E3 		mov	r0, #4
 869 0674 FEFFFFEB 		bl	CyU3PDebugPrint
 870              	.LVL69:
1345:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 871              		.loc 1 1345 0
 872 0678 0500A0E1 		mov	r0, r5
 873 067c 0110A0E3 		mov	r1, #1
 874 0680 0520A0E1 		mov	r2, r5
 875 0684 FEFFFFEB 		bl	CyU3PUsbStall
1339:../uvc.c      ****                         uvcHandleReq = CyTrue;
 876              		.loc 1 1339 0
 877 0688 0100A0E3 		mov	r0, #1
 878 068c B5FFFFEA 		b	.L46
 879              	.LVL70:
 880              	.L48:
1405:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 881              		.loc 1 1405 0
 882 0690 010058E3 		cmp	r8, #1
 883 0694 B2FFFF1A 		bne	.L63
1407:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 884              		.loc 1 1407 0
 885 0698 830055E3 		cmp	r5, #131
 886 069c B0FFFF1A 		bne	.L63
1413:../uvc.c      ****                     if (streamingStarted == CyTrue)
 887              		.loc 1 1413 0
 888 06a0 30719FE5 		ldr	r7, .L70+20
 889 06a4 346097E5 		ldr	r6, [r7, #52]
 890 06a8 010056E3 		cmp	r6, #1
 891 06ac 1500000A 		beq	.L68
 892              	.LVL71:
1445:../uvc.c      ****                         CyU3PUsbAckSetup ();
 893              		.loc 1 1445 0
 894 06b0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1444:../uvc.c      ****                         uvcHandleReq = CyTrue;
 895              		.loc 1 1444 0
 896 06b4 0800A0E1 		mov	r0, r8
 897 06b8 AAFFFFEA 		b	.L46
 898              	.LVL72:
 899              	.L67:
1335:../uvc.c      ****             switch (wIndex & 0xFF)
 900              		.loc 1 1335 0
 901 06bc 010055E3 		cmp	r5, #1
 902 06c0 A7FFFF1A 		bne	.L63
 903              	.LVL73:
1353:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 904              		.loc 1 1353 0
 905 06c4 0020A0E3 		mov	r2, #0
 906 06c8 08019FE5 		ldr	r0, .L70+20
 907 06cc 0810A0E3 		mov	r1, #8
 908 06d0 FEFFFFEB 		bl	_txe_event_flags_set
 909              	.LVL74:
1355:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 910              		.loc 1 1355 0
 911 06d4 002050E2 		subs	r2, r0, #0
 912 06d8 0100001A 		bne	.L69
 913              	.LVL75:
 914              	.L61:
 915              	.LBB43:
 916              	.LBB42:
1393:../uvc.c      ****                     uvcHandleReq = CyTrue;
 917              		.loc 1 1393 0
 918 06dc 0500A0E1 		mov	r0, r5
 919 06e0 A0FFFFEA 		b	.L46
 920              	.LVL76:
 921              	.L69:
 922              	.LBE42:
 923              	.LBE43:
1358:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 924              		.loc 1 1358 0
 925 06e4 FC109FE5 		ldr	r1, .L70+36
 926 06e8 0400A0E3 		mov	r0, #4
 927              	.LVL77:
 928 06ec FEFFFFEB 		bl	CyU3PDebugPrint
 929              	.LVL78:
1359:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 930              		.loc 1 1359 0
 931 06f0 0000A0E3 		mov	r0, #0
 932 06f4 0510A0E1 		mov	r1, r5
 933 06f8 0020A0E1 		mov	r2, r0
 934 06fc FEFFFFEB 		bl	CyU3PUsbStall
1352:../uvc.c      ****                         uvcHandleReq = CyTrue;
 935              		.loc 1 1352 0
 936 0700 0500A0E1 		mov	r0, r5
 937 0704 97FFFFEA 		b	.L46
 938              	.LVL79:
 939              	.L68:
1415:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 940              		.loc 1 1415 0
 941 0708 DC109FE5 		ldr	r1, .L70+40
 942 070c 0400A0E3 		mov	r0, #4
 943 0710 FEFFFFEB 		bl	CyU3PDebugPrint
1419:../uvc.c      ****                         gpif_initialized = 0;
 944              		.loc 1 1419 0
 945 0714 0080A0E3 		mov	r8, #0
1418:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 946              		.loc 1 1418 0
 947 0718 0600A0E1 		mov	r0, r6
 948 071c FEFFFFEB 		bl	CyU3PGpifDisable
1423:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 949              		.loc 1 1423 0
 950 0720 0610A0E1 		mov	r1, r6
 951 0724 0500A0E1 		mov	r0, r5
1419:../uvc.c      ****                         gpif_initialized = 0;
 952              		.loc 1 1419 0
 953 0728 388087E5 		str	r8, [r7, #56]
1420:../uvc.c      ****                         streamingStarted = CyFalse;
 954              		.loc 1 1420 0
 955 072c 348087E5 		str	r8, [r7, #52]
1423:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 956              		.loc 1 1423 0
 957 0730 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1424:../uvc.c      ****                         CyU3PBusyWait (100);
 958              		.loc 1 1424 0
 959 0734 6400A0E3 		mov	r0, #100
 960 0738 FEFFFFEB 		bl	CyU3PBusyWait
1427:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 961              		.loc 1 1427 0
 962 073c 9C009FE5 		ldr	r0, .L70+28
 963 0740 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1428:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 964              		.loc 1 1428 0
 965 0744 0500A0E1 		mov	r0, r5
 966 0748 FEFFFFEB 		bl	CyU3PUsbFlushEp
1429:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 967              		.loc 1 1429 0
 968 074c 0810A0E1 		mov	r1, r8
 969 0750 0500A0E1 		mov	r0, r5
 970 0754 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1430:../uvc.c      ****                         CyU3PBusyWait (100);
 971              		.loc 1 1430 0
 972 0758 6400A0E3 		mov	r0, #100
 973 075c FEFFFFEB 		bl	CyU3PBusyWait
1433:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 974              		.loc 1 1433 0
 975 0760 0810A0E1 		mov	r1, r8
 976 0764 0620A0E1 		mov	r2, r6
 977 0768 0500A0E1 		mov	r0, r5
 978 076c FEFFFFEB 		bl	CyU3PUsbStall
 979              	.LVL80:
1437:../uvc.c      ****                         CyU3PUsbAckSetup ();
 980              		.loc 1 1437 0
 981 0770 FEFFFFEB 		bl	CyU3PUsbAckSetup
1439:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 982              		.loc 1 1439 0
 983 0774 406087E5 		str	r6, [r7, #64]
 984              	.LBB44:
 985              	.LBB45:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 986              		.loc 1 1257 0
 987 0778 0700A0E1 		mov	r0, r7
 988 077c 0610A0E1 		mov	r1, r6
 989 0780 0420A0E1 		mov	r2, r4
 990 0784 0C308DE2 		add	r3, sp, #12
 991 0788 00808DE5 		str	r8, [sp, #0]
 992 078c FEFFFFEB 		bl	_txe_event_flags_get
 993 0790 005050E2 		subs	r5, r0, #0
1435:../uvc.c      ****                         uvcHandleReq = CyTrue;
 994              		.loc 1 1435 0
 995 0794 0600A011 		movne	r0, r6
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 996              		.loc 1 1257 0
 997 0798 72FFFF1A 		bne	.L46
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 998              		.loc 1 1260 0
 999 079c 0110E0E3 		mvn	r1, #1
 1000 07a0 0420A0E1 		mov	r2, r4
 1001 07a4 0700A0E1 		mov	r0, r7
 1002 07a8 FEFFFFEB 		bl	_txe_event_flags_set
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1003              		.loc 1 1263 0
 1004 07ac 0700A0E1 		mov	r0, r7
 1005 07b0 0410A0E1 		mov	r1, r4
 1006 07b4 0520A0E1 		mov	r2, r5
 1007 07b8 FEFFFFEB 		bl	_txe_event_flags_set
1435:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1008              		.loc 1 1435 0
 1009 07bc 0600A0E1 		mov	r0, r6
 1010 07c0 68FFFFEA 		b	.L46
 1011              	.L71:
 1012              		.align	2
 1013              	.L70:
 1014 07c4 00000000 		.word	bmReqType
 1015 07c8 00000000 		.word	bRequest
 1016 07cc 00000000 		.word	wValue
 1017 07d0 00000000 		.word	wIndex
 1018 07d4 00000000 		.word	wLength
 1019 07d8 00000000 		.word	.LANCHOR0
 1020 07dc 50010000 		.word	.LC8
 1021 07e0 00000000 		.word	glChHandleUVCStream
 1022 07e4 E4000000 		.word	.LC6
 1023 07e8 1C010000 		.word	.LC7
 1024 07ec 68010000 		.word	.LC9
 1025              	.LBE45:
 1026              	.LBE44:
 1027              		.cfi_endproc
 1028              	.LFE9:
 1030              		.align	2
 1031              		.global	CyFxGpifCB
 1033              	CyFxGpifCB:
 1034              	.LFB12:
1628:../uvc.c      **** {
 1035              		.loc 1 1628 0
 1036              		.cfi_startproc
 1037              		@ args = 0, pretend = 0, frame = 0
 1038              		@ frame_needed = 0, uses_anonymous_args = 0
 1039              	.LVL81:
1629:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1040              		.loc 1 1629 0
 1041 07f0 010050E3 		cmp	r0, #1
1628:../uvc.c      **** {
 1042              		.loc 1 1628 0
 1043 07f4 10402DE9 		stmfd	sp!, {r4, lr}
 1044              	.LCFI8:
 1045              		.cfi_def_cfa_offset 8
1628:../uvc.c      **** {
 1046              		.loc 1 1628 0
 1047 07f8 0120A0E1 		mov	r2, r1
1629:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1048              		.loc 1 1629 0
 1049 07fc 1080BD18 		ldmnefd	sp!, {r4, pc}
 1050              		.cfi_offset 14, -4
 1051              		.cfi_offset 4, -8
1631:../uvc.c      ****         hitFV = CyTrue;
 1052              		.loc 1 1631 0
 1053 0800 D0109FE5 		ldr	r1, .L88
 1054              	.LVL82:
 1055              	.LBB50:
 1056              	.LBB52:
1528:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1057              		.loc 1 1528 0
 1058 0804 4830D1E5 		ldrb	r3, [r1, #72]	@ zero_extendqisi2
 1059              	.LBE52:
 1060              	.LBE50:
1631:../uvc.c      ****         hitFV = CyTrue;
 1061              		.loc 1 1631 0
 1062 0808 440081E5 		str	r0, [r1, #68]
 1063              	.LVL83:
 1064              	.LBB56:
 1065              	.LBB51:
1528:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1066              		.loc 1 1528 0
 1067 080c 030053E3 		cmp	r3, #3
 1068 0810 2800000A 		beq	.L87
1552:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1069              		.loc 1 1552 0
 1070 0814 020053E3 		cmp	r3, #2
 1071 0818 1080BD18 		ldmnefd	sp!, {r4, pc}
1554:../uvc.c      ****         switch (stateId)
 1072              		.loc 1 1554 0
 1073 081c 080042E2 		sub	r0, r2, #8
 1074              	.LVL84:
 1075 0820 0A0050E3 		cmp	r0, #10
 1076 0824 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1077 0828 1B0000EA 		b	.L80
 1078              	.L82:
 1079 082c 5C080000 		.word	.L76
 1080 0830 9C080000 		.word	.L80
 1081 0834 9C080000 		.word	.L80
 1082 0838 58080000 		.word	.L72
 1083 083c 9C080000 		.word	.L80
 1084 0840 9C080000 		.word	.L80
 1085 0844 9C080000 		.word	.L80
 1086 0848 94080000 		.word	.L86
 1087 084c 9C080000 		.word	.L80
 1088 0850 9C080000 		.word	.L80
 1089 0854 58080000 		.word	.L72
 1090              	.LVL85:
 1091              	.L72:
 1092 0858 1080BDE8 		ldmfd	sp!, {r4, pc}
 1093              	.LVL86:
 1094              	.L76:
1538:../uvc.c      ****                 socket = 0;
 1095              		.loc 1 1538 0
 1096 085c 0010A0E3 		mov	r1, #0
 1097              	.L77:
 1098              	.LVL87:
1611:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1099              		.loc 1 1611 0
 1100 0860 74009FE5 		ldr	r0, .L88+4
 1101 0864 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1102              	.LVL88:
1612:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1103              		.loc 1 1612 0
 1104 0868 002050E2 		subs	r2, r0, #0
 1105 086c F9FFFF0A 		beq	.L72
1614:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1106              		.loc 1 1614 0
 1107 0870 0400A0E3 		mov	r0, #4
 1108              	.LVL89:
 1109 0874 64109FE5 		ldr	r1, .L88+8
 1110 0878 FEFFFFEB 		bl	CyU3PDebugPrint
 1111              	.LVL90:
 1112              	.L83:
 1113              	.LBB53:
 1114              	.LBB54:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1115              		.loc 1 1244 0
 1116 087c 60109FE5 		ldr	r1, .L88+12
 1117 0880 0400A0E3 		mov	r0, #4
 1118 0884 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 1119              		.loc 1 1245 0
 1120 0888 FA0FA0E3 		mov	r0, #1000
 1121 088c FEFFFFEB 		bl	_tx_thread_sleep
 1122 0890 F9FFFFEA 		b	.L83
 1123              	.LVL91:
 1124              	.L86:
 1125              	.LBE54:
 1126              	.LBE53:
1581:../uvc.c      ****                 socket = 1;
 1127              		.loc 1 1581 0
 1128 0894 0110A0E3 		mov	r1, #1
 1129 0898 F0FFFFEA 		b	.L77
 1130              	.L80:
1600:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1131              		.loc 1 1600 0
 1132 089c 44109FE5 		ldr	r1, .L88+16
 1133 08a0 0100A0E3 		mov	r0, #1
 1134 08a4 FEFFFFEB 		bl	CyU3PDebugPrint
 1135              	.LVL92:
 1136              	.LBE51:
 1137              	.LBE56:
1633:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1138              		.loc 1 1633 0
 1139 08a8 3C109FE5 		ldr	r1, .L88+20
 1140 08ac 0400A0E3 		mov	r0, #4
1635:../uvc.c      **** }
 1141              		.loc 1 1635 0
 1142 08b0 1040BDE8 		ldmfd	sp!, {r4, lr}
1633:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1143              		.loc 1 1633 0
 1144 08b4 FEFFFFEA 		b	CyU3PDebugPrint
 1145              	.LVL93:
 1146              	.L87:
 1147              	.LBB57:
 1148              	.LBB55:
1530:../uvc.c      ****         switch (stateId)
 1149              		.loc 1 1530 0
 1150 08b8 0B3042E2 		sub	r3, r2, #11
 1151 08bc 030053E3 		cmp	r3, #3
 1152 08c0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1153 08c4 F4FFFFEA 		b	.L80
 1154              	.L78:
 1155 08c8 5C080000 		.word	.L76
 1156 08cc 94080000 		.word	.L86
 1157 08d0 58080000 		.word	.L72
 1158 08d4 58080000 		.word	.L72
 1159              	.L89:
 1160              		.align	2
 1161              	.L88:
 1162 08d8 00000000 		.word	.LANCHOR0
 1163 08dc 00000000 		.word	glChHandleUVCStream
 1164 08e0 A4010000 		.word	.LC11
 1165 08e4 D4010000 		.word	.LC12
 1166 08e8 8C010000 		.word	.LC10
 1167 08ec E8010000 		.word	.LC13
 1168              	.LBE55:
 1169              	.LBE57:
 1170              		.cfi_endproc
 1171              	.LFE12:
 1173              		.align	2
 1174              		.global	I2CCmdHandler
 1176              	I2CCmdHandler:
 1177              	.LFB0:
 323:../uvc.c      **** void I2CCmdHandler(){
 1178              		.loc 1 323 0
 1179              		.cfi_startproc
 1180              		@ args = 0, pretend = 0, frame = 8
 1181              		@ frame_needed = 0, uses_anonymous_args = 0
 1182 08f0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1183              	.LCFI9:
 1184              		.cfi_def_cfa_offset 36
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1185              		.loc 1 326 0
 1186 08f4 E8409FE5 		ldr	r4, .L96
 1187              		.cfi_offset 14, -4
 1188              		.cfi_offset 11, -8
 1189              		.cfi_offset 10, -12
 1190              		.cfi_offset 9, -16
 1191              		.cfi_offset 8, -20
 1192              		.cfi_offset 7, -24
 1193              		.cfi_offset 6, -28
 1194              		.cfi_offset 5, -32
 1195              		.cfi_offset 4, -36
 323:../uvc.c      **** void I2CCmdHandler(){
 1196              		.loc 1 323 0
 1197 08f8 34D04DE2 		sub	sp, sp, #52
 1198              	.LCFI10:
 1199              		.cfi_def_cfa_offset 88
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1200              		.loc 1 326 0
 1201 08fc 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1202              	.LVL94:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1203              		.loc 1 331 0
 1204 0900 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1205              		.loc 1 328 0
 1206 0904 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1207              	.LVL95:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1208              		.loc 1 331 0
 1209 0908 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1210 090c 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1211 0910 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1212 0914 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1213 0918 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1214 091c 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1215 0920 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1216 0924 1C208DE5 		str	r2, [sp, #28]
 1217 0928 0400A0E3 		mov	r0, #4
 1218 092c 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 1219 0930 B0109FE5 		ldr	r1, .L96+4
 1220 0934 0520A0E1 		mov	r2, r5
 1221 0938 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1222 093c 08808DE5 		str	r8, [sp, #8]
 1223 0940 0CA08DE5 		str	sl, [sp, #12]
 1224 0944 10908DE5 		str	r9, [sp, #16]
 1225 0948 14B08DE5 		str	fp, [sp, #20]
 1226 094c 18608DE5 		str	r6, [sp, #24]
 1227 0950 20C08DE5 		str	ip, [sp, #32]
 1228 0954 FEFFFFEB 		bl	CyU3PDebugPrint
 1229              	.LVL96:
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1230              		.loc 1 335 0
 1231 0958 000055E3 		cmp	r5, #0
 1232 095c 0300000A 		beq	.L94
 360:../uvc.c      **** 	}else if(CmdType == 1){
 1233              		.loc 1 360 0
 1234 0960 010055E3 		cmp	r5, #1
 1235 0964 1400000A 		beq	.L95
 1236              	.L90:
 373:../uvc.c      **** }
 1237              		.loc 1 373 0
 1238 0968 34D08DE2 		add	sp, sp, #52
 1239 096c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1240              	.L94:
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1241              		.loc 1 351 0
 1242 0970 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1243 0974 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1244 0978 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1245              		.loc 1 337 0
 1246 097c 0FE0A0E3 		mov	lr, #15
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1247              		.loc 1 351 0
 1248 0980 2CC08DE2 		add	ip, sp, #44
 1249 0984 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1250 0988 010080E3 		orr	r0, r0, #1
 1251 098c 011081E3 		orr	r1, r1, #1
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1252              		.loc 1 337 0
 1253 0990 57E0C4E5 		strb	lr, [r4, #87]
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1254              		.loc 1 351 0
 1255 0994 00C08DE5 		str	ip, [sp, #0]
 1256 0998 FEFFFFEB 		bl	SensorRead2B
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1257              		.loc 1 352 0
 1258 099c 2C00DDE5 		ldrb	r0, [sp, #44]	@ zero_extendqisi2
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 1259              		.loc 1 353 0
 1260 09a0 020056E3 		cmp	r6, #2
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1261              		.loc 1 352 0
 1262 09a4 5500C4E5 		strb	r0, [r4, #85]
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1263              		.loc 1 354 0
 1264 09a8 2D00DD05 		ldreqb	r0, [sp, #45]	@ zero_extendqisi2
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1265              		.loc 1 356 0
 1266 09ac 0030E0E3 		mvn	r3, #0
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1267              		.loc 1 354 0
 1268 09b0 5600C405 		streqb	r0, [r4, #86]
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1269              		.loc 1 356 0
 1270 09b4 5730C4E5 		strb	r3, [r4, #87]
 1271 09b8 EAFFFFEA 		b	.L90
 1272              	.L95:
 367:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1273              		.loc 1 367 0
 1274 09bc 4E10D4E5 		ldrb	r1, [r4, #78]	@ zero_extendqisi2
 1275 09c0 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1276 09c4 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1277 09c8 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1278 09cc 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1279 09d0 FE0001E2 		and	r0, r1, #254
 1280 09d4 FE100EE2 		and	r1, lr, #254
 1281 09d8 00C08DE5 		str	ip, [sp, #0]
 1282 09dc FEFFFFEB 		bl	SensorWrite2B
 1283 09e0 E0FFFFEA 		b	.L90
 1284              	.L97:
 1285              		.align	2
 1286              	.L96:
 1287 09e4 00000000 		.word	.LANCHOR0
 1288 09e8 FC010000 		.word	.LC14
 1289              		.cfi_endproc
 1290              	.LFE0:
 1292              		.align	2
 1293              		.global	setIrisauto
 1295              	setIrisauto:
 1296              	.LFB1:
 379:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1297              		.loc 1 379 0
 1298              		.cfi_startproc
 1299              		@ args = 0, pretend = 0, frame = 0
 1300              		@ frame_needed = 0, uses_anonymous_args = 0
 1301              	.LVL97:
 1302 09ec 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1303              	.LCFI11:
 1304              		.cfi_def_cfa_offset 16
 1305 09f0 0160A0E1 		mov	r6, r1
 1306              		.cfi_offset 14, -4
 1307              		.cfi_offset 6, -8
 1308              		.cfi_offset 5, -12
 1309              		.cfi_offset 4, -16
 1310 09f4 08D04DE2 		sub	sp, sp, #8
 1311              	.LCFI12:
 1312              		.cfi_def_cfa_offset 24
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1313              		.loc 1 383 0
 1314 09f8 0050A0E3 		mov	r5, #0
 379:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1315              		.loc 1 379 0
 1316 09fc 0040A0E1 		mov	r4, r0
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1317              		.loc 1 382 0
 1318 0a00 0010E0E3 		mvn	r1, #0
 1319              	.LVL98:
 1320 0a04 1C0090E5 		ldr	r0, [r0, #28]
 1321              	.LVL99:
 1322 0a08 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1323              		.loc 1 383 0
 1324 0a0c 060065E0 		rsb	r0, r5, r6
 1325 0a10 00C070E2 		rsbs	ip, r0, #0
 1326 0a14 00C0ACE0 		adc	ip, ip, r0
 1327 0a18 1410A0E3 		mov	r1, #20
 1328 0a1c 2720A0E3 		mov	r2, #39
 1329 0a20 3030A0E3 		mov	r3, #48
 1330 0a24 0400A0E1 		mov	r0, r4
 1331 0a28 00C08DE5 		str	ip, [sp, #0]
 1332 0a2c 04508DE5 		str	r5, [sp, #4]
 1333 0a30 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1334              		.loc 1 384 0
 1335 0a34 050056E1 		cmp	r6, r5
 1336 0a38 0260A003 		moveq	r6, #2
 1337 0a3c 0560A011 		movne	r6, r5
 1338 0a40 0400A0E1 		mov	r0, r4
 1339 0a44 1510A0E3 		mov	r1, #21
 1340 0a48 2520A0E3 		mov	r2, #37
 1341 0a4c 3030A0E3 		mov	r3, #48
 1342 0a50 00608DE5 		str	r6, [sp, #0]
 1343 0a54 04508DE5 		str	r5, [sp, #4]
 1344 0a58 FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1345              		.loc 1 385 0
 1346 0a5c 1C0094E5 		ldr	r0, [r4, #28]
 386:../uvc.c      **** }
 1347              		.loc 1 386 0
 1348 0a60 08D08DE2 		add	sp, sp, #8
 1349 0a64 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1350              		.loc 1 385 0
 1351 0a68 FEFFFFEA 		b	_txe_mutex_put
 1352              		.cfi_endproc
 1353              	.LFE1:
 1355              		.align	2
 1356              		.global	ControlHandle
 1358              	ControlHandle:
 1359              	.LFB2:
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1360              		.loc 1 388 0
 1361              		.cfi_startproc
 1362              		@ args = 0, pretend = 0, frame = 24
 1363              		@ frame_needed = 0, uses_anonymous_args = 0
 1364              	.LVL100:
 1365 0a6c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1366              	.LCFI13:
 1367              		.cfi_def_cfa_offset 36
 395:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1368              		.loc 1 395 0
 1369 0a70 1F0050E3 		cmp	r0, #31
 394:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1370              		.loc 1 394 0
 1371 0a74 207040E2 		sub	r7, r0, #32
 1372              		.cfi_offset 14, -4
 1373              		.cfi_offset 11, -8
 1374              		.cfi_offset 10, -12
 1375              		.cfi_offset 9, -16
 1376              		.cfi_offset 8, -20
 1377              		.cfi_offset 7, -24
 1378              		.cfi_offset 6, -28
 1379              		.cfi_offset 5, -32
 1380              		.cfi_offset 4, -36
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1381              		.loc 1 388 0
 1382 0a78 2CD04DE2 		sub	sp, sp, #44
 1383              	.LCFI14:
 1384              		.cfi_def_cfa_offset 80
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1385              		.loc 1 388 0
 1386 0a7c 0040A0E1 		mov	r4, r0
 394:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1387              		.loc 1 394 0
 1388 0a80 FF7007E2 		and	r7, r7, #255
 1389              	.LVL101:
 395:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1390              		.loc 1 395 0
 1391 0a84 2400009A 		bls	.L102
 396:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1392              		.loc 1 396 0
 1393 0a88 CC6E9FE5 		ldr	r6, .L206
 1394 0a8c 872087E0 		add	r2, r7, r7, asl #1
 1395 0a90 8221A0E1 		mov	r2, r2, asl #3
 1396 0a94 023086E0 		add	r3, r6, r2
 397:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1397              		.loc 1 397 0
 1398 0a98 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 398:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1399              		.loc 1 398 0
 1400 0a9c 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 399:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1401              		.loc 1 399 0
 1402 0aa0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 410:../uvc.c      ****     reqData = bRequest;
 1403              		.loc 1 410 0
 1404 0aa4 B43E9FE5 		ldr	r3, .L206+4
 396:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1405              		.loc 1 396 0
 1406 0aa8 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1407              	.LVL102:
 410:../uvc.c      ****     reqData = bRequest;
 1408              		.loc 1 410 0
 1409 0aac 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1410              	.LVL103:
 418:../uvc.c      ****     switch (bRequest)
 1411              		.loc 1 418 0
 1412 0ab0 830055E3 		cmp	r5, #131
 1413 0ab4 2300000A 		beq	.L108
 1414              	.LVL104:
 1415              	.L203:
 1416 0ab8 2C00009A 		bls	.L201
 1417 0abc 850055E3 		cmp	r5, #133
 1418 0ac0 8700000A 		beq	.L110
 1419 0ac4 7500003A 		bcc	.L109
 1420 0ac8 860055E3 		cmp	r5, #134
 1421 0acc C000000A 		beq	.L111
 1422 0ad0 870055E3 		cmp	r5, #135
 1423 0ad4 B400000A 		beq	.L202
 1424              	.L104:
 894:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1425              		.loc 1 894 0
 1426 0ad8 0000A0E3 		mov	r0, #0
 1427 0adc 0110A0E3 		mov	r1, #1
 1428 0ae0 0020A0E1 		mov	r2, r0
 1429 0ae4 FEFFFFEB 		bl	CyU3PUsbStall
 895:../uvc.c      **** 			  break;
 1430              		.loc 1 895 0
 1431 0ae8 FFC0A0E3 		mov	ip, #255
 1432 0aec 0C70A0E1 		mov	r7, ip
 1433              	.LVL105:
 1434 0af0 0CE0A0E1 		mov	lr, ip
 1435 0af4 0C40A0E1 		mov	r4, ip
 1436              	.LVL106:
 1437              	.L114:
 897:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1438              		.loc 1 897 0
 1439 0af8 641E9FE5 		ldr	r1, .L206+8
 1440 0afc 0520A0E1 		mov	r2, r5
 1441 0b00 0430A0E1 		mov	r3, r4
 1442 0b04 0400A0E3 		mov	r0, #4
 1443 0b08 00E08DE5 		str	lr, [sp, #0]
 1444 0b0c 80108DE9 		stmib	sp, {r7, ip}	@ phole stm
 1445 0b10 FEFFFFEB 		bl	CyU3PDebugPrint
 898:../uvc.c      **** }
 1446              		.loc 1 898 0
 1447 0b14 2CD08DE2 		add	sp, sp, #44
 1448 0b18 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1449              	.LVL107:
 1450              	.L102:
 401:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1451              		.loc 1 401 0
 1452 0b1c 386E9FE5 		ldr	r6, .L206
 410:../uvc.c      ****     reqData = bRequest;
 1453              		.loc 1 410 0
 1454 0b20 383E9FE5 		ldr	r3, .L206+4
 401:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1455              		.loc 1 401 0
 1456 0b24 805080E0 		add	r5, r0, r0, asl #1
 1457 0b28 850186E0 		add	r0, r6, r5, asl #3
 1458              	.LVL108:
 410:../uvc.c      ****     reqData = bRequest;
 1459              		.loc 1 410 0
 1460 0b2c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 401:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1461              		.loc 1 401 0
 1462 0b30 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1463              	.LVL109:
 418:../uvc.c      ****     switch (bRequest)
 1464              		.loc 1 418 0
 1465 0b34 830055E3 		cmp	r5, #131
 402:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1466              		.loc 1 402 0
 1467 0b38 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1468              	.LVL110:
 403:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1469              		.loc 1 403 0
 1470 0b3c 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1471              	.LVL111:
 404:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1472              		.loc 1 404 0
 1473 0b40 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1474              	.LVL112:
 418:../uvc.c      ****     switch (bRequest)
 1475              		.loc 1 418 0
 1476 0b44 DBFFFF1A 		bne	.L203
 1477              	.LVL113:
 1478              	.L108:
 541:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1479              		.loc 1 541 0
 1480 0b48 1F0054E3 		cmp	r4, #31
 1481 0b4c BE00009A 		bls	.L136
 542:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1482              		.loc 1 542 0
 1483 0b50 870087E0 		add	r0, r7, r7, asl #1
 1484 0b54 806186E0 		add	r6, r6, r0, asl #3
 1485 0b58 08AE9FE5 		ldr	sl, .L206+12
 1486 0b5c 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
 543:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1487              		.loc 1 543 0
 1488 0b60 06E0D6E5 		ldrb	lr, [r6, #6]	@ zero_extendqisi2
 542:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1489              		.loc 1 542 0
 1490 0b64 58C0CAE5 		strb	ip, [sl, #88]
 543:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1491              		.loc 1 543 0
 1492 0b68 59E0CAE5 		strb	lr, [sl, #89]
 1493 0b6c 0B0000EA 		b	.L144
 1494              	.L201:
 418:../uvc.c      ****     switch (bRequest)
 1495              		.loc 1 418 0
 1496 0b70 810055E3 		cmp	r5, #129
 1497 0b74 6600000A 		beq	.L106
 1498 0b78 1000009A 		bls	.L204
 522:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1499              		.loc 1 522 0
 1500 0b7c 1F0054E3 		cmp	r4, #31
 1501 0b80 A500009A 		bls	.L133
 523:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1502              		.loc 1 523 0
 1503 0b84 87A087E0 		add	sl, r7, r7, asl #1
 1504 0b88 8A6186E0 		add	r6, r6, sl, asl #3
 1505 0b8c 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 1506 0b90 D0AD9FE5 		ldr	sl, .L206+12
 524:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1507              		.loc 1 524 0
 1508 0b94 0470D6E5 		ldrb	r7, [r6, #4]	@ zero_extendqisi2
 1509              	.LVL114:
 523:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1510              		.loc 1 523 0
 1511 0b98 5840CAE5 		strb	r4, [sl, #88]
 524:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1512              		.loc 1 524 0
 1513 0b9c 5970CAE5 		strb	r7, [sl, #89]
 1514              	.L144:
 600:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1515              		.loc 1 600 0
 1516 0ba0 0800A0E1 		mov	r0, r8
 1517 0ba4 C01D9FE5 		ldr	r1, .L206+16
 1518 0ba8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1519              	.LVL115:
 602:../uvc.c      **** 			  break;
 1520              		.loc 1 602 0
 1521 0bac FFC0A0E3 		mov	ip, #255
 600:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1522              		.loc 1 600 0
 1523 0bb0 5870DAE5 		ldrb	r7, [sl, #88]	@ zero_extendqisi2
 602:../uvc.c      **** 			  break;
 1524              		.loc 1 602 0
 1525 0bb4 0CE0A0E1 		mov	lr, ip
 1526 0bb8 0C40A0E1 		mov	r4, ip
 1527 0bbc CDFFFFEA 		b	.L114
 1528              	.LVL116:
 1529              	.L204:
 418:../uvc.c      ****     switch (bRequest)
 1530              		.loc 1 418 0
 1531 0bc0 010055E3 		cmp	r5, #1
 1532 0bc4 C3FFFF1A 		bne	.L104
 604:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1533              		.loc 1 604 0
 1534 0bc8 981D9FE5 		ldr	r1, .L206+12
 1535 0bcc 26208DE2 		add	r2, sp, #38
 1536 0bd0 2000A0E3 		mov	r0, #32
 1537 0bd4 581081E2 		add	r1, r1, #88
 1538 0bd8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1539              	.LVL117:
 606:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1540              		.loc 1 606 0
 1541 0bdc 002050E2 		subs	r2, r0, #0
 1542 0be0 3903001A 		bne	.L146
 608:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1543              		.loc 1 608 0
 1544 0be4 7C3D9FE5 		ldr	r3, .L206+12
 609:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1545              		.loc 1 609 0
 1546 0be8 780D9FE5 		ldr	r0, .L206+12
 1547              	.LVL118:
 611:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1548              		.loc 1 611 0
 1549 0bec 74ED9FE5 		ldr	lr, .L206+12
 608:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1550              		.loc 1 608 0
 1551 0bf0 5830D3E5 		ldrb	r3, [r3, #88]	@ zero_extendqisi2
 609:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1552              		.loc 1 609 0
 1553 0bf4 59C0D0E5 		ldrb	ip, [r0, #89]	@ zero_extendqisi2
 611:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1554              		.loc 1 611 0
 1555 0bf8 5AE0DEE5 		ldrb	lr, [lr, #90]	@ zero_extendqisi2
 608:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1556              		.loc 1 608 0
 1557 0bfc 14308DE5 		str	r3, [sp, #20]
 1558              	.LVL119:
 609:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1559              		.loc 1 609 0
 1560 0c00 1CC08DE5 		str	ip, [sp, #28]
 1561              	.LVL120:
 611:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1562              		.loc 1 611 0
 1563 0c04 18E08DE5 		str	lr, [sp, #24]
 1564              	.LVL121:
 615:../uvc.c      **** 				  switch(CtrlID)
 1565              		.loc 1 615 0
 1566 0c08 220054E3 		cmp	r4, #34
 1567 0c0c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1568 0c10 130300EA 		b	.L147
 1569              	.L163:
 1570 0c14 E8170000 		.word	.L148
 1571 0c18 28170000 		.word	.L149
 1572 0c1c 64180000 		.word	.L147
 1573 0c20 64180000 		.word	.L147
 1574 0c24 C4160000 		.word	.L150
 1575 0c28 84150000 		.word	.L151
 1576 0c2c 08150000 		.word	.L152
 1577 0c30 64180000 		.word	.L147
 1578 0c34 64180000 		.word	.L147
 1579 0c38 64180000 		.word	.L147
 1580 0c3c 64180000 		.word	.L147
 1581 0c40 80140000 		.word	.L153
 1582 0c44 64180000 		.word	.L147
 1583 0c48 64180000 		.word	.L147
 1584 0c4c 64180000 		.word	.L147
 1585 0c50 64180000 		.word	.L147
 1586 0c54 FC130000 		.word	.L154
 1587 0c58 64180000 		.word	.L147
 1588 0c5c 64180000 		.word	.L147
 1589 0c60 64180000 		.word	.L147
 1590 0c64 64180000 		.word	.L147
 1591 0c68 64180000 		.word	.L147
 1592 0c6c 64180000 		.word	.L147
 1593 0c70 64180000 		.word	.L147
 1594 0c74 64180000 		.word	.L147
 1595 0c78 44130000 		.word	.L155
 1596 0c7c AC120000 		.word	.L156
 1597 0c80 64180000 		.word	.L147
 1598 0c84 9C120000 		.word	.L157
 1599 0c88 64180000 		.word	.L147
 1600 0c8c 40120000 		.word	.L158
 1601 0c90 BC110000 		.word	.L159
 1602 0c94 20110000 		.word	.L160
 1603 0c98 08110000 		.word	.L161
 1604 0c9c A4100000 		.word	.L162
 1605              	.LVL122:
 1606              	.L109:
 559:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1607              		.loc 1 559 0
 1608 0ca0 1F0054E3 		cmp	r4, #31
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1609              		.loc 1 560 0
 1610 0ca4 87708780 		addhi	r7, r7, r7, asl #1
 1611              	.LVL123:
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1612              		.loc 1 566 0
 1613 0ca8 84408490 		addls	r4, r4, r4, asl #1
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1614              		.loc 1 560 0
 1615 0cac 87618680 		addhi	r6, r6, r7, asl #3
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1616              		.loc 1 566 0
 1617 0cb0 84618690 		addls	r6, r6, r4, asl #3
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1618              		.loc 1 560 0
 1619 0cb4 ACAC9F85 		ldrhi	sl, .L206+12
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1620              		.loc 1 566 0
 1621 0cb8 A8AC9F95 		ldrls	sl, .L206+12
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1622              		.loc 1 560 0
 1623 0cbc 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 561:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1624              		.loc 1 561 0
 1625 0cc0 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1626              		.loc 1 566 0
 1627 0cc4 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 567:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1628              		.loc 1 567 0
 1629 0cc8 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 568:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1630              		.loc 1 568 0
 1631 0ccc 0030A0E3 		mov	r3, #0
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1632              		.loc 1 566 0
 1633 0cd0 5810CAE5 		strb	r1, [sl, #88]
 567:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1634              		.loc 1 567 0
 1635 0cd4 5920CAE5 		strb	r2, [sl, #89]
 568:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1636              		.loc 1 568 0
 1637 0cd8 5A30CAE5 		strb	r3, [sl, #90]
 569:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1638              		.loc 1 569 0
 1639 0cdc 5B30CAE5 		strb	r3, [sl, #91]
 1640 0ce0 AEFFFFEA 		b	.L144
 1641              	.LVL124:
 1642              	.L110:
 422:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1643              		.loc 1 422 0
 1644 0ce4 7C4C9FE5 		ldr	r4, .L206+12
 423:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1645              		.loc 1 423 0
 1646 0ce8 00C0A0E3 		mov	ip, #0
 1647 0cec 59C0C4E5 		strb	ip, [r4, #89]
 424:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1648              		.loc 1 424 0
 1649 0cf0 581084E2 		add	r1, r4, #88
 422:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1650              		.loc 1 422 0
 1651 0cf4 5880C4E5 		strb	r8, [r4, #88]
 424:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1652              		.loc 1 424 0
 1653 0cf8 0200A0E3 		mov	r0, #2
 1654 0cfc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1655              	.LVL125:
 426:../uvc.c      **** 			  break;
 1656              		.loc 1 426 0
 1657 0d00 FFC0A0E3 		mov	ip, #255
 424:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1658              		.loc 1 424 0
 1659 0d04 5870D4E5 		ldrb	r7, [r4, #88]	@ zero_extendqisi2
 1660              	.LVL126:
 426:../uvc.c      **** 			  break;
 1661              		.loc 1 426 0
 1662 0d08 0CE0A0E1 		mov	lr, ip
 1663 0d0c 0C40A0E1 		mov	r4, ip
 1664 0d10 78FFFFEA 		b	.L114
 1665              	.LVL127:
 1666              	.L106:
 429:../uvc.c      **** 			 switch(CtrlID)
 1667              		.loc 1 429 0
 1668 0d14 011044E2 		sub	r1, r4, #1
 1669 0d18 210051E3 		cmp	r1, #33
 1670 0d1c 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1671 0d20 D60000EA 		b	.L115
 1672              	.L123:
 1673 0d24 3C100000 		.word	.L116
 1674 0d28 80100000 		.word	.L115
 1675 0d2c 80100000 		.word	.L115
 1676 0d30 80100000 		.word	.L115
 1677 0d34 1C100000 		.word	.L117
 1678 0d38 80100000 		.word	.L115
 1679 0d3c 80100000 		.word	.L115
 1680 0d40 80100000 		.word	.L115
 1681 0d44 80100000 		.word	.L115
 1682 0d48 80100000 		.word	.L115
 1683 0d4c F80F0000 		.word	.L118
 1684 0d50 80100000 		.word	.L115
 1685 0d54 80100000 		.word	.L115
 1686 0d58 80100000 		.word	.L115
 1687 0d5c 80100000 		.word	.L115
 1688 0d60 80100000 		.word	.L115
 1689 0d64 80100000 		.word	.L115
 1690 0d68 80100000 		.word	.L115
 1691 0d6c 80100000 		.word	.L115
 1692 0d70 80100000 		.word	.L115
 1693 0d74 80100000 		.word	.L115
 1694 0d78 80100000 		.word	.L115
 1695 0d7c 80100000 		.word	.L115
 1696 0d80 80100000 		.word	.L115
 1697 0d84 BC0F0000 		.word	.L119
 1698 0d88 80100000 		.word	.L115
 1699 0d8c 80100000 		.word	.L115
 1700 0d90 A00F0000 		.word	.L120
 1701 0d94 80100000 		.word	.L115
 1702 0d98 80100000 		.word	.L115
 1703 0d9c 040F0000 		.word	.L121
 1704 0da0 C80E0000 		.word	.L122
 1705 0da4 C80E0000 		.word	.L122
 1706 0da8 C80E0000 		.word	.L122
 1707              	.L202:
 586:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1708              		.loc 1 586 0
 1709 0dac 1F0054E3 		cmp	r4, #31
 1710 0db0 3100009A 		bls	.L143
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1711              		.loc 1 587 0
 1712 0db4 877087E0 		add	r7, r7, r7, asl #1
 1713              	.LVL128:
 1714 0db8 876186E0 		add	r6, r6, r7, asl #3
 1715 0dbc A4AB9FE5 		ldr	sl, .L206+12
 1716 0dc0 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1717              		.loc 1 588 0
 1718 0dc4 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1719              		.loc 1 587 0
 1720 0dc8 5820CAE5 		strb	r2, [sl, #88]
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1721              		.loc 1 588 0
 1722 0dcc 5910CAE5 		strb	r1, [sl, #89]
 1723 0dd0 72FFFFEA 		b	.L144
 1724              	.LVL129:
 1725              	.L111:
 575:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1726              		.loc 1 575 0
 1727 0dd4 1F0054E3 		cmp	r4, #31
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1728              		.loc 1 576 0
 1729 0dd8 87708780 		addhi	r7, r7, r7, asl #1
 1730              	.LVL130:
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1731              		.loc 1 579 0
 1732 0ddc 84408490 		addls	r4, r4, r4, asl #1
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1733              		.loc 1 576 0
 1734 0de0 87618680 		addhi	r6, r6, r7, asl #3
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1735              		.loc 1 579 0
 1736 0de4 84618690 		addls	r6, r6, r4, asl #3
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1737              		.loc 1 576 0
 1738 0de8 788B9F85 		ldrhi	r8, .L206+12
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1739              		.loc 1 579 0
 1740 0dec 748B9F95 		ldrls	r8, .L206+12
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1741              		.loc 1 576 0
 1742 0df0 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1743              		.loc 1 579 0
 1744 0df4 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 581:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1745              		.loc 1 581 0
 1746 0df8 0100A0E3 		mov	r0, #1
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1747              		.loc 1 579 0
 1748 0dfc 5830C8E5 		strb	r3, [r8, #88]
 581:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1749              		.loc 1 581 0
 1750 0e00 641B9FE5 		ldr	r1, .L206+16
 1751 0e04 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1752              	.LVL131:
 584:../uvc.c      **** 			  break;
 1753              		.loc 1 584 0
 1754 0e08 FFC0A0E3 		mov	ip, #255
 581:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1755              		.loc 1 581 0
 1756 0e0c 5870D8E5 		ldrb	r7, [r8, #88]	@ zero_extendqisi2
 584:../uvc.c      **** 			  break;
 1757              		.loc 1 584 0
 1758 0e10 0CE0A0E1 		mov	lr, ip
 1759 0e14 0C40A0E1 		mov	r4, ip
 1760 0e18 36FFFFEA 		b	.L114
 1761              	.LVL132:
 1762              	.L133:
 527:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1763              		.loc 1 527 0
 1764 0e1c 0B0054E3 		cmp	r4, #11
 534:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1765              		.loc 1 534 0
 1766 0e20 84408410 		addne	r4, r4, r4, asl #1
 1767 0e24 84618610 		addne	r6, r6, r4, asl #3
 1768 0e28 38AB9F15 		ldrne	sl, .L206+12
 528:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1769              		.loc 1 528 0
 1770 0e2c 34AB9F05 		ldreq	sl, .L206+12
 1771 0e30 383B9F05 		ldreq	r3, .L206+20
 534:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1772              		.loc 1 534 0
 1773 0e34 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 535:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1774              		.loc 1 535 0
 1775 0e38 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 528:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1776              		.loc 1 528 0
 1777 0e3c 58308A05 		streq	r3, [sl, #88]
 534:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1778              		.loc 1 534 0
 1779 0e40 5820CA15 		strneb	r2, [sl, #88]
 535:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1780              		.loc 1 535 0
 1781 0e44 5930CA15 		strneb	r3, [sl, #89]
 1782 0e48 54FFFFEA 		b	.L144
 1783              	.L136:
 545:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1784              		.loc 1 545 0
 1785 0e4c 0B0054E3 		cmp	r4, #11
 552:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1786              		.loc 1 552 0
 1787 0e50 84408410 		addne	r4, r4, r4, asl #1
 1788 0e54 84618610 		addne	r6, r6, r4, asl #3
 1789 0e58 08AB9F15 		ldrne	sl, .L206+12
 546:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1790              		.loc 1 546 0
 1791 0e5c 04AB9F05 		ldreq	sl, .L206+12
 1792 0e60 0C3B9F05 		ldreq	r3, .L206+24
 552:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1793              		.loc 1 552 0
 1794 0e64 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 553:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1795              		.loc 1 553 0
 1796 0e68 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 546:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1797              		.loc 1 546 0
 1798 0e6c 58308A05 		streq	r3, [sl, #88]
 552:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1799              		.loc 1 552 0
 1800 0e70 5820CA15 		strneb	r2, [sl, #88]
 553:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1801              		.loc 1 553 0
 1802 0e74 5930CA15 		strneb	r3, [sl, #89]
 1803 0e78 48FFFFEA 		b	.L144
 1804              	.L143:
 591:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1805              		.loc 1 591 0
 1806 0e7c 0B0054E3 		cmp	r4, #11
 1807 0e80 0700000A 		beq	.L205
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1808              		.loc 1 597 0
 1809 0e84 84A084E0 		add	sl, r4, r4, asl #1
 1810 0e88 8A6186E0 		add	r6, r6, sl, asl #3
 1811 0e8c 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1812 0e90 D0AA9FE5 		ldr	sl, .L206+12
 598:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1813              		.loc 1 598 0
 1814 0e94 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1815              		.loc 1 597 0
 1816 0e98 5830CAE5 		strb	r3, [sl, #88]
 598:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1817              		.loc 1 598 0
 1818 0e9c 5900CAE5 		strb	r0, [sl, #89]
 1819 0ea0 3EFFFFEA 		b	.L144
 1820              	.L205:
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1821              		.loc 1 592 0
 1822 0ea4 BCAA9FE5 		ldr	sl, .L206+12
 1823 0ea8 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 594:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1824              		.loc 1 594 0
 1825 0eac 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 593:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1826              		.loc 1 593 0
 1827 0eb0 0040A0E3 		mov	r4, #0
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1828              		.loc 1 592 0
 1829 0eb4 58C0CAE5 		strb	ip, [sl, #88]
 593:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1830              		.loc 1 593 0
 1831 0eb8 5940CAE5 		strb	r4, [sl, #89]
 594:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1832              		.loc 1 594 0
 1833 0ebc 5AE0CAE5 		strb	lr, [sl, #90]
 595:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1834              		.loc 1 595 0
 1835 0ec0 5B40CAE5 		strb	r4, [sl, #91]
 1836 0ec4 35FFFFEA 		b	.L144
 1837              	.L122:
 435:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1838              		.loc 1 435 0
 1839 0ec8 877087E0 		add	r7, r7, r7, asl #1
 1840              	.LVL133:
 1841 0ecc 876186E0 		add	r6, r6, r7, asl #3
 1842 0ed0 90EA9FE5 		ldr	lr, .L206+12
 1843 0ed4 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 436:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1844              		.loc 1 436 0
 1845 0ed8 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 435:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1846              		.loc 1 435 0
 1847 0edc 5840CEE5 		strb	r4, [lr, #88]
 436:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1848              		.loc 1 436 0
 1849 0ee0 5960CEE5 		strb	r6, [lr, #89]
 1850              	.LVL134:
 1851              	.L126:
 515:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1852              		.loc 1 515 0
 1853 0ee4 0800A0E1 		mov	r0, r8
 1854 0ee8 7C1A9FE5 		ldr	r1, .L206+16
 1855 0eec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 520:../uvc.c      **** 			  break;
 1856              		.loc 1 520 0
 1857 0ef0 FFE0A0E3 		mov	lr, #255
 515:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1858              		.loc 1 515 0
 1859 0ef4 0470A0E1 		mov	r7, r4
 1860 0ef8 06C0A0E1 		mov	ip, r6
 520:../uvc.c      **** 			  break;
 1861              		.loc 1 520 0
 1862 0efc 0E40A0E1 		mov	r4, lr
 1863              	.LVL135:
 1864 0f00 FCFEFFEA 		b	.L114
 1865              	.LVL136:
 1866              	.L121:
 456:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1867              		.loc 1 456 0 discriminator 1
 1868 0f04 000058E3 		cmp	r8, #0
 1869 0f08 8C02000A 		beq	.L196
 454:../uvc.c      **** 					 break;
 1870              		.loc 1 454 0
 1871 0f0c 28E1A0E1 		mov	lr, r8, lsr #2
 1872 0f10 00005EE3 		cmp	lr, #0
 1873 0f14 03005813 		cmpne	r8, #3
 1874 0f18 0020A083 		movhi	r2, #0
 1875 0f1c 0120A093 		movls	r2, #1
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1876              		.loc 1 388 0
 1877 0f20 0E31A0E1 		mov	r3, lr, asl #2
 454:../uvc.c      **** 					 break;
 1878              		.loc 1 454 0
 1879 0f24 8902009A 		bls	.L184
 1880 0f28 3C1A9FE5 		ldr	r1, .L206+16
 1881 0f2c 0C0041E2 		sub	r0, r1, #12
 1882              	.LVL137:
 1883              	.L128:
 457:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1884              		.loc 1 457 0 discriminator 2
 1885 0f30 044090E4 		ldr	r4, [r0], #4
 1886 0f34 01C082E2 		add	ip, r2, #1
 1887 0f38 FF200CE2 		and	r2, ip, #255
 1888 0f3c 02005EE1 		cmp	lr, r2
 1889 0f40 044081E4 		str	r4, [r1], #4
 1890 0f44 F9FFFF8A 		bhi	.L128
 457:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1891              		.loc 1 457 0 is_stmt 0
 1892 0f48 030058E1 		cmp	r8, r3
 1893 0f4c 140A9F15 		ldrne	r0, .L206+12
 1894 0f50 7A02000A 		beq	.L196
 1895              	.L188:
 1896 0f54 03E080E0 		add	lr, r0, r3
 1897 0f58 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 456:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1898              		.loc 1 456 0 is_stmt 1
 1899 0f5c 016083E2 		add	r6, r3, #1
 1900 0f60 FF3006E2 		and	r3, r6, #255
 1901              	.LVL138:
 1902 0f64 030058E1 		cmp	r8, r3
 457:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1903              		.loc 1 457 0
 1904 0f68 5810CEE5 		strb	r1, [lr, #88]
 456:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1905              		.loc 1 456 0
 1906 0f6c F8FFFF8A 		bhi	.L188
 1907              	.LVL139:
 1908              	.L125:
 466:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1909              		.loc 1 466 0
 1910 0f70 5770D0E5 		ldrb	r7, [r0, #87]	@ zero_extendqisi2
 1911              	.LVL140:
 459:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1912              		.loc 1 459 0
 1913 0f74 EC399FE5 		ldr	r3, .L206+12
 466:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1914              		.loc 1 466 0
 1915 0f78 FF0057E3 		cmp	r7, #255
 459:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1916              		.loc 1 459 0
 1917 0f7c 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1918              	.LVL141:
 460:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1919              		.loc 1 460 0
 1920 0f80 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 1921              	.LVL142:
 466:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1922              		.loc 1 466 0
 1923 0f84 D6FFFF0A 		beq	.L126
 468:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1924              		.loc 1 468 0
 1925 0f88 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1926 0f8c E4199FE5 		ldr	r1, .L206+28
 1927 0f90 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1928 0f94 0400A0E3 		mov	r0, #4
 1929 0f98 FEFFFFEB 		bl	CyU3PDebugPrint
 1930 0f9c D0FFFFEA 		b	.L126
 1931              	.LVL143:
 1932              	.L120:
 452:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 1933              		.loc 1 452 0
 1934 0fa0 C0399FE5 		ldr	r3, .L206+12
 442:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 1935              		.loc 1 442 0
 1936 0fa4 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 1937              	.LVL144:
 453:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1938              		.loc 1 453 0
 1939 0fa8 0020A0E3 		mov	r2, #0
 452:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 1940              		.loc 1 452 0
 1941 0fac 5840C3E5 		strb	r4, [r3, #88]
 453:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1942              		.loc 1 453 0
 1943 0fb0 5920C3E5 		strb	r2, [r3, #89]
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 1944              		.loc 1 406 0
 1945 0fb4 FF60A0E3 		mov	r6, #255
 454:../uvc.c      **** 					 break;
 1946              		.loc 1 454 0
 1947 0fb8 C9FFFFEA 		b	.L126
 1948              	.LVL145:
 1949              	.L119:
 472:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1950              		.loc 1 472 0
 1951 0fbc E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 1952 0fc0 A0C99FE5 		ldr	ip, .L206+12
 474:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1953              		.loc 1 474 0
 1954 0fc4 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1955              		.loc 1 473 0
 1956 0fc8 00E0A0E3 		mov	lr, #0
 472:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1957              		.loc 1 472 0
 1958 0fcc 5840CCE5 		strb	r4, [ip, #88]
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1959              		.loc 1 473 0
 1960 0fd0 59E0CCE5 		strb	lr, [ip, #89]
 474:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1961              		.loc 1 474 0
 1962 0fd4 5A60CCE5 		strb	r6, [ip, #90]
 475:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1963              		.loc 1 475 0
 1964 0fd8 5BE0CCE5 		strb	lr, [ip, #91]
 1965              	.LVL146:
 478:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 1966              		.loc 1 478 0
 1967 0fdc 98199FE5 		ldr	r1, .L206+32
 1968 0fe0 0420A0E1 		mov	r2, r4
 1969 0fe4 0E30A0E1 		mov	r3, lr
 1970 0fe8 0400A0E3 		mov	r0, #4
 1971 0fec 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 1972 0ff0 FEFFFFEB 		bl	CyU3PDebugPrint
 479:../uvc.c      **** 					 break;
 1973              		.loc 1 479 0
 1974 0ff4 BAFFFFEA 		b	.L126
 1975              	.LVL147:
 1976              	.L118:
 500:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 1977              		.loc 1 500 0
 1978 0ff8 68C99FE5 		ldr	ip, .L206+12
 1979 0ffc 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 502:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 1980              		.loc 1 502 0
 1981 1000 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1982              		.loc 1 501 0
 1983 1004 00E0A0E3 		mov	lr, #0
 500:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 1984              		.loc 1 500 0
 1985 1008 5840CCE5 		strb	r4, [ip, #88]
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1986              		.loc 1 501 0
 1987 100c 59E0CCE5 		strb	lr, [ip, #89]
 502:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 1988              		.loc 1 502 0
 1989 1010 5A60CCE5 		strb	r6, [ip, #90]
 503:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1990              		.loc 1 503 0
 1991 1014 5BE0CCE5 		strb	lr, [ip, #91]
 1992              	.LVL148:
 506:../uvc.c      **** 					 break;
 1993              		.loc 1 506 0
 1994 1018 B1FFFFEA 		b	.L126
 1995              	.LVL149:
 1996              	.L117:
 495:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 1997              		.loc 1 495 0
 1998 101c 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 1999 1020 40799FE5 		ldr	r7, .L206+12
 2000              	.LVL150:
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2001              		.loc 1 496 0
 2002 1024 0060A0E3 		mov	r6, #0
 495:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2003              		.loc 1 495 0
 2004 1028 804024E2 		eor	r4, r4, #128
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2005              		.loc 1 496 0
 2006 102c 5960C7E5 		strb	r6, [r7, #89]
 2007              	.LVL151:
 495:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2008              		.loc 1 495 0
 2009 1030 5840C7E5 		strb	r4, [r7, #88]
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2010              		.loc 1 406 0
 2011 1034 FF60A0E3 		mov	r6, #255
 498:../uvc.c      **** 					 break;
 2012              		.loc 1 498 0
 2013 1038 A9FFFFEA 		b	.L126
 2014              	.LVL152:
 2015              	.L116:
 484:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2016              		.loc 1 484 0
 2017 103c A631D6E5 		ldrb	r3, [r6, #422]	@ zero_extendqisi2
 482:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2018              		.loc 1 482 0
 2019 1040 A511D6E5 		ldrb	r1, [r6, #421]	@ zero_extendqisi2
 2020              	.LVL153:
 484:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2021              		.loc 1 484 0
 2022 1044 020013E3 		tst	r3, #2
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2023              		.loc 1 487 0
 2024 1048 2111A001 		moveq	r1, r1, lsr #2
 2025              	.LVL154:
 2026 104c 811CE001 		mvneq	r1, r1, asl #25
 489:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2027              		.loc 1 489 0
 2028 1050 10299FE5 		ldr	r2, .L206+12
 485:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2029              		.loc 1 485 0
 2030 1054 0333A011 		movne	r3, r3, asl #6
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2031              		.loc 1 487 0
 2032 1058 A11CE001 		mvneq	r1, r1, lsr #25
 485:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2033              		.loc 1 485 0
 2034 105c 40400312 		andne	r4, r3, #64
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2035              		.loc 1 487 0
 2036 1060 03338101 		orreq	r3, r1, r3, asl #6
 485:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2037              		.loc 1 485 0
 2038 1064 21418411 		orrne	r4, r4, r1, lsr #2
 2039              	.LVL155:
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2040              		.loc 1 487 0
 2041 1068 FF400302 		andeq	r4, r3, #255
 2042              	.LVL156:
 490:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2043              		.loc 1 490 0
 2044 106c 0000A0E3 		mov	r0, #0
 489:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2045              		.loc 1 489 0
 2046 1070 5840C2E5 		strb	r4, [r2, #88]
 490:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2047              		.loc 1 490 0
 2048 1074 5900C2E5 		strb	r0, [r2, #89]
 2049              	.LVL157:
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2050              		.loc 1 406 0
 2051 1078 FF60A0E3 		mov	r6, #255
 492:../uvc.c      **** 					 break;
 2052              		.loc 1 492 0
 2053 107c 98FFFFEA 		b	.L126
 2054              	.LVL158:
 2055              	.L115:
 509:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2056              		.loc 1 509 0
 2057 1080 841084E0 		add	r1, r4, r4, asl #1
 2058 1084 813186E0 		add	r3, r6, r1, asl #3
 2059 1088 D8289FE5 		ldr	r2, .L206+12
 2060 108c 8D41D3E5 		ldrb	r4, [r3, #397]	@ zero_extendqisi2
 510:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2061              		.loc 1 510 0
 2062 1090 0000A0E3 		mov	r0, #0
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2063              		.loc 1 406 0
 2064 1094 FF60A0E3 		mov	r6, #255
 509:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2065              		.loc 1 509 0
 2066 1098 5840C2E5 		strb	r4, [r2, #88]
 510:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2067              		.loc 1 510 0
 2068 109c 5900C2E5 		strb	r0, [r2, #89]
 2069              	.LVL159:
 512:../uvc.c      **** 					 break;
 2070              		.loc 1 512 0
 2071 10a0 8FFFFFEA 		b	.L126
 2072              	.LVL160:
 2073              	.L162:
 759:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2074              		.loc 1 759 0
 2075 10a4 D4489FE5 		ldr	r4, .L206+36
 2076 10a8 0010E0E3 		mvn	r1, #0
 2077 10ac 1C0094E5 		ldr	r0, [r4, #28]
 2078 10b0 FEFFFFEB 		bl	_txe_mutex_get
 2079              	.LVL161:
 760:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2080              		.loc 1 760 0
 2081 10b4 2210A0E3 		mov	r1, #34
 2082              	.L200:
 2083 10b8 14C09DE5 		ldr	ip, [sp, #20]
 2084 10bc 00E0A0E3 		mov	lr, #0
 2085 10c0 0A30A0E1 		mov	r3, sl
 2086 10c4 0920A0E1 		mov	r2, r9
 2087 10c8 0400A0E1 		mov	r0, r4
 2088 10cc 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2089 10d0 FEFFFFEB 		bl	cmdSet
 761:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2090              		.loc 1 761 0
 2091 10d4 1C0094E5 		ldr	r0, [r4, #28]
 2092 10d8 FEFFFFEB 		bl	_txe_mutex_put
 762:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2093              		.loc 1 762 0
 2094 10dc 14109DE5 		ldr	r1, [sp, #20]
 2095 10e0 873087E0 		add	r3, r7, r7, asl #1
 2096 10e4 836186E0 		add	r6, r6, r3, asl #3
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2097              		.loc 1 763 0
 2098 10e8 0170A0E3 		mov	r7, #1
 2099              	.LVL162:
 764:../uvc.c      **** 							 break;
 2100              		.loc 1 764 0
 2101 10ec FFC0A0E3 		mov	ip, #255
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2102              		.loc 1 763 0
 2103 10f0 1070C6E5 		strb	r7, [r6, #16]
 762:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2104              		.loc 1 762 0
 2105 10f4 0D10C6E5 		strb	r1, [r6, #13]
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2106              		.loc 1 763 0
 2107 10f8 0140A0E1 		mov	r4, r1
 2108 10fc 18E09DE5 		ldr	lr, [sp, #24]
 764:../uvc.c      **** 							 break;
 2109              		.loc 1 764 0
 2110 1100 0C70A0E1 		mov	r7, ip
 2111 1104 7BFEFFEA 		b	.L114
 2112              	.LVL163:
 2113              	.L161:
 751:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2114              		.loc 1 751 0
 2115 1108 70489FE5 		ldr	r4, .L206+36
 2116 110c 0010E0E3 		mvn	r1, #0
 2117 1110 1C0094E5 		ldr	r0, [r4, #28]
 2118 1114 FEFFFFEB 		bl	_txe_mutex_get
 2119              	.LVL164:
 752:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2120              		.loc 1 752 0
 2121 1118 2110A0E3 		mov	r1, #33
 2122 111c E5FFFFEA 		b	.L200
 2123              	.LVL165:
 2124              	.L160:
 737:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2125              		.loc 1 737 0
 2126 1120 58489FE5 		ldr	r4, .L206+36
 2127 1124 0010E0E3 		mvn	r1, #0
 2128 1128 1C0094E5 		ldr	r0, [r4, #28]
 2129 112c FEFFFFEB 		bl	_txe_mutex_get
 2130              	.LVL166:
 736:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2131              		.loc 1 736 0
 2132 1130 14209DE5 		ldr	r2, [sp, #20]
 739:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2133              		.loc 1 739 0
 2134 1134 2010A0E3 		mov	r1, #32
 736:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2135              		.loc 1 736 0
 2136 1138 7F8002E2 		and	r8, r2, #127
 2137 113c 18808DE5 		str	r8, [sp, #24]
 2138              	.LVL167:
 739:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2139              		.loc 1 739 0
 2140 1140 18C09DE5 		ldr	ip, [sp, #24]
 2141 1144 0920A0E1 		mov	r2, r9
 2142 1148 0A30A0E1 		mov	r3, sl
 2143 114c 0400A0E1 		mov	r0, r4
 2144 1150 00C08DE5 		str	ip, [sp, #0]
 2145 1154 00C0A0E3 		mov	ip, #0
 2146 1158 04C08DE5 		str	ip, [sp, #4]
 2147 115c FEFFFFEB 		bl	cmdSet
 2148              	.LVL168:
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2149              		.loc 1 741 0
 2150 1160 1CE09DE5 		ldr	lr, [sp, #28]
 2151 1164 0180A0E3 		mov	r8, #1
 2152 1168 2010A0E3 		mov	r1, #32
 2153 116c 0B20A0E1 		mov	r2, fp
 2154 1170 0A30A0E1 		mov	r3, sl
 2155 1174 0400A0E1 		mov	r0, r4
 2156 1178 00E08DE5 		str	lr, [sp, #0]
 2157 117c 04808DE5 		str	r8, [sp, #4]
 2158 1180 FEFFFFEB 		bl	cmdSet
 742:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2159              		.loc 1 742 0
 2160 1184 1C0094E5 		ldr	r0, [r4, #28]
 2161 1188 FEFFFFEB 		bl	_txe_mutex_put
 2162              	.LVL169:
 745:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2163              		.loc 1 745 0
 2164 118c 18409DE5 		ldr	r4, [sp, #24]
 746:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2165              		.loc 1 746 0
 2166 1190 1C009DE5 		ldr	r0, [sp, #28]
 745:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2167              		.loc 1 745 0
 2168 1194 87C087E0 		add	ip, r7, r7, asl #1
 2169 1198 8C6186E0 		add	r6, r6, ip, asl #3
 748:../uvc.c      **** 							 break;
 2170              		.loc 1 748 0
 2171 119c FFC0A0E3 		mov	ip, #255
 745:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2172              		.loc 1 745 0
 2173 11a0 0D40C6E5 		strb	r4, [r6, #13]
 746:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2174              		.loc 1 746 0
 2175 11a4 0E00C6E5 		strb	r0, [r6, #14]
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2176              		.loc 1 747 0
 2177 11a8 1080C6E5 		strb	r8, [r6, #16]
 2178 11ac 14409DE5 		ldr	r4, [sp, #20]
 2179 11b0 00E0A0E1 		mov	lr, r0
 748:../uvc.c      **** 							 break;
 2180              		.loc 1 748 0
 2181 11b4 0C70A0E1 		mov	r7, ip
 2182              	.LVL170:
 2183 11b8 4EFEFFEA 		b	.L114
 2184              	.LVL171:
 2185              	.L159:
 708:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2186              		.loc 1 708 0 discriminator 1
 2187 11bc 000058E3 		cmp	r8, #0
 2188 11c0 1800000A 		beq	.L165
 706:../uvc.c      **** 							 break;
 2189              		.loc 1 706 0
 2190 11c4 28E1A0E1 		mov	lr, r8, lsr #2
 2191 11c8 00005EE3 		cmp	lr, #0
 2192 11cc 03005813 		cmpne	r8, #3
 2193 11d0 0020A083 		movhi	r2, #0
 2194 11d4 0120A093 		movls	r2, #1
 2195              	.LVL172:
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2196              		.loc 1 388 0
 2197 11d8 0E31A0E1 		mov	r3, lr, asl #2
 706:../uvc.c      **** 							 break;
 2198              		.loc 1 706 0
 2199 11dc D901009A 		bls	.L185
 2200 11e0 9C179FE5 		ldr	r1, .L206+40
 2201 11e4 0C0081E2 		add	r0, r1, #12
 2202              	.LVL173:
 2203              	.L176:
 709:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2204              		.loc 1 709 0 discriminator 2
 2205 11e8 044090E4 		ldr	r4, [r0], #4
 2206 11ec 012082E2 		add	r2, r2, #1
 2207 11f0 FF2002E2 		and	r2, r2, #255
 2208 11f4 02005EE1 		cmp	lr, r2
 2209 11f8 044081E4 		str	r4, [r1], #4
 2210 11fc F9FFFF8A 		bhi	.L176
 709:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2211              		.loc 1 709 0 is_stmt 0
 2212 1200 030058E1 		cmp	r8, r3
 2213 1204 0700000A 		beq	.L165
 2214              	.LVL174:
 2215              	.L189:
 2216 1208 58E79FE5 		ldr	lr, .L206+12
 2217 120c 03708EE0 		add	r7, lr, r3
 2218 1210 5810D7E5 		ldrb	r1, [r7, #88]	@ zero_extendqisi2
 708:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2219              		.loc 1 708 0 is_stmt 1
 2220 1214 013083E2 		add	r3, r3, #1
 2221 1218 FF3003E2 		and	r3, r3, #255
 2222              	.LVL175:
 2223 121c 030058E1 		cmp	r8, r3
 709:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2224              		.loc 1 709 0
 2225 1220 4C10C7E5 		strb	r1, [r7, #76]
 708:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2226              		.loc 1 708 0
 2227 1224 F7FFFF8A 		bhi	.L189
 2228              	.LVL176:
 2229              	.L165:
 711:../uvc.c      **** 					 		I2CCmdHandler();
 2230              		.loc 1 711 0
 2231 1228 FEFFFFEB 		bl	I2CCmdHandler
 712:../uvc.c      **** 							 break;
 2232              		.loc 1 712 0
 2233 122c FFC0A0E3 		mov	ip, #255
 711:../uvc.c      **** 					 		I2CCmdHandler();
 2234              		.loc 1 711 0
 2235 1230 14409DE5 		ldr	r4, [sp, #20]
 2236 1234 18E09DE5 		ldr	lr, [sp, #24]
 712:../uvc.c      **** 							 break;
 2237              		.loc 1 712 0
 2238 1238 0C70A0E1 		mov	r7, ip
 2239 123c 2DFEFFEA 		b	.L114
 2240              	.LVL177:
 2241              	.L158:
 702:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2242              		.loc 1 702 0
 2243 1240 38779FE5 		ldr	r7, .L206+36
 2244              	.LVL178:
 2245 1244 0010E0E3 		mvn	r1, #0
 2246 1248 1C0097E5 		ldr	r0, [r7, #28]
 2247 124c FEFFFFEB 		bl	_txe_mutex_get
 2248              	.LVL179:
 703:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2249              		.loc 1 703 0
 2250 1250 14009DE5 		ldr	r0, [sp, #20]
 2251 1254 00E0A0E3 		mov	lr, #0
 2252 1258 01C070E2 		rsbs	ip, r0, #1
 2253 125c 00C0A033 		movcc	ip, #0
 2254 1260 1E10A0E3 		mov	r1, #30
 2255 1264 0920A0E1 		mov	r2, r9
 2256 1268 0A30A0E1 		mov	r3, sl
 2257 126c 0700A0E1 		mov	r0, r7
 2258 1270 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2259 1274 FEFFFFEB 		bl	cmdSet
 704:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2260              		.loc 1 704 0
 2261 1278 1C0097E5 		ldr	r0, [r7, #28]
 2262 127c FEFFFFEB 		bl	_txe_mutex_put
 705:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2263              		.loc 1 705 0
 2264 1280 0140A0E3 		mov	r4, #1
 706:../uvc.c      **** 							 break;
 2265              		.loc 1 706 0
 2266 1284 FFC0A0E3 		mov	ip, #255
 705:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2267              		.loc 1 705 0
 2268 1288 6044C6E5 		strb	r4, [r6, #1120]
 2269 128c 18E09DE5 		ldr	lr, [sp, #24]
 2270 1290 14409DE5 		ldr	r4, [sp, #20]
 706:../uvc.c      **** 							 break;
 2271              		.loc 1 706 0
 2272 1294 0C70A0E1 		mov	r7, ip
 2273 1298 16FEFFEA 		b	.L114
 2274              	.LVL180:
 2275              	.L157:
 615:../uvc.c      **** 				  switch(CtrlID)
 2276              		.loc 1 615 0
 2277 129c FFC0A0E3 		mov	ip, #255
 2278 12a0 0340A0E1 		mov	r4, r3
 2279 12a4 0C70A0E1 		mov	r7, ip
 2280              	.LVL181:
 2281 12a8 12FEFFEA 		b	.L114
 2282              	.LVL182:
 2283              	.L156:
 669:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2284              		.loc 1 669 0
 2285 12ac CC769FE5 		ldr	r7, .L206+36
 2286              	.LVL183:
 667:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2287              		.loc 1 667 0
 2288 12b0 FD33C6E5 		strb	r3, [r6, #1021]
 668:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2289              		.loc 1 668 0
 2290 12b4 0130A0E3 		mov	r3, #1
 2291 12b8 0034C6E5 		strb	r3, [r6, #1024]
 669:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2292              		.loc 1 669 0
 2293 12bc 0010E0E3 		mvn	r1, #0
 2294 12c0 1C0097E5 		ldr	r0, [r7, #28]
 2295 12c4 FEFFFFEB 		bl	_txe_mutex_get
 2296              	.LVL184:
 670:../uvc.c      **** 							 if(WDRflag)
 2297              		.loc 1 670 0
 2298 12c8 10C696E5 		ldr	ip, [r6, #1552]
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2299              		.loc 1 671 0
 2300 12cc 1A10A0E3 		mov	r1, #26
 670:../uvc.c      **** 							 if(WDRflag)
 2301              		.loc 1 670 0
 2302 12d0 00005CE3 		cmp	ip, #0
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2303              		.loc 1 671 0
 2304 12d4 14C09D15 		ldrne	ip, [sp, #20]
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2305              		.loc 1 673 0
 2306 12d8 14E09D05 		ldreq	lr, [sp, #20]
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2307              		.loc 1 671 0
 2308 12dc 00C08D15 		strne	ip, [sp, #0]
 2309 12e0 0B20A011 		movne	r2, fp
 2310 12e4 00C0A013 		movne	ip, #0
 2311 12e8 0A30A011 		movne	r3, sl
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2312              		.loc 1 673 0
 2313 12ec 0920A001 		moveq	r2, r9
 2314 12f0 0A30A001 		moveq	r3, sl
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2315              		.loc 1 671 0
 2316 12f4 0700A0E1 		mov	r0, r7
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2317              		.loc 1 673 0
 2318 12f8 04C08DE5 		str	ip, [sp, #4]
 2319 12fc 00E08D05 		streq	lr, [sp, #0]
 2320 1300 FEFFFFEB 		bl	cmdSet
 674:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2321              		.loc 1 674 0
 2322 1304 1C0097E5 		ldr	r0, [r7, #28]
 2323 1308 FEFFFFEB 		bl	_txe_mutex_put
 675:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2324              		.loc 1 675 0
 2325 130c 54269FE5 		ldr	r2, .L206+12
 2326 1310 103696E5 		ldr	r3, [r6, #1552]
 2327 1314 5AC0D2E5 		ldrb	ip, [r2, #90]	@ zero_extendqisi2
 2328 1318 5BE0D2E5 		ldrb	lr, [r2, #91]	@ zero_extendqisi2
 2329 131c 14409DE5 		ldr	r4, [sp, #20]
 2330 1320 60169FE5 		ldr	r1, .L206+44
 2331 1324 0400A0E3 		mov	r0, #4
 2332              	.L199:
 871:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2333              		.loc 1 871 0
 2334 1328 0420A0E1 		mov	r2, r4
 2335 132c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2336 1330 FEFFFFEB 		bl	CyU3PDebugPrint
 873:../uvc.c      **** 					 		 break;
 2337              		.loc 1 873 0
 2338 1334 FFC0A0E3 		mov	ip, #255
 871:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2339              		.loc 1 871 0
 2340 1338 18E09DE5 		ldr	lr, [sp, #24]
 873:../uvc.c      **** 					 		 break;
 2341              		.loc 1 873 0
 2342 133c 0C70A0E1 		mov	r7, ip
 2343 1340 ECFDFFEA 		b	.L114
 2344              	.LVL185:
 2345              	.L155:
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2346              		.loc 1 656 0
 2347 1344 34469FE5 		ldr	r4, .L206+36
 652:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2348              		.loc 1 652 0
 2349 1348 E533C6E5 		strb	r3, [r6, #997]
 653:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2350              		.loc 1 653 0
 2351 134c 18309DE5 		ldr	r3, [sp, #24]
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2352              		.loc 1 654 0
 2353 1350 0170A0E3 		mov	r7, #1
 2354              	.LVL186:
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2355              		.loc 1 656 0
 2356 1354 0010E0E3 		mvn	r1, #0
 653:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2357              		.loc 1 653 0
 2358 1358 E633C6E5 		strb	r3, [r6, #998]
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2359              		.loc 1 656 0
 2360 135c 1C0094E5 		ldr	r0, [r4, #28]
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2361              		.loc 1 654 0
 2362 1360 E873C6E5 		strb	r7, [r6, #1000]
 2363              	.LVL187:
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2364              		.loc 1 656 0
 2365 1364 FEFFFFEB 		bl	_txe_mutex_get
 2366              	.LVL188:
 657:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2367              		.loc 1 657 0
 2368 1368 14C09DE5 		ldr	ip, [sp, #20]
 2369 136c 1910A0E3 		mov	r1, #25
 2370 1370 00C08DE5 		str	ip, [sp, #0]
 2371 1374 0400A0E1 		mov	r0, r4
 2372 1378 00C0A0E3 		mov	ip, #0
 2373 137c 0920A0E1 		mov	r2, r9
 2374 1380 0A30A0E1 		mov	r3, sl
 2375 1384 04C08DE5 		str	ip, [sp, #4]
 2376 1388 FEFFFFEB 		bl	cmdSet
 658:../uvc.c      **** 							 if(getData != 0){
 2377              		.loc 1 658 0
 2378 138c 14109DE5 		ldr	r1, [sp, #20]
 2379 1390 000051E3 		cmp	r1, #0
 2380 1394 0700000A 		beq	.L172
 2381              	.LVL189:
 660:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2382              		.loc 1 660 0
 2383 1398 18E09DE5 		ldr	lr, [sp, #24]
 2384 139c 0400A0E1 		mov	r0, r4
 2385 13a0 1910A0E3 		mov	r1, #25
 2386 13a4 0B20A0E1 		mov	r2, fp
 2387 13a8 0A30A0E1 		mov	r3, sl
 2388 13ac 00E08DE5 		str	lr, [sp, #0]
 2389 13b0 04708DE5 		str	r7, [sp, #4]
 2390 13b4 FEFFFFEB 		bl	cmdSet
 2391              	.LVL190:
 2392              	.L172:
 662:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2393              		.loc 1 662 0
 2394 13b8 1C0094E5 		ldr	r0, [r4, #28]
 2395 13bc FEFFFFEB 		bl	_txe_mutex_put
 663:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2396              		.loc 1 663 0
 2397 13c0 A0159FE5 		ldr	r1, .L206+12
 2398 13c4 9C059FE5 		ldr	r0, .L206+12
 2399 13c8 5A40D1E5 		ldrb	r4, [r1, #90]	@ zero_extendqisi2
 2400 13cc 5B70D0E5 		ldrb	r7, [r0, #91]	@ zero_extendqisi2
 2401 13d0 5820D1E5 		ldrb	r2, [r1, #88]	@ zero_extendqisi2
 2402 13d4 5930D1E5 		ldrb	r3, [r1, #89]	@ zero_extendqisi2
 2403 13d8 0400A0E3 		mov	r0, #4
 2404 13dc A8159FE5 		ldr	r1, .L206+48
 2405 13e0 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2406 13e4 FEFFFFEB 		bl	CyU3PDebugPrint
 664:../uvc.c      **** 							 break;
 2407              		.loc 1 664 0
 2408 13e8 FFC0A0E3 		mov	ip, #255
 663:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2409              		.loc 1 663 0
 2410 13ec 14409DE5 		ldr	r4, [sp, #20]
 2411 13f0 18E09DE5 		ldr	lr, [sp, #24]
 664:../uvc.c      **** 							 break;
 2412              		.loc 1 664 0
 2413 13f4 0C70A0E1 		mov	r7, ip
 2414 13f8 BEFDFFEA 		b	.L114
 2415              	.LVL191:
 2416              	.L154:
 619:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2417              		.loc 1 619 0
 2418 13fc 000053E2 		subs	r0, r3, #0
 618:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2419              		.loc 1 618 0
 2420 1400 0D03C6E5 		strb	r0, [r6, #781]
 2421 1404 50359FE5 		ldr	r3, .L206
 619:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2422              		.loc 1 619 0
 2423 1408 3701001A 		bne	.L166
 620:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2424              		.loc 1 620 0
 2425 140c B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2426              	.LVL192:
 2427 1410 020052E3 		cmp	r2, #2
 2428 1414 08005213 		cmpne	r2, #8
 2429 1418 0300000A 		beq	.L167
 621:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2430              		.loc 1 621 0
 2431 141c 010052E3 		cmp	r2, #1
 622:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2432              		.loc 1 622 0
 2433 1420 07208202 		addeq	r2, r2, #7
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2434              		.loc 1 624 0
 2435 1424 0220A013 		movne	r2, #2
 2436 1428 B524C3E5 		strb	r2, [r3, #1205]
 2437              	.LVL193:
 2438              	.L167:
 646:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2439              		.loc 1 646 0
 2440 142c 4C459FE5 		ldr	r4, .L206+36
 644:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2441              		.loc 1 644 0
 2442 1430 0120A0E3 		mov	r2, #1
 646:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2443              		.loc 1 646 0
 2444 1434 0010E0E3 		mvn	r1, #0
 2445 1438 1C0094E5 		ldr	r0, [r4, #28]
 644:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2446              		.loc 1 644 0
 2447 143c 1023C6E5 		strb	r2, [r6, #784]
 2448              	.LVL194:
 646:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2449              		.loc 1 646 0
 2450 1440 FEFFFFEB 		bl	_txe_mutex_get
 647:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2451              		.loc 1 647 0
 2452 1444 14C09DE5 		ldr	ip, [sp, #20]
 2453 1448 00E0A0E3 		mov	lr, #0
 2454 144c 1010A0E3 		mov	r1, #16
 2455 1450 0920A0E1 		mov	r2, r9
 2456 1454 0A30A0E1 		mov	r3, sl
 2457 1458 0400A0E1 		mov	r0, r4
 2458 145c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2459 1460 FEFFFFEB 		bl	cmdSet
 648:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2460              		.loc 1 648 0
 2461 1464 1C0094E5 		ldr	r0, [r4, #28]
 2462 1468 FEFFFFEB 		bl	_txe_mutex_put
 650:../uvc.c      **** 							 break;
 2463              		.loc 1 650 0
 2464 146c FFC0A0E3 		mov	ip, #255
 648:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2465              		.loc 1 648 0
 2466 1470 14409DE5 		ldr	r4, [sp, #20]
 2467 1474 18E09DE5 		ldr	lr, [sp, #24]
 650:../uvc.c      **** 							 break;
 2468              		.loc 1 650 0
 2469 1478 0C70A0E1 		mov	r7, ip
 2470 147c 9DFDFFEA 		b	.L114
 2471              	.LVL195:
 2472              	.L153:
 825:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2473              		.loc 1 825 0
 2474 1480 F8449FE5 		ldr	r4, .L206+36
 2475 1484 0010E0E3 		mvn	r1, #0
 2476 1488 1C0094E5 		ldr	r0, [r4, #28]
 2477 148c FEFFFFEB 		bl	_txe_mutex_get
 2478              	.LVL196:
 826:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2479              		.loc 1 826 0
 2480 1490 14C09DE5 		ldr	ip, [sp, #20]
 2481 1494 0B10A0E3 		mov	r1, #11
 2482 1498 0920A0E1 		mov	r2, r9
 2483 149c 0A30A0E1 		mov	r3, sl
 2484 14a0 0400A0E1 		mov	r0, r4
 2485 14a4 00C08DE5 		str	ip, [sp, #0]
 2486 14a8 00C0A0E3 		mov	ip, #0
 2487 14ac 04C08DE5 		str	ip, [sp, #4]
 2488 14b0 FEFFFFEB 		bl	cmdSet
 2489              	.LVL197:
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2490              		.loc 1 828 0
 2491 14b4 18E09DE5 		ldr	lr, [sp, #24]
 2492 14b8 0170A0E3 		mov	r7, #1
 2493              	.LVL198:
 2494 14bc 0B20A0E1 		mov	r2, fp
 2495 14c0 0B10A0E3 		mov	r1, #11
 2496 14c4 0A30A0E1 		mov	r3, sl
 2497 14c8 0400A0E1 		mov	r0, r4
 2498 14cc 00E08DE5 		str	lr, [sp, #0]
 2499 14d0 04708DE5 		str	r7, [sp, #4]
 2500 14d4 FEFFFFEB 		bl	cmdSet
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2501              		.loc 1 829 0
 2502 14d8 1C0094E5 		ldr	r0, [r4, #28]
 2503 14dc FEFFFFEB 		bl	_txe_mutex_put
 831:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2504              		.loc 1 831 0
 2505 14e0 14009DE5 		ldr	r0, [sp, #20]
 832:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2506              		.loc 1 832 0
 2507 14e4 18209DE5 		ldr	r2, [sp, #24]
 834:../uvc.c      **** 							 break;
 2508              		.loc 1 834 0
 2509 14e8 FFC0A0E3 		mov	ip, #255
 833:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2510              		.loc 1 833 0
 2511 14ec 9872C6E5 		strb	r7, [r6, #664]
 831:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2512              		.loc 1 831 0
 2513 14f0 8C04C6E5 		strb	r0, [r6, #1164]
 832:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2514              		.loc 1 832 0
 2515 14f4 8E24C6E5 		strb	r2, [r6, #1166]
 833:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2516              		.loc 1 833 0
 2517 14f8 0040A0E1 		mov	r4, r0
 2518 14fc 02E0A0E1 		mov	lr, r2
 834:../uvc.c      **** 							 break;
 2519              		.loc 1 834 0
 2520 1500 0C70A0E1 		mov	r7, ip
 2521 1504 7BFDFFEA 		b	.L114
 2522              	.LVL199:
 2523              	.L152:
 811:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2524              		.loc 1 811 0
 2525 1508 70449FE5 		ldr	r4, .L206+36
 2526 150c 0010E0E3 		mvn	r1, #0
 2527 1510 1C0094E5 		ldr	r0, [r4, #28]
 2528 1514 FEFFFFEB 		bl	_txe_mutex_get
 2529              	.LVL200:
 812:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2530              		.loc 1 812 0
 2531 1518 14C09DE5 		ldr	ip, [sp, #20]
 2532 151c 0610A0E3 		mov	r1, #6
 2533 1520 0920A0E1 		mov	r2, r9
 2534 1524 0A30A0E1 		mov	r3, sl
 2535 1528 0400A0E1 		mov	r0, r4
 2536 152c 00C08DE5 		str	ip, [sp, #0]
 2537 1530 00C0A0E3 		mov	ip, #0
 2538 1534 04C08DE5 		str	ip, [sp, #4]
 2539 1538 FEFFFFEB 		bl	cmdSet
 2540              	.LVL201:
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2541              		.loc 1 814 0
 2542 153c 14E09DE5 		ldr	lr, [sp, #20]
 2543 1540 0170A0E3 		mov	r7, #1
 2544              	.LVL202:
 2545 1544 0610A0E3 		mov	r1, #6
 2546 1548 0B20A0E1 		mov	r2, fp
 2547 154c 0A30A0E1 		mov	r3, sl
 2548 1550 0400A0E1 		mov	r0, r4
 2549 1554 00E08DE5 		str	lr, [sp, #0]
 2550 1558 04708DE5 		str	r7, [sp, #4]
 2551 155c FEFFFFEB 		bl	cmdSet
 815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2552              		.loc 1 815 0
 2553 1560 1C0094E5 		ldr	r0, [r4, #28]
 2554 1564 FEFFFFEB 		bl	_txe_mutex_put
 816:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2555              		.loc 1 816 0
 2556 1568 14409DE5 		ldr	r4, [sp, #20]
 818:../uvc.c      **** 							 break;
 2557              		.loc 1 818 0
 2558 156c FFC0A0E3 		mov	ip, #255
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2559              		.loc 1 817 0
 2560 1570 2072C6E5 		strb	r7, [r6, #544]
 816:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2561              		.loc 1 816 0
 2562 1574 1D42C6E5 		strb	r4, [r6, #541]
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2563              		.loc 1 817 0
 2564 1578 18E09DE5 		ldr	lr, [sp, #24]
 818:../uvc.c      **** 							 break;
 2565              		.loc 1 818 0
 2566 157c 0C70A0E1 		mov	r7, ip
 2567 1580 5CFDFFEA 		b	.L114
 2568              	.LVL203:
 2569              	.L151:
 791:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2570              		.loc 1 791 0
 2571 1584 F4439FE5 		ldr	r4, .L206+36
 2572 1588 0010E0E3 		mvn	r1, #0
 2573 158c 1C0094E5 		ldr	r0, [r4, #28]
 2574 1590 FEFFFFEB 		bl	_txe_mutex_get
 2575              	.LVL204:
 792:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2576              		.loc 1 792 0
 2577 1594 14309DE5 		ldr	r3, [sp, #20]
 2578 1598 00C0A0E3 		mov	ip, #0
 2579 159c 801043E2 		sub	r1, r3, #128
 2580 15a0 FF7001E2 		and	r7, r1, #255
 2581              	.LVL205:
 2582 15a4 0920A0E1 		mov	r2, r9
 2583 15a8 0510A0E3 		mov	r1, #5
 2584 15ac 0A30A0E1 		mov	r3, sl
 2585 15b0 0400A0E1 		mov	r0, r4
 2586 15b4 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2587 15b8 FEFFFFEB 		bl	cmdSet
 2588              	.LVL206:
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2589              		.loc 1 794 0
 2590 15bc 14009DE5 		ldr	r0, [sp, #20]
 2591 15c0 0510A0E3 		mov	r1, #5
 2592 15c4 767040E2 		sub	r7, r0, #118
 2593 15c8 FFC007E2 		and	ip, r7, #255
 2594 15cc DC20A0E3 		mov	r2, #220
 2595 15d0 0170A0E3 		mov	r7, #1
 2596 15d4 0A30A0E1 		mov	r3, sl
 2597 15d8 0400A0E1 		mov	r0, r4
 2598 15dc 00C08DE5 		str	ip, [sp, #0]
 2599 15e0 04708DE5 		str	r7, [sp, #4]
 2600 15e4 FEFFFFEB 		bl	cmdSet
 2601              	.LVL207:
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2602              		.loc 1 796 0
 2603 15e8 14209DE5 		ldr	r2, [sp, #20]
 2604 15ec 0510A0E3 		mov	r1, #5
 2605 15f0 7E3082E2 		add	r3, r2, #126
 2606 15f4 FFC003E2 		and	ip, r3, #255
 2607 15f8 DE20A0E3 		mov	r2, #222
 2608 15fc 0A30A0E1 		mov	r3, sl
 2609 1600 0400A0E1 		mov	r0, r4
 2610 1604 00C08DE5 		str	ip, [sp, #0]
 2611 1608 02C0A0E3 		mov	ip, #2
 2612 160c 04C08DE5 		str	ip, [sp, #4]
 2613 1610 FEFFFFEB 		bl	cmdSet
 2614              	.LVL208:
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2615              		.loc 1 798 0
 2616 1614 14109DE5 		ldr	r1, [sp, #20]
 2617 1618 03E0A0E3 		mov	lr, #3
 2618 161c 720081E2 		add	r0, r1, #114
 2619 1620 FFC000E2 		and	ip, r0, #255
 2620 1624 0510A0E3 		mov	r1, #5
 2621 1628 E020A0E3 		mov	r2, #224
 2622 162c 0A30A0E1 		mov	r3, sl
 2623 1630 0400A0E1 		mov	r0, r4
 2624 1634 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2625 1638 FEFFFFEB 		bl	cmdSet
 2626              	.LVL209:
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2627              		.loc 1 800 0
 2628 163c 14209DE5 		ldr	r2, [sp, #20]
 2629 1640 0510A0E3 		mov	r1, #5
 2630 1644 6F3042E2 		sub	r3, r2, #111
 2631 1648 FFC003E2 		and	ip, r3, #255
 2632 164c DD20A0E3 		mov	r2, #221
 2633 1650 0A30A0E1 		mov	r3, sl
 2634 1654 0400A0E1 		mov	r0, r4
 2635 1658 00C08DE5 		str	ip, [sp, #0]
 2636 165c 04C0A0E3 		mov	ip, #4
 2637 1660 04C08DE5 		str	ip, [sp, #4]
 2638 1664 FEFFFFEB 		bl	cmdSet
 2639              	.LVL210:
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2640              		.loc 1 802 0
 2641 1668 F8129FE5 		ldr	r1, .L206+12
 2642 166c 05E0A0E3 		mov	lr, #5
 2643 1670 5800D1E5 		ldrb	r0, [r1, #88]	@ zero_extendqisi2
 2644 1674 0A30A0E1 		mov	r3, sl
 2645 1678 7F2080E2 		add	r2, r0, #127
 2646 167c FFC002E2 		and	ip, r2, #255
 2647 1680 0E10A0E1 		mov	r1, lr
 2648 1684 0B20A0E1 		mov	r2, fp
 2649 1688 0400A0E1 		mov	r0, r4
 2650 168c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2651 1690 FEFFFFEB 		bl	cmdSet
 803:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2652              		.loc 1 803 0
 2653 1694 1C0094E5 		ldr	r0, [r4, #28]
 2654 1698 FEFFFFEB 		bl	_txe_mutex_put
 805:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2655              		.loc 1 805 0
 2656 169c C4429FE5 		ldr	r4, .L206+12
 807:../uvc.c      **** 							 break;
 2657              		.loc 1 807 0
 2658 16a0 FFC0A0E3 		mov	ip, #255
 805:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2659              		.loc 1 805 0
 2660 16a4 5830D4E5 		ldrb	r3, [r4, #88]	@ zero_extendqisi2
 806:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2661              		.loc 1 806 0
 2662 16a8 0872C6E5 		strb	r7, [r6, #520]
 805:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2663              		.loc 1 805 0
 2664 16ac 801043E2 		sub	r1, r3, #128
 2665 16b0 0512C6E5 		strb	r1, [r6, #517]
 806:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2666              		.loc 1 806 0
 2667 16b4 14409DE5 		ldr	r4, [sp, #20]
 2668 16b8 18E09DE5 		ldr	lr, [sp, #24]
 807:../uvc.c      **** 							 break;
 2669              		.loc 1 807 0
 2670 16bc 0C70A0E1 		mov	r7, ip
 2671 16c0 0CFDFFEA 		b	.L114
 2672              	.LVL211:
 2673              	.L150:
 843:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2674              		.loc 1 843 0
 2675 16c4 B4429FE5 		ldr	r4, .L206+36
 837:../uvc.c      **** 							 Data0 = Data0 - 1;
 2676              		.loc 1 837 0
 2677 16c8 013043E2 		sub	r3, r3, #1
 2678 16cc FF7003E2 		and	r7, r3, #255
 2679              	.LVL212:
 841:../uvc.c      **** 								 Data0 = 1;
 2680              		.loc 1 841 0
 2681 16d0 020057E3 		cmp	r7, #2
 843:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2682              		.loc 1 843 0
 2683 16d4 0010E0E3 		mvn	r1, #0
 2684 16d8 1C0094E5 		ldr	r0, [r4, #28]
 841:../uvc.c      **** 								 Data0 = 1;
 2685              		.loc 1 841 0
 2686 16dc 0170A083 		movhi	r7, #1
 2687              	.LVL213:
 843:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2688              		.loc 1 843 0
 2689 16e0 FEFFFFEB 		bl	_txe_mutex_get
 2690              	.LVL214:
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2691              		.loc 1 844 0
 2692 16e4 00C0A0E3 		mov	ip, #0
 2693 16e8 0410A0E3 		mov	r1, #4
 2694 16ec 0920A0E1 		mov	r2, r9
 2695 16f0 0A30A0E1 		mov	r3, sl
 2696 16f4 0400A0E1 		mov	r0, r4
 2697 16f8 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2698 16fc FEFFFFEB 		bl	cmdSet
 845:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2699              		.loc 1 845 0
 2700 1700 1C0094E5 		ldr	r0, [r4, #28]
 2701 1704 FEFFFFEB 		bl	_txe_mutex_put
 849:../uvc.c      **** 							 break;
 2702              		.loc 1 849 0
 2703 1708 FFC0A0E3 		mov	ip, #255
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2704              		.loc 1 848 0
 2705 170c 0110A0E3 		mov	r1, #1
 847:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2706              		.loc 1 847 0
 2707 1710 ED71C6E5 		strb	r7, [r6, #493]
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2708              		.loc 1 848 0
 2709 1714 F011C6E5 		strb	r1, [r6, #496]
 2710 1718 14409DE5 		ldr	r4, [sp, #20]
 2711 171c 18E09DE5 		ldr	lr, [sp, #24]
 849:../uvc.c      **** 							 break;
 2712              		.loc 1 849 0
 2713 1720 0C70A0E1 		mov	r7, ip
 2714 1724 F3FCFFEA 		b	.L114
 2715              	.LVL215:
 2716              	.L149:
 767:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2717              		.loc 1 767 0
 2718 1728 50729FE5 		ldr	r7, .L206+36
 2719              	.LVL216:
 2720 172c 0010E0E3 		mvn	r1, #0
 2721 1730 1C0097E5 		ldr	r0, [r7, #28]
 2722 1734 FEFFFFEB 		bl	_txe_mutex_get
 2723              	.LVL217:
 769:../uvc.c      **** 							  if(Data0&0x80){
 2724              		.loc 1 769 0
 2725 1738 14009DE5 		ldr	r0, [sp, #20]
 770:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2726              		.loc 1 770 0
 2727 173c A6C1D6E5 		ldrb	ip, [r6, #422]	@ zero_extendqisi2
 769:../uvc.c      **** 							  if(Data0&0x80){
 2728              		.loc 1 769 0
 2729 1740 800010E3 		tst	r0, #128
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2730              		.loc 1 772 0
 2731 1744 2023A001 		moveq	r2, r0, lsr #6
 770:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2732              		.loc 1 770 0
 2733 1748 802CA011 		movne	r2, r0, asl #25
 2734 174c 03C0CC13 		bicne	ip, ip, #3
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2735              		.loc 1 772 0
 2736 1750 03C0CC03 		biceq	ip, ip, #3
 776:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2737              		.loc 1 776 0
 2738 1754 24029FE5 		ldr	r0, .L206+36
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2739              		.loc 1 772 0
 2740 1758 02208203 		orreq	r2, r2, #2
 770:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2741              		.loc 1 770 0
 2742 175c A2CF8C11 		orrne	ip, ip, r2, lsr #31
 2743              	.LVL218:
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2744              		.loc 1 772 0
 2745 1760 0CC08201 		orreq	ip, r2, ip
 2746              	.LVL219:
 774:../uvc.c      **** 							 Data1 |= ~0x03;
 2747              		.loc 1 774 0
 2748 1764 0C4FE0E1 		mvn	r4, ip, asl #30
 2749 1768 243FE0E1 		mvn	r3, r4, lsr #30
 2750              	.LVL220:
 775:../uvc.c      **** 							 Data1 &= 0xC7;
 2751              		.loc 1 775 0
 2752 176c C71003E2 		and	r1, r3, #199
 2753 1770 1C108DE5 		str	r1, [sp, #28]
 2754              	.LVL221:
 776:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2755              		.loc 1 776 0
 2756 1774 1C809DE5 		ldr	r8, [sp, #28]
 2757 1778 00C0A0E3 		mov	ip, #0
 2758 177c 0110A0E3 		mov	r1, #1
 2759 1780 0B20A0E1 		mov	r2, fp
 2760 1784 0A30A0E1 		mov	r3, sl
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2761              		.loc 1 780 0
 2762 1788 0140A0E1 		mov	r4, r1
 776:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2763              		.loc 1 776 0
 2764 178c 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2765 1790 FEFFFFEB 		bl	cmdSet
 2766              	.LVL222:
 779:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2767              		.loc 1 779 0
 2768 1794 14209DE5 		ldr	r2, [sp, #20]
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2769              		.loc 1 780 0
 2770 1798 0410A0E1 		mov	r1, r4
 779:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2771              		.loc 1 779 0
 2772 179c 0281A0E1 		mov	r8, r2, asl #2
 2773 17a0 FF8008E2 		and	r8, r8, #255
 2774              	.LVL223:
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2775              		.loc 1 780 0
 2776 17a4 0920A0E1 		mov	r2, r9
 2777 17a8 0A30A0E1 		mov	r3, sl
 2778 17ac CC019FE5 		ldr	r0, .L206+36
 2779 17b0 04408DE5 		str	r4, [sp, #4]
 2780 17b4 00808DE5 		str	r8, [sp, #0]
 2781 17b8 FEFFFFEB 		bl	cmdSet
 781:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2782              		.loc 1 781 0
 2783 17bc 1C0097E5 		ldr	r0, [r7, #28]
 2784 17c0 FEFFFFEB 		bl	_txe_mutex_put
 784:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2785              		.loc 1 784 0
 2786 17c4 1C009DE5 		ldr	r0, [sp, #28]
 787:../uvc.c      **** 							 break;
 2787              		.loc 1 787 0
 2788 17c8 FFC0A0E3 		mov	ip, #255
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2789              		.loc 1 785 0
 2790 17cc A841C6E5 		strb	r4, [r6, #424]
 783:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2791              		.loc 1 783 0
 2792 17d0 A581C6E5 		strb	r8, [r6, #421]
 784:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2793              		.loc 1 784 0
 2794 17d4 A601C6E5 		strb	r0, [r6, #422]
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2795              		.loc 1 785 0
 2796 17d8 14409DE5 		ldr	r4, [sp, #20]
 2797 17dc 18E09DE5 		ldr	lr, [sp, #24]
 787:../uvc.c      **** 							 break;
 2798              		.loc 1 787 0
 2799 17e0 0C70A0E1 		mov	r7, ip
 2800 17e4 C3FCFFEA 		b	.L114
 2801              	.LVL224:
 2802              	.L148:
 868:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2803              		.loc 1 868 0
 2804 17e8 90719FE5 		ldr	r7, .L206+36
 2805              	.LVL225:
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2806              		.loc 1 851 0
 2807 17ec 68019FE5 		ldr	r0, .L206
 852:../uvc.c      **** 							 if(Data0 == 3)
 2808              		.loc 1 852 0
 2809 17f0 030053E3 		cmp	r3, #3
 853:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2810              		.loc 1 853 0
 2811 17f4 0120A003 		moveq	r2, #1
 2812              	.LVL226:
 855:../uvc.c      **** 								 WDRflag = CyFalse;
 2813              		.loc 1 855 0
 2814 17f8 0020A013 		movne	r2, #0
 856:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2815              		.loc 1 856 0
 2816 17fc 01C0A0E3 		mov	ip, #1
 2817 1800 90C1C6E5 		strb	ip, [r6, #400]
 2818              	.LVL227:
 855:../uvc.c      **** 								 WDRflag = CyFalse;
 2819              		.loc 1 855 0
 2820 1804 102680E5 		str	r2, [r0, #1552]
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2821              		.loc 1 851 0
 2822 1808 8D31C6E5 		strb	r3, [r6, #397]
 868:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2823              		.loc 1 868 0
 2824 180c 0010E0E3 		mvn	r1, #0
 2825 1810 1C0097E5 		ldr	r0, [r7, #28]
 2826 1814 FEFFFFEB 		bl	_txe_mutex_get
 869:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2827              		.loc 1 869 0
 2828 1818 14E09DE5 		ldr	lr, [sp, #20]
 2829 181c 0040A0E3 		mov	r4, #0
 2830 1820 0410A0E1 		mov	r1, r4
 2831 1824 0920A0E1 		mov	r2, r9
 2832 1828 0A30A0E1 		mov	r3, sl
 2833 182c 0700A0E1 		mov	r0, r7
 2834 1830 00E08DE5 		str	lr, [sp, #0]
 2835 1834 04408DE5 		str	r4, [sp, #4]
 2836 1838 FEFFFFEB 		bl	cmdSet
 870:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2837              		.loc 1 870 0
 2838 183c 1C0097E5 		ldr	r0, [r7, #28]
 2839 1840 FEFFFFEB 		bl	_txe_mutex_put
 871:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2840              		.loc 1 871 0
 2841 1844 1C219FE5 		ldr	r2, .L206+12
 2842 1848 103696E5 		ldr	r3, [r6, #1552]
 2843 184c 5AC0D2E5 		ldrb	ip, [r2, #90]	@ zero_extendqisi2
 2844 1850 5BE0D2E5 		ldrb	lr, [r2, #91]	@ zero_extendqisi2
 2845 1854 14409DE5 		ldr	r4, [sp, #20]
 2846 1858 0400A0E3 		mov	r0, #4
 2847 185c 2C119FE5 		ldr	r1, .L206+52
 2848 1860 B0FEFFEA 		b	.L199
 2849              	.LVL228:
 2850              	.L147:
 877:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2851              		.loc 1 877 0
 2852 1864 14719FE5 		ldr	r7, .L206+36
 2853              	.LVL229:
 2854 1868 0010E0E3 		mvn	r1, #0
 2855 186c 1C0097E5 		ldr	r0, [r7, #28]
 2856 1870 FEFFFFEB 		bl	_txe_mutex_get
 2857              	.LVL230:
 878:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2858              		.loc 1 878 0
 2859 1874 14C09DE5 		ldr	ip, [sp, #20]
 2860 1878 0410A0E1 		mov	r1, r4
 2861 187c 0920A0E1 		mov	r2, r9
 2862 1880 0A30A0E1 		mov	r3, sl
 2863 1884 0700A0E1 		mov	r0, r7
 2864 1888 00C08DE5 		str	ip, [sp, #0]
 2865 188c 00C0A0E3 		mov	ip, #0
 2866 1890 04C08DE5 		str	ip, [sp, #4]
 2867 1894 FEFFFFEB 		bl	cmdSet
 879:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2868              		.loc 1 879 0
 2869 1898 1C0097E5 		ldr	r0, [r7, #28]
 2870 189c FEFFFFEB 		bl	_txe_mutex_put
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2871              		.loc 1 881 0
 2872 18a0 14209DE5 		ldr	r2, [sp, #20]
 2873 18a4 847084E0 		add	r7, r4, r4, asl #1
 2874 18a8 876186E0 		add	r6, r6, r7, asl #3
 883:../uvc.c      **** 							 break;
 2875              		.loc 1 883 0
 2876 18ac FFC0A0E3 		mov	ip, #255
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2877              		.loc 1 882 0
 2878 18b0 0130A0E3 		mov	r3, #1
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2879              		.loc 1 881 0
 2880 18b4 8D21C6E5 		strb	r2, [r6, #397]
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2881              		.loc 1 882 0
 2882 18b8 9031C6E5 		strb	r3, [r6, #400]
 2883 18bc 0240A0E1 		mov	r4, r2
 2884 18c0 18E09DE5 		ldr	lr, [sp, #24]
 883:../uvc.c      **** 							 break;
 2885              		.loc 1 883 0
 2886 18c4 0C70A0E1 		mov	r7, ip
 2887 18c8 8AFCFFEA 		b	.L114
 2888              	.LVL231:
 2889              	.L146:
 886:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2890              		.loc 1 886 0
 2891 18cc 0400A0E3 		mov	r0, #4
 2892              	.LVL232:
 2893 18d0 BC109FE5 		ldr	r1, .L206+56
 2894 18d4 FEFFFFEB 		bl	CyU3PDebugPrint
 2895              	.LVL233:
 2896 18d8 FFC0A0E3 		mov	ip, #255
 2897 18dc 0C70A0E1 		mov	r7, ip
 2898              	.LVL234:
 2899 18e0 0CE0A0E1 		mov	lr, ip
 2900 18e4 0C40A0E1 		mov	r4, ip
 2901 18e8 82FCFFEA 		b	.L114
 2902              	.LVL235:
 2903              	.L166:
 629:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2904              		.loc 1 629 0
 2905 18ec B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2906              	.LVL236:
 628:../uvc.c      **** 								 Data1 = Data0 - 1;
 2907              		.loc 1 628 0
 2908 18f0 017040E2 		sub	r7, r0, #1
 2909              	.LVL237:
 629:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2910              		.loc 1 629 0
 2911 18f4 040052E3 		cmp	r2, #4
 2912 18f8 01005213 		cmpne	r2, #1
 628:../uvc.c      **** 								 Data1 = Data0 - 1;
 2913              		.loc 1 628 0
 2914 18fc FF1007E2 		and	r1, r7, #255
 2915              	.LVL238:
 629:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2916              		.loc 1 629 0
 2917 1900 0300000A 		beq	.L169
 630:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2918              		.loc 1 630 0
 2919 1904 080052E3 		cmp	r2, #8
 631:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2920              		.loc 1 631 0
 2921 1908 0120A003 		moveq	r2, #1
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2922              		.loc 1 633 0
 2923 190c 0420A013 		movne	r2, #4
 2924 1910 B524C3E5 		strb	r2, [r3, #1205]
 2925              	.L169:
 636:../uvc.c      **** 								 if(Data1 < 8){
 2926              		.loc 1 636 0
 2927 1914 070051E3 		cmp	r1, #7
 637:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2928              		.loc 1 637 0
 2929 1918 78309F95 		ldrls	r3, .L206+60
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2930              		.loc 1 640 0
 2931 191c 0130A083 		movhi	r3, #1
 638:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2932              		.loc 1 638 0
 2933 1920 81008390 		addls	r0, r3, r1, asl #1
 637:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2934              		.loc 1 637 0
 2935 1924 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 638:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2936              		.loc 1 638 0
 2937 1928 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2938              		.loc 1 640 0
 2939 192c E534C685 		strhib	r3, [r6, #1253]
 641:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2940              		.loc 1 641 0
 2941 1930 0030A083 		movhi	r3, #0
 637:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2942              		.loc 1 637 0
 2943 1934 E524C695 		strlsb	r2, [r6, #1253]
 641:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2944              		.loc 1 641 0
 2945 1938 E634C6E5 		strb	r3, [r6, #1254]
 2946 193c BAFEFFEA 		b	.L167
 2947              	.LVL239:
 2948              	.L196:
 2949 1940 20009FE5 		ldr	r0, .L206+12
 2950 1944 89FDFFEA 		b	.L125
 2951              	.LVL240:
 2952              	.L185:
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2953              		.loc 1 388 0
 2954 1948 0030A0E3 		mov	r3, #0
 2955 194c 2DFEFFEA 		b	.L189
 2956              	.LVL241:
 2957              	.L184:
 2958 1950 10009FE5 		ldr	r0, .L206+12
 2959 1954 0030A0E3 		mov	r3, #0
 2960 1958 7DFDFFEA 		b	.L188
 2961              	.L207:
 2962              		.align	2
 2963              	.L206:
 2964 195c 00000000 		.word	.LANCHOR1
 2965 1960 00000000 		.word	bRequest
 2966 1964 3C030000 		.word	.LC21
 2967 1968 00000000 		.word	.LANCHOR0
 2968 196c 58000000 		.word	.LANCHOR0+88
 2969 1970 01000100 		.word	65537
 2970 1974 FF00FF00 		.word	16711935
 2971 1978 48020000 		.word	.LC15
 2972 197c 84020000 		.word	.LC16
 2973 1980 00000000 		.word	cmdQu
 2974 1984 4C000000 		.word	.LANCHOR0+76
 2975 1988 D8020000 		.word	.LC18
 2976 198c AC020000 		.word	.LC17
 2977 1990 F4020000 		.word	.LC19
 2978 1994 0C030000 		.word	.LC20
 2979 1998 00000000 		.word	.LANCHOR2
 2980              		.cfi_endproc
 2981              	.LFE2:
 2983              		.align	2
 2984              		.global	CTControlHandle
 2986              	CTControlHandle:
 2987              	.LFB3:
 902:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 2988              		.loc 1 902 0
 2989              		.cfi_startproc
 2990              		@ args = 0, pretend = 0, frame = 64
 2991              		@ frame_needed = 0, uses_anonymous_args = 0
 2992              	.LVL242:
 2993 199c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2994              	.LCFI15:
 2995              		.cfi_def_cfa_offset 36
 921:../uvc.c      ****     reqData = bRequest;
 2996              		.loc 1 921 0
 2997 19a0 60A99FE5 		ldr	sl, .L293
 2998              		.cfi_offset 14, -4
 2999              		.cfi_offset 11, -8
 3000              		.cfi_offset 10, -12
 3001              		.cfi_offset 9, -16
 3002              		.cfi_offset 8, -20
 3003              		.cfi_offset 7, -24
 3004              		.cfi_offset 6, -28
 3005              		.cfi_offset 5, -32
 3006              		.cfi_offset 4, -36
 913:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3007              		.loc 1 913 0
 3008 19a4 60899FE5 		ldr	r8, .L293+4
 921:../uvc.c      ****     reqData = bRequest;
 3009              		.loc 1 921 0
 3010 19a8 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 913:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3011              		.loc 1 913 0
 3012 19ac 8090A0E1 		mov	r9, r0, asl #1
 3013 19b0 002089E0 		add	r2, r9, r0
 3014 19b4 822188E0 		add	r2, r8, r2, asl #3
 923:../uvc.c      ****     switch (bRequest)
 3015              		.loc 1 923 0
 3016 19b8 830055E3 		cmp	r5, #131
 902:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3017              		.loc 1 902 0
 3018 19bc 5CD04DE2 		sub	sp, sp, #92
 3019              	.LCFI16:
 3020              		.cfi_def_cfa_offset 128
 902:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3021              		.loc 1 902 0
 3022 19c0 0060A0E1 		mov	r6, r0
 913:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3023              		.loc 1 913 0
 3024 19c4 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3025              	.LVL243:
 914:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3026              		.loc 1 914 0
 3027 19c8 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3028              	.LVL244:
 916:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3029              		.loc 1 916 0
 3030 19cc 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3031              	.LVL245:
 923:../uvc.c      ****     switch (bRequest)
 3032              		.loc 1 923 0
 3033 19d0 7600000A 		beq	.L213
 3034 19d4 2100009A 		bls	.L288
 3035 19d8 850055E3 		cmp	r5, #133
 3036 19dc 5900000A 		beq	.L215
 3037 19e0 4E00003A 		bcc	.L214
 3038 19e4 860055E3 		cmp	r5, #134
 3039 19e8 8000000A 		beq	.L216
 3040 19ec 870055E3 		cmp	r5, #135
 3041 19f0 7600000A 		beq	.L289
 3042              	.L209:
1130:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3043              		.loc 1 1130 0
 3044 19f4 0000A0E3 		mov	r0, #0
 3045              	.LVL246:
 3046 19f8 0110A0E3 		mov	r1, #1
 3047 19fc 0020A0E1 		mov	r2, r0
 3048 1a00 FEFFFFEB 		bl	CyU3PUsbStall
 3049              	.LVL247:
 3050 1a04 04499FE5 		ldr	r4, .L293+8
1131:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3051              		.loc 1 1131 0
 3052 1a08 0620A0E1 		mov	r2, r6
 3053 1a0c 0400A0E3 		mov	r0, #4
 3054 1a10 FC189FE5 		ldr	r1, .L293+12
 3055 1a14 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3056 1a18 FEFFFFEB 		bl	CyU3PDebugPrint
1132:../uvc.c      **** 			  break;
 3057              		.loc 1 1132 0
 3058 1a1c FFC0A0E3 		mov	ip, #255
 3059 1a20 0C60A0E1 		mov	r6, ip
 3060 1a24 0C80A0E1 		mov	r8, ip
 3061              	.LVL248:
 3062              	.L219:
1136:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3063              		.loc 1 1136 0
 3064 1a28 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3065 1a2c 08C08DE5 		str	ip, [sp, #8]
 3066 1a30 E0189FE5 		ldr	r1, .L293+16
 3067 1a34 FFC0A0E3 		mov	ip, #255
 3068 1a38 0520A0E1 		mov	r2, r5
 3069 1a3c 0830A0E1 		mov	r3, r8
 3070 1a40 0400A0E3 		mov	r0, #4
 3071 1a44 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3072 1a48 0CC08DE5 		str	ip, [sp, #12]
 3073 1a4c 10E08DE5 		str	lr, [sp, #16]
 3074 1a50 14708DE5 		str	r7, [sp, #20]
 3075 1a54 FEFFFFEB 		bl	CyU3PDebugPrint
1137:../uvc.c      **** }
 3076              		.loc 1 1137 0
 3077 1a58 5CD08DE2 		add	sp, sp, #92
 3078 1a5c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3079              	.LVL249:
 3080              	.L288:
 923:../uvc.c      ****     switch (bRequest)
 3081              		.loc 1 923 0
 3082 1a60 810055E3 		cmp	r5, #129
 3083 1a64 4200000A 		beq	.L211
 3084 1a68 1100009A 		bls	.L290
 952:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3085              		.loc 1 952 0
 3086 1a6c 9C489FE5 		ldr	r4, .L293+8
 3087 1a70 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 953:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3088              		.loc 1 953 0
 3089 1a74 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 954:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3090              		.loc 1 954 0
 3091 1a78 0A0050E3 		cmp	r0, #10
 952:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3092              		.loc 1 952 0
 3093 1a7c 5810C4E5 		strb	r1, [r4, #88]
 953:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3094              		.loc 1 953 0
 3095 1a80 5960C4E5 		strb	r6, [r4, #89]
 954:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3096              		.loc 1 954 0
 3097 1a84 2C00000A 		beq	.L287
 3098              	.LVL250:
 3099              	.L226:
 988:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3100              		.loc 1 988 0
 3101 1a88 00E0A0E3 		mov	lr, #0
 3102 1a8c 5AE0C4E5 		strb	lr, [r4, #90]
 3103              	.L227:
 989:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3104              		.loc 1 989 0
 3105 1a90 0030A0E3 		mov	r3, #0
 990:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3106              		.loc 1 990 0
 3107 1a94 0700A0E1 		mov	r0, r7
 3108              	.LVL251:
 3109 1a98 7C189FE5 		ldr	r1, .L293+20
 992:../uvc.c      **** 			  break;
 3110              		.loc 1 992 0
 3111 1a9c FF60A0E3 		mov	r6, #255
 989:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3112              		.loc 1 989 0
 3113 1aa0 5B30C4E5 		strb	r3, [r4, #91]
 992:../uvc.c      **** 			  break;
 3114              		.loc 1 992 0
 3115 1aa4 0680A0E1 		mov	r8, r6
 990:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3116              		.loc 1 990 0
 3117 1aa8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3118              	.LVL252:
 3119 1aac 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 992:../uvc.c      **** 			  break;
 3120              		.loc 1 992 0
 3121 1ab0 DCFFFFEA 		b	.L219
 3122              	.LVL253:
 3123              	.L290:
 923:../uvc.c      ****     switch (bRequest)
 3124              		.loc 1 923 0
 3125 1ab4 010055E3 		cmp	r5, #1
 3126 1ab8 CDFFFF1A 		bne	.L209
 994:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3127              		.loc 1 994 0
 3128 1abc 4C489FE5 		ldr	r4, .L293+8
 3129 1ac0 56208DE2 		add	r2, sp, #86
 3130 1ac4 2000A0E3 		mov	r0, #32
 3131              	.LVL254:
 3132 1ac8 581084E2 		add	r1, r4, #88
 3133 1acc 2C308DE5 		str	r3, [sp, #44]
 3134 1ad0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3135              	.LVL255:
 996:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3136              		.loc 1 996 0
 3137 1ad4 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 997:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3138              		.loc 1 997 0
 3139 1ad8 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
1000:../uvc.c      **** 			  switch(CtrlID)
 3140              		.loc 1 1000 0
 3141 1adc 012046E2 		sub	r2, r6, #1
 996:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3142              		.loc 1 996 0
 3143 1ae0 30008DE5 		str	r0, [sp, #48]
 3144              	.LVL256:
 997:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3145              		.loc 1 997 0
 3146 1ae4 34C08DE5 		str	ip, [sp, #52]
 3147              	.LVL257:
1000:../uvc.c      **** 			  switch(CtrlID)
 3148              		.loc 1 1000 0
 3149 1ae8 2C309DE5 		ldr	r3, [sp, #44]
 3150 1aec 090052E3 		cmp	r2, #9
 3151 1af0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3152 1af4 550100EA 		b	.L228
 3153              	.L233:
 3154 1af8 0C200000 		.word	.L229
 3155 1afc 50200000 		.word	.L228
 3156 1b00 1C1D0000 		.word	.L230
 3157 1b04 50200000 		.word	.L228
 3158 1b08 50200000 		.word	.L228
 3159 1b0c 50200000 		.word	.L228
 3160 1b10 981C0000 		.word	.L231
 3161 1b14 50200000 		.word	.L228
 3162 1b18 50200000 		.word	.L228
 3163 1b1c 1C1C0000 		.word	.L232
 3164              	.LVL258:
 3165              	.L214:
 970:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3166              		.loc 1 970 0
 3167 1b20 E8479FE5 		ldr	r4, .L293+8
 3168 1b24 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 971:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3169              		.loc 1 971 0
 3170 1b28 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 972:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3171              		.loc 1 972 0
 3172 1b2c 0A0050E3 		cmp	r0, #10
 970:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3173              		.loc 1 970 0
 3174 1b30 5880C4E5 		strb	r8, [r4, #88]
 971:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3175              		.loc 1 971 0
 3176 1b34 5920C4E5 		strb	r2, [r4, #89]
 972:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3177              		.loc 1 972 0
 3178 1b38 D2FFFF1A 		bne	.L226
 3179              	.LVL259:
 3180              	.L287:
 987:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3181              		.loc 1 987 0 discriminator 1
 3182 1b3c 0110A0E3 		mov	r1, #1
 3183 1b40 5A10C4E5 		strb	r1, [r4, #90]
 3184 1b44 D1FFFFEA 		b	.L227
 3185              	.LVL260:
 3186              	.L215:
 927:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3187              		.loc 1 927 0
 3188 1b48 C0479FE5 		ldr	r4, .L293+8
 928:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3189              		.loc 1 928 0
 3190 1b4c 0030A0E3 		mov	r3, #0
 3191              	.LVL261:
 929:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3192              		.loc 1 929 0
 3193 1b50 0200A0E3 		mov	r0, #2
 3194              	.LVL262:
 3195 1b54 581084E2 		add	r1, r4, #88
 931:../uvc.c      **** 			  break;
 3196              		.loc 1 931 0
 3197 1b58 FF60A0E3 		mov	r6, #255
 927:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3198              		.loc 1 927 0
 3199 1b5c 5870C4E5 		strb	r7, [r4, #88]
 928:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3200              		.loc 1 928 0
 3201 1b60 5930C4E5 		strb	r3, [r4, #89]
 931:../uvc.c      **** 			  break;
 3202              		.loc 1 931 0
 3203 1b64 0680A0E1 		mov	r8, r6
 929:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3204              		.loc 1 929 0
 3205 1b68 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3206              	.LVL263:
 3207 1b6c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 931:../uvc.c      **** 			  break;
 3208              		.loc 1 931 0
 3209 1b70 ACFFFFEA 		b	.L219
 3210              	.LVL264:
 3211              	.L211:
 937:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3212              		.loc 1 937 0
 3213 1b74 94479FE5 		ldr	r4, .L293+8
 3214 1b78 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 938:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3215              		.loc 1 938 0
 3216 1b7c 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 939:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3217              		.loc 1 939 0
 3218 1b80 0080A0E3 		mov	r8, #0
 945:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3219              		.loc 1 945 0
 3220 1b84 0700A0E1 		mov	r0, r7
 3221              	.LVL265:
 3222 1b88 581084E2 		add	r1, r4, #88
 950:../uvc.c      **** 			  break;
 3223              		.loc 1 950 0
 3224 1b8c FF60A0E3 		mov	r6, #255
 938:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3225              		.loc 1 938 0
 3226 1b90 59C0C4E5 		strb	ip, [r4, #89]
 939:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3227              		.loc 1 939 0
 3228 1b94 5A80C4E5 		strb	r8, [r4, #90]
 940:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3229              		.loc 1 940 0
 3230 1b98 5B80C4E5 		strb	r8, [r4, #91]
 3231              	.LVL266:
 937:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3232              		.loc 1 937 0
 3233 1b9c 58A0C4E5 		strb	sl, [r4, #88]
 950:../uvc.c      **** 			  break;
 3234              		.loc 1 950 0
 3235 1ba0 0680A0E1 		mov	r8, r6
 945:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3236              		.loc 1 945 0
 3237 1ba4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3238              	.LVL267:
 3239 1ba8 0AC0A0E1 		mov	ip, sl
 950:../uvc.c      **** 			  break;
 3240              		.loc 1 950 0
 3241 1bac 9DFFFFEA 		b	.L219
 3242              	.LVL268:
 3243              	.L213:
 961:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3244              		.loc 1 961 0
 3245 1bb0 58479FE5 		ldr	r4, .L293+8
 3246 1bb4 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3247              	.LVL269:
 962:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3248              		.loc 1 962 0
 3249 1bb8 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 963:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3250              		.loc 1 963 0
 3251 1bbc 0A0050E3 		cmp	r0, #10
 961:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3252              		.loc 1 961 0
 3253 1bc0 5830C4E5 		strb	r3, [r4, #88]
 962:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3254              		.loc 1 962 0
 3255 1bc4 59E0C4E5 		strb	lr, [r4, #89]
 963:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3256              		.loc 1 963 0
 3257 1bc8 AEFFFF1A 		bne	.L226
 3258 1bcc DAFFFFEA 		b	.L287
 3259              	.LVL270:
 3260              	.L289:
 985:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3261              		.loc 1 985 0
 3262 1bd0 38479FE5 		ldr	r4, .L293+8
 3263 1bd4 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 986:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3264              		.loc 1 986 0
 3265 1bd8 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 987:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3266              		.loc 1 987 0
 3267 1bdc 0A0050E3 		cmp	r0, #10
 985:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3268              		.loc 1 985 0
 3269 1be0 5860C4E5 		strb	r6, [r4, #88]
 986:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3270              		.loc 1 986 0
 3271 1be4 59C0C4E5 		strb	ip, [r4, #89]
 987:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3272              		.loc 1 987 0
 3273 1be8 A6FFFF1A 		bne	.L226
 3274 1bec D2FFFFEA 		b	.L287
 3275              	.L216:
 979:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3276              		.loc 1 979 0
 3277 1bf0 18479FE5 		ldr	r4, .L293+8
 3278 1bf4 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3279              	.LVL271:
 3280 1bf8 0410A0E1 		mov	r1, r4
 3281 1bfc 5800E1E5 		strb	r0, [r1, #88]!
 983:../uvc.c      **** 			  break;
 3282              		.loc 1 983 0
 3283 1c00 FF60A0E3 		mov	r6, #255
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3284              		.loc 1 980 0
 3285 1c04 0100A0E3 		mov	r0, #1
 3286 1c08 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3287              	.LVL272:
 983:../uvc.c      **** 			  break;
 3288              		.loc 1 983 0
 3289 1c0c 0680A0E1 		mov	r8, r6
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3290              		.loc 1 980 0
 3291 1c10 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 983:../uvc.c      **** 			  break;
 3292              		.loc 1 983 0
 3293 1c14 0170A0E3 		mov	r7, #1
 3294 1c18 82FFFFEA 		b	.L219
 3295              	.LVL273:
 3296              	.L232:
1109:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3297              		.loc 1 1109 0
 3298 1c1c FC669FE5 		ldr	r6, .L293+24
 3299 1c20 0010E0E3 		mvn	r1, #0
 3300 1c24 1C0096E5 		ldr	r0, [r6, #28]
 3301 1c28 2C308DE5 		str	r3, [sp, #44]
 3302 1c2c FEFFFFEB 		bl	_txe_mutex_get
1110:../uvc.c      **** 					  if(getData == 1)
 3303              		.loc 1 1110 0
 3304 1c30 30E09DE5 		ldr	lr, [sp, #48]
 3305 1c34 2C309DE5 		ldr	r3, [sp, #44]
 3306 1c38 01005EE3 		cmp	lr, #1
 3307 1c3c A901000A 		beq	.L291
1112:../uvc.c      **** 					  else if(getData == 0xff)
 3308              		.loc 1 1112 0
 3309 1c40 FF005EE3 		cmp	lr, #255
 3310 1c44 9E01000A 		beq	.L292
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3311              		.loc 1 1115 0
 3312 1c48 0080A0E3 		mov	r8, #0
 3313 1c4c 0600A0E1 		mov	r0, r6
 3314 1c50 1710A0E3 		mov	r1, #23
 3315 1c54 0B20A0E1 		mov	r2, fp
 3316 1c58 00808DE5 		str	r8, [sp, #0]
 3317 1c5c 04808DE5 		str	r8, [sp, #4]
 3318 1c60 FEFFFFEB 		bl	cmdSet
 3319              	.L285:
1118:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3320              		.loc 1 1118 0
 3321 1c64 1C0096E5 		ldr	r0, [r6, #28]
 3322 1c68 FEFFFFEB 		bl	_txe_mutex_put
1120:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3323              		.loc 1 1120 0
 3324 1c6c 30809DE5 		ldr	r8, [sp, #48]
 3325 1c70 34609DE5 		ldr	r6, [sp, #52]
 3326 1c74 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3327 1c78 0400A0E3 		mov	r0, #4
 3328 1c7c A0169FE5 		ldr	r1, .L293+28
 3329 1c80 0820A0E1 		mov	r2, r8
 3330 1c84 0630A0E1 		mov	r3, r6
 3331 1c88 00C08DE5 		str	ip, [sp, #0]
 3332 1c8c FEFFFFEB 		bl	CyU3PDebugPrint
1121:../uvc.c      **** 					  break;
 3333              		.loc 1 1121 0
 3334 1c90 FFC0A0E3 		mov	ip, #255
 3335 1c94 63FFFFEA 		b	.L219
 3336              	.LVL274:
 3337              	.L231:
1086:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3338              		.loc 1 1086 0
 3339 1c98 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3340 1c9c 010058E3 		cmp	r8, #1
 3341 1ca0 08005813 		cmpne	r8, #8
 3342 1ca4 0000A013 		movne	r0, #0
 3343 1ca8 0100A003 		moveq	r0, #1
 3344 1cac 8001001A 		bne	.L282
 3345              	.LVL275:
1089:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3346              		.loc 1 1089 0
 3347 1cb0 68869FE5 		ldr	r8, .L293+24
 3348 1cb4 0010E0E3 		mvn	r1, #0
 3349 1cb8 1C0098E5 		ldr	r0, [r8, #28]
 3350 1cbc 2C308DE5 		str	r3, [sp, #44]
 3351 1cc0 FEFFFFEB 		bl	_txe_mutex_get
1090:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3352              		.loc 1 1090 0
 3353 1cc4 30A09DE5 		ldr	sl, [sp, #48]
 3354 1cc8 1610A0E3 		mov	r1, #22
 3355 1ccc 0B20A0E1 		mov	r2, fp
 3356 1cd0 2C309DE5 		ldr	r3, [sp, #44]
 3357 1cd4 00C0A0E3 		mov	ip, #0
 3358 1cd8 0800A0E1 		mov	r0, r8
 3359 1cdc 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3360 1ce0 FEFFFFEB 		bl	cmdSet
1091:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3361              		.loc 1 1091 0
 3362 1ce4 1C0098E5 		ldr	r0, [r8, #28]
 3363 1ce8 FEFFFFEB 		bl	_txe_mutex_put
1094:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3364              		.loc 1 1094 0
 3365 1cec 18069FE5 		ldr	r0, .L293+4
1095:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3366              		.loc 1 1095 0
 3367 1cf0 34209DE5 		ldr	r2, [sp, #52]
1094:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3368              		.loc 1 1094 0
 3369 1cf4 061089E0 		add	r1, r9, r6
 3370 1cf8 813180E0 		add	r3, r0, r1, asl #3
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3371              		.loc 1 1096 0
 3372 1cfc 0160A0E3 		mov	r6, #1
1094:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3373              		.loc 1 1094 0
 3374 1d00 9DA4C3E5 		strb	sl, [r3, #1181]
1095:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3375              		.loc 1 1095 0
 3376 1d04 9E24C3E5 		strb	r2, [r3, #1182]
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3377              		.loc 1 1096 0
 3378 1d08 A064C3E5 		strb	r6, [r3, #1184]
 3379              	.LVL276:
 3380              	.L283:
1098:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3381              		.loc 1 1098 0
 3382 1d0c 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3383 1d10 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1103:../uvc.c      **** 					  break;
 3384              		.loc 1 1103 0
 3385 1d14 FFC0A0E3 		mov	ip, #255
 3386 1d18 42FFFFEA 		b	.L219
 3387              	.LVL277:
 3388              	.L230:
1052:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3389              		.loc 1 1052 0
 3390 1d1c B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3391 1d20 010050E3 		cmp	r0, #1
 3392 1d24 04005013 		cmpne	r0, #4
 3393 1d28 5C01001A 		bne	.L240
1051:../uvc.c      **** 					  value = (value << 8)|Data0;
 3394              		.loc 1 1051 0
 3395 1d2c 30109DE5 		ldr	r1, [sp, #48]
 3396 1d30 34E09DE5 		ldr	lr, [sp, #52]
 3397 1d34 0E2481E1 		orr	r2, r1, lr, asl #8
1053:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3398              		.loc 1 1053 0
 3399 1d38 F90052E3 		cmp	r2, #249
 3400 1d3c 5701008A 		bhi	.L240
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3401              		.loc 1 1058 0
 3402 1d40 C8A042E2 		sub	sl, r2, #200
 3403 1d44 0AC8A0E1 		mov	ip, sl, asl #16
 3404 1d48 3CC08DE5 		str	ip, [sp, #60]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3405              		.loc 1 1060 0
 3406 1d4c 27A062E2 		rsb	sl, r2, #39
 3407 1d50 38A08DE5 		str	sl, [sp, #56]
 3408 1d54 3CA09DE5 		ldr	sl, [sp, #60]
 3409 1d58 C81062E2 		rsb	r1, r2, #200
 3410 1d5c C80052E3 		cmp	r2, #200
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3411              		.loc 1 1058 0
 3412 1d60 640042E2 		sub	r0, r2, #100
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3413              		.loc 1 1060 0
 3414 1d64 0118A0E1 		mov	r1, r1, asl #16
 3415 1d68 64E062E2 		rsb	lr, r2, #100
 3416 1d6c 2A18A081 		movhi	r1, sl, lsr #16
 3417 1d70 2118A091 		movls	r1, r1, lsr #16
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3418              		.loc 1 1058 0
 3419 1d74 00C8A0E1 		mov	ip, r0, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3420              		.loc 1 1060 0
 3421 1d78 640052E3 		cmp	r2, #100
 3422 1d7c 0E08A0E1 		mov	r0, lr, asl #16
 3423 1d80 2C08A081 		movhi	r0, ip, lsr #16
 3424 1d84 38C09DE5 		ldr	ip, [sp, #56]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3425              		.loc 1 1058 0
 3426 1d88 14A042E2 		sub	sl, r2, #20
 3427 1d8c 38A08DE5 		str	sl, [sp, #56]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3428              		.loc 1 1060 0
 3429 1d90 2008A091 		movls	r0, r0, lsr #16
 3430 1d94 14A062E2 		rsb	sl, r2, #20
 3431 1d98 3CA08DE5 		str	sl, [sp, #60]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3432              		.loc 1 1058 0
 3433 1d9c 27E042E2 		sub	lr, r2, #39
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3434              		.loc 1 1060 0
 3435 1da0 000051E1 		cmp	r1, r0
 3436 1da4 01A0A031 		movcc	sl, r1
 3437 1da8 00A0A021 		movcs	sl, r0
 3438 1dac 0CC8A0E1 		mov	ip, ip, asl #16
 3439 1db0 270052E3 		cmp	r2, #39
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3440              		.loc 1 1058 0
 3441 1db4 0EE8A0E1 		mov	lr, lr, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3442              		.loc 1 1060 0
 3443 1db8 2CE8A091 		movls	lr, ip, lsr #16
 3444 1dbc 64C59FE5 		ldr	ip, .L293+32
 3445 1dc0 20A08DE5 		str	sl, [sp, #32]
 3446 1dc4 01A06CE0 		rsb	sl, ip, r1
 3447 1dc8 2EE8A081 		movhi	lr, lr, lsr #16
 3448 1dcc 00C07AE2 		rsbs	ip, sl, #0
 3449 1dd0 0AC0ACE0 		adc	ip, ip, sl
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3450              		.loc 1 1058 0
 3451 1dd4 38A09DE5 		ldr	sl, [sp, #56]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3452              		.loc 1 1060 0
 3453 1dd8 44C08DE5 		str	ip, [sp, #68]
 3454              	.LVL278:
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3455              		.loc 1 1058 0
 3456 1ddc 0AC8A0E1 		mov	ip, sl, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3457              		.loc 1 1060 0
 3458 1de0 3CA09DE5 		ldr	sl, [sp, #60]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3459              		.loc 1 1058 0
 3460 1de4 4CC08DE5 		str	ip, [sp, #76]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3461              		.loc 1 1060 0
 3462 1de8 0AC8A0E1 		mov	ip, sl, asl #16
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3463              		.loc 1 1058 0
 3464 1dec 0AA042E2 		sub	sl, r2, #10
 3465 1df0 48A08DE5 		str	sl, [sp, #72]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3466              		.loc 1 1060 0
 3467 1df4 20A09DE5 		ldr	sl, [sp, #32]
 3468 1df8 3CC08DE5 		str	ip, [sp, #60]
 3469 1dfc 0A005EE1 		cmp	lr, sl
 3470 1e00 0EA0A031 		movcc	sl, lr
 3471 1e04 0AC062E2 		rsb	ip, r2, #10
 3472 1e08 40C08DE5 		str	ip, [sp, #64]
 3473 1e0c 38A08DE5 		str	sl, [sp, #56]
 3474 1e10 3CC09DE5 		ldr	ip, [sp, #60]
 3475 1e14 4CA09DE5 		ldr	sl, [sp, #76]
 3476 1e18 140052E3 		cmp	r2, #20
 3477 1e1c 2CA8A091 		movls	sl, ip, lsr #16
 3478 1e20 2AA8A081 		movhi	sl, sl, lsr #16
 3479 1e24 44C09DE5 		ldr	ip, [sp, #68]
 3480 1e28 010050E1 		cmp	r0, r1
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3481              		.loc 1 1058 0
 3482 1e2c 48109DE5 		ldr	r1, [sp, #72]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3483              		.loc 1 1060 0
 3484 1e30 01C0A033 		movcc	ip, #1
 3485 1e34 3CA08DE5 		str	sl, [sp, #60]
 3486 1e38 24C08DE5 		str	ip, [sp, #36]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3487              		.loc 1 1058 0
 3488 1e3c 01A8A0E1 		mov	sl, r1, asl #16
 3489 1e40 05C042E2 		sub	ip, r2, #5
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3490              		.loc 1 1060 0
 3491 1e44 051062E2 		rsb	r1, r2, #5
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3492              		.loc 1 1058 0
 3493 1e48 48A08DE5 		str	sl, [sp, #72]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3494              		.loc 1 1060 0
 3495 1e4c 40009DE5 		ldr	r0, [sp, #64]
 3496 1e50 38A09DE5 		ldr	sl, [sp, #56]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3497              		.loc 1 1058 0
 3498 1e54 40C08DE5 		str	ip, [sp, #64]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3499              		.loc 1 1060 0
 3500 1e58 3CC09DE5 		ldr	ip, [sp, #60]
 3501 1e5c 4C108DE5 		str	r1, [sp, #76]
 3502 1e60 48109DE5 		ldr	r1, [sp, #72]
 3503 1e64 0008A0E1 		mov	r0, r0, asl #16
 3504 1e68 0A005CE1 		cmp	ip, sl
 3505 1e6c 0AC0A021 		movcs	ip, sl
 3506 1e70 0A0052E3 		cmp	r2, #10
 3507 1e74 20A09DE5 		ldr	sl, [sp, #32]
 3508 1e78 2108A081 		movhi	r0, r1, lsr #16
 3509 1e7c 2008A091 		movls	r0, r0, lsr #16
 3510 1e80 48008DE5 		str	r0, [sp, #72]
 3511 1e84 24009DE5 		ldr	r0, [sp, #36]
 3512 1e88 0A005EE1 		cmp	lr, sl
 3513 1e8c 0200A033 		movcc	r0, #2
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3514              		.loc 1 1058 0
 3515 1e90 02E042E2 		sub	lr, r2, #2
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3516              		.loc 1 1060 0
 3517 1e94 44C08DE5 		str	ip, [sp, #68]
 3518 1e98 24008DE5 		str	r0, [sp, #36]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3519              		.loc 1 1058 0
 3520 1e9c 40C09DE5 		ldr	ip, [sp, #64]
 3521 1ea0 1CE08DE5 		str	lr, [sp, #28]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3522              		.loc 1 1060 0
 3523 1ea4 44009DE5 		ldr	r0, [sp, #68]
 3524 1ea8 48E09DE5 		ldr	lr, [sp, #72]
 3525 1eac 4C109DE5 		ldr	r1, [sp, #76]
 3526 1eb0 02A062E2 		rsb	sl, r2, #2
 3527 1eb4 00005EE1 		cmp	lr, r0
 3528 1eb8 00E0A021 		movcs	lr, r0
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3529              		.loc 1 1058 0
 3530 1ebc 0CC8A0E1 		mov	ip, ip, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3531              		.loc 1 1060 0
 3532 1ec0 050052E3 		cmp	r2, #5
 3533 1ec4 40A08DE5 		str	sl, [sp, #64]
 3534 1ec8 0118A0E1 		mov	r1, r1, asl #16
 3535 1ecc 3CA09DE5 		ldr	sl, [sp, #60]
 3536 1ed0 2C18A081 		movhi	r1, ip, lsr #16
 3537 1ed4 38C09DE5 		ldr	ip, [sp, #56]
 3538 1ed8 4CE08DE5 		str	lr, [sp, #76]
 3539 1edc 24009DE5 		ldr	r0, [sp, #36]
 3540 1ee0 40E09DE5 		ldr	lr, [sp, #64]
 3541 1ee4 2118A091 		movls	r1, r1, lsr #16
 3542 1ee8 0C005AE1 		cmp	sl, ip
 3543 1eec 20108DE5 		str	r1, [sp, #32]
 3544 1ef0 0300A033 		movcc	r0, #3
 3545 1ef4 38008DE5 		str	r0, [sp, #56]
 3546 1ef8 4CA09DE5 		ldr	sl, [sp, #76]
 3547 1efc 0E08A0E1 		mov	r0, lr, asl #16
 3548 1f00 20E09DE5 		ldr	lr, [sp, #32]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3549              		.loc 1 1058 0
 3550 1f04 1C109DE5 		ldr	r1, [sp, #28]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3551              		.loc 1 1060 0
 3552 1f08 0A005EE1 		cmp	lr, sl
 3553 1f0c 0AE0A021 		movcs	lr, sl
 3554 1f10 44C09DE5 		ldr	ip, [sp, #68]
 3555 1f14 48A09DE5 		ldr	sl, [sp, #72]
 3556 1f18 020052E3 		cmp	r2, #2
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3557              		.loc 1 1058 0
 3558 1f1c 0118A0E1 		mov	r1, r1, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3559              		.loc 1 1060 0
 3560 1f20 2018A091 		movls	r1, r0, lsr #16
 3561 1f24 38009DE5 		ldr	r0, [sp, #56]
 3562 1f28 2118A081 		movhi	r1, r1, lsr #16
 3563 1f2c 0C005AE1 		cmp	sl, ip
 3564 1f30 0400A033 		movcc	r0, #4
 3565 1f34 40008DE5 		str	r0, [sp, #64]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3566              		.loc 1 1058 0
 3567 1f38 010042E2 		sub	r0, r2, #1
 3568 1f3c 38008DE5 		str	r0, [sp, #56]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3569              		.loc 1 1060 0
 3570 1f40 4CA09DE5 		ldr	sl, [sp, #76]
 3571 1f44 20009DE5 		ldr	r0, [sp, #32]
 3572 1f48 01C062E2 		rsb	ip, r2, #1
 3573 1f4c 3CC08DE5 		str	ip, [sp, #60]
 3574 1f50 0A0050E1 		cmp	r0, sl
1067:../uvc.c      **** 						  shutter = shutter+index;
 3575              		.loc 1 1067 0
 3576 1f54 38A09DE5 		ldr	sl, [sp, #56]
 3577 1f58 3C009DE5 		ldr	r0, [sp, #60]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3578              		.loc 1 1060 0
 3579 1f5c 40C09DE5 		ldr	ip, [sp, #64]
 3580 1f60 05C0A033 		movcc	ip, #5
1067:../uvc.c      **** 						  shutter = shutter+index;
 3581              		.loc 1 1067 0
 3582 1f64 010052E3 		cmp	r2, #1
 3583 1f68 0028A091 		movls	r2, r0, asl #16
 3584 1f6c 0A28A081 		movhi	r2, sl, asl #16
 3585 1f70 0E0051E1 		cmp	r1, lr
 3586 1f74 01A0A031 		movcc	sl, r1
 3587 1f78 0EA0A021 		movcs	sl, lr
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3588              		.loc 1 1060 0
 3589 1f7c 0E0051E1 		cmp	r1, lr
 3590 1f80 0C10A021 		movcs	r1, ip
 3591 1f84 0610A033 		movcc	r1, #6
1067:../uvc.c      **** 						  shutter = shutter+index;
 3592              		.loc 1 1067 0
 3593 1f88 22085AE1 		cmp	sl, r2, lsr #16
1070:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3594              		.loc 1 1070 0
 3595 1f8c 8CA39FE5 		ldr	sl, .L293+24
1067:../uvc.c      **** 						  shutter = shutter+index;
 3596              		.loc 1 1067 0
 3597 1f90 0120A091 		movls	r2, r1
 3598 1f94 0720A083 		movhi	r2, #7
 3599 1f98 012082E2 		add	r2, r2, #1
 3600 1f9c FFE002E2 		and	lr, r2, #255
1070:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3601              		.loc 1 1070 0
 3602 1fa0 0010E0E3 		mvn	r1, #0
 3603 1fa4 1C009AE5 		ldr	r0, [sl, #28]
1067:../uvc.c      **** 						  shutter = shutter+index;
 3604              		.loc 1 1067 0
 3605 1fa8 38E08DE5 		str	lr, [sp, #56]
 3606              	.LVL279:
1070:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3607              		.loc 1 1070 0
 3608 1fac 2C308DE5 		str	r3, [sp, #44]
 3609 1fb0 FEFFFFEB 		bl	_txe_mutex_get
1071:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3610              		.loc 1 1071 0
 3611 1fb4 38C09DE5 		ldr	ip, [sp, #56]
 3612 1fb8 0310A0E3 		mov	r1, #3
 3613 1fbc 0B20A0E1 		mov	r2, fp
 3614 1fc0 2C309DE5 		ldr	r3, [sp, #44]
 3615 1fc4 00C08DE5 		str	ip, [sp, #0]
 3616 1fc8 0A00A0E1 		mov	r0, sl
 3617 1fcc 00C0A0E3 		mov	ip, #0
 3618 1fd0 04C08DE5 		str	ip, [sp, #4]
 3619 1fd4 FEFFFFEB 		bl	cmdSet
1072:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3620              		.loc 1 1072 0
 3621 1fd8 1C009AE5 		ldr	r0, [sl, #28]
 3622 1fdc FEFFFFEB 		bl	_txe_mutex_put
1075:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3623              		.loc 1 1075 0
 3624 1fe0 30009DE5 		ldr	r0, [sp, #48]
1076:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3625              		.loc 1 1076 0
 3626 1fe4 34C09DE5 		ldr	ip, [sp, #52]
1078:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3627              		.loc 1 1078 0
 3628 1fe8 38309DE5 		ldr	r3, [sp, #56]
1075:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3629              		.loc 1 1075 0
 3630 1fec 061089E0 		add	r1, r9, r6
 3631 1ff0 816188E0 		add	r6, r8, r1, asl #3
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3632              		.loc 1 1077 0
 3633 1ff4 0120A0E3 		mov	r2, #1
1075:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3634              		.loc 1 1075 0
 3635 1ff8 9D04C6E5 		strb	r0, [r6, #1181]
1076:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3636              		.loc 1 1076 0
 3637 1ffc 9EC4C6E5 		strb	ip, [r6, #1182]
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3638              		.loc 1 1077 0
 3639 2000 A024C6E5 		strb	r2, [r6, #1184]
1078:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3640              		.loc 1 1078 0
 3641 2004 0D33C8E5 		strb	r3, [r8, #781]
 3642 2008 3FFFFFEA 		b	.L283
 3643              	.LVL280:
 3644              	.L229:
1005:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3645              		.loc 1 1005 0
 3646 200c 062089E0 		add	r2, r9, r6
 3647 2010 826188E0 		add	r6, r8, r2, asl #3
1006:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3648              		.loc 1 1006 0
 3649 2014 0110A0E3 		mov	r1, #1
1009:../uvc.c      **** 		  		    switch (getData){
 3650              		.loc 1 1009 0
 3651 2018 01E040E2 		sub	lr, r0, #1
1005:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3652              		.loc 1 1005 0
 3653 201c 9D04C6E5 		strb	r0, [r6, #1181]
1006:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3654              		.loc 1 1006 0
 3655 2020 A014C6E5 		strb	r1, [r6, #1184]
 3656              	.LVL281:
1009:../uvc.c      **** 		  		    switch (getData){
 3657              		.loc 1 1009 0
 3658 2024 07005EE3 		cmp	lr, #7
 3659 2028 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3660 202c 970000EA 		b	.L234
 3661              	.L239:
 3662 2030 24220000 		.word	.L235
 3663 2034 88210000 		.word	.L236
 3664 2038 90220000 		.word	.L234
 3665 203c 24210000 		.word	.L237
 3666 2040 90220000 		.word	.L234
 3667 2044 90220000 		.word	.L234
 3668 2048 90220000 		.word	.L234
 3669 204c 84200000 		.word	.L238
 3670              	.LVL282:
 3671              	.L228:
1125:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3672              		.loc 1 1125 0
 3673 2050 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1124:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3674              		.loc 1 1124 0
 3675 2054 30A09DE5 		ldr	sl, [sp, #48]
 3676 2058 069089E0 		add	r9, r9, r6
 3677 205c 89E188E0 		add	lr, r8, r9, asl #3
1125:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3678              		.loc 1 1125 0
 3679 2060 0620A0E1 		mov	r2, r6
 3680 2064 0400A0E3 		mov	r0, #4
 3681 2068 BC129FE5 		ldr	r1, .L293+36
1124:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3682              		.loc 1 1124 0
 3683 206c 9DA4CEE5 		strb	sl, [lr, #1181]
1125:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3684              		.loc 1 1125 0
 3685 2070 FEFFFFEB 		bl	CyU3PDebugPrint
1126:../uvc.c      **** 			  		 break;
 3686              		.loc 1 1126 0
 3687 2074 FFC0A0E3 		mov	ip, #255
 3688 2078 0C60A0E1 		mov	r6, ip
 3689 207c 0C80A0E1 		mov	r8, ip
 3690 2080 68FEFFEA 		b	.L219
 3691              	.LVL283:
 3692              	.L238:
1028:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3693              		.loc 1 1028 0
 3694 2084 94629FE5 		ldr	r6, .L293+24
1026:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3695              		.loc 1 1026 0
 3696 2088 00A0A0E3 		mov	sl, #0
1028:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3697              		.loc 1 1028 0
 3698 208c 1C0096E5 		ldr	r0, [r6, #28]
1026:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3699              		.loc 1 1026 0
 3700 2090 0DA3C8E5 		strb	sl, [r8, #781]
 3701              	.LVL284:
1028:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3702              		.loc 1 1028 0
 3703 2094 0010E0E3 		mvn	r1, #0
 3704 2098 2C308DE5 		str	r3, [sp, #44]
 3705 209c FEFFFFEB 		bl	_txe_mutex_get
1029:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3706              		.loc 1 1029 0
 3707 20a0 0B20A0E1 		mov	r2, fp
 3708 20a4 2C309DE5 		ldr	r3, [sp, #44]
 3709 20a8 1010A0E3 		mov	r1, #16
 3710 20ac 0600A0E1 		mov	r0, r6
 3711 20b0 00A08DE5 		str	sl, [sp, #0]
 3712 20b4 04A08DE5 		str	sl, [sp, #4]
 3713 20b8 FEFFFFEB 		bl	cmdSet
1030:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3714              		.loc 1 1030 0
 3715 20bc 1C0096E5 		ldr	r0, [r6, #28]
 3716 20c0 FEFFFFEB 		bl	_txe_mutex_put
 3717              	.LVL285:
 3718              	.LBB66:
 3719              	.LBB67:
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3720              		.loc 1 382 0
 3721 20c4 0010E0E3 		mvn	r1, #0
 3722 20c8 1C0096E5 		ldr	r0, [r6, #28]
 3723 20cc FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3724              		.loc 1 383 0
 3725 20d0 0180A0E3 		mov	r8, #1
 3726 20d4 1410A0E3 		mov	r1, #20
 3727 20d8 2720A0E3 		mov	r2, #39
 3728 20dc 3030A0E3 		mov	r3, #48
 3729 20e0 0600A0E1 		mov	r0, r6
 3730 20e4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3731 20e8 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3732              		.loc 1 384 0
 3733 20ec 02C0A0E3 		mov	ip, #2
 3734 20f0 1510A0E3 		mov	r1, #21
 3735 20f4 2520A0E3 		mov	r2, #37
 3736 20f8 3030A0E3 		mov	r3, #48
 3737 20fc 0600A0E1 		mov	r0, r6
 3738 2100 00C08DE5 		str	ip, [sp, #0]
 3739 2104 04A08DE5 		str	sl, [sp, #4]
 3740 2108 FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3741              		.loc 1 385 0
 3742 210c 1C0096E5 		ldr	r0, [r6, #28]
 3743 2110 FEFFFFEB 		bl	_txe_mutex_put
 3744              	.LBE67:
 3745              	.LBE66:
1032:../uvc.c      **** 							break;
 3746              		.loc 1 1032 0
 3747 2114 FFC0A0E3 		mov	ip, #255
 3748 2118 0C60A0E1 		mov	r6, ip
 3749 211c 0880A0E3 		mov	r8, #8
 3750 2120 40FEFFEA 		b	.L219
 3751              	.LVL286:
 3752              	.L237:
 3753              	.LBB68:
 3754              	.LBB69:
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3755              		.loc 1 382 0
 3756 2124 F4819FE5 		ldr	r8, .L293+24
 3757 2128 0010E0E3 		mvn	r1, #0
 3758 212c 1C0098E5 		ldr	r0, [r8, #28]
 3759 2130 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3760              		.loc 1 383 0
 3761 2134 0060A0E3 		mov	r6, #0
 3762 2138 1410A0E3 		mov	r1, #20
 3763 213c 2720A0E3 		mov	r2, #39
 3764 2140 3030A0E3 		mov	r3, #48
 3765 2144 0800A0E1 		mov	r0, r8
 3766 2148 00608DE5 		str	r6, [sp, #0]
 3767 214c 04608DE5 		str	r6, [sp, #4]
 3768 2150 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3769              		.loc 1 384 0
 3770 2154 1510A0E3 		mov	r1, #21
 3771 2158 2520A0E3 		mov	r2, #37
 3772 215c 3030A0E3 		mov	r3, #48
 3773 2160 0800A0E1 		mov	r0, r8
 3774 2164 00608DE5 		str	r6, [sp, #0]
 3775 2168 04608DE5 		str	r6, [sp, #4]
 3776 216c FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3777              		.loc 1 385 0
 3778 2170 1C0098E5 		ldr	r0, [r8, #28]
 3779 2174 FEFFFFEB 		bl	_txe_mutex_put
 3780 2178 FFC0A0E3 		mov	ip, #255
 3781 217c 0C60A0E1 		mov	r6, ip
 3782 2180 0480A0E3 		mov	r8, #4
 3783 2184 27FEFFEA 		b	.L219
 3784              	.LVL287:
 3785              	.L236:
 3786              	.LBE69:
 3787              	.LBE68:
1016:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3788              		.loc 1 1016 0
 3789 2188 90A19FE5 		ldr	sl, .L293+24
1014:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3790              		.loc 1 1014 0
 3791 218c 0060A0E3 		mov	r6, #0
 3792 2190 0D63C8E5 		strb	r6, [r8, #781]
 3793              	.LVL288:
1016:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3794              		.loc 1 1016 0
 3795 2194 0010E0E3 		mvn	r1, #0
 3796 2198 1C009AE5 		ldr	r0, [sl, #28]
 3797 219c 2C308DE5 		str	r3, [sp, #44]
 3798 21a0 FEFFFFEB 		bl	_txe_mutex_get
1017:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3799              		.loc 1 1017 0
 3800 21a4 0B20A0E1 		mov	r2, fp
 3801 21a8 2C309DE5 		ldr	r3, [sp, #44]
 3802 21ac 1010A0E3 		mov	r1, #16
 3803 21b0 0A00A0E1 		mov	r0, sl
 3804 21b4 00608DE5 		str	r6, [sp, #0]
 3805 21b8 04608DE5 		str	r6, [sp, #4]
 3806 21bc FEFFFFEB 		bl	cmdSet
1018:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3807              		.loc 1 1018 0
 3808 21c0 1C009AE5 		ldr	r0, [sl, #28]
 3809 21c4 FEFFFFEB 		bl	_txe_mutex_put
 3810              	.LVL289:
 3811              	.LBB70:
 3812              	.LBB71:
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3813              		.loc 1 382 0
 3814 21c8 0010E0E3 		mvn	r1, #0
 3815 21cc 1C009AE5 		ldr	r0, [sl, #28]
 3816 21d0 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3817              		.loc 1 383 0
 3818 21d4 1410A0E3 		mov	r1, #20
 3819 21d8 2720A0E3 		mov	r2, #39
 3820 21dc 3030A0E3 		mov	r3, #48
 3821 21e0 0A00A0E1 		mov	r0, sl
 3822 21e4 00608DE5 		str	r6, [sp, #0]
 3823 21e8 04608DE5 		str	r6, [sp, #4]
 3824 21ec FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3825              		.loc 1 384 0
 3826 21f0 1510A0E3 		mov	r1, #21
 3827 21f4 2520A0E3 		mov	r2, #37
 3828 21f8 3030A0E3 		mov	r3, #48
 3829 21fc 0A00A0E1 		mov	r0, sl
 3830 2200 00608DE5 		str	r6, [sp, #0]
 3831 2204 04608DE5 		str	r6, [sp, #4]
 3832 2208 FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3833              		.loc 1 385 0
 3834 220c 1C009AE5 		ldr	r0, [sl, #28]
 3835 2210 FEFFFFEB 		bl	_txe_mutex_put
 3836 2214 FFC0A0E3 		mov	ip, #255
 3837 2218 0C60A0E1 		mov	r6, ip
 3838 221c 0280A0E3 		mov	r8, #2
 3839 2220 00FEFFEA 		b	.L219
 3840              	.LVL290:
 3841              	.L235:
 3842              	.LBE71:
 3843              	.LBE70:
 3844              	.LBB72:
 3845              	.LBB73:
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3846              		.loc 1 382 0
 3847 2224 F4609FE5 		ldr	r6, .L293+24
 3848 2228 0010E0E3 		mvn	r1, #0
 3849 222c 1C0096E5 		ldr	r0, [r6, #28]
 3850 2230 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3851              		.loc 1 383 0
 3852 2234 0080A0E3 		mov	r8, #0
 3853 2238 01A0A0E3 		mov	sl, #1
 3854 223c 1410A0E3 		mov	r1, #20
 3855 2240 2720A0E3 		mov	r2, #39
 3856 2244 3030A0E3 		mov	r3, #48
 3857 2248 0600A0E1 		mov	r0, r6
 3858 224c 04808DE5 		str	r8, [sp, #4]
 3859 2250 00A08DE5 		str	sl, [sp, #0]
 3860 2254 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3861              		.loc 1 384 0
 3862 2258 02C0A0E3 		mov	ip, #2
 3863 225c 1510A0E3 		mov	r1, #21
 3864 2260 2520A0E3 		mov	r2, #37
 3865 2264 3030A0E3 		mov	r3, #48
 3866 2268 0600A0E1 		mov	r0, r6
 3867 226c 00C08DE5 		str	ip, [sp, #0]
 3868 2270 04808DE5 		str	r8, [sp, #4]
 3869 2274 FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3870              		.loc 1 385 0
 3871 2278 1C0096E5 		ldr	r0, [r6, #28]
 3872 227c FEFFFFEB 		bl	_txe_mutex_put
 3873              	.LBE73:
 3874              	.LBE72:
1012:../uvc.c      **** 							break;
 3875              		.loc 1 1012 0
 3876 2280 FFC0A0E3 		mov	ip, #255
 3877 2284 0C60A0E1 		mov	r6, ip
 3878 2288 0A80A0E1 		mov	r8, sl
 3879 228c E5FDFFEA 		b	.L219
 3880              	.LVL291:
 3881              	.L234:
1009:../uvc.c      **** 		  		    switch (getData){
 3882              		.loc 1 1009 0
 3883 2290 FFC0A0E3 		mov	ip, #255
 3884 2294 0080A0E1 		mov	r8, r0
 3885 2298 0C60A0E1 		mov	r6, ip
 3886 229c E1FDFFEA 		b	.L219
 3887              	.LVL292:
 3888              	.L240:
1080:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3889              		.loc 1 1080 0
 3890 22a0 0000A0E3 		mov	r0, #0
 3891 22a4 0110A0E3 		mov	r1, #1
 3892 22a8 0020A0E1 		mov	r2, r0
 3893 22ac FEFFFFEB 		bl	CyU3PUsbStall
 3894              	.LVL293:
 3895 22b0 95FEFFEA 		b	.L283
 3896              	.LVL294:
 3897              	.L282:
1098:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3898              		.loc 1 1098 0
 3899 22b4 0110A0E3 		mov	r1, #1
 3900 22b8 0020A0E1 		mov	r2, r0
 3901 22bc FEFFFFEB 		bl	CyU3PUsbStall
 3902 22c0 91FEFFEA 		b	.L283
 3903              	.LVL295:
 3904              	.L292:
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3905              		.loc 1 1113 0
 3906 22c4 08E0A0E3 		mov	lr, #8
 3907 22c8 00C0A0E3 		mov	ip, #0
 3908 22cc 0600A0E1 		mov	r0, r6
 3909 22d0 1710A0E3 		mov	r1, #23
 3910 22d4 0B20A0E1 		mov	r2, fp
 3911 22d8 00E08DE5 		str	lr, [sp, #0]
 3912 22dc 04C08DE5 		str	ip, [sp, #4]
 3913 22e0 FEFFFFEB 		bl	cmdSet
 3914 22e4 5EFEFFEA 		b	.L285
 3915              	.L291:
1111:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3916              		.loc 1 1111 0
 3917 22e8 0480A0E3 		mov	r8, #4
 3918 22ec 00E0A0E3 		mov	lr, #0
 3919 22f0 0600A0E1 		mov	r0, r6
 3920 22f4 1710A0E3 		mov	r1, #23
 3921 22f8 0B20A0E1 		mov	r2, fp
 3922 22fc 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3923 2300 FEFFFFEB 		bl	cmdSet
 3924 2304 56FEFFEA 		b	.L285
 3925              	.L294:
 3926              		.align	2
 3927              	.L293:
 3928 2308 00000000 		.word	bRequest
 3929 230c 00000000 		.word	.LANCHOR1
 3930 2310 00000000 		.word	.LANCHOR0
 3931 2314 D8030000 		.word	.LC24
 3932 2318 FC030000 		.word	.LC25
 3933 231c 58000000 		.word	.LANCHOR0+88
 3934 2320 00000000 		.word	cmdQu
 3935 2324 8C030000 		.word	.LC22
 3936 2328 FFFF0000 		.word	65535
 3937 232c B4030000 		.word	.LC23
 3938              		.cfi_endproc
 3939              	.LFE3:
 3941              		.align	2
 3942              		.global	UVCAppEP0Thread_Entry
 3944              	UVCAppEP0Thread_Entry:
 3945              	.LFB24:
3092:../uvc.c      **** {
 3946              		.loc 1 3092 0
 3947              		.cfi_startproc
 3948              		@ args = 0, pretend = 0, frame = 32
 3949              		@ frame_needed = 0, uses_anonymous_args = 0
 3950              	.LVL296:
 3951 2330 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3952              	.LCFI17:
 3953              		.cfi_def_cfa_offset 36
 3954 2334 DC499FE5 		ldr	r4, .L442
 3955              		.cfi_offset 14, -4
 3956              		.cfi_offset 11, -8
 3957              		.cfi_offset 10, -12
 3958              		.cfi_offset 9, -16
 3959              		.cfi_offset 8, -20
 3960              		.cfi_offset 7, -24
 3961              		.cfi_offset 6, -28
 3962              		.cfi_offset 5, -32
 3963              		.cfi_offset 4, -36
 3964 2338 DC699FE5 		ldr	r6, .L442+4
 3965 233c DC899FE5 		ldr	r8, .L442+8
 3966 2340 DC999FE5 		ldr	r9, .L442+12
 3967 2344 DCA99FE5 		ldr	sl, .L442+16
 3968 2348 DC799FE5 		ldr	r7, .L442+20
 3969 234c 3CD04DE2 		sub	sp, sp, #60
 3970              	.LCFI18:
 3971              		.cfi_def_cfa_offset 96
 3972              	.LVL297:
3114:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 3973              		.loc 1 3114 0
 3974 2350 0450A0E1 		mov	r5, r4
 3975              	.LVL298:
 3976              	.L419:
 3977 2354 00C0E0E3 		mvn	ip, #0
 3978 2358 B8099FE5 		ldr	r0, .L442
 3979 235c 4C10A0E3 		mov	r1, #76
 3980 2360 0120A0E3 		mov	r2, #1
 3981 2364 30308DE2 		add	r3, sp, #48
 3982 2368 00C08DE5 		str	ip, [sp, #0]
 3983 236c FEFFFFEB 		bl	_txe_event_flags_get
 3984 2370 000050E3 		cmp	r0, #0
 3985 2374 3000001A 		bne	.L296
3118:../uvc.c      ****             if (!isUsbConnected)
 3986              		.loc 1 3118 0
 3987 2378 3C3095E5 		ldr	r3, [r5, #60]
 3988 237c 000053E3 		cmp	r3, #0
 3989 2380 8900000A 		beq	.L433
 3990              	.L297:
3127:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 3991              		.loc 1 3127 0
 3992 2384 30309DE5 		ldr	r3, [sp, #48]
 3993 2388 0C0013E3 		tst	r3, #12
 3994 238c 7200001A 		bne	.L434
 3995              	.L298:
3134:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 3996              		.loc 1 3134 0
 3997 2390 040013E3 		tst	r3, #4
 3998 2394 1C00000A 		beq	.L299
3136:../uvc.c      ****             	switch ((wIndex >> 8))
 3999              		.loc 1 3136 0
 4000 2398 B0E0DAE1 		ldrh	lr, [sl, #0]
 4001 239c 2E24A0E1 		mov	r2, lr, lsr #8
 4002 23a0 030052E3 		cmp	r2, #3
 4003 23a4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4004 23a8 120000EA 		b	.L300
 4005              	.L305:
 4006 23ac F8230000 		.word	.L300
 4007 23b0 DC240000 		.word	.L302
 4008 23b4 BC230000 		.word	.L303
 4009 23b8 18250000 		.word	.L304
 4010              	.L303:
 4011              	.LBB88:
 4012              	.LBB90:
2423:../uvc.c      ****     switch (wValue)
 4013              		.loc 1 2423 0
 4014 23bc B020D9E1 		ldrh	r2, [r9, #0]
 4015 23c0 060C52E3 		cmp	r2, #1536
 4016 23c4 D901000A 		beq	.L311
 4017 23c8 CC00008A 		bhi	.L317
 4018 23cc 030C52E3 		cmp	r2, #768
 4019 23d0 D201000A 		beq	.L309
 4020 23d4 C901008A 		bhi	.L318
 4021 23d8 010C52E3 		cmp	r2, #256
 4022 23dc 6801000A 		beq	.L307
 4023 23e0 020C52E3 		cmp	r2, #512
 4024 23e4 6201000A 		beq	.L435
 4025              	.L320:
 4026              	.LBE90:
 4027              	.LBE88:
 4028              	.LBB93:
 4029              	.LBB97:
2555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4030              		.loc 1 2555 0
 4031 23e8 40199FE5 		ldr	r1, .L442+24
 4032 23ec 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4033 23f0 0400A0E3 		mov	r0, #4
 4034 23f4 FEFFFFEB 		bl	CyU3PDebugPrint
 4035              	.L300:
 4036              	.LBE97:
 4037              	.LBE93:
3157:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4038              		.loc 1 3157 0
 4039 23f8 0000A0E3 		mov	r0, #0
 4040 23fc 0110A0E3 		mov	r1, #1
 4041 2400 0020A0E1 		mov	r2, r0
 4042 2404 FEFFFFEB 		bl	CyU3PUsbStall
 4043 2408 30309DE5 		ldr	r3, [sp, #48]
 4044              	.L299:
3162:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4045              		.loc 1 3162 0
 4046 240c 080013E3 		tst	r3, #8
 4047 2410 0700000A 		beq	.L361
3166:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4048              		.loc 1 3166 0
 4049 2414 B030DAE1 		ldrh	r3, [sl, #0]
 4050 2418 010053E3 		cmp	r3, #1
 4051 241c 6800000A 		beq	.L362
 4052              	.L363:
 4053              	.LBB102:
 4054              	.LBB108:
3081:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4055              		.loc 1 3081 0
 4056 2420 0000A0E3 		mov	r0, #0
 4057 2424 0110A0E3 		mov	r1, #1
 4058 2428 0020A0E1 		mov	r2, r0
 4059 242c FEFFFFEB 		bl	CyU3PUsbStall
 4060              	.L423:
 4061 2430 30309DE5 		ldr	r3, [sp, #48]
 4062              	.L361:
 4063              	.LBE108:
 4064              	.LBE102:
3177:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4065              		.loc 1 3177 0
 4066 2434 400013E3 		tst	r3, #64
 4067 2438 0100001A 		bne	.L436
 4068              	.L296:
3390:../uvc.c      ****         CyU3PThreadRelinquish ();
 4069              		.loc 1 3390 0
 4070 243c FEFFFFEB 		bl	_txe_thread_relinquish
3391:../uvc.c      ****     }
 4071              		.loc 1 3391 0
 4072 2440 C3FFFFEA 		b	.L419
 4073              	.L436:
3182:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4074              		.loc 1 3182 0
 4075 2444 1800A0E3 		mov	r0, #24
 4076 2448 2C108DE2 		add	r1, sp, #44
 4077 244c FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3187:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4078              		.loc 1 3187 0
 4079 2450 2C209DE5 		ldr	r2, [sp, #44]
 4080 2454 000052E3 		cmp	r2, #0
 4081 2458 6D00000A 		beq	.L414
3187:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4082              		.loc 1 3187 0 is_stmt 0 discriminator 1
 4083 245c 6336D6E5 		ldrb	r3, [r6, #1635]	@ zero_extendqisi2
 4084 2460 000053E3 		cmp	r3, #0
 4085 2464 F4FFFF1A 		bne	.L296
3189:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4086              		.loc 1 3189 0 is_stmt 1
 4087 2468 002097E5 		ldr	r2, [r7, #0]
 4088 246c 02B0A0E3 		mov	fp, #2
 4089 2470 00B0C2E5 		strb	fp, [r2, #0]
3190:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4090              		.loc 1 3190 0
 4091 2474 001097E5 		ldr	r1, [r7, #0]
 4092 2478 01B0A0E3 		mov	fp, #1
 4093 247c 01B0C1E5 		strb	fp, [r1, #1]
3191:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4094              		.loc 1 3191 0
 4095 2480 000097E5 		ldr	r0, [r7, #0]
3195:../uvc.c      **** 					interStabuf.size   = 1024;
 4096              		.loc 1 3195 0
 4097 2484 01EBA0E3 		mov	lr, #1024	@ movhi
3191:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4098              		.loc 1 3191 0
 4099 2488 0230C0E5 		strb	r3, [r0, #2]
3192:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4100              		.loc 1 3192 0
 4101 248c 00C097E5 		ldr	ip, [r7, #0]
3201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4102              		.loc 1 3201 0
 4103 2490 0010E0E3 		mvn	r1, #0
3192:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4104              		.loc 1 3192 0
 4105 2494 0330CCE5 		strb	r3, [ip, #3]
3194:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4106              		.loc 1 3194 0
 4107 2498 002097E5 		ldr	r2, [r7, #0]
3198:../uvc.c      **** 					interStabuf.count = 4;
 4108              		.loc 1 3198 0
 4109 249c 04C0A0E3 		mov	ip, #4	@ movhi
3201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4110              		.loc 1 3201 0
 4111 24a0 8C089FE5 		ldr	r0, .L442+28
3194:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4112              		.loc 1 3194 0
 4113 24a4 20208DE5 		str	r2, [sp, #32]
3195:../uvc.c      **** 					interStabuf.size   = 1024;
 4114              		.loc 1 3195 0
 4115 24a8 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3196:../uvc.c      **** 					interStabuf.status = 0;
 4116              		.loc 1 3196 0
 4117 24ac B832CDE1 		strh	r3, [sp, #40]	@ movhi
3198:../uvc.c      **** 					interStabuf.count = 4;
 4118              		.loc 1 3198 0
 4119 24b0 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
3201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4120              		.loc 1 3201 0
 4121 24b4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3204:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4122              		.loc 1 3204 0
 4123 24b8 74089FE5 		ldr	r0, .L442+28
 4124 24bc 20108DE2 		add	r1, sp, #32
 4125 24c0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4126              	.LVL299:
3205:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4127              		.loc 1 3205 0
 4128 24c4 002050E2 		subs	r2, r0, #0
 4129 24c8 6701001A 		bne	.L437
3210:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4130              		.loc 1 3210 0
 4131 24cc 48389FE5 		ldr	r3, .L442+4
 4132 24d0 63B6C3E5 		strb	fp, [r3, #1635]
3390:../uvc.c      ****         CyU3PThreadRelinquish ();
 4133              		.loc 1 3390 0
 4134 24d4 FEFFFFEB 		bl	_txe_thread_relinquish
 4135              	.LVL300:
 4136 24d8 9DFFFFEA 		b	.L419
 4137              	.L302:
 4138              	.LBB114:
 4139              	.LBB98:
2498:../uvc.c      ****     switch (wValue)
 4140              		.loc 1 2498 0
 4141 24dc B020D9E1 		ldrh	r2, [r9, #0]
 4142 24e0 060C52E3 		cmp	r2, #1536
 4143 24e4 D500000A 		beq	.L326
 4144 24e8 8F00008A 		bhi	.L332
 4145 24ec 030C52E3 		cmp	r2, #768
 4146 24f0 1701000A 		beq	.L323
 4147 24f4 0E01008A 		bhi	.L333
 4148 24f8 010C52E3 		cmp	r2, #256
 4149 24fc 5601000A 		beq	.L321
 4150 2500 020C52E3 		cmp	r2, #512
 4151 2504 B7FFFF1A 		bne	.L320
 4152              	.LVL301:
2506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4153              		.loc 1 2506 0
 4154 2508 0100A0E3 		mov	r0, #1
 4155 250c FEFFFFEB 		bl	CTControlHandle
 4156              	.LVL302:
 4157 2510 30309DE5 		ldr	r3, [sp, #48]
 4158 2514 BCFFFFEA 		b	.L299
 4159              	.L304:
 4160              	.LBE98:
 4161              	.LBE114:
 4162              	.LBB115:
 4163              	.LBB120:
2723:../uvc.c      ****     switch (wValue)
 4164              		.loc 1 2723 0
 4165 2518 B020D9E1 		ldrh	r2, [r9, #0]
 4166 251c 090C52E3 		cmp	r2, #2304
 4167 2520 EE01000A 		beq	.L347
 4168 2524 8800008A 		bhi	.L356
 4169 2528 010B52E3 		cmp	r2, #1024
 4170 252c EF01000A 		beq	.L342
 4171 2530 8701008A 		bhi	.L357
 4172 2534 020C52E3 		cmp	r2, #512
 4173 2538 E401000A 		beq	.L340
 4174 253c 030C52E3 		cmp	r2, #768
 4175 2540 C301000A 		beq	.L341
 4176 2544 010C52E3 		cmp	r2, #256
 4177 2548 AAFFFF1A 		bne	.L300
 4178              	.LVL303:
2727:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4179              		.loc 1 2727 0
 4180 254c 1000A0E3 		mov	r0, #16
 4181 2550 FEFFFFEB 		bl	ControlHandle
 4182              	.LVL304:
 4183 2554 30309DE5 		ldr	r3, [sp, #48]
 4184 2558 ABFFFFEA 		b	.L299
 4185              	.L434:
 4186              	.LBE120:
 4187              	.LBE115:
3128:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4188              		.loc 1 3128 0
 4189 255c D4B79FE5 		ldr	fp, .L442+32
 4190 2560 B0C0D9E1 		ldrh	ip, [r9, #0]
 4191 2564 B000DAE1 		ldrh	r0, [sl, #0]
 4192 2568 CC179FE5 		ldr	r1, .L442+36
 4193 256c 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4194 2570 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4195 2574 0C008DE5 		str	r0, [sp, #12]
 4196 2578 08C08DE5 		str	ip, [sp, #8]
 4197 257c B0C0D1E1 		ldrh	ip, [r1, #0]
 4198 2580 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4199 2584 04B08DE5 		str	fp, [sp, #4]
 4200 2588 0400A0E3 		mov	r0, #4
 4201 258c AC179FE5 		ldr	r1, .L442+40
 4202 2590 00B0A0E3 		mov	fp, #0
 4203 2594 00E08DE5 		str	lr, [sp, #0]
 4204 2598 10C08DE5 		str	ip, [sp, #16]
 4205 259c 14B08DE5 		str	fp, [sp, #20]
 4206 25a0 FEFFFFEB 		bl	CyU3PDebugPrint
 4207 25a4 30309DE5 		ldr	r3, [sp, #48]
 4208 25a8 78FFFFEA 		b	.L298
 4209              	.L433:
3120:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4210              		.loc 1 3120 0
 4211 25ac FEFFFFEB 		bl	CyU3PUsbGetSpeed
3121:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4212              		.loc 1 3121 0
 4213 25b0 000050E3 		cmp	r0, #0
3120:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4214              		.loc 1 3120 0
 4215 25b4 4800C5E5 		strb	r0, [r5, #72]
3123:../uvc.c      ****                     isUsbConnected = CyTrue;
 4216              		.loc 1 3123 0
 4217 25b8 0100A013 		movne	r0, #1
 4218 25bc 3C008515 		strne	r0, [r5, #60]
 4219 25c0 6FFFFFEA 		b	.L297
 4220              	.L362:
 4221              	.LVL305:
 4222              	.LBB125:
 4223              	.LBB107:
2818:../uvc.c      ****     switch (wValue)
 4224              		.loc 1 2818 0
 4225 25c4 B020D9E1 		ldrh	r2, [r9, #0]
 4226 25c8 030C52E3 		cmp	r2, #768
 4227 25cc 8100000A 		beq	.L366
 4228 25d0 3300008A 		bhi	.L369
 4229 25d4 010C52E3 		cmp	r2, #256
 4230 25d8 8B00000A 		beq	.L364
 4231 25dc 020C52E3 		cmp	r2, #512
 4232 25e0 8EFFFF1A 		bne	.L363
2870:../uvc.c      ****             switch (bRequest)
 4233              		.loc 1 2870 0
 4234 25e4 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4235 25e8 810053E3 		cmp	r3, #129
 4236 25ec 8B00000A 		beq	.L408
 4237 25f0 2601008A 		bhi	.L384
 4238 25f4 010053E3 		cmp	r3, #1
 4239 25f8 8401000A 		beq	.L438
 4240              	.L388:
2969:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4241              		.loc 1 2969 0
 4242 25fc 0000A0E3 		mov	r0, #0
 4243 2600 0110A0E3 		mov	r1, #1
 4244 2604 0020A0E1 		mov	r2, r0
 4245 2608 FEFFFFEB 		bl	CyU3PUsbStall
 4246 260c 30309DE5 		ldr	r3, [sp, #48]
 4247 2610 87FFFFEA 		b	.L361
 4248              	.LVL306:
 4249              	.L414:
 4250              	.LBE107:
 4251              	.LBE125:
3211:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4252              		.loc 1 3211 0
 4253 2614 63E6D6E5 		ldrb	lr, [r6, #1635]	@ zero_extendqisi2
 4254 2618 00005EE3 		cmp	lr, #0
 4255 261c 86FFFF0A 		beq	.L296
3213:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4256              		.loc 1 3213 0
 4257 2620 003097E5 		ldr	r3, [r7, #0]
 4258 2624 02B0A0E3 		mov	fp, #2
 4259 2628 00B0C3E5 		strb	fp, [r3, #0]
3214:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4260              		.loc 1 3214 0
 4261 262c 001097E5 		ldr	r1, [r7, #0]
 4262 2630 01B0A0E3 		mov	fp, #1
 4263 2634 01B0C1E5 		strb	fp, [r1, #1]
3215:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4264              		.loc 1 3215 0
 4265 2638 000097E5 		ldr	r0, [r7, #0]
3219:../uvc.c      **** 					interStabuf.size   = 1024;
 4266              		.loc 1 3219 0
 4267 263c 01EBA0E3 		mov	lr, #1024	@ movhi
3215:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4268              		.loc 1 3215 0
 4269 2640 0220C0E5 		strb	r2, [r0, #2]
3216:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4270              		.loc 1 3216 0
 4271 2644 00C097E5 		ldr	ip, [r7, #0]
3225:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4272              		.loc 1 3225 0
 4273 2648 0010E0E3 		mvn	r1, #0
3216:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4274              		.loc 1 3216 0
 4275 264c 03B0CCE5 		strb	fp, [ip, #3]
3218:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4276              		.loc 1 3218 0
 4277 2650 003097E5 		ldr	r3, [r7, #0]
3220:../uvc.c      **** 					interStabuf.status = 0;
 4278              		.loc 1 3220 0
 4279 2654 02C0A0E1 		mov	ip, r2	@ movhi
 4280 2658 B822CDE1 		strh	r2, [sp, #40]	@ movhi
3225:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4281              		.loc 1 3225 0
 4282 265c D0069FE5 		ldr	r0, .L442+28
3222:../uvc.c      **** 					interStabuf.count = 4;
 4283              		.loc 1 3222 0
 4284 2660 0420A0E3 		mov	r2, #4	@ movhi
3218:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4285              		.loc 1 3218 0
 4286 2664 20308DE5 		str	r3, [sp, #32]
3222:../uvc.c      **** 					interStabuf.count = 4;
 4287              		.loc 1 3222 0
 4288 2668 B422CDE1 		strh	r2, [sp, #36]	@ movhi
3219:../uvc.c      **** 					interStabuf.size   = 1024;
 4289              		.loc 1 3219 0
 4290 266c B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3225:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4291              		.loc 1 3225 0
 4292 2670 1CC08DE5 		str	ip, [sp, #28]
 4293 2674 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3228:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4294              		.loc 1 3228 0
 4295 2678 B4069FE5 		ldr	r0, .L442+28
 4296 267c 20108DE2 		add	r1, sp, #32
 4297 2680 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4298              	.LVL307:
3229:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4299              		.loc 1 3229 0
 4300 2684 1C309DE5 		ldr	r3, [sp, #28]
 4301 2688 002050E2 		subs	r2, r0, #0
 4302 268c C000001A 		bne	.L439
3235:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4303              		.loc 1 3235 0
 4304 2690 84269FE5 		ldr	r2, .L442+4
3236:../uvc.c      **** 					stiflag = CyTrue;
 4305              		.loc 1 3236 0
 4306 2694 98B084E5 		str	fp, [r4, #152]
3235:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4307              		.loc 1 3235 0
 4308 2698 6336C2E5 		strb	r3, [r2, #1635]
3390:../uvc.c      ****         CyU3PThreadRelinquish ();
 4309              		.loc 1 3390 0
 4310 269c FEFFFFEB 		bl	_txe_thread_relinquish
 4311              	.LVL308:
 4312 26a0 2BFFFFEA 		b	.L419
 4313              	.LVL309:
 4314              	.L369:
 4315              	.LBB126:
 4316              	.LBB109:
2818:../uvc.c      ****     switch (wValue)
 4317              		.loc 1 2818 0
 4318 26a4 010B52E3 		cmp	r2, #1024
 4319 26a8 3800000A 		beq	.L367
 4320 26ac 050C52E3 		cmp	r2, #1280
 4321 26b0 5AFFFF1A 		bne	.L363
3030:../uvc.c      ****                 switch (bRequest)
 4322              		.loc 1 3030 0
 4323 26b4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4324 26b8 810052E3 		cmp	r2, #129
 4325 26bc 5700000A 		beq	.L408
 4326 26c0 1E01008A 		bhi	.L411
 4327 26c4 010052E3 		cmp	r2, #1
 4328 26c8 54FFFF1A 		bne	.L363
3055:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4329              		.loc 1 3055 0
 4330 26cc 2000A0E3 		mov	r0, #32
 4331 26d0 6C169FE5 		ldr	r1, .L442+44
 4332 26d4 36208DE2 		add	r2, sp, #54
 4333 26d8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4334              	.LVL310:
3057:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4335              		.loc 1 3057 0
 4336 26dc 000050E3 		cmp	r0, #0
 4337 26e0 8601001A 		bne	.L413
3067:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4338              		.loc 1 3067 0
 4339 26e4 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 4340 26e8 040080E2 		add	r0, r0, #4
 4341              	.LVL311:
 4342 26ec 54169FE5 		ldr	r1, .L442+48
 4343 26f0 B623DDE1 		ldrh	r2, [sp, #54]
 4344 26f4 FEFFFFEB 		bl	CyU3PDebugPrint
 4345              	.LVL312:
 4346 26f8 30309DE5 		ldr	r3, [sp, #48]
 4347 26fc 4CFFFFEA 		b	.L361
 4348              	.L317:
 4349              	.LBE109:
 4350              	.LBE126:
 4351              	.LBB127:
 4352              	.LBB91:
2423:../uvc.c      ****     switch (wValue)
 4353              		.loc 1 2423 0
 4354 2700 0A0C52E3 		cmp	r2, #2560
 4355 2704 F500000A 		beq	.L314
 4356 2708 EA00008A 		bhi	.L319
 4357 270c 070C52E3 		cmp	r2, #1792
 4358 2710 E400000A 		beq	.L312
 4359 2714 020B52E3 		cmp	r2, #2048
 4360 2718 32FFFF1A 		bne	.L320
 4361              	.LVL313:
2454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4362              		.loc 1 2454 0
 4363 271c 0700A0E3 		mov	r0, #7
 4364 2720 FEFFFFEB 		bl	ControlHandle
 4365              	.LVL314:
 4366 2724 30309DE5 		ldr	r3, [sp, #48]
 4367 2728 37FFFFEA 		b	.L299
 4368              	.L332:
 4369              	.LBE91:
 4370              	.LBE127:
 4371              	.LBB128:
 4372              	.LBB96:
2498:../uvc.c      ****     switch (wValue)
 4373              		.loc 1 2498 0
 4374 272c 090C52E3 		cmp	r2, #2304
 4375 2730 2601000A 		beq	.L328
 4376 2734 1B01008A 		bhi	.L334
 4377 2738 070C52E3 		cmp	r2, #1792
 4378 273c 0D01000A 		beq	.L327
 4379 2740 020B52E3 		cmp	r2, #2048
 4380 2744 27FFFF1A 		bne	.L320
 4381 2748 2FFFFFEA 		b	.L299
 4382              	.L356:
 4383              	.LBE96:
 4384              	.LBE128:
 4385              	.LBB129:
 4386              	.LBB119:
2723:../uvc.c      ****     switch (wValue)
 4387              		.loc 1 2723 0
 4388 274c 0F0C52E3 		cmp	r2, #3840
 4389 2750 5A01000A 		beq	.L351
 4390 2754 3D00008A 		bhi	.L359
 4391 2758 0B0C52E3 		cmp	r2, #2816
 4392 275c 5301000A 		beq	.L349
 4393 2760 0D0C52E3 		cmp	r2, #3328
 4394 2764 4D01000A 		beq	.L350
 4395 2768 0A0C52E3 		cmp	r2, #2560
 4396 276c 21FFFF1A 		bne	.L300
2766:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
 4397              		.loc 1 2766 0
 4398 2770 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4399 2774 00C0A0E3 		mov	ip, #0
 4400 2778 0400A0E3 		mov	r0, #4
 4401 277c C8159FE5 		ldr	r1, .L442+52
 4402 2780 00C08DE5 		str	ip, [sp, #0]
 4403 2784 FEFFFFEB 		bl	CyU3PDebugPrint
 4404 2788 30309DE5 		ldr	r3, [sp, #48]
 4405 278c 1EFFFFEA 		b	.L299
 4406              	.LVL315:
 4407              	.L367:
 4408              	.LBE119:
 4409              	.LBE129:
 4410              	.LBB130:
 4411              	.LBB106:
2975:../uvc.c      ****                 switch (bRequest)
 4412              		.loc 1 2975 0
 4413 2790 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4414 2794 81005BE3 		cmp	fp, #129
 4415 2798 1300000A 		beq	.L399
 4416 279c 8500008A 		bhi	.L402
 4417 27a0 01005BE3 		cmp	fp, #1
 4418 27a4 1DFFFF1A 		bne	.L363
3000:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4419              		.loc 1 3000 0
 4420 27a8 36208DE2 		add	r2, sp, #54
 4421 27ac 2000A0E3 		mov	r0, #32
 4422 27b0 8C159FE5 		ldr	r1, .L442+44
 4423 27b4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4424              	.LVL316:
3002:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4425              		.loc 1 3002 0
 4426 27b8 002050E2 		subs	r2, r0, #0
 4427 27bc 1BFFFF1A 		bne	.L423
3015:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4428              		.loc 1 3015 0
 4429 27c0 50059FE5 		ldr	r0, .L442
 4430              	.LVL317:
 4431 27c4 0B10A0E1 		mov	r1, fp
 4432 27c8 FEFFFFEB 		bl	_txe_event_flags_set
 4433              	.LVL318:
3016:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4434              		.loc 1 3016 0
 4435 27cc 002050E2 		subs	r2, r0, #0
 4436 27d0 16FFFF0A 		beq	.L423
 4437 27d4 190100EA 		b	.L405
 4438              	.LVL319:
 4439              	.L366:
2926:../uvc.c      ****                 switch (bRequest)
 4440              		.loc 1 2926 0
 4441 27d8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4442 27dc 830052E3 		cmp	r2, #131
 4443 27e0 9800008A 		bhi	.L393
 4444 27e4 810052E3 		cmp	r2, #129
 4445 27e8 7D00003A 		bcc	.L440
 4446              	.L399:
2987:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4447              		.loc 1 2987 0
 4448 27ec 48B0D4E5 		ldrb	fp, [r4, #72]	@ zero_extendqisi2
2989:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4449              		.loc 1 2989 0
 4450 27f0 0B00A0E3 		mov	r0, #11
2987:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4451              		.loc 1 2987 0
 4452 27f4 03005BE3 		cmp	fp, #3
2989:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4453              		.loc 1 2989 0
 4454 27f8 50159F05 		ldreq	r1, .L442+56
2993:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4455              		.loc 1 2993 0
 4456 27fc 50159F15 		ldrne	r1, .L442+60
 4457 2800 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4458 2804 30309DE5 		ldr	r3, [sp, #48]
 4459 2808 09FFFFEA 		b	.L361
 4460              	.L364:
2821:../uvc.c      ****             switch (bRequest)
 4461              		.loc 1 2821 0
 4462 280c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4463 2810 830052E3 		cmp	r2, #131
 4464 2814 2F00008A 		bhi	.L375
 4465 2818 810052E3 		cmp	r2, #129
 4466 281c 1400003A 		bcc	.L441
 4467              	.L408:
3042:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4468              		.loc 1 3042 0
 4469 2820 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3044:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4470              		.loc 1 3044 0
 4471 2824 1A00A0E3 		mov	r0, #26
3042:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4472              		.loc 1 3042 0
 4473 2828 030052E3 		cmp	r2, #3
3044:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4474              		.loc 1 3044 0
 4475 282c 24159F05 		ldreq	r1, .L442+64
3048:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4476              		.loc 1 3048 0
 4477 2830 24159F15 		ldrne	r1, .L442+68
 4478 2834 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4479 2838 30309DE5 		ldr	r3, [sp, #48]
 4480 283c FCFEFFEA 		b	.L361
 4481              	.LVL320:
 4482              	.L326:
 4483              	.LBE106:
 4484              	.LBE130:
 4485              	.LBB131:
 4486              	.LBB99:
2524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4487              		.loc 1 2524 0
 4488 2840 0500A0E3 		mov	r0, #5
 4489 2844 FEFFFFEB 		bl	CTControlHandle
 4490              	.LVL321:
 4491 2848 30309DE5 		ldr	r3, [sp, #48]
 4492 284c EEFEFFEA 		b	.L299
 4493              	.L359:
 4494              	.LBE99:
 4495              	.LBE131:
 4496              	.LBB132:
 4497              	.LBB121:
2723:../uvc.c      ****     switch (wValue)
 4498              		.loc 1 2723 0
 4499 2850 110C52E3 		cmp	r2, #4352
 4500 2854 E900000A 		beq	.L353
 4501 2858 2D00008A 		bhi	.L360
 4502 285c 010A52E3 		cmp	r2, #4096
 4503 2860 E4FEFF1A 		bne	.L300
 4504              	.LVL322:
2786:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4505              		.loc 1 2786 0
 4506 2864 1F00A0E3 		mov	r0, #31
 4507 2868 FEFFFFEB 		bl	ControlHandle
 4508              	.LVL323:
 4509 286c 30309DE5 		ldr	r3, [sp, #48]
 4510 2870 E5FEFFEA 		b	.L299
 4511              	.LVL324:
 4512              	.L441:
 4513              	.LBE121:
 4514              	.LBE132:
 4515              	.LBB133:
 4516              	.LBB110:
2821:../uvc.c      ****             switch (bRequest)
 4517              		.loc 1 2821 0
 4518 2874 010052E3 		cmp	r2, #1
 4519 2878 5FFFFF1A 		bne	.L388
2846:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4520              		.loc 1 2846 0
 4521 287c 2000A0E3 		mov	r0, #32
 4522 2880 BC149FE5 		ldr	r1, .L442+44
 4523 2884 36208DE2 		add	r2, sp, #54
 4524 2888 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4525              	.LVL325:
2848:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4526              		.loc 1 2848 0
 4527 288c 000050E3 		cmp	r0, #0
 4528 2890 E6FEFF1A 		bne	.L423
2850:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4529              		.loc 1 2850 0
 4530 2894 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 4531 2898 030053E3 		cmp	r3, #3
 4532 289c E3FEFF1A 		bne	.L423
2854:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4533              		.loc 1 2854 0
 4534 28a0 7AE0D4E5 		ldrb	lr, [r4, #122]	@ zero_extendqisi2
2855:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4535              		.loc 1 2855 0
 4536 28a4 7BC0D4E5 		ldrb	ip, [r4, #123]	@ zero_extendqisi2
2856:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4537              		.loc 1 2856 0
 4538 28a8 7C00D4E5 		ldrb	r0, [r4, #124]	@ zero_extendqisi2
 4539              	.LVL326:
2857:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4540              		.loc 1 2857 0
 4541 28ac 7D10D4E5 		ldrb	r1, [r4, #125]	@ zero_extendqisi2
2858:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4542              		.loc 1 2858 0
 4543 28b0 7E20D4E5 		ldrb	r2, [r4, #126]	@ zero_extendqisi2
2859:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4544              		.loc 1 2859 0
 4545 28b4 7FB0D4E5 		ldrb	fp, [r4, #127]	@ zero_extendqisi2
2854:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4546              		.loc 1 2854 0
 4547 28b8 16E6C6E5 		strb	lr, [r6, #1558]
2855:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4548              		.loc 1 2855 0
 4549 28bc 17C6C6E5 		strb	ip, [r6, #1559]
2856:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4550              		.loc 1 2856 0
 4551 28c0 1806C6E5 		strb	r0, [r6, #1560]
2857:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4552              		.loc 1 2857 0
 4553 28c4 1916C6E5 		strb	r1, [r6, #1561]
2858:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4554              		.loc 1 2858 0
 4555 28c8 1A26C6E5 		strb	r2, [r6, #1562]
2859:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4556              		.loc 1 2859 0
 4557 28cc 1BB6C6E5 		strb	fp, [r6, #1563]
 4558 28d0 30309DE5 		ldr	r3, [sp, #48]
 4559 28d4 D6FEFFEA 		b	.L361
 4560              	.LVL327:
 4561              	.L375:
2821:../uvc.c      ****             switch (bRequest)
 4562              		.loc 1 2821 0
 4563 28d8 860052E3 		cmp	r2, #134
 4564 28dc 3900000A 		beq	.L426
 4565 28e0 870052E3 		cmp	r2, #135
 4566 28e4 CDFFFF0A 		beq	.L408
 4567              	.L432:
2926:../uvc.c      ****                 switch (bRequest)
 4568              		.loc 1 2926 0
 4569 28e8 850052E3 		cmp	r2, #133
 4570 28ec 42FFFF1A 		bne	.L388
 4571              	.L400:
2984:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4572              		.loc 1 2984 0
 4573 28f0 68149FE5 		ldr	r1, .L442+72
 4574 28f4 0200A0E3 		mov	r0, #2
2982:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4575              		.loc 1 2982 0
 4576 28f8 1A30A0E3 		mov	r3, #26
 4577              	.L424:
3037:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4578              		.loc 1 3037 0
 4579 28fc 5830C4E5 		strb	r3, [r4, #88]
3038:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4580              		.loc 1 3038 0
 4581 2900 0030A0E3 		mov	r3, #0
 4582 2904 5930C4E5 		strb	r3, [r4, #89]
3039:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4583              		.loc 1 3039 0
 4584 2908 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4585 290c 30309DE5 		ldr	r3, [sp, #48]
 4586 2910 C7FEFFEA 		b	.L361
 4587              	.LVL328:
 4588              	.L360:
 4589              	.LBE110:
 4590              	.LBE133:
 4591              	.LBB134:
 4592              	.LBB118:
2723:../uvc.c      ****     switch (wValue)
 4593              		.loc 1 2723 0
 4594 2914 120C52E3 		cmp	r2, #4608
 4595 2918 DC00000A 		beq	.L354
 4596 291c 130C52E3 		cmp	r2, #4864
 4597 2920 B4FEFF1A 		bne	.L300
 4598              	.LVL329:
2798:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4599              		.loc 1 2798 0
 4600 2924 2200A0E3 		mov	r0, #34
 4601 2928 FEFFFFEB 		bl	ControlHandle
 4602              	.LVL330:
 4603 292c 30309DE5 		ldr	r3, [sp, #48]
 4604 2930 B5FEFFEA 		b	.L299
 4605              	.L333:
 4606              	.LBE118:
 4607              	.LBE134:
 4608              	.LBB135:
 4609              	.LBB95:
2498:../uvc.c      ****     switch (wValue)
 4610              		.loc 1 2498 0
 4611 2934 010B52E3 		cmp	r2, #1024
 4612 2938 0900000A 		beq	.L324
 4613 293c 050C52E3 		cmp	r2, #1280
 4614 2940 A8FEFF1A 		bne	.L320
 4615              	.LVL331:
2520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4616              		.loc 1 2520 0
 4617 2944 0400A0E3 		mov	r0, #4
 4618 2948 FEFFFFEB 		bl	CTControlHandle
 4619              	.LVL332:
 4620 294c 30309DE5 		ldr	r3, [sp, #48]
 4621 2950 ADFEFFEA 		b	.L299
 4622              	.L323:
 4623              	.LVL333:
2510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4624              		.loc 1 2510 0
 4625 2954 0200A0E3 		mov	r0, #2
 4626 2958 FEFFFFEB 		bl	CTControlHandle
 4627              	.LVL334:
 4628 295c 30309DE5 		ldr	r3, [sp, #48]
 4629 2960 A9FEFFEA 		b	.L299
 4630              	.L324:
 4631              	.LVL335:
2515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4632              		.loc 1 2515 0
 4633 2964 0300A0E3 		mov	r0, #3
 4634 2968 FEFFFFEB 		bl	CTControlHandle
 4635              	.LVL336:
 4636 296c 30309DE5 		ldr	r3, [sp, #48]
 4637 2970 A5FEFFEA 		b	.L299
 4638              	.L435:
 4639              	.LVL337:
 4640              	.LBE95:
 4641              	.LBE135:
 4642              	.LBB136:
 4643              	.LBB89:
2431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4644              		.loc 1 2431 0
 4645 2974 0100A0E3 		mov	r0, #1
 4646 2978 FEFFFFEB 		bl	ControlHandle
 4647              	.LVL338:
 4648 297c 30309DE5 		ldr	r3, [sp, #48]
 4649 2980 A1FEFFEA 		b	.L299
 4650              	.L307:
 4651              	.LVL339:
2427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4652              		.loc 1 2427 0
 4653 2984 0000A0E3 		mov	r0, #0
 4654 2988 FEFFFFEB 		bl	ControlHandle
 4655              	.LVL340:
 4656 298c 30309DE5 		ldr	r3, [sp, #48]
 4657 2990 9DFEFFEA 		b	.L299
 4658              	.LVL341:
 4659              	.L439:
 4660              	.LBE89:
 4661              	.LBE136:
3231:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4662              		.loc 1 3231 0
 4663 2994 0400A0E3 		mov	r0, #4
 4664              	.LVL342:
 4665 2998 C4139FE5 		ldr	r1, .L442+76
 4666 299c FEFFFFEB 		bl	CyU3PDebugPrint
 4667              	.LVL343:
 4668              	.L418:
 4669              	.LBB137:
 4670              	.LBB138:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4671              		.loc 1 1244 0
 4672 29a0 C0139FE5 		ldr	r1, .L442+80
 4673 29a4 0400A0E3 		mov	r0, #4
 4674 29a8 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 4675              		.loc 1 1245 0
 4676 29ac FA0FA0E3 		mov	r0, #1000
 4677 29b0 FEFFFFEB 		bl	_tx_thread_sleep
 4678 29b4 F9FFFFEA 		b	.L418
 4679              	.LVL344:
 4680              	.L402:
 4681              	.LBE138:
 4682              	.LBE137:
 4683              	.LBB139:
 4684              	.LBB105:
2975:../uvc.c      ****                 switch (bRequest)
 4685              		.loc 1 2975 0
 4686 29b8 85005BE3 		cmp	fp, #133
 4687 29bc CBFFFF0A 		beq	.L400
 4688 29c0 86005BE3 		cmp	fp, #134
 4689 29c4 95FEFF1A 		bne	.L363
 4690              	.L426:
2979:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4691              		.loc 1 2979 0
 4692 29c8 0300A0E1 		mov	r0, r3
 4693              	.L421:
2873:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4694              		.loc 1 2873 0
 4695 29cc 0330A0E3 		mov	r3, #3
2874:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4696              		.loc 1 2874 0
 4697 29d0 88139FE5 		ldr	r1, .L442+72
2873:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4698              		.loc 1 2873 0
 4699 29d4 5830C4E5 		strb	r3, [r4, #88]
2874:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4700              		.loc 1 2874 0
 4701 29d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4702 29dc 30309DE5 		ldr	r3, [sp, #48]
 4703 29e0 93FEFFEA 		b	.L361
 4704              	.L440:
2926:../uvc.c      ****                 switch (bRequest)
 4705              		.loc 1 2926 0
 4706 29e4 010052E3 		cmp	r2, #1
 4707 29e8 03FFFF1A 		bne	.L388
2951:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4708              		.loc 1 2951 0
 4709 29ec 2000A0E3 		mov	r0, #32
 4710 29f0 4C139FE5 		ldr	r1, .L442+44
 4711 29f4 36208DE2 		add	r2, sp, #54
 4712 29f8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4713              	.LVL345:
2953:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4714              		.loc 1 2953 0
 4715 29fc 000050E3 		cmp	r0, #0
 4716 2a00 8AFEFF1A 		bne	.L423
2955:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4717              		.loc 1 2955 0
 4718 2a04 48B0D5E5 		ldrb	fp, [r5, #72]	@ zero_extendqisi2
 4719 2a08 03005BE3 		cmp	fp, #3
 4720 2a0c 87FEFF1A 		bne	.L423
2964:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4721              		.loc 1 2964 0
 4722 2a10 7E30D5E5 		ldrb	r3, [r5, #126]	@ zero_extendqisi2
2959:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4723              		.loc 1 2959 0
 4724 2a14 79E0D5E5 		ldrb	lr, [r5, #121]	@ zero_extendqisi2
2960:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4725              		.loc 1 2960 0
 4726 2a18 7AC0D5E5 		ldrb	ip, [r5, #122]	@ zero_extendqisi2
2961:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4727              		.loc 1 2961 0
 4728 2a1c 7B00D5E5 		ldrb	r0, [r5, #123]	@ zero_extendqisi2
 4729              	.LVL346:
2962:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4730              		.loc 1 2962 0
 4731 2a20 7C10D5E5 		ldrb	r1, [r5, #124]	@ zero_extendqisi2
2963:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4732              		.loc 1 2963 0
 4733 2a24 7D20D5E5 		ldrb	r2, [r5, #125]	@ zero_extendqisi2
2964:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4734              		.loc 1 2964 0
 4735 2a28 5236C6E5 		strb	r3, [r6, #1618]
2959:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4736              		.loc 1 2959 0
 4737 2a2c 4DE6C6E5 		strb	lr, [r6, #1613]
2960:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4738              		.loc 1 2960 0
 4739 2a30 4EC6C6E5 		strb	ip, [r6, #1614]
2961:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4740              		.loc 1 2961 0
 4741 2a34 4F06C6E5 		strb	r0, [r6, #1615]
2962:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4742              		.loc 1 2962 0
 4743 2a38 5016C6E5 		strb	r1, [r6, #1616]
2963:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4744              		.loc 1 2963 0
 4745 2a3c 5126C6E5 		strb	r2, [r6, #1617]
2964:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4746              		.loc 1 2964 0
 4747 2a40 30309DE5 		ldr	r3, [sp, #48]
 4748 2a44 7AFEFFEA 		b	.L361
 4749              	.LVL347:
 4750              	.L393:
2926:../uvc.c      ****                 switch (bRequest)
 4751              		.loc 1 2926 0
 4752 2a48 860052E3 		cmp	r2, #134
 4753 2a4c DDFFFF0A 		beq	.L426
 4754 2a50 870052E3 		cmp	r2, #135
 4755 2a54 A3FFFF1A 		bne	.L432
 4756 2a58 63FFFFEA 		b	.L399
 4757              	.LVL348:
 4758              	.L321:
 4759              	.LBE105:
 4760              	.LBE139:
 4761              	.LBB140:
 4762              	.LBB100:
2502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4763              		.loc 1 2502 0
 4764 2a5c 0000A0E3 		mov	r0, #0
 4765 2a60 FEFFFFEB 		bl	CTControlHandle
 4766              	.LVL349:
 4767 2a64 30309DE5 		ldr	r3, [sp, #48]
 4768 2a68 67FEFFEA 		b	.L299
 4769              	.LVL350:
 4770              	.L437:
 4771              	.LBE100:
 4772              	.LBE140:
3207:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4773              		.loc 1 3207 0
 4774 2a6c 0400A0E3 		mov	r0, #4
 4775              	.LVL351:
 4776 2a70 EC129FE5 		ldr	r1, .L442+76
 4777 2a74 FEFFFFEB 		bl	CyU3PDebugPrint
 4778              	.LVL352:
 4779              	.L416:
 4780              	.LBB141:
 4781              	.LBB142:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4782              		.loc 1 1244 0
 4783 2a78 E8129FE5 		ldr	r1, .L442+80
 4784 2a7c 0400A0E3 		mov	r0, #4
 4785 2a80 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 4786              		.loc 1 1245 0
 4787 2a84 FA0FA0E3 		mov	r0, #1000
 4788 2a88 FEFFFFEB 		bl	_tx_thread_sleep
 4789 2a8c F9FFFFEA 		b	.L416
 4790              	.LVL353:
 4791              	.L384:
 4792              	.LBE142:
 4793              	.LBE141:
 4794              	.LBB143:
 4795              	.LBB111:
2870:../uvc.c      ****             switch (bRequest)
 4796              		.loc 1 2870 0
 4797 2a90 850053E3 		cmp	r3, #133
 4798 2a94 95FFFF0A 		beq	.L400
 4799 2a98 860053E3 		cmp	r3, #134
 4800 2a9c D6FEFF1A 		bne	.L388
 4801              	.L427:
2874:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4802              		.loc 1 2874 0
 4803 2aa0 0100A0E3 		mov	r0, #1
 4804 2aa4 C8FFFFEA 		b	.L421
 4805              	.LVL354:
 4806              	.L312:
 4807              	.LBE111:
 4808              	.LBE143:
 4809              	.LBB144:
 4810              	.LBB92:
2450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4811              		.loc 1 2450 0
 4812 2aa8 0600A0E3 		mov	r0, #6
 4813 2aac FEFFFFEB 		bl	ControlHandle
 4814              	.LVL355:
 4815 2ab0 30309DE5 		ldr	r3, [sp, #48]
 4816 2ab4 54FEFFEA 		b	.L299
 4817              	.L319:
2423:../uvc.c      ****     switch (wValue)
 4818              		.loc 1 2423 0
 4819 2ab8 0D0C52E3 		cmp	r2, #3328
 4820 2abc 0700000A 		beq	.L314
 4821 2ac0 0E0C52E3 		cmp	r2, #3584
 4822 2ac4 0900000A 		beq	.L316
 4823 2ac8 030B52E3 		cmp	r2, #3072
 4824 2acc 45FEFF1A 		bne	.L320
 4825              	.LVL356:
2464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4826              		.loc 1 2464 0
 4827 2ad0 0B00A0E3 		mov	r0, #11
 4828 2ad4 FEFFFFEB 		bl	ControlHandle
 4829              	.LVL357:
 4830 2ad8 30309DE5 		ldr	r3, [sp, #48]
 4831 2adc 4AFEFFEA 		b	.L299
 4832              	.L314:
 4833              	.LVL358:
2460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4834              		.loc 1 2460 0
 4835 2ae0 0900A0E3 		mov	r0, #9
 4836 2ae4 FEFFFFEB 		bl	ControlHandle
 4837              	.LVL359:
 4838 2ae8 30309DE5 		ldr	r3, [sp, #48]
 4839 2aec 46FEFFEA 		b	.L299
 4840              	.L316:
 4841              	.LVL360:
2468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4842              		.loc 1 2468 0
 4843 2af0 0E00A0E3 		mov	r0, #14
 4844 2af4 FEFFFFEB 		bl	ControlHandle
 4845              	.LVL361:
 4846 2af8 30309DE5 		ldr	r3, [sp, #48]
 4847 2afc 42FEFFEA 		b	.L299
 4848              	.L318:
2423:../uvc.c      ****     switch (wValue)
 4849              		.loc 1 2423 0
 4850 2b00 010B52E3 		cmp	r2, #1024
 4851 2b04 40FEFF0A 		beq	.L299
 4852 2b08 050C52E3 		cmp	r2, #1280
 4853 2b0c 35FEFF1A 		bne	.L320
 4854              	.LVL362:
2442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4855              		.loc 1 2442 0
 4856 2b10 0400A0E3 		mov	r0, #4
 4857 2b14 FEFFFFEB 		bl	ControlHandle
 4858              	.LVL363:
 4859 2b18 30309DE5 		ldr	r3, [sp, #48]
 4860 2b1c 3AFEFFEA 		b	.L299
 4861              	.L309:
 4862              	.LVL364:
2435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4863              		.loc 1 2435 0
 4864 2b20 0200A0E3 		mov	r0, #2
 4865 2b24 FEFFFFEB 		bl	ControlHandle
 4866              	.LVL365:
 4867 2b28 30309DE5 		ldr	r3, [sp, #48]
 4868 2b2c 36FEFFEA 		b	.L299
 4869              	.L311:
 4870              	.LVL366:
2446:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4871              		.loc 1 2446 0
 4872 2b30 0500A0E3 		mov	r0, #5
 4873 2b34 FEFFFFEB 		bl	ControlHandle
 4874              	.LVL367:
 4875 2b38 30309DE5 		ldr	r3, [sp, #48]
 4876 2b3c 32FEFFEA 		b	.L299
 4877              	.LVL368:
 4878              	.L411:
 4879              	.LBE92:
 4880              	.LBE144:
 4881              	.LBB145:
 4882              	.LBB104:
3030:../uvc.c      ****                 switch (bRequest)
 4883              		.loc 1 3030 0
 4884 2b40 850052E3 		cmp	r2, #133
 4885 2b44 4E00000A 		beq	.L409
 4886 2b48 860052E3 		cmp	r2, #134
 4887 2b4c 33FEFF1A 		bne	.L363
 4888 2b50 D2FFFFEA 		b	.L427
 4889              	.LVL369:
 4890              	.L357:
 4891              	.LBE104:
 4892              	.LBE145:
 4893              	.LBB146:
 4894              	.LBB122:
2723:../uvc.c      ****     switch (wValue)
 4895              		.loc 1 2723 0
 4896 2b54 060C52E3 		cmp	r2, #1536
 4897 2b58 4500000A 		beq	.L344
 4898 2b5c 0900008A 		bhi	.L358
 4899 2b60 050C52E3 		cmp	r2, #1280
 4900 2b64 23FEFF1A 		bne	.L300
 4901              	.LVL370:
2743:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4902              		.loc 1 2743 0
 4903 2b68 1400A0E3 		mov	r0, #20
 4904 2b6c FEFFFFEB 		bl	ControlHandle
 4905              	.LVL371:
 4906 2b70 30309DE5 		ldr	r3, [sp, #48]
 4907 2b74 24FEFFEA 		b	.L299
 4908              	.L327:
 4909              	.LVL372:
 4910              	.LBE122:
 4911              	.LBE146:
 4912              	.LBB147:
 4913              	.LBB94:
2528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 4914              		.loc 1 2528 0
 4915 2b78 0600A0E3 		mov	r0, #6
 4916 2b7c FEFFFFEB 		bl	CTControlHandle
 4917              	.LVL373:
 4918 2b80 30309DE5 		ldr	r3, [sp, #48]
 4919 2b84 20FEFFEA 		b	.L299
 4920              	.L358:
 4921              	.LBE94:
 4922              	.LBE147:
 4923              	.LBB148:
 4924              	.LBB117:
2723:../uvc.c      ****     switch (wValue)
 4925              		.loc 1 2723 0
 4926 2b88 070C52E3 		cmp	r2, #1792
 4927 2b8c 3400000A 		beq	.L345
 4928 2b90 020B52E3 		cmp	r2, #2048
 4929 2b94 17FEFF1A 		bne	.L300
 4930              	.LVL374:
2755:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 4931              		.loc 1 2755 0
 4932 2b98 1700A0E3 		mov	r0, #23
 4933 2b9c FEFFFFEB 		bl	ControlHandle
 4934              	.LVL375:
 4935 2ba0 30309DE5 		ldr	r3, [sp, #48]
 4936 2ba4 18FEFFEA 		b	.L299
 4937              	.L334:
 4938              	.LBE117:
 4939              	.LBE148:
 4940              	.LBB149:
 4941              	.LBB101:
2498:../uvc.c      ****     switch (wValue)
 4942              		.loc 1 2498 0
 4943 2ba8 0B0C52E3 		cmp	r2, #2816
 4944 2bac 0F00000A 		beq	.L330
 4945 2bb0 030B52E3 		cmp	r2, #3072
 4946 2bb4 0900000A 		beq	.L331
 4947 2bb8 0A0C52E3 		cmp	r2, #2560
 4948 2bbc 09FEFF1A 		bne	.L320
 4949              	.LVL376:
2539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 4950              		.loc 1 2539 0
 4951 2bc0 0800A0E3 		mov	r0, #8
 4952 2bc4 FEFFFFEB 		bl	CTControlHandle
 4953              	.LVL377:
 4954 2bc8 30309DE5 		ldr	r3, [sp, #48]
 4955 2bcc 0EFEFFEA 		b	.L299
 4956              	.L328:
 4957              	.LVL378:
2534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 4958              		.loc 1 2534 0
 4959 2bd0 0700A0E3 		mov	r0, #7
 4960 2bd4 FEFFFFEB 		bl	CTControlHandle
 4961              	.LVL379:
 4962 2bd8 30309DE5 		ldr	r3, [sp, #48]
 4963 2bdc 0AFEFFEA 		b	.L299
 4964              	.L331:
 4965              	.LVL380:
2547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 4966              		.loc 1 2547 0
 4967 2be0 0A00A0E3 		mov	r0, #10
 4968 2be4 FEFFFFEB 		bl	CTControlHandle
 4969              	.LVL381:
 4970 2be8 30309DE5 		ldr	r3, [sp, #48]
 4971 2bec 06FEFFEA 		b	.L299
 4972              	.L330:
 4973              	.LVL382:
2543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 4974              		.loc 1 2543 0
 4975 2bf0 0900A0E3 		mov	r0, #9
 4976 2bf4 FEFFFFEB 		bl	CTControlHandle
 4977              	.LVL383:
 4978 2bf8 30309DE5 		ldr	r3, [sp, #48]
 4979 2bfc 02FEFFEA 		b	.L299
 4980              	.L353:
 4981              	.LVL384:
 4982              	.LBE101:
 4983              	.LBE149:
 4984              	.LBB150:
 4985              	.LBB123:
2790:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 4986              		.loc 1 2790 0
 4987 2c00 2000A0E3 		mov	r0, #32
 4988 2c04 FEFFFFEB 		bl	ControlHandle
 4989              	.LVL385:
 4990 2c08 30309DE5 		ldr	r3, [sp, #48]
 4991 2c0c FEFDFFEA 		b	.L299
 4992              	.LVL386:
 4993              	.L438:
 4994              	.LBE123:
 4995              	.LBE150:
 4996              	.LBB151:
 4997              	.LBB112:
2895:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4998              		.loc 1 2895 0
 4999 2c10 2000A0E3 		mov	r0, #32
 5000 2c14 28119FE5 		ldr	r1, .L442+44
 5001 2c18 36208DE2 		add	r2, sp, #54
 5002 2c1c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5003              	.LVL387:
2897:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5004              		.loc 1 2897 0
 5005 2c20 000050E3 		cmp	r0, #0
 5006 2c24 01FEFF1A 		bne	.L423
2910:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5007              		.loc 1 2910 0
 5008 2c28 0020A0E3 		mov	r2, #0
 5009 2c2c E4009FE5 		ldr	r0, .L442
 5010              	.LVL388:
 5011 2c30 0110A0E3 		mov	r1, #1
 5012 2c34 FEFFFFEB 		bl	_txe_event_flags_set
 5013              	.LVL389:
2911:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5014              		.loc 1 2911 0
 5015 2c38 002050E2 		subs	r2, r0, #0
 5016 2c3c FBFDFF0A 		beq	.L423
 5017              	.L405:
3018:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5018              		.loc 1 3018 0
 5019 2c40 0400A0E3 		mov	r0, #4
 5020              	.LVL390:
 5021 2c44 20119FE5 		ldr	r1, .L442+84
 5022 2c48 FEFFFFEB 		bl	CyU3PDebugPrint
 5023              	.LVL391:
 5024 2c4c 30309DE5 		ldr	r3, [sp, #48]
 5025 2c50 F7FDFFEA 		b	.L361
 5026              	.L341:
 5027              	.LVL392:
 5028              	.LBE112:
 5029              	.LBE151:
 5030              	.LBB152:
 5031              	.LBB116:
2735:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5032              		.loc 1 2735 0
 5033 2c54 1200A0E3 		mov	r0, #18
 5034 2c58 FEFFFFEB 		bl	ControlHandle
 5035              	.LVL393:
 5036 2c5c 30309DE5 		ldr	r3, [sp, #48]
 5037 2c60 E9FDFFEA 		b	.L299
 5038              	.L345:
 5039              	.LVL394:
2751:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5040              		.loc 1 2751 0
 5041 2c64 1600A0E3 		mov	r0, #22
 5042 2c68 FEFFFFEB 		bl	ControlHandle
 5043              	.LVL395:
 5044 2c6c 30309DE5 		ldr	r3, [sp, #48]
 5045 2c70 E5FDFFEA 		b	.L299
 5046              	.L344:
 5047              	.LVL396:
2747:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5048              		.loc 1 2747 0
 5049 2c74 1500A0E3 		mov	r0, #21
 5050 2c78 FEFFFFEB 		bl	ControlHandle
 5051              	.LVL397:
 5052 2c7c 30309DE5 		ldr	r3, [sp, #48]
 5053 2c80 E1FDFFEA 		b	.L299
 5054              	.LVL398:
 5055              	.L409:
 5056              	.LBE116:
 5057              	.LBE152:
 5058              	.LBB153:
 5059              	.LBB103:
3039:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5060              		.loc 1 3039 0
 5061 2c84 0200A0E3 		mov	r0, #2
 5062 2c88 D0109FE5 		ldr	r1, .L442+72
 5063 2c8c 1AFFFFEA 		b	.L424
 5064              	.LVL399:
 5065              	.L354:
 5066              	.LBE103:
 5067              	.LBE153:
 5068              	.LBB154:
 5069              	.LBB124:
2794:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5070              		.loc 1 2794 0
 5071 2c90 2100A0E3 		mov	r0, #33
 5072 2c94 FEFFFFEB 		bl	ControlHandle
 5073              	.LVL400:
 5074 2c98 30309DE5 		ldr	r3, [sp, #48]
 5075 2c9c DAFDFFEA 		b	.L299
 5076              	.L350:
 5077              	.LVL401:
2774:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5078              		.loc 1 2774 0
 5079 2ca0 1C00A0E3 		mov	r0, #28
 5080 2ca4 FEFFFFEB 		bl	ControlHandle
 5081              	.LVL402:
 5082 2ca8 30309DE5 		ldr	r3, [sp, #48]
 5083 2cac D6FDFFEA 		b	.L299
 5084              	.L349:
 5085              	.LVL403:
2770:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5086              		.loc 1 2770 0
 5087 2cb0 1A00A0E3 		mov	r0, #26
 5088 2cb4 FEFFFFEB 		bl	ControlHandle
 5089              	.LVL404:
 5090 2cb8 30309DE5 		ldr	r3, [sp, #48]
 5091 2cbc D2FDFFEA 		b	.L299
 5092              	.L351:
 5093              	.LVL405:
2782:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5094              		.loc 1 2782 0
 5095 2cc0 1E00A0E3 		mov	r0, #30
 5096 2cc4 FEFFFFEB 		bl	ControlHandle
 5097              	.LVL406:
 5098 2cc8 30309DE5 		ldr	r3, [sp, #48]
 5099 2ccc CEFDFFEA 		b	.L299
 5100              	.L340:
 5101              	.LVL407:
2731:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5102              		.loc 1 2731 0
 5103 2cd0 1100A0E3 		mov	r0, #17
 5104 2cd4 FEFFFFEB 		bl	ControlHandle
 5105              	.LVL408:
 5106 2cd8 30309DE5 		ldr	r3, [sp, #48]
 5107 2cdc CAFDFFEA 		b	.L299
 5108              	.L347:
 5109              	.LVL409:
2759:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5110              		.loc 1 2759 0
 5111 2ce0 1800A0E3 		mov	r0, #24
 5112 2ce4 FEFFFFEB 		bl	ControlHandle
 5113              	.LVL410:
 5114 2ce8 30309DE5 		ldr	r3, [sp, #48]
 5115 2cec C6FDFFEA 		b	.L299
 5116              	.L342:
 5117              	.LVL411:
2739:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5118              		.loc 1 2739 0
 5119 2cf0 1300A0E3 		mov	r0, #19
 5120 2cf4 FEFFFFEB 		bl	ControlHandle
 5121              	.LVL412:
 5122 2cf8 30309DE5 		ldr	r3, [sp, #48]
 5123 2cfc C2FDFFEA 		b	.L299
 5124              	.LVL413:
 5125              	.L413:
 5126              	.LBE124:
 5127              	.LBE154:
 5128              	.LBB155:
 5129              	.LBB113:
3069:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5130              		.loc 1 3069 0
 5131 2d00 68109FE5 		ldr	r1, .L442+88
 5132 2d04 B623DDE1 		ldrh	r2, [sp, #54]
 5133 2d08 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 5134 2d0c 0400A0E3 		mov	r0, #4
 5135              	.LVL414:
 5136 2d10 FEFFFFEB 		bl	CyU3PDebugPrint
 5137 2d14 C1FDFFEA 		b	.L363
 5138              	.L443:
 5139              		.align	2
 5140              	.L442:
 5141 2d18 00000000 		.word	.LANCHOR0
 5142 2d1c 00000000 		.word	.LANCHOR1
 5143 2d20 00000000 		.word	bRequest
 5144 2d24 00000000 		.word	wValue
 5145 2d28 00000000 		.word	wIndex
 5146 2d2c 00000000 		.word	glInterStaBuffer
 5147 2d30 DC040000 		.word	.LC27
 5148 2d34 00000000 		.word	glChHandleInterStat
 5149 2d38 00000000 		.word	bmReqType
 5150 2d3c 00000000 		.word	wLength
 5151 2d40 60040000 		.word	.LC26
 5152 2d44 78000000 		.word	.LANCHOR0+120
 5153 2d48 70050000 		.word	.LC30
 5154 2d4c 08050000 		.word	.LC28
 5155 2d50 4C060000 		.word	.LANCHOR1+1612
 5156 2d54 58060000 		.word	.LANCHOR1+1624
 5157 2d58 14060000 		.word	.LANCHOR1+1556
 5158 2d5c 30060000 		.word	.LANCHOR1+1584
 5159 2d60 58000000 		.word	.LANCHOR0+88
 5160 2d64 C0050000 		.word	.LC32
 5161 2d68 D4010000 		.word	.LC12
 5162 2d6c 48050000 		.word	.LC29
 5163 2d70 98050000 		.word	.LC31
 5164              	.LBE113:
 5165              	.LBE155:
 5166              		.cfi_endproc
 5167              	.LFE24:
 5169              		.align	2
 5170              		.global	CamDefSet
 5172              	CamDefSet:
 5173              	.LFB4:
1141:../uvc.c      **** {
 5174              		.loc 1 1141 0
 5175              		.cfi_startproc
 5176              		@ args = 0, pretend = 0, frame = 24
 5177              		@ frame_needed = 0, uses_anonymous_args = 0
 5178              	.LVL415:
 5179 2d74 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5180              	.LCFI19:
 5181              		.cfi_def_cfa_offset 36
1147:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5182              		.loc 1 1147 0
 5183 2d78 AC429FE5 		ldr	r4, .L447
 5184              		.cfi_offset 14, -4
 5185              		.cfi_offset 11, -8
 5186              		.cfi_offset 10, -12
 5187              		.cfi_offset 9, -16
 5188              		.cfi_offset 8, -20
 5189              		.cfi_offset 7, -24
 5190              		.cfi_offset 6, -28
 5191              		.cfi_offset 5, -32
 5192              		.cfi_offset 4, -36
1152:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5193              		.loc 1 1152 0
 5194 2d7c AC229FE5 		ldr	r2, .L447+4
1149:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5195              		.loc 1 1149 0
 5196 2d80 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1141:../uvc.c      **** {
 5197              		.loc 1 1141 0
 5198 2d84 2CD04DE2 		sub	sp, sp, #44
 5199              	.LCFI20:
 5200              		.cfi_def_cfa_offset 80
1152:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5201              		.loc 1 1152 0
 5202 2d88 1C0092E5 		ldr	r0, [r2, #28]
 5203 2d8c 0010E0E3 		mvn	r1, #0
1154:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5204              		.loc 1 1154 0
 5205 2d90 2963A0E1 		mov	r6, r9, lsr #6
1148:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5206              		.loc 1 1148 0
 5207 2d94 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1147:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5208              		.loc 1 1147 0
 5209 2d98 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5210              	.LVL416:
1152:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5211              		.loc 1 1152 0
 5212 2d9c FEFFFFEB 		bl	_txe_mutex_get
1153:../uvc.c      ****     if(Data1&0x80){
 5213              		.loc 1 1153 0
 5214 2da0 800019E3 		tst	r9, #128
1154:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5215              		.loc 1 1154 0
 5216 2da4 01600612 		andne	r6, r6, #1
 5217 2da8 0660E011 		mvnne	r6, r6
 5218 2dac 3B600612 		andne	r6, r6, #59
 5219 2db0 0660E011 		mvnne	r6, r6
 5220 2db4 FF600612 		andne	r6, r6, #255
 5221              	.LVL417:
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5222              		.loc 1 1156 0
 5223 2db8 C6608603 		orreq	r6, r6, #198
 5224              	.LVL418:
1160:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5225              		.loc 1 1160 0
 5226 2dbc 0080A0E3 		mov	r8, #0
 5227 2dc0 0A20A0E1 		mov	r2, sl
 5228 2dc4 0730A0E1 		mov	r3, r7
 5229 2dc8 0110A0E3 		mov	r1, #1
1158:../uvc.c      ****     Data0 = (Data0 << 2);
 5230              		.loc 1 1158 0
 5231 2dcc 0951A0E1 		mov	r5, r9, asl #2
1160:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5232              		.loc 1 1160 0
 5233 2dd0 58029FE5 		ldr	r0, .L447+4
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5234              		.loc 1 1163 0
 5235 2dd4 0190A0E3 		mov	r9, #1
 5236              	.LVL419:
1158:../uvc.c      ****     Data0 = (Data0 << 2);
 5237              		.loc 1 1158 0
 5238 2dd8 FF5005E2 		and	r5, r5, #255
 5239              	.LVL420:
1160:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5240              		.loc 1 1160 0
 5241 2ddc 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5242 2de0 FEFFFFEB 		bl	cmdSet
 5243              	.LVL421:
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5244              		.loc 1 1163 0
 5245 2de4 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5246 2de8 0910A0E1 		mov	r1, r9
 5247 2dec 0730A0E1 		mov	r3, r7
 5248 2df0 38029FE5 		ldr	r0, .L447+4
 5249 2df4 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5250 2df8 FEFFFFEB 		bl	cmdSet
 5251              	.LVL422:
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5252              		.loc 1 1166 0
 5253 2dfc 0620A0E1 		mov	r2, r6
 5254 2e00 0530A0E1 		mov	r3, r5
 5255 2e04 28129FE5 		ldr	r1, .L447+8
 5256 2e08 0400A0E3 		mov	r0, #4
1165:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5257              		.loc 1 1165 0
 5258 2e0c A661C4E5 		strb	r6, [r4, #422]
1164:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5259              		.loc 1 1164 0
 5260 2e10 A551C4E5 		strb	r5, [r4, #421]
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5261              		.loc 1 1166 0
 5262 2e14 FEFFFFEB 		bl	CyU3PDebugPrint
 5263              	.LVL423:
1171:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5264              		.loc 1 1171 0
 5265 2e18 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5266              	.LVL424:
1172:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5267              		.loc 1 1172 0
 5268 2e1c B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5269 2e20 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5270 2e24 0210A0E3 		mov	r1, #2
 5271 2e28 00029FE5 		ldr	r0, .L447+4
 5272 2e2c 00B08DE5 		str	fp, [sp, #0]
 5273 2e30 04808DE5 		str	r8, [sp, #4]
 5274 2e34 FEFFFFEB 		bl	cmdSet
 5275              	.LVL425:
1174:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5276              		.loc 1 1174 0
 5277 2e38 0B20A0E1 		mov	r2, fp
 5278 2e3c 0530A0E1 		mov	r3, r5
 5279 2e40 EC119FE5 		ldr	r1, .L447+8
 5280 2e44 0400A0E3 		mov	r0, #4
1173:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5281              		.loc 1 1173 0
 5282 2e48 BD51C4E5 		strb	r5, [r4, #445]
1174:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5283              		.loc 1 1174 0
 5284 2e4c FEFFFFEB 		bl	CyU3PDebugPrint
 5285              	.LVL426:
1179:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5286              		.loc 1 1179 0
 5287 2e50 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1178:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5288              		.loc 1 1178 0
 5289 2e54 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5290              	.LVL427:
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5291              		.loc 1 1180 0
 5292 2e58 80B047E2 		sub	fp, r7, #128
 5293 2e5c FF100BE2 		and	r1, fp, #255
 5294 2e60 14108DE5 		str	r1, [sp, #20]
 5295 2e64 14C09DE5 		ldr	ip, [sp, #20]
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5296              		.loc 1 1181 0
 5297 2e68 760047E2 		sub	r0, r7, #118
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5298              		.loc 1 1182 0
 5299 2e6c 7EE087E2 		add	lr, r7, #126
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5300              		.loc 1 1180 0
 5301 2e70 0630A0E1 		mov	r3, r6
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5302              		.loc 1 1181 0
 5303 2e74 18008DE5 		str	r0, [sp, #24]
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5304              		.loc 1 1180 0
 5305 2e78 0510A0E3 		mov	r1, #5
 5306 2e7c DF20A0E3 		mov	r2, #223
 5307 2e80 A8019FE5 		ldr	r0, .L447+4
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5308              		.loc 1 1182 0
 5309 2e84 1CE08DE5 		str	lr, [sp, #28]
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5310              		.loc 1 1180 0
 5311 2e88 00C08DE5 		str	ip, [sp, #0]
 5312 2e8c 04808DE5 		str	r8, [sp, #4]
 5313 2e90 FEFFFFEB 		bl	cmdSet
 5314              	.LVL428:
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5315              		.loc 1 1181 0
 5316 2e94 18A09DE5 		ldr	sl, [sp, #24]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5317              		.loc 1 1183 0
 5318 2e98 72E087E2 		add	lr, r7, #114
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5319              		.loc 1 1181 0
 5320 2e9c FFC00AE2 		and	ip, sl, #255
 5321 2ea0 0630A0E1 		mov	r3, r6
 5322 2ea4 0510A0E3 		mov	r1, #5
 5323 2ea8 DC20A0E3 		mov	r2, #220
 5324 2eac 7C019FE5 		ldr	r0, .L447+4
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5325              		.loc 1 1183 0
 5326 2eb0 20E08DE5 		str	lr, [sp, #32]
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5327              		.loc 1 1181 0
 5328 2eb4 00C08DE5 		str	ip, [sp, #0]
 5329 2eb8 04908DE5 		str	r9, [sp, #4]
 5330 2ebc FEFFFFEB 		bl	cmdSet
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5331              		.loc 1 1182 0
 5332 2ec0 1C009DE5 		ldr	r0, [sp, #28]
 5333 2ec4 02E0A0E3 		mov	lr, #2
 5334 2ec8 FFC000E2 		and	ip, r0, #255
 5335 2ecc 0630A0E1 		mov	r3, r6
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5336              		.loc 1 1184 0
 5337 2ed0 6FA047E2 		sub	sl, r7, #111
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5338              		.loc 1 1182 0
 5339 2ed4 0510A0E3 		mov	r1, #5
 5340 2ed8 DE20A0E3 		mov	r2, #222
 5341 2edc 4C019FE5 		ldr	r0, .L447+4
 5342 2ee0 04E08DE5 		str	lr, [sp, #4]
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5343              		.loc 1 1184 0
 5344 2ee4 24A08DE5 		str	sl, [sp, #36]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5345              		.loc 1 1182 0
 5346 2ee8 00C08DE5 		str	ip, [sp, #0]
 5347 2eec FEFFFFEB 		bl	cmdSet
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5348              		.loc 1 1183 0
 5349 2ef0 20A09DE5 		ldr	sl, [sp, #32]
 5350 2ef4 0630A0E1 		mov	r3, r6
 5351 2ef8 FFC00AE2 		and	ip, sl, #255
 5352 2efc 00C08DE5 		str	ip, [sp, #0]
 5353 2f00 0510A0E3 		mov	r1, #5
 5354 2f04 03C0A0E3 		mov	ip, #3
 5355 2f08 E020A0E3 		mov	r2, #224
 5356 2f0c 1C019FE5 		ldr	r0, .L447+4
 5357 2f10 04C08DE5 		str	ip, [sp, #4]
 5358 2f14 FEFFFFEB 		bl	cmdSet
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5359              		.loc 1 1184 0
 5360 2f18 24009DE5 		ldr	r0, [sp, #36]
 5361 2f1c 04A0A0E3 		mov	sl, #4
 5362 2f20 FFC000E2 		and	ip, r0, #255
 5363 2f24 0630A0E1 		mov	r3, r6
 5364 2f28 0510A0E3 		mov	r1, #5
 5365 2f2c DD20A0E3 		mov	r2, #221
 5366 2f30 F8009FE5 		ldr	r0, .L447+4
 5367 2f34 00C08DE5 		str	ip, [sp, #0]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5368              		.loc 1 1185 0
 5369 2f38 7F7087E2 		add	r7, r7, #127
 5370              	.LVL429:
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5371              		.loc 1 1184 0
 5372 2f3c 04A08DE5 		str	sl, [sp, #4]
 5373 2f40 FEFFFFEB 		bl	cmdSet
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5374              		.loc 1 1185 0
 5375 2f44 05E0A0E3 		mov	lr, #5
 5376 2f48 0E10A0E1 		mov	r1, lr
 5377 2f4c 0630A0E1 		mov	r3, r6
 5378 2f50 E120A0E3 		mov	r2, #225
 5379 2f54 FF6007E2 		and	r6, r7, #255
 5380              	.LVL430:
 5381 2f58 D0009FE5 		ldr	r0, .L447+4
 5382 2f5c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5383 2f60 FEFFFFEB 		bl	cmdSet
 5384              	.LVL431:
1186:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5385              		.loc 1 1186 0
 5386 2f64 14C09DE5 		ldr	ip, [sp, #20]
1187:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5387              		.loc 1 1187 0
 5388 2f68 24E09DE5 		ldr	lr, [sp, #36]
 5389 2f6c 1C609DE5 		ldr	r6, [sp, #28]
1186:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5390              		.loc 1 1186 0
 5391 2f70 05C2C4E5 		strb	ip, [r4, #517]
1187:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5392              		.loc 1 1187 0
 5393 2f74 20C09DE5 		ldr	ip, [sp, #32]
 5394 2f78 0B20A0E1 		mov	r2, fp
 5395 2f7c 18309DE5 		ldr	r3, [sp, #24]
 5396 2f80 B0109FE5 		ldr	r1, .L447+12
 5397 2f84 0A00A0E1 		mov	r0, sl
 5398 2f88 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5399 2f8c 0C708DE5 		str	r7, [sp, #12]
 5400 2f90 FEFFFFEB 		bl	CyU3PDebugPrint
 5401              	.LVL432:
1191:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5402              		.loc 1 1191 0
 5403 2f94 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5404              	.LVL433:
1192:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5405              		.loc 1 1192 0
 5406 2f98 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5407              	.LVL434:
1193:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5408              		.loc 1 1193 0
 5409 2f9c 0730A0E1 		mov	r3, r7
 5410 2fa0 0610A0E3 		mov	r1, #6
 5411 2fa4 8520A0E3 		mov	r2, #133
 5412 2fa8 80009FE5 		ldr	r0, .L447+4
 5413 2fac 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5414 2fb0 FEFFFFEB 		bl	cmdSet
1194:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5415              		.loc 1 1194 0
 5416 2fb4 0730A0E1 		mov	r3, r7
 5417 2fb8 0610A0E3 		mov	r1, #6
 5418 2fbc 8620A0E3 		mov	r2, #134
 5419 2fc0 68009FE5 		ldr	r0, .L447+4
 5420 2fc4 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5421 2fc8 FEFFFFEB 		bl	cmdSet
1196:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5422              		.loc 1 1196 0
 5423 2fcc 0620A0E1 		mov	r2, r6
 5424 2fd0 0530A0E1 		mov	r3, r5
 5425 2fd4 58109FE5 		ldr	r1, .L447+8
 5426 2fd8 0A00A0E1 		mov	r0, sl
1195:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5427              		.loc 1 1195 0
 5428 2fdc 1D62C4E5 		strb	r6, [r4, #541]
1196:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5429              		.loc 1 1196 0
 5430 2fe0 FEFFFFEB 		bl	CyU3PDebugPrint
 5431              	.LVL435:
1201:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5432              		.loc 1 1201 0
 5433 2fe4 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5434              	.LVL436:
1202:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5435              		.loc 1 1202 0
 5436 2fe8 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5437 2fec 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5438 2ff0 0710A0E3 		mov	r1, #7
 5439 2ff4 34009FE5 		ldr	r0, .L447+4
 5440 2ff8 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5441 2ffc FEFFFFEB 		bl	cmdSet
 5442              	.LVL437:
1204:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5443              		.loc 1 1204 0
 5444 3000 0530A0E1 		mov	r3, r5
 5445 3004 0A00A0E1 		mov	r0, sl
 5446 3008 24109FE5 		ldr	r1, .L447+8
 5447 300c 0620A0E1 		mov	r2, r6
1203:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5448              		.loc 1 1203 0
 5449 3010 3552C4E5 		strb	r5, [r4, #565]
1204:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5450              		.loc 1 1204 0
 5451 3014 FEFFFFEB 		bl	CyU3PDebugPrint
1206:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5452              		.loc 1 1206 0
 5453 3018 10309FE5 		ldr	r3, .L447+4
 5454 301c 1C0093E5 		ldr	r0, [r3, #28]
1209:../uvc.c      **** }
 5455              		.loc 1 1209 0
 5456 3020 2CD08DE2 		add	sp, sp, #44
 5457 3024 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1206:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5458              		.loc 1 1206 0
 5459 3028 FEFFFFEA 		b	_txe_mutex_put
 5460              	.L448:
 5461              		.align	2
 5462              	.L447:
 5463 302c 00000000 		.word	.LANCHOR1
 5464 3030 00000000 		.word	cmdQu
 5465 3034 F4050000 		.word	.LC33
 5466 3038 14060000 		.word	.LC34
 5467              		.cfi_endproc
 5468              	.LFE4:
 5470              		.align	2
 5471              		.global	CyFxUVCAddHeader
 5473              	CyFxUVCAddHeader:
 5474              	.LFB5:
1217:../uvc.c      **** {
 5475              		.loc 1 1217 0
 5476              		.cfi_startproc
 5477              		@ args = 0, pretend = 0, frame = 0
 5478              		@ frame_needed = 0, uses_anonymous_args = 0
 5479              	.LVL438:
 5480 303c 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5481              	.LCFI21:
 5482              		.cfi_def_cfa_offset 16
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5483              		.loc 1 1219 0
 5484 3040 0C20A0E3 		mov	r2, #12
1217:../uvc.c      **** {
 5485              		.loc 1 1217 0
 5486 3044 0150A0E1 		mov	r5, r1
 5487              		.cfi_offset 14, -4
 5488              		.cfi_offset 5, -8
 5489              		.cfi_offset 4, -12
 5490              		.cfi_offset 3, -16
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5491              		.loc 1 1219 0
 5492 3048 18109FE5 		ldr	r1, .L451
 5493              	.LVL439:
1217:../uvc.c      **** {
 5494              		.loc 1 1217 0
 5495 304c 0040A0E1 		mov	r4, r0
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5496              		.loc 1 1219 0
 5497 3050 FEFFFFEB 		bl	CyU3PMemCopy
 5498              	.LVL440:
1222:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5499              		.loc 1 1222 0
 5500 3054 020015E3 		tst	r5, #2
1224:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5501              		.loc 1 1224 0
 5502 3058 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5503 305c 02308313 		orrne	r3, r3, #2
 5504 3060 0130C415 		strneb	r3, [r4, #1]
 5505 3064 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5506              	.L452:
 5507              		.align	2
 5508              	.L451:
 5509 3068 80040000 		.word	.LANCHOR1+1152
 5510              		.cfi_endproc
 5511              	.LFE5:
 5513              		.align	2
 5514              		.global	CyFxAppErrorHandler
 5516              	CyFxAppErrorHandler:
 5517              	.LFB6:
1234:../uvc.c      **** {
 5518              		.loc 1 1234 0
 5519              		.cfi_startproc
 5520              		@ args = 0, pretend = 0, frame = 0
 5521              		@ frame_needed = 0, uses_anonymous_args = 0
 5522              	.LVL441:
 5523 306c 08402DE9 		stmfd	sp!, {r3, lr}
 5524              	.LCFI22:
 5525              		.cfi_def_cfa_offset 8
 5526              	.LVL442:
 5527              	.L454:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5528              		.loc 1 1244 0 discriminator 1
 5529 3070 10109FE5 		ldr	r1, .L455
 5530 3074 0400A0E3 		mov	r0, #4
 5531              		.cfi_offset 14, -4
 5532              		.cfi_offset 3, -8
 5533 3078 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 5534              		.loc 1 1245 0 discriminator 1
 5535 307c FA0FA0E3 		mov	r0, #1000
 5536 3080 FEFFFFEB 		bl	_tx_thread_sleep
 5537 3084 F9FFFFEA 		b	.L454
 5538              	.L456:
 5539              		.align	2
 5540              	.L455:
 5541 3088 D4010000 		.word	.LC12
 5542              		.cfi_endproc
 5543              	.LFE6:
 5545              		.align	2
 5546              		.global	UVCAppThread_Entry
 5548              	UVCAppThread_Entry:
 5549              	.LFB18:
2189:../uvc.c      **** {
 5550              		.loc 1 2189 0
 5551              		.cfi_startproc
 5552              		@ args = 0, pretend = 0, frame = 176
 5553              		@ frame_needed = 0, uses_anonymous_args = 0
 5554              	.LVL443:
 5555 308c F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5556              	.LCFI23:
 5557              		.cfi_def_cfa_offset 28
 5558 3090 BCD04DE2 		sub	sp, sp, #188
 5559              	.LCFI24:
 5560              		.cfi_def_cfa_offset 216
 5561              	.LBB212:
 5562              	.LBB213:
1646:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5563              		.loc 1 1646 0
 5564              		.cfi_offset 14, -4
 5565              		.cfi_offset 10, -8
 5566              		.cfi_offset 8, -12
 5567              		.cfi_offset 7, -16
 5568              		.cfi_offset 6, -20
 5569              		.cfi_offset 5, -24
 5570              		.cfi_offset 4, -28
 5571 3094 FEFFFFEB 		bl	CyU3PUartInit
 5572              	.LVL444:
1647:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5573              		.loc 1 1647 0
 5574 3098 004050E2 		subs	r4, r0, #0
 5575 309c 0400000A 		beq	.L458
1649:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5576              		.loc 1 1649 0
 5577 30a0 0400A0E3 		mov	r0, #4
 5578              	.LVL445:
 5579 30a4 A41A9FE5 		ldr	r1, .L552
 5580 30a8 FEFFFFEB 		bl	CyU3PDebugPrint
1650:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5581              		.loc 1 1650 0
 5582 30ac 0400A0E1 		mov	r0, r4
 5583 30b0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5584              	.L458:
1654:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5585              		.loc 1 1654 0
 5586 30b4 98CA9FE5 		ldr	ip, .L552+4
1656:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5587              		.loc 1 1656 0
 5588 30b8 0030A0E3 		mov	r3, #0
1655:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5589              		.loc 1 1655 0
 5590 30bc 0120A0E3 		mov	r2, #1
1663:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5591              		.loc 1 1663 0
 5592 30c0 50008DE2 		add	r0, sp, #80
 5593 30c4 0310A0E1 		mov	r1, r3
1654:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5594              		.loc 1 1654 0
 5595 30c8 60C08DE5 		str	ip, [sp, #96]
1655:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5596              		.loc 1 1655 0
 5597 30cc 6420CDE5 		strb	r2, [sp, #100]
1656:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5598              		.loc 1 1656 0
 5599 30d0 6530CDE5 		strb	r3, [sp, #101]
1657:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5600              		.loc 1 1657 0
 5601 30d4 50208DE5 		str	r2, [sp, #80]
1658:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5602              		.loc 1 1658 0
 5603 30d8 54308DE5 		str	r3, [sp, #84]
1659:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5604              		.loc 1 1659 0
 5605 30dc 58308DE5 		str	r3, [sp, #88]
1660:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5606              		.loc 1 1660 0
 5607 30e0 5C208DE5 		str	r2, [sp, #92]
1663:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5608              		.loc 1 1663 0
 5609 30e4 FEFFFFEB 		bl	CyU3PUartSetConfig
 5610              	.LVL446:
1664:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5611              		.loc 1 1664 0
 5612 30e8 000050E3 		cmp	r0, #0
 5613 30ec 0000000A 		beq	.L459
1666:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5614              		.loc 1 1666 0
 5615 30f0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5616              	.LVL447:
 5617              	.L459:
1670:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5618              		.loc 1 1670 0
 5619 30f4 0000E0E3 		mvn	r0, #0
 5620 30f8 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5621              	.LVL448:
1671:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5622              		.loc 1 1671 0
 5623 30fc 000050E3 		cmp	r0, #0
 5624 3100 0000000A 		beq	.L460
1673:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5625              		.loc 1 1673 0
 5626 3104 FEFFFFEB 		bl	CyFxAppErrorHandler
 5627              	.LVL449:
 5628              	.L460:
1677:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5629              		.loc 1 1677 0
 5630 3108 0300A0E3 		mov	r0, #3
 5631 310c 0410A0E3 		mov	r1, #4
 5632 3110 FEFFFFEB 		bl	CyU3PDebugInit
 5633              	.LVL450:
1678:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5634              		.loc 1 1678 0
 5635 3114 000050E3 		cmp	r0, #0
 5636 3118 0000000A 		beq	.L461
1680:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5637              		.loc 1 1680 0
 5638 311c FEFFFFEB 		bl	CyFxAppErrorHandler
 5639              	.LVL451:
 5640              	.L461:
1684:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5641              		.loc 1 1684 0
 5642 3120 0000A0E3 		mov	r0, #0
 5643 3124 FEFFFFEB 		bl	CyU3PDebugPreamble
 5644              	.LVL452:
 5645              	.LBE213:
 5646              	.LBE212:
2204:../uvc.c      **** 		CyU3PThreadSleep(500);
 5647              		.loc 1 2204 0
 5648 3128 7D0FA0E3 		mov	r0, #500
 5649 312c FEFFFFEB 		bl	_tx_thread_sleep
 5650              	.LVL453:
 5651 3130 7D0FA0E3 		mov	r0, #500
 5652 3134 FEFFFFEB 		bl	_tx_thread_sleep
 5653 3138 7D0FA0E3 		mov	r0, #500
 5654 313c FEFFFFEB 		bl	_tx_thread_sleep
 5655 3140 7D0FA0E3 		mov	r0, #500
 5656 3144 FEFFFFEB 		bl	_tx_thread_sleep
 5657 3148 7D0FA0E3 		mov	r0, #500
 5658 314c FEFFFFEB 		bl	_tx_thread_sleep
 5659 3150 7D0FA0E3 		mov	r0, #500
 5660 3154 FEFFFFEB 		bl	_tx_thread_sleep
 5661              	.LBB214:
 5662              	.LBB215:
1695:../uvc.c      ****     status = CyU3PI2cInit ();
 5663              		.loc 1 1695 0
 5664 3158 FEFFFFEB 		bl	CyU3PI2cInit
 5665              	.LVL454:
1696:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5666              		.loc 1 1696 0
 5667 315c 002050E2 		subs	r2, r0, #0
 5668 3160 0201001A 		bne	.L527
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5669              		.loc 1 1703 0
 5670 3164 EC599FE5 		ldr	r5, .L552+8
1705:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5671              		.loc 1 1705 0
 5672 3168 0040E0E3 		mvn	r4, #0
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5673              		.loc 1 1708 0
 5674 316c 0210A0E1 		mov	r1, r2
 5675 3170 8C008DE2 		add	r0, sp, #140
 5676              	.LVL455:
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5677              		.loc 1 1703 0
 5678 3174 8C508DE5 		str	r5, [sp, #140]
1704:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5679              		.loc 1 1704 0
 5680 3178 90208DE5 		str	r2, [sp, #144]
1705:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5681              		.loc 1 1705 0
 5682 317c 94408DE5 		str	r4, [sp, #148]
1706:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5683              		.loc 1 1706 0
 5684 3180 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5685              		.loc 1 1708 0
 5686 3184 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5687              	.LVL456:
1709:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5688              		.loc 1 1709 0
 5689 3188 001050E2 		subs	r1, r0, #0
 5690 318c 0001001A 		bne	.L528
 5691              	.LBE215:
 5692              	.LBE214:
 5693              	.LBB221:
 5694              	.LBB224:
1782:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5695              		.loc 1 1782 0
 5696 3190 C4699FE5 		ldr	r6, .L552+12
 5697 3194 2820A0E3 		mov	r2, #40
 5698 3198 0600A0E1 		mov	r0, r6
 5699              	.LVL457:
 5700 319c FEFFFFEB 		bl	_txe_event_flags_create
 5701              	.LVL458:
1783:../uvc.c      ****     if (apiRetStatus != 0)
 5702              		.loc 1 1783 0
 5703 31a0 002050E2 		subs	r2, r0, #0
 5704 31a4 0301001A 		bne	.L529
1797:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5705              		.loc 1 1797 0
 5706 31a8 0280A0E3 		mov	r8, #2
1804:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5707              		.loc 1 1804 0
 5708 31ac 0210A0E1 		mov	r1, r2
 5709 31b0 9C008DE2 		add	r0, sp, #156
 5710              	.LVL459:
1800:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5711              		.loc 1 1800 0
 5712 31b4 017088E2 		add	r7, r8, #1
1793:../uvc.c      ****     isUsbConnected = CyFalse;
 5713              		.loc 1 1793 0
 5714 31b8 3C2086E5 		str	r2, [r6, #60]
1794:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5715              		.loc 1 1794 0
 5716 31bc 402086E5 		str	r2, [r6, #64]
1799:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5717              		.loc 1 1799 0
 5718 31c0 A420CDE5 		strb	r2, [sp, #164]
1801:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5719              		.loc 1 1801 0
 5720 31c4 A0208DE5 		str	r2, [sp, #160]
1797:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5721              		.loc 1 1797 0
 5722 31c8 9C80CDE5 		strb	r8, [sp, #156]
1798:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5723              		.loc 1 1798 0
 5724 31cc 9D80CDE5 		strb	r8, [sp, #157]
1800:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5725              		.loc 1 1800 0
 5726 31d0 A570CDE5 		strb	r7, [sp, #165]
1804:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5727              		.loc 1 1804 0
 5728 31d4 FEFFFFEB 		bl	CyU3PGpioInit
 5729              	.LVL460:
1805:../uvc.c      ****     if (apiRetStatus != 0)
 5730              		.loc 1 1805 0
 5731 31d8 002050E2 		subs	r2, r0, #0
 5732 31dc 7B01001A 		bne	.L530
1813:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5733              		.loc 1 1813 0
 5734 31e0 1600A0E3 		mov	r0, #22
 5735              	.LVL461:
 5736 31e4 0110A0E3 		mov	r1, #1
 5737 31e8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5738              	.LVL462:
1814:../uvc.c      ****     if (apiRetStatus != 0)
 5739              		.loc 1 1814 0
 5740 31ec 002050E2 		subs	r2, r0, #0
 5741 31f0 6D01001A 		bne	.L531
1819:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5742              		.loc 1 1819 0
 5743 31f4 1400A0E3 		mov	r0, #20
 5744              	.LVL463:
 5745 31f8 0110A0E3 		mov	r1, #1
 5746 31fc FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5747              	.LVL464:
1820:../uvc.c      ****     if (apiRetStatus != 0)
 5748              		.loc 1 1820 0
 5749 3200 002050E2 		subs	r2, r0, #0
 5750 3204 5F01001A 		bne	.L532
1825:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5751              		.loc 1 1825 0
 5752 3208 1800A0E3 		mov	r0, #24
 5753              	.LVL465:
 5754 320c 0110A0E3 		mov	r1, #1
 5755 3210 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5756              	.LVL466:
1826:../uvc.c      ****     if (apiRetStatus != 0)
 5757              		.loc 1 1826 0
 5758 3214 002050E2 		subs	r2, r0, #0
 5759 3218 5101001A 		bne	.L533
1833:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5760              		.loc 1 1833 0
 5761 321c 0140A0E3 		mov	r4, #1
1838:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5762              		.loc 1 1838 0
 5763 3220 1600A0E3 		mov	r0, #22
 5764              	.LVL467:
 5765 3224 68108DE2 		add	r1, sp, #104
1836:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5766              		.loc 1 1836 0
 5767 3228 74208DE5 		str	r2, [sp, #116]
1837:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5768              		.loc 1 1837 0
 5769 322c 7820CDE5 		strb	r2, [sp, #120]
1833:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5770              		.loc 1 1833 0
 5771 3230 68408DE5 		str	r4, [sp, #104]
1834:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5772              		.loc 1 1834 0
 5773 3234 6C408DE5 		str	r4, [sp, #108]
1835:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5774              		.loc 1 1835 0
 5775 3238 70408DE5 		str	r4, [sp, #112]
1838:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5776              		.loc 1 1838 0
 5777 323c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5778              	.LVL468:
1839:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5779              		.loc 1 1839 0
 5780 3240 002050E2 		subs	r2, r0, #0
 5781 3244 1B01001A 		bne	.L534
1852:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5782              		.loc 1 1852 0
 5783 3248 1400A0E3 		mov	r0, #20
 5784              	.LVL469:
 5785 324c 68108DE2 		add	r1, sp, #104
1850:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5786              		.loc 1 1850 0
 5787 3250 74208DE5 		str	r2, [sp, #116]
1851:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5788              		.loc 1 1851 0
 5789 3254 7820CDE5 		strb	r2, [sp, #120]
1847:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5790              		.loc 1 1847 0
 5791 3258 68408DE5 		str	r4, [sp, #104]
1848:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5792              		.loc 1 1848 0
 5793 325c 6C408DE5 		str	r4, [sp, #108]
1849:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5794              		.loc 1 1849 0
 5795 3260 70408DE5 		str	r4, [sp, #112]
1852:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5796              		.loc 1 1852 0
 5797 3264 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5798              	.LVL470:
1853:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5799              		.loc 1 1853 0
 5800 3268 002050E2 		subs	r2, r0, #0
 5801 326c 0801001A 		bne	.L535
1866:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5802              		.loc 1 1866 0
 5803 3270 1800A0E3 		mov	r0, #24
 5804              	.LVL471:
 5805 3274 68108DE2 		add	r1, sp, #104
1861:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5806              		.loc 1 1861 0
 5807 3278 68208DE5 		str	r2, [sp, #104]
1862:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5808              		.loc 1 1862 0
 5809 327c 6C208DE5 		str	r2, [sp, #108]
1863:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5810              		.loc 1 1863 0
 5811 3280 70208DE5 		str	r2, [sp, #112]
1865:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5812              		.loc 1 1865 0
 5813 3284 7820CDE5 		strb	r2, [sp, #120]
1864:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5814              		.loc 1 1864 0
 5815 3288 74408DE5 		str	r4, [sp, #116]
1866:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5816              		.loc 1 1866 0
 5817 328c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5818              	.LVL472:
1867:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5819              		.loc 1 1867 0
 5820 3290 002050E2 		subs	r2, r0, #0
 5821 3294 F500001A 		bne	.L536
1876:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5822              		.loc 1 1876 0
 5823 3298 00A0A0E3 		mov	sl, #0
1874:../uvc.c      ****     pibclock.clkDiv      = 2;
 5824              		.loc 1 1874 0
 5825 329c 0270A0E3 		mov	r7, #2	@ movhi
1875:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5826              		.loc 1 1875 0
 5827 32a0 0380A0E3 		mov	r8, #3
1879:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5828              		.loc 1 1879 0
 5829 32a4 0100A0E3 		mov	r0, #1
 5830              	.LVL473:
 5831 32a8 7C108DE2 		add	r1, sp, #124
1874:../uvc.c      ****     pibclock.clkDiv      = 2;
 5832              		.loc 1 1874 0
 5833 32ac BC77CDE1 		strh	r7, [sp, #124]	@ movhi
1875:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5834              		.loc 1 1875 0
 5835 32b0 8880CDE5 		strb	r8, [sp, #136]
1876:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5836              		.loc 1 1876 0
 5837 32b4 84A08DE5 		str	sl, [sp, #132]
1877:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5838              		.loc 1 1877 0
 5839 32b8 80A08DE5 		str	sl, [sp, #128]
1879:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5840              		.loc 1 1879 0
 5841 32bc FEFFFFEB 		bl	CyU3PPibInit
 5842              	.LVL474:
1880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5843              		.loc 1 1880 0
 5844 32c0 002050E2 		subs	r2, r0, #0
 5845 32c4 7A01001A 		bne	.L537
1887:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5846              		.loc 1 1887 0
 5847 32c8 90089FE5 		ldr	r0, .L552+16
 5848              	.LVL475:
 5849 32cc FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 5850              	.LVL476:
1895:../uvc.c      ****     SensorReset ();
 5851              		.loc 1 1895 0
 5852 32d0 FEFFFFEB 		bl	SensorReset
1896:../uvc.c      ****     SensorInit ();
 5853              		.loc 1 1896 0
 5854 32d4 FEFFFFEB 		bl	SensorInit
1899:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5855              		.loc 1 1899 0
 5856 32d8 FEFFFFEB 		bl	CyU3PUsbStart
 5857              	.LVL477:
1900:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5858              		.loc 1 1900 0
 5859 32dc 004050E2 		subs	r4, r0, #0
 5860 32e0 6901001A 		bne	.L538
1906:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 5861              		.loc 1 1906 0
 5862 32e4 0410A0E1 		mov	r1, r4
 5863 32e8 74089FE5 		ldr	r0, .L552+20
 5864              	.LVL478:
 5865 32ec FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 5866              	.LVL479:
1909:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 5867              		.loc 1 1909 0
 5868 32f0 70089FE5 		ldr	r0, .L552+24
 5869 32f4 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1915:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 5870              		.loc 1 1915 0
 5871 32f8 6C289FE5 		ldr	r2, .L552+28
 5872 32fc 0410A0E1 		mov	r1, r4
 5873 3300 0100A0E3 		mov	r0, #1
 5874 3304 FEFFFFEB 		bl	CyU3PUsbSetDesc
1916:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 5875              		.loc 1 1916 0
 5876 3308 0410A0E1 		mov	r1, r4
 5877 330c 5C289FE5 		ldr	r2, .L552+32
 5878 3310 0400A0E1 		mov	r0, r4
 5879 3314 FEFFFFEB 		bl	CyU3PUsbSetDesc
1919:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 5880              		.loc 1 1919 0
 5881 3318 0410A0E1 		mov	r1, r4
 5882 331c 50289FE5 		ldr	r2, .L552+36
 5883 3320 0200A0E3 		mov	r0, #2
 5884 3324 FEFFFFEB 		bl	CyU3PUsbSetDesc
1920:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 5885              		.loc 1 1920 0
 5886 3328 0410A0E1 		mov	r1, r4
 5887 332c 44289FE5 		ldr	r2, .L552+40
 5888 3330 0700A0E3 		mov	r0, #7
 5889 3334 FEFFFFEB 		bl	CyU3PUsbSetDesc
1923:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 5890              		.loc 1 1923 0
 5891 3338 3C289FE5 		ldr	r2, .L552+44
 5892 333c 0410A0E1 		mov	r1, r4
 5893 3340 0400A0E3 		mov	r0, #4
 5894 3344 FEFFFFEB 		bl	CyU3PUsbSetDesc
1924:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 5895              		.loc 1 1924 0
 5896 3348 0410A0E1 		mov	r1, r4
 5897 334c 2C289FE5 		ldr	r2, .L552+48
 5898 3350 0800A0E1 		mov	r0, r8
 5899 3354 FEFFFFEB 		bl	CyU3PUsbSetDesc
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5900              		.loc 1 1925 0
 5901 3358 0410A0E1 		mov	r1, r4
 5902 335c 20289FE5 		ldr	r2, .L552+52
 5903 3360 0600A0E3 		mov	r0, #6
 5904 3364 FEFFFFEB 		bl	CyU3PUsbSetDesc
1928:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 5905              		.loc 1 1928 0
 5906 3368 0410A0E1 		mov	r1, r4
 5907 336c 14289FE5 		ldr	r2, .L552+56
 5908 3370 0500A0E3 		mov	r0, #5
 5909 3374 FEFFFFEB 		bl	CyU3PUsbSetDesc
1929:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 5910              		.loc 1 1929 0
 5911 3378 0110A0E3 		mov	r1, #1
 5912 337c 08289FE5 		ldr	r2, .L552+60
 5913 3380 0500A0E3 		mov	r0, #5
 5914 3384 FEFFFFEB 		bl	CyU3PUsbSetDesc
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 5915              		.loc 1 1930 0
 5916 3388 0210A0E3 		mov	r1, #2
 5917 338c FC279FE5 		ldr	r2, .L552+64
 5918 3390 0500A0E3 		mov	r0, #5
 5919 3394 FEFFFFEB 		bl	CyU3PUsbSetDesc
1937:../uvc.c      ****     endPointConfig.enable   = 1;
 5920              		.loc 1 1937 0
 5921 3398 0150A0E3 		mov	r5, #1
1939:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5922              		.loc 1 1939 0
 5923 339c 4020A0E3 		mov	r2, #64	@ movhi
1943:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5924              		.loc 1 1943 0
 5925 33a0 8200A0E3 		mov	r0, #130
 5926 33a4 A8108DE2 		add	r1, sp, #168
1937:../uvc.c      ****     endPointConfig.enable   = 1;
 5927              		.loc 1 1937 0
 5928 33a8 A8508DE5 		str	r5, [sp, #168]
1938:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 5929              		.loc 1 1938 0
 5930 33ac AC80CDE5 		strb	r8, [sp, #172]
1939:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5931              		.loc 1 1939 0
 5932 33b0 B02BCDE1 		strh	r2, [sp, #176]	@ movhi
1940:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 5933              		.loc 1 1940 0
 5934 33b4 B340CDE5 		strb	r4, [sp, #179]
1941:../uvc.c      ****     endPointConfig.streams  = 0;
 5935              		.loc 1 1941 0
 5936 33b8 BE4ACDE1 		strh	r4, [sp, #174]	@ movhi
1942:../uvc.c      ****     endPointConfig.burstLen = 1;
 5937              		.loc 1 1942 0
 5938 33bc B250CDE5 		strb	r5, [sp, #178]
1943:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5939              		.loc 1 1943 0
 5940 33c0 FEFFFFEB 		bl	CyU3PSetEpConfig
 5941              	.LVL480:
1944:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5942              		.loc 1 1944 0
 5943 33c4 003050E2 		subs	r3, r0, #0
 5944 33c8 2501001A 		bne	.L539
1954:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5945              		.loc 1 1954 0
 5946 33cc C0C79FE5 		ldr	ip, .L552+68
1955:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5947              		.loc 1 1955 0
 5948 33d0 C0E79FE5 		ldr	lr, .L552+72
1952:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5949              		.loc 1 1952 0
 5950 33d4 018BA0E3 		mov	r8, #1024	@ movhi
1961:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5951              		.loc 1 1961 0
 5952 33d8 10A0A0E3 		mov	sl, #16
1963:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5953              		.loc 1 1963 0
 5954 33dc B8079FE5 		ldr	r0, .L552+76
 5955              	.LVL481:
 5956 33e0 0410A0E3 		mov	r1, #4
 5957 33e4 34208DE2 		add	r2, sp, #52
1952:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5958              		.loc 1 1952 0
 5959 33e8 B483CDE1 		strh	r8, [sp, #52]	@ movhi
1953:../uvc.c      ****     dmaInterConfig.count          = 1;
 5960              		.loc 1 1953 0
 5961 33ec B653CDE1 		strh	r5, [sp, #54]	@ movhi
1954:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5962              		.loc 1 1954 0
 5963 33f0 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1955:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5964              		.loc 1 1955 0
 5965 33f4 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1956:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 5966              		.loc 1 1956 0
 5967 33f8 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1957:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 5968              		.loc 1 1957 0
 5969 33fc BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1958:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 5970              		.loc 1 1958 0
 5971 3400 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1959:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 5972              		.loc 1 1959 0
 5973 3404 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1960:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 5974              		.loc 1 1960 0
 5975 3408 4440CDE5 		strb	r4, [sp, #68]
1961:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5976              		.loc 1 1961 0
 5977 340c 48A08DE5 		str	sl, [sp, #72]
1962:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 5978              		.loc 1 1962 0
 5979 3410 4C308DE5 		str	r3, [sp, #76]
1963:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5980              		.loc 1 1963 0
 5981 3414 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 5982              	.LVL482:
1965:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5983              		.loc 1 1965 0
 5984 3418 008050E2 		subs	r8, r0, #0
 5985 341c 0601001A 		bne	.L540
1972:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 5986              		.loc 1 1972 0
 5987 3420 010BA0E3 		mov	r0, #1024
 5988              	.LVL483:
 5989 3424 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 5990 3428 70179FE5 		ldr	r1, .L552+80
1973:../uvc.c      ****     if (glInterStaBuffer == 0)
 5991              		.loc 1 1973 0
 5992 342c 000050E3 		cmp	r0, #0
1972:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 5993              		.loc 1 1972 0
 5994 3430 000081E5 		str	r0, [r1, #0]
1973:../uvc.c      ****     if (glInterStaBuffer == 0)
 5995              		.loc 1 1973 0
 5996 3434 3001000A 		beq	.L541
1981:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 5997              		.loc 1 1981 0
 5998 3438 0430A0E3 		mov	r3, #4	@ movhi
 5999 343c BE30CDE1 		strh	r3, [sp, #14]	@ movhi
1985:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6000              		.loc 1 1985 0
 6001 3440 5C379FE5 		ldr	r3, .L552+84
1980:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6002              		.loc 1 1980 0
 6003 3444 01E9A0E3 		mov	lr, #16384	@ movhi
 6004 3448 BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
1984:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6005              		.loc 1 1984 0
 6006 344c 54E79FE5 		ldr	lr, .L552+88
1985:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6007              		.loc 1 1985 0
 6008 3450 BA31CDE1 		strh	r3, [sp, #26]	@ movhi
1992:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6009              		.loc 1 1992 0
 6010 3454 50379FE5 		ldr	r3, .L552+92
1983:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6011              		.loc 1 1983 0
 6012 3458 01CCA0E3 		mov	ip, #256	@ movhi
1993:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6013              		.loc 1 1993 0
 6014 345c 0C208DE2 		add	r2, sp, #12
1983:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6015              		.loc 1 1983 0
 6016 3460 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
1984:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6017              		.loc 1 1984 0
 6018 3464 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
1987:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6019              		.loc 1 1987 0
 6020 3468 0CC0A0E3 		mov	ip, #12	@ movhi
1988:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6021              		.loc 1 1988 0
 6022 346c 04E0A0E3 		mov	lr, #4	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6023              		.loc 1 1990 0
 6024 3470 2A40CDE5 		strb	r4, [sp, #42]
1993:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6025              		.loc 1 1993 0
 6026 3474 34079FE5 		ldr	r0, .L552+96
 6027 3478 0710A0E3 		mov	r1, #7
1991:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6028              		.loc 1 1991 0
 6029 347c 1840A0E3 		mov	r4, #24
1982:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6030              		.loc 1 1982 0
 6031 3480 B071CDE1 		strh	r7, [sp, #16]	@ movhi
1986:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6032              		.loc 1 1986 0
 6033 3484 B282CDE1 		strh	r8, [sp, #34]	@ movhi
1987:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6034              		.loc 1 1987 0
 6035 3488 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
1988:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6036              		.loc 1 1988 0
 6037 348c B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
1989:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6038              		.loc 1 1989 0
 6039 3490 B882CDE1 		strh	r8, [sp, #40]	@ movhi
1991:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6040              		.loc 1 1991 0
 6041 3494 2C408DE5 		str	r4, [sp, #44]
1992:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6042              		.loc 1 1992 0
 6043 3498 30308DE5 		str	r3, [sp, #48]
1993:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6044              		.loc 1 1993 0
 6045 349c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6046              	.LVL484:
1995:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6047              		.loc 1 1995 0
 6048 34a0 002050E2 		subs	r2, r0, #0
 6049 34a4 0B01001A 		bne	.L542
2086:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6050              		.loc 1 2086 0
 6051 34a8 0500A0E1 		mov	r0, r5
 6052              	.LVL485:
 6053 34ac 0510A0E1 		mov	r1, r5
 6054 34b0 FEFFFFEB 		bl	CyU3PConnectState
 6055              	.LVL486:
2087:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6056              		.loc 1 2087 0
 6057 34b4 002050E2 		subs	r2, r0, #0
 6058 34b8 6300001A 		bne	.L543
2093:../uvc.c      ****     CyU3PBusyWait(100);
 6059              		.loc 1 2093 0
 6060 34bc 6400A0E3 		mov	r0, #100
 6061              	.LVL487:
 6062 34c0 FEFFFFEB 		bl	CyU3PBusyWait
 6063              	.LVL488:
2095:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6064              		.loc 1 2095 0
 6065 34c4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2097:../uvc.c      ****     endPointConfig.enable   = 1;
 6066              		.loc 1 2097 0
 6067 34c8 A8508DE5 		str	r5, [sp, #168]
2098:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6068              		.loc 1 2098 0
 6069 34cc AC70CDE5 		strb	r7, [sp, #172]
2110:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6070              		.loc 1 2110 0
 6071 34d0 A8108DE2 		add	r1, sp, #168
2099:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6072              		.loc 1 2099 0
 6073 34d4 030050E3 		cmp	r0, #3
2095:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6074              		.loc 1 2095 0
 6075 34d8 4800C6E5 		strb	r0, [r6, #72]
2106:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6076              		.loc 1 2106 0
 6077 34dc 020CA013 		movne	r0, #512	@ movhi
2101:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6078              		.loc 1 2101 0
 6079 34e0 017BA003 		moveq	r7, #1024	@ movhi
2106:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6080              		.loc 1 2106 0
 6081 34e4 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2107:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6082              		.loc 1 2107 0
 6083 34e8 B250CD15 		strneb	r5, [sp, #178]
2110:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6084              		.loc 1 2110 0
 6085 34ec 8300A0E3 		mov	r0, #131
2109:../uvc.c      ****     endPointConfig.streams  = 0;
 6086              		.loc 1 2109 0
 6087 34f0 0050A0E3 		mov	r5, #0	@ movhi
2101:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6088              		.loc 1 2101 0
 6089 34f4 B07BCD01 		streqh	r7, [sp, #176]	@ movhi
2102:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6090              		.loc 1 2102 0
 6091 34f8 B2A0CD05 		streqb	sl, [sp, #178]
2109:../uvc.c      ****     endPointConfig.streams  = 0;
 6092              		.loc 1 2109 0
 6093 34fc BE5ACDE1 		strh	r5, [sp, #174]	@ movhi
2110:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6094              		.loc 1 2110 0
 6095 3500 FEFFFFEB 		bl	CyU3PSetEpConfig
 6096              	.LVL489:
2111:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6097              		.loc 1 2111 0
 6098 3504 002050E2 		subs	r2, r0, #0
 6099 3508 4600001A 		bne	.L524
 6100 350c A0869FE5 		ldr	r8, .L552+100
 6101              	.LBE224:
 6102              	.LBE221:
2231:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6103              		.loc 1 2231 0
 6104 3510 44569FE5 		ldr	r5, .L552+12
 6105 3514 0240A0E1 		mov	r4, r2
2302:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6106              		.loc 1 2302 0
 6107 3518 0870A0E1 		mov	r7, r8
 6108              	.LVL490:
 6109              	.L498:
2231:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6110              		.loc 1 2231 0
 6111 351c 38069FE5 		ldr	r0, .L552+12
 6112 3520 0110A0E3 		mov	r1, #1
 6113 3524 0220A0E3 		mov	r2, #2
 6114 3528 B4308DE2 		add	r3, sp, #180
 6115 352c 00408DE5 		str	r4, [sp, #0]
 6116 3530 FEFFFFEB 		bl	_txe_event_flags_get
 6117 3534 000050E3 		cmp	r0, #0
 6118 3538 2700001A 		bne	.L500
2277:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6119              		.loc 1 2277 0
 6120 353c 44A095E5 		ldr	sl, [r5, #68]
 6121 3540 00005AE3 		cmp	sl, #0
 6122 3544 0300000A 		beq	.L501
2277:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6123              		.loc 1 2277 0 is_stmt 0 discriminator 1
 6124 3548 BE22D5E1 		ldrh	r2, [r5, #46]
 6125 354c B013D5E1 		ldrh	r1, [r5, #48]
 6126 3550 010052E1 		cmp	r2, r1
 6127 3554 6000000A 		beq	.L544
 6128              	.L501:
2404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6129              		.loc 1 2404 0 is_stmt 1
 6130 3558 4010A0E3 		mov	r1, #64
 6131 355c 0020A0E3 		mov	r2, #0
 6132 3560 F4059FE5 		ldr	r0, .L552+12
 6133 3564 FEFFFFEB 		bl	_txe_event_flags_set
2407:../uvc.c      ****         CyU3PThreadRelinquish ();
 6134              		.loc 1 2407 0
 6135 3568 FEFFFFEB 		bl	_txe_thread_relinquish
2408:../uvc.c      ****     }
 6136              		.loc 1 2408 0
 6137 356c EAFFFFEA 		b	.L498
 6138              	.LVL491:
 6139              	.L527:
 6140              	.LBB259:
 6141              	.LBB220:
1698:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6142              		.loc 1 1698 0
 6143 3570 0400A0E3 		mov	r0, #4
 6144              	.LVL492:
 6145 3574 3C169FE5 		ldr	r1, .L552+104
 6146 3578 FEFFFFEB 		bl	CyU3PDebugPrint
 6147              	.LVL493:
 6148              	.L463:
 6149              	.LBB216:
 6150              	.LBB217:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6151              		.loc 1 1244 0
 6152 357c 38169FE5 		ldr	r1, .L552+108
 6153 3580 0400A0E3 		mov	r0, #4
 6154 3584 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6155              		.loc 1 1245 0
 6156 3588 FA0FA0E3 		mov	r0, #1000
 6157 358c FEFFFFEB 		bl	_tx_thread_sleep
 6158 3590 F9FFFFEA 		b	.L463
 6159              	.LVL494:
 6160              	.L528:
 6161              	.LBE217:
 6162              	.LBE216:
1711:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6163              		.loc 1 1711 0
 6164 3594 0400A0E3 		mov	r0, #4
 6165              	.LVL495:
 6166 3598 20169FE5 		ldr	r1, .L552+112
 6167              	.LVL496:
 6168 359c FEFFFFEB 		bl	CyU3PDebugPrint
 6169              	.L465:
 6170              	.LBB218:
 6171              	.LBB219:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6172              		.loc 1 1244 0
 6173 35a0 14169FE5 		ldr	r1, .L552+108
 6174 35a4 0400A0E3 		mov	r0, #4
 6175 35a8 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6176              		.loc 1 1245 0
 6177 35ac FA0FA0E3 		mov	r0, #1000
 6178 35b0 FEFFFFEB 		bl	_tx_thread_sleep
 6179 35b4 F9FFFFEA 		b	.L465
 6180              	.LVL497:
 6181              	.L529:
 6182              	.LBE219:
 6183              	.LBE218:
 6184              	.LBE220:
 6185              	.LBE259:
 6186              	.LBB260:
 6187              	.LBB223:
1785:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6188              		.loc 1 1785 0
 6189 35b8 0400A0E3 		mov	r0, #4
 6190              	.LVL498:
 6191 35bc 00169FE5 		ldr	r1, .L552+116
 6192 35c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6193              	.LVL499:
 6194              	.L467:
 6195              	.LBB233:
 6196              	.LBB234:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6197              		.loc 1 1244 0
 6198 35c4 F0159FE5 		ldr	r1, .L552+108
 6199 35c8 0400A0E3 		mov	r0, #4
 6200 35cc FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6201              		.loc 1 1245 0
 6202 35d0 FA0FA0E3 		mov	r0, #1000
 6203 35d4 FEFFFFEB 		bl	_tx_thread_sleep
 6204 35d8 F9FFFFEA 		b	.L467
 6205              	.LVL500:
 6206              	.L500:
 6207              	.LBE234:
 6208              	.LBE233:
 6209              	.LBE223:
 6210              	.LBE260:
2333:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6211              		.loc 1 2333 0
 6212 35dc 78059FE5 		ldr	r0, .L552+12
 6213 35e0 0210A0E3 		mov	r1, #2
 6214 35e4 0320A0E3 		mov	r2, #3
 6215 35e8 B4308DE2 		add	r3, sp, #180
 6216 35ec 00408DE5 		str	r4, [sp, #0]
 6217 35f0 FEFFFFEB 		bl	_txe_event_flags_get
 6218 35f4 000050E3 		cmp	r0, #0
 6219 35f8 DA00001A 		bne	.L508
2348:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6220              		.loc 1 2348 0
 6221 35fc 402095E5 		ldr	r2, [r5, #64]
2336:../uvc.c      ****                 hitFV     = CyFalse;
 6222              		.loc 1 2336 0
 6223 3600 444085E5 		str	r4, [r5, #68]
2348:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6224              		.loc 1 2348 0
 6225 3604 000052E3 		cmp	r2, #0
2337:../uvc.c      ****                 prodCount = 0;
 6226              		.loc 1 2337 0
 6227 3608 BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2344:../uvc.c      ****                 fb=0;
 6228              		.loc 1 2344 0
 6229 360c B842C5E1 		strh	r4, [r5, #40]	@ movhi
2338:../uvc.c      ****                 consCount = 0;
 6230              		.loc 1 2338 0
 6231 3610 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2345:../uvc.c      ****                 pb=0;
 6232              		.loc 1 2345 0
 6233 3614 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2346:../uvc.c      ****                 pbc=0;
 6234              		.loc 1 2346 0
 6235 3618 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2348:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6236              		.loc 1 2348 0
 6237 361c BF00000A 		beq	.L545
 6238              	.L509:
2360:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6239              		.loc 1 2360 0
 6240 3620 404086E5 		str	r4, [r6, #64]
 6241 3624 CBFFFFEA 		b	.L501
 6242              	.LVL501:
 6243              	.L524:
 6244              	.LBB261:
 6245              	.LBB257:
2114:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6246              		.loc 1 2114 0
 6247 3628 0400A0E3 		mov	r0, #4
 6248              	.LVL502:
 6249 362c 94159FE5 		ldr	r1, .L552+120
 6250 3630 FEFFFFEB 		bl	CyU3PDebugPrint
 6251              	.LVL503:
 6252              	.L499:
 6253              	.LBB235:
 6254              	.LBB236:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6255              		.loc 1 1244 0
 6256 3634 80159FE5 		ldr	r1, .L552+108
 6257 3638 0400A0E3 		mov	r0, #4
 6258 363c FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6259              		.loc 1 1245 0
 6260 3640 FA0FA0E3 		mov	r0, #1000
 6261 3644 FEFFFFEB 		bl	_tx_thread_sleep
 6262 3648 F9FFFFEA 		b	.L499
 6263              	.LVL504:
 6264              	.L543:
 6265              	.LBE236:
 6266              	.LBE235:
2089:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6267              		.loc 1 2089 0
 6268 364c 0400A0E3 		mov	r0, #4
 6269              	.LVL505:
 6270 3650 74159FE5 		ldr	r1, .L552+124
 6271 3654 FEFFFFEB 		bl	CyU3PDebugPrint
 6272              	.LVL506:
 6273              	.L495:
 6274              	.LBB237:
 6275              	.LBB238:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6276              		.loc 1 1244 0
 6277 3658 5C159FE5 		ldr	r1, .L552+108
 6278 365c 0400A0E3 		mov	r0, #4
 6279 3660 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6280              		.loc 1 1245 0
 6281 3664 FA0FA0E3 		mov	r0, #1000
 6282 3668 FEFFFFEB 		bl	_tx_thread_sleep
 6283 366c F9FFFFEA 		b	.L495
 6284              	.LVL507:
 6285              	.L536:
 6286              	.LBE238:
 6287              	.LBE237:
1869:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6288              		.loc 1 1869 0
 6289 3670 0400A0E3 		mov	r0, #4
 6290              	.LVL508:
 6291 3674 54159FE5 		ldr	r1, .L552+128
 6292 3678 FEFFFFEB 		bl	CyU3PDebugPrint
 6293              	.LVL509:
 6294              	.L481:
 6295              	.LBB239:
 6296              	.LBB240:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6297              		.loc 1 1244 0
 6298 367c 38159FE5 		ldr	r1, .L552+108
 6299 3680 0400A0E3 		mov	r0, #4
 6300 3684 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6301              		.loc 1 1245 0
 6302 3688 FA0FA0E3 		mov	r0, #1000
 6303 368c FEFFFFEB 		bl	_tx_thread_sleep
 6304 3690 F9FFFFEA 		b	.L481
 6305              	.LVL510:
 6306              	.L535:
 6307              	.LBE240:
 6308              	.LBE239:
1855:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6309              		.loc 1 1855 0
 6310 3694 0400A0E3 		mov	r0, #4
 6311              	.LVL511:
 6312 3698 34159FE5 		ldr	r1, .L552+132
 6313 369c FEFFFFEB 		bl	CyU3PDebugPrint
 6314              	.LVL512:
 6315              	.L479:
 6316              	.LBB241:
 6317              	.LBB242:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6318              		.loc 1 1244 0
 6319 36a0 14159FE5 		ldr	r1, .L552+108
 6320 36a4 0400A0E3 		mov	r0, #4
 6321 36a8 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6322              		.loc 1 1245 0
 6323 36ac FA0FA0E3 		mov	r0, #1000
 6324 36b0 FEFFFFEB 		bl	_tx_thread_sleep
 6325 36b4 F9FFFFEA 		b	.L479
 6326              	.LVL513:
 6327              	.L534:
 6328              	.LBE242:
 6329              	.LBE241:
1841:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6330              		.loc 1 1841 0
 6331 36b8 0400A0E3 		mov	r0, #4
 6332              	.LVL514:
 6333 36bc 14159FE5 		ldr	r1, .L552+136
 6334 36c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6335              	.LVL515:
 6336              	.L477:
 6337              	.LBB243:
 6338              	.LBB244:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6339              		.loc 1 1244 0
 6340 36c4 F0149FE5 		ldr	r1, .L552+108
 6341 36c8 0400A0E3 		mov	r0, #4
 6342 36cc FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6343              		.loc 1 1245 0
 6344 36d0 FA0FA0E3 		mov	r0, #1000
 6345 36d4 FEFFFFEB 		bl	_tx_thread_sleep
 6346 36d8 F9FFFFEA 		b	.L477
 6347              	.LVL516:
 6348              	.L544:
 6349              	.LBE244:
 6350              	.LBE243:
 6351              	.LBE257:
 6352              	.LBE261:
2287:../uvc.c      ****                 prodCount = 0;
 6353              		.loc 1 2287 0
 6354 36dc BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2288:../uvc.c      ****                 consCount = 0;
 6355              		.loc 1 2288 0
 6356 36e0 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2289:../uvc.c      ****                 hitFV     = CyFalse;
 6357              		.loc 1 2289 0
 6358 36e4 444085E5 		str	r4, [r5, #68]
2302:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6359              		.loc 1 2302 0
 6360 36e8 8104D8E5 		ldrb	r0, [r8, #1153]	@ zero_extendqisi2
2284:../uvc.c      ****             	fb=0;
 6361              		.loc 1 2284 0
 6362 36ec B842C5E1 		strh	r4, [r5, #40]	@ movhi
2302:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6363              		.loc 1 2302 0
 6364 36f0 01E020E2 		eor	lr, r0, #1
 6365 36f4 81E4C8E5 		strb	lr, [r8, #1153]
2303:../uvc.c      ****                 if(stiflag){
 6366              		.loc 1 2303 0
 6367 36f8 983095E5 		ldr	r3, [r5, #152]
2304:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6368              		.loc 1 2304 0
 6369 36fc 81C4D7E5 		ldrb	ip, [r7, #1153]	@ zero_extendqisi2
2303:../uvc.c      ****                 if(stiflag){
 6370              		.loc 1 2303 0
 6371 3700 000053E3 		cmp	r3, #0
2304:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6372              		.loc 1 2304 0
 6373 3704 20C08C13 		orrne	ip, ip, #32
2307:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6374              		.loc 1 2307 0
 6375 3708 DFC00C02 		andeq	ip, ip, #223
2304:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6376              		.loc 1 2304 0
 6377 370c 81C4C715 		strneb	ip, [r7, #1153]
2307:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6378              		.loc 1 2307 0
 6379 3710 81C4C705 		streqb	ip, [r7, #1153]
2305:../uvc.c      ****                 	stiflag = CyFalse;
 6380              		.loc 1 2305 0
 6381 3714 98408515 		strne	r4, [r5, #152]
2285:../uvc.c      ****             	pb=0;
 6382              		.loc 1 2285 0
 6383 3718 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2286:../uvc.c      ****             	pbc=0;
 6384              		.loc 1 2286 0
 6385 371c BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2310:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6386              		.loc 1 2310 0
 6387 3720 88049FE5 		ldr	r0, .L552+96
 6388 3724 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6389              	.LVL517:
2311:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6390              		.loc 1 2311 0
 6391 3728 002050E2 		subs	r2, r0, #0
 6392 372c 3900001A 		bne	.L546
2318:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6393              		.loc 1 2318 0
 6394 3730 0210A0E1 		mov	r1, r2
 6395 3734 74049FE5 		ldr	r0, .L552+96
 6396              	.LVL518:
 6397 3738 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6398              	.LVL519:
2319:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6399              		.loc 1 2319 0
 6400 373c 002050E2 		subs	r2, r0, #0
 6401 3740 2B00001A 		bne	.L547
2327:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6402              		.loc 1 2327 0
 6403 3744 5C049FE5 		ldr	r0, .L552+88
 6404              	.LVL520:
 6405 3748 0210A0E1 		mov	r1, r2
 6406 374c 02A0A0E3 		mov	sl, #2
 6407 3750 0020A0E1 		mov	r2, r0
 6408              	.LVL521:
 6409 3754 0130A0E1 		mov	r3, r1
 6410 3758 00A08DE5 		str	sl, [sp, #0]
 6411 375c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6412              	.LVL522:
 6413 3760 7CFFFFEA 		b	.L501
 6414              	.LVL523:
 6415              	.L533:
 6416              	.LBB262:
 6417              	.LBB222:
1828:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6418              		.loc 1 1828 0
 6419 3764 0400A0E3 		mov	r0, #4
 6420              	.LVL524:
 6421 3768 6C149FE5 		ldr	r1, .L552+140
 6422 376c FEFFFFEB 		bl	CyU3PDebugPrint
 6423              	.LVL525:
 6424              	.L475:
 6425              	.LBB231:
 6426              	.LBB232:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6427              		.loc 1 1244 0
 6428 3770 44149FE5 		ldr	r1, .L552+108
 6429 3774 0400A0E3 		mov	r0, #4
 6430 3778 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6431              		.loc 1 1245 0
 6432 377c FA0FA0E3 		mov	r0, #1000
 6433 3780 FEFFFFEB 		bl	_tx_thread_sleep
 6434 3784 F9FFFFEA 		b	.L475
 6435              	.LVL526:
 6436              	.L532:
 6437              	.LBE232:
 6438              	.LBE231:
1822:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6439              		.loc 1 1822 0
 6440 3788 0400A0E3 		mov	r0, #4
 6441              	.LVL527:
 6442 378c 4C149FE5 		ldr	r1, .L552+144
 6443 3790 FEFFFFEB 		bl	CyU3PDebugPrint
 6444              	.LVL528:
 6445              	.L473:
 6446              	.LBB229:
 6447              	.LBB230:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6448              		.loc 1 1244 0
 6449 3794 20149FE5 		ldr	r1, .L552+108
 6450 3798 0400A0E3 		mov	r0, #4
 6451 379c FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6452              		.loc 1 1245 0
 6453 37a0 FA0FA0E3 		mov	r0, #1000
 6454 37a4 FEFFFFEB 		bl	_tx_thread_sleep
 6455 37a8 F9FFFFEA 		b	.L473
 6456              	.LVL529:
 6457              	.L531:
 6458              	.LBE230:
 6459              	.LBE229:
1816:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6460              		.loc 1 1816 0
 6461 37ac 0400A0E3 		mov	r0, #4
 6462              	.LVL530:
 6463 37b0 2C149FE5 		ldr	r1, .L552+148
 6464 37b4 FEFFFFEB 		bl	CyU3PDebugPrint
 6465              	.LVL531:
 6466              	.L471:
 6467              	.LBB227:
 6468              	.LBB228:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6469              		.loc 1 1244 0
 6470 37b8 FC139FE5 		ldr	r1, .L552+108
 6471 37bc 0400A0E3 		mov	r0, #4
 6472 37c0 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6473              		.loc 1 1245 0
 6474 37c4 FA0FA0E3 		mov	r0, #1000
 6475 37c8 FEFFFFEB 		bl	_tx_thread_sleep
 6476 37cc F9FFFFEA 		b	.L471
 6477              	.LVL532:
 6478              	.L530:
 6479              	.LBE228:
 6480              	.LBE227:
1807:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6481              		.loc 1 1807 0
 6482 37d0 0400A0E3 		mov	r0, #4
 6483              	.LVL533:
 6484 37d4 0C149FE5 		ldr	r1, .L552+152
 6485 37d8 FEFFFFEB 		bl	CyU3PDebugPrint
 6486              	.LVL534:
 6487              	.L469:
 6488              	.LBB225:
 6489              	.LBB226:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6490              		.loc 1 1244 0
 6491 37dc D8139FE5 		ldr	r1, .L552+108
 6492 37e0 0400A0E3 		mov	r0, #4
 6493 37e4 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6494              		.loc 1 1245 0
 6495 37e8 FA0FA0E3 		mov	r0, #1000
 6496 37ec FEFFFFEB 		bl	_tx_thread_sleep
 6497 37f0 F9FFFFEA 		b	.L469
 6498              	.LVL535:
 6499              	.L547:
 6500              	.LBE226:
 6501              	.LBE225:
 6502              	.LBE222:
 6503              	.LBE262:
2321:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6504              		.loc 1 2321 0
 6505 37f4 0400A0E3 		mov	r0, #4
 6506              	.LVL536:
 6507 37f8 EC139FE5 		ldr	r1, .L552+156
 6508 37fc FEFFFFEB 		bl	CyU3PDebugPrint
 6509              	.LVL537:
 6510              	.L507:
 6511              	.LBB263:
 6512              	.LBB264:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6513              		.loc 1 1244 0
 6514 3800 B4139FE5 		ldr	r1, .L552+108
 6515 3804 0400A0E3 		mov	r0, #4
 6516 3808 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6517              		.loc 1 1245 0
 6518 380c FA0FA0E3 		mov	r0, #1000
 6519 3810 FEFFFFEB 		bl	_tx_thread_sleep
 6520 3814 F9FFFFEA 		b	.L507
 6521              	.LVL538:
 6522              	.L546:
 6523              	.LBE264:
 6524              	.LBE263:
2313:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6525              		.loc 1 2313 0
 6526 3818 0400A0E3 		mov	r0, #4
 6527              	.LVL539:
 6528 381c CC139FE5 		ldr	r1, .L552+160
 6529 3820 FEFFFFEB 		bl	CyU3PDebugPrint
 6530              	.LVL540:
 6531              	.L505:
 6532              	.LBB265:
 6533              	.LBB266:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6534              		.loc 1 1244 0
 6535 3824 90139FE5 		ldr	r1, .L552+108
 6536 3828 0400A0E3 		mov	r0, #4
 6537 382c FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6538              		.loc 1 1245 0
 6539 3830 FA0FA0E3 		mov	r0, #1000
 6540 3834 FEFFFFEB 		bl	_tx_thread_sleep
 6541 3838 F9FFFFEA 		b	.L505
 6542              	.LVL541:
 6543              	.L540:
 6544              	.LBE266:
 6545              	.LBE265:
 6546              	.LBB267:
 6547              	.LBB258:
1968:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6548              		.loc 1 1968 0
 6549 383c 0400A0E3 		mov	r0, #4
 6550              	.LVL542:
 6551 3840 AC139FE5 		ldr	r1, .L552+164
 6552 3844 0820A0E1 		mov	r2, r8
 6553 3848 FEFFFFEB 		bl	CyU3PDebugPrint
 6554              	.L489:
 6555              	.LBB245:
 6556              	.LBB246:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6557              		.loc 1 1244 0
 6558 384c 68139FE5 		ldr	r1, .L552+108
 6559 3850 0400A0E3 		mov	r0, #4
 6560 3854 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6561              		.loc 1 1245 0
 6562 3858 FA0FA0E3 		mov	r0, #1000
 6563 385c FEFFFFEB 		bl	_tx_thread_sleep
 6564 3860 F9FFFFEA 		b	.L489
 6565              	.LVL543:
 6566              	.L539:
 6567              	.LBE246:
 6568              	.LBE245:
1947:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6569              		.loc 1 1947 0
 6570 3864 0400A0E3 		mov	r0, #4
 6571              	.LVL544:
 6572 3868 58139FE5 		ldr	r1, .L552+120
 6573 386c 0320A0E1 		mov	r2, r3
 6574 3870 FEFFFFEB 		bl	CyU3PDebugPrint
 6575              	.LVL545:
 6576              	.L487:
 6577              	.LBB247:
 6578              	.LBB248:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6579              		.loc 1 1244 0
 6580 3874 40139FE5 		ldr	r1, .L552+108
 6581 3878 0400A0E3 		mov	r0, #4
 6582 387c FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6583              		.loc 1 1245 0
 6584 3880 FA0FA0E3 		mov	r0, #1000
 6585 3884 FEFFFFEB 		bl	_tx_thread_sleep
 6586 3888 F9FFFFEA 		b	.L487
 6587              	.LVL546:
 6588              	.L538:
 6589              	.LBE248:
 6590              	.LBE247:
1902:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6591              		.loc 1 1902 0
 6592 388c 0400A0E3 		mov	r0, #4
 6593 3890 60139FE5 		ldr	r1, .L552+168
 6594 3894 0420A0E1 		mov	r2, r4
 6595 3898 FEFFFFEB 		bl	CyU3PDebugPrint
 6596              	.L485:
 6597              	.LBB249:
 6598              	.LBB250:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6599              		.loc 1 1244 0
 6600 389c 18139FE5 		ldr	r1, .L552+108
 6601 38a0 0400A0E3 		mov	r0, #4
 6602 38a4 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6603              		.loc 1 1245 0
 6604 38a8 FA0FA0E3 		mov	r0, #1000
 6605 38ac FEFFFFEB 		bl	_tx_thread_sleep
 6606 38b0 F9FFFFEA 		b	.L485
 6607              	.LVL547:
 6608              	.L537:
 6609              	.LBE250:
 6610              	.LBE249:
1882:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6611              		.loc 1 1882 0
 6612 38b4 0400A0E3 		mov	r0, #4
 6613              	.LVL548:
 6614 38b8 3C139FE5 		ldr	r1, .L552+172
 6615 38bc FEFFFFEB 		bl	CyU3PDebugPrint
 6616              	.LVL549:
 6617              	.L483:
 6618              	.LBB251:
 6619              	.LBB252:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6620              		.loc 1 1244 0
 6621 38c0 F4129FE5 		ldr	r1, .L552+108
 6622 38c4 0400A0E3 		mov	r0, #4
 6623 38c8 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6624              		.loc 1 1245 0
 6625 38cc FA0FA0E3 		mov	r0, #1000
 6626 38d0 FEFFFFEB 		bl	_tx_thread_sleep
 6627 38d4 F9FFFFEA 		b	.L483
 6628              	.LVL550:
 6629              	.L542:
 6630              	.LBE252:
 6631              	.LBE251:
1998:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6632              		.loc 1 1998 0
 6633 38d8 0400A0E3 		mov	r0, #4
 6634              	.LVL551:
 6635 38dc 1C139FE5 		ldr	r1, .L552+176
 6636 38e0 FEFFFFEB 		bl	CyU3PDebugPrint
 6637              	.LVL552:
 6638              	.L493:
 6639              	.LBB253:
 6640              	.LBB254:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6641              		.loc 1 1244 0
 6642 38e4 D0129FE5 		ldr	r1, .L552+108
 6643 38e8 0400A0E3 		mov	r0, #4
 6644 38ec FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6645              		.loc 1 1245 0
 6646 38f0 FA0FA0E3 		mov	r0, #1000
 6647 38f4 FEFFFFEB 		bl	_tx_thread_sleep
 6648 38f8 F9FFFFEA 		b	.L493
 6649              	.LVL553:
 6650              	.L541:
 6651              	.LBE254:
 6652              	.LBE253:
1975:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6653              		.loc 1 1975 0
 6654 38fc 040080E2 		add	r0, r0, #4
 6655 3900 FC129FE5 		ldr	r1, .L552+180
 6656 3904 FEFFFFEB 		bl	CyU3PDebugPrint
 6657              	.LVL554:
 6658              	.L491:
 6659              	.LBB255:
 6660              	.LBB256:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6661              		.loc 1 1244 0
 6662 3908 AC129FE5 		ldr	r1, .L552+108
 6663 390c 0400A0E3 		mov	r0, #4
 6664 3910 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6665              		.loc 1 1245 0
 6666 3914 FA0FA0E3 		mov	r0, #1000
 6667 3918 FEFFFFEB 		bl	_tx_thread_sleep
 6668 391c F9FFFFEA 		b	.L491
 6669              	.LVL555:
 6670              	.L545:
 6671              	.LBE256:
 6672              	.LBE255:
 6673              	.LBE258:
 6674              	.LBE267:
2350:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6675              		.loc 1 2350 0
 6676 3920 88029FE5 		ldr	r0, .L552+96
 6677 3924 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6678              	.LVL556:
2351:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6679              		.loc 1 2351 0
 6680 3928 000050E3 		cmp	r0, #0
 6681 392c 0200001A 		bne	.L525
2357:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6682              		.loc 1 2357 0
 6683 3930 8300A0E3 		mov	r0, #131
 6684              	.LVL557:
 6685 3934 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6686 3938 38FFFFEA 		b	.L509
 6687              	.L525:
 6688              	.LBB268:
 6689              	.LBB269:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6690              		.loc 1 1244 0
 6691 393c 78129FE5 		ldr	r1, .L552+108
 6692 3940 0400A0E3 		mov	r0, #4
 6693 3944 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6694              		.loc 1 1245 0
 6695 3948 FA0FA0E3 		mov	r0, #1000
 6696 394c FEFFFFEB 		bl	_tx_thread_sleep
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6697              		.loc 1 1244 0
 6698 3950 64129FE5 		ldr	r1, .L552+108
 6699 3954 0400A0E3 		mov	r0, #4
 6700 3958 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6701              		.loc 1 1245 0
 6702 395c FA0FA0E3 		mov	r0, #1000
 6703 3960 FEFFFFEB 		bl	_tx_thread_sleep
 6704 3964 F4FFFFEA 		b	.L525
 6705              	.L508:
 6706              	.LBE269:
 6707              	.LBE268:
2365:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6708              		.loc 1 2365 0
 6709 3968 00C0E0E3 		mvn	ip, #0
 6710 396c 0110A0E3 		mov	r1, #1
 6711 3970 0220A0E3 		mov	r2, #2
 6712 3974 B4308DE2 		add	r3, sp, #180
 6713 3978 DC019FE5 		ldr	r0, .L552+12
 6714 397c 00C08DE5 		str	ip, [sp, #0]
 6715 3980 FEFFFFEB 		bl	_txe_event_flags_get
2369:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6716              		.loc 1 2369 0
 6717 3984 0420A0E1 		mov	r2, r4
 6718 3988 20029FE5 		ldr	r0, .L552+96
 6719 398c 0410A0E1 		mov	r1, r4
 6720 3990 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6721              	.LVL558:
2370:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6722              		.loc 1 2370 0
 6723 3994 002050E2 		subs	r2, r0, #0
 6724 3998 2F00001A 		bne	.L548
2378:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6725              		.loc 1 2378 0
 6726 399c 383095E5 		ldr	r3, [r5, #56]
 6727 39a0 000053E3 		cmp	r3, #0
 6728 39a4 5800001A 		bne	.L514
2381:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6729              		.loc 1 2381 0
 6730 39a8 3010A0E3 		mov	r1, #48
 6731 39ac 0120A0E3 		mov	r2, #1
 6732 39b0 823083E2 		add	r3, r3, #130
 6733 39b4 2100A0E3 		mov	r0, #33
 6734              	.LVL559:
 6735 39b8 FEFFFFEB 		bl	SensorSetIrisControl
2382:../uvc.c      ****                     CyU3PThreadSleep(500);
 6736              		.loc 1 2382 0
 6737 39bc 7D0FA0E3 		mov	r0, #500
 6738 39c0 FEFFFFEB 		bl	_tx_thread_sleep
2383:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6739              		.loc 1 2383 0
 6740 39c4 3010A0E3 		mov	r1, #48
 6741 39c8 0220A0E3 		mov	r2, #2
 6742 39cc 5230A0E3 		mov	r3, #82
 6743 39d0 2500A0E3 		mov	r0, #37
 6744 39d4 FEFFFFEB 		bl	SensorSetIrisControl
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
 6745              		.loc 1 2384 0
 6746 39d8 7D0FA0E3 		mov	r0, #500
 6747 39dc FEFFFFEB 		bl	_tx_thread_sleep
2385:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
 6748              		.loc 1 2385 0
 6749 39e0 3010A0E3 		mov	r1, #48
 6750 39e4 0A20A0E3 		mov	r2, #10
 6751 39e8 8230A0E3 		mov	r3, #130
 6752 39ec 2300A0E3 		mov	r0, #35
 6753 39f0 FEFFFFEB 		bl	SensorSetIrisControl
2386:../uvc.c      ****                    	CyU3PThreadSleep(300);
 6754              		.loc 1 2386 0
 6755 39f4 4B0FA0E3 		mov	r0, #300
 6756 39f8 FEFFFFEB 		bl	_tx_thread_sleep
2387:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6757              		.loc 1 2387 0
 6758 39fc 3010A0E3 		mov	r1, #48
 6759 3a00 0420A0E1 		mov	r2, r4
 6760 3a04 8230A0E3 		mov	r3, #130
 6761 3a08 2100A0E3 		mov	r0, #33
 6762 3a0c FEFFFFEB 		bl	SensorSetIrisControl
2388:../uvc.c      ****                     CyU3PThreadSleep(500);
 6763              		.loc 1 2388 0
 6764 3a10 7D0FA0E3 		mov	r0, #500
 6765 3a14 FEFFFFEB 		bl	_tx_thread_sleep
2389:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6766              		.loc 1 2389 0
 6767 3a18 5230A0E3 		mov	r3, #82
 6768 3a1c 3010A0E3 		mov	r1, #48
 6769 3a20 0420A0E1 		mov	r2, r4
 6770 3a24 2500A0E3 		mov	r0, #37
 6771 3a28 FEFFFFEB 		bl	SensorSetIrisControl
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
 6772              		.loc 1 2390 0
 6773 3a2c 7D0FA0E3 		mov	r0, #500
 6774 3a30 FEFFFFEB 		bl	_tx_thread_sleep
 6775              	.LVL560:
 6776              	.LBB270:
 6777              	.LBB272:
2139:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6778              		.loc 1 2139 0
 6779 3a34 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6780 3a38 030053E3 		cmp	r3, #3
 6781 3a3c 2B00000A 		beq	.L549
2144:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6782              		.loc 1 2144 0
 6783 3a40 020053E3 		cmp	r3, #2
 6784 3a44 0D00000A 		beq	.L550
 6785              	.LVL561:
 6786              	.L517:
 6787              	.LBE272:
 6788              	.LBE270:
2392:../uvc.c      ****                     gpif_initialized = CyTrue;
 6789              		.loc 1 2392 0
 6790 3a48 0110A0E3 		mov	r1, #1
2393:../uvc.c      ****                     CyU3PThreadSleep(200);
 6791              		.loc 1 2393 0
 6792 3a4c C800A0E3 		mov	r0, #200
2392:../uvc.c      ****                     gpif_initialized = CyTrue;
 6793              		.loc 1 2392 0
 6794 3a50 381086E5 		str	r1, [r6, #56]
2393:../uvc.c      ****                     CyU3PThreadSleep(200);
 6795              		.loc 1 2393 0
 6796 3a54 FEFFFFEB 		bl	_tx_thread_sleep
 6797 3a58 BEFEFFEA 		b	.L501
 6798              	.LVL562:
 6799              	.L548:
2373:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6800              		.loc 1 2373 0
 6801 3a5c 0400A0E3 		mov	r0, #4
 6802              	.LVL563:
 6803 3a60 A0119FE5 		ldr	r1, .L552+184
 6804 3a64 FEFFFFEB 		bl	CyU3PDebugPrint
 6805              	.LVL564:
 6806              	.L513:
 6807              	.LBB278:
 6808              	.LBB279:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6809              		.loc 1 1244 0
 6810 3a68 4C119FE5 		ldr	r1, .L552+108
 6811 3a6c 0400A0E3 		mov	r0, #4
 6812 3a70 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6813              		.loc 1 1245 0
 6814 3a74 FA0FA0E3 		mov	r0, #1000
 6815 3a78 FEFFFFEB 		bl	_tx_thread_sleep
 6816 3a7c F9FFFFEA 		b	.L513
 6817              	.LVL565:
 6818              	.L550:
 6819              	.LBE279:
 6820              	.LBE278:
 6821              	.LBB280:
 6822              	.LBB271:
2146:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6823              		.loc 1 2146 0
 6824 3a80 84119FE5 		ldr	r1, .L552+188
 6825 3a84 0100A0E3 		mov	r0, #1
 6826 3a88 FEFFFFEB 		bl	CyU3PDebugPrint
2147:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6827              		.loc 1 2147 0
 6828 3a8c 7C019FE5 		ldr	r0, .L552+192
 6829 3a90 FEFFFFEB 		bl	CyU3PGpifLoad
 6830 3a94 0020A0E1 		mov	r2, r0
 6831              	.LVL566:
 6832              	.L516:
2149:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6833              		.loc 1 2149 0
 6834 3a98 000052E3 		cmp	r2, #0
 6835 3a9c 2200001A 		bne	.L551
2157:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6836              		.loc 1 2157 0
 6837 3aa0 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6838 3aa4 030053E3 		cmp	r3, #3
 6839 3aa8 0100000A 		beq	.L526
2161:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6840              		.loc 1 2161 0
 6841 3aac 020053E3 		cmp	r3, #2
 6842 3ab0 E4FFFF1A 		bne	.L517
 6843              	.L526:
2163:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6844              		.loc 1 2163 0
 6845 3ab4 0200A0E1 		mov	r0, r2
 6846              	.LVL567:
 6847 3ab8 0210A0E1 		mov	r1, r2
 6848 3abc FEFFFFEB 		bl	CyU3PGpifSMStart
 6849              	.LVL568:
2165:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6850              		.loc 1 2165 0
 6851 3ac0 000050E3 		cmp	r0, #0
2163:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6852              		.loc 1 2163 0
 6853 3ac4 0020A0E1 		mov	r2, r0
 6854              	.LVL569:
2165:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6855              		.loc 1 2165 0
 6856 3ac8 DEFFFF0A 		beq	.L517
2168:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6857              		.loc 1 2168 0
 6858 3acc 0400A0E3 		mov	r0, #4
 6859              	.LVL570:
 6860 3ad0 3C119FE5 		ldr	r1, .L552+196
 6861 3ad4 FEFFFFEB 		bl	CyU3PDebugPrint
 6862              	.LVL571:
 6863              	.L522:
 6864              	.LBB273:
 6865              	.LBB274:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6866              		.loc 1 1244 0
 6867 3ad8 DC109FE5 		ldr	r1, .L552+108
 6868 3adc 0400A0E3 		mov	r0, #4
 6869 3ae0 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6870              		.loc 1 1245 0
 6871 3ae4 FA0FA0E3 		mov	r0, #1000
 6872 3ae8 FEFFFFEB 		bl	_tx_thread_sleep
 6873 3aec F9FFFFEA 		b	.L522
 6874              	.LVL572:
 6875              	.L549:
 6876              	.LBE274:
 6877              	.LBE273:
2141:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6878              		.loc 1 2141 0
 6879 3af0 20119FE5 		ldr	r1, .L552+200
 6880 3af4 0100A0E3 		mov	r0, #1
 6881 3af8 FEFFFFEB 		bl	CyU3PDebugPrint
2142:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6882              		.loc 1 2142 0
 6883 3afc 18019FE5 		ldr	r0, .L552+204
 6884 3b00 FEFFFFEB 		bl	CyU3PGpifLoad
 6885 3b04 0020A0E1 		mov	r2, r0
 6886              	.LVL573:
 6887 3b08 E2FFFFEA 		b	.L516
 6888              	.LVL574:
 6889              	.L514:
 6890              	.LBE271:
 6891              	.LBE280:
2400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6892              		.loc 1 2400 0
 6893 3b0c 94009FE5 		ldr	r0, .L552+88
 6894              	.LVL575:
 6895 3b10 02E0A0E3 		mov	lr, #2
 6896 3b14 0410A0E1 		mov	r1, r4
 6897 3b18 0020A0E1 		mov	r2, r0
 6898              	.LVL576:
 6899 3b1c 0430A0E1 		mov	r3, r4
 6900 3b20 00E08DE5 		str	lr, [sp, #0]
 6901 3b24 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6902 3b28 8AFEFFEA 		b	.L501
 6903              	.LVL577:
 6904              	.L551:
 6905              	.LBB281:
 6906              	.LBB277:
2152:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6907              		.loc 1 2152 0
 6908 3b2c 0400A0E3 		mov	r0, #4
 6909              	.LVL578:
 6910 3b30 E8109FE5 		ldr	r1, .L552+208
 6911 3b34 FEFFFFEB 		bl	CyU3PDebugPrint
 6912              	.LVL579:
 6913              	.L519:
 6914              	.LBB275:
 6915              	.LBB276:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6916              		.loc 1 1244 0
 6917 3b38 7C109FE5 		ldr	r1, .L552+108
 6918 3b3c 0400A0E3 		mov	r0, #4
 6919 3b40 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6920              		.loc 1 1245 0
 6921 3b44 FA0FA0E3 		mov	r0, #1000
 6922 3b48 FEFFFFEB 		bl	_tx_thread_sleep
 6923 3b4c F9FFFFEA 		b	.L519
 6924              	.L553:
 6925              		.align	2
 6926              	.L552:
 6927 3b50 4C060000 		.word	.LC35
 6928 3b54 00C20100 		.word	115200
 6929 3b58 A0860100 		.word	100000
 6930 3b5c 00000000 		.word	.LANCHOR0
 6931 3b60 00000000 		.word	CyFxGpifCB
 6932 3b64 00000000 		.word	CyFxUVCApplnUSBSetupCB
 6933 3b68 00000000 		.word	CyFxUVCApplnUSBEventCB
 6934 3b6c 00000000 		.word	CyFxUSBDeviceDscr
 6935 3b70 00000000 		.word	CyFxUSBDeviceDscrSS
 6936 3b74 00000000 		.word	CyFxUSBDeviceQualDscr
 6937 3b78 00000000 		.word	CyFxUSBBOSDscr
 6938 3b7c 00000000 		.word	CyFxUSBHSConfigDscr
 6939 3b80 00000000 		.word	CyFxUSBFSConfigDscr
 6940 3b84 00000000 		.word	CyFxUSBSSConfigDscr
 6941 3b88 00000000 		.word	CyFxUSBStringLangIDDscr
 6942 3b8c 00000000 		.word	CyFxUSBManufactureDscr
 6943 3b90 00000000 		.word	CyFxUSBProductDscr
 6944 3b94 013F0000 		.word	16129
 6945 3b98 02030000 		.word	770
 6946 3b9c 00000000 		.word	glChHandleInterStat
 6947 3ba0 00000000 		.word	glInterStaBuffer
 6948 3ba4 03030000 		.word	771
 6949 3ba8 01010000 		.word	257
 6950 3bac 00000000 		.word	CyFxUvcApplnDmaCallback
 6951 3bb0 00000000 		.word	glChHandleUVCStream
 6952 3bb4 00000000 		.word	.LANCHOR1
 6953 3bb8 6C060000 		.word	.LC36
 6954 3bbc D4010000 		.word	.LC12
 6955 3bc0 88060000 		.word	.LC37
 6956 3bc4 A4060000 		.word	.LC38
 6957 3bc8 74080000 		.word	.LC48
 6958 3bcc 50090000 		.word	.LC52
 6959 3bd0 DC070000 		.word	.LC45
 6960 3bd4 A8070000 		.word	.LC44
 6961 3bd8 74070000 		.word	.LC43
 6962 3bdc 48070000 		.word	.LC42
 6963 3be0 1C070000 		.word	.LC41
 6964 3be4 F4060000 		.word	.LC40
 6965 3be8 D0060000 		.word	.LC39
 6966 3bec A4090000 		.word	.LC54
 6967 3bf0 78090000 		.word	.LC53
 6968 3bf4 A8080000 		.word	.LC49
 6969 3bf8 44080000 		.word	.LC47
 6970 3bfc 14080000 		.word	.LC46
 6971 3c00 20090000 		.word	.LC51
 6972 3c04 E8080000 		.word	.LC50
 6973 3c08 D8090000 		.word	.LC55
 6974 3c0c 1C0A0000 		.word	.LC57
 6975 3c10 2C000000 		.word	.LANCHOR2+44
 6976 3c14 640A0000 		.word	.LC59
 6977 3c18 0C0A0000 		.word	.LC56
 6978 3c1c 10000000 		.word	.LANCHOR2+16
 6979 3c20 2C0A0000 		.word	.LC58
 6980              	.LBE276:
 6981              	.LBE275:
 6982              	.LBE277:
 6983              	.LBE281:
 6984              		.cfi_endproc
 6985              	.LFE18:
 6987              		.align	2
 6988              		.global	CyFxUVCApplnI2CInit
 6990              	CyFxUVCApplnI2CInit:
 6991              	.LFB14:
1691:../uvc.c      **** {
 6992              		.loc 1 1691 0
 6993              		.cfi_startproc
 6994              		@ args = 0, pretend = 0, frame = 16
 6995              		@ frame_needed = 0, uses_anonymous_args = 0
 6996 3c24 04E02DE5 		str	lr, [sp, #-4]!
 6997              	.LCFI25:
 6998              		.cfi_def_cfa_offset 4
 6999 3c28 14D04DE2 		sub	sp, sp, #20
 7000              	.LCFI26:
 7001              		.cfi_def_cfa_offset 24
1695:../uvc.c      ****     status = CyU3PI2cInit ();
 7002              		.loc 1 1695 0
 7003              		.cfi_offset 14, -4
 7004 3c2c FEFFFFEB 		bl	CyU3PI2cInit
 7005              	.LVL580:
1696:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7006              		.loc 1 1696 0
 7007 3c30 002050E2 		subs	r2, r0, #0
 7008 3c34 0B00001A 		bne	.L559
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7009              		.loc 1 1703 0
 7010 3c38 70C09FE5 		ldr	ip, .L561
1705:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7011              		.loc 1 1705 0
 7012 3c3c 0030E0E3 		mvn	r3, #0
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7013              		.loc 1 1708 0
 7014 3c40 0D00A0E1 		mov	r0, sp
 7015              	.LVL581:
 7016 3c44 0210A0E1 		mov	r1, r2
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7017              		.loc 1 1703 0
 7018 3c48 00C08DE5 		str	ip, [sp, #0]
1704:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7019              		.loc 1 1704 0
 7020 3c4c 0C008DE9 		stmib	sp, {r2, r3}	@ phole stm
1706:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7021              		.loc 1 1706 0
 7022 3c50 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7023              		.loc 1 1708 0
 7024 3c54 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7025              	.LVL582:
1709:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7026              		.loc 1 1709 0
 7027 3c58 000050E3 		cmp	r0, #0
 7028 3c5c 0A00001A 		bne	.L560
1714:../uvc.c      **** }
 7029              		.loc 1 1714 0
 7030 3c60 14D08DE2 		add	sp, sp, #20
 7031 3c64 04F09DE4 		ldmfd	sp!, {pc}
 7032              	.L559:
1698:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7033              		.loc 1 1698 0
 7034 3c68 0400A0E3 		mov	r0, #4
 7035              	.LVL583:
 7036 3c6c 40109FE5 		ldr	r1, .L561+4
 7037 3c70 FEFFFFEB 		bl	CyU3PDebugPrint
 7038              	.LVL584:
 7039              	.L556:
 7040              	.LBB286:
 7041              	.LBB287:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7042              		.loc 1 1244 0
 7043 3c74 3C109FE5 		ldr	r1, .L561+8
 7044 3c78 0400A0E3 		mov	r0, #4
 7045 3c7c FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 7046              		.loc 1 1245 0
 7047 3c80 FA0FA0E3 		mov	r0, #1000
 7048 3c84 FEFFFFEB 		bl	_tx_thread_sleep
 7049 3c88 F9FFFFEA 		b	.L556
 7050              	.LVL585:
 7051              	.L560:
 7052              	.LBE287:
 7053              	.LBE286:
1711:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7054              		.loc 1 1711 0
 7055 3c8c 0400A0E3 		mov	r0, #4
 7056              	.LVL586:
 7057 3c90 24109FE5 		ldr	r1, .L561+12
 7058 3c94 FEFFFFEB 		bl	CyU3PDebugPrint
 7059              	.L558:
 7060              	.LBB288:
 7061              	.LBB289:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7062              		.loc 1 1244 0
 7063 3c98 18109FE5 		ldr	r1, .L561+8
 7064 3c9c 0400A0E3 		mov	r0, #4
 7065 3ca0 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 7066              		.loc 1 1245 0
 7067 3ca4 FA0FA0E3 		mov	r0, #1000
 7068 3ca8 FEFFFFEB 		bl	_tx_thread_sleep
 7069 3cac F9FFFFEA 		b	.L558
 7070              	.L562:
 7071              		.align	2
 7072              	.L561:
 7073 3cb0 A0860100 		.word	100000
 7074 3cb4 6C060000 		.word	.LC36
 7075 3cb8 D4010000 		.word	.LC12
 7076 3cbc 88060000 		.word	.LC37
 7077              	.LBE289:
 7078              	.LBE288:
 7079              		.cfi_endproc
 7080              	.LFE14:
 7082              		.align	2
 7083              		.global	CyFxApplicationDefine
 7085              	CyFxApplicationDefine:
 7086              	.LFB26:
3627:../uvc.c      **** }
3628:../uvc.c      **** 
3629:../uvc.c      **** 
3630:../uvc.c      **** /*
3631:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3632:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3633:../uvc.c      ****  */
3634:../uvc.c      **** void
3635:../uvc.c      **** CyFxApplicationDefine (
3636:../uvc.c      ****         void)
3637:../uvc.c      **** {
 7087              		.loc 1 3637 0
 7088              		.cfi_startproc
 7089              		@ args = 0, pretend = 0, frame = 40
 7090              		@ frame_needed = 0, uses_anonymous_args = 0
 7091              	.LVL587:
 7092 3cc0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7093              	.LCFI27:
 7094              		.cfi_def_cfa_offset 36
3638:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3639:../uvc.c      ****     uint32_t retThrdCreate;
3640:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3641:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3642:../uvc.c      **** 
3643:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3644:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7095              		.loc 1 3644 0
 7096 3cc4 010AA0E3 		mov	r0, #4096
3637:../uvc.c      **** {
 7097              		.loc 1 3637 0
 7098 3cc8 4CD04DE2 		sub	sp, sp, #76
 7099              	.LCFI28:
 7100              		.cfi_def_cfa_offset 112
 7101              		.loc 1 3644 0
 7102              		.cfi_offset 14, -4
 7103              		.cfi_offset 11, -8
 7104              		.cfi_offset 10, -12
 7105              		.cfi_offset 9, -16
 7106              		.cfi_offset 8, -20
 7107              		.cfi_offset 7, -24
 7108              		.cfi_offset 6, -28
 7109              		.cfi_offset 5, -32
 7110              		.cfi_offset 4, -36
 7111 3ccc FEFFFFEB 		bl	CyU3PMemAlloc
 7112 3cd0 00A0A0E1 		mov	sl, r0
 7113              	.LVL588:
3645:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7114              		.loc 1 3645 0
 7115 3cd4 010AA0E3 		mov	r0, #4096
 7116              	.LVL589:
 7117 3cd8 FEFFFFEB 		bl	CyU3PMemAlloc
 7118 3cdc 00B0A0E1 		mov	fp, r0
 7119              	.LVL590:
3646:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7120              		.loc 1 3646 0
 7121 3ce0 010AA0E3 		mov	r0, #4096
 7122              	.LVL591:
 7123 3ce4 FEFFFFEB 		bl	CyU3PMemAlloc
3647:../uvc.c      **** 
3648:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7124              		.loc 1 3648 0
 7125 3ce8 00005AE3 		cmp	sl, #0
 7126 3cec 00005B13 		cmpne	fp, #0
 7127 3cf0 0090A013 		movne	r9, #0
 7128 3cf4 0190A003 		moveq	r9, #1
3646:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7129              		.loc 1 3646 0
 7130 3cf8 24008DE5 		str	r0, [sp, #36]
 7131              	.LVL592:
 7132              		.loc 1 3648 0
 7133 3cfc 0000001A 		bne	.L567
 7134              	.LVL593:
 7135              	.L564:
 7136              	.L566:
 7137 3d00 FEFFFFEA 		b	.L566
 7138              	.L567:
 7139              		.loc 1 3648 0 is_stmt 0 discriminator 1
 7140 3d04 000050E3 		cmp	r0, #0
 7141 3d08 FCFFFF0A 		beq	.L564
3649:../uvc.c      ****         goto fatalErrorHandler;
3650:../uvc.c      **** 
3651:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3652:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7142              		.loc 1 3652 0 is_stmt 1
 7143 3d0c 28408DE2 		add	r4, sp, #40
 7144 3d10 0400A0E1 		mov	r0, r4
 7145 3d14 4010A0E3 		mov	r1, #64
 7146 3d18 18219FE5 		ldr	r2, .L568
 7147 3d1c FEFFFFEB 		bl	cmdbufCreate
 7148 3d20 0450A0E1 		mov	r5, r4
 7149 3d24 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7150 3d28 0C719FE5 		ldr	r7, .L568+4
3653:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7151              		.loc 1 3653 0
 7152 3d2c 0C819FE5 		ldr	r8, .L568+8
3652:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7153              		.loc 1 3652 0
 7154 3d30 07C0A0E1 		mov	ip, r7
 7155 3d34 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7156 3d38 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3654:../uvc.c      **** 
3655:../uvc.c      **** 	/****** initialize command descriptor ***********/
3656:../uvc.c      **** 	cmdquInit(cmdQuptr);
3657:../uvc.c      **** 	cmdquInit(statQuptr);
3658:../uvc.c      **** 
3659:../uvc.c      ****     /* Create the UVC application thread. */
3660:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7157              		.loc 1 3660 0
 7158 3d3c 0860A0E3 		mov	r6, #8
3652:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7159              		.loc 1 3652 0
 7160 3d40 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3653:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7161              		.loc 1 3653 0
 7162 3d44 F8209FE5 		ldr	r2, .L568+12
 7163 3d48 0400A0E1 		mov	r0, r4
 7164 3d4c 2010A0E3 		mov	r1, #32
 7165 3d50 FEFFFFEB 		bl	cmdbufCreate
 7166 3d54 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7167 3d58 08C0A0E1 		mov	ip, r8
 7168 3d5c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7169 3d60 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7170              		.loc 1 3660 0
 7171 3d64 0140A0E3 		mov	r4, #1
3653:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7172              		.loc 1 3653 0
 7173 3d68 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3656:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7174              		.loc 1 3656 0
 7175 3d6c 0700A0E1 		mov	r0, r7
 7176 3d70 FEFFFFEB 		bl	cmdquInit
3657:../uvc.c      **** 	cmdquInit(statQuptr);
 7177              		.loc 1 3657 0
 7178 3d74 0800A0E1 		mov	r0, r8
 7179 3d78 FEFFFFEB 		bl	cmdquInit
 7180              		.loc 1 3660 0
 7181 3d7c A850A0E3 		mov	r5, #168
 7182 3d80 01CAA0E3 		mov	ip, #4096
 7183 3d84 BC009FE5 		ldr	r0, .L568+16
 7184 3d88 BC109FE5 		ldr	r1, .L568+20
 7185 3d8c BC209FE5 		ldr	r2, .L568+24
 7186 3d90 0930A0E1 		mov	r3, r9
 7187 3d94 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7188 3d98 08608DE5 		str	r6, [sp, #8]
 7189 3d9c 0C608DE5 		str	r6, [sp, #12]
 7190 3da0 10908DE5 		str	r9, [sp, #16]
 7191 3da4 14408DE5 		str	r4, [sp, #20]
 7192 3da8 18508DE5 		str	r5, [sp, #24]
 7193 3dac FEFFFFEB 		bl	_txe_thread_create
 7194              	.LVL594:
3661:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3662:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3663:../uvc.c      ****             0,                                          /* No input parameter to thread */
3664:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3665:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3666:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3667:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3668:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3669:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3670:../uvc.c      ****             );
3671:../uvc.c      ****     if (retThrdCreate != 0)
 7195              		.loc 1 3671 0
 7196 3db0 00C050E2 		subs	ip, r0, #0
 7197 3db4 D1FFFF1A 		bne	.L564
3672:../uvc.c      ****     {
3673:../uvc.c      ****         goto fatalErrorHandler;
3674:../uvc.c      ****     }
3675:../uvc.c      **** 
3676:../uvc.c      ****     /* Create the control request handling thread. */
3677:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7198              		.loc 1 3677 0
 7199 3db8 0C30A0E1 		mov	r3, ip
 7200 3dbc 027BA0E3 		mov	r7, #2048
 7201 3dc0 8C009FE5 		ldr	r0, .L568+28
 7202              	.LVL595:
 7203 3dc4 8C109FE5 		ldr	r1, .L568+32
 7204 3dc8 8C209FE5 		ldr	r2, .L568+36
 7205 3dcc 10C08DE5 		str	ip, [sp, #16]
 7206 3dd0 00B08DE5 		str	fp, [sp, #0]
 7207 3dd4 04708DE5 		str	r7, [sp, #4]
 7208 3dd8 08608DE5 		str	r6, [sp, #8]
 7209 3ddc 0C608DE5 		str	r6, [sp, #12]
 7210 3de0 14408DE5 		str	r4, [sp, #20]
 7211 3de4 18508DE5 		str	r5, [sp, #24]
 7212 3de8 FEFFFFEB 		bl	_txe_thread_create
 7213              	.LVL596:
3678:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3679:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3680:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3681:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3682:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3683:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3684:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3685:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3686:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3687:../uvc.c      ****             );
3688:../uvc.c      ****     if (retThrdCreate != 0)
 7214              		.loc 1 3688 0
 7215 3dec 00C050E2 		subs	ip, r0, #0
 7216 3df0 C2FFFF1A 		bne	.L564
3689:../uvc.c      ****     {
3690:../uvc.c      ****         goto fatalErrorHandler;
3691:../uvc.c      ****     }
3692:../uvc.c      **** #if 1
3693:../uvc.c      ****     /* Create the I2C control command handling thread. */
3694:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7217              		.loc 1 3694 0
 7218 3df4 24E09DE5 		ldr	lr, [sp, #36]
 7219 3df8 60009FE5 		ldr	r0, .L568+40
 7220              	.LVL597:
 7221 3dfc 60109FE5 		ldr	r1, .L568+44
 7222 3e00 60209FE5 		ldr	r2, .L568+48
 7223 3e04 0C30A0E1 		mov	r3, ip
 7224 3e08 00E08DE5 		str	lr, [sp, #0]
 7225 3e0c 04708DE5 		str	r7, [sp, #4]
 7226 3e10 08608DE5 		str	r6, [sp, #8]
 7227 3e14 0C608DE5 		str	r6, [sp, #12]
 7228 3e18 10C08DE5 		str	ip, [sp, #16]
 7229 3e1c 14408DE5 		str	r4, [sp, #20]
 7230 3e20 18508DE5 		str	r5, [sp, #24]
 7231 3e24 FEFFFFEB 		bl	_txe_thread_create
 7232              	.LVL598:
3695:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3696:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3697:../uvc.c      ****             0,                                          /* No input parameter to thread */
3698:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3699:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3700:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3701:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3702:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3703:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3704:../uvc.c      ****             );
3705:../uvc.c      ****     if (retThrdCreate != 0)
 7233              		.loc 1 3705 0
 7234 3e28 000050E3 		cmp	r0, #0
 7235 3e2c B3FFFF1A 		bne	.L564
3706:../uvc.c      ****     {
3707:../uvc.c      ****         goto fatalErrorHandler;
3708:../uvc.c      ****     }
3709:../uvc.c      **** #endif
3710:../uvc.c      **** 
3711:../uvc.c      ****     return;
3712:../uvc.c      **** 
3713:../uvc.c      **** fatalErrorHandler:
3714:../uvc.c      ****     /* Add custom recovery or debug actions here */
3715:../uvc.c      ****     /* Loop indefinitely */
3716:../uvc.c      ****     while (1);
3717:../uvc.c      **** }
 7236              		.loc 1 3717 0
 7237 3e30 4CD08DE2 		add	sp, sp, #76
 7238 3e34 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7239              	.L569:
 7240              		.align	2
 7241              	.L568:
 7242 3e38 00000000 		.word	cmdQuMux
 7243 3e3c 00000000 		.word	cmdQu
 7244 3e40 00000000 		.word	statQu
 7245 3e44 00000000 		.word	staQuMux
 7246 3e48 9C000000 		.word	.LANCHOR0+156
 7247 3e4c 9C0A0000 		.word	.LC60
 7248 3e50 00000000 		.word	UVCAppThread_Entry
 7249 3e54 44010000 		.word	.LANCHOR0+324
 7250 3e58 B00A0000 		.word	.LC61
 7251 3e5c 00000000 		.word	UVCAppEP0Thread_Entry
 7252 3e60 EC010000 		.word	.LANCHOR0+492
 7253 3e64 C80A0000 		.word	.LC62
 7254 3e68 00000000 		.word	I2cAppThread_Entry
 7255              		.cfi_endproc
 7256              	.LFE26:
 7258              		.align	2
 7259              		.global	main
 7261              	main:
 7262              	.LFB27:
3718:../uvc.c      **** 
3719:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3720:../uvc.c      ****  * the ThreadX RTOS here.
3721:../uvc.c      ****  */
3722:../uvc.c      **** int
3723:../uvc.c      **** main (
3724:../uvc.c      ****         void)
3725:../uvc.c      **** {
 7263              		.loc 1 3725 0
 7264              		.cfi_startproc
 7265              		@ args = 0, pretend = 0, frame = 56
 7266              		@ frame_needed = 0, uses_anonymous_args = 0
 7267 3e6c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7268              	.LCFI29:
 7269              		.cfi_def_cfa_offset 12
3726:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3727:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3728:../uvc.c      **** 
3729:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3730:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3731:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3732:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3733:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3734:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7270              		.loc 1 3734 0
 7271 3e70 0010A0E3 		mov	r1, #0
3725:../uvc.c      **** {
 7272              		.loc 1 3725 0
 7273 3e74 3CD04DE2 		sub	sp, sp, #60
 7274              	.LCFI30:
 7275              		.cfi_def_cfa_offset 72
3731:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7276              		.loc 1 3731 0
 7277 3e78 0220A0E3 		mov	r2, #2
3735:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7278              		.loc 1 3735 0
 7279 3e7c 033081E2 		add	r3, r1, #3
3730:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7280              		.loc 1 3730 0
 7281 3e80 0150A0E3 		mov	r5, #1
 7282              		.cfi_offset 14, -4
 7283              		.cfi_offset 5, -8
 7284              		.cfi_offset 4, -12
3736:../uvc.c      **** 
3737:../uvc.c      ****     /* Initialize the device */
3738:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7285              		.loc 1 3738 0
 7286 3e84 28008DE2 		add	r0, sp, #40
3730:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7287              		.loc 1 3730 0
 7288 3e88 28508DE5 		str	r5, [sp, #40]
3731:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7289              		.loc 1 3731 0
 7290 3e8c 2C20CDE5 		strb	r2, [sp, #44]
3732:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7291              		.loc 1 3732 0
 7292 3e90 2D20CDE5 		strb	r2, [sp, #45]
3733:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7293              		.loc 1 3733 0
 7294 3e94 2E20CDE5 		strb	r2, [sp, #46]
3734:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7295              		.loc 1 3734 0
 7296 3e98 30108DE5 		str	r1, [sp, #48]
3735:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7297              		.loc 1 3735 0
 7298 3e9c 3430CDE5 		strb	r3, [sp, #52]
 7299              		.loc 1 3738 0
 7300 3ea0 FEFFFFEB 		bl	CyU3PDeviceInit
 7301              	.LVL599:
3739:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7302              		.loc 1 3739 0
 7303 3ea4 004050E2 		subs	r4, r0, #0
 7304 3ea8 0000000A 		beq	.L573
 7305              	.L571:
 7306              	.L572:
 7307 3eac FEFFFFEA 		b	.L572
 7308              	.L573:
3740:../uvc.c      ****     {
3741:../uvc.c      ****         goto handle_fatal_error;
3742:../uvc.c      ****     }
3743:../uvc.c      **** 
3744:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3745:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7309              		.loc 1 3745 0
 7310 3eb0 0410A0E1 		mov	r1, r4
 7311 3eb4 0420A0E1 		mov	r2, r4
 7312 3eb8 0500A0E1 		mov	r0, r5
 7313              	.LVL600:
 7314 3ebc FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7315              	.LVL601:
3746:../uvc.c      **** 
3747:../uvc.c      ****     /* Configure the IO matrix for the device. */
3748:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3749:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3750:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3751:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3752:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3753:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3754:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3755:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3756:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3757:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3758:../uvc.c      **** 
3759:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7316              		.loc 1 3759 0
 7317 3ec0 0D00A0E1 		mov	r0, sp
3749:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7318              		.loc 1 3749 0
 7319 3ec4 1640CDE5 		strb	r4, [sp, #22]
3750:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7320              		.loc 1 3750 0
 7321 3ec8 18408DE5 		str	r4, [sp, #24]
3751:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7322              		.loc 1 3751 0
 7323 3ecc 1C408DE5 		str	r4, [sp, #28]
3752:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7324              		.loc 1 3752 0
 7325 3ed0 20408DE5 		str	r4, [sp, #32]
3753:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7326              		.loc 1 3753 0
 7327 3ed4 24408DE5 		str	r4, [sp, #36]
3756:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7328              		.loc 1 3756 0
 7329 3ed8 0C408DE5 		str	r4, [sp, #12]
3757:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7330              		.loc 1 3757 0
 7331 3edc 10408DE5 		str	r4, [sp, #16]
3748:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7332              		.loc 1 3748 0
 7333 3ee0 00508DE5 		str	r5, [sp, #0]
3754:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7334              		.loc 1 3754 0
 7335 3ee4 04508DE5 		str	r5, [sp, #4]
3755:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7336              		.loc 1 3755 0
 7337 3ee8 08508DE5 		str	r5, [sp, #8]
 7338              		.loc 1 3759 0
 7339 3eec FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7340              	.LVL602:
3760:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7341              		.loc 1 3760 0
 7342 3ef0 004050E2 		subs	r4, r0, #0
 7343 3ef4 ECFFFF1A 		bne	.L571
3761:../uvc.c      ****     {
3762:../uvc.c      ****         goto handle_fatal_error;
3763:../uvc.c      ****     }
3764:../uvc.c      **** 
3765:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3766:../uvc.c      ****     CyU3PKernelEntry ();
 7344              		.loc 1 3766 0
 7345 3ef8 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7346              	.LVL603:
3767:../uvc.c      **** 
3768:../uvc.c      ****     /* Dummy return to make the compiler happy */
3769:../uvc.c      ****     return 0;
3770:../uvc.c      **** 
3771:../uvc.c      **** handle_fatal_error:
3772:../uvc.c      ****     /* Cannot recover from this error. */
3773:../uvc.c      ****     while (1);
3774:../uvc.c      **** }
 7347              		.loc 1 3774 0
 7348 3efc 0400A0E1 		mov	r0, r4
 7349 3f00 3CD08DE2 		add	sp, sp, #60
 7350 3f04 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7351              		.cfi_endproc
 7352              	.LFE27:
 7354              		.global	CyFxGpifTransition
 7355              		.global	CyFxGpifWavedata
 7356              		.global	CyFxGpifWavedataPosition
 7357              		.global	CyFxGpifRegValue
 7358              		.global	CyFxGpifConfig
 7359              		.global	CyFxGpifTransition_usb2
 7360              		.global	CyFxGpifWavedata_usb2
 7361              		.global	CyFxGpifWavedataPosition_usb2
 7362              		.global	CyFxGpifRegValue_usb2
 7363              		.global	CyFxGpifConfig_usb2
 7364              		.global	snapButFlag
 7365              		.global	testSnap
 7366              		.global	fb
 7367              		.global	pb
 7368              		.global	pbc
 7369              		.global	fbbak
 7370              		.global	pbbak
 7371              		.global	pbcbak
 7372              		.global	pbcpbak
 7373              		.global	isUsbConnected
 7374              		.global	usbSpeed
 7375              		.global	clearFeatureRqtReceived
 7376              		.global	streamingStarted
 7377              		.global	glProbeCtrl
 7378              		.global	glProbeStilCtrl
 7379              		.global	glProbeCtrl20
 7380              		.global	glProbeStilCtrl20
 7381              		.global	glUVCHeader
 7382              		.comm	glChHandleUVCStream,220,4
 7383              		.comm	glChHandleStillStream,220,4
 7384              		.comm	glChHandleInterStat,160,4
 7385              		.comm	glInterStaBuffer,4,4
 7386              		.comm	cmdQu,32,4
 7387              		.comm	statQu,32,4
 7388              		.comm	cmdQuMux,56,4
 7389              		.comm	staQuMux,56,4
 7390              		.comm	timMux,56,4
 7391              		.comm	bmReqType,1,1
 7392              		.comm	bRequest,1,1
 7393              		.comm	wValue,2,2
 7394              		.comm	wIndex,2,2
 7395              		.comm	wLength,2,2
 7396              		.comm	posTick,4,4
 7397              		.comm	I2CCmdTimer,44,4
 7398              		.section	.rodata
 7399              		.align	2
 7400              		.set	.LANCHOR2,. + 0
 7403              	ExTime:
 7404 0000 9C       		.byte	-100
 7405 0001 00       		.byte	0
 7406 0002 4E       		.byte	78
 7407 0003 00       		.byte	0
 7408 0004 27       		.byte	39
 7409 0005 00       		.byte	0
 7410 0006 14       		.byte	20
 7411 0007 00       		.byte	0
 7412 0008 0A       		.byte	10
 7413 0009 00       		.byte	0
 7414 000a 05       		.byte	5
 7415 000b 00       		.byte	0
 7416 000c 02       		.byte	2
 7417 000d 00       		.byte	0
 7418 000e 01       		.byte	1
 7419 000f 00       		.byte	0
 7422              	CyFxGpifConfig:
 7423 0010 0F00     		.short	15
 7424 0012 0000     		.space	2
 7425 0014 00000000 		.word	CyFxGpifWavedata
 7426 0018 00000000 		.word	CyFxGpifWavedataPosition
 7427 001c 0500     		.short	5
 7428 001e 0000     		.space	2
 7429 0020 00000000 		.word	CyFxGpifTransition
 7430 0024 4C00     		.short	76
 7431 0026 0000     		.space	2
 7432 0028 00000000 		.word	CyFxGpifRegValue
 7435              	CyFxGpifConfig_usb2:
 7436 002c 9300     		.short	147
 7437 002e 0000     		.space	2
 7438 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7439 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7440 0038 0800     		.short	8
 7441 003a 0000     		.space	2
 7442 003c 00000000 		.word	CyFxGpifTransition_usb2
 7443 0040 4C00     		.short	76
 7444 0042 0000     		.space	2
 7445 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7446              		.data
 7447              		.align	2
 7448              		.set	.LANCHOR1,. + 0
 7451              	ExUCtrlParArry:
 7452 0000 13       		.byte	19
 7453 0001 14       		.byte	20
 7454 0002 02       		.byte	2
 7455 0003 01       		.byte	1
 7456 0004 00       		.byte	0
 7457 0005 03       		.byte	3
 7458 0006 00       		.byte	0
 7459 0007 01       		.byte	1
 7460 0008 00       		.byte	0
 7461 0009 03       		.byte	3
 7462 000a 00       		.byte	0
 7463 000b 23       		.byte	35
 7464 000c 37       		.byte	55
 7465 000d 23       		.byte	35
 7466 000e 37       		.byte	55
 7467 000f 30       		.byte	48
 7468 0010 01       		.byte	1
 7469 0011 00       		.byte	0
 7470 0012 00       		.byte	0
 7471 0013 00000000 		.space	5
 7471      00
 7472 0018 11       		.byte	17
 7473 0019 00       		.byte	0
 7474 001a 02       		.byte	2
 7475 001b 01       		.byte	1
 7476 001c 00       		.byte	0
 7477 001d 03       		.byte	3
 7478 001e 00       		.byte	0
 7479 001f 01       		.byte	1
 7480 0020 00       		.byte	0
 7481 0021 03       		.byte	3
 7482 0022 00       		.byte	0
 7483 0023 01       		.byte	1
 7484 0024 00       		.byte	0
 7485 0025 01       		.byte	1
 7486 0026 00       		.byte	0
 7487 0027 30       		.byte	48
 7488 0028 01       		.byte	1
 7489 0029 01       		.byte	1
 7490 002a 00       		.byte	0
 7491 002b 00000000 		.space	5
 7491      00
 7492 0030 17       		.byte	23
 7493 0031 00       		.byte	0
 7494 0032 01       		.byte	1
 7495 0033 01       		.byte	1
 7496 0034 00       		.byte	0
 7497 0035 02       		.byte	2
 7498 0036 00       		.byte	0
 7499 0037 01       		.byte	1
 7500 0038 00       		.byte	0
 7501 0039 03       		.byte	3
 7502 003a 00       		.byte	0
 7503 003b 00       		.byte	0
 7504 003c 00       		.byte	0
 7505 003d 00       		.byte	0
 7506 003e 00       		.byte	0
 7507 003f 30       		.byte	48
 7508 0040 01       		.byte	1
 7509 0041 01       		.byte	1
 7510 0042 00       		.byte	0
 7511 0043 00000000 		.space	5
 7511      00
 7512 0048 00       		.byte	0
 7513 0049 00       		.byte	0
 7514 004a 04       		.byte	4
 7515 004b 01       		.byte	1
 7516 004c 00       		.byte	0
 7517 004d 38       		.byte	56
 7518 004e 01       		.byte	1
 7519 004f 01       		.byte	1
 7520 0050 00       		.byte	0
 7521 0051 03       		.byte	3
 7522 0052 00       		.byte	0
 7523 0053 4E       		.byte	78
 7524 0054 00       		.byte	0
 7525 0055 4E       		.byte	78
 7526 0056 00       		.byte	0
 7527 0057 30       		.byte	48
 7528 0058 01       		.byte	1
 7529 0059 00       		.byte	0
 7530 005a 00       		.byte	0
 7531 005b 00000000 		.space	5
 7531      00
 7532 0060 00       		.byte	0
 7533 0061 00       		.byte	0
 7534 0062 01       		.byte	1
 7535 0063 00       		.byte	0
 7536 0064 00       		.byte	0
 7537 0065 00       		.byte	0
 7538 0066 00       		.byte	0
 7539 0067 01       		.byte	1
 7540 0068 00       		.byte	0
 7541 0069 03       		.byte	3
 7542 006a 00       		.byte	0
 7543 006b 00       		.byte	0
 7544 006c 00       		.byte	0
 7545 006d 00       		.byte	0
 7546 006e 00       		.byte	0
 7547 006f 30       		.byte	48
 7548 0070 01       		.byte	1
 7549 0071 00       		.byte	0
 7550 0072 00       		.byte	0
 7551 0073 00000000 		.space	5
 7551      00
 7552 0078 00       		.byte	0
 7553 0079 00       		.byte	0
 7554 007a 02       		.byte	2
 7555 007b 00       		.byte	0
 7556 007c 00       		.byte	0
 7557 007d FF       		.byte	-1
 7558 007e 00       		.byte	0
 7559 007f 01       		.byte	1
 7560 0080 00       		.byte	0
 7561 0081 03       		.byte	3
 7562 0082 00       		.byte	0
 7563 0083 01       		.byte	1
 7564 0084 00       		.byte	0
 7565 0085 00       		.byte	0
 7566 0086 00       		.byte	0
 7567 0087 30       		.byte	48
 7568 0088 01       		.byte	1
 7569 0089 01       		.byte	1
 7570 008a 00       		.byte	0
 7571 008b 00000000 		.space	5
 7571      00
 7572 0090 00       		.byte	0
 7573 0091 00       		.byte	0
 7574 0092 02       		.byte	2
 7575 0093 00       		.byte	0
 7576 0094 00       		.byte	0
 7577 0095 00       		.byte	0
 7578 0096 00       		.byte	0
 7579 0097 00       		.byte	0
 7580 0098 00       		.byte	0
 7581 0099 03       		.byte	3
 7582 009a 00       		.byte	0
 7583 009b 00       		.byte	0
 7584 009c 00       		.byte	0
 7585 009d 00       		.byte	0
 7586 009e 00       		.byte	0
 7587 009f 30       		.byte	48
 7588 00a0 01       		.byte	1
 7589 00a1 01       		.byte	1
 7590 00a2 00       		.byte	0
 7591 00a3 00000000 		.space	5
 7591      00
 7592 00a8 00       		.byte	0
 7593 00a9 00       		.byte	0
 7594 00aa 02       		.byte	2
 7595 00ab 00       		.byte	0
 7596 00ac 00       		.byte	0
 7597 00ad 30       		.byte	48
 7598 00ae 00       		.byte	0
 7599 00af 01       		.byte	1
 7600 00b0 00       		.byte	0
 7601 00b1 03       		.byte	3
 7602 00b2 0A       		.byte	10
 7603 00b3 00       		.byte	0
 7604 00b4 00       		.byte	0
 7605 00b5 0A       		.byte	10
 7606 00b6 00       		.byte	0
 7607 00b7 30       		.byte	48
 7608 00b8 01       		.byte	1
 7609 00b9 01       		.byte	1
 7610 00ba 00       		.byte	0
 7611 00bb 00000000 		.space	5
 7611      00
 7612 00c0 00       		.byte	0
 7613 00c1 00       		.byte	0
 7614 00c2 01       		.byte	1
 7615 00c3 00       		.byte	0
 7616 00c4 00       		.byte	0
 7617 00c5 7F       		.byte	127
 7618 00c6 00       		.byte	0
 7619 00c7 01       		.byte	1
 7620 00c8 00       		.byte	0
 7621 00c9 03       		.byte	3
 7622 00ca 00       		.byte	0
 7623 00cb 00       		.byte	0
 7624 00cc 00       		.byte	0
 7625 00cd 00       		.byte	0
 7626 00ce 00       		.byte	0
 7627 00cf 30       		.byte	48
 7628 00d0 01       		.byte	1
 7629 00d1 00       		.byte	0
 7630 00d2 00       		.byte	0
 7631 00d3 00000000 		.space	5
 7631      00
 7632 00d8 00       		.byte	0
 7633 00d9 00       		.byte	0
 7634 00da 02       		.byte	2
 7635 00db 00       		.byte	0
 7636 00dc 00       		.byte	0
 7637 00dd 05       		.byte	5
 7638 00de 00       		.byte	0
 7639 00df 01       		.byte	1
 7640 00e0 00       		.byte	0
 7641 00e1 03       		.byte	3
 7642 00e2 00       		.byte	0
 7643 00e3 00       		.byte	0
 7644 00e4 00       		.byte	0
 7645 00e5 00       		.byte	0
 7646 00e6 00       		.byte	0
 7647 00e7 30       		.byte	48
 7648 00e8 01       		.byte	1
 7649 00e9 00       		.byte	0
 7650 00ea 00       		.byte	0
 7651 00eb 00000000 		.space	5
 7651      00
 7652 00f0 00       		.byte	0
 7653 00f1 00       		.byte	0
 7654 00f2 03       		.byte	3
 7655 00f3 00       		.byte	0
 7656 00f4 00       		.byte	0
 7657 00f5 0A       		.byte	10
 7658 00f6 00       		.byte	0
 7659 00f7 01       		.byte	1
 7660 00f8 00       		.byte	0
 7661 00f9 03       		.byte	3
 7662 00fa 00       		.byte	0
 7663 00fb 00       		.byte	0
 7664 00fc 00       		.byte	0
 7665 00fd 00       		.byte	0
 7666 00fe 00       		.byte	0
 7667 00ff 30       		.byte	48
 7668 0100 01       		.byte	1
 7669 0101 00       		.byte	0
 7670 0102 00       		.byte	0
 7671 0103 00000000 		.space	5
 7671      00
 7672 0108 00       		.byte	0
 7673 0109 00       		.byte	0
 7674 010a 02       		.byte	2
 7675 010b 00       		.byte	0
 7676 010c 00       		.byte	0
 7677 010d 40       		.byte	64
 7678 010e 00       		.byte	0
 7679 010f 01       		.byte	1
 7680 0110 00       		.byte	0
 7681 0111 03       		.byte	3
 7682 0112 00       		.byte	0
 7683 0113 0F       		.byte	15
 7684 0114 11       		.byte	17
 7685 0115 00       		.byte	0
 7686 0116 00       		.byte	0
 7687 0117 30       		.byte	48
 7688 0118 01       		.byte	1
 7689 0119 00       		.byte	0
 7690 011a 00       		.byte	0
 7691 011b 00000000 		.space	5
 7691      00
 7692 0120 00       		.byte	0
 7693 0121 00       		.byte	0
 7694 0122 02       		.byte	2
 7695 0123 00       		.byte	0
 7696 0124 00       		.byte	0
 7697 0125 64       		.byte	100
 7698 0126 00       		.byte	0
 7699 0127 01       		.byte	1
 7700 0128 00       		.byte	0
 7701 0129 03       		.byte	3
 7702 012a 00       		.byte	0
 7703 012b 00       		.byte	0
 7704 012c 00       		.byte	0
 7705 012d 00       		.byte	0
 7706 012e 00       		.byte	0
 7707 012f 30       		.byte	48
 7708 0130 01       		.byte	1
 7709 0131 00       		.byte	0
 7710 0132 00       		.byte	0
 7711 0133 00000000 		.space	5
 7711      00
 7712 0138 00       		.byte	0
 7713 0139 00       		.byte	0
 7714 013a 02       		.byte	2
 7715 013b 00       		.byte	0
 7716 013c 00       		.byte	0
 7717 013d 64       		.byte	100
 7718 013e 00       		.byte	0
 7719 013f 01       		.byte	1
 7720 0140 00       		.byte	0
 7721 0141 03       		.byte	3
 7722 0142 00       		.byte	0
 7723 0143 00       		.byte	0
 7724 0144 00       		.byte	0
 7725 0145 00       		.byte	0
 7726 0146 00       		.byte	0
 7727 0147 30       		.byte	48
 7728 0148 01       		.byte	1
 7729 0149 00       		.byte	0
 7730 014a 00       		.byte	0
 7731 014b 00000000 		.space	5
 7731      00
 7732 0150 00       		.byte	0
 7733 0151 00       		.byte	0
 7734 0152 02       		.byte	2
 7735 0153 00       		.byte	0
 7736 0154 00       		.byte	0
 7737 0155 64       		.byte	100
 7738 0156 00       		.byte	0
 7739 0157 01       		.byte	1
 7740 0158 00       		.byte	0
 7741 0159 03       		.byte	3
 7742 015a 00       		.byte	0
 7743 015b 00       		.byte	0
 7744 015c 00       		.byte	0
 7745 015d 00       		.byte	0
 7746 015e 00       		.byte	0
 7747 015f 30       		.byte	48
 7748 0160 01       		.byte	1
 7749 0161 00       		.byte	0
 7750 0162 00       		.byte	0
 7751 0163 00000000 		.space	5
 7751      00
 7752 0168 00       		.byte	0
 7753 0169 00       		.byte	0
 7754 016a 02       		.byte	2
 7755 016b 00       		.byte	0
 7756 016c 00       		.byte	0
 7757 016d 64       		.byte	100
 7758 016e 00       		.byte	0
 7759 016f 01       		.byte	1
 7760 0170 00       		.byte	0
 7761 0171 03       		.byte	3
 7762 0172 00       		.byte	0
 7763 0173 00       		.byte	0
 7764 0174 00       		.byte	0
 7765 0175 00       		.byte	0
 7766 0176 00       		.byte	0
 7767 0177 30       		.byte	48
 7768 0178 01       		.byte	1
 7769 0179 00       		.byte	0
 7770 017a 00       		.byte	0
 7771 017b 00000000 		.space	5
 7771      00
 7774              	CtrlParArry:
 7775 0180 10       		.byte	16
 7776 0181 10       		.byte	16
 7777 0182 02       		.byte	2
 7778 0183 00       		.byte	0
 7779 0184 00       		.byte	0
 7780 0185 03       		.byte	3
 7781 0186 00       		.byte	0
 7782 0187 01       		.byte	1
 7783 0188 00       		.byte	0
 7784 0189 03       		.byte	3
 7785 018a 00       		.byte	0
 7786 018b 00       		.byte	0
 7787 018c 00       		.byte	0
 7788 018d 03       		.byte	3
 7789 018e 00       		.byte	0
 7790 018f 30       		.byte	48
 7791 0190 01       		.byte	1
 7792 0191 00       		.byte	0
 7793 0192 00       		.byte	0
 7794 0193 00000000 		.space	5
 7794      00
 7795 0198 01       		.byte	1
 7796 0199 00       		.byte	0
 7797 019a 02       		.byte	2
 7798 019b 00       		.byte	0
 7799 019c 00       		.byte	0
 7800 019d FF       		.byte	-1
 7801 019e 00       		.byte	0
 7802 019f 01       		.byte	1
 7803 01a0 00       		.byte	0
 7804 01a1 03       		.byte	3
 7805 01a2 00       		.byte	0
 7806 01a3 76       		.byte	118
 7807 01a4 00       		.byte	0
 7808 01a5 76       		.byte	118
 7809 01a6 C7       		.byte	-57
 7810 01a7 C6       		.byte	-58
 7811 01a8 01       		.byte	1
 7812 01a9 01       		.byte	1
 7813 01aa 00       		.byte	0
 7814 01ab 00000000 		.space	5
 7814      00
 7815 01b0 02       		.byte	2
 7816 01b1 02       		.byte	2
 7817 01b2 02       		.byte	2
 7818 01b3 00       		.byte	0
 7819 01b4 00       		.byte	0
 7820 01b5 FF       		.byte	-1
 7821 01b6 00       		.byte	0
 7822 01b7 01       		.byte	1
 7823 01b8 00       		.byte	0
 7824 01b9 03       		.byte	3
 7825 01ba 00       		.byte	0
 7826 01bb 70       		.byte	112
 7827 01bc 00       		.byte	0
 7828 01bd 70       		.byte	112
 7829 01be 00       		.byte	0
 7830 01bf C6       		.byte	-58
 7831 01c0 01       		.byte	1
 7832 01c1 01       		.byte	1
 7833 01c2 00       		.byte	0
 7834 01c3 00000000 		.space	5
 7834      00
 7835 01c8 00       		.byte	0
 7836 01c9 00       		.byte	0
 7837 01ca 02       		.byte	2
 7838 01cb 00       		.byte	0
 7839 01cc 00       		.byte	0
 7840 01cd 64       		.byte	100
 7841 01ce 00       		.byte	0
 7842 01cf 01       		.byte	1
 7843 01d0 00       		.byte	0
 7844 01d1 03       		.byte	3
 7845 01d2 00       		.byte	0
 7846 01d3 00       		.byte	0
 7847 01d4 00       		.byte	0
 7848 01d5 00       		.byte	0
 7849 01d6 00       		.byte	0
 7850 01d7 30       		.byte	48
 7851 01d8 01       		.byte	1
 7852 01d9 00       		.byte	0
 7853 01da 00       		.byte	0
 7854 01db 00000000 		.space	5
 7854      00
 7855 01e0 07       		.byte	7
 7856 01e1 07       		.byte	7
 7857 01e2 02       		.byte	2
 7858 01e3 00       		.byte	0
 7859 01e4 00       		.byte	0
 7860 01e5 01       		.byte	1
 7861 01e6 00       		.byte	0
 7862 01e7 01       		.byte	1
 7863 01e8 00       		.byte	0
 7864 01e9 03       		.byte	3
 7865 01ea 00       		.byte	0
 7866 01eb 01       		.byte	1
 7867 01ec 00       		.byte	0
 7868 01ed 01       		.byte	1
 7869 01ee 00       		.byte	0
 7870 01ef 30       		.byte	48
 7871 01f0 01       		.byte	1
 7872 01f1 00       		.byte	0
 7873 01f2 00       		.byte	0
 7874 01f3 00000000 		.space	5
 7874      00
 7875 01f8 DF       		.byte	-33
 7876 01f9 E1       		.byte	-31
 7877 01fa 02       		.byte	2
 7878 01fb 00       		.byte	0
 7879 01fc 00       		.byte	0
 7880 01fd FF       		.byte	-1
 7881 01fe 00       		.byte	0
 7882 01ff 01       		.byte	1
 7883 0200 00       		.byte	0
 7884 0201 03       		.byte	3
 7885 0202 00       		.byte	0
 7886 0203 80       		.byte	-128
 7887 0204 00       		.byte	0
 7888 0205 00       		.byte	0
 7889 0206 00       		.byte	0
 7890 0207 C6       		.byte	-58
 7891 0208 01       		.byte	1
 7892 0209 01       		.byte	1
 7893 020a 00       		.byte	0
 7894 020b 00000000 		.space	5
 7894      00
 7895 0210 85       		.byte	-123
 7896 0211 86       		.byte	-122
 7897 0212 02       		.byte	2
 7898 0213 00       		.byte	0
 7899 0214 00       		.byte	0
 7900 0215 64       		.byte	100
 7901 0216 00       		.byte	0
 7902 0217 01       		.byte	1
 7903 0218 00       		.byte	0
 7904 0219 03       		.byte	3
 7905 021a 00       		.byte	0
 7906 021b 32       		.byte	50
 7907 021c 00       		.byte	0
 7908 021d 32       		.byte	50
 7909 021e 00       		.byte	0
 7910 021f F2       		.byte	-14
 7911 0220 01       		.byte	1
 7912 0221 01       		.byte	1
 7913 0222 00       		.byte	0
 7914 0223 00000000 		.space	5
 7914      00
 7915 0228 06       		.byte	6
 7916 0229 06       		.byte	6
 7917 022a 02       		.byte	2
 7918 022b 00       		.byte	0
 7919 022c 00       		.byte	0
 7920 022d 40       		.byte	64
 7921 022e 00       		.byte	0
 7922 022f 01       		.byte	1
 7923 0230 00       		.byte	0
 7924 0231 03       		.byte	3
 7925 0232 00       		.byte	0
 7926 0233 20       		.byte	32
 7927 0234 00       		.byte	0
 7928 0235 20       		.byte	32
 7929 0236 00       		.byte	0
 7930 0237 30       		.byte	48
 7931 0238 01       		.byte	1
 7932 0239 01       		.byte	1
 7933 023a 00       		.byte	0
 7934 023b 00000000 		.space	5
 7934      00
 7935 0240 00       		.byte	0
 7936 0241 00       		.byte	0
 7937 0242 02       		.byte	2
 7938 0243 00       		.byte	0
 7939 0244 00       		.byte	0
 7940 0245 64       		.byte	100
 7941 0246 00       		.byte	0
 7942 0247 01       		.byte	1
 7943 0248 00       		.byte	0
 7944 0249 03       		.byte	3
 7945 024a 00       		.byte	0
 7946 024b 00       		.byte	0
 7947 024c 00       		.byte	0
 7948 024d 00       		.byte	0
 7949 024e 00       		.byte	0
 7950 024f 30       		.byte	48
 7951 0250 01       		.byte	1
 7952 0251 00       		.byte	0
 7953 0252 00       		.byte	0
 7954 0253 00000000 		.space	5
 7954      00
 7955 0258 08       		.byte	8
 7956 0259 08       		.byte	8
 7957 025a 02       		.byte	2
 7958 025b 00       		.byte	0
 7959 025c 00       		.byte	0
 7960 025d 05       		.byte	5
 7961 025e 00       		.byte	0
 7962 025f 01       		.byte	1
 7963 0260 00       		.byte	0
 7964 0261 03       		.byte	3
 7965 0262 00       		.byte	0
 7966 0263 00       		.byte	0
 7967 0264 00       		.byte	0
 7968 0265 00       		.byte	0
 7969 0266 00       		.byte	0
 7970 0267 30       		.byte	48
 7971 0268 01       		.byte	1
 7972 0269 00       		.byte	0
 7973 026a 00       		.byte	0
 7974 026b 00000000 		.space	5
 7974      00
 7975 0270 00       		.byte	0
 7976 0271 00       		.byte	0
 7977 0272 02       		.byte	2
 7978 0273 00       		.byte	0
 7979 0274 00       		.byte	0
 7980 0275 40       		.byte	64
 7981 0276 00       		.byte	0
 7982 0277 01       		.byte	1
 7983 0278 00       		.byte	0
 7984 0279 03       		.byte	3
 7985 027a 00       		.byte	0
 7986 027b 00       		.byte	0
 7987 027c 00       		.byte	0
 7988 027d 00       		.byte	0
 7989 027e 00       		.byte	0
 7990 027f 30       		.byte	48
 7991 0280 01       		.byte	1
 7992 0281 00       		.byte	0
 7993 0282 00       		.byte	0
 7994 0283 00000000 		.space	5
 7994      00
 7995 0288 09       		.byte	9
 7996 0289 0A       		.byte	10
 7997 028a 04       		.byte	4
 7998 028b 00       		.byte	0
 7999 028c 00       		.byte	0
 8000 028d 40       		.byte	64
 8001 028e 00       		.byte	0
 8002 028f 01       		.byte	1
 8003 0290 00       		.byte	0
 8004 0291 03       		.byte	3
 8005 0292 00       		.byte	0
 8006 0293 20       		.byte	32
 8007 0294 38       		.byte	56
 8008 0295 20       		.byte	32
 8009 0296 38       		.byte	56
 8010 0297 30       		.byte	48
 8011 0298 01       		.byte	1
 8012 0299 00       		.byte	0
 8013 029a 00       		.byte	0
 8014 029b 00000000 		.space	5
 8014      00
 8015 02a0 00       		.byte	0
 8016 02a1 00       		.byte	0
 8017 02a2 02       		.byte	2
 8018 02a3 00       		.byte	0
 8019 02a4 00       		.byte	0
 8020 02a5 64       		.byte	100
 8021 02a6 00       		.byte	0
 8022 02a7 01       		.byte	1
 8023 02a8 00       		.byte	0
 8024 02a9 03       		.byte	3
 8025 02aa 00       		.byte	0
 8026 02ab 00       		.byte	0
 8027 02ac 00       		.byte	0
 8028 02ad 00       		.byte	0
 8029 02ae 00       		.byte	0
 8030 02af 30       		.byte	48
 8031 02b0 01       		.byte	1
 8032 02b1 00       		.byte	0
 8033 02b2 00       		.byte	0
 8034 02b3 00000000 		.space	5
 8034      00
 8035 02b8 00       		.byte	0
 8036 02b9 00       		.byte	0
 8037 02ba 02       		.byte	2
 8038 02bb 00       		.byte	0
 8039 02bc 00       		.byte	0
 8040 02bd 64       		.byte	100
 8041 02be 00       		.byte	0
 8042 02bf 01       		.byte	1
 8043 02c0 00       		.byte	0
 8044 02c1 03       		.byte	3
 8045 02c2 00       		.byte	0
 8046 02c3 00       		.byte	0
 8047 02c4 00       		.byte	0
 8048 02c5 00       		.byte	0
 8049 02c6 00       		.byte	0
 8050 02c7 30       		.byte	48
 8051 02c8 01       		.byte	1
 8052 02c9 00       		.byte	0
 8053 02ca 00       		.byte	0
 8054 02cb 00000000 		.space	5
 8054      00
 8055 02d0 2A       		.byte	42
 8056 02d1 2A       		.byte	42
 8057 02d2 02       		.byte	2
 8058 02d3 00       		.byte	0
 8059 02d4 00       		.byte	0
 8060 02d5 1B       		.byte	27
 8061 02d6 00       		.byte	0
 8062 02d7 01       		.byte	1
 8063 02d8 00       		.byte	0
 8064 02d9 03       		.byte	3
 8065 02da 00       		.byte	0
 8066 02db 00       		.byte	0
 8067 02dc 00       		.byte	0
 8068 02dd 00       		.byte	0
 8069 02de 00       		.byte	0
 8070 02df 30       		.byte	48
 8071 02e0 01       		.byte	1
 8072 02e1 00       		.byte	0
 8073 02e2 00       		.byte	0
 8074 02e3 00000000 		.space	5
 8074      00
 8075 02e8 00       		.byte	0
 8076 02e9 00       		.byte	0
 8077 02ea 02       		.byte	2
 8078 02eb 00       		.byte	0
 8079 02ec 00       		.byte	0
 8080 02ed 64       		.byte	100
 8081 02ee 00       		.byte	0
 8082 02ef 01       		.byte	1
 8083 02f0 00       		.byte	0
 8084 02f1 03       		.byte	3
 8085 02f2 00       		.byte	0
 8086 02f3 00       		.byte	0
 8087 02f4 00       		.byte	0
 8088 02f5 00       		.byte	0
 8089 02f6 00       		.byte	0
 8090 02f7 30       		.byte	48
 8091 02f8 01       		.byte	1
 8092 02f9 00       		.byte	0
 8093 02fa 00       		.byte	0
 8094 02fb 00000000 		.space	5
 8094      00
 8095 0300 00       		.byte	0
 8096 0301 00       		.byte	0
 8097 0302 02       		.byte	2
 8098 0303 00       		.byte	0
 8099 0304 00       		.byte	0
 8100 0305 12       		.byte	18
 8101 0306 00       		.byte	0
 8102 0307 01       		.byte	1
 8103 0308 00       		.byte	0
 8104 0309 03       		.byte	3
 8105 030a 00       		.byte	0
 8106 030b 00       		.byte	0
 8107 030c 00       		.byte	0
 8108 030d 00       		.byte	0
 8109 030e 00       		.byte	0
 8110 030f 30       		.byte	48
 8111 0310 01       		.byte	1
 8112 0311 00       		.byte	0
 8113 0312 00       		.byte	0
 8114 0313 00000000 		.space	5
 8114      00
 8115 0318 01       		.byte	1
 8116 0319 01       		.byte	1
 8117 031a 02       		.byte	2
 8118 031b 00       		.byte	0
 8119 031c 00       		.byte	0
 8120 031d 09       		.byte	9
 8121 031e 00       		.byte	0
 8122 031f 01       		.byte	1
 8123 0320 00       		.byte	0
 8124 0321 03       		.byte	3
 8125 0322 00       		.byte	0
 8126 0323 00       		.byte	0
 8127 0324 00       		.byte	0
 8128 0325 01       		.byte	1
 8129 0326 00       		.byte	0
 8130 0327 30       		.byte	48
 8131 0328 01       		.byte	1
 8132 0329 00       		.byte	0
 8133 032a 00       		.byte	0
 8134 032b 00000000 		.space	5
 8134      00
 8135 0330 05       		.byte	5
 8136 0331 05       		.byte	5
 8137 0332 02       		.byte	2
 8138 0333 00       		.byte	0
 8139 0334 00       		.byte	0
 8140 0335 03       		.byte	3
 8141 0336 00       		.byte	0
 8142 0337 01       		.byte	1
 8143 0338 00       		.byte	0
 8144 0339 03       		.byte	3
 8145 033a 00       		.byte	0
 8146 033b 00       		.byte	0
 8147 033c 00       		.byte	0
 8148 033d 03       		.byte	3
 8149 033e 00       		.byte	0
 8150 033f 30       		.byte	48
 8151 0340 01       		.byte	1
 8152 0341 00       		.byte	0
 8153 0342 00       		.byte	0
 8154 0343 00000000 		.space	5
 8154      00
 8155 0348 18       		.byte	24
 8156 0349 18       		.byte	24
 8157 034a 02       		.byte	2
 8158 034b 00       		.byte	0
 8159 034c 00       		.byte	0
 8160 034d 01       		.byte	1
 8161 034e 00       		.byte	0
 8162 034f 01       		.byte	1
 8163 0350 00       		.byte	0
 8164 0351 03       		.byte	3
 8165 0352 00       		.byte	0
 8166 0353 00       		.byte	0
 8167 0354 00       		.byte	0
 8168 0355 00       		.byte	0
 8169 0356 00       		.byte	0
 8170 0357 30       		.byte	48
 8171 0358 01       		.byte	1
 8172 0359 00       		.byte	0
 8173 035a 00       		.byte	0
 8174 035b 00000000 		.space	5
 8174      00
 8175 0360 19       		.byte	25
 8176 0361 19       		.byte	25
 8177 0362 01       		.byte	1
 8178 0363 00       		.byte	0
 8179 0364 00       		.byte	0
 8180 0365 40       		.byte	64
 8181 0366 00       		.byte	0
 8182 0367 01       		.byte	1
 8183 0368 00       		.byte	0
 8184 0369 03       		.byte	3
 8185 036a 00       		.byte	0
 8186 036b 20       		.byte	32
 8187 036c 00       		.byte	0
 8188 036d 20       		.byte	32
 8189 036e 00       		.byte	0
 8190 036f 30       		.byte	48
 8191 0370 01       		.byte	1
 8192 0371 00       		.byte	0
 8193 0372 00       		.byte	0
 8194 0373 00000000 		.space	5
 8194      00
 8195 0378 20       		.byte	32
 8196 0379 20       		.byte	32
 8197 037a 02       		.byte	2
 8198 037b 00       		.byte	0
 8199 037c 00       		.byte	0
 8200 037d 02       		.byte	2
 8201 037e 00       		.byte	0
 8202 037f 01       		.byte	1
 8203 0380 00       		.byte	0
 8204 0381 03       		.byte	3
 8205 0382 00       		.byte	0
 8206 0383 00       		.byte	0
 8207 0384 00       		.byte	0
 8208 0385 00       		.byte	0
 8209 0386 00       		.byte	0
 8210 0387 30       		.byte	48
 8211 0388 01       		.byte	1
 8212 0389 00       		.byte	0
 8213 038a 00       		.byte	0
 8214 038b 00000000 		.space	5
 8214      00
 8215 0390 22       		.byte	34
 8216 0391 22       		.byte	34
 8217 0392 02       		.byte	2
 8218 0393 00       		.byte	0
 8219 0394 00       		.byte	0
 8220 0395 3F       		.byte	63
 8221 0396 00       		.byte	0
 8222 0397 01       		.byte	1
 8223 0398 00       		.byte	0
 8224 0399 03       		.byte	3
 8225 039a 00       		.byte	0
 8226 039b 00       		.byte	0
 8227 039c 00       		.byte	0
 8228 039d 00       		.byte	0
 8229 039e 00       		.byte	0
 8230 039f 30       		.byte	48
 8231 03a0 01       		.byte	1
 8232 03a1 00       		.byte	0
 8233 03a2 00       		.byte	0
 8234 03a3 00000000 		.space	5
 8234      00
 8235 03a8 23       		.byte	35
 8236 03a9 23       		.byte	35
 8237 03aa 02       		.byte	2
 8238 03ab 00       		.byte	0
 8239 03ac 00       		.byte	0
 8240 03ad 64       		.byte	100
 8241 03ae 00       		.byte	0
 8242 03af 01       		.byte	1
 8243 03b0 00       		.byte	0
 8244 03b1 03       		.byte	3
 8245 03b2 00       		.byte	0
 8246 03b3 10       		.byte	16
 8247 03b4 00       		.byte	0
 8248 03b5 10       		.byte	16
 8249 03b6 00       		.byte	0
 8250 03b7 30       		.byte	48
 8251 03b8 01       		.byte	1
 8252 03b9 00       		.byte	0
 8253 03ba 00       		.byte	0
 8254 03bb 00000000 		.space	5
 8254      00
 8255 03c0 24       		.byte	36
 8256 03c1 24       		.byte	36
 8257 03c2 02       		.byte	2
 8258 03c3 00       		.byte	0
 8259 03c4 00       		.byte	0
 8260 03c5 64       		.byte	100
 8261 03c6 00       		.byte	0
 8262 03c7 01       		.byte	1
 8263 03c8 00       		.byte	0
 8264 03c9 03       		.byte	3
 8265 03ca 00       		.byte	0
 8266 03cb 10       		.byte	16
 8267 03cc 00       		.byte	0
 8268 03cd 10       		.byte	16
 8269 03ce 00       		.byte	0
 8270 03cf 30       		.byte	48
 8271 03d0 01       		.byte	1
 8272 03d1 00       		.byte	0
 8273 03d2 00       		.byte	0
 8274 03d3 00000000 		.space	5
 8274      00
 8275 03d8 02       		.byte	2
 8276 03d9 03       		.byte	3
 8277 03da 04       		.byte	4
 8278 03db 00       		.byte	0
 8279 03dc 00       		.byte	0
 8280 03dd 7F       		.byte	127
 8281 03de 00       		.byte	0
 8282 03df 01       		.byte	1
 8283 03e0 00       		.byte	0
 8284 03e1 03       		.byte	3
 8285 03e2 00       		.byte	0
 8286 03e3 00       		.byte	0
 8287 03e4 20       		.byte	32
 8288 03e5 00       		.byte	0
 8289 03e6 20       		.byte	32
 8290 03e7 30       		.byte	48
 8291 03e8 01       		.byte	1
 8292 03e9 00       		.byte	0
 8293 03ea 00       		.byte	0
 8294 03eb 00000000 		.space	5
 8294      00
 8295 03f0 04       		.byte	4
 8296 03f1 0C       		.byte	12
 8297 03f2 02       		.byte	2
 8298 03f3 00       		.byte	0
 8299 03f4 00       		.byte	0
 8300 03f5 40       		.byte	64
 8301 03f6 00       		.byte	0
 8302 03f7 01       		.byte	1
 8303 03f8 00       		.byte	0
 8304 03f9 03       		.byte	3
 8305 03fa 00       		.byte	0
 8306 03fb 20       		.byte	32
 8307 03fc 00       		.byte	0
 8308 03fd 20       		.byte	32
 8309 03fe 00       		.byte	0
 8310 03ff 30       		.byte	48
 8311 0400 01       		.byte	1
 8312 0401 00       		.byte	0
 8313 0402 00       		.byte	0
 8314 0403 00000000 		.space	5
 8314      00
 8315 0408 00       		.byte	0
 8316 0409 00       		.byte	0
 8317 040a 02       		.byte	2
 8318 040b 00       		.byte	0
 8319 040c 00       		.byte	0
 8320 040d 19       		.byte	25
 8321 040e 00       		.byte	0
 8322 040f 01       		.byte	1
 8323 0410 00       		.byte	0
 8324 0411 03       		.byte	3
 8325 0412 00       		.byte	0
 8326 0413 00       		.byte	0
 8327 0414 00       		.byte	0
 8328 0415 00       		.byte	0
 8329 0416 00       		.byte	0
 8330 0417 30       		.byte	48
 8331 0418 01       		.byte	1
 8332 0419 00       		.byte	0
 8333 041a 00       		.byte	0
 8334 041b 00000000 		.space	5
 8334      00
 8335 0420 10       		.byte	16
 8336 0421 10       		.byte	16
 8337 0422 02       		.byte	2
 8338 0423 00       		.byte	0
 8339 0424 00       		.byte	0
 8340 0425 06       		.byte	6
 8341 0426 00       		.byte	0
 8342 0427 01       		.byte	1
 8343 0428 00       		.byte	0
 8344 0429 03       		.byte	3
 8345 042a 00       		.byte	0
 8346 042b 00       		.byte	0
 8347 042c 00       		.byte	0
 8348 042d 00       		.byte	0
 8349 042e 00       		.byte	0
 8350 042f 30       		.byte	48
 8351 0430 01       		.byte	1
 8352 0431 00       		.byte	0
 8353 0432 00       		.byte	0
 8354 0433 00000000 		.space	5
 8354      00
 8355 0438 00       		.byte	0
 8356 0439 00       		.byte	0
 8357 043a 02       		.byte	2
 8358 043b 00       		.byte	0
 8359 043c 00       		.byte	0
 8360 043d 03       		.byte	3
 8361 043e 00       		.byte	0
 8362 043f 01       		.byte	1
 8363 0440 00       		.byte	0
 8364 0441 03       		.byte	3
 8365 0442 00       		.byte	0
 8366 0443 00       		.byte	0
 8367 0444 00       		.byte	0
 8368 0445 00       		.byte	0
 8369 0446 00       		.byte	0
 8370 0447 30       		.byte	48
 8371 0448 01       		.byte	1
 8372 0449 00       		.byte	0
 8373 044a 00       		.byte	0
 8374 044b 00000000 		.space	5
 8374      00
 8375 0450 50       		.byte	80
 8376 0451 50       		.byte	80
 8377 0452 01       		.byte	1
 8378 0453 00       		.byte	0
 8379 0454 00       		.byte	0
 8380 0455 03       		.byte	3
 8381 0456 00       		.byte	0
 8382 0457 01       		.byte	1
 8383 0458 00       		.byte	0
 8384 0459 03       		.byte	3
 8385 045a 00       		.byte	0
 8386 045b 00       		.byte	0
 8387 045c 00       		.byte	0
 8388 045d 00       		.byte	0
 8389 045e 00       		.byte	0
 8390 045f 30       		.byte	48
 8391 0460 01       		.byte	1
 8392 0461 00       		.byte	0
 8393 0462 00       		.byte	0
 8394 0463 00000000 		.space	5
 8394      00
 8395 0468 00       		.byte	0
 8396 0469 00       		.byte	0
 8397 046a 0B       		.byte	11
 8398 046b 00       		.byte	0
 8399 046c 00       		.byte	0
 8400 046d FF       		.byte	-1
 8401 046e FF       		.byte	-1
 8402 046f 01       		.byte	1
 8403 0470 00       		.byte	0
 8404 0471 03       		.byte	3
 8405 0472 00       		.byte	0
 8406 0473 00       		.byte	0
 8407 0474 00       		.byte	0
 8408 0475 00       		.byte	0
 8409 0476 00       		.byte	0
 8410 0477 00       		.byte	0
 8411 0478 01       		.byte	1
 8412 0479 00       		.byte	0
 8413 047a 00       		.byte	0
 8414 047b 00000000 		.space	5
 8414      00
 8417              	glUVCHeader:
 8418 0480 0C       		.byte	12
 8419 0481 8C       		.byte	-116
 8420 0482 00       		.byte	0
 8421 0483 00       		.byte	0
 8422 0484 00       		.byte	0
 8423 0485 00       		.byte	0
 8424 0486 00       		.byte	0
 8425 0487 00       		.byte	0
 8426 0488 00       		.byte	0
 8427 0489 00       		.byte	0
 8428 048a 00       		.byte	0
 8429 048b 00       		.byte	0
 8432              	WBMenuCmpArry:
 8433 048c 20       		.byte	32
 8434 048d 0F       		.byte	15
 8435 048e 38       		.byte	56
 8436 048f F0       		.byte	-16
 8439              	CTCtrlParArry:
 8440 0490 00       		.byte	0
 8441 0491 00       		.byte	0
 8442 0492 01       		.byte	1
 8443 0493 00       		.byte	0
 8444 0494 00       		.byte	0
 8445 0495 03       		.byte	3
 8446 0496 00       		.byte	0
 8447 0497 01       		.byte	1
 8448 0498 00       		.byte	0
 8449 0499 03       		.byte	3
 8450 049a 00       		.byte	0
 8451 049b 03       		.byte	3
 8452 049c 00       		.byte	0
 8453 049d 03       		.byte	3
 8454 049e 00       		.byte	0
 8455 049f 30       		.byte	48
 8456 04a0 01       		.byte	1
 8457 04a1 00       		.byte	0
 8458 04a2 00       		.byte	0
 8459 04a3 00000000 		.space	5
 8459      00
 8460 04a8 00       		.byte	0
 8461 04a9 00       		.byte	0
 8462 04aa 01       		.byte	1
 8463 04ab 01       		.byte	1
 8464 04ac 00       		.byte	0
 8465 04ad 0F       		.byte	15
 8466 04ae 00       		.byte	0
 8467 04af 0F       		.byte	15
 8468 04b0 00       		.byte	0
 8469 04b1 03       		.byte	3
 8470 04b2 00       		.byte	0
 8471 04b3 02       		.byte	2
 8472 04b4 00       		.byte	0
 8473 04b5 02       		.byte	2
 8474 04b6 00       		.byte	0
 8475 04b7 30       		.byte	48
 8476 04b8 01       		.byte	1
 8477 04b9 01       		.byte	1
 8478 04ba 00       		.byte	0
 8479 04bb 00000000 		.space	5
 8479      00
 8480 04c0 02       		.byte	2
 8481 04c1 00       		.byte	0
 8482 04c2 01       		.byte	1
 8483 04c3 00       		.byte	0
 8484 04c4 00       		.byte	0
 8485 04c5 01       		.byte	1
 8486 04c6 00       		.byte	0
 8487 04c7 01       		.byte	1
 8488 04c8 00       		.byte	0
 8489 04c9 03       		.byte	3
 8490 04ca 00       		.byte	0
 8491 04cb 00       		.byte	0
 8492 04cc 00       		.byte	0
 8493 04cd 00       		.byte	0
 8494 04ce 00       		.byte	0
 8495 04cf 30       		.byte	48
 8496 04d0 01       		.byte	1
 8497 04d1 01       		.byte	1
 8498 04d2 00       		.byte	0
 8499 04d3 00000000 		.space	5
 8499      00
 8500 04d8 00       		.byte	0
 8501 04d9 00       		.byte	0
 8502 04da 04       		.byte	4
 8503 04db 01       		.byte	1
 8504 04dc 00       		.byte	0
 8505 04dd 38       		.byte	56
 8506 04de 01       		.byte	1
 8507 04df 01       		.byte	1
 8508 04e0 00       		.byte	0
 8509 04e1 03       		.byte	3
 8510 04e2 00       		.byte	0
 8511 04e3 4E       		.byte	78
 8512 04e4 00       		.byte	0
 8513 04e5 4E       		.byte	78
 8514 04e6 00       		.byte	0
 8515 04e7 30       		.byte	48
 8516 04e8 01       		.byte	1
 8517 04e9 00       		.byte	0
 8518 04ea 00       		.byte	0
 8519 04eb 00000000 		.space	5
 8519      00
 8520 04f0 04       		.byte	4
 8521 04f1 00       		.byte	0
 8522 04f2 01       		.byte	1
 8523 04f3 00       		.byte	0
 8524 04f4 00       		.byte	0
 8525 04f5 00       		.byte	0
 8526 04f6 00       		.byte	0
 8527 04f7 01       		.byte	1
 8528 04f8 00       		.byte	0
 8529 04f9 03       		.byte	3
 8530 04fa 00       		.byte	0
 8531 04fb 00       		.byte	0
 8532 04fc 00       		.byte	0
 8533 04fd 00       		.byte	0
 8534 04fe 00       		.byte	0
 8535 04ff 30       		.byte	48
 8536 0500 01       		.byte	1
 8537 0501 00       		.byte	0
 8538 0502 00       		.byte	0
 8539 0503 00000000 		.space	5
 8539      00
 8540 0508 05       		.byte	5
 8541 0509 00       		.byte	0
 8542 050a 02       		.byte	2
 8543 050b 00       		.byte	0
 8544 050c 00       		.byte	0
 8545 050d FF       		.byte	-1
 8546 050e 00       		.byte	0
 8547 050f 01       		.byte	1
 8548 0510 00       		.byte	0
 8549 0511 03       		.byte	3
 8550 0512 00       		.byte	0
 8551 0513 01       		.byte	1
 8552 0514 00       		.byte	0
 8553 0515 00       		.byte	0
 8554 0516 00       		.byte	0
 8555 0517 30       		.byte	48
 8556 0518 01       		.byte	1
 8557 0519 01       		.byte	1
 8558 051a 00       		.byte	0
 8559 051b 00000000 		.space	5
 8559      00
 8560 0520 06       		.byte	6
 8561 0521 00       		.byte	0
 8562 0522 02       		.byte	2
 8563 0523 00       		.byte	0
 8564 0524 00       		.byte	0
 8565 0525 00       		.byte	0
 8566 0526 00       		.byte	0
 8567 0527 00       		.byte	0
 8568 0528 00       		.byte	0
 8569 0529 03       		.byte	3
 8570 052a 00       		.byte	0
 8571 052b 00       		.byte	0
 8572 052c 00       		.byte	0
 8573 052d 00       		.byte	0
 8574 052e 00       		.byte	0
 8575 052f 30       		.byte	48
 8576 0530 01       		.byte	1
 8577 0531 01       		.byte	1
 8578 0532 00       		.byte	0
 8579 0533 00000000 		.space	5
 8579      00
 8580 0538 23       		.byte	35
 8581 0539 00       		.byte	0
 8582 053a 02       		.byte	2
 8583 053b 00       		.byte	0
 8584 053c 00       		.byte	0
 8585 053d 30       		.byte	48
 8586 053e 00       		.byte	0
 8587 053f 01       		.byte	1
 8588 0540 00       		.byte	0
 8589 0541 03       		.byte	3
 8590 0542 0A       		.byte	10
 8591 0543 00       		.byte	0
 8592 0544 00       		.byte	0
 8593 0545 0A       		.byte	10
 8594 0546 00       		.byte	0
 8595 0547 30       		.byte	48
 8596 0548 01       		.byte	1
 8597 0549 01       		.byte	1
 8598 054a 00       		.byte	0
 8599 054b 00000000 		.space	5
 8599      00
 8600 0550 08       		.byte	8
 8601 0551 00       		.byte	0
 8602 0552 01       		.byte	1
 8603 0553 00       		.byte	0
 8604 0554 00       		.byte	0
 8605 0555 7F       		.byte	127
 8606 0556 00       		.byte	0
 8607 0557 01       		.byte	1
 8608 0558 00       		.byte	0
 8609 0559 03       		.byte	3
 8610 055a 00       		.byte	0
 8611 055b 00       		.byte	0
 8612 055c 00       		.byte	0
 8613 055d 00       		.byte	0
 8614 055e 00       		.byte	0
 8615 055f 30       		.byte	48
 8616 0560 01       		.byte	1
 8617 0561 00       		.byte	0
 8618 0562 00       		.byte	0
 8619 0563 00000000 		.space	5
 8619      00
 8620 0568 09       		.byte	9
 8621 0569 00       		.byte	0
 8622 056a 02       		.byte	2
 8623 056b 00       		.byte	0
 8624 056c 00       		.byte	0
 8625 056d 05       		.byte	5
 8626 056e 00       		.byte	0
 8627 056f 01       		.byte	1
 8628 0570 00       		.byte	0
 8629 0571 03       		.byte	3
 8630 0572 00       		.byte	0
 8631 0573 00       		.byte	0
 8632 0574 00       		.byte	0
 8633 0575 00       		.byte	0
 8634 0576 00       		.byte	0
 8635 0577 30       		.byte	48
 8636 0578 01       		.byte	1
 8637 0579 00       		.byte	0
 8638 057a 00       		.byte	0
 8639 057b 00000000 		.space	5
 8639      00
 8640 0580 10       		.byte	16
 8641 0581 00       		.byte	0
 8642 0582 03       		.byte	3
 8643 0583 00       		.byte	0
 8644 0584 00       		.byte	0
 8645 0585 00       		.byte	0
 8646 0586 00       		.byte	0
 8647 0587 00       		.byte	0
 8648 0588 00       		.byte	0
 8649 0589 03       		.byte	3
 8650 058a 00       		.byte	0
 8651 058b 00       		.byte	0
 8652 058c 00       		.byte	0
 8653 058d 00       		.byte	0
 8654 058e 00       		.byte	0
 8655 058f 30       		.byte	48
 8656 0590 01       		.byte	1
 8657 0591 00       		.byte	0
 8658 0592 00       		.byte	0
 8659 0593 00000000 		.space	5
 8659      00
 8660 0598 00       		.byte	0
 8661 0599 00       		.byte	0
 8662 059a 02       		.byte	2
 8663 059b 00       		.byte	0
 8664 059c 00       		.byte	0
 8665 059d 40       		.byte	64
 8666 059e 00       		.byte	0
 8667 059f 01       		.byte	1
 8668 05a0 00       		.byte	0
 8669 05a1 03       		.byte	3
 8670 05a2 00       		.byte	0
 8671 05a3 0F       		.byte	15
 8672 05a4 11       		.byte	17
 8673 05a5 00       		.byte	0
 8674 05a6 00       		.byte	0
 8675 05a7 30       		.byte	48
 8676 05a8 01       		.byte	1
 8677 05a9 00       		.byte	0
 8678 05aa 00       		.byte	0
 8679 05ab 00000000 		.space	5
 8679      00
 8680 05b0 00       		.byte	0
 8681 05b1 00       		.byte	0
 8682 05b2 02       		.byte	2
 8683 05b3 00       		.byte	0
 8684 05b4 00       		.byte	0
 8685 05b5 64       		.byte	100
 8686 05b6 00       		.byte	0
 8687 05b7 01       		.byte	1
 8688 05b8 00       		.byte	0
 8689 05b9 03       		.byte	3
 8690 05ba 00       		.byte	0
 8691 05bb 00       		.byte	0
 8692 05bc 00       		.byte	0
 8693 05bd 00       		.byte	0
 8694 05be 00       		.byte	0
 8695 05bf 30       		.byte	48
 8696 05c0 01       		.byte	1
 8697 05c1 00       		.byte	0
 8698 05c2 00       		.byte	0
 8699 05c3 00000000 		.space	5
 8699      00
 8700 05c8 00       		.byte	0
 8701 05c9 00       		.byte	0
 8702 05ca 02       		.byte	2
 8703 05cb 00       		.byte	0
 8704 05cc 00       		.byte	0
 8705 05cd 64       		.byte	100
 8706 05ce 00       		.byte	0
 8707 05cf 01       		.byte	1
 8708 05d0 00       		.byte	0
 8709 05d1 03       		.byte	3
 8710 05d2 00       		.byte	0
 8711 05d3 00       		.byte	0
 8712 05d4 00       		.byte	0
 8713 05d5 00       		.byte	0
 8714 05d6 00       		.byte	0
 8715 05d7 30       		.byte	48
 8716 05d8 01       		.byte	1
 8717 05d9 00       		.byte	0
 8718 05da 00       		.byte	0
 8719 05db 00000000 		.space	5
 8719      00
 8720 05e0 00       		.byte	0
 8721 05e1 00       		.byte	0
 8722 05e2 02       		.byte	2
 8723 05e3 00       		.byte	0
 8724 05e4 00       		.byte	0
 8725 05e5 64       		.byte	100
 8726 05e6 00       		.byte	0
 8727 05e7 01       		.byte	1
 8728 05e8 00       		.byte	0
 8729 05e9 03       		.byte	3
 8730 05ea 00       		.byte	0
 8731 05eb 00       		.byte	0
 8732 05ec 00       		.byte	0
 8733 05ed 00       		.byte	0
 8734 05ee 00       		.byte	0
 8735 05ef 30       		.byte	48
 8736 05f0 01       		.byte	1
 8737 05f1 00       		.byte	0
 8738 05f2 00       		.byte	0
 8739 05f3 00000000 		.space	5
 8739      00
 8740 05f8 00       		.byte	0
 8741 05f9 00       		.byte	0
 8742 05fa 02       		.byte	2
 8743 05fb 00       		.byte	0
 8744 05fc 00       		.byte	0
 8745 05fd 64       		.byte	100
 8746 05fe 00       		.byte	0
 8747 05ff 01       		.byte	1
 8748 0600 00       		.byte	0
 8749 0601 03       		.byte	3
 8750 0602 00       		.byte	0
 8751 0603 00       		.byte	0
 8752 0604 00       		.byte	0
 8753 0605 00       		.byte	0
 8754 0606 00       		.byte	0
 8755 0607 30       		.byte	48
 8756 0608 01       		.byte	1
 8757 0609 00       		.byte	0
 8758 060a 00       		.byte	0
 8759 060b 00000000 		.space	5
 8759      00
 8762              	WDRflag:
 8763 0610 01000000 		.word	1
 8766              	glProbeCtrl:
 8767 0614 00       		.byte	0
 8768 0615 00       		.byte	0
 8769 0616 01       		.byte	1
 8770 0617 01       		.byte	1
 8771 0618 15       		.byte	21
 8772 0619 16       		.byte	22
 8773 061a 05       		.byte	5
 8774 061b 00       		.byte	0
 8775 061c 00       		.byte	0
 8776 061d 00       		.byte	0
 8777 061e 00       		.byte	0
 8778 061f 00       		.byte	0
 8779 0620 00       		.byte	0
 8780 0621 00       		.byte	0
 8781 0622 00       		.byte	0
 8782 0623 00       		.byte	0
 8783 0624 00       		.byte	0
 8784 0625 00       		.byte	0
 8785 0626 00       		.byte	0
 8786 0627 48       		.byte	72
 8787 0628 3F       		.byte	63
 8788 0629 00       		.byte	0
 8789 062a 00       		.byte	0
 8790 062b 40       		.byte	64
 8791 062c 00       		.byte	0
 8792 062d 00       		.byte	0
 8793 062e 0000     		.space	2
 8796              	glProbeCtrl20:
 8797 0630 00       		.byte	0
 8798 0631 00       		.byte	0
 8799 0632 01       		.byte	1
 8800 0633 01       		.byte	1
 8801 0634 80       		.byte	-128
 8802 0635 1A       		.byte	26
 8803 0636 06       		.byte	6
 8804 0637 00       		.byte	0
 8805 0638 00       		.byte	0
 8806 0639 00       		.byte	0
 8807 063a 00       		.byte	0
 8808 063b 00       		.byte	0
 8809 063c 00       		.byte	0
 8810 063d 00       		.byte	0
 8811 063e 00       		.byte	0
 8812 063f 00       		.byte	0
 8813 0640 00       		.byte	0
 8814 0641 00       		.byte	0
 8815 0642 00       		.byte	0
 8816 0643 D2       		.byte	-46
 8817 0644 0F       		.byte	15
 8818 0645 00       		.byte	0
 8819 0646 00       		.byte	0
 8820 0647 40       		.byte	64
 8821 0648 00       		.byte	0
 8822 0649 00       		.byte	0
 8823 064a 0000     		.space	2
 8826              	glProbeStilCtrl:
 8827 064c 01       		.byte	1
 8828 064d 01       		.byte	1
 8829 064e 00       		.byte	0
 8830 064f 00       		.byte	0
 8831 0650 48       		.byte	72
 8832 0651 3F       		.byte	63
 8833 0652 00       		.byte	0
 8834 0653 00       		.byte	0
 8835 0654 40       		.byte	64
 8836 0655 00       		.byte	0
 8837 0656 00       		.byte	0
 8838 0657 00       		.space	1
 8841              	glProbeStilCtrl20:
 8842 0658 01       		.byte	1
 8843 0659 01       		.byte	1
 8844 065a 00       		.byte	0
 8845 065b 00       		.byte	0
 8846 065c D2       		.byte	-46
 8847 065d 0F       		.byte	15
 8848 065e 00       		.byte	0
 8849 065f 00       		.byte	0
 8850 0660 40       		.byte	64
 8851 0661 00       		.byte	0
 8852 0662 00       		.byte	0
 8855              	snapButFlag:
 8856 0663 01       		.byte	1
 8859              	CyFxGpifTransition:
 8860 0664 0000     		.short	0
 8861 0666 5555     		.short	21845
 8862 0668 8888     		.short	-30584
 8863 066a AAAA     		.short	-21846
 8864 066c 3333     		.short	13107
 8865 066e 0000     		.space	2
 8868              	CyFxGpifWavedata:
 8869 0670 0181731E 		.word	510886145
 8870 0674 00000000 		.word	0
 8871 0678 00000080 		.word	-2147483648
 8872 067c 00000000 		.word	0
 8873 0680 00000000 		.word	0
 8874 0684 00000000 		.word	0
 8875 0688 0201702E 		.word	779092226
 8876 068c 00010000 		.word	256
 8877 0690 A0000080 		.word	-2147483488
 8878 0694 00000000 		.word	0
 8879 0698 00000000 		.word	0
 8880 069c 00000000 		.word	0
 8881 06a0 0380722E 		.word	779255811
 8882 06a4 02010020 		.word	536871170
 8883 06a8 60000080 		.word	-2147483552
 8884 06ac 00000000 		.word	0
 8885 06b0 00000000 		.word	0
 8886 06b4 00000000 		.word	0
 8887 06b8 0460722E 		.word	779247620
 8888 06bc 02010024 		.word	603980034
 8889 06c0 90000080 		.word	-2147483504
 8890 06c4 0594731E 		.word	510891013
 8891 06c8 06000000 		.word	6
 8892 06cc 00000080 		.word	-2147483648
 8893 06d0 0380722E 		.word	779255811
 8894 06d4 02010020 		.word	536871170
 8895 06d8 60000080 		.word	-2147483552
 8896 06dc 0693731E 		.word	510890758
 8897 06e0 06000000 		.word	6
 8898 06e4 00000080 		.word	-2147483648
 8899 06e8 0720703E 		.word	1047535623
 8900 06ec 08010000 		.word	264
 8901 06f0 00000080 		.word	-2147483648
 8902 06f4 0820703E 		.word	1047535624
 8903 06f8 08010000 		.word	264
 8904 06fc 00000080 		.word	-2147483648
 8905 0700 0920703E 		.word	1047535625
 8906 0704 08010000 		.word	264
 8907 0708 00000080 		.word	-2147483648
 8908 070c 0A20703E 		.word	1047535626
 8909 0710 08010000 		.word	264
 8910 0714 00000080 		.word	-2147483648
 8911 0718 0380722E 		.word	779255811
 8912 071c 02010020 		.word	536871170
 8913 0720 60000080 		.word	-2147483552
 8914 0724 0B000000 		.word	11
 8915 0728 00000000 		.word	0
 8916 072c 00010080 		.word	-2147483392
 8917 0730 0460722E 		.word	779247620
 8918 0734 02010024 		.word	603980034
 8919 0738 90000080 		.word	-2147483504
 8920 073c 0D000000 		.word	13
 8921 0740 00000000 		.word	0
 8922 0744 00010080 		.word	-2147483392
 8923 0748 0460722E 		.word	779247620
 8924 074c 02010024 		.word	603980034
 8925 0750 90000080 		.word	-2147483504
 8926 0754 0C000000 		.word	12
 8927 0758 00000000 		.word	0
 8928 075c 00010080 		.word	-2147483392
 8929 0760 0380722E 		.word	779255811
 8930 0764 02010020 		.word	536871170
 8931 0768 60000080 		.word	-2147483552
 8932 076c 0E000000 		.word	14
 8933 0770 00000000 		.word	0
 8934 0774 00010080 		.word	-2147483392
 8935 0778 00000000 		.word	0
 8936 077c 00000000 		.word	0
 8937 0780 00000000 		.word	0
 8938 0784 00000000 		.word	0
 8939 0788 00000000 		.word	0
 8940 078c 00000000 		.word	0
 8943              	CyFxGpifWavedataPosition:
 8944 0790 00       		.byte	0
 8945 0791 01       		.byte	1
 8946 0792 02       		.byte	2
 8947 0793 03       		.byte	3
 8948 0794 04       		.byte	4
 8949 0795 05       		.byte	5
 8950 0796 06       		.byte	6
 8951 0797 07       		.byte	7
 8952 0798 08       		.byte	8
 8953 0799 09       		.byte	9
 8954 079a 0A       		.byte	10
 8955 079b 0B       		.byte	11
 8956 079c 0B       		.byte	11
 8957 079d 0B       		.byte	11
 8958 079e 0B       		.byte	11
 8959 079f 00       		.space	1
 8962              	CyFxGpifRegValue:
 8963 07a0 08830080 		.word	-2147450104
 8964 07a4 67000000 		.word	103
 8965 07a8 00000000 		.word	0
 8966 07ac 46000000 		.word	70
 8967 07b0 00000000 		.word	0
 8968 07b4 00000000 		.word	0
 8969 07b8 02000000 		.word	2
 8970 07bc 82000000 		.word	130
 8971 07c0 82070000 		.word	1922
 8972 07c4 40040000 		.word	1088
 8973 07c8 FCFF0000 		.word	65532
 8974 07cc 28000000 		.word	40
 8975 07d0 00000000 		.word	0
 8976 07d4 00000000 		.word	0
 8977 07d8 00000000 		.word	0
 8978 07dc 00000000 		.word	0
 8979 07e0 01000000 		.word	1
 8980 07e4 00000000 		.word	0
 8981 07e8 00000000 		.word	0
 8982 07ec 00000000 		.word	0
 8983 07f0 00000000 		.word	0
 8984 07f4 00000000 		.word	0
 8985 07f8 00000000 		.word	0
 8986 07fc 00000000 		.word	0
 8987 0800 00000000 		.word	0
 8988 0804 00000000 		.word	0
 8989 0808 00000000 		.word	0
 8990 080c 00000000 		.word	0
 8991 0810 00000000 		.word	0
 8992 0814 06000000 		.word	6
 8993 0818 00000000 		.word	0
 8994 081c FFFF0000 		.word	65535
 8995 0820 09010000 		.word	265
 8996 0824 00000000 		.word	0
 8997 0828 F71F0000 		.word	8183
 8998 082c 00000000 		.word	0
 8999 0830 FFFF0000 		.word	65535
 9000 0834 09010000 		.word	265
 9001 0838 00000000 		.word	0
 9002 083c F71F0000 		.word	8183
 9003 0840 00000000 		.word	0
 9004 0844 00000000 		.word	0
 9005 0848 00000000 		.word	0
 9006 084c 00000000 		.word	0
 9007 0850 00000000 		.word	0
 9008 0854 00000000 		.word	0
 9009 0858 00000000 		.word	0
 9010 085c 00000000 		.word	0
 9011 0860 00000000 		.word	0
 9012 0864 00000000 		.word	0
 9013 0868 00000000 		.word	0
 9014 086c 00000000 		.word	0
 9015 0870 00000000 		.word	0
 9016 0874 00000000 		.word	0
 9017 0878 00000000 		.word	0
 9018 087c 00000000 		.word	0
 9019 0880 00000000 		.word	0
 9020 0884 00000000 		.word	0
 9021 0888 00000000 		.word	0
 9022 088c 00000000 		.word	0
 9023 0890 00000000 		.word	0
 9024 0894 00000000 		.word	0
 9025 0898 00000000 		.word	0
 9026 089c 00040180 		.word	-2147417088
 9027 08a0 01040180 		.word	-2147417087
 9028 08a4 02040180 		.word	-2147417086
 9029 08a8 03040180 		.word	-2147417085
 9030 08ac 00000000 		.word	0
 9031 08b0 00000000 		.word	0
 9032 08b4 00000000 		.word	0
 9033 08b8 00000000 		.word	0
 9034 08bc 00000000 		.word	0
 9035 08c0 00000000 		.word	0
 9036 08c4 00000000 		.word	0
 9037 08c8 00000000 		.word	0
 9038 08cc C1FFFFFF 		.word	-63
 9041              	CyFxGpifTransition_usb2:
 9042 08d0 0000     		.short	0
 9043 08d2 5555     		.short	21845
 9044 08d4 AAAA     		.short	-21846
 9045 08d6 8888     		.short	-30584
 9046 08d8 1111     		.short	4369
 9047 08da 4444     		.short	17476
 9048 08dc 3333     		.short	13107
 9049 08de CCCC     		.short	-13108
 9052              	CyFxGpifWavedata_usb2:
 9053 08e0 0181731E 		.word	510886145
 9054 08e4 00000000 		.word	0
 9055 08e8 00000080 		.word	-2147483648
 9056 08ec 00000000 		.word	0
 9057 08f0 00000000 		.word	0
 9058 08f4 00000000 		.word	0
 9059 08f8 0201703E 		.word	1047527682
 9060 08fc 00010000 		.word	256
 9061 0900 A00000C0 		.word	-1073741664
 9062 0904 00000000 		.word	0
 9063 0908 00000000 		.word	0
 9064 090c 00000000 		.word	0
 9065 0910 0394731E 		.word	510891011
 9066 0914 04000020 		.word	536870916
 9067 0918 60004080 		.word	-2143289248
 9068 091c 00000000 		.word	0
 9069 0920 00000000 		.word	0
 9070 0924 00000000 		.word	0
 9071 0928 0620702E 		.word	779100166
 9072 092c 0C000000 		.word	12
 9073 0930 00000080 		.word	-2147483648
 9074 0934 0620702E 		.word	779100166
 9075 0938 0C000000 		.word	12
 9076 093c 00000080 		.word	-2147483648
 9077 0940 0394731E 		.word	510891011
 9078 0944 04000020 		.word	536870916
 9079 0948 60004080 		.word	-2143289248
 9080 094c 0620702E 		.word	779100166
 9081 0950 0C000000 		.word	12
 9082 0954 00000080 		.word	-2147483648
 9083 0958 0C93731E 		.word	510890764
 9084 095c 04000024 		.word	603979780
 9085 0960 90004080 		.word	-2143289200
 9086 0964 0D20702E 		.word	779100173
 9087 0968 0C000000 		.word	12
 9088 096c 00000080 		.word	-2147483648
 9089 0970 0780724E 		.word	1316126727
 9090 0974 0A000000 		.word	10
 9091 0978 00000080 		.word	-2147483648
 9092 097c 08000000 		.word	8
 9093 0980 00000000 		.word	0
 9094 0984 00010080 		.word	-2147483392
 9095 0988 0920702E 		.word	779100169
 9096 098c 0C010000 		.word	268
 9097 0990 00000080 		.word	-2147483648
 9098 0994 0A01701E 		.word	510656778
 9099 0998 0E000100 		.word	65550
 9100 099c 00000080 		.word	-2147483648
 9101 09a0 00000000 		.word	0
 9102 09a4 00000000 		.word	0
 9103 09a8 00000000 		.word	0
 9104 09ac 00000000 		.word	0
 9105 09b0 00000000 		.word	0
 9106 09b4 00000000 		.word	0
 9107 09b8 0394731E 		.word	510891011
 9108 09bc 04000020 		.word	536870916
 9109 09c0 60004080 		.word	-2143289248
 9110 09c4 08000000 		.word	8
 9111 09c8 00000000 		.word	0
 9112 09cc 00010080 		.word	-2147483392
 9113 09d0 0B000000 		.word	11
 9114 09d4 00000000 		.word	0
 9115 09d8 00010080 		.word	-2147483392
 9116 09dc 0C93731E 		.word	510890764
 9117 09e0 04000024 		.word	603979780
 9118 09e4 90004080 		.word	-2143289200
 9119 09e8 0D20702E 		.word	779100173
 9120 09ec 0C000000 		.word	12
 9121 09f0 00000080 		.word	-2147483648
 9122 09f4 0D20702E 		.word	779100173
 9123 09f8 0C000000 		.word	12
 9124 09fc 00000080 		.word	-2147483648
 9125 0a00 0E60724E 		.word	1316118542
 9126 0a04 0A000000 		.word	10
 9127 0a08 00000080 		.word	-2147483648
 9128 0a0c 0F000000 		.word	15
 9129 0a10 00000000 		.word	0
 9130 0a14 00010080 		.word	-2147483392
 9131 0a18 1020702E 		.word	779100176
 9132 0a1c 0C010000 		.word	268
 9133 0a20 00000080 		.word	-2147483648
 9134 0a24 1101701E 		.word	510656785
 9135 0a28 0E000100 		.word	65550
 9136 0a2c 00000080 		.word	-2147483648
 9137 0a30 0C93731E 		.word	510890764
 9138 0a34 04000024 		.word	603979780
 9139 0a38 90004080 		.word	-2143289200
 9140 0a3c 0F000000 		.word	15
 9141 0a40 00000000 		.word	0
 9142 0a44 00010080 		.word	-2147483392
 9143 0a48 12000000 		.word	18
 9144 0a4c 00000000 		.word	0
 9145 0a50 00010080 		.word	-2147483392
 9146 0a54 0394731E 		.word	510891011
 9147 0a58 04000020 		.word	536870916
 9148 0a5c 60004080 		.word	-2143289248
 9149 0a60 0480732E 		.word	779321348
 9150 0a64 02010000 		.word	258
 9151 0a68 000040C0 		.word	-1069547520
 9152 0a6c 0580732E 		.word	779321349
 9153 0a70 02010000 		.word	258
 9154 0a74 000040C0 		.word	-1069547520
 9155 0a78 0580732E 		.word	779321349
 9156 0a7c 02010000 		.word	258
 9157 0a80 000040C0 		.word	-1069547520
 9158 0a84 0480732E 		.word	779321348
 9159 0a88 02010000 		.word	258
 9160 0a8c 000040C0 		.word	-1069547520
 9163              	CyFxGpifWavedataPosition_usb2:
 9164 0a90 00       		.byte	0
 9165 0a91 01       		.byte	1
 9166 0a92 02       		.byte	2
 9167 0a93 03       		.byte	3
 9168 0a94 04       		.byte	4
 9169 0a95 05       		.byte	5
 9170 0a96 06       		.byte	6
 9171 0a97 07       		.byte	7
 9172 0a98 08       		.byte	8
 9173 0a99 09       		.byte	9
 9174 0a9a 0A       		.byte	10
 9175 0a9b 08       		.byte	8
 9176 0a9c 0B       		.byte	11
 9177 0a9d 0C       		.byte	12
 9178 0a9e 0D       		.byte	13
 9179 0a9f 08       		.byte	8
 9180 0aa0 0E       		.byte	14
 9181 0aa1 0F       		.byte	15
 9182 0aa2 08       		.byte	8
 9183 0aa3 08       		.byte	8
 9184 0aa4 08       		.byte	8
 9185 0aa5 08       		.byte	8
 9186 0aa6 08       		.byte	8
 9187 0aa7 08       		.byte	8
 9188 0aa8 08       		.byte	8
 9189 0aa9 08       		.byte	8
 9190 0aaa 08       		.byte	8
 9191 0aab 08       		.byte	8
 9192 0aac 08       		.byte	8
 9193 0aad 08       		.byte	8
 9194 0aae 08       		.byte	8
 9195 0aaf 08       		.byte	8
 9196 0ab0 08       		.byte	8
 9197 0ab1 08       		.byte	8
 9198 0ab2 08       		.byte	8
 9199 0ab3 08       		.byte	8
 9200 0ab4 08       		.byte	8
 9201 0ab5 08       		.byte	8
 9202 0ab6 08       		.byte	8
 9203 0ab7 08       		.byte	8
 9204 0ab8 08       		.byte	8
 9205 0ab9 08       		.byte	8
 9206 0aba 08       		.byte	8
 9207 0abb 08       		.byte	8
 9208 0abc 08       		.byte	8
 9209 0abd 08       		.byte	8
 9210 0abe 08       		.byte	8
 9211 0abf 08       		.byte	8
 9212 0ac0 08       		.byte	8
 9213 0ac1 08       		.byte	8
 9214 0ac2 08       		.byte	8
 9215 0ac3 08       		.byte	8
 9216 0ac4 08       		.byte	8
 9217 0ac5 08       		.byte	8
 9218 0ac6 08       		.byte	8
 9219 0ac7 08       		.byte	8
 9220 0ac8 08       		.byte	8
 9221 0ac9 08       		.byte	8
 9222 0aca 08       		.byte	8
 9223 0acb 08       		.byte	8
 9224 0acc 08       		.byte	8
 9225 0acd 08       		.byte	8
 9226 0ace 08       		.byte	8
 9227 0acf 08       		.byte	8
 9228 0ad0 08       		.byte	8
 9229 0ad1 08       		.byte	8
 9230 0ad2 08       		.byte	8
 9231 0ad3 08       		.byte	8
 9232 0ad4 08       		.byte	8
 9233 0ad5 08       		.byte	8
 9234 0ad6 08       		.byte	8
 9235 0ad7 08       		.byte	8
 9236 0ad8 08       		.byte	8
 9237 0ad9 08       		.byte	8
 9238 0ada 08       		.byte	8
 9239 0adb 08       		.byte	8
 9240 0adc 08       		.byte	8
 9241 0add 08       		.byte	8
 9242 0ade 08       		.byte	8
 9243 0adf 08       		.byte	8
 9244 0ae0 08       		.byte	8
 9245 0ae1 08       		.byte	8
 9246 0ae2 08       		.byte	8
 9247 0ae3 08       		.byte	8
 9248 0ae4 08       		.byte	8
 9249 0ae5 08       		.byte	8
 9250 0ae6 08       		.byte	8
 9251 0ae7 08       		.byte	8
 9252 0ae8 08       		.byte	8
 9253 0ae9 08       		.byte	8
 9254 0aea 08       		.byte	8
 9255 0aeb 08       		.byte	8
 9256 0aec 08       		.byte	8
 9257 0aed 08       		.byte	8
 9258 0aee 08       		.byte	8
 9259 0aef 08       		.byte	8
 9260 0af0 08       		.byte	8
 9261 0af1 08       		.byte	8
 9262 0af2 08       		.byte	8
 9263 0af3 08       		.byte	8
 9264 0af4 08       		.byte	8
 9265 0af5 08       		.byte	8
 9266 0af6 08       		.byte	8
 9267 0af7 08       		.byte	8
 9268 0af8 08       		.byte	8
 9269 0af9 08       		.byte	8
 9270 0afa 08       		.byte	8
 9271 0afb 08       		.byte	8
 9272 0afc 08       		.byte	8
 9273 0afd 08       		.byte	8
 9274 0afe 08       		.byte	8
 9275 0aff 08       		.byte	8
 9276 0b00 08       		.byte	8
 9277 0b01 08       		.byte	8
 9278 0b02 08       		.byte	8
 9279 0b03 08       		.byte	8
 9280 0b04 08       		.byte	8
 9281 0b05 08       		.byte	8
 9282 0b06 08       		.byte	8
 9283 0b07 08       		.byte	8
 9284 0b08 08       		.byte	8
 9285 0b09 08       		.byte	8
 9286 0b0a 08       		.byte	8
 9287 0b0b 08       		.byte	8
 9288 0b0c 08       		.byte	8
 9289 0b0d 08       		.byte	8
 9290 0b0e 08       		.byte	8
 9291 0b0f 08       		.byte	8
 9292 0b10 00       		.byte	0
 9293 0b11 01       		.byte	1
 9294 0b12 02       		.byte	2
 9295 0b13 10       		.byte	16
 9296 0b14 04       		.byte	4
 9297 0b15 05       		.byte	5
 9298 0b16 06       		.byte	6
 9299 0b17 07       		.byte	7
 9300 0b18 08       		.byte	8
 9301 0b19 09       		.byte	9
 9302 0b1a 0A       		.byte	10
 9303 0b1b 08       		.byte	8
 9304 0b1c 11       		.byte	17
 9305 0b1d 0C       		.byte	12
 9306 0b1e 0D       		.byte	13
 9307 0b1f 08       		.byte	8
 9308 0b20 0E       		.byte	14
 9309 0b21 0F       		.byte	15
 9310 0b22 08       		.byte	8
 9311 0b23 00       		.space	1
 9314              	CyFxGpifRegValue_usb2:
 9315 0b24 08830080 		.word	-2147450104
 9316 0b28 67000000 		.word	103
 9317 0b2c 01000000 		.word	1
 9318 0b30 46000000 		.word	70
 9319 0b34 00000000 		.word	0
 9320 0b38 00000000 		.word	0
 9321 0b3c 02000000 		.word	2
 9322 0b40 82000000 		.word	130
 9323 0b44 82070000 		.word	1922
 9324 0b48 40040000 		.word	1088
 9325 0b4c FCFF0000 		.word	65532
 9326 0b50 28000000 		.word	40
 9327 0b54 00000000 		.word	0
 9328 0b58 00000000 		.word	0
 9329 0b5c 00000000 		.word	0
 9330 0b60 00000000 		.word	0
 9331 0b64 01000000 		.word	1
 9332 0b68 00000000 		.word	0
 9333 0b6c 00000000 		.word	0
 9334 0b70 00000000 		.word	0
 9335 0b74 00000000 		.word	0
 9336 0b78 00000000 		.word	0
 9337 0b7c 00000000 		.word	0
 9338 0b80 00000000 		.word	0
 9339 0b84 00000000 		.word	0
 9340 0b88 00000000 		.word	0
 9341 0b8c 00000000 		.word	0
 9342 0b90 00000000 		.word	0
 9343 0b94 00000000 		.word	0
 9344 0b98 06000000 		.word	6
 9345 0b9c 00000000 		.word	0
 9346 0ba0 FFFF0000 		.word	65535
 9347 0ba4 09010000 		.word	265
 9348 0ba8 00000000 		.word	0
 9349 0bac F71F0000 		.word	8183
 9350 0bb0 00000000 		.word	0
 9351 0bb4 FFFF0000 		.word	65535
 9352 0bb8 09010000 		.word	265
 9353 0bbc 00000000 		.word	0
 9354 0bc0 F71F0000 		.word	8183
 9355 0bc4 00000000 		.word	0
 9356 0bc8 00000000 		.word	0
 9357 0bcc 00000000 		.word	0
 9358 0bd0 00000000 		.word	0
 9359 0bd4 00000000 		.word	0
 9360 0bd8 00000000 		.word	0
 9361 0bdc 00000000 		.word	0
 9362 0be0 00000000 		.word	0
 9363 0be4 00000000 		.word	0
 9364 0be8 00000000 		.word	0
 9365 0bec 00000000 		.word	0
 9366 0bf0 00000000 		.word	0
 9367 0bf4 00000000 		.word	0
 9368 0bf8 00000000 		.word	0
 9369 0bfc 00000000 		.word	0
 9370 0c00 00000000 		.word	0
 9371 0c04 00000000 		.word	0
 9372 0c08 00000000 		.word	0
 9373 0c0c 00000000 		.word	0
 9374 0c10 00000000 		.word	0
 9375 0c14 00000000 		.word	0
 9376 0c18 00000000 		.word	0
 9377 0c1c 00000000 		.word	0
 9378 0c20 00040180 		.word	-2147417088
 9379 0c24 01040180 		.word	-2147417087
 9380 0c28 02040180 		.word	-2147417086
 9381 0c2c 03040180 		.word	-2147417085
 9382 0c30 00000000 		.word	0
 9383 0c34 00000000 		.word	0
 9384 0c38 00000000 		.word	0
 9385 0c3c 00000000 		.word	0
 9386 0c40 00000000 		.word	0
 9387 0c44 00000000 		.word	0
 9388 0c48 00000000 		.word	0
 9389 0c4c 00000000 		.word	0
 9390 0c50 C1FFFFFF 		.word	-63
 9391              		.section	.rodata.str1.4,"aMS",%progbits,1
 9392              		.align	2
 9393              	.LC0:
 9394 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9394      7065722D 
 9394      74696D65 
 9394      72202564 
 9394      0D0A00
 9395 0013 00       		.space	1
 9396              	.LC1:
 9397 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9397      636F6D6D 
 9397      616E6420 
 9397      71756575 
 9397      65206973 
 9398 0037 00       		.space	1
 9399              	.LC2:
 9400 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9400      7220696E 
 9400      206D756C 
 9400      74696368 
 9400      616E6E65 
 9401 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 9401      2C20646D 
 9401      61446F6E 
 9401      65202578 
 9401      0D0A00
 9402 007e 0000     		.space	2
 9403              	.LC3:
 9404 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9404      5420656E 
 9404      636F756E 
 9404      74657265 
 9404      642E2E2E 
 9405              	.LC4:
 9406 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9406      454E4420 
 9406      656E636F 
 9406      756E7465 
 9406      7265642E 
 9407 00c2 0000     		.space	2
 9408              	.LC5:
 9409 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9409      64697363 
 9409      6F6E6E65 
 9409      63746564 
 9409      2E2E2E30 
 9410 00e3 00       		.space	1
 9411              	.LC6:
 9412 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9412      43595F46 
 9412      585F5556 
 9412      435F5649 
 9412      44454F5F 
 9413 0117 0A00     		.ascii	"\012\000"
 9414 0119 000000   		.space	3
 9415              	.LC7:
 9416 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9416      43595F46 
 9416      585F5556 
 9416      435F5649 
 9416      44454F5F 
 9417 014f 00       		.ascii	"\000"
 9418              	.LC8:
 9419 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9419      726E6174 
 9419      65207365 
 9419      7474696E 
 9419      6720302E 
 9420              	.LC9:
 9421 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9421      72206665 
 9421      61747572 
 9421      65207265 
 9421      71756573 
 9422 018b 00       		.space	1
 9423              	.LC10:
 9424 018c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9424      6F6D6D69 
 9424      74656F66 
 9424      20737461 
 9424      7465203D 
 9425              	.LC11:
 9426 01a4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9426      6E656C20 
 9426      53657420 
 9426      57726170 
 9426      55702066 
 9427 01d1 000000   		.space	3
 9428              	.LC12:
 9429 01d4 4572726F 		.ascii	"Error handler...\015\012\000"
 9429      72206861 
 9429      6E646C65 
 9429      722E2E2E 
 9429      0D0A00
 9430 01e7 00       		.space	1
 9431              	.LC13:
 9432 01e8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9432      69742045 
 9432      4F462066 
 9432      61696C65 
 9432      64210A00 
 9433              	.LC14:
 9434 01fc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9434      49324320 
 9434      636F6D6D 
 9434      616E6420 
 9434      69732030 
 9435 022f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9435      78257820 
 9435      30782578 
 9435      20307825 
 9435      78203078 
 9436              	.LC15:
 9437 0248 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9437      49324320 
 9437      63757272 
 9437      656E7420 
 9437      64617461 
 9438 027b 64202564 		.ascii	"d %d\015\012\000"
 9438      0D0A00
 9439 0282 0000     		.space	2
 9440              	.LC16:
 9441 0284 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9441      26414743 
 9441      2073656E 
 9441      7420746F 
 9441      20686F73 
 9442 02aa 0000     		.space	2
 9443              	.LC17:
 9444 02ac 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9444      26414743 
 9444      20676F74 
 9444      74656E20 
 9444      66726F6D 
 9445 02d6 0000     		.space	2
 9446              	.LC18:
 9447 02d8 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 9447      6C657665 
 9447      6C2E2025 
 9447      64202564 
 9447      3B202564 
 9448 02f2 0000     		.space	2
 9449              	.LC19:
 9450 02f4 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 9450      7365742E 
 9450      20256420 
 9450      25643B20 
 9450      25642025 
 9451              	.LC20:
 9452 030c 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9452      67657420 
 9452      64617461 
 9452      2066726F 
 9452      6D20686F 
 9453 0339 000000   		.space	3
 9454              	.LC21:
 9455 033c 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9455      52657175 
 9455      65737420 
 9455      30782578 
 9455      20706172 
 9456 036f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9456      6E642074 
 9456      6F20686F 
 9456      73742030 
 9456      78257820 
 9457 038a 0000     		.space	2
 9458              	.LC22:
 9459 038c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9459      204F7020 
 9459      72656365 
 9459      69766573 
 9459      20284354 
 9460 03b3 00       		.space	1
 9461              	.LC23:
 9462 03b4 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9462      756C7420 
 9462      73656C65 
 9462      63746F72 
 9462      20284354 
 9463 03d6 0000     		.space	2
 9464              	.LC24:
 9465 03d8 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9465      756C7420 
 9465      72657175 
 9465      65737420 
 9465      28435429 
 9466 03f9 000000   		.space	3
 9467              	.LC25:
 9468 03fc 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9468      52657175 
 9468      65737420 
 9468      30782578 
 9468      20706172 
 9469 042f 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9469      20307825 
 9469      78202F20 
 9469      73656E64 
 9469      20746F20 
 9470 045c 00       		.ascii	"\000"
 9471 045d 000000   		.space	3
 9472              	.LC26:
 9473 0460 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9473      73706565 
 9473      64203D20 
 9473      25642065 
 9473      76656E66 
 9474 0490 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9474      71756573 
 9474      74203D20 
 9474      30782578 
 9474      20775661 
 9475 04c0 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9475      203D2030 
 9475      78257820 
 9475      6973666C 
 9475      61672030 
 9476 04da 0000     		.space	2
 9477              	.LC27:
 9478 04dc 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9478      64656661 
 9478      756C7420 
 9478      73657475 
 9478      70207265 
 9479              	.LC28:
 9480 0508 54686520 		.ascii	"The host command is not correct for 1080p camera 0x"
 9480      686F7374 
 9480      20636F6D 
 9480      6D616E64 
 9480      20697320 
 9481 053b 25782030 		.ascii	"%x 0x%x %d\015\012\000"
 9481      78257820 
 9481      25640D0A 
 9481      00
 9482              	.LC29:
 9483 0548 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9483      43595F46 
 9483      585F5556 
 9483      435F5354 
 9483      5245414D 
 9484 056e 0000     		.space	2
 9485              	.LC30:
 9486 0570 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9486      55564320 
 9486      7374696C 
 9486      6C207472 
 9486      69676765 
 9487 0596 0000     		.space	2
 9488              	.LC31:
 9489 0598 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9489      7374696C 
 9489      6C207472 
 9489      69676765 
 9489      7220636F 
 9490 05bf 00       		.space	1
 9491              	.LC32:
 9492 05c0 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9492      65642074 
 9492      6F207365 
 9492      6E642069 
 9492      6E746572 
 9493 05f1 0A00     		.ascii	"\012\000"
 9494 05f3 00       		.space	1
 9495              	.LC33:
 9496 05f4 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9496      73657420 
 9496      64656620 
 9496      64617461 
 9496      20307825 
 9497 0613 00       		.space	1
 9498              	.LC34:
 9499 0614 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9499      73657420 
 9499      64656620 
 9499      64617461 
 9499      20307825 
 9500 0647 2E0D0A00 		.ascii	".\015\012\000"
 9501 064b 00       		.space	1
 9502              	.LC35:
 9503 064c 55415254 		.ascii	"UART initialization failed!\012\000"
 9503      20696E69 
 9503      7469616C 
 9503      697A6174 
 9503      696F6E20 
 9504 0669 000000   		.space	3
 9505              	.LC36:
 9506 066c 49324320 		.ascii	"I2C initialization failed!\012\000"
 9506      696E6974 
 9506      69616C69 
 9506      7A617469 
 9506      6F6E2066 
 9507              	.LC37:
 9508 0688 49324320 		.ascii	"I2C configuration failed!\012\000"
 9508      636F6E66 
 9508      69677572 
 9508      6174696F 
 9508      6E206661 
 9509 06a3 00       		.space	1
 9510              	.LC38:
 9511 06a4 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9511      43726561 
 9511      74652045 
 9511      76656E74 
 9511      20666169 
 9512 06ce 0000     		.space	2
 9513              	.LC39:
 9514 06d0 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9514      20496E69 
 9514      74206661 
 9514      696C6564 
 9514      2C204572 
 9515 06f3 00       		.space	1
 9516              	.LC40:
 9517 06f4 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9517      204F7665 
 9517      72726964 
 9517      65206661 
 9517      696C6564 
 9518 071b 00       		.space	1
 9519              	.LC41:
 9520 071c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9520      28323029 
 9520      204F7665 
 9520      72726964 
 9520      65206661 
 9521 0747 00       		.space	1
 9522              	.LC42:
 9523 0748 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9523      28323429 
 9523      204F7665 
 9523      72726964 
 9523      65206661 
 9524 0773 00       		.space	1
 9525              	.LC43:
 9526 0774 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9526      20536574 
 9526      20287265 
 9526      73657420 
 9526      32322920 
 9527 07a6 00       		.ascii	"\000"
 9528 07a7 00       		.space	1
 9529              	.LC44:
 9530 07a8 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9530      20536574 
 9530      2028706F 
 9530      77657220 
 9530      32302920 
 9531 07da 00       		.ascii	"\000"
 9532 07db 00       		.space	1
 9533              	.LC45:
 9534 07dc 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9534      20536574 
 9534      2028736E 
 9534      61702073 
 9534      686F7420 
 9535 080f 25640A00 		.ascii	"%d\012\000"
 9536 0813 00       		.space	1
 9537              	.LC46:
 9538 0814 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9538      46756E63 
 9538      74696F6E 
 9538      20466169 
 9538      6C656420 
 9539 0843 00       		.space	1
 9540              	.LC47:
 9541 0844 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9541      46756E63 
 9541      74696F6E 
 9541      20466169 
 9541      6C656420 
 9542 0873 00       		.space	1
 9543              	.LC48:
 9544 0874 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9544      53657420 
 9544      456E6470 
 9544      6F696E74 
 9544      20636F6E 
 9545 08a4 00       		.ascii	"\000"
 9546 08a5 000000   		.space	3
 9547              	.LC49:
 9548 08a8 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9548      496E7465 
 9548      72727570 
 9548      74205374 
 9548      61747573 
 9549 08db 20436F64 		.ascii	" Code = %d\012\000"
 9549      65203D20 
 9549      25640A00 
 9550 08e7 00       		.space	1
 9551              	.LC50:
 9552 08e8 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9552      65642074 
 9552      6F20616C 
 9552      6C6F6361 
 9552      7465206D 
 9553 091b 65720D0A 		.ascii	"er\015\012\000"
 9553      00
 9554              	.LC51:
 9555 0920 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9555      4368616E 
 9555      6E656C20 
 9555      43726561 
 9555      74696F6E 
 9556 094e 0000     		.space	2
 9557              	.LC52:
 9558 0950 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9558      436F6E6E 
 9558      65637420 
 9558      6661696C 
 9558      65642C20 
 9559 0975 000000   		.space	3
 9560              	.LC53:
 9561 0978 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9561      4368616E 
 9561      6E656C20 
 9561      52657365 
 9561      74204661 
 9562 09a3 00       		.space	1
 9563              	.LC54:
 9564 09a4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9564      4368616E 
 9564      6E656C20 
 9564      53657420 
 9564      5472616E 
 9565 09d5 00       		.ascii	"\000"
 9566 09d6 0000     		.space	2
 9567              	.LC55:
 9568 09d8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9568      4368616E 
 9568      6E656C20 
 9568      53657420 
 9568      5472616E 
 9569 0a09 0A00     		.ascii	"\012\000"
 9570 0a0b 00       		.space	1
 9571              	.LC56:
 9572 0a0c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9572      75706572 
 9572      20677069 
 9572      6600
 9573 0a1a 0000     		.space	2
 9574              	.LC57:
 9575 0a1c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9575      69676820 
 9575      67706966 
 9575      00
 9576 0a29 000000   		.space	3
 9577              	.LC58:
 9578 0a2c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9578      696E6720 
 9578      47504946 
 9578      20436F6E 
 9578      66696775 
 9579 0a5f 0A00     		.ascii	"\012\000"
 9580 0a61 000000   		.space	3
 9581              	.LC59:
 9582 0a64 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9582      74696E67 
 9582      20475049 
 9582      46207374 
 9582      61746520 
 9583 0a97 0D0A00   		.ascii	"\015\012\000"
 9584 0a9a 0000     		.space	2
 9585              	.LC60:
 9586 0a9c 33303A55 		.ascii	"30:UVC App Thread\000"
 9586      56432041 
 9586      70702054 
 9586      68726561 
 9586      6400
 9587 0aae 0000     		.space	2
 9588              	.LC61:
 9589 0ab0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9589      56432041 
 9589      70702045 
 9589      50302054 
 9589      68726561 
 9590 0ac6 0000     		.space	2
 9591              	.LC62:
 9592 0ac8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9592      32432041 
 9592      70702043 
 9592      54524C20 
 9592      54687265 
 9593 0adf 00       		.bss
 9594              		.align	2
 9595              		.set	.LANCHOR0,. + 0
 9598              	glFxUVCEvent:
 9599 0000 00000000 		.space	40
 9599      00000000 
 9599      00000000 
 9599      00000000 
 9599      00000000 
 9602              	fb:
 9603 0028 0000     		.space	2
 9606              	pb:
 9607 002a 0000     		.space	2
 9610              	pbc:
 9611 002c 0000     		.space	2
 9614              	prodCount:
 9615 002e 0000     		.space	2
 9618              	consCount:
 9619 0030 0000     		.space	2
 9620 0032 0000     		.space	2
 9623              	streamingStarted:
 9624 0034 00000000 		.space	4
 9627              	gpif_initialized:
 9628 0038 00000000 		.space	4
 9631              	isUsbConnected:
 9632 003c 00000000 		.space	4
 9635              	clearFeatureRqtReceived:
 9636 0040 00000000 		.space	4
 9639              	hitFV:
 9640 0044 00000000 		.space	4
 9643              	usbSpeed:
 9644 0048 00       		.space	1
 9645 0049 000000   		.space	3
 9648              	I2CCMDArry:
 9649 004c 00000000 		.space	12
 9649      00000000 
 9649      00000000 
 9652              	glEp0Buffer:
 9653 0058 00000000 		.space	32
 9653      00000000 
 9653      00000000 
 9653      00000000 
 9653      00000000 
 9656              	glCommitCtrl:
 9657 0078 00000000 		.space	32
 9657      00000000 
 9657      00000000 
 9657      00000000 
 9657      00000000 
 9660              	stiflag:
 9661 0098 00000000 		.space	4
 9664              	uvcAppThread:
 9665 009c 00000000 		.space	168
 9665      00000000 
 9665      00000000 
 9665      00000000 
 9665      00000000 
 9668              	uvcAppEP0Thread:
 9669 0144 00000000 		.space	168
 9669      00000000 
 9669      00000000 
 9669      00000000 
 9669      00000000 
 9672              	i2cAppThread:
 9673 01ec 00000000 		.space	168
 9673      00000000 
 9673      00000000 
 9673      00000000 
 9673      00000000 
 9676              	testSnap:
 9677 0294 00       		.space	1
 9678 0295 00       		.space	1
 9681              	fbbak:
 9682 0296 0000     		.space	2
 9685              	pbbak:
 9686 0298 0000     		.space	2
 9689              	pbcbak:
 9690 029a 0000     		.space	2
 9693              	pbcpbak:
 9694 029c 0000     		.space	2
 9695 029e 0000     		.text
 9696              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:331    .text:00000250 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:489    .text:00000378 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:497    .text:0000038c $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:499    .text:0000038c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:678    .text:000004ec $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:687    .text:000004fc $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:689    .text:000004fc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1014   .text:000007c4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1030   .text:000007f0 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1033   .text:000007f0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1079   .text:0000082c $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1092   .text:00000858 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1155   .text:000008c8 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1162   .text:000008d8 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1173   .text:000008f0 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1176   .text:000008f0 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1287   .text:000009e4 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1292   .text:000009ec $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1295   .text:000009ec setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1358   .text:00000a6c ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1570   .text:00000c14 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1608   .text:00000ca0 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1673   .text:00000d24 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:1709   .text:00000dac $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:2964   .text:0000195c $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:2983   .text:0000199c $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:2986   .text:0000199c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:3154   .text:00001af8 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:3167   .text:00001b20 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:3662   .text:00002030 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:3673   .text:00002050 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:3928   .text:00002308 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:3941   .text:00002330 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:3944   .text:00002330 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:4006   .text:000023ac $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:4014   .text:000023bc $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5141   .text:00002d18 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5169   .text:00002d74 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5172   .text:00002d74 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5463   .text:0000302c $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5470   .text:0000303c $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5473   .text:0000303c CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5509   .text:00003068 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5513   .text:0000306c $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5516   .text:0000306c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5541   .text:00003088 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5545   .text:0000308c $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:5548   .text:0000308c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:6927   .text:00003b50 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:6987   .text:00003c24 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:6990   .text:00003c24 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7073   .text:00003cb0 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7082   .text:00003cc0 $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7085   .text:00003cc0 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7242   .text:00003e38 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7258   .text:00003e6c $a
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7261   .text:00003e6c main
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8859   .data:00000664 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8868   .data:00000670 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8943   .data:00000790 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8962   .data:000007a0 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7422   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9041   .data:000008d0 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9052   .data:000008e0 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9163   .data:00000a90 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9314   .data:00000b24 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7435   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8855   .data:00000663 snapButFlag
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9676   .bss:00000294 testSnap
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9602   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9606   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9610   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9681   .bss:00000296 fbbak
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9685   .bss:00000298 pbbak
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9689   .bss:0000029a pbcbak
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9693   .bss:0000029c pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9631   .bss:0000003c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9643   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9635   .bss:00000040 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9623   .bss:00000034 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8766   .data:00000614 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8826   .data:0000064c glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8796   .data:00000630 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8841   .data:00000658 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8417   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7399   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7403   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7447   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7451   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:7774   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8432   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8439   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:8762   .data:00000610 WDRflag
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9392   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9594   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9598   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9614   .bss:0000002e prodCount
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9618   .bss:00000030 consCount
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9627   .bss:00000038 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9639   .bss:00000044 hitFV
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9648   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9652   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9656   .bss:00000078 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9660   .bss:00000098 stiflag
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9664   .bss:0000009c uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9668   .bss:00000144 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cc06GnRQ.s:9672   .bss:000001ec i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
