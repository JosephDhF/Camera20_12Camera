   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB17:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 141:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 145:../uvc.c      ****     0x00, 0x80, 0x25, 0x00,     /* Max video frame size in bytes */
 146:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 147:../uvc.c      **** };
 148:../uvc.c      **** 
 149:../uvc.c      **** 
 150:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 151:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 152:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 154:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 155:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 156:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 157:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 158:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 159:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 160:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 161:../uvc.c      ****                                    with adjustable compression parameters */
 162:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 163:../uvc.c      ****                                    streaming with adjustable compression parameters */
 164:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 165:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 170:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 171:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 173:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 174:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 175:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 176:../uvc.c      **** };
 177:../uvc.c      **** 
 178:../uvc.c      **** 
 179:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 180:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 181:../uvc.c      **** 
 182:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 183:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 184:../uvc.c      **** {
 185:../uvc.c      ****     0x0C,                               /* Header Length */
 186:../uvc.c      ****     0x8C,                               /* Bit field header field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 188:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 189:../uvc.c      **** };
 190:../uvc.c      **** 
 191:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 192:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 193:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 194:../uvc.c      ****                                                            the current video frame. */
 195:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 196:../uvc.c      **** #ifndef CAM720
 197:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 198:../uvc.c      **** #else
 199:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 200:../uvc.c      **** #endif
 201:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 202:../uvc.c      **** 
 203:../uvc.c      **** /************ control parameters array ***********
 204:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 205:../uvc.c      ****  *    e.g.
 206:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 207:../uvc.c      ****  *     2nd D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 208:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 209:../uvc.c      ****  **************************************************/
 210:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 211:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 212:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 213:../uvc.c      **** #ifndef CAM720
 214:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 215:../uvc.c      **** #else
 216:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 217:../uvc.c      **** #endif
 218:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  63,     0, 1, 0, 3, 0, 31, 0, 
 219:../uvc.c      **** 		{/*2*/0x7/*ContrastReg*/  , 0x7/*ContrastReg*/   , 2,    16,   0,  64,     0, 1, 0, 3, 0, 40, 0, 
 220:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 221:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 222:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 223:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 224:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   14,    0, 1, 0, 3, 0,   0, 0,
 225:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*9*/0x8/*WBModeReg*/    , 0x8/*WBModeReg*/     , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 228:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 229:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 233:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 235:../uvc.c      **** #ifndef CAM720
 236:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 237:../uvc.c      **** #else
 238:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 239:../uvc.c      **** #endif
 240:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 241:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 242:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 244:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 246:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  255,    0, 1, 0, 3, 0,   0,32
 247:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg0     , 2,    0,    0,   63,    0, 1, 0, 3, 0,  32, 0
 248:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		/**********************************
 253:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 254:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 255:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 256:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 257:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 258:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 259:../uvc.c      **** 		 *
 260:../uvc.c      **** 		 *********************************/
 261:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 262:../uvc.c      **** };
 263:../uvc.c      **** 
 264:../uvc.c      **** #ifndef CAM720
 265:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 266:../uvc.c      **** #else
 267:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 268:../uvc.c      **** #endif
 269:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 270:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 271:../uvc.c      **** 
 272:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 273:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 274:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 275:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 276:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 277:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 278:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 279:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 280:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 281:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 282:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 285:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 287:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 288:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 289:../uvc.c      **** };
 290:../uvc.c      **** 
 291:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 292:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 293:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 294:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 295:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 296:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 297:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 298:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 299:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 300:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 302:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 303:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 304:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 308:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 309:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 310:../uvc.c      **** };
 311:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 312:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 313:../uvc.c      **** 
 314:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 315:../uvc.c      **** 
 316:../uvc.c      **** /*
 317:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 318:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 319:../uvc.c      ****  */
 320:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 321:../uvc.c      **** 		0xa0, 0x0f, 0xf, 0xf0
 322:../uvc.c      **** };
 323:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 324:../uvc.c      **** 		0
 325:../uvc.c      **** };
 326:../uvc.c      **** 
 327:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 328:../uvc.c      **** 
 329:../uvc.c      **** void I2CCmdHandler(){
 330:../uvc.c      **** 	uint8_t buf[2];
 331:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 332:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 333:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 334:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 335:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 336:../uvc.c      **** 
 337:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 338:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 339:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 340:../uvc.c      **** 
 341:../uvc.c      **** 	if(CmdType == 0)//I2C read
 342:../uvc.c      **** 	{
 343:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 344:../uvc.c      **** #if 0 //for debugging
 345:../uvc.c      **** 		/* test still image operation */
 346:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 347:../uvc.c      **** 			snapButFlag = 0; //press
 348:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 349:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 350:../uvc.c      **** 			snapButFlag = 0xf; //release
 351:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 352:../uvc.c      **** 		}
 353:../uvc.c      **** 
 354:../uvc.c      **** 		/* end of the test */
 355:../uvc.c      **** #endif
 356:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 357:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 358:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 359:../uvc.c      **** 			if(CmdDataLen == 2){
 360:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 361:../uvc.c      **** 			}
 362:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 363:../uvc.c      **** 		}else{//not support currently
 364:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 365:../uvc.c      **** 		}
 366:../uvc.c      **** 	}else if(CmdType == 1){
 367:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 368:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 369:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 370:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 371:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 372:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 373:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 374:../uvc.c      **** 			}
 375:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 376:../uvc.c      **** 		}else{//not support currently
 377:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 378:../uvc.c      **** 		}
 379:../uvc.c      **** 
 380:../uvc.c      **** 	}
 381:../uvc.c      **** }
 382:../uvc.c      **** 
 383:../uvc.c      **** /************************************
 384:../uvc.c      ****  * set Iris mode
 385:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 386:../uvc.c      ****  */
 387:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 388:../uvc.c      **** 	uint8_t dataIdx;
 389:../uvc.c      **** 	  dataIdx = 0;
 390:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 392:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 393:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 394:../uvc.c      **** }
 395:../uvc.c      **** 
 396:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 397:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 398:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 399:../uvc.c      ****     uint16_t readCount;
 400:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 401:../uvc.c      ****     uint8_t devAdd;
 402:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 403:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 404:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 405:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 406:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 407:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 408:../uvc.c      ****     }else{
 409:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 410:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 411:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 412:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 413:../uvc.c      ****     }
 414:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 415:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 416:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 417:../uvc.c      **** #endif
 418:../uvc.c      ****     reqData = bRequest;
 419:../uvc.c      ****     /*
 420:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 421:../uvc.c      ****      */
 422:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 423:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 424:../uvc.c      ****     	goto EndofSet;
 425:../uvc.c      ****     }
 426:../uvc.c      ****     switch (bRequest)
 427:../uvc.c      **** 		 {
 428:../uvc.c      **** 
 429:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 430:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 431:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 432:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 433:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 434:../uvc.c      **** 			  break;
 435:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 436:../uvc.c      **** 
 437:../uvc.c      **** 			 switch(CtrlID)
 438:../uvc.c      **** 			 {
 439:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 440:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 441:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 442:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 443:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 444:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 445:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 446:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 447:../uvc.c      **** 			 	 		 break;
 448:../uvc.c      **** 			 	 }
 449:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 450:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 451:../uvc.c      **** 					 if(CamMode == 1){//720p or invendo
 452:../uvc.c      **** 						if(sendData >= 3){
 453:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 454:../uvc.c      **** 							sendData = 0; //set back to default
 455:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 456:../uvc.c      **** 						}
 457:../uvc.c      **** 						sendData += 4;
 458:../uvc.c      **** 					 }
 459:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 460:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 461:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 462:../uvc.c      **** 					 break;
 463:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 464:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 465:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 466:../uvc.c      **** 			 		 }
 467:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 468:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 469:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 470:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 471:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 472:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 473:../uvc.c      **** #endif
 474:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 475:../uvc.c      **** 			 		 {
 476:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 477:../uvc.c      **** 			 		 }
 478:../uvc.c      **** 			 		 break;
 479:../uvc.c      **** 				 case ExtAexModCtlID9:
 480:../uvc.c      **** 
 481:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 482:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 483:../uvc.c      **** 						 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 484:../uvc.c      **** 		 	 		 }else{
 485:../uvc.c      **** 		 	 			//remove for invendo
 486:../uvc.c      **** 		 	 			//glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 487:../uvc.c      **** 		 	 			//glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 488:../uvc.c      **** 		 	 			//CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 489:../uvc.c      **** 
 490:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 491:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 492:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 493:../uvc.c      **** 		 	 		 }
 494:../uvc.c      **** 
 495:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 497:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 498:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 499:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 500:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 501:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 502:../uvc.c      **** 					 break;
 503:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 504:../uvc.c      **** 			 	 case BrgtCtlID1:
 505:../uvc.c      **** 
 506:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 507:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 508:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 509:../uvc.c      **** 		 	 		 }else{
 510:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 511:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 512:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 513:../uvc.c      **** 
 514:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 515:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 516:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 517:../uvc.c      **** 		 	 		 }
 518:../uvc.c      **** 
 519:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 520:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 521:../uvc.c      **** 					 }else{
 522:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 523:../uvc.c      **** 					 }
 524:../uvc.c      **** 
 525:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 526:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 527:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 528:../uvc.c      **** 					 break;
 529:../uvc.c      **** #endif
 530:../uvc.c      **** 				 case HueCtlID5://TODO check sensor register
 531:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 532:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 533:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 534:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 535:../uvc.c      **** 					 break;
 536:../uvc.c      **** 				 case WBTLevCtlID11:
 537:../uvc.c      **** 
 538:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 539:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 540:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 541:../uvc.c      **** 		 	 		 }else{
 542:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd1, devAdd);
 543:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 544:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 545:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 546:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 547:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 548:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 549:../uvc.c      **** 		 	 		 }
 550:../uvc.c      **** 
 551:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 552:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 553:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 554:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 555:../uvc.c      **** 					 break;
 556:../uvc.c      **** 				 case SaturCtlID6://TODO check sensor register
 557:../uvc.c      **** 				 default:
 558:../uvc.c      **** 
 559:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 560:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 561:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 562:../uvc.c      **** 		 	 		 }else{
 563:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 564:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 565:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 566:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 567:../uvc.c      **** 		 	 		 }
 568:../uvc.c      **** 
 569:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 570:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 571:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 572:../uvc.c      **** 					 break;
 573:../uvc.c      **** 			 }
 574:../uvc.c      **** 
 575:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 576:../uvc.c      **** 
 577:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 578:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 579:../uvc.c      **** #endif
 580:../uvc.c      **** 			  break;
 581:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 582:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 583:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 584:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 585:../uvc.c      **** 		 	 }
 586:../uvc.c      **** 
 587:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 588:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 589:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 590:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 591:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 592:../uvc.c      **** 			 }else
 593:../uvc.c      **** 			 {
 594:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 595:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 596:../uvc.c      **** 			 }
 597:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 598:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 599:../uvc.c      **** 			  break;
 600:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 601:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 602:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 603:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 604:../uvc.c      **** 		 	 }
 605:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 606:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 607:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 608:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 609:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 610:../uvc.c      **** 			 }else
 611:../uvc.c      **** 			 {
 612:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 613:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 614:../uvc.c      **** 			 }
 615:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 616:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 617:../uvc.c      **** 			  break;
 618:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 619:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 620:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 621:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 622:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 623:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 624:../uvc.c      **** 		 	 }
 625:../uvc.c      **** 		 	 else{
 626:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 627:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 628:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 629:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 630:../uvc.c      **** 		 	 }
 631:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 632:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 633:../uvc.c      **** 			  break;
 634:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 635:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 636:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 637:../uvc.c      **** 		 	 }
 638:../uvc.c      **** 		 	 else{
 639:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 640:../uvc.c      **** 		 	 }
 641:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 642:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 643:../uvc.c      **** 			  Len = 1;
 644:../uvc.c      **** 			  break;
 645:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 646:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 647:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 648:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 649:../uvc.c      **** 		 	 }
 650:../uvc.c      **** 
 651:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 652:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 653:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 654:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 655:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 656:../uvc.c      **** 			 }else{
 657:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 658:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 659:../uvc.c      **** 			 }
 660:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 661:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 662:../uvc.c      **** 			  break;
 663:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 664:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 665:../uvc.c      **** 				  glEp0Buffer, &readCount);
 666:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 667:../uvc.c      **** 			   {
 668:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 669:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 670:../uvc.c      **** 				  getData = glEp0Buffer[0];
 671:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 672:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 673:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 674:../uvc.c      **** #endif
 675:../uvc.c      **** 				  switch(CtrlID)
 676:../uvc.c      **** 					 {
 677:../uvc.c      **** 						 case ExtShutCtlID0:
 678:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 679:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 680:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 681:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 682:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 683:../uvc.c      **** 									 }else{
 684:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 685:../uvc.c      **** 									 }
 686:../uvc.c      **** 								 }
 687:../uvc.c      **** 							 }else{
 688:../uvc.c      **** 								 Data1 = Data0 - 1;
 689:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 690:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 691:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 692:../uvc.c      **** 									 }else{
 693:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 694:../uvc.c      **** 									 }
 695:../uvc.c      **** 								 }
 696:../uvc.c      **** 								 if(Data1 < 8){
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 698:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 699:../uvc.c      **** 								 }else{
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 701:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 702:../uvc.c      **** 								 }
 703:../uvc.c      **** 							 }
 704:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 705:../uvc.c      **** 							 dataIdx = 0;
 706:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 707:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 708:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 709:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 710:../uvc.c      **** 							 break;
 711:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 714:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 715:../uvc.c      **** 							 dataIdx = 0;
 716:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 717:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 718:../uvc.c      **** 							 if(1 || (getData != 0)){
 719:../uvc.c      **** 								 //dataIdx++;
 720:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 721:../uvc.c      **** 							 }
 722:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 723:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 724:../uvc.c      **** 							 break;
 725:../uvc.c      **** 						 case ExtExRefCtlID10:
 726:../uvc.c      **** 							 dataIdx = 0;
 727:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 728:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 729:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 730:../uvc.c      **** 							 if(WDRflag)
 731:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 732:../uvc.c      **** 							 else
 733:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 734:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 735:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 736:../uvc.c      **** 						 case ExtCamMCtlID12:
 737:../uvc.c      **** 							 /*
 738:../uvc.c      **** 							 dataIdx = 0;
 739:../uvc.c      **** 							 if(Data0 <= 3){
 740:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 741:../uvc.c      **** 								 Data1 = Data0;
 742:../uvc.c      **** 							 }else{
 743:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 744:../uvc.c      **** 								 Data1 = Data0-4;
 745:../uvc.c      **** 							 }
 746:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 747:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 748:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 749:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 750:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 751:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 752:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 753:../uvc.c      **** 							 */
 754:../uvc.c      **** 							 break;
 755:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 756:../uvc.c      **** 							 dataIdx = 0;
 757:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 758:../uvc.c      **** 								 Data0 = 1;
 759:../uvc.c      **** 							 }else{ //save current sensor parameters.
 760:../uvc.c      **** 								 Data0 = 0;
 761:../uvc.c      **** 							 }
 762:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 763:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 764:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 765:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 766:../uvc.c      **** 							 break;
 767:../uvc.c      **** 						 case ExtI2CCtlID15:
 768:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 769:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 770:../uvc.c      **** 					 		 }
 771:../uvc.c      **** 					 		I2CCmdHandler();
 772:../uvc.c      **** 							 break;
 773:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 774:../uvc.c      **** 							 dataIdx = 0;
 775:../uvc.c      **** #if 0 //seperate version
 776:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 777:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 778:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 779:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 780:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 781:../uvc.c      **** 							 }else{ //disable BLD window
 782:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 783:../uvc.c      **** 							 }
 784:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 786:../uvc.c      **** 							 dataIdx++;
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 788:../uvc.c      **** 							 dataIdx++;
 789:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 790:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 791:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 792:../uvc.c      **** 							 dataIdx++;
 793:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 794:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 795:../uvc.c      **** #else //combination version
 796:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 797:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 798:../uvc.c      **** 						     /* end test */
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 800:../uvc.c      **** 							 dataIdx++;
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 802:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 803:../uvc.c      **** 							 getData1 = Data1;
 804:../uvc.c      **** #endif
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 807:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 808:../uvc.c      **** 							 break;
 809:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 810:../uvc.c      **** 							 dataIdx = 0;
 811:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 812:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 813:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 815:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 816:../uvc.c      **** 							 break;
 817:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 818:../uvc.c      **** 							 dataIdx = 0;
 819:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 820:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 821:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 823:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 824:../uvc.c      **** 							 break;
 825:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 826:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 827:../uvc.c      **** 							 dataIdx = 0;
 828:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 829:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 830:../uvc.c      **** 							  if(Data0&0x80){
 831:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 832:../uvc.c      **** 							  }else{
 833:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 834:../uvc.c      **** 							  }
 835:../uvc.c      **** 							 Data1 |= ~0x03;
 836:../uvc.c      **** 							 Data1 &= 0xC7;
 837:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 838:../uvc.c      **** 						  	 dataIdx++;
 839:../uvc.c      **** 
 840:../uvc.c      **** 							 Data0 = (Data0 << 2);
 841:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 842:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 843:../uvc.c      **** 
 844:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 845:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 846:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 847:../uvc.c      **** 
 848:../uvc.c      **** 							 break;
 849:../uvc.c      **** #endif
 850:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 851:../uvc.c      **** 							 dataIdx = 0;
 852:../uvc.c      **** 
 853:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 854:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 855:../uvc.c      **** 							 dataIdx++;
 856:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 857:../uvc.c      **** 							 dataIdx++;
 858:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 859:../uvc.c      **** 							 dataIdx++;
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 861:../uvc.c      **** 							 dataIdx++;
 862:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 863:../uvc.c      **** 							 dataIdx++;
 864:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 865:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 866:../uvc.c      **** 
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 868:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 869:../uvc.c      **** 							 break;
 870:../uvc.c      **** 						 case SaturCtlID6:
 871:../uvc.c      **** 							 dataIdx = 0;
 872:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 875:../uvc.c      **** 							 dataIdx++;
 876:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 877:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 878:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 879:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 880:../uvc.c      **** 							 break;
 881:../uvc.c      **** 
 882:../uvc.c      **** 						 case WBTLevCtlID11:
 883:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue to 0x9 or low to 0xa
 884:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red to 0xa or high to 0x9
 885:../uvc.c      **** 							 dataIdx = 0;
 886:../uvc.c      **** 
 887:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 888:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 889:../uvc.c      **** 							 dataIdx++;
 890:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data1, dataIdx);  //Second
 891:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 892:../uvc.c      **** 
 893:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 894:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 895:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 896:../uvc.c      **** 							 break;
 897:../uvc.c      **** 						 case MFreqCtlID4:
 898:../uvc.c      **** 							 dataIdx = 0;
 899:../uvc.c      **** 							 Data0 = Data0 - 1;
 900:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 901:../uvc.c      **** 								 Data0 = 0;
 902:../uvc.c      **** 							 else if(Data0 >2)
 903:../uvc.c      **** 								 Data0 = 1;
 904:../uvc.c      **** 
 905:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 906:../uvc.c      **** 							 //remove for Invendo
 907:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 908:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 909:../uvc.c      **** 
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 911:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 912:../uvc.c      **** 							 break;
 913:../uvc.c      **** 					 	 case BLCCtlID0:
 914:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 915:../uvc.c      **** 							 if(Data0 == 3)
 916:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 917:../uvc.c      **** 							 else
 918:../uvc.c      **** 								 WDRflag = CyFalse;
 919:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 920:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 921:../uvc.c      **** 							 {
 922:../uvc.c      **** 								 if(Data0 < 2){
 923:../uvc.c      **** 					 				 ;//Data0 += 4;
 924:../uvc.c      **** 					 			 }else{
 925:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 926:../uvc.c      **** 									Data0 = 0; //set to default.
 927:../uvc.c      **** 					 			 }
 928:../uvc.c      **** 					 		 }
 929:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 930:../uvc.c      **** 							 dataIdx = 0;
 931:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 932:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 933:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 934:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 935:../uvc.c      **** 
 936:../uvc.c      **** 					 		 break;
 937:../uvc.c      **** 						 default:
 938:../uvc.c      **** 							 dataIdx = 0;
 939:../uvc.c      **** 
 940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 941:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 942:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 943:../uvc.c      **** 
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 945:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 946:../uvc.c      **** 							 break;
 947:../uvc.c      **** 					 }
 948:../uvc.c      **** 			   }else{
 949:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 950:../uvc.c      **** 			   }
 951:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 952:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 953:../uvc.c      **** #endif
 954:../uvc.c      **** 
 955:../uvc.c      **** 			  break;
 956:../uvc.c      **** 		  default:
 957:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 958:../uvc.c      **** 			  break;
 959:../uvc.c      **** 		 }
 960:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 961:../uvc.c      **** }
 962:../uvc.c      **** /************** CT control requests handler *************************/
 963:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 964:../uvc.c      **** 
 965:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 966:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 967:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 968:../uvc.c      ****     uint16_t readCount;
 969:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 970:../uvc.c      ****     uint16_t diff, value, diffRd;
 971:../uvc.c      ****     uint8_t i, shutter, index;
 972:../uvc.c      ****     diff = 0xffff;
 973:../uvc.c      ****     shutter = 1;
 974:../uvc.c      ****     index = 1;
 975:../uvc.c      **** 
 976:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 977:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 978:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 979:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 980:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 981:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 982:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 983:../uvc.c      **** #endif
 984:../uvc.c      ****     reqData = bRequest;
 985:../uvc.c      **** 
 986:../uvc.c      ****     switch (bRequest)
 987:../uvc.c      **** 		 {
 988:../uvc.c      **** 
 989:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 990:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 991:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 993:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 994:../uvc.c      **** 			  break;
 995:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 996:../uvc.c      **** 
 997:../uvc.c      **** 			 switch(CtrlID)
 998:../uvc.c      **** 			 {
 999:../uvc.c      **** 				 default:
1000:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1001:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1002:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1003:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1004:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1005:../uvc.c      **** 					 break;
1006:../uvc.c      **** 			 }
1007:../uvc.c      **** 
1008:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1009:../uvc.c      **** 
1010:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1011:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1012:../uvc.c      **** #endif
1013:../uvc.c      **** 			  break;
1014:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1015:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1016:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1017:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1018:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1019:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1020:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1021:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1022:../uvc.c      **** 			  break;
1023:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1024:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1025:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1026:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1027:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1028:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1029:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1030:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1031:../uvc.c      **** 			  break;
1032:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1033:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1034:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1035:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1036:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1037:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1040:../uvc.c      **** 			  break;
1041:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1042:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1043:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1044:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1045:../uvc.c      **** 			  Len = 1;
1046:../uvc.c      **** 			  break;
1047:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1048:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1049:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1050:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1051:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1052:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1053:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1054:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1055:../uvc.c      **** 			  break;
1056:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1057:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1058:../uvc.c      **** 			  glEp0Buffer, &readCount);
1059:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1060:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1061:../uvc.c      **** 			  value = Data1;
1062:../uvc.c      **** 
1063:../uvc.c      **** 			  switch(CtrlID)
1064:../uvc.c      **** 			  {
1065:../uvc.c      **** 		  	      case AutoExMCtlID1:
1066:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1067:../uvc.c      **** 
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1069:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1070:../uvc.c      **** 				    getData = glEp0Buffer[0];
1071:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1072:../uvc.c      **** 		  		    switch (getData){
1073:../uvc.c      **** 						case 1:
1074:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1075:../uvc.c      **** 							break;
1076:../uvc.c      **** 						case 2:
1077:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1078:../uvc.c      **** 							dataIdx = 0;
1079:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1080:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1081:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1082:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1083:../uvc.c      **** 
1084:../uvc.c      **** 							break;
1085:../uvc.c      **** 						case 4:
1086:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1087:../uvc.c      **** 							break;
1088:../uvc.c      **** 						case 8:
1089:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1090:../uvc.c      **** 			  		    	dataIdx = 0;
1091:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1092:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1093:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1094:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1095:../uvc.c      **** 							break;
1096:../uvc.c      **** 		  		    }
1097:../uvc.c      **** #if 0
1098:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1099:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1100:../uvc.c      **** 						  dataIdx = 0;
1101:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1102:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1103:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1104:../uvc.c      **** 		  		    }
1105:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1106:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1107:../uvc.c      **** 		  		    }
1108:../uvc.c      **** #endif
1109:../uvc.c      **** 				    break;
1110:../uvc.c      **** 
1111:../uvc.c      **** 			  	  case ExTmACtlID3:
1112:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1113:../uvc.c      **** 
1114:../uvc.c      **** 					  value = (value << 8)|Data0;
1115:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1116:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1117:../uvc.c      **** 					  {
1118:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1119:../uvc.c      **** 						  {
1120:../uvc.c      **** 							if(value > ShutValueArry[i]){
1121:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1122:../uvc.c      **** 							}else{
1123:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1124:../uvc.c      **** 							}
1125:../uvc.c      **** 							  if(diff > diffRd){
1126:../uvc.c      **** 								  diff = diffRd;
1127:../uvc.c      **** 								  index = i;
1128:../uvc.c      **** 							  }
1129:../uvc.c      **** 						  }
1130:../uvc.c      **** 						  shutter = shutter+index;
1131:../uvc.c      **** 
1132:../uvc.c      **** 						  dataIdx = 0;
1133:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1134:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1135:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1136:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1137:../uvc.c      **** 
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1140:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1141:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1142:../uvc.c      **** 					  }else{
1143:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1144:../uvc.c      **** 					  }
1145:../uvc.c      **** 					  getData = glEp0Buffer[0];
1146:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1147:../uvc.c      **** 					  break;
1148:../uvc.c      **** 			  	  case IriACtlID7:
1149:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1150:../uvc.c      **** 					  {
1151:../uvc.c      **** 							 dataIdx = 0;
1152:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1153:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1154:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1155:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1156:../uvc.c      **** 
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1159:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1160:../uvc.c      **** 					  }else{
1161:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1162:../uvc.c      **** 					  }
1163:../uvc.c      **** 					  getData = glEp0Buffer[0];
1164:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1165:../uvc.c      **** 
1166:../uvc.c      **** 					  break;
1167:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1168:../uvc.c      **** 					  getData = glEp0Buffer[0];
1169:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1170:../uvc.c      **** #if 1
1171:../uvc.c      **** 					  dataIdx = 0;
1172:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1173:../uvc.c      **** 					  if(getData == 1)
1174:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1175:../uvc.c      **** 					  else if(getData == 0xff)
1176:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1177:../uvc.c      **** 					  else
1178:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1179:../uvc.c      **** 					  //dataIdx++;
1180:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1181:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1182:../uvc.c      **** #endif
1183:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1184:../uvc.c      **** 					  break;
1185:../uvc.c      **** 
1186:../uvc.c      **** 			  	  default:
1187:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1188:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1189:../uvc.c      **** 			  		 break;
1190:../uvc.c      **** 			  }
1191:../uvc.c      **** 			  break;
1192:../uvc.c      **** 		  default:
1193:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1194:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1195:../uvc.c      **** 			  break;
1196:../uvc.c      **** 		 }
1197:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1198:../uvc.c      **** 
1199:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1200:../uvc.c      **** }
1201:../uvc.c      **** 
1202:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1203:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1204:../uvc.c      **** {
1205:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1206:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1207:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1208:../uvc.c      **** 
1209:../uvc.c      ****     CtrlID = BrgtCtlID1;
1210:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1211:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1212:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1213:../uvc.c      ****     Data1 = Data0;
1214:../uvc.c      **** 
1215:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1216:../uvc.c      ****     if(Data1&0x80){
1217:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1218:../uvc.c      ****     }else{
1219:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1220:../uvc.c      ****     }
1221:../uvc.c      ****     Data0 = (Data0 << 2);
1222:../uvc.c      **** 
1223:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1224:../uvc.c      **** 
1225:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1226:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1227:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1228:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1229:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1230:../uvc.c      **** 
1231:../uvc.c      ****     CtrlID = ConsCtlID2;
1232:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1233:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1234:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1235:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1236:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1237:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1238:../uvc.c      **** 
1239:../uvc.c      ****     CtrlID = HueCtlID5;
1240:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1241:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1242:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1248:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1249:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1250:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1251:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1252:../uvc.c      **** 
1253:../uvc.c      ****     CtrlID = SaturCtlID6;
1254:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1255:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1256:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1257:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1258:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1259:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1260:../uvc.c      **** 
1261:../uvc.c      ****     CtrlID = ShapCtlID7;
1262:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1263:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1264:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1265:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1266:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1267:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1268:../uvc.c      **** 
1269:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1270:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1271:../uvc.c      **** 	return;
1272:../uvc.c      **** }
1273:../uvc.c      **** 
1274:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1275:../uvc.c      **** void
1276:../uvc.c      **** CyFxUVCAddHeader (
1277:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1278:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1279:../uvc.c      ****         )
1280:../uvc.c      **** {
1281:../uvc.c      ****     /* Copy header to buffer */
1282:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1283:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1284:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1285:../uvc.c      **** 
1286:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1287:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1288:../uvc.c      ****     {
1289:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1290:../uvc.c      ****     }
1291:../uvc.c      **** }
1292:../uvc.c      **** 
1293:../uvc.c      **** 
1294:../uvc.c      **** /* Application Error Handler */
1295:../uvc.c      **** void
1296:../uvc.c      **** CyFxAppErrorHandler (
1297:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1298:../uvc.c      ****         )
1299:../uvc.c      **** {
1300:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1301:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1302:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1303:../uvc.c      **** 
1304:../uvc.c      ****        This function can be modified to take additional error handling actions such
1305:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1306:../uvc.c      ****      */
1307:../uvc.c      ****     for (;;)
1308:../uvc.c      ****     {
1309:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1310:../uvc.c      ****         CyU3PThreadSleep (1000);
1311:../uvc.c      ****     }
1312:../uvc.c      **** }
1313:../uvc.c      **** 
1314:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1315:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1316:../uvc.c      ****  */
1317:../uvc.c      **** static void
1318:../uvc.c      **** CyFxUVCApplnAbortHandler (
1319:../uvc.c      ****         void)
1320:../uvc.c      **** {
1321:../uvc.c      **** 	uint32_t flag;
1322:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1323:../uvc.c      **** 	{
1324:../uvc.c      ****         /* Clear the Video Stream Request Event */
1325:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1326:../uvc.c      **** 
1327:../uvc.c      ****         /* Set Video Stream Abort Event */
1328:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1329:../uvc.c      **** 	}
1330:../uvc.c      **** }
1331:../uvc.c      **** 
1332:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1333:../uvc.c      **** static void
1334:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1335:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1336:../uvc.c      ****         uint16_t             evdata  /* Event data */
1337:../uvc.c      ****         )
1338:../uvc.c      **** {
1339:../uvc.c      ****     switch (evtype)
1340:../uvc.c      ****     {
1341:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1342:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1343:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1344:../uvc.c      ****             gpif_initialized = 0;
1345:../uvc.c      ****             streamingStarted = CyFalse;
1346:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1347:../uvc.c      ****             break;
1348:../uvc.c      **** 
1349:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1350:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1351:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1352:../uvc.c      ****             gpif_initialized = 0;
1353:../uvc.c      ****             streamingStarted = CyFalse;
1354:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1355:../uvc.c      ****             break;
1356:../uvc.c      **** 
1357:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1358:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1359:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1360:../uvc.c      ****             gpif_initialized = 0;
1361:../uvc.c      ****             isUsbConnected = CyFalse;
1362:../uvc.c      ****             streamingStarted = CyFalse;
1363:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1364:../uvc.c      ****             break;
1365:../uvc.c      **** 
1366:../uvc.c      **** #ifdef BACKFLOW_DETECT
1367:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1368:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1369:../uvc.c      ****             break;
1370:../uvc.c      **** #endif
1371:../uvc.c      **** 
1372:../uvc.c      ****         default:
1373:../uvc.c      ****             break;
1374:../uvc.c      ****     }
1375:../uvc.c      **** }
1376:../uvc.c      **** 
1377:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1378:../uvc.c      **** static CyBool_t
1379:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1380:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1381:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1382:../uvc.c      ****         )
1383:../uvc.c      **** {
1384:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1385:../uvc.c      ****     uint32_t status;
1386:../uvc.c      **** 
1387:../uvc.c      ****     /* Obtain Request Type and Request */
1388:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1389:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1390:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1391:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1392:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1393:../uvc.c      **** 
1394:../uvc.c      **** #if 1
1395:../uvc.c      ****    	CyU3PDebugPrint(4, "\n\rbRType = 0x%x, bRequest = 0x%x, wValue = 0x%x, wIndex = 0x%x, wLength= 
1396:../uvc.c      **** #endif
1397:../uvc.c      **** 
1398:../uvc.c      ****     /* Check for UVC Class Requests */
1399:../uvc.c      ****     switch (bmReqType)
1400:../uvc.c      ****     {
1401:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1402:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1403:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1404:../uvc.c      ****             switch (wIndex & 0xFF)
1405:../uvc.c      ****             {
1406:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1407:../uvc.c      ****                     {
1408:../uvc.c      ****                         uvcHandleReq = CyTrue;
1409:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1410:../uvc.c      ****                                 CYU3P_EVENT_OR);
1411:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1412:../uvc.c      ****                         {
1413:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1414:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1415:../uvc.c      ****                         }
1416:../uvc.c      ****                     }
1417:../uvc.c      ****                     break;
1418:../uvc.c      **** 
1419:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1420:../uvc.c      ****                     {
1421:../uvc.c      ****                         uvcHandleReq = CyTrue;
1422:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1423:../uvc.c      ****                                 CYU3P_EVENT_OR);
1424:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1425:../uvc.c      ****                         {
1426:../uvc.c      ****                             /* Error handling */
1427:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1428:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1429:../uvc.c      ****                         }
1430:../uvc.c      ****                     }
1431:../uvc.c      ****                     break;
1432:../uvc.c      **** 
1433:../uvc.c      ****                 default:
1434:../uvc.c      ****                     break;
1435:../uvc.c      ****             }
1436:../uvc.c      ****             break;
1437:../uvc.c      **** 
1438:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1439:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1440:../uvc.c      ****             {
1441:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1442:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1443:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1444:../uvc.c      ****                 {
1445:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1446:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1447:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1448:../uvc.c      ****                     gpif_initialized = 0;
1449:../uvc.c      ****                     streamingStarted = CyFalse;
1450:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1451:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1452:../uvc.c      ****                     CyU3PBusyWait (100);
1453:../uvc.c      **** 
1454:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1455:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1456:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1457:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1458:../uvc.c      ****                     CyU3PBusyWait (100);
1459:../uvc.c      **** 
1460:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1461:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1462:../uvc.c      ****                     uvcHandleReq = CyTrue;
1463:../uvc.c      ****                     /* Complete Control request handshake */
1464:../uvc.c      ****                     CyU3PUsbAckSetup ();
1465:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1466:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1467:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1468:../uvc.c      **** 
1469:../uvc.c      ****                 }
1470:../uvc.c      ****             }
1471:../uvc.c      ****             break;
1472:../uvc.c      **** 
1473:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1474:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1475:../uvc.c      ****             {
1476:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1477:../uvc.c      ****                 {
1478:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1479:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1480:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1481:../uvc.c      ****                 	 * has started. */
1482:../uvc.c      ****                     if (streamingStarted == CyTrue)
1483:../uvc.c      ****                     {
1484:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1485:../uvc.c      **** 
1486:../uvc.c      ****                         /* Disable the GPIF state machine. */
1487:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1488:../uvc.c      ****                         gpif_initialized = 0;
1489:../uvc.c      ****                         streamingStarted = CyFalse;
1490:../uvc.c      **** 
1491:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1492:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1493:../uvc.c      ****                         CyU3PBusyWait (100);
1494:../uvc.c      **** 
1495:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1496:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1497:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1498:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1499:../uvc.c      ****                         CyU3PBusyWait (100);
1500:../uvc.c      **** 
1501:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1502:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1503:../uvc.c      **** 
1504:../uvc.c      ****                         uvcHandleReq = CyTrue;
1505:../uvc.c      ****                         /* Complete Control request handshake */
1506:../uvc.c      ****                         CyU3PUsbAckSetup ();
1507:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1508:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1509:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1510:../uvc.c      ****                     }
1511:../uvc.c      ****                     else
1512:../uvc.c      ****                     {
1513:../uvc.c      ****                         uvcHandleReq = CyTrue;
1514:../uvc.c      ****                         CyU3PUsbAckSetup ();
1515:../uvc.c      ****                     }
1516:../uvc.c      ****                 }
1517:../uvc.c      ****             }
1518:../uvc.c      ****             break;
1519:../uvc.c      **** 
1520:../uvc.c      ****         default:
1521:../uvc.c      ****             break;
1522:../uvc.c      ****     }
1523:../uvc.c      **** 
1524:../uvc.c      ****     /* Return status of request handling to the USB driver */
1525:../uvc.c      ****     return uvcHandleReq;
1526:../uvc.c      **** }
1527:../uvc.c      **** 
1528:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1529:../uvc.c      **** 
1530:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1531:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1532:../uvc.c      ****  */
1533:../uvc.c      **** void
1534:../uvc.c      **** CyFxUvcApplnDmaCallback (
1535:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1536:../uvc.c      ****         CyU3PDmaCbType_t      type,
1537:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1538:../uvc.c      ****         )
1539:../uvc.c      **** {
1540:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1541:../uvc.c      **** #if 1
1542:../uvc.c      ****     CyU3PReturnStatus_t status;
1543:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1544:../uvc.c      ****     {
1545:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1546:../uvc.c      ****             {
1547:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1548:../uvc.c      ****                 fb++;
1549:../uvc.c      ****             }
1550:../uvc.c      ****             else
1551:../uvc.c      ****             {
1552:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1553:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1554:../uvc.c      ****                 pb++;
1555:../uvc.c      ****                 pbc = input->buffer_p.count;
1556:../uvc.c      ****                // hitFV = CyTrue;
1557:../uvc.c      **** #if 1   //remove the still flag clearing here
1558:../uvc.c      ****                 if(stiflag == 0x0F){
1559:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1560:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1561:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1562:../uvc.c      ****                 	//stiflag = 0xAA;
1563:../uvc.c      ****                 	stiflag = 0x0;//set back to video
1564:../uvc.c      ****                 }
1565:../uvc.c      **** #endif
1566:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1567:../uvc.c      ****             }
1568:../uvc.c      **** 
1569:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1570:../uvc.c      ****             prodCount++;
1571:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1572:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1573:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1574:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1575:../uvc.c      ****             {
1576:../uvc.c      ****                 prodCount--;
1577:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1578:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1579:../uvc.c      ****             }
1580:../uvc.c      ****     }
1581:../uvc.c      **** #endif
1582:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1583:../uvc.c      ****     {
1584:../uvc.c      ****         consCount++;
1585:../uvc.c      ****         streamingStarted = CyTrue;
1586:../uvc.c      ****     }
1587:../uvc.c      **** }
1588:../uvc.c      **** 
1589:../uvc.c      **** /*
1590:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1591:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1592:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1593:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1594:../uvc.c      ****  * to commit the buffer.
1595:../uvc.c      ****  */
1596:../uvc.c      **** static uint8_t
1597:../uvc.c      **** CyFxUvcAppCommitEOF (
1598:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1599:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1600:../uvc.c      ****         )
1601:../uvc.c      **** {
1602:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1603:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1604:../uvc.c      **** 
1605:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1606:../uvc.c      **** 
1607:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1608:../uvc.c      ****     {
1609:../uvc.c      ****         switch (stateId)
1610:../uvc.c      ****         {
1611:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1612:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1613:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1614:../uvc.c      ****                 break;
1615:../uvc.c      **** 
1616:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1617:../uvc.c      ****                 socket = 0;
1618:../uvc.c      ****                 break;
1619:../uvc.c      **** 
1620:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1621:../uvc.c      ****                 socket = 1;
1622:../uvc.c      ****                 break;
1623:../uvc.c      **** 
1624:../uvc.c      ****             default:
1625:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1626:../uvc.c      ****                 /* Unexpected current state. Return error. */
1627:../uvc.c      ****                 return 1;
1628:../uvc.c      ****         }
1629:../uvc.c      ****     }
1630:../uvc.c      **** 
1631:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1632:../uvc.c      ****     {
1633:../uvc.c      ****         switch (stateId)
1634:../uvc.c      ****         {
1635:../uvc.c      **** #ifndef CAM720
1636:../uvc.c      **** #ifdef GPIFIIM
1637:../uvc.c      ****             case 13:
1638:../uvc.c      ****             case 24:
1639:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1640:../uvc.c      ****                 break;
1641:../uvc.c      **** 
1642:../uvc.c      ****             case 8:
1643:../uvc.c      ****                 socket = 0;
1644:../uvc.c      ****                 break;
1645:../uvc.c      **** 
1646:../uvc.c      ****             case 20:
1647:../uvc.c      ****                 socket = 1;
1648:../uvc.c      ****                 break;
1649:../uvc.c      **** #else
1650:../uvc.c      ****             case 11:
1651:../uvc.c      ****             case 18:
1652:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1653:../uvc.c      ****                 break;
1654:../uvc.c      **** 
1655:../uvc.c      ****             case 8:
1656:../uvc.c      ****                 socket = 0;
1657:../uvc.c      ****                 break;
1658:../uvc.c      **** 
1659:../uvc.c      ****             case 15:
1660:../uvc.c      ****                 socket = 1;
1661:../uvc.c      ****                 break;
1662:../uvc.c      **** #endif
1663:../uvc.c      **** #else
1664:../uvc.c      ****             case 11:
1665:../uvc.c      ****             case 18:
1666:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1667:../uvc.c      ****                 break;
1668:../uvc.c      **** 
1669:../uvc.c      ****             case 8:
1670:../uvc.c      ****                 socket = 0;
1671:../uvc.c      ****                 break;
1672:../uvc.c      **** 
1673:../uvc.c      ****             case 15:
1674:../uvc.c      ****                 socket = 1;
1675:../uvc.c      ****                 break;
1676:../uvc.c      **** 
1677:../uvc.c      **** #endif
1678:../uvc.c      ****              default:
1679:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1680:../uvc.c      ****                 /* Unexpected current state. Return error. */
1681:../uvc.c      ****                return 1;
1682:../uvc.c      ****         }
1683:../uvc.c      ****     }
1684:../uvc.c      **** 
1685:../uvc.c      ****     if (socket != 0xFF)
1686:../uvc.c      ****     {
1687:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1688:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1689:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1690:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1691:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1692:../uvc.c      ****         {
1693:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1694:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1695:../uvc.c      ****         }
1696:../uvc.c      ****     }
1697:../uvc.c      **** 
1698:../uvc.c      ****     return 0;
1699:../uvc.c      **** }
1700:../uvc.c      **** 
1701:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1702:../uvc.c      **** void
1703:../uvc.c      **** CyFxGpifCB (
1704:../uvc.c      ****         CyU3PGpifEventType event,
1705:../uvc.c      ****         uint8_t currentState
1706:../uvc.c      ****         )
1707:../uvc.c      **** {
1708:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1709:../uvc.c      ****     {
1710:../uvc.c      ****         //hitFV = CyTrue;
1711:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1712:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1713:../uvc.c      ****     }
1714:../uvc.c      **** }
1715:../uvc.c      **** 
1716:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1717:../uvc.c      **** static void
1718:../uvc.c      **** CyFxUVCApplnDebugInit (
1719:../uvc.c      ****         void)
1720:../uvc.c      **** {
1721:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1722:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1723:../uvc.c      **** 
1724:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1725:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1726:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1727:../uvc.c      ****     {
1728:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1729:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1730:../uvc.c      ****     }
1731:../uvc.c      **** 
1732:../uvc.c      ****     /* Set UART Configuration */
1733:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1734:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1735:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1736:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1737:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1738:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1739:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1740:../uvc.c      **** 
1741:../uvc.c      ****     /* Set the UART configuration */
1742:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1743:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1744:../uvc.c      ****     {
1745:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1746:../uvc.c      ****     }
1747:../uvc.c      **** 
1748:../uvc.c      ****     /* Set the UART transfer */
1749:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1750:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1751:../uvc.c      ****     {
1752:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1753:../uvc.c      ****     }
1754:../uvc.c      **** 
1755:../uvc.c      ****     /* Initialize the Debug logger module. */
1756:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1757:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1758:../uvc.c      ****     {
1759:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1760:../uvc.c      ****     }
1761:../uvc.c      **** 
1762:../uvc.c      ****     /* Disable log message headers. */
1763:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1764:../uvc.c      **** }
1765:../uvc.c      **** 
1766:../uvc.c      **** /* I2C initialization. */
1767:../uvc.c      **** //static void
1768:../uvc.c      **** void
1769:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1770:../uvc.c      **** {
1771:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1772:../uvc.c      ****     CyU3PReturnStatus_t status;
1773:../uvc.c      **** 
1774:../uvc.c      ****     status = CyU3PI2cInit ();
1775:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1776:../uvc.c      ****     {
1777:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1778:../uvc.c      ****         CyFxAppErrorHandler (status);
1779:../uvc.c      ****     }
1780:../uvc.c      **** 
1781:../uvc.c      ****     /*  Set I2C Configuration */
1782:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1783:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1784:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1785:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1786:../uvc.c      **** 
1787:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1788:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1789:../uvc.c      ****     {
1790:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1791:../uvc.c      ****         CyFxAppErrorHandler (status);
1792:../uvc.c      ****     }
1793:../uvc.c      **** }
1794:../uvc.c      **** 
1795:../uvc.c      **** #ifdef BACKFLOW_DETECT
1796:../uvc.c      **** static void CyFxUvcAppPibCallback (
1797:../uvc.c      ****         CyU3PPibIntrType cbType,
1798:../uvc.c      ****         uint16_t cbArg)
1799:../uvc.c      **** {
1800:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1801:../uvc.c      ****     {
1802:../uvc.c      ****         if (!back_flow_detected)
1803:../uvc.c      ****         {
1804:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1805:../uvc.c      ****             back_flow_detected = 1;
1806:../uvc.c      ****         }
1807:../uvc.c      ****     }
1808:../uvc.c      **** }
1809:../uvc.c      **** #endif
1810:../uvc.c      **** 
1811:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1812:../uvc.c      **** static void
1813:../uvc.c      **** CyFxUvcAppDebugCallback (
1814:../uvc.c      ****         CyU3PDmaChannel   *handle,
1815:../uvc.c      ****         CyU3PDmaCbType_t   type,
1816:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1817:../uvc.c      **** {
1818:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1819:../uvc.c      ****     {
1820:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1821:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1822:../uvc.c      ****     }
1823:../uvc.c      **** }
1824:../uvc.c      **** #endif
1825:../uvc.c      **** 
1826:../uvc.c      **** #if 0
1827:../uvc.c      **** static void CyFxAppIntEpCb(
1828:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1829:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1830:../uvc.c      **** 		uint8_t  ebNum)
1831:../uvc.c      **** 		{
1832:../uvc.c      **** 			//CyBool_t value;
1833:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1834:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1835:../uvc.c      **** 
1836:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1837:../uvc.c      **** 		}
1838:../uvc.c      **** #endif
1839:../uvc.c      **** 
1840:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1841:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1842:../uvc.c      ****    configures the DMA module for the UVC Application */
1843:../uvc.c      **** static void
1844:../uvc.c      **** CyFxUVCApplnInit (void)
1845:../uvc.c      **** {
1846:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1847:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1848:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1849:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1850:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1851:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1852:../uvc.c      **** 
1853:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1854:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1855:../uvc.c      **** 
1856:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1857:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1858:../uvc.c      **** #endif
1859:../uvc.c      **** 
1860:../uvc.c      ****     /* Create UVC event group */
1861:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1862:../uvc.c      ****     if (apiRetStatus != 0)
1863:../uvc.c      ****     {
1864:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1865:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1866:../uvc.c      ****     }
1867:../uvc.c      **** 
1868:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1869:../uvc.c      ****     CyFxUvcAppPTZInit ();
1870:../uvc.c      **** #endif
1871:../uvc.c      **** 
1872:../uvc.c      ****     isUsbConnected = CyFalse;
1873:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1874:../uvc.c      **** 
1875:../uvc.c      ****     /* Init the GPIO module */
1876:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1877:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1878:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1879:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1880:../uvc.c      ****     gpioClock.halfDiv    = 0;
1881:../uvc.c      **** 
1882:../uvc.c      ****     /* Initialize Gpio interface */
1883:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1884:../uvc.c      ****     if (apiRetStatus != 0)
1885:../uvc.c      ****     {
1886:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1887:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1888:../uvc.c      ****     }
1889:../uvc.c      **** 
1890:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1891:../uvc.c      ****      * must use GpioOverride to configure it */
1892:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1893:../uvc.c      ****     if (apiRetStatus != 0)
1894:../uvc.c      ****     {
1895:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1896:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1897:../uvc.c      ****     }
1898:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1899:../uvc.c      ****     if (apiRetStatus != 0)
1900:../uvc.c      ****     {
1901:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1902:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1903:../uvc.c      ****     }
1904:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1905:../uvc.c      ****     if (apiRetStatus != 0)
1906:../uvc.c      ****     {
1907:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1908:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1909:../uvc.c      ****     }
1910:../uvc.c      **** 
1911:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1912:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1913:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1914:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1915:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1916:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1917:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1918:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1919:../uvc.c      ****     {
1920:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1921:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1922:../uvc.c      ****     }
1923:../uvc.c      **** 
1924:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1925:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1926:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1927:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1928:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1929:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1930:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1931:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1932:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1933:../uvc.c      ****     {
1934:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1935:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1936:../uvc.c      ****     }
1937:../uvc.c      **** 
1938:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1939:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1940:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1941:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1942:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1943:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1944:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1945:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1947:../uvc.c      ****     {
1948:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1949:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1950:../uvc.c      ****     }
1951:../uvc.c      **** 
1952:../uvc.c      ****     /* Initialize the P-port. */
1953:../uvc.c      ****     pibclock.clkDiv      = 2;
1954:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1955:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1956:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1957:../uvc.c      **** 
1958:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1959:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1960:../uvc.c      ****     {
1961:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1962:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1963:../uvc.c      ****     }
1964:../uvc.c      **** 
1965:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1966:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1967:../uvc.c      **** 
1968:../uvc.c      **** #ifdef BACKFLOW_DETECT
1969:../uvc.c      ****     back_flow_detected = 0;
1970:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1971:../uvc.c      **** #endif
1972:../uvc.c      **** 
1973:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1974:../uvc.c      ****     SensorReset ();
1975:../uvc.c      ****     SensorInit ();
1976:../uvc.c      **** 
1977:../uvc.c      ****     /* USB initialization. */
1978:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1979:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1980:../uvc.c      ****     {
1981:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1982:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1983:../uvc.c      ****     }
1984:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1985:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1986:../uvc.c      **** 
1987:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1988:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1989:../uvc.c      **** 
1990:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1991:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1992:../uvc.c      **** 
1993:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1994:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1995:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1996:../uvc.c      **** 
1997:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1998:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1999:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2000:../uvc.c      **** 
2001:../uvc.c      ****     /* Configuration descriptors. */
2002:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2003:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2004:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2005:../uvc.c      **** 
2006:../uvc.c      ****     /* String Descriptors */
2007:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2008:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2009:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2010:../uvc.c      **** 
2011:../uvc.c      ****     /* Configure the status interrupt endpoint.
2012:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2013:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2014:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2015:../uvc.c      ****      */
2016:../uvc.c      ****     endPointConfig.enable   = 1;
2017:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2018:../uvc.c      ****     endPointConfig.pcktSize = 64;
2019:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2020:../uvc.c      ****     endPointConfig.streams  = 0;
2021:../uvc.c      ****     endPointConfig.burstLen = 1;
2022:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2023:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2024:../uvc.c      ****     {
2025:../uvc.c      ****         /* Error Handling */
2026:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2027:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2028:../uvc.c      ****     }
2029:../uvc.c      **** 
2030:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2031:../uvc.c      ****     dmaInterConfig.size           = 1024;
2032:../uvc.c      ****     dmaInterConfig.count          = 1;
2033:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2034:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2035:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2036:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2037:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2038:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2039:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2040:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2041:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2042:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2043:../uvc.c      ****             &dmaInterConfig);
2044:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2045:../uvc.c      ****     {
2046:../uvc.c      ****         /* Error handling */
2047:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2048:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2049:../uvc.c      ****     }
2050:../uvc.c      **** 
2051:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2052:../uvc.c      ****     if (glInterStaBuffer == 0)
2053:../uvc.c      ****     {
2054:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2055:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2056:../uvc.c      ****     }
2057:../uvc.c      **** 
2058:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2059:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2060:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2061:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2062:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2063:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2064:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2065:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2066:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2067:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2068:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2069:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2070:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2071:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2072:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2073:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2074:../uvc.c      ****             &dmaMultiConfig);
2075:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2076:../uvc.c      ****     {
2077:../uvc.c      ****         /* Error handling */
2078:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2079:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2080:../uvc.c      ****     }
2081:../uvc.c      **** 
2082:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2083:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2084:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2085:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2086:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2087:../uvc.c      ****      */
2088:../uvc.c      **** 
2089:../uvc.c      ****     endPointConfig.enable   = 1;
2090:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2091:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2092:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2093:../uvc.c      ****     endPointConfig.streams  = 0;
2094:../uvc.c      ****     endPointConfig.burstLen = 1;
2095:../uvc.c      **** 
2096:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2097:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2098:../uvc.c      ****     {
2099:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2100:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2101:../uvc.c      ****     }
2102:../uvc.c      **** 
2103:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2104:../uvc.c      **** 
2105:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2106:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2107:../uvc.c      ****     {
2108:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2109:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2110:../uvc.c      ****     }
2111:../uvc.c      **** 
2112:../uvc.c      ****     channelConfig.size           = 1024;
2113:../uvc.c      ****     channelConfig.count          = 1;
2114:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2115:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2116:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2117:../uvc.c      ****     channelConfig.prodHeader     = 0;
2118:../uvc.c      ****     channelConfig.prodFooter     = 0;
2119:../uvc.c      ****     channelConfig.consHeader     = 0;
2120:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2121:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2122:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2123:../uvc.c      **** 
2124:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2125:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2126:../uvc.c      ****     {
2127:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2128:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2129:../uvc.c      ****     }
2130:../uvc.c      **** 
2131:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2132:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2133:../uvc.c      ****     {
2134:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2135:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2136:../uvc.c      ****     }
2137:../uvc.c      **** 
2138:../uvc.c      ****     channelConfig.size           = 1024;
2139:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2140:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2141:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2142:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2143:../uvc.c      ****     channelConfig.prodHeader     = 0;
2144:../uvc.c      ****     channelConfig.prodFooter     = 0;
2145:../uvc.c      ****     channelConfig.consHeader     = 0;
2146:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2147:../uvc.c      ****     channelConfig.notification   = 0;
2148:../uvc.c      ****     channelConfig.cb             = 0;
2149:../uvc.c      **** 
2150:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2152:../uvc.c      ****     {
2153:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2154:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2155:../uvc.c      ****     }
2156:../uvc.c      **** 
2157:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2158:../uvc.c      ****     if (glDebugRspBuffer == 0)
2159:../uvc.c      ****     {
2160:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2161:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2162:../uvc.c      ****     }
2163:../uvc.c      **** #endif
2164:../uvc.c      **** 
2165:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2166:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2168:../uvc.c      ****     {
2169:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2170:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2171:../uvc.c      ****     }
2172:../uvc.c      **** 
2173:../uvc.c      ****     CyU3PBusyWait(100);
2174:../uvc.c      **** 
2175:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2176:../uvc.c      **** 
2177:../uvc.c      ****     endPointConfig.enable   = 1;
2178:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2179:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2180:../uvc.c      ****     {
2181:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2182:../uvc.c      ****     	endPointConfig.burstLen = 16;
2183:../uvc.c      ****     }
2184:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2185:../uvc.c      ****     {
2186:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2187:../uvc.c      ****     	endPointConfig.burstLen = 1;
2188:../uvc.c      ****     }
2189:../uvc.c      ****     endPointConfig.streams  = 0;
2190:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2191:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2192:../uvc.c      ****     {
2193:../uvc.c      ****         /* Error Handling */
2194:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2195:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2196:../uvc.c      ****     }
2197:../uvc.c      **** #if 0    //for still image method 3 using
2198:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2199:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2200:../uvc.c      ****     {
2201:../uvc.c      ****         /* Error Handling */
2202:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2203:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2204:../uvc.c      ****     }
2205:../uvc.c      **** #endif
2206:../uvc.c      **** 
2207:../uvc.c      **** }
2208:../uvc.c      **** 
2209:../uvc.c      **** /*
2210:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2211:../uvc.c      ****  * streaming session is started.
2212:../uvc.c      ****  */
2213:../uvc.c      **** static void
2214:../uvc.c      **** CyFxUvcAppGpifInit (
2215:../uvc.c      ****         void)
2216:../uvc.c      **** {
2217:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2218:../uvc.c      **** 
2219:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2220:../uvc.c      ****     {
2221:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2222:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2223:../uvc.c      ****     }
2224:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2225:../uvc.c      ****     {
2226:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2227:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2228:../uvc.c      ****     }
2229:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2230:../uvc.c      ****     {
2231:../uvc.c      ****         /* Error Handling */
2232:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2233:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2234:../uvc.c      ****     }
2235:../uvc.c      **** 
2236:../uvc.c      ****     /* Start the state machine from the designated start state. */
2237:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2238:../uvc.c      ****     {
2239:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2240:../uvc.c      ****     }
2241:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2242:../uvc.c      ****     {
2243:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2244:../uvc.c      ****     }
2245:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2246:../uvc.c      ****     {
2247:../uvc.c      ****         /* Error Handling */
2248:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2249:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2250:../uvc.c      ****     }
2251:../uvc.c      **** }
2252:../uvc.c      **** 
2253:../uvc.c      **** /*
2254:../uvc.c      ****  * Entry function for the UVC Application Thread
2255:../uvc.c      ****  */
2256:../uvc.c      **** 
2257:../uvc.c      **** uint32_t posTick;
2258:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2259:../uvc.c      **** 
2260:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 2260 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              		@ link register save eliminated.
  27              	.LVL0:
2261:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2262:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  28              		.loc 1 2262 0
  29 0000 08009FE5 		ldr	r0, .L2
  30              	.LVL1:
  31 0004 2010A0E3 		mov	r1, #32
  32 0008 0020A0E3 		mov	r2, #0
  33 000c FEFFFFEA 		b	_txe_event_flags_set
  34              	.LVL2:
  35              	.L3:
  36              		.align	2
  37              	.L2:
  38 0010 00000000 		.word	.LANCHOR0
  39              		.cfi_endproc
  40              	.LFE17:
  42              		.align	2
  43              		.global	I2cAppThread_Entry
  45              	I2cAppThread_Entry:
  46              	.LFB25:
2263:../uvc.c      **** }
2264:../uvc.c      **** 
2265:../uvc.c      **** 
2266:../uvc.c      **** void
2267:../uvc.c      **** UVCAppThread_Entry (
2268:../uvc.c      ****         uint32_t input)
2269:../uvc.c      **** {
2270:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2271:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2272:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2273:../uvc.c      ****     uint8_t i = 0;
2274:../uvc.c      ****     uint32_t flag;
2275:../uvc.c      ****     uint32_t prinflag = 0;
2276:../uvc.c      **** static uint8_t IMcount = 0;
2277:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2278:../uvc.c      ****     uint32_t frameCnt = 0;
2279:../uvc.c      **** #endif
2280:../uvc.c      ****     /* Initialize the Uart Debug Module */
2281:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2282:../uvc.c      **** 
2283:../uvc.c      ****     /* Initialize the I2C interface */
2284:../uvc.c      **** 	while (i++ < 6){
2285:../uvc.c      **** 		CyU3PThreadSleep(500);
2286:../uvc.c      **** 	}
2287:../uvc.c      **** 
2288:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2289:../uvc.c      **** 
2290:../uvc.c      ****     /* Initialize the UVC Application */
2291:../uvc.c      ****     CyFxUVCApplnInit ();
2292:../uvc.c      **** 
2293:../uvc.c      ****     /*
2294:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2295:../uvc.c      **** 
2296:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2297:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2298:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2299:../uvc.c      **** 
2300:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2301:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2302:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2303:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2304:../uvc.c      **** 
2305:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2306:../uvc.c      ****        of handling the abort request.
2307:../uvc.c      ****      */
2308:../uvc.c      **** 
2309:../uvc.c      ****     for (;;)
2310:../uvc.c      ****     {
2311:../uvc.c      ****         /* Waiting for the Video Stream Event */
2312:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2313:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2314:../uvc.c      ****         {
2315:../uvc.c      **** #if 0 //test for new firmware no video bring up
2316:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2317:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2318:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2319:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2320:../uvc.c      ****             {
2321:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2322:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2323:../uvc.c      ****                 {
2324:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2325:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2326:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2327:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2328:../uvc.c      **** #endif
2329:../uvc.c      **** #endif
2330:../uvc.c      ****                     }
2331:../uvc.c      ****                 else
2332:../uvc.c      ****                 {
2333:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2334:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2335:../uvc.c      **** #ifdef USB_LOWRES_IMG
2336:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2337:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2338:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2339:../uvc.c      **** #endif
2340:../uvc.c      **** #endif
2341:../uvc.c      ****                 }
2342:../uvc.c      **** 
2343:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2344:../uvc.c      ****                 prodCount++;
2345:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2346:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2347:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2348:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2349:../uvc.c      ****                 {
2350:../uvc.c      ****                     prodCount--;
2351:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2352:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2353:../uvc.c      ****                 }
2354:../uvc.c      ****             }
2355:../uvc.c      **** #endif
2356:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2357:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2358:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2359:../uvc.c      ****             {
2360:../uvc.c      ****             	if(0&&(prinflag == 0)){
2361:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2362:../uvc.c      ****             		prinflag = 1;
2363:../uvc.c      ****             	}
2364:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2365:../uvc.c      ****             	fb=0;
2366:../uvc.c      ****             	pb=0;
2367:../uvc.c      ****             	pbc=0;
2368:../uvc.c      ****                 prodCount = 0;
2369:../uvc.c      ****                 consCount = 0;
2370:../uvc.c      ****                 hitFV     = CyFalse;
2371:../uvc.c      **** 
2372:../uvc.c      **** #ifdef BACKFLOW_DETECT
2373:../uvc.c      ****                 back_flow_detected = 0;
2374:../uvc.c      **** #endif
2375:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2376:../uvc.c      ****                 frameCnt++;
2377:../uvc.c      **** #endif
2378:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2379:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2380:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2381:../uvc.c      ****                 //}
2382:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2383:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2384:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2385:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2386:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2387:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2388:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2389:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2390:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2391:../uvc.c      ****                 		stiflag = 0xFF;
2392:../uvc.c      ****                 		IMcount = 0;
2393:../uvc.c      ****                 	}
2394:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2395:../uvc.c      **** 
2396:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2397:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2398:../uvc.c      ****                 		stiflag = 0x0F;
2399:../uvc.c      ****                 		IMcount = 0;
2400:../uvc.c      ****                 		}
2401:../uvc.c      ****                  		/*if(IMcount > 0x4){
2402:../uvc.c      ****                 			stiflag = 0x0F;
2403:../uvc.c      ****                 			IMcount = 0;
2404:../uvc.c      ****                 		}*/
2405:../uvc.c      **** 
2406:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2407:../uvc.c      ****                     //CyU3PThreadSleep(400);
2408:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2409:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2410:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2411:../uvc.c      **** 
2412:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2413:../uvc.c      ****                 	{
2414:../uvc.c      ****                     switch (setRes)
2415:../uvc.c      ****                      {
2416:../uvc.c      ****                  	case 1: //720
2417:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2418:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2419:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0xb, 0x0);
2420:../uvc.c      ****                  		break;
2421:../uvc.c      ****                  	case 2: //960
2422:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2423:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2424:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0x0b, 0x1);
2425:../uvc.c      ****                  		break;
2426:../uvc.c      ****                  	default:
2427:../uvc.c      ****                  		break;
2428:../uvc.c      ****                      }
2429:../uvc.c      ****                     IMcount = 0;
2430:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2431:../uvc.c      ****                 	stiflag = 0x0;
2432:../uvc.c      ****                 	}
2433:../uvc.c      ****                 }
2434:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2435:../uvc.c      ****                 /* Reset the DMA channel. */
2436:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2437:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2438:../uvc.c      ****                 {
2439:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2440:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2441:../uvc.c      ****                 }
2442:../uvc.c      **** 
2443:../uvc.c      ****                 /* Start Channel Immediately */
2444:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2445:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2446:../uvc.c      ****                 {
2447:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2448:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2449:../uvc.c      ****                 }
2450:../uvc.c      **** 
2451:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2452:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2453:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2454:../uvc.c      ****                 }
2455:../uvc.c      ****         }
2456:../uvc.c      ****         else
2457:../uvc.c      ****         {
2458:../uvc.c      ****             /* If we have a stream abort request pending. */
2459:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2460:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2461:../uvc.c      ****             {
2462:../uvc.c      ****                 hitFV     = CyFalse;
2463:../uvc.c      ****                 prodCount = 0;
2464:../uvc.c      ****                 consCount = 0;
2465:../uvc.c      ****                 if(0&&(prinflag == 0)){
2466:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2467:../uvc.c      ****                 	prinflag = 1;
2468:../uvc.c      ****                 }
2469:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2470:../uvc.c      ****                 fb=0;
2471:../uvc.c      ****                 pb=0;
2472:../uvc.c      ****                 pbc=0;
2473:../uvc.c      **** 
2474:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2475:../uvc.c      ****                 {
2476:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2477:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2478:../uvc.c      ****                     {
2479:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2480:../uvc.c      ****                     }
2481:../uvc.c      **** 
2482:../uvc.c      ****                     /* Flush the Endpoint memory */
2483:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2484:../uvc.c      ****                 }
2485:../uvc.c      **** 
2486:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2487:../uvc.c      ****             }
2488:../uvc.c      ****             else
2489:../uvc.c      ****             {
2490:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2491:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2492:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2493:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2494:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2495:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2496:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2497:../uvc.c      ****                 {
2498:../uvc.c      ****                     /* Error handling */
2499:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2500:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2501:../uvc.c      ****                 }
2502:../uvc.c      **** 
2503:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2504:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2505:../uvc.c      ****                 {
2506:../uvc.c      **** #if 0
2507:../uvc.c      ****                 	//for start up of the AF Lens
2508:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2509:../uvc.c      ****                     CyU3PThreadSleep(500);
2510:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2511:../uvc.c      ****                     CyU3PThreadSleep(500);
2512:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2513:../uvc.c      ****                    	CyU3PThreadSleep(300);
2514:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2515:../uvc.c      ****                     CyU3PThreadSleep(500);
2516:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2517:../uvc.c      ****                     CyU3PThreadSleep(500);
2518:../uvc.c      **** #endif
2519:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2520:../uvc.c      ****                     gpif_initialized = CyTrue;
2521:../uvc.c      ****                     CyU3PThreadSleep(200);
2522:../uvc.c      ****                     
2523:../uvc.c      ****                 }
2524:../uvc.c      ****                 else
2525:../uvc.c      ****                 {
2526:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2527:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2528:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2529:../uvc.c      ****                 }
2530:../uvc.c      ****             }
2531:../uvc.c      ****         }
2532:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2533:../uvc.c      **** 
2534:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2535:../uvc.c      ****         CyU3PThreadRelinquish ();
2536:../uvc.c      ****     }
2537:../uvc.c      **** }
2538:../uvc.c      **** 
2539:../uvc.c      **** /*
2540:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2541:../uvc.c      ****  */
2542:../uvc.c      **** 
2543:../uvc.c      **** static void
2544:../uvc.c      **** UVCHandleProcessingUnitRqts (
2545:../uvc.c      ****         void)
2546:../uvc.c      **** {
2547:../uvc.c      ****     uint8_t CtrlAdd;
2548:../uvc.c      **** #ifdef DbgInfo
2549:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2550:../uvc.c      **** #endif
2551:../uvc.c      ****     switch (wValue)
2552:../uvc.c      ****     {
2553:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2554:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2555:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2556:../uvc.c      ****     		break;
2557:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2558:../uvc.c      ****         	CtrlAdd = CtrlParArry[ExtExRefCtlID10/*BrgtCtlID1*/][0]; //Exreference places brightness.
2559:../uvc.c      ****    			ControlHandle(ExtExRefCtlID10/*BrgtCtlID1*/);
2560:../uvc.c      ****     		break;
2561:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2562:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2563:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2564:../uvc.c      **** 			break;
2565:../uvc.c      **** 
2566:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2567:../uvc.c      **** 
2568:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2569:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2570:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2571:../uvc.c      ****       		break;
2572:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2573:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2574:../uvc.c      ****      		ControlHandle(HueCtlID5);
2575:../uvc.c      ****      		break;
2576:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2577:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2578:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2579:../uvc.c      ****           		break;
2580:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2581:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2582:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2583:../uvc.c      ****           		break;
2584:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2585:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2586:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2587:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2588:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2589:../uvc.c      ****     		break;
2590:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2591:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2592:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2593:../uvc.c      ****     		break;
2594:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2595:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2596:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2597:../uvc.c      ****     		break;
2598:../uvc.c      **** 
2599:../uvc.c      ****         default:
2600:../uvc.c      ****             /*
2601:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2602:../uvc.c      ****              * other controls.
2603:../uvc.c      ****              */
2604:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2605:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2606:../uvc.c      ****             break;
2607:../uvc.c      ****     }
2608:../uvc.c      **** }
2609:../uvc.c      **** 
2610:../uvc.c      **** /*
2611:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2612:../uvc.c      ****  */
2613:../uvc.c      **** static void
2614:../uvc.c      **** UVCHandleCameraTerminalRqts (
2615:../uvc.c      ****         void)
2616:../uvc.c      **** {
2617:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2618:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2619:../uvc.c      ****     uint16_t readCount;
2620:../uvc.c      ****     uint16_t zoomVal;
2621:../uvc.c      ****     int32_t  panVal, tiltVal;
2622:../uvc.c      ****     CyBool_t sendData = CyFalse;
2623:../uvc.c      **** #endif
2624:../uvc.c      ****     uint8_t CtrlAdd;
2625:../uvc.c      **** 
2626:../uvc.c      ****     switch (wValue)
2627:../uvc.c      ****     {
2628:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2629:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2630:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2631:../uvc.c      ****     		break;
2632:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2633:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2634:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2635:../uvc.c      ****     		break;
2636:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2637:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2638:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2639:../uvc.c      **** 			break;
2640:../uvc.c      **** 
2641:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2642:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2643:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2644:../uvc.c      **** 			break;
2645:../uvc.c      **** 
2646:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2647:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2648:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2649:../uvc.c      ****       		break;
2650:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2651:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2652:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2653:../uvc.c      ****      		break;
2654:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2655:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2656:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2657:../uvc.c      ****           		break;
2658:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2659:../uvc.c      ****           		break;
2660:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2661:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2662:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2663:../uvc.c      ****      		break;
2664:../uvc.c      **** 
2665:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2666:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2667:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2668:../uvc.c      ****     		break;
2669:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2670:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2671:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2672:../uvc.c      ****     		break;
2673:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2674:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2675:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2676:../uvc.c      ****     		break;
2677:../uvc.c      **** 
2678:../uvc.c      ****         default:
2679:../uvc.c      ****             /*
2680:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2681:../uvc.c      ****              * other controls.
2682:../uvc.c      ****              */
2683:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2684:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2685:../uvc.c      ****             break;
2686:../uvc.c      ****     }
2687:../uvc.c      **** 
2688:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2689:../uvc.c      ****     switch (wValue)
2690:../uvc.c      ****     {
2691:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2692:../uvc.c      ****             switch (bRequest)
2693:../uvc.c      ****             {
2694:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2695:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2696:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2697:../uvc.c      ****                     break;
2698:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2699:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2700:../uvc.c      ****                     sendData = CyTrue;
2701:../uvc.c      ****                     break;
2702:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2703:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2704:../uvc.c      ****                     sendData = CyTrue;
2705:../uvc.c      ****                     break;
2706:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2707:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2708:../uvc.c      ****                     sendData = CyTrue;
2709:../uvc.c      ****                     break;
2710:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2711:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2712:../uvc.c      ****                     sendData = CyTrue;
2713:../uvc.c      ****                     break;
2714:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2715:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2716:../uvc.c      ****                     sendData = CyTrue;
2717:../uvc.c      ****                     break;
2718:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2719:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2720:../uvc.c      ****                             glEp0Buffer, &readCount);
2721:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2722:../uvc.c      ****                     {
2723:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2724:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2725:../uvc.c      ****                     }
2726:../uvc.c      ****                     break;
2727:../uvc.c      ****                 default:
2728:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2729:../uvc.c      ****                     break;
2730:../uvc.c      ****             }
2731:../uvc.c      **** 
2732:../uvc.c      ****             if (sendData)
2733:../uvc.c      ****             {
2734:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2735:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2736:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2737:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2738:../uvc.c      ****             }
2739:../uvc.c      ****             break;
2740:../uvc.c      **** 
2741:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2742:../uvc.c      ****             switch (bRequest)
2743:../uvc.c      ****             {
2744:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2745:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2746:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2747:../uvc.c      ****                     break;
2748:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2749:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2750:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2751:../uvc.c      ****                     sendData = CyTrue;
2752:../uvc.c      ****                     break;
2753:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2754:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2755:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2756:../uvc.c      ****                     sendData = CyTrue;
2757:../uvc.c      ****                     break;
2758:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2759:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2760:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2761:../uvc.c      ****                     sendData = CyTrue;
2762:../uvc.c      ****                     break;
2763:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2764:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2765:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2766:../uvc.c      ****                     sendData = CyTrue;
2767:../uvc.c      ****                     break;
2768:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2769:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2770:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2771:../uvc.c      ****                     sendData = CyTrue;
2772:../uvc.c      ****                     break;
2773:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2774:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2775:../uvc.c      ****                             glEp0Buffer, &readCount);
2776:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2777:../uvc.c      ****                     {
2778:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2779:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2780:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2781:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2782:../uvc.c      **** 
2783:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2784:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2785:../uvc.c      ****                     }
2786:../uvc.c      ****                     break;
2787:../uvc.c      ****                 default:
2788:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2789:../uvc.c      ****                     break;
2790:../uvc.c      ****             }
2791:../uvc.c      **** 
2792:../uvc.c      ****             if (sendData)
2793:../uvc.c      ****             {
2794:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2795:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2796:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2797:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2798:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2799:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2800:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2801:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2802:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2803:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2804:../uvc.c      ****             }
2805:../uvc.c      ****             break;
2806:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2807:../uvc.c      ****         default:
2808:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2809:../uvc.c      ****             break;
2810:../uvc.c      ****     }
2811:../uvc.c      **** #endif
2812:../uvc.c      **** }
2813:../uvc.c      **** 
2814:../uvc.c      **** /*
2815:../uvc.c      ****  * Handler for UVC Interface control requests.
2816:../uvc.c      ****  */
2817:../uvc.c      **** static void
2818:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2819:../uvc.c      ****         void)
2820:../uvc.c      **** {
2821:../uvc.c      **** 
2822:../uvc.c      ****     switch (wValue)
2823:../uvc.c      ****     {
2824:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2825:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2826:../uvc.c      ****     		break;
2827:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2828:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2829:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2830:../uvc.c      ****     		break;
2831:../uvc.c      ****     	default:
2832:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2833:../uvc.c      ****      		break;
2834:../uvc.c      ****     }
2835:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2836:../uvc.c      **** 
2837:../uvc.c      **** }
2838:../uvc.c      **** 
2839:../uvc.c      **** /*
2840:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2841:../uvc.c      ****  */
2842:../uvc.c      **** static void
2843:../uvc.c      **** UVCHandleExtensionUnitRqts (
2844:../uvc.c      ****         void)
2845:../uvc.c      **** {
2846:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2847:../uvc.c      **** 
2848:../uvc.c      **** #ifdef DbgInfo
2849:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2850:../uvc.c      **** #endif
2851:../uvc.c      ****     switch (wValue)
2852:../uvc.c      ****     {
2853:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2854:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2855:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2856:../uvc.c      ****     		break;
2857:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2858:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2859:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2860:../uvc.c      ****     		break;
2861:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2862:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2863:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2864:../uvc.c      ****      		break;
2865:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2866:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2867:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2868:../uvc.c      ****     		break;
2869:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2870:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2871:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2872:../uvc.c      ****     		break;
2873:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2874:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2875:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2876:../uvc.c      ****      		break;
2877:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2878:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2879:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2880:../uvc.c      ****     		break;
2881:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2882:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2883:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2884:../uvc.c      ****     		break;
2885:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2886:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2887:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2888:../uvc.c      ****      		break;
2889:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2890:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2891:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2892:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2893:../uvc.c      ****     		}else/* no support for 1080p camera */
2894:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2895:../uvc.c      ****     		break;
2896:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2897:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2898:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2899:../uvc.c      ****     		break;
2900:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2901:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2902:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2903:../uvc.c      ****     		break;
2904:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2905:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2906:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2907:../uvc.c      ****     		//break;
2908:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2909:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2910:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2911:../uvc.c      ****     		break;
2912:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2913:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2914:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2915:../uvc.c      ****     		break;
2916:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2917:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2918:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2919:../uvc.c      ****     		break;
2920:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2921:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2922:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2923:../uvc.c      ****     		break;
2924:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2925:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2926:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2927:../uvc.c      ****     		break;
2928:../uvc.c      ****    	default:
2929:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2930:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2931:../uvc.c      ****     		break;
2932:../uvc.c      ****     }
2933:../uvc.c      **** 
2934:../uvc.c      **** }
2935:../uvc.c      **** 
2936:../uvc.c      **** /*
2937:../uvc.c      ****  * Handler for the video streaming control requests.
2938:../uvc.c      ****  */
2939:../uvc.c      **** static void
2940:../uvc.c      **** UVCHandleVideoStreamingRqts (
2941:../uvc.c      ****         void)
2942:../uvc.c      **** {
2943:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2944:../uvc.c      ****     uint16_t readCount;
2945:../uvc.c      **** 
2946:../uvc.c      ****     switch (wValue)
2947:../uvc.c      ****     {
2948:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2949:../uvc.c      ****             switch (bRequest)
2950:../uvc.c      ****             {
2951:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2952:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2953:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2954:../uvc.c      ****                     break;
2955:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2956:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2957:../uvc.c      ****                     glEp0Buffer[1] = 0;
2958:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2959:../uvc.c      ****                     break;
2960:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2961:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2962:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2963:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2964:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED)//supports both SS and HS
2965:../uvc.c      ****                     {
2966:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2967:../uvc.c      ****                     }
2968:../uvc.c      ****                     else
2969:../uvc.c      ****                     {
2970:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2971:../uvc.c      ****                     }
2972:../uvc.c      ****                     break;
2973:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2974:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2975:../uvc.c      ****                             glCommitCtrl, &readCount);
2976:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2977:../uvc.c      ****                     {
2978:../uvc.c      ****                         //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
2979:../uvc.c      ****                         {
2980:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2981:../uvc.c      ****                                active data structure. */
2982:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2983:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2984:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2985:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2986:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2987:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2988:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
2989:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
2990:../uvc.c      ****                         }
2991:../uvc.c      ****                     }
2992:../uvc.c      ****                     break;
2993:../uvc.c      ****                 default:
2994:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2995:../uvc.c      ****                     break;
2996:../uvc.c      ****             }
2997:../uvc.c      ****             break;
2998:../uvc.c      **** 
2999:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3000:../uvc.c      ****             switch (bRequest)
3001:../uvc.c      ****             {
3002:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3003:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3004:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3005:../uvc.c      ****                     break;
3006:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3007:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3008:../uvc.c      ****                     glEp0Buffer[1] = 0;
3009:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3010:../uvc.c      ****                     break;
3011:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3012:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED) //support both SS and HS
3013:../uvc.c      ****                     {
3014:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3015:../uvc.c      ****                     }
3016:../uvc.c      ****                     else
3017:../uvc.c      ****                     {
3018:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3019:../uvc.c      ****                     }
3020:../uvc.c      ****                     break;
3021:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3022:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3023:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3024:../uvc.c      ****                        */
3025:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3026:../uvc.c      ****                             glCommitCtrl, &readCount);
3027:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)//supports both SS and HS
3028:../uvc.c      ****                     {
3029:../uvc.c      ****                         if(setRes != glCommitCtrl[3])
3030:../uvc.c      ****                         {
3031:../uvc.c      ****                         switch (glCommitCtrl[3])
3032:../uvc.c      ****                          {
3033:../uvc.c      ****                          	case 1: //720 or 360
3034:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
3035:../uvc.c      ****                          		CyU3PThreadSleep(500);
3036:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
3037:../uvc.c      ****                          		break;
3038:../uvc.c      ****                          	case 2: //960 or 480
3039:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
3040:../uvc.c      ****                          		CyU3PThreadSleep(500);
3041:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
3042:../uvc.c      ****                          		break;
3043:../uvc.c      ****                          	default:
3044:../uvc.c      ****                          		break;
3045:../uvc.c      ****                          }                         
3046:../uvc.c      ****                         setRes = glCommitCtrl[3];
3047:../uvc.c      ****                         }
3048:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3049:../uvc.c      **** 
3050:../uvc.c      **** #if 0
3051:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3052:../uvc.c      ****                         {
3053:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3054:../uvc.c      ****                         }
3055:../uvc.c      ****                         else
3056:../uvc.c      ****                         {
3057:../uvc.c      ****                             SensorScaling_VGA ();
3058:../uvc.c      ****                         }
3059:../uvc.c      **** #endif
3060:../uvc.c      ****                         /* We can start streaming video now. */
3061:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3062:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3063:../uvc.c      ****                         {
3064:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3065:../uvc.c      ****                         }
3066:../uvc.c      ****                     }
3067:../uvc.c      ****                     break;
3068:../uvc.c      **** 
3069:../uvc.c      ****                 default:
3070:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3071:../uvc.c      ****                     break;
3072:../uvc.c      ****             }
3073:../uvc.c      ****             break;
3074:../uvc.c      **** 
3075:../uvc.c      **** /* still image streaming handler */
3076:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3077:../uvc.c      ****                 switch (bRequest)
3078:../uvc.c      ****                 {
3079:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3080:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3081:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3082:../uvc.c      ****                         break;
3083:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3084:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3085:../uvc.c      ****                         glEp0Buffer[1] = 0;
3086:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3087:../uvc.c      ****                         break;
3088:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3089:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3090:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3091:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3092:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3093:../uvc.c      ****                         {
3094:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3095:../uvc.c      ****                         }
3096:../uvc.c      ****                         else
3097:../uvc.c      ****                         {
3098:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3099:../uvc.c      ****                         }
3100:../uvc.c      ****                         break;
3101:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3102:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3103:../uvc.c      ****                                 glCommitCtrl, &readCount);
3104:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3105:../uvc.c      ****                         {
3106:../uvc.c      ****                             //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
3107:../uvc.c      ****                             {
3108:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3109:../uvc.c      ****                                    active data structure. */
3110:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3111:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3112:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
3113:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
3114:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
3115:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
3116:../uvc.c      ****                             }
3117:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3118:../uvc.c      ****                         }
3119:../uvc.c      ****                         break;
3120:../uvc.c      ****                     default:
3121:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3122:../uvc.c      ****                         break;
3123:../uvc.c      ****                 }
3124:../uvc.c      ****                 break;
3125:../uvc.c      **** 
3126:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3127:../uvc.c      ****                 switch (bRequest)
3128:../uvc.c      ****                 {
3129:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3130:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3131:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3132:../uvc.c      ****                         break;
3133:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3134:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3135:../uvc.c      ****                         glEp0Buffer[1] = 0;
3136:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3137:../uvc.c      ****                         break;
3138:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3139:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3140:../uvc.c      ****                         {
3141:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3142:../uvc.c      ****                         }
3143:../uvc.c      ****                         else
3144:../uvc.c      ****                         {
3145:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3146:../uvc.c      ****                         }
3147:../uvc.c      ****                         break;
3148:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3149:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3150:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3151:../uvc.c      ****                            */
3152:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3153:../uvc.c      ****                                 glCommitCtrl, &readCount);
3154:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3155:../uvc.c      ****                         {
3156:../uvc.c      ****     #if 0
3157:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3158:../uvc.c      ****                             {
3159:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3160:../uvc.c      ****                             }
3161:../uvc.c      ****                             else
3162:../uvc.c      ****                             {
3163:../uvc.c      ****                                 SensorScaling_VGA ();
3164:../uvc.c      ****                             }
3165:../uvc.c      ****                             /* We can start streaming video now. */
3166:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3167:../uvc.c      **** 
3168:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3169:../uvc.c      ****                             {
3170:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3171:../uvc.c      ****                             }
3172:../uvc.c      **** 	#endif
3173:../uvc.c      **** #if 0 //remove the still resolution set for invendo because the still res. is always the same as th
3174:../uvc.c      ****                            switch (glCommitCtrl[1])
3175:../uvc.c      ****                              {
3176:../uvc.c      ****                              	case 1: //720
3177:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*
3178:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3179:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3180:../uvc.c      ****                              		break;
3181:../uvc.c      ****                             	case 2: //960
3182:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*
3183:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3184:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3185:../uvc.c      ****                              		break;
3186:../uvc.c      ****                               	default:
3187:../uvc.c      ****                              		break;
3188:../uvc.c      ****                              }
3189:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3190:../uvc.c      **** 
3191:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3192:../uvc.c      **** #endif
3193:../uvc.c      ****                         }
3194:../uvc.c      ****                         break;
3195:../uvc.c      **** 
3196:../uvc.c      ****                     default:
3197:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3198:../uvc.c      ****                         break;
3199:../uvc.c      ****                 }
3200:../uvc.c      ****                 break;
3201:../uvc.c      **** 
3202:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3203:../uvc.c      ****                 switch (bRequest)
3204:../uvc.c      ****                 {
3205:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3206:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3207:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3208:../uvc.c      ****                         break;
3209:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3210:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3211:../uvc.c      ****                         glEp0Buffer[1] = 0;
3212:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3213:../uvc.c      ****                         break;
3214:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3215:../uvc.c      ****                         if (1 || usbSpeed == CY_U3P_SUPER_SPEED)// support both SS and HS
3216:../uvc.c      ****                         {
3217:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3218:../uvc.c      ****                         }
3219:../uvc.c      ****                         else
3220:../uvc.c      ****                         {
3221:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3222:../uvc.c      ****                         }
3223:../uvc.c      ****                         break;
3224:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3225:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3226:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3227:../uvc.c      ****                            */
3228:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3229:../uvc.c      ****                                 glCommitCtrl, &readCount);
3230:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3231:../uvc.c      ****                         {
3232:../uvc.c      ****     #if 1
3233:../uvc.c      ****                             /* We can start still streaming video now. */
3234:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3235:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3236:../uvc.c      ****                             {
3237:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3238:../uvc.c      ****                             }
3239:../uvc.c      ****     #endif
3240:../uvc.c      ****                             else{
3241:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3242:../uvc.c      ****                             //stillcont = 0;
3243:../uvc.c      ****                             }
3244:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3245:../uvc.c      ****                         }else{
3246:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3247:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3248:../uvc.c      ****                         }
3249:../uvc.c      ****                         break;
3250:../uvc.c      **** 
3251:../uvc.c      ****                     default:
3252:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3253:../uvc.c      ****                         break;
3254:../uvc.c      ****                 }
3255:../uvc.c      ****                 break;
3256:../uvc.c      **** 
3257:../uvc.c      ****         default:
3258:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3259:../uvc.c      ****             break;
3260:../uvc.c      ****     }
3261:../uvc.c      **** }
3262:../uvc.c      **** 
3263:../uvc.c      **** /*
3264:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3265:../uvc.c      ****  */
3266:../uvc.c      **** void
3267:../uvc.c      **** UVCAppEP0Thread_Entry (
3268:../uvc.c      ****         uint32_t input)
3269:../uvc.c      **** {
3270:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3271:../uvc.c      ****     uint32_t eventFlag;
3272:../uvc.c      **** 	CyBool_t value;
3273:../uvc.c      **** 	CyBool_t *valueptr = &value;
3274:../uvc.c      **** 
3275:../uvc.c      **** 
3276:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3277:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3278:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3279:../uvc.c      **** 
3280:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3281:../uvc.c      **** #endif
3282:../uvc.c      **** 
3283:../uvc.c      ****     /* for interrupt status test */
3284:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3285:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3286:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3287:../uvc.c      **** 
3288:../uvc.c      ****     for (;;)
3289:../uvc.c      ****     {
3290:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3291:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3292:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3293:../uvc.c      ****         {
3294:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3295:../uvc.c      ****             if (!isUsbConnected)
3296:../uvc.c      ****             {
3297:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3298:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3299:../uvc.c      ****                 {
3300:../uvc.c      ****                     isUsbConnected = CyTrue;
3301:../uvc.c      ****                 }
3302:../uvc.c      ****             }
3303:../uvc.c      **** //#ifdef DbgInfo
3304:../uvc.c      **** #if 0
3305:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3306:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3307:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3308:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3309:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3310:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3311:../uvc.c      **** #endif
3312:../uvc.c      **** //#endif
3313:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3314:../uvc.c      ****             {
3315:../uvc.c      ****             	switch ((wIndex >> 8))
3316:../uvc.c      ****                 {
3317:../uvc.c      **** 
3318:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3319:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3320:../uvc.c      ****                         break;
3321:../uvc.c      **** 
3322:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3323:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3324:../uvc.c      ****                         break;
3325:../uvc.c      **** 
3326:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3327:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3328:../uvc.c      ****                         break;
3329:../uvc.c      **** 
3330:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3331:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3332:../uvc.c      ****                         break;
3333:../uvc.c      **** 
3334:../uvc.c      ****                     default:
3335:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3336:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3337:../uvc.c      ****                         break;
3338:../uvc.c      ****                 }
3339:../uvc.c      ****             }
3340:../uvc.c      **** 
3341:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3342:../uvc.c      ****             {
3343:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3344:../uvc.c      **** 
3345:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3346:../uvc.c      ****                 {
3347:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3348:../uvc.c      ****                 }
3349:../uvc.c      ****                 else
3350:../uvc.c      ****                 {
3351:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3352:../uvc.c      ****                 }
3353:../uvc.c      ****             }
3354:../uvc.c      **** 
3355:../uvc.c      ****             /* handle interrupt status event */
3356:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3357:../uvc.c      ****             {
3358:../uvc.c      **** 
3359:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3360:../uvc.c      ****             	/** preparing interrupt status data **/
3361:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3362:../uvc.c      **** 
3363:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3364:../uvc.c      **** 
3365:../uvc.c      **** #if 1 //for real button
3366:../uvc.c      **** 				if(value&&(!snapButFlag)){
3367:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3368:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3369:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3370:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3371:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3372:../uvc.c      **** 
3373:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3374:../uvc.c      **** 					interStabuf.size   = 1024;
3375:../uvc.c      **** 					interStabuf.status = 0;
3376:../uvc.c      **** 
3377:../uvc.c      **** 					interStabuf.count = 4;
3378:../uvc.c      **** 
3379:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3380:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3381:../uvc.c      **** 
3382:../uvc.c      **** 					/** send a interrupt status data **/
3383:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3384:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3385:../uvc.c      **** 					{
3386:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3387:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3388:../uvc.c      **** 					}
3389:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3390:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3391:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3392:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3393:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3394:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3395:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3396:../uvc.c      **** 
3397:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3398:../uvc.c      **** 					interStabuf.size   = 1024;
3399:../uvc.c      **** 					interStabuf.status = 0;
3400:../uvc.c      **** 
3401:../uvc.c      **** 					interStabuf.count = 4;
3402:../uvc.c      **** 
3403:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3404:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3405:../uvc.c      **** 
3406:../uvc.c      **** 					/** send a interrupt status data **/
3407:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3408:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3409:../uvc.c      **** 					{
3410:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3411:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3412:../uvc.c      **** 					}
3413:../uvc.c      **** 
3414:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3415:../uvc.c      **** 					stiflag = 0xFF;
3416:../uvc.c      **** 				}
3417:../uvc.c      **** #else			//for botton simulation
3418:../uvc.c      **** 				if(snapButFlag == 0x0f){
3419:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3420:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3421:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3422:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3423:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3424:../uvc.c      **** 
3425:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3426:../uvc.c      **** 					interStabuf.size   = 1024;
3427:../uvc.c      **** 					interStabuf.status = 0;
3428:../uvc.c      **** 
3429:../uvc.c      **** 					interStabuf.count = 4;
3430:../uvc.c      **** 
3431:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3432:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3433:../uvc.c      **** 
3434:../uvc.c      **** 					/** send a interrupt status data **/
3435:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3436:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3437:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3438:../uvc.c      **** 					{
3439:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3440:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3441:../uvc.c      **** 					}
3442:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3443:../uvc.c      **** 
3444:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3445:../uvc.c      **** 				}else if(!snapButFlag){
3446:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3447:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3448:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3449:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3450:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3451:../uvc.c      **** 
3452:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3453:../uvc.c      **** 					interStabuf.size   = 1024;
3454:../uvc.c      **** 					interStabuf.status = 0;
3455:../uvc.c      **** 
3456:../uvc.c      **** 					interStabuf.count = 4;
3457:../uvc.c      **** 
3458:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3459:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3460:../uvc.c      **** 
3461:../uvc.c      **** 					/** send a interrupt status data **/
3462:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3463:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3464:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3465:../uvc.c      **** 					{
3466:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3467:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3468:../uvc.c      **** 					}
3469:../uvc.c      **** 
3470:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3471:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3472:../uvc.c      **** 				}
3473:../uvc.c      **** #endif
3474:../uvc.c      **** 
3475:../uvc.c      ****             }
3476:../uvc.c      **** 
3477:../uvc.c      **** 
3478:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3479:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3480:../uvc.c      ****             {
3481:../uvc.c      ****                 /* Get the command buffer */
3482:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3483:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3484:../uvc.c      ****                 {
3485:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3486:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3487:../uvc.c      ****                 }
3488:../uvc.c      **** 
3489:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3490:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3491:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3492:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3493:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3494:../uvc.c      ****                  * register value high byte and register value low byte.
3495:../uvc.c      ****                  */
3496:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3497:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3498:../uvc.c      ****                 {
3499:../uvc.c      ****                     if (dmaInfo.count == 3)
3500:../uvc.c      ****                     {
3501:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3502:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3503:../uvc.c      ****                         dmaInfo.count = 3;
3504:../uvc.c      ****                     }
3505:../uvc.c      ****                     else if (dmaInfo.count == 4)
3506:../uvc.c      ****                     {
3507:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3508:../uvc.c      ****                         {
3509:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3510:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3511:../uvc.c      ****                         }
3512:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3513:../uvc.c      ****                     }
3514:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3515:../uvc.c      ****                 }
3516:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3517:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3518:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3519:../uvc.c      ****                  */
3520:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3521:../uvc.c      ****                 {
3522:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3523:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3524:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3525:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3526:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3527:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3528:../uvc.c      ****                         	break;
3529:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3530:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3531:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3532:../uvc.c      ****                         	break;*/
3533:../uvc.c      ****                     dmaInfo.count -= 2;
3534:../uvc.c      ****                 }
3535:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3536:../uvc.c      ****                 else
3537:../uvc.c      ****                 {
3538:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3539:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3540:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3541:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3542:../uvc.c      ****                 }
3543:../uvc.c      **** 
3544:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3545:../uvc.c      ****                 dmaInfo.size   = 1024;
3546:../uvc.c      ****                 dmaInfo.status = 0;
3547:../uvc.c      **** 
3548:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3549:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3550:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3551:../uvc.c      ****                 {
3552:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3553:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3554:../uvc.c      ****                 }
3555:../uvc.c      **** 
3556:../uvc.c      ****                 /* Wait until the response has gone out. */
3557:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3558:../uvc.c      **** 
3559:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3560:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3561:../uvc.c      ****                 {
3562:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3563:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3564:../uvc.c      ****                 }
3565:../uvc.c      ****             }
3566:../uvc.c      **** #endif
3567:../uvc.c      ****         }
3568:../uvc.c      ****         /* Allow other ready threads to run. */
3569:../uvc.c      ****         CyU3PThreadRelinquish ();
3570:../uvc.c      ****     }
3571:../uvc.c      **** }
3572:../uvc.c      **** 
3573:../uvc.c      **** /*
3574:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3575:../uvc.c      ****  * added 10/2013
3576:../uvc.c      ****  */
3577:../uvc.c      **** /*
3578:../uvc.c      **** static uint8_t timeDelay[64] = {
3579:../uvc.c      **** 
3580:../uvc.c      **** };
3581:../uvc.c      **** */
3582:../uvc.c      **** 
3583:../uvc.c      **** static uint8_t timercount = 0;
3584:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  47              		.loc 1 3584 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 8
  50              		@ frame_needed = 0, uses_anonymous_args = 0
  51              	.LVL3:
  52 0014 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
  53              	.LCFI0:
  54              		.cfi_def_cfa_offset 36
  55              		.cfi_offset 4, -36
  56              		.cfi_offset 5, -32
  57              		.cfi_offset 6, -28
  58              		.cfi_offset 7, -24
  59              		.cfi_offset 8, -20
  60              		.cfi_offset 9, -16
  61              		.cfi_offset 10, -12
  62              		.cfi_offset 11, -8
  63              		.cfi_offset 14, -4
3585:../uvc.c      **** 
3586:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3587:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3588:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3589:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3590:../uvc.c      **** 	VdstateDes *lcStaDes;
3591:../uvc.c      **** 	uint32_t flag = 0;
3592:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3593:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3594:../uvc.c      **** 	uint8_t i, curFlagIdx;
3595:../uvc.c      **** 	uint16_t delaytime;
3596:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3597:../uvc.c      **** 
3598:../uvc.c      **** #if 0 //for test the command queue
3599:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3600:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3601:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3602:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3603:../uvc.c      **** 		lcCmdDes += 1;
3604:../uvc.c      **** 	}
3605:../uvc.c      **** #endif
3606:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3607:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  64              		.loc 1 3607 0
  65 0018 38029FE5 		ldr	r0, .L27
  66              	.LVL4:
3584:../uvc.c      **** 
  67              		.loc 1 3584 0
  68 001c 1CD04DE2 		sub	sp, sp, #28
  69              	.LCFI1:
  70              		.cfi_def_cfa_offset 64
3591:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  71              		.loc 1 3591 0
  72 0020 00C0A0E3 		mov	ip, #0
  73              		.loc 1 3607 0
  74 0024 FA2FA0E3 		mov	r2, #1000
  75 0028 2C30A0E3 		mov	r3, #44
  76 002c 0C10A0E1 		mov	r1, ip
  77 0030 04C08DE5 		str	ip, [sp, #4]
  78 0034 08C08DE5 		str	ip, [sp, #8]
  79 0038 00208DE5 		str	r2, [sp]
  80 003c 0C308DE5 		str	r3, [sp, #12]
  81 0040 14229FE5 		ldr	r2, .L27+4
  82 0044 0B30A0E3 		mov	r3, #11
3591:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  83              		.loc 1 3591 0
  84 0048 14C08DE5 		str	ip, [sp, #20]
  85              	.LVL5:
  86              		.loc 1 3607 0
  87 004c FEFFFFEB 		bl	_txe_timer_create
  88              	.LVL6:
3608:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  89              		.loc 1 3608 0
  90 0050 FEFFFFEB 		bl	_tx_time_get
  91              	.LVL7:
3609:../uvc.c      **** 	CyU3PThreadSleep(50);
3610:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
3611:../uvc.c      **** 
3612:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  92              		.loc 1 3612 0
  93 0054 04529FE5 		ldr	r5, .L27+8
3608:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  94              		.loc 1 3608 0
  95 0058 04129FE5 		ldr	r1, .L27+12
  96 005c 0020A0E1 		mov	r2, r0
  97 0060 0400A0E3 		mov	r0, #4
  98 0064 FEFFFFEB 		bl	CyU3PDebugPrint
  99              	.LVL8:
3609:../uvc.c      **** 	CyU3PThreadSleep(50);
 100              		.loc 1 3609 0
 101 0068 3200A0E3 		mov	r0, #50
 102 006c FEFFFFEB 		bl	_tx_thread_sleep
 103              	.LVL9:
3610:../uvc.c      **** 
 104              		.loc 1 3610 0
 105 0070 E0019FE5 		ldr	r0, .L27
 106 0074 FEFFFFEB 		bl	_txe_timer_activate
 107              	.LVL10:
 108              		.loc 1 3612 0
 109 0078 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 110 007c 000052E3 		cmp	r2, #0
 111 0080 0300001A 		bne	.L5
 112              	.L6:
3613:../uvc.c      ****         /* Allow other ready threads to run. */
3614:../uvc.c      **** 
3615:../uvc.c      ****         CyU3PThreadRelinquish ();
 113              		.loc 1 3615 0
 114 0084 FEFFFFEB 		bl	_txe_thread_relinquish
 115              	.LVL11:
3612:../uvc.c      ****         /* Allow other ready threads to run. */
 116              		.loc 1 3612 0
 117 0088 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 118 008c 000052E3 		cmp	r2, #0
 119 0090 FBFFFF0A 		beq	.L6
 120              	.L5:
3616:../uvc.c      **** 	}
3617:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 121              		.loc 1 3617 0
 122 0094 103095E5 		ldr	r3, [r5, #16]
 123 0098 0400A0E3 		mov	r0, #4
 124 009c 3C3093E5 		ldr	r3, [r3, #60]
 125 00a0 C0119FE5 		ldr	r1, .L27+16
 126 00a4 FEFFFFEB 		bl	CyU3PDebugPrint
 127              	.LVL12:
 128 00a8 BC819FE5 		ldr	r8, .L27+20
 129 00ac BC619FE5 		ldr	r6, .L27+24
 130 00b0 BCA19FE5 		ldr	r10, .L27+28
3618:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3619:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3620:../uvc.c      **** 	//CyU3PThreadSleep(100);
3621:../uvc.c      **** 	//SetCurCmd();
3622:../uvc.c      **** 	/*********** the loop of the thread ***********/
3623:../uvc.c      **** 	for(;;){
3624:../uvc.c      **** 
3625:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 131              		.loc 1 3625 0
 132 00b4 0890A0E1 		mov	r9, r8
 133 00b8 0070E0E3 		mvn	r7, #0
 134              	.L21:
 135 00bc 14308DE2 		add	r3, sp, #20
 136 00c0 0320A0E3 		mov	r2, #3
 137 00c4 2010A0E3 		mov	r1, #32
 138 00c8 00708DE5 		str	r7, [sp]
 139 00cc 98019FE5 		ldr	r0, .L27+20
 140 00d0 FEFFFFEB 		bl	_txe_event_flags_get
 141              	.LVL13:
3626:../uvc.c      **** 		//CyU3PDebugPrint (4, "In I2C loop timercounter %d cmdFlag 0x%x\r\n", timercount, cmdFlag);
3627:../uvc.c      **** /*  // for test GPIO output
3628:../uvc.c      **** 		if(trigger)
3629:../uvc.c      **** 		{
3630:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3631:../uvc.c      **** 			{
3632:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3633:../uvc.c      **** 			}
3634:../uvc.c      **** 
3635:../uvc.c      **** 		}else{
3636:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3637:../uvc.c      **** 			{
3638:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3639:../uvc.c      **** 			}
3640:../uvc.c      **** 
3641:../uvc.c      **** 		}
3642:../uvc.c      **** */
3643:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 142              		.loc 1 3643 0
 143 00d4 0010E0E3 		mvn	r1, #0
 144 00d8 1C0096E5 		ldr	r0, [r6, #28]
 145 00dc FEFFFFEB 		bl	_txe_mutex_get
 146              	.LVL14:
3644:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3645:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3646:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3647:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3648:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3649:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3650:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3651:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3652:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3653:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3654:../uvc.c      **** #endif
3655:../uvc.c      **** 				}
3656:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3657:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3658:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3659:../uvc.c      **** 			}
3660:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 147              		.loc 1 3660 0
 148 00e0 1C0096E5 		ldr	r0, [r6, #28]
 149 00e4 FEFFFFEB 		bl	_txe_mutex_put
 150              	.LVL15:
3661:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3662:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 151              		.loc 1 3662 0
 152 00e8 1C0095E5 		ldr	r0, [r5, #28]
 153 00ec 0010E0E3 		mvn	r1, #0
 154 00f0 FEFFFFEB 		bl	_txe_mutex_get
 155              	.LVL16:
3663:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 156              		.loc 1 3663 0
 157 00f4 104095E5 		ldr	r4, [r5, #16]
 158              	.LVL17:
3664:../uvc.c      **** 
3665:../uvc.c      **** 				/*
3666:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3667:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3668:../uvc.c      **** 				*/
3669:../uvc.c      **** 
3670:../uvc.c      **** 				/* find a available command */
3671:../uvc.c      **** 				i = 0;
3672:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 159              		.loc 1 3672 0
 160 00f8 3C3094E5 		ldr	r3, [r4, #60]
 161 00fc 000053E3 		cmp	r3, #0
 162 0100 0900001A 		bne	.L7
 163 0104 40B0A0E3 		mov	fp, #64
 164 0108 010000EA 		b	.L10
 165              	.LVL18:
 166              	.L8:
 167              		.loc 1 3672 0 is_stmt 0 discriminator 2
 168 010c FFB013E2 		ands	fp, r3, #255
 169 0110 2D00000A 		beq	.L25
 170              	.L10:
3673:../uvc.c      **** 					i++;
3674:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 171              		.loc 1 3674 0 is_stmt 1
 172 0114 344094E5 		ldr	r4, [r4, #52]
 173              	.LVL19:
 174 0118 01304BE2 		sub	r3, fp, #1
3672:../uvc.c      **** 					i++;
 175              		.loc 1 3672 0
 176 011c 3C2094E5 		ldr	r2, [r4, #60]
 177 0120 000052E3 		cmp	r2, #0
 178 0124 F8FFFF0A 		beq	.L8
 179 0128 104085E5 		str	r4, [r5, #16]
 180              	.L7:
 181              	.LVL20:
 182 012c 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3675:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3676:../uvc.c      **** 				}
3677:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3678:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3679:../uvc.c      **** 					i = lcCmdDes->curNum;
3680:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3681:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3682:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3683:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3684:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 183              		.loc 1 3684 0
 184 0130 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 185 0134 833083E0 		add	r3, r3, r3, asl #1
 186 0138 833084E0 		add	r3, r4, r3, asl #1
 187 013c 20C04CE2 		sub	ip, ip, #32
3680:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 188              		.loc 1 3680 0
 189 0140 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 190              	.LVL21:
3681:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 191              		.loc 1 3681 0
 192 0144 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 193              	.LVL22:
3682:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 194              		.loc 1 3682 0
 195 0148 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 196              	.LVL23:
3683:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 197              		.loc 1 3683 0
 198 014c B8B0D3E1 		ldrh	fp, [r3, #8]
 199              	.LVL24:
 200              		.loc 1 3684 0
 201 0150 03005CE3 		cmp	ip, #3
 202 0154 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 203 0158 3B0000EA 		b	.L16
 204              	.L23:
 205 015c 6C010000 		.word	.L13
 206 0160 6C010000 		.word	.L13
 207 0164 BC010000 		.word	.L15
 208 0168 BC010000 		.word	.L15
 209              	.L13:
3685:../uvc.c      **** 						case 0x20:
3686:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3687:../uvc.c      **** 							delaytime = 500;
3688:../uvc.c      **** 							break;
3689:../uvc.c      **** 						case 0x21:
3690:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 210              		.loc 1 3690 0
 211 016c 5230A0E3 		mov	r3, #82
 212              	.LVL25:
 213 0170 FEFFFFEB 		bl	SensorSetIrisControl
 214              	.LVL26:
3691:../uvc.c      **** 							delaytime = 500;
3692:../uvc.c      **** 							break;
 215              		.loc 1 3692 0
 216 0174 7D1FA0E3 		mov	r1, #500
 217              	.LVL27:
 218              	.L12:
3693:../uvc.c      **** 						case 0x22:
3694:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3695:../uvc.c      **** 							delaytime = 300;
3696:../uvc.c      **** 							break;
3697:../uvc.c      **** 						case 0x23:
3698:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3699:../uvc.c      **** 							delaytime = 300;
3700:../uvc.c      **** 							break;
3701:../uvc.c      **** 						default:
3702:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3703:../uvc.c      **** 							break;
3704:../uvc.c      **** 					}
3705:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3706:../uvc.c      **** 					/** timer's ticket modify **/
3707:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 219              		.loc 1 3707 0
 220 0178 0020A0E3 		mov	r2, #0
 221 017c D4009FE5 		ldr	r0, .L27
 222 0180 FEFFFFEB 		bl	_txe_timer_change
 223              	.LVL28:
3708:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 224              		.loc 1 3708 0
 225 0184 CC009FE5 		ldr	r0, .L27
 226 0188 FEFFFFEB 		bl	_txe_timer_activate
 227              	.LVL29:
3709:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3710:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3711:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3712:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3713:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3714:../uvc.c      **** #endif
3715:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 228              		.loc 1 3715 0
 229 018c 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 230 0190 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 231 0194 030052E1 		cmp	r2, r3
 232 0198 1D00000A 		beq	.L26
3716:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3717:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3718:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3719:../uvc.c      **** 						}else{
3720:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3721:../uvc.c      **** 						}
3722:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3723:../uvc.c      **** 					}else{
3724:../uvc.c      **** 						lcCmdDes->curNum ++;
 233              		.loc 1 3724 0
 234 019c 013083E2 		add	r3, r3, #1
3725:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 235              		.loc 1 3725 0
 236 01a0 0F20A0E3 		mov	r2, #15
3724:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 237              		.loc 1 3724 0
 238 01a4 0130C4E5 		strb	r3, [r4, #1]
 239              		.loc 1 3725 0
 240 01a8 3C2084E5 		str	r2, [r4, #60]
 241              	.LVL30:
 242              	.L20:
3726:../uvc.c      **** 					}
3727:../uvc.c      **** 				}else{
3728:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0); //the free I2C commands timer pace (no setting comman
3729:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3730:../uvc.c      **** 					//CyU3PDebugPrint (4, "I2Ctimer counter %d", timercount);
3731:../uvc.c      **** 					if(timercount >= 3){
3732:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
3733:../uvc.c      **** 							curFlag[curFlagIdx] = 0;
3734:../uvc.c      **** 						}
3735:../uvc.c      **** 							timercount = 0;
3736:../uvc.c      **** 
3737:../uvc.c      **** 					}else{
3738:../uvc.c      **** 							timercount++;
3739:../uvc.c      **** 					}
3740:../uvc.c      **** 				}
3741:../uvc.c      **** 			}
3742:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 243              		.loc 1 3742 0
 244 01ac 1C0095E5 		ldr	r0, [r5, #28]
 245 01b0 FEFFFFEB 		bl	_txe_mutex_put
 246              	.LVL31:
3743:../uvc.c      **** /*
3744:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3745:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3746:../uvc.c      **** */
3747:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3748:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3749:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3750:../uvc.c      **** #endif
3751:../uvc.c      **** 
3752:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3753:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3754:../uvc.c      **** #if 0
3755:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3756:../uvc.c      **** 
3757:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3758:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3759:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3760:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3761:../uvc.c      **** 			    i = 0;
3762:../uvc.c      **** 				 switch(cmdCopyIdx)
3763:../uvc.c      **** 				 {
3764:../uvc.c      **** 					 case BrgtCtlID1:
3765:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3766:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3767:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3768:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3769:../uvc.c      **** 							 i++;
3770:../uvc.c      **** 						 }
3771:../uvc.c      **** 						 else{
3772:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3773:../uvc.c      **** 						 }
3774:../uvc.c      **** 
3775:../uvc.c      **** 						 CyU3PBusyWait(500);
3776:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3777:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3778:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3779:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3780:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3781:../uvc.c      **** 						 }
3782:../uvc.c      **** 						 else{
3783:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3784:../uvc.c      **** 						 }
3785:../uvc.c      **** 						 break;
3786:../uvc.c      **** 					 case HueCtlID5:
3787:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3788:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3789:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3790:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3791:../uvc.c      **** 						 }
3792:../uvc.c      **** 						 else{
3793:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3794:../uvc.c      **** 						 }
3795:../uvc.c      **** 						 break;
3796:../uvc.c      **** 					 case SaturCtlID6:
3797:../uvc.c      **** 					 case WBTLevCtlID10:
3798:../uvc.c      **** 					 default:
3799:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3800:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3801:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3802:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3803:../uvc.c      **** 						 }
3804:../uvc.c      **** 						 else{
3805:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3806:../uvc.c      **** 						 }
3807:../uvc.c      **** 						 break;
3808:../uvc.c      **** 				 }
3809:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3810:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3811:../uvc.c      **** 			}
3812:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3813:../uvc.c      **** #endif
3814:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3815:../uvc.c      **** 		/* Allow other ready threads to run. */
3816:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3817:../uvc.c      **** 			CyU3PThreadRelinquish ();
 247              		.loc 1 3817 0
 248 01b4 FEFFFFEB 		bl	_txe_thread_relinquish
 249              	.LVL32:
3818:../uvc.c      **** 		}
 250              		.loc 1 3818 0
 251 01b8 BFFFFFEA 		b	.L21
 252              	.LVL33:
 253              	.L15:
3698:../uvc.c      **** 							delaytime = 300;
 254              		.loc 1 3698 0
 255 01bc 8230A0E3 		mov	r3, #130
 256              	.LVL34:
 257 01c0 FEFFFFEB 		bl	SensorSetIrisControl
 258              	.LVL35:
3700:../uvc.c      **** 						default:
 259              		.loc 1 3700 0
 260 01c4 4B1FA0E3 		mov	r1, #300
 261 01c8 EAFFFFEA 		b	.L12
 262              	.LVL36:
 263              	.L25:
3728:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 264              		.loc 1 3728 0
 265 01cc 0B20A0E1 		mov	r2, fp
 266 01d0 FA1FA0E3 		mov	r1, #1000
 267 01d4 7C009FE5 		ldr	r0, .L27
 268 01d8 104085E5 		str	r4, [r5, #16]
 269 01dc FEFFFFEB 		bl	_txe_timer_change
 270              	.LVL37:
3729:../uvc.c      **** 					//CyU3PDebugPrint (4, "I2Ctimer counter %d", timercount);
 271              		.loc 1 3729 0
 272 01e0 70009FE5 		ldr	r0, .L27
 273 01e4 FEFFFFEB 		bl	_txe_timer_activate
 274              	.LVL38:
3731:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
 275              		.loc 1 3731 0
 276 01e8 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 277 01ec 020052E3 		cmp	r2, #2
3738:../uvc.c      **** 					}
 278              		.loc 1 3738 0
 279 01f0 01208292 		addls	r2, r2, #1
 280 01f4 2820C995 		strlsb	r2, [r9, #40]
3731:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
 281              		.loc 1 3731 0
 282 01f8 EBFFFF9A 		bls	.L20
 283 01fc 74009FE5 		ldr	r0, .L27+32
 284 0200 0B10A0E1 		mov	r1, fp
 285 0204 4020A0E3 		mov	r2, #64
 286 0208 FEFFFFEB 		bl	memset
 287              	.LVL39:
3735:../uvc.c      **** 
 288              		.loc 1 3735 0
 289 020c 28B0C9E5 		strb	fp, [r9, #40]
 290 0210 E5FFFFEA 		b	.L20
 291              	.LVL40:
 292              	.L26:
3717:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 293              		.loc 1 3717 0
 294 0214 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
3716:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 295              		.loc 1 3716 0
 296 0218 0020A0E3 		mov	r2, #0
3717:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 297              		.loc 1 3717 0
 298 021c 230053E3 		cmp	r3, #35
3718:../uvc.c      **** 						}else{
 299              		.loc 1 3718 0
 300 0220 20304382 		subhi	r3, r3, #32
 301 0224 83308380 		addhi	r3, r3, r3, asl #1
3720:../uvc.c      **** 						}
 302              		.loc 1 3720 0
 303 0228 83308390 		addls	r3, r3, r3, asl #1
3718:../uvc.c      **** 						}else{
 304              		.loc 1 3718 0
 305 022c 83318A80 		addhi	r3, r10, r3, asl #3
3720:../uvc.c      **** 						}
 306              		.loc 1 3720 0
 307 0230 83318A90 		addls	r3, r10, r3, asl #3
3718:../uvc.c      **** 						}else{
 308              		.loc 1 3718 0
 309 0234 1020C385 		strhib	r2, [r3, #16]
3720:../uvc.c      **** 						}
 310              		.loc 1 3720 0
 311 0238 9021C395 		strlsb	r2, [r3, #400]
3722:../uvc.c      **** 					}else{
 312              		.loc 1 3722 0
 313 023c 343094E5 		ldr	r3, [r4, #52]
3716:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 314              		.loc 1 3716 0
 315 0240 3C2084E5 		str	r2, [r4, #60]
3722:../uvc.c      **** 					}else{
 316              		.loc 1 3722 0
 317 0244 103085E5 		str	r3, [r5, #16]
 318 0248 D7FFFFEA 		b	.L20
 319              	.LVL41:
 320              	.L16:
3702:../uvc.c      **** 							break;
 321              		.loc 1 3702 0
 322 024c FEFFFFEB 		bl	SensorSetControl
 323              	.LVL42:
 324 0250 0B10A0E1 		mov	r1, fp
3703:../uvc.c      **** 					}
 325              		.loc 1 3703 0
 326 0254 C7FFFFEA 		b	.L12
 327              	.L28:
 328              		.align	2
 329              	.L27:
 330 0258 00000000 		.word	I2CCmdTimer
 331 025c 00000000 		.word	I2CCmdCb
 332 0260 00000000 		.word	cmdQu
 333 0264 00000000 		.word	.LC0
 334 0268 14000000 		.word	.LC1
 335 026c 00000000 		.word	.LANCHOR0
 336 0270 00000000 		.word	statQu
 337 0274 00000000 		.word	.LANCHOR1
 338 0278 2C000000 		.word	.LANCHOR0+44
 339              		.cfi_endproc
 340              	.LFE25:
 342              		.align	2
 343              		.global	CyFxUvcApplnDmaCallback
 345              	CyFxUvcApplnDmaCallback:
 346              	.LFB10:
1539:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 347              		.loc 1 1539 0
 348              		.cfi_startproc
 349              		@ args = 0, pretend = 0, frame = 0
 350              		@ frame_needed = 0, uses_anonymous_args = 0
 351              	.LVL43:
1543:../uvc.c      ****     {
 352              		.loc 1 1543 0
 353 027c 080051E3 		cmp	r1, #8
1539:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 354              		.loc 1 1539 0
 355 0280 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 356              	.LCFI2:
 357              		.cfi_def_cfa_offset 20
 358              		.cfi_offset 4, -20
 359              		.cfi_offset 5, -16
 360              		.cfi_offset 6, -12
 361              		.cfi_offset 7, -8
 362              		.cfi_offset 14, -4
 363 0284 0250A0E1 		mov	r5, r2
 364 0288 0CD04DE2 		sub	sp, sp, #12
 365              	.LCFI3:
 366              		.cfi_def_cfa_offset 32
1543:../uvc.c      ****     {
 367              		.loc 1 1543 0
 368 028c 0B00000A 		beq	.L40
1582:../uvc.c      ****     {
 369              		.loc 1 1582 0
 370 0290 100051E3 		cmp	r1, #16
 371 0294 0700001A 		bne	.L29
1584:../uvc.c      ****         streamingStarted = CyTrue;
 372              		.loc 1 1584 0
 373 0298 74319FE5 		ldr	r3, .L43
1585:../uvc.c      ****     }
 374              		.loc 1 1585 0
 375 029c 0110A0E3 		mov	r1, #1
 376              	.LVL44:
1584:../uvc.c      ****         streamingStarted = CyTrue;
 377              		.loc 1 1584 0
 378 02a0 BE27D3E1 		ldrh	r2, [r3, #126]
 379              	.LVL45:
1585:../uvc.c      ****     }
 380              		.loc 1 1585 0
 381 02a4 801083E5 		str	r1, [r3, #128]
1584:../uvc.c      ****         streamingStarted = CyTrue;
 382              		.loc 1 1584 0
 383 02a8 012082E0 		add	r2, r2, r1
 384 02ac 0228A0E1 		mov	r2, r2, asl #16
 385 02b0 2228A0E1 		mov	r2, r2, lsr #16
 386 02b4 BE27C3E1 		strh	r2, [r3, #126]	@ movhi
 387              	.LVL46:
 388              	.L29:
1587:../uvc.c      **** 
 389              		.loc 1 1587 0
 390 02b8 0CD08DE2 		add	sp, sp, #12
 391              		@ sp needed
 392 02bc F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 393              	.LVL47:
 394              	.L40:
1545:../uvc.c      ****             {
 395              		.loc 1 1545 0
 396 02c0 50319FE5 		ldr	r3, .L43+4
 397 02c4 B420D2E1 		ldrh	r2, [r2, #4]
 398              	.LVL48:
1547:../uvc.c      ****                 fb++;
 399              		.loc 1 1547 0
 400 02c8 006095E5 		ldr	r6, [r5]
1545:../uvc.c      ****             {
 401              		.loc 1 1545 0
 402 02cc 030052E1 		cmp	r2, r3
 403 02d0 3300000A 		beq	.L41
 404              	.LVL49:
 405              	.LBB6:
 406              	.LBB7:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 407              		.loc 1 1283 0
 408 02d4 40719FE5 		ldr	r7, .L43+8
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 409              		.loc 1 1282 0
 410 02d8 0010E0E3 		mvn	r1, #0
 411              	.LVL50:
 412 02dc 3C019FE5 		ldr	r0, .L43+12
 413              	.LVL51:
 414 02e0 FEFFFFEB 		bl	_txe_mutex_get
 415              	.LVL52:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 416              		.loc 1 1283 0
 417 02e4 121D87E2 		add	r1, r7, #1152
 418 02e8 0C20A0E3 		mov	r2, #12
 419 02ec 0C0046E2 		sub	r0, r6, #12
 420              	.LVL53:
 421 02f0 FEFFFFEB 		bl	CyU3PMemCopy
 422              	.LVL54:
1284:../uvc.c      **** 
 423              		.loc 1 1284 0
 424 02f4 24019FE5 		ldr	r0, .L43+12
 425 02f8 FEFFFFEB 		bl	_txe_mutex_put
 426              	.LVL55:
1289:../uvc.c      ****     }
 427              		.loc 1 1289 0
 428 02fc 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 429              	.LBE7:
 430              	.LBE6:
1554:../uvc.c      ****                 pbc = input->buffer_p.count;
 431              		.loc 1 1554 0
 432 0300 0C419FE5 		ldr	r4, .L43
 433              	.LBB9:
 434              	.LBB8:
1289:../uvc.c      ****     }
 435              		.loc 1 1289 0
 436 0304 023083E3 		orr	r3, r3, #2
 437 0308 0B3046E5 		strb	r3, [r6, #-11]
 438              	.LBE8:
 439              	.LBE9:
1558:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 440              		.loc 1 1558 0
 441 030c 741094E5 		ldr	r1, [r4, #116]
1554:../uvc.c      ****                 pbc = input->buffer_p.count;
 442              		.loc 1 1554 0
 443 0310 BE26D4E1 		ldrh	r2, [r4, #110]
1555:../uvc.c      ****                // hitFV = CyTrue;
 444              		.loc 1 1555 0
 445 0314 B430D5E1 		ldrh	r3, [r5, #4]
1554:../uvc.c      ****                 pbc = input->buffer_p.count;
 446              		.loc 1 1554 0
 447 0318 012082E2 		add	r2, r2, #1
1558:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 448              		.loc 1 1558 0
 449 031c 0F0051E3 		cmp	r1, #15
1554:../uvc.c      ****                 pbc = input->buffer_p.count;
 450              		.loc 1 1554 0
 451 0320 BE26C4E1 		strh	r2, [r4, #110]	@ movhi
1555:../uvc.c      ****                // hitFV = CyTrue;
 452              		.loc 1 1555 0
 453 0324 B037C4E1 		strh	r3, [r4, #112]	@ movhi
1558:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 454              		.loc 1 1558 0
 455 0328 2D00000A 		beq	.L42
 456              	.L33:
1566:../uvc.c      ****             }
 457              		.loc 1 1566 0
 458 032c 0120A0E3 		mov	r2, #1
 459 0330 782084E5 		str	r2, [r4, #120]
 460              	.LVL56:
 461              	.L32:
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 462              		.loc 1 1570 0
 463 0334 BC27D4E1 		ldrh	r2, [r4, #124]
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 464              		.loc 1 1571 0
 465 0338 0C1083E2 		add	r1, r3, #12
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 466              		.loc 1 1570 0
 467 033c 013082E2 		add	r3, r2, #1
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 468              		.loc 1 1571 0
 469 0340 0118A0E1 		mov	r1, r1, asl #16
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 470              		.loc 1 1570 0
 471 0344 0338A0E1 		mov	r3, r3, asl #16
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 472              		.loc 1 1571 0
 473 0348 2118A0E1 		mov	r1, r1, lsr #16
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 474              		.loc 1 1570 0
 475 034c 2338A0E1 		mov	r3, r3, lsr #16
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 476              		.loc 1 1571 0
 477 0350 0020A0E3 		mov	r2, #0
 478 0354 C8009FE5 		ldr	r0, .L43+16
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 479              		.loc 1 1570 0
 480 0358 BC37C4E1 		strh	r3, [r4, #124]	@ movhi
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 481              		.loc 1 1571 0
 482 035c FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 483              	.LVL57:
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 484              		.loc 1 1570 0
 485 0360 AC109FE5 		ldr	r1, .L43
1574:../uvc.c      ****             {
 486              		.loc 1 1574 0
 487 0364 002050E2 		subs	r2, r0, #0
 488 0368 D2FFFF0A 		beq	.L29
1576:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 489              		.loc 1 1576 0
 490 036c BC07D1E1 		ldrh	r0, [r1, #124]
 491              	.LVL58:
1577:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 492              		.loc 1 1577 0
 493 0370 B430D5E1 		ldrh	r3, [r5, #4]
1576:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 494              		.loc 1 1576 0
 495 0374 010040E2 		sub	r0, r0, #1
 496 0378 0008A0E1 		mov	r0, r0, asl #16
 497 037c 2008A0E1 		mov	r0, r0, lsr #16
 498 0380 BC07C1E1 		strh	r0, [r1, #124]	@ movhi
1577:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 499              		.loc 1 1577 0
 500 0384 BC07D1E1 		ldrh	r0, [r1, #124]
 501 0388 BE17D1E1 		ldrh	r1, [r1, #126]
 502 038c 001061E0 		rsb	r1, r1, r0
 503 0390 00108DE5 		str	r1, [sp]
 504 0394 0400A0E3 		mov	r0, #4
 505 0398 88109FE5 		ldr	r1, .L43+20
 506 039c FEFFFFEB 		bl	CyU3PDebugPrint
 507              	.LVL59:
 508 03a0 C4FFFFEA 		b	.L29
 509              	.LVL60:
 510              	.L41:
 511              	.LBB10:
 512              	.LBB11:
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 513              		.loc 1 1282 0
 514 03a4 0010E0E3 		mvn	r1, #0
 515              	.LVL61:
 516              	.LBE11:
 517              	.LBE10:
1548:../uvc.c      ****             }
 518              		.loc 1 1548 0
 519 03a8 64409FE5 		ldr	r4, .L43
 520              	.LBB14:
 521              	.LBB12:
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 522              		.loc 1 1282 0
 523 03ac 6C009FE5 		ldr	r0, .L43+12
 524              	.LVL62:
 525 03b0 FEFFFFEB 		bl	_txe_mutex_get
 526              	.LVL63:
 527              	.LBE12:
 528              	.LBE14:
1547:../uvc.c      ****                 fb++;
 529              		.loc 1 1547 0
 530 03b4 0C6046E2 		sub	r6, r6, #12
 531              	.LVL64:
 532              	.LBB15:
 533              	.LBB13:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 534              		.loc 1 1283 0
 535 03b8 0C20A0E3 		mov	r2, #12
 536 03bc 0600A0E1 		mov	r0, r6
 537 03c0 64109FE5 		ldr	r1, .L43+24
 538 03c4 FEFFFFEB 		bl	CyU3PMemCopy
 539              	.LVL65:
1284:../uvc.c      **** 
 540              		.loc 1 1284 0
 541 03c8 50009FE5 		ldr	r0, .L43+12
 542 03cc FEFFFFEB 		bl	_txe_mutex_put
 543              	.LVL66:
 544              	.LBE13:
 545              	.LBE15:
1548:../uvc.c      ****             }
 546              		.loc 1 1548 0
 547 03d0 BC26D4E1 		ldrh	r2, [r4, #108]
 548 03d4 B430D5E1 		ldrh	r3, [r5, #4]
 549 03d8 012082E2 		add	r2, r2, #1
 550 03dc BC26C4E1 		strh	r2, [r4, #108]	@ movhi
 551 03e0 D3FFFFEA 		b	.L32
 552              	.LVL67:
 553              	.L42:
1559:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 554              		.loc 1 1559 0
 555 03e4 0010E0E3 		mvn	r1, #0
 556 03e8 30009FE5 		ldr	r0, .L43+12
 557 03ec FEFFFFEB 		bl	_txe_mutex_get
 558              	.LVL68:
1560:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 559              		.loc 1 1560 0
 560 03f0 8134D7E5 		ldrb	r3, [r7, #1153]	@ zero_extendqisi2
1561:../uvc.c      ****                 	//stiflag = 0xAA;
 561              		.loc 1 1561 0
 562 03f4 24009FE5 		ldr	r0, .L43+12
1560:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 563              		.loc 1 1560 0
 564 03f8 DF3003E2 		and	r3, r3, #223
 565 03fc 8134C7E5 		strb	r3, [r7, #1153]
1561:../uvc.c      ****                 	//stiflag = 0xAA;
 566              		.loc 1 1561 0
 567 0400 FEFFFFEB 		bl	_txe_mutex_put
 568              	.LVL69:
1563:../uvc.c      ****                 }
 569              		.loc 1 1563 0
 570 0404 0030A0E3 		mov	r3, #0
 571 0408 743084E5 		str	r3, [r4, #116]
 572 040c B430D5E1 		ldrh	r3, [r5, #4]
 573 0410 C5FFFFEA 		b	.L33
 574              	.L44:
 575              		.align	2
 576              	.L43:
 577 0414 00000000 		.word	.LANCHOR0
 578 0418 F03F0000 		.word	16368
 579 041c 00000000 		.word	.LANCHOR1
 580 0420 00000000 		.word	imgHdMux
 581 0424 00000000 		.word	glChHandleUVCStream
 582 0428 38000000 		.word	.LC2
 583 042c 80040000 		.word	.LANCHOR1+1152
 584              		.cfi_endproc
 585              	.LFE10:
 587              		.align	2
 589              	CyFxUVCApplnUSBEventCB:
 590              	.LFB8:
1338:../uvc.c      ****     switch (evtype)
 591              		.loc 1 1338 0
 592              		.cfi_startproc
 593              		@ args = 0, pretend = 0, frame = 8
 594              		@ frame_needed = 0, uses_anonymous_args = 0
 595              	.LVL70:
1339:../uvc.c      ****     {
 596              		.loc 1 1339 0
 597 0430 020050E3 		cmp	r0, #2
1338:../uvc.c      ****     switch (evtype)
 598              		.loc 1 1338 0
 599 0434 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 600              	.LCFI4:
 601              		.cfi_def_cfa_offset 16
 602              		.cfi_offset 4, -16
 603              		.cfi_offset 5, -12
 604              		.cfi_offset 6, -8
 605              		.cfi_offset 14, -4
 606 0438 0040A0E1 		mov	r4, r0
 607 043c 10D04DE2 		sub	sp, sp, #16
 608              	.LCFI5:
 609              		.cfi_def_cfa_offset 32
1339:../uvc.c      ****     {
 610              		.loc 1 1339 0
 611 0440 3D00000A 		beq	.L47
 612 0444 040050E3 		cmp	r0, #4
 613 0448 2000000A 		beq	.L48
 614 044c 010050E3 		cmp	r0, #1
 615 0450 0100000A 		beq	.L53
 616              	.LVL71:
 617              	.L45:
1375:../uvc.c      **** 
 618              		.loc 1 1375 0
 619 0454 10D08DE2 		add	sp, sp, #16
 620              		@ sp needed
 621 0458 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 622              	.LVL72:
 623              	.L53:
 624              	.LBB30:
 625              	.LBB31:
1358:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 626              		.loc 1 1358 0
 627 045c 0130A0E1 		mov	r3, r1
 628 0460 0420A0E1 		mov	r2, r4
1360:../uvc.c      ****             isUsbConnected = CyFalse;
 629              		.loc 1 1360 0
 630 0464 40519FE5 		ldr	r5, .L54
1358:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 631              		.loc 1 1358 0
 632 0468 40119FE5 		ldr	r1, .L54+4
 633              	.LVL73:
 634 046c 0400A0E3 		mov	r0, #4
 635              	.LVL74:
 636 0470 FEFFFFEB 		bl	CyU3PDebugPrint
 637              	.LVL75:
1359:../uvc.c      ****             gpif_initialized = 0;
 638              		.loc 1 1359 0
 639 0474 0400A0E1 		mov	r0, r4
 640 0478 FEFFFFEB 		bl	CyU3PGpifDisable
 641              	.LVL76:
1360:../uvc.c      ****             isUsbConnected = CyFalse;
 642              		.loc 1 1360 0
 643 047c 00C0A0E3 		mov	ip, #0
 644              	.LBB32:
 645              	.LBB33:
1322:../uvc.c      **** 	{
 646              		.loc 1 1322 0
 647 0480 00C08DE5 		str	ip, [sp]
 648 0484 0410A0E1 		mov	r1, r4
 649 0488 0500A0E1 		mov	r0, r5
 650 048c 0220A0E3 		mov	r2, #2
 651 0490 0C308DE2 		add	r3, sp, #12
 652              	.LBE33:
 653              	.LBE32:
1360:../uvc.c      ****             isUsbConnected = CyFalse;
 654              		.loc 1 1360 0
 655 0494 84C085E5 		str	ip, [r5, #132]
1361:../uvc.c      ****             streamingStarted = CyFalse;
 656              		.loc 1 1361 0
 657 0498 88C085E5 		str	ip, [r5, #136]
1362:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 658              		.loc 1 1362 0
 659 049c 80C085E5 		str	ip, [r5, #128]
 660              	.LBB37:
 661              	.LBB36:
1322:../uvc.c      **** 	{
 662              		.loc 1 1322 0
 663 04a0 FEFFFFEB 		bl	_txe_event_flags_get
 664              	.LVL77:
 665 04a4 004050E2 		subs	r4, r0, #0
 666 04a8 E9FFFF1A 		bne	.L45
 667              	.LBB34:
 668              	.LBB35:
1325:../uvc.c      **** 
 669              		.loc 1 1325 0
 670 04ac 0500A0E1 		mov	r0, r5
 671 04b0 0110E0E3 		mvn	r1, #1
 672 04b4 0220A0E3 		mov	r2, #2
 673 04b8 FEFFFFEB 		bl	_txe_event_flags_set
 674              	.LVL78:
1328:../uvc.c      **** 	}
 675              		.loc 1 1328 0
 676 04bc 0500A0E1 		mov	r0, r5
 677 04c0 0420A0E1 		mov	r2, r4
 678 04c4 0210A0E3 		mov	r1, #2
 679 04c8 FEFFFFEB 		bl	_txe_event_flags_set
 680              	.LVL79:
 681 04cc E0FFFFEA 		b	.L45
 682              	.LVL80:
 683              	.L48:
 684              	.LBE35:
 685              	.LBE34:
 686              	.LBE36:
 687              	.LBE37:
 688              	.LBE31:
 689              	.LBE30:
1342:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 690              		.loc 1 1342 0
 691 04d0 0130A0E1 		mov	r3, r1
 692 04d4 0020A0E1 		mov	r2, r0
 693 04d8 D4109FE5 		ldr	r1, .L54+8
 694              	.LVL81:
 695 04dc FEFFFFEB 		bl	CyU3PDebugPrint
 696              	.LVL82:
1344:../uvc.c      ****             streamingStarted = CyFalse;
 697              		.loc 1 1344 0
 698 04e0 C4409FE5 		ldr	r4, .L54
1343:../uvc.c      ****             gpif_initialized = 0;
 699              		.loc 1 1343 0
 700 04e4 0100A0E3 		mov	r0, #1
 701 04e8 FEFFFFEB 		bl	CyU3PGpifDisable
 702              	.LVL83:
1344:../uvc.c      ****             streamingStarted = CyFalse;
 703              		.loc 1 1344 0
 704 04ec 00C0A0E3 		mov	ip, #0
 705              	.LBB38:
 706              	.LBB39:
1322:../uvc.c      **** 	{
 707              		.loc 1 1322 0
 708 04f0 00C08DE5 		str	ip, [sp]
 709 04f4 0400A0E1 		mov	r0, r4
 710 04f8 0110A0E3 		mov	r1, #1
 711 04fc 0220A0E3 		mov	r2, #2
 712 0500 0C308DE2 		add	r3, sp, #12
 713              	.LBE39:
 714              	.LBE38:
1344:../uvc.c      ****             streamingStarted = CyFalse;
 715              		.loc 1 1344 0
 716 0504 84C084E5 		str	ip, [r4, #132]
1345:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 717              		.loc 1 1345 0
 718 0508 80C084E5 		str	ip, [r4, #128]
 719              	.LBB43:
 720              	.LBB42:
1322:../uvc.c      **** 	{
 721              		.loc 1 1322 0
 722 050c FEFFFFEB 		bl	_txe_event_flags_get
 723              	.LVL84:
 724 0510 005050E2 		subs	r5, r0, #0
 725 0514 CEFFFF1A 		bne	.L45
 726              	.LBB40:
 727              	.LBB41:
1325:../uvc.c      **** 
 728              		.loc 1 1325 0
 729 0518 0400A0E1 		mov	r0, r4
 730 051c 0110E0E3 		mvn	r1, #1
 731 0520 0220A0E3 		mov	r2, #2
 732 0524 FEFFFFEB 		bl	_txe_event_flags_set
 733              	.LVL85:
1328:../uvc.c      **** 	}
 734              		.loc 1 1328 0
 735 0528 0400A0E1 		mov	r0, r4
 736 052c 0520A0E1 		mov	r2, r5
 737 0530 0210A0E3 		mov	r1, #2
 738 0534 FEFFFFEB 		bl	_txe_event_flags_set
 739              	.LVL86:
 740 0538 C5FFFFEA 		b	.L45
 741              	.LVL87:
 742              	.L47:
 743              	.LBE41:
 744              	.LBE40:
 745              	.LBE42:
 746              	.LBE43:
1350:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 747              		.loc 1 1350 0
 748 053c 0130A0E1 		mov	r3, r1
 749 0540 0420A0E1 		mov	r2, r4
 750 0544 6C109FE5 		ldr	r1, .L54+12
 751              	.LVL88:
1352:../uvc.c      ****             streamingStarted = CyFalse;
 752              		.loc 1 1352 0
 753 0548 5C509FE5 		ldr	r5, .L54
1350:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 754              		.loc 1 1350 0
 755 054c 0400A0E3 		mov	r0, #4
 756              	.LVL89:
 757 0550 FEFFFFEB 		bl	CyU3PDebugPrint
 758              	.LVL90:
1351:../uvc.c      ****             gpif_initialized = 0;
 759              		.loc 1 1351 0
 760 0554 0100A0E3 		mov	r0, #1
 761 0558 FEFFFFEB 		bl	CyU3PGpifDisable
 762              	.LVL91:
1352:../uvc.c      ****             streamingStarted = CyFalse;
 763              		.loc 1 1352 0
 764 055c 00C0A0E3 		mov	ip, #0
 765              	.LBB44:
 766              	.LBB45:
1322:../uvc.c      **** 	{
 767              		.loc 1 1322 0
 768 0560 00C08DE5 		str	ip, [sp]
 769 0564 0500A0E1 		mov	r0, r5
 770 0568 0110A0E3 		mov	r1, #1
 771 056c 0420A0E1 		mov	r2, r4
 772 0570 0C308DE2 		add	r3, sp, #12
 773              	.LBE45:
 774              	.LBE44:
1352:../uvc.c      ****             streamingStarted = CyFalse;
 775              		.loc 1 1352 0
 776 0574 84C085E5 		str	ip, [r5, #132]
1353:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 777              		.loc 1 1353 0
 778 0578 80C085E5 		str	ip, [r5, #128]
 779              	.LBB49:
 780              	.LBB48:
1322:../uvc.c      **** 	{
 781              		.loc 1 1322 0
 782 057c FEFFFFEB 		bl	_txe_event_flags_get
 783              	.LVL92:
 784 0580 006050E2 		subs	r6, r0, #0
 785 0584 B2FFFF1A 		bne	.L45
 786              	.LBB46:
 787              	.LBB47:
1325:../uvc.c      **** 
 788              		.loc 1 1325 0
 789 0588 0420A0E1 		mov	r2, r4
 790 058c 0500A0E1 		mov	r0, r5
 791 0590 0110E0E3 		mvn	r1, #1
 792 0594 FEFFFFEB 		bl	_txe_event_flags_set
 793              	.LVL93:
1328:../uvc.c      **** 	}
 794              		.loc 1 1328 0
 795 0598 0500A0E1 		mov	r0, r5
 796 059c 0410A0E1 		mov	r1, r4
 797 05a0 0620A0E1 		mov	r2, r6
 798 05a4 FEFFFFEB 		bl	_txe_event_flags_set
 799              	.LVL94:
 800 05a8 A9FFFFEA 		b	.L45
 801              	.L55:
 802              		.align	2
 803              	.L54:
 804 05ac 00000000 		.word	.LANCHOR0
 805 05b0 C4000000 		.word	.LC5
 806 05b4 80000000 		.word	.LC3
 807 05b8 A0000000 		.word	.LC4
 808              	.LBE47:
 809              	.LBE46:
 810              	.LBE48:
 811              	.LBE49:
 812              		.cfi_endproc
 813              	.LFE8:
 815              		.align	2
 817              	CyFxUVCApplnUSBSetupCB:
 818              	.LFB9:
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 819              		.loc 1 1383 0
 820              		.cfi_startproc
 821              		@ args = 0, pretend = 0, frame = 8
 822              		@ frame_needed = 0, uses_anonymous_args = 0
 823              	.LVL95:
 824 05bc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 825              	.LCFI6:
 826              		.cfi_def_cfa_offset 36
 827              		.cfi_offset 4, -36
 828              		.cfi_offset 5, -32
 829              		.cfi_offset 6, -28
 830              		.cfi_offset 7, -24
 831              		.cfi_offset 8, -20
 832              		.cfi_offset 9, -16
 833              		.cfi_offset 10, -12
 834              		.cfi_offset 11, -8
 835              		.cfi_offset 14, -4
1388:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 836              		.loc 1 1388 0
 837 05c0 EC429FE5 		ldr	r4, .L90
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 838              		.loc 1 1389 0
 839 05c4 EC729FE5 		ldr	r7, .L90+4
1392:../uvc.c      **** 
 840              		.loc 1 1392 0
 841 05c8 ECB29FE5 		ldr	fp, .L90+8
1391:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 842              		.loc 1 1391 0
 843 05cc EC829FE5 		ldr	r8, .L90+12
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 844              		.loc 1 1383 0
 845 05d0 01E0A0E1 		mov	lr, r1
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 846              		.loc 1 1389 0
 847 05d4 FFAC00E2 		and	r10, r0, #65280
 848 05d8 0118A0E1 		mov	r1, r1, asl #16
 849              	.LVL96:
1390:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 850              		.loc 1 1390 0
 851 05dc E0929FE5 		ldr	r9, .L90+16
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 852              		.loc 1 1383 0
 853 05e0 1CD04DE2 		sub	sp, sp, #28
 854              	.LCFI7:
 855              		.cfi_def_cfa_offset 64
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 856              		.loc 1 1383 0
 857 05e4 00C0A0E1 		mov	ip, r0
1390:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 858              		.loc 1 1390 0
 859 05e8 2068A0E1 		mov	r6, r0, lsr #16
1392:../uvc.c      **** 
 860              		.loc 1 1392 0
 861 05ec 2E58A0E1 		mov	r5, lr, lsr #16
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 862              		.loc 1 1389 0
 863 05f0 2AA4A0E1 		mov	r10, r10, lsr #8
 864 05f4 2118A0E1 		mov	r1, r1, lsr #16
1395:../uvc.c      **** #endif
 865              		.loc 1 1395 0
 866 05f8 04108DE5 		str	r1, [sp, #4]
 867 05fc 00608DE5 		str	r6, [sp]
 868 0600 08508DE5 		str	r5, [sp, #8]
 869 0604 FF2000E2 		and	r2, r0, #255
1388:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 870              		.loc 1 1388 0
 871 0608 00C0C4E5 		strb	ip, [r4]
1395:../uvc.c      **** #endif
 872              		.loc 1 1395 0
 873 060c 0A30A0E1 		mov	r3, r10
 874 0610 0400A0E3 		mov	r0, #4
 875              	.LVL97:
 876 0614 AC129FE5 		ldr	r1, .L90+20
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 877              		.loc 1 1389 0
 878 0618 00A0C7E5 		strb	r10, [r7]
1392:../uvc.c      **** 
 879              		.loc 1 1392 0
 880 061c B050CBE1 		strh	r5, [fp]	@ movhi
1391:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 881              		.loc 1 1391 0
 882 0620 B0E0C8E1 		strh	lr, [r8]	@ movhi
1390:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 883              		.loc 1 1390 0
 884 0624 B060C9E1 		strh	r6, [r9]	@ movhi
1395:../uvc.c      **** #endif
 885              		.loc 1 1395 0
 886 0628 FEFFFFEB 		bl	CyU3PDebugPrint
 887              	.LVL98:
1399:../uvc.c      ****     {
 888              		.loc 1 1399 0
 889 062c 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 890 0630 020054E3 		cmp	r4, #2
 891 0634 4D00000A 		beq	.L58
 892 0638 0600009A 		bls	.L87
 893 063c 210054E3 		cmp	r4, #33
 894 0640 3C00000A 		beq	.L61
 895 0644 A10054E3 		cmp	r4, #161
 896 0648 3A00000A 		beq	.L61
 897              	.L75:
1384:../uvc.c      ****     uint32_t status;
 898              		.loc 1 1384 0
 899 064c 0000A0E3 		mov	r0, #0
 900              	.LVL99:
 901              	.L57:
1526:../uvc.c      **** 
 902              		.loc 1 1526 0
 903 0650 1CD08DE2 		add	sp, sp, #28
 904              		@ sp needed
 905 0654 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 906              	.LVL100:
 907              	.L87:
1399:../uvc.c      ****     {
 908              		.loc 1 1399 0
 909 0658 010054E3 		cmp	r4, #1
 910 065c FAFFFF1A 		bne	.L75
1439:../uvc.c      ****             {
 911              		.loc 1 1439 0
 912 0660 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 913 0664 0B0053E3 		cmp	r3, #11
 914 0668 F7FFFF1A 		bne	.L75
1443:../uvc.c      ****                 {
 915              		.loc 1 1443 0
 916 066c B040D8E1 		ldrh	r4, [r8]
 917 0670 010054E3 		cmp	r4, #1
 918 0674 F4FFFF1A 		bne	.L75
1443:../uvc.c      ****                 {
 919              		.loc 1 1443 0 is_stmt 0 discriminator 1
 920 0678 B050D9E1 		ldrh	r5, [r9]
 921 067c 000055E3 		cmp	r5, #0
 922 0680 F1FFFF1A 		bne	.L75
1448:../uvc.c      ****                     streamingStarted = CyFalse;
 923              		.loc 1 1448 0 is_stmt 1
 924 0684 40629FE5 		ldr	r6, .L90+24
1446:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 925              		.loc 1 1446 0
 926 0688 40129FE5 		ldr	r1, .L90+28
 927 068c 0400A0E3 		mov	r0, #4
 928 0690 FEFFFFEB 		bl	CyU3PDebugPrint
 929              	.LVL101:
1447:../uvc.c      ****                     gpif_initialized = 0;
 930              		.loc 1 1447 0
 931 0694 0400A0E1 		mov	r0, r4
 932 0698 FEFFFFEB 		bl	CyU3PGpifDisable
 933              	.LVL102:
1451:../uvc.c      ****                     CyU3PBusyWait (100);
 934              		.loc 1 1451 0
 935 069c 0410A0E1 		mov	r1, r4
 936 06a0 8300A0E3 		mov	r0, #131
1448:../uvc.c      ****                     streamingStarted = CyFalse;
 937              		.loc 1 1448 0
 938 06a4 845086E5 		str	r5, [r6, #132]
1449:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 939              		.loc 1 1449 0
 940 06a8 805086E5 		str	r5, [r6, #128]
1451:../uvc.c      ****                     CyU3PBusyWait (100);
 941              		.loc 1 1451 0
 942 06ac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 943              	.LVL103:
1452:../uvc.c      **** 
 944              		.loc 1 1452 0
 945 06b0 6400A0E3 		mov	r0, #100
 946 06b4 FEFFFFEB 		bl	CyFx3BusyWait
 947              	.LVL104:
1455:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 948              		.loc 1 1455 0
 949 06b8 14029FE5 		ldr	r0, .L90+32
 950 06bc FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 951              	.LVL105:
1456:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 952              		.loc 1 1456 0
 953 06c0 8300A0E3 		mov	r0, #131
 954 06c4 FEFFFFEB 		bl	CyU3PUsbFlushEp
 955              	.LVL106:
1457:../uvc.c      ****                     CyU3PBusyWait (100);
 956              		.loc 1 1457 0
 957 06c8 0510A0E1 		mov	r1, r5
 958 06cc 8300A0E3 		mov	r0, #131
 959 06d0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 960              	.LVL107:
1458:../uvc.c      **** 
 961              		.loc 1 1458 0
 962 06d4 6400A0E3 		mov	r0, #100
 963 06d8 FEFFFFEB 		bl	CyFx3BusyWait
 964              	.LVL108:
1461:../uvc.c      ****                     uvcHandleReq = CyTrue;
 965              		.loc 1 1461 0
 966 06dc 0420A0E1 		mov	r2, r4
 967 06e0 0510A0E1 		mov	r1, r5
 968 06e4 8300A0E3 		mov	r0, #131
 969 06e8 FEFFFFEB 		bl	CyU3PUsbStall
 970              	.LVL109:
1464:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 971              		.loc 1 1464 0
 972 06ec FEFFFFEB 		bl	CyU3PUsbAckSetup
 973              	.LVL110:
 974              	.LBB58:
 975              	.LBB59:
1322:../uvc.c      **** 	{
 976              		.loc 1 1322 0
 977 06f0 00508DE5 		str	r5, [sp]
 978 06f4 0410A0E1 		mov	r1, r4
 979              	.LBE59:
 980              	.LBE58:
1466:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 981              		.loc 1 1466 0
 982 06f8 8C4086E5 		str	r4, [r6, #140]
 983              	.LBB63:
 984              	.LBB62:
1322:../uvc.c      **** 	{
 985              		.loc 1 1322 0
 986 06fc 0600A0E1 		mov	r0, r6
 987 0700 0220A0E3 		mov	r2, #2
 988 0704 14308DE2 		add	r3, sp, #20
 989 0708 FEFFFFEB 		bl	_txe_event_flags_get
 990              	.LVL111:
 991 070c 004050E2 		subs	r4, r0, #0
 992 0710 1300001A 		bne	.L86
 993              	.LBB60:
 994              	.LBB61:
1325:../uvc.c      **** 
 995              		.loc 1 1325 0
 996 0714 0600A0E1 		mov	r0, r6
 997 0718 0110E0E3 		mvn	r1, #1
 998 071c 0220A0E3 		mov	r2, #2
 999 0720 FEFFFFEB 		bl	_txe_event_flags_set
 1000              	.LVL112:
1328:../uvc.c      **** 	}
 1001              		.loc 1 1328 0
 1002 0724 0600A0E1 		mov	r0, r6
 1003 0728 0420A0E1 		mov	r2, r4
 1004 072c 0210A0E3 		mov	r1, #2
 1005 0730 FEFFFFEB 		bl	_txe_event_flags_set
 1006              	.LVL113:
 1007 0734 0A0000EA 		b	.L86
 1008              	.LVL114:
 1009              	.L61:
 1010              	.LBE61:
 1011              	.LBE60:
 1012              	.LBE62:
 1013              	.LBE63:
1404:../uvc.c      ****             {
 1014              		.loc 1 1404 0
 1015 0738 0040D8E5 		ldrb	r4, [r8]	@ zero_extendqisi2
 1016 073c 000054E3 		cmp	r4, #0
 1017 0740 1700000A 		beq	.L62
 1018 0744 010054E3 		cmp	r4, #1
 1019 0748 BFFFFF1A 		bne	.L75
 1020              	.LVL115:
1422:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1021              		.loc 1 1422 0
 1022 074c 0020A0E3 		mov	r2, #0
 1023 0750 74019FE5 		ldr	r0, .L90+24
 1024 0754 0810A0E3 		mov	r1, #8
 1025 0758 FEFFFFEB 		bl	_txe_event_flags_set
 1026              	.LVL116:
1424:../uvc.c      ****                         {
 1027              		.loc 1 1424 0
 1028 075c 002050E2 		subs	r2, r0, #0
 1029 0760 1D00001A 		bne	.L88
 1030              	.LVL117:
 1031              	.L86:
1408:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1032              		.loc 1 1408 0
 1033 0764 0100A0E3 		mov	r0, #1
 1034              	.LVL118:
1526:../uvc.c      **** 
 1035              		.loc 1 1526 0
 1036 0768 1CD08DE2 		add	sp, sp, #28
 1037              		@ sp needed
 1038 076c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1039              	.LVL119:
 1040              	.L58:
1474:../uvc.c      ****             {
 1041              		.loc 1 1474 0
 1042 0770 0050D7E5 		ldrb	r5, [r7]	@ zero_extendqisi2
 1043 0774 010055E3 		cmp	r5, #1
 1044 0778 B3FFFF1A 		bne	.L75
1476:../uvc.c      ****                 {
 1045              		.loc 1 1476 0
 1046 077c B060D8E1 		ldrh	r6, [r8]
 1047 0780 830056E3 		cmp	r6, #131
 1048 0784 B0FFFF1A 		bne	.L75
1482:../uvc.c      ****                     {
 1049              		.loc 1 1482 0
 1050 0788 3C819FE5 		ldr	r8, .L90+24
 1051 078c 807098E5 		ldr	r7, [r8, #128]
 1052 0790 010057E3 		cmp	r7, #1
 1053 0794 1900000A 		beq	.L89
 1054              	.LVL120:
1514:../uvc.c      ****                     }
 1055              		.loc 1 1514 0
 1056 0798 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1057              	.LVL121:
1513:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1058              		.loc 1 1513 0
 1059 079c 0500A0E1 		mov	r0, r5
 1060 07a0 AAFFFFEA 		b	.L57
 1061              	.LVL122:
 1062              	.L62:
1409:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1063              		.loc 1 1409 0
 1064 07a4 0420A0E1 		mov	r2, r4
 1065 07a8 1C019FE5 		ldr	r0, .L90+24
 1066 07ac 0410A0E3 		mov	r1, #4
 1067 07b0 FEFFFFEB 		bl	_txe_event_flags_set
 1068              	.LVL123:
1411:../uvc.c      ****                         {
 1069              		.loc 1 1411 0
 1070 07b4 002050E2 		subs	r2, r0, #0
 1071 07b8 E9FFFF0A 		beq	.L86
1413:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1072              		.loc 1 1413 0
 1073 07bc 14119FE5 		ldr	r1, .L90+36
 1074 07c0 0400A0E3 		mov	r0, #4
 1075              	.LVL124:
 1076 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 1077              	.LVL125:
1414:../uvc.c      ****                         }
 1078              		.loc 1 1414 0
 1079 07c8 0400A0E1 		mov	r0, r4
 1080 07cc 0420A0E1 		mov	r2, r4
 1081 07d0 0110A0E3 		mov	r1, #1
 1082 07d4 FEFFFFEB 		bl	CyU3PUsbStall
 1083              	.LVL126:
 1084 07d8 E1FFFFEA 		b	.L86
 1085              	.LVL127:
 1086              	.L88:
1427:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1087              		.loc 1 1427 0
 1088 07dc F8109FE5 		ldr	r1, .L90+40
 1089 07e0 0400A0E3 		mov	r0, #4
 1090              	.LVL128:
 1091 07e4 FEFFFFEB 		bl	CyU3PDebugPrint
 1092              	.LVL129:
1428:../uvc.c      ****                         }
 1093              		.loc 1 1428 0
 1094 07e8 0000A0E3 		mov	r0, #0
 1095 07ec 0020A0E1 		mov	r2, r0
 1096 07f0 0410A0E1 		mov	r1, r4
 1097 07f4 FEFFFFEB 		bl	CyU3PUsbStall
 1098              	.LVL130:
1421:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1099              		.loc 1 1421 0
 1100 07f8 0400A0E1 		mov	r0, r4
 1101 07fc 93FFFFEA 		b	.L57
 1102              	.LVL131:
 1103              	.L89:
1484:../uvc.c      **** 
 1104              		.loc 1 1484 0
 1105 0800 D8109FE5 		ldr	r1, .L90+44
 1106 0804 0400A0E3 		mov	r0, #4
 1107 0808 FEFFFFEB 		bl	CyU3PDebugPrint
 1108              	.LVL132:
1487:../uvc.c      ****                         gpif_initialized = 0;
 1109              		.loc 1 1487 0
 1110 080c 0700A0E1 		mov	r0, r7
 1111 0810 FEFFFFEB 		bl	CyU3PGpifDisable
 1112              	.LVL133:
1488:../uvc.c      ****                         streamingStarted = CyFalse;
 1113              		.loc 1 1488 0
 1114 0814 0050A0E3 		mov	r5, #0
1492:../uvc.c      ****                         CyU3PBusyWait (100);
 1115              		.loc 1 1492 0
 1116 0818 0710A0E1 		mov	r1, r7
 1117 081c 0600A0E1 		mov	r0, r6
1488:../uvc.c      ****                         streamingStarted = CyFalse;
 1118              		.loc 1 1488 0
 1119 0820 845088E5 		str	r5, [r8, #132]
1489:../uvc.c      **** 
 1120              		.loc 1 1489 0
 1121 0824 805088E5 		str	r5, [r8, #128]
1492:../uvc.c      ****                         CyU3PBusyWait (100);
 1122              		.loc 1 1492 0
 1123 0828 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1124              	.LVL134:
1493:../uvc.c      **** 
 1125              		.loc 1 1493 0
 1126 082c 6400A0E3 		mov	r0, #100
 1127 0830 FEFFFFEB 		bl	CyFx3BusyWait
 1128              	.LVL135:
1496:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1129              		.loc 1 1496 0
 1130 0834 98009FE5 		ldr	r0, .L90+32
 1131 0838 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1132              	.LVL136:
1497:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1133              		.loc 1 1497 0
 1134 083c 0600A0E1 		mov	r0, r6
 1135 0840 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1136              	.LVL137:
1498:../uvc.c      ****                         CyU3PBusyWait (100);
 1137              		.loc 1 1498 0
 1138 0844 0510A0E1 		mov	r1, r5
 1139 0848 0600A0E1 		mov	r0, r6
 1140 084c FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1141              	.LVL138:
1499:../uvc.c      **** 
 1142              		.loc 1 1499 0
 1143 0850 6400A0E3 		mov	r0, #100
 1144 0854 FEFFFFEB 		bl	CyFx3BusyWait
 1145              	.LVL139:
1502:../uvc.c      **** 
 1146              		.loc 1 1502 0
 1147 0858 0510A0E1 		mov	r1, r5
 1148 085c 0720A0E1 		mov	r2, r7
 1149 0860 0600A0E1 		mov	r0, r6
 1150 0864 FEFFFFEB 		bl	CyU3PUsbStall
 1151              	.LVL140:
1506:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1152              		.loc 1 1506 0
 1153 0868 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1154              	.LVL141:
 1155              	.LBB64:
 1156              	.LBB65:
1322:../uvc.c      **** 	{
 1157              		.loc 1 1322 0
 1158 086c 00508DE5 		str	r5, [sp]
 1159 0870 0710A0E1 		mov	r1, r7
 1160 0874 0800A0E1 		mov	r0, r8
 1161 0878 0420A0E1 		mov	r2, r4
 1162 087c 14308DE2 		add	r3, sp, #20
 1163              	.LBE65:
 1164              	.LBE64:
1508:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1165              		.loc 1 1508 0
 1166 0880 8C7088E5 		str	r7, [r8, #140]
 1167              	.LBB69:
 1168              	.LBB68:
1322:../uvc.c      **** 	{
 1169              		.loc 1 1322 0
 1170 0884 FEFFFFEB 		bl	_txe_event_flags_get
 1171              	.LVL142:
 1172 0888 005050E2 		subs	r5, r0, #0
 1173 088c B4FFFF1A 		bne	.L86
 1174              	.LBB66:
 1175              	.LBB67:
1325:../uvc.c      **** 
 1176              		.loc 1 1325 0
 1177 0890 0420A0E1 		mov	r2, r4
 1178 0894 0800A0E1 		mov	r0, r8
 1179 0898 0110E0E3 		mvn	r1, #1
 1180 089c FEFFFFEB 		bl	_txe_event_flags_set
 1181              	.LVL143:
1328:../uvc.c      **** 	}
 1182              		.loc 1 1328 0
 1183 08a0 0800A0E1 		mov	r0, r8
 1184 08a4 0410A0E1 		mov	r1, r4
 1185 08a8 0520A0E1 		mov	r2, r5
 1186 08ac FEFFFFEB 		bl	_txe_event_flags_set
 1187              	.LVL144:
 1188 08b0 ABFFFFEA 		b	.L86
 1189              	.L91:
 1190              		.align	2
 1191              	.L90:
 1192 08b4 00000000 		.word	bmReqType
 1193 08b8 00000000 		.word	bRequest
 1194 08bc 00000000 		.word	wLength
 1195 08c0 00000000 		.word	wIndex
 1196 08c4 00000000 		.word	wValue
 1197 08c8 E4000000 		.word	.LC6
 1198 08cc 00000000 		.word	.LANCHOR0
 1199 08d0 A0010000 		.word	.LC9
 1200 08d4 00000000 		.word	glChHandleUVCStream
 1201 08d8 34010000 		.word	.LC7
 1202 08dc 6C010000 		.word	.LC8
 1203 08e0 B8010000 		.word	.LC10
 1204              	.LBE67:
 1205              	.LBE66:
 1206              	.LBE68:
 1207              	.LBE69:
 1208              		.cfi_endproc
 1209              	.LFE9:
 1211              		.align	2
 1212              		.global	I2CCmdHandler
 1214              	I2CCmdHandler:
 1215              	.LFB0:
 329:../uvc.c      **** 	uint8_t buf[2];
 1216              		.loc 1 329 0
 1217              		.cfi_startproc
 1218              		@ args = 0, pretend = 0, frame = 8
 1219              		@ frame_needed = 0, uses_anonymous_args = 0
 1220 08e4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1221              	.LCFI8:
 1222              		.cfi_def_cfa_offset 36
 1223              		.cfi_offset 4, -36
 1224              		.cfi_offset 5, -32
 1225              		.cfi_offset 6, -28
 1226              		.cfi_offset 7, -24
 1227              		.cfi_offset 8, -20
 1228              		.cfi_offset 9, -16
 1229              		.cfi_offset 10, -12
 1230              		.cfi_offset 11, -8
 1231              		.cfi_offset 14, -4
 332:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1232              		.loc 1 332 0
 1233 08e8 14419FE5 		ldr	r4, .L98
 329:../uvc.c      **** 	uint8_t buf[2];
 1234              		.loc 1 329 0
 1235 08ec 34D04DE2 		sub	sp, sp, #52
 1236              	.LCFI9:
 1237              		.cfi_def_cfa_offset 88
 332:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1238              		.loc 1 332 0
 1239 08f0 9050D4E5 		ldrb	r5, [r4, #144]	@ zero_extendqisi2
 1240              	.LVL145:
 337:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1241              		.loc 1 337 0
 1242 08f4 9A10D4E5 		ldrb	r1, [r4, #154]	@ zero_extendqisi2
 334:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1243              		.loc 1 334 0
 1244 08f8 9860D4E5 		ldrb	r6, [r4, #152]	@ zero_extendqisi2
 1245              	.LVL146:
 337:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1246              		.loc 1 337 0
 1247 08fc 92B0D4E5 		ldrb	fp, [r4, #146]	@ zero_extendqisi2
 1248 0900 93A0D4E5 		ldrb	r10, [r4, #147]	@ zero_extendqisi2
 1249 0904 9490D4E5 		ldrb	r9, [r4, #148]	@ zero_extendqisi2
 1250 0908 9580D4E5 		ldrb	r8, [r4, #149]	@ zero_extendqisi2
 1251 090c 9670D4E5 		ldrb	r7, [r4, #150]	@ zero_extendqisi2
 1252 0910 97E0D4E5 		ldrb	lr, [r4, #151]	@ zero_extendqisi2
 1253 0914 99C0D4E5 		ldrb	ip, [r4, #153]	@ zero_extendqisi2
 1254 0918 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
 1255 091c 0400A0E3 		mov	r0, #4
 1256 0920 20108DE5 		str	r1, [sp, #32]
 1257 0924 0520A0E1 		mov	r2, r5
 1258 0928 18608DE5 		str	r6, [sp, #24]
 1259 092c 00B08DE5 		str	fp, [sp]
 1260 0930 04A08DE5 		str	r10, [sp, #4]
 1261 0934 08908DE5 		str	r9, [sp, #8]
 1262 0938 0C808DE5 		str	r8, [sp, #12]
 1263 093c 10708DE5 		str	r7, [sp, #16]
 1264 0940 14E08DE5 		str	lr, [sp, #20]
 1265 0944 1CC08DE5 		str	ip, [sp, #28]
 1266 0948 B8109FE5 		ldr	r1, .L98+4
 1267 094c FEFFFFEB 		bl	CyU3PDebugPrint
 1268              	.LVL147:
 341:../uvc.c      **** 	{
 1269              		.loc 1 341 0
 1270 0950 000055E3 		cmp	r5, #0
 1271 0954 0300000A 		beq	.L96
 366:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1272              		.loc 1 366 0
 1273 0958 010055E3 		cmp	r5, #1
 1274 095c 1700000A 		beq	.L97
 381:../uvc.c      **** 
 1275              		.loc 1 381 0
 1276 0960 34D08DE2 		add	sp, sp, #52
 1277              		@ sp needed
 1278 0964 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1279              	.LVL148:
 1280              	.L96:
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1281              		.loc 1 357 0
 1282 0968 9200D4E5 		ldrb	r0, [r4, #146]	@ zero_extendqisi2
 1283 096c 9310D4E5 		ldrb	r1, [r4, #147]	@ zero_extendqisi2
 1284 0970 98E0D4E5 		ldrb	lr, [r4, #152]	@ zero_extendqisi2
 1285 0974 28C08DE2 		add	ip, sp, #40
 1286 0978 9530D4E5 		ldrb	r3, [r4, #149]	@ zero_extendqisi2
 1287 097c 9420D4E5 		ldrb	r2, [r4, #148]	@ zero_extendqisi2
 1288 0980 04C08DE5 		str	ip, [sp, #4]
 343:../uvc.c      **** #if 0 //for debugging
 1289              		.loc 1 343 0
 1290 0984 0FC0A0E3 		mov	ip, #15
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1291              		.loc 1 357 0
 1292 0988 00E08DE5 		str	lr, [sp]
 1293 098c 011081E3 		orr	r1, r1, #1
 343:../uvc.c      **** #if 0 //for debugging
 1294              		.loc 1 343 0
 1295 0990 9BC0C4E5 		strb	ip, [r4, #155]
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1296              		.loc 1 357 0
 1297 0994 010080E3 		orr	r0, r0, #1
 1298 0998 FEFFFFEB 		bl	SensorRead2B
 1299              	.LVL149:
 358:../uvc.c      **** 			if(CmdDataLen == 2){
 1300              		.loc 1 358 0
 1301 099c 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
 359:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1302              		.loc 1 359 0
 1303 09a0 020056E3 		cmp	r6, #2
 358:../uvc.c      **** 			if(CmdDataLen == 2){
 1304              		.loc 1 358 0
 1305 09a4 9930C4E5 		strb	r3, [r4, #153]
 360:../uvc.c      **** 			}
 1306              		.loc 1 360 0
 1307 09a8 2930DD05 		ldreqb	r3, [sp, #41]	@ zero_extendqisi2
 1308 09ac 9A30C405 		streqb	r3, [r4, #154]
 362:../uvc.c      **** 		}else{//not support currently
 1309              		.loc 1 362 0
 1310 09b0 0030E0E3 		mvn	r3, #0
 1311 09b4 9B30C4E5 		strb	r3, [r4, #155]
 381:../uvc.c      **** 
 1312              		.loc 1 381 0
 1313 09b8 34D08DE2 		add	sp, sp, #52
 1314              		@ sp needed
 1315 09bc F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1316              	.LVL150:
 1317              	.L97:
 375:../uvc.c      **** 		}else{//not support currently
 1318              		.loc 1 375 0
 1319 09c0 9200D4E5 		ldrb	r0, [r4, #146]	@ zero_extendqisi2
 1320 09c4 9310D4E5 		ldrb	r1, [r4, #147]	@ zero_extendqisi2
 1321 09c8 9850D4E5 		ldrb	r5, [r4, #152]	@ zero_extendqisi2
 1322              	.LVL151:
 368:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1323              		.loc 1 368 0
 1324 09cc 99E0D4E5 		ldrb	lr, [r4, #153]	@ zero_extendqisi2
 369:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1325              		.loc 1 369 0
 1326 09d0 9AC0D4E5 		ldrb	ip, [r4, #154]	@ zero_extendqisi2
 375:../uvc.c      **** 		}else{//not support currently
 1327              		.loc 1 375 0
 1328 09d4 9420D4E5 		ldrb	r2, [r4, #148]	@ zero_extendqisi2
 1329 09d8 9530D4E5 		ldrb	r3, [r4, #149]	@ zero_extendqisi2
 1330 09dc 28408DE2 		add	r4, sp, #40
 1331 09e0 FE1001E2 		and	r1, r1, #254
 1332 09e4 00508DE5 		str	r5, [sp]
 1333 09e8 04408DE5 		str	r4, [sp, #4]
 1334 09ec FE0000E2 		and	r0, r0, #254
 368:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1335              		.loc 1 368 0
 1336 09f0 28E0CDE5 		strb	lr, [sp, #40]
 369:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1337              		.loc 1 369 0
 1338 09f4 29C0CDE5 		strb	ip, [sp, #41]
 375:../uvc.c      **** 		}else{//not support currently
 1339              		.loc 1 375 0
 1340 09f8 FEFFFFEB 		bl	SensorWrite2B
 1341              	.LVL152:
 381:../uvc.c      **** 
 1342              		.loc 1 381 0
 1343 09fc 34D08DE2 		add	sp, sp, #52
 1344              		@ sp needed
 1345 0a00 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1346              	.LVL153:
 1347              	.L99:
 1348              		.align	2
 1349              	.L98:
 1350 0a04 00000000 		.word	.LANCHOR0
 1351 0a08 DC010000 		.word	.LC11
 1352              		.cfi_endproc
 1353              	.LFE0:
 1355              		.align	2
 1356              		.global	setIrisauto
 1358              	setIrisauto:
 1359              	.LFB1:
 387:../uvc.c      **** 	uint8_t dataIdx;
 1360              		.loc 1 387 0
 1361              		.cfi_startproc
 1362              		@ args = 0, pretend = 0, frame = 0
 1363              		@ frame_needed = 0, uses_anonymous_args = 0
 1364              	.LVL154:
 1365 0a0c 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1366              	.LCFI10:
 1367              		.cfi_def_cfa_offset 16
 1368              		.cfi_offset 4, -16
 1369              		.cfi_offset 5, -12
 1370              		.cfi_offset 6, -8
 1371              		.cfi_offset 14, -4
 1372 0a10 0150A0E1 		mov	r5, r1
 1373 0a14 08D04DE2 		sub	sp, sp, #8
 1374              	.LCFI11:
 1375              		.cfi_def_cfa_offset 24
 387:../uvc.c      **** 	uint8_t dataIdx;
 1376              		.loc 1 387 0
 1377 0a18 0040A0E1 		mov	r4, r0
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1378              		.loc 1 391 0
 1379 0a1c 0060A0E3 		mov	r6, #0
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1380              		.loc 1 390 0
 1381 0a20 0010E0E3 		mvn	r1, #0
 1382              	.LVL155:
 1383 0a24 1C0090E5 		ldr	r0, [r0, #28]
 1384              	.LVL156:
 1385 0a28 FEFFFFEB 		bl	_txe_mutex_get
 1386              	.LVL157:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1387              		.loc 1 391 0
 1388 0a2c 062055E0 		subs	r2, r5, r6
 1389 0a30 003072E2 		rsbs	r3, r2, #0
 1390 0a34 0230B3E0 		adcs	r3, r3, r2
 1391 0a38 00308DE5 		str	r3, [sp]
 1392 0a3c 0400A0E1 		mov	r0, r4
 1393 0a40 04608DE5 		str	r6, [sp, #4]
 1394 0a44 2010A0E3 		mov	r1, #32
 1395 0a48 2720A0E3 		mov	r2, #39
 1396 0a4c 3030A0E3 		mov	r3, #48
 1397 0a50 FEFFFFEB 		bl	cmdSet
 1398              	.LVL158:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1399              		.loc 1 392 0
 1400 0a54 060055E1 		cmp	r5, r6
 1401 0a58 0250A003 		moveq	r5, #2
 1402 0a5c 0150A013 		movne	r5, #1
 1403 0a60 60008DE8 		stmia	sp, {r5, r6}
 1404 0a64 0400A0E1 		mov	r0, r4
 1405 0a68 2110A0E3 		mov	r1, #33
 1406 0a6c 2520A0E3 		mov	r2, #37
 1407 0a70 3030A0E3 		mov	r3, #48
 1408 0a74 FEFFFFEB 		bl	cmdSet
 1409              	.LVL159:
 393:../uvc.c      **** }
 1410              		.loc 1 393 0
 1411 0a78 1C0094E5 		ldr	r0, [r4, #28]
 394:../uvc.c      **** 
 1412              		.loc 1 394 0
 1413 0a7c 08D08DE2 		add	sp, sp, #8
 1414              		@ sp needed
 1415 0a80 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1416              	.LVL160:
 393:../uvc.c      **** }
 1417              		.loc 1 393 0
 1418 0a84 FEFFFFEA 		b	_txe_mutex_put
 1419              	.LVL161:
 1420              		.cfi_endproc
 1421              	.LFE1:
 1423              		.align	2
 1424              		.global	ControlHandle
 1426              	ControlHandle:
 1427              	.LFB2:
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1428              		.loc 1 396 0
 1429              		.cfi_startproc
 1430              		@ args = 0, pretend = 0, frame = 24
 1431              		@ frame_needed = 0, uses_anonymous_args = 0
 1432              	.LVL162:
 1433 0a88 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1434              	.LCFI12:
 1435              		.cfi_def_cfa_offset 36
 1436              		.cfi_offset 4, -36
 1437              		.cfi_offset 5, -32
 1438              		.cfi_offset 6, -28
 1439              		.cfi_offset 7, -24
 1440              		.cfi_offset 8, -20
 1441              		.cfi_offset 9, -16
 1442              		.cfi_offset 10, -12
 1443              		.cfi_offset 11, -8
 1444              		.cfi_offset 14, -4
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1445              		.loc 1 404 0
 1446 0a8c 9C6E9FE5 		ldr	r6, .L195
 402:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1447              		.loc 1 402 0
 1448 0a90 208040E2 		sub	r8, r0, #32
 403:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1449              		.loc 1 403 0
 1450 0a94 230050E3 		cmp	r0, #35
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1451              		.loc 1 396 0
 1452 0a98 2CD04DE2 		sub	sp, sp, #44
 1453              	.LCFI13:
 1454              		.cfi_def_cfa_offset 80
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1455              		.loc 1 396 0
 1456 0a9c 0040A0E1 		mov	r4, r0
 402:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1457              		.loc 1 402 0
 1458 0aa0 FF8008E2 		and	r8, r8, #255
 1459              	.LVL163:
 403:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1460              		.loc 1 403 0
 1461 0aa4 2A00009A 		bls	.L104
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1462              		.loc 1 404 0
 1463 0aa8 882088E0 		add	r2, r8, r8, asl #1
 1464 0aac 8221A0E1 		mov	r2, r2, asl #3
 1465 0ab0 023086E0 		add	r3, r6, r2
 405:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1466              		.loc 1 405 0
 1467 0ab4 01C0D3E5 		ldrb	ip, [r3, #1]	@ zero_extendqisi2
 406:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1468              		.loc 1 406 0
 1469 0ab8 0FA0D3E5 		ldrb	r10, [r3, #15]	@ zero_extendqisi2
 407:../uvc.c      ****     }else{
 1470              		.loc 1 407 0
 1471 0abc 0290D3E5 		ldrb	r9, [r3, #2]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 1472              		.loc 1 418 0
 1473 0ac0 6C3E9FE5 		ldr	r3, .L195+4
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1474              		.loc 1 404 0
 1475 0ac4 02B0D6E7 		ldrb	fp, [r6, r2]	@ zero_extendqisi2
 1476              	.LVL164:
 418:../uvc.c      ****     /*
 1477              		.loc 1 418 0
 1478 0ac8 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 1479              	.LVL165:
 426:../uvc.c      **** 		 {
 1480              		.loc 1 426 0
 1481 0acc 830055E3 		cmp	r5, #131
 1482 0ad0 2900000A 		beq	.L107
 1483              	.LVL166:
 1484              	.L193:
 1485 0ad4 3200009A 		bls	.L192
 1486 0ad8 850055E3 		cmp	r5, #133
 1487 0adc B800000A 		beq	.L112
 1488 0ae0 C300003A 		bcc	.L113
 1489 0ae4 860055E3 		cmp	r5, #134
 1490 0ae8 7500000A 		beq	.L114
 1491 0aec 870055E3 		cmp	r5, #135
 1492 0af0 AA00001A 		bne	.L106
 646:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1493              		.loc 1 646 0
 1494 0af4 230054E3 		cmp	r4, #35
 1495 0af8 CD00009A 		bls	.L148
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1496              		.loc 1 647 0
 1497 0afc 888088E0 		add	r8, r8, r8, asl #1
 1498              	.LVL167:
 1499 0b00 886186E0 		add	r6, r6, r8, asl #3
 1500 0b04 2C7E9FE5 		ldr	r7, .L195+8
 1501 0b08 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 648:../uvc.c      **** 		 	 }
 1502              		.loc 1 648 0
 1503 0b0c 0C30D6E5 		ldrb	r3, [r6, #12]	@ zero_extendqisi2
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1504              		.loc 1 647 0
 1505 0b10 9C20C7E5 		strb	r2, [r7, #156]
 648:../uvc.c      **** 		 	 }
 1506              		.loc 1 648 0
 1507 0b14 9D30C7E5 		strb	r3, [r7, #157]
 1508              	.L149:
 660:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1509              		.loc 1 660 0
 1510 0b18 0900A0E1 		mov	r0, r9
 1511              	.LVL168:
 1512 0b1c 181E9FE5 		ldr	r1, .L195+12
 1513 0b20 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1514              	.LVL169:
 1515 0b24 9C60D7E5 		ldrb	r6, [r7, #156]	@ zero_extendqisi2
 662:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 1516              		.loc 1 662 0
 1517 0b28 FF80A0E3 		mov	r8, #255
 1518 0b2c 0830A0E1 		mov	r3, r8
 1519 0b30 0840A0E1 		mov	r4, r8
 1520              	.LVL170:
 1521              	.L116:
 960:../uvc.c      **** }
 1522              		.loc 1 960 0
 1523 0b34 48018DE8 		stmia	sp, {r3, r6, r8}
 1524 0b38 001E9FE5 		ldr	r1, .L195+16
 1525 0b3c 0520A0E1 		mov	r2, r5
 1526 0b40 0430A0E1 		mov	r3, r4
 1527 0b44 0400A0E3 		mov	r0, #4
 1528 0b48 FEFFFFEB 		bl	CyU3PDebugPrint
 1529              	.LVL171:
 961:../uvc.c      **** /************** CT control requests handler *************************/
 1530              		.loc 1 961 0
 1531 0b4c 2CD08DE2 		add	sp, sp, #44
 1532              		@ sp needed
 1533 0b50 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1534              	.LVL172:
 1535              	.L104:
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1536              		.loc 1 409 0
 1537 0b54 803080E0 		add	r3, r0, r0, asl #1
 1538 0b58 833186E0 		add	r3, r6, r3, asl #3
 1539 0b5c 80B1D3E5 		ldrb	fp, [r3, #384]	@ zero_extendqisi2
 1540              	.LVL173:
 410:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1541              		.loc 1 410 0
 1542 0b60 81C1D3E5 		ldrb	ip, [r3, #385]	@ zero_extendqisi2
 1543              	.LVL174:
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1544              		.loc 1 411 0
 1545 0b64 8FA1D3E5 		ldrb	r10, [r3, #399]	@ zero_extendqisi2
 1546              	.LVL175:
 412:../uvc.c      ****     }
 1547              		.loc 1 412 0
 1548 0b68 8291D3E5 		ldrb	r9, [r3, #386]	@ zero_extendqisi2
 1549              	.LVL176:
 418:../uvc.c      ****     /*
 1550              		.loc 1 418 0
 1551 0b6c C03D9FE5 		ldr	r3, .L195+4
 1552              	.LVL177:
 1553 0b70 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 1554              	.LVL178:
 426:../uvc.c      **** 		 {
 1555              		.loc 1 426 0
 1556 0b74 830055E3 		cmp	r5, #131
 1557 0b78 D5FFFF1A 		bne	.L193
 1558              	.LVL179:
 1559              	.L107:
 601:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1560              		.loc 1 601 0
 1561 0b7c 230054E3 		cmp	r4, #35
 1562 0b80 C100009A 		bls	.L141
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1563              		.loc 1 602 0
 1564 0b84 888088E0 		add	r8, r8, r8, asl #1
 1565              	.LVL180:
 1566 0b88 886186E0 		add	r6, r6, r8, asl #3
 1567 0b8c A47D9FE5 		ldr	r7, .L195+8
 1568 0b90 0520D6E5 		ldrb	r2, [r6, #5]	@ zero_extendqisi2
 603:../uvc.c      **** 		 	 }
 1569              		.loc 1 603 0
 1570 0b94 0630D6E5 		ldrb	r3, [r6, #6]	@ zero_extendqisi2
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1571              		.loc 1 602 0
 1572 0b98 9C20C7E5 		strb	r2, [r7, #156]
 603:../uvc.c      **** 		 	 }
 1573              		.loc 1 603 0
 1574 0b9c 9D30C7E5 		strb	r3, [r7, #157]
 1575 0ba0 DCFFFFEA 		b	.L149
 1576              	.LVL181:
 1577              	.L192:
 426:../uvc.c      **** 		 {
 1578              		.loc 1 426 0
 1579 0ba4 810055E3 		cmp	r5, #129
 1580 0ba8 5600000A 		beq	.L109
 1581 0bac 3A00008A 		bhi	.L110
 1582 0bb0 010055E3 		cmp	r5, #1
 1583 0bb4 7900001A 		bne	.L106
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 1584              		.loc 1 664 0
 1585 0bb8 787D9FE5 		ldr	r7, .L195+8
 1586 0bbc 26208DE2 		add	r2, sp, #38
 1587 0bc0 2000A0E3 		mov	r0, #32
 1588              	.LVL182:
 1589 0bc4 9C1087E2 		add	r1, r7, #156
 1590 0bc8 10C08DE5 		str	ip, [sp, #16]
 1591 0bcc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1592              	.LVL183:
 666:../uvc.c      **** 			   {
 1593              		.loc 1 666 0
 1594 0bd0 10C09DE5 		ldr	ip, [sp, #16]
 1595 0bd4 002050E2 		subs	r2, r0, #0
 1596 0bd8 0C03001A 		bne	.L151
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1597              		.loc 1 668 0
 1598 0bdc 9C00D7E5 		ldrb	r0, [r7, #156]	@ zero_extendqisi2
 1599              	.LVL184:
 669:../uvc.c      **** 				  getData = glEp0Buffer[0];
 1600              		.loc 1 669 0
 1601 0be0 9D20D7E5 		ldrb	r2, [r7, #157]	@ zero_extendqisi2
 1602              	.LVL185:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1603              		.loc 1 671 0
 1604 0be4 9E30D7E5 		ldrb	r3, [r7, #158]	@ zero_extendqisi2
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1605              		.loc 1 668 0
 1606 0be8 14008DE5 		str	r0, [sp, #20]
 1607              	.LVL186:
 669:../uvc.c      **** 				  getData = glEp0Buffer[0];
 1608              		.loc 1 669 0
 1609 0bec 1C208DE5 		str	r2, [sp, #28]
 1610              	.LVL187:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1611              		.loc 1 671 0
 1612 0bf0 18308DE5 		str	r3, [sp, #24]
 1613              	.LVL188:
 675:../uvc.c      **** 					 {
 1614              		.loc 1 675 0
 1615 0bf4 260054E3 		cmp	r4, #38
 1616 0bf8 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1617 0bfc E90200EA 		b	.L152
 1618              	.L154:
 1619 0c00 0C140000 		.word	.L153
 1620 0c04 A8170000 		.word	.L152
 1621 0c08 A8170000 		.word	.L152
 1622 0c0c A8170000 		.word	.L152
 1623 0c10 C4130000 		.word	.L155
 1624 0c14 7C120000 		.word	.L156
 1625 0c18 F8110000 		.word	.L157
 1626 0c1c A8170000 		.word	.L152
 1627 0c20 A8170000 		.word	.L152
 1628 0c24 A8170000 		.word	.L152
 1629 0c28 A8170000 		.word	.L152
 1630 0c2c 6C110000 		.word	.L158
 1631 0c30 A8170000 		.word	.L152
 1632 0c34 A8170000 		.word	.L152
 1633 0c38 A8170000 		.word	.L152
 1634 0c3c A8170000 		.word	.L152
 1635 0c40 E4100000 		.word	.L159
 1636 0c44 A8170000 		.word	.L152
 1637 0c48 A8170000 		.word	.L152
 1638 0c4c A8170000 		.word	.L152
 1639 0c50 A8170000 		.word	.L152
 1640 0c54 A8170000 		.word	.L152
 1641 0c58 A8170000 		.word	.L152
 1642 0c5c A8170000 		.word	.L152
 1643 0c60 A8170000 		.word	.L152
 1644 0c64 E8150000 		.word	.L160
 1645 0c68 48150000 		.word	.L161
 1646 0c6c A8170000 		.word	.L152
 1647 0c70 38150000 		.word	.L162
 1648 0c74 A8170000 		.word	.L152
 1649 0c78 D8140000 		.word	.L163
 1650 0c7c 10170000 		.word	.L164
 1651 0c80 A8170000 		.word	.L152
 1652 0c84 A8170000 		.word	.L152
 1653 0c88 A8170000 		.word	.L152
 1654 0c8c A8170000 		.word	.L152
 1655 0c90 78160000 		.word	.L165
 1656 0c94 40170000 		.word	.L166
 1657 0c98 7C100000 		.word	.L167
 1658              	.LVL189:
 1659              	.L110:
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1660              		.loc 1 582 0
 1661 0c9c 230054E3 		cmp	r4, #35
 1662 0ca0 6D00009A 		bls	.L138
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1663              		.loc 1 583 0
 1664 0ca4 888088E0 		add	r8, r8, r8, asl #1
 1665              	.LVL190:
 1666 0ca8 886186E0 		add	r6, r6, r8, asl #3
 1667 0cac 847C9FE5 		ldr	r7, .L195+8
 1668 0cb0 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 584:../uvc.c      **** 		 	 }
 1669              		.loc 1 584 0
 1670 0cb4 0430D6E5 		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1671              		.loc 1 583 0
 1672 0cb8 9C20C7E5 		strb	r2, [r7, #156]
 584:../uvc.c      **** 		 	 }
 1673              		.loc 1 584 0
 1674 0cbc 9D30C7E5 		strb	r3, [r7, #157]
 1675 0cc0 94FFFFEA 		b	.L149
 1676              	.LVL191:
 1677              	.L114:
 635:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1678              		.loc 1 635 0
 1679 0cc4 230054E3 		cmp	r4, #35
 636:../uvc.c      **** 		 	 }
 1680              		.loc 1 636 0
 1681 0cc8 88808880 		addhi	r8, r8, r8, asl #1
 1682              	.LVL192:
 639:../uvc.c      **** 		 	 }
 1683              		.loc 1 639 0
 1684 0ccc 84408490 		addls	r4, r4, r4, asl #1
 636:../uvc.c      **** 		 	 }
 1685              		.loc 1 636 0
 1686 0cd0 88618680 		addhi	r6, r6, r8, asl #3
 639:../uvc.c      **** 		 	 }
 1687              		.loc 1 639 0
 1688 0cd4 84618690 		addls	r6, r6, r4, asl #3
 636:../uvc.c      **** 		 	 }
 1689              		.loc 1 636 0
 1690 0cd8 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 639:../uvc.c      **** 		 	 }
 1691              		.loc 1 639 0
 1692 0cdc 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 1693 0ce0 506C9FE5 		ldr	r6, .L195+8
 644:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 1694              		.loc 1 644 0
 1695 0ce4 FF80A0E3 		mov	r8, #255
 1696 0ce8 0610A0E1 		mov	r1, r6
 1697 0cec 9C30E1E5 		strb	r3, [r1, #156]!
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1698              		.loc 1 641 0
 1699 0cf0 0100A0E3 		mov	r0, #1
 1700              	.LVL193:
 1701 0cf4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1702              	.LVL194:
 644:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 1703              		.loc 1 644 0
 1704 0cf8 0840A0E1 		mov	r4, r8
 1705 0cfc 9C60D6E5 		ldrb	r6, [r6, #156]	@ zero_extendqisi2
 1706 0d00 0830A0E1 		mov	r3, r8
 1707 0d04 8AFFFFEA 		b	.L116
 1708              	.LVL195:
 1709              	.L109:
 437:../uvc.c      **** 			 {
 1710              		.loc 1 437 0
 1711 0d08 053044E2 		sub	r3, r4, #5
 1712 0d0c 210053E3 		cmp	r3, #33
 1713 0d10 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1714 0d14 CA0000EA 		b	.L117
 1715              	.L119:
 1716 0d18 C40F0000 		.word	.L118
 1717 0d1c 44100000 		.word	.L117
 1718 0d20 44100000 		.word	.L117
 1719 0d24 44100000 		.word	.L117
 1720 0d28 44100000 		.word	.L117
 1721 0d2c 44100000 		.word	.L117
 1722 0d30 E80F0000 		.word	.L120
 1723 0d34 44100000 		.word	.L117
 1724 0d38 44100000 		.word	.L117
 1725 0d3c 44100000 		.word	.L117
 1726 0d40 44100000 		.word	.L117
 1727 0d44 44100000 		.word	.L117
 1728 0d48 44100000 		.word	.L117
 1729 0d4c 44100000 		.word	.L117
 1730 0d50 44100000 		.word	.L117
 1731 0d54 44100000 		.word	.L117
 1732 0d58 44100000 		.word	.L117
 1733 0d5c 44100000 		.word	.L117
 1734 0d60 44100000 		.word	.L117
 1735 0d64 44100000 		.word	.L117
 1736 0d68 700F0000 		.word	.L121
 1737 0d6c 44100000 		.word	.L117
 1738 0d70 44100000 		.word	.L117
 1739 0d74 3C0F0000 		.word	.L122
 1740 0d78 44100000 		.word	.L117
 1741 0d7c 44100000 		.word	.L117
 1742 0d80 F40E0000 		.word	.L123
 1743 0d84 44100000 		.word	.L117
 1744 0d88 44100000 		.word	.L117
 1745 0d8c 44100000 		.word	.L117
 1746 0d90 44100000 		.word	.L117
 1747 0d94 BC0E0000 		.word	.L124
 1748 0d98 BC0E0000 		.word	.L124
 1749 0d9c BC0E0000 		.word	.L124
 1750              	.L106:
 957:../uvc.c      **** 			  break;
 1751              		.loc 1 957 0
 1752 0da0 0000A0E3 		mov	r0, #0
 1753              	.LVL196:
 958:../uvc.c      **** 		 }
 1754              		.loc 1 958 0
 1755 0da4 FF80A0E3 		mov	r8, #255
 1756              	.LVL197:
 957:../uvc.c      **** 			  break;
 1757              		.loc 1 957 0
 1758 0da8 0020A0E1 		mov	r2, r0
 1759 0dac 0110A0E3 		mov	r1, #1
 1760 0db0 FEFFFFEB 		bl	CyU3PUsbStall
 1761              	.LVL198:
 958:../uvc.c      **** 		 }
 1762              		.loc 1 958 0
 1763 0db4 0860A0E1 		mov	r6, r8
 1764 0db8 0830A0E1 		mov	r3, r8
 1765 0dbc 0840A0E1 		mov	r4, r8
 1766              	.LVL199:
 1767 0dc0 5BFFFFEA 		b	.L116
 1768              	.LVL200:
 1769              	.L112:
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1770              		.loc 1 430 0
 1771 0dc4 6C6B9FE5 		ldr	r6, .L195+8
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1772              		.loc 1 431 0
 1773 0dc8 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1774              		.loc 1 432 0
 1775 0dcc 9C1086E2 		add	r1, r6, #156
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1776              		.loc 1 434 0
 1777 0dd0 FF80A0E3 		mov	r8, #255
 1778              	.LVL201:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1779              		.loc 1 432 0
 1780 0dd4 0200A0E3 		mov	r0, #2
 1781              	.LVL202:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1782              		.loc 1 431 0
 1783 0dd8 9D30C6E5 		strb	r3, [r6, #157]
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1784              		.loc 1 430 0
 1785 0ddc 9C90C6E5 		strb	r9, [r6, #156]
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1786              		.loc 1 434 0
 1787 0de0 0840A0E1 		mov	r4, r8
 1788              	.LVL203:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1789              		.loc 1 432 0
 1790 0de4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1791              	.LVL204:
 1792 0de8 9C60D6E5 		ldrb	r6, [r6, #156]	@ zero_extendqisi2
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1793              		.loc 1 434 0
 1794 0dec 0830A0E1 		mov	r3, r8
 1795 0df0 4FFFFFEA 		b	.L116
 1796              	.LVL205:
 1797              	.L113:
 619:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1798              		.loc 1 619 0
 1799 0df4 230054E3 		cmp	r4, #35
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1800              		.loc 1 620 0
 1801 0df8 88808880 		addhi	r8, r8, r8, asl #1
 1802              	.LVL206:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1803              		.loc 1 626 0
 1804 0dfc 84408490 		addls	r4, r4, r4, asl #1
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1805              		.loc 1 620 0
 1806 0e00 88618680 		addhi	r6, r6, r8, asl #3
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1807              		.loc 1 626 0
 1808 0e04 84618690 		addls	r6, r6, r4, asl #3
 1809 0e08 287B9FE5 		ldr	r7, .L195+8
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1810              		.loc 1 620 0
 1811 0e0c 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 1812              		.loc 1 621 0
 1813 0e10 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1814              		.loc 1 626 0
 1815 0e14 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1816              		.loc 1 627 0
 1817 0e18 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1818              		.loc 1 628 0
 1819 0e1c 0030A0E3 		mov	r3, #0
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1820              		.loc 1 626 0
 1821 0e20 9C10C7E5 		strb	r1, [r7, #156]
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1822              		.loc 1 627 0
 1823 0e24 9D20C7E5 		strb	r2, [r7, #157]
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1824              		.loc 1 628 0
 1825 0e28 9E30C7E5 		strb	r3, [r7, #158]
 629:../uvc.c      **** 		 	 }
 1826              		.loc 1 629 0
 1827 0e2c 9F30C7E5 		strb	r3, [r7, #159]
 1828 0e30 38FFFFEA 		b	.L149
 1829              	.LVL207:
 1830              	.L148:
 651:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1831              		.loc 1 651 0
 1832 0e34 0B0054E3 		cmp	r4, #11
 1833 0e38 7800000A 		beq	.L194
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1834              		.loc 1 657 0
 1835 0e3c 844084E0 		add	r4, r4, r4, asl #1
 1836 0e40 846186E0 		add	r6, r6, r4, asl #3
 1837 0e44 EC7A9FE5 		ldr	r7, .L195+8
 1838 0e48 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 1839              		.loc 1 658 0
 1840 0e4c 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1841              		.loc 1 657 0
 1842 0e50 9C20C7E5 		strb	r2, [r7, #156]
 658:../uvc.c      **** 			 }
 1843              		.loc 1 658 0
 1844 0e54 9D30C7E5 		strb	r3, [r7, #157]
 1845 0e58 2EFFFFEA 		b	.L149
 1846              	.L138:
 587:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1847              		.loc 1 587 0
 1848 0e5c 0B0054E3 		cmp	r4, #11
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1849              		.loc 1 594 0
 1850 0e60 84408410 		addne	r4, r4, r4, asl #1
 1851 0e64 84618610 		addne	r6, r6, r4, asl #3
 1852 0e68 C87A9F15 		ldrne	r7, .L195+8
 588:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1853              		.loc 1 588 0
 1854 0e6c C47A9F05 		ldreq	r7, .L195+8
 1855 0e70 CC3A9F05 		ldreq	r3, .L195+20
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1856              		.loc 1 594 0
 1857 0e74 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 1858              		.loc 1 595 0
 1859 0e78 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 588:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1860              		.loc 1 588 0
 1861 0e7c 9C308705 		streq	r3, [r7, #156]
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1862              		.loc 1 594 0
 1863 0e80 9C20C715 		strneb	r2, [r7, #156]
 595:../uvc.c      **** 			 }
 1864              		.loc 1 595 0
 1865 0e84 9D30C715 		strneb	r3, [r7, #157]
 1866 0e88 22FFFFEA 		b	.L149
 1867              	.L141:
 605:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1868              		.loc 1 605 0
 1869 0e8c 0B0054E3 		cmp	r4, #11
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1870              		.loc 1 612 0
 1871 0e90 84408410 		addne	r4, r4, r4, asl #1
 1872 0e94 84618610 		addne	r6, r6, r4, asl #3
 1873 0e98 987A9F15 		ldrne	r7, .L195+8
 606:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1874              		.loc 1 606 0
 1875 0e9c 947A9F05 		ldreq	r7, .L195+8
 1876 0ea0 A03A9F05 		ldreq	r3, .L195+24
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1877              		.loc 1 612 0
 1878 0ea4 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 1879              		.loc 1 613 0
 1880 0ea8 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 606:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1881              		.loc 1 606 0
 1882 0eac 9C308705 		streq	r3, [r7, #156]
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1883              		.loc 1 612 0
 1884 0eb0 9C20C715 		strneb	r2, [r7, #156]
 613:../uvc.c      **** 			 }
 1885              		.loc 1 613 0
 1886 0eb4 9D30C715 		strneb	r3, [r7, #157]
 1887 0eb8 16FFFFEA 		b	.L149
 1888              	.L124:
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1889              		.loc 1 443 0
 1890 0ebc 888088E0 		add	r8, r8, r8, asl #1
 1891              	.LVL208:
 1892 0ec0 886186E0 		add	r6, r6, r8, asl #3
 1893 0ec4 0D20D6E5 		ldrb	r2, [r6, #13]	@ zero_extendqisi2
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 1894              		.loc 1 444 0
 1895 0ec8 0E80D6E5 		ldrb	r8, [r6, #14]	@ zero_extendqisi2
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1896              		.loc 1 443 0
 1897 0ecc 643A9FE5 		ldr	r3, .L195+8
 1898 0ed0 0260A0E1 		mov	r6, r2
 1899 0ed4 9C20C3E5 		strb	r2, [r3, #156]
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 1900              		.loc 1 444 0
 1901 0ed8 9D80C3E5 		strb	r8, [r3, #157]
 1902              	.LVL209:
 1903              	.L128:
 575:../uvc.c      **** 
 1904              		.loc 1 575 0
 1905 0edc 0900A0E1 		mov	r0, r9
 1906 0ee0 541A9FE5 		ldr	r1, .L195+12
 1907 0ee4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1908              	.LVL210:
 580:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 1909              		.loc 1 580 0
 1910 0ee8 FF30A0E3 		mov	r3, #255
 1911 0eec 0340A0E1 		mov	r4, r3
 1912 0ef0 0FFFFFEA 		b	.L116
 1913              	.LVL211:
 1914              	.L123:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1915              		.loc 1 464 0 discriminator 1
 1916 0ef4 000059E3 		cmp	r9, #0
 1917 0ef8 0300000A 		beq	.L131
 1918 0efc 380A9FE5 		ldr	r0, .L195+12
 1919              	.LVL212:
 1920 0f00 0920A0E1 		mov	r2, r9
 1921 0f04 0C1040E2 		sub	r1, r0, #12
 1922 0f08 FEFFFFEB 		bl	memcpy
 1923              	.LVL213:
 1924              	.L131:
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1925              		.loc 1 467 0
 1926 0f0c 243A9FE5 		ldr	r3, .L195+8
 474:../uvc.c      **** 			 		 {
 1927              		.loc 1 474 0
 1928 0f10 9B20D3E5 		ldrb	r2, [r3, #155]	@ zero_extendqisi2
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1929              		.loc 1 467 0
 1930 0f14 A560D3E5 		ldrb	r6, [r3, #165]	@ zero_extendqisi2
 1931              	.LVL214:
 474:../uvc.c      **** 			 		 {
 1932              		.loc 1 474 0
 1933 0f18 FF0052E3 		cmp	r2, #255
 468:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1934              		.loc 1 468 0
 1935 0f1c A680D3E5 		ldrb	r8, [r3, #166]	@ zero_extendqisi2
 1936              	.LVL215:
 474:../uvc.c      **** 			 		 {
 1937              		.loc 1 474 0
 1938 0f20 EDFFFF0A 		beq	.L128
 476:../uvc.c      **** 			 		 }
 1939              		.loc 1 476 0
 1940 0f24 9920D3E5 		ldrb	r2, [r3, #153]	@ zero_extendqisi2
 1941 0f28 1C1A9FE5 		ldr	r1, .L195+28
 1942 0f2c 9A30D3E5 		ldrb	r3, [r3, #154]	@ zero_extendqisi2
 1943 0f30 0400A0E3 		mov	r0, #4
 1944 0f34 FEFFFFEB 		bl	CyU3PDebugPrint
 1945              	.LVL216:
 1946 0f38 E7FFFFEA 		b	.L128
 1947              	.LVL217:
 1948              	.L122:
 450:../uvc.c      **** 					 if(CamMode == 1){//720p or invendo
 1949              		.loc 1 450 0
 1950 0f3c 2D34D6E5 		ldrb	r3, [r6, #1069]	@ zero_extendqisi2
 1951              	.LVL218:
 1952 0f40 E8499FE5 		ldr	r4, .L195
 452:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 1953              		.loc 1 452 0
 1954 0f44 020053E3 		cmp	r3, #2
 1955 0f48 6F02008A 		bhi	.L129
 1956 0f4c 043083E2 		add	r3, r3, #4
 1957 0f50 FF3003E2 		and	r3, r3, #255
 1958 0f54 0360A0E1 		mov	r6, r3
 1959              	.LVL219:
 1960              	.L130:
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1961              		.loc 1 460 0
 1962 0f58 D8299FE5 		ldr	r2, .L195+8
 461:../uvc.c      **** 					 break;
 1963              		.loc 1 461 0
 1964 0f5c 0010A0E3 		mov	r1, #0
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1965              		.loc 1 460 0
 1966 0f60 9C30C2E5 		strb	r3, [r2, #156]
 461:../uvc.c      **** 					 break;
 1967              		.loc 1 461 0
 1968 0f64 9D10C2E5 		strb	r1, [r2, #157]
 462:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 1969              		.loc 1 462 0
 1970 0f68 FF80A0E3 		mov	r8, #255
 1971              	.LVL220:
 1972 0f6c DAFFFFEA 		b	.L128
 1973              	.LVL221:
 1974              	.L121:
 481:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1975              		.loc 1 481 0
 1976 0f70 C0799FE5 		ldr	r7, .L195+8
 1977 0f74 4530D7E5 		ldrb	r3, [r7, #69]	@ zero_extendqisi2
 1978 0f78 000053E3 		cmp	r3, #0
 1979 0f7c 4502000A 		beq	.L132
 1980 0f80 E6E3D6E5 		ldrb	lr, [r6, #998]	@ zero_extendqisi2
 1981              	.LVL222:
 1982              	.L133:
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1983              		.loc 1 495 0
 1984 0f84 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 496:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1985              		.loc 1 496 0
 1986 0f88 00C0A0E3 		mov	ip, #0
 501:../uvc.c      **** 					 break;
 1987              		.loc 1 501 0
 1988 0f8c 00E08DE5 		str	lr, [sp]
 1989 0f90 04C08DE5 		str	ip, [sp, #4]
 1990 0f94 0420A0E1 		mov	r2, r4
 1991 0f98 0C30A0E1 		mov	r3, ip
 1992 0f9c AC199FE5 		ldr	r1, .L195+32
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1993              		.loc 1 495 0
 1994 0fa0 9C40C7E5 		strb	r4, [r7, #156]
 497:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1995              		.loc 1 497 0
 1996 0fa4 9EE0C7E5 		strb	lr, [r7, #158]
 496:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1997              		.loc 1 496 0
 1998 0fa8 9DC0C7E5 		strb	ip, [r7, #157]
 498:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 1999              		.loc 1 498 0
 2000 0fac 9FC0C7E5 		strb	ip, [r7, #159]
 2001              	.LVL223:
 501:../uvc.c      **** 					 break;
 2002              		.loc 1 501 0
 2003 0fb0 0400A0E3 		mov	r0, #4
 2004 0fb4 0E80A0E1 		mov	r8, lr
 2005              	.LVL224:
 2006 0fb8 0460A0E1 		mov	r6, r4
 2007 0fbc FEFFFFEB 		bl	CyU3PDebugPrint
 2008              	.LVL225:
 502:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2009              		.loc 1 502 0
 2010 0fc0 C5FFFFEA 		b	.L128
 2011              	.LVL226:
 2012              	.L118:
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2013              		.loc 1 532 0
 2014 0fc4 0562D6E5 		ldrb	r6, [r6, #517]	@ zero_extendqisi2
 2015 0fc8 68399FE5 		ldr	r3, .L195+8
 2016 0fcc 806046E2 		sub	r6, r6, #128
 2017 0fd0 FF6006E2 		and	r6, r6, #255
 533:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2018              		.loc 1 533 0
 2019 0fd4 0020A0E3 		mov	r2, #0
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2020              		.loc 1 532 0
 2021 0fd8 9C60C3E5 		strb	r6, [r3, #156]
 533:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2022              		.loc 1 533 0
 2023 0fdc 9D20C3E5 		strb	r2, [r3, #157]
 2024              	.LVL227:
 535:../uvc.c      **** 				 case WBTLevCtlID11:
 2025              		.loc 1 535 0
 2026 0fe0 FF80A0E3 		mov	r8, #255
 2027              	.LVL228:
 2028 0fe4 BCFFFFEA 		b	.L128
 2029              	.LVL229:
 2030              	.L120:
 538:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2031              		.loc 1 538 0
 2032 0fe8 48799FE5 		ldr	r7, .L195+8
 2033 0fec 3730D7E5 		ldrb	r3, [r7, #55]	@ zero_extendqisi2
 2034 0ff0 000053E3 		cmp	r3, #0
 2035 0ff4 1702000A 		beq	.L134
 539:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2036              		.loc 1 539 0
 2037 0ff8 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 540:../uvc.c      **** 		 	 		 }else{
 2038              		.loc 1 540 0
 2039 0ffc 8E84D6E5 		ldrb	r8, [r6, #1166]	@ zero_extendqisi2
 2040              	.LVL230:
 2041 1000 0320A0E1 		mov	r2, r3
 539:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2042              		.loc 1 539 0
 2043 1004 9C30C7E5 		strb	r3, [r7, #156]
 540:../uvc.c      **** 		 	 		 }else{
 2044              		.loc 1 540 0
 2045 1008 9E80C7E5 		strb	r8, [r7, #158]
 2046              	.LVL231:
 2047              	.L135:
 551:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2048              		.loc 1 551 0
 2049 100c 0030A0E3 		mov	r3, #0
 2050 1010 0260A0E1 		mov	r6, r2
 2051 1014 9D30C7E5 		strb	r3, [r7, #157]
 552:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2052              		.loc 1 552 0
 2053 1018 9F30C7E5 		strb	r3, [r7, #159]
 2054              	.LVL232:
 555:../uvc.c      **** 				 case SaturCtlID6://TODO check sensor register
 2055              		.loc 1 555 0
 2056 101c AEFFFFEA 		b	.L128
 2057              	.LVL233:
 2058              	.L194:
 652:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2059              		.loc 1 652 0
 2060 1020 10799FE5 		ldr	r7, .L195+8
 2061 1024 9312D6E5 		ldrb	r1, [r6, #659]	@ zero_extendqisi2
 654:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2062              		.loc 1 654 0
 2063 1028 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 653:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2064              		.loc 1 653 0
 2065 102c 0030A0E3 		mov	r3, #0
 652:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2066              		.loc 1 652 0
 2067 1030 9C10C7E5 		strb	r1, [r7, #156]
 654:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2068              		.loc 1 654 0
 2069 1034 9E20C7E5 		strb	r2, [r7, #158]
 653:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2070              		.loc 1 653 0
 2071 1038 9D30C7E5 		strb	r3, [r7, #157]
 655:../uvc.c      **** 			 }else{
 2072              		.loc 1 655 0
 2073 103c 9F30C7E5 		strb	r3, [r7, #159]
 2074 1040 B4FEFFEA 		b	.L149
 2075              	.L117:
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2076              		.loc 1 559 0
 2077 1044 EC789FE5 		ldr	r7, .L195+8
 2078 1048 048087E0 		add	r8, r7, r4
 2079              	.LVL234:
 2080 104c 2C30D8E5 		ldrb	r3, [r8, #44]	@ zero_extendqisi2
 2081 1050 000053E3 		cmp	r3, #0
 2082 1054 F501000A 		beq	.L136
 2083 1058 844084E0 		add	r4, r4, r4, asl #1
 2084 105c 846186E0 		add	r6, r6, r4, asl #3
 2085 1060 8D31D6E5 		ldrb	r3, [r6, #397]	@ zero_extendqisi2
 2086              	.LVL235:
 2087              	.L137:
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2088              		.loc 1 570 0
 2089 1064 0020A0E3 		mov	r2, #0
 2090 1068 0360A0E1 		mov	r6, r3
 572:../uvc.c      **** 			 }
 2091              		.loc 1 572 0
 2092 106c FF80A0E3 		mov	r8, #255
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2093              		.loc 1 569 0
 2094 1070 9C30C7E5 		strb	r3, [r7, #156]
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2095              		.loc 1 570 0
 2096 1074 9D20C7E5 		strb	r2, [r7, #157]
 2097              	.LVL236:
 572:../uvc.c      **** 			 }
 2098              		.loc 1 572 0
 2099 1078 97FFFFEA 		b	.L128
 2100              	.LVL237:
 2101              	.L167:
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2102              		.loc 1 819 0
 2103 107c D0489FE5 		ldr	r4, .L195+36
 2104 1080 0010E0E3 		mvn	r1, #0
 2105 1084 1C0094E5 		ldr	r0, [r4, #28]
 2106 1088 FEFFFFEB 		bl	_txe_mutex_get
 2107              	.LVL238:
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2108              		.loc 1 820 0
 2109 108c 14209DE5 		ldr	r2, [sp, #20]
 2110 1090 0010A0E3 		mov	r1, #0
 2111 1094 0A30A0E1 		mov	r3, r10
 2112 1098 00208DE5 		str	r2, [sp]
 2113 109c 0400A0E1 		mov	r0, r4
 2114 10a0 0B20A0E1 		mov	r2, fp
 2115 10a4 04108DE5 		str	r1, [sp, #4]
 2116 10a8 2610A0E3 		mov	r1, #38
 2117 10ac FEFFFFEB 		bl	cmdSet
 2118              	.LVL239:
 821:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2119              		.loc 1 821 0
 2120 10b0 1C0094E5 		ldr	r0, [r4, #28]
 2121 10b4 FEFFFFEB 		bl	_txe_mutex_put
 2122              	.LVL240:
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2123              		.loc 1 822 0
 2124 10b8 14309DE5 		ldr	r3, [sp, #20]
 2125 10bc 888088E0 		add	r8, r8, r8, asl #1
 2126              	.LVL241:
 2127 10c0 886186E0 		add	r6, r6, r8, asl #3
 823:../uvc.c      **** 							 break;
 2128              		.loc 1 823 0
 2129 10c4 0120A0E3 		mov	r2, #1
 824:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2130              		.loc 1 824 0
 2131 10c8 FF80A0E3 		mov	r8, #255
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2132              		.loc 1 822 0
 2133 10cc 0D30C6E5 		strb	r3, [r6, #13]
 2134 10d0 0340A0E1 		mov	r4, r3
 823:../uvc.c      **** 							 break;
 2135              		.loc 1 823 0
 2136 10d4 1020C6E5 		strb	r2, [r6, #16]
 2137 10d8 18309DE5 		ldr	r3, [sp, #24]
 824:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2138              		.loc 1 824 0
 2139 10dc 0860A0E1 		mov	r6, r8
 2140 10e0 93FEFFEA 		b	.L116
 2141              	.LVL242:
 2142              	.L159:
 678:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2143              		.loc 1 678 0
 2144 10e4 44389FE5 		ldr	r3, .L195
 679:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2145              		.loc 1 679 0
 2146 10e8 000050E3 		cmp	r0, #0
 678:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2147              		.loc 1 678 0
 2148 10ec 0D03C6E5 		strb	r0, [r6, #781]
 680:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2149              		.loc 1 680 0
 2150 10f0 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 679:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2151              		.loc 1 679 0
 2152 10f4 EF01001A 		bne	.L169
 680:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2153              		.loc 1 680 0
 2154 10f8 020052E3 		cmp	r2, #2
 2155 10fc 08005213 		cmpne	r2, #8
 2156 1100 0300000A 		beq	.L170
 681:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2157              		.loc 1 681 0
 2158 1104 010052E3 		cmp	r2, #1
 682:../uvc.c      **** 									 }else{
 2159              		.loc 1 682 0
 2160 1108 0820A003 		moveq	r2, #8
 684:../uvc.c      **** 									 }
 2161              		.loc 1 684 0
 2162 110c 0220A013 		movne	r2, #2
 2163 1110 B524C3E5 		strb	r2, [r3, #1205]
 2164              	.LVL243:
 2165              	.L170:
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2166              		.loc 1 706 0
 2167 1114 38489FE5 		ldr	r4, .L195+36
 704:../uvc.c      **** 							 dataIdx = 0;
 2168              		.loc 1 704 0
 2169 1118 0130A0E3 		mov	r3, #1
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2170              		.loc 1 706 0
 2171 111c 1C0094E5 		ldr	r0, [r4, #28]
 2172 1120 0010E0E3 		mvn	r1, #0
 704:../uvc.c      **** 							 dataIdx = 0;
 2173              		.loc 1 704 0
 2174 1124 1033C6E5 		strb	r3, [r6, #784]
 2175              	.LVL244:
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2176              		.loc 1 706 0
 2177 1128 FEFFFFEB 		bl	_txe_mutex_get
 2178              	.LVL245:
 707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2179              		.loc 1 707 0
 2180 112c 14209DE5 		ldr	r2, [sp, #20]
 2181 1130 0010A0E3 		mov	r1, #0
 2182 1134 0A30A0E1 		mov	r3, r10
 2183 1138 00208DE5 		str	r2, [sp]
 2184 113c 0400A0E1 		mov	r0, r4
 2185 1140 0B20A0E1 		mov	r2, fp
 2186 1144 04108DE5 		str	r1, [sp, #4]
 2187 1148 1010A0E3 		mov	r1, #16
 2188 114c FEFFFFEB 		bl	cmdSet
 2189              	.LVL246:
 710:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 2190              		.loc 1 710 0
 2191 1150 FF80A0E3 		mov	r8, #255
 2192              	.LVL247:
 708:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 2193              		.loc 1 708 0
 2194 1154 1C0094E5 		ldr	r0, [r4, #28]
 2195 1158 FEFFFFEB 		bl	_txe_mutex_put
 2196              	.LVL248:
 710:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 2197              		.loc 1 710 0
 2198 115c 0860A0E1 		mov	r6, r8
 2199 1160 14409DE5 		ldr	r4, [sp, #20]
 2200 1164 18309DE5 		ldr	r3, [sp, #24]
 2201 1168 71FEFFEA 		b	.L116
 2202              	.LVL249:
 2203              	.L158:
 887:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2204              		.loc 1 887 0
 2205 116c E0479FE5 		ldr	r4, .L195+36
 2206 1170 0010E0E3 		mvn	r1, #0
 2207 1174 1C0094E5 		ldr	r0, [r4, #28]
 2208 1178 10C08DE5 		str	ip, [sp, #16]
 2209 117c FEFFFFEB 		bl	_txe_mutex_get
 2210              	.LVL250:
 888:../uvc.c      **** 							 dataIdx++;
 2211              		.loc 1 888 0
 2212 1180 10C09DE5 		ldr	ip, [sp, #16]
 2213 1184 14009DE5 		ldr	r0, [sp, #20]
 2214 1188 0030A0E3 		mov	r3, #0
 2215 118c 0C20A0E1 		mov	r2, ip
 2216 1190 00008DE5 		str	r0, [sp]
 2217 1194 04308DE5 		str	r3, [sp, #4]
 2218 1198 0400A0E1 		mov	r0, r4
 2219 119c 0B10A0E3 		mov	r1, #11
 2220 11a0 0A30A0E1 		mov	r3, r10
 2221 11a4 FEFFFFEB 		bl	cmdSet
 2222              	.LVL251:
 890:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2223              		.loc 1 890 0
 2224 11a8 18209DE5 		ldr	r2, [sp, #24]
 2225 11ac 0170A0E3 		mov	r7, #1
 2226 11b0 0A30A0E1 		mov	r3, r10
 2227 11b4 00208DE5 		str	r2, [sp]
 2228 11b8 0400A0E1 		mov	r0, r4
 2229 11bc 0B20A0E1 		mov	r2, fp
 2230 11c0 0B10A0E3 		mov	r1, #11
 2231 11c4 04708DE5 		str	r7, [sp, #4]
 2232 11c8 FEFFFFEB 		bl	cmdSet
 2233              	.LVL252:
 891:../uvc.c      **** 
 2234              		.loc 1 891 0
 2235 11cc 1C0094E5 		ldr	r0, [r4, #28]
 2236 11d0 FEFFFFEB 		bl	_txe_mutex_put
 2237              	.LVL253:
 894:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2238              		.loc 1 894 0
 2239 11d4 18009DE5 		ldr	r0, [sp, #24]
 2240 11d8 14409DE5 		ldr	r4, [sp, #20]
 896:../uvc.c      **** 						 case MFreqCtlID4:
 2241              		.loc 1 896 0
 2242 11dc FF80A0E3 		mov	r8, #255
 2243              	.LVL254:
 895:../uvc.c      **** 							 break;
 2244              		.loc 1 895 0
 2245 11e0 9872C6E5 		strb	r7, [r6, #664]
 893:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2246              		.loc 1 893 0
 2247 11e4 8C44C6E5 		strb	r4, [r6, #1164]
 894:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2248              		.loc 1 894 0
 2249 11e8 8E04C6E5 		strb	r0, [r6, #1166]
 2250 11ec 0030A0E1 		mov	r3, r0
 896:../uvc.c      **** 						 case MFreqCtlID4:
 2251              		.loc 1 896 0
 2252 11f0 0860A0E1 		mov	r6, r8
 2253 11f4 4EFEFFEA 		b	.L116
 2254              	.LVL255:
 2255              	.L157:
 873:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2256              		.loc 1 873 0
 2257 11f8 54479FE5 		ldr	r4, .L195+36
 2258 11fc 0010E0E3 		mvn	r1, #0
 2259 1200 1C0094E5 		ldr	r0, [r4, #28]
 2260 1204 10C08DE5 		str	ip, [sp, #16]
 2261 1208 FEFFFFEB 		bl	_txe_mutex_get
 2262              	.LVL256:
 874:../uvc.c      **** 							 dataIdx++;
 2263              		.loc 1 874 0
 2264 120c 14009DE5 		ldr	r0, [sp, #20]
 2265 1210 0030A0E3 		mov	r3, #0
 2266 1214 00008DE5 		str	r0, [sp]
 2267 1218 0B20A0E1 		mov	r2, fp
 2268 121c 0400A0E1 		mov	r0, r4
 2269 1220 04308DE5 		str	r3, [sp, #4]
 2270 1224 0610A0E3 		mov	r1, #6
 2271 1228 0A30A0E1 		mov	r3, r10
 2272 122c FEFFFFEB 		bl	cmdSet
 2273              	.LVL257:
 876:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2274              		.loc 1 876 0
 2275 1230 14209DE5 		ldr	r2, [sp, #20]
 2276 1234 10C09DE5 		ldr	ip, [sp, #16]
 2277 1238 0170A0E3 		mov	r7, #1
 2278 123c 0A30A0E1 		mov	r3, r10
 2279 1240 00208DE5 		str	r2, [sp]
 2280 1244 0400A0E1 		mov	r0, r4
 2281 1248 0C20A0E1 		mov	r2, ip
 2282 124c 0610A0E3 		mov	r1, #6
 2283 1250 04708DE5 		str	r7, [sp, #4]
 2284 1254 FEFFFFEB 		bl	cmdSet
 2285              	.LVL258:
 877:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2286              		.loc 1 877 0
 2287 1258 1C0094E5 		ldr	r0, [r4, #28]
 2288 125c FEFFFFEB 		bl	_txe_mutex_put
 2289              	.LVL259:
 2290 1260 14409DE5 		ldr	r4, [sp, #20]
 880:../uvc.c      **** 
 2291              		.loc 1 880 0
 2292 1264 FF80A0E3 		mov	r8, #255
 2293              	.LVL260:
 879:../uvc.c      **** 							 break;
 2294              		.loc 1 879 0
 2295 1268 2072C6E5 		strb	r7, [r6, #544]
 878:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2296              		.loc 1 878 0
 2297 126c 1D42C6E5 		strb	r4, [r6, #541]
 2298 1270 18309DE5 		ldr	r3, [sp, #24]
 880:../uvc.c      **** 
 2299              		.loc 1 880 0
 2300 1274 0860A0E1 		mov	r6, r8
 2301 1278 2DFEFFEA 		b	.L116
 2302              	.LVL261:
 2303              	.L156:
 853:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2304              		.loc 1 853 0
 2305 127c D0469FE5 		ldr	r4, .L195+36
 2306 1280 0010E0E3 		mvn	r1, #0
 2307 1284 1C0094E5 		ldr	r0, [r4, #28]
 2308 1288 10C08DE5 		str	ip, [sp, #16]
 2309 128c FEFFFFEB 		bl	_txe_mutex_get
 2310              	.LVL262:
 854:../uvc.c      **** 							 dataIdx++;
 2311              		.loc 1 854 0
 2312 1290 14009DE5 		ldr	r0, [sp, #20]
 2313 1294 0030A0E3 		mov	r3, #0
 2314 1298 801040E2 		sub	r1, r0, #128
 2315 129c FF1001E2 		and	r1, r1, #255
 2316 12a0 0B20A0E1 		mov	r2, fp
 2317 12a4 00108DE5 		str	r1, [sp]
 2318 12a8 0400A0E1 		mov	r0, r4
 2319 12ac 04308DE5 		str	r3, [sp, #4]
 2320 12b0 0510A0E3 		mov	r1, #5
 2321 12b4 0A30A0E1 		mov	r3, r10
 2322 12b8 FEFFFFEB 		bl	cmdSet
 2323              	.LVL263:
 856:../uvc.c      **** 							 dataIdx++;
 2324              		.loc 1 856 0
 2325 12bc 14209DE5 		ldr	r2, [sp, #20]
 2326 12c0 0190A0E3 		mov	r9, #1
 2327 12c4 763042E2 		sub	r3, r2, #118
 2328 12c8 FF3003E2 		and	r3, r3, #255
 2329 12cc 00308DE5 		str	r3, [sp]
 2330 12d0 0400A0E1 		mov	r0, r4
 2331 12d4 0510A0E3 		mov	r1, #5
 2332 12d8 DC20A0E3 		mov	r2, #220
 2333 12dc 0A30A0E1 		mov	r3, r10
 2334 12e0 04908DE5 		str	r9, [sp, #4]
 2335 12e4 FEFFFFEB 		bl	cmdSet
 2336              	.LVL264:
 858:../uvc.c      **** 							 dataIdx++;
 2337              		.loc 1 858 0
 2338 12e8 14309DE5 		ldr	r3, [sp, #20]
 2339 12ec 0400A0E1 		mov	r0, r4
 2340 12f0 7E2083E2 		add	r2, r3, #126
 2341 12f4 FF2002E2 		and	r2, r2, #255
 2342 12f8 0230A0E3 		mov	r3, #2
 2343 12fc 00208DE5 		str	r2, [sp]
 2344 1300 04308DE5 		str	r3, [sp, #4]
 2345 1304 0510A0E3 		mov	r1, #5
 2346 1308 DE20A0E3 		mov	r2, #222
 2347 130c 0A30A0E1 		mov	r3, r10
 2348 1310 FEFFFFEB 		bl	cmdSet
 2349              	.LVL265:
 860:../uvc.c      **** 							 dataIdx++;
 2350              		.loc 1 860 0
 2351 1314 14009DE5 		ldr	r0, [sp, #20]
 2352 1318 0330A0E3 		mov	r3, #3
 2353 131c 722080E2 		add	r2, r0, #114
 2354 1320 FF2002E2 		and	r2, r2, #255
 2355 1324 00208DE5 		str	r2, [sp]
 2356 1328 0400A0E1 		mov	r0, r4
 2357 132c 04308DE5 		str	r3, [sp, #4]
 2358 1330 0510A0E3 		mov	r1, #5
 2359 1334 E020A0E3 		mov	r2, #224
 2360 1338 0A30A0E1 		mov	r3, r10
 2361 133c FEFFFFEB 		bl	cmdSet
 2362              	.LVL266:
 862:../uvc.c      **** 							 dataIdx++;
 2363              		.loc 1 862 0
 2364 1340 14309DE5 		ldr	r3, [sp, #20]
 2365 1344 0400A0E1 		mov	r0, r4
 2366 1348 6F2043E2 		sub	r2, r3, #111
 2367 134c FF2002E2 		and	r2, r2, #255
 2368 1350 0430A0E3 		mov	r3, #4
 2369 1354 00208DE5 		str	r2, [sp]
 2370 1358 04308DE5 		str	r3, [sp, #4]
 2371 135c 0510A0E3 		mov	r1, #5
 2372 1360 DD20A0E3 		mov	r2, #221
 2373 1364 0A30A0E1 		mov	r3, r10
 2374 1368 FEFFFFEB 		bl	cmdSet
 2375              	.LVL267:
 864:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2376              		.loc 1 864 0
 2377 136c 9C00D7E5 		ldrb	r0, [r7, #156]	@ zero_extendqisi2
 2378 1370 10C09DE5 		ldr	ip, [sp, #16]
 2379 1374 7F0080E2 		add	r0, r0, #127
 2380 1378 0510A0E3 		mov	r1, #5
 2381 137c FF0000E2 		and	r0, r0, #255
 2382 1380 0A30A0E1 		mov	r3, r10
 2383 1384 0C20A0E1 		mov	r2, ip
 2384 1388 00008DE5 		str	r0, [sp]
 2385 138c 04108DE5 		str	r1, [sp, #4]
 2386 1390 0400A0E1 		mov	r0, r4
 2387 1394 FEFFFFEB 		bl	cmdSet
 2388              	.LVL268:
 865:../uvc.c      **** 
 2389              		.loc 1 865 0
 2390 1398 1C0094E5 		ldr	r0, [r4, #28]
 2391 139c FEFFFFEB 		bl	_txe_mutex_put
 2392              	.LVL269:
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2393              		.loc 1 867 0
 2394 13a0 9C30D7E5 		ldrb	r3, [r7, #156]	@ zero_extendqisi2
 869:../uvc.c      **** 						 case SaturCtlID6:
 2395              		.loc 1 869 0
 2396 13a4 FF80A0E3 		mov	r8, #255
 2397              	.LVL270:
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2398              		.loc 1 867 0
 2399 13a8 803043E2 		sub	r3, r3, #128
 2400 13ac 0532C6E5 		strb	r3, [r6, #517]
 868:../uvc.c      **** 							 break;
 2401              		.loc 1 868 0
 2402 13b0 0892C6E5 		strb	r9, [r6, #520]
 2403 13b4 14409DE5 		ldr	r4, [sp, #20]
 2404 13b8 18309DE5 		ldr	r3, [sp, #24]
 869:../uvc.c      **** 						 case SaturCtlID6:
 2405              		.loc 1 869 0
 2406 13bc 0860A0E1 		mov	r6, r8
 2407 13c0 DBFDFFEA 		b	.L116
 2408              	.LVL271:
 2409              	.L155:
 905:../uvc.c      **** 							 //remove for Invendo
 2410              		.loc 1 905 0
 2411 13c4 88459FE5 		ldr	r4, .L195+36
 899:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 2412              		.loc 1 899 0
 2413 13c8 017040E2 		sub	r7, r0, #1
 905:../uvc.c      **** 							 //remove for Invendo
 2414              		.loc 1 905 0
 2415 13cc 0010E0E3 		mvn	r1, #0
 2416 13d0 1C0094E5 		ldr	r0, [r4, #28]
 2417 13d4 FEFFFFEB 		bl	_txe_mutex_get
 2418              	.LVL272:
 899:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 2419              		.loc 1 899 0
 2420 13d8 FF7007E2 		and	r7, r7, #255
 2421              	.LVL273:
 908:../uvc.c      **** 
 2422              		.loc 1 908 0
 2423 13dc 1C0094E5 		ldr	r0, [r4, #28]
 2424 13e0 FEFFFFEB 		bl	_txe_mutex_put
 2425              	.LVL274:
 903:../uvc.c      **** 
 2426              		.loc 1 903 0
 2427 13e4 020057E3 		cmp	r7, #2
 2428 13e8 0170A083 		movhi	r7, #1
 2429              	.LVL275:
 911:../uvc.c      **** 							 break;
 2430              		.loc 1 911 0
 2431 13ec 0120A0E3 		mov	r2, #1
 912:../uvc.c      **** 					 	 case BLCCtlID0:
 2432              		.loc 1 912 0
 2433 13f0 FF80A0E3 		mov	r8, #255
 2434              	.LVL276:
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2435              		.loc 1 910 0
 2436 13f4 ED71C6E5 		strb	r7, [r6, #493]
 911:../uvc.c      **** 							 break;
 2437              		.loc 1 911 0
 2438 13f8 F021C6E5 		strb	r2, [r6, #496]
 2439 13fc 14409DE5 		ldr	r4, [sp, #20]
 2440 1400 18309DE5 		ldr	r3, [sp, #24]
 912:../uvc.c      **** 					 	 case BLCCtlID0:
 2441              		.loc 1 912 0
 2442 1404 0860A0E1 		mov	r6, r8
 2443 1408 C9FDFFEA 		b	.L116
 2444              	.LVL277:
 2445              	.L153:
 914:../uvc.c      **** 							 if(Data0 == 3)
 2446              		.loc 1 914 0
 2447 140c 1C359FE5 		ldr	r3, .L195
 915:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2448              		.loc 1 915 0
 2449 1410 030050E3 		cmp	r0, #3
 916:../uvc.c      **** 							 else
 2450              		.loc 1 916 0
 2451 1414 0120A003 		moveq	r2, #1
 914:../uvc.c      **** 							 if(Data0 == 3)
 2452              		.loc 1 914 0
 2453 1418 8D01C6E5 		strb	r0, [r6, #397]
 916:../uvc.c      **** 							 else
 2454              		.loc 1 916 0
 2455 141c BC208705 		streq	r2, [r7, #188]
 919:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2456              		.loc 1 919 0
 2457 1420 9021C305 		streqb	r2, [r3, #400]
 915:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2458              		.loc 1 915 0
 2459 1424 0800000A 		beq	.L180
 922:../uvc.c      **** 					 				 ;//Data0 += 4;
 2460              		.loc 1 922 0
 2461 1428 14009DE5 		ldr	r0, [sp, #20]
 918:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2462              		.loc 1 918 0
 2463 142c 0010A0E3 		mov	r1, #0
 922:../uvc.c      **** 					 				 ;//Data0 += 4;
 2464              		.loc 1 922 0
 2465 1430 010050E3 		cmp	r0, #1
 919:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2466              		.loc 1 919 0
 2467 1434 0120A0E3 		mov	r2, #1
 2468 1438 0040A091 		movls	r4, r0
 918:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2469              		.loc 1 918 0
 2470 143c BC1087E5 		str	r1, [r7, #188]
 919:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2471              		.loc 1 919 0
 2472 1440 9021C3E5 		strb	r2, [r3, #400]
 922:../uvc.c      **** 					 				 ;//Data0 += 4;
 2473              		.loc 1 922 0
 2474 1444 0460A091 		movls	r6, r4
 2475 1448 0800009A 		bls	.L181
 2476              	.L180:
 925:../uvc.c      **** 									Data0 = 0; //set to default.
 2477              		.loc 1 925 0
 2478 144c 14409DE5 		ldr	r4, [sp, #20]
 2479 1450 0120A0E3 		mov	r2, #1
 2480 1454 0430A0E1 		mov	r3, r4
 2481 1458 0400A0E3 		mov	r0, #4
 2482 145c F4149FE5 		ldr	r1, .L195+40
 2483 1460 FEFFFFEB 		bl	CyU3PDebugPrint
 2484              	.LVL278:
 2485 1464 0020A0E3 		mov	r2, #0
 926:../uvc.c      **** 					 			 }
 2486              		.loc 1 926 0
 2487 1468 0260A0E1 		mov	r6, r2
 925:../uvc.c      **** 									Data0 = 0; //set to default.
 2488              		.loc 1 925 0
 2489 146c 14208DE5 		str	r2, [sp, #20]
 2490              	.LVL279:
 2491              	.L181:
 931:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2492              		.loc 1 931 0
 2493 1470 DC849FE5 		ldr	r8, .L195+36
 2494              	.LVL280:
 2495 1474 0010E0E3 		mvn	r1, #0
 2496 1478 1C0098E5 		ldr	r0, [r8, #28]
 2497 147c FEFFFFEB 		bl	_txe_mutex_get
 2498              	.LVL281:
 932:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2499              		.loc 1 932 0
 2500 1480 14309DE5 		ldr	r3, [sp, #20]
 2501 1484 0010A0E3 		mov	r1, #0
 2502 1488 0B20A0E1 		mov	r2, fp
 2503 148c 04108DE5 		str	r1, [sp, #4]
 2504 1490 00308DE5 		str	r3, [sp]
 2505 1494 0800A0E1 		mov	r0, r8
 2506 1498 0A30A0E1 		mov	r3, r10
 2507 149c FEFFFFEB 		bl	cmdSet
 2508              	.LVL282:
 933:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2509              		.loc 1 933 0
 2510 14a0 1C0098E5 		ldr	r0, [r8, #28]
 2511 14a4 FEFFFFEB 		bl	_txe_mutex_put
 2512              	.LVL283:
 934:../uvc.c      **** 
 2513              		.loc 1 934 0
 2514 14a8 9E00D7E5 		ldrb	r0, [r7, #158]	@ zero_extendqisi2
 2515 14ac 9F10D7E5 		ldrb	r1, [r7, #159]	@ zero_extendqisi2
 2516 14b0 BC3097E5 		ldr	r3, [r7, #188]
 2517 14b4 0620A0E1 		mov	r2, r6
 2518 14b8 03008DE8 		stmia	sp, {r0, r1}
 2519 14bc 98149FE5 		ldr	r1, .L195+44
 2520 14c0 0400A0E3 		mov	r0, #4
 936:../uvc.c      **** 						 default:
 2521              		.loc 1 936 0
 2522 14c4 FF80A0E3 		mov	r8, #255
 934:../uvc.c      **** 
 2523              		.loc 1 934 0
 2524 14c8 FEFFFFEB 		bl	CyU3PDebugPrint
 2525              	.LVL284:
 936:../uvc.c      **** 						 default:
 2526              		.loc 1 936 0
 2527 14cc 0860A0E1 		mov	r6, r8
 2528 14d0 18309DE5 		ldr	r3, [sp, #24]
 2529 14d4 96FDFFEA 		b	.L116
 2530              	.LVL285:
 2531              	.L163:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2532              		.loc 1 762 0
 2533 14d8 74449FE5 		ldr	r4, .L195+36
 2534 14dc 0010E0E3 		mvn	r1, #0
 2535 14e0 1C0094E5 		ldr	r0, [r4, #28]
 2536 14e4 FEFFFFEB 		bl	_txe_mutex_get
 2537              	.LVL286:
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2538              		.loc 1 763 0
 2539 14e8 14209DE5 		ldr	r2, [sp, #20]
 2540 14ec 0010A0E3 		mov	r1, #0
 2541 14f0 01C072E2 		rsbs	ip, r2, #1
 2542 14f4 00C0A033 		movcc	ip, #0
 2543 14f8 0B20A0E1 		mov	r2, fp
 2544 14fc 0A30A0E1 		mov	r3, r10
 2545 1500 0400A0E1 		mov	r0, r4
 2546 1504 00C08DE5 		str	ip, [sp]
 2547 1508 04108DE5 		str	r1, [sp, #4]
 2548 150c 1E10A0E3 		mov	r1, #30
 2549 1510 FEFFFFEB 		bl	cmdSet
 2550              	.LVL287:
 764:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2551              		.loc 1 764 0
 2552 1514 1C0094E5 		ldr	r0, [r4, #28]
 2553 1518 FEFFFFEB 		bl	_txe_mutex_put
 2554              	.LVL288:
 766:../uvc.c      **** 						 case ExtI2CCtlID15:
 2555              		.loc 1 766 0
 2556 151c FF80A0E3 		mov	r8, #255
 2557              	.LVL289:
 765:../uvc.c      **** 							 break;
 2558              		.loc 1 765 0
 2559 1520 0120A0E3 		mov	r2, #1
 2560 1524 6024C6E5 		strb	r2, [r6, #1120]
 2561 1528 14409DE5 		ldr	r4, [sp, #20]
 2562 152c 18309DE5 		ldr	r3, [sp, #24]
 766:../uvc.c      **** 						 case ExtI2CCtlID15:
 2563              		.loc 1 766 0
 2564 1530 0860A0E1 		mov	r6, r8
 2565 1534 7EFDFFEA 		b	.L116
 2566              	.LVL290:
 2567              	.L162:
 675:../uvc.c      **** 					 {
 2568              		.loc 1 675 0
 2569 1538 FF80A0E3 		mov	r8, #255
 2570              	.LVL291:
 2571 153c 0040A0E1 		mov	r4, r0
 2572              	.LVL292:
 2573 1540 0860A0E1 		mov	r6, r8
 2574 1544 7AFDFFEA 		b	.L116
 2575              	.LVL293:
 2576              	.L161:
 729:../uvc.c      **** 							 if(WDRflag)
 2577              		.loc 1 729 0
 2578 1548 04449FE5 		ldr	r4, .L195+36
 2579 154c 0020A0E1 		mov	r2, r0
 2580 1550 0010E0E3 		mvn	r1, #0
 728:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2581              		.loc 1 728 0
 2582 1554 0130A0E3 		mov	r3, #1
 729:../uvc.c      **** 							 if(WDRflag)
 2583              		.loc 1 729 0
 2584 1558 1C0094E5 		ldr	r0, [r4, #28]
 727:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2585              		.loc 1 727 0
 2586 155c FD23C6E5 		strb	r2, [r6, #1021]
 728:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2587              		.loc 1 728 0
 2588 1560 0034C6E5 		strb	r3, [r6, #1024]
 729:../uvc.c      **** 							 if(WDRflag)
 2589              		.loc 1 729 0
 2590 1564 10C08DE5 		str	ip, [sp, #16]
 2591 1568 FEFFFFEB 		bl	_txe_mutex_get
 2592              	.LVL294:
 730:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2593              		.loc 1 730 0
 2594 156c BC3097E5 		ldr	r3, [r7, #188]
 2595 1570 10C09DE5 		ldr	ip, [sp, #16]
 2596 1574 000053E3 		cmp	r3, #0
 731:../uvc.c      **** 							 else
 2597              		.loc 1 731 0
 2598 1578 14309D15 		ldrne	r3, [sp, #20]
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2599              		.loc 1 733 0
 2600 157c 14009D05 		ldreq	r0, [sp, #20]
 731:../uvc.c      **** 							 else
 2601              		.loc 1 731 0
 2602 1580 0010A013 		movne	r1, #0
 2603 1584 00308D15 		strne	r3, [sp]
 2604 1588 0C20A011 		movne	r2, ip
 2605 158c 0A30A011 		movne	r3, r10
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2606              		.loc 1 733 0
 2607 1590 0B20A001 		moveq	r2, fp
 735:../uvc.c      **** 						 case ExtCamMCtlID12:
 2608              		.loc 1 735 0
 2609 1594 FF80A0E3 		mov	r8, #255
 2610              	.LVL295:
 2611 1598 0860A0E1 		mov	r6, r8
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2612              		.loc 1 733 0
 2613 159c 09008D08 		stmeqia	sp, {r0, r3}
 731:../uvc.c      **** 							 else
 2614              		.loc 1 731 0
 2615 15a0 04108D15 		strne	r1, [sp, #4]
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2616              		.loc 1 733 0
 2617 15a4 0A30A001 		moveq	r3, r10
 2618 15a8 1A10A0E3 		mov	r1, #26
 2619 15ac 0400A0E1 		mov	r0, r4
 2620 15b0 FEFFFFEB 		bl	cmdSet
 2621              	.LVL296:
 734:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2622              		.loc 1 734 0
 2623 15b4 1C0094E5 		ldr	r0, [r4, #28]
 2624 15b8 FEFFFFEB 		bl	_txe_mutex_put
 2625              	.LVL297:
 735:../uvc.c      **** 						 case ExtCamMCtlID12:
 2626              		.loc 1 735 0
 2627 15bc 9E00D7E5 		ldrb	r0, [r7, #158]	@ zero_extendqisi2
 2628 15c0 9F10D7E5 		ldrb	r1, [r7, #159]	@ zero_extendqisi2
 2629 15c4 14409DE5 		ldr	r4, [sp, #20]
 2630 15c8 BC3097E5 		ldr	r3, [r7, #188]
 2631 15cc 0420A0E1 		mov	r2, r4
 2632 15d0 03008DE8 		stmia	sp, {r0, r1}
 2633 15d4 84139FE5 		ldr	r1, .L195+48
 2634 15d8 0400A0E3 		mov	r0, #4
 2635 15dc FEFFFFEB 		bl	CyU3PDebugPrint
 2636              	.LVL298:
 2637 15e0 18309DE5 		ldr	r3, [sp, #24]
 2638 15e4 52FDFFEA 		b	.L116
 2639              	.LVL299:
 2640              	.L160:
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2641              		.loc 1 716 0
 2642 15e8 64439FE5 		ldr	r4, .L195+36
 2643 15ec 0020A0E1 		mov	r2, r0
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2644              		.loc 1 712 0
 2645 15f0 E523C6E5 		strb	r2, [r6, #997]
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2646              		.loc 1 713 0
 2647 15f4 18209DE5 		ldr	r2, [sp, #24]
 714:../uvc.c      **** 							 dataIdx = 0;
 2648              		.loc 1 714 0
 2649 15f8 0130A0E3 		mov	r3, #1
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2650              		.loc 1 716 0
 2651 15fc 1C0094E5 		ldr	r0, [r4, #28]
 2652 1600 0010E0E3 		mvn	r1, #0
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2653              		.loc 1 713 0
 2654 1604 E623C6E5 		strb	r2, [r6, #998]
 714:../uvc.c      **** 							 dataIdx = 0;
 2655              		.loc 1 714 0
 2656 1608 E833C6E5 		strb	r3, [r6, #1000]
 2657              	.LVL300:
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2658              		.loc 1 716 0
 2659 160c 10C08DE5 		str	ip, [sp, #16]
 2660 1610 FEFFFFEB 		bl	_txe_mutex_get
 2661              	.LVL301:
 720:../uvc.c      **** 							 }
 2662              		.loc 1 720 0
 2663 1614 10C09DE5 		ldr	ip, [sp, #16]
 2664 1618 18309DE5 		ldr	r3, [sp, #24]
 2665 161c 0010A0E3 		mov	r1, #0
 2666 1620 0C20A0E1 		mov	r2, ip
 2667 1624 00308DE5 		str	r3, [sp]
 2668 1628 0400A0E1 		mov	r0, r4
 2669 162c 0A30A0E1 		mov	r3, r10
 2670 1630 04108DE5 		str	r1, [sp, #4]
 2671 1634 1910A0E3 		mov	r1, #25
 2672 1638 FEFFFFEB 		bl	cmdSet
 2673              	.LVL302:
 722:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2674              		.loc 1 722 0
 2675 163c 1C0094E5 		ldr	r0, [r4, #28]
 2676 1640 FEFFFFEB 		bl	_txe_mutex_put
 2677              	.LVL303:
 723:../uvc.c      **** 							 break;
 2678              		.loc 1 723 0
 2679 1644 9E00D7E5 		ldrb	r0, [r7, #158]	@ zero_extendqisi2
 2680 1648 9F10D7E5 		ldrb	r1, [r7, #159]	@ zero_extendqisi2
 2681 164c 9D30D7E5 		ldrb	r3, [r7, #157]	@ zero_extendqisi2
 2682 1650 9C20D7E5 		ldrb	r2, [r7, #156]	@ zero_extendqisi2
 724:../uvc.c      **** 						 case ExtExRefCtlID10:
 2683              		.loc 1 724 0
 2684 1654 FF80A0E3 		mov	r8, #255
 2685              	.LVL304:
 723:../uvc.c      **** 							 break;
 2686              		.loc 1 723 0
 2687 1658 03008DE8 		stmia	sp, {r0, r1}
 2688 165c 00139FE5 		ldr	r1, .L195+52
 2689 1660 0400A0E3 		mov	r0, #4
 2690 1664 FEFFFFEB 		bl	CyU3PDebugPrint
 2691              	.LVL305:
 724:../uvc.c      **** 						 case ExtExRefCtlID10:
 2692              		.loc 1 724 0
 2693 1668 0860A0E1 		mov	r6, r8
 2694 166c 14409DE5 		ldr	r4, [sp, #20]
 2695 1670 18309DE5 		ldr	r3, [sp, #24]
 2696 1674 2EFDFFEA 		b	.L116
 2697              	.LVL306:
 2698              	.L165:
 797:../uvc.c      **** 						     /* end test */
 2699              		.loc 1 797 0
 2700 1678 D4429FE5 		ldr	r4, .L195+36
 2701 167c 0010E0E3 		mvn	r1, #0
 2702 1680 1C0094E5 		ldr	r0, [r4, #28]
 2703 1684 10C08DE5 		str	ip, [sp, #16]
 2704 1688 FEFFFFEB 		bl	_txe_mutex_get
 2705              	.LVL307:
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2706              		.loc 1 796 0
 2707 168c 14309DE5 		ldr	r3, [sp, #20]
 799:../uvc.c      **** 							 dataIdx++;
 2708              		.loc 1 799 0
 2709 1690 0B20A0E1 		mov	r2, fp
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2710              		.loc 1 796 0
 2711 1694 7F7003E2 		and	r7, r3, #127
 2712              	.LVL308:
 799:../uvc.c      **** 							 dataIdx++;
 2713              		.loc 1 799 0
 2714 1698 0030A0E3 		mov	r3, #0
 2715 169c 0400A0E1 		mov	r0, r4
 2716 16a0 04308DE5 		str	r3, [sp, #4]
 2717 16a4 2410A0E3 		mov	r1, #36
 2718 16a8 0A30A0E1 		mov	r3, r10
 2719 16ac 00708DE5 		str	r7, [sp]
 2720 16b0 FEFFFFEB 		bl	cmdSet
 2721              	.LVL309:
 801:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2722              		.loc 1 801 0
 2723 16b4 1C009DE5 		ldr	r0, [sp, #28]
 2724 16b8 10C09DE5 		ldr	ip, [sp, #16]
 2725 16bc 0190A0E3 		mov	r9, #1
 2726 16c0 0C20A0E1 		mov	r2, ip
 2727 16c4 0A30A0E1 		mov	r3, r10
 2728 16c8 00008DE5 		str	r0, [sp]
 2729 16cc 2410A0E3 		mov	r1, #36
 2730 16d0 0400A0E1 		mov	r0, r4
 2731 16d4 04908DE5 		str	r9, [sp, #4]
 2732 16d8 FEFFFFEB 		bl	cmdSet
 2733              	.LVL310:
 802:../uvc.c      **** 							 getData1 = Data1;
 2734              		.loc 1 802 0
 2735 16dc 1C0094E5 		ldr	r0, [r4, #28]
 2736 16e0 FEFFFFEB 		bl	_txe_mutex_put
 2737              	.LVL311:
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2738              		.loc 1 806 0
 2739 16e4 1C209DE5 		ldr	r2, [sp, #28]
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2740              		.loc 1 805 0
 2741 16e8 888088E0 		add	r8, r8, r8, asl #1
 2742              	.LVL312:
 2743 16ec 886186E0 		add	r6, r6, r8, asl #3
 808:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 2744              		.loc 1 808 0
 2745 16f0 FF80A0E3 		mov	r8, #255
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2746              		.loc 1 805 0
 2747 16f4 0D70C6E5 		strb	r7, [r6, #13]
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2748              		.loc 1 806 0
 2749 16f8 0E20C6E5 		strb	r2, [r6, #14]
 807:../uvc.c      **** 							 break;
 2750              		.loc 1 807 0
 2751 16fc 1090C6E5 		strb	r9, [r6, #16]
 2752 1700 14409DE5 		ldr	r4, [sp, #20]
 2753 1704 0230A0E1 		mov	r3, r2
 808:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 2754              		.loc 1 808 0
 2755 1708 0860A0E1 		mov	r6, r8
 2756 170c 08FDFFEA 		b	.L116
 2757              	.LVL313:
 2758              	.L164:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2759              		.loc 1 768 0 discriminator 1
 2760 1710 000059E3 		cmp	r9, #0
 2761 1714 0300000A 		beq	.L177
 2762 1718 48029FE5 		ldr	r0, .L195+56
 2763 171c 0920A0E1 		mov	r2, r9
 2764 1720 0C1080E2 		add	r1, r0, #12
 2765 1724 FEFFFFEB 		bl	memcpy
 2766              	.LVL314:
 2767              	.L177:
 772:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 2768              		.loc 1 772 0
 2769 1728 FF80A0E3 		mov	r8, #255
 2770              	.LVL315:
 771:../uvc.c      **** 							 break;
 2771              		.loc 1 771 0
 2772 172c FEFFFFEB 		bl	I2CCmdHandler
 2773              	.LVL316:
 772:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 2774              		.loc 1 772 0
 2775 1730 0860A0E1 		mov	r6, r8
 2776 1734 14409DE5 		ldr	r4, [sp, #20]
 2777              	.LVL317:
 2778 1738 18309DE5 		ldr	r3, [sp, #24]
 2779 173c FCFCFFEA 		b	.L116
 2780              	.LVL318:
 2781              	.L166:
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2782              		.loc 1 811 0
 2783 1740 0C429FE5 		ldr	r4, .L195+36
 2784 1744 0010E0E3 		mvn	r1, #0
 2785 1748 1C0094E5 		ldr	r0, [r4, #28]
 2786 174c FEFFFFEB 		bl	_txe_mutex_get
 2787              	.LVL319:
 812:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2788              		.loc 1 812 0
 2789 1750 14309DE5 		ldr	r3, [sp, #20]
 2790 1754 0010A0E3 		mov	r1, #0
 2791 1758 0B20A0E1 		mov	r2, fp
 2792 175c 00308DE5 		str	r3, [sp]
 2793 1760 0400A0E1 		mov	r0, r4
 2794 1764 0A30A0E1 		mov	r3, r10
 2795 1768 04108DE5 		str	r1, [sp, #4]
 2796 176c 2510A0E3 		mov	r1, #37
 2797 1770 FEFFFFEB 		bl	cmdSet
 2798              	.LVL320:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2799              		.loc 1 813 0
 2800 1774 1C0094E5 		ldr	r0, [r4, #28]
 2801 1778 FEFFFFEB 		bl	_txe_mutex_put
 2802              	.LVL321:
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2803              		.loc 1 814 0
 2804 177c 14009DE5 		ldr	r0, [sp, #20]
 2805 1780 888088E0 		add	r8, r8, r8, asl #1
 2806              	.LVL322:
 2807 1784 886186E0 		add	r6, r6, r8, asl #3
 815:../uvc.c      **** 							 break;
 2808              		.loc 1 815 0
 2809 1788 0120A0E3 		mov	r2, #1
 816:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 2810              		.loc 1 816 0
 2811 178c FF80A0E3 		mov	r8, #255
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2812              		.loc 1 814 0
 2813 1790 0D00C6E5 		strb	r0, [r6, #13]
 815:../uvc.c      **** 							 break;
 2814              		.loc 1 815 0
 2815 1794 1020C6E5 		strb	r2, [r6, #16]
 2816 1798 0040A0E1 		mov	r4, r0
 2817 179c 18309DE5 		ldr	r3, [sp, #24]
 816:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 2818              		.loc 1 816 0
 2819 17a0 0860A0E1 		mov	r6, r8
 2820 17a4 E2FCFFEA 		b	.L116
 2821              	.LVL323:
 2822              	.L152:
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2823              		.loc 1 940 0
 2824 17a8 A4719FE5 		ldr	r7, .L195+36
 2825 17ac 0010E0E3 		mvn	r1, #0
 2826 17b0 1C0097E5 		ldr	r0, [r7, #28]
 2827 17b4 FEFFFFEB 		bl	_txe_mutex_get
 2828              	.LVL324:
 941:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2829              		.loc 1 941 0
 2830 17b8 14009DE5 		ldr	r0, [sp, #20]
 2831 17bc 0010A0E3 		mov	r1, #0
 2832 17c0 0B20A0E1 		mov	r2, fp
 2833 17c4 0A30A0E1 		mov	r3, r10
 2834 17c8 00008DE5 		str	r0, [sp]
 2835 17cc 04108DE5 		str	r1, [sp, #4]
 2836 17d0 0700A0E1 		mov	r0, r7
 2837 17d4 0410A0E1 		mov	r1, r4
 2838 17d8 FEFFFFEB 		bl	cmdSet
 2839              	.LVL325:
 942:../uvc.c      **** 
 2840              		.loc 1 942 0
 2841 17dc 1C0097E5 		ldr	r0, [r7, #28]
 2842 17e0 FEFFFFEB 		bl	_txe_mutex_put
 2843              	.LVL326:
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2844              		.loc 1 944 0
 2845 17e4 14309DE5 		ldr	r3, [sp, #20]
 2846 17e8 844084E0 		add	r4, r4, r4, asl #1
 2847 17ec 846186E0 		add	r6, r6, r4, asl #3
 945:../uvc.c      **** 							 break;
 2848              		.loc 1 945 0
 2849 17f0 0120A0E3 		mov	r2, #1
 946:../uvc.c      **** 					 }
 2850              		.loc 1 946 0
 2851 17f4 FF80A0E3 		mov	r8, #255
 2852              	.LVL327:
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2853              		.loc 1 944 0
 2854 17f8 8D31C6E5 		strb	r3, [r6, #397]
 2855 17fc 0340A0E1 		mov	r4, r3
 945:../uvc.c      **** 							 break;
 2856              		.loc 1 945 0
 2857 1800 9021C6E5 		strb	r2, [r6, #400]
 2858 1804 18309DE5 		ldr	r3, [sp, #24]
 946:../uvc.c      **** 					 }
 2859              		.loc 1 946 0
 2860 1808 0860A0E1 		mov	r6, r8
 2861 180c C8FCFFEA 		b	.L116
 2862              	.LVL328:
 2863              	.L151:
 949:../uvc.c      **** 			   }
 2864              		.loc 1 949 0
 2865 1810 FF80A0E3 		mov	r8, #255
 2866              	.LVL329:
 2867 1814 0400A0E3 		mov	r0, #4
 2868              	.LVL330:
 2869 1818 4C119FE5 		ldr	r1, .L195+60
 2870 181c FEFFFFEB 		bl	CyU3PDebugPrint
 2871              	.LVL331:
 2872 1820 0860A0E1 		mov	r6, r8
 2873 1824 0830A0E1 		mov	r3, r8
 2874 1828 0840A0E1 		mov	r4, r8
 2875              	.LVL332:
 2876 182c C0FCFFEA 		b	.L116
 2877              	.LVL333:
 2878              	.L136:
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 2879              		.loc 1 563 0
 2880 1830 0B00A0E1 		mov	r0, fp
 2881              	.LVL334:
 2882 1834 0A10A0E1 		mov	r1, r10
 2883 1838 FEFFFFEB 		bl	SensorGetControl
 2884              	.LVL335:
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2885              		.loc 1 564 0
 2886 183c 844084E0 		add	r4, r4, r4, asl #1
 2887              	.LVL336:
 2888 1840 846186E0 		add	r6, r6, r4, asl #3
 566:../uvc.c      **** 		 	 		 }
 2889              		.loc 1 566 0
 2890 1844 0120A0E3 		mov	r2, #1
 2891 1848 2C20C8E5 		strb	r2, [r8, #44]
 2892 184c 0030A0E1 		mov	r3, r0
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2893              		.loc 1 564 0
 2894 1850 8D01C6E5 		strb	r0, [r6, #397]
 2895 1854 02FEFFEA 		b	.L137
 2896              	.LVL337:
 2897              	.L134:
 542:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 2898              		.loc 1 542 0
 2899 1858 0C00A0E1 		mov	r0, ip
 2900              	.LVL338:
 2901 185c 0A10A0E1 		mov	r1, r10
 2902 1860 FEFFFFEB 		bl	SensorGetControl
 2903              	.LVL339:
 543:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 2904              		.loc 1 543 0
 2905 1864 0A10A0E1 		mov	r1, r10
 542:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 2906              		.loc 1 542 0
 2907 1868 0040A0E1 		mov	r4, r0
 2908              	.LVL340:
 543:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 2909              		.loc 1 543 0
 2910 186c 0B00A0E1 		mov	r0, fp
 2911              	.LVL341:
 2912 1870 FEFFFFEB 		bl	SensorGetControl
 2913              	.LVL342:
 548:../uvc.c      **** 		 	 		 }
 2914              		.loc 1 548 0
 2915 1874 0130A0E3 		mov	r3, #1
 2916 1878 0420A0E1 		mov	r2, r4
 544:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2917              		.loc 1 544 0
 2918 187c 9C40C7E5 		strb	r4, [r7, #156]
 545:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 2919              		.loc 1 545 0
 2920 1880 8C44C6E5 		strb	r4, [r6, #1164]
 548:../uvc.c      **** 		 	 		 }
 2921              		.loc 1 548 0
 2922 1884 3730C7E5 		strb	r3, [r7, #55]
 2923 1888 0080A0E1 		mov	r8, r0
 2924              	.LVL343:
 546:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 2925              		.loc 1 546 0
 2926 188c 9E00C7E5 		strb	r0, [r7, #158]
 547:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 2927              		.loc 1 547 0
 2928 1890 8E04C6E5 		strb	r0, [r6, #1166]
 2929 1894 DCFDFFEA 		b	.L135
 2930              	.LVL344:
 2931              	.L132:
 490:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 2932              		.loc 1 490 0
 2933 1898 0C00A0E1 		mov	r0, ip
 2934              	.LVL345:
 2935 189c 0A10A0E1 		mov	r1, r10
 2936 18a0 FEFFFFEB 		bl	SensorGetControl
 2937              	.LVL346:
 492:../uvc.c      **** 		 	 		 }
 2938              		.loc 1 492 0
 2939 18a4 0130A0E3 		mov	r3, #1
 2940 18a8 4530C7E5 		strb	r3, [r7, #69]
 2941 18ac 00E0A0E1 		mov	lr, r0
 491:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 2942              		.loc 1 491 0
 2943 18b0 E603C6E5 		strb	r0, [r6, #998]
 2944 18b4 B2FDFFEA 		b	.L133
 2945              	.LVL347:
 2946              	.L169:
 688:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2947              		.loc 1 688 0
 2948 18b8 011040E2 		sub	r1, r0, #1
 689:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2949              		.loc 1 689 0
 2950 18bc 040052E3 		cmp	r2, #4
 2951 18c0 01005213 		cmpne	r2, #1
 688:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2952              		.loc 1 688 0
 2953 18c4 FF1001E2 		and	r1, r1, #255
 2954              	.LVL348:
 689:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2955              		.loc 1 689 0
 2956 18c8 0300000A 		beq	.L172
 690:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2957              		.loc 1 690 0
 2958 18cc 080052E3 		cmp	r2, #8
 691:../uvc.c      **** 									 }else{
 2959              		.loc 1 691 0
 2960 18d0 0120A003 		moveq	r2, #1
 693:../uvc.c      **** 									 }
 2961              		.loc 1 693 0
 2962 18d4 0420A013 		movne	r2, #4
 2963 18d8 B524C3E5 		strb	r2, [r3, #1205]
 2964              	.L172:
 696:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2965              		.loc 1 696 0
 2966 18dc 070051E3 		cmp	r1, #7
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2967              		.loc 1 697 0
 2968 18e0 88309F95 		ldrls	r3, .L195+64
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2969              		.loc 1 700 0
 2970 18e4 0120A083 		movhi	r2, #1
 698:../uvc.c      **** 								 }else{
 2971              		.loc 1 698 0
 2972 18e8 81208390 		addls	r2, r3, r1, asl #1
 2973 18ec 0120D295 		ldrlsb	r2, [r2, #1]	@ zero_extendqisi2
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2974              		.loc 1 697 0
 2975 18f0 8130D397 		ldrlsb	r3, [r3, r1, asl #1]	@ zero_extendqisi2
 701:../uvc.c      **** 								 }
 2976              		.loc 1 701 0
 2977 18f4 0030A083 		movhi	r3, #0
 698:../uvc.c      **** 								 }else{
 2978              		.loc 1 698 0
 2979 18f8 E624C695 		strlsb	r2, [r6, #1254]
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2980              		.loc 1 697 0
 2981 18fc E534C695 		strlsb	r3, [r6, #1253]
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2982              		.loc 1 700 0
 2983 1900 E524C685 		strhib	r2, [r6, #1253]
 701:../uvc.c      **** 								 }
 2984              		.loc 1 701 0
 2985 1904 E634C685 		strhib	r3, [r6, #1254]
 2986 1908 01FEFFEA 		b	.L170
 2987              	.LVL349:
 2988              	.L129:
 453:../uvc.c      **** 							sendData = 0; //set back to default
 2989              		.loc 1 453 0
 2990 190c 0400A0E3 		mov	r0, #4
 2991              	.LVL350:
 2992 1910 0120A0E3 		mov	r2, #1
 2993 1914 3C109FE5 		ldr	r1, .L195+40
 455:../uvc.c      **** 						}
 2994              		.loc 1 455 0
 2995 1918 0060A0E1 		mov	r6, r0
 453:../uvc.c      **** 							sendData = 0; //set back to default
 2996              		.loc 1 453 0
 2997 191c FEFFFFEB 		bl	CyU3PDebugPrint
 2998              	.LVL351:
 455:../uvc.c      **** 						}
 2999              		.loc 1 455 0
 3000 1920 0020A0E3 		mov	r2, #0
 3001 1924 0630A0E1 		mov	r3, r6
 3002 1928 2D24C4E5 		strb	r2, [r4, #1069]
 3003 192c 89FDFFEA 		b	.L130
 3004              	.L196:
 3005              		.align	2
 3006              	.L195:
 3007 1930 00000000 		.word	.LANCHOR1
 3008 1934 00000000 		.word	bRequest
 3009 1938 00000000 		.word	.LANCHOR0
 3010 193c 9C000000 		.word	.LANCHOR0+156
 3011 1940 54030000 		.word	.LC19
 3012 1944 01000100 		.word	65537
 3013 1948 FF00FF00 		.word	16711935
 3014 194c 60020000 		.word	.LC13
 3015 1950 9C020000 		.word	.LC14
 3016 1954 00000000 		.word	cmdQu
 3017 1958 28020000 		.word	.LC12
 3018 195c 0C030000 		.word	.LC17
 3019 1960 F0020000 		.word	.LC16
 3020 1964 C4020000 		.word	.LC15
 3021 1968 90000000 		.word	.LANCHOR0+144
 3022 196c 24030000 		.word	.LC18
 3023 1970 00000000 		.word	.LANCHOR2
 3024              		.cfi_endproc
 3025              	.LFE2:
 3027              		.align	2
 3028              		.global	CTControlHandle
 3030              	CTControlHandle:
 3031              	.LFB3:
 965:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3032              		.loc 1 965 0
 3033              		.cfi_startproc
 3034              		@ args = 0, pretend = 0, frame = 24
 3035              		@ frame_needed = 0, uses_anonymous_args = 0
 3036              	.LVL352:
 3037 1974 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3038              	.LCFI14:
 3039              		.cfi_def_cfa_offset 36
 3040              		.cfi_offset 4, -36
 3041              		.cfi_offset 5, -32
 3042              		.cfi_offset 6, -28
 3043              		.cfi_offset 7, -24
 3044              		.cfi_offset 8, -20
 3045              		.cfi_offset 9, -16
 3046              		.cfi_offset 10, -12
 3047              		.cfi_offset 11, -8
 3048              		.cfi_offset 14, -4
 984:../uvc.c      **** 
 3049              		.loc 1 984 0
 3050 1978 28B89FE5 		ldr	fp, .L235
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3051              		.loc 1 976 0
 3052 197c 28389FE5 		ldr	r3, .L235+4
 984:../uvc.c      **** 
 3053              		.loc 1 984 0
 3054 1980 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3055              		.loc 1 976 0
 3056 1984 8080A0E1 		mov	r8, r0, asl #1
 3057 1988 002088E0 		add	r2, r8, r0
 3058 198c 822183E0 		add	r2, r3, r2, asl #3
 986:../uvc.c      **** 		 {
 3059              		.loc 1 986 0
 3060 1990 830055E3 		cmp	r5, #131
 965:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3061              		.loc 1 965 0
 3062 1994 34D04DE2 		sub	sp, sp, #52
 3063              	.LCFI15:
 3064              		.cfi_def_cfa_offset 88
 965:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3065              		.loc 1 965 0
 3066 1998 0060A0E1 		mov	r6, r0
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3067              		.loc 1 976 0
 3068 199c 9F94D2E5 		ldrb	r9, [r2, #1183]	@ zero_extendqisi2
 3069              	.LVL353:
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 3070              		.loc 1 977 0
 3071 19a0 90A4D2E5 		ldrb	r10, [r2, #1168]	@ zero_extendqisi2
 3072              	.LVL354:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 3073              		.loc 1 979 0
 3074 19a4 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3075              	.LVL355:
 986:../uvc.c      **** 		 {
 3076              		.loc 1 986 0
 3077 19a8 8000000A 		beq	.L199
 3078 19ac 2600009A 		bls	.L233
 3079 19b0 850055E3 		cmp	r5, #133
 3080 19b4 7200000A 		beq	.L204
 3081 19b8 5000003A 		bcc	.L205
 3082 19bc 860055E3 		cmp	r5, #134
 3083 19c0 4300000A 		beq	.L206
 3084 19c4 870055E3 		cmp	r5, #135
 3085 19c8 5F00001A 		bne	.L198
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3086              		.loc 1 1048 0
 3087 19cc 9BC4D2E5 		ldrb	ip, [r2, #1179]	@ zero_extendqisi2
 3088 19d0 D8479FE5 		ldr	r4, .L235+8
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3089              		.loc 1 1049 0
 3090 19d4 9C24D2E5 		ldrb	r2, [r2, #1180]	@ zero_extendqisi2
 3091              	.LVL356:
 3092              	.L232:
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3093              		.loc 1 1026 0
 3094 19d8 0A1056E2 		subs	r1, r6, #10
 3095 19dc 006071E2 		rsbs	r6, r1, #0
 3096 19e0 0160B6E0 		adcs	r6, r6, r1
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3097              		.loc 1 1028 0
 3098 19e4 0030A0E3 		mov	r3, #0
 3099              	.LVL357:
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3100              		.loc 1 1029 0
 3101 19e8 9C1084E2 		add	r1, r4, #156
 3102 19ec 0700A0E1 		mov	r0, r7
 3103              	.LVL358:
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3104              		.loc 1 1026 0
 3105 19f0 9E60C4E5 		strb	r6, [r4, #158]
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3106              		.loc 1 1024 0
 3107 19f4 9CC0C4E5 		strb	ip, [r4, #156]
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3108              		.loc 1 1025 0
 3109 19f8 9D20C4E5 		strb	r2, [r4, #157]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3110              		.loc 1 1028 0
 3111 19fc 9F30C4E5 		strb	r3, [r4, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3112              		.loc 1 1029 0
 3113 1a00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3114              	.LVL359:
 3115 1a04 9C00D4E5 		ldrb	r0, [r4, #156]	@ zero_extendqisi2
1031:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 3116              		.loc 1 1031 0
 3117 1a08 FF80A0E3 		mov	r8, #255
 3118 1a0c 0860A0E1 		mov	r6, r8
 3119              	.LVL360:
 3120              	.L208:
1199:../uvc.c      **** }
 3121              		.loc 1 1199 0
 3122 1a10 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 3123 1a14 FFC0A0E3 		mov	ip, #255
 3124 1a18 04108DE5 		str	r1, [sp, #4]
 3125 1a1c 10108DE5 		str	r1, [sp, #16]
 3126 1a20 08008DE5 		str	r0, [sp, #8]
 3127 1a24 00808DE5 		str	r8, [sp]
 3128 1a28 14708DE5 		str	r7, [sp, #20]
 3129 1a2c 0520A0E1 		mov	r2, r5
 3130 1a30 0630A0E1 		mov	r3, r6
 3131 1a34 0CC08DE5 		str	ip, [sp, #12]
 3132 1a38 74179FE5 		ldr	r1, .L235+12
 3133 1a3c 0400A0E3 		mov	r0, #4
 3134 1a40 FEFFFFEB 		bl	CyU3PDebugPrint
 3135              	.LVL361:
1200:../uvc.c      **** 
 3136              		.loc 1 1200 0
 3137 1a44 34D08DE2 		add	sp, sp, #52
 3138              		@ sp needed
 3139 1a48 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 3140              	.LVL362:
 3141              	.L233:
 986:../uvc.c      **** 		 {
 3142              		.loc 1 986 0
 3143 1a4c 810055E3 		cmp	r5, #129
 3144 1a50 2E00000A 		beq	.L201
 3145 1a54 1A00008A 		bhi	.L202
 3146 1a58 010055E3 		cmp	r5, #1
 3147 1a5c 3A00001A 		bne	.L198
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 3148              		.loc 1 1057 0
 3149 1a60 48479FE5 		ldr	r4, .L235+8
 3150 1a64 2E208DE2 		add	r2, sp, #46
 3151              	.LVL363:
 3152 1a68 2000A0E3 		mov	r0, #32
 3153              	.LVL364:
 3154 1a6c 9C1084E2 		add	r1, r4, #156
 3155 1a70 18308DE5 		str	r3, [sp, #24]
 3156 1a74 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3157              	.LVL365:
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3158              		.loc 1 1059 0
 3159 1a78 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
1063:../uvc.c      **** 			  {
 3160              		.loc 1 1063 0
 3161 1a7c 012046E2 		sub	r2, r6, #1
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3162              		.loc 1 1059 0
 3163 1a80 1CC08DE5 		str	ip, [sp, #28]
 3164              	.LVL366:
1060:../uvc.c      **** 			  value = Data1;
 3165              		.loc 1 1060 0
 3166 1a84 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
1063:../uvc.c      **** 			  {
 3167              		.loc 1 1063 0
 3168 1a88 18309DE5 		ldr	r3, [sp, #24]
1060:../uvc.c      **** 			  value = Data1;
 3169              		.loc 1 1060 0
 3170 1a8c 20C08DE5 		str	ip, [sp, #32]
 3171              	.LVL367:
1063:../uvc.c      **** 			  {
 3172              		.loc 1 1063 0
 3173 1a90 090052E3 		cmp	r2, #9
 3174 1a94 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3175 1a98 1D0100EA 		b	.L209
 3176              	.L211:
 3177 1a9c CC1E0000 		.word	.L210
 3178 1aa0 141F0000 		.word	.L209
 3179 1aa4 CC1C0000 		.word	.L212
 3180 1aa8 141F0000 		.word	.L209
 3181 1aac 141F0000 		.word	.L209
 3182 1ab0 141F0000 		.word	.L209
 3183 1ab4 3C1C0000 		.word	.L213
 3184 1ab8 141F0000 		.word	.L209
 3185 1abc 141F0000 		.word	.L209
 3186 1ac0 C01B0000 		.word	.L214
 3187              	.LVL368:
 3188              	.L202:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3189              		.loc 1 1015 0
 3190 1ac4 93C4D2E5 		ldrb	ip, [r2, #1171]	@ zero_extendqisi2
 3191 1ac8 E0469FE5 		ldr	r4, .L235+8
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3192              		.loc 1 1016 0
 3193 1acc 9424D2E5 		ldrb	r2, [r2, #1172]	@ zero_extendqisi2
 3194              	.LVL369:
 3195 1ad0 C0FFFFEA 		b	.L232
 3196              	.LVL370:
 3197              	.L206:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3198              		.loc 1 1042 0
 3199 1ad4 D4469FE5 		ldr	r4, .L235+8
 3200 1ad8 9934D2E5 		ldrb	r3, [r2, #1177]	@ zero_extendqisi2
 3201 1adc 0410A0E1 		mov	r1, r4
 3202 1ae0 9C30E1E5 		strb	r3, [r1, #156]!
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3203              		.loc 1 1043 0
 3204 1ae4 0100A0E3 		mov	r0, #1
 3205              	.LVL371:
1046:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3206              		.loc 1 1046 0
 3207 1ae8 FF80A0E3 		mov	r8, #255
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3208              		.loc 1 1043 0
 3209 1aec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3210              	.LVL372:
1046:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3211              		.loc 1 1046 0
 3212 1af0 0860A0E1 		mov	r6, r8
 3213 1af4 9C00D4E5 		ldrb	r0, [r4, #156]	@ zero_extendqisi2
 3214 1af8 0170A0E3 		mov	r7, #1
 3215 1afc C3FFFFEA 		b	.L208
 3216              	.LVL373:
 3217              	.L205:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3218              		.loc 1 1033 0
 3219 1b00 97C4D2E5 		ldrb	ip, [r2, #1175]	@ zero_extendqisi2
 3220 1b04 A4469FE5 		ldr	r4, .L235+8
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3221              		.loc 1 1034 0
 3222 1b08 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 3223              	.LVL374:
 3224 1b0c B1FFFFEA 		b	.L232
 3225              	.LVL375:
 3226              	.L201:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3227              		.loc 1 1000 0
 3228 1b10 98469FE5 		ldr	r4, .L235+8
 3229 1b14 9D94D2E5 		ldrb	r9, [r2, #1181]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3230              		.loc 1 1001 0
 3231 1b18 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3232              		.loc 1 1002 0
 3233 1b1c 0030A0E3 		mov	r3, #0
1008:../uvc.c      **** 
 3234              		.loc 1 1008 0
 3235 1b20 9C1084E2 		add	r1, r4, #156
 3236 1b24 0700A0E1 		mov	r0, r7
 3237              	.LVL376:
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3238              		.loc 1 1013 0
 3239 1b28 FF80A0E3 		mov	r8, #255
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3240              		.loc 1 1001 0
 3241 1b2c 9DC0C4E5 		strb	ip, [r4, #157]
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3242              		.loc 1 1000 0
 3243 1b30 9C90C4E5 		strb	r9, [r4, #156]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3244              		.loc 1 1002 0
 3245 1b34 9E30C4E5 		strb	r3, [r4, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3246              		.loc 1 1003 0
 3247 1b38 9F30C4E5 		strb	r3, [r4, #159]
 3248              	.LVL377:
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3249              		.loc 1 1013 0
 3250 1b3c 0860A0E1 		mov	r6, r8
 3251              	.LVL378:
1008:../uvc.c      **** 
 3252              		.loc 1 1008 0
 3253 1b40 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3254              	.LVL379:
 3255 1b44 0900A0E1 		mov	r0, r9
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3256              		.loc 1 1013 0
 3257 1b48 B0FFFFEA 		b	.L208
 3258              	.LVL380:
 3259              	.L198:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3260              		.loc 1 1193 0
 3261 1b4c 0000A0E3 		mov	r0, #0
 3262              	.LVL381:
 3263 1b50 0020A0E1 		mov	r2, r0
 3264              	.LVL382:
 3265 1b54 0110A0E3 		mov	r1, #1
 3266 1b58 FEFFFFEB 		bl	CyU3PUsbStall
 3267              	.LVL383:
1194:../uvc.c      **** 			  break;
 3268              		.loc 1 1194 0
 3269 1b5c 0620A0E1 		mov	r2, r6
 3270 1b60 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 3271 1b64 0400A0E3 		mov	r0, #4
 3272 1b68 48169FE5 		ldr	r1, .L235+16
 3273 1b6c FEFFFFEB 		bl	CyU3PDebugPrint
 3274              	.LVL384:
1195:../uvc.c      **** 		 }
 3275              		.loc 1 1195 0
 3276 1b70 FF00A0E3 		mov	r0, #255
 3277 1b74 34469FE5 		ldr	r4, .L235+8
 3278 1b78 0080A0E1 		mov	r8, r0
 3279 1b7c 0060A0E1 		mov	r6, r0
 3280 1b80 A2FFFFEA 		b	.L208
 3281              	.LVL385:
 3282              	.L204:
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3283              		.loc 1 990 0
 3284 1b84 24469FE5 		ldr	r4, .L235+8
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3285              		.loc 1 991 0
 3286 1b88 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3287              		.loc 1 992 0
 3288 1b8c 9C1084E2 		add	r1, r4, #156
 3289 1b90 0200A0E3 		mov	r0, #2
 3290              	.LVL386:
 994:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3291              		.loc 1 994 0
 3292 1b94 FF80A0E3 		mov	r8, #255
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3293              		.loc 1 990 0
 3294 1b98 9C70C4E5 		strb	r7, [r4, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3295              		.loc 1 991 0
 3296 1b9c 9D30C4E5 		strb	r3, [r4, #157]
 994:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3297              		.loc 1 994 0
 3298 1ba0 0860A0E1 		mov	r6, r8
 3299              	.LVL387:
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3300              		.loc 1 992 0
 3301 1ba4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3302              	.LVL388:
 3303 1ba8 9C00D4E5 		ldrb	r0, [r4, #156]	@ zero_extendqisi2
 994:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3304              		.loc 1 994 0
 3305 1bac 97FFFFEA 		b	.L208
 3306              	.LVL389:
 3307              	.L199:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3308              		.loc 1 1024 0
 3309 1bb0 95C4D2E5 		ldrb	ip, [r2, #1173]	@ zero_extendqisi2
 3310 1bb4 F4459FE5 		ldr	r4, .L235+8
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3311              		.loc 1 1025 0
 3312 1bb8 9624D2E5 		ldrb	r2, [r2, #1174]	@ zero_extendqisi2
 3313              	.LVL390:
 3314 1bbc 85FFFFEA 		b	.L232
 3315              	.LVL391:
 3316              	.L214:
1172:../uvc.c      **** 					  if(getData == 1)
 3317              		.loc 1 1172 0
 3318 1bc0 F4659FE5 		ldr	r6, .L235+20
 3319 1bc4 0010E0E3 		mvn	r1, #0
 3320 1bc8 1C0096E5 		ldr	r0, [r6, #28]
 3321 1bcc FEFFFFEB 		bl	_txe_mutex_get
 3322              	.LVL392:
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3323              		.loc 1 1173 0
 3324 1bd0 1CC09DE5 		ldr	ip, [sp, #28]
 3325 1bd4 01005CE3 		cmp	ip, #1
1174:../uvc.c      **** 					  else if(getData == 0xff)
 3326              		.loc 1 1174 0
 3327 1bd8 0400A003 		moveq	r0, #4
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3328              		.loc 1 1173 0
 3329 1bdc 6901000A 		beq	.L231
1175:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3330              		.loc 1 1175 0
 3331 1be0 FF005CE3 		cmp	ip, #255
 3332 1be4 6601000A 		beq	.L234
1178:../uvc.c      **** 					  //dataIdx++;
 3333              		.loc 1 1178 0
 3334 1be8 0010A0E3 		mov	r1, #0
 3335 1bec 00108DE5 		str	r1, [sp]
 3336 1bf0 04108DE5 		str	r1, [sp, #4]
 3337 1bf4 0A20A0E1 		mov	r2, r10
 3338 1bf8 0930A0E1 		mov	r3, r9
 3339 1bfc 0600A0E1 		mov	r0, r6
 3340 1c00 2310A0E3 		mov	r1, #35
 3341 1c04 FEFFFFEB 		bl	cmdSet
 3342              	.LVL393:
 3343              	.L226:
1181:../uvc.c      **** #endif
 3344              		.loc 1 1181 0
 3345 1c08 1C0096E5 		ldr	r0, [r6, #28]
 3346 1c0c FEFFFFEB 		bl	_txe_mutex_put
 3347              	.LVL394:
1183:../uvc.c      **** 					  break;
 3348              		.loc 1 1183 0
 3349 1c10 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 3350 1c14 1C609DE5 		ldr	r6, [sp, #28]
 3351 1c18 20809DE5 		ldr	r8, [sp, #32]
 3352 1c1c 00108DE5 		str	r1, [sp]
 3353 1c20 0620A0E1 		mov	r2, r6
 3354 1c24 0830A0E1 		mov	r3, r8
 3355 1c28 0400A0E3 		mov	r0, #4
 3356 1c2c 8C159FE5 		ldr	r1, .L235+24
 3357 1c30 FEFFFFEB 		bl	CyU3PDebugPrint
 3358              	.LVL395:
1184:../uvc.c      **** 
 3359              		.loc 1 1184 0
 3360 1c34 FF00A0E3 		mov	r0, #255
 3361 1c38 74FFFFEA 		b	.L208
 3362              	.LVL396:
 3363              	.L213:
1149:../uvc.c      **** 					  {
 3364              		.loc 1 1149 0
 3365 1c3c B504D3E5 		ldrb	r0, [r3, #1205]	@ zero_extendqisi2
 3366 1c40 64C59FE5 		ldr	ip, .L235+4
 3367 1c44 010050E3 		cmp	r0, #1
 3368 1c48 08005013 		cmpne	r0, #8
 3369 1c4c 0000A013 		movne	r0, #0
 3370 1c50 0100A003 		moveq	r0, #1
 3371 1c54 4601001A 		bne	.L223
 3372              	.LVL397:
1152:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3373              		.loc 1 1152 0
 3374 1c58 5CB59FE5 		ldr	fp, .L235+20
 3375 1c5c 0010E0E3 		mvn	r1, #0
 3376 1c60 1C009BE5 		ldr	r0, [fp, #28]
 3377 1c64 18C08DE5 		str	ip, [sp, #24]
 3378 1c68 FEFFFFEB 		bl	_txe_mutex_get
 3379              	.LVL398:
1153:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3380              		.loc 1 1153 0
 3381 1c6c 1C009DE5 		ldr	r0, [sp, #28]
 3382 1c70 0010A0E3 		mov	r1, #0
 3383 1c74 0A20A0E1 		mov	r2, r10
 3384 1c78 0930A0E1 		mov	r3, r9
 3385 1c7c 00008DE5 		str	r0, [sp]
 3386 1c80 04108DE5 		str	r1, [sp, #4]
 3387 1c84 0B00A0E1 		mov	r0, fp
 3388 1c88 2210A0E3 		mov	r1, #34
 3389 1c8c FEFFFFEB 		bl	cmdSet
 3390              	.LVL399:
1154:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 3391              		.loc 1 1154 0
 3392 1c90 1C009BE5 		ldr	r0, [fp, #28]
 3393 1c94 FEFFFFEB 		bl	_txe_mutex_put
 3394              	.LVL400:
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3395              		.loc 1 1157 0
 3396 1c98 18C09DE5 		ldr	ip, [sp, #24]
 3397 1c9c 1C109DE5 		ldr	r1, [sp, #28]
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3398              		.loc 1 1158 0
 3399 1ca0 20209DE5 		ldr	r2, [sp, #32]
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3400              		.loc 1 1157 0
 3401 1ca4 066088E0 		add	r6, r8, r6
 3402 1ca8 86C18CE0 		add	ip, ip, r6, asl #3
1159:../uvc.c      **** 					  }else{
 3403              		.loc 1 1159 0
 3404 1cac 0130A0E3 		mov	r3, #1
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3405              		.loc 1 1157 0
 3406 1cb0 9D14CCE5 		strb	r1, [ip, #1181]
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3407              		.loc 1 1158 0
 3408 1cb4 9E24CCE5 		strb	r2, [ip, #1182]
1159:../uvc.c      **** 					  }else{
 3409              		.loc 1 1159 0
 3410 1cb8 A034CCE5 		strb	r3, [ip, #1184]
 3411              	.LVL401:
 3412              	.L224:
 3413 1cbc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 3414 1cc0 9D80D4E5 		ldrb	r8, [r4, #157]	@ zero_extendqisi2
1166:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 3415              		.loc 1 1166 0
 3416 1cc4 FF00A0E3 		mov	r0, #255
 3417 1cc8 50FFFFEA 		b	.L208
 3418              	.LVL402:
 3419              	.L212:
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3420              		.loc 1 1115 0
 3421 1ccc B534D3E5 		ldrb	r3, [r3, #1205]	@ zero_extendqisi2
 3422 1cd0 010053E3 		cmp	r3, #1
 3423 1cd4 04005313 		cmpne	r3, #4
 3424 1cd8 2001001A 		bne	.L221
1114:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3425              		.loc 1 1114 0
 3426 1cdc 1CC09DE5 		ldr	ip, [sp, #28]
 3427 1ce0 20009DE5 		ldr	r0, [sp, #32]
 3428 1ce4 00348CE1 		orr	r3, ip, r0, asl #8
1116:../uvc.c      **** 					  {
 3429              		.loc 1 1116 0
 3430 1ce8 F90053E3 		cmp	r3, #249
 3431 1cec 1B01008A 		bhi	.L221
 3432              	.LVL403:
1121:../uvc.c      **** 							}else{
 3433              		.loc 1 1121 0
 3434 1cf0 C80043E2 		sub	r0, r3, #200
 3435 1cf4 C80053E3 		cmp	r3, #200
1123:../uvc.c      **** 							}
 3436              		.loc 1 1123 0
 3437 1cf8 C82063E2 		rsb	r2, r3, #200
 3438 1cfc C0149FE5 		ldr	r1, .L235+28
 3439 1d00 0208A091 		movls	r0, r2, asl #16
 3440 1d04 0008A081 		movhi	r0, r0, asl #16
 3441 1d08 642063E2 		rsb	r2, r3, #100
 3442 1d0c 640053E3 		cmp	r3, #100
1121:../uvc.c      **** 							}else{
 3443              		.loc 1 1121 0
 3444 1d10 64C043E2 		sub	ip, r3, #100
 3445 1d14 2008A0E1 		mov	r0, r0, lsr #16
 3446 1d18 0C28A081 		movhi	r2, ip, asl #16
 3447 1d1c 0228A091 		movls	r2, r2, asl #16
 3448 1d20 010050E1 		cmp	r0, r1
 3449 1d24 00E0A031 		movcc	lr, r0
 3450 1d28 01E0A021 		movcs	lr, r1
 3451 1d2c 010050E1 		cmp	r0, r1
 3452 1d30 27C043E2 		sub	ip, r3, #39
1123:../uvc.c      **** 							}
 3453              		.loc 1 1123 0
 3454 1d34 271063E2 		rsb	r1, r3, #39
 3455 1d38 00B0A033 		movcc	fp, #0
 3456 1d3c 01B0A023 		movcs	fp, #1
 3457 1d40 270053E3 		cmp	r3, #39
1121:../uvc.c      **** 							}else{
 3458              		.loc 1 1121 0
 3459 1d44 140043E2 		sub	r0, r3, #20
 3460 1d48 01C8A091 		movls	ip, r1, asl #16
 3461 1d4c 2228A0E1 		mov	r2, r2, lsr #16
1123:../uvc.c      **** 							}
 3462              		.loc 1 1123 0
 3463 1d50 141063E2 		rsb	r1, r3, #20
 3464 1d54 0CC8A081 		movhi	ip, ip, asl #16
 3465 1d58 140053E3 		cmp	r3, #20
 3466 1d5c 0018A081 		movhi	r1, r0, asl #16
 3467 1d60 0118A091 		movls	r1, r1, asl #16
 3468 1d64 0E0052E1 		cmp	r2, lr
1121:../uvc.c      **** 							}else{
 3469              		.loc 1 1121 0
 3470 1d68 0A0043E2 		sub	r0, r3, #10
 3471 1d6c 01B0A033 		movcc	fp, #1
 3472 1d70 2CC8A0E1 		mov	ip, ip, lsr #16
 3473 1d74 02005EE1 		cmp	lr, r2
 3474 1d78 0E20A031 		movcc	r2, lr
 3475 1d7c 0A0053E3 		cmp	r3, #10
 3476 1d80 21E8A0E1 		mov	lr, r1, lsr #16
1123:../uvc.c      **** 							}
 3477              		.loc 1 1123 0
 3478 1d84 0A1063E2 		rsb	r1, r3, #10
 3479 1d88 0118A091 		movls	r1, r1, asl #16
 3480 1d8c 0018A081 		movhi	r1, r0, asl #16
 3481 1d90 0C0052E1 		cmp	r2, ip
 3482 1d94 02B0A083 		movhi	fp, #2
 3483 1d98 24B08DE5 		str	fp, [sp, #36]
1121:../uvc.c      **** 							}else{
 3484              		.loc 1 1121 0
 3485 1d9c 050043E2 		sub	r0, r3, #5
 3486 1da0 02005CE1 		cmp	ip, r2
 3487 1da4 0C20A031 		movcc	r2, ip
 3488 1da8 21B8A0E1 		mov	fp, r1, lsr #16
1123:../uvc.c      **** 							}
 3489              		.loc 1 1123 0
 3490 1dac 05C063E2 		rsb	ip, r3, #5
 3491 1db0 050053E3 		cmp	r3, #5
 3492 1db4 24109DE5 		ldr	r1, [sp, #36]
 3493 1db8 00C8A081 		movhi	ip, r0, asl #16
 3494 1dbc 0CC8A091 		movls	ip, ip, asl #16
 3495 1dc0 0E0052E1 		cmp	r2, lr
 3496 1dc4 0310A083 		movhi	r1, #3
 3497 1dc8 24108DE5 		str	r1, [sp, #36]
 3498 1dcc 02005EE1 		cmp	lr, r2
 3499 1dd0 0E00A031 		movcc	r0, lr
 3500 1dd4 0200A021 		movcs	r0, r2
 3501 1dd8 021063E2 		rsb	r1, r3, #2
1121:../uvc.c      **** 							}else{
 3502              		.loc 1 1121 0
 3503 1ddc 022043E2 		sub	r2, r3, #2
 3504 1de0 020053E3 		cmp	r3, #2
 3505 1de4 0128A091 		movls	r2, r1, asl #16
 3506 1de8 0228A081 		movhi	r2, r2, asl #16
 3507 1dec 0B0050E1 		cmp	r0, fp
 3508 1df0 24E09DE5 		ldr	lr, [sp, #36]
 3509 1df4 2CC8A0E1 		mov	ip, ip, lsr #16
 3510 1df8 04E0A083 		movhi	lr, #4
 3511 1dfc 00005BE1 		cmp	fp, r0
 3512 1e00 0B00A031 		movcc	r0, fp
 3513 1e04 00005CE1 		cmp	ip, r0
 3514 1e08 0C10A031 		movcc	r1, ip
 3515 1e0c 0010A021 		movcs	r1, r0
 3516 1e10 0C0050E1 		cmp	r0, ip
 3517 1e14 05E0A083 		movhi	lr, #5
 3518 1e18 01C043E2 		sub	ip, r3, #1
 3519 1e1c 010053E3 		cmp	r3, #1
1123:../uvc.c      **** 							}
 3520              		.loc 1 1123 0
 3521 1e20 010063E2 		rsb	r0, r3, #1
 3522 1e24 0C38A081 		movhi	r3, ip, asl #16
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3523              		.loc 1 1133 0
 3524 1e28 8CC39FE5 		ldr	ip, .L235+20
 3525 1e2c 2228A0E1 		mov	r2, r2, lsr #16
 3526 1e30 0038A091 		movls	r3, r0, asl #16
 3527 1e34 010052E1 		cmp	r2, r1
 3528 1e38 0200A031 		movcc	r0, r2
 3529 1e3c 0100A021 		movcs	r0, r1
 3530 1e40 020051E1 		cmp	r1, r2
 3531 1e44 0E20A091 		movls	r2, lr
 3532 1e48 0620A083 		movhi	r2, #6
 3533              	.LVL404:
 3534 1e4c 0010E0E3 		mvn	r1, #0
 3535              	.LVL405:
 3536 1e50 230850E1 		cmp	r0, r3, lsr #16
 3537 1e54 1C009CE5 		ldr	r0, [ip, #28]
 3538 1e58 02B0A091 		movls	fp, r2
 3539 1e5c 07B0A083 		movhi	fp, #7
 3540              	.LVL406:
 3541 1e60 18C08DE5 		str	ip, [sp, #24]
 3542 1e64 FEFFFFEB 		bl	_txe_mutex_get
 3543              	.LVL407:
1134:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3544              		.loc 1 1134 0
 3545 1e68 18C09DE5 		ldr	ip, [sp, #24]
1130:../uvc.c      **** 
 3546              		.loc 1 1130 0
 3547 1e6c 01B08BE2 		add	fp, fp, #1
 3548              	.LVL408:
1134:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3549              		.loc 1 1134 0
 3550 1e70 0010A0E3 		mov	r1, #0
 3551 1e74 0A20A0E1 		mov	r2, r10
 3552 1e78 0930A0E1 		mov	r3, r9
 3553 1e7c 0C00A0E1 		mov	r0, ip
 3554 1e80 04108DE5 		str	r1, [sp, #4]
 3555 1e84 00B08DE5 		str	fp, [sp]
 3556 1e88 0310A0E3 		mov	r1, #3
 3557 1e8c FEFFFFEB 		bl	cmdSet
 3558              	.LVL409:
1135:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 3559              		.loc 1 1135 0
 3560 1e90 18C09DE5 		ldr	ip, [sp, #24]
 3561 1e94 1C009CE5 		ldr	r0, [ip, #28]
 3562 1e98 FEFFFFEB 		bl	_txe_mutex_put
 3563              	.LVL410:
1141:../uvc.c      **** 					  }else{
 3564              		.loc 1 1141 0
 3565 1e9c 08C39FE5 		ldr	ip, .L235+4
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3566              		.loc 1 1138 0
 3567 1ea0 04239FE5 		ldr	r2, .L235+4
1141:../uvc.c      **** 					  }else{
 3568              		.loc 1 1141 0
 3569 1ea4 0DB3CCE5 		strb	fp, [ip, #781]
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3570              		.loc 1 1138 0
 3571 1ea8 1CC09DE5 		ldr	ip, [sp, #28]
 3572 1eac 063088E0 		add	r3, r8, r6
 3573 1eb0 833182E0 		add	r3, r2, r3, asl #3
 3574 1eb4 9DC4C3E5 		strb	ip, [r3, #1181]
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3575              		.loc 1 1139 0
 3576 1eb8 20C09DE5 		ldr	ip, [sp, #32]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3577              		.loc 1 1140 0
 3578 1ebc 0120A0E3 		mov	r2, #1
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3579              		.loc 1 1139 0
 3580 1ec0 9EC4C3E5 		strb	ip, [r3, #1182]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3581              		.loc 1 1140 0
 3582 1ec4 A024C3E5 		strb	r2, [r3, #1184]
1141:../uvc.c      **** 					  }else{
 3583              		.loc 1 1141 0
 3584 1ec8 7BFFFFEA 		b	.L224
 3585              	.LVL411:
 3586              	.L210:
1072:../uvc.c      **** 						case 1:
 3587              		.loc 1 1072 0
 3588 1ecc 1CC09DE5 		ldr	ip, [sp, #28]
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3589              		.loc 1 1068 0
 3590 1ed0 066088E0 		add	r6, r8, r6
 3591 1ed4 866183E0 		add	r6, r3, r6, asl #3
1069:../uvc.c      **** 				    getData = glEp0Buffer[0];
 3592              		.loc 1 1069 0
 3593 1ed8 0110A0E3 		mov	r1, #1
1072:../uvc.c      **** 						case 1:
 3594              		.loc 1 1072 0
 3595 1edc 01204CE2 		sub	r2, ip, #1
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3596              		.loc 1 1068 0
 3597 1ee0 9DC4C6E5 		strb	ip, [r6, #1181]
1069:../uvc.c      **** 				    getData = glEp0Buffer[0];
 3598              		.loc 1 1069 0
 3599 1ee4 A014C6E5 		strb	r1, [r6, #1184]
 3600              	.LVL412:
1072:../uvc.c      **** 						case 1:
 3601              		.loc 1 1072 0
 3602 1ee8 070052E3 		cmp	r2, #7
 3603 1eec 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3604 1ef0 960000EA 		b	.L215
 3605              	.L217:
 3606 1ef4 EC200000 		.word	.L216
 3607 1ef8 50200000 		.word	.L218
 3608 1efc 50210000 		.word	.L215
 3609 1f00 E81F0000 		.word	.L219
 3610 1f04 50210000 		.word	.L215
 3611 1f08 50210000 		.word	.L215
 3612 1f0c 50210000 		.word	.L215
 3613 1f10 481F0000 		.word	.L220
 3614              	.LVL413:
 3615              	.L209:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3616              		.loc 1 1187 0
 3617 1f14 1CC09DE5 		ldr	ip, [sp, #28]
 3618 1f18 068088E0 		add	r8, r8, r6
 3619 1f1c 888183E0 		add	r8, r3, r8, asl #3
1188:../uvc.c      **** 			  		 break;
 3620              		.loc 1 1188 0
 3621 1f20 0620A0E1 		mov	r2, r6
 3622 1f24 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 3623 1f28 0400A0E3 		mov	r0, #4
 3624 1f2c 94129FE5 		ldr	r1, .L235+32
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3625              		.loc 1 1187 0
 3626 1f30 9DC4C8E5 		strb	ip, [r8, #1181]
1188:../uvc.c      **** 			  		 break;
 3627              		.loc 1 1188 0
 3628 1f34 FEFFFFEB 		bl	CyU3PDebugPrint
 3629              	.LVL414:
1189:../uvc.c      **** 			  }
 3630              		.loc 1 1189 0
 3631 1f38 FF00A0E3 		mov	r0, #255
 3632 1f3c 0080A0E1 		mov	r8, r0
 3633 1f40 0060A0E1 		mov	r6, r0
 3634 1f44 B1FEFFEA 		b	.L208
 3635              	.LVL415:
 3636              	.L220:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3637              		.loc 1 1091 0
 3638 1f48 6C629FE5 		ldr	r6, .L235+20
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 3639              		.loc 1 1089 0
 3640 1f4c 0080A0E3 		mov	r8, #0
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3641              		.loc 1 1091 0
 3642 1f50 1C0096E5 		ldr	r0, [r6, #28]
 3643 1f54 0010E0E3 		mvn	r1, #0
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 3644              		.loc 1 1089 0
 3645 1f58 0D83C3E5 		strb	r8, [r3, #781]
 3646              	.LVL416:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3647              		.loc 1 1091 0
 3648 1f5c FEFFFFEB 		bl	_txe_mutex_get
 3649              	.LVL417:
1092:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3650              		.loc 1 1092 0
 3651 1f60 0A20A0E1 		mov	r2, r10
 3652 1f64 0930A0E1 		mov	r3, r9
 3653 1f68 1010A0E3 		mov	r1, #16
 3654 1f6c 00808DE5 		str	r8, [sp]
 3655 1f70 04808DE5 		str	r8, [sp, #4]
 3656 1f74 0600A0E1 		mov	r0, r6
 3657 1f78 FEFFFFEB 		bl	cmdSet
 3658              	.LVL418:
1093:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 3659              		.loc 1 1093 0
 3660 1f7c 1C0096E5 		ldr	r0, [r6, #28]
 3661 1f80 FEFFFFEB 		bl	_txe_mutex_put
 3662              	.LVL419:
 3663              	.LBB78:
 3664              	.LBB79:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3665              		.loc 1 390 0
 3666 1f84 1C0096E5 		ldr	r0, [r6, #28]
 3667 1f88 0010E0E3 		mvn	r1, #0
 3668 1f8c FEFFFFEB 		bl	_txe_mutex_get
 3669              	.LVL420:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3670              		.loc 1 391 0
 3671 1f90 0130A0E3 		mov	r3, #1
 3672 1f94 04808DE5 		str	r8, [sp, #4]
 3673 1f98 0600A0E1 		mov	r0, r6
 3674 1f9c 00308DE5 		str	r3, [sp]
 3675 1fa0 2010A0E3 		mov	r1, #32
 3676 1fa4 2720A0E3 		mov	r2, #39
 3677 1fa8 3030A0E3 		mov	r3, #48
 3678 1fac FEFFFFEB 		bl	cmdSet
 3679              	.LVL421:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3680              		.loc 1 392 0
 3681 1fb0 0230A0E3 		mov	r3, #2
 3682 1fb4 04808DE5 		str	r8, [sp, #4]
 3683 1fb8 0600A0E1 		mov	r0, r6
 3684 1fbc 00308DE5 		str	r3, [sp]
 3685 1fc0 2110A0E3 		mov	r1, #33
 3686 1fc4 2520A0E3 		mov	r2, #37
 3687 1fc8 3030A0E3 		mov	r3, #48
 3688 1fcc FEFFFFEB 		bl	cmdSet
 3689              	.LVL422:
 393:../uvc.c      **** }
 3690              		.loc 1 393 0
 3691 1fd0 1C0096E5 		ldr	r0, [r6, #28]
 3692 1fd4 FEFFFFEB 		bl	_txe_mutex_put
 3693              	.LVL423:
 3694 1fd8 FF00A0E3 		mov	r0, #255
 3695 1fdc 0080A0E1 		mov	r8, r0
 3696 1fe0 0860A0E3 		mov	r6, #8
 3697 1fe4 89FEFFEA 		b	.L208
 3698              	.LVL424:
 3699              	.L219:
 3700              	.LBE79:
 3701              	.LBE78:
 3702              	.LBB80:
 3703              	.LBB81:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3704              		.loc 1 390 0
 3705 1fe8 CC619FE5 		ldr	r6, .L235+20
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3706              		.loc 1 391 0
 3707 1fec 0080A0E3 		mov	r8, #0
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3708              		.loc 1 390 0
 3709 1ff0 0010E0E3 		mvn	r1, #0
 3710 1ff4 1C0096E5 		ldr	r0, [r6, #28]
 3711 1ff8 FEFFFFEB 		bl	_txe_mutex_get
 3712              	.LVL425:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3713              		.loc 1 391 0
 3714 1ffc 0600A0E1 		mov	r0, r6
 3715 2000 00808DE5 		str	r8, [sp]
 3716 2004 04808DE5 		str	r8, [sp, #4]
 3717 2008 2010A0E3 		mov	r1, #32
 3718 200c 2720A0E3 		mov	r2, #39
 3719 2010 3030A0E3 		mov	r3, #48
 3720 2014 FEFFFFEB 		bl	cmdSet
 3721              	.LVL426:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3722              		.loc 1 392 0
 3723 2018 0130A0E3 		mov	r3, #1
 3724 201c 04808DE5 		str	r8, [sp, #4]
 3725 2020 0600A0E1 		mov	r0, r6
 3726 2024 00308DE5 		str	r3, [sp]
 3727 2028 2110A0E3 		mov	r1, #33
 3728 202c 2520A0E3 		mov	r2, #37
 3729 2030 3030A0E3 		mov	r3, #48
 3730 2034 FEFFFFEB 		bl	cmdSet
 3731              	.LVL427:
 393:../uvc.c      **** }
 3732              		.loc 1 393 0
 3733 2038 1C0096E5 		ldr	r0, [r6, #28]
 3734 203c FEFFFFEB 		bl	_txe_mutex_put
 3735              	.LVL428:
 3736 2040 FF00A0E3 		mov	r0, #255
 3737 2044 0080A0E1 		mov	r8, r0
 3738 2048 0460A0E3 		mov	r6, #4
 3739 204c 6FFEFFEA 		b	.L208
 3740              	.LVL429:
 3741              	.L218:
 3742              	.LBE81:
 3743              	.LBE80:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3744              		.loc 1 1079 0
 3745 2050 64619FE5 		ldr	r6, .L235+20
1077:../uvc.c      **** 							dataIdx = 0;
 3746              		.loc 1 1077 0
 3747 2054 0080A0E3 		mov	r8, #0
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3748              		.loc 1 1079 0
 3749 2058 1C0096E5 		ldr	r0, [r6, #28]
 3750 205c 0010E0E3 		mvn	r1, #0
1077:../uvc.c      **** 							dataIdx = 0;
 3751              		.loc 1 1077 0
 3752 2060 0D83C3E5 		strb	r8, [r3, #781]
 3753              	.LVL430:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3754              		.loc 1 1079 0
 3755 2064 FEFFFFEB 		bl	_txe_mutex_get
 3756              	.LVL431:
1080:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3757              		.loc 1 1080 0
 3758 2068 0A20A0E1 		mov	r2, r10
 3759 206c 0930A0E1 		mov	r3, r9
 3760 2070 1010A0E3 		mov	r1, #16
 3761 2074 00808DE5 		str	r8, [sp]
 3762 2078 04808DE5 		str	r8, [sp, #4]
 3763 207c 0600A0E1 		mov	r0, r6
 3764 2080 FEFFFFEB 		bl	cmdSet
 3765              	.LVL432:
1081:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 3766              		.loc 1 1081 0
 3767 2084 1C0096E5 		ldr	r0, [r6, #28]
 3768 2088 FEFFFFEB 		bl	_txe_mutex_put
 3769              	.LVL433:
 3770              	.LBB82:
 3771              	.LBB83:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3772              		.loc 1 390 0
 3773 208c 1C0096E5 		ldr	r0, [r6, #28]
 3774 2090 0010E0E3 		mvn	r1, #0
 3775 2094 FEFFFFEB 		bl	_txe_mutex_get
 3776              	.LVL434:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3777              		.loc 1 391 0
 3778 2098 00808DE5 		str	r8, [sp]
 3779 209c 04808DE5 		str	r8, [sp, #4]
 3780 20a0 0600A0E1 		mov	r0, r6
 3781 20a4 2010A0E3 		mov	r1, #32
 3782 20a8 2720A0E3 		mov	r2, #39
 3783 20ac 3030A0E3 		mov	r3, #48
 3784 20b0 FEFFFFEB 		bl	cmdSet
 3785              	.LVL435:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3786              		.loc 1 392 0
 3787 20b4 0130A0E3 		mov	r3, #1
 3788 20b8 04808DE5 		str	r8, [sp, #4]
 3789 20bc 0600A0E1 		mov	r0, r6
 3790 20c0 00308DE5 		str	r3, [sp]
 3791 20c4 2110A0E3 		mov	r1, #33
 3792 20c8 2520A0E3 		mov	r2, #37
 3793 20cc 3030A0E3 		mov	r3, #48
 3794 20d0 FEFFFFEB 		bl	cmdSet
 3795              	.LVL436:
 393:../uvc.c      **** }
 3796              		.loc 1 393 0
 3797 20d4 1C0096E5 		ldr	r0, [r6, #28]
 3798 20d8 FEFFFFEB 		bl	_txe_mutex_put
 3799              	.LVL437:
 3800 20dc FF00A0E3 		mov	r0, #255
 3801 20e0 0080A0E1 		mov	r8, r0
 3802 20e4 0260A0E3 		mov	r6, #2
 3803 20e8 48FEFFEA 		b	.L208
 3804              	.LVL438:
 3805              	.L216:
 3806              	.LBE83:
 3807              	.LBE82:
 3808              	.LBB84:
 3809              	.LBB85:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3810              		.loc 1 390 0
 3811 20ec C8809FE5 		ldr	r8, .L235+20
 3812 20f0 0010E0E3 		mvn	r1, #0
 3813 20f4 1C0098E5 		ldr	r0, [r8, #28]
 3814 20f8 FEFFFFEB 		bl	_txe_mutex_get
 3815              	.LVL439:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3816              		.loc 1 391 0
 3817 20fc 0090A0E3 		mov	r9, #0
 3818              	.LVL440:
 3819 2100 0160A0E3 		mov	r6, #1
 3820 2104 0800A0E1 		mov	r0, r8
 3821 2108 2010A0E3 		mov	r1, #32
 3822 210c 2720A0E3 		mov	r2, #39
 3823 2110 3030A0E3 		mov	r3, #48
 3824 2114 40028DE8 		stmia	sp, {r6, r9}
 3825 2118 FEFFFFEB 		bl	cmdSet
 3826              	.LVL441:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3827              		.loc 1 392 0
 3828 211c 0230A0E3 		mov	r3, #2
 3829 2120 0800A0E1 		mov	r0, r8
 3830 2124 00308DE5 		str	r3, [sp]
 3831 2128 2110A0E3 		mov	r1, #33
 3832 212c 2520A0E3 		mov	r2, #37
 3833 2130 3030A0E3 		mov	r3, #48
 3834 2134 04908DE5 		str	r9, [sp, #4]
 3835 2138 FEFFFFEB 		bl	cmdSet
 3836              	.LVL442:
 393:../uvc.c      **** }
 3837              		.loc 1 393 0
 3838 213c 1C0098E5 		ldr	r0, [r8, #28]
 3839 2140 FEFFFFEB 		bl	_txe_mutex_put
 3840              	.LVL443:
 3841 2144 FF00A0E3 		mov	r0, #255
 3842 2148 0080A0E1 		mov	r8, r0
 3843 214c 2FFEFFEA 		b	.L208
 3844              	.LVL444:
 3845              	.L215:
 3846              	.LBE85:
 3847              	.LBE84:
1072:../uvc.c      **** 						case 1:
 3848              		.loc 1 1072 0
 3849 2150 FF00A0E3 		mov	r0, #255
 3850 2154 0C60A0E1 		mov	r6, ip
 3851 2158 0080A0E1 		mov	r8, r0
 3852 215c 2BFEFFEA 		b	.L208
 3853              	.LVL445:
 3854              	.L221:
1143:../uvc.c      **** 					  }
 3855              		.loc 1 1143 0
 3856 2160 0000A0E3 		mov	r0, #0
 3857 2164 0020A0E1 		mov	r2, r0
 3858 2168 0110A0E3 		mov	r1, #1
 3859 216c FEFFFFEB 		bl	CyU3PUsbStall
 3860              	.LVL446:
 3861 2170 D1FEFFEA 		b	.L224
 3862              	.LVL447:
 3863              	.L223:
1161:../uvc.c      **** 					  }
 3864              		.loc 1 1161 0
 3865 2174 0020A0E1 		mov	r2, r0
 3866 2178 0110A0E3 		mov	r1, #1
 3867 217c FEFFFFEB 		bl	CyU3PUsbStall
 3868              	.LVL448:
 3869 2180 CDFEFFEA 		b	.L224
 3870              	.LVL449:
 3871              	.L234:
1176:../uvc.c      **** 					  else
 3872              		.loc 1 1176 0
 3873 2184 0800A0E3 		mov	r0, #8
 3874              	.L231:
 3875 2188 0010A0E3 		mov	r1, #0
 3876 218c 03008DE8 		stmia	sp, {r0, r1}
 3877 2190 0A20A0E1 		mov	r2, r10
 3878 2194 0930A0E1 		mov	r3, r9
 3879 2198 0600A0E1 		mov	r0, r6
 3880 219c 2310A0E3 		mov	r1, #35
 3881 21a0 FEFFFFEB 		bl	cmdSet
 3882              	.LVL450:
 3883 21a4 97FEFFEA 		b	.L226
 3884              	.L236:
 3885              		.align	2
 3886              	.L235:
 3887 21a8 00000000 		.word	bRequest
 3888 21ac 00000000 		.word	.LANCHOR1
 3889 21b0 00000000 		.word	.LANCHOR0
 3890 21b4 14040000 		.word	.LC23
 3891 21b8 F0030000 		.word	.LC22
 3892 21bc 00000000 		.word	cmdQu
 3893 21c0 A4030000 		.word	.LC20
 3894 21c4 FFFF0000 		.word	65535
 3895 21c8 CC030000 		.word	.LC21
 3896              		.cfi_endproc
 3897              	.LFE3:
 3899              		.align	2
 3900              		.global	CamDefSet
 3902              	CamDefSet:
 3903              	.LFB4:
1204:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 3904              		.loc 1 1204 0
 3905              		.cfi_startproc
 3906              		@ args = 0, pretend = 0, frame = 24
 3907              		@ frame_needed = 0, uses_anonymous_args = 0
 3908              	.LVL451:
 3909 21cc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3910              	.LCFI16:
 3911              		.cfi_def_cfa_offset 36
 3912              		.cfi_offset 4, -36
 3913              		.cfi_offset 5, -32
 3914              		.cfi_offset 6, -28
 3915              		.cfi_offset 7, -24
 3916              		.cfi_offset 8, -20
 3917              		.cfi_offset 9, -16
 3918              		.cfi_offset 10, -12
 3919              		.cfi_offset 11, -8
 3920              		.cfi_offset 14, -4
1210:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 3921              		.loc 1 1210 0
 3922 21d0 AC429FE5 		ldr	r4, .L240
1215:../uvc.c      ****     if(Data1&0x80){
 3923              		.loc 1 1215 0
 3924 21d4 AC229FE5 		ldr	r2, .L240+4
1212:../uvc.c      ****     Data1 = Data0;
 3925              		.loc 1 1212 0
 3926 21d8 A351D4E5 		ldrb	r5, [r4, #419]	@ zero_extendqisi2
1204:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 3927              		.loc 1 1204 0
 3928 21dc 2CD04DE2 		sub	sp, sp, #44
 3929              	.LCFI17:
 3930              		.cfi_def_cfa_offset 80
1215:../uvc.c      ****     if(Data1&0x80){
 3931              		.loc 1 1215 0
 3932 21e0 1C0092E5 		ldr	r0, [r2, #28]
 3933 21e4 0010E0E3 		mvn	r1, #0
1217:../uvc.c      ****     }else{
 3934              		.loc 1 1217 0
 3935 21e8 2563A0E1 		mov	r6, r5, lsr #6
1211:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 3936              		.loc 1 1211 0
 3937 21ec A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1210:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 3938              		.loc 1 1210 0
 3939 21f0 9991D4E5 		ldrb	r9, [r4, #409]	@ zero_extendqisi2
 3940              	.LVL452:
1215:../uvc.c      ****     if(Data1&0x80){
 3941              		.loc 1 1215 0
 3942 21f4 FEFFFFEB 		bl	_txe_mutex_get
 3943              	.LVL453:
1216:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 3944              		.loc 1 1216 0
 3945 21f8 800015E3 		tst	r5, #128
1217:../uvc.c      ****     }else{
 3946              		.loc 1 1217 0
 3947 21fc 01600612 		andne	r6, r6, #1
 3948 2200 0660E011 		mvnne	r6, r6
 3949 2204 3B600612 		andne	r6, r6, #59
 3950 2208 0660E011 		mvnne	r6, r6
 3951 220c FF600612 		andne	r6, r6, #255
 3952              	.LVL454:
1219:../uvc.c      ****     }
 3953              		.loc 1 1219 0
 3954 2210 C6608603 		orreq	r6, r6, #198
 3955              	.LVL455:
1223:../uvc.c      **** 
 3956              		.loc 1 1223 0
 3957 2214 0080A0E3 		mov	r8, #0
1221:../uvc.c      **** 
 3958              		.loc 1 1221 0
 3959 2218 0551A0E1 		mov	r5, r5, asl #2
 3960              	.LVL456:
 3961 221c FF5005E2 		and	r5, r5, #255
 3962              	.LVL457:
1226:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3963              		.loc 1 1226 0
 3964 2220 01A0A0E3 		mov	r10, #1
1223:../uvc.c      **** 
 3965              		.loc 1 1223 0
 3966 2224 00608DE5 		str	r6, [sp]
 3967 2228 0920A0E1 		mov	r2, r9
 3968 222c 0730A0E1 		mov	r3, r7
 3969 2230 04808DE5 		str	r8, [sp, #4]
 3970 2234 0110A0E3 		mov	r1, #1
 3971 2238 48029FE5 		ldr	r0, .L240+4
 3972 223c FEFFFFEB 		bl	cmdSet
 3973              	.LVL458:
1226:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3974              		.loc 1 1226 0
 3975 2240 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 3976 2244 0730A0E1 		mov	r3, r7
 3977 2248 0A10A0E1 		mov	r1, r10
 3978 224c 00508DE5 		str	r5, [sp]
 3979 2250 04A08DE5 		str	r10, [sp, #4]
 3980 2254 2C029FE5 		ldr	r0, .L240+4
 3981 2258 FEFFFFEB 		bl	cmdSet
 3982              	.LVL459:
1229:../uvc.c      **** 
 3983              		.loc 1 1229 0
 3984 225c 0620A0E1 		mov	r2, r6
 3985 2260 0530A0E1 		mov	r3, r5
 3986 2264 20129FE5 		ldr	r1, .L240+8
 3987 2268 0400A0E3 		mov	r0, #4
1228:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 3988              		.loc 1 1228 0
 3989 226c A661C4E5 		strb	r6, [r4, #422]
1227:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 3990              		.loc 1 1227 0
 3991 2270 A551C4E5 		strb	r5, [r4, #421]
1229:../uvc.c      **** 
 3992              		.loc 1 1229 0
 3993 2274 FEFFFFEB 		bl	CyU3PDebugPrint
 3994              	.LVL460:
1234:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 3995              		.loc 1 1234 0
 3996 2278 BB61D4E5 		ldrb	r6, [r4, #443]	@ zero_extendqisi2
 3997              	.LVL461:
1235:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3998              		.loc 1 1235 0
 3999 227c B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 4000 2280 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 4001 2284 40018DE8 		stmia	sp, {r6, r8}
 4002 2288 F8019FE5 		ldr	r0, .L240+4
 4003 228c 0210A0E3 		mov	r1, #2
 4004 2290 FEFFFFEB 		bl	cmdSet
 4005              	.LVL462:
1237:../uvc.c      **** 
 4006              		.loc 1 1237 0
 4007 2294 0620A0E1 		mov	r2, r6
 4008 2298 0530A0E1 		mov	r3, r5
 4009 229c E8119FE5 		ldr	r1, .L240+8
 4010 22a0 0400A0E3 		mov	r0, #4
1236:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4011              		.loc 1 1236 0
 4012 22a4 BD51C4E5 		strb	r5, [r4, #445]
1237:../uvc.c      **** 
 4013              		.loc 1 1237 0
 4014 22a8 FEFFFFEB 		bl	CyU3PDebugPrint
 4015              	.LVL463:
1242:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 4016              		.loc 1 1242 0
 4017 22ac 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1241:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 4018              		.loc 1 1241 0
 4019 22b0 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 4020              	.LVL464:
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4021              		.loc 1 1243 0
 4022 22b4 80C047E2 		sub	ip, r7, #128
 4023 22b8 FF300CE2 		and	r3, ip, #255
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4024              		.loc 1 1244 0
 4025 22bc 76E047E2 		sub	lr, r7, #118
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4026              		.loc 1 1243 0
 4027 22c0 18308DE5 		str	r3, [sp, #24]
 4028 22c4 08018DE8 		stmia	sp, {r3, r8}
 4029 22c8 B8019FE5 		ldr	r0, .L240+4
 4030 22cc 0630A0E1 		mov	r3, r6
 4031 22d0 0510A0E3 		mov	r1, #5
 4032 22d4 DF20A0E3 		mov	r2, #223
 4033 22d8 14C08DE5 		str	ip, [sp, #20]
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4034              		.loc 1 1244 0
 4035 22dc 1CE08DE5 		str	lr, [sp, #28]
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4036              		.loc 1 1243 0
 4037 22e0 FEFFFFEB 		bl	cmdSet
 4038              	.LVL465:
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4039              		.loc 1 1244 0
 4040 22e4 1C209DE5 		ldr	r2, [sp, #28]
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4041              		.loc 1 1245 0
 4042 22e8 7EE087E2 		add	lr, r7, #126
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4043              		.loc 1 1244 0
 4044 22ec FF3002E2 		and	r3, r2, #255
 4045 22f0 08048DE8 		stmia	sp, {r3, r10}
 4046 22f4 8C019FE5 		ldr	r0, .L240+4
 4047 22f8 0630A0E1 		mov	r3, r6
 4048 22fc 0510A0E3 		mov	r1, #5
 4049 2300 DC20A0E3 		mov	r2, #220
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4050              		.loc 1 1245 0
 4051 2304 20E08DE5 		str	lr, [sp, #32]
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4052              		.loc 1 1244 0
 4053 2308 FEFFFFEB 		bl	cmdSet
 4054              	.LVL466:
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4055              		.loc 1 1245 0
 4056 230c 20209DE5 		ldr	r2, [sp, #32]
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4057              		.loc 1 1246 0
 4058 2310 72E087E2 		add	lr, r7, #114
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4059              		.loc 1 1245 0
 4060 2314 FF3002E2 		and	r3, r2, #255
 4061 2318 0220A0E3 		mov	r2, #2
 4062 231c 00308DE5 		str	r3, [sp]
 4063 2320 04208DE5 		str	r2, [sp, #4]
 4064 2324 0630A0E1 		mov	r3, r6
 4065 2328 0510A0E3 		mov	r1, #5
 4066 232c DE20A0E3 		mov	r2, #222
 4067 2330 50019FE5 		ldr	r0, .L240+4
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4068              		.loc 1 1246 0
 4069 2334 24E08DE5 		str	lr, [sp, #36]
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4070              		.loc 1 1245 0
 4071 2338 FEFFFFEB 		bl	cmdSet
 4072              	.LVL467:
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4073              		.loc 1 1246 0
 4074 233c 24209DE5 		ldr	r2, [sp, #36]
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4075              		.loc 1 1247 0
 4076 2340 6FB047E2 		sub	fp, r7, #111
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4077              		.loc 1 1246 0
 4078 2344 FF3002E2 		and	r3, r2, #255
 4079 2348 0320A0E3 		mov	r2, #3
 4080 234c 00308DE5 		str	r3, [sp]
 4081 2350 04208DE5 		str	r2, [sp, #4]
 4082 2354 0630A0E1 		mov	r3, r6
 4083 2358 0510A0E3 		mov	r1, #5
 4084 235c E020A0E3 		mov	r2, #224
 4085 2360 20019FE5 		ldr	r0, .L240+4
 4086 2364 FEFFFFEB 		bl	cmdSet
 4087              	.LVL468:
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4088              		.loc 1 1247 0
 4089 2368 0490A0E3 		mov	r9, #4
 4090 236c FF300BE2 		and	r3, fp, #255
1248:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 4091              		.loc 1 1248 0
 4092 2370 7F7087E2 		add	r7, r7, #127
 4093              	.LVL469:
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4094              		.loc 1 1247 0
 4095 2374 00308DE5 		str	r3, [sp]
 4096 2378 04908DE5 		str	r9, [sp, #4]
 4097 237c 0630A0E1 		mov	r3, r6
 4098 2380 0510A0E3 		mov	r1, #5
 4099 2384 DD20A0E3 		mov	r2, #221
 4100 2388 F8009FE5 		ldr	r0, .L240+4
 4101 238c FEFFFFEB 		bl	cmdSet
 4102              	.LVL470:
1248:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 4103              		.loc 1 1248 0
 4104 2390 FF2007E2 		and	r2, r7, #255
 4105 2394 0510A0E3 		mov	r1, #5
 4106 2398 0630A0E1 		mov	r3, r6
 4107 239c 00208DE5 		str	r2, [sp]
 4108 23a0 04108DE5 		str	r1, [sp, #4]
 4109 23a4 E120A0E3 		mov	r2, #225
 4110 23a8 D8009FE5 		ldr	r0, .L240+4
 4111 23ac FEFFFFEB 		bl	cmdSet
 4112              	.LVL471:
1250:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4113              		.loc 1 1250 0
 4114 23b0 14C09DE5 		ldr	ip, [sp, #20]
 4115 23b4 24E09DE5 		ldr	lr, [sp, #36]
 4116 23b8 20309DE5 		ldr	r3, [sp, #32]
 4117 23bc 0C20A0E1 		mov	r2, ip
1249:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 4118              		.loc 1 1249 0
 4119 23c0 18C09DE5 		ldr	ip, [sp, #24]
1250:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4120              		.loc 1 1250 0
 4121 23c4 04E08DE5 		str	lr, [sp, #4]
 4122 23c8 00308DE5 		str	r3, [sp]
 4123 23cc 0C708DE5 		str	r7, [sp, #12]
 4124 23d0 1C309DE5 		ldr	r3, [sp, #28]
 4125 23d4 08B08DE5 		str	fp, [sp, #8]
 4126 23d8 0900A0E1 		mov	r0, r9
 4127 23dc AC109FE5 		ldr	r1, .L240+12
1249:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 4128              		.loc 1 1249 0
 4129 23e0 05C2C4E5 		strb	ip, [r4, #517]
1250:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4130              		.loc 1 1250 0
 4131 23e4 FEFFFFEB 		bl	CyU3PDebugPrint
 4132              	.LVL472:
1255:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 4133              		.loc 1 1255 0
 4134 23e8 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 4135              	.LVL473:
1254:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 4136              		.loc 1 1254 0
 4137 23ec 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 4138              	.LVL474:
1256:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 4139              		.loc 1 1256 0
 4140 23f0 00608DE5 		str	r6, [sp]
 4141 23f4 0730A0E1 		mov	r3, r7
 4142 23f8 04808DE5 		str	r8, [sp, #4]
 4143 23fc 0610A0E3 		mov	r1, #6
 4144 2400 8520A0E3 		mov	r2, #133
 4145 2404 7C009FE5 		ldr	r0, .L240+4
 4146 2408 FEFFFFEB 		bl	cmdSet
 4147              	.LVL475:
1257:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 4148              		.loc 1 1257 0
 4149 240c 40048DE8 		stmia	sp, {r6, r10}
 4150 2410 70009FE5 		ldr	r0, .L240+4
 4151 2414 0730A0E1 		mov	r3, r7
 4152 2418 0610A0E3 		mov	r1, #6
 4153 241c 8620A0E3 		mov	r2, #134
 4154 2420 FEFFFFEB 		bl	cmdSet
 4155              	.LVL476:
1259:../uvc.c      **** 
 4156              		.loc 1 1259 0
 4157 2424 0620A0E1 		mov	r2, r6
 4158 2428 0530A0E1 		mov	r3, r5
 4159 242c 0900A0E1 		mov	r0, r9
 4160 2430 54109FE5 		ldr	r1, .L240+8
1258:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4161              		.loc 1 1258 0
 4162 2434 1D62C4E5 		strb	r6, [r4, #541]
1259:../uvc.c      **** 
 4163              		.loc 1 1259 0
 4164 2438 FEFFFFEB 		bl	CyU3PDebugPrint
 4165              	.LVL477:
1264:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 4166              		.loc 1 1264 0
 4167 243c 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 4168              	.LVL478:
1265:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 4169              		.loc 1 1265 0
 4170 2440 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 4171 2444 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 4172 2448 40018DE8 		stmia	sp, {r6, r8}
 4173 244c 34009FE5 		ldr	r0, .L240+4
 4174 2450 0710A0E3 		mov	r1, #7
 4175 2454 FEFFFFEB 		bl	cmdSet
 4176              	.LVL479:
1267:../uvc.c      **** 
 4177              		.loc 1 1267 0
 4178 2458 0620A0E1 		mov	r2, r6
 4179 245c 0530A0E1 		mov	r3, r5
 4180 2460 0900A0E1 		mov	r0, r9
 4181 2464 20109FE5 		ldr	r1, .L240+8
1266:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4182              		.loc 1 1266 0
 4183 2468 3552C4E5 		strb	r5, [r4, #565]
1267:../uvc.c      **** 
 4184              		.loc 1 1267 0
 4185 246c FEFFFFEB 		bl	CyU3PDebugPrint
 4186              	.LVL480:
1269:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 4187              		.loc 1 1269 0
 4188 2470 10209FE5 		ldr	r2, .L240+4
 4189 2474 1C0092E5 		ldr	r0, [r2, #28]
1272:../uvc.c      **** 
 4190              		.loc 1 1272 0
 4191 2478 2CD08DE2 		add	sp, sp, #44
 4192              		@ sp needed
 4193 247c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4194              	.LVL481:
1269:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 4195              		.loc 1 1269 0
 4196 2480 FEFFFFEA 		b	_txe_mutex_put
 4197              	.LVL482:
 4198              	.L241:
 4199              		.align	2
 4200              	.L240:
 4201 2484 00000000 		.word	.LANCHOR1
 4202 2488 00000000 		.word	cmdQu
 4203 248c 78040000 		.word	.LC24
 4204 2490 98040000 		.word	.LC25
 4205              		.cfi_endproc
 4206              	.LFE4:
 4208              		.align	2
 4209              		.global	CyFxUVCAddHeader
 4211              	CyFxUVCAddHeader:
 4212              	.LFB5:
1280:../uvc.c      ****     /* Copy header to buffer */
 4213              		.loc 1 1280 0
 4214              		.cfi_startproc
 4215              		@ args = 0, pretend = 0, frame = 0
 4216              		@ frame_needed = 0, uses_anonymous_args = 0
 4217              	.LVL483:
 4218 2494 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 4219              	.LCFI18:
 4220              		.cfi_def_cfa_offset 16
 4221              		.cfi_offset 3, -16
 4222              		.cfi_offset 4, -12
 4223              		.cfi_offset 5, -8
 4224              		.cfi_offset 14, -4
1280:../uvc.c      ****     /* Copy header to buffer */
 4225              		.loc 1 1280 0
 4226 2498 0040A0E1 		mov	r4, r0
 4227 249c 0150A0E1 		mov	r5, r1
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 4228              		.loc 1 1282 0
 4229 24a0 30009FE5 		ldr	r0, .L247
 4230              	.LVL484:
 4231 24a4 0010E0E3 		mvn	r1, #0
 4232              	.LVL485:
 4233 24a8 FEFFFFEB 		bl	_txe_mutex_get
 4234              	.LVL486:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 4235              		.loc 1 1283 0
 4236 24ac 0400A0E1 		mov	r0, r4
 4237 24b0 24109FE5 		ldr	r1, .L247+4
 4238 24b4 0C20A0E3 		mov	r2, #12
 4239 24b8 FEFFFFEB 		bl	CyU3PMemCopy
 4240              	.LVL487:
1284:../uvc.c      **** 
 4241              		.loc 1 1284 0
 4242 24bc 14009FE5 		ldr	r0, .L247
 4243 24c0 FEFFFFEB 		bl	_txe_mutex_put
 4244              	.LVL488:
1287:../uvc.c      ****     {
 4245              		.loc 1 1287 0
 4246 24c4 020015E3 		tst	r5, #2
1289:../uvc.c      ****     }
 4247              		.loc 1 1289 0
 4248 24c8 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 4249 24cc 02308313 		orrne	r3, r3, #2
 4250 24d0 0130C415 		strneb	r3, [r4, #1]
 4251 24d4 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 4252              	.L248:
 4253              		.align	2
 4254              	.L247:
 4255 24d8 00000000 		.word	imgHdMux
 4256 24dc 80040000 		.word	.LANCHOR1+1152
 4257              		.cfi_endproc
 4258              	.LFE5:
 4260              		.align	2
 4261              		.global	CyFxAppErrorHandler
 4263              	CyFxAppErrorHandler:
 4264              	.LFB6:
1299:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 4265              		.loc 1 1299 0
 4266              		.cfi_startproc
 4267              		@ Volatile: function does not return.
 4268              		@ args = 0, pretend = 0, frame = 0
 4269              		@ frame_needed = 0, uses_anonymous_args = 0
 4270              	.LVL489:
 4271 24e0 08402DE9 		stmfd	sp!, {r3, lr}
 4272              	.LCFI19:
 4273              		.cfi_def_cfa_offset 8
 4274              		.cfi_offset 3, -8
 4275              		.cfi_offset 14, -4
 4276              	.LVL490:
 4277              	.L250:
1309:../uvc.c      ****         CyU3PThreadSleep (1000);
 4278              		.loc 1 1309 0 discriminator 1
 4279 24e4 10109FE5 		ldr	r1, .L251
 4280 24e8 0400A0E3 		mov	r0, #4
 4281 24ec FEFFFFEB 		bl	CyU3PDebugPrint
 4282              	.LVL491:
1310:../uvc.c      ****     }
 4283              		.loc 1 1310 0 discriminator 1
 4284 24f0 FA0FA0E3 		mov	r0, #1000
 4285 24f4 FEFFFFEB 		bl	_tx_thread_sleep
 4286              	.LVL492:
 4287 24f8 F9FFFFEA 		b	.L250
 4288              	.L252:
 4289              		.align	2
 4290              	.L251:
 4291 24fc D0040000 		.word	.LC26
 4292              		.cfi_endproc
 4293              	.LFE6:
 4295              		.align	2
 4296              		.global	UVCAppEP0Thread_Entry
 4298              	UVCAppEP0Thread_Entry:
 4299              	.LFB24:
3269:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 4300              		.loc 1 3269 0
 4301              		.cfi_startproc
 4302              		@ args = 0, pretend = 0, frame = 72
 4303              		@ frame_needed = 0, uses_anonymous_args = 0
 4304              	.LVL493:
 4305 2500 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4306              	.LCFI20:
 4307              		.cfi_def_cfa_offset 36
 4308              		.cfi_offset 4, -36
 4309              		.cfi_offset 5, -32
 4310              		.cfi_offset 6, -28
 4311              		.cfi_offset 7, -24
 4312              		.cfi_offset 8, -20
 4313              		.cfi_offset 9, -16
 4314              		.cfi_offset 10, -12
 4315              		.cfi_offset 11, -8
 4316              		.cfi_offset 14, -4
 4317 2504 F49F9FE5 		ldr	r9, .L740
 4318 2508 F4AF9FE5 		ldr	r10, .L740+4
 4319 250c F45F9FE5 		ldr	r5, .L740+8
3345:../uvc.c      ****                 {
 4320              		.loc 1 3345 0
 4321 2510 F48F9FE5 		ldr	r8, .L740+12
 4322              	.LBB126:
 4323              	.LBB127:
2946:../uvc.c      ****     {
 4324              		.loc 1 2946 0
 4325 2514 F4BF9FE5 		ldr	fp, .L740+16
 4326              	.LBE127:
 4327              	.LBE126:
3269:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 4328              		.loc 1 3269 0
 4329 2518 64D04DE2 		sub	sp, sp, #100
 4330              	.LCFI21:
 4331              		.cfi_def_cfa_offset 136
 4332              	.LVL494:
3291:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 4333              		.loc 1 3291 0
 4334 251c 0940A0E1 		mov	r4, r9
 4335              	.LVL495:
 4336              	.L568:
 4337 2520 0030E0E3 		mvn	r3, #0
 4338 2524 00308DE5 		str	r3, [sp]
 4339 2528 D00F9FE5 		ldr	r0, .L740
 4340 252c 4C10A0E3 		mov	r1, #76
 4341 2530 0120A0E3 		mov	r2, #1
 4342 2534 48308DE2 		add	r3, sp, #72
 4343 2538 FEFFFFEB 		bl	_txe_event_flags_get
 4344              	.LVL496:
 4345 253c 000050E3 		cmp	r0, #0
 4346 2540 5700001A 		bne	.L255
3295:../uvc.c      ****             {
 4347              		.loc 1 3295 0
 4348 2544 883094E5 		ldr	r3, [r4, #136]
 4349 2548 000053E3 		cmp	r3, #0
 4350 254c 7700000A 		beq	.L704
 4351              	.L257:
3313:../uvc.c      ****             {
 4352              		.loc 1 3313 0
 4353 2550 48309DE5 		ldr	r3, [sp, #72]
 4354 2554 040013E3 		tst	r3, #4
 4355 2558 1F00000A 		beq	.L259
3315:../uvc.c      ****                 {
 4356              		.loc 1 3315 0
 4357 255c B020D8E1 		ldrh	r2, [r8]
 4358 2560 2224A0E1 		mov	r2, r2, lsr #8
 4359 2564 030052E3 		cmp	r2, #3
 4360 2568 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4361 256c 150000EA 		b	.L260
 4362              	.L262:
 4363 2570 C8250000 		.word	.L260
 4364 2574 80250000 		.word	.L263
 4365 2578 AC260000 		.word	.L264
 4366 257c E8260000 		.word	.L265
 4367              	.L263:
 4368              	.LBB138:
 4369              	.LBB139:
2626:../uvc.c      ****     {
 4370              		.loc 1 2626 0
 4371 2580 B020DBE1 		ldrh	r2, [fp]
 4372 2584 060C52E3 		cmp	r2, #1536
 4373 2588 2B02000A 		beq	.L281
 4374 258c CD00009A 		bls	.L705
 4375 2590 090C52E3 		cmp	r2, #2304
 4376 2594 8302000A 		beq	.L289
 4377 2598 5001009A 		bls	.L706
 4378 259c 0B0C52E3 		cmp	r2, #2816
 4379 25a0 0902000A 		beq	.L292
 4380 25a4 030B52E3 		cmp	r2, #3072
 4381 25a8 E001000A 		beq	.L293
 4382 25ac 0A0C52E3 		cmp	r2, #2560
 4383 25b0 C201000A 		beq	.L707
 4384              	.L280:
2683:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4385              		.loc 1 2683 0
 4386 25b4 583F9FE5 		ldr	r3, .L740+20
 4387 25b8 0400A0E3 		mov	r0, #4
 4388 25bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 4389 25c0 501F9FE5 		ldr	r1, .L740+24
 4390 25c4 FEFFFFEB 		bl	CyU3PDebugPrint
 4391              	.LVL497:
 4392              	.L260:
 4393              	.LBE139:
 4394              	.LBE138:
3336:../uvc.c      ****                         break;
 4395              		.loc 1 3336 0
 4396 25c8 0000A0E3 		mov	r0, #0
 4397 25cc 0020A0E1 		mov	r2, r0
 4398 25d0 0110A0E3 		mov	r1, #1
 4399 25d4 FEFFFFEB 		bl	CyU3PUsbStall
 4400              	.LVL498:
 4401 25d8 48309DE5 		ldr	r3, [sp, #72]
 4402              	.L259:
3341:../uvc.c      ****             {
 4403              		.loc 1 3341 0
 4404 25dc 080013E3 		tst	r3, #8
 4405 25e0 0700000A 		beq	.L513
3345:../uvc.c      ****                 {
 4406              		.loc 1 3345 0
 4407 25e4 B030D8E1 		ldrh	r3, [r8]
 4408 25e8 010053E3 		cmp	r3, #1
 4409 25ec 7500000A 		beq	.L514
 4410              	.L515:
 4411              	.LBB341:
 4412              	.LBB128:
3258:../uvc.c      ****             break;
 4413              		.loc 1 3258 0
 4414 25f0 0000A0E3 		mov	r0, #0
 4415 25f4 0020A0E1 		mov	r2, r0
 4416 25f8 0110A0E3 		mov	r1, #1
 4417 25fc FEFFFFEB 		bl	CyU3PUsbStall
 4418              	.LVL499:
 4419              	.L528:
 4420 2600 48309DE5 		ldr	r3, [sp, #72]
 4421              	.L513:
 4422              	.LBE128:
 4423              	.LBE341:
3356:../uvc.c      ****             {
 4424              		.loc 1 3356 0
 4425 2604 400013E3 		tst	r3, #64
 4426 2608 2500000A 		beq	.L255
3361:../uvc.c      **** 
 4427              		.loc 1 3361 0
 4428 260c 1800A0E3 		mov	r0, #24
 4429 2610 50108DE2 		add	r1, sp, #80
 4430              	.LVL500:
 4431 2614 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 4432              	.LVL501:
3366:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4433              		.loc 1 3366 0
 4434 2618 50309DE5 		ldr	r3, [sp, #80]
 4435 261c 000053E3 		cmp	r3, #0
 4436 2620 4800001A 		bne	.L708
3390:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4437              		.loc 1 3390 0
 4438 2624 4326DAE5 		ldrb	r2, [r10, #1603]	@ zero_extendqisi2
 4439 2628 000052E3 		cmp	r2, #0
 4440 262c 1C00000A 		beq	.L255
3392:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4441              		.loc 1 3392 0
 4442 2630 002095E5 		ldr	r2, [r5]
 4443 2634 0210A0E3 		mov	r1, #2
 4444 2638 0010C2E5 		strb	r1, [r2]
3393:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4445              		.loc 1 3393 0
 4446 263c 001095E5 		ldr	r1, [r5]
 4447 2640 0120A0E3 		mov	r2, #1
 4448 2644 0120C1E5 		strb	r2, [r1, #1]
3394:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4449              		.loc 1 3394 0
 4450 2648 001095E5 		ldr	r1, [r5]
3398:../uvc.c      **** 					interStabuf.status = 0;
 4451              		.loc 1 3398 0
 4452 264c 01CBA0E3 		mov	ip, #1024
3394:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4453              		.loc 1 3394 0
 4454 2650 0230C1E5 		strb	r3, [r1, #2]
3395:../uvc.c      **** 
 4455              		.loc 1 3395 0
 4456 2654 001095E5 		ldr	r1, [r5]
3401:../uvc.c      **** 
 4457              		.loc 1 3401 0
 4458 2658 0470A0E3 		mov	r7, #4
3395:../uvc.c      **** 
 4459              		.loc 1 3395 0
 4460 265c 0320C1E5 		strb	r2, [r1, #3]
3397:../uvc.c      **** 					interStabuf.size   = 1024;
 4461              		.loc 1 3397 0
 4462 2660 002095E5 		ldr	r2, [r5]
3404:../uvc.c      **** 
 4463              		.loc 1 3404 0
 4464 2664 0010E0E3 		mvn	r1, #0
 4465 2668 AC0E9FE5 		ldr	r0, .L740+28
3399:../uvc.c      **** 
 4466              		.loc 1 3399 0
 4467 266c BC35CDE1 		strh	r3, [sp, #92]	@ movhi
3397:../uvc.c      **** 					interStabuf.size   = 1024;
 4468              		.loc 1 3397 0
 4469 2670 54208DE5 		str	r2, [sp, #84]
3398:../uvc.c      **** 					interStabuf.status = 0;
 4470              		.loc 1 3398 0
 4471 2674 BAC5CDE1 		strh	ip, [sp, #90]	@ movhi
3401:../uvc.c      **** 
 4472              		.loc 1 3401 0
 4473 2678 B875CDE1 		strh	r7, [sp, #88]	@ movhi
3404:../uvc.c      **** 
 4474              		.loc 1 3404 0
 4475 267c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 4476              	.LVL502:
3407:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4477              		.loc 1 3407 0
 4478 2680 940E9FE5 		ldr	r0, .L740+28
 4479 2684 54108DE2 		add	r1, sp, #84
 4480 2688 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4481              	.LVL503:
3408:../uvc.c      **** 					{
 4482              		.loc 1 3408 0
 4483 268c 000050E3 		cmp	r0, #0
 4484 2690 B105001A 		bne	.L709
3414:../uvc.c      **** 					stiflag = 0xFF;
 4485              		.loc 1 3414 0
 4486 2694 68EE9FE5 		ldr	lr, .L740+4
3415:../uvc.c      **** 				}
 4487              		.loc 1 3415 0
 4488 2698 FF30A0E3 		mov	r3, #255
3414:../uvc.c      **** 					stiflag = 0xFF;
 4489              		.loc 1 3414 0
 4490 269c 4306CEE5 		strb	r0, [lr, #1603]
3415:../uvc.c      **** 				}
 4491              		.loc 1 3415 0
 4492 26a0 743089E5 		str	r3, [r9, #116]
 4493              	.LVL504:
 4494              	.L255:
3569:../uvc.c      ****     }
 4495              		.loc 1 3569 0
 4496 26a4 FEFFFFEB 		bl	_txe_thread_relinquish
 4497              	.LVL505:
3570:../uvc.c      **** }
 4498              		.loc 1 3570 0
 4499 26a8 9CFFFFEA 		b	.L568
 4500              	.L264:
 4501              	.LBB342:
 4502              	.LBB343:
2551:../uvc.c      ****     {
 4503              		.loc 1 2551 0
 4504 26ac B020DBE1 		ldrh	r2, [fp]
 4505 26b0 060C52E3 		cmp	r2, #1536
 4506 26b4 6901000A 		beq	.L267
 4507 26b8 7500008A 		bhi	.L268
 4508 26bc 030C52E3 		cmp	r2, #768
 4509 26c0 6E01000A 		beq	.L269
 4510 26c4 E100008A 		bhi	.L270
 4511 26c8 010C52E3 		cmp	r2, #256
 4512 26cc 6701000A 		beq	.L271
 4513 26d0 020C52E3 		cmp	r2, #512
 4514 26d4 B6FFFF1A 		bne	.L280
 4515              	.L448:
 4516              	.LVL506:
 4517              	.LBE343:
 4518              	.LBE342:
 4519              	.LBB347:
 4520              	.LBB348:
2898:../uvc.c      ****     		break;
 4521              		.loc 1 2898 0
 4522 26d8 1A00A0E3 		mov	r0, #26
 4523 26dc FEFFFFEB 		bl	ControlHandle
 4524              	.LVL507:
 4525 26e0 48309DE5 		ldr	r3, [sp, #72]
 4526 26e4 BCFFFFEA 		b	.L259
 4527              	.L265:
2851:../uvc.c      ****     {
 4528              		.loc 1 2851 0
 4529 26e8 B030DBE1 		ldrh	r3, [fp]
 4530 26ec 090C53E3 		cmp	r3, #2304
 4531 26f0 3A03000A 		beq	.L434
 4532 26f4 5800008A 		bhi	.L435
 4533 26f8 010B53E3 		cmp	r3, #1024
 4534 26fc 0003000A 		beq	.L436
 4535 2700 EC00009A 		bls	.L710
 4536 2704 060C53E3 		cmp	r3, #1536
 4537 2708 3C03000A 		beq	.L441
 4538 270c A502009A 		bls	.L711
 4539 2710 070C53E3 		cmp	r3, #1792
 4540 2714 3503000A 		beq	.L444
 4541 2718 020B53E3 		cmp	r3, #2048
 4542 271c A9FFFF1A 		bne	.L260
 4543              	.LVL508:
2883:../uvc.c      ****     		break;
 4544              		.loc 1 2883 0
 4545 2720 1700A0E3 		mov	r0, #23
 4546 2724 FEFFFFEB 		bl	ControlHandle
 4547              	.LVL509:
 4548 2728 48309DE5 		ldr	r3, [sp, #72]
 4549 272c AAFFFFEA 		b	.L259
 4550              	.L704:
 4551              	.LBE348:
 4552              	.LBE347:
3297:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4553              		.loc 1 3297 0
 4554 2730 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 4555              	.LVL510:
3298:../uvc.c      ****                 {
 4556              		.loc 1 3298 0
 4557 2734 000050E3 		cmp	r0, #0
3300:../uvc.c      ****                 }
 4558              		.loc 1 3300 0
 4559 2738 0130A013 		movne	r3, #1
3297:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4560              		.loc 1 3297 0
 4561 273c C000C4E5 		strb	r0, [r4, #192]
3300:../uvc.c      ****                 }
 4562              		.loc 1 3300 0
 4563 2740 88308415 		strne	r3, [r4, #136]
 4564 2744 81FFFFEA 		b	.L257
 4565              	.L708:
3366:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4566              		.loc 1 3366 0 discriminator 1
 4567 2748 4336DAE5 		ldrb	r3, [r10, #1603]	@ zero_extendqisi2
 4568 274c 000053E3 		cmp	r3, #0
 4569 2750 D3FFFF1A 		bne	.L255
3368:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4570              		.loc 1 3368 0
 4571 2754 002095E5 		ldr	r2, [r5]
 4572 2758 0210A0E3 		mov	r1, #2
 4573 275c 0010C2E5 		strb	r1, [r2]
3369:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4574              		.loc 1 3369 0
 4575 2760 002095E5 		ldr	r2, [r5]
 4576 2764 0160A0E3 		mov	r6, #1
 4577 2768 0160C2E5 		strb	r6, [r2, #1]
3370:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4578              		.loc 1 3370 0
 4579 276c 001095E5 		ldr	r1, [r5]
3374:../uvc.c      **** 					interStabuf.status = 0;
 4580              		.loc 1 3374 0
 4581 2770 012BA0E3 		mov	r2, #1024
3370:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4582              		.loc 1 3370 0
 4583 2774 0230C1E5 		strb	r3, [r1, #2]
3371:../uvc.c      **** 
 4584              		.loc 1 3371 0
 4585 2778 001095E5 		ldr	r1, [r5]
3377:../uvc.c      **** 
 4586              		.loc 1 3377 0
 4587 277c 0470A0E3 		mov	r7, #4
3371:../uvc.c      **** 
 4588              		.loc 1 3371 0
 4589 2780 0330C1E5 		strb	r3, [r1, #3]
3373:../uvc.c      **** 					interStabuf.size   = 1024;
 4590              		.loc 1 3373 0
 4591 2784 001095E5 		ldr	r1, [r5]
3380:../uvc.c      **** 
 4592              		.loc 1 3380 0
 4593 2788 8C0D9FE5 		ldr	r0, .L740+28
3373:../uvc.c      **** 					interStabuf.size   = 1024;
 4594              		.loc 1 3373 0
 4595 278c 54108DE5 		str	r1, [sp, #84]
3380:../uvc.c      **** 
 4596              		.loc 1 3380 0
 4597 2790 0010E0E3 		mvn	r1, #0
3375:../uvc.c      **** 
 4598              		.loc 1 3375 0
 4599 2794 BC35CDE1 		strh	r3, [sp, #92]	@ movhi
3374:../uvc.c      **** 					interStabuf.status = 0;
 4600              		.loc 1 3374 0
 4601 2798 BA25CDE1 		strh	r2, [sp, #90]	@ movhi
3377:../uvc.c      **** 
 4602              		.loc 1 3377 0
 4603 279c B875CDE1 		strh	r7, [sp, #88]	@ movhi
3380:../uvc.c      **** 
 4604              		.loc 1 3380 0
 4605 27a0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 4606              	.LVL511:
3383:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4607              		.loc 1 3383 0
 4608 27a4 700D9FE5 		ldr	r0, .L740+28
 4609 27a8 54108DE2 		add	r1, sp, #84
 4610 27ac FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4611              	.LVL512:
3384:../uvc.c      **** 					{
 4612              		.loc 1 3384 0
 4613 27b0 000050E3 		cmp	r0, #0
 4614 27b4 2003001A 		bne	.L712
3389:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4615              		.loc 1 3389 0
 4616 27b8 447D9FE5 		ldr	r7, .L740+4
 4617 27bc 4366C7E5 		strb	r6, [r7, #1603]
3569:../uvc.c      ****     }
 4618              		.loc 1 3569 0
 4619 27c0 FEFFFFEB 		bl	_txe_thread_relinquish
 4620              	.LVL513:
 4621 27c4 55FFFFEA 		b	.L568
 4622              	.L514:
 4623              	.LVL514:
 4624              	.LBB437:
 4625              	.LBB129:
2946:../uvc.c      ****     {
 4626              		.loc 1 2946 0
 4627 27c8 B020DBE1 		ldrh	r2, [fp]
 4628 27cc 030C52E3 		cmp	r2, #768
 4629 27d0 7100000A 		beq	.L516
 4630 27d4 1200008A 		bhi	.L517
 4631 27d8 010C52E3 		cmp	r2, #256
 4632 27dc 8000000A 		beq	.L518
 4633 27e0 020C52E3 		cmp	r2, #512
 4634 27e4 81FFFF1A 		bne	.L515
3000:../uvc.c      ****             {
 4635              		.loc 1 3000 0
 4636 27e8 243D9FE5 		ldr	r3, .L740+20
 4637 27ec 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 4638 27f0 810053E3 		cmp	r3, #129
 4639 27f4 8200000A 		beq	.L556
 4640 27f8 4302009A 		bls	.L713
 4641 27fc 850053E3 		cmp	r3, #133
 4642 2800 6F00000A 		beq	.L552
 4643 2804 860053E3 		cmp	r3, #134
 4644 2808 78FFFF1A 		bne	.L515
 4645              	.L695:
3206:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4646              		.loc 1 3206 0
 4647 280c 0330A0E3 		mov	r3, #3
3207:../uvc.c      ****                         break;
 4648              		.loc 1 3207 0
 4649 2810 581D9FE5 		ldr	r1, .L740+112
 4650 2814 0100A0E3 		mov	r0, #1
3206:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4651              		.loc 1 3206 0
 4652 2818 9C30C9E5 		strb	r3, [r9, #156]
3207:../uvc.c      ****                         break;
 4653              		.loc 1 3207 0
 4654 281c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4655              	.LVL515:
 4656 2820 76FFFFEA 		b	.L528
 4657              	.L517:
2946:../uvc.c      ****     {
 4658              		.loc 1 2946 0
 4659 2824 010B52E3 		cmp	r2, #1024
 4660 2828 7900000A 		beq	.L520
 4661 282c 050C52E3 		cmp	r2, #1280
 4662 2830 6EFFFF1A 		bne	.L515
3203:../uvc.c      ****                 {
 4663              		.loc 1 3203 0
 4664 2834 D82C9FE5 		ldr	r2, .L740+20
 4665 2838 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4666 283c 810052E3 		cmp	r2, #129
 4667 2840 6F00000A 		beq	.L556
 4668 2844 1802009A 		bls	.L714
 4669 2848 850052E3 		cmp	r2, #133
 4670 284c F302000A 		beq	.L559
 4671 2850 860052E3 		cmp	r2, #134
 4672 2854 ECFFFF0A 		beq	.L695
 4673 2858 64FFFFEA 		b	.L515
 4674              	.LVL516:
 4675              	.L435:
 4676              	.LBE129:
 4677              	.LBE437:
 4678              	.LBB438:
 4679              	.LBB425:
2851:../uvc.c      ****     {
 4680              		.loc 1 2851 0
 4681 285c 0F0C53E3 		cmp	r3, #3840
 4682 2860 CA02000A 		beq	.L446
 4683 2864 8900009A 		bls	.L715
 4684 2868 110C53E3 		cmp	r3, #4352
 4685 286c E702000A 		beq	.L451
 4686 2870 5202009A 		bls	.L716
 4687 2874 120C53E3 		cmp	r3, #4608
 4688 2878 8502000A 		beq	.L454
 4689 287c 130C53E3 		cmp	r3, #4864
 4690 2880 50FFFF1A 		bne	.L260
 4691              	.LVL517:
2926:../uvc.c      ****     		break;
 4692              		.loc 1 2926 0
 4693 2884 2600A0E3 		mov	r0, #38
 4694 2888 FEFFFFEB 		bl	ControlHandle
 4695              	.LVL518:
 4696 288c 48309DE5 		ldr	r3, [sp, #72]
 4697 2890 51FFFFEA 		b	.L259
 4698              	.L268:
 4699              	.LBE425:
 4700              	.LBE438:
 4701              	.LBB439:
 4702              	.LBB344:
2551:../uvc.c      ****     {
 4703              		.loc 1 2551 0
 4704 2894 0A0C52E3 		cmp	r2, #2560
 4705 2898 FC00000A 		beq	.L274
 4706 289c 7300009A 		bls	.L717
 4707 28a0 0D0C52E3 		cmp	r2, #3328
 4708 28a4 F900000A 		beq	.L274
 4709 28a8 0E0C52E3 		cmp	r2, #3584
 4710 28ac FB00000A 		beq	.L278
 4711 28b0 030B52E3 		cmp	r2, #3072
 4712 28b4 3EFFFF1A 		bne	.L280
 4713              	.LVL519:
2592:../uvc.c      ****     		break;
 4714              		.loc 1 2592 0
 4715 28b8 0B00A0E3 		mov	r0, #11
 4716 28bc FEFFFFEB 		bl	ControlHandle
 4717              	.LVL520:
 4718 28c0 48309DE5 		ldr	r3, [sp, #72]
 4719 28c4 44FFFFEA 		b	.L259
 4720              	.L705:
 4721              	.LBE344:
 4722              	.LBE439:
 4723              	.LBB440:
 4724              	.LBB328:
2626:../uvc.c      ****     {
 4725              		.loc 1 2626 0
 4726 28c8 030C52E3 		cmp	r2, #768
 4727 28cc C901000A 		beq	.L283
 4728 28d0 8700008A 		bhi	.L284
 4729 28d4 010C52E3 		cmp	r2, #256
 4730 28d8 9601000A 		beq	.L285
 4731 28dc 020C52E3 		cmp	r2, #512
 4732 28e0 33FFFF1A 		bne	.L280
 4733              	.LVL521:
 4734              	.LBB140:
 4735              	.LBB141:
 984:../uvc.c      **** 
 4736              		.loc 1 984 0
 4737 28e4 287C9FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4738              		.loc 1 979 0
 4739 28e8 AA14DAE5 		ldrb	r1, [r10, #1194]	@ zero_extendqisi2
 984:../uvc.c      **** 
 4740              		.loc 1 984 0
 4741 28ec 00E0D7E5 		ldrb	lr, [r7]	@ zero_extendqisi2
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4742              		.loc 1 976 0
 4743 28f0 B764DAE5 		ldrb	r6, [r10, #1207]	@ zero_extendqisi2
 4744              	.LVL522:
 986:../uvc.c      **** 		 {
 4745              		.loc 1 986 0
 4746 28f4 83005EE3 		cmp	lr, #131
 984:../uvc.c      **** 
 4747              		.loc 1 984 0
 4748 28f8 28E08DE5 		str	lr, [sp, #40]
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4749              		.loc 1 977 0
 4750 28fc A834DAE5 		ldrb	r3, [r10, #1192]	@ zero_extendqisi2
 4751              	.LVL523:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4752              		.loc 1 979 0
 4753 2900 2C108DE5 		str	r1, [sp, #44]
 4754              	.LVL524:
 986:../uvc.c      **** 		 {
 4755              		.loc 1 986 0
 4756 2904 FC06000A 		beq	.L307
 4757 2908 9B03009A 		bls	.L718
 4758 290c 28209DE5 		ldr	r2, [sp, #40]
 4759 2910 850052E3 		cmp	r2, #133
 4760 2914 9306000A 		beq	.L312
 4761 2918 4F05003A 		bcc	.L313
 4762 291c 860052E3 		cmp	r2, #134
 4763 2920 6506000A 		beq	.L314
 4764 2924 870052E3 		cmp	r2, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4765              		.loc 1 1048 0
 4766 2928 B314DA05 		ldreqb	r1, [r10, #1203]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4767              		.loc 1 1049 0
 4768 292c B424DA05 		ldreqb	r2, [r10, #1204]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 4769              		.loc 1 986 0
 4770 2930 FA05001A 		bne	.L306
 4771              	.L670:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4772              		.loc 1 1027 0
 4773 2934 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4774              		.loc 1 1024 0
 4775 2938 9C10C9E5 		strb	r1, [r9, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4776              		.loc 1 1029 0
 4777 293c 2C009DE5 		ldr	r0, [sp, #44]
 4778 2940 281C9FE5 		ldr	r1, .L740+112
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4779              		.loc 1 1025 0
 4780 2944 9D20C9E5 		strb	r2, [r9, #157]
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4781              		.loc 1 1027 0
 4782 2948 9E30C9E5 		strb	r3, [r9, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4783              		.loc 1 1028 0
 4784 294c 9F30C9E5 		strb	r3, [r9, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4785              		.loc 1 1029 0
 4786 2950 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4787              	.LVL525:
1030:../uvc.c      **** 			  break;
 4788              		.loc 1 1030 0
 4789 2954 9C60D9E5 		ldrb	r6, [r9, #156]	@ zero_extendqisi2
 4790              	.LVL526:
 4791 2958 2C709DE5 		ldr	r7, [sp, #44]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 4792              		.loc 1 980 0
 4793 295c FFC0A0E3 		mov	ip, #255
 4794              	.LVL527:
 4795              	.L316:
1199:../uvc.c      **** }
 4796              		.loc 1 1199 0
 4797 2960 9E00D9E5 		ldrb	r0, [r9, #158]	@ zero_extendqisi2
 4798 2964 FF10A0E3 		mov	r1, #255
 4799 2968 0C30A0E1 		mov	r3, ip
 4800 296c 04008DE5 		str	r0, [sp, #4]
 4801 2970 10008DE5 		str	r0, [sp, #16]
 4802 2974 00108DE5 		str	r1, [sp]
 4803 2978 0C108DE5 		str	r1, [sp, #12]
 4804 297c 08608DE5 		str	r6, [sp, #8]
 4805 2980 14708DE5 		str	r7, [sp, #20]
 4806 2984 28209DE5 		ldr	r2, [sp, #40]
 4807 2988 0400A0E3 		mov	r0, #4
 4808 298c 8C1B9FE5 		ldr	r1, .L740+32
 4809 2990 FEFFFFEB 		bl	CyU3PDebugPrint
 4810              	.LVL528:
 4811 2994 48309DE5 		ldr	r3, [sp, #72]
 4812 2998 0FFFFFEA 		b	.L259
 4813              	.LVL529:
 4814              	.L516:
 4815              	.LBE141:
 4816              	.LBE140:
 4817              	.LBE328:
 4818              	.LBE440:
 4819              	.LBB441:
 4820              	.LBB130:
3077:../uvc.c      ****                 {
 4821              		.loc 1 3077 0
 4822 299c 702B9FE5 		ldr	r2, .L740+20
 4823 29a0 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4824 29a4 830052E3 		cmp	r2, #131
 4825 29a8 7700009A 		bls	.L719
 4826 29ac 860052E3 		cmp	r2, #134
 4827 29b0 2000000A 		beq	.L696
 4828 29b4 870052E3 		cmp	r2, #135
 4829 29b8 6C00000A 		beq	.L543
 4830              	.L702:
 4831 29bc 850052E3 		cmp	r2, #133
 4832 29c0 0AFFFF1A 		bne	.L515
 4833              	.L552:
3134:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4834              		.loc 1 3134 0
 4835 29c4 1A20A0E3 		mov	r2, #26
3135:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4836              		.loc 1 3135 0
 4837 29c8 0030A0E3 		mov	r3, #0
3136:../uvc.c      ****                         break;
 4838              		.loc 1 3136 0
 4839 29cc 9C1B9FE5 		ldr	r1, .L740+112
 4840 29d0 0200A0E3 		mov	r0, #2
3134:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4841              		.loc 1 3134 0
 4842 29d4 9C20C9E5 		strb	r2, [r9, #156]
3135:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4843              		.loc 1 3135 0
 4844 29d8 9D30C9E5 		strb	r3, [r9, #157]
3136:../uvc.c      ****                         break;
 4845              		.loc 1 3136 0
 4846 29dc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4847              	.LVL530:
 4848 29e0 06FFFFEA 		b	.L528
 4849              	.L518:
2949:../uvc.c      ****             {
 4850              		.loc 1 2949 0
 4851 29e4 282B9FE5 		ldr	r2, .L740+20
 4852 29e8 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4853 29ec 830052E3 		cmp	r2, #131
 4854 29f0 7A00009A 		bls	.L720
 4855 29f4 860052E3 		cmp	r2, #134
 4856 29f8 0E00000A 		beq	.L696
 4857 29fc 870052E3 		cmp	r2, #135
 4858 2a00 EDFFFF1A 		bne	.L702
 4859              	.L556:
3217:../uvc.c      ****                         }
 4860              		.loc 1 3217 0
 4861 2a04 181B9FE5 		ldr	r1, .L740+36
 4862 2a08 1A00A0E3 		mov	r0, #26
 4863 2a0c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4864              	.LVL531:
 4865 2a10 FAFEFFEA 		b	.L528
 4866              	.L520:
3127:../uvc.c      ****                 {
 4867              		.loc 1 3127 0
 4868 2a14 F82A9FE5 		ldr	r2, .L740+20
 4869 2a18 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4870 2a1c 810052E3 		cmp	r2, #129
 4871 2a20 5200000A 		beq	.L543
 4872 2a24 D801009A 		bls	.L721
 4873 2a28 850052E3 		cmp	r2, #133
 4874 2a2c E4FFFF0A 		beq	.L552
 4875 2a30 860052E3 		cmp	r2, #134
 4876 2a34 EDFEFF1A 		bne	.L515
 4877              	.L696:
3131:../uvc.c      ****                         break;
 4878              		.loc 1 3131 0
 4879 2a38 0300A0E1 		mov	r0, r3
 4880 2a3c 2C1B9FE5 		ldr	r1, .L740+112
3130:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4881              		.loc 1 3130 0
 4882 2a40 0330A0E3 		mov	r3, #3
 4883 2a44 9C30C9E5 		strb	r3, [r9, #156]
3131:../uvc.c      ****                         break;
 4884              		.loc 1 3131 0
 4885 2a48 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4886              	.LVL532:
 4887 2a4c EBFEFFEA 		b	.L528
 4888              	.LVL533:
 4889              	.L270:
 4890              	.LBE130:
 4891              	.LBE441:
 4892              	.LBB442:
 4893              	.LBB345:
2551:../uvc.c      ****     {
 4894              		.loc 1 2551 0
 4895 2a50 010B52E3 		cmp	r2, #1024
 4896 2a54 E0FEFF0A 		beq	.L259
 4897 2a58 050C52E3 		cmp	r2, #1280
 4898 2a5c D4FEFF1A 		bne	.L280
 4899              	.LVL534:
2570:../uvc.c      ****       		break;
 4900              		.loc 1 2570 0
 4901 2a60 0400A0E3 		mov	r0, #4
 4902 2a64 FEFFFFEB 		bl	ControlHandle
 4903              	.LVL535:
 4904 2a68 48309DE5 		ldr	r3, [sp, #72]
 4905 2a6c DAFEFFEA 		b	.L259
 4906              	.L717:
2551:../uvc.c      ****     {
 4907              		.loc 1 2551 0
 4908 2a70 070C52E3 		cmp	r2, #1792
 4909 2a74 8D00000A 		beq	.L276
 4910 2a78 020B52E3 		cmp	r2, #2048
 4911 2a7c CCFEFF1A 		bne	.L280
 4912              	.LVL536:
2582:../uvc.c      ****           		break;
 4913              		.loc 1 2582 0
 4914 2a80 0700A0E3 		mov	r0, #7
 4915 2a84 FEFFFFEB 		bl	ControlHandle
 4916              	.LVL537:
 4917 2a88 48309DE5 		ldr	r3, [sp, #72]
 4918 2a8c D2FEFFEA 		b	.L259
 4919              	.L715:
 4920              	.LBE345:
 4921              	.LBE442:
 4922              	.LBB443:
 4923              	.LBB426:
2851:../uvc.c      ****     {
 4924              		.loc 1 2851 0
 4925 2a90 0B0C53E3 		cmp	r3, #2816
 4926 2a94 0FFFFF0A 		beq	.L448
 4927 2a98 0D0C53E3 		cmp	r3, #3328
 4928 2a9c 2F02000A 		beq	.L449
 4929 2aa0 0A0C53E3 		cmp	r3, #2560
 4930 2aa4 C7FEFF1A 		bne	.L260
 4931              	.LVL538:
2892:../uvc.c      ****     		}else/* no support for 1080p camera */
 4932              		.loc 1 2892 0
 4933 2aa8 1900A0E3 		mov	r0, #25
 4934 2aac FEFFFFEB 		bl	ControlHandle
 4935              	.LVL539:
 4936 2ab0 48309DE5 		ldr	r3, [sp, #72]
 4937 2ab4 C8FEFFEA 		b	.L259
 4938              	.L710:
2851:../uvc.c      ****     {
 4939              		.loc 1 2851 0
 4940 2ab8 020C53E3 		cmp	r3, #512
 4941 2abc 2F02000A 		beq	.L438
 4942 2ac0 030C53E3 		cmp	r3, #768
 4943 2ac4 2902000A 		beq	.L439
 4944 2ac8 010C53E3 		cmp	r3, #256
 4945 2acc BDFEFF1A 		bne	.L260
 4946              	.LVL540:
2855:../uvc.c      ****     		break;
 4947              		.loc 1 2855 0
 4948 2ad0 1000A0E3 		mov	r0, #16
 4949 2ad4 FEFFFFEB 		bl	ControlHandle
 4950              	.LVL541:
 4951 2ad8 48309DE5 		ldr	r3, [sp, #72]
 4952 2adc BEFEFFEA 		b	.L259
 4953              	.L706:
 4954              	.LBE426:
 4955              	.LBE443:
 4956              	.LBB444:
 4957              	.LBB329:
2626:../uvc.c      ****     {
 4958              		.loc 1 2626 0
 4959 2ae0 070C52E3 		cmp	r2, #1792
 4960 2ae4 5401000A 		beq	.L291
 4961 2ae8 020B52E3 		cmp	r2, #2048
 4962 2aec BAFEFF0A 		beq	.L259
 4963 2af0 AFFEFFEA 		b	.L280
 4964              	.L284:
 4965 2af4 010B52E3 		cmp	r2, #1024
 4966 2af8 E000000A 		beq	.L287
 4967 2afc 050C52E3 		cmp	r2, #1280
 4968 2b00 ABFEFF1A 		bne	.L280
 4969              	.LVL542:
 4970              	.LBB151:
 4971              	.LBB152:
 984:../uvc.c      **** 
 4972              		.loc 1 984 0
 4973 2b04 087A9FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4974              		.loc 1 979 0
 4975 2b08 F2C4DAE5 		ldrb	ip, [r10, #1266]	@ zero_extendqisi2
 4976              	.LVL543:
 984:../uvc.c      **** 
 4977              		.loc 1 984 0
 4978 2b0c 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 4979              	.LVL544:
 986:../uvc.c      **** 		 {
 4980              		.loc 1 986 0
 4981 2b10 830056E3 		cmp	r6, #131
 4982 2b14 5C06000A 		beq	.L349
 4983 2b18 AB02009A 		bls	.L722
 4984 2b1c 850056E3 		cmp	r6, #133
 4985 2b20 C401000A 		beq	.L411
 4986 2b24 2805003A 		bcc	.L355
 4987 2b28 860056E3 		cmp	r6, #134
 4988 2b2c DC05000A 		beq	.L356
 4989 2b30 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4990              		.loc 1 1048 0
 4991 2b34 FB14DA05 		ldreqb	r1, [r10, #1275]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4992              		.loc 1 1049 0
 4993 2b38 FC24DA05 		ldreqb	r2, [r10, #1276]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 4994              		.loc 1 986 0
 4995 2b3c 8405001A 		bne	.L348
 4996              	.LVL545:
 4997              	.L679:
 4998              	.LBE152:
 4999              	.LBE151:
 5000              	.LBB160:
 5001              	.LBB161:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5002              		.loc 1 1027 0
 5003 2b40 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5004              		.loc 1 1024 0
 5005 2b44 9C10C9E5 		strb	r1, [r9, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5006              		.loc 1 1029 0
 5007 2b48 0C00A0E1 		mov	r0, ip
 5008 2b4c 1C1A9FE5 		ldr	r1, .L740+112
 5009 2b50 1CC08DE5 		str	ip, [sp, #28]
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5010              		.loc 1 1025 0
 5011 2b54 9D20C9E5 		strb	r2, [r9, #157]
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5012              		.loc 1 1027 0
 5013 2b58 9E30C9E5 		strb	r3, [r9, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5014              		.loc 1 1028 0
 5015 2b5c 9F30C9E5 		strb	r3, [r9, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5016              		.loc 1 1029 0
 5017 2b60 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5018              	.LVL546:
1030:../uvc.c      **** 			  break;
 5019              		.loc 1 1030 0
 5020 2b64 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 5021              	.LVL547:
 5022 2b68 1CC09DE5 		ldr	ip, [sp, #28]
 5023 2b6c BA0100EA 		b	.L415
 5024              	.LVL548:
 5025              	.L543:
 5026              	.LBE161:
 5027              	.LBE160:
 5028              	.LBE329:
 5029              	.LBE444:
 5030              	.LBB445:
 5031              	.LBB131:
3092:../uvc.c      ****                         {
 5032              		.loc 1 3092 0
 5033 2b70 C030D9E5 		ldrb	r3, [r9, #192]	@ zero_extendqisi2
3094:../uvc.c      ****                         }
 5034              		.loc 1 3094 0
 5035 2b74 0B00A0E3 		mov	r0, #11
3092:../uvc.c      ****                         {
 5036              		.loc 1 3092 0
 5037 2b78 030053E3 		cmp	r3, #3
3094:../uvc.c      ****                         }
 5038              		.loc 1 3094 0
 5039 2b7c A4199F05 		ldreq	r1, .L740+40
3098:../uvc.c      ****                         }
 5040              		.loc 1 3098 0
 5041 2b80 A4199F15 		ldrne	r1, .L740+44
 5042 2b84 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5043              	.LVL549:
 5044 2b88 9CFEFFEA 		b	.L528
 5045              	.L719:
3077:../uvc.c      ****                 {
 5046              		.loc 1 3077 0
 5047 2b8c 810052E3 		cmp	r2, #129
 5048 2b90 F6FFFF2A 		bcs	.L543
 5049 2b94 010052E3 		cmp	r2, #1
 5050 2b98 94FEFF1A 		bne	.L515
3102:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5051              		.loc 1 3102 0
 5052 2b9c 2000A0E3 		mov	r0, #32
 5053 2ba0 88199FE5 		ldr	r1, .L740+48
 5054 2ba4 40208DE2 		add	r2, sp, #64
 5055 2ba8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5056              	.LVL550:
3104:../uvc.c      ****                         {
 5057              		.loc 1 3104 0
 5058 2bac 000050E3 		cmp	r0, #0
 5059 2bb0 92FEFF1A 		bne	.L528
3110:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5060              		.loc 1 3110 0
 5061 2bb4 C510D4E5 		ldrb	r1, [r4, #197]	@ zero_extendqisi2
3111:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 5062              		.loc 1 3111 0
 5063 2bb8 C6C0D4E5 		ldrb	ip, [r4, #198]	@ zero_extendqisi2
3117:../uvc.c      ****                         }
 5064              		.loc 1 3117 0
 5065 2bbc C430D4E5 		ldrb	r3, [r4, #196]	@ zero_extendqisi2
3110:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5066              		.loc 1 3110 0
 5067 2bc0 2D16CAE5 		strb	r1, [r10, #1581]
3117:../uvc.c      ****                         }
 5068              		.loc 1 3117 0
 5069 2bc4 00108DE5 		str	r1, [sp]
 5070 2bc8 B024DDE1 		ldrh	r2, [sp, #64]
 5071 2bcc 60199FE5 		ldr	r1, .L740+52
 5072 2bd0 0400A0E3 		mov	r0, #4
 5073              	.LVL551:
3111:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 5074              		.loc 1 3111 0
 5075 2bd4 2EC6CAE5 		strb	ip, [r10, #1582]
3117:../uvc.c      ****                         }
 5076              		.loc 1 3117 0
 5077 2bd8 FEFFFFEB 		bl	CyU3PDebugPrint
 5078              	.LVL552:
 5079 2bdc 87FEFFEA 		b	.L528
 5080              	.LVL553:
 5081              	.L720:
2949:../uvc.c      ****             {
 5082              		.loc 1 2949 0
 5083 2be0 810052E3 		cmp	r2, #129
 5084 2be4 86FFFF2A 		bcs	.L556
 5085 2be8 010052E3 		cmp	r2, #1
 5086 2bec 7FFEFF1A 		bne	.L515
2974:../uvc.c      ****                             glCommitCtrl, &readCount);
 5087              		.loc 1 2974 0
 5088 2bf0 2000A0E3 		mov	r0, #32
 5089 2bf4 34199FE5 		ldr	r1, .L740+48
 5090 2bf8 40208DE2 		add	r2, sp, #64
 5091 2bfc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5092              	.LVL554:
2976:../uvc.c      ****                     {
 5093              		.loc 1 2976 0
 5094 2c00 000050E3 		cmp	r0, #0
 5095 2c04 7DFEFF1A 		bne	.L528
2984:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 5096              		.loc 1 2984 0
 5097 2c08 C8E0D4E5 		ldrb	lr, [r4, #200]	@ zero_extendqisi2
2986:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 5098              		.loc 1 2986 0
 5099 2c0c CA00D4E5 		ldrb	r0, [r4, #202]	@ zero_extendqisi2
 5100              	.LVL555:
2987:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
 5101              		.loc 1 2987 0
 5102 2c10 CB10D4E5 		ldrb	r1, [r4, #203]	@ zero_extendqisi2
2983:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 5103              		.loc 1 2983 0
 5104 2c14 C760D4E5 		ldrb	r6, [r4, #199]	@ zero_extendqisi2
2985:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 5105              		.loc 1 2985 0
 5106 2c18 C9C0D4E5 		ldrb	ip, [r4, #201]	@ zero_extendqisi2
2988:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5107              		.loc 1 2988 0
 5108 2c1c C430D4E5 		ldrb	r3, [r4, #196]	@ zero_extendqisi2
2984:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 5109              		.loc 1 2984 0
 5110 2c20 14E6CAE5 		strb	lr, [r10, #1556]
2988:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5111              		.loc 1 2988 0
 5112 2c24 0C008DE5 		str	r0, [sp, #12]
 5113 2c28 10108DE5 		str	r1, [sp, #16]
 5114 2c2c 40408DE8 		stmia	sp, {r6, lr}
 5115 2c30 B024DDE1 		ldrh	r2, [sp, #64]
 5116 2c34 08C08DE5 		str	ip, [sp, #8]
2982:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 5117              		.loc 1 2982 0
 5118 2c38 C6E0D4E5 		ldrb	lr, [r4, #198]	@ zero_extendqisi2
2986:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 5119              		.loc 1 2986 0
 5120 2c3c 1606CAE5 		strb	r0, [r10, #1558]
2987:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
 5121              		.loc 1 2987 0
 5122 2c40 1716CAE5 		strb	r1, [r10, #1559]
2988:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5123              		.loc 1 2988 0
 5124 2c44 0400A0E3 		mov	r0, #4
 5125 2c48 E8189FE5 		ldr	r1, .L740+56
2983:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 5126              		.loc 1 2983 0
 5127 2c4c 1366CAE5 		strb	r6, [r10, #1555]
2985:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 5128              		.loc 1 2985 0
 5129 2c50 15C6CAE5 		strb	ip, [r10, #1557]
2982:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 5130              		.loc 1 2982 0
 5131 2c54 12E6CAE5 		strb	lr, [r10, #1554]
2988:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5132              		.loc 1 2988 0
 5133 2c58 FEFFFFEB 		bl	CyU3PDebugPrint
 5134              	.LVL556:
 5135 2c5c 67FEFFEA 		b	.L528
 5136              	.L267:
 5137              	.LVL557:
 5138              	.LBE131:
 5139              	.LBE445:
 5140              	.LBB446:
 5141              	.LBB346:
2574:../uvc.c      ****      		break;
 5142              		.loc 1 2574 0
 5143 2c60 0500A0E3 		mov	r0, #5
 5144 2c64 FEFFFFEB 		bl	ControlHandle
 5145              	.LVL558:
 5146 2c68 48309DE5 		ldr	r3, [sp, #72]
 5147 2c6c 5AFEFFEA 		b	.L259
 5148              	.L271:
 5149              	.LVL559:
2555:../uvc.c      ****     		break;
 5150              		.loc 1 2555 0
 5151 2c70 0000A0E3 		mov	r0, #0
 5152 2c74 FEFFFFEB 		bl	ControlHandle
 5153              	.LVL560:
 5154 2c78 48309DE5 		ldr	r3, [sp, #72]
 5155 2c7c 56FEFFEA 		b	.L259
 5156              	.L269:
 5157              	.LVL561:
2563:../uvc.c      **** 			break;
 5158              		.loc 1 2563 0
 5159 2c80 0200A0E3 		mov	r0, #2
 5160 2c84 FEFFFFEB 		bl	ControlHandle
 5161              	.LVL562:
 5162 2c88 48309DE5 		ldr	r3, [sp, #72]
 5163 2c8c 52FEFFEA 		b	.L259
 5164              	.L274:
 5165              	.LVL563:
2588:../uvc.c      ****     		break;
 5166              		.loc 1 2588 0
 5167 2c90 0900A0E3 		mov	r0, #9
 5168 2c94 FEFFFFEB 		bl	ControlHandle
 5169              	.LVL564:
 5170 2c98 48309DE5 		ldr	r3, [sp, #72]
 5171 2c9c 4EFEFFEA 		b	.L259
 5172              	.L278:
 5173              	.LVL565:
2596:../uvc.c      ****     		break;
 5174              		.loc 1 2596 0
 5175 2ca0 0E00A0E3 		mov	r0, #14
 5176 2ca4 FEFFFFEB 		bl	ControlHandle
 5177              	.LVL566:
 5178 2ca8 48309DE5 		ldr	r3, [sp, #72]
 5179 2cac 4AFEFFEA 		b	.L259
 5180              	.L276:
 5181              	.LVL567:
2578:../uvc.c      ****           		break;
 5182              		.loc 1 2578 0
 5183 2cb0 0600A0E3 		mov	r0, #6
 5184 2cb4 FEFFFFEB 		bl	ControlHandle
 5185              	.LVL568:
 5186 2cb8 48309DE5 		ldr	r3, [sp, #72]
 5187 2cbc 46FEFFEA 		b	.L259
 5188              	.L707:
 5189              	.LVL569:
 5190              	.LBE346:
 5191              	.LBE446:
 5192              	.LBB447:
 5193              	.LBB330:
 5194              	.LBB171:
 5195              	.LBB172:
 984:../uvc.c      **** 
 5196              		.loc 1 984 0
 5197 2cc0 4C789FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5198              		.loc 1 979 0
 5199 2cc4 52C5DAE5 		ldrb	ip, [r10, #1362]	@ zero_extendqisi2
 5200              	.LVL570:
 984:../uvc.c      **** 
 5201              		.loc 1 984 0
 5202 2cc8 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 5203              	.LVL571:
 986:../uvc.c      **** 		 {
 5204              		.loc 1 986 0
 5205 2ccc 830056E3 		cmp	r6, #131
 5206 2cd0 F105000A 		beq	.L395
 5207 2cd4 E101009A 		bls	.L723
 5208 2cd8 850056E3 		cmp	r6, #133
 5209 2cdc 5501000A 		beq	.L411
 5210 2ce0 8F04003A 		bcc	.L401
 5211 2ce4 860056E3 		cmp	r6, #134
 5212 2ce8 6B05000A 		beq	.L402
 5213 2cec 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5214              		.loc 1 1048 0
 5215 2cf0 5B15DA05 		ldreqb	r1, [r10, #1371]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5216              		.loc 1 1049 0
 5217 2cf4 5C25DA05 		ldreqb	r2, [r10, #1372]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5218              		.loc 1 986 0
 5219 2cf8 90FFFF0A 		beq	.L679
 5220              	.L394:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5221              		.loc 1 1193 0
 5222 2cfc 0000A0E3 		mov	r0, #0
 5223 2d00 0020A0E1 		mov	r2, r0
 5224 2d04 0110A0E3 		mov	r1, #1
 5225 2d08 1CC08DE5 		str	ip, [sp, #28]
 5226 2d0c FEFFFFEB 		bl	CyU3PUsbStall
 5227              	.LVL572:
1194:../uvc.c      **** 			  break;
 5228              		.loc 1 1194 0
 5229 2d10 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 5230 2d14 0400A0E3 		mov	r0, #4
 5231 2d18 48189FE5 		ldr	r1, .L740+104
 5232 2d1c 0820A0E3 		mov	r2, #8
 5233 2d20 FEFFFFEB 		bl	CyU3PDebugPrint
 5234              	.LVL573:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5235              		.loc 1 980 0
 5236 2d24 FF70A0E3 		mov	r7, #255
 5237 2d28 1CC09DE5 		ldr	ip, [sp, #28]
 5238              	.LVL574:
 5239 2d2c 4A0100EA 		b	.L415
 5240              	.LVL575:
 5241              	.L293:
 5242              	.LBE172:
 5243              	.LBE171:
 5244              	.LBB178:
 5245              	.LBB179:
 984:../uvc.c      **** 
 5246              		.loc 1 984 0
 5247 2d30 DC779FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5248              		.loc 1 979 0
 5249 2d34 82E5DAE5 		ldrb	lr, [r10, #1410]	@ zero_extendqisi2
 984:../uvc.c      **** 
 5250              		.loc 1 984 0
 5251 2d38 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5252              		.loc 1 976 0
 5253 2d3c 8FC5DAE5 		ldrb	ip, [r10, #1423]	@ zero_extendqisi2
 5254              	.LVL576:
 986:../uvc.c      **** 		 {
 5255              		.loc 1 986 0
 5256 2d40 830056E3 		cmp	r6, #131
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5257              		.loc 1 977 0
 5258 2d44 8035DAE5 		ldrb	r3, [r10, #1408]	@ zero_extendqisi2
 5259              	.LVL577:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5260              		.loc 1 979 0
 5261 2d48 28E08DE5 		str	lr, [sp, #40]
 5262              	.LVL578:
 986:../uvc.c      **** 		 {
 5263              		.loc 1 986 0
 5264 2d4c BF05000A 		beq	.L417
 5265 2d50 4602009A 		bls	.L724
 5266 2d54 850056E3 		cmp	r6, #133
 5267 2d58 C005000A 		beq	.L422
 5268 2d5c 4104003A 		bcc	.L423
 5269 2d60 860056E3 		cmp	r6, #134
 5270 2d64 3605000A 		beq	.L424
 5271 2d68 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5272              		.loc 1 1048 0
 5273 2d6c 8B05DA05 		ldreqb	r0, [r10, #1419]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5274              		.loc 1 1049 0
 5275 2d70 8C15DA05 		ldreqb	r1, [r10, #1420]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5276              		.loc 1 986 0
 5277 2d74 DC04001A 		bne	.L416
 5278              	.L681:
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5279              		.loc 1 1028 0
 5280 2d78 0030A0E3 		mov	r3, #0
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5281              		.loc 1 1026 0
 5282 2d7c 0120A0E3 		mov	r2, #1
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5283              		.loc 1 1024 0
 5284 2d80 9C00C9E5 		strb	r0, [r9, #156]
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5285              		.loc 1 1025 0
 5286 2d84 9D10C9E5 		strb	r1, [r9, #157]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5287              		.loc 1 1029 0
 5288 2d88 28009DE5 		ldr	r0, [sp, #40]
 5289 2d8c DC179FE5 		ldr	r1, .L740+112
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5290              		.loc 1 1028 0
 5291 2d90 9F30C9E5 		strb	r3, [r9, #159]
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5292              		.loc 1 1026 0
 5293 2d94 9E20C9E5 		strb	r2, [r9, #158]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5294              		.loc 1 1029 0
 5295 2d98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5296              	.LVL579:
1030:../uvc.c      **** 			  break;
 5297              		.loc 1 1030 0
 5298 2d9c 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 5299              	.LVL580:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5300              		.loc 1 980 0
 5301 2da0 FF70A0E3 		mov	r7, #255
 5302 2da4 2C708DE5 		str	r7, [sp, #44]
 5303              	.LVL581:
 5304              	.L426:
1199:../uvc.c      **** }
 5305              		.loc 1 1199 0
 5306 2da8 00708DE5 		str	r7, [sp]
 5307 2dac 28709DE5 		ldr	r7, [sp, #40]
 5308              	.LVL582:
 5309 2db0 08308DE5 		str	r3, [sp, #8]
 5310 2db4 9E10D9E5 		ldrb	r1, [r9, #158]	@ zero_extendqisi2
 5311 2db8 FF00A0E3 		mov	r0, #255
 5312 2dbc 14708DE5 		str	r7, [sp, #20]
 5313 2dc0 0620A0E1 		mov	r2, r6
 5314 2dc4 2C309DE5 		ldr	r3, [sp, #44]
 5315              	.LVL583:
 5316 2dc8 520000EA 		b	.L693
 5317              	.LVL584:
 5318              	.L292:
 5319              	.LBE179:
 5320              	.LBE178:
 5321              	.LBB189:
 5322              	.LBB162:
 984:../uvc.c      **** 
 5323              		.loc 1 984 0
 5324 2dcc 40779FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5325              		.loc 1 979 0
 5326 2dd0 6AC5DAE5 		ldrb	ip, [r10, #1386]	@ zero_extendqisi2
 5327              	.LVL585:
 984:../uvc.c      **** 
 5328              		.loc 1 984 0
 5329 2dd4 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 5330              	.LVL586:
 986:../uvc.c      **** 		 {
 5331              		.loc 1 986 0
 5332 2dd8 830056E3 		cmp	r6, #131
 5333 2ddc 9705000A 		beq	.L406
 5334 2de0 B201009A 		bls	.L725
 5335 2de4 850056E3 		cmp	r6, #133
 5336 2de8 1201000A 		beq	.L411
 5337 2dec 4004003A 		bcc	.L412
 5338 2df0 860056E3 		cmp	r6, #134
 5339 2df4 6605000A 		beq	.L413
 5340 2df8 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5341              		.loc 1 1048 0
 5342 2dfc 7315DA05 		ldreqb	r1, [r10, #1395]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5343              		.loc 1 1049 0
 5344 2e00 7425DA05 		ldreqb	r2, [r10, #1396]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5345              		.loc 1 986 0
 5346 2e04 4DFFFF0A 		beq	.L679
 5347              	.L405:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5348              		.loc 1 1193 0
 5349 2e08 0000A0E3 		mov	r0, #0
 5350 2e0c 0020A0E1 		mov	r2, r0
 5351 2e10 0110A0E3 		mov	r1, #1
 5352 2e14 1CC08DE5 		str	ip, [sp, #28]
 5353 2e18 FEFFFFEB 		bl	CyU3PUsbStall
 5354              	.LVL587:
1194:../uvc.c      **** 			  break;
 5355              		.loc 1 1194 0
 5356 2e1c 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 5357 2e20 0400A0E3 		mov	r0, #4
 5358 2e24 3C179FE5 		ldr	r1, .L740+104
 5359 2e28 0920A0E3 		mov	r2, #9
 5360 2e2c FEFFFFEB 		bl	CyU3PDebugPrint
 5361              	.LVL588:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5362              		.loc 1 980 0
 5363 2e30 FF70A0E3 		mov	r7, #255
 5364 2e34 1CC09DE5 		ldr	ip, [sp, #28]
 5365 2e38 070100EA 		b	.L415
 5366              	.LVL589:
 5367              	.L281:
 5368              	.LBE162:
 5369              	.LBE189:
 5370              	.LBB190:
 5371              	.LBB191:
 984:../uvc.c      **** 
 5372              		.loc 1 984 0
 5373 2e3c D0769FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5374              		.loc 1 979 0
 5375 2e40 0AC5DAE5 		ldrb	ip, [r10, #1290]	@ zero_extendqisi2
 5376              	.LVL590:
 984:../uvc.c      **** 
 5377              		.loc 1 984 0
 5378 2e44 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 5379              	.LVL591:
 986:../uvc.c      **** 		 {
 5380              		.loc 1 986 0
 5381 2e48 830056E3 		cmp	r6, #131
 5382 2e4c 9A05000A 		beq	.L360
 5383 2e50 F101009A 		bls	.L726
 5384 2e54 850056E3 		cmp	r6, #133
 5385 2e58 F600000A 		beq	.L411
 5386 2e5c 2C04003A 		bcc	.L366
 5387 2e60 860056E3 		cmp	r6, #134
 5388 2e64 0105000A 		beq	.L367
 5389 2e68 870056E3 		cmp	r6, #135
 5390 2e6c 9104001A 		bne	.L359
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5391              		.loc 1 1048 0
 5392 2e70 8CE69FE5 		ldr	lr, .L740+4
 5393 2e74 1315DEE5 		ldrb	r1, [lr, #1299]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5394              		.loc 1 1049 0
 5395 2e78 1425DEE5 		ldrb	r2, [lr, #1300]	@ zero_extendqisi2
 5396 2e7c 2FFFFFEA 		b	.L679
 5397              	.LVL592:
 5398              	.L287:
 5399              	.LBE191:
 5400              	.LBE190:
 5401              	.LBB199:
 5402              	.LBB200:
 984:../uvc.c      **** 
 5403              		.loc 1 984 0
 5404 2e80 8C769FE5 		ldr	r7, .L740+20
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5405              		.loc 1 976 0
 5406 2e84 E734DAE5 		ldrb	r3, [r10, #1255]	@ zero_extendqisi2
 984:../uvc.c      **** 
 5407              		.loc 1 984 0
 5408 2e88 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5409              		.loc 1 976 0
 5410 2e8c 2C308DE5 		str	r3, [sp, #44]
 5411              	.LVL593:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5412              		.loc 1 979 0
 5413 2e90 DAE4DAE5 		ldrb	lr, [r10, #1242]	@ zero_extendqisi2
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5414              		.loc 1 977 0
 5415 2e94 D834DAE5 		ldrb	r3, [r10, #1240]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5416              		.loc 1 986 0
 5417 2e98 830056E3 		cmp	r6, #131
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5418              		.loc 1 977 0
 5419 2e9c 30308DE5 		str	r3, [sp, #48]
 5420              	.LVL594:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5421              		.loc 1 979 0
 5422 2ea0 28E08DE5 		str	lr, [sp, #40]
 5423              	.LVL595:
 986:../uvc.c      **** 		 {
 5424              		.loc 1 986 0
 5425 2ea4 8005000A 		beq	.L334
 5426 2ea8 4E02009A 		bls	.L727
 5427 2eac 850056E3 		cmp	r6, #133
 5428 2eb0 B003000A 		beq	.L387
 5429 2eb4 EE03003A 		bcc	.L340
 5430 2eb8 860056E3 		cmp	r6, #134
 5431 2ebc 4805000A 		beq	.L341
 5432 2ec0 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5433              		.loc 1 1048 0
 5434 2ec4 E314DA05 		ldreqb	r1, [r10, #1251]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5435              		.loc 1 1049 0
 5436 2ec8 E424DA05 		ldreqb	r2, [r10, #1252]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5437              		.loc 1 986 0
 5438 2ecc C704001A 		bne	.L333
 5439              	.LVL596:
 5440              	.L677:
 5441              	.LBE200:
 5442              	.LBE199:
 5443              	.LBB209:
 5444              	.LBB210:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5445              		.loc 1 1027 0
 5446 2ed0 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5447              		.loc 1 1024 0
 5448 2ed4 9C10C9E5 		strb	r1, [r9, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5449              		.loc 1 1029 0
 5450 2ed8 28009DE5 		ldr	r0, [sp, #40]
 5451 2edc 8C169FE5 		ldr	r1, .L740+112
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5452              		.loc 1 1025 0
 5453 2ee0 9D20C9E5 		strb	r2, [r9, #157]
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5454              		.loc 1 1027 0
 5455 2ee4 9E30C9E5 		strb	r3, [r9, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5456              		.loc 1 1028 0
 5457 2ee8 9F30C9E5 		strb	r3, [r9, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5458              		.loc 1 1029 0
 5459 2eec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5460              	.LVL597:
1030:../uvc.c      **** 			  break;
 5461              		.loc 1 1030 0
 5462 2ef0 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 5463              	.LVL598:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5464              		.loc 1 980 0
 5465 2ef4 FF20A0E3 		mov	r2, #255
 5466 2ef8 0230A0E1 		mov	r3, r2
 5467              	.LVL599:
 5468              	.L391:
1199:../uvc.c      **** }
 5469              		.loc 1 1199 0
 5470 2efc 08708DE5 		str	r7, [sp, #8]
 5471 2f00 9E10D9E5 		ldrb	r1, [r9, #158]	@ zero_extendqisi2
 5472 2f04 28709DE5 		ldr	r7, [sp, #40]
 5473              	.LVL600:
 5474 2f08 00208DE5 		str	r2, [sp]
 5475 2f0c FF00A0E3 		mov	r0, #255
 5476 2f10 0620A0E1 		mov	r2, r6
 5477              	.LVL601:
 5478 2f14 14708DE5 		str	r7, [sp, #20]
 5479              	.LVL602:
 5480              	.L693:
 5481              	.LBE210:
 5482              	.LBE209:
 5483              	.LBB221:
 5484              	.LBB180:
 5485 2f18 04108DE5 		str	r1, [sp, #4]
 5486 2f1c 10108DE5 		str	r1, [sp, #16]
 5487 2f20 0C008DE5 		str	r0, [sp, #12]
 5488 2f24 F4159FE5 		ldr	r1, .L740+32
 5489 2f28 0400A0E3 		mov	r0, #4
 5490 2f2c FEFFFFEB 		bl	CyU3PDebugPrint
 5491              	.LVL603:
 5492 2f30 48309DE5 		ldr	r3, [sp, #72]
 5493 2f34 A8FDFFEA 		b	.L259
 5494              	.L285:
 5495              	.LVL604:
 5496              	.LBE180:
 5497              	.LBE221:
 5498              	.LBB222:
 5499              	.LBB223:
 984:../uvc.c      **** 
 5500              		.loc 1 984 0
 5501 2f38 D4759FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5502              		.loc 1 979 0
 5503 2f3c 92C4DAE5 		ldrb	ip, [r10, #1170]	@ zero_extendqisi2
 5504              	.LVL605:
 984:../uvc.c      **** 
 5505              		.loc 1 984 0
 5506 2f40 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 5507              	.LVL606:
 986:../uvc.c      **** 		 {
 5508              		.loc 1 986 0
 5509 2f44 830056E3 		cmp	r6, #131
 5510 2f48 5F05000A 		beq	.L296
 5511 2f4c 8A01009A 		bls	.L728
 5512 2f50 850056E3 		cmp	r6, #133
 5513 2f54 B700000A 		beq	.L411
 5514 2f58 B303003A 		bcc	.L302
 5515 2f5c 860056E3 		cmp	r6, #134
 5516 2f60 ED04000A 		beq	.L303
 5517 2f64 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5518              		.loc 1 1048 0
 5519 2f68 9B14DA05 		ldreqb	r1, [r10, #1179]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5520              		.loc 1 1049 0
 5521 2f6c 9C24DA05 		ldreqb	r2, [r10, #1180]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5522              		.loc 1 986 0
 5523 2f70 F2FEFF0A 		beq	.L679
 5524              	.L295:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5525              		.loc 1 1193 0
 5526 2f74 0000A0E3 		mov	r0, #0
 5527 2f78 0020A0E1 		mov	r2, r0
 5528 2f7c 0110A0E3 		mov	r1, #1
 5529 2f80 1CC08DE5 		str	ip, [sp, #28]
 5530 2f84 FEFFFFEB 		bl	CyU3PUsbStall
 5531              	.LVL607:
1194:../uvc.c      **** 			  break;
 5532              		.loc 1 1194 0
 5533 2f88 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 5534 2f8c 0400A0E3 		mov	r0, #4
 5535 2f90 D0159FE5 		ldr	r1, .L740+104
 5536 2f94 0020A0E3 		mov	r2, #0
 5537 2f98 FEFFFFEB 		bl	CyU3PDebugPrint
 5538              	.LVL608:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5539              		.loc 1 980 0
 5540 2f9c FF70A0E3 		mov	r7, #255
 5541 2fa0 1CC09DE5 		ldr	ip, [sp, #28]
 5542              	.LVL609:
 5543 2fa4 AC0000EA 		b	.L415
 5544              	.LVL610:
 5545              	.L289:
 5546              	.LBE223:
 5547              	.LBE222:
 5548              	.LBB230:
 5549              	.LBB211:
 984:../uvc.c      **** 
 5550              		.loc 1 984 0
 5551 2fa8 64759FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5552              		.loc 1 979 0
 5553 2fac 3AE5DAE5 		ldrb	lr, [r10, #1338]	@ zero_extendqisi2
 984:../uvc.c      **** 
 5554              		.loc 1 984 0
 5555 2fb0 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5556              		.loc 1 976 0
 5557 2fb4 47C5DAE5 		ldrb	ip, [r10, #1351]	@ zero_extendqisi2
 5558              	.LVL611:
 986:../uvc.c      **** 		 {
 5559              		.loc 1 986 0
 5560 2fb8 830056E3 		cmp	r6, #131
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5561              		.loc 1 977 0
 5562 2fbc 3835DAE5 		ldrb	r3, [r10, #1336]	@ zero_extendqisi2
 5563              	.LVL612:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5564              		.loc 1 979 0
 5565 2fc0 28E08DE5 		str	lr, [sp, #40]
 5566              	.LVL613:
 986:../uvc.c      **** 		 {
 5567              		.loc 1 986 0
 5568 2fc4 4405000A 		beq	.L382
 5569 2fc8 4C02009A 		bls	.L729
 5570 2fcc 850056E3 		cmp	r6, #133
 5571 2fd0 6803000A 		beq	.L387
 5572 2fd4 9803003A 		bcc	.L388
 5573 2fd8 860056E3 		cmp	r6, #134
 5574 2fdc C204000A 		beq	.L389
 5575 2fe0 870056E3 		cmp	r6, #135
 5576 2fe4 7404001A 		bne	.L381
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5577              		.loc 1 1048 0
 5578 2fe8 14259FE5 		ldr	r2, .L740+4
 5579 2fec 4315D2E5 		ldrb	r1, [r2, #1347]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5580              		.loc 1 1049 0
 5581 2ff0 4425D2E5 		ldrb	r2, [r2, #1348]	@ zero_extendqisi2
 5582 2ff4 B5FFFFEA 		b	.L677
 5583              	.LVL614:
 5584              	.L283:
 5585              	.LBE211:
 5586              	.LBE230:
 5587              	.LBB231:
 5588              	.LBB232:
 984:../uvc.c      **** 
 5589              		.loc 1 984 0
 5590 2ff8 14759FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5591              		.loc 1 979 0
 5592 2ffc C2C4DAE5 		ldrb	ip, [r10, #1218]	@ zero_extendqisi2
 5593              	.LVL615:
 984:../uvc.c      **** 
 5594              		.loc 1 984 0
 5595 3000 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 5596              	.LVL616:
 986:../uvc.c      **** 		 {
 5597              		.loc 1 986 0
 5598 3004 830056E3 		cmp	r6, #131
 5599 3008 3705000A 		beq	.L323
 5600 300c 6C02009A 		bls	.L730
 5601 3010 850056E3 		cmp	r6, #133
 5602 3014 8700000A 		beq	.L411
 5603 3018 8B03003A 		bcc	.L329
 5604 301c 860056E3 		cmp	r6, #134
 5605 3020 BF04000A 		beq	.L330
 5606 3024 870056E3 		cmp	r6, #135
 5607 3028 5604001A 		bne	.L322
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5608              		.loc 1 1048 0
 5609 302c D0249FE5 		ldr	r2, .L740+4
 5610 3030 CB14D2E5 		ldrb	r1, [r2, #1227]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5611              		.loc 1 1049 0
 5612 3034 CC24D2E5 		ldrb	r2, [r2, #1228]	@ zero_extendqisi2
 5613 3038 C0FEFFEA 		b	.L679
 5614              	.LVL617:
 5615              	.L291:
 5616              	.LBE232:
 5617              	.LBE231:
 5618              	.LBB240:
 5619              	.LBB241:
 984:../uvc.c      **** 
 5620              		.loc 1 984 0
 5621 303c D0749FE5 		ldr	r7, .L740+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5622              		.loc 1 979 0
 5623 3040 22C5DAE5 		ldrb	ip, [r10, #1314]	@ zero_extendqisi2
 5624              	.LVL618:
 984:../uvc.c      **** 
 5625              		.loc 1 984 0
 5626 3044 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 5627              	.LVL619:
 986:../uvc.c      **** 		 {
 5628              		.loc 1 986 0
 5629 3048 830056E3 		cmp	r6, #131
 5630 304c F704000A 		beq	.L371
 5631 3050 B501009A 		bls	.L731
 5632 3054 850056E3 		cmp	r6, #133
 5633 3058 7600000A 		beq	.L411
 5634 305c A803003A 		bcc	.L377
 5635 3060 860056E3 		cmp	r6, #134
 5636 3064 8A04000A 		beq	.L378
 5637 3068 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5638              		.loc 1 1048 0
 5639 306c 2B15DA05 		ldreqb	r1, [r10, #1323]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5640              		.loc 1 1049 0
 5641 3070 2C25DA05 		ldreqb	r2, [r10, #1324]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5642              		.loc 1 986 0
 5643 3074 B1FEFF0A 		beq	.L679
 5644              	.L370:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5645              		.loc 1 1193 0
 5646 3078 0000A0E3 		mov	r0, #0
 5647 307c 0020A0E1 		mov	r2, r0
 5648 3080 0110A0E3 		mov	r1, #1
 5649 3084 1CC08DE5 		str	ip, [sp, #28]
 5650 3088 FEFFFFEB 		bl	CyU3PUsbStall
 5651              	.LVL620:
1194:../uvc.c      **** 			  break;
 5652              		.loc 1 1194 0
 5653 308c 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 5654 3090 0400A0E3 		mov	r0, #4
 5655 3094 CC149FE5 		ldr	r1, .L740+104
 5656 3098 0620A0E3 		mov	r2, #6
 5657 309c FEFFFFEB 		bl	CyU3PDebugPrint
 5658              	.LVL621:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5659              		.loc 1 980 0
 5660 30a0 FF70A0E3 		mov	r7, #255
 5661 30a4 1CC09DE5 		ldr	ip, [sp, #28]
 5662              	.LVL622:
 5663 30a8 6B0000EA 		b	.L415
 5664              	.LVL623:
 5665              	.L714:
 5666              	.LBE241:
 5667              	.LBE240:
 5668              	.LBE330:
 5669              	.LBE447:
 5670              	.LBB448:
 5671              	.LBB132:
3203:../uvc.c      ****                 {
 5672              		.loc 1 3203 0
 5673 30ac 010052E3 		cmp	r2, #1
 5674 30b0 4EFDFF1A 		bne	.L515
3228:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5675              		.loc 1 3228 0
 5676 30b4 2000A0E3 		mov	r0, #32
 5677 30b8 70149FE5 		ldr	r1, .L740+48
 5678 30bc 40208DE2 		add	r2, sp, #64
 5679 30c0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5680              	.LVL624:
3230:../uvc.c      ****                         {
 5681              		.loc 1 3230 0
 5682 30c4 000050E3 		cmp	r0, #0
 5683 30c8 1903001A 		bne	.L561
3234:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5684              		.loc 1 3234 0
 5685 30cc 0020A0E3 		mov	r2, #0
 5686 30d0 28049FE5 		ldr	r0, .L740
 5687              	.LVL625:
 5688 30d4 8010A0E3 		mov	r1, #128
 5689 30d8 FEFFFFEB 		bl	_txe_event_flags_set
 5690              	.LVL626:
3235:../uvc.c      ****                             {
 5691              		.loc 1 3235 0
 5692 30dc 002050E2 		subs	r2, r0, #0
3241:../uvc.c      ****                             //stillcont = 0;
 5693              		.loc 1 3241 0
 5694 30e0 F030A003 		moveq	r3, #240
 5695 30e4 74308405 		streq	r3, [r4, #116]
3235:../uvc.c      ****                             {
 5696              		.loc 1 3235 0
 5697 30e8 6F04001A 		bne	.L732
 5698              	.LVL627:
 5699              	.L563:
3244:../uvc.c      ****                         }else{
 5700              		.loc 1 3244 0
 5701 30ec C510D9E5 		ldrb	r1, [r9, #197]	@ zero_extendqisi2
 5702 30f0 B024DDE1 		ldrh	r2, [sp, #64]
 5703 30f4 00108DE5 		str	r1, [sp]
 5704 30f8 C430D9E5 		ldrb	r3, [r9, #196]	@ zero_extendqisi2
 5705 30fc 38149FE5 		ldr	r1, .L740+60
 5706 3100 0400A0E3 		mov	r0, #4
 5707 3104 FEFFFFEB 		bl	CyU3PDebugPrint
 5708              	.LVL628:
 5709 3108 3CFDFFEA 		b	.L528
 5710              	.LVL629:
 5711              	.L713:
3000:../uvc.c      ****             {
 5712              		.loc 1 3000 0
 5713 310c 010053E3 		cmp	r3, #1
 5714 3110 36FDFF1A 		bne	.L515
3025:../uvc.c      ****                             glCommitCtrl, &readCount);
 5715              		.loc 1 3025 0
 5716 3114 2000A0E3 		mov	r0, #32
 5717 3118 10149FE5 		ldr	r1, .L740+48
 5718 311c 40208DE2 		add	r2, sp, #64
 5719 3120 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5720              	.LVL630:
3027:../uvc.c      ****                     {
 5721              		.loc 1 3027 0
 5722 3124 000050E3 		cmp	r0, #0
 5723 3128 34FDFF1A 		bne	.L528
3029:../uvc.c      ****                         {
 5724              		.loc 1 3029 0
 5725 312c C760D9E5 		ldrb	r6, [r9, #199]	@ zero_extendqisi2
 5726 3130 E430D9E5 		ldrb	r3, [r9, #228]	@ zero_extendqisi2
 5727 3134 060053E1 		cmp	r3, r6
 5728 3138 0500000A 		beq	.L537
3031:../uvc.c      ****                          {
 5729              		.loc 1 3031 0
 5730 313c 010056E3 		cmp	r6, #1
 5731 3140 F104000A 		beq	.L539
 5732 3144 020056E3 		cmp	r6, #2
 5733 3148 A603000A 		beq	.L540
 5734              	.LVL631:
 5735              	.L538:
3046:../uvc.c      ****                         }
 5736              		.loc 1 3046 0
 5737 314c C730D9E5 		ldrb	r3, [r9, #199]	@ zero_extendqisi2
 5738 3150 E430C9E5 		strb	r3, [r9, #228]
 5739              	.L537:
3048:../uvc.c      **** 
 5740              		.loc 1 3048 0
 5741 3154 E4139FE5 		ldr	r1, .L740+64
 5742 3158 E420D9E5 		ldrb	r2, [r9, #228]	@ zero_extendqisi2
 5743 315c 0400A0E3 		mov	r0, #4
 5744 3160 FEFFFFEB 		bl	CyU3PDebugPrint
 5745              	.LVL632:
3061:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5746              		.loc 1 3061 0
 5747 3164 0020A0E3 		mov	r2, #0
 5748 3168 90039FE5 		ldr	r0, .L740
 5749 316c 0110A0E3 		mov	r1, #1
 5750 3170 FEFFFFEB 		bl	_txe_event_flags_set
 5751              	.LVL633:
3062:../uvc.c      ****                         {
 5752              		.loc 1 3062 0
 5753 3174 002050E2 		subs	r2, r0, #0
 5754 3178 20FDFF0A 		beq	.L528
3064:../uvc.c      ****                         }
 5755              		.loc 1 3064 0
 5756 317c C0139FE5 		ldr	r1, .L740+68
 5757 3180 0400A0E3 		mov	r0, #4
 5758              	.LVL634:
 5759 3184 FEFFFFEB 		bl	CyU3PDebugPrint
 5760              	.LVL635:
 5761 3188 1CFDFFEA 		b	.L528
 5762              	.LVL636:
 5763              	.L721:
3127:../uvc.c      ****                 {
 5764              		.loc 1 3127 0
 5765 318c 010052E3 		cmp	r2, #1
 5766 3190 16FDFF1A 		bne	.L515
3152:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5767              		.loc 1 3152 0
 5768 3194 94139FE5 		ldr	r1, .L740+48
 5769 3198 40208DE2 		add	r2, sp, #64
 5770 319c 2000A0E3 		mov	r0, #32
 5771 31a0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5772              	.LVL637:
 5773 31a4 15FDFFEA 		b	.L528
 5774              	.L711:
 5775              	.LBE132:
 5776              	.LBE448:
 5777              	.LBB449:
 5778              	.LBB427:
2851:../uvc.c      ****     {
 5779              		.loc 1 2851 0
 5780 31a8 050C53E3 		cmp	r3, #1280
 5781 31ac 05FDFF1A 		bne	.L260
 5782              	.L466:
 5783              	.LVL638:
2871:../uvc.c      ****     		break;
 5784              		.loc 1 2871 0
 5785 31b0 1400A0E3 		mov	r0, #20
 5786 31b4 FEFFFFEB 		bl	ControlHandle
 5787              	.LVL639:
 5788 31b8 48309DE5 		ldr	r3, [sp, #72]
 5789 31bc 06FDFFEA 		b	.L259
 5790              	.L716:
2851:../uvc.c      ****     {
 5791              		.loc 1 2851 0
 5792 31c0 010A53E3 		cmp	r3, #4096
 5793 31c4 FFFCFF1A 		bne	.L260
 5794              	.LVL640:
 5795              	.LBB349:
 5796              	.LBB350:
 418:../uvc.c      ****     /*
 5797              		.loc 1 418 0
 5798 31c8 44339FE5 		ldr	r3, .L740+20
 412:../uvc.c      ****     }
 5799              		.loc 1 412 0
 5800 31cc 6A64DAE5 		ldrb	r6, [r10, #1130]	@ zero_extendqisi2
 5801              	.LVL641:
 418:../uvc.c      ****     /*
 5802              		.loc 1 418 0
 5803 31d0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 5804              		.loc 1 426 0
 5805 31d4 830053E3 		cmp	r3, #131
 418:../uvc.c      ****     /*
 5806              		.loc 1 418 0
 5807 31d8 28308DE5 		str	r3, [sp, #40]
 5808              	.LVL642:
 426:../uvc.c      **** 		 {
 5809              		.loc 1 426 0
 5810 31dc E304000A 		beq	.L483
 5811 31e0 0C02009A 		bls	.L733
 5812 31e4 28709DE5 		ldr	r7, [sp, #40]
 5813 31e8 850057E3 		cmp	r7, #133
 5814 31ec 8F05000A 		beq	.L488
 5815 31f0 8305003A 		bcc	.L489
 5816 31f4 860057E3 		cmp	r7, #134
 5817 31f8 9703000A 		beq	.L490
 5818 31fc 870057E3 		cmp	r7, #135
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 5819              		.loc 1 657 0
 5820 3200 7324DA05 		ldreqb	r2, [r10, #1139]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 5821              		.loc 1 658 0
 5822 3204 7434DA05 		ldreqb	r3, [r10, #1140]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 5823              		.loc 1 426 0
 5824 3208 5D05001A 		bne	.L482
 5825              	.L687:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5826              		.loc 1 597 0
 5827 320c 5C139FE5 		ldr	r1, .L740+112
 5828 3210 0600A0E1 		mov	r0, r6
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5829              		.loc 1 414 0
 5830 3214 FF70A0E3 		mov	r7, #255
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 5831              		.loc 1 594 0
 5832 3218 9C20C9E5 		strb	r2, [r9, #156]
 5833              	.L686:
 595:../uvc.c      **** 			 }
 5834              		.loc 1 595 0
 5835 321c 9D30C9E5 		strb	r3, [r9, #157]
 5836              	.L688:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5837              		.loc 1 597 0
 5838 3220 24708DE5 		str	r7, [sp, #36]
 5839 3224 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5840              	.LVL643:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5841              		.loc 1 414 0
 5842 3228 0730A0E1 		mov	r3, r7
 598:../uvc.c      **** 			  break;
 5843              		.loc 1 598 0
 5844 322c 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 5845              	.LVL644:
 5846 3230 24209DE5 		ldr	r2, [sp, #36]
 5847 3234 380200EA 		b	.L492
 5848              	.LVL645:
 5849              	.L411:
 5850              	.LBE350:
 5851              	.LBE349:
 5852              	.LBE427:
 5853              	.LBE449:
 5854              	.LBB450:
 5855              	.LBB331:
 5856              	.LBB248:
 5857              	.LBB163:
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5858              		.loc 1 991 0
 5859 3238 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5860              		.loc 1 992 0
 5861 323c 0200A0E3 		mov	r0, #2
 5862 3240 28139FE5 		ldr	r1, .L740+112
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5863              		.loc 1 990 0
 5864 3244 9CC0C9E5 		strb	ip, [r9, #156]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5865              		.loc 1 992 0
 5866 3248 1CC08DE5 		str	ip, [sp, #28]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5867              		.loc 1 991 0
 5868 324c 9D30C9E5 		strb	r3, [r9, #157]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5869              		.loc 1 992 0
 5870 3250 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5871              	.LVL646:
 993:../uvc.c      **** 			  break;
 5872              		.loc 1 993 0
 5873 3254 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 5874              	.LVL647:
 5875 3258 1CC09DE5 		ldr	ip, [sp, #28]
 5876              	.LVL648:
 5877              	.L415:
1199:../uvc.c      **** }
 5878              		.loc 1 1199 0
 5879 325c 9E10D9E5 		ldrb	r1, [r9, #158]	@ zero_extendqisi2
 5880 3260 FF30A0E3 		mov	r3, #255
 5881 3264 04108DE5 		str	r1, [sp, #4]
 5882 3268 10108DE5 		str	r1, [sp, #16]
 5883 326c 00308DE5 		str	r3, [sp]
 5884 3270 0C308DE5 		str	r3, [sp, #12]
 5885 3274 08708DE5 		str	r7, [sp, #8]
 5886 3278 14C08DE5 		str	ip, [sp, #20]
 5887 327c 0620A0E1 		mov	r2, r6
 5888 3280 0400A0E3 		mov	r0, #4
 5889 3284 94129FE5 		ldr	r1, .L740+32
 5890 3288 FEFFFFEB 		bl	CyU3PDebugPrint
 5891              	.LVL649:
 5892 328c 48309DE5 		ldr	r3, [sp, #72]
 5893 3290 D1FCFFEA 		b	.L259
 5894              	.LVL650:
 5895              	.L454:
 5896              	.LBE163:
 5897              	.LBE248:
 5898              	.LBE331:
 5899              	.LBE450:
 5900              	.LBB451:
 5901              	.LBB428:
 5902              	.LBB359:
 5903              	.LBB360:
 418:../uvc.c      ****     /*
 5904              		.loc 1 418 0
 5905 3294 78229FE5 		ldr	r2, .L740+20
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 5906              		.loc 1 404 0
 5907 3298 7830DAE5 		ldrb	r3, [r10, #120]	@ zero_extendqisi2
 5908              	.LVL651:
 418:../uvc.c      ****     /*
 5909              		.loc 1 418 0
 5910 329c 0060D2E5 		ldrb	r6, [r2]	@ zero_extendqisi2
 406:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 5911              		.loc 1 406 0
 5912 32a0 8770DAE5 		ldrb	r7, [r10, #135]	@ zero_extendqisi2
 5913              	.LVL652:
 426:../uvc.c      **** 		 {
 5914              		.loc 1 426 0
 5915 32a4 830056E3 		cmp	r6, #131
 407:../uvc.c      ****     }else{
 5916              		.loc 1 407 0
 5917 32a8 7AC0DAE5 		ldrb	ip, [r10, #122]	@ zero_extendqisi2
 5918              	.LVL653:
 426:../uvc.c      **** 		 {
 5919              		.loc 1 426 0
 5920 32ac A304000A 		beq	.L502
 5921 32b0 4702009A 		bls	.L734
 5922 32b4 850056E3 		cmp	r6, #133
 5923 32b8 C004000A 		beq	.L507
 5924 32bc B404003A 		bcc	.L508
 5925 32c0 860056E3 		cmp	r6, #134
 5926 32c4 6A03000A 		beq	.L509
 5927 32c8 870056E3 		cmp	r6, #135
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 5928              		.loc 1 647 0
 5929 32cc 83E0DA05 		ldreqb	lr, [r10, #131]	@ zero_extendqisi2
 648:../uvc.c      **** 		 	 }
 5930              		.loc 1 648 0
 5931 32d0 8420DA05 		ldreqb	r2, [r10, #132]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 5932              		.loc 1 426 0
 5933 32d4 2005001A 		bne	.L501
 5934              	.L691:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5935              		.loc 1 597 0
 5936 32d8 90129FE5 		ldr	r1, .L740+112
 5937 32dc 0C00A0E1 		mov	r0, ip
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5938              		.loc 1 414 0
 5939 32e0 FF70A0E3 		mov	r7, #255
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 5940              		.loc 1 583 0
 5941 32e4 9CE0C9E5 		strb	lr, [r9, #156]
 5942              	.L689:
 584:../uvc.c      **** 		 	 }
 5943              		.loc 1 584 0
 5944 32e8 9D20C9E5 		strb	r2, [r9, #157]
 5945              	.L692:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5946              		.loc 1 414 0
 5947 32ec 28708DE5 		str	r7, [sp, #40]
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5948              		.loc 1 597 0
 5949 32f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5950              	.LVL654:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5951              		.loc 1 414 0
 5952 32f4 07C0A0E1 		mov	ip, r7
 598:../uvc.c      **** 			  break;
 5953              		.loc 1 598 0
 5954 32f8 9C20D9E5 		ldrb	r2, [r9, #156]	@ zero_extendqisi2
 5955              	.LVL655:
 5956 32fc 28309DE5 		ldr	r3, [sp, #40]
 5957 3300 5B0200EA 		b	.L511
 5958              	.LVL656:
 5959              	.L436:
 5960              	.LBE360:
 5961              	.LBE359:
 5962              	.LBB369:
 5963              	.LBB370:
 418:../uvc.c      ****     /*
 5964              		.loc 1 418 0
 5965 3304 08229FE5 		ldr	r2, .L740+20
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 5966              		.loc 1 409 0
 5967 3308 4833DAE5 		ldrb	r3, [r10, #840]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 5968              		.loc 1 418 0
 5969 330c 0070D2E5 		ldrb	r7, [r2]	@ zero_extendqisi2
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 5970              		.loc 1 409 0
 5971 3310 28308DE5 		str	r3, [sp, #40]
 5972              	.LVL657:
 426:../uvc.c      **** 		 {
 5973              		.loc 1 426 0
 5974 3314 830057E3 		cmp	r7, #131
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 5975              		.loc 1 411 0
 5976 3318 5733DAE5 		ldrb	r3, [r10, #855]	@ zero_extendqisi2
 5977              	.LVL658:
 412:../uvc.c      ****     }
 5978              		.loc 1 412 0
 5979 331c 4A63DAE5 		ldrb	r6, [r10, #842]	@ zero_extendqisi2
 5980              	.LVL659:
 426:../uvc.c      **** 		 {
 5981              		.loc 1 426 0
 5982 3320 8E04000A 		beq	.L457
 5983 3324 0402009A 		bls	.L735
 5984 3328 850057E3 		cmp	r7, #133
 5985 332c 9C02000A 		beq	.L475
 5986 3330 2F05003A 		bcc	.L463
 5987 3334 860057E3 		cmp	r7, #134
 5988 3338 3A03000A 		beq	.L464
 5989 333c 870057E3 		cmp	r7, #135
 5990 3340 B703001A 		bne	.L469
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 5991              		.loc 1 657 0
 5992 3344 B8319FE5 		ldr	r3, .L740+4
 5993 3348 5323D3E5 		ldrb	r2, [r3, #851]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 5994              		.loc 1 658 0
 5995 334c 5433D3E5 		ldrb	r3, [r3, #852]	@ zero_extendqisi2
 5996              	.LVL660:
 5997              	.L685:
 5998              	.LBE370:
 5999              	.LBE369:
 6000              	.LBB378:
 6001              	.LBB379:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6002              		.loc 1 597 0
 6003 3350 0600A0E1 		mov	r0, r6
 6004 3354 14129FE5 		ldr	r1, .L740+112
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 6005              		.loc 1 594 0
 6006 3358 9C20C9E5 		strb	r2, [r9, #156]
 6007 335c 940200EA 		b	.L684
 6008              	.L449:
 6009              	.LVL661:
 6010              	.LBE379:
 6011              	.LBE378:
2902:../uvc.c      ****     		break;
 6012              		.loc 1 2902 0
 6013 3360 1C00A0E3 		mov	r0, #28
 6014 3364 FEFFFFEB 		bl	ControlHandle
 6015              	.LVL662:
 6016 3368 48309DE5 		ldr	r3, [sp, #72]
 6017 336c 9AFCFFEA 		b	.L259
 6018              	.L439:
 6019              	.LVL663:
2863:../uvc.c      ****      		break;
 6020              		.loc 1 2863 0
 6021 3370 1200A0E3 		mov	r0, #18
 6022 3374 FEFFFFEB 		bl	ControlHandle
 6023              	.LVL664:
 6024 3378 48309DE5 		ldr	r3, [sp, #72]
 6025 337c 96FCFFEA 		b	.L259
 6026              	.L438:
 6027              	.LVL665:
2859:../uvc.c      ****     		break;
 6028              		.loc 1 2859 0
 6029 3380 1100A0E3 		mov	r0, #17
 6030 3384 FEFFFFEB 		bl	ControlHandle
 6031              	.LVL666:
 6032 3388 48309DE5 		ldr	r3, [sp, #72]
 6033 338c 92FCFFEA 		b	.L259
 6034              	.L446:
 6035              	.LVL667:
 6036              	.LBB391:
 6037              	.LBB380:
 418:../uvc.c      ****     /*
 6038              		.loc 1 418 0
 6039 3390 7C219FE5 		ldr	r2, .L740+20
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6040              		.loc 1 409 0
 6041 3394 5034DAE5 		ldrb	r3, [r10, #1104]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 6042              		.loc 1 418 0
 6043 3398 0070D2E5 		ldrb	r7, [r2]	@ zero_extendqisi2
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6044              		.loc 1 409 0
 6045 339c 28308DE5 		str	r3, [sp, #40]
 6046              	.LVL668:
 426:../uvc.c      **** 		 {
 6047              		.loc 1 426 0
 6048 33a0 830057E3 		cmp	r7, #131
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 6049              		.loc 1 411 0
 6050 33a4 5F34DAE5 		ldrb	r3, [r10, #1119]	@ zero_extendqisi2
 6051              	.LVL669:
 412:../uvc.c      ****     }
 6052              		.loc 1 412 0
 6053 33a8 5264DAE5 		ldrb	r6, [r10, #1106]	@ zero_extendqisi2
 6054              	.LVL670:
 426:../uvc.c      **** 		 {
 6055              		.loc 1 426 0
 6056 33ac 6704000A 		beq	.L470
 6057 33b0 3802009A 		bls	.L736
 6058 33b4 850057E3 		cmp	r7, #133
 6059 33b8 7902000A 		beq	.L475
 6060 33bc D704003A 		bcc	.L476
 6061 33c0 860057E3 		cmp	r7, #134
 6062 33c4 2103000A 		beq	.L477
 6063 33c8 870057E3 		cmp	r7, #135
 6064 33cc 9403001A 		bne	.L469
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 6065              		.loc 1 657 0
 6066 33d0 2C319FE5 		ldr	r3, .L740+4
 6067 33d4 5B24D3E5 		ldrb	r2, [r3, #1115]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 6068              		.loc 1 658 0
 6069 33d8 5C34D3E5 		ldrb	r3, [r3, #1116]	@ zero_extendqisi2
 6070 33dc DBFFFFEA 		b	.L685
 6071              	.LVL671:
 6072              	.L434:
 6073              	.LBE380:
 6074              	.LBE391:
2887:../uvc.c      ****      		break;
 6075              		.loc 1 2887 0
 6076 33e0 1800A0E3 		mov	r0, #24
 6077 33e4 FEFFFFEB 		bl	ControlHandle
 6078              	.LVL672:
 6079 33e8 48309DE5 		ldr	r3, [sp, #72]
 6080 33ec 7AFCFFEA 		b	.L259
 6081              	.L444:
 6082              	.LVL673:
2879:../uvc.c      ****     		break;
 6083              		.loc 1 2879 0
 6084 33f0 1600A0E3 		mov	r0, #22
 6085 33f4 FEFFFFEB 		bl	ControlHandle
 6086              	.LVL674:
 6087 33f8 48309DE5 		ldr	r3, [sp, #72]
 6088 33fc 76FCFFEA 		b	.L259
 6089              	.L441:
 6090              	.LVL675:
2875:../uvc.c      ****      		break;
 6091              		.loc 1 2875 0
 6092 3400 1500A0E3 		mov	r0, #21
 6093 3404 FEFFFFEB 		bl	ControlHandle
 6094              	.LVL676:
 6095 3408 48309DE5 		ldr	r3, [sp, #72]
 6096 340c 72FCFFEA 		b	.L259
 6097              	.L451:
 6098              	.LVL677:
2918:../uvc.c      ****     		break;
 6099              		.loc 1 2918 0
 6100 3410 2400A0E3 		mov	r0, #36
 6101 3414 FEFFFFEB 		bl	ControlHandle
 6102              	.LVL678:
 6103 3418 48309DE5 		ldr	r3, [sp, #72]
 6104 341c 6EFCFFEA 		b	.L259
 6105              	.LVL679:
 6106              	.L559:
 6107              	.LBE428:
 6108              	.LBE451:
 6109              	.LBB452:
 6110              	.LBB133:
3211:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6111              		.loc 1 3211 0
 6112 3420 0020A0E3 		mov	r2, #0
3212:../uvc.c      ****                         break;
 6113              		.loc 1 3212 0
 6114 3424 44119FE5 		ldr	r1, .L740+112
 6115 3428 0200A0E3 		mov	r0, #2
3210:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6116              		.loc 1 3210 0
 6117 342c 9C30C9E5 		strb	r3, [r9, #156]
3211:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6118              		.loc 1 3211 0
 6119 3430 9D20C9E5 		strb	r2, [r9, #157]
3212:../uvc.c      ****                         break;
 6120              		.loc 1 3212 0
 6121 3434 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6122              	.LVL680:
 6123 3438 70FCFFEA 		b	.L528
 6124              	.LVL681:
 6125              	.L712:
 6126 343c 0030A0E1 		mov	r3, r0
 6127              	.LBE133:
 6128              	.LBE452:
3386:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 6129              		.loc 1 3386 0
 6130 3440 0320A0E1 		mov	r2, r3
 6131 3444 0700A0E1 		mov	r0, r7
 6132              	.LVL682:
 6133 3448 10119FE5 		ldr	r1, .L740+96
 6134 344c 20308DE5 		str	r3, [sp, #32]
 6135 3450 FEFFFFEB 		bl	CyU3PDebugPrint
 6136              	.LVL683:
3387:../uvc.c      **** 					}
 6137              		.loc 1 3387 0
 6138 3454 20309DE5 		ldr	r3, [sp, #32]
 6139 3458 0300A0E1 		mov	r0, r3
 6140 345c FEFFFFEB 		bl	CyFxAppErrorHandler
 6141              	.LVL684:
 6142              	.L723:
 6143              	.LBB453:
 6144              	.LBB332:
 6145              	.LBB249:
 6146              	.LBB173:
 986:../uvc.c      **** 		 {
 6147              		.loc 1 986 0
 6148 3460 810056E3 		cmp	r6, #129
 6149 3464 B102000A 		beq	.L397
 6150 3468 D603008A 		bhi	.L398
 6151 346c 010056E3 		cmp	r6, #1
 6152 3470 21FEFF1A 		bne	.L394
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6153              		.loc 1 1057 0
 6154 3474 F4109FE5 		ldr	r1, .L740+112
 6155 3478 40208DE2 		add	r2, sp, #64
 6156 347c 2000A0E3 		mov	r0, #32
 6157 3480 1CC08DE5 		str	ip, [sp, #28]
 6158 3484 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6159              	.LVL685:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6160              		.loc 1 1187 0
 6161 3488 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6162              		.loc 1 1188 0
 6163 348c 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 6164 3490 0400A0E3 		mov	r0, #4
 6165 3494 B8109FE5 		ldr	r1, .L740+84
 6166 3498 0820A0E3 		mov	r2, #8
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6167              		.loc 1 1187 0
 6168 349c 5DE5CAE5 		strb	lr, [r10, #1373]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6169              		.loc 1 980 0
 6170 34a0 FF70A0E3 		mov	r7, #255
1188:../uvc.c      **** 			  		 break;
 6171              		.loc 1 1188 0
 6172 34a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6173              	.LVL686:
 6174 34a8 1CC09DE5 		ldr	ip, [sp, #28]
 6175 34ac 6AFFFFEA 		b	.L415
 6176              	.LVL687:
 6177              	.L725:
 6178              	.LBE173:
 6179              	.LBE249:
 6180              	.LBB250:
 6181              	.LBB164:
 986:../uvc.c      **** 		 {
 6182              		.loc 1 986 0
 6183 34b0 810056E3 		cmp	r6, #129
 6184 34b4 A002000A 		beq	.L408
 6185 34b8 C503008A 		bhi	.L409
 6186 34bc 010056E3 		cmp	r6, #1
 6187 34c0 50FEFF1A 		bne	.L405
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6188              		.loc 1 1057 0
 6189 34c4 A4109FE5 		ldr	r1, .L740+112
 6190 34c8 40208DE2 		add	r2, sp, #64
 6191 34cc 2000A0E3 		mov	r0, #32
 6192 34d0 1CC08DE5 		str	ip, [sp, #28]
 6193 34d4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6194              	.LVL688:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6195              		.loc 1 1187 0
 6196 34d8 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6197              		.loc 1 1188 0
 6198 34dc 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 6199 34e0 0400A0E3 		mov	r0, #4
 6200 34e4 68109FE5 		ldr	r1, .L740+84
 6201 34e8 0920A0E3 		mov	r2, #9
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6202              		.loc 1 1187 0
 6203 34ec 75E5CAE5 		strb	lr, [r10, #1397]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6204              		.loc 1 980 0
 6205 34f0 FF70A0E3 		mov	r7, #255
1188:../uvc.c      **** 			  		 break;
 6206              		.loc 1 1188 0
 6207 34f4 FEFFFFEB 		bl	CyU3PDebugPrint
 6208              	.LVL689:
 6209 34f8 1CC09DE5 		ldr	ip, [sp, #28]
 6210 34fc 56FFFFEA 		b	.L415
 6211              	.L741:
 6212              		.align	2
 6213              	.L740:
 6214 3500 00000000 		.word	.LANCHOR0
 6215 3504 00000000 		.word	.LANCHOR1
 6216 3508 00000000 		.word	glInterStaBuffer
 6217 350c 00000000 		.word	wIndex
 6218 3510 00000000 		.word	wValue
 6219 3514 00000000 		.word	bRequest
 6220 3518 E4040000 		.word	.LC27
 6221 351c 00000000 		.word	glChHandleInterStat
 6222 3520 14040000 		.word	.LC23
 6223 3524 10060000 		.word	.LANCHOR1+1552
 6224 3528 2C060000 		.word	.LANCHOR1+1580
 6225 352c 38060000 		.word	.LANCHOR1+1592
 6226 3530 C4000000 		.word	.LANCHOR0+196
 6227 3534 B8050000 		.word	.LC32
 6228 3538 10050000 		.word	.LC28
 6229 353c 08060000 		.word	.LC34
 6230 3540 68050000 		.word	.LC30
 6231 3544 90050000 		.word	.LC31
 6232 3548 A4030000 		.word	.LC20
 6233 354c FFFF0000 		.word	65535
 6234 3550 10000000 		.word	.LANCHOR2+16
 6235 3554 CC030000 		.word	.LC21
 6236 3558 00000000 		.word	cmdQu
 6237 355c 34060000 		.word	.LC35
 6238 3560 5C060000 		.word	.LC36
 6239 3564 54030000 		.word	.LC19
 6240 3568 F0030000 		.word	.LC22
 6241 356c E4050000 		.word	.LC33
 6242 3570 9C000000 		.word	.LANCHOR0+156
 6243 3574 44050000 		.word	.LC29
 6244 3578 00000000 		.word	.LANCHOR1
 6245              	.LVL690:
 6246              	.L728:
 6247              	.LBE164:
 6248              	.LBE250:
 6249              	.LBB251:
 6250              	.LBB224:
 986:../uvc.c      **** 		 {
 6251              		.loc 1 986 0
 6252 357c 810056E3 		cmp	r6, #129
 6253 3580 7102000A 		beq	.L298
 6254 3584 8803008A 		bhi	.L299
 6255 3588 010056E3 		cmp	r6, #1
 6256 358c 78FEFF1A 		bne	.L295
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6257              		.loc 1 1057 0
 6258 3590 28101FE5 		ldr	r1, .L740+112
 6259 3594 40208DE2 		add	r2, sp, #64
 6260 3598 2000A0E3 		mov	r0, #32
 6261 359c 1CC08DE5 		str	ip, [sp, #28]
 6262 35a0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6263              	.LVL691:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6264              		.loc 1 1187 0
 6265 35a4 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6266              		.loc 1 1188 0
 6267 35a8 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 6268 35ac 0400A0E3 		mov	r0, #4
 6269 35b0 64101FE5 		ldr	r1, .L740+84
 6270 35b4 0020A0E3 		mov	r2, #0
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6271              		.loc 1 1187 0
 6272 35b8 9DE4CAE5 		strb	lr, [r10, #1181]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6273              		.loc 1 980 0
 6274 35bc FF70A0E3 		mov	r7, #255
1188:../uvc.c      **** 			  		 break;
 6275              		.loc 1 1188 0
 6276 35c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6277              	.LVL692:
 6278 35c4 1CC09DE5 		ldr	ip, [sp, #28]
 6279 35c8 23FFFFEA 		b	.L415
 6280              	.LVL693:
 6281              	.L722:
 6282              	.LBE224:
 6283              	.LBE251:
 6284              	.LBB252:
 6285              	.LBB153:
 986:../uvc.c      **** 		 {
 6286              		.loc 1 986 0
 6287 35cc 810056E3 		cmp	r6, #129
 6288 35d0 6102000A 		beq	.L351
 6289 35d4 7803008A 		bhi	.L352
 6290 35d8 010056E3 		cmp	r6, #1
 6291 35dc DC02001A 		bne	.L348
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6292              		.loc 1 1057 0
 6293 35e0 78101FE5 		ldr	r1, .L740+112
 6294 35e4 40208DE2 		add	r2, sp, #64
 6295 35e8 2000A0E3 		mov	r0, #32
 6296 35ec 1CC08DE5 		str	ip, [sp, #28]
 6297 35f0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6298              	.LVL694:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6299              		.loc 1 1187 0
 6300 35f4 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6301              		.loc 1 1188 0
 6302 35f8 0400A0E3 		mov	r0, #4
 6303 35fc 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 6304 3600 0020A0E1 		mov	r2, r0
 6305 3604 B8101FE5 		ldr	r1, .L740+84
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6306              		.loc 1 1187 0
 6307 3608 FDE4CAE5 		strb	lr, [r10, #1277]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6308              		.loc 1 980 0
 6309 360c FF70A0E3 		mov	r7, #255
1188:../uvc.c      **** 			  		 break;
 6310              		.loc 1 1188 0
 6311 3610 FEFFFFEB 		bl	CyU3PDebugPrint
 6312              	.LVL695:
 6313 3614 1CC09DE5 		ldr	ip, [sp, #28]
 6314 3618 0FFFFFEA 		b	.L415
 6315              	.LVL696:
 6316              	.L726:
 6317              	.LBE153:
 6318              	.LBE252:
 6319              	.LBB253:
 6320              	.LBB192:
 986:../uvc.c      **** 		 {
 6321              		.loc 1 986 0
 6322 361c 810056E3 		cmp	r6, #129
 6323 3620 5102000A 		beq	.L362
 6324 3624 4B03008A 		bhi	.L363
 6325 3628 010056E3 		cmp	r6, #1
 6326 362c A102001A 		bne	.L359
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6327              		.loc 1 1057 0
 6328 3630 C8101FE5 		ldr	r1, .L740+112
 6329 3634 40208DE2 		add	r2, sp, #64
 6330 3638 2000A0E3 		mov	r0, #32
 6331 363c 1CC08DE5 		str	ip, [sp, #28]
 6332 3640 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6333              	.LVL697:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6334              		.loc 1 1187 0
 6335 3644 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6336              		.loc 1 1188 0
 6337 3648 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6338              		.loc 1 1187 0
 6339 364c DC701FE5 		ldr	r7, .L740+120
1188:../uvc.c      **** 			  		 break;
 6340              		.loc 1 1188 0
 6341 3650 0400A0E3 		mov	r0, #4
 6342 3654 08111FE5 		ldr	r1, .L740+84
 6343 3658 0520A0E3 		mov	r2, #5
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6344              		.loc 1 1187 0
 6345 365c 15E5C7E5 		strb	lr, [r7, #1301]
1188:../uvc.c      **** 			  		 break;
 6346              		.loc 1 1188 0
 6347 3660 FEFFFFEB 		bl	CyU3PDebugPrint
 6348              	.LVL698:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6349              		.loc 1 980 0
 6350 3664 FF70A0E3 		mov	r7, #255
 6351 3668 1CC09DE5 		ldr	ip, [sp, #28]
 6352 366c FAFEFFEA 		b	.L415
 6353              	.LVL699:
 6354              	.L724:
 6355              	.LBE192:
 6356              	.LBE253:
 6357              	.LBB254:
 6358              	.LBB181:
 986:../uvc.c      **** 		 {
 6359              		.loc 1 986 0
 6360 3670 810056E3 		cmp	r6, #129
 6361 3674 4002000A 		beq	.L419
 6362 3678 3303008A 		bhi	.L420
 6363 367c 010056E3 		cmp	r6, #1
 6364 3680 9902001A 		bne	.L416
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6365              		.loc 1 1057 0
 6366 3684 1C111FE5 		ldr	r1, .L740+112
 6367 3688 40208DE2 		add	r2, sp, #64
 6368 368c 2000A0E3 		mov	r0, #32
 6369 3690 20308DE5 		str	r3, [sp, #32]
 6370 3694 1CC08DE5 		str	ip, [sp, #28]
 6371 3698 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6372              	.LVL700:
1172:../uvc.c      **** 					  if(getData == 1)
 6373              		.loc 1 1172 0
 6374 369c 4CE11FE5 		ldr	lr, .L740+88
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6375              		.loc 1 1059 0
 6376 36a0 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
1172:../uvc.c      **** 					  if(getData == 1)
 6377              		.loc 1 1172 0
 6378 36a4 0010E0E3 		mvn	r1, #0
 6379 36a8 1C009EE5 		ldr	r0, [lr, #28]
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6380              		.loc 1 1059 0
 6381 36ac 2C708DE5 		str	r7, [sp, #44]
 6382              	.LVL701:
1060:../uvc.c      **** 			  value = Data1;
 6383              		.loc 1 1060 0
 6384 36b0 9D70D9E5 		ldrb	r7, [r9, #157]	@ zero_extendqisi2
 6385              	.LVL702:
1172:../uvc.c      **** 					  if(getData == 1)
 6386              		.loc 1 1172 0
 6387 36b4 FEFFFFEB 		bl	_txe_mutex_get
 6388              	.LVL703:
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 6389              		.loc 1 1173 0
 6390 36b8 2C109DE5 		ldr	r1, [sp, #44]
 6391 36bc 20309DE5 		ldr	r3, [sp, #32]
 6392 36c0 010051E3 		cmp	r1, #1
 6393 36c4 1CC09DE5 		ldr	ip, [sp, #28]
1174:../uvc.c      **** 					  else if(getData == 0xff)
 6394              		.loc 1 1174 0
 6395 36c8 0410A003 		moveq	r1, #4
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 6396              		.loc 1 1173 0
 6397 36cc 6904000A 		beq	.L680
1175:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 6398              		.loc 1 1175 0
 6399 36d0 2C209DE5 		ldr	r2, [sp, #44]
 6400 36d4 FF0052E3 		cmp	r2, #255
 6401 36d8 6504000A 		beq	.L737
1178:../uvc.c      **** 					  //dataIdx++;
 6402              		.loc 1 1178 0
 6403 36dc 0010A0E3 		mov	r1, #0
 6404 36e0 0320A0E1 		mov	r2, r3
 6405 36e4 00108DE5 		str	r1, [sp]
 6406 36e8 04108DE5 		str	r1, [sp, #4]
 6407 36ec 0C30A0E1 		mov	r3, ip
 6408 36f0 A0011FE5 		ldr	r0, .L740+88
 6409 36f4 2310A0E3 		mov	r1, #35
 6410 36f8 FEFFFFEB 		bl	cmdSet
 6411              	.LVL704:
 6412              	.L428:
1181:../uvc.c      **** #endif
 6413              		.loc 1 1181 0
 6414 36fc AC311FE5 		ldr	r3, .L740+88
 6415 3700 1C0093E5 		ldr	r0, [r3, #28]
 6416 3704 FEFFFFEB 		bl	_txe_mutex_put
 6417              	.LVL705:
1183:../uvc.c      **** 					  break;
 6418              		.loc 1 1183 0
 6419 3708 9E30D9E5 		ldrb	r3, [r9, #158]	@ zero_extendqisi2
 6420 370c 0400A0E3 		mov	r0, #4
 6421 3710 00308DE5 		str	r3, [sp]
 6422 3714 D4111FE5 		ldr	r1, .L740+72
 6423 3718 0730A0E1 		mov	r3, r7
 6424 371c 2C209DE5 		ldr	r2, [sp, #44]
 6425 3720 FEFFFFEB 		bl	CyU3PDebugPrint
 6426              	.LVL706:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6427              		.loc 1 980 0
 6428 3724 FF30A0E3 		mov	r3, #255
 6429 3728 9EFDFFEA 		b	.L426
 6430              	.LVL707:
 6431              	.L731:
 6432              	.LBE181:
 6433              	.LBE254:
 6434              	.LBB255:
 6435              	.LBB242:
 986:../uvc.c      **** 		 {
 6436              		.loc 1 986 0
 6437 372c 810056E3 		cmp	r6, #129
 6438 3730 2102000A 		beq	.L373
 6439 3734 1803008A 		bhi	.L374
 6440 3738 010056E3 		cmp	r6, #1
 6441 373c 4DFEFF1A 		bne	.L370
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6442              		.loc 1 1057 0
 6443 3740 D8111FE5 		ldr	r1, .L740+112
 6444 3744 40208DE2 		add	r2, sp, #64
 6445 3748 2000A0E3 		mov	r0, #32
 6446 374c 1CC08DE5 		str	ip, [sp, #28]
 6447 3750 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6448              	.LVL708:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6449              		.loc 1 1187 0
 6450 3754 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6451              		.loc 1 1188 0
 6452 3758 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 6453 375c 0400A0E3 		mov	r0, #4
 6454 3760 14121FE5 		ldr	r1, .L740+84
 6455 3764 0620A0E3 		mov	r2, #6
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6456              		.loc 1 1187 0
 6457 3768 2DE5CAE5 		strb	lr, [r10, #1325]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6458              		.loc 1 980 0
 6459 376c FF70A0E3 		mov	r7, #255
1188:../uvc.c      **** 			  		 break;
 6460              		.loc 1 1188 0
 6461 3770 FEFFFFEB 		bl	CyU3PDebugPrint
 6462              	.LVL709:
 6463 3774 1CC09DE5 		ldr	ip, [sp, #28]
 6464 3778 B7FEFFEA 		b	.L415
 6465              	.LVL710:
 6466              	.L718:
 6467              	.LBE242:
 6468              	.LBE255:
 6469              	.LBB256:
 6470              	.LBB142:
 986:../uvc.c      **** 		 {
 6471              		.loc 1 986 0
 6472 377c 81005EE3 		cmp	lr, #129
 6473 3780 9B01000A 		beq	.L309
 6474 3784 E902008A 		bhi	.L310
 6475 3788 01005EE3 		cmp	lr, #1
 6476 378c 6302001A 		bne	.L306
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6477              		.loc 1 1057 0
 6478 3790 40208DE2 		add	r2, sp, #64
 6479 3794 2000A0E3 		mov	r0, #32
 6480 3798 30121FE5 		ldr	r1, .L740+112
 6481 379c 20308DE5 		str	r3, [sp, #32]
 6482 37a0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6483              	.LVL711:
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6484              		.loc 1 1059 0
 6485 37a4 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 6486              	.LVL712:
1069:../uvc.c      **** 				    getData = glEp0Buffer[0];
 6487              		.loc 1 1069 0
 6488 37a8 28709DE5 		ldr	r7, [sp, #40]
1072:../uvc.c      **** 						case 1:
 6489              		.loc 1 1072 0
 6490 37ac 01204CE2 		sub	r2, ip, #1
1069:../uvc.c      **** 				    getData = glEp0Buffer[0];
 6491              		.loc 1 1069 0
 6492 37b0 B874CAE5 		strb	r7, [r10, #1208]
 6493              	.LVL713:
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 6494              		.loc 1 1068 0
 6495 37b4 B5C4CAE5 		strb	ip, [r10, #1205]
1072:../uvc.c      **** 						case 1:
 6496              		.loc 1 1072 0
 6497 37b8 20309DE5 		ldr	r3, [sp, #32]
 6498 37bc 070052E3 		cmp	r2, #7
 6499 37c0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 6500 37c4 740400EA 		b	.L573
 6501              	.L318:
 6502 37c8 90490000 		.word	.L317
 6503 37cc 24490000 		.word	.L319
 6504 37d0 9C490000 		.word	.L573
 6505 37d4 04490000 		.word	.L320
 6506 37d8 9C490000 		.word	.L573
 6507 37dc 9C490000 		.word	.L573
 6508 37e0 9C490000 		.word	.L573
 6509 37e4 9C480000 		.word	.L321
 6510              	.LVL714:
 6511              	.L727:
 6512              	.LBE142:
 6513              	.LBE256:
 6514              	.LBB257:
 6515              	.LBB201:
 986:../uvc.c      **** 		 {
 6516              		.loc 1 986 0
 6517 37e8 810056E3 		cmp	r6, #129
 6518 37ec F901000A 		beq	.L336
 6519 37f0 D102008A 		bhi	.L337
 6520 37f4 010056E3 		cmp	r6, #1
 6521 37f8 7C02001A 		bne	.L333
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6522              		.loc 1 1057 0
 6523 37fc 40208DE2 		add	r2, sp, #64
 6524 3800 2000A0E3 		mov	r0, #32
 6525 3804 9C121FE5 		ldr	r1, .L740+112
 6526 3808 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6527              	.LVL715:
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6528              		.loc 1 1059 0
 6529 380c 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6530              		.loc 1 1115 0
 6531 3810 B524DAE5 		ldrb	r2, [r10, #1205]	@ zero_extendqisi2
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6532              		.loc 1 1059 0
 6533 3814 38708DE5 		str	r7, [sp, #56]
 6534              	.LVL716:
1060:../uvc.c      **** 			  value = Data1;
 6535              		.loc 1 1060 0
 6536 3818 9D70D9E5 		ldrb	r7, [r9, #157]	@ zero_extendqisi2
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6537              		.loc 1 1115 0
 6538 381c 010052E3 		cmp	r2, #1
 6539 3820 04005213 		cmpne	r2, #4
1060:../uvc.c      **** 			  value = Data1;
 6540              		.loc 1 1060 0
 6541 3824 3C708DE5 		str	r7, [sp, #60]
 6542              	.LVL717:
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6543              		.loc 1 1115 0
 6544 3828 5403001A 		bne	.L344
1114:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 6545              		.loc 1 1114 0
 6546 382c 38E09DE5 		ldr	lr, [sp, #56]
 6547 3830 07C48EE1 		orr	ip, lr, r7, asl #8
1116:../uvc.c      **** 					  {
 6548              		.loc 1 1116 0
 6549 3834 F9005CE3 		cmp	ip, #249
 6550 3838 5003008A 		bhi	.L344
 6551 383c F8021FE5 		ldr	r0, .L740+76
 6552 3840 0020A0E3 		mov	r2, #0
 6553 3844 0130A0E3 		mov	r3, #1
 6554              	.LVL718:
 6555              	.L346:
1120:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 6556              		.loc 1 1120 0
 6557 3848 00731FE5 		ldr	r7, .L740+80
 6558 384c 8210A0E1 		mov	r1, r2, asl #1
 6559 3850 B11097E1 		ldrh	r1, [r7, r1]
 6560 3854 FFE002E2 		and	lr, r2, #255
1121:../uvc.c      **** 							}else{
 6561              		.loc 1 1121 0
 6562 3858 0C7061E0 		rsb	r7, r1, ip
 6563 385c 01005CE1 		cmp	ip, r1
 6564 3860 34E08DE5 		str	lr, [sp, #52]
1123:../uvc.c      **** 							}
 6565              		.loc 1 1123 0
 6566 3864 01E06CE0 		rsb	lr, ip, r1
 6567 3868 0E18A091 		movls	r1, lr, asl #16
 6568 386c 0718A081 		movhi	r1, r7, asl #16
 6569 3870 34709DE5 		ldr	r7, [sp, #52]
 6570 3874 2118A0E1 		mov	r1, r1, lsr #16
 6571 3878 000051E1 		cmp	r1, r0
 6572 387c 012082E2 		add	r2, r2, #1
 6573 3880 0730A031 		movcc	r3, r7
 6574              	.LVL719:
 6575 3884 000051E1 		cmp	r1, r0
 6576 3888 0100A031 		movcc	r0, r1
 6577              	.LVL720:
1118:../uvc.c      **** 						  {
 6578              		.loc 1 1118 0
 6579 388c 080052E3 		cmp	r2, #8
 6580 3890 ECFFFF1A 		bne	.L346
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6581              		.loc 1 1133 0
 6582 3894 44731FE5 		ldr	r7, .L740+88
1130:../uvc.c      **** 
 6583              		.loc 1 1130 0
 6584 3898 012083E2 		add	r2, r3, #1
 6585 389c FF2002E2 		and	r2, r2, #255
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6586              		.loc 1 1133 0
 6587 38a0 1C0097E5 		ldr	r0, [r7, #28]
 6588              	.LVL721:
 6589 38a4 0010E0E3 		mvn	r1, #0
1130:../uvc.c      **** 
 6590              		.loc 1 1130 0
 6591 38a8 34208DE5 		str	r2, [sp, #52]
 6592              	.LVL722:
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6593              		.loc 1 1133 0
 6594 38ac FEFFFFEB 		bl	_txe_mutex_get
 6595              	.LVL723:
1134:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6596              		.loc 1 1134 0
 6597 38b0 34E09DE5 		ldr	lr, [sp, #52]
 6598 38b4 0010A0E3 		mov	r1, #0
 6599 38b8 2C309DE5 		ldr	r3, [sp, #44]
 6600 38bc 00E08DE5 		str	lr, [sp]
 6601 38c0 30209DE5 		ldr	r2, [sp, #48]
 6602 38c4 0700A0E1 		mov	r0, r7
 6603 38c8 04108DE5 		str	r1, [sp, #4]
 6604 38cc 0310A0E3 		mov	r1, #3
 6605 38d0 FEFFFFEB 		bl	cmdSet
 6606              	.LVL724:
1135:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 6607              		.loc 1 1135 0
 6608 38d4 1C0097E5 		ldr	r0, [r7, #28]
 6609 38d8 FEFFFFEB 		bl	_txe_mutex_put
 6610              	.LVL725:
1141:../uvc.c      **** 					  }else{
 6611              		.loc 1 1141 0
 6612 38dc 34709DE5 		ldr	r7, [sp, #52]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6613              		.loc 1 1140 0
 6614 38e0 0130A0E3 		mov	r3, #1
1141:../uvc.c      **** 					  }else{
 6615              		.loc 1 1141 0
 6616 38e4 0D73CAE5 		strb	r7, [r10, #781]
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6617              		.loc 1 1138 0
 6618 38e8 38709DE5 		ldr	r7, [sp, #56]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6619              		.loc 1 1140 0
 6620 38ec E834CAE5 		strb	r3, [r10, #1256]
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6621              		.loc 1 1138 0
 6622 38f0 E574CAE5 		strb	r7, [r10, #1253]
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 6623              		.loc 1 1139 0
 6624 38f4 3C709DE5 		ldr	r7, [sp, #60]
 6625 38f8 E674CAE5 		strb	r7, [r10, #1254]
 6626 38fc 2C0000EA 		b	.L393
 6627              	.LVL726:
 6628              	.L729:
 6629              	.LBE201:
 6630              	.LBE257:
 6631              	.LBB258:
 6632              	.LBB212:
 986:../uvc.c      **** 		 {
 6633              		.loc 1 986 0
 6634 3900 810056E3 		cmp	r6, #129
 6635 3904 5E01000A 		beq	.L384
 6636 3908 C402008A 		bhi	.L385
 6637 390c 010056E3 		cmp	r6, #1
 6638 3910 2902001A 		bne	.L381
1149:../uvc.c      **** 					  {
 6639              		.loc 1 1149 0
 6640 3914 A4731FE5 		ldr	r7, .L740+120
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6641              		.loc 1 1057 0
 6642 3918 2000A0E3 		mov	r0, #32
 6643 391c B4131FE5 		ldr	r1, .L740+112
 6644 3920 40208DE2 		add	r2, sp, #64
 6645 3924 20308DE5 		str	r3, [sp, #32]
 6646 3928 1CC08DE5 		str	ip, [sp, #28]
 6647 392c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6648              	.LVL727:
1149:../uvc.c      **** 					  {
 6649              		.loc 1 1149 0
 6650 3930 B504D7E5 		ldrb	r0, [r7, #1205]	@ zero_extendqisi2
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6651              		.loc 1 1059 0
 6652 3934 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
1149:../uvc.c      **** 					  {
 6653              		.loc 1 1149 0
 6654 3938 010050E3 		cmp	r0, #1
 6655 393c 08005013 		cmpne	r0, #8
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6656              		.loc 1 1059 0
 6657 3940 2C708DE5 		str	r7, [sp, #44]
 6658              	.LVL728:
1060:../uvc.c      **** 			  value = Data1;
 6659              		.loc 1 1060 0
 6660 3944 9D70D9E5 		ldrb	r7, [r9, #157]	@ zero_extendqisi2
1149:../uvc.c      **** 					  {
 6661              		.loc 1 1149 0
 6662 3948 0000A013 		movne	r0, #0
 6663 394c 0100A003 		moveq	r0, #1
1060:../uvc.c      **** 			  value = Data1;
 6664              		.loc 1 1060 0
 6665 3950 30708DE5 		str	r7, [sp, #48]
 6666              	.LVL729:
1149:../uvc.c      **** 					  {
 6667              		.loc 1 1149 0
 6668 3954 BB03001A 		bne	.L392
 6669              	.LVL730:
1152:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 6670              		.loc 1 1152 0
 6671 3958 08741FE5 		ldr	r7, .L740+88
 6672 395c 0010E0E3 		mvn	r1, #0
 6673 3960 1C0097E5 		ldr	r0, [r7, #28]
 6674 3964 FEFFFFEB 		bl	_txe_mutex_get
 6675              	.LVL731:
1153:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6676              		.loc 1 1153 0
 6677 3968 2CE09DE5 		ldr	lr, [sp, #44]
 6678 396c 20309DE5 		ldr	r3, [sp, #32]
 6679 3970 1CC09DE5 		ldr	ip, [sp, #28]
 6680 3974 0010A0E3 		mov	r1, #0
 6681 3978 00E08DE5 		str	lr, [sp]
 6682 397c 0320A0E1 		mov	r2, r3
 6683 3980 0700A0E1 		mov	r0, r7
 6684 3984 0C30A0E1 		mov	r3, ip
 6685 3988 04108DE5 		str	r1, [sp, #4]
 6686 398c 2210A0E3 		mov	r1, #34
 6687 3990 FEFFFFEB 		bl	cmdSet
 6688              	.LVL732:
1154:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 6689              		.loc 1 1154 0
 6690 3994 1C0097E5 		ldr	r0, [r7, #28]
 6691 3998 FEFFFFEB 		bl	_txe_mutex_put
 6692              	.LVL733:
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6693              		.loc 1 1157 0
 6694 399c 2CE41FE5 		ldr	lr, .L740+120
 6695 39a0 2C709DE5 		ldr	r7, [sp, #44]
1159:../uvc.c      **** 					  }else{
 6696              		.loc 1 1159 0
 6697 39a4 4865CEE5 		strb	r6, [lr, #1352]
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6698              		.loc 1 1157 0
 6699 39a8 4575CEE5 		strb	r7, [lr, #1349]
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 6700              		.loc 1 1158 0
 6701 39ac 30709DE5 		ldr	r7, [sp, #48]
 6702 39b0 4675CEE5 		strb	r7, [lr, #1350]
 6703              	.LVL734:
 6704              	.L393:
1163:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 6705              		.loc 1 1163 0
 6706 39b4 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 6707              	.LVL735:
1164:../uvc.c      **** 
 6708              		.loc 1 1164 0
 6709 39b8 9D20D9E5 		ldrb	r2, [r9, #157]	@ zero_extendqisi2
 6710              	.LVL736:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6711              		.loc 1 980 0
 6712 39bc FF70A0E3 		mov	r7, #255
 6713 39c0 4DFDFFEA 		b	.L391
 6714              	.LVL737:
 6715              	.L730:
 6716              	.LBE212:
 6717              	.LBE258:
 6718              	.LBB259:
 6719              	.LBB233:
 986:../uvc.c      **** 		 {
 6720              		.loc 1 986 0
 6721 39c4 810056E3 		cmp	r6, #129
 6722 39c8 3B01000A 		beq	.L325
 6723 39cc 8F02008A 		bhi	.L326
 6724 39d0 010056E3 		cmp	r6, #1
 6725 39d4 EB01001A 		bne	.L322
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6726              		.loc 1 1057 0
 6727 39d8 70141FE5 		ldr	r1, .L740+112
 6728 39dc 40208DE2 		add	r2, sp, #64
 6729 39e0 2000A0E3 		mov	r0, #32
 6730 39e4 1CC08DE5 		str	ip, [sp, #28]
 6731 39e8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6732              	.LVL738:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6733              		.loc 1 1187 0
 6734 39ec 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6735              		.loc 1 1188 0
 6736 39f0 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6737              		.loc 1 1187 0
 6738 39f4 84741FE5 		ldr	r7, .L740+120
1188:../uvc.c      **** 			  		 break;
 6739              		.loc 1 1188 0
 6740 39f8 0400A0E3 		mov	r0, #4
 6741 39fc B0141FE5 		ldr	r1, .L740+84
 6742 3a00 0220A0E3 		mov	r2, #2
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6743              		.loc 1 1187 0
 6744 3a04 CDE4C7E5 		strb	lr, [r7, #1229]
1188:../uvc.c      **** 			  		 break;
 6745              		.loc 1 1188 0
 6746 3a08 FEFFFFEB 		bl	CyU3PDebugPrint
 6747              	.LVL739:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6748              		.loc 1 980 0
 6749 3a0c FF70A0E3 		mov	r7, #255
 6750 3a10 1CC09DE5 		ldr	ip, [sp, #28]
 6751 3a14 10FEFFEA 		b	.L415
 6752              	.LVL740:
 6753              	.L733:
 6754              	.LBE233:
 6755              	.LBE259:
 6756              	.LBE332:
 6757              	.LBE453:
 6758              	.LBB454:
 6759              	.LBB429:
 6760              	.LBB392:
 6761              	.LBB351:
 426:../uvc.c      **** 		 {
 6762              		.loc 1 426 0
 6763 3a18 810053E3 		cmp	r3, #129
 6764 3a1c FC02000A 		beq	.L485
 6765 3a20 A101008A 		bhi	.L486
 6766 3a24 010053E3 		cmp	r3, #1
 6767 3a28 5503001A 		bne	.L482
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6768              		.loc 1 664 0
 6769 3a2c 40208DE2 		add	r2, sp, #64
 6770 3a30 2000A0E3 		mov	r0, #32
 6771 3a34 CC141FE5 		ldr	r1, .L740+112
 6772 3a38 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6773              	.LVL741:
 666:../uvc.c      **** 			   {
 6774              		.loc 1 666 0
 6775 3a3c 002050E2 		subs	r2, r0, #0
 6776 3a40 D803001A 		bne	.L497
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6777              		.loc 1 768 0
 6778 3a44 000056E3 		cmp	r6, #0
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6779              		.loc 1 668 0
 6780 3a48 9C30D4E5 		ldrb	r3, [r4, #156]	@ zero_extendqisi2
 6781              	.LVL742:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6782              		.loc 1 671 0
 6783 3a4c 9E20D4E5 		ldrb	r2, [r4, #158]	@ zero_extendqisi2
 6784              	.LVL743:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6785              		.loc 1 768 0
 6786 3a50 2A00000A 		beq	.L499
 6787 3a54 010056E3 		cmp	r6, #1
 769:../uvc.c      **** 					 		 }
 6788              		.loc 1 769 0
 6789 3a58 9030C4E5 		strb	r3, [r4, #144]
 6790              	.LVL744:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6791              		.loc 1 768 0
 6792 3a5c 2700009A 		bls	.L499
 769:../uvc.c      **** 					 		 }
 6793              		.loc 1 769 0
 6794 3a60 9D10D4E5 		ldrb	r1, [r4, #157]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6795              		.loc 1 768 0
 6796 3a64 020056E3 		cmp	r6, #2
 769:../uvc.c      **** 					 		 }
 6797              		.loc 1 769 0
 6798 3a68 9110C4E5 		strb	r1, [r4, #145]
 6799              	.LVL745:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6800              		.loc 1 768 0
 6801 3a6c 2300000A 		beq	.L499
 6802 3a70 030056E3 		cmp	r6, #3
 769:../uvc.c      **** 					 		 }
 6803              		.loc 1 769 0
 6804 3a74 9220C4E5 		strb	r2, [r4, #146]
 6805              	.LVL746:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6806              		.loc 1 768 0
 6807 3a78 2000000A 		beq	.L499
 769:../uvc.c      **** 					 		 }
 6808              		.loc 1 769 0
 6809 3a7c 9F10D4E5 		ldrb	r1, [r4, #159]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6810              		.loc 1 768 0
 6811 3a80 040056E3 		cmp	r6, #4
 769:../uvc.c      **** 					 		 }
 6812              		.loc 1 769 0
 6813 3a84 9310C4E5 		strb	r1, [r4, #147]
 6814              	.LVL747:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6815              		.loc 1 768 0
 6816 3a88 1C00000A 		beq	.L499
 769:../uvc.c      **** 					 		 }
 6817              		.loc 1 769 0
 6818 3a8c A010D4E5 		ldrb	r1, [r4, #160]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6819              		.loc 1 768 0
 6820 3a90 050056E3 		cmp	r6, #5
 769:../uvc.c      **** 					 		 }
 6821              		.loc 1 769 0
 6822 3a94 9410C4E5 		strb	r1, [r4, #148]
 6823              	.LVL748:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6824              		.loc 1 768 0
 6825 3a98 1800000A 		beq	.L499
 769:../uvc.c      **** 					 		 }
 6826              		.loc 1 769 0
 6827 3a9c A110D4E5 		ldrb	r1, [r4, #161]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6828              		.loc 1 768 0
 6829 3aa0 060056E3 		cmp	r6, #6
 769:../uvc.c      **** 					 		 }
 6830              		.loc 1 769 0
 6831 3aa4 9510C4E5 		strb	r1, [r4, #149]
 6832              	.LVL749:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6833              		.loc 1 768 0
 6834 3aa8 1400000A 		beq	.L499
 769:../uvc.c      **** 					 		 }
 6835              		.loc 1 769 0
 6836 3aac A210D9E5 		ldrb	r1, [r9, #162]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6837              		.loc 1 768 0
 6838 3ab0 070056E3 		cmp	r6, #7
 769:../uvc.c      **** 					 		 }
 6839              		.loc 1 769 0
 6840 3ab4 9610C9E5 		strb	r1, [r9, #150]
 6841              	.LVL750:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6842              		.loc 1 768 0
 6843 3ab8 1000000A 		beq	.L499
 769:../uvc.c      **** 					 		 }
 6844              		.loc 1 769 0
 6845 3abc A310D4E5 		ldrb	r1, [r4, #163]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6846              		.loc 1 768 0
 6847 3ac0 080056E3 		cmp	r6, #8
 769:../uvc.c      **** 					 		 }
 6848              		.loc 1 769 0
 6849 3ac4 9710C4E5 		strb	r1, [r4, #151]
 6850              	.LVL751:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6851              		.loc 1 768 0
 6852 3ac8 0C00000A 		beq	.L499
 769:../uvc.c      **** 					 		 }
 6853              		.loc 1 769 0
 6854 3acc A410D4E5 		ldrb	r1, [r4, #164]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6855              		.loc 1 768 0
 6856 3ad0 090056E3 		cmp	r6, #9
 769:../uvc.c      **** 					 		 }
 6857              		.loc 1 769 0
 6858 3ad4 9810C4E5 		strb	r1, [r4, #152]
 6859              	.LVL752:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6860              		.loc 1 768 0
 6861 3ad8 0800000A 		beq	.L499
 769:../uvc.c      **** 					 		 }
 6862              		.loc 1 769 0
 6863 3adc A510D4E5 		ldrb	r1, [r4, #165]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6864              		.loc 1 768 0
 6865 3ae0 0A0056E3 		cmp	r6, #10
 769:../uvc.c      **** 					 		 }
 6866              		.loc 1 769 0
 6867 3ae4 9910C4E5 		strb	r1, [r4, #153]
 6868              	.LVL753:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6869              		.loc 1 768 0
 6870 3ae8 0400000A 		beq	.L499
 769:../uvc.c      **** 					 		 }
 6871              		.loc 1 769 0
 6872 3aec A610D4E5 		ldrb	r1, [r4, #166]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6873              		.loc 1 768 0
 6874 3af0 0B0056E3 		cmp	r6, #11
 769:../uvc.c      **** 					 		 }
 6875              		.loc 1 769 0
 6876 3af4 9A10C4E5 		strb	r1, [r4, #154]
 6877              	.LVL754:
 6878 3af8 A710D415 		ldrneb	r1, [r4, #167]	@ zero_extendqisi2
 6879 3afc 9B10C415 		strneb	r1, [r4, #155]
 6880              	.LVL755:
 6881              	.L499:
 771:../uvc.c      **** 							 break;
 6882              		.loc 1 771 0
 6883 3b00 24208DE5 		str	r2, [sp, #36]
 6884 3b04 20308DE5 		str	r3, [sp, #32]
 6885 3b08 FEFFFFEB 		bl	I2CCmdHandler
 6886              	.LVL756:
 6887 3b0c 24209DE5 		ldr	r2, [sp, #36]
 6888 3b10 20309DE5 		ldr	r3, [sp, #32]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6889              		.loc 1 414 0
 6890 3b14 FF70A0E3 		mov	r7, #255
 6891 3b18 07C0A0E1 		mov	ip, r7
 6892              	.LVL757:
 6893              	.L492:
 960:../uvc.c      **** }
 6894              		.loc 1 960 0
 6895 3b1c 04108DE8 		stmia	sp, {r2, ip}
 6896 3b20 C4151FE5 		ldr	r1, .L740+100
 6897 3b24 08708DE5 		str	r7, [sp, #8]
 6898 3b28 28209DE5 		ldr	r2, [sp, #40]
 6899              	.LVL758:
 6900 3b2c 0400A0E3 		mov	r0, #4
 6901 3b30 FEFFFFEB 		bl	CyU3PDebugPrint
 6902              	.LVL759:
 6903 3b34 48309DE5 		ldr	r3, [sp, #72]
 6904 3b38 A7FAFFEA 		b	.L259
 6905              	.LVL760:
 6906              	.L735:
 6907              	.LBE351:
 6908              	.LBE392:
 6909              	.LBB393:
 6910              	.LBB371:
 426:../uvc.c      **** 		 {
 6911              		.loc 1 426 0
 6912 3b3c 810057E3 		cmp	r7, #129
 6913 3b40 1803000A 		beq	.L459
 6914 3b44 5001008A 		bhi	.L460
 6915 3b48 010057E3 		cmp	r7, #1
 6916 3b4c B401001A 		bne	.L469
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6917              		.loc 1 664 0
 6918 3b50 40208DE2 		add	r2, sp, #64
 6919 3b54 2000A0E3 		mov	r0, #32
 6920 3b58 F0151FE5 		ldr	r1, .L740+112
 6921 3b5c 20308DE5 		str	r3, [sp, #32]
 6922 3b60 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6923              	.LVL761:
 666:../uvc.c      **** 			   {
 6924              		.loc 1 666 0
 6925 3b64 002050E2 		subs	r2, r0, #0
 6926 3b68 3A03001A 		bne	.L481
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 6927              		.loc 1 940 0
 6928 3b6c 1CE61FE5 		ldr	lr, .L740+88
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6929              		.loc 1 668 0
 6930 3b70 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
 6931              	.LVL762:
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 6932              		.loc 1 940 0
 6933 3b74 1C009EE5 		ldr	r0, [lr, #28]
 6934              	.LVL763:
 6935 3b78 0010E0E3 		mvn	r1, #0
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6936              		.loc 1 671 0
 6937 3b7c 9E60D4E5 		ldrb	r6, [r4, #158]	@ zero_extendqisi2
 6938              	.LVL764:
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 6939              		.loc 1 940 0
 6940 3b80 24208DE5 		str	r2, [sp, #36]
 6941 3b84 1CC08DE5 		str	ip, [sp, #28]
 6942 3b88 FEFFFFEB 		bl	_txe_mutex_get
 6943              	.LVL765:
 941:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6944              		.loc 1 941 0
 6945 3b8c 1CC09DE5 		ldr	ip, [sp, #28]
 6946 3b90 24209DE5 		ldr	r2, [sp, #36]
 6947 3b94 00C08DE5 		str	ip, [sp]
 6948 3b98 20309DE5 		ldr	r3, [sp, #32]
 6949 3b9c 04208DE5 		str	r2, [sp, #4]
 6950 3ba0 1310A0E3 		mov	r1, #19
 6951 3ba4 28209DE5 		ldr	r2, [sp, #40]
 6952 3ba8 58061FE5 		ldr	r0, .L740+88
 6953 3bac FEFFFFEB 		bl	cmdSet
 6954              	.LVL766:
 942:../uvc.c      **** 
 6955              		.loc 1 942 0
 6956 3bb0 60161FE5 		ldr	r1, .L740+88
 6957 3bb4 1C0091E5 		ldr	r0, [r1, #28]
 6958 3bb8 FEFFFFEB 		bl	_txe_mutex_put
 6959              	.LVL767:
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 6960              		.loc 1 944 0
 6961 3bbc 1CC09DE5 		ldr	ip, [sp, #28]
 6962 3bc0 50261FE5 		ldr	r2, .L740+120
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6963              		.loc 1 414 0
 6964 3bc4 FF30A0E3 		mov	r3, #255
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 6965              		.loc 1 944 0
 6966 3bc8 55C3C2E5 		strb	ip, [r2, #853]
 945:../uvc.c      **** 							 break;
 6967              		.loc 1 945 0
 6968 3bcc 5873C2E5 		strb	r7, [r2, #856]
 6969 3bd0 7C0000EA 		b	.L479
 6970              	.LVL768:
 6971              	.L734:
 6972              	.LBE371:
 6973              	.LBE393:
 6974              	.LBB394:
 6975              	.LBB361:
 426:../uvc.c      **** 		 {
 6976              		.loc 1 426 0
 6977 3bd4 810056E3 		cmp	r6, #129
 6978 3bd8 F702000A 		beq	.L504
 6979 3bdc 0E01008A 		bhi	.L505
 6980 3be0 010056E3 		cmp	r6, #1
 6981 3be4 DC02001A 		bne	.L501
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6982              		.loc 1 664 0
 6983 3be8 40208DE2 		add	r2, sp, #64
 6984 3bec 2000A0E3 		mov	r0, #32
 6985 3bf0 88161FE5 		ldr	r1, .L740+112
 6986 3bf4 20308DE5 		str	r3, [sp, #32]
 6987 3bf8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6988              	.LVL769:
 666:../uvc.c      **** 			   {
 6989              		.loc 1 666 0
 6990 3bfc 002050E2 		subs	r2, r0, #0
 6991 3c00 7003001A 		bne	.L512
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6992              		.loc 1 811 0
 6993 3c04 B4E61FE5 		ldr	lr, .L740+88
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6994              		.loc 1 668 0
 6995 3c08 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
 6996              	.LVL770:
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6997              		.loc 1 811 0
 6998 3c0c 1C009EE5 		ldr	r0, [lr, #28]
 6999              	.LVL771:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7000              		.loc 1 671 0
 7001 3c10 9EE0D4E5 		ldrb	lr, [r4, #158]	@ zero_extendqisi2
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 7002              		.loc 1 811 0
 7003 3c14 0010E0E3 		mvn	r1, #0
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7004              		.loc 1 671 0
 7005 3c18 28E08DE5 		str	lr, [sp, #40]
 7006              	.LVL772:
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 7007              		.loc 1 811 0
 7008 3c1c 24208DE5 		str	r2, [sp, #36]
 7009 3c20 1CC08DE5 		str	ip, [sp, #28]
 7010 3c24 FEFFFFEB 		bl	_txe_mutex_get
 7011              	.LVL773:
 812:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 7012              		.loc 1 812 0
 7013 3c28 1CC09DE5 		ldr	ip, [sp, #28]
 7014 3c2c 24209DE5 		ldr	r2, [sp, #36]
 7015 3c30 20309DE5 		ldr	r3, [sp, #32]
 7016 3c34 00C08DE5 		str	ip, [sp]
 7017 3c38 04208DE5 		str	r2, [sp, #4]
 7018 3c3c 2510A0E3 		mov	r1, #37
 7019 3c40 0320A0E1 		mov	r2, r3
 7020 3c44 F4061FE5 		ldr	r0, .L740+88
 7021 3c48 0730A0E1 		mov	r3, r7
 7022 3c4c FEFFFFEB 		bl	cmdSet
 7023              	.LVL774:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 7024              		.loc 1 813 0
 7025 3c50 00171FE5 		ldr	r1, .L740+88
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7026              		.loc 1 414 0
 7027 3c54 FF70A0E3 		mov	r7, #255
 7028              	.LVL775:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 7029              		.loc 1 813 0
 7030 3c58 1C0091E5 		ldr	r0, [r1, #28]
 7031 3c5c FEFFFFEB 		bl	_txe_mutex_put
 7032              	.LVL776:
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 7033              		.loc 1 814 0
 7034 3c60 1CC09DE5 		ldr	ip, [sp, #28]
 7035 3c64 28309DE5 		ldr	r3, [sp, #40]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7036              		.loc 1 414 0
 7037 3c68 0720A0E1 		mov	r2, r7
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 7038              		.loc 1 814 0
 7039 3c6c 85C0CAE5 		strb	ip, [r10, #133]
 815:../uvc.c      **** 							 break;
 7040              		.loc 1 815 0
 7041 3c70 8860CAE5 		strb	r6, [r10, #136]
 7042              	.LVL777:
 7043              	.L511:
 960:../uvc.c      **** }
 7044              		.loc 1 960 0
 7045 3c74 00308DE5 		str	r3, [sp]
 7046 3c78 84008DE9 		stmib	sp, {r2, r7}
 7047 3c7c 20171FE5 		ldr	r1, .L740+100
 7048 3c80 0C30A0E1 		mov	r3, ip
 7049 3c84 0620A0E1 		mov	r2, r6
 7050              	.LVL778:
 7051 3c88 0400A0E3 		mov	r0, #4
 7052 3c8c FEFFFFEB 		bl	CyU3PDebugPrint
 7053              	.LVL779:
 7054 3c90 48309DE5 		ldr	r3, [sp, #72]
 7055 3c94 50FAFFEA 		b	.L259
 7056              	.LVL780:
 7057              	.L736:
 7058              	.LBE361:
 7059              	.LBE394:
 7060              	.LBB395:
 7061              	.LBB381:
 426:../uvc.c      **** 		 {
 7062              		.loc 1 426 0
 7063 3c98 810057E3 		cmp	r7, #129
 7064 3c9c 4D02000A 		beq	.L472
 7065 3ca0 FD00008A 		bhi	.L473
 7066 3ca4 010057E3 		cmp	r7, #1
 7067 3ca8 5D01001A 		bne	.L469
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 7068              		.loc 1 664 0
 7069 3cac 40208DE2 		add	r2, sp, #64
 7070 3cb0 2000A0E3 		mov	r0, #32
 7071 3cb4 4C171FE5 		ldr	r1, .L740+112
 7072 3cb8 20308DE5 		str	r3, [sp, #32]
 7073 3cbc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 7074              	.LVL781:
 666:../uvc.c      **** 			   {
 7075              		.loc 1 666 0
 7076 3cc0 002050E2 		subs	r2, r0, #0
 7077 3cc4 E302001A 		bne	.L481
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7078              		.loc 1 762 0
 7079 3cc8 78E71FE5 		ldr	lr, .L740+88
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 7080              		.loc 1 668 0
 7081 3ccc 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
 7082              	.LVL782:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7083              		.loc 1 762 0
 7084 3cd0 1C009EE5 		ldr	r0, [lr, #28]
 7085              	.LVL783:
 7086 3cd4 0010E0E3 		mvn	r1, #0
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7087              		.loc 1 671 0
 7088 3cd8 9E60D4E5 		ldrb	r6, [r4, #158]	@ zero_extendqisi2
 7089              	.LVL784:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7090              		.loc 1 762 0
 7091 3cdc 24208DE5 		str	r2, [sp, #36]
 7092 3ce0 1CC08DE5 		str	ip, [sp, #28]
 7093 3ce4 FEFFFFEB 		bl	_txe_mutex_get
 7094              	.LVL785:
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 7095              		.loc 1 763 0
 7096 3ce8 1CC09DE5 		ldr	ip, [sp, #28]
 7097 3cec 24209DE5 		ldr	r2, [sp, #36]
 7098 3cf0 01107CE2 		rsbs	r1, ip, #1
 7099 3cf4 0010A033 		movcc	r1, #0
 7100 3cf8 20309DE5 		ldr	r3, [sp, #32]
 7101 3cfc 04208DE5 		str	r2, [sp, #4]
 7102 3d00 00108DE5 		str	r1, [sp]
 7103 3d04 28209DE5 		ldr	r2, [sp, #40]
 7104 3d08 1E10A0E3 		mov	r1, #30
 7105 3d0c BC071FE5 		ldr	r0, .L740+88
 7106 3d10 FEFFFFEB 		bl	cmdSet
 7107              	.LVL786:
 764:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 7108              		.loc 1 764 0
 7109 3d14 C4171FE5 		ldr	r1, .L740+88
 7110 3d18 1C0091E5 		ldr	r0, [r1, #28]
 7111 3d1c FEFFFFEB 		bl	_txe_mutex_put
 7112              	.LVL787:
 765:../uvc.c      **** 							 break;
 7113              		.loc 1 765 0
 7114 3d20 B0271FE5 		ldr	r2, .L740+120
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7115              		.loc 1 414 0
 7116 3d24 FF30A0E3 		mov	r3, #255
 765:../uvc.c      **** 							 break;
 7117              		.loc 1 765 0
 7118 3d28 6074C2E5 		strb	r7, [r2, #1120]
 7119 3d2c 1CC09DE5 		ldr	ip, [sp, #28]
 7120 3d30 240000EA 		b	.L479
 7121              	.LVL788:
 7122              	.L561:
 7123              	.LBE381:
 7124              	.LBE395:
 7125              	.LBE429:
 7126              	.LBE454:
 7127              	.LBB455:
 7128              	.LBB134:
3246:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 7129              		.loc 1 3246 0
 7130 3d34 B024DDE1 		ldrh	r2, [sp, #64]
 7131 3d38 E4171FE5 		ldr	r1, .L740+92
 7132 3d3c C430D9E5 		ldrb	r3, [r9, #196]	@ zero_extendqisi2
 7133 3d40 0400A0E3 		mov	r0, #4
 7134              	.LVL789:
 7135 3d44 FEFFFFEB 		bl	CyU3PDebugPrint
 7136              	.LVL790:
3247:../uvc.c      ****                         }
 7137              		.loc 1 3247 0
 7138 3d48 0000A0E3 		mov	r0, #0
 7139 3d4c 0020A0E1 		mov	r2, r0
 7140 3d50 0110A0E3 		mov	r1, #1
 7141 3d54 FEFFFFEB 		bl	CyU3PUsbStall
 7142              	.LVL791:
 7143 3d58 28FAFFEA 		b	.L528
 7144              	.LVL792:
 7145              	.L709:
 7146 3d5c 0060A0E1 		mov	r6, r0
 7147              	.LBE134:
 7148              	.LBE455:
3410:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 7149              		.loc 1 3410 0
 7150 3d60 08181FE5 		ldr	r1, .L740+96
 7151 3d64 0700A0E1 		mov	r0, r7
 7152              	.LVL793:
 7153 3d68 0620A0E1 		mov	r2, r6
 7154 3d6c FEFFFFEB 		bl	CyU3PDebugPrint
 7155              	.LVL794:
3411:../uvc.c      **** 					}
 7156              		.loc 1 3411 0
 7157 3d70 0600A0E1 		mov	r0, r6
 7158 3d74 FEFFFFEB 		bl	CyFxAppErrorHandler
 7159              	.LVL795:
 7160              	.L387:
 7161              	.LBB456:
 7162              	.LBB333:
 7163              	.LBB260:
 7164              	.LBB213:
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 7165              		.loc 1 990 0
 7166 3d78 28709DE5 		ldr	r7, [sp, #40]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 7167              		.loc 1 991 0
 7168 3d7c 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7169              		.loc 1 992 0
 7170 3d80 0200A0E3 		mov	r0, #2
 7171 3d84 1C181FE5 		ldr	r1, .L740+112
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 7172              		.loc 1 990 0
 7173 3d88 9C70C9E5 		strb	r7, [r9, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 7174              		.loc 1 991 0
 7175 3d8c 9D30C9E5 		strb	r3, [r9, #157]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7176              		.loc 1 992 0
 7177 3d90 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7178              	.LVL796:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7179              		.loc 1 980 0
 7180 3d94 FF20A0E3 		mov	r2, #255
 7181 3d98 0230A0E1 		mov	r3, r2
 993:../uvc.c      **** 			  break;
 7182              		.loc 1 993 0
 7183 3d9c 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 7184              	.LVL797:
 7185 3da0 55FCFFEA 		b	.L391
 7186              	.LVL798:
 7187              	.L475:
 7188              	.LBE213:
 7189              	.LBE260:
 7190              	.LBE333:
 7191              	.LBE456:
 7192              	.LBB457:
 7193              	.LBB430:
 7194              	.LBB396:
 7195              	.LBB382:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7196              		.loc 1 432 0
 7197 3da4 3C181FE5 		ldr	r1, .L740+112
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 7198              		.loc 1 431 0
 7199 3da8 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7200              		.loc 1 432 0
 7201 3dac 0200A0E3 		mov	r0, #2
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 7202              		.loc 1 430 0
 7203 3db0 9C60C9E5 		strb	r6, [r9, #156]
 7204              	.L684:
 595:../uvc.c      **** 			 }
 7205              		.loc 1 595 0
 7206 3db4 9D30C9E5 		strb	r3, [r9, #157]
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7207              		.loc 1 597 0
 7208 3db8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7209              	.LVL799:
 598:../uvc.c      **** 			  break;
 7210              		.loc 1 598 0
 7211 3dbc 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 7212              	.LVL800:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7213              		.loc 1 414 0
 7214 3dc0 FF60A0E3 		mov	r6, #255
 7215 3dc4 06C0A0E1 		mov	ip, r6
 7216              	.LVL801:
 7217              	.L479:
 960:../uvc.c      **** }
 7218              		.loc 1 960 0
 7219 3dc8 FF10A0E3 		mov	r1, #255
 7220 3dcc 04308DE5 		str	r3, [sp, #4]
 7221 3dd0 08108DE5 		str	r1, [sp, #8]
 7222 3dd4 0C30A0E1 		mov	r3, ip
 7223              	.LVL802:
 7224 3dd8 00608DE5 		str	r6, [sp]
 7225 3ddc 0720A0E1 		mov	r2, r7
 7226 3de0 0400A0E3 		mov	r0, #4
 7227 3de4 88181FE5 		ldr	r1, .L740+100
 7228 3de8 FEFFFFEB 		bl	CyU3PDebugPrint
 7229              	.LVL803:
 7230 3dec 48309DE5 		ldr	r3, [sp, #72]
 7231 3df0 F9F9FFEA 		b	.L259
 7232              	.LVL804:
 7233              	.L309:
 7234              	.LBE382:
 7235              	.LBE396:
 7236              	.LBE430:
 7237              	.LBE457:
 7238              	.LBB458:
 7239              	.LBB334:
 7240              	.LBB261:
 7241              	.LBB143:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7242              		.loc 1 1000 0
 7243 3df4 84E81FE5 		ldr	lr, .L740+120
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7244              		.loc 1 1002 0
 7245 3df8 0030A0E3 		mov	r3, #0
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7246              		.loc 1 1000 0
 7247 3dfc B564DEE5 		ldrb	r6, [lr, #1205]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7248              		.loc 1 1001 0
 7249 3e00 B624DEE5 		ldrb	r2, [lr, #1206]	@ zero_extendqisi2
1008:../uvc.c      **** 
 7250              		.loc 1 1008 0
 7251 3e04 2C009DE5 		ldr	r0, [sp, #44]
 7252 3e08 A0181FE5 		ldr	r1, .L740+112
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7253              		.loc 1 1000 0
 7254 3e0c 9C60C9E5 		strb	r6, [r9, #156]
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7255              		.loc 1 1001 0
 7256 3e10 9D20C9E5 		strb	r2, [r9, #157]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7257              		.loc 1 1002 0
 7258 3e14 9E30C9E5 		strb	r3, [r9, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7259              		.loc 1 1003 0
 7260 3e18 9F30C9E5 		strb	r3, [r9, #159]
 7261              	.LVL805:
1008:../uvc.c      **** 
 7262              		.loc 1 1008 0
 7263 3e1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7264              	.LVL806:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7265              		.loc 1 980 0
 7266 3e20 FFC0A0E3 		mov	ip, #255
 7267 3e24 2C709DE5 		ldr	r7, [sp, #44]
 7268 3e28 CCFAFFEA 		b	.L316
 7269              	.LVL807:
 7270              	.L302:
 7271              	.LBE143:
 7272              	.LBE261:
 7273              	.LBB262:
 7274              	.LBB225:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7275              		.loc 1 1033 0
 7276 3e2c BC781FE5 		ldr	r7, .L740+120
 7277 3e30 9714D7E5 		ldrb	r1, [r7, #1175]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7278              		.loc 1 1034 0
 7279 3e34 9824D7E5 		ldrb	r2, [r7, #1176]	@ zero_extendqisi2
 7280 3e38 40FBFFEA 		b	.L679
 7281              	.LVL808:
 7282              	.L388:
 7283              	.LBE225:
 7284              	.LBE262:
 7285              	.LBB263:
 7286              	.LBB214:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7287              		.loc 1 1033 0
 7288 3e3c CC781FE5 		ldr	r7, .L740+120
 7289 3e40 3F15D7E5 		ldrb	r1, [r7, #1343]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7290              		.loc 1 1034 0
 7291 3e44 4025D7E5 		ldrb	r2, [r7, #1344]	@ zero_extendqisi2
 7292 3e48 20FCFFEA 		b	.L677
 7293              	.LVL809:
 7294              	.L329:
 7295              	.LBE214:
 7296              	.LBE263:
 7297              	.LBB264:
 7298              	.LBB234:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7299              		.loc 1 1033 0
 7300 3e4c DC781FE5 		ldr	r7, .L740+120
 7301 3e50 C714D7E5 		ldrb	r1, [r7, #1223]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7302              		.loc 1 1034 0
 7303 3e54 C824D7E5 		ldrb	r2, [r7, #1224]	@ zero_extendqisi2
 7304 3e58 38FBFFEA 		b	.L679
 7305              	.LVL810:
 7306              	.L313:
 7307              	.LBE234:
 7308              	.LBE264:
 7309              	.LBB265:
 7310              	.LBB144:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7311              		.loc 1 1033 0
 7312 3e5c AF14DAE5 		ldrb	r1, [r10, #1199]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7313              		.loc 1 1034 0
 7314 3e60 B024DAE5 		ldrb	r2, [r10, #1200]	@ zero_extendqisi2
 7315 3e64 B2FAFFEA 		b	.L670
 7316              	.LVL811:
 7317              	.L423:
 7318              	.LBE144:
 7319              	.LBE265:
 7320              	.LBB266:
 7321              	.LBB182:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7322              		.loc 1 1033 0
 7323 3e68 8705DAE5 		ldrb	r0, [r10, #1415]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7324              		.loc 1 1034 0
 7325 3e6c 8815DAE5 		ldrb	r1, [r10, #1416]	@ zero_extendqisi2
 7326 3e70 C0FBFFEA 		b	.L681
 7327              	.LVL812:
 7328              	.L340:
 7329              	.LBE182:
 7330              	.LBE266:
 7331              	.LBB267:
 7332              	.LBB202:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7333              		.loc 1 1033 0
 7334 3e74 04791FE5 		ldr	r7, .L740+120
 7335 3e78 DF14D7E5 		ldrb	r1, [r7, #1247]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7336              		.loc 1 1034 0
 7337 3e7c E024D7E5 		ldrb	r2, [r7, #1248]	@ zero_extendqisi2
 7338 3e80 12FCFFEA 		b	.L677
 7339              	.LVL813:
 7340              	.L384:
 7341              	.LBE202:
 7342              	.LBE267:
 7343              	.LBB268:
 7344              	.LBB215:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7345              		.loc 1 1000 0
 7346 3e84 14E91FE5 		ldr	lr, .L740+120
 7347 3e88 4575DEE5 		ldrb	r7, [lr, #1349]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7348              		.loc 1 1001 0
 7349 3e8c 4625DEE5 		ldrb	r2, [lr, #1350]	@ zero_extendqisi2
 7350              	.LVL814:
 7351              	.L703:
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7352              		.loc 1 1002 0
 7353 3e90 0030A0E3 		mov	r3, #0
1008:../uvc.c      **** 
 7354              		.loc 1 1008 0
 7355 3e94 28009DE5 		ldr	r0, [sp, #40]
 7356 3e98 30191FE5 		ldr	r1, .L740+112
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7357              		.loc 1 1001 0
 7358 3e9c 9D20C9E5 		strb	r2, [r9, #157]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7359              		.loc 1 1002 0
 7360 3ea0 9E30C9E5 		strb	r3, [r9, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7361              		.loc 1 1003 0
 7362 3ea4 9F30C9E5 		strb	r3, [r9, #159]
 7363              	.LVL815:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7364              		.loc 1 1000 0
 7365 3ea8 9C70C9E5 		strb	r7, [r9, #156]
1008:../uvc.c      **** 
 7366              		.loc 1 1008 0
 7367 3eac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7368              	.LVL816:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7369              		.loc 1 980 0
 7370 3eb0 FF20A0E3 		mov	r2, #255
 7371 3eb4 0230A0E1 		mov	r3, r2
 7372 3eb8 0FFCFFEA 		b	.L391
 7373              	.LVL817:
 7374              	.L325:
 7375              	.LBE215:
 7376              	.LBE268:
 7377              	.LBB269:
 7378              	.LBB235:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7379              		.loc 1 1000 0
 7380 3ebc 4CE91FE5 		ldr	lr, .L740+120
 7381 3ec0 CD74DEE5 		ldrb	r7, [lr, #1229]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7382              		.loc 1 1001 0
 7383 3ec4 CE24DEE5 		ldrb	r2, [lr, #1230]	@ zero_extendqisi2
 7384              	.LVL818:
 7385              	.L697:
 7386              	.LBE235:
 7387              	.LBE269:
 7388              	.LBB270:
 7389              	.LBB165:
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7390              		.loc 1 1002 0
 7391 3ec8 0030A0E3 		mov	r3, #0
1008:../uvc.c      **** 
 7392              		.loc 1 1008 0
 7393 3ecc 0C00A0E1 		mov	r0, ip
 7394 3ed0 68191FE5 		ldr	r1, .L740+112
 7395 3ed4 1CC08DE5 		str	ip, [sp, #28]
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7396              		.loc 1 1000 0
 7397 3ed8 9C70C9E5 		strb	r7, [r9, #156]
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7398              		.loc 1 1001 0
 7399 3edc 9D20C9E5 		strb	r2, [r9, #157]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7400              		.loc 1 1002 0
 7401 3ee0 9E30C9E5 		strb	r3, [r9, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7402              		.loc 1 1003 0
 7403 3ee4 9F30C9E5 		strb	r3, [r9, #159]
 7404              	.LVL819:
1008:../uvc.c      **** 
 7405              		.loc 1 1008 0
 7406 3ee8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7407              	.LVL820:
 7408 3eec 1CC09DE5 		ldr	ip, [sp, #28]
 7409 3ef0 D9FCFFEA 		b	.L415
 7410              	.LVL821:
 7411              	.L412:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7412              		.loc 1 1033 0
 7413 3ef4 84791FE5 		ldr	r7, .L740+120
 7414 3ef8 6F15D7E5 		ldrb	r1, [r7, #1391]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7415              		.loc 1 1034 0
 7416 3efc 7025D7E5 		ldrb	r2, [r7, #1392]	@ zero_extendqisi2
 7417 3f00 0EFBFFEA 		b	.L679
 7418              	.LVL822:
 7419              	.L377:
 7420              	.LBE165:
 7421              	.LBE270:
 7422              	.LBB271:
 7423              	.LBB243:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7424              		.loc 1 1033 0
 7425 3f04 94791FE5 		ldr	r7, .L740+120
 7426 3f08 2715D7E5 		ldrb	r1, [r7, #1319]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7427              		.loc 1 1034 0
 7428 3f0c 2825D7E5 		ldrb	r2, [r7, #1320]	@ zero_extendqisi2
 7429 3f10 0AFBFFEA 		b	.L679
 7430              	.LVL823:
 7431              	.L366:
 7432              	.LBE243:
 7433              	.LBE271:
 7434              	.LBB272:
 7435              	.LBB193:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7436              		.loc 1 1033 0
 7437 3f14 A4291FE5 		ldr	r2, .L740+120
 7438 3f18 0F15D2E5 		ldrb	r1, [r2, #1295]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7439              		.loc 1 1034 0
 7440 3f1c 1025D2E5 		ldrb	r2, [r2, #1296]	@ zero_extendqisi2
 7441 3f20 06FBFFEA 		b	.L679
 7442              	.LVL824:
 7443              	.L401:
 7444              	.LBE193:
 7445              	.LBE272:
 7446              	.LBB273:
 7447              	.LBB174:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7448              		.loc 1 1033 0
 7449 3f24 5715DAE5 		ldrb	r1, [r10, #1367]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7450              		.loc 1 1034 0
 7451 3f28 5825DAE5 		ldrb	r2, [r10, #1368]	@ zero_extendqisi2
 7452 3f2c 03FBFFEA 		b	.L679
 7453              	.L397:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7454              		.loc 1 1000 0
 7455 3f30 5D75DAE5 		ldrb	r7, [r10, #1373]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7456              		.loc 1 1001 0
 7457 3f34 5E25DAE5 		ldrb	r2, [r10, #1374]	@ zero_extendqisi2
 7458 3f38 E2FFFFEA 		b	.L697
 7459              	.LVL825:
 7460              	.L408:
 7461              	.LBE174:
 7462              	.LBE273:
 7463              	.LBB274:
 7464              	.LBB166:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7465              		.loc 1 1000 0
 7466 3f3c CC191FE5 		ldr	r1, .L740+120
 7467 3f40 7575D1E5 		ldrb	r7, [r1, #1397]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7468              		.loc 1 1001 0
 7469 3f44 7625D1E5 		ldrb	r2, [r1, #1398]	@ zero_extendqisi2
 7470 3f48 DEFFFFEA 		b	.L697
 7471              	.LVL826:
 7472              	.L298:
 7473              	.LBE166:
 7474              	.LBE274:
 7475              	.LBB275:
 7476              	.LBB226:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7477              		.loc 1 1000 0
 7478 3f4c DC191FE5 		ldr	r1, .L740+120
 7479 3f50 9D74D1E5 		ldrb	r7, [r1, #1181]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7480              		.loc 1 1001 0
 7481 3f54 9E24D1E5 		ldrb	r2, [r1, #1182]	@ zero_extendqisi2
 7482 3f58 DAFFFFEA 		b	.L697
 7483              	.LVL827:
 7484              	.L351:
 7485              	.LBE226:
 7486              	.LBE275:
 7487              	.LBB276:
 7488              	.LBB154:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7489              		.loc 1 1000 0
 7490 3f5c ECE91FE5 		ldr	lr, .L740+120
 7491 3f60 FD74DEE5 		ldrb	r7, [lr, #1277]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7492              		.loc 1 1001 0
 7493 3f64 FE24DEE5 		ldrb	r2, [lr, #1278]	@ zero_extendqisi2
 7494 3f68 D6FFFFEA 		b	.L697
 7495              	.LVL828:
 7496              	.L362:
 7497              	.LBE154:
 7498              	.LBE276:
 7499              	.LBB277:
 7500              	.LBB194:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7501              		.loc 1 1000 0
 7502 3f6c FC391FE5 		ldr	r3, .L740+120
 7503 3f70 1575D3E5 		ldrb	r7, [r3, #1301]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7504              		.loc 1 1001 0
 7505 3f74 1625D3E5 		ldrb	r2, [r3, #1302]	@ zero_extendqisi2
 7506 3f78 D2FFFFEA 		b	.L697
 7507              	.LVL829:
 7508              	.L419:
 7509              	.LBE194:
 7510              	.LBE277:
 7511              	.LBB278:
 7512              	.LBB183:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7513              		.loc 1 1000 0
 7514 3f7c 0C7A1FE5 		ldr	r7, .L740+120
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7515              		.loc 1 1002 0
 7516 3f80 0020A0E3 		mov	r2, #0
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7517              		.loc 1 1001 0
 7518 3f84 8E15D7E5 		ldrb	r1, [r7, #1422]	@ zero_extendqisi2
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7519              		.loc 1 1000 0
 7520 3f88 8D35D7E5 		ldrb	r3, [r7, #1421]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7521              		.loc 1 1001 0
 7522 3f8c 9D10C9E5 		strb	r1, [r9, #157]
1008:../uvc.c      **** 
 7523              		.loc 1 1008 0
 7524 3f90 28009DE5 		ldr	r0, [sp, #40]
 7525 3f94 2C1A1FE5 		ldr	r1, .L740+112
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7526              		.loc 1 980 0
 7527 3f98 FF70A0E3 		mov	r7, #255
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7528              		.loc 1 1000 0
 7529 3f9c 9C30C9E5 		strb	r3, [r9, #156]
1008:../uvc.c      **** 
 7530              		.loc 1 1008 0
 7531 3fa0 20308DE5 		str	r3, [sp, #32]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7532              		.loc 1 1002 0
 7533 3fa4 9E20C9E5 		strb	r2, [r9, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7534              		.loc 1 1003 0
 7535 3fa8 9F20C9E5 		strb	r2, [r9, #159]
 7536              	.LVL830:
1008:../uvc.c      **** 
 7537              		.loc 1 1008 0
 7538 3fac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7539              	.LVL831:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7540              		.loc 1 980 0
 7541 3fb0 2C708DE5 		str	r7, [sp, #44]
 7542 3fb4 20309DE5 		ldr	r3, [sp, #32]
 7543 3fb8 7AFBFFEA 		b	.L426
 7544              	.LVL832:
 7545              	.L373:
 7546              	.LBE183:
 7547              	.LBE278:
 7548              	.LBB279:
 7549              	.LBB244:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7550              		.loc 1 1000 0
 7551 3fbc 4CEA1FE5 		ldr	lr, .L740+120
 7552 3fc0 2D75DEE5 		ldrb	r7, [lr, #1325]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7553              		.loc 1 1001 0
 7554 3fc4 2E25DEE5 		ldrb	r2, [lr, #1326]	@ zero_extendqisi2
 7555 3fc8 BEFFFFEA 		b	.L697
 7556              	.LVL833:
 7557              	.L355:
 7558              	.LBE244:
 7559              	.LBE279:
 7560              	.LBB280:
 7561              	.LBB155:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7562              		.loc 1 1033 0
 7563 3fcc F714DAE5 		ldrb	r1, [r10, #1271]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7564              		.loc 1 1034 0
 7565 3fd0 F824DAE5 		ldrb	r2, [r10, #1272]	@ zero_extendqisi2
 7566 3fd4 D9FAFFEA 		b	.L679
 7567              	.LVL834:
 7568              	.L336:
 7569              	.LBE155:
 7570              	.LBE280:
 7571              	.LBB281:
 7572              	.LBB203:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7573              		.loc 1 1000 0
 7574 3fd8 68EA1FE5 		ldr	lr, .L740+120
 7575 3fdc E574DEE5 		ldrb	r7, [lr, #1253]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7576              		.loc 1 1001 0
 7577 3fe0 E624DEE5 		ldrb	r2, [lr, #1254]	@ zero_extendqisi2
 7578 3fe4 A9FFFFEA 		b	.L703
 7579              	.LVL835:
 7580              	.L540:
 7581              	.LBE203:
 7582              	.LBE281:
 7583              	.LBE334:
 7584              	.LBE458:
 7585              	.LBB459:
 7586              	.LBB135:
3039:../uvc.c      ****                          		CyU3PThreadSleep(500);
 7587              		.loc 1 3039 0
 7588 3fe8 3010A0E3 		mov	r1, #48
 7589 3fec 0020A0E3 		mov	r2, #0
 7590 3ff0 5230A0E3 		mov	r3, #82
 7591 3ff4 0B00A0E3 		mov	r0, #11
 7592              	.LVL836:
 7593 3ff8 FEFFFFEB 		bl	SensorSetIrisControl
 7594              	.LVL837:
3040:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
 7595              		.loc 1 3040 0
 7596 3ffc 7D0FA0E3 		mov	r0, #500
 7597 4000 FEFFFFEB 		bl	_tx_thread_sleep
 7598              	.LVL838:
3041:../uvc.c      ****                          		break;
 7599              		.loc 1 3041 0
 7600 4004 981A1FE5 		ldr	r1, .L740+116
 7601 4008 0020A0E3 		mov	r2, #0
 7602 400c 0B30A0E3 		mov	r3, #11
 7603 4010 0400A0E3 		mov	r0, #4
 7604 4014 FEFFFFEB 		bl	CyU3PDebugPrint
 7605              	.LVL839:
 7606 4018 4BFCFFEA 		b	.L538
 7607              	.LVL840:
 7608              	.L505:
 7609              	.LBE135:
 7610              	.LBE459:
 7611              	.LBB460:
 7612              	.LBB431:
 7613              	.LBB397:
 7614              	.LBB362:
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 7615              		.loc 1 583 0
 7616 401c 7BE0DAE5 		ldrb	lr, [r10, #123]	@ zero_extendqisi2
 584:../uvc.c      **** 		 	 }
 7617              		.loc 1 584 0
 7618 4020 7C20DAE5 		ldrb	r2, [r10, #124]	@ zero_extendqisi2
 7619 4024 ABFCFFEA 		b	.L691
 7620              	.LVL841:
 7621              	.L464:
 7622              	.LBE362:
 7623              	.LBE397:
 7624              	.LBB398:
 7625              	.LBB372:
 639:../uvc.c      **** 		 	 }
 7626              		.loc 1 639 0
 7627 4028 B81A1FE5 		ldr	r1, .L740+120
 7628 402c 5133D1E5 		ldrb	r3, [r1, #849]	@ zero_extendqisi2
 7629              	.LVL842:
 7630              	.L700:
 7631              	.LBE372:
 7632              	.LBE398:
 7633              	.LBB399:
 7634              	.LBB383:
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7635              		.loc 1 641 0
 7636 4030 0100A0E3 		mov	r0, #1
 7637 4034 CC1A1FE5 		ldr	r1, .L740+112
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7638              		.loc 1 414 0
 7639 4038 FF60A0E3 		mov	r6, #255
 639:../uvc.c      **** 		 	 }
 7640              		.loc 1 639 0
 7641 403c 9C30C9E5 		strb	r3, [r9, #156]
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7642              		.loc 1 641 0
 7643 4040 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7644              	.LVL843:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7645              		.loc 1 414 0
 7646 4044 06C0A0E1 		mov	ip, r6
 642:../uvc.c      **** 			  Len = 1;
 7647              		.loc 1 642 0
 7648 4048 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 7649              	.LVL844:
 7650 404c 5DFFFFEA 		b	.L479
 7651              	.LVL845:
 7652              	.L477:
 639:../uvc.c      **** 		 	 }
 7653              		.loc 1 639 0
 7654 4050 E01A1FE5 		ldr	r1, .L740+120
 7655 4054 5934D1E5 		ldrb	r3, [r1, #1113]	@ zero_extendqisi2
 7656 4058 F4FFFFEA 		b	.L700
 7657              	.LVL846:
 7658              	.L490:
 7659              	.LBE383:
 7660              	.LBE399:
 7661              	.LBB400:
 7662              	.LBB352:
 7663 405c 7134DAE5 		ldrb	r3, [r10, #1137]	@ zero_extendqisi2
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7664              		.loc 1 641 0
 7665 4060 0100A0E3 		mov	r0, #1
 7666 4064 FC1A1FE5 		ldr	r1, .L740+112
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7667              		.loc 1 414 0
 7668 4068 FF70A0E3 		mov	r7, #255
 639:../uvc.c      **** 		 	 }
 7669              		.loc 1 639 0
 7670 406c 9C30C9E5 		strb	r3, [r9, #156]
 7671 4070 6AFCFFEA 		b	.L688
 7672              	.LVL847:
 7673              	.L509:
 7674              	.LBE352:
 7675              	.LBE400:
 7676              	.LBB401:
 7677              	.LBB363:
 636:../uvc.c      **** 		 	 }
 7678              		.loc 1 636 0
 7679 4074 8120DAE5 		ldrb	r2, [r10, #129]	@ zero_extendqisi2
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7680              		.loc 1 641 0
 7681 4078 0100A0E3 		mov	r0, #1
 7682 407c 141B1FE5 		ldr	r1, .L740+112
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7683              		.loc 1 414 0
 7684 4080 FF70A0E3 		mov	r7, #255
 636:../uvc.c      **** 		 	 }
 7685              		.loc 1 636 0
 7686 4084 9C20C9E5 		strb	r2, [r9, #156]
 7687 4088 97FCFFEA 		b	.L692
 7688              	.LVL848:
 7689              	.L460:
 7690              	.LBE363:
 7691              	.LBE401:
 7692              	.LBB402:
 7693              	.LBB373:
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7694              		.loc 1 594 0
 7695 408c 1C1B1FE5 		ldr	r1, .L740+120
 7696 4090 4B23D1E5 		ldrb	r2, [r1, #843]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 7697              		.loc 1 595 0
 7698 4094 4C33D1E5 		ldrb	r3, [r1, #844]	@ zero_extendqisi2
 7699 4098 ACFCFFEA 		b	.L685
 7700              	.LVL849:
 7701              	.L473:
 7702              	.LBE373:
 7703              	.LBE402:
 7704              	.LBB403:
 7705              	.LBB384:
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7706              		.loc 1 594 0
 7707 409c 2C1B1FE5 		ldr	r1, .L740+120
 7708 40a0 5324D1E5 		ldrb	r2, [r1, #1107]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 7709              		.loc 1 595 0
 7710 40a4 5434D1E5 		ldrb	r3, [r1, #1108]	@ zero_extendqisi2
 7711 40a8 A8FCFFEA 		b	.L685
 7712              	.LVL850:
 7713              	.L486:
 7714              	.LBE384:
 7715              	.LBE403:
 7716              	.LBB404:
 7717              	.LBB353:
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7718              		.loc 1 594 0
 7719 40ac 6B24DAE5 		ldrb	r2, [r10, #1131]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 7720              		.loc 1 595 0
 7721 40b0 6C34DAE5 		ldrb	r3, [r10, #1132]	@ zero_extendqisi2
 7722 40b4 54FCFFEA 		b	.L687
 7723              	.LVL851:
 7724              	.L359:
 7725              	.LBE353:
 7726              	.LBE404:
 7727              	.LBE431:
 7728              	.LBE460:
 7729              	.LBB461:
 7730              	.LBB335:
 7731              	.LBB282:
 7732              	.LBB195:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7733              		.loc 1 1193 0
 7734 40b8 0000A0E3 		mov	r0, #0
 7735 40bc 0020A0E1 		mov	r2, r0
 7736 40c0 0110A0E3 		mov	r1, #1
 7737 40c4 1CC08DE5 		str	ip, [sp, #28]
 7738 40c8 FEFFFFEB 		bl	CyU3PUsbStall
 7739              	.LVL852:
1194:../uvc.c      **** 			  break;
 7740              		.loc 1 1194 0
 7741 40cc 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 7742 40d0 0400A0E3 		mov	r0, #4
 7743 40d4 741B1FE5 		ldr	r1, .L740+104
 7744 40d8 0520A0E3 		mov	r2, #5
 7745 40dc FEFFFFEB 		bl	CyU3PDebugPrint
 7746              	.LVL853:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7747              		.loc 1 980 0
 7748 40e0 FF70A0E3 		mov	r7, #255
 7749 40e4 1CC09DE5 		ldr	ip, [sp, #28]
 7750              	.LVL854:
 7751 40e8 5BFCFFEA 		b	.L415
 7752              	.LVL855:
 7753              	.L416:
 7754              	.LBE195:
 7755              	.LBE282:
 7756              	.LBB283:
 7757              	.LBB184:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7758              		.loc 1 1193 0
 7759 40ec 0000A0E3 		mov	r0, #0
 7760 40f0 0020A0E1 		mov	r2, r0
 7761 40f4 0110A0E3 		mov	r1, #1
 7762 40f8 FEFFFFEB 		bl	CyU3PUsbStall
 7763              	.LVL856:
1194:../uvc.c      **** 			  break;
 7764              		.loc 1 1194 0
 7765 40fc 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 7766 4100 0400A0E3 		mov	r0, #4
 7767 4104 A41B1FE5 		ldr	r1, .L740+104
 7768 4108 0A20A0E3 		mov	r2, #10
 7769 410c FEFFFFEB 		bl	CyU3PDebugPrint
 7770              	.LVL857:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7771              		.loc 1 980 0
 7772 4110 FF30A0E3 		mov	r3, #255
 7773 4114 0370A0E1 		mov	r7, r3
 7774 4118 2C308DE5 		str	r3, [sp, #44]
 7775 411c 21FBFFEA 		b	.L426
 7776              	.LVL858:
 7777              	.L306:
 7778              	.LBE184:
 7779              	.LBE283:
 7780              	.LBB284:
 7781              	.LBB145:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7782              		.loc 1 1193 0
 7783 4120 0000A0E3 		mov	r0, #0
 7784 4124 0020A0E1 		mov	r2, r0
 7785 4128 0110A0E3 		mov	r1, #1
 7786 412c FEFFFFEB 		bl	CyU3PUsbStall
 7787              	.LVL859:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7788              		.loc 1 980 0
 7789 4130 FF60A0E3 		mov	r6, #255
 7790              	.LVL860:
1194:../uvc.c      **** 			  break;
 7791              		.loc 1 1194 0
 7792 4134 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 7793 4138 0400A0E3 		mov	r0, #4
 7794 413c DC1B1FE5 		ldr	r1, .L740+104
 7795 4140 0120A0E3 		mov	r2, #1
 7796 4144 FEFFFFEB 		bl	CyU3PDebugPrint
 7797              	.LVL861:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7798              		.loc 1 980 0
 7799 4148 06C0A0E1 		mov	ip, r6
 7800 414c 2C709DE5 		ldr	r7, [sp, #44]
 7801 4150 02FAFFEA 		b	.L316
 7802              	.LVL862:
 7803              	.L348:
 7804              	.LBE145:
 7805              	.LBE284:
 7806              	.LBB285:
 7807              	.LBB156:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7808              		.loc 1 1193 0
 7809 4154 0000A0E3 		mov	r0, #0
 7810 4158 0020A0E1 		mov	r2, r0
 7811 415c 0110A0E3 		mov	r1, #1
 7812 4160 1CC08DE5 		str	ip, [sp, #28]
 7813 4164 FEFFFFEB 		bl	CyU3PUsbStall
 7814              	.LVL863:
1194:../uvc.c      **** 			  break;
 7815              		.loc 1 1194 0
 7816 4168 0400A0E3 		mov	r0, #4
 7817 416c 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 7818 4170 0020A0E1 		mov	r2, r0
 7819 4174 141C1FE5 		ldr	r1, .L740+104
 7820 4178 FEFFFFEB 		bl	CyU3PDebugPrint
 7821              	.LVL864:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7822              		.loc 1 980 0
 7823 417c FF70A0E3 		mov	r7, #255
 7824 4180 1CC09DE5 		ldr	ip, [sp, #28]
 7825              	.LVL865:
 7826 4184 34FCFFEA 		b	.L415
 7827              	.LVL866:
 7828              	.L322:
 7829              	.LBE156:
 7830              	.LBE285:
 7831              	.LBB286:
 7832              	.LBB236:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7833              		.loc 1 1193 0
 7834 4188 0000A0E3 		mov	r0, #0
 7835 418c 0020A0E1 		mov	r2, r0
 7836 4190 0110A0E3 		mov	r1, #1
 7837 4194 1CC08DE5 		str	ip, [sp, #28]
 7838 4198 FEFFFFEB 		bl	CyU3PUsbStall
 7839              	.LVL867:
1194:../uvc.c      **** 			  break;
 7840              		.loc 1 1194 0
 7841 419c 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 7842 41a0 0400A0E3 		mov	r0, #4
 7843 41a4 441C1FE5 		ldr	r1, .L740+104
 7844 41a8 0220A0E3 		mov	r2, #2
 7845 41ac FEFFFFEB 		bl	CyU3PDebugPrint
 7846              	.LVL868:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7847              		.loc 1 980 0
 7848 41b0 FF70A0E3 		mov	r7, #255
 7849 41b4 1CC09DE5 		ldr	ip, [sp, #28]
 7850              	.LVL869:
 7851 41b8 27FCFFEA 		b	.L415
 7852              	.LVL870:
 7853              	.L381:
 7854              	.LBE236:
 7855              	.LBE286:
 7856              	.LBB287:
 7857              	.LBB216:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7858              		.loc 1 1193 0
 7859 41bc 0000A0E3 		mov	r0, #0
 7860 41c0 0020A0E1 		mov	r2, r0
 7861 41c4 0110A0E3 		mov	r1, #1
 7862 41c8 FEFFFFEB 		bl	CyU3PUsbStall
 7863              	.LVL871:
1194:../uvc.c      **** 			  break;
 7864              		.loc 1 1194 0
 7865 41cc 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 7866 41d0 0720A0E3 		mov	r2, #7
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7867              		.loc 1 980 0
 7868 41d4 FF70A0E3 		mov	r7, #255
1194:../uvc.c      **** 			  break;
 7869              		.loc 1 1194 0
 7870 41d8 0400A0E3 		mov	r0, #4
 7871 41dc 7C1C1FE5 		ldr	r1, .L740+104
 7872 41e0 FEFFFFEB 		bl	CyU3PDebugPrint
 7873              	.LVL872:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7874              		.loc 1 980 0
 7875 41e4 0720A0E1 		mov	r2, r7
 7876 41e8 0730A0E1 		mov	r3, r7
 7877 41ec 42FBFFEA 		b	.L391
 7878              	.LVL873:
 7879              	.L333:
 7880              	.LBE216:
 7881              	.LBE287:
 7882              	.LBB288:
 7883              	.LBB204:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7884              		.loc 1 1193 0
 7885 41f0 0000A0E3 		mov	r0, #0
 7886 41f4 0020A0E1 		mov	r2, r0
 7887 41f8 0110A0E3 		mov	r1, #1
 7888 41fc FEFFFFEB 		bl	CyU3PUsbStall
 7889              	.LVL874:
1194:../uvc.c      **** 			  break;
 7890              		.loc 1 1194 0
 7891 4200 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 7892 4204 0320A0E3 		mov	r2, #3
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7893              		.loc 1 980 0
 7894 4208 FF70A0E3 		mov	r7, #255
1194:../uvc.c      **** 			  break;
 7895              		.loc 1 1194 0
 7896 420c 0400A0E3 		mov	r0, #4
 7897 4210 B01C1FE5 		ldr	r1, .L740+104
 7898 4214 FEFFFFEB 		bl	CyU3PDebugPrint
 7899              	.LVL875:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7900              		.loc 1 980 0
 7901 4218 0720A0E1 		mov	r2, r7
 7902 421c 0730A0E1 		mov	r3, r7
 7903              	.LVL876:
 7904 4220 35FBFFEA 		b	.L391
 7905              	.LVL877:
 7906              	.L469:
 7907              	.LBE204:
 7908              	.LBE288:
 7909              	.LBE335:
 7910              	.LBE461:
 7911              	.LBB462:
 7912              	.LBB432:
 7913              	.LBB405:
 7914              	.LBB385:
 957:../uvc.c      **** 			  break;
 7915              		.loc 1 957 0
 7916 4224 0000A0E3 		mov	r0, #0
 7917 4228 0020A0E1 		mov	r2, r0
 7918 422c 0110A0E3 		mov	r1, #1
 7919 4230 FEFFFFEB 		bl	CyU3PUsbStall
 7920              	.LVL878:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7921              		.loc 1 414 0
 7922 4234 FF30A0E3 		mov	r3, #255
 7923 4238 0360A0E1 		mov	r6, r3
 7924 423c 03C0A0E1 		mov	ip, r3
 7925 4240 E0FEFFEA 		b	.L479
 7926              	.LVL879:
 7927              	.L424:
 7928              	.LBE385:
 7929              	.LBE405:
 7930              	.LBE432:
 7931              	.LBE462:
 7932              	.LBB463:
 7933              	.LBB336:
 7934              	.LBB289:
 7935              	.LBB185:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7936              		.loc 1 1042 0
 7937 4244 8935DAE5 		ldrb	r3, [r10, #1417]	@ zero_extendqisi2
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7938              		.loc 1 1043 0
 7939 4248 E01C1FE5 		ldr	r1, .L740+112
 7940 424c 0100A0E3 		mov	r0, #1
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7941              		.loc 1 980 0
 7942 4250 FF70A0E3 		mov	r7, #255
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7943              		.loc 1 1042 0
 7944 4254 9C30C9E5 		strb	r3, [r9, #156]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7945              		.loc 1 980 0
 7946 4258 2C708DE5 		str	r7, [sp, #44]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7947              		.loc 1 1043 0
 7948 425c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7949              	.LVL880:
1045:../uvc.c      **** 			  break;
 7950              		.loc 1 1045 0
 7951 4260 0110A0E3 		mov	r1, #1
 7952 4264 28108DE5 		str	r1, [sp, #40]
 7953              	.LVL881:
1044:../uvc.c      **** 			  Len = 1;
 7954              		.loc 1 1044 0
 7955 4268 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 7956              	.LVL882:
 7957 426c CDFAFFEA 		b	.L426
 7958              	.LVL883:
 7959              	.L367:
 7960              	.LBE185:
 7961              	.LBE289:
 7962              	.LBB290:
 7963              	.LBB196:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7964              		.loc 1 1042 0
 7965 4270 007D1FE5 		ldr	r7, .L740+120
 7966 4274 1135D7E5 		ldrb	r3, [r7, #1297]	@ zero_extendqisi2
 7967              	.LVL884:
 7968              	.L698:
 7969              	.LBE196:
 7970              	.LBE290:
 7971              	.LBB291:
 7972              	.LBB167:
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7973              		.loc 1 1043 0
 7974 4278 0100A0E3 		mov	r0, #1
 7975 427c 141D1FE5 		ldr	r1, .L740+112
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7976              		.loc 1 1042 0
 7977 4280 9C30C9E5 		strb	r3, [r9, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7978              		.loc 1 1043 0
 7979 4284 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7980              	.LVL885:
1045:../uvc.c      **** 			  break;
 7981              		.loc 1 1045 0
 7982 4288 01C0A0E3 		mov	ip, #1
1044:../uvc.c      **** 			  Len = 1;
 7983              		.loc 1 1044 0
 7984 428c 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 7985              	.LVL886:
 7986 4290 F1FBFFEA 		b	.L415
 7987              	.LVL887:
 7988              	.L378:
 7989              	.LBE167:
 7990              	.LBE291:
 7991              	.LBB292:
 7992              	.LBB245:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7993              		.loc 1 1042 0
 7994 4294 2935DAE5 		ldrb	r3, [r10, #1321]	@ zero_extendqisi2
 7995 4298 F6FFFFEA 		b	.L698
 7996              	.LVL888:
 7997              	.L402:
 7998              	.LBE245:
 7999              	.LBE292:
 8000              	.LBB293:
 8001              	.LBB175:
 8002 429c 5935DAE5 		ldrb	r3, [r10, #1369]	@ zero_extendqisi2
 8003 42a0 F4FFFFEA 		b	.L698
 8004              	.LVL889:
 8005              	.L356:
 8006              	.LBE175:
 8007              	.LBE293:
 8008              	.LBB294:
 8009              	.LBB157:
 8010 42a4 F934DAE5 		ldrb	r3, [r10, #1273]	@ zero_extendqisi2
 8011 42a8 F2FFFFEA 		b	.L698
 8012              	.LVL890:
 8013              	.L732:
 8014              	.LBE157:
 8015              	.LBE294:
 8016              	.LBE336:
 8017              	.LBE463:
 8018              	.LBB464:
 8019              	.LBB136:
3237:../uvc.c      ****                             }
 8020              		.loc 1 3237 0
 8021 42ac 481D1FE5 		ldr	r1, .L740+108
 8022 42b0 0400A0E3 		mov	r0, #4
 8023              	.LVL891:
 8024 42b4 FEFFFFEB 		bl	CyU3PDebugPrint
 8025              	.LVL892:
 8026 42b8 8BFBFFEA 		b	.L563
 8027              	.LVL893:
 8028              	.L314:
 8029              	.LBE136:
 8030              	.LBE464:
 8031              	.LBB465:
 8032              	.LBB337:
 8033              	.LBB295:
 8034              	.LBB146:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8035              		.loc 1 1042 0
 8036 42bc B134DAE5 		ldrb	r3, [r10, #1201]	@ zero_extendqisi2
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8037              		.loc 1 980 0
 8038 42c0 FFC0A0E3 		mov	ip, #255
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8039              		.loc 1 1043 0
 8040 42c4 0100A0E3 		mov	r0, #1
 8041 42c8 601D1FE5 		ldr	r1, .L740+112
1045:../uvc.c      **** 			  break;
 8042              		.loc 1 1045 0
 8043 42cc 0170A0E3 		mov	r7, #1
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8044              		.loc 1 1043 0
 8045 42d0 1CC08DE5 		str	ip, [sp, #28]
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8046              		.loc 1 1042 0
 8047 42d4 9C30C9E5 		strb	r3, [r9, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8048              		.loc 1 1043 0
 8049 42d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8050              	.LVL894:
1045:../uvc.c      **** 			  break;
 8051              		.loc 1 1045 0
 8052 42dc 2C708DE5 		str	r7, [sp, #44]
 8053              	.LVL895:
1044:../uvc.c      **** 			  Len = 1;
 8054              		.loc 1 1044 0
 8055 42e0 9C60D9E5 		ldrb	r6, [r9, #156]	@ zero_extendqisi2
 8056              	.LVL896:
 8057 42e4 1CC09DE5 		ldr	ip, [sp, #28]
 8058 42e8 9CF9FFEA 		b	.L316
 8059              	.LVL897:
 8060              	.L389:
 8061              	.LBE146:
 8062              	.LBE295:
 8063              	.LBB296:
 8064              	.LBB217:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8065              		.loc 1 1042 0
 8066 42ec 7CED1FE5 		ldr	lr, .L740+120
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8067              		.loc 1 1043 0
 8068 42f0 881D1FE5 		ldr	r1, .L740+112
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8069              		.loc 1 1042 0
 8070 42f4 4135DEE5 		ldrb	r3, [lr, #1345]	@ zero_extendqisi2
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8071              		.loc 1 1043 0
 8072 42f8 0100A0E3 		mov	r0, #1
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8073              		.loc 1 1042 0
 8074 42fc 9C30C9E5 		strb	r3, [r9, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8075              		.loc 1 1043 0
 8076 4300 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8077              	.LVL898:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8078              		.loc 1 980 0
 8079 4304 FF20A0E3 		mov	r2, #255
1045:../uvc.c      **** 			  break;
 8080              		.loc 1 1045 0
 8081 4308 0110A0E3 		mov	r1, #1
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8082              		.loc 1 980 0
 8083 430c 0230A0E1 		mov	r3, r2
1044:../uvc.c      **** 			  Len = 1;
 8084              		.loc 1 1044 0
 8085 4310 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 8086              	.LVL899:
1045:../uvc.c      **** 			  break;
 8087              		.loc 1 1045 0
 8088 4314 28108DE5 		str	r1, [sp, #40]
 8089 4318 F7FAFFEA 		b	.L391
 8090              	.LVL900:
 8091              	.L303:
 8092              	.LBE217:
 8093              	.LBE296:
 8094              	.LBB297:
 8095              	.LBB227:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8096              		.loc 1 1042 0
 8097 431c 9934DAE5 		ldrb	r3, [r10, #1177]	@ zero_extendqisi2
 8098 4320 D4FFFFEA 		b	.L698
 8099              	.LVL901:
 8100              	.L330:
 8101              	.LBE227:
 8102              	.LBE297:
 8103              	.LBB298:
 8104              	.LBB237:
 8105 4324 B4ED1FE5 		ldr	lr, .L740+120
 8106 4328 C934DEE5 		ldrb	r3, [lr, #1225]	@ zero_extendqisi2
 8107 432c D1FFFFEA 		b	.L698
 8108              	.LVL902:
 8109              	.L310:
 8110              	.LBE237:
 8111              	.LBE298:
 8112              	.LBB299:
 8113              	.LBB147:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8114              		.loc 1 1015 0
 8115 4330 AB14DAE5 		ldrb	r1, [r10, #1195]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8116              		.loc 1 1016 0
 8117 4334 AC24DAE5 		ldrb	r2, [r10, #1196]	@ zero_extendqisi2
 8118 4338 7DF9FFEA 		b	.L670
 8119              	.LVL903:
 8120              	.L337:
 8121              	.LBE147:
 8122              	.LBE299:
 8123              	.LBB300:
 8124              	.LBB205:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8125              		.loc 1 1015 0
 8126 433c CC2D1FE5 		ldr	r2, .L740+120
 8127 4340 DB14D2E5 		ldrb	r1, [r2, #1243]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8128              		.loc 1 1016 0
 8129 4344 DC24D2E5 		ldrb	r2, [r2, #1244]	@ zero_extendqisi2
 8130 4348 E0FAFFEA 		b	.L677
 8131              	.LVL904:
 8132              	.L420:
 8133              	.LBE205:
 8134              	.LBE300:
 8135              	.LBB301:
 8136              	.LBB186:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8137              		.loc 1 1015 0
 8138 434c 8305DAE5 		ldrb	r0, [r10, #1411]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8139              		.loc 1 1016 0
 8140 4350 8415DAE5 		ldrb	r1, [r10, #1412]	@ zero_extendqisi2
 8141 4354 87FAFFEA 		b	.L681
 8142              	.LVL905:
 8143              	.L363:
 8144              	.LBE186:
 8145              	.LBE301:
 8146              	.LBB302:
 8147              	.LBB197:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8148              		.loc 1 1015 0
 8149 4358 E87D1FE5 		ldr	r7, .L740+120
 8150 435c 0B15D7E5 		ldrb	r1, [r7, #1291]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8151              		.loc 1 1016 0
 8152 4360 0C25D7E5 		ldrb	r2, [r7, #1292]	@ zero_extendqisi2
 8153 4364 F5F9FFEA 		b	.L679
 8154              	.LVL906:
 8155              	.L312:
 8156              	.LBE197:
 8157              	.LBE302:
 8158              	.LBB303:
 8159              	.LBB148:
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8160              		.loc 1 990 0
 8161 4368 2C709DE5 		ldr	r7, [sp, #44]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8162              		.loc 1 991 0
 8163 436c 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8164              		.loc 1 992 0
 8165 4370 0200A0E3 		mov	r0, #2
 8166 4374 0C1E1FE5 		ldr	r1, .L740+112
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8167              		.loc 1 990 0
 8168 4378 9C70C9E5 		strb	r7, [r9, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8169              		.loc 1 991 0
 8170 437c 9D30C9E5 		strb	r3, [r9, #157]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8171              		.loc 1 992 0
 8172 4380 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8173              	.LVL907:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8174              		.loc 1 980 0
 8175 4384 FFC0A0E3 		mov	ip, #255
 993:../uvc.c      **** 			  break;
 8176              		.loc 1 993 0
 8177 4388 9C60D9E5 		ldrb	r6, [r9, #156]	@ zero_extendqisi2
 8178              	.LVL908:
 8179 438c 2C709DE5 		ldr	r7, [sp, #44]
 8180 4390 72F9FFEA 		b	.L316
 8181              	.LVL909:
 8182              	.L413:
 8183              	.LBE148:
 8184              	.LBE303:
 8185              	.LBB304:
 8186              	.LBB168:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8187              		.loc 1 1042 0
 8188 4394 7135DAE5 		ldrb	r3, [r10, #1393]	@ zero_extendqisi2
 8189 4398 B6FFFFEA 		b	.L698
 8190              	.LVL910:
 8191              	.L374:
 8192              	.LBE168:
 8193              	.LBE304:
 8194              	.LBB305:
 8195              	.LBB246:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8196              		.loc 1 1015 0
 8197 439c 2C2E1FE5 		ldr	r2, .L740+120
 8198 43a0 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8199              		.loc 1 1016 0
 8200 43a4 2425D2E5 		ldrb	r2, [r2, #1316]	@ zero_extendqisi2
 8201 43a8 E4F9FFEA 		b	.L679
 8202              	.LVL911:
 8203              	.L299:
 8204              	.LBE246:
 8205              	.LBE305:
 8206              	.LBB306:
 8207              	.LBB228:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8208              		.loc 1 1015 0
 8209 43ac 3C2E1FE5 		ldr	r2, .L740+120
 8210 43b0 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8211              		.loc 1 1016 0
 8212 43b4 9424D2E5 		ldrb	r2, [r2, #1172]	@ zero_extendqisi2
 8213 43b8 E0F9FFEA 		b	.L679
 8214              	.LVL912:
 8215              	.L352:
 8216              	.LBE228:
 8217              	.LBE306:
 8218              	.LBB307:
 8219              	.LBB158:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8220              		.loc 1 1015 0
 8221 43bc F314DAE5 		ldrb	r1, [r10, #1267]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8222              		.loc 1 1016 0
 8223 43c0 F424DAE5 		ldrb	r2, [r10, #1268]	@ zero_extendqisi2
 8224 43c4 DDF9FFEA 		b	.L679
 8225              	.LVL913:
 8226              	.L398:
 8227              	.LBE158:
 8228              	.LBE307:
 8229              	.LBB308:
 8230              	.LBB176:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8231              		.loc 1 1015 0
 8232 43c8 5315DAE5 		ldrb	r1, [r10, #1363]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8233              		.loc 1 1016 0
 8234 43cc 5425DAE5 		ldrb	r2, [r10, #1364]	@ zero_extendqisi2
 8235 43d0 DAF9FFEA 		b	.L679
 8236              	.LVL914:
 8237              	.L409:
 8238              	.LBE176:
 8239              	.LBE308:
 8240              	.LBB309:
 8241              	.LBB169:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8242              		.loc 1 1015 0
 8243 43d4 642E1FE5 		ldr	r2, .L740+120
 8244 43d8 6B15D2E5 		ldrb	r1, [r2, #1387]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8245              		.loc 1 1016 0
 8246 43dc 6C25D2E5 		ldrb	r2, [r2, #1388]	@ zero_extendqisi2
 8247 43e0 D6F9FFEA 		b	.L679
 8248              	.LVL915:
 8249              	.L341:
 8250              	.LBE169:
 8251              	.LBE309:
 8252              	.LBB310:
 8253              	.LBB206:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8254              		.loc 1 1042 0
 8255 43e4 E134DAE5 		ldrb	r3, [r10, #1249]	@ zero_extendqisi2
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8256              		.loc 1 1043 0
 8257 43e8 0100A0E3 		mov	r0, #1
 8258 43ec 841E1FE5 		ldr	r1, .L740+112
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8259              		.loc 1 1042 0
 8260 43f0 9C30C9E5 		strb	r3, [r9, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8261              		.loc 1 1043 0
 8262 43f4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8263              	.LVL916:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8264              		.loc 1 980 0
 8265 43f8 FF20A0E3 		mov	r2, #255
1045:../uvc.c      **** 			  break;
 8266              		.loc 1 1045 0
 8267 43fc 01E0A0E3 		mov	lr, #1
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8268              		.loc 1 980 0
 8269 4400 0230A0E1 		mov	r3, r2
1044:../uvc.c      **** 			  Len = 1;
 8270              		.loc 1 1044 0
 8271 4404 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 8272              	.LVL917:
1045:../uvc.c      **** 			  break;
 8273              		.loc 1 1045 0
 8274 4408 28E08DE5 		str	lr, [sp, #40]
 8275 440c BAFAFFEA 		b	.L391
 8276              	.LVL918:
 8277              	.L326:
 8278              	.LBE206:
 8279              	.LBE310:
 8280              	.LBB311:
 8281              	.LBB238:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8282              		.loc 1 1015 0
 8283 4410 A02E1FE5 		ldr	r2, .L740+120
 8284 4414 C314D2E5 		ldrb	r1, [r2, #1219]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8285              		.loc 1 1016 0
 8286 4418 C424D2E5 		ldrb	r2, [r2, #1220]	@ zero_extendqisi2
 8287 441c C7F9FFEA 		b	.L679
 8288              	.LVL919:
 8289              	.L385:
 8290              	.LBE238:
 8291              	.LBE311:
 8292              	.LBB312:
 8293              	.LBB218:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8294              		.loc 1 1015 0
 8295 4420 B02E1FE5 		ldr	r2, .L740+120
 8296 4424 3B15D2E5 		ldrb	r1, [r2, #1339]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8297              		.loc 1 1016 0
 8298 4428 3C25D2E5 		ldrb	r2, [r2, #1340]	@ zero_extendqisi2
 8299 442c A7FAFFEA 		b	.L677
 8300              	.LVL920:
 8301              	.L371:
 8302              	.LBE218:
 8303              	.LBE312:
 8304              	.LBB313:
 8305              	.LBB247:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8306              		.loc 1 1024 0
 8307 4430 C03E1FE5 		ldr	r3, .L740+120
 8308 4434 2515D3E5 		ldrb	r1, [r3, #1317]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8309              		.loc 1 1025 0
 8310 4438 2625D3E5 		ldrb	r2, [r3, #1318]	@ zero_extendqisi2
 8311 443c BFF9FFEA 		b	.L679
 8312              	.LVL921:
 8313              	.L406:
 8314              	.LBE247:
 8315              	.LBE313:
 8316              	.LBB314:
 8317              	.LBB170:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8318              		.loc 1 1024 0
 8319 4440 D03E1FE5 		ldr	r3, .L740+120
 8320 4444 6D15D3E5 		ldrb	r1, [r3, #1389]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8321              		.loc 1 1025 0
 8322 4448 6E25D3E5 		ldrb	r2, [r3, #1390]	@ zero_extendqisi2
 8323 444c BBF9FFEA 		b	.L679
 8324              	.LVL922:
 8325              	.L417:
 8326              	.LBE170:
 8327              	.LBE314:
 8328              	.LBB315:
 8329              	.LBB187:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8330              		.loc 1 1024 0
 8331 4450 E0EE1FE5 		ldr	lr, .L740+120
 8332 4454 8505DEE5 		ldrb	r0, [lr, #1413]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8333              		.loc 1 1025 0
 8334 4458 8615DEE5 		ldrb	r1, [lr, #1414]	@ zero_extendqisi2
 8335 445c 45FAFFEA 		b	.L681
 8336              	.L422:
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8337              		.loc 1 990 0
 8338 4460 28209DE5 		ldr	r2, [sp, #40]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8339              		.loc 1 991 0
 8340 4464 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8341              		.loc 1 992 0
 8342 4468 0200A0E3 		mov	r0, #2
 8343 446c 041F1FE5 		ldr	r1, .L740+112
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8344              		.loc 1 980 0
 8345 4470 FF70A0E3 		mov	r7, #255
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8346              		.loc 1 991 0
 8347 4474 9D30C9E5 		strb	r3, [r9, #157]
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8348              		.loc 1 990 0
 8349 4478 9C20C9E5 		strb	r2, [r9, #156]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8350              		.loc 1 992 0
 8351 447c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8352              	.LVL923:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8353              		.loc 1 980 0
 8354 4480 2C708DE5 		str	r7, [sp, #44]
 993:../uvc.c      **** 			  break;
 8355              		.loc 1 993 0
 8356 4484 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 8357              	.LVL924:
 8358 4488 46FAFFEA 		b	.L426
 8359              	.LVL925:
 8360              	.L349:
 8361              	.LBE187:
 8362              	.LBE315:
 8363              	.LBB316:
 8364              	.LBB159:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8365              		.loc 1 1024 0
 8366 448c 1C2F1FE5 		ldr	r2, .L740+120
 8367 4490 F514D2E5 		ldrb	r1, [r2, #1269]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8368              		.loc 1 1025 0
 8369 4494 F624D2E5 		ldrb	r2, [r2, #1270]	@ zero_extendqisi2
 8370 4498 A8F9FFEA 		b	.L679
 8371              	.LVL926:
 8372              	.L395:
 8373              	.LBE159:
 8374              	.LBE316:
 8375              	.LBB317:
 8376              	.LBB177:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8377              		.loc 1 1024 0
 8378 449c 2CEF1FE5 		ldr	lr, .L740+120
 8379 44a0 5515DEE5 		ldrb	r1, [lr, #1365]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8380              		.loc 1 1025 0
 8381 44a4 5625DEE5 		ldrb	r2, [lr, #1366]	@ zero_extendqisi2
 8382 44a8 A4F9FFEA 		b	.L679
 8383              	.LVL927:
 8384              	.L334:
 8385              	.LBE177:
 8386              	.LBE317:
 8387              	.LBB318:
 8388              	.LBB207:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8389              		.loc 1 1024 0
 8390 44ac 3C3F1FE5 		ldr	r3, .L740+120
 8391 44b0 DD14D3E5 		ldrb	r1, [r3, #1245]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8392              		.loc 1 1025 0
 8393 44b4 DE24D3E5 		ldrb	r2, [r3, #1246]	@ zero_extendqisi2
 8394 44b8 84FAFFEA 		b	.L677
 8395              	.LVL928:
 8396              	.L360:
 8397              	.LBE207:
 8398              	.LBE318:
 8399              	.LBB319:
 8400              	.LBB198:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8401              		.loc 1 1024 0
 8402 44bc 4CEF1FE5 		ldr	lr, .L740+120
 8403 44c0 0D15DEE5 		ldrb	r1, [lr, #1293]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8404              		.loc 1 1025 0
 8405 44c4 0E25DEE5 		ldrb	r2, [lr, #1294]	@ zero_extendqisi2
 8406 44c8 9CF9FFEA 		b	.L679
 8407              	.LVL929:
 8408              	.L296:
 8409              	.LBE198:
 8410              	.LBE319:
 8411              	.LBB320:
 8412              	.LBB229:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8413              		.loc 1 1024 0
 8414 44cc 5C3F1FE5 		ldr	r3, .L740+120
 8415 44d0 9514D3E5 		ldrb	r1, [r3, #1173]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8416              		.loc 1 1025 0
 8417 44d4 9624D3E5 		ldrb	r2, [r3, #1174]	@ zero_extendqisi2
 8418 44d8 98F9FFEA 		b	.L679
 8419              	.LVL930:
 8420              	.L382:
 8421              	.LBE229:
 8422              	.LBE320:
 8423              	.LBB321:
 8424              	.LBB219:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8425              		.loc 1 1024 0
 8426 44dc 6C3F1FE5 		ldr	r3, .L740+120
 8427 44e0 3D15D3E5 		ldrb	r1, [r3, #1341]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8428              		.loc 1 1025 0
 8429 44e4 3E25D3E5 		ldrb	r2, [r3, #1342]	@ zero_extendqisi2
 8430 44e8 78FAFFEA 		b	.L677
 8431              	.LVL931:
 8432              	.L323:
 8433              	.LBE219:
 8434              	.LBE321:
 8435              	.LBB322:
 8436              	.LBB239:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8437              		.loc 1 1024 0
 8438 44ec 7C3F1FE5 		ldr	r3, .L740+120
 8439 44f0 C514D3E5 		ldrb	r1, [r3, #1221]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8440              		.loc 1 1025 0
 8441 44f4 C624D3E5 		ldrb	r2, [r3, #1222]	@ zero_extendqisi2
 8442 44f8 90F9FFEA 		b	.L679
 8443              	.LVL932:
 8444              	.L307:
 8445              	.LBE239:
 8446              	.LBE322:
 8447              	.LBB323:
 8448              	.LBB149:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8449              		.loc 1 1024 0
 8450 44fc 8C2F1FE5 		ldr	r2, .L740+120
 8451 4500 AD14D2E5 		ldrb	r1, [r2, #1197]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8452              		.loc 1 1025 0
 8453 4504 AE24D2E5 		ldrb	r2, [r2, #1198]	@ zero_extendqisi2
 8454 4508 09F9FFEA 		b	.L670
 8455              	.LVL933:
 8456              	.L539:
 8457              	.LBE149:
 8458              	.LBE323:
 8459              	.LBE337:
 8460              	.LBE465:
 8461              	.LBB466:
 8462              	.LBB137:
3034:../uvc.c      ****                          		CyU3PThreadSleep(500);
 8463              		.loc 1 3034 0
 8464 450c 0620A0E1 		mov	r2, r6
 8465 4510 3010A0E3 		mov	r1, #48
 8466 4514 5230A0E3 		mov	r3, #82
 8467 4518 0B00A0E3 		mov	r0, #11
 8468              	.LVL934:
 8469 451c FEFFFFEB 		bl	SensorSetIrisControl
 8470              	.LVL935:
3035:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
 8471              		.loc 1 3035 0
 8472 4520 7D0FA0E3 		mov	r0, #500
 8473 4524 FEFFFFEB 		bl	_tx_thread_sleep
 8474              	.LVL936:
3036:../uvc.c      ****                          		break;
 8475              		.loc 1 3036 0
 8476 4528 0620A0E1 		mov	r2, r6
 8477 452c C01F1FE5 		ldr	r1, .L740+116
 8478 4530 0B30A0E3 		mov	r3, #11
 8479 4534 0400A0E3 		mov	r0, #4
 8480 4538 FEFFFFEB 		bl	CyU3PDebugPrint
 8481              	.LVL937:
 8482 453c 02FBFFEA 		b	.L538
 8483              	.LVL938:
 8484              	.L502:
 8485              	.LBE137:
 8486              	.LBE466:
 8487              	.LBB467:
 8488              	.LBB433:
 8489              	.LBB406:
 8490              	.LBB364:
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 8491              		.loc 1 602 0
 8492 4540 D07F1FE5 		ldr	r7, .L740+120
 8493 4544 7DE0D7E5 		ldrb	lr, [r7, #125]	@ zero_extendqisi2
 603:../uvc.c      **** 		 	 }
 8494              		.loc 1 603 0
 8495 4548 7E20D7E5 		ldrb	r2, [r7, #126]	@ zero_extendqisi2
 8496 454c 61FBFFEA 		b	.L691
 8497              	.LVL939:
 8498              	.L470:
 8499              	.LBE364:
 8500              	.LBE406:
 8501              	.LBB407:
 8502              	.LBB386:
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8503              		.loc 1 612 0
 8504 4550 E03F1FE5 		ldr	r3, .L740+120
 8505 4554 5524D3E5 		ldrb	r2, [r3, #1109]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 8506              		.loc 1 613 0
 8507 4558 5634D3E5 		ldrb	r3, [r3, #1110]	@ zero_extendqisi2
 8508 455c 7BFBFFEA 		b	.L685
 8509              	.LVL940:
 8510              	.L457:
 8511              	.LBE386:
 8512              	.LBE407:
 8513              	.LBB408:
 8514              	.LBB374:
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8515              		.loc 1 612 0
 8516 4560 F03F1FE5 		ldr	r3, .L740+120
 8517 4564 4D23D3E5 		ldrb	r2, [r3, #845]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 8518              		.loc 1 613 0
 8519 4568 4E33D3E5 		ldrb	r3, [r3, #846]	@ zero_extendqisi2
 8520 456c 77FBFFEA 		b	.L685
 8521              	.LVL941:
 8522              	.L483:
 8523              	.LBE374:
 8524              	.LBE408:
 8525              	.LBB409:
 8526              	.LBB354:
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8527              		.loc 1 612 0
 8528 4570 A0E49FE5 		ldr	lr, .L742
 8529 4574 6D24DEE5 		ldrb	r2, [lr, #1133]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 8530              		.loc 1 613 0
 8531 4578 6E34DEE5 		ldrb	r3, [lr, #1134]	@ zero_extendqisi2
 8532 457c 22FBFFEA 		b	.L687
 8533              	.LVL942:
 8534              	.L344:
 8535              	.LBE354:
 8536              	.LBE409:
 8537              	.LBE433:
 8538              	.LBE467:
 8539              	.LBB468:
 8540              	.LBB338:
 8541              	.LBB324:
 8542              	.LBB208:
1143:../uvc.c      **** 					  }
 8543              		.loc 1 1143 0
 8544 4580 0000A0E3 		mov	r0, #0
 8545 4584 0020A0E1 		mov	r2, r0
 8546 4588 0110A0E3 		mov	r1, #1
 8547 458c FEFFFFEB 		bl	CyU3PUsbStall
 8548              	.LVL943:
 8549 4590 07FDFFEA 		b	.L393
 8550              	.LVL944:
 8551              	.L508:
 8552              	.LBE208:
 8553              	.LBE324:
 8554              	.LBE338:
 8555              	.LBE468:
 8556              	.LBB469:
 8557              	.LBB434:
 8558              	.LBB410:
 8559              	.LBB365:
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 8560              		.loc 1 620 0
 8561 4594 7F30DAE5 		ldrb	r3, [r10, #127]	@ zero_extendqisi2
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 8562              		.loc 1 621 0
 8563 4598 80E0DAE5 		ldrb	lr, [r10, #128]	@ zero_extendqisi2
 622:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 8564              		.loc 1 622 0
 8565 459c 0020A0E3 		mov	r2, #0
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8566              		.loc 1 631 0
 8567 45a0 0C00A0E1 		mov	r0, ip
 8568 45a4 70149FE5 		ldr	r1, .L742+4
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 8569              		.loc 1 620 0
 8570 45a8 9C30C9E5 		strb	r3, [r9, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8571              		.loc 1 414 0
 8572 45ac FF70A0E3 		mov	r7, #255
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 8573              		.loc 1 621 0
 8574 45b0 9DE0C9E5 		strb	lr, [r9, #157]
 622:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 8575              		.loc 1 622 0
 8576 45b4 9E20C9E5 		strb	r2, [r9, #158]
 623:../uvc.c      **** 		 	 }
 8577              		.loc 1 623 0
 8578 45b8 9F20C9E5 		strb	r2, [r9, #159]
 8579 45bc 4AFBFFEA 		b	.L692
 8580              	.L507:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8581              		.loc 1 431 0
 8582 45c0 0020A0E3 		mov	r2, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8583              		.loc 1 432 0
 8584 45c4 0200A0E3 		mov	r0, #2
 8585 45c8 4C149FE5 		ldr	r1, .L742+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8586              		.loc 1 414 0
 8587 45cc FF70A0E3 		mov	r7, #255
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8588              		.loc 1 430 0
 8589 45d0 9CC0C9E5 		strb	ip, [r9, #156]
 8590 45d4 43FBFFEA 		b	.L689
 8591              	.LVL945:
 8592              	.L472:
 8593              	.LBE365:
 8594              	.LBE410:
 8595              	.LBB411:
 8596              	.LBB387:
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 8597              		.loc 1 559 0
 8598 45d8 4A20D9E5 		ldrb	r2, [r9, #74]	@ zero_extendqisi2
 8599 45dc 000052E3 		cmp	r2, #0
 8600 45e0 0401000A 		beq	.L738
 8601              	.LVL946:
 8602              	.L480:
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8603              		.loc 1 569 0
 8604 45e4 5D34DAE5 		ldrb	r3, [r10, #1117]	@ zero_extendqisi2
 8605              	.LVL947:
 8606              	.L699:
 575:../uvc.c      **** 
 8607              		.loc 1 575 0
 8608 45e8 0600A0E1 		mov	r0, r6
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 8609              		.loc 1 570 0
 8610 45ec 0020A0E3 		mov	r2, #0
 575:../uvc.c      **** 
 8611              		.loc 1 575 0
 8612 45f0 24149FE5 		ldr	r1, .L742+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8613              		.loc 1 414 0
 8614 45f4 FF60A0E3 		mov	r6, #255
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8615              		.loc 1 569 0
 8616 45f8 9C30C9E5 		strb	r3, [r9, #156]
 575:../uvc.c      **** 
 8617              		.loc 1 575 0
 8618 45fc 20308DE5 		str	r3, [sp, #32]
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 8619              		.loc 1 570 0
 8620 4600 9D20C9E5 		strb	r2, [r9, #157]
 8621              	.LVL948:
 575:../uvc.c      **** 
 8622              		.loc 1 575 0
 8623 4604 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8624              	.LVL949:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8625              		.loc 1 414 0
 8626 4608 06C0A0E1 		mov	ip, r6
 8627 460c 20309DE5 		ldr	r3, [sp, #32]
 8628 4610 ECFDFFEA 		b	.L479
 8629              	.LVL950:
 8630              	.L485:
 8631              	.LBE387:
 8632              	.LBE411:
 8633              	.LBB412:
 8634              	.LBB355:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8635              		.loc 1 464 0
 8636 4614 000056E3 		cmp	r6, #0
 8637 4618 2C00000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8638              		.loc 1 465 0
 8639 461c 9030D9E5 		ldrb	r3, [r9, #144]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8640              		.loc 1 464 0
 8641 4620 010056E3 		cmp	r6, #1
 465:../uvc.c      **** 			 		 }
 8642              		.loc 1 465 0
 8643 4624 9C30C9E5 		strb	r3, [r9, #156]
 8644              	.LVL951:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8645              		.loc 1 464 0
 8646 4628 2800009A 		bls	.L494
 465:../uvc.c      **** 			 		 }
 8647              		.loc 1 465 0
 8648 462c 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8649              		.loc 1 464 0
 8650 4630 020056E3 		cmp	r6, #2
 465:../uvc.c      **** 			 		 }
 8651              		.loc 1 465 0
 8652 4634 9D30C4E5 		strb	r3, [r4, #157]
 8653              	.LVL952:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8654              		.loc 1 464 0
 8655 4638 2400000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8656              		.loc 1 465 0
 8657 463c 9230D4E5 		ldrb	r3, [r4, #146]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8658              		.loc 1 464 0
 8659 4640 030056E3 		cmp	r6, #3
 465:../uvc.c      **** 			 		 }
 8660              		.loc 1 465 0
 8661 4644 9E30C4E5 		strb	r3, [r4, #158]
 8662              	.LVL953:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8663              		.loc 1 464 0
 8664 4648 2000000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8665              		.loc 1 465 0
 8666 464c 9330D4E5 		ldrb	r3, [r4, #147]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8667              		.loc 1 464 0
 8668 4650 040056E3 		cmp	r6, #4
 465:../uvc.c      **** 			 		 }
 8669              		.loc 1 465 0
 8670 4654 9F30C4E5 		strb	r3, [r4, #159]
 8671              	.LVL954:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8672              		.loc 1 464 0
 8673 4658 1C00000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8674              		.loc 1 465 0
 8675 465c 9430D4E5 		ldrb	r3, [r4, #148]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8676              		.loc 1 464 0
 8677 4660 050056E3 		cmp	r6, #5
 465:../uvc.c      **** 			 		 }
 8678              		.loc 1 465 0
 8679 4664 A030C4E5 		strb	r3, [r4, #160]
 8680              	.LVL955:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8681              		.loc 1 464 0
 8682 4668 1800000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8683              		.loc 1 465 0
 8684 466c 9530D4E5 		ldrb	r3, [r4, #149]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8685              		.loc 1 464 0
 8686 4670 060056E3 		cmp	r6, #6
 465:../uvc.c      **** 			 		 }
 8687              		.loc 1 465 0
 8688 4674 A130C4E5 		strb	r3, [r4, #161]
 8689              	.LVL956:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8690              		.loc 1 464 0
 8691 4678 1400000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8692              		.loc 1 465 0
 8693 467c 9630D4E5 		ldrb	r3, [r4, #150]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8694              		.loc 1 464 0
 8695 4680 070056E3 		cmp	r6, #7
 465:../uvc.c      **** 			 		 }
 8696              		.loc 1 465 0
 8697 4684 A230C4E5 		strb	r3, [r4, #162]
 8698              	.LVL957:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8699              		.loc 1 464 0
 8700 4688 1000000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8701              		.loc 1 465 0
 8702 468c 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8703              		.loc 1 464 0
 8704 4690 080056E3 		cmp	r6, #8
 465:../uvc.c      **** 			 		 }
 8705              		.loc 1 465 0
 8706 4694 A330C4E5 		strb	r3, [r4, #163]
 8707              	.LVL958:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8708              		.loc 1 464 0
 8709 4698 0C00000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8710              		.loc 1 465 0
 8711 469c 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8712              		.loc 1 464 0
 8713 46a0 090056E3 		cmp	r6, #9
 465:../uvc.c      **** 			 		 }
 8714              		.loc 1 465 0
 8715 46a4 A430C4E5 		strb	r3, [r4, #164]
 8716              	.LVL959:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8717              		.loc 1 464 0
 8718 46a8 0800000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8719              		.loc 1 465 0
 8720 46ac 9930D9E5 		ldrb	r3, [r9, #153]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8721              		.loc 1 464 0
 8722 46b0 0A0056E3 		cmp	r6, #10
 465:../uvc.c      **** 			 		 }
 8723              		.loc 1 465 0
 8724 46b4 A530C9E5 		strb	r3, [r9, #165]
 8725              	.LVL960:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8726              		.loc 1 464 0
 8727 46b8 0400000A 		beq	.L494
 465:../uvc.c      **** 			 		 }
 8728              		.loc 1 465 0
 8729 46bc 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8730              		.loc 1 464 0
 8731 46c0 0B0056E3 		cmp	r6, #11
 465:../uvc.c      **** 			 		 }
 8732              		.loc 1 465 0
 8733 46c4 A630C4E5 		strb	r3, [r4, #166]
 8734              	.LVL961:
 8735 46c8 9B30D415 		ldrneb	r3, [r4, #155]	@ zero_extendqisi2
 8736 46cc A730C415 		strneb	r3, [r4, #167]
 8737              	.LVL962:
 8738              	.L494:
 474:../uvc.c      **** 			 		 {
 8739              		.loc 1 474 0
 8740 46d0 9B30D9E5 		ldrb	r3, [r9, #155]	@ zero_extendqisi2
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 8741              		.loc 1 467 0
 8742 46d4 A5C0D9E5 		ldrb	ip, [r9, #165]	@ zero_extendqisi2
 8743              	.LVL963:
 474:../uvc.c      **** 			 		 {
 8744              		.loc 1 474 0
 8745 46d8 FF0053E3 		cmp	r3, #255
 468:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8746              		.loc 1 468 0
 8747 46dc A670D9E5 		ldrb	r7, [r9, #166]	@ zero_extendqisi2
 8748              	.LVL964:
 474:../uvc.c      **** 			 		 {
 8749              		.loc 1 474 0
 8750 46e0 0600000A 		beq	.L496
 476:../uvc.c      **** 			 		 }
 8751              		.loc 1 476 0
 8752 46e4 9920D4E5 		ldrb	r2, [r4, #153]	@ zero_extendqisi2
 8753 46e8 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
 8754 46ec 0400A0E3 		mov	r0, #4
 8755 46f0 28139FE5 		ldr	r1, .L742+8
 8756 46f4 1CC08DE5 		str	ip, [sp, #28]
 8757 46f8 FEFFFFEB 		bl	CyU3PDebugPrint
 8758              	.LVL965:
 8759 46fc 1CC09DE5 		ldr	ip, [sp, #28]
 8760              	.L496:
 8761              	.LVL966:
 575:../uvc.c      **** 
 8762              		.loc 1 575 0
 8763 4700 0600A0E1 		mov	r0, r6
 8764 4704 10139FE5 		ldr	r1, .L742+4
 8765 4708 1CC08DE5 		str	ip, [sp, #28]
 8766 470c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8767              	.LVL967:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8768              		.loc 1 414 0
 8769 4710 FF20A0E3 		mov	r2, #255
 8770 4714 0230A0E1 		mov	r3, r2
 8771 4718 1CC09DE5 		ldr	ip, [sp, #28]
 8772 471c FEFCFFEA 		b	.L492
 8773              	.LVL968:
 8774              	.L476:
 8775              	.LBE355:
 8776              	.LBE412:
 8777              	.LBB413:
 8778              	.LBB388:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8779              		.loc 1 626 0
 8780 4720 F0E29FE5 		ldr	lr, .L742
 8781 4724 5714DEE5 		ldrb	r1, [lr, #1111]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8782              		.loc 1 627 0
 8783 4728 5824DEE5 		ldrb	r2, [lr, #1112]	@ zero_extendqisi2
 8784              	.LVL969:
 8785              	.L701:
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8786              		.loc 1 628 0
 8787 472c 0030A0E3 		mov	r3, #0
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8788              		.loc 1 631 0
 8789 4730 0600A0E1 		mov	r0, r6
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8790              		.loc 1 626 0
 8791 4734 9C10C9E5 		strb	r1, [r9, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8792              		.loc 1 414 0
 8793 4738 FF60A0E3 		mov	r6, #255
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8794              		.loc 1 631 0
 8795 473c D8129FE5 		ldr	r1, .L742+4
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8796              		.loc 1 628 0
 8797 4740 9E30C9E5 		strb	r3, [r9, #158]
 629:../uvc.c      **** 		 	 }
 8798              		.loc 1 629 0
 8799 4744 9F30C9E5 		strb	r3, [r9, #159]
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8800              		.loc 1 627 0
 8801 4748 9D20C9E5 		strb	r2, [r9, #157]
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8802              		.loc 1 631 0
 8803 474c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8804              	.LVL970:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8805              		.loc 1 414 0
 8806 4750 06C0A0E1 		mov	ip, r6
 632:../uvc.c      **** 			  break;
 8807              		.loc 1 632 0
 8808 4754 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 8809              	.LVL971:
 8810 4758 9AFDFFEA 		b	.L479
 8811              	.LVL972:
 8812              	.L501:
 8813              	.LBE388:
 8814              	.LBE413:
 8815              	.LBB414:
 8816              	.LBB366:
 957:../uvc.c      **** 			  break;
 8817              		.loc 1 957 0
 8818 475c 0000A0E3 		mov	r0, #0
 8819 4760 0020A0E1 		mov	r2, r0
 8820 4764 0110A0E3 		mov	r1, #1
 8821 4768 FEFFFFEB 		bl	CyU3PUsbStall
 8822              	.LVL973:
 8823              	.L690:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8824              		.loc 1 414 0
 8825 476c FF70A0E3 		mov	r7, #255
 8826              	.LVL974:
 8827 4770 0720A0E1 		mov	r2, r7
 8828 4774 28708DE5 		str	r7, [sp, #40]
 8829 4778 07C0A0E1 		mov	ip, r7
 8830 477c 0730A0E1 		mov	r3, r7
 8831 4780 3BFDFFEA 		b	.L511
 8832              	.LVL975:
 8833              	.L482:
 8834              	.LBE366:
 8835              	.LBE414:
 8836              	.LBB415:
 8837              	.LBB356:
 957:../uvc.c      **** 			  break;
 8838              		.loc 1 957 0
 8839 4784 0000A0E3 		mov	r0, #0
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8840              		.loc 1 414 0
 8841 4788 FF70A0E3 		mov	r7, #255
 957:../uvc.c      **** 			  break;
 8842              		.loc 1 957 0
 8843 478c 0020A0E1 		mov	r2, r0
 8844 4790 0110A0E3 		mov	r1, #1
 8845 4794 FEFFFFEB 		bl	CyU3PUsbStall
 8846              	.LVL976:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8847              		.loc 1 414 0
 8848 4798 07C0A0E1 		mov	ip, r7
 8849 479c 0720A0E1 		mov	r2, r7
 8850 47a0 0730A0E1 		mov	r3, r7
 8851 47a4 DCFCFFEA 		b	.L492
 8852              	.LVL977:
 8853              	.L459:
 8854              	.LBE356:
 8855              	.LBE415:
 8856              	.LBB416:
 8857              	.LBB375:
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 8858              		.loc 1 559 0
 8859 47a8 3F20D9E5 		ldrb	r2, [r9, #63]	@ zero_extendqisi2
 8860 47ac 000052E3 		cmp	r2, #0
 8861 47b0 8800000A 		beq	.L739
 8862              	.LVL978:
 8863              	.L467:
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8864              		.loc 1 569 0
 8865 47b4 5533DAE5 		ldrb	r3, [r10, #853]	@ zero_extendqisi2
 8866 47b8 8AFFFFEA 		b	.L699
 8867              	.LVL979:
 8868              	.L504:
 8869              	.LBE375:
 8870              	.LBE416:
 8871              	.LBB417:
 8872              	.LBB367:
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 8873              		.loc 1 443 0
 8874 47bc 8520DAE5 		ldrb	r2, [r10, #133]	@ zero_extendqisi2
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 8875              		.loc 1 444 0
 8876 47c0 8670DAE5 		ldrb	r7, [r10, #134]	@ zero_extendqisi2
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8877              		.loc 1 414 0
 8878 47c4 FF30A0E3 		mov	r3, #255
 575:../uvc.c      **** 
 8879              		.loc 1 575 0
 8880 47c8 0C00A0E1 		mov	r0, ip
 8881 47cc 48129FE5 		ldr	r1, .L742+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8882              		.loc 1 414 0
 8883 47d0 28308DE5 		str	r3, [sp, #40]
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 8884              		.loc 1 443 0
 8885 47d4 9C20C9E5 		strb	r2, [r9, #156]
 575:../uvc.c      **** 
 8886              		.loc 1 575 0
 8887 47d8 24208DE5 		str	r2, [sp, #36]
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 8888              		.loc 1 444 0
 8889 47dc 9D70C9E5 		strb	r7, [r9, #157]
 8890              	.LVL980:
 575:../uvc.c      **** 
 8891              		.loc 1 575 0
 8892 47e0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8893              	.LVL981:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8894              		.loc 1 414 0
 8895 47e4 28C09DE5 		ldr	ip, [sp, #40]
 8896 47e8 24209DE5 		ldr	r2, [sp, #36]
 8897 47ec 0C30A0E1 		mov	r3, ip
 8898 47f0 1FFDFFEA 		b	.L511
 8899              	.LVL982:
 8900              	.L463:
 8901              	.LBE367:
 8902              	.LBE417:
 8903              	.LBB418:
 8904              	.LBB376:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8905              		.loc 1 626 0
 8906 47f4 1CE29FE5 		ldr	lr, .L742
 8907 47f8 4F13DEE5 		ldrb	r1, [lr, #847]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8908              		.loc 1 627 0
 8909 47fc 5023DEE5 		ldrb	r2, [lr, #848]	@ zero_extendqisi2
 8910 4800 C9FFFFEA 		b	.L701
 8911              	.LVL983:
 8912              	.L489:
 8913              	.LBE376:
 8914              	.LBE418:
 8915              	.LBB419:
 8916              	.LBB357:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8917              		.loc 1 626 0
 8918 4804 6FC4DAE5 		ldrb	ip, [r10, #1135]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8919              		.loc 1 627 0
 8920 4808 7024DAE5 		ldrb	r2, [r10, #1136]	@ zero_extendqisi2
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8921              		.loc 1 628 0
 8922 480c 0030A0E3 		mov	r3, #0
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8923              		.loc 1 631 0
 8924 4810 0600A0E1 		mov	r0, r6
 8925 4814 00129FE5 		ldr	r1, .L742+4
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8926              		.loc 1 626 0
 8927 4818 9CC0C9E5 		strb	ip, [r9, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8928              		.loc 1 414 0
 8929 481c FF70A0E3 		mov	r7, #255
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8930              		.loc 1 627 0
 8931 4820 9D20C9E5 		strb	r2, [r9, #157]
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8932              		.loc 1 628 0
 8933 4824 9E30C9E5 		strb	r3, [r9, #158]
 629:../uvc.c      **** 		 	 }
 8934              		.loc 1 629 0
 8935 4828 9F30C9E5 		strb	r3, [r9, #159]
 8936 482c 7BFAFFEA 		b	.L688
 8937              	.L488:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8938              		.loc 1 431 0
 8939 4830 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8940              		.loc 1 432 0
 8941 4834 0200A0E3 		mov	r0, #2
 8942 4838 DC119FE5 		ldr	r1, .L742+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8943              		.loc 1 414 0
 8944 483c FF70A0E3 		mov	r7, #255
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8945              		.loc 1 430 0
 8946 4840 9C60C9E5 		strb	r6, [r9, #156]
 8947 4844 74FAFFEA 		b	.L686
 8948              	.LVL984:
 8949              	.L392:
 8950              	.LBE357:
 8951              	.LBE419:
 8952              	.LBE434:
 8953              	.LBE469:
 8954              	.LBB470:
 8955              	.LBB339:
 8956              	.LBB325:
 8957              	.LBB220:
1161:../uvc.c      **** 					  }
 8958              		.loc 1 1161 0
 8959 4848 0020A0E1 		mov	r2, r0
 8960 484c 0610A0E1 		mov	r1, r6
 8961 4850 FEFFFFEB 		bl	CyU3PUsbStall
 8962              	.LVL985:
 8963 4854 56FCFFEA 		b	.L393
 8964              	.LVL986:
 8965              	.L481:
 8966              	.LBE220:
 8967              	.LBE325:
 8968              	.LBE339:
 8969              	.LBE470:
 8970              	.LBB471:
 8971              	.LBB435:
 8972              	.LBB420:
 8973              	.LBB389:
 949:../uvc.c      **** 			   }
 8974              		.loc 1 949 0
 8975 4858 0400A0E3 		mov	r0, #4
 8976 485c C0119FE5 		ldr	r1, .L742+12
 8977 4860 FEFFFFEB 		bl	CyU3PDebugPrint
 8978              	.LVL987:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8979              		.loc 1 414 0
 8980 4864 FF30A0E3 		mov	r3, #255
 8981 4868 0360A0E1 		mov	r6, r3
 8982 486c 03C0A0E1 		mov	ip, r3
 8983 4870 54FDFFEA 		b	.L479
 8984              	.LVL988:
 8985              	.L737:
 8986              	.LBE389:
 8987              	.LBE420:
 8988              	.LBE435:
 8989              	.LBE471:
 8990              	.LBB472:
 8991              	.LBB340:
 8992              	.LBB326:
 8993              	.LBB188:
1176:../uvc.c      **** 					  else
 8994              		.loc 1 1176 0
 8995 4874 0810A0E3 		mov	r1, #8
 8996              	.L680:
 8997 4878 0000A0E3 		mov	r0, #0
 8998 487c 0320A0E1 		mov	r2, r3
 8999 4880 00108DE5 		str	r1, [sp]
 9000 4884 04008DE5 		str	r0, [sp, #4]
 9001 4888 0C30A0E1 		mov	r3, ip
 9002 488c 2310A0E3 		mov	r1, #35
 9003 4890 90019FE5 		ldr	r0, .L742+16
 9004 4894 FEFFFFEB 		bl	cmdSet
 9005              	.LVL989:
 9006 4898 97FBFFEA 		b	.L428
 9007              	.LVL990:
 9008              	.L321:
 9009              	.LBE188:
 9010              	.LBE326:
 9011              	.LBB327:
 9012              	.LBB150:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 9013              		.loc 1 1091 0
 9014 489c 84719FE5 		ldr	r7, .L742+16
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 9015              		.loc 1 1089 0
 9016 48a0 00E0A0E3 		mov	lr, #0
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 9017              		.loc 1 1091 0
 9018 48a4 1C0097E5 		ldr	r0, [r7, #28]
 9019 48a8 0010E0E3 		mvn	r1, #0
 9020 48ac 1CC08DE5 		str	ip, [sp, #28]
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 9021              		.loc 1 1089 0
 9022 48b0 0DE3CAE5 		strb	lr, [r10, #781]
 9023              	.LVL991:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 9024              		.loc 1 1091 0
 9025 48b4 20308DE5 		str	r3, [sp, #32]
 9026 48b8 FEFFFFEB 		bl	_txe_mutex_get
 9027              	.LVL992:
1092:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9028              		.loc 1 1092 0
 9029 48bc 20309DE5 		ldr	r3, [sp, #32]
 9030 48c0 0010A0E3 		mov	r1, #0
 9031 48c4 0320A0E1 		mov	r2, r3
 9032 48c8 00108DE5 		str	r1, [sp]
 9033 48cc 0630A0E1 		mov	r3, r6
 9034 48d0 04108DE5 		str	r1, [sp, #4]
 9035 48d4 0700A0E1 		mov	r0, r7
 9036 48d8 1010A0E3 		mov	r1, #16
 9037 48dc FEFFFFEB 		bl	cmdSet
 9038              	.LVL993:
1093:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 9039              		.loc 1 1093 0
 9040 48e0 1C0097E5 		ldr	r0, [r7, #28]
 9041 48e4 FEFFFFEB 		bl	_txe_mutex_put
 9042              	.LVL994:
1094:../uvc.c      **** 							break;
 9043              		.loc 1 1094 0
 9044 48e8 0700A0E1 		mov	r0, r7
 9045 48ec 0010A0E3 		mov	r1, #0
 9046 48f0 FEFFFFEB 		bl	setIrisauto
 9047              	.LVL995:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9048              		.loc 1 980 0
 9049 48f4 FF60A0E3 		mov	r6, #255
 9050              	.LVL996:
 9051 48f8 1CC09DE5 		ldr	ip, [sp, #28]
 9052 48fc 2C709DE5 		ldr	r7, [sp, #44]
 9053 4900 16F8FFEA 		b	.L316
 9054              	.LVL997:
 9055              	.L320:
1086:../uvc.c      **** 							break;
 9056              		.loc 1 1086 0
 9057 4904 1C019FE5 		ldr	r0, .L742+16
 9058 4908 0110A0E3 		mov	r1, #1
 9059              	.L671:
 9060 490c 1CC08DE5 		str	ip, [sp, #28]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9061              		.loc 1 980 0
 9062 4910 FF60A0E3 		mov	r6, #255
 9063              	.LVL998:
1086:../uvc.c      **** 							break;
 9064              		.loc 1 1086 0
 9065 4914 FEFFFFEB 		bl	setIrisauto
 9066              	.LVL999:
 9067 4918 1CC09DE5 		ldr	ip, [sp, #28]
 9068 491c 2C709DE5 		ldr	r7, [sp, #44]
 9069 4920 0EF8FFEA 		b	.L316
 9070              	.LVL1000:
 9071              	.L319:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 9072              		.loc 1 1079 0
 9073 4924 FC709FE5 		ldr	r7, .L742+16
1077:../uvc.c      **** 							dataIdx = 0;
 9074              		.loc 1 1077 0
 9075 4928 0020A0E3 		mov	r2, #0
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 9076              		.loc 1 1079 0
 9077 492c 1C0097E5 		ldr	r0, [r7, #28]
 9078 4930 0010E0E3 		mvn	r1, #0
 9079 4934 1CC08DE5 		str	ip, [sp, #28]
1077:../uvc.c      **** 							dataIdx = 0;
 9080              		.loc 1 1077 0
 9081 4938 0D23CAE5 		strb	r2, [r10, #781]
 9082              	.LVL1001:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 9083              		.loc 1 1079 0
 9084 493c 24208DE5 		str	r2, [sp, #36]
 9085 4940 20308DE5 		str	r3, [sp, #32]
 9086 4944 FEFFFFEB 		bl	_txe_mutex_get
 9087              	.LVL1002:
1080:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9088              		.loc 1 1080 0
 9089 4948 24209DE5 		ldr	r2, [sp, #36]
 9090 494c 20309DE5 		ldr	r3, [sp, #32]
 9091 4950 1010A0E3 		mov	r1, #16
 9092 4954 00208DE5 		str	r2, [sp]
 9093 4958 04208DE5 		str	r2, [sp, #4]
 9094 495c 0700A0E1 		mov	r0, r7
 9095 4960 0320A0E1 		mov	r2, r3
 9096 4964 0630A0E1 		mov	r3, r6
 9097 4968 FEFFFFEB 		bl	cmdSet
 9098              	.LVL1003:
1081:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 9099              		.loc 1 1081 0
 9100 496c 1C0097E5 		ldr	r0, [r7, #28]
 9101 4970 FEFFFFEB 		bl	_txe_mutex_put
 9102              	.LVL1004:
1082:../uvc.c      **** 
 9103              		.loc 1 1082 0
 9104 4974 0700A0E1 		mov	r0, r7
 9105 4978 0110A0E3 		mov	r1, #1
 9106 497c FEFFFFEB 		bl	setIrisauto
 9107              	.LVL1005:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9108              		.loc 1 980 0
 9109 4980 FF60A0E3 		mov	r6, #255
 9110              	.LVL1006:
 9111 4984 1CC09DE5 		ldr	ip, [sp, #28]
 9112 4988 2C709DE5 		ldr	r7, [sp, #44]
 9113 498c F3F7FFEA 		b	.L316
 9114              	.LVL1007:
 9115              	.L317:
1074:../uvc.c      **** 							break;
 9116              		.loc 1 1074 0
 9117 4990 90009FE5 		ldr	r0, .L742+16
 9118 4994 0010A0E3 		mov	r1, #0
 9119 4998 DBFFFFEA 		b	.L671
 9120              	.L573:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9121              		.loc 1 980 0
 9122 499c FF60A0E3 		mov	r6, #255
 9123              	.LVL1008:
 9124 49a0 2C709DE5 		ldr	r7, [sp, #44]
 9125 49a4 EDF7FFEA 		b	.L316
 9126              	.LVL1009:
 9127              	.L497:
 9128              	.LBE150:
 9129              	.LBE327:
 9130              	.LBE340:
 9131              	.LBE472:
 9132              	.LBB473:
 9133              	.LBB436:
 9134              	.LBB421:
 9135              	.LBB358:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9136              		.loc 1 414 0
 9137 49a8 FF70A0E3 		mov	r7, #255
 949:../uvc.c      **** 			   }
 9138              		.loc 1 949 0
 9139 49ac 0400A0E3 		mov	r0, #4
 9140              	.LVL1010:
 9141 49b0 6C109FE5 		ldr	r1, .L742+12
 9142 49b4 FEFFFFEB 		bl	CyU3PDebugPrint
 9143              	.LVL1011:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9144              		.loc 1 414 0
 9145 49b8 07C0A0E1 		mov	ip, r7
 9146 49bc 0720A0E1 		mov	r2, r7
 9147 49c0 0730A0E1 		mov	r3, r7
 9148 49c4 54FCFFEA 		b	.L492
 9149              	.LVL1012:
 9150              	.L512:
 9151              	.LBE358:
 9152              	.LBE421:
 9153              	.LBB422:
 9154              	.LBB368:
 949:../uvc.c      **** 			   }
 9155              		.loc 1 949 0
 9156 49c8 54109FE5 		ldr	r1, .L742+12
 9157 49cc 0400A0E3 		mov	r0, #4
 9158              	.LVL1013:
 9159 49d0 FEFFFFEB 		bl	CyU3PDebugPrint
 9160              	.LVL1014:
 9161 49d4 64FFFFEA 		b	.L690
 9162              	.LVL1015:
 9163              	.L739:
 9164              	.LBE368:
 9165              	.LBE422:
 9166              	.LBB423:
 9167              	.LBB377:
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 9168              		.loc 1 563 0
 9169 49d8 0310A0E1 		mov	r1, r3
 9170 49dc 28009DE5 		ldr	r0, [sp, #40]
 9171 49e0 FEFFFFEB 		bl	SensorGetControl
 9172              	.LVL1016:
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9173              		.loc 1 564 0
 9174 49e4 2CE09FE5 		ldr	lr, .L742
 566:../uvc.c      **** 		 	 		 }
 9175              		.loc 1 566 0
 9176 49e8 0130A0E3 		mov	r3, #1
 9177 49ec 3F30C4E5 		strb	r3, [r4, #63]
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9178              		.loc 1 564 0
 9179 49f0 5503CEE5 		strb	r0, [lr, #853]
 9180 49f4 6EFFFFEA 		b	.L467
 9181              	.LVL1017:
 9182              	.L738:
 9183              	.LBE377:
 9184              	.LBE423:
 9185              	.LBB424:
 9186              	.LBB390:
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 9187              		.loc 1 563 0
 9188 49f8 0310A0E1 		mov	r1, r3
 9189 49fc 28009DE5 		ldr	r0, [sp, #40]
 9190 4a00 FEFFFFEB 		bl	SensorGetControl
 9191              	.LVL1018:
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9192              		.loc 1 564 0
 9193 4a04 0CE09FE5 		ldr	lr, .L742
 566:../uvc.c      **** 		 	 		 }
 9194              		.loc 1 566 0
 9195 4a08 0130A0E3 		mov	r3, #1
 9196 4a0c 4A30C4E5 		strb	r3, [r4, #74]
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9197              		.loc 1 564 0
 9198 4a10 5D04CEE5 		strb	r0, [lr, #1117]
 9199 4a14 F2FEFFEA 		b	.L480
 9200              	.L743:
 9201              		.align	2
 9202              	.L742:
 9203 4a18 00000000 		.word	.LANCHOR1
 9204 4a1c 9C000000 		.word	.LANCHOR0+156
 9205 4a20 60020000 		.word	.LC13
 9206 4a24 24030000 		.word	.LC18
 9207 4a28 00000000 		.word	cmdQu
 9208              	.LBE390:
 9209              	.LBE424:
 9210              	.LBE436:
 9211              	.LBE473:
 9212              		.cfi_endproc
 9213              	.LFE24:
 9215              		.align	2
 9216              		.global	CyFxGpifCB
 9218              	CyFxGpifCB:
 9219              	.LFB12:
1707:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 9220              		.loc 1 1707 0
 9221              		.cfi_startproc
 9222              		@ args = 0, pretend = 0, frame = 0
 9223              		@ frame_needed = 0, uses_anonymous_args = 0
1708:../uvc.c      ****     {
 9224              		.loc 1 1708 0
 9225 4a2c 010050E3 		cmp	r0, #1
1707:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 9226              		.loc 1 1707 0
 9227 4a30 10402DE9 		stmfd	sp!, {r4, lr}
 9228              	.LCFI22:
 9229              		.cfi_def_cfa_offset 8
 9230              		.cfi_offset 4, -8
 9231              		.cfi_offset 14, -4
1708:../uvc.c      ****     {
 9232              		.loc 1 1708 0
 9233 4a34 1080BD18 		ldmnefd	sp!, {r4, pc}
 9234              	.LBB478:
 9235              	.LBB479:
1607:../uvc.c      ****     {
 9236              		.loc 1 1607 0
 9237 4a38 C4309FE5 		ldr	r3, .L762
 9238 4a3c C030D3E5 		ldrb	r3, [r3, #192]	@ zero_extendqisi2
 9239 4a40 030053E3 		cmp	r3, #3
 9240 4a44 1000000A 		beq	.L761
1631:../uvc.c      ****     {
 9241              		.loc 1 1631 0
 9242 4a48 020053E3 		cmp	r3, #2
 9243 4a4c 1080BD18 		ldmnefd	sp!, {r4, pc}
1633:../uvc.c      ****         {
 9244              		.loc 1 1633 0
 9245 4a50 083041E2 		sub	r3, r1, #8
 9246 4a54 0A0053E3 		cmp	r3, #10
 9247 4a58 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 9248 4a5c 200000EA 		b	.L754
 9249              	.L756:
 9250 4a60 DC4A0000 		.word	.L748
 9251 4a64 E44A0000 		.word	.L754
 9252 4a68 E44A0000 		.word	.L754
 9253 4a6c AC4A0000 		.word	.L744
 9254 4a70 E44A0000 		.word	.L754
 9255 4a74 E44A0000 		.word	.L754
 9256 4a78 E44A0000 		.word	.L754
 9257 4a7c B04A0000 		.word	.L760
 9258 4a80 E44A0000 		.word	.L754
 9259 4a84 E44A0000 		.word	.L754
 9260 4a88 AC4A0000 		.word	.L744
 9261              	.L761:
1609:../uvc.c      ****         {
 9262              		.loc 1 1609 0
 9263 4a8c 0B3041E2 		sub	r3, r1, #11
 9264 4a90 030053E3 		cmp	r3, #3
 9265 4a94 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 9266 4a98 110000EA 		b	.L754
 9267              	.L749:
 9268 4a9c DC4A0000 		.word	.L748
 9269 4aa0 B04A0000 		.word	.L760
 9270 4aa4 AC4A0000 		.word	.L744
 9271 4aa8 AC4A0000 		.word	.L744
 9272              	.L744:
 9273 4aac 1080BDE8 		ldmfd	sp!, {r4, pc}
 9274              	.L760:
1633:../uvc.c      ****         {
 9275              		.loc 1 1633 0
 9276 4ab0 0110A0E3 		mov	r1, #1
 9277              	.L750:
1690:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 9278              		.loc 1 1690 0
 9279 4ab4 4C009FE5 		ldr	r0, .L762+4
 9280 4ab8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
1691:../uvc.c      ****         {
 9281              		.loc 1 1691 0
 9282 4abc 004050E2 		subs	r4, r0, #0
 9283 4ac0 1080BD08 		ldmeqfd	sp!, {r4, pc}
1693:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 9284              		.loc 1 1693 0
 9285 4ac4 0400A0E3 		mov	r0, #4
 9286 4ac8 3C109FE5 		ldr	r1, .L762+8
 9287 4acc 0420A0E1 		mov	r2, r4
 9288 4ad0 FEFFFFEB 		bl	CyU3PDebugPrint
1694:../uvc.c      ****         }
 9289              		.loc 1 1694 0
 9290 4ad4 0400A0E1 		mov	r0, r4
 9291 4ad8 FEFFFFEB 		bl	CyFxAppErrorHandler
 9292              	.L748:
1609:../uvc.c      ****         {
 9293              		.loc 1 1609 0
 9294 4adc 0010A0E3 		mov	r1, #0
 9295 4ae0 F3FFFFEA 		b	.L750
 9296              	.L754:
1679:../uvc.c      ****                 /* Unexpected current state. Return error. */
 9297              		.loc 1 1679 0
 9298 4ae4 0120A0E1 		mov	r2, r1
 9299 4ae8 0100A0E3 		mov	r0, #1
 9300 4aec 1C109FE5 		ldr	r1, .L762+12
 9301 4af0 FEFFFFEB 		bl	CyU3PDebugPrint
 9302              	.LBE479:
 9303              	.LBE478:
 9304              	.LBB480:
 9305              	.LBB481:
1712:../uvc.c      ****     }
 9306              		.loc 1 1712 0
 9307 4af4 0400A0E3 		mov	r0, #4
 9308 4af8 14109FE5 		ldr	r1, .L762+16
 9309              	.LBE481:
 9310              	.LBE480:
1714:../uvc.c      **** 
 9311              		.loc 1 1714 0
 9312 4afc 1040BDE8 		ldmfd	sp!, {r4, lr}
 9313              	.LBB483:
 9314              	.LBB482:
1712:../uvc.c      ****     }
 9315              		.loc 1 1712 0
 9316 4b00 FEFFFFEA 		b	CyU3PDebugPrint
 9317              	.L763:
 9318              		.align	2
 9319              	.L762:
 9320 4b04 00000000 		.word	.LANCHOR0
 9321 4b08 00000000 		.word	glChHandleUVCStream
 9322 4b0c A8060000 		.word	.LC38
 9323 4b10 90060000 		.word	.LC37
 9324 4b14 D8060000 		.word	.LC39
 9325              	.LBE482:
 9326              	.LBE483:
 9327              		.cfi_endproc
 9328              	.LFE12:
 9330              		.align	2
 9331              		.global	CyFxUVCApplnI2CInit
 9333              	CyFxUVCApplnI2CInit:
 9334              	.LFB14:
1770:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
 9335              		.loc 1 1770 0
 9336              		.cfi_startproc
 9337              		@ args = 0, pretend = 0, frame = 16
 9338              		@ frame_needed = 0, uses_anonymous_args = 0
 9339 4b18 10402DE9 		stmfd	sp!, {r4, lr}
 9340              	.LCFI23:
 9341              		.cfi_def_cfa_offset 8
 9342              		.cfi_offset 4, -8
 9343              		.cfi_offset 14, -4
 9344 4b1c 10D04DE2 		sub	sp, sp, #16
 9345              	.LCFI24:
 9346              		.cfi_def_cfa_offset 24
1774:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 9347              		.loc 1 1774 0
 9348 4b20 FEFFFFEB 		bl	CyU3PI2cInit
 9349              	.LVL1019:
1775:../uvc.c      ****     {
 9350              		.loc 1 1775 0
 9351 4b24 004050E2 		subs	r4, r0, #0
 9352 4b28 0B00001A 		bne	.L767
1782:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 9353              		.loc 1 1782 0
 9354 4b2c 50209FE5 		ldr	r2, .L769
1784:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 9355              		.loc 1 1784 0
 9356 4b30 0030E0E3 		mvn	r3, #0
1787:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 9357              		.loc 1 1787 0
 9358 4b34 0410A0E1 		mov	r1, r4
 9359 4b38 0D00A0E1 		mov	r0, sp
 9360              	.LVL1020:
1782:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 9361              		.loc 1 1782 0
 9362 4b3c 14008DE8 		stmia	sp, {r2, r4}
1784:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 9363              		.loc 1 1784 0
 9364 4b40 08308DE5 		str	r3, [sp, #8]
1785:../uvc.c      **** 
 9365              		.loc 1 1785 0
 9366 4b44 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1787:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 9367              		.loc 1 1787 0
 9368 4b48 FEFFFFEB 		bl	CyU3PI2cSetConfig
 9369              	.LVL1021:
1788:../uvc.c      ****     {
 9370              		.loc 1 1788 0
 9371 4b4c 004050E2 		subs	r4, r0, #0
 9372 4b50 0600001A 		bne	.L768
1793:../uvc.c      **** 
 9373              		.loc 1 1793 0
 9374 4b54 10D08DE2 		add	sp, sp, #16
 9375              		@ sp needed
 9376 4b58 1080BDE8 		ldmfd	sp!, {r4, pc}
 9377              	.L767:
1777:../uvc.c      ****         CyFxAppErrorHandler (status);
 9378              		.loc 1 1777 0
 9379 4b5c 0400A0E3 		mov	r0, #4
 9380              	.LVL1022:
 9381 4b60 20109FE5 		ldr	r1, .L769+4
 9382 4b64 FEFFFFEB 		bl	CyU3PDebugPrint
 9383              	.LVL1023:
1778:../uvc.c      ****     }
 9384              		.loc 1 1778 0
 9385 4b68 0400A0E1 		mov	r0, r4
 9386 4b6c FEFFFFEB 		bl	CyFxAppErrorHandler
 9387              	.LVL1024:
 9388              	.L768:
1790:../uvc.c      ****         CyFxAppErrorHandler (status);
 9389              		.loc 1 1790 0
 9390 4b70 0400A0E3 		mov	r0, #4
 9391              	.LVL1025:
 9392 4b74 10109FE5 		ldr	r1, .L769+8
 9393 4b78 FEFFFFEB 		bl	CyU3PDebugPrint
 9394              	.LVL1026:
1791:../uvc.c      ****     }
 9395              		.loc 1 1791 0
 9396 4b7c 0400A0E1 		mov	r0, r4
 9397 4b80 FEFFFFEB 		bl	CyFxAppErrorHandler
 9398              	.LVL1027:
 9399              	.L770:
 9400              		.align	2
 9401              	.L769:
 9402 4b84 A0860100 		.word	100000
 9403 4b88 EC060000 		.word	.LC40
 9404 4b8c 08070000 		.word	.LC41
 9405              		.cfi_endproc
 9406              	.LFE14:
 9408              		.align	2
 9409              		.global	UVCAppThread_Entry
 9411              	UVCAppThread_Entry:
 9412              	.LFB18:
2269:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 9413              		.loc 1 2269 0
 9414              		.cfi_startproc
 9415              		@ args = 0, pretend = 0, frame = 128
 9416              		@ frame_needed = 0, uses_anonymous_args = 0
 9417              	.LVL1028:
 9418 4b90 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 9419              	.LCFI25:
 9420              		.cfi_def_cfa_offset 32
 9421              		.cfi_offset 4, -32
 9422              		.cfi_offset 5, -28
 9423              		.cfi_offset 6, -24
 9424              		.cfi_offset 7, -20
 9425              		.cfi_offset 8, -16
 9426              		.cfi_offset 9, -12
 9427              		.cfi_offset 10, -8
 9428              		.cfi_offset 14, -4
 9429 4b94 88D04DE2 		sub	sp, sp, #136
 9430              	.LCFI26:
 9431              		.cfi_def_cfa_offset 168
 9432              	.LBB490:
 9433              	.LBB491:
1725:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9434              		.loc 1 1725 0
 9435 4b98 FEFFFFEB 		bl	CyU3PUartInit
 9436              	.LVL1029:
1726:../uvc.c      ****     {
 9437              		.loc 1 1726 0
 9438 4b9c 004050E2 		subs	r4, r0, #0
 9439 4ba0 DF01001A 		bne	.L831
1733:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 9440              		.loc 1 1733 0
 9441 4ba4 08299FE5 		ldr	r2, .L860
1734:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 9442              		.loc 1 1734 0
 9443 4ba8 0130A0E3 		mov	r3, #1
1742:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9444              		.loc 1 1742 0
 9445 4bac 0410A0E1 		mov	r1, r4
 9446 4bb0 60008DE2 		add	r0, sp, #96
 9447              	.LVL1030:
1735:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 9448              		.loc 1 1735 0
 9449 4bb4 7540CDE5 		strb	r4, [sp, #117]
1737:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 9450              		.loc 1 1737 0
 9451 4bb8 64408DE5 		str	r4, [sp, #100]
1738:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 9452              		.loc 1 1738 0
 9453 4bbc 68408DE5 		str	r4, [sp, #104]
1733:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 9454              		.loc 1 1733 0
 9455 4bc0 70208DE5 		str	r2, [sp, #112]
1734:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 9456              		.loc 1 1734 0
 9457 4bc4 7430CDE5 		strb	r3, [sp, #116]
1736:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 9458              		.loc 1 1736 0
 9459 4bc8 60308DE5 		str	r3, [sp, #96]
1739:../uvc.c      **** 
 9460              		.loc 1 1739 0
 9461 4bcc 6C308DE5 		str	r3, [sp, #108]
1742:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9462              		.loc 1 1742 0
 9463 4bd0 FEFFFFEB 		bl	CyU3PUartSetConfig
 9464              	.LVL1031:
1743:../uvc.c      ****     {
 9465              		.loc 1 1743 0
 9466 4bd4 000050E3 		cmp	r0, #0
 9467 4bd8 AD01001A 		bne	.L830
1749:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9468              		.loc 1 1749 0
 9469 4bdc 0000E0E3 		mvn	r0, #0
 9470              	.LVL1032:
 9471 4be0 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 9472              	.LVL1033:
1750:../uvc.c      ****     {
 9473              		.loc 1 1750 0
 9474 4be4 000050E3 		cmp	r0, #0
 9475 4be8 A901001A 		bne	.L830
1756:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9476              		.loc 1 1756 0
 9477 4bec 0300A0E3 		mov	r0, #3
 9478              	.LVL1034:
 9479 4bf0 0410A0E3 		mov	r1, #4
 9480 4bf4 FEFFFFEB 		bl	CyU3PDebugInit
 9481              	.LVL1035:
1757:../uvc.c      ****     {
 9482              		.loc 1 1757 0
 9483 4bf8 000050E3 		cmp	r0, #0
 9484 4bfc A401001A 		bne	.L830
1763:../uvc.c      **** }
 9485              		.loc 1 1763 0
 9486 4c00 FEFFFFEB 		bl	CyU3PDebugPreamble
 9487              	.LVL1036:
 9488 4c04 0640A0E3 		mov	r4, #6
 9489              	.LVL1037:
 9490              	.L777:
 9491              	.LBE491:
 9492              	.LBE490:
2285:../uvc.c      **** 	}
 9493              		.loc 1 2285 0
 9494 4c08 7D0FA0E3 		mov	r0, #500
 9495 4c0c 014044E2 		sub	r4, r4, #1
 9496 4c10 FEFFFFEB 		bl	_tx_thread_sleep
 9497              	.LVL1038:
2284:../uvc.c      **** 		CyU3PThreadSleep(500);
 9498              		.loc 1 2284 0
 9499 4c14 FF4014E2 		ands	r4, r4, #255
 9500 4c18 FAFFFF1A 		bne	.L777
 9501              	.LBB493:
 9502              	.LBB494:
1861:../uvc.c      ****     if (apiRetStatus != 0)
 9503              		.loc 1 1861 0
 9504 4c1c 94789FE5 		ldr	r7, .L860+4
 9505              	.LBE494:
 9506              	.LBE493:
2288:../uvc.c      **** 
 9507              		.loc 1 2288 0
 9508 4c20 FEFFFFEB 		bl	CyFxUVCApplnI2CInit
 9509              	.LVL1039:
 9510              	.LBB498:
 9511              	.LBB495:
1861:../uvc.c      ****     if (apiRetStatus != 0)
 9512              		.loc 1 1861 0
 9513 4c24 0410A0E1 		mov	r1, r4
 9514 4c28 0700A0E1 		mov	r0, r7
 9515 4c2c 2820A0E3 		mov	r2, #40
 9516 4c30 FEFFFFEB 		bl	_txe_event_flags_create
 9517              	.LVL1040:
1862:../uvc.c      ****     {
 9518              		.loc 1 1862 0
 9519 4c34 005050E2 		subs	r5, r0, #0
 9520 4c38 FF01001A 		bne	.L832
1876:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 9521              		.loc 1 1876 0
 9522 4c3c 0260A0E3 		mov	r6, #2
1879:../uvc.c      ****     gpioClock.halfDiv    = 0;
 9523              		.loc 1 1879 0
 9524 4c40 0380A0E3 		mov	r8, #3
1883:../uvc.c      ****     if (apiRetStatus != 0)
 9525              		.loc 1 1883 0
 9526 4c44 14008DE2 		add	r0, sp, #20
 9527              	.LVL1041:
 9528 4c48 0410A0E1 		mov	r1, r4
1872:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 9529              		.loc 1 1872 0
 9530 4c4c 884087E5 		str	r4, [r7, #136]
1873:../uvc.c      **** 
 9531              		.loc 1 1873 0
 9532 4c50 8C4087E5 		str	r4, [r7, #140]
1878:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 9533              		.loc 1 1878 0
 9534 4c54 1C40CDE5 		strb	r4, [sp, #28]
1880:../uvc.c      **** 
 9535              		.loc 1 1880 0
 9536 4c58 18408DE5 		str	r4, [sp, #24]
1876:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 9537              		.loc 1 1876 0
 9538 4c5c 1460CDE5 		strb	r6, [sp, #20]
1877:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 9539              		.loc 1 1877 0
 9540 4c60 1560CDE5 		strb	r6, [sp, #21]
1879:../uvc.c      ****     gpioClock.halfDiv    = 0;
 9541              		.loc 1 1879 0
 9542 4c64 1D80CDE5 		strb	r8, [sp, #29]
1883:../uvc.c      ****     if (apiRetStatus != 0)
 9543              		.loc 1 1883 0
 9544 4c68 FEFFFFEB 		bl	CyU3PGpioInit
 9545              	.LVL1042:
1884:../uvc.c      ****     {
 9546              		.loc 1 1884 0
 9547 4c6c 005050E2 		subs	r5, r0, #0
 9548 4c70 EB01001A 		bne	.L833
1892:../uvc.c      ****     if (apiRetStatus != 0)
 9549              		.loc 1 1892 0
 9550 4c74 1600A0E3 		mov	r0, #22
 9551              	.LVL1043:
 9552 4c78 0110A0E3 		mov	r1, #1
 9553 4c7c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9554              	.LVL1044:
1893:../uvc.c      ****     {
 9555              		.loc 1 1893 0
 9556 4c80 005050E2 		subs	r5, r0, #0
 9557 4c84 E001001A 		bne	.L834
1898:../uvc.c      ****     if (apiRetStatus != 0)
 9558              		.loc 1 1898 0
 9559 4c88 1400A0E3 		mov	r0, #20
 9560              	.LVL1045:
 9561 4c8c 0110A0E3 		mov	r1, #1
 9562 4c90 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9563              	.LVL1046:
1899:../uvc.c      ****     {
 9564              		.loc 1 1899 0
 9565 4c94 005050E2 		subs	r5, r0, #0
 9566 4c98 D501001A 		bne	.L835
1904:../uvc.c      ****     if (apiRetStatus != 0)
 9567              		.loc 1 1904 0
 9568 4c9c 1800A0E3 		mov	r0, #24
 9569              	.LVL1047:
 9570 4ca0 0110A0E3 		mov	r1, #1
 9571 4ca4 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9572              	.LVL1048:
1905:../uvc.c      ****     {
 9573              		.loc 1 1905 0
 9574 4ca8 005050E2 		subs	r5, r0, #0
 9575 4cac FA01001A 		bne	.L836
1912:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9576              		.loc 1 1912 0
 9577 4cb0 0150A0E3 		mov	r5, #1
1917:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9578              		.loc 1 1917 0
 9579 4cb4 30108DE2 		add	r1, sp, #48
 9580 4cb8 1600A0E3 		mov	r0, #22
 9581              	.LVL1049:
1915:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9582              		.loc 1 1915 0
 9583 4cbc 3C408DE5 		str	r4, [sp, #60]
1916:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 9584              		.loc 1 1916 0
 9585 4cc0 4040CDE5 		strb	r4, [sp, #64]
1912:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9586              		.loc 1 1912 0
 9587 4cc4 30508DE5 		str	r5, [sp, #48]
1913:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 9588              		.loc 1 1913 0
 9589 4cc8 34508DE5 		str	r5, [sp, #52]
1914:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 9590              		.loc 1 1914 0
 9591 4ccc 38508DE5 		str	r5, [sp, #56]
1917:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9592              		.loc 1 1917 0
 9593 4cd0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9594              	.LVL1050:
1918:../uvc.c      ****     {
 9595              		.loc 1 1918 0
 9596 4cd4 009050E2 		subs	r9, r0, #0
 9597 4cd8 E901001A 		bne	.L837
1931:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9598              		.loc 1 1931 0
 9599 4cdc 1400A0E3 		mov	r0, #20
 9600              	.LVL1051:
 9601 4ce0 30108DE2 		add	r1, sp, #48
1926:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9602              		.loc 1 1926 0
 9603 4ce4 30508DE5 		str	r5, [sp, #48]
1927:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 9604              		.loc 1 1927 0
 9605 4ce8 34508DE5 		str	r5, [sp, #52]
1928:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 9606              		.loc 1 1928 0
 9607 4cec 38508DE5 		str	r5, [sp, #56]
1929:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9608              		.loc 1 1929 0
 9609 4cf0 3C408DE5 		str	r4, [sp, #60]
1930:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 9610              		.loc 1 1930 0
 9611 4cf4 4040CDE5 		strb	r4, [sp, #64]
1931:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9612              		.loc 1 1931 0
 9613 4cf8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9614              	.LVL1052:
1932:../uvc.c      ****     {
 9615              		.loc 1 1932 0
 9616 4cfc 009050E2 		subs	r9, r0, #0
 9617 4d00 D901001A 		bne	.L838
1945:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9618              		.loc 1 1945 0
 9619 4d04 30108DE2 		add	r1, sp, #48
 9620 4d08 1800A0E3 		mov	r0, #24
 9621              	.LVL1053:
1940:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 9622              		.loc 1 1940 0
 9623 4d0c 30408DE5 		str	r4, [sp, #48]
1941:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 9624              		.loc 1 1941 0
 9625 4d10 34408DE5 		str	r4, [sp, #52]
1942:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 9626              		.loc 1 1942 0
 9627 4d14 38408DE5 		str	r4, [sp, #56]
1943:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9628              		.loc 1 1943 0
 9629 4d18 3C508DE5 		str	r5, [sp, #60]
1944:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 9630              		.loc 1 1944 0
 9631 4d1c 4040CDE5 		strb	r4, [sp, #64]
1945:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9632              		.loc 1 1945 0
 9633 4d20 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9634              	.LVL1054:
1946:../uvc.c      ****     {
 9635              		.loc 1 1946 0
 9636 4d24 009050E2 		subs	r9, r0, #0
 9637 4d28 C901001A 		bne	.L839
1958:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9638              		.loc 1 1958 0
 9639 4d2c 0500A0E1 		mov	r0, r5
 9640              	.LVL1055:
 9641 4d30 20108DE2 		add	r1, sp, #32
1955:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 9642              		.loc 1 1955 0
 9643 4d34 28408DE5 		str	r4, [sp, #40]
1956:../uvc.c      **** 
 9644              		.loc 1 1956 0
 9645 4d38 24408DE5 		str	r4, [sp, #36]
1953:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 9646              		.loc 1 1953 0
 9647 4d3c B062CDE1 		strh	r6, [sp, #32]	@ movhi
1954:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 9648              		.loc 1 1954 0
 9649 4d40 2C80CDE5 		strb	r8, [sp, #44]
1958:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9650              		.loc 1 1958 0
 9651 4d44 FEFFFFEB 		bl	CyU3PPibInit
 9652              	.LVL1056:
1959:../uvc.c      ****     {
 9653              		.loc 1 1959 0
 9654 4d48 004050E2 		subs	r4, r0, #0
 9655 4d4c A201001A 		bne	.L840
1966:../uvc.c      **** 
 9656              		.loc 1 1966 0
 9657 4d50 64079FE5 		ldr	r0, .L860+8
 9658              	.LVL1057:
 9659 4d54 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 9660              	.LVL1058:
1974:../uvc.c      ****     SensorInit ();
 9661              		.loc 1 1974 0
 9662 4d58 FEFFFFEB 		bl	SensorReset
 9663              	.LVL1059:
1975:../uvc.c      **** 
 9664              		.loc 1 1975 0
 9665 4d5c FEFFFFEB 		bl	SensorInit
 9666              	.LVL1060:
1978:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9667              		.loc 1 1978 0
 9668 4d60 FEFFFFEB 		bl	CyU3PUsbStart
 9669              	.LVL1061:
1979:../uvc.c      ****     {
 9670              		.loc 1 1979 0
 9671 4d64 004050E2 		subs	r4, r0, #0
 9672 4d68 9501001A 		bne	.L841
1985:../uvc.c      **** 
 9673              		.loc 1 1985 0
 9674 4d6c 0410A0E1 		mov	r1, r4
 9675 4d70 48079FE5 		ldr	r0, .L860+12
 9676              	.LVL1062:
 9677 4d74 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 9678              	.LVL1063:
1988:../uvc.c      **** 
 9679              		.loc 1 1988 0
 9680 4d78 44079FE5 		ldr	r0, .L860+16
 9681 4d7c FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 9682              	.LVL1064:
1994:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 9683              		.loc 1 1994 0
 9684 4d80 0410A0E1 		mov	r1, r4
 9685 4d84 3C279FE5 		ldr	r2, .L860+20
 9686 4d88 0100A0E3 		mov	r0, #1
 9687 4d8c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9688              	.LVL1065:
1995:../uvc.c      **** 
 9689              		.loc 1 1995 0
 9690 4d90 0410A0E1 		mov	r1, r4
 9691 4d94 0400A0E1 		mov	r0, r4
 9692 4d98 2C279FE5 		ldr	r2, .L860+24
 9693 4d9c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9694              	.LVL1066:
1998:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 9695              		.loc 1 1998 0
 9696 4da0 0410A0E1 		mov	r1, r4
 9697 4da4 24279FE5 		ldr	r2, .L860+28
 9698 4da8 0200A0E3 		mov	r0, #2
 9699 4dac FEFFFFEB 		bl	CyU3PUsbSetDesc
 9700              	.LVL1067:
1999:../uvc.c      **** 
 9701              		.loc 1 1999 0
 9702 4db0 0410A0E1 		mov	r1, r4
 9703 4db4 18279FE5 		ldr	r2, .L860+32
 9704 4db8 0700A0E3 		mov	r0, #7
 9705 4dbc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9706              	.LVL1068:
2002:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 9707              		.loc 1 2002 0
 9708 4dc0 0410A0E1 		mov	r1, r4
 9709 4dc4 0C279FE5 		ldr	r2, .L860+36
 9710 4dc8 0400A0E3 		mov	r0, #4
 9711 4dcc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9712              	.LVL1069:
2003:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 9713              		.loc 1 2003 0
 9714 4dd0 0410A0E1 		mov	r1, r4
 9715 4dd4 00279FE5 		ldr	r2, .L860+40
 9716 4dd8 0300A0E3 		mov	r0, #3
 9717 4ddc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9718              	.LVL1070:
2004:../uvc.c      **** 
 9719              		.loc 1 2004 0
 9720 4de0 0410A0E1 		mov	r1, r4
 9721 4de4 F4269FE5 		ldr	r2, .L860+44
 9722 4de8 0600A0E3 		mov	r0, #6
 9723 4dec FEFFFFEB 		bl	CyU3PUsbSetDesc
 9724              	.LVL1071:
2007:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 9725              		.loc 1 2007 0
 9726 4df0 0410A0E1 		mov	r1, r4
 9727 4df4 E8269FE5 		ldr	r2, .L860+48
 9728 4df8 0500A0E3 		mov	r0, #5
 9729 4dfc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9730              	.LVL1072:
2008:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 9731              		.loc 1 2008 0
 9732 4e00 0110A0E3 		mov	r1, #1
 9733 4e04 DC269FE5 		ldr	r2, .L860+52
 9734 4e08 0500A0E3 		mov	r0, #5
 9735 4e0c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9736              	.LVL1073:
2009:../uvc.c      **** 
 9737              		.loc 1 2009 0
 9738 4e10 0210A0E3 		mov	r1, #2
 9739 4e14 D0269FE5 		ldr	r2, .L860+56
 9740 4e18 0500A0E3 		mov	r0, #5
 9741 4e1c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9742              	.LVL1074:
2016:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 9743              		.loc 1 2016 0
 9744 4e20 0150A0E3 		mov	r5, #1
2017:../uvc.c      ****     endPointConfig.pcktSize = 64;
 9745              		.loc 1 2017 0
 9746 4e24 0320A0E3 		mov	r2, #3
2018:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 9747              		.loc 1 2018 0
 9748 4e28 4030A0E3 		mov	r3, #64
2022:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9749              		.loc 1 2022 0
 9750 4e2c 08108DE2 		add	r1, sp, #8
 9751 4e30 8200A0E3 		mov	r0, #130
2019:../uvc.c      ****     endPointConfig.streams  = 0;
 9752              		.loc 1 2019 0
 9753 4e34 1340CDE5 		strb	r4, [sp, #19]
2020:../uvc.c      ****     endPointConfig.burstLen = 1;
 9754              		.loc 1 2020 0
 9755 4e38 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2016:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 9756              		.loc 1 2016 0
 9757 4e3c 08508DE5 		str	r5, [sp, #8]
2021:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 9758              		.loc 1 2021 0
 9759 4e40 1250CDE5 		strb	r5, [sp, #18]
2017:../uvc.c      ****     endPointConfig.pcktSize = 64;
 9760              		.loc 1 2017 0
 9761 4e44 0C20CDE5 		strb	r2, [sp, #12]
2018:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 9762              		.loc 1 2018 0
 9763 4e48 B031CDE1 		strh	r3, [sp, #16]	@ movhi
2022:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9764              		.loc 1 2022 0
 9765 4e4c FEFFFFEB 		bl	CyU3PSetEpConfig
 9766              	.LVL1075:
2023:../uvc.c      ****     {
 9767              		.loc 1 2023 0
 9768 4e50 004050E2 		subs	r4, r0, #0
2026:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 9769              		.loc 1 2026 0
 9770 4e54 0400A013 		movne	r0, #4
 9771              	.LVL1076:
2023:../uvc.c      ****     {
 9772              		.loc 1 2023 0
 9773 4e58 3D01001A 		bne	.L828
2031:../uvc.c      ****     dmaInterConfig.count          = 1;
 9774              		.loc 1 2031 0
 9775 4e5c 8CC69FE5 		ldr	ip, .L860+60
 9776 4e60 413BA0E3 		mov	r3, #66560
2040:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 9777              		.loc 1 2040 0
 9778 4e64 1060A0E3 		mov	r6, #16
2042:../uvc.c      ****             &dmaInterConfig);
 9779              		.loc 1 2042 0
 9780 4e68 84069FE5 		ldr	r0, .L860+64
 9781 4e6c 0410A0E3 		mov	r1, #4
 9782 4e70 44208DE2 		add	r2, sp, #68
2031:../uvc.c      ****     dmaInterConfig.count          = 1;
 9783              		.loc 1 2031 0
 9784 4e74 4C408DE5 		str	r4, [sp, #76]
 9785 4e78 50408DE5 		str	r4, [sp, #80]
2039:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 9786              		.loc 1 2039 0
 9787 4e7c 5440CDE5 		strb	r4, [sp, #84]
2041:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 9788              		.loc 1 2041 0
 9789 4e80 5C408DE5 		str	r4, [sp, #92]
2031:../uvc.c      ****     dmaInterConfig.count          = 1;
 9790              		.loc 1 2031 0
 9791 4e84 48C08DE5 		str	ip, [sp, #72]
 9792 4e88 44308DE5 		str	r3, [sp, #68]
2040:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 9793              		.loc 1 2040 0
 9794 4e8c 58608DE5 		str	r6, [sp, #88]
2042:../uvc.c      ****             &dmaInterConfig);
 9795              		.loc 1 2042 0
 9796 4e90 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 9797              	.LVL1077:
2044:../uvc.c      ****     {
 9798              		.loc 1 2044 0
 9799 4e94 004050E2 		subs	r4, r0, #0
 9800 4e98 4301001A 		bne	.L842
2051:../uvc.c      ****     if (glInterStaBuffer == 0)
 9801              		.loc 1 2051 0
 9802 4e9c 010BA0E3 		mov	r0, #1024
 9803              	.LVL1078:
 9804 4ea0 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 9805              	.LVL1079:
 9806 4ea4 4C369FE5 		ldr	r3, .L860+68
2052:../uvc.c      ****     {
 9807              		.loc 1 2052 0
 9808 4ea8 000050E3 		cmp	r0, #0
2051:../uvc.c      ****     if (glInterStaBuffer == 0)
 9809              		.loc 1 2051 0
 9810 4eac 000083E5 		str	r0, [r3]
2052:../uvc.c      ****     {
 9811              		.loc 1 2052 0
 9812 4eb0 3801000A 		beq	.L843
2059:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 9813              		.loc 1 2059 0
 9814 4eb4 0410A0E1 		mov	r1, r4
 9815 4eb8 0420A0E1 		mov	r2, r4
 9816 4ebc 3830A0E3 		mov	r3, #56
 9817 4ec0 34069FE5 		ldr	r0, .L860+72
 9818 4ec4 FEFFFFEB 		bl	_txe_mutex_create
 9819              	.LVL1080:
2064:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 9820              		.loc 1 2064 0
 9821 4ec8 30169FE5 		ldr	r1, .L860+76
2065:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 9822              		.loc 1 2065 0
 9823 4ecc 30269FE5 		ldr	r2, .L860+80
2072:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 9824              		.loc 1 2072 0
 9825 4ed0 30A69FE5 		ldr	r10, .L860+84
2061:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 9826              		.loc 1 2061 0
 9827 4ed4 0460A0E3 		mov	r6, #4
2063:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 9828              		.loc 1 2063 0
 9829 4ed8 01ECA0E3 		mov	lr, #256
2067:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 9830              		.loc 1 2067 0
 9831 4edc 0CC0A0E3 		mov	ip, #12
2071:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 9832              		.loc 1 2071 0
 9833 4ee0 1830A0E3 		mov	r3, #24
2064:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 9834              		.loc 1 2064 0
 9835 4ee4 B816CDE1 		strh	r1, [sp, #104]	@ movhi
2065:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 9836              		.loc 1 2065 0
 9837 4ee8 BE26CDE1 		strh	r2, [sp, #110]	@ movhi
2060:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 9838              		.loc 1 2060 0
 9839 4eec 0199A0E3 		mov	r9, #16384
2062:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 9840              		.loc 1 2062 0
 9841 4ef0 0280A0E3 		mov	r8, #2
2073:../uvc.c      ****             &dmaMultiConfig);
 9842              		.loc 1 2073 0
 9843 4ef4 10069FE5 		ldr	r0, .L860+88
 9844 4ef8 0710A0E3 		mov	r1, #7
 9845 4efc 60208DE2 		add	r2, sp, #96
2066:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 9846              		.loc 1 2066 0
 9847 4f00 B647CDE1 		strh	r4, [sp, #118]	@ movhi
2069:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 9848              		.loc 1 2069 0
 9849 4f04 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
2070:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 9850              		.loc 1 2070 0
 9851 4f08 7E40CDE5 		strb	r4, [sp, #126]
2072:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 9852              		.loc 1 2072 0
 9853 4f0c 84A08DE5 		str	r10, [sp, #132]
2060:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 9854              		.loc 1 2060 0
 9855 4f10 B096CDE1 		strh	r9, [sp, #96]	@ movhi
2061:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 9856              		.loc 1 2061 0
 9857 4f14 B266CDE1 		strh	r6, [sp, #98]	@ movhi
2068:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 9858              		.loc 1 2068 0
 9859 4f18 BA67CDE1 		strh	r6, [sp, #122]	@ movhi
2062:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 9860              		.loc 1 2062 0
 9861 4f1c B486CDE1 		strh	r8, [sp, #100]	@ movhi
2063:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 9862              		.loc 1 2063 0
 9863 4f20 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
2067:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 9864              		.loc 1 2067 0
 9865 4f24 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
2071:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 9866              		.loc 1 2071 0
 9867 4f28 80308DE5 		str	r3, [sp, #128]
2073:../uvc.c      ****             &dmaMultiConfig);
 9868              		.loc 1 2073 0
 9869 4f2c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 9870              	.LVL1081:
2075:../uvc.c      ****     {
 9871              		.loc 1 2075 0
 9872 4f30 004050E2 		subs	r4, r0, #0
 9873 4f34 1101001A 		bne	.L844
2166:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9874              		.loc 1 2166 0
 9875 4f38 0500A0E1 		mov	r0, r5
 9876              	.LVL1082:
 9877 4f3c 0510A0E1 		mov	r1, r5
 9878 4f40 FEFFFFEB 		bl	CyU3PConnectState
 9879              	.LVL1083:
2167:../uvc.c      ****     {
 9880              		.loc 1 2167 0
 9881 4f44 004050E2 		subs	r4, r0, #0
 9882 4f48 0601001A 		bne	.L845
2173:../uvc.c      **** 
 9883              		.loc 1 2173 0
 9884 4f4c 6400A0E3 		mov	r0, #100
 9885              	.LVL1084:
 9886 4f50 FEFFFFEB 		bl	CyFx3BusyWait
 9887              	.LVL1085:
2175:../uvc.c      **** 
 9888              		.loc 1 2175 0
 9889 4f54 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 9890              	.LVL1086:
2190:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9891              		.loc 1 2190 0
 9892 4f58 08108DE2 		add	r1, sp, #8
2189:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 9893              		.loc 1 2189 0
 9894 4f5c BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2177:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 9895              		.loc 1 2177 0
 9896 4f60 08508DE5 		str	r5, [sp, #8]
2178:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 9897              		.loc 1 2178 0
 9898 4f64 0C80CDE5 		strb	r8, [sp, #12]
2182:../uvc.c      ****     }
 9899              		.loc 1 2182 0
 9900 4f68 030050E3 		cmp	r0, #3
2175:../uvc.c      **** 
 9901              		.loc 1 2175 0
 9902 4f6c 0030A0E1 		mov	r3, r0
2182:../uvc.c      ****     }
 9903              		.loc 1 2182 0
 9904 4f70 01C0A013 		movne	ip, #1
 9905 4f74 10C0A003 		moveq	ip, #16
 9906 4f78 022CA013 		movne	r2, #512
 9907 4f7c 012BA003 		moveq	r2, #1024
2190:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9908              		.loc 1 2190 0
 9909 4f80 8300A0E3 		mov	r0, #131
2175:../uvc.c      **** 
 9910              		.loc 1 2175 0
 9911 4f84 C030C7E5 		strb	r3, [r7, #192]
 9912 4f88 12C0CDE5 		strb	ip, [sp, #18]
 9913 4f8c B021CDE1 		strh	r2, [sp, #16]	@ movhi
2190:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9914              		.loc 1 2190 0
 9915 4f90 FEFFFFEB 		bl	CyU3PSetEpConfig
 9916              	.LVL1087:
2191:../uvc.c      ****     {
 9917              		.loc 1 2191 0
 9918 4f94 004050E2 		subs	r4, r0, #0
 9919              	.LBE495:
 9920              	.LBE498:
2312:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9921              		.loc 1 2312 0
 9922 4f98 18459F05 		ldreq	r4, .L860+4
 9923              	.LBB499:
 9924              	.LBB496:
2191:../uvc.c      ****     {
 9925              		.loc 1 2191 0
 9926 4f9c 0C00000A 		beq	.L815
 9927 4fa0 EA0000EA 		b	.L859
 9928              	.LVL1088:
 9929              	.L848:
 9930              	.LBE496:
 9931              	.LBE499:
2358:../uvc.c      ****             {
 9932              		.loc 1 2358 0
 9933 4fa4 783094E5 		ldr	r3, [r4, #120]
 9934 4fa8 050053E1 		cmp	r3, r5
 9935 4fac 0300000A 		beq	.L796
2358:../uvc.c      ****             {
 9936              		.loc 1 2358 0 is_stmt 0 discriminator 1
 9937 4fb0 BC27D4E1 		ldrh	r2, [r4, #124]
 9938 4fb4 BE37D4E1 		ldrh	r3, [r4, #126]
 9939 4fb8 030052E1 		cmp	r2, r3
 9940 4fbc 3B00000A 		beq	.L847
 9941              	.L796:
2532:../uvc.c      **** 
 9942              		.loc 1 2532 0 is_stmt 1
 9943 4fc0 4010A0E3 		mov	r1, #64
 9944 4fc4 0020A0E3 		mov	r2, #0
 9945 4fc8 E8049FE5 		ldr	r0, .L860+4
 9946 4fcc FEFFFFEB 		bl	_txe_event_flags_set
 9947              	.LVL1089:
2535:../uvc.c      ****     }
 9948              		.loc 1 2535 0
 9949 4fd0 FEFFFFEB 		bl	_txe_thread_relinquish
 9950              	.LVL1090:
 9951              	.L815:
2312:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9952              		.loc 1 2312 0
 9953 4fd4 0050A0E3 		mov	r5, #0
 9954 4fd8 00508DE5 		str	r5, [sp]
 9955 4fdc D4049FE5 		ldr	r0, .L860+4
 9956 4fe0 0110A0E3 		mov	r1, #1
 9957 4fe4 0220A0E3 		mov	r2, #2
 9958 4fe8 60308DE2 		add	r3, sp, #96
 9959 4fec FEFFFFEB 		bl	_txe_event_flags_get
 9960              	.LVL1091:
 9961 4ff0 006050E2 		subs	r6, r0, #0
 9962 4ff4 EAFFFF0A 		beq	.L848
2459:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9963              		.loc 1 2459 0
 9964 4ff8 00508DE5 		str	r5, [sp]
 9965 4ffc B4049FE5 		ldr	r0, .L860+4
 9966 5000 0210A0E3 		mov	r1, #2
 9967 5004 0320A0E3 		mov	r2, #3
 9968 5008 60308DE2 		add	r3, sp, #96
 9969 500c FEFFFFEB 		bl	_txe_event_flags_get
 9970              	.LVL1092:
 9971 5010 000050E3 		cmp	r0, #0
 9972 5014 0B00001A 		bne	.L807
2474:../uvc.c      ****                 {
 9973              		.loc 1 2474 0
 9974 5018 8C3094E5 		ldr	r3, [r4, #140]
2462:../uvc.c      ****                 prodCount = 0;
 9975              		.loc 1 2462 0
 9976 501c 780084E5 		str	r0, [r4, #120]
2474:../uvc.c      ****                 {
 9977              		.loc 1 2474 0
 9978 5020 000053E3 		cmp	r3, #0
2463:../uvc.c      ****                 consCount = 0;
 9979              		.loc 1 2463 0
 9980 5024 BC07C4E1 		strh	r0, [r4, #124]	@ movhi
2470:../uvc.c      ****                 pb=0;
 9981              		.loc 1 2470 0
 9982 5028 BC06C4E1 		strh	r0, [r4, #108]	@ movhi
2464:../uvc.c      ****                 if(0&&(prinflag == 0)){
 9983              		.loc 1 2464 0
 9984 502c BE07C4E1 		strh	r0, [r4, #126]	@ movhi
2471:../uvc.c      ****                 pbc=0;
 9985              		.loc 1 2471 0
 9986 5030 BE06C4E1 		strh	r0, [r4, #110]	@ movhi
2472:../uvc.c      **** 
 9987              		.loc 1 2472 0
 9988 5034 B007C4E1 		strh	r0, [r4, #112]	@ movhi
2474:../uvc.c      ****                 {
 9989              		.loc 1 2474 0
 9990 5038 4600000A 		beq	.L849
 9991              	.L808:
2486:../uvc.c      ****             }
 9992              		.loc 1 2486 0
 9993 503c 0030A0E3 		mov	r3, #0
 9994 5040 8C3087E5 		str	r3, [r7, #140]
 9995 5044 DDFFFFEA 		b	.L796
 9996              	.L807:
2491:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 9997              		.loc 1 2491 0
 9998 5048 0030E0E3 		mvn	r3, #0
 9999 504c 00308DE5 		str	r3, [sp]
 10000 5050 0110A0E3 		mov	r1, #1
 10001 5054 0220A0E3 		mov	r2, #2
 10002 5058 60308DE2 		add	r3, sp, #96
 10003 505c 54049FE5 		ldr	r0, .L860+4
 10004 5060 FEFFFFEB 		bl	_txe_event_flags_get
 10005              	.LVL1093:
2495:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 10006              		.loc 1 2495 0
 10007 5064 0510A0E1 		mov	r1, r5
 10008 5068 0520A0E1 		mov	r2, r5
 10009 506c 98049FE5 		ldr	r0, .L860+88
 10010 5070 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 10011              	.LVL1094:
2496:../uvc.c      ****                 {
 10012              		.loc 1 2496 0
 10013 5074 005050E2 		subs	r5, r0, #0
 10014 5078 9300001A 		bne	.L850
2504:../uvc.c      ****                 {
 10015              		.loc 1 2504 0
 10016 507c 843094E5 		ldr	r3, [r4, #132]
 10017 5080 000053E3 		cmp	r3, #0
 10018 5084 2B00001A 		bne	.L806
 10019              	.LVL1095:
 10020              	.LBB500:
 10021              	.LBB501:
2219:../uvc.c      ****     {
 10022              		.loc 1 2219 0
 10023 5088 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 10024 508c 030053E3 		cmp	r3, #3
 10025 5090 6800000A 		beq	.L851
2224:../uvc.c      ****     {
 10026              		.loc 1 2224 0
 10027 5094 020053E3 		cmp	r3, #2
 10028 5098 7E00000A 		beq	.L852
 10029              	.LVL1096:
 10030              	.L813:
 10031              	.LBE501:
 10032              	.LBE500:
2520:../uvc.c      ****                     CyU3PThreadSleep(200);
 10033              		.loc 1 2520 0
 10034 509c 0130A0E3 		mov	r3, #1
2521:../uvc.c      ****                     
 10035              		.loc 1 2521 0
 10036 50a0 C800A0E3 		mov	r0, #200
2520:../uvc.c      ****                     CyU3PThreadSleep(200);
 10037              		.loc 1 2520 0
 10038 50a4 843087E5 		str	r3, [r7, #132]
2521:../uvc.c      ****                     
 10039              		.loc 1 2521 0
 10040 50a8 FEFFFFEB 		bl	_tx_thread_sleep
 10041              	.LVL1097:
 10042 50ac C3FFFFEA 		b	.L796
 10043              	.L847:
2384:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 10044              		.loc 1 2384 0
 10045 50b0 58549FE5 		ldr	r5, .L860+92
2383:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 10046              		.loc 1 2383 0
 10047 50b4 40049FE5 		ldr	r0, .L860+72
 10048 50b8 0010E0E3 		mvn	r1, #0
2368:../uvc.c      ****                 consCount = 0;
 10049              		.loc 1 2368 0
 10050 50bc BC67C4E1 		strh	r6, [r4, #124]	@ movhi
2365:../uvc.c      ****             	pb=0;
 10051              		.loc 1 2365 0
 10052 50c0 BC66C4E1 		strh	r6, [r4, #108]	@ movhi
2369:../uvc.c      ****                 hitFV     = CyFalse;
 10053              		.loc 1 2369 0
 10054 50c4 BE67C4E1 		strh	r6, [r4, #126]	@ movhi
2366:../uvc.c      ****             	pbc=0;
 10055              		.loc 1 2366 0
 10056 50c8 BE66C4E1 		strh	r6, [r4, #110]	@ movhi
2367:../uvc.c      ****                 prodCount = 0;
 10057              		.loc 1 2367 0
 10058 50cc B067C4E1 		strh	r6, [r4, #112]	@ movhi
2370:../uvc.c      **** 
 10059              		.loc 1 2370 0
 10060 50d0 786084E5 		str	r6, [r4, #120]
2383:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 10061              		.loc 1 2383 0
 10062 50d4 FEFFFFEB 		bl	_txe_mutex_get
 10063              	.LVL1098:
2384:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 10064              		.loc 1 2384 0
 10065 50d8 8134D5E5 		ldrb	r3, [r5, #1153]	@ zero_extendqisi2
 10066 50dc 013023E2 		eor	r3, r3, #1
 10067 50e0 8134C5E5 		strb	r3, [r5, #1153]
2386:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 10068              		.loc 1 2386 0
 10069 50e4 743094E5 		ldr	r3, [r4, #116]
 10070 50e8 F00053E3 		cmp	r3, #240
 10071 50ec 4500000A 		beq	.L853
 10072              	.L797:
2394:../uvc.c      **** 
 10073              		.loc 1 2394 0
 10074 50f0 743097E5 		ldr	r3, [r7, #116]
 10075 50f4 FF0053E3 		cmp	r3, #255
 10076 50f8 1D00000A 		beq	.L854
2406:../uvc.c      ****                     //CyU3PThreadSleep(400);
 10077              		.loc 1 2406 0
 10078 50fc 743094E5 		ldr	r3, [r4, #116]
 10079 5100 AA0053E3 		cmp	r3, #170
 10080 5104 2700000A 		beq	.L855
 10081              	.L798:
2434:../uvc.c      ****                 /* Reset the DMA channel. */
 10082              		.loc 1 2434 0
 10083 5108 EC039FE5 		ldr	r0, .L860+72
 10084 510c FEFFFFEB 		bl	_txe_mutex_put
 10085              	.LVL1099:
2436:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 10086              		.loc 1 2436 0
 10087 5110 F4039FE5 		ldr	r0, .L860+88
 10088 5114 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 10089              	.LVL1100:
2437:../uvc.c      ****                 {
 10090              		.loc 1 2437 0
 10091 5118 005050E2 		subs	r5, r0, #0
 10092 511c 7A00001A 		bne	.L856
2444:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 10093              		.loc 1 2444 0
 10094 5120 0510A0E1 		mov	r1, r5
 10095 5124 0520A0E1 		mov	r2, r5
 10096 5128 DC039FE5 		ldr	r0, .L860+88
 10097              	.LVL1101:
 10098 512c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 10099              	.LVL1102:
2445:../uvc.c      ****                 {
 10100              		.loc 1 2445 0
 10101 5130 005050E2 		subs	r5, r0, #0
 10102 5134 5E00001A 		bne	.L857
 10103              	.L806:
2453:../uvc.c      ****                 }
 10104              		.loc 1 2453 0
 10105 5138 C0039FE5 		ldr	r0, .L860+76
 10106              	.LVL1103:
 10107 513c 0230A0E3 		mov	r3, #2
 10108 5140 0010A0E3 		mov	r1, #0
 10109 5144 00308DE5 		str	r3, [sp]
 10110 5148 0020A0E1 		mov	r2, r0
 10111 514c 0130A0E1 		mov	r3, r1
 10112 5150 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 10113              	.LVL1104:
 10114 5154 99FFFFEA 		b	.L796
 10115              	.LVL1105:
 10116              	.L849:
2476:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 10117              		.loc 1 2476 0
 10118 5158 AC039FE5 		ldr	r0, .L860+88
 10119 515c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 10120              	.LVL1106:
2477:../uvc.c      ****                     {
 10121              		.loc 1 2477 0
 10122 5160 000050E3 		cmp	r0, #0
 10123 5164 4A00001A 		bne	.L830
2483:../uvc.c      ****                 }
 10124              		.loc 1 2483 0
 10125 5168 8300A0E3 		mov	r0, #131
 10126              	.LVL1107:
 10127 516c FEFFFFEB 		bl	CyU3PUsbFlushEp
 10128              	.LVL1108:
 10129 5170 B1FFFFEA 		b	.L808
 10130              	.L854:
2396:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 10131              		.loc 1 2396 0
 10132 5174 E530D4E5 		ldrb	r3, [r4, #229]	@ zero_extendqisi2
 10133 5178 020053E3 		cmp	r3, #2
 10134 517c 013083E2 		add	r3, r3, #1
 10135 5180 E530C4E5 		strb	r3, [r4, #229]
 10136 5184 DFFFFF9A 		bls	.L798
2397:../uvc.c      ****                 		stiflag = 0x0F;
 10137              		.loc 1 2397 0
 10138 5188 8114D5E5 		ldrb	r1, [r5, #1153]	@ zero_extendqisi2
2398:../uvc.c      ****                 		IMcount = 0;
 10139              		.loc 1 2398 0
 10140 518c 0F30A0E3 		mov	r3, #15
2397:../uvc.c      ****                 		stiflag = 0x0F;
 10141              		.loc 1 2397 0
 10142 5190 201081E3 		orr	r1, r1, #32
2399:../uvc.c      ****                 		}
 10143              		.loc 1 2399 0
 10144 5194 0020A0E3 		mov	r2, #0
2397:../uvc.c      ****                 		stiflag = 0x0F;
 10145              		.loc 1 2397 0
 10146 5198 8114C5E5 		strb	r1, [r5, #1153]
2399:../uvc.c      ****                 		}
 10147              		.loc 1 2399 0
 10148 519c E520C4E5 		strb	r2, [r4, #229]
2398:../uvc.c      ****                 		IMcount = 0;
 10149              		.loc 1 2398 0
 10150 51a0 743084E5 		str	r3, [r4, #116]
 10151 51a4 D7FFFFEA 		b	.L798
 10152              	.L855:
2412:../uvc.c      ****                 	{
 10153              		.loc 1 2412 0
 10154 51a8 E530D4E5 		ldrb	r3, [r4, #229]	@ zero_extendqisi2
 10155 51ac 020053E3 		cmp	r3, #2
 10156 51b0 013083E2 		add	r3, r3, #1
 10157 51b4 E530C4E5 		strb	r3, [r4, #229]
 10158 51b8 D2FFFF9A 		bls	.L798
2414:../uvc.c      ****                      {
 10159              		.loc 1 2414 0
 10160 51bc E420D4E5 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 10161 51c0 010052E3 		cmp	r2, #1
 10162 51c4 4600000A 		beq	.L803
 10163 51c8 020052E3 		cmp	r2, #2
 10164 51cc 0900001A 		bne	.L802
2422:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 10165              		.loc 1 2422 0
 10166 51d0 3010A0E3 		mov	r1, #48
 10167 51d4 0020A0E3 		mov	r2, #0
 10168 51d8 5230A0E3 		mov	r3, #82
 10169 51dc 0B00A0E3 		mov	r0, #11
 10170 51e0 FEFFFFEB 		bl	SensorSetIrisControl
 10171              	.LVL1109:
2424:../uvc.c      ****                  		break;
 10172              		.loc 1 2424 0
 10173 51e4 0400A0E3 		mov	r0, #4
 10174 51e8 24139FE5 		ldr	r1, .L860+96
 10175 51ec 0B20A0E3 		mov	r2, #11
 10176 51f0 0130A0E3 		mov	r3, #1
 10177 51f4 FEFFFFEB 		bl	CyU3PDebugPrint
 10178              	.LVL1110:
 10179              	.L802:
2429:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 10180              		.loc 1 2429 0
 10181 51f8 0030A0E3 		mov	r3, #0
 10182 51fc E530C7E5 		strb	r3, [r7, #229]
2431:../uvc.c      ****                 	}
 10183              		.loc 1 2431 0
 10184 5200 743087E5 		str	r3, [r7, #116]
 10185 5204 BFFFFFEA 		b	.L798
 10186              	.L853:
2386:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 10187              		.loc 1 2386 0 discriminator 1
 10188 5208 00608DE5 		str	r6, [sp]
 10189 520c A4029FE5 		ldr	r0, .L860+4
 10190 5210 8010A0E3 		mov	r1, #128
 10191 5214 0320A0E3 		mov	r2, #3
 10192 5218 60308DE2 		add	r3, sp, #96
 10193 521c FEFFFFEB 		bl	_txe_event_flags_get
 10194              	.LVL1111:
 10195 5220 000050E3 		cmp	r0, #0
 10196 5224 B1FFFF1A 		bne	.L797
2391:../uvc.c      ****                 		IMcount = 0;
 10197              		.loc 1 2391 0
 10198 5228 FF30A0E3 		mov	r3, #255
2392:../uvc.c      ****                 	}
 10199              		.loc 1 2392 0
 10200 522c E500C4E5 		strb	r0, [r4, #229]
2391:../uvc.c      ****                 		IMcount = 0;
 10201              		.loc 1 2391 0
 10202 5230 743084E5 		str	r3, [r4, #116]
2392:../uvc.c      ****                 	}
 10203              		.loc 1 2392 0
 10204 5234 B3FFFFEA 		b	.L798
 10205              	.LVL1112:
 10206              	.L851:
 10207              	.LBB504:
 10208              	.LBB502:
2221:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 10209              		.loc 1 2221 0
 10210 5238 D8129FE5 		ldr	r1, .L860+100
 10211 523c 0100A0E3 		mov	r0, #1
 10212              	.LVL1113:
 10213 5240 FEFFFFEB 		bl	CyU3PDebugPrint
 10214              	.LVL1114:
2222:../uvc.c      ****     }
 10215              		.loc 1 2222 0
 10216 5244 D0029FE5 		ldr	r0, .L860+104
 10217 5248 FEFFFFEB 		bl	CyU3PGpifLoad
 10218              	.LVL1115:
 10219 524c 0050A0E1 		mov	r5, r0
 10220              	.LVL1116:
 10221              	.L812:
2229:../uvc.c      ****     {
 10222              		.loc 1 2229 0
 10223 5250 000055E3 		cmp	r5, #0
 10224 5254 3700001A 		bne	.L858
 10225              	.LVL1117:
2241:../uvc.c      ****     {
 10226              		.loc 1 2241 0
 10227 5258 C030D7E5 		ldrb	r3, [r7, #192]	@ zero_extendqisi2
 10228 525c 023043E2 		sub	r3, r3, #2
 10229 5260 FF3003E2 		and	r3, r3, #255
 10230 5264 010053E3 		cmp	r3, #1
 10231 5268 8BFFFF8A 		bhi	.L813
2239:../uvc.c      ****     }
 10232              		.loc 1 2239 0
 10233 526c 0500A0E1 		mov	r0, r5
 10234 5270 0510A0E1 		mov	r1, r5
 10235 5274 FEFFFFEB 		bl	CyU3PGpifSMStart
 10236              	.LVL1118:
2245:../uvc.c      ****     {
 10237              		.loc 1 2245 0
 10238 5278 005050E2 		subs	r5, r0, #0
 10239 527c 86FFFF0A 		beq	.L813
2248:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10240              		.loc 1 2248 0
 10241 5280 0400A0E3 		mov	r0, #4
 10242              	.LVL1119:
 10243 5284 94129FE5 		ldr	r1, .L860+108
 10244 5288 0520A0E1 		mov	r2, r5
 10245 528c FEFFFFEB 		bl	CyU3PDebugPrint
 10246              	.LVL1120:
2249:../uvc.c      ****     }
 10247              		.loc 1 2249 0
 10248 5290 0500A0E1 		mov	r0, r5
 10249              	.LVL1121:
 10250              	.L830:
2233:../uvc.c      ****     }
 10251              		.loc 1 2233 0
 10252 5294 FEFFFFEB 		bl	CyFxAppErrorHandler
 10253              	.LVL1122:
 10254              	.L852:
2226:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 10255              		.loc 1 2226 0
 10256 5298 84129FE5 		ldr	r1, .L860+112
 10257 529c 0100A0E3 		mov	r0, #1
 10258              	.LVL1123:
 10259 52a0 FEFFFFEB 		bl	CyU3PDebugPrint
 10260              	.LVL1124:
2227:../uvc.c      ****     }
 10261              		.loc 1 2227 0
 10262 52a4 7C029FE5 		ldr	r0, .L860+116
 10263 52a8 FEFFFFEB 		bl	CyU3PGpifLoad
 10264              	.LVL1125:
 10265 52ac 0050A0E1 		mov	r5, r0
 10266              	.LVL1126:
 10267 52b0 E6FFFFEA 		b	.L812
 10268              	.LVL1127:
 10269              	.L857:
 10270              	.LBE502:
 10271              	.LBE504:
2447:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10272              		.loc 1 2447 0
 10273 52b4 0400A0E3 		mov	r0, #4
 10274              	.LVL1128:
 10275 52b8 6C129FE5 		ldr	r1, .L860+120
 10276 52bc 0520A0E1 		mov	r2, r5
 10277 52c0 FEFFFFEB 		bl	CyU3PDebugPrint
 10278              	.LVL1129:
2448:../uvc.c      ****                 }
 10279              		.loc 1 2448 0
 10280 52c4 0500A0E1 		mov	r0, r5
 10281 52c8 FEFFFFEB 		bl	CyFxAppErrorHandler
 10282              	.LVL1130:
 10283              	.L850:
2499:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10284              		.loc 1 2499 0
 10285 52cc 0400A0E3 		mov	r0, #4
 10286              	.LVL1131:
 10287 52d0 58129FE5 		ldr	r1, .L860+124
 10288 52d4 0520A0E1 		mov	r2, r5
 10289 52d8 FEFFFFEB 		bl	CyU3PDebugPrint
 10290              	.LVL1132:
2500:../uvc.c      ****                 }
 10291              		.loc 1 2500 0
 10292 52dc 0500A0E1 		mov	r0, r5
 10293 52e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 10294              	.LVL1133:
 10295              	.L803:
2417:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 10296              		.loc 1 2417 0
 10297 52e4 3010A0E3 		mov	r1, #48
 10298 52e8 5230A0E3 		mov	r3, #82
 10299 52ec 0B00A0E3 		mov	r0, #11
 10300 52f0 FEFFFFEB 		bl	SensorSetIrisControl
 10301              	.LVL1134:
2419:../uvc.c      ****                  		break;
 10302              		.loc 1 2419 0
 10303 52f4 18129FE5 		ldr	r1, .L860+96
 10304 52f8 0B20A0E3 		mov	r2, #11
 10305 52fc 0030A0E3 		mov	r3, #0
 10306 5300 0400A0E3 		mov	r0, #4
 10307 5304 FEFFFFEB 		bl	CyU3PDebugPrint
 10308              	.LVL1135:
2420:../uvc.c      ****                  	case 2: //960
 10309              		.loc 1 2420 0
 10310 5308 BAFFFFEA 		b	.L802
 10311              	.LVL1136:
 10312              	.L856:
2439:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10313              		.loc 1 2439 0
 10314 530c 0400A0E3 		mov	r0, #4
 10315              	.LVL1137:
 10316 5310 1C129FE5 		ldr	r1, .L860+128
 10317 5314 0520A0E1 		mov	r2, r5
 10318 5318 FEFFFFEB 		bl	CyU3PDebugPrint
 10319              	.LVL1138:
2440:../uvc.c      ****                 }
 10320              		.loc 1 2440 0
 10321 531c 0500A0E1 		mov	r0, r5
 10322 5320 FEFFFFEB 		bl	CyFxAppErrorHandler
 10323              	.LVL1139:
 10324              	.L831:
 10325              	.LBB505:
 10326              	.LBB492:
1728:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10327              		.loc 1 1728 0
 10328 5324 0400A0E3 		mov	r0, #4
 10329              	.LVL1140:
 10330 5328 08129FE5 		ldr	r1, .L860+132
 10331 532c FEFFFFEB 		bl	CyU3PDebugPrint
 10332              	.LVL1141:
1729:../uvc.c      ****     }
 10333              		.loc 1 1729 0
 10334 5330 0400A0E1 		mov	r0, r4
 10335 5334 FEFFFFEB 		bl	CyFxAppErrorHandler
 10336              	.LVL1142:
 10337              	.L858:
 10338              	.LBE492:
 10339              	.LBE505:
 10340              	.LBB506:
 10341              	.LBB503:
2232:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10342              		.loc 1 2232 0
 10343 5338 0400A0E3 		mov	r0, #4
 10344              	.LVL1143:
 10345 533c F8119FE5 		ldr	r1, .L860+136
 10346 5340 0520A0E1 		mov	r2, r5
 10347 5344 FEFFFFEB 		bl	CyU3PDebugPrint
 10348              	.LVL1144:
2233:../uvc.c      ****     }
 10349              		.loc 1 2233 0
 10350 5348 0500A0E1 		mov	r0, r5
 10351 534c D0FFFFEA 		b	.L830
 10352              	.LVL1145:
 10353              	.L859:
 10354              	.LBE503:
 10355              	.LBE506:
 10356              	.LBB507:
 10357              	.LBB497:
2194:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10358              		.loc 1 2194 0
 10359 5350 0600A0E1 		mov	r0, r6
 10360              	.LVL1146:
 10361              	.L828:
 10362 5354 E4119FE5 		ldr	r1, .L860+140
 10363 5358 0420A0E1 		mov	r2, r4
 10364 535c FEFFFFEB 		bl	CyU3PDebugPrint
 10365              	.LVL1147:
2195:../uvc.c      ****     }
 10366              		.loc 1 2195 0
 10367 5360 0400A0E1 		mov	r0, r4
 10368 5364 CAFFFFEA 		b	.L830
 10369              	.LVL1148:
 10370              	.L845:
2169:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10371              		.loc 1 2169 0
 10372 5368 0600A0E1 		mov	r0, r6
 10373              	.LVL1149:
 10374 536c D0119FE5 		ldr	r1, .L860+144
 10375 5370 0420A0E1 		mov	r2, r4
 10376 5374 FEFFFFEB 		bl	CyU3PDebugPrint
 10377              	.LVL1150:
2170:../uvc.c      ****     }
 10378              		.loc 1 2170 0
 10379 5378 0400A0E1 		mov	r0, r4
 10380 537c FEFFFFEB 		bl	CyFxAppErrorHandler
 10381              	.LVL1151:
 10382              	.L844:
2078:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10383              		.loc 1 2078 0
 10384 5380 0600A0E1 		mov	r0, r6
 10385              	.LVL1152:
 10386 5384 BC119FE5 		ldr	r1, .L860+148
 10387 5388 0420A0E1 		mov	r2, r4
 10388 538c FEFFFFEB 		bl	CyU3PDebugPrint
 10389              	.LVL1153:
2079:../uvc.c      ****     }
 10390              		.loc 1 2079 0
 10391 5390 0400A0E1 		mov	r0, r4
 10392 5394 FEFFFFEB 		bl	CyFxAppErrorHandler
 10393              	.LVL1154:
 10394              	.L843:
2054:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 10395              		.loc 1 2054 0
 10396 5398 0400A0E3 		mov	r0, #4
 10397 539c A8119FE5 		ldr	r1, .L860+152
 10398 53a0 FEFFFFEB 		bl	CyU3PDebugPrint
 10399              	.LVL1155:
2055:../uvc.c      ****     }
 10400              		.loc 1 2055 0
 10401 53a4 0600A0E1 		mov	r0, r6
 10402 53a8 FEFFFFEB 		bl	CyFxAppErrorHandler
 10403              	.LVL1156:
 10404              	.L842:
2047:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10405              		.loc 1 2047 0
 10406 53ac 0400A0E3 		mov	r0, #4
 10407              	.LVL1157:
 10408 53b0 98119FE5 		ldr	r1, .L860+156
 10409 53b4 0420A0E1 		mov	r2, r4
 10410 53b8 FEFFFFEB 		bl	CyU3PDebugPrint
 10411              	.LVL1158:
2048:../uvc.c      ****     }
 10412              		.loc 1 2048 0
 10413 53bc 0400A0E1 		mov	r0, r4
 10414 53c0 FEFFFFEB 		bl	CyFxAppErrorHandler
 10415              	.LVL1159:
 10416              	.L841:
1981:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10417              		.loc 1 1981 0
 10418 53c4 0400A0E3 		mov	r0, #4
 10419              	.LVL1160:
 10420 53c8 84119FE5 		ldr	r1, .L860+160
 10421 53cc 0420A0E1 		mov	r2, r4
 10422 53d0 FEFFFFEB 		bl	CyU3PDebugPrint
 10423              	.LVL1161:
1982:../uvc.c      ****     }
 10424              		.loc 1 1982 0
 10425 53d4 0400A0E1 		mov	r0, r4
 10426 53d8 FEFFFFEB 		bl	CyFxAppErrorHandler
 10427              	.LVL1162:
 10428              	.L840:
1961:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10429              		.loc 1 1961 0
 10430 53dc 0400A0E3 		mov	r0, #4
 10431              	.LVL1163:
 10432 53e0 70119FE5 		ldr	r1, .L860+164
 10433 53e4 0420A0E1 		mov	r2, r4
 10434 53e8 FEFFFFEB 		bl	CyU3PDebugPrint
 10435              	.LVL1164:
1962:../uvc.c      ****     }
 10436              		.loc 1 1962 0
 10437 53ec 0400A0E1 		mov	r0, r4
 10438 53f0 FEFFFFEB 		bl	CyFxAppErrorHandler
 10439              	.LVL1165:
 10440              	.L835:
1901:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10441              		.loc 1 1901 0
 10442 53f4 0400A0E3 		mov	r0, #4
 10443              	.LVL1166:
 10444 53f8 5C119FE5 		ldr	r1, .L860+168
 10445 53fc 0520A0E1 		mov	r2, r5
 10446 5400 FEFFFFEB 		bl	CyU3PDebugPrint
 10447              	.LVL1167:
1902:../uvc.c      ****     }
 10448              		.loc 1 1902 0
 10449 5404 0500A0E1 		mov	r0, r5
 10450 5408 FEFFFFEB 		bl	CyFxAppErrorHandler
 10451              	.LVL1168:
 10452              	.L834:
1895:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10453              		.loc 1 1895 0
 10454 540c 0400A0E3 		mov	r0, #4
 10455              	.LVL1169:
 10456 5410 48119FE5 		ldr	r1, .L860+172
 10457 5414 0520A0E1 		mov	r2, r5
 10458 5418 FEFFFFEB 		bl	CyU3PDebugPrint
 10459              	.LVL1170:
1896:../uvc.c      ****     }
 10460              		.loc 1 1896 0
 10461 541c 0500A0E1 		mov	r0, r5
 10462 5420 FEFFFFEB 		bl	CyFxAppErrorHandler
 10463              	.LVL1171:
 10464              	.L833:
1886:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10465              		.loc 1 1886 0
 10466 5424 0400A0E3 		mov	r0, #4
 10467              	.LVL1172:
 10468 5428 34119FE5 		ldr	r1, .L860+176
 10469 542c 0520A0E1 		mov	r2, r5
 10470 5430 FEFFFFEB 		bl	CyU3PDebugPrint
 10471              	.LVL1173:
1887:../uvc.c      ****     }
 10472              		.loc 1 1887 0
 10473 5434 0500A0E1 		mov	r0, r5
 10474 5438 FEFFFFEB 		bl	CyFxAppErrorHandler
 10475              	.LVL1174:
 10476              	.L832:
1864:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10477              		.loc 1 1864 0
 10478 543c 0400A0E3 		mov	r0, #4
 10479              	.LVL1175:
 10480 5440 20119FE5 		ldr	r1, .L860+180
 10481 5444 0520A0E1 		mov	r2, r5
 10482 5448 FEFFFFEB 		bl	CyU3PDebugPrint
 10483              	.LVL1176:
1865:../uvc.c      ****     }
 10484              		.loc 1 1865 0
 10485 544c 0500A0E1 		mov	r0, r5
 10486 5450 FEFFFFEB 		bl	CyFxAppErrorHandler
 10487              	.LVL1177:
 10488              	.L839:
1948:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10489              		.loc 1 1948 0
 10490 5454 0400A0E3 		mov	r0, #4
 10491              	.LVL1178:
 10492 5458 0C119FE5 		ldr	r1, .L860+184
 10493 545c 0920A0E1 		mov	r2, r9
 10494 5460 FEFFFFEB 		bl	CyU3PDebugPrint
 10495              	.LVL1179:
1949:../uvc.c      ****     }
 10496              		.loc 1 1949 0
 10497 5464 0900A0E1 		mov	r0, r9
 10498 5468 FEFFFFEB 		bl	CyFxAppErrorHandler
 10499              	.LVL1180:
 10500              	.L838:
1934:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10501              		.loc 1 1934 0
 10502 546c 0400A0E3 		mov	r0, #4
 10503              	.LVL1181:
 10504 5470 F8109FE5 		ldr	r1, .L860+188
 10505 5474 0920A0E1 		mov	r2, r9
 10506 5478 FEFFFFEB 		bl	CyU3PDebugPrint
 10507              	.LVL1182:
1935:../uvc.c      ****     }
 10508              		.loc 1 1935 0
 10509 547c 0900A0E1 		mov	r0, r9
 10510 5480 FEFFFFEB 		bl	CyFxAppErrorHandler
 10511              	.LVL1183:
 10512              	.L837:
1920:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10513              		.loc 1 1920 0
 10514 5484 0400A0E3 		mov	r0, #4
 10515              	.LVL1184:
 10516 5488 E4109FE5 		ldr	r1, .L860+192
 10517 548c 0920A0E1 		mov	r2, r9
 10518 5490 FEFFFFEB 		bl	CyU3PDebugPrint
 10519              	.LVL1185:
1921:../uvc.c      ****     }
 10520              		.loc 1 1921 0
 10521 5494 0900A0E1 		mov	r0, r9
 10522 5498 FEFFFFEB 		bl	CyFxAppErrorHandler
 10523              	.LVL1186:
 10524              	.L836:
1907:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10525              		.loc 1 1907 0
 10526 549c 0400A0E3 		mov	r0, #4
 10527              	.LVL1187:
 10528 54a0 D0109FE5 		ldr	r1, .L860+196
 10529 54a4 0520A0E1 		mov	r2, r5
 10530 54a8 FEFFFFEB 		bl	CyU3PDebugPrint
 10531              	.LVL1188:
1908:../uvc.c      ****     }
 10532              		.loc 1 1908 0
 10533 54ac 0500A0E1 		mov	r0, r5
 10534 54b0 FEFFFFEB 		bl	CyFxAppErrorHandler
 10535              	.LVL1189:
 10536              	.L861:
 10537              		.align	2
 10538              	.L860:
 10539 54b4 00C20100 		.word	115200
 10540 54b8 00000000 		.word	.LANCHOR0
 10541 54bc 00000000 		.word	CyFxGpifCB
 10542 54c0 00000000 		.word	CyFxUVCApplnUSBSetupCB
 10543 54c4 00000000 		.word	CyFxUVCApplnUSBEventCB
 10544 54c8 00000000 		.word	CyFxUSBDeviceDscr
 10545 54cc 00000000 		.word	CyFxUSBDeviceDscrSS
 10546 54d0 00000000 		.word	CyFxUSBDeviceQualDscr
 10547 54d4 00000000 		.word	CyFxUSBBOSDscr
 10548 54d8 00000000 		.word	CyFxUSBHSConfigDscr
 10549 54dc 00000000 		.word	CyFxUSBFSConfigDscr
 10550 54e0 00000000 		.word	CyFxUSBSSConfigDscr
 10551 54e4 00000000 		.word	CyFxUSBStringLangIDDscr
 10552 54e8 00000000 		.word	CyFxUSBManufactureDscr
 10553 54ec 00000000 		.word	CyFxUSBProductDscr
 10554 54f0 013F0203 		.word	50478849
 10555 54f4 00000000 		.word	glChHandleInterStat
 10556 54f8 00000000 		.word	glInterStaBuffer
 10557 54fc 00000000 		.word	imgHdMux
 10558 5500 01010000 		.word	257
 10559 5504 03030000 		.word	771
 10560 5508 00000000 		.word	CyFxUvcApplnDmaCallback
 10561 550c 00000000 		.word	glChHandleUVCStream
 10562 5510 00000000 		.word	.LANCHOR1
 10563 5514 180A0000 		.word	.LC58
 10564 5518 D00A0000 		.word	.LC62
 10565 551c 20000000 		.word	.LANCHOR2+32
 10566 5520 280B0000 		.word	.LC65
 10567 5524 E00A0000 		.word	.LC63
 10568 5528 3C000000 		.word	.LANCHOR2+60
 10569 552c 680A0000 		.word	.LC60
 10570 5530 9C0A0000 		.word	.LC61
 10571 5534 3C0A0000 		.word	.LC59
 10572 5538 24070000 		.word	.LC42
 10573 553c F00A0000 		.word	.LC64
 10574 5540 14090000 		.word	.LC53
 10575 5544 F0090000 		.word	.LC57
 10576 5548 C0090000 		.word	.LC56
 10577 554c 88090000 		.word	.LC55
 10578 5550 48090000 		.word	.LC54
 10579 5554 E4080000 		.word	.LC52
 10580 5558 B4080000 		.word	.LC51
 10581 555c BC070000 		.word	.LC46
 10582 5560 94070000 		.word	.LC45
 10583 5564 70070000 		.word	.LC44
 10584 5568 44070000 		.word	.LC43
 10585 556c 7C080000 		.word	.LC50
 10586 5570 48080000 		.word	.LC49
 10587 5574 14080000 		.word	.LC48
 10588 5578 E8070000 		.word	.LC47
 10589              	.LBE497:
 10590              	.LBE507:
 10591              		.cfi_endproc
 10592              	.LFE18:
 10594              		.align	2
 10595              		.global	CyFxApplicationDefine
 10597              	CyFxApplicationDefine:
 10598              	.LFB26:
3819:../uvc.c      **** }
3820:../uvc.c      **** 
3821:../uvc.c      **** 
3822:../uvc.c      **** /*
3823:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3824:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3825:../uvc.c      ****  */
3826:../uvc.c      **** void
3827:../uvc.c      **** CyFxApplicationDefine (
3828:../uvc.c      ****         void)
3829:../uvc.c      **** {
 10599              		.loc 1 3829 0
 10600              		.cfi_startproc
 10601              		@ args = 0, pretend = 0, frame = 40
 10602              		@ frame_needed = 0, uses_anonymous_args = 0
 10603              	.LVL1190:
 10604 557c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 10605              	.LCFI27:
 10606              		.cfi_def_cfa_offset 36
 10607              		.cfi_offset 4, -36
 10608              		.cfi_offset 5, -32
 10609              		.cfi_offset 6, -28
 10610              		.cfi_offset 7, -24
 10611              		.cfi_offset 8, -20
 10612              		.cfi_offset 9, -16
 10613              		.cfi_offset 10, -12
 10614              		.cfi_offset 11, -8
 10615              		.cfi_offset 14, -4
3830:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3831:../uvc.c      ****     uint32_t retThrdCreate;
3832:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3833:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3834:../uvc.c      **** 
3835:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3836:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10616              		.loc 1 3836 0
 10617 5580 010AA0E3 		mov	r0, #4096
3829:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 10618              		.loc 1 3829 0
 10619 5584 4CD04DE2 		sub	sp, sp, #76
 10620              	.LCFI28:
 10621              		.cfi_def_cfa_offset 112
 10622              		.loc 1 3836 0
 10623 5588 FEFFFFEB 		bl	CyU3PMemAlloc
 10624              	.LVL1191:
 10625 558c 00A0A0E1 		mov	r10, r0
 10626              	.LVL1192:
3837:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10627              		.loc 1 3837 0
 10628 5590 010AA0E3 		mov	r0, #4096
 10629              	.LVL1193:
 10630 5594 FEFFFFEB 		bl	CyU3PMemAlloc
 10631              	.LVL1194:
 10632 5598 0090A0E1 		mov	r9, r0
 10633              	.LVL1195:
3838:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10634              		.loc 1 3838 0
 10635 559c 010AA0E3 		mov	r0, #4096
 10636              	.LVL1196:
 10637 55a0 FEFFFFEB 		bl	CyU3PMemAlloc
 10638              	.LVL1197:
3839:../uvc.c      **** 
3840:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 10639              		.loc 1 3840 0
 10640 55a4 000059E3 		cmp	r9, #0
 10641 55a8 00005A13 		cmpne	r10, #0
 10642 55ac 00C0A013 		movne	ip, #0
 10643 55b0 01C0A003 		moveq	ip, #1
3838:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10644              		.loc 1 3838 0
 10645 55b4 00B0A0E1 		mov	fp, r0
 10646              	.LVL1198:
 10647              		.loc 1 3840 0
 10648 55b8 0000001A 		bne	.L873
 10649              	.LVL1199:
 10650              	.L863:
 10651              	.L865:
 10652 55bc FEFFFFEA 		b	.L865
 10653              	.LVL1200:
 10654              	.L873:
 10655              		.loc 1 3840 0 is_stmt 0 discriminator 1
 10656 55c0 000050E3 		cmp	r0, #0
 10657 55c4 FCFFFF0A 		beq	.L863
3841:../uvc.c      ****         goto fatalErrorHandler;
3842:../uvc.c      **** 
3843:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3844:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 10658              		.loc 1 3844 0 is_stmt 1
 10659 55c8 28008DE2 		add	r0, sp, #40
 10660              	.LVL1201:
 10661 55cc 4010A0E3 		mov	r1, #64
 10662 55d0 0C219FE5 		ldr	r2, .L874
 10663 55d4 28708DE2 		add	r7, sp, #40
 10664 55d8 24C08DE5 		str	ip, [sp, #36]
 10665 55dc FEFFFFEB 		bl	cmdbufCreate
 10666              	.LVL1202:
 10667 55e0 0F00B7E8 		ldmia	r7!, {r0, r1, r2, r3}
 10668 55e4 FC509FE5 		ldr	r5, .L874+4
3845:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10669              		.loc 1 3845 0
 10670 55e8 FC409FE5 		ldr	r4, .L874+8
3844:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10671              		.loc 1 3844 0
 10672 55ec 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 10673 55f0 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
3846:../uvc.c      **** 
3847:../uvc.c      **** 	/****** initialize command descriptor ***********/
3848:../uvc.c      **** 	cmdquInit(cmdQuptr);
3849:../uvc.c      **** 	cmdquInit(statQuptr);
3850:../uvc.c      **** 
3851:../uvc.c      ****     /* Create the UVC application thread. */
3852:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 10674              		.loc 1 3852 0
 10675 55f4 0860A0E3 		mov	r6, #8
3844:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10676              		.loc 1 3844 0
 10677 55f8 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
3845:../uvc.c      **** 
 10678              		.loc 1 3845 0
 10679 55fc EC209FE5 		ldr	r2, .L874+12
 10680 5600 28008DE2 		add	r0, sp, #40
 10681 5604 2010A0E3 		mov	r1, #32
 10682 5608 FEFFFFEB 		bl	cmdbufCreate
 10683              	.LVL1203:
 10684 560c 28E08DE2 		add	lr, sp, #40
 10685 5610 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 10686              		.loc 1 3852 0
 10687 5614 0180A0E3 		mov	r8, #1
3845:../uvc.c      **** 
 10688              		.loc 1 3845 0
 10689 5618 0F00A4E8 		stmia	r4!, {r0, r1, r2, r3}
 10690 561c 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
 10691              		.loc 1 3852 0
 10692 5620 A870A0E3 		mov	r7, #168
3845:../uvc.c      **** 
 10693              		.loc 1 3845 0
 10694 5624 0F0084E8 		stmia	r4, {r0, r1, r2, r3}
3848:../uvc.c      **** 	cmdquInit(statQuptr);
 10695              		.loc 1 3848 0
 10696 5628 100045E2 		sub	r0, r5, #16
 10697 562c FEFFFFEB 		bl	cmdquInit
 10698              	.LVL1204:
3849:../uvc.c      **** 
 10699              		.loc 1 3849 0
 10700 5630 100044E2 		sub	r0, r4, #16
 10701 5634 FEFFFFEB 		bl	cmdquInit
 10702              	.LVL1205:
 10703              		.loc 1 3852 0
 10704 5638 24C09DE5 		ldr	ip, [sp, #36]
 10705 563c 012AA0E3 		mov	r2, #4096
 10706 5640 0C30A0E1 		mov	r3, ip
 10707 5644 44008DE9 		stmib	sp, {r2, r6}
 10708 5648 A4009FE5 		ldr	r0, .L874+16
 10709 564c 00A08DE5 		str	r10, [sp]
 10710 5650 10C08DE5 		str	ip, [sp, #16]
 10711 5654 0C608DE5 		str	r6, [sp, #12]
 10712 5658 14808DE5 		str	r8, [sp, #20]
 10713 565c 18708DE5 		str	r7, [sp, #24]
 10714 5660 90109FE5 		ldr	r1, .L874+20
 10715 5664 90209FE5 		ldr	r2, .L874+24
 10716 5668 FEFFFFEB 		bl	_txe_thread_create
 10717              	.LVL1206:
3853:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3854:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3855:../uvc.c      ****             0,                                          /* No input parameter to thread */
3856:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3857:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3858:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3859:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3860:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3861:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3862:../uvc.c      ****             );
3863:../uvc.c      ****     if (retThrdCreate != 0)
 10718              		.loc 1 3863 0
 10719 566c 003050E2 		subs	r3, r0, #0
 10720 5670 D1FFFF1A 		bne	.L863
3864:../uvc.c      ****     {
3865:../uvc.c      ****         goto fatalErrorHandler;
3866:../uvc.c      ****     }
3867:../uvc.c      **** 
3868:../uvc.c      ****     /* Create the control request handling thread. */
3869:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 10721              		.loc 1 3869 0
 10722 5674 024BA0E3 		mov	r4, #2048
 10723 5678 10308DE5 		str	r3, [sp, #16]
 10724 567c 00908DE5 		str	r9, [sp]
 10725 5680 08608DE5 		str	r6, [sp, #8]
 10726 5684 0C608DE5 		str	r6, [sp, #12]
 10727 5688 14808DE5 		str	r8, [sp, #20]
 10728 568c 18708DE5 		str	r7, [sp, #24]
 10729 5690 04408DE5 		str	r4, [sp, #4]
 10730 5694 64009FE5 		ldr	r0, .L874+28
 10731              	.LVL1207:
 10732 5698 64109FE5 		ldr	r1, .L874+32
 10733 569c 64209FE5 		ldr	r2, .L874+36
 10734 56a0 FEFFFFEB 		bl	_txe_thread_create
 10735              	.LVL1208:
3870:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3871:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3872:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3873:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3874:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3875:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3876:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3877:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3878:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3879:../uvc.c      ****             );
3880:../uvc.c      ****     if (retThrdCreate != 0)
 10736              		.loc 1 3880 0
 10737 56a4 003050E2 		subs	r3, r0, #0
 10738 56a8 C3FFFF1A 		bne	.L863
3881:../uvc.c      ****     {
3882:../uvc.c      ****         goto fatalErrorHandler;
3883:../uvc.c      ****     }
3884:../uvc.c      **** #if 1
3885:../uvc.c      ****     /* Create the I2C control command handling thread. */
3886:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 10739              		.loc 1 3886 0
 10740 56ac 00B08DE5 		str	fp, [sp]
 10741 56b0 50008DE9 		stmib	sp, {r4, r6}
 10742 56b4 50009FE5 		ldr	r0, .L874+40
 10743              	.LVL1209:
 10744 56b8 0C608DE5 		str	r6, [sp, #12]
 10745 56bc 10308DE5 		str	r3, [sp, #16]
 10746 56c0 14808DE5 		str	r8, [sp, #20]
 10747 56c4 18708DE5 		str	r7, [sp, #24]
 10748 56c8 40109FE5 		ldr	r1, .L874+44
 10749 56cc 40209FE5 		ldr	r2, .L874+48
 10750 56d0 FEFFFFEB 		bl	_txe_thread_create
 10751              	.LVL1210:
3887:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3888:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3889:../uvc.c      ****             0,                                          /* No input parameter to thread */
3890:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3891:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3892:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3893:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3894:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3895:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3896:../uvc.c      ****             );
3897:../uvc.c      ****     if (retThrdCreate != 0)
 10752              		.loc 1 3897 0
 10753 56d4 000050E3 		cmp	r0, #0
 10754 56d8 B7FFFF1A 		bne	.L863
3898:../uvc.c      ****     {
3899:../uvc.c      ****         goto fatalErrorHandler;
3900:../uvc.c      ****     }
3901:../uvc.c      **** #endif
3902:../uvc.c      **** 
3903:../uvc.c      ****     return;
3904:../uvc.c      **** 
3905:../uvc.c      **** fatalErrorHandler:
3906:../uvc.c      ****     /* Add custom recovery or debug actions here */
3907:../uvc.c      ****     /* Loop indefinitely */
3908:../uvc.c      ****     while (1);
3909:../uvc.c      **** }
 10755              		.loc 1 3909 0
 10756 56dc 4CD08DE2 		add	sp, sp, #76
 10757              		@ sp needed
 10758 56e0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 10759              	.LVL1211:
 10760              	.L875:
 10761              		.align	2
 10762              	.L874:
 10763 56e4 00000000 		.word	cmdQuMux
 10764 56e8 00000000 		.word	cmdQu
 10765 56ec 00000000 		.word	statQu
 10766 56f0 00000000 		.word	staQuMux
 10767 56f4 E8000000 		.word	.LANCHOR0+232
 10768 56f8 600B0000 		.word	.LC66
 10769 56fc 00000000 		.word	UVCAppThread_Entry
 10770 5700 90010000 		.word	.LANCHOR0+400
 10771 5704 740B0000 		.word	.LC67
 10772 5708 00000000 		.word	UVCAppEP0Thread_Entry
 10773 570c 38020000 		.word	.LANCHOR0+568
 10774 5710 8C0B0000 		.word	.LC68
 10775 5714 00000000 		.word	I2cAppThread_Entry
 10776              		.cfi_endproc
 10777              	.LFE26:
 10779              		.section	.text.startup,"ax",%progbits
 10780              		.align	2
 10781              		.global	main
 10783              	main:
 10784              	.LFB27:
3910:../uvc.c      **** 
3911:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3912:../uvc.c      ****  * the ThreadX RTOS here.
3913:../uvc.c      ****  */
3914:../uvc.c      **** int
3915:../uvc.c      **** main (
3916:../uvc.c      ****         void)
3917:../uvc.c      **** {
 10785              		.loc 1 3917 0
 10786              		.cfi_startproc
 10787              		@ args = 0, pretend = 0, frame = 56
 10788              		@ frame_needed = 0, uses_anonymous_args = 0
 10789 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 10790              	.LCFI29:
 10791              		.cfi_def_cfa_offset 12
 10792              		.cfi_offset 4, -12
 10793              		.cfi_offset 5, -8
 10794              		.cfi_offset 14, -4
 10795 0004 3CD04DE2 		sub	sp, sp, #60
 10796              	.LCFI30:
 10797              		.cfi_def_cfa_offset 72
3918:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3919:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3920:../uvc.c      **** 
3921:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3922:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3923:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10798              		.loc 1 3923 0
 10799 0008 0230A0E3 		mov	r3, #2
3924:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3925:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3926:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 10800              		.loc 1 3926 0
 10801 000c 0010A0E3 		mov	r1, #0
3927:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 10802              		.loc 1 3927 0
 10803 0010 0320A0E3 		mov	r2, #3
3922:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10804              		.loc 1 3922 0
 10805 0014 0150A0E3 		mov	r5, #1
3928:../uvc.c      **** 
3929:../uvc.c      ****     /* Initialize the device */
3930:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 10806              		.loc 1 3930 0
 10807 0018 0D00A0E1 		mov	r0, sp
3922:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10808              		.loc 1 3922 0
 10809 001c 00508DE5 		str	r5, [sp]
3923:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 10810              		.loc 1 3923 0
 10811 0020 0430CDE5 		strb	r3, [sp, #4]
3924:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 10812              		.loc 1 3924 0
 10813 0024 0530CDE5 		strb	r3, [sp, #5]
3925:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 10814              		.loc 1 3925 0
 10815 0028 0630CDE5 		strb	r3, [sp, #6]
3926:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 10816              		.loc 1 3926 0
 10817 002c 08108DE5 		str	r1, [sp, #8]
3927:../uvc.c      **** 
 10818              		.loc 1 3927 0
 10819 0030 0C20CDE5 		strb	r2, [sp, #12]
 10820              		.loc 1 3930 0
 10821 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 10822              	.LVL1212:
3931:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10823              		.loc 1 3931 0
 10824 0038 004050E2 		subs	r4, r0, #0
 10825 003c 0000000A 		beq	.L881
 10826              	.L877:
 10827              	.L878:
 10828 0040 FEFFFFEA 		b	.L878
 10829              	.L881:
3932:../uvc.c      ****     {
3933:../uvc.c      ****         goto handle_fatal_error;
3934:../uvc.c      ****     }
3935:../uvc.c      **** 
3936:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3937:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 10830              		.loc 1 3937 0
 10831 0044 0410A0E1 		mov	r1, r4
 10832 0048 0420A0E1 		mov	r2, r4
 10833 004c 0500A0E1 		mov	r0, r5
 10834              	.LVL1213:
 10835 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 10836              	.LVL1214:
3938:../uvc.c      **** 
3939:../uvc.c      ****     /* Configure the IO matrix for the device. */
3940:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3941:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3942:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3943:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3944:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3945:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3946:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3947:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3948:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3949:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3950:../uvc.c      **** 
3951:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 10837              		.loc 1 3951 0
 10838 0054 10008DE2 		add	r0, sp, #16
3941:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 10839              		.loc 1 3941 0
 10840 0058 2640CDE5 		strb	r4, [sp, #38]
3942:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 10841              		.loc 1 3942 0
 10842 005c 28408DE5 		str	r4, [sp, #40]
3943:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 10843              		.loc 1 3943 0
 10844 0060 2C408DE5 		str	r4, [sp, #44]
3944:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 10845              		.loc 1 3944 0
 10846 0064 30408DE5 		str	r4, [sp, #48]
3945:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 10847              		.loc 1 3945 0
 10848 0068 34408DE5 		str	r4, [sp, #52]
3948:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 10849              		.loc 1 3948 0
 10850 006c 1C408DE5 		str	r4, [sp, #28]
3949:../uvc.c      **** 
 10851              		.loc 1 3949 0
 10852 0070 20408DE5 		str	r4, [sp, #32]
3940:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 10853              		.loc 1 3940 0
 10854 0074 10508DE5 		str	r5, [sp, #16]
3946:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 10855              		.loc 1 3946 0
 10856 0078 14508DE5 		str	r5, [sp, #20]
3947:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 10857              		.loc 1 3947 0
 10858 007c 18508DE5 		str	r5, [sp, #24]
 10859              		.loc 1 3951 0
 10860 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 10861              	.LVL1215:
3952:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10862              		.loc 1 3952 0
 10863 0084 004050E2 		subs	r4, r0, #0
 10864 0088 ECFFFF1A 		bne	.L877
3953:../uvc.c      ****     {
3954:../uvc.c      ****         goto handle_fatal_error;
3955:../uvc.c      ****     }
3956:../uvc.c      **** 
3957:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3958:../uvc.c      ****     CyU3PKernelEntry ();
 10865              		.loc 1 3958 0
 10866 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 10867              	.LVL1216:
3959:../uvc.c      **** 
3960:../uvc.c      ****     /* Dummy return to make the compiler happy */
3961:../uvc.c      ****     return 0;
3962:../uvc.c      **** 
3963:../uvc.c      **** handle_fatal_error:
3964:../uvc.c      ****     /* Cannot recover from this error. */
3965:../uvc.c      ****     while (1);
3966:../uvc.c      **** }
 10868              		.loc 1 3966 0
 10869 0090 0400A0E1 		mov	r0, r4
 10870 0094 3CD08DE2 		add	sp, sp, #60
 10871              		@ sp needed
 10872 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 10873              		.cfi_endproc
 10874              	.LFE27:
 10876              		.comm	I2CCmdTimer,44,4
 10877              		.comm	posTick,4,4
 10878              		.global	glUVCHeader
 10879              		.global	glProbeStilCtrl20
 10880              		.global	glProbeCtrl20
 10881              		.global	glProbeStilCtrl
 10882              		.global	glProbeCtrl
 10883              		.global	streamingStarted
 10884              		.global	clearFeatureRqtReceived
 10885              		.global	usbSpeed
 10886              		.global	isUsbConnected
 10887              		.global	pbcpbak
 10888              		.global	pbcbak
 10889              		.global	pbbak
 10890              		.global	fbbak
 10891              		.global	pbc
 10892              		.global	pb
 10893              		.global	fb
 10894              		.comm	wLength,2,2
 10895              		.comm	wIndex,2,2
 10896              		.comm	wValue,2,2
 10897              		.comm	bRequest,1,1
 10898              		.comm	bmReqType,1,1
 10899              		.comm	imgHdMux,56,4
 10900              		.comm	timMux,56,4
 10901              		.comm	staQuMux,56,4
 10902              		.comm	cmdQuMux,56,4
 10903              		.comm	statQu,32,4
 10904              		.comm	cmdQu,32,4
 10905              		.global	testSnap
 10906              		.global	snapButFlag
 10907              		.comm	glInterStaBuffer,4,4
 10908              		.comm	glChHandleInterStat,172,4
 10909              		.comm	glChHandleStillStream,232,4
 10910              		.comm	glChHandleUVCStream,232,4
 10911              		.global	CyFxGpifConfig_usb2
 10912              		.global	CyFxGpifRegValue_usb2
 10913              		.global	CyFxGpifWavedataPosition_usb2
 10914              		.global	CyFxGpifWavedata_usb2
 10915              		.global	CyFxGpifTransition_usb2
 10916              		.global	CyFxGpifConfig
 10917              		.global	CyFxGpifRegValue
 10918              		.global	CyFxGpifWavedataPosition
 10919              		.global	CyFxGpifWavedata
 10920              		.global	CyFxGpifTransition
 10921              		.section	.rodata
 10922              		.align	2
 10923              		.set	.LANCHOR2,. + 0
 10926              	ExTime:
 10927 0000 9C       		.byte	-100
 10928 0001 00       		.byte	0
 10929 0002 4E       		.byte	78
 10930 0003 00       		.byte	0
 10931 0004 27       		.byte	39
 10932 0005 00       		.byte	0
 10933 0006 14       		.byte	20
 10934 0007 00       		.byte	0
 10935 0008 0A       		.byte	10
 10936 0009 00       		.byte	0
 10937 000a 05       		.byte	5
 10938 000b 00       		.byte	0
 10939 000c 02       		.byte	2
 10940 000d 00       		.byte	0
 10941 000e 01       		.byte	1
 10942 000f 00       		.byte	0
 10945              	ShutValueArry:
 10946 0010 C800     		.short	200
 10947 0012 6400     		.short	100
 10948 0014 2700     		.short	39
 10949 0016 1400     		.short	20
 10950 0018 0A00     		.short	10
 10951 001a 0500     		.short	5
 10952 001c 0200     		.short	2
 10953 001e 0100     		.short	1
 10956              	CyFxGpifConfig:
 10957 0020 0F00     		.short	15
 10958 0022 0000     		.space	2
 10959 0024 00000000 		.word	CyFxGpifWavedata
 10960 0028 00000000 		.word	CyFxGpifWavedataPosition
 10961 002c 0500     		.short	5
 10962 002e 0000     		.space	2
 10963 0030 00000000 		.word	CyFxGpifTransition
 10964 0034 4C00     		.short	76
 10965 0036 0000     		.space	2
 10966 0038 00000000 		.word	CyFxGpifRegValue
 10969              	CyFxGpifConfig_usb2:
 10970 003c 9300     		.short	147
 10971 003e 0000     		.space	2
 10972 0040 00000000 		.word	CyFxGpifWavedata_usb2
 10973 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 10974 0048 0800     		.short	8
 10975 004a 0000     		.space	2
 10976 004c 00000000 		.word	CyFxGpifTransition_usb2
 10977 0050 4C00     		.short	76
 10978 0052 0000     		.space	2
 10979 0054 00000000 		.word	CyFxGpifRegValue_usb2
 10980              		.data
 10981              		.align	2
 10982              		.set	.LANCHOR1,. + 0
 10985              	ExUCtrlParArry:
 10986 0000 00       		.byte	0
 10987 0001 00       		.byte	0
 10988 0002 04       		.byte	4
 10989 0003 01       		.byte	1
 10990 0004 00       		.byte	0
 10991 0005 38       		.byte	56
 10992 0006 01       		.byte	1
 10993 0007 01       		.byte	1
 10994 0008 00       		.byte	0
 10995 0009 03       		.byte	3
 10996 000a 00       		.byte	0
 10997 000b 4E       		.byte	78
 10998 000c 00       		.byte	0
 10999 000d 4E       		.byte	78
 11000 000e 00       		.byte	0
 11001 000f 30       		.byte	48
 11002 0010 01       		.byte	1
 11003 0011 00       		.byte	0
 11004 0012 00       		.byte	0
 11005 0013 00000000 		.space	5
 11005      00
 11006 0018 00       		.byte	0
 11007 0019 00       		.byte	0
 11008 001a 01       		.byte	1
 11009 001b 00       		.byte	0
 11010 001c 00       		.byte	0
 11011 001d 00       		.byte	0
 11012 001e 00       		.byte	0
 11013 001f 01       		.byte	1
 11014 0020 00       		.byte	0
 11015 0021 03       		.byte	3
 11016 0022 00       		.byte	0
 11017 0023 00       		.byte	0
 11018 0024 00       		.byte	0
 11019 0025 00       		.byte	0
 11020 0026 00       		.byte	0
 11021 0027 30       		.byte	48
 11022 0028 01       		.byte	1
 11023 0029 00       		.byte	0
 11024 002a 00       		.byte	0
 11025 002b 00000000 		.space	5
 11025      00
 11026 0030 00       		.byte	0
 11027 0031 00       		.byte	0
 11028 0032 02       		.byte	2
 11029 0033 00       		.byte	0
 11030 0034 00       		.byte	0
 11031 0035 FF       		.byte	-1
 11032 0036 00       		.byte	0
 11033 0037 01       		.byte	1
 11034 0038 00       		.byte	0
 11035 0039 03       		.byte	3
 11036 003a 00       		.byte	0
 11037 003b 01       		.byte	1
 11038 003c 00       		.byte	0
 11039 003d 00       		.byte	0
 11040 003e 00       		.byte	0
 11041 003f 30       		.byte	48
 11042 0040 01       		.byte	1
 11043 0041 01       		.byte	1
 11044 0042 00       		.byte	0
 11045 0043 00000000 		.space	5
 11045      00
 11046 0048 00       		.byte	0
 11047 0049 00       		.byte	0
 11048 004a 02       		.byte	2
 11049 004b 00       		.byte	0
 11050 004c 00       		.byte	0
 11051 004d 00       		.byte	0
 11052 004e 00       		.byte	0
 11053 004f 00       		.byte	0
 11054 0050 00       		.byte	0
 11055 0051 03       		.byte	3
 11056 0052 00       		.byte	0
 11057 0053 00       		.byte	0
 11058 0054 00       		.byte	0
 11059 0055 00       		.byte	0
 11060 0056 00       		.byte	0
 11061 0057 30       		.byte	48
 11062 0058 01       		.byte	1
 11063 0059 01       		.byte	1
 11064 005a 00       		.byte	0
 11065 005b 00000000 		.space	5
 11065      00
 11066 0060 13       		.byte	19
 11067 0061 14       		.byte	20
 11068 0062 02       		.byte	2
 11069 0063 01       		.byte	1
 11070 0064 00       		.byte	0
 11071 0065 03       		.byte	3
 11072 0066 00       		.byte	0
 11073 0067 01       		.byte	1
 11074 0068 00       		.byte	0
 11075 0069 03       		.byte	3
 11076 006a 00       		.byte	0
 11077 006b 23       		.byte	35
 11078 006c 37       		.byte	55
 11079 006d 23       		.byte	35
 11080 006e 37       		.byte	55
 11081 006f 30       		.byte	48
 11082 0070 01       		.byte	1
 11083 0071 00       		.byte	0
 11084 0072 00       		.byte	0
 11085 0073 00000000 		.space	5
 11085      00
 11086 0078 11       		.byte	17
 11087 0079 00       		.byte	0
 11088 007a 02       		.byte	2
 11089 007b 01       		.byte	1
 11090 007c 00       		.byte	0
 11091 007d 03       		.byte	3
 11092 007e 00       		.byte	0
 11093 007f 01       		.byte	1
 11094 0080 00       		.byte	0
 11095 0081 03       		.byte	3
 11096 0082 00       		.byte	0
 11097 0083 01       		.byte	1
 11098 0084 00       		.byte	0
 11099 0085 01       		.byte	1
 11100 0086 00       		.byte	0
 11101 0087 30       		.byte	48
 11102 0088 01       		.byte	1
 11103 0089 01       		.byte	1
 11104 008a 00       		.byte	0
 11105 008b 00000000 		.space	5
 11105      00
 11106 0090 17       		.byte	23
 11107 0091 00       		.byte	0
 11108 0092 01       		.byte	1
 11109 0093 01       		.byte	1
 11110 0094 00       		.byte	0
 11111 0095 02       		.byte	2
 11112 0096 00       		.byte	0
 11113 0097 01       		.byte	1
 11114 0098 00       		.byte	0
 11115 0099 03       		.byte	3
 11116 009a 00       		.byte	0
 11117 009b 00       		.byte	0
 11118 009c 00       		.byte	0
 11119 009d 00       		.byte	0
 11120 009e 00       		.byte	0
 11121 009f 30       		.byte	48
 11122 00a0 01       		.byte	1
 11123 00a1 01       		.byte	1
 11124 00a2 00       		.byte	0
 11125 00a3 00000000 		.space	5
 11125      00
 11126 00a8 00       		.byte	0
 11127 00a9 00       		.byte	0
 11128 00aa 04       		.byte	4
 11129 00ab 01       		.byte	1
 11130 00ac 00       		.byte	0
 11131 00ad 38       		.byte	56
 11132 00ae 01       		.byte	1
 11133 00af 01       		.byte	1
 11134 00b0 00       		.byte	0
 11135 00b1 03       		.byte	3
 11136 00b2 00       		.byte	0
 11137 00b3 4E       		.byte	78
 11138 00b4 00       		.byte	0
 11139 00b5 4E       		.byte	78
 11140 00b6 00       		.byte	0
 11141 00b7 30       		.byte	48
 11142 00b8 01       		.byte	1
 11143 00b9 00       		.byte	0
 11144 00ba 00       		.byte	0
 11145 00bb 00000000 		.space	5
 11145      00
 11146 00c0 00       		.byte	0
 11147 00c1 00       		.byte	0
 11148 00c2 01       		.byte	1
 11149 00c3 00       		.byte	0
 11150 00c4 00       		.byte	0
 11151 00c5 00       		.byte	0
 11152 00c6 00       		.byte	0
 11153 00c7 01       		.byte	1
 11154 00c8 00       		.byte	0
 11155 00c9 03       		.byte	3
 11156 00ca 00       		.byte	0
 11157 00cb 00       		.byte	0
 11158 00cc 00       		.byte	0
 11159 00cd 00       		.byte	0
 11160 00ce 00       		.byte	0
 11161 00cf 30       		.byte	48
 11162 00d0 01       		.byte	1
 11163 00d1 00       		.byte	0
 11164 00d2 00       		.byte	0
 11165 00d3 00000000 		.space	5
 11165      00
 11166 00d8 00       		.byte	0
 11167 00d9 00       		.byte	0
 11168 00da 02       		.byte	2
 11169 00db 00       		.byte	0
 11170 00dc 00       		.byte	0
 11171 00dd 05       		.byte	5
 11172 00de 00       		.byte	0
 11173 00df 01       		.byte	1
 11174 00e0 00       		.byte	0
 11175 00e1 03       		.byte	3
 11176 00e2 00       		.byte	0
 11177 00e3 00       		.byte	0
 11178 00e4 00       		.byte	0
 11179 00e5 00       		.byte	0
 11180 00e6 00       		.byte	0
 11181 00e7 30       		.byte	48
 11182 00e8 01       		.byte	1
 11183 00e9 00       		.byte	0
 11184 00ea 00       		.byte	0
 11185 00eb 00000000 		.space	5
 11185      00
 11186 00f0 00       		.byte	0
 11187 00f1 00       		.byte	0
 11188 00f2 03       		.byte	3
 11189 00f3 00       		.byte	0
 11190 00f4 00       		.byte	0
 11191 00f5 0A       		.byte	10
 11192 00f6 00       		.byte	0
 11193 00f7 01       		.byte	1
 11194 00f8 00       		.byte	0
 11195 00f9 03       		.byte	3
 11196 00fa 00       		.byte	0
 11197 00fb 00       		.byte	0
 11198 00fc 00       		.byte	0
 11199 00fd 00       		.byte	0
 11200 00fe 00       		.byte	0
 11201 00ff 30       		.byte	48
 11202 0100 01       		.byte	1
 11203 0101 00       		.byte	0
 11204 0102 00       		.byte	0
 11205 0103 00000000 		.space	5
 11205      00
 11206 0108 00       		.byte	0
 11207 0109 00       		.byte	0
 11208 010a 02       		.byte	2
 11209 010b 00       		.byte	0
 11210 010c 00       		.byte	0
 11211 010d 40       		.byte	64
 11212 010e 00       		.byte	0
 11213 010f 01       		.byte	1
 11214 0110 00       		.byte	0
 11215 0111 03       		.byte	3
 11216 0112 00       		.byte	0
 11217 0113 0F       		.byte	15
 11218 0114 11       		.byte	17
 11219 0115 00       		.byte	0
 11220 0116 00       		.byte	0
 11221 0117 30       		.byte	48
 11222 0118 01       		.byte	1
 11223 0119 00       		.byte	0
 11224 011a 00       		.byte	0
 11225 011b 00000000 		.space	5
 11225      00
 11226 0120 00       		.byte	0
 11227 0121 00       		.byte	0
 11228 0122 02       		.byte	2
 11229 0123 00       		.byte	0
 11230 0124 00       		.byte	0
 11231 0125 64       		.byte	100
 11232 0126 00       		.byte	0
 11233 0127 01       		.byte	1
 11234 0128 00       		.byte	0
 11235 0129 03       		.byte	3
 11236 012a 00       		.byte	0
 11237 012b 00       		.byte	0
 11238 012c 00       		.byte	0
 11239 012d 00       		.byte	0
 11240 012e 00       		.byte	0
 11241 012f 30       		.byte	48
 11242 0130 01       		.byte	1
 11243 0131 00       		.byte	0
 11244 0132 00       		.byte	0
 11245 0133 00000000 		.space	5
 11245      00
 11246 0138 00       		.byte	0
 11247 0139 00       		.byte	0
 11248 013a 02       		.byte	2
 11249 013b 00       		.byte	0
 11250 013c 00       		.byte	0
 11251 013d 64       		.byte	100
 11252 013e 00       		.byte	0
 11253 013f 01       		.byte	1
 11254 0140 00       		.byte	0
 11255 0141 03       		.byte	3
 11256 0142 00       		.byte	0
 11257 0143 00       		.byte	0
 11258 0144 00       		.byte	0
 11259 0145 00       		.byte	0
 11260 0146 00       		.byte	0
 11261 0147 30       		.byte	48
 11262 0148 01       		.byte	1
 11263 0149 00       		.byte	0
 11264 014a 00       		.byte	0
 11265 014b 00000000 		.space	5
 11265      00
 11266 0150 00       		.byte	0
 11267 0151 00       		.byte	0
 11268 0152 02       		.byte	2
 11269 0153 00       		.byte	0
 11270 0154 00       		.byte	0
 11271 0155 64       		.byte	100
 11272 0156 00       		.byte	0
 11273 0157 01       		.byte	1
 11274 0158 00       		.byte	0
 11275 0159 03       		.byte	3
 11276 015a 00       		.byte	0
 11277 015b 00       		.byte	0
 11278 015c 00       		.byte	0
 11279 015d 00       		.byte	0
 11280 015e 00       		.byte	0
 11281 015f 30       		.byte	48
 11282 0160 01       		.byte	1
 11283 0161 00       		.byte	0
 11284 0162 00       		.byte	0
 11285 0163 00000000 		.space	5
 11285      00
 11286 0168 00       		.byte	0
 11287 0169 00       		.byte	0
 11288 016a 02       		.byte	2
 11289 016b 00       		.byte	0
 11290 016c 00       		.byte	0
 11291 016d 64       		.byte	100
 11292 016e 00       		.byte	0
 11293 016f 01       		.byte	1
 11294 0170 00       		.byte	0
 11295 0171 03       		.byte	3
 11296 0172 00       		.byte	0
 11297 0173 00       		.byte	0
 11298 0174 00       		.byte	0
 11299 0175 00       		.byte	0
 11300 0176 00       		.byte	0
 11301 0177 30       		.byte	48
 11302 0178 01       		.byte	1
 11303 0179 00       		.byte	0
 11304 017a 00       		.byte	0
 11305 017b 00000000 		.space	5
 11305      00
 11308              	CtrlParArry:
 11309 0180 10       		.byte	16
 11310 0181 10       		.byte	16
 11311 0182 02       		.byte	2
 11312 0183 00       		.byte	0
 11313 0184 00       		.byte	0
 11314 0185 03       		.byte	3
 11315 0186 00       		.byte	0
 11316 0187 01       		.byte	1
 11317 0188 00       		.byte	0
 11318 0189 03       		.byte	3
 11319 018a 00       		.byte	0
 11320 018b 00       		.byte	0
 11321 018c 00       		.byte	0
 11322 018d 00       		.byte	0
 11323 018e 00       		.byte	0
 11324 018f 30       		.byte	48
 11325 0190 01       		.byte	1
 11326 0191 00       		.byte	0
 11327 0192 00       		.byte	0
 11328 0193 00000000 		.space	5
 11328      00
 11329 0198 01       		.byte	1
 11330 0199 00       		.byte	0
 11331 019a 02       		.byte	2
 11332 019b 00       		.byte	0
 11333 019c 00       		.byte	0
 11334 019d 3F       		.byte	63
 11335 019e 00       		.byte	0
 11336 019f 01       		.byte	1
 11337 01a0 00       		.byte	0
 11338 01a1 03       		.byte	3
 11339 01a2 00       		.byte	0
 11340 01a3 1F       		.byte	31
 11341 01a4 00       		.byte	0
 11342 01a5 1F       		.byte	31
 11343 01a6 C7       		.byte	-57
 11344 01a7 30       		.byte	48
 11345 01a8 01       		.byte	1
 11346 01a9 01       		.byte	1
 11347 01aa 00       		.byte	0
 11348 01ab 00000000 		.space	5
 11348      00
 11349 01b0 07       		.byte	7
 11350 01b1 07       		.byte	7
 11351 01b2 02       		.byte	2
 11352 01b3 10       		.byte	16
 11353 01b4 00       		.byte	0
 11354 01b5 40       		.byte	64
 11355 01b6 00       		.byte	0
 11356 01b7 01       		.byte	1
 11357 01b8 00       		.byte	0
 11358 01b9 03       		.byte	3
 11359 01ba 00       		.byte	0
 11360 01bb 28       		.byte	40
 11361 01bc 00       		.byte	0
 11362 01bd 28       		.byte	40
 11363 01be 00       		.byte	0
 11364 01bf 30       		.byte	48
 11365 01c0 01       		.byte	1
 11366 01c1 01       		.byte	1
 11367 01c2 00       		.byte	0
 11368 01c3 00000000 		.space	5
 11368      00
 11369 01c8 00       		.byte	0
 11370 01c9 00       		.byte	0
 11371 01ca 02       		.byte	2
 11372 01cb 00       		.byte	0
 11373 01cc 00       		.byte	0
 11374 01cd 64       		.byte	100
 11375 01ce 00       		.byte	0
 11376 01cf 01       		.byte	1
 11377 01d0 00       		.byte	0
 11378 01d1 03       		.byte	3
 11379 01d2 00       		.byte	0
 11380 01d3 00       		.byte	0
 11381 01d4 00       		.byte	0
 11382 01d5 00       		.byte	0
 11383 01d6 00       		.byte	0
 11384 01d7 30       		.byte	48
 11385 01d8 01       		.byte	1
 11386 01d9 00       		.byte	0
 11387 01da 00       		.byte	0
 11388 01db 00000000 		.space	5
 11388      00
 11389 01e0 07       		.byte	7
 11390 01e1 07       		.byte	7
 11391 01e2 02       		.byte	2
 11392 01e3 00       		.byte	0
 11393 01e4 00       		.byte	0
 11394 01e5 01       		.byte	1
 11395 01e6 00       		.byte	0
 11396 01e7 01       		.byte	1
 11397 01e8 00       		.byte	0
 11398 01e9 03       		.byte	3
 11399 01ea 00       		.byte	0
 11400 01eb 01       		.byte	1
 11401 01ec 00       		.byte	0
 11402 01ed 01       		.byte	1
 11403 01ee 00       		.byte	0
 11404 01ef 30       		.byte	48
 11405 01f0 01       		.byte	1
 11406 01f1 00       		.byte	0
 11407 01f2 00       		.byte	0
 11408 01f3 00000000 		.space	5
 11408      00
 11409 01f8 DF       		.byte	-33
 11410 01f9 E1       		.byte	-31
 11411 01fa 02       		.byte	2
 11412 01fb 00       		.byte	0
 11413 01fc 00       		.byte	0
 11414 01fd FF       		.byte	-1
 11415 01fe 00       		.byte	0
 11416 01ff 01       		.byte	1
 11417 0200 00       		.byte	0
 11418 0201 03       		.byte	3
 11419 0202 00       		.byte	0
 11420 0203 80       		.byte	-128
 11421 0204 00       		.byte	0
 11422 0205 00       		.byte	0
 11423 0206 00       		.byte	0
 11424 0207 C6       		.byte	-58
 11425 0208 01       		.byte	1
 11426 0209 01       		.byte	1
 11427 020a 00       		.byte	0
 11428 020b 00000000 		.space	5
 11428      00
 11429 0210 85       		.byte	-123
 11430 0211 86       		.byte	-122
 11431 0212 02       		.byte	2
 11432 0213 00       		.byte	0
 11433 0214 00       		.byte	0
 11434 0215 64       		.byte	100
 11435 0216 00       		.byte	0
 11436 0217 01       		.byte	1
 11437 0218 00       		.byte	0
 11438 0219 03       		.byte	3
 11439 021a 00       		.byte	0
 11440 021b 32       		.byte	50
 11441 021c 00       		.byte	0
 11442 021d 32       		.byte	50
 11443 021e 00       		.byte	0
 11444 021f F2       		.byte	-14
 11445 0220 01       		.byte	1
 11446 0221 01       		.byte	1
 11447 0222 00       		.byte	0
 11448 0223 00000000 		.space	5
 11448      00
 11449 0228 06       		.byte	6
 11450 0229 06       		.byte	6
 11451 022a 02       		.byte	2
 11452 022b 00       		.byte	0
 11453 022c 00       		.byte	0
 11454 022d 0E       		.byte	14
 11455 022e 00       		.byte	0
 11456 022f 01       		.byte	1
 11457 0230 00       		.byte	0
 11458 0231 03       		.byte	3
 11459 0232 00       		.byte	0
 11460 0233 00       		.byte	0
 11461 0234 00       		.byte	0
 11462 0235 00       		.byte	0
 11463 0236 00       		.byte	0
 11464 0237 30       		.byte	48
 11465 0238 01       		.byte	1
 11466 0239 01       		.byte	1
 11467 023a 00       		.byte	0
 11468 023b 00000000 		.space	5
 11468      00
 11469 0240 00       		.byte	0
 11470 0241 00       		.byte	0
 11471 0242 02       		.byte	2
 11472 0243 00       		.byte	0
 11473 0244 00       		.byte	0
 11474 0245 64       		.byte	100
 11475 0246 00       		.byte	0
 11476 0247 01       		.byte	1
 11477 0248 00       		.byte	0
 11478 0249 03       		.byte	3
 11479 024a 00       		.byte	0
 11480 024b 00       		.byte	0
 11481 024c 00       		.byte	0
 11482 024d 00       		.byte	0
 11483 024e 00       		.byte	0
 11484 024f 30       		.byte	48
 11485 0250 01       		.byte	1
 11486 0251 00       		.byte	0
 11487 0252 00       		.byte	0
 11488 0253 00000000 		.space	5
 11488      00
 11489 0258 08       		.byte	8
 11490 0259 08       		.byte	8
 11491 025a 02       		.byte	2
 11492 025b 00       		.byte	0
 11493 025c 00       		.byte	0
 11494 025d 05       		.byte	5
 11495 025e 00       		.byte	0
 11496 025f 01       		.byte	1
 11497 0260 00       		.byte	0
 11498 0261 03       		.byte	3
 11499 0262 00       		.byte	0
 11500 0263 00       		.byte	0
 11501 0264 00       		.byte	0
 11502 0265 00       		.byte	0
 11503 0266 00       		.byte	0
 11504 0267 30       		.byte	48
 11505 0268 01       		.byte	1
 11506 0269 00       		.byte	0
 11507 026a 00       		.byte	0
 11508 026b 00000000 		.space	5
 11508      00
 11509 0270 00       		.byte	0
 11510 0271 00       		.byte	0
 11511 0272 02       		.byte	2
 11512 0273 00       		.byte	0
 11513 0274 00       		.byte	0
 11514 0275 40       		.byte	64
 11515 0276 00       		.byte	0
 11516 0277 01       		.byte	1
 11517 0278 00       		.byte	0
 11518 0279 03       		.byte	3
 11519 027a 00       		.byte	0
 11520 027b 00       		.byte	0
 11521 027c 00       		.byte	0
 11522 027d 00       		.byte	0
 11523 027e 00       		.byte	0
 11524 027f 30       		.byte	48
 11525 0280 01       		.byte	1
 11526 0281 00       		.byte	0
 11527 0282 00       		.byte	0
 11528 0283 00000000 		.space	5
 11528      00
 11529 0288 09       		.byte	9
 11530 0289 0A       		.byte	10
 11531 028a 04       		.byte	4
 11532 028b 00       		.byte	0
 11533 028c 00       		.byte	0
 11534 028d 40       		.byte	64
 11535 028e 00       		.byte	0
 11536 028f 01       		.byte	1
 11537 0290 00       		.byte	0
 11538 0291 03       		.byte	3
 11539 0292 00       		.byte	0
 11540 0293 20       		.byte	32
 11541 0294 38       		.byte	56
 11542 0295 20       		.byte	32
 11543 0296 38       		.byte	56
 11544 0297 30       		.byte	48
 11545 0298 01       		.byte	1
 11546 0299 00       		.byte	0
 11547 029a 00       		.byte	0
 11548 029b 00000000 		.space	5
 11548      00
 11549 02a0 00       		.byte	0
 11550 02a1 00       		.byte	0
 11551 02a2 02       		.byte	2
 11552 02a3 00       		.byte	0
 11553 02a4 00       		.byte	0
 11554 02a5 64       		.byte	100
 11555 02a6 00       		.byte	0
 11556 02a7 01       		.byte	1
 11557 02a8 00       		.byte	0
 11558 02a9 03       		.byte	3
 11559 02aa 00       		.byte	0
 11560 02ab 00       		.byte	0
 11561 02ac 00       		.byte	0
 11562 02ad 00       		.byte	0
 11563 02ae 00       		.byte	0
 11564 02af 30       		.byte	48
 11565 02b0 01       		.byte	1
 11566 02b1 00       		.byte	0
 11567 02b2 00       		.byte	0
 11568 02b3 00000000 		.space	5
 11568      00
 11569 02b8 00       		.byte	0
 11570 02b9 00       		.byte	0
 11571 02ba 02       		.byte	2
 11572 02bb 00       		.byte	0
 11573 02bc 00       		.byte	0
 11574 02bd 64       		.byte	100
 11575 02be 00       		.byte	0
 11576 02bf 01       		.byte	1
 11577 02c0 00       		.byte	0
 11578 02c1 03       		.byte	3
 11579 02c2 00       		.byte	0
 11580 02c3 00       		.byte	0
 11581 02c4 00       		.byte	0
 11582 02c5 00       		.byte	0
 11583 02c6 00       		.byte	0
 11584 02c7 30       		.byte	48
 11585 02c8 01       		.byte	1
 11586 02c9 00       		.byte	0
 11587 02ca 00       		.byte	0
 11588 02cb 00000000 		.space	5
 11588      00
 11589 02d0 2A       		.byte	42
 11590 02d1 2A       		.byte	42
 11591 02d2 02       		.byte	2
 11592 02d3 00       		.byte	0
 11593 02d4 00       		.byte	0
 11594 02d5 1B       		.byte	27
 11595 02d6 00       		.byte	0
 11596 02d7 01       		.byte	1
 11597 02d8 00       		.byte	0
 11598 02d9 03       		.byte	3
 11599 02da 00       		.byte	0
 11600 02db 00       		.byte	0
 11601 02dc 00       		.byte	0
 11602 02dd 00       		.byte	0
 11603 02de 00       		.byte	0
 11604 02df 30       		.byte	48
 11605 02e0 01       		.byte	1
 11606 02e1 00       		.byte	0
 11607 02e2 00       		.byte	0
 11608 02e3 00000000 		.space	5
 11608      00
 11609 02e8 00       		.byte	0
 11610 02e9 00       		.byte	0
 11611 02ea 02       		.byte	2
 11612 02eb 00       		.byte	0
 11613 02ec 00       		.byte	0
 11614 02ed 64       		.byte	100
 11615 02ee 00       		.byte	0
 11616 02ef 01       		.byte	1
 11617 02f0 00       		.byte	0
 11618 02f1 03       		.byte	3
 11619 02f2 00       		.byte	0
 11620 02f3 00       		.byte	0
 11621 02f4 00       		.byte	0
 11622 02f5 00       		.byte	0
 11623 02f6 00       		.byte	0
 11624 02f7 30       		.byte	48
 11625 02f8 01       		.byte	1
 11626 02f9 00       		.byte	0
 11627 02fa 00       		.byte	0
 11628 02fb 00000000 		.space	5
 11628      00
 11629 0300 00       		.byte	0
 11630 0301 00       		.byte	0
 11631 0302 02       		.byte	2
 11632 0303 00       		.byte	0
 11633 0304 00       		.byte	0
 11634 0305 12       		.byte	18
 11635 0306 00       		.byte	0
 11636 0307 01       		.byte	1
 11637 0308 00       		.byte	0
 11638 0309 03       		.byte	3
 11639 030a 00       		.byte	0
 11640 030b 00       		.byte	0
 11641 030c 00       		.byte	0
 11642 030d 00       		.byte	0
 11643 030e 00       		.byte	0
 11644 030f 30       		.byte	48
 11645 0310 01       		.byte	1
 11646 0311 00       		.byte	0
 11647 0312 00       		.byte	0
 11648 0313 00000000 		.space	5
 11648      00
 11649 0318 01       		.byte	1
 11650 0319 01       		.byte	1
 11651 031a 02       		.byte	2
 11652 031b 00       		.byte	0
 11653 031c 00       		.byte	0
 11654 031d 09       		.byte	9
 11655 031e 00       		.byte	0
 11656 031f 01       		.byte	1
 11657 0320 00       		.byte	0
 11658 0321 03       		.byte	3
 11659 0322 00       		.byte	0
 11660 0323 00       		.byte	0
 11661 0324 00       		.byte	0
 11662 0325 01       		.byte	1
 11663 0326 00       		.byte	0
 11664 0327 30       		.byte	48
 11665 0328 01       		.byte	1
 11666 0329 00       		.byte	0
 11667 032a 00       		.byte	0
 11668 032b 00000000 		.space	5
 11668      00
 11669 0330 05       		.byte	5
 11670 0331 05       		.byte	5
 11671 0332 02       		.byte	2
 11672 0333 00       		.byte	0
 11673 0334 00       		.byte	0
 11674 0335 03       		.byte	3
 11675 0336 00       		.byte	0
 11676 0337 01       		.byte	1
 11677 0338 00       		.byte	0
 11678 0339 03       		.byte	3
 11679 033a 00       		.byte	0
 11680 033b 00       		.byte	0
 11681 033c 00       		.byte	0
 11682 033d 00       		.byte	0
 11683 033e 00       		.byte	0
 11684 033f 30       		.byte	48
 11685 0340 01       		.byte	1
 11686 0341 00       		.byte	0
 11687 0342 00       		.byte	0
 11688 0343 00000000 		.space	5
 11688      00
 11689 0348 18       		.byte	24
 11690 0349 18       		.byte	24
 11691 034a 02       		.byte	2
 11692 034b 00       		.byte	0
 11693 034c 00       		.byte	0
 11694 034d 01       		.byte	1
 11695 034e 00       		.byte	0
 11696 034f 01       		.byte	1
 11697 0350 00       		.byte	0
 11698 0351 03       		.byte	3
 11699 0352 00       		.byte	0
 11700 0353 00       		.byte	0
 11701 0354 00       		.byte	0
 11702 0355 00       		.byte	0
 11703 0356 00       		.byte	0
 11704 0357 30       		.byte	48
 11705 0358 01       		.byte	1
 11706 0359 00       		.byte	0
 11707 035a 00       		.byte	0
 11708 035b 00000000 		.space	5
 11708      00
 11709 0360 19       		.byte	25
 11710 0361 19       		.byte	25
 11711 0362 01       		.byte	1
 11712 0363 00       		.byte	0
 11713 0364 00       		.byte	0
 11714 0365 40       		.byte	64
 11715 0366 00       		.byte	0
 11716 0367 01       		.byte	1
 11717 0368 00       		.byte	0
 11718 0369 03       		.byte	3
 11719 036a 00       		.byte	0
 11720 036b 20       		.byte	32
 11721 036c 00       		.byte	0
 11722 036d 20       		.byte	32
 11723 036e 00       		.byte	0
 11724 036f 30       		.byte	48
 11725 0370 01       		.byte	1
 11726 0371 00       		.byte	0
 11727 0372 00       		.byte	0
 11728 0373 00000000 		.space	5
 11728      00
 11729 0378 20       		.byte	32
 11730 0379 20       		.byte	32
 11731 037a 02       		.byte	2
 11732 037b 00       		.byte	0
 11733 037c 00       		.byte	0
 11734 037d 02       		.byte	2
 11735 037e 00       		.byte	0
 11736 037f 01       		.byte	1
 11737 0380 00       		.byte	0
 11738 0381 03       		.byte	3
 11739 0382 00       		.byte	0
 11740 0383 00       		.byte	0
 11741 0384 00       		.byte	0
 11742 0385 00       		.byte	0
 11743 0386 00       		.byte	0
 11744 0387 30       		.byte	48
 11745 0388 01       		.byte	1
 11746 0389 00       		.byte	0
 11747 038a 00       		.byte	0
 11748 038b 00000000 		.space	5
 11748      00
 11749 0390 22       		.byte	34
 11750 0391 22       		.byte	34
 11751 0392 02       		.byte	2
 11752 0393 00       		.byte	0
 11753 0394 00       		.byte	0
 11754 0395 3F       		.byte	63
 11755 0396 00       		.byte	0
 11756 0397 01       		.byte	1
 11757 0398 00       		.byte	0
 11758 0399 03       		.byte	3
 11759 039a 00       		.byte	0
 11760 039b 00       		.byte	0
 11761 039c 00       		.byte	0
 11762 039d 00       		.byte	0
 11763 039e 00       		.byte	0
 11764 039f 30       		.byte	48
 11765 03a0 01       		.byte	1
 11766 03a1 00       		.byte	0
 11767 03a2 00       		.byte	0
 11768 03a3 00000000 		.space	5
 11768      00
 11769 03a8 23       		.byte	35
 11770 03a9 23       		.byte	35
 11771 03aa 02       		.byte	2
 11772 03ab 00       		.byte	0
 11773 03ac 00       		.byte	0
 11774 03ad 64       		.byte	100
 11775 03ae 00       		.byte	0
 11776 03af 01       		.byte	1
 11777 03b0 00       		.byte	0
 11778 03b1 03       		.byte	3
 11779 03b2 00       		.byte	0
 11780 03b3 10       		.byte	16
 11781 03b4 00       		.byte	0
 11782 03b5 10       		.byte	16
 11783 03b6 00       		.byte	0
 11784 03b7 30       		.byte	48
 11785 03b8 01       		.byte	1
 11786 03b9 00       		.byte	0
 11787 03ba 00       		.byte	0
 11788 03bb 00000000 		.space	5
 11788      00
 11789 03c0 24       		.byte	36
 11790 03c1 24       		.byte	36
 11791 03c2 02       		.byte	2
 11792 03c3 00       		.byte	0
 11793 03c4 00       		.byte	0
 11794 03c5 64       		.byte	100
 11795 03c6 00       		.byte	0
 11796 03c7 01       		.byte	1
 11797 03c8 00       		.byte	0
 11798 03c9 03       		.byte	3
 11799 03ca 00       		.byte	0
 11800 03cb 10       		.byte	16
 11801 03cc 00       		.byte	0
 11802 03cd 10       		.byte	16
 11803 03ce 00       		.byte	0
 11804 03cf 30       		.byte	48
 11805 03d0 01       		.byte	1
 11806 03d1 00       		.byte	0
 11807 03d2 00       		.byte	0
 11808 03d3 00000000 		.space	5
 11808      00
 11809 03d8 02       		.byte	2
 11810 03d9 03       		.byte	3
 11811 03da 04       		.byte	4
 11812 03db 00       		.byte	0
 11813 03dc 00       		.byte	0
 11814 03dd FF       		.byte	-1
 11815 03de 00       		.byte	0
 11816 03df 01       		.byte	1
 11817 03e0 00       		.byte	0
 11818 03e1 03       		.byte	3
 11819 03e2 00       		.byte	0
 11820 03e3 00       		.byte	0
 11821 03e4 20       		.byte	32
 11822 03e5 00       		.byte	0
 11823 03e6 20       		.byte	32
 11824 03e7 30       		.byte	48
 11825 03e8 01       		.byte	1
 11826 03e9 00       		.byte	0
 11827 03ea 00       		.byte	0
 11828 03eb 00000000 		.space	5
 11828      00
 11829 03f0 04       		.byte	4
 11830 03f1 04       		.byte	4
 11831 03f2 02       		.byte	2
 11832 03f3 00       		.byte	0
 11833 03f4 00       		.byte	0
 11834 03f5 3F       		.byte	63
 11835 03f6 00       		.byte	0
 11836 03f7 01       		.byte	1
 11837 03f8 00       		.byte	0
 11838 03f9 03       		.byte	3
 11839 03fa 00       		.byte	0
 11840 03fb 20       		.byte	32
 11841 03fc 00       		.byte	0
 11842 03fd 20       		.byte	32
 11843 03fe 00       		.byte	0
 11844 03ff 30       		.byte	48
 11845 0400 01       		.byte	1
 11846 0401 00       		.byte	0
 11847 0402 00       		.byte	0
 11848 0403 00000000 		.space	5
 11848      00
 11849 0408 00       		.byte	0
 11850 0409 00       		.byte	0
 11851 040a 02       		.byte	2
 11852 040b 00       		.byte	0
 11853 040c 00       		.byte	0
 11854 040d 19       		.byte	25
 11855 040e 00       		.byte	0
 11856 040f 01       		.byte	1
 11857 0410 00       		.byte	0
 11858 0411 03       		.byte	3
 11859 0412 00       		.byte	0
 11860 0413 00       		.byte	0
 11861 0414 00       		.byte	0
 11862 0415 00       		.byte	0
 11863 0416 00       		.byte	0
 11864 0417 30       		.byte	48
 11865 0418 01       		.byte	1
 11866 0419 00       		.byte	0
 11867 041a 00       		.byte	0
 11868 041b 00000000 		.space	5
 11868      00
 11869 0420 10       		.byte	16
 11870 0421 10       		.byte	16
 11871 0422 02       		.byte	2
 11872 0423 00       		.byte	0
 11873 0424 00       		.byte	0
 11874 0425 06       		.byte	6
 11875 0426 00       		.byte	0
 11876 0427 01       		.byte	1
 11877 0428 00       		.byte	0
 11878 0429 03       		.byte	3
 11879 042a 00       		.byte	0
 11880 042b 00       		.byte	0
 11881 042c 00       		.byte	0
 11882 042d 00       		.byte	0
 11883 042e 00       		.byte	0
 11884 042f 30       		.byte	48
 11885 0430 01       		.byte	1
 11886 0431 00       		.byte	0
 11887 0432 00       		.byte	0
 11888 0433 00000000 		.space	5
 11888      00
 11889 0438 00       		.byte	0
 11890 0439 00       		.byte	0
 11891 043a 02       		.byte	2
 11892 043b 00       		.byte	0
 11893 043c 00       		.byte	0
 11894 043d 03       		.byte	3
 11895 043e 00       		.byte	0
 11896 043f 01       		.byte	1
 11897 0440 00       		.byte	0
 11898 0441 03       		.byte	3
 11899 0442 00       		.byte	0
 11900 0443 00       		.byte	0
 11901 0444 00       		.byte	0
 11902 0445 00       		.byte	0
 11903 0446 00       		.byte	0
 11904 0447 30       		.byte	48
 11905 0448 01       		.byte	1
 11906 0449 00       		.byte	0
 11907 044a 00       		.byte	0
 11908 044b 00000000 		.space	5
 11908      00
 11909 0450 50       		.byte	80
 11910 0451 50       		.byte	80
 11911 0452 01       		.byte	1
 11912 0453 00       		.byte	0
 11913 0454 00       		.byte	0
 11914 0455 03       		.byte	3
 11915 0456 00       		.byte	0
 11916 0457 01       		.byte	1
 11917 0458 00       		.byte	0
 11918 0459 03       		.byte	3
 11919 045a 00       		.byte	0
 11920 045b 00       		.byte	0
 11921 045c 00       		.byte	0
 11922 045d 00       		.byte	0
 11923 045e 00       		.byte	0
 11924 045f 30       		.byte	48
 11925 0460 01       		.byte	1
 11926 0461 00       		.byte	0
 11927 0462 00       		.byte	0
 11928 0463 00000000 		.space	5
 11928      00
 11929 0468 00       		.byte	0
 11930 0469 00       		.byte	0
 11931 046a 0B       		.byte	11
 11932 046b 00       		.byte	0
 11933 046c 00       		.byte	0
 11934 046d FF       		.byte	-1
 11935 046e FF       		.byte	-1
 11936 046f 01       		.byte	1
 11937 0470 00       		.byte	0
 11938 0471 03       		.byte	3
 11939 0472 00       		.byte	0
 11940 0473 00       		.byte	0
 11941 0474 00       		.byte	0
 11942 0475 00       		.byte	0
 11943 0476 00       		.byte	0
 11944 0477 00       		.byte	0
 11945 0478 01       		.byte	1
 11946 0479 00       		.byte	0
 11947 047a 00       		.byte	0
 11948 047b 00000000 		.space	5
 11948      00
 11951              	glUVCHeader:
 11952 0480 0C       		.byte	12
 11953 0481 8C       		.byte	-116
 11954 0482 00       		.byte	0
 11955 0483 00       		.byte	0
 11956 0484 00       		.byte	0
 11957 0485 00       		.byte	0
 11958 0486 00       		.byte	0
 11959 0487 00       		.byte	0
 11960 0488 00       		.byte	0
 11961 0489 00       		.byte	0
 11962 048a 00       		.byte	0
 11963 048b 00       		.byte	0
 11966              	WBMenuCmpArry:
 11967 048c A0       		.byte	-96
 11968 048d 0F       		.byte	15
 11969 048e 0F       		.byte	15
 11970 048f F0       		.byte	-16
 11973              	CTCtrlParArry:
 11974 0490 00       		.byte	0
 11975 0491 00       		.byte	0
 11976 0492 01       		.byte	1
 11977 0493 00       		.byte	0
 11978 0494 00       		.byte	0
 11979 0495 03       		.byte	3
 11980 0496 00       		.byte	0
 11981 0497 01       		.byte	1
 11982 0498 00       		.byte	0
 11983 0499 03       		.byte	3
 11984 049a 00       		.byte	0
 11985 049b 03       		.byte	3
 11986 049c 00       		.byte	0
 11987 049d 03       		.byte	3
 11988 049e 00       		.byte	0
 11989 049f 30       		.byte	48
 11990 04a0 01       		.byte	1
 11991 04a1 00       		.byte	0
 11992 04a2 00       		.byte	0
 11993 04a3 00000000 		.space	5
 11993      00
 11994 04a8 00       		.byte	0
 11995 04a9 00       		.byte	0
 11996 04aa 01       		.byte	1
 11997 04ab 01       		.byte	1
 11998 04ac 00       		.byte	0
 11999 04ad 0F       		.byte	15
 12000 04ae 00       		.byte	0
 12001 04af 0F       		.byte	15
 12002 04b0 00       		.byte	0
 12003 04b1 03       		.byte	3
 12004 04b2 00       		.byte	0
 12005 04b3 02       		.byte	2
 12006 04b4 00       		.byte	0
 12007 04b5 02       		.byte	2
 12008 04b6 00       		.byte	0
 12009 04b7 30       		.byte	48
 12010 04b8 01       		.byte	1
 12011 04b9 01       		.byte	1
 12012 04ba 00       		.byte	0
 12013 04bb 00000000 		.space	5
 12013      00
 12014 04c0 02       		.byte	2
 12015 04c1 00       		.byte	0
 12016 04c2 01       		.byte	1
 12017 04c3 00       		.byte	0
 12018 04c4 00       		.byte	0
 12019 04c5 01       		.byte	1
 12020 04c6 00       		.byte	0
 12021 04c7 01       		.byte	1
 12022 04c8 00       		.byte	0
 12023 04c9 03       		.byte	3
 12024 04ca 00       		.byte	0
 12025 04cb 00       		.byte	0
 12026 04cc 00       		.byte	0
 12027 04cd 00       		.byte	0
 12028 04ce 00       		.byte	0
 12029 04cf 30       		.byte	48
 12030 04d0 01       		.byte	1
 12031 04d1 01       		.byte	1
 12032 04d2 00       		.byte	0
 12033 04d3 00000000 		.space	5
 12033      00
 12034 04d8 00       		.byte	0
 12035 04d9 00       		.byte	0
 12036 04da 04       		.byte	4
 12037 04db 01       		.byte	1
 12038 04dc 00       		.byte	0
 12039 04dd 38       		.byte	56
 12040 04de 01       		.byte	1
 12041 04df 01       		.byte	1
 12042 04e0 00       		.byte	0
 12043 04e1 03       		.byte	3
 12044 04e2 00       		.byte	0
 12045 04e3 4E       		.byte	78
 12046 04e4 00       		.byte	0
 12047 04e5 4E       		.byte	78
 12048 04e6 00       		.byte	0
 12049 04e7 30       		.byte	48
 12050 04e8 01       		.byte	1
 12051 04e9 00       		.byte	0
 12052 04ea 00       		.byte	0
 12053 04eb 00000000 		.space	5
 12053      00
 12054 04f0 04       		.byte	4
 12055 04f1 00       		.byte	0
 12056 04f2 01       		.byte	1
 12057 04f3 00       		.byte	0
 12058 04f4 00       		.byte	0
 12059 04f5 00       		.byte	0
 12060 04f6 00       		.byte	0
 12061 04f7 01       		.byte	1
 12062 04f8 00       		.byte	0
 12063 04f9 03       		.byte	3
 12064 04fa 00       		.byte	0
 12065 04fb 00       		.byte	0
 12066 04fc 00       		.byte	0
 12067 04fd 00       		.byte	0
 12068 04fe 00       		.byte	0
 12069 04ff 30       		.byte	48
 12070 0500 01       		.byte	1
 12071 0501 00       		.byte	0
 12072 0502 00       		.byte	0
 12073 0503 00000000 		.space	5
 12073      00
 12074 0508 05       		.byte	5
 12075 0509 00       		.byte	0
 12076 050a 02       		.byte	2
 12077 050b 00       		.byte	0
 12078 050c 00       		.byte	0
 12079 050d FF       		.byte	-1
 12080 050e 00       		.byte	0
 12081 050f 01       		.byte	1
 12082 0510 00       		.byte	0
 12083 0511 03       		.byte	3
 12084 0512 00       		.byte	0
 12085 0513 01       		.byte	1
 12086 0514 00       		.byte	0
 12087 0515 00       		.byte	0
 12088 0516 00       		.byte	0
 12089 0517 30       		.byte	48
 12090 0518 01       		.byte	1
 12091 0519 01       		.byte	1
 12092 051a 00       		.byte	0
 12093 051b 00000000 		.space	5
 12093      00
 12094 0520 06       		.byte	6
 12095 0521 00       		.byte	0
 12096 0522 02       		.byte	2
 12097 0523 00       		.byte	0
 12098 0524 00       		.byte	0
 12099 0525 00       		.byte	0
 12100 0526 00       		.byte	0
 12101 0527 00       		.byte	0
 12102 0528 00       		.byte	0
 12103 0529 03       		.byte	3
 12104 052a 00       		.byte	0
 12105 052b 00       		.byte	0
 12106 052c 00       		.byte	0
 12107 052d 00       		.byte	0
 12108 052e 00       		.byte	0
 12109 052f 30       		.byte	48
 12110 0530 01       		.byte	1
 12111 0531 01       		.byte	1
 12112 0532 00       		.byte	0
 12113 0533 00000000 		.space	5
 12113      00
 12114 0538 23       		.byte	35
 12115 0539 00       		.byte	0
 12116 053a 02       		.byte	2
 12117 053b 00       		.byte	0
 12118 053c 00       		.byte	0
 12119 053d 30       		.byte	48
 12120 053e 00       		.byte	0
 12121 053f 01       		.byte	1
 12122 0540 00       		.byte	0
 12123 0541 03       		.byte	3
 12124 0542 0A       		.byte	10
 12125 0543 00       		.byte	0
 12126 0544 00       		.byte	0
 12127 0545 0A       		.byte	10
 12128 0546 00       		.byte	0
 12129 0547 30       		.byte	48
 12130 0548 01       		.byte	1
 12131 0549 01       		.byte	1
 12132 054a 00       		.byte	0
 12133 054b 00000000 		.space	5
 12133      00
 12134 0550 08       		.byte	8
 12135 0551 00       		.byte	0
 12136 0552 01       		.byte	1
 12137 0553 00       		.byte	0
 12138 0554 00       		.byte	0
 12139 0555 7F       		.byte	127
 12140 0556 00       		.byte	0
 12141 0557 01       		.byte	1
 12142 0558 00       		.byte	0
 12143 0559 03       		.byte	3
 12144 055a 00       		.byte	0
 12145 055b 00       		.byte	0
 12146 055c 00       		.byte	0
 12147 055d 00       		.byte	0
 12148 055e 00       		.byte	0
 12149 055f 30       		.byte	48
 12150 0560 01       		.byte	1
 12151 0561 00       		.byte	0
 12152 0562 00       		.byte	0
 12153 0563 00000000 		.space	5
 12153      00
 12154 0568 09       		.byte	9
 12155 0569 00       		.byte	0
 12156 056a 02       		.byte	2
 12157 056b 00       		.byte	0
 12158 056c 00       		.byte	0
 12159 056d 05       		.byte	5
 12160 056e 00       		.byte	0
 12161 056f 01       		.byte	1
 12162 0570 00       		.byte	0
 12163 0571 03       		.byte	3
 12164 0572 00       		.byte	0
 12165 0573 00       		.byte	0
 12166 0574 00       		.byte	0
 12167 0575 00       		.byte	0
 12168 0576 00       		.byte	0
 12169 0577 30       		.byte	48
 12170 0578 01       		.byte	1
 12171 0579 00       		.byte	0
 12172 057a 00       		.byte	0
 12173 057b 00000000 		.space	5
 12173      00
 12174 0580 10       		.byte	16
 12175 0581 00       		.byte	0
 12176 0582 03       		.byte	3
 12177 0583 00       		.byte	0
 12178 0584 00       		.byte	0
 12179 0585 00       		.byte	0
 12180 0586 00       		.byte	0
 12181 0587 00       		.byte	0
 12182 0588 00       		.byte	0
 12183 0589 03       		.byte	3
 12184 058a 00       		.byte	0
 12185 058b 00       		.byte	0
 12186 058c 00       		.byte	0
 12187 058d 00       		.byte	0
 12188 058e 00       		.byte	0
 12189 058f 30       		.byte	48
 12190 0590 01       		.byte	1
 12191 0591 00       		.byte	0
 12192 0592 00       		.byte	0
 12193 0593 00000000 		.space	5
 12193      00
 12194 0598 00       		.byte	0
 12195 0599 00       		.byte	0
 12196 059a 02       		.byte	2
 12197 059b 00       		.byte	0
 12198 059c 00       		.byte	0
 12199 059d 40       		.byte	64
 12200 059e 00       		.byte	0
 12201 059f 01       		.byte	1
 12202 05a0 00       		.byte	0
 12203 05a1 03       		.byte	3
 12204 05a2 00       		.byte	0
 12205 05a3 0F       		.byte	15
 12206 05a4 11       		.byte	17
 12207 05a5 00       		.byte	0
 12208 05a6 00       		.byte	0
 12209 05a7 30       		.byte	48
 12210 05a8 01       		.byte	1
 12211 05a9 00       		.byte	0
 12212 05aa 00       		.byte	0
 12213 05ab 00000000 		.space	5
 12213      00
 12214 05b0 00       		.byte	0
 12215 05b1 00       		.byte	0
 12216 05b2 02       		.byte	2
 12217 05b3 00       		.byte	0
 12218 05b4 00       		.byte	0
 12219 05b5 64       		.byte	100
 12220 05b6 00       		.byte	0
 12221 05b7 01       		.byte	1
 12222 05b8 00       		.byte	0
 12223 05b9 03       		.byte	3
 12224 05ba 00       		.byte	0
 12225 05bb 00       		.byte	0
 12226 05bc 00       		.byte	0
 12227 05bd 00       		.byte	0
 12228 05be 00       		.byte	0
 12229 05bf 30       		.byte	48
 12230 05c0 01       		.byte	1
 12231 05c1 00       		.byte	0
 12232 05c2 00       		.byte	0
 12233 05c3 00000000 		.space	5
 12233      00
 12234 05c8 00       		.byte	0
 12235 05c9 00       		.byte	0
 12236 05ca 02       		.byte	2
 12237 05cb 00       		.byte	0
 12238 05cc 00       		.byte	0
 12239 05cd 64       		.byte	100
 12240 05ce 00       		.byte	0
 12241 05cf 01       		.byte	1
 12242 05d0 00       		.byte	0
 12243 05d1 03       		.byte	3
 12244 05d2 00       		.byte	0
 12245 05d3 00       		.byte	0
 12246 05d4 00       		.byte	0
 12247 05d5 00       		.byte	0
 12248 05d6 00       		.byte	0
 12249 05d7 30       		.byte	48
 12250 05d8 01       		.byte	1
 12251 05d9 00       		.byte	0
 12252 05da 00       		.byte	0
 12253 05db 00000000 		.space	5
 12253      00
 12254 05e0 00       		.byte	0
 12255 05e1 00       		.byte	0
 12256 05e2 02       		.byte	2
 12257 05e3 00       		.byte	0
 12258 05e4 00       		.byte	0
 12259 05e5 64       		.byte	100
 12260 05e6 00       		.byte	0
 12261 05e7 01       		.byte	1
 12262 05e8 00       		.byte	0
 12263 05e9 03       		.byte	3
 12264 05ea 00       		.byte	0
 12265 05eb 00       		.byte	0
 12266 05ec 00       		.byte	0
 12267 05ed 00       		.byte	0
 12268 05ee 00       		.byte	0
 12269 05ef 30       		.byte	48
 12270 05f0 01       		.byte	1
 12271 05f1 00       		.byte	0
 12272 05f2 00       		.byte	0
 12273 05f3 00000000 		.space	5
 12273      00
 12274 05f8 00       		.byte	0
 12275 05f9 00       		.byte	0
 12276 05fa 02       		.byte	2
 12277 05fb 00       		.byte	0
 12278 05fc 00       		.byte	0
 12279 05fd 64       		.byte	100
 12280 05fe 00       		.byte	0
 12281 05ff 01       		.byte	1
 12282 0600 00       		.byte	0
 12283 0601 03       		.byte	3
 12284 0602 00       		.byte	0
 12285 0603 00       		.byte	0
 12286 0604 00       		.byte	0
 12287 0605 00       		.byte	0
 12288 0606 00       		.byte	0
 12289 0607 30       		.byte	48
 12290 0608 01       		.byte	1
 12291 0609 00       		.byte	0
 12292 060a 00       		.byte	0
 12293 060b 00000000 		.space	5
 12293      00
 12296              	glProbeCtrl:
 12297 0610 00       		.byte	0
 12298 0611 00       		.byte	0
 12299 0612 01       		.byte	1
 12300 0613 01       		.byte	1
 12301 0614 15       		.byte	21
 12302 0615 16       		.byte	22
 12303 0616 05       		.byte	5
 12304 0617 00       		.byte	0
 12305 0618 00       		.byte	0
 12306 0619 00       		.byte	0
 12307 061a 00       		.byte	0
 12308 061b 00       		.byte	0
 12309 061c 00       		.byte	0
 12310 061d 00       		.byte	0
 12311 061e 00       		.byte	0
 12312 061f 00       		.byte	0
 12313 0620 00       		.byte	0
 12314 0621 00       		.byte	0
 12315 0622 00       		.byte	0
 12316 0623 48       		.byte	72
 12317 0624 3F       		.byte	63
 12318 0625 00       		.byte	0
 12319 0626 00       		.byte	0
 12320 0627 40       		.byte	64
 12321 0628 00       		.byte	0
 12322 0629 00       		.byte	0
 12323 062a 0000     		.space	2
 12326              	glProbeStilCtrl:
 12327 062c 01       		.byte	1
 12328 062d 01       		.byte	1
 12329 062e 00       		.byte	0
 12330 062f 00       		.byte	0
 12331 0630 80       		.byte	-128
 12332 0631 25       		.byte	37
 12333 0632 00       		.byte	0
 12334 0633 00       		.byte	0
 12335 0634 40       		.byte	64
 12336 0635 00       		.byte	0
 12337 0636 00       		.byte	0
 12338 0637 00       		.space	1
 12341              	glProbeStilCtrl20:
 12342 0638 01       		.byte	1
 12343 0639 01       		.byte	1
 12344 063a 00       		.byte	0
 12345 063b 00       		.byte	0
 12346 063c D2       		.byte	-46
 12347 063d 0F       		.byte	15
 12348 063e 00       		.byte	0
 12349 063f 00       		.byte	0
 12350 0640 40       		.byte	64
 12351 0641 00       		.byte	0
 12352 0642 00       		.byte	0
 12355              	snapButFlag:
 12356 0643 01       		.byte	1
 12359              	glProbeCtrl20:
 12360 0644 00       		.byte	0
 12361 0645 00       		.byte	0
 12362 0646 01       		.byte	1
 12363 0647 01       		.byte	1
 12364 0648 80       		.byte	-128
 12365 0649 1A       		.byte	26
 12366 064a 06       		.byte	6
 12367 064b 00       		.byte	0
 12368 064c 00       		.byte	0
 12369 064d 00       		.byte	0
 12370 064e 00       		.byte	0
 12371 064f 00       		.byte	0
 12372 0650 00       		.byte	0
 12373 0651 00       		.byte	0
 12374 0652 00       		.byte	0
 12375 0653 00       		.byte	0
 12376 0654 00       		.byte	0
 12377 0655 00       		.byte	0
 12378 0656 00       		.byte	0
 12379 0657 D2       		.byte	-46
 12380 0658 0F       		.byte	15
 12381 0659 00       		.byte	0
 12382 065a 00       		.byte	0
 12383 065b 40       		.byte	64
 12384 065c 00       		.byte	0
 12385 065d 00       		.byte	0
 12386 065e 0000     		.space	2
 12389              	CyFxGpifRegValue_usb2:
 12390 0660 08830080 		.word	-2147450104
 12391 0664 67000000 		.word	103
 12392 0668 01000000 		.word	1
 12393 066c 46000000 		.word	70
 12394 0670 00000000 		.word	0
 12395 0674 00000000 		.word	0
 12396 0678 02000000 		.word	2
 12397 067c 82000000 		.word	130
 12398 0680 82070000 		.word	1922
 12399 0684 40040000 		.word	1088
 12400 0688 FCFF0000 		.word	65532
 12401 068c 28000000 		.word	40
 12402 0690 00000000 		.word	0
 12403 0694 00000000 		.word	0
 12404 0698 00000000 		.word	0
 12405 069c 00000000 		.word	0
 12406 06a0 01000000 		.word	1
 12407 06a4 00000000 		.word	0
 12408 06a8 00000000 		.word	0
 12409 06ac 00000000 		.word	0
 12410 06b0 00000000 		.word	0
 12411 06b4 00000000 		.word	0
 12412 06b8 00000000 		.word	0
 12413 06bc 00000000 		.word	0
 12414 06c0 00000000 		.word	0
 12415 06c4 00000000 		.word	0
 12416 06c8 00000000 		.word	0
 12417 06cc 00000000 		.word	0
 12418 06d0 00000000 		.word	0
 12419 06d4 06000000 		.word	6
 12420 06d8 00000000 		.word	0
 12421 06dc FFFF0000 		.word	65535
 12422 06e0 09010000 		.word	265
 12423 06e4 00000000 		.word	0
 12424 06e8 F71F0000 		.word	8183
 12425 06ec 00000000 		.word	0
 12426 06f0 FFFF0000 		.word	65535
 12427 06f4 09010000 		.word	265
 12428 06f8 00000000 		.word	0
 12429 06fc F71F0000 		.word	8183
 12430 0700 00000000 		.word	0
 12431 0704 00000000 		.word	0
 12432 0708 00000000 		.word	0
 12433 070c 00000000 		.word	0
 12434 0710 00000000 		.word	0
 12435 0714 00000000 		.word	0
 12436 0718 00000000 		.word	0
 12437 071c 00000000 		.word	0
 12438 0720 00000000 		.word	0
 12439 0724 00000000 		.word	0
 12440 0728 00000000 		.word	0
 12441 072c 00000000 		.word	0
 12442 0730 00000000 		.word	0
 12443 0734 00000000 		.word	0
 12444 0738 00000000 		.word	0
 12445 073c 00000000 		.word	0
 12446 0740 00000000 		.word	0
 12447 0744 00000000 		.word	0
 12448 0748 00000000 		.word	0
 12449 074c 00000000 		.word	0
 12450 0750 00000000 		.word	0
 12451 0754 00000000 		.word	0
 12452 0758 00000000 		.word	0
 12453 075c 00040180 		.word	-2147417088
 12454 0760 01040180 		.word	-2147417087
 12455 0764 02040180 		.word	-2147417086
 12456 0768 03040180 		.word	-2147417085
 12457 076c 00000000 		.word	0
 12458 0770 00000000 		.word	0
 12459 0774 00000000 		.word	0
 12460 0778 00000000 		.word	0
 12461 077c 00000000 		.word	0
 12462 0780 00000000 		.word	0
 12463 0784 00000000 		.word	0
 12464 0788 00000000 		.word	0
 12465 078c C1FFFFFF 		.word	-63
 12468              	CyFxGpifWavedataPosition_usb2:
 12469 0790 00       		.byte	0
 12470 0791 01       		.byte	1
 12471 0792 02       		.byte	2
 12472 0793 03       		.byte	3
 12473 0794 04       		.byte	4
 12474 0795 05       		.byte	5
 12475 0796 06       		.byte	6
 12476 0797 07       		.byte	7
 12477 0798 08       		.byte	8
 12478 0799 09       		.byte	9
 12479 079a 0A       		.byte	10
 12480 079b 08       		.byte	8
 12481 079c 0B       		.byte	11
 12482 079d 0C       		.byte	12
 12483 079e 0D       		.byte	13
 12484 079f 08       		.byte	8
 12485 07a0 0E       		.byte	14
 12486 07a1 0F       		.byte	15
 12487 07a2 08       		.byte	8
 12488 07a3 08       		.byte	8
 12489 07a4 08       		.byte	8
 12490 07a5 08       		.byte	8
 12491 07a6 08       		.byte	8
 12492 07a7 08       		.byte	8
 12493 07a8 08       		.byte	8
 12494 07a9 08       		.byte	8
 12495 07aa 08       		.byte	8
 12496 07ab 08       		.byte	8
 12497 07ac 08       		.byte	8
 12498 07ad 08       		.byte	8
 12499 07ae 08       		.byte	8
 12500 07af 08       		.byte	8
 12501 07b0 08       		.byte	8
 12502 07b1 08       		.byte	8
 12503 07b2 08       		.byte	8
 12504 07b3 08       		.byte	8
 12505 07b4 08       		.byte	8
 12506 07b5 08       		.byte	8
 12507 07b6 08       		.byte	8
 12508 07b7 08       		.byte	8
 12509 07b8 08       		.byte	8
 12510 07b9 08       		.byte	8
 12511 07ba 08       		.byte	8
 12512 07bb 08       		.byte	8
 12513 07bc 08       		.byte	8
 12514 07bd 08       		.byte	8
 12515 07be 08       		.byte	8
 12516 07bf 08       		.byte	8
 12517 07c0 08       		.byte	8
 12518 07c1 08       		.byte	8
 12519 07c2 08       		.byte	8
 12520 07c3 08       		.byte	8
 12521 07c4 08       		.byte	8
 12522 07c5 08       		.byte	8
 12523 07c6 08       		.byte	8
 12524 07c7 08       		.byte	8
 12525 07c8 08       		.byte	8
 12526 07c9 08       		.byte	8
 12527 07ca 08       		.byte	8
 12528 07cb 08       		.byte	8
 12529 07cc 08       		.byte	8
 12530 07cd 08       		.byte	8
 12531 07ce 08       		.byte	8
 12532 07cf 08       		.byte	8
 12533 07d0 08       		.byte	8
 12534 07d1 08       		.byte	8
 12535 07d2 08       		.byte	8
 12536 07d3 08       		.byte	8
 12537 07d4 08       		.byte	8
 12538 07d5 08       		.byte	8
 12539 07d6 08       		.byte	8
 12540 07d7 08       		.byte	8
 12541 07d8 08       		.byte	8
 12542 07d9 08       		.byte	8
 12543 07da 08       		.byte	8
 12544 07db 08       		.byte	8
 12545 07dc 08       		.byte	8
 12546 07dd 08       		.byte	8
 12547 07de 08       		.byte	8
 12548 07df 08       		.byte	8
 12549 07e0 08       		.byte	8
 12550 07e1 08       		.byte	8
 12551 07e2 08       		.byte	8
 12552 07e3 08       		.byte	8
 12553 07e4 08       		.byte	8
 12554 07e5 08       		.byte	8
 12555 07e6 08       		.byte	8
 12556 07e7 08       		.byte	8
 12557 07e8 08       		.byte	8
 12558 07e9 08       		.byte	8
 12559 07ea 08       		.byte	8
 12560 07eb 08       		.byte	8
 12561 07ec 08       		.byte	8
 12562 07ed 08       		.byte	8
 12563 07ee 08       		.byte	8
 12564 07ef 08       		.byte	8
 12565 07f0 08       		.byte	8
 12566 07f1 08       		.byte	8
 12567 07f2 08       		.byte	8
 12568 07f3 08       		.byte	8
 12569 07f4 08       		.byte	8
 12570 07f5 08       		.byte	8
 12571 07f6 08       		.byte	8
 12572 07f7 08       		.byte	8
 12573 07f8 08       		.byte	8
 12574 07f9 08       		.byte	8
 12575 07fa 08       		.byte	8
 12576 07fb 08       		.byte	8
 12577 07fc 08       		.byte	8
 12578 07fd 08       		.byte	8
 12579 07fe 08       		.byte	8
 12580 07ff 08       		.byte	8
 12581 0800 08       		.byte	8
 12582 0801 08       		.byte	8
 12583 0802 08       		.byte	8
 12584 0803 08       		.byte	8
 12585 0804 08       		.byte	8
 12586 0805 08       		.byte	8
 12587 0806 08       		.byte	8
 12588 0807 08       		.byte	8
 12589 0808 08       		.byte	8
 12590 0809 08       		.byte	8
 12591 080a 08       		.byte	8
 12592 080b 08       		.byte	8
 12593 080c 08       		.byte	8
 12594 080d 08       		.byte	8
 12595 080e 08       		.byte	8
 12596 080f 08       		.byte	8
 12597 0810 00       		.byte	0
 12598 0811 01       		.byte	1
 12599 0812 02       		.byte	2
 12600 0813 10       		.byte	16
 12601 0814 04       		.byte	4
 12602 0815 05       		.byte	5
 12603 0816 06       		.byte	6
 12604 0817 07       		.byte	7
 12605 0818 08       		.byte	8
 12606 0819 09       		.byte	9
 12607 081a 0A       		.byte	10
 12608 081b 08       		.byte	8
 12609 081c 11       		.byte	17
 12610 081d 0C       		.byte	12
 12611 081e 0D       		.byte	13
 12612 081f 08       		.byte	8
 12613 0820 0E       		.byte	14
 12614 0821 0F       		.byte	15
 12615 0822 08       		.byte	8
 12616 0823 00       		.space	1
 12619              	CyFxGpifWavedata_usb2:
 12620 0824 0181731E 		.word	510886145
 12621 0828 00000000 		.word	0
 12622 082c 00000080 		.word	-2147483648
 12623 0830 00000000 		.word	0
 12624 0834 00000000 		.word	0
 12625 0838 00000000 		.word	0
 12626 083c 0201703E 		.word	1047527682
 12627 0840 00010000 		.word	256
 12628 0844 A00000C0 		.word	-1073741664
 12629 0848 00000000 		.word	0
 12630 084c 00000000 		.word	0
 12631 0850 00000000 		.word	0
 12632 0854 0394731E 		.word	510891011
 12633 0858 04000020 		.word	536870916
 12634 085c 60004080 		.word	-2143289248
 12635 0860 00000000 		.word	0
 12636 0864 00000000 		.word	0
 12637 0868 00000000 		.word	0
 12638 086c 0620702E 		.word	779100166
 12639 0870 0C000000 		.word	12
 12640 0874 00000080 		.word	-2147483648
 12641 0878 0620702E 		.word	779100166
 12642 087c 0C000000 		.word	12
 12643 0880 00000080 		.word	-2147483648
 12644 0884 0394731E 		.word	510891011
 12645 0888 04000020 		.word	536870916
 12646 088c 60004080 		.word	-2143289248
 12647 0890 0620702E 		.word	779100166
 12648 0894 0C000000 		.word	12
 12649 0898 00000080 		.word	-2147483648
 12650 089c 0C93731E 		.word	510890764
 12651 08a0 04000024 		.word	603979780
 12652 08a4 90004080 		.word	-2143289200
 12653 08a8 0D20702E 		.word	779100173
 12654 08ac 0C000000 		.word	12
 12655 08b0 00000080 		.word	-2147483648
 12656 08b4 0780724E 		.word	1316126727
 12657 08b8 0A000000 		.word	10
 12658 08bc 00000080 		.word	-2147483648
 12659 08c0 08000000 		.word	8
 12660 08c4 00000000 		.word	0
 12661 08c8 00010080 		.word	-2147483392
 12662 08cc 0920702E 		.word	779100169
 12663 08d0 0C010000 		.word	268
 12664 08d4 00000080 		.word	-2147483648
 12665 08d8 0A01701E 		.word	510656778
 12666 08dc 0E000100 		.word	65550
 12667 08e0 00000080 		.word	-2147483648
 12668 08e4 00000000 		.word	0
 12669 08e8 00000000 		.word	0
 12670 08ec 00000000 		.word	0
 12671 08f0 00000000 		.word	0
 12672 08f4 00000000 		.word	0
 12673 08f8 00000000 		.word	0
 12674 08fc 0394731E 		.word	510891011
 12675 0900 04000020 		.word	536870916
 12676 0904 60004080 		.word	-2143289248
 12677 0908 08000000 		.word	8
 12678 090c 00000000 		.word	0
 12679 0910 00010080 		.word	-2147483392
 12680 0914 0B000000 		.word	11
 12681 0918 00000000 		.word	0
 12682 091c 00010080 		.word	-2147483392
 12683 0920 0C93731E 		.word	510890764
 12684 0924 04000024 		.word	603979780
 12685 0928 90004080 		.word	-2143289200
 12686 092c 0D20702E 		.word	779100173
 12687 0930 0C000000 		.word	12
 12688 0934 00000080 		.word	-2147483648
 12689 0938 0D20702E 		.word	779100173
 12690 093c 0C000000 		.word	12
 12691 0940 00000080 		.word	-2147483648
 12692 0944 0E60724E 		.word	1316118542
 12693 0948 0A000000 		.word	10
 12694 094c 00000080 		.word	-2147483648
 12695 0950 0F000000 		.word	15
 12696 0954 00000000 		.word	0
 12697 0958 00010080 		.word	-2147483392
 12698 095c 1020702E 		.word	779100176
 12699 0960 0C010000 		.word	268
 12700 0964 00000080 		.word	-2147483648
 12701 0968 1101701E 		.word	510656785
 12702 096c 0E000100 		.word	65550
 12703 0970 00000080 		.word	-2147483648
 12704 0974 0C93731E 		.word	510890764
 12705 0978 04000024 		.word	603979780
 12706 097c 90004080 		.word	-2143289200
 12707 0980 0F000000 		.word	15
 12708 0984 00000000 		.word	0
 12709 0988 00010080 		.word	-2147483392
 12710 098c 12000000 		.word	18
 12711 0990 00000000 		.word	0
 12712 0994 00010080 		.word	-2147483392
 12713 0998 0394731E 		.word	510891011
 12714 099c 04000020 		.word	536870916
 12715 09a0 60004080 		.word	-2143289248
 12716 09a4 0480732E 		.word	779321348
 12717 09a8 02010000 		.word	258
 12718 09ac 000040C0 		.word	-1069547520
 12719 09b0 0580732E 		.word	779321349
 12720 09b4 02010000 		.word	258
 12721 09b8 000040C0 		.word	-1069547520
 12722 09bc 0580732E 		.word	779321349
 12723 09c0 02010000 		.word	258
 12724 09c4 000040C0 		.word	-1069547520
 12725 09c8 0480732E 		.word	779321348
 12726 09cc 02010000 		.word	258
 12727 09d0 000040C0 		.word	-1069547520
 12730              	CyFxGpifTransition_usb2:
 12731 09d4 0000     		.short	0
 12732 09d6 5555     		.short	21845
 12733 09d8 AAAA     		.short	-21846
 12734 09da 8888     		.short	-30584
 12735 09dc 1111     		.short	4369
 12736 09de 4444     		.short	17476
 12737 09e0 3333     		.short	13107
 12738 09e2 CCCC     		.short	-13108
 12741              	CyFxGpifRegValue:
 12742 09e4 08830080 		.word	-2147450104
 12743 09e8 67000000 		.word	103
 12744 09ec 00000000 		.word	0
 12745 09f0 46000000 		.word	70
 12746 09f4 00000000 		.word	0
 12747 09f8 00000000 		.word	0
 12748 09fc 02000000 		.word	2
 12749 0a00 82000000 		.word	130
 12750 0a04 82070000 		.word	1922
 12751 0a08 40040000 		.word	1088
 12752 0a0c FCFF0000 		.word	65532
 12753 0a10 28000000 		.word	40
 12754 0a14 00000000 		.word	0
 12755 0a18 00000000 		.word	0
 12756 0a1c 00000000 		.word	0
 12757 0a20 00000000 		.word	0
 12758 0a24 01000000 		.word	1
 12759 0a28 00000000 		.word	0
 12760 0a2c 00000000 		.word	0
 12761 0a30 00000000 		.word	0
 12762 0a34 00000000 		.word	0
 12763 0a38 00000000 		.word	0
 12764 0a3c 00000000 		.word	0
 12765 0a40 00000000 		.word	0
 12766 0a44 00000000 		.word	0
 12767 0a48 00000000 		.word	0
 12768 0a4c 00000000 		.word	0
 12769 0a50 00000000 		.word	0
 12770 0a54 00000000 		.word	0
 12771 0a58 06000000 		.word	6
 12772 0a5c 00000000 		.word	0
 12773 0a60 FFFF0000 		.word	65535
 12774 0a64 09010000 		.word	265
 12775 0a68 00000000 		.word	0
 12776 0a6c F71F0000 		.word	8183
 12777 0a70 00000000 		.word	0
 12778 0a74 FFFF0000 		.word	65535
 12779 0a78 09010000 		.word	265
 12780 0a7c 00000000 		.word	0
 12781 0a80 F71F0000 		.word	8183
 12782 0a84 00000000 		.word	0
 12783 0a88 00000000 		.word	0
 12784 0a8c 00000000 		.word	0
 12785 0a90 00000000 		.word	0
 12786 0a94 00000000 		.word	0
 12787 0a98 00000000 		.word	0
 12788 0a9c 00000000 		.word	0
 12789 0aa0 00000000 		.word	0
 12790 0aa4 00000000 		.word	0
 12791 0aa8 00000000 		.word	0
 12792 0aac 00000000 		.word	0
 12793 0ab0 00000000 		.word	0
 12794 0ab4 00000000 		.word	0
 12795 0ab8 00000000 		.word	0
 12796 0abc 00000000 		.word	0
 12797 0ac0 00000000 		.word	0
 12798 0ac4 00000000 		.word	0
 12799 0ac8 00000000 		.word	0
 12800 0acc 00000000 		.word	0
 12801 0ad0 00000000 		.word	0
 12802 0ad4 00000000 		.word	0
 12803 0ad8 00000000 		.word	0
 12804 0adc 00000000 		.word	0
 12805 0ae0 00040180 		.word	-2147417088
 12806 0ae4 01040180 		.word	-2147417087
 12807 0ae8 02040180 		.word	-2147417086
 12808 0aec 03040180 		.word	-2147417085
 12809 0af0 00000000 		.word	0
 12810 0af4 00000000 		.word	0
 12811 0af8 00000000 		.word	0
 12812 0afc 00000000 		.word	0
 12813 0b00 00000000 		.word	0
 12814 0b04 00000000 		.word	0
 12815 0b08 00000000 		.word	0
 12816 0b0c 00000000 		.word	0
 12817 0b10 C1FFFFFF 		.word	-63
 12820              	CyFxGpifWavedataPosition:
 12821 0b14 00       		.byte	0
 12822 0b15 01       		.byte	1
 12823 0b16 02       		.byte	2
 12824 0b17 03       		.byte	3
 12825 0b18 04       		.byte	4
 12826 0b19 05       		.byte	5
 12827 0b1a 06       		.byte	6
 12828 0b1b 07       		.byte	7
 12829 0b1c 08       		.byte	8
 12830 0b1d 09       		.byte	9
 12831 0b1e 0A       		.byte	10
 12832 0b1f 0B       		.byte	11
 12833 0b20 0B       		.byte	11
 12834 0b21 0B       		.byte	11
 12835 0b22 0B       		.byte	11
 12836 0b23 00       		.space	1
 12839              	CyFxGpifWavedata:
 12840 0b24 0181731E 		.word	510886145
 12841 0b28 00000000 		.word	0
 12842 0b2c 00000080 		.word	-2147483648
 12843 0b30 00000000 		.word	0
 12844 0b34 00000000 		.word	0
 12845 0b38 00000000 		.word	0
 12846 0b3c 0201702E 		.word	779092226
 12847 0b40 00010000 		.word	256
 12848 0b44 A0000080 		.word	-2147483488
 12849 0b48 00000000 		.word	0
 12850 0b4c 00000000 		.word	0
 12851 0b50 00000000 		.word	0
 12852 0b54 0380722E 		.word	779255811
 12853 0b58 02010020 		.word	536871170
 12854 0b5c 60000080 		.word	-2147483552
 12855 0b60 00000000 		.word	0
 12856 0b64 00000000 		.word	0
 12857 0b68 00000000 		.word	0
 12858 0b6c 0460722E 		.word	779247620
 12859 0b70 02010024 		.word	603980034
 12860 0b74 90000080 		.word	-2147483504
 12861 0b78 0594731E 		.word	510891013
 12862 0b7c 06000000 		.word	6
 12863 0b80 00000080 		.word	-2147483648
 12864 0b84 0380722E 		.word	779255811
 12865 0b88 02010020 		.word	536871170
 12866 0b8c 60000080 		.word	-2147483552
 12867 0b90 0693731E 		.word	510890758
 12868 0b94 06000000 		.word	6
 12869 0b98 00000080 		.word	-2147483648
 12870 0b9c 0720703E 		.word	1047535623
 12871 0ba0 08010000 		.word	264
 12872 0ba4 00000080 		.word	-2147483648
 12873 0ba8 0820703E 		.word	1047535624
 12874 0bac 08010000 		.word	264
 12875 0bb0 00000080 		.word	-2147483648
 12876 0bb4 0920703E 		.word	1047535625
 12877 0bb8 08010000 		.word	264
 12878 0bbc 00000080 		.word	-2147483648
 12879 0bc0 0A20703E 		.word	1047535626
 12880 0bc4 08010000 		.word	264
 12881 0bc8 00000080 		.word	-2147483648
 12882 0bcc 0380722E 		.word	779255811
 12883 0bd0 02010020 		.word	536871170
 12884 0bd4 60000080 		.word	-2147483552
 12885 0bd8 0B000000 		.word	11
 12886 0bdc 00000000 		.word	0
 12887 0be0 00010080 		.word	-2147483392
 12888 0be4 0460722E 		.word	779247620
 12889 0be8 02010024 		.word	603980034
 12890 0bec 90000080 		.word	-2147483504
 12891 0bf0 0D000000 		.word	13
 12892 0bf4 00000000 		.word	0
 12893 0bf8 00010080 		.word	-2147483392
 12894 0bfc 0460722E 		.word	779247620
 12895 0c00 02010024 		.word	603980034
 12896 0c04 90000080 		.word	-2147483504
 12897 0c08 0C000000 		.word	12
 12898 0c0c 00000000 		.word	0
 12899 0c10 00010080 		.word	-2147483392
 12900 0c14 0380722E 		.word	779255811
 12901 0c18 02010020 		.word	536871170
 12902 0c1c 60000080 		.word	-2147483552
 12903 0c20 0E000000 		.word	14
 12904 0c24 00000000 		.word	0
 12905 0c28 00010080 		.word	-2147483392
 12906 0c2c 00000000 		.word	0
 12907 0c30 00000000 		.word	0
 12908 0c34 00000000 		.word	0
 12909 0c38 00000000 		.word	0
 12910 0c3c 00000000 		.word	0
 12911 0c40 00000000 		.word	0
 12914              	CyFxGpifTransition:
 12915 0c44 0000     		.short	0
 12916 0c46 5555     		.short	21845
 12917 0c48 8888     		.short	-30584
 12918 0c4a AAAA     		.short	-21846
 12919 0c4c 3333     		.short	13107
 12920 0c4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 12921              		.align	2
 12922              	.LC0:
 12923 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 12923      7065722D 
 12923      74696D65 
 12923      72202564 
 12923      0D0A00
 12924 0013 00       		.space	1
 12925              	.LC1:
 12926 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 12926      636F6D6D 
 12926      616E6420 
 12926      71756575 
 12926      65206973 
 12927 0037 00       		.space	1
 12928              	.LC2:
 12929 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 12929      7220696E 
 12929      206D756C 
 12929      74696368 
 12929      616E6E65 
 12930 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 12930      2C20646D 
 12930      61446F6E 
 12930      65202578 
 12930      0D0A00
 12931 007e 0000     		.space	2
 12932              	.LC3:
 12933 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 12933      5420656E 
 12933      636F756E 
 12933      74657265 
 12933      642E2E2E 
 12934              	.LC4:
 12935 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 12935      454E4420 
 12935      656E636F 
 12935      756E7465 
 12935      7265642E 
 12936 00c2 0000     		.space	2
 12937              	.LC5:
 12938 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 12938      64697363 
 12938      6F6E6E65 
 12938      63746564 
 12938      2E2E2E30 
 12939 00e3 00       		.space	1
 12940              	.LC6:
 12941 00e4 0A0D6252 		.ascii	"\012\015bRType = 0x%x, bRequest = 0x%x, wValue = 0x"
 12941      54797065 
 12941      203D2030 
 12941      7825782C 
 12941      20625265 
 12942 0111 25782C20 		.ascii	"%x, wIndex = 0x%x, wLength= 0x%x\000"
 12942      77496E64 
 12942      6578203D 
 12942      20307825 
 12942      782C2077 
 12943 0132 0000     		.space	2
 12944              	.LC7:
 12945 0134 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 12945      43595F46 
 12945      585F5556 
 12945      435F5649 
 12945      44454F5F 
 12946 0167 0A00     		.ascii	"\012\000"
 12947 0169 000000   		.space	3
 12948              	.LC8:
 12949 016c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 12949      43595F46 
 12949      585F5556 
 12949      435F5649 
 12949      44454F5F 
 12950 019f 00       		.ascii	"\000"
 12951              	.LC9:
 12952 01a0 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 12952      726E6174 
 12952      65207365 
 12952      7474696E 
 12952      6720302E 
 12953              	.LC10:
 12954 01b8 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 12954      72206665 
 12954      61747572 
 12954      65207265 
 12954      71756573 
 12955 01db 00       		.space	1
 12956              	.LC11:
 12957 01dc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 12957      49324320 
 12957      636F6D6D 
 12957      616E6420 
 12957      69732030 
 12958 020f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 12958      78257820 
 12958      30782578 
 12958      20307825 
 12958      78203078 
 12959              	.LC12:
 12960 0228 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 12960      206C6967 
 12960      68742063 
 12960      6F6D7065 
 12960      6E736174 
 12961 025b 25640D0A 		.ascii	"%d\015\012\000"
 12961      00
 12962              	.LC13:
 12963 0260 54686520 		.ascii	"The I2C current data is not available. try again. %"
 12963      49324320 
 12963      63757272 
 12963      656E7420 
 12963      64617461 
 12964 0293 64202564 		.ascii	"d %d\015\012\000"
 12964      0D0A00
 12965 029a 0000     		.space	2
 12966              	.LC14:
 12967 029c 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 12967      26414743 
 12967      2073656E 
 12967      7420746F 
 12967      20686F73 
 12968 02c2 0000     		.space	2
 12969              	.LC15:
 12970 02c4 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 12970      26414743 
 12970      20676F74 
 12970      74656E20 
 12970      66726F6D 
 12971 02ee 0000     		.space	2
 12972              	.LC16:
 12973 02f0 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 12973      6C657665 
 12973      6C2E2025 
 12973      64202564 
 12973      3B202564 
 12974 030a 0000     		.space	2
 12975              	.LC17:
 12976 030c 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 12976      7365742E 
 12976      20256420 
 12976      25643B20 
 12976      25642025 
 12977              	.LC18:
 12978 0324 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 12978      67657420 
 12978      64617461 
 12978      2066726F 
 12978      6D20686F 
 12979 0351 000000   		.space	3
 12980              	.LC19:
 12981 0354 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 12981      52657175 
 12981      65737420 
 12981      30782578 
 12981      20706172 
 12982 0387 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 12982      6E642074 
 12982      6F20686F 
 12982      73742030 
 12982      78257820 
 12983 03a2 0000     		.space	2
 12984              	.LC20:
 12985 03a4 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 12985      204F7020 
 12985      72656365 
 12985      69766573 
 12985      20284354 
 12986 03cb 00       		.space	1
 12987              	.LC21:
 12988 03cc 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 12988      756C7420 
 12988      73656C65 
 12988      63746F72 
 12988      20284354 
 12989 03ee 0000     		.space	2
 12990              	.LC22:
 12991 03f0 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 12991      756C7420 
 12991      72657175 
 12991      65737420 
 12991      28435429 
 12992 0411 000000   		.space	3
 12993              	.LC23:
 12994 0414 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 12994      52657175 
 12994      65737420 
 12994      30782578 
 12994      20706172 
 12995 0447 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 12995      20307825 
 12995      78202F20 
 12995      73656E64 
 12995      20746F20 
 12996 0474 00       		.ascii	"\000"
 12997 0475 000000   		.space	3
 12998              	.LC24:
 12999 0478 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 12999      73657420 
 12999      64656620 
 12999      64617461 
 12999      20307825 
 13000 0497 00       		.space	1
 13001              	.LC25:
 13002 0498 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 13002      73657420 
 13002      64656620 
 13002      64617461 
 13002      20307825 
 13003 04cb 2E0D0A00 		.ascii	".\015\012\000"
 13004 04cf 00       		.space	1
 13005              	.LC26:
 13006 04d0 4572726F 		.ascii	"Error handler...\015\012\000"
 13006      72206861 
 13006      6E646C65 
 13006      722E2E2E 
 13006      0D0A00
 13007 04e3 00       		.space	1
 13008              	.LC27:
 13009 04e4 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 13009      64656661 
 13009      756C7420 
 13009      73657475 
 13009      70207265 
 13010              	.LC28:
 13011 0510 47657420 		.ascii	"Get UVC Prob(set) control %d %d %d %d %d %d %d\015\012"
 13011      55564320 
 13011      50726F62 
 13011      28736574 
 13011      2920636F 
 13012 0540 00       		.ascii	"\000"
 13013 0541 000000   		.space	3
 13014              	.LC29:
 13015 0544 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 13015      74686520 
 13015      76696465 
 13015      6F206D6F 
 13015      64652066 
 13016 0565 000000   		.space	3
 13017              	.LC30:
 13018 0568 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 13018      74686520 
 13018      76696465 
 13018      6F206D6F 
 13018      64652066 
 13019 058d 000000   		.space	3
 13020              	.LC31:
 13021 0590 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 13021      43595F46 
 13021      585F5556 
 13021      435F5354 
 13021      5245414D 
 13022 05b6 0000     		.space	2
 13023              	.LC32:
 13024 05b8 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 13024      55564320 
 13024      7374696C 
 13024      6C205072 
 13024      6F622873 
 13025 05e3 00       		.space	1
 13026              	.LC33:
 13027 05e4 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 13027      43595F46 
 13027      585F5556 
 13027      435F5354 
 13027      494C5F45 
 13028              	.LC34:
 13029 0608 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 13029      55564320 
 13029      7374696C 
 13029      6C207472 
 13029      69676765 
 13030 0631 000000   		.space	3
 13031              	.LC35:
 13032 0634 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 13032      7374696C 
 13032      6C207472 
 13032      69676765 
 13032      7220636F 
 13033 065b 00       		.space	1
 13034              	.LC36:
 13035 065c 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 13035      65642074 
 13035      6F207365 
 13035      6E642069 
 13035      6E746572 
 13036 068d 0A00     		.ascii	"\012\000"
 13037 068f 00       		.space	1
 13038              	.LC37:
 13039 0690 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 13039      6F6D6D69 
 13039      74656F66 
 13039      20737461 
 13039      7465203D 
 13040              	.LC38:
 13041 06a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 13041      6E656C20 
 13041      53657420 
 13041      57726170 
 13041      55702066 
 13042 06d5 000000   		.space	3
 13043              	.LC39:
 13044 06d8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 13044      69742045 
 13044      4F462066 
 13044      61696C65 
 13044      64210A00 
 13045              	.LC40:
 13046 06ec 49324320 		.ascii	"I2C initialization failed!\012\000"
 13046      696E6974 
 13046      69616C69 
 13046      7A617469 
 13046      6F6E2066 
 13047              	.LC41:
 13048 0708 49324320 		.ascii	"I2C configuration failed!\012\000"
 13048      636F6E66 
 13048      69677572 
 13048      6174696F 
 13048      6E206661 
 13049 0723 00       		.space	1
 13050              	.LC42:
 13051 0724 55415254 		.ascii	"UART initialization failed!\012\000"
 13051      20696E69 
 13051      7469616C 
 13051      697A6174 
 13051      696F6E20 
 13052 0741 000000   		.space	3
 13053              	.LC43:
 13054 0744 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 13054      43726561 
 13054      74652045 
 13054      76656E74 
 13054      20666169 
 13055 076e 0000     		.space	2
 13056              	.LC44:
 13057 0770 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 13057      20496E69 
 13057      74206661 
 13057      696C6564 
 13057      2C204572 
 13058 0793 00       		.space	1
 13059              	.LC45:
 13060 0794 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 13060      204F7665 
 13060      72726964 
 13060      65206661 
 13060      696C6564 
 13061 07bb 00       		.space	1
 13062              	.LC46:
 13063 07bc 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 13063      28323029 
 13063      204F7665 
 13063      72726964 
 13063      65206661 
 13064 07e7 00       		.space	1
 13065              	.LC47:
 13066 07e8 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 13066      28323429 
 13066      204F7665 
 13066      72726964 
 13066      65206661 
 13067 0813 00       		.space	1
 13068              	.LC48:
 13069 0814 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 13069      20536574 
 13069      20287265 
 13069      73657420 
 13069      32322920 
 13070 0846 00       		.ascii	"\000"
 13071 0847 00       		.space	1
 13072              	.LC49:
 13073 0848 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 13073      20536574 
 13073      2028706F 
 13073      77657220 
 13073      32302920 
 13074 087a 00       		.ascii	"\000"
 13075 087b 00       		.space	1
 13076              	.LC50:
 13077 087c 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 13077      20536574 
 13077      2028736E 
 13077      61702073 
 13077      686F7420 
 13078 08af 25640A00 		.ascii	"%d\012\000"
 13079 08b3 00       		.space	1
 13080              	.LC51:
 13081 08b4 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 13081      46756E63 
 13081      74696F6E 
 13081      20466169 
 13081      6C656420 
 13082 08e3 00       		.space	1
 13083              	.LC52:
 13084 08e4 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 13084      46756E63 
 13084      74696F6E 
 13084      20466169 
 13084      6C656420 
 13085 0913 00       		.space	1
 13086              	.LC53:
 13087 0914 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 13087      53657420 
 13087      456E6470 
 13087      6F696E74 
 13087      20636F6E 
 13088 0944 00       		.ascii	"\000"
 13089 0945 000000   		.space	3
 13090              	.LC54:
 13091 0948 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 13091      496E7465 
 13091      72727570 
 13091      74205374 
 13091      61747573 
 13092 097b 20436F64 		.ascii	" Code = %d\012\000"
 13092      65203D20 
 13092      25640A00 
 13093 0987 00       		.space	1
 13094              	.LC55:
 13095 0988 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 13095      65642074 
 13095      6F20616C 
 13095      6C6F6361 
 13095      7465206D 
 13096 09bb 65720D0A 		.ascii	"er\015\012\000"
 13096      00
 13097              	.LC56:
 13098 09c0 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 13098      4368616E 
 13098      6E656C20 
 13098      43726561 
 13098      74696F6E 
 13099 09ee 0000     		.space	2
 13100              	.LC57:
 13101 09f0 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 13101      436F6E6E 
 13101      65637420 
 13101      6661696C 
 13101      65642C20 
 13102 0a15 000000   		.space	3
 13103              	.LC58:
 13104 0a18 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 13104      74686520 
 13104      76696465 
 13104      6F206D6F 
 13104      64652066 
 13105 0a3a 0000     		.space	2
 13106              	.LC59:
 13107 0a3c 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 13107      4368616E 
 13107      6E656C20 
 13107      52657365 
 13107      74204661 
 13108 0a67 00       		.space	1
 13109              	.LC60:
 13110 0a68 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 13110      4368616E 
 13110      6E656C20 
 13110      53657420 
 13110      5472616E 
 13111 0a99 00       		.ascii	"\000"
 13112 0a9a 0000     		.space	2
 13113              	.LC61:
 13114 0a9c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 13114      4368616E 
 13114      6E656C20 
 13114      53657420 
 13114      5472616E 
 13115 0acd 0A00     		.ascii	"\012\000"
 13116 0acf 00       		.space	1
 13117              	.LC62:
 13118 0ad0 0D0A2073 		.ascii	"\015\012 super gpif\000"
 13118      75706572 
 13118      20677069 
 13118      6600
 13119 0ade 0000     		.space	2
 13120              	.LC63:
 13121 0ae0 0D0A2068 		.ascii	"\015\012 high gpif\000"
 13121      69676820 
 13121      67706966 
 13121      00
 13122 0aed 000000   		.space	3
 13123              	.LC64:
 13124 0af0 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 13124      696E6720 
 13124      47504946 
 13124      20436F6E 
 13124      66696775 
 13125 0b23 0A00     		.ascii	"\012\000"
 13126 0b25 000000   		.space	3
 13127              	.LC65:
 13128 0b28 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 13128      74696E67 
 13128      20475049 
 13128      46207374 
 13128      61746520 
 13129 0b5b 0D0A00   		.ascii	"\015\012\000"
 13130 0b5e 0000     		.space	2
 13131              	.LC66:
 13132 0b60 33303A55 		.ascii	"30:UVC App Thread\000"
 13132      56432041 
 13132      70702054 
 13132      68726561 
 13132      6400
 13133 0b72 0000     		.space	2
 13134              	.LC67:
 13135 0b74 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 13135      56432041 
 13135      70702045 
 13135      50302054 
 13135      68726561 
 13136 0b8a 0000     		.space	2
 13137              	.LC68:
 13138 0b8c 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 13138      32432041 
 13138      70702043 
 13138      54524C20 
 13138      54687265 
 13139 0ba3 00       		.bss
 13140              		.align	2
 13141              		.set	.LANCHOR0,. + 0
 13144              	glFxUVCEvent:
 13145 0000 00000000 		.space	40
 13145      00000000 
 13145      00000000 
 13145      00000000 
 13145      00000000 
 13148              	timercount:
 13149 0028 00       		.space	1
 13150 0029 000000   		.space	3
 13153              	curFlag:
 13154 002c 00000000 		.space	64
 13154      00000000 
 13154      00000000 
 13154      00000000 
 13154      00000000 
 13157              	fb:
 13158 006c 0000     		.space	2
 13161              	pb:
 13162 006e 0000     		.space	2
 13165              	pbc:
 13166 0070 0000     		.space	2
 13167 0072 0000     		.space	2
 13170              	stiflag:
 13171 0074 00000000 		.space	4
 13174              	hitFV:
 13175 0078 00000000 		.space	4
 13178              	prodCount:
 13179 007c 0000     		.space	2
 13182              	consCount:
 13183 007e 0000     		.space	2
 13186              	streamingStarted:
 13187 0080 00000000 		.space	4
 13190              	gpif_initialized:
 13191 0084 00000000 		.space	4
 13194              	isUsbConnected:
 13195 0088 00000000 		.space	4
 13198              	clearFeatureRqtReceived:
 13199 008c 00000000 		.space	4
 13202              	I2CCMDArry:
 13203 0090 00000000 		.space	12
 13203      00000000 
 13203      00000000 
 13206              	glEp0Buffer:
 13207 009c 00000000 		.space	32
 13207      00000000 
 13207      00000000 
 13207      00000000 
 13207      00000000 
 13210              	WDRflag:
 13211 00bc 00000000 		.space	4
 13214              	usbSpeed:
 13215 00c0 00       		.space	1
 13216 00c1 000000   		.space	3
 13219              	glCommitCtrl:
 13220 00c4 00000000 		.space	32
 13220      00000000 
 13220      00000000 
 13220      00000000 
 13220      00000000 
 13223              	setRes:
 13224 00e4 00       		.space	1
 13227              	IMcount.8108:
 13228 00e5 00       		.space	1
 13229 00e6 0000     		.space	2
 13232              	uvcAppThread:
 13233 00e8 00000000 		.space	168
 13233      00000000 
 13233      00000000 
 13233      00000000 
 13233      00000000 
 13236              	uvcAppEP0Thread:
 13237 0190 00000000 		.space	168
 13237      00000000 
 13237      00000000 
 13237      00000000 
 13237      00000000 
 13240              	i2cAppThread:
 13241 0238 00000000 		.space	168
 13241      00000000 
 13241      00000000 
 13241      00000000 
 13241      00000000 
 13244              	pbcpbak:
 13245 02e0 0000     		.space	2
 13248              	pbcbak:
 13249 02e2 0000     		.space	2
 13252              	pbbak:
 13253 02e4 0000     		.space	2
 13256              	fbbak:
 13257 02e6 0000     		.space	2
 13260              	testSnap:
 13261 02e8 00       		.space	1
 13262 02e9 000000   		.text
 13263              	.Letext0:
 13264              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 13265              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13266              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 13267              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 13268              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 13269              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13270              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13271              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13272              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13273              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13274              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13275              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13276              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13277              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13278              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13279              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13280              		.file 18 "../cmdqu.h"
 13281              		.file 19 "../uvc.h"
 13282              		.file 20 "../cyfxgpif2config.h"
 13283              		.file 21 "../cyfxgpif2config_usb2_720.h"
 13284              		.file 22 "../sensor.h"
 13285              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:38     .text:00000010 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:42     .text:00000014 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:45     .text:00000014 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:205    .text:0000015c $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:211    .text:0000016c $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:330    .text:00000258 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:342    .text:0000027c $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:345    .text:0000027c CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:577    .text:00000414 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:587    .text:00000430 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:589    .text:00000430 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:804    .text:000005ac $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:815    .text:000005bc $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:817    .text:000005bc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1192   .text:000008b4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000002 wValue
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1211   .text:000008e4 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1214   .text:000008e4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1350   .text:00000a04 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1355   .text:00000a0c $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1358   .text:00000a0c setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1426   .text:00000a88 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1619   .text:00000c00 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1661   .text:00000c9c $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1716   .text:00000d18 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:1752   .text:00000da0 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3007   .text:00001930 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3027   .text:00001974 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3030   .text:00001974 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3177   .text:00001a9c $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3190   .text:00001ac4 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3606   .text:00001ef4 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3617   .text:00001f14 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3887   .text:000021a8 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3899   .text:000021cc $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:3902   .text:000021cc CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4201   .text:00002484 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4208   .text:00002494 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4211   .text:00002494 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4255   .text:000024d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4260   .text:000024e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4263   .text:000024e0 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4291   .text:000024fc $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4295   .text:00002500 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4298   .text:00002500 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4363   .text:00002570 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:4371   .text:00002580 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:6214   .text:00003500 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000ac glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:6252   .text:0000357c $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:6502   .text:000037c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:6517   .text:000037e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9203   .text:00004a18 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9215   .text:00004a2c $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9218   .text:00004a2c CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9250   .text:00004a60 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9263   .text:00004a8c $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9268   .text:00004a9c $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9273   .text:00004aac $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9320   .text:00004b04 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9330   .text:00004b18 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9333   .text:00004b18 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9402   .text:00004b84 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9408   .text:00004b90 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:9411   .text:00004b90 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10539  .text:000054b4 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10594  .text:0000557c $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10597  .text:0000557c CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10763  .text:000056e4 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10780  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10783  .text.startup:00000000 main
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:11951  .data:00000480 glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12341  .data:00000638 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12359  .data:00000644 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12326  .data:0000062c glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12296  .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13186  .bss:00000080 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13198  .bss:0000008c clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13214  .bss:000000c0 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13194  .bss:00000088 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13244  .bss:000002e0 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13248  .bss:000002e2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13252  .bss:000002e4 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13256  .bss:000002e6 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13165  .bss:00000070 pbc
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13161  .bss:0000006e pb
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13157  .bss:0000006c fb
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13260  .bss:000002e8 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12355  .data:00000643 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10969  .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12389  .data:00000660 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12468  .data:00000790 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12619  .data:00000824 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12730  .data:000009d4 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10956  .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12741  .data:000009e4 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12820  .data:00000b14 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12839  .data:00000b24 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12914  .data:00000c44 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10922  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10926  .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10945  .rodata:00000010 ShutValueArry
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10981  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:10985  .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:11308  .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:11966  .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:11973  .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:12921  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13140  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13144  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13148  .bss:00000028 timercount
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13153  .bss:0000002c curFlag
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13170  .bss:00000074 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13174  .bss:00000078 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13178  .bss:0000007c prodCount
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13182  .bss:0000007e consCount
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13190  .bss:00000084 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13202  .bss:00000090 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13206  .bss:0000009c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13210  .bss:000000bc WDRflag
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13219  .bss:000000c4 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13223  .bss:000000e4 setRes
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13227  .bss:000000e5 IMcount.8108
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13232  .bss:000000e8 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13236  .bss:00000190 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccZ7ZGZq.s:13240  .bss:00000238 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_event_flags_set
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
memset
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
memcpy
SensorGetControl
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetWrapUp
CyU3PI2cInit
CyU3PI2cSetConfig
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
