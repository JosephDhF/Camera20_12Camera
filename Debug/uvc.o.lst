   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** 
 105:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 106:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 107:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 108:../uvc.c      ****                                                            received. */
 109:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 110:../uvc.c      **** #ifdef BACKFLOW_DETECT
 111:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 112:../uvc.c      **** #endif
 113:../uvc.c      **** 
 114:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 115:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 116:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 117:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 118:../uvc.c      **** #endif
 119:../uvc.c      **** 
 120:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 121:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 122:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 123:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 125:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 126:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 127:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 128:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 129:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 131:../uvc.c      ****                                    with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 133:../uvc.c      ****                                    streaming with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 135:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 136:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 137:../uvc.c      **** };
 138:../uvc.c      **** 
 139:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 140:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 141:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 143:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 144:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 145:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 146:../uvc.c      **** };
 147:../uvc.c      **** 
 148:../uvc.c      **** 
 149:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 150:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 151:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 152:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 154:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 155:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 156:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 157:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 158:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 159:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 160:../uvc.c      ****                                    with adjustable compression parameters */
 161:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 162:../uvc.c      ****                                    streaming with adjustable compression parameters */
 163:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 164:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 169:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 170:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 171:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 172:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 173:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 174:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 175:../uvc.c      **** };
 176:../uvc.c      **** 
 177:../uvc.c      **** 
 178:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 179:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 180:../uvc.c      **** 
 181:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 182:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 183:../uvc.c      **** {
 184:../uvc.c      ****     0x0C,                               /* Header Length */
 185:../uvc.c      ****     0x8C,                               /* Bit field header field */
 186:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 188:../uvc.c      **** };
 189:../uvc.c      **** 
 190:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 191:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 192:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 193:../uvc.c      ****                                                            the current video frame. */
 194:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 195:../uvc.c      **** #ifndef CAM720
 196:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 197:../uvc.c      **** #else
 198:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 199:../uvc.c      **** #endif
 200:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 201:../uvc.c      **** 
 202:../uvc.c      **** /************ control parameters array ***********
 203:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 204:../uvc.c      ****  *    e.g.
 205:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 206:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 207:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 208:../uvc.c      ****  **************************************************/
 209:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 210:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 211:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 212:../uvc.c      **** #ifndef CAM720
 213:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 214:../uvc.c      **** #else
 215:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 216:../uvc.c      **** #endif
 217:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0,
 218:../uvc.c      **** 		{/*2*/ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0,
 219:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 220:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 221:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 222:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 223:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,
 224:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 225:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 228:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 229:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 233:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** #ifndef CAM720
 235:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 236:../uvc.c      **** #else
 237:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 238:../uvc.c      **** #endif
 239:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 240:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 241:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 242:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 244:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 246:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg1     , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 247:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 248:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		/**********************************
 252:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 253:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 254:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 255:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 256:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 257:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 258:../uvc.c      **** 		 *
 259:../uvc.c      **** 		 *********************************/
 260:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 261:../uvc.c      **** };
 262:../uvc.c      **** 
 263:../uvc.c      **** #ifndef CAM720
 264:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 265:../uvc.c      **** #else
 266:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 267:../uvc.c      **** #endif
 268:../uvc.c      **** 
 269:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 270:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 271:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 272:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 273:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 274:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 275:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 276:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 277:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 278:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 279:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 280:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 281:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 282:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 285:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** };
 287:../uvc.c      **** 
 288:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 289:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 290:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 291:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 292:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 293:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 294:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 295:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 296:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 297:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 298:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 299:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 300:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 302:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 303:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 304:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** };
 308:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 309:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 310:../uvc.c      **** /*
 311:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 312:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 313:../uvc.c      ****  */
 314:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 315:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 316:../uvc.c      **** };
 317:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 318:../uvc.c      **** 		0
 319:../uvc.c      **** };
 320:../uvc.c      **** 
 321:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 322:../uvc.c      **** 
 323:../uvc.c      **** void I2CCmdHandler(){
 324:../uvc.c      **** 	uint8_t buf[2];
 325:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 327:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 329:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 330:../uvc.c      **** 
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 332:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 333:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 334:../uvc.c      **** 
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 336:../uvc.c      **** 	{
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 338:../uvc.c      **** #if 0 //for debugging
 339:../uvc.c      **** 		/* test still image operation */
 340:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 341:../uvc.c      **** 			snapButFlag = 0; //press
 342:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 343:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 344:../uvc.c      **** 			snapButFlag = 0xf; //release
 345:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 346:../uvc.c      **** 		}
 347:../uvc.c      **** 
 348:../uvc.c      **** 		/* end of the test */
 349:../uvc.c      **** #endif
 350:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 355:../uvc.c      **** 			}
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 357:../uvc.c      **** 		}else{//not support currently
 358:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 359:../uvc.c      **** 		}
 360:../uvc.c      **** 	}else if(CmdType == 1){
 361:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 362:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 363:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 364:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 365:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 366:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 367:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 368:../uvc.c      **** 			}
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 370:../uvc.c      **** 		}else{//not support currently
 371:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 372:../uvc.c      **** 		}
 373:../uvc.c      **** 
 374:../uvc.c      **** 	}
 375:../uvc.c      **** }
 376:../uvc.c      **** 
 377:../uvc.c      **** /************************************
 378:../uvc.c      ****  * set Iris mode
 379:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 380:../uvc.c      ****  */
 381:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 382:../uvc.c      **** 	uint8_t dataIdx;
 383:../uvc.c      **** 	  dataIdx = 0;
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 388:../uvc.c      **** }
 389:../uvc.c      **** 
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 391:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 392:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 393:../uvc.c      ****     uint16_t readCount;
 394:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 395:../uvc.c      ****     uint8_t devAdd;
 396:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 397:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 398:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 399:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 400:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 401:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 402:../uvc.c      ****     }else{
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 404:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 405:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 406:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 407:../uvc.c      ****     }
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 409:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 410:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 411:../uvc.c      **** #endif
 412:../uvc.c      ****     reqData = bRequest;
 413:../uvc.c      ****     /*
 414:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 415:../uvc.c      ****      */
 416:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 417:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 418:../uvc.c      ****     	goto EndofSet;
 419:../uvc.c      ****     }
 420:../uvc.c      ****     switch (bRequest)
 421:../uvc.c      **** 		 {
 422:../uvc.c      **** 
 423:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 424:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 425:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 427:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 428:../uvc.c      **** 			  break;
 429:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 430:../uvc.c      **** 
 431:../uvc.c      **** 			 switch(CtrlID)
 432:../uvc.c      **** 			 {
 433:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 434:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 435:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 436:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 437:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 438:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 439:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 440:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 441:../uvc.c      **** 			 	 		 break;
 442:../uvc.c      **** 			 	 }
 443:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 444:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 445:../uvc.c      **** 					 if(CamMode == 1){//720p
 446:../uvc.c      **** 						if(sendData >= 3){
 447:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 448:../uvc.c      **** 							sendData = 0; //set back to default
 449:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 450:../uvc.c      **** 						}
 451:../uvc.c      **** 						sendData += 4;
 452:../uvc.c      **** 					 }
 453:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 454:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 455:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 456:../uvc.c      **** 					 break;
 457:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 460:../uvc.c      **** 			 		 }
 461:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 462:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 463:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 464:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 465:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 466:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 467:../uvc.c      **** #endif
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 469:../uvc.c      **** 			 		 {
 470:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 471:../uvc.c      **** 			 		 }
 472:../uvc.c      **** 			 		 break;
 473:../uvc.c      **** 				 case ExtAexModCtlID9:
 474:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 475:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 476:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 477:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 478:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 479:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 480:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 481:../uvc.c      **** 					 break;
 482:../uvc.c      **** 
 483:../uvc.c      **** 			 	 case BrgtCtlID1:
 484:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 485:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 486:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 488:../uvc.c      **** 					 }else{
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 490:../uvc.c      **** 					 }
 491:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 492:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 493:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 494:../uvc.c      **** 					 break;
 495:../uvc.c      **** 				 case HueCtlID5:
 496:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 499:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 500:../uvc.c      **** 					 break;
 501:../uvc.c      **** 				 case WBTLevCtlID11:
 502:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 503:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 504:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 505:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 506:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 507:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 508:../uvc.c      **** 					 break;
 509:../uvc.c      **** 				 case SaturCtlID6:
 510:../uvc.c      **** 				 default:
 511:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 512:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 513:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 514:../uvc.c      **** 					 break;
 515:../uvc.c      **** 			 }
 516:../uvc.c      **** 
 517:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 518:../uvc.c      **** 
 519:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 520:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 521:../uvc.c      **** #endif
 522:../uvc.c      **** 			  break;
 523:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 524:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 525:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 526:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 527:../uvc.c      **** 		 	 }
 528:../uvc.c      **** 
 529:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 530:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 531:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 532:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 533:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 534:../uvc.c      **** 			 }else
 535:../uvc.c      **** 			 {
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 537:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 538:../uvc.c      **** 			 }
 539:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 540:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 541:../uvc.c      **** 			  break;
 542:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 543:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 544:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 545:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 546:../uvc.c      **** 		 	 }
 547:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 548:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 549:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 550:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 551:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 552:../uvc.c      **** 			 }else
 553:../uvc.c      **** 			 {
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 555:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 556:../uvc.c      **** 			 }
 557:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 558:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 559:../uvc.c      **** 			  break;
 560:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 561:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 563:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 564:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 565:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 566:../uvc.c      **** 		 	 }
 567:../uvc.c      **** 		 	 else{
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 569:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 570:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 571:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 572:../uvc.c      **** 		 	 }
 573:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 574:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 575:../uvc.c      **** 			  break;
 576:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 577:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 579:../uvc.c      **** 		 	 }
 580:../uvc.c      **** 		 	 else{
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 582:../uvc.c      **** 		 	 }
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 584:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 585:../uvc.c      **** 			  Len = 1;
 586:../uvc.c      **** 			  break;
 587:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 588:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 589:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 590:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 591:../uvc.c      **** 		 	 }
 592:../uvc.c      **** 
 593:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 594:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 595:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 596:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 597:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 598:../uvc.c      **** 			 }else{
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 600:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 601:../uvc.c      **** 			 }
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 603:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 604:../uvc.c      **** 			  break;
 605:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 606:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 607:../uvc.c      **** 				  glEp0Buffer, &readCount);
 608:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 609:../uvc.c      **** 			   {
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 612:../uvc.c      **** 				  getData = glEp0Buffer[0];
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 614:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 615:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 616:../uvc.c      **** #endif
 617:../uvc.c      **** 				  switch(CtrlID)
 618:../uvc.c      **** 					 {
 619:../uvc.c      **** 						 case ExtShutCtlID0:
 620:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 621:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 622:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 623:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 625:../uvc.c      **** 									 }else{
 626:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 627:../uvc.c      **** 									 }
 628:../uvc.c      **** 								 }
 629:../uvc.c      **** 							 }else{
 630:../uvc.c      **** 								 Data1 = Data0 - 1;
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 632:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 634:../uvc.c      **** 									 }else{
 635:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 636:../uvc.c      **** 									 }
 637:../uvc.c      **** 								 }
 638:../uvc.c      **** 								 if(Data1 < 8){
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 641:../uvc.c      **** 								 }else{
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 644:../uvc.c      **** 								 }
 645:../uvc.c      **** 							 }
 646:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 647:../uvc.c      **** 							 dataIdx = 0;
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 649:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 651:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 652:../uvc.c      **** 							 break;
 653:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 655:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 656:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 657:../uvc.c      **** 							 dataIdx = 0;
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 659:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 660:../uvc.c      **** 							 if(getData != 0){
 661:../uvc.c      **** 								 dataIdx++;
 662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 663:../uvc.c      **** 							 }
 664:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 665:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 666:../uvc.c      **** 							 break;
 667:../uvc.c      **** 						 case ExtExRefCtlID10:
 668:../uvc.c      **** 							 dataIdx = 0;
 669:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 670:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 672:../uvc.c      **** 							 if(WDRflag)
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 674:../uvc.c      **** 							 else
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 676:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 677:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 678:../uvc.c      **** 						 case ExtCamMCtlID12:
 679:../uvc.c      **** 							 /*
 680:../uvc.c      **** 							 dataIdx = 0;
 681:../uvc.c      **** 							 if(Data0 <= 3){
 682:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 683:../uvc.c      **** 								 Data1 = Data0;
 684:../uvc.c      **** 							 }else{
 685:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 686:../uvc.c      **** 								 Data1 = Data0-4;
 687:../uvc.c      **** 							 }
 688:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 689:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 690:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 692:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 693:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 694:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 695:../uvc.c      **** 							 */
 696:../uvc.c      **** 							 break;
 697:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 698:../uvc.c      **** 							 dataIdx = 0;
 699:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 700:../uvc.c      **** 								 Data0 = 1;
 701:../uvc.c      **** 							 }else{ //save current sensor parameters.
 702:../uvc.c      **** 								 Data0 = 0;
 703:../uvc.c      **** 							 }
 704:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 706:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 708:../uvc.c      **** 							 break;
 709:../uvc.c      **** 						 case ExtI2CCtlID15:
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 712:../uvc.c      **** 					 		 }
 713:../uvc.c      **** 					 		I2CCmdHandler();
 714:../uvc.c      **** 							 break;
 715:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 716:../uvc.c      **** 							 dataIdx = 0;
 717:../uvc.c      **** #if 0 //seperate version
 718:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 719:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 720:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 721:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 722:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 723:../uvc.c      **** 							 }else{ //disable BLD window
 724:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 725:../uvc.c      **** 							 }
 726:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 727:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 728:../uvc.c      **** 							 dataIdx++;
 729:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 730:../uvc.c      **** 							 dataIdx++;
 731:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 732:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 733:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 734:../uvc.c      **** 							 dataIdx++;
 735:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 737:../uvc.c      **** #else //combination version
 738:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 739:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 740:../uvc.c      **** 						     /* end test */
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 742:../uvc.c      **** 							 dataIdx++;
 743:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 744:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 745:../uvc.c      **** 							 getData1 = Data1;
 746:../uvc.c      **** #endif
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 748:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 749:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 750:../uvc.c      **** 							 break;
 751:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 752:../uvc.c      **** 							 dataIdx = 0;
 753:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 755:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 756:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 757:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 758:../uvc.c      **** 							 break;
 759:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 760:../uvc.c      **** 							 dataIdx = 0;
 761:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 766:../uvc.c      **** 							 break;
 767:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 768:../uvc.c      **** 							 dataIdx = 0;
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 770:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 771:../uvc.c      **** 							  if(Data0&0x80){
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 773:../uvc.c      **** 							  }else{
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 775:../uvc.c      **** 							  }
 776:../uvc.c      **** 							 Data1 |= ~0x03;
 777:../uvc.c      **** 							 Data1 &= 0xC7;
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 779:../uvc.c      **** 						  	 dataIdx++;
 780:../uvc.c      **** 
 781:../uvc.c      **** 							 Data0 = (Data0 << 2);
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 783:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 784:../uvc.c      **** 
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 786:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 787:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 788:../uvc.c      **** 
 789:../uvc.c      **** 							 break;
 790:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 791:../uvc.c      **** 							 dataIdx = 0;
 792:../uvc.c      **** 
 793:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 795:../uvc.c      **** 							 dataIdx++;
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 797:../uvc.c      **** 							 dataIdx++;
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 799:../uvc.c      **** 							 dataIdx++;
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 801:../uvc.c      **** 							 dataIdx++;
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 803:../uvc.c      **** 							 dataIdx++;
 804:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 805:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 806:../uvc.c      **** 
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 809:../uvc.c      **** 							 break;
 810:../uvc.c      **** 						 case SaturCtlID6:
 811:../uvc.c      **** 							 dataIdx = 0;
 812:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 813:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 815:../uvc.c      **** 							 dataIdx++;
 816:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 817:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 820:../uvc.c      **** 							 break;
 821:../uvc.c      **** 
 822:../uvc.c      **** 						 case WBTLevCtlID11:
 823:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 824:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 825:../uvc.c      **** 							 dataIdx = 0;
 826:../uvc.c      **** 
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 829:../uvc.c      **** 							 dataIdx++;
 830:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 831:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 832:../uvc.c      **** 
 833:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 834:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 836:../uvc.c      **** 							 break;
 837:../uvc.c      **** 						 case MFreqCtlID4:
 838:../uvc.c      **** 							 dataIdx = 0;
 839:../uvc.c      **** 							 Data0 = Data0 - 1;
 840:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 841:../uvc.c      **** 								 Data0 = 0;
 842:../uvc.c      **** 							 else if(Data0 >2)
 843:../uvc.c      **** 								 Data0 = 1;
 844:../uvc.c      **** 
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 847:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 848:../uvc.c      **** 
 849:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 851:../uvc.c      **** 							 break;
 852:../uvc.c      **** 					 	 case BLCCtlID0:
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 854:../uvc.c      **** 							 if(Data0 == 3)
 855:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 856:../uvc.c      **** 							 else
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 859:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 860:../uvc.c      **** 							 {
 861:../uvc.c      **** 								 if(Data0 < 2){
 862:../uvc.c      **** 					 				 ;//Data0 += 4;
 863:../uvc.c      **** 					 			 }else{
 864:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 865:../uvc.c      **** 									Data0 = 0; //set to default.
 866:../uvc.c      **** 					 			 }
 867:../uvc.c      **** 					 		 }
 868:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 869:../uvc.c      **** 							 dataIdx = 0;
 870:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 874:../uvc.c      **** 
 875:../uvc.c      **** 					 		 break;
 876:../uvc.c      **** 						 default:
 877:../uvc.c      **** 							 dataIdx = 0;
 878:../uvc.c      **** 
 879:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 880:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 881:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 882:../uvc.c      **** 
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 885:../uvc.c      **** 							 break;
 886:../uvc.c      **** 					 }
 887:../uvc.c      **** 			   }else{
 888:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 889:../uvc.c      **** 			   }
 890:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 891:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 892:../uvc.c      **** #endif
 893:../uvc.c      **** 
 894:../uvc.c      **** 			  break;
 895:../uvc.c      **** 		  default:
 896:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 897:../uvc.c      **** 			  break;
 898:../uvc.c      **** 		 }
 899:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 900:../uvc.c      **** }
 901:../uvc.c      **** /************** CT control requests handler *************************/
 902:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 903:../uvc.c      **** 
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 905:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 906:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 907:../uvc.c      ****     uint16_t readCount;
 908:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 909:../uvc.c      ****     uint16_t diff, value, diffRd;
 910:../uvc.c      ****     uint8_t i, shutter, index;
 911:../uvc.c      ****     diff = 0xffff;
 912:../uvc.c      ****     shutter = 1;
 913:../uvc.c      ****     index = 1;
 914:../uvc.c      **** 
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 916:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 917:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 918:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 919:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 920:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 921:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 922:../uvc.c      **** #endif
 923:../uvc.c      ****     reqData = bRequest;
 924:../uvc.c      **** 
 925:../uvc.c      ****     switch (bRequest)
 926:../uvc.c      **** 		 {
 927:../uvc.c      **** 
 928:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 932:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 933:../uvc.c      **** 			  break;
 934:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 935:../uvc.c      **** 
 936:../uvc.c      **** 			 switch(CtrlID)
 937:../uvc.c      **** 			 {
 938:../uvc.c      **** 				 default:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 942:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 943:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 944:../uvc.c      **** 					 break;
 945:../uvc.c      **** 			 }
 946:../uvc.c      **** 
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 948:../uvc.c      **** 
 949:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 950:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 951:../uvc.c      **** #endif
 952:../uvc.c      **** 			  break;
 953:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 957:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 958:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 960:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 961:../uvc.c      **** 			  break;
 962:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 966:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 967:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 968:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 969:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 970:../uvc.c      **** 			  break;
 971:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 975:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 976:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 977:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 978:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 979:../uvc.c      **** 			  break;
 980:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 983:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 984:../uvc.c      **** 			  Len = 1;
 985:../uvc.c      **** 			  break;
 986:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 990:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 993:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 994:../uvc.c      **** 			  break;
 995:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 996:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 997:../uvc.c      **** 			  glEp0Buffer, &readCount);
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1000:../uvc.c      **** 			  value = Data1;
1001:../uvc.c      **** 
1002:../uvc.c      **** 			  switch(CtrlID)
1003:../uvc.c      **** 			  {
1004:../uvc.c      **** 		  	      case AutoExMCtlID1:
1005:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1006:../uvc.c      **** 
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1009:../uvc.c      **** 				    getData = glEp0Buffer[0];
1010:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1011:../uvc.c      **** 		  		    switch (getData){
1012:../uvc.c      **** 						case 1:
1013:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1014:../uvc.c      **** 							break;
1015:../uvc.c      **** 						case 2:
1016:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1017:../uvc.c      **** 							dataIdx = 0;
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1019:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1020:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1021:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1022:../uvc.c      **** 
1023:../uvc.c      **** 							break;
1024:../uvc.c      **** 						case 4:
1025:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1026:../uvc.c      **** 							break;
1027:../uvc.c      **** 						case 8:
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1029:../uvc.c      **** 			  		    	dataIdx = 0;
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1031:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1032:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1033:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1034:../uvc.c      **** 							break;
1035:../uvc.c      **** 		  		    }
1036:../uvc.c      **** #if 0
1037:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1038:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1039:../uvc.c      **** 						  dataIdx = 0;
1040:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1041:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1042:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1043:../uvc.c      **** 		  		    }
1044:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1045:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1046:../uvc.c      **** 		  		    }
1047:../uvc.c      **** #endif
1048:../uvc.c      **** 				    break;
1049:../uvc.c      **** 
1050:../uvc.c      **** 			  	  case ExTmACtlID3:
1051:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1052:../uvc.c      **** 
1053:../uvc.c      **** 					  value = (value << 8)|Data0;
1054:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1055:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1056:../uvc.c      **** 					  {
1057:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1058:../uvc.c      **** 						  {
1059:../uvc.c      **** 							if(value > ShutValueArry[i]){
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1061:../uvc.c      **** 							}else{
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1063:../uvc.c      **** 							}
1064:../uvc.c      **** 							  if(diff > diffRd){
1065:../uvc.c      **** 								  diff = diffRd;
1066:../uvc.c      **** 								  index = i;
1067:../uvc.c      **** 							  }
1068:../uvc.c      **** 						  }
1069:../uvc.c      **** 						  shutter = shutter+index;
1070:../uvc.c      **** 
1071:../uvc.c      **** 						  dataIdx = 0;
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1073:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1074:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1075:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1076:../uvc.c      **** 
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1081:../uvc.c      **** 					  }else{
1082:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1083:../uvc.c      **** 					  }
1084:../uvc.c      **** 					  getData = glEp0Buffer[0];
1085:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1086:../uvc.c      **** 					  break;
1087:../uvc.c      **** 			  	  case IriACtlID7:
1088:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1089:../uvc.c      **** 					  {
1090:../uvc.c      **** 							 dataIdx = 0;
1091:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1092:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1094:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1095:../uvc.c      **** 
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1099:../uvc.c      **** 					  }else{
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1101:../uvc.c      **** 					  }
1102:../uvc.c      **** 					  getData = glEp0Buffer[0];
1103:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1104:../uvc.c      **** 
1105:../uvc.c      **** 					  break;
1106:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1107:../uvc.c      **** 					  getData = glEp0Buffer[0];
1108:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1109:../uvc.c      **** #if 1
1110:../uvc.c      **** 					  dataIdx = 0;
1111:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1112:../uvc.c      **** 					  if(getData == 1)
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1114:../uvc.c      **** 					  else if(getData == 0xff)
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1116:../uvc.c      **** 					  else
1117:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1118:../uvc.c      **** 					  //dataIdx++;
1119:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1120:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1121:../uvc.c      **** #endif
1122:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1123:../uvc.c      **** 					  break;
1124:../uvc.c      **** 
1125:../uvc.c      **** 			  	  default:
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1128:../uvc.c      **** 			  		 break;
1129:../uvc.c      **** 			  }
1130:../uvc.c      **** 			  break;
1131:../uvc.c      **** 		  default:
1132:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1133:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1134:../uvc.c      **** 			  break;
1135:../uvc.c      **** 		 }
1136:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1137:../uvc.c      **** 
1138:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1139:../uvc.c      **** }
1140:../uvc.c      **** 
1141:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1142:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1143:../uvc.c      **** {
1144:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1145:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1146:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1147:../uvc.c      **** 
1148:../uvc.c      ****     CtrlID = BrgtCtlID1;
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1150:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1151:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1152:../uvc.c      ****     Data1 = Data0;
1153:../uvc.c      **** 
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1155:../uvc.c      ****     if(Data1&0x80){
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1157:../uvc.c      ****     }else{
1158:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1159:../uvc.c      ****     }
1160:../uvc.c      ****     Data0 = (Data0 << 2);
1161:../uvc.c      **** 
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1163:../uvc.c      **** 
1164:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1166:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1167:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1169:../uvc.c      **** 
1170:../uvc.c      ****     CtrlID = ConsCtlID2;
1171:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1172:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1173:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1174:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1175:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1177:../uvc.c      **** 
1178:../uvc.c      ****     CtrlID = HueCtlID5;
1179:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1180:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1181:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1190:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1191:../uvc.c      **** 
1192:../uvc.c      ****     CtrlID = SaturCtlID6;
1193:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1194:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1195:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1196:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1199:../uvc.c      **** 
1200:../uvc.c      ****     CtrlID = ShapCtlID7;
1201:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1202:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1203:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1204:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1205:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1207:../uvc.c      **** 
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1209:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1210:../uvc.c      **** 	return;
1211:../uvc.c      **** }
1212:../uvc.c      **** 
1213:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1214:../uvc.c      **** void
1215:../uvc.c      **** CyFxUVCAddHeader (
1216:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1217:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1218:../uvc.c      ****         )
1219:../uvc.c      **** {
1220:../uvc.c      ****     /* Copy header to buffer */
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1222:../uvc.c      **** 
1223:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1224:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1225:../uvc.c      ****     {
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1227:../uvc.c      ****     }
1228:../uvc.c      **** }
1229:../uvc.c      **** 
1230:../uvc.c      **** 
1231:../uvc.c      **** /* Application Error Handler */
1232:../uvc.c      **** void
1233:../uvc.c      **** CyFxAppErrorHandler (
1234:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1235:../uvc.c      ****         )
1236:../uvc.c      **** {
1237:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1238:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1239:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1240:../uvc.c      **** 
1241:../uvc.c      ****        This function can be modified to take additional error handling actions such
1242:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1243:../uvc.c      ****      */
1244:../uvc.c      ****     for (;;)
1245:../uvc.c      ****     {
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
1248:../uvc.c      ****     }
1249:../uvc.c      **** }
1250:../uvc.c      **** 
1251:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1252:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1253:../uvc.c      ****  */
1254:../uvc.c      **** static void
1255:../uvc.c      **** CyFxUVCApplnAbortHandler (
1256:../uvc.c      ****         void)
1257:../uvc.c      **** {
1258:../uvc.c      **** 	uint32_t flag;
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1260:../uvc.c      **** 	{
1261:../uvc.c      ****         /* Clear the Video Stream Request Event */
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1263:../uvc.c      **** 
1264:../uvc.c      ****         /* Set Video Stream Abort Event */
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1266:../uvc.c      **** 	}
1267:../uvc.c      **** }
1268:../uvc.c      **** 
1269:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1270:../uvc.c      **** static void
1271:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1272:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1273:../uvc.c      ****         uint16_t             evdata  /* Event data */
1274:../uvc.c      ****         )
1275:../uvc.c      **** {
1276:../uvc.c      ****     switch (evtype)
1277:../uvc.c      ****     {
1278:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1279:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1280:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1281:../uvc.c      ****             gpif_initialized = 0;
1282:../uvc.c      ****             streamingStarted = CyFalse;
1283:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1284:../uvc.c      ****             break;
1285:../uvc.c      **** 
1286:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1287:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1288:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1289:../uvc.c      ****             gpif_initialized = 0;
1290:../uvc.c      ****             streamingStarted = CyFalse;
1291:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1292:../uvc.c      ****             break;
1293:../uvc.c      **** 
1294:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1295:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1296:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1297:../uvc.c      ****             gpif_initialized = 0;
1298:../uvc.c      ****             isUsbConnected = CyFalse;
1299:../uvc.c      ****             streamingStarted = CyFalse;
1300:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1301:../uvc.c      ****             break;
1302:../uvc.c      **** 
1303:../uvc.c      **** #ifdef BACKFLOW_DETECT
1304:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1305:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1306:../uvc.c      ****             break;
1307:../uvc.c      **** #endif
1308:../uvc.c      **** 
1309:../uvc.c      ****         default:
1310:../uvc.c      ****             break;
1311:../uvc.c      ****     }
1312:../uvc.c      **** }
1313:../uvc.c      **** 
1314:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1315:../uvc.c      **** static CyBool_t
1316:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1317:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1318:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1319:../uvc.c      ****         )
1320:../uvc.c      **** {
1321:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1322:../uvc.c      ****     uint32_t status;
1323:../uvc.c      **** 
1324:../uvc.c      ****     /* Obtain Request Type and Request */
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1330:../uvc.c      **** 
1331:../uvc.c      ****     /* Check for UVC Class Requests */
1332:../uvc.c      ****     switch (bmReqType)
1333:../uvc.c      ****     {
1334:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1335:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1336:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1337:../uvc.c      ****             switch (wIndex & 0xFF)
1338:../uvc.c      ****             {
1339:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1340:../uvc.c      ****                     {
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
1342:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1343:../uvc.c      ****                                 CYU3P_EVENT_OR);
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1345:../uvc.c      ****                         {
1346:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1347:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1348:../uvc.c      ****                         }
1349:../uvc.c      ****                     }
1350:../uvc.c      ****                     break;
1351:../uvc.c      **** 
1352:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1353:../uvc.c      ****                     {
1354:../uvc.c      ****                         uvcHandleReq = CyTrue;
1355:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1356:../uvc.c      ****                                 CYU3P_EVENT_OR);
1357:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1358:../uvc.c      ****                         {
1359:../uvc.c      ****                             /* Error handling */
1360:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1361:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1362:../uvc.c      ****                         }
1363:../uvc.c      ****                     }
1364:../uvc.c      ****                     break;
1365:../uvc.c      **** 
1366:../uvc.c      ****                 default:
1367:../uvc.c      ****                     break;
1368:../uvc.c      ****             }
1369:../uvc.c      ****             break;
1370:../uvc.c      **** 
1371:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1372:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1373:../uvc.c      ****             {
1374:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1375:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1377:../uvc.c      ****                 {
1378:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1379:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1380:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1381:../uvc.c      ****                     gpif_initialized = 0;
1382:../uvc.c      ****                     streamingStarted = CyFalse;
1383:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1385:../uvc.c      ****                     CyU3PBusyWait (100);
1386:../uvc.c      **** 
1387:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1388:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1389:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1390:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1391:../uvc.c      ****                     CyU3PBusyWait (100);
1392:../uvc.c      **** 
1393:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1394:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
1396:../uvc.c      ****                     /* Complete Control request handshake */
1397:../uvc.c      ****                     CyU3PUsbAckSetup ();
1398:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1399:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1400:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1401:../uvc.c      **** 
1402:../uvc.c      ****                 }
1403:../uvc.c      ****             }
1404:../uvc.c      ****             break;
1405:../uvc.c      **** 
1406:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1407:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1408:../uvc.c      ****             {
1409:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1410:../uvc.c      ****                 {
1411:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1412:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1413:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1414:../uvc.c      ****                 	 * has started. */
1415:../uvc.c      ****                     if (streamingStarted == CyTrue)
1416:../uvc.c      ****                     {
1417:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1418:../uvc.c      **** 
1419:../uvc.c      ****                         /* Disable the GPIF state machine. */
1420:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1421:../uvc.c      ****                         gpif_initialized = 0;
1422:../uvc.c      ****                         streamingStarted = CyFalse;
1423:../uvc.c      **** 
1424:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1426:../uvc.c      ****                         CyU3PBusyWait (100);
1427:../uvc.c      **** 
1428:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1429:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1430:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1431:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1432:../uvc.c      ****                         CyU3PBusyWait (100);
1433:../uvc.c      **** 
1434:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1435:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1436:../uvc.c      **** 
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
1438:../uvc.c      ****                         /* Complete Control request handshake */
1439:../uvc.c      ****                         CyU3PUsbAckSetup ();
1440:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1441:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1442:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1443:../uvc.c      ****                     }
1444:../uvc.c      ****                     else
1445:../uvc.c      ****                     {
1446:../uvc.c      ****                         uvcHandleReq = CyTrue;
1447:../uvc.c      ****                         CyU3PUsbAckSetup ();
1448:../uvc.c      ****                     }
1449:../uvc.c      ****                 }
1450:../uvc.c      ****             }
1451:../uvc.c      ****             break;
1452:../uvc.c      **** 
1453:../uvc.c      ****         default:
1454:../uvc.c      ****             break;
1455:../uvc.c      ****     }
1456:../uvc.c      **** 
1457:../uvc.c      ****     /* Return status of request handling to the USB driver */
1458:../uvc.c      ****     return uvcHandleReq;
1459:../uvc.c      **** }
1460:../uvc.c      **** 
1461:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1462:../uvc.c      **** 
1463:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1464:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1465:../uvc.c      ****  */
1466:../uvc.c      **** void
1467:../uvc.c      **** CyFxUvcApplnDmaCallback (
1468:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1469:../uvc.c      ****         CyU3PDmaCbType_t      type,
1470:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1471:../uvc.c      ****         )
1472:../uvc.c      **** {
1473:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1474:../uvc.c      **** #if 1
1475:../uvc.c      ****     CyU3PReturnStatus_t status;
1476:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1477:../uvc.c      ****     {
1478:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1479:../uvc.c      ****             {
1480:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1481:../uvc.c      ****                 fb++;
1482:../uvc.c      ****             }
1483:../uvc.c      ****             else
1484:../uvc.c      ****             {
1485:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1486:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1487:../uvc.c      ****                 pb++;
1488:../uvc.c      ****                 pbc = input->buffer_p.count;
1489:../uvc.c      ****                // hitFV = CyTrue;
1490:../uvc.c      ****             }
1491:../uvc.c      **** 
1492:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1493:../uvc.c      ****             prodCount++;
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1495:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1496:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1497:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1498:../uvc.c      ****             {
1499:../uvc.c      ****                 prodCount--;
1500:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1501:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1502:../uvc.c      ****             }
1503:../uvc.c      ****     }
1504:../uvc.c      **** #endif
1505:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1506:../uvc.c      ****     {
1507:../uvc.c      ****         consCount++;
1508:../uvc.c      ****         streamingStarted = CyTrue;
1509:../uvc.c      ****     }
1510:../uvc.c      **** }
1511:../uvc.c      **** 
1512:../uvc.c      **** /*
1513:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1514:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1515:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1516:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1517:../uvc.c      ****  * to commit the buffer.
1518:../uvc.c      ****  */
1519:../uvc.c      **** static uint8_t
1520:../uvc.c      **** CyFxUvcAppCommitEOF (
1521:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1522:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1523:../uvc.c      ****         )
1524:../uvc.c      **** {
1525:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1526:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1527:../uvc.c      **** 
1528:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1529:../uvc.c      **** 
1530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1531:../uvc.c      ****     {
1532:../uvc.c      ****         switch (stateId)
1533:../uvc.c      ****         {
1534:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1535:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1536:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1537:../uvc.c      ****                 break;
1538:../uvc.c      **** 
1539:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1540:../uvc.c      ****                 socket = 0;
1541:../uvc.c      ****                 break;
1542:../uvc.c      **** 
1543:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1544:../uvc.c      ****                 socket = 1;
1545:../uvc.c      ****                 break;
1546:../uvc.c      **** 
1547:../uvc.c      ****             default:
1548:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1549:../uvc.c      ****                 /* Unexpected current state. Return error. */
1550:../uvc.c      ****                 return 1;
1551:../uvc.c      ****         }
1552:../uvc.c      ****     }
1553:../uvc.c      **** 
1554:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1555:../uvc.c      ****     {
1556:../uvc.c      ****         switch (stateId)
1557:../uvc.c      ****         {
1558:../uvc.c      **** #ifndef CAM720
1559:../uvc.c      **** #ifdef GPIFIIM
1560:../uvc.c      ****             case 13:
1561:../uvc.c      ****             case 24:
1562:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1563:../uvc.c      ****                 break;
1564:../uvc.c      **** 
1565:../uvc.c      ****             case 8:
1566:../uvc.c      ****                 socket = 0;
1567:../uvc.c      ****                 break;
1568:../uvc.c      **** 
1569:../uvc.c      ****             case 20:
1570:../uvc.c      ****                 socket = 1;
1571:../uvc.c      ****                 break;
1572:../uvc.c      **** #else
1573:../uvc.c      ****             case 11:
1574:../uvc.c      ****             case 18:
1575:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1576:../uvc.c      ****                 break;
1577:../uvc.c      **** 
1578:../uvc.c      ****             case 8:
1579:../uvc.c      ****                 socket = 0;
1580:../uvc.c      ****                 break;
1581:../uvc.c      **** 
1582:../uvc.c      ****             case 15:
1583:../uvc.c      ****                 socket = 1;
1584:../uvc.c      ****                 break;
1585:../uvc.c      **** #endif
1586:../uvc.c      **** #else
1587:../uvc.c      ****             case 11:
1588:../uvc.c      ****             case 18:
1589:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1590:../uvc.c      ****                 break;
1591:../uvc.c      **** 
1592:../uvc.c      ****             case 8:
1593:../uvc.c      ****                 socket = 0;
1594:../uvc.c      ****                 break;
1595:../uvc.c      **** 
1596:../uvc.c      ****             case 15:
1597:../uvc.c      ****                 socket = 1;
1598:../uvc.c      ****                 break;
1599:../uvc.c      **** 
1600:../uvc.c      **** #endif
1601:../uvc.c      ****              default:
1602:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1603:../uvc.c      ****                 /* Unexpected current state. Return error. */
1604:../uvc.c      ****                return 1;
1605:../uvc.c      ****         }
1606:../uvc.c      ****     }
1607:../uvc.c      **** 
1608:../uvc.c      ****     if (socket != 0xFF)
1609:../uvc.c      ****     {
1610:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1611:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1612:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1613:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1614:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1615:../uvc.c      ****         {
1616:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1617:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1618:../uvc.c      ****         }
1619:../uvc.c      ****     }
1620:../uvc.c      **** 
1621:../uvc.c      ****     return 0;
1622:../uvc.c      **** }
1623:../uvc.c      **** 
1624:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1625:../uvc.c      **** void
1626:../uvc.c      **** CyFxGpifCB (
1627:../uvc.c      ****         CyU3PGpifEventType event,
1628:../uvc.c      ****         uint8_t currentState
1629:../uvc.c      ****         )
1630:../uvc.c      **** {
1631:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1632:../uvc.c      ****     {
1633:../uvc.c      ****         hitFV = CyTrue;
1634:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1635:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1636:../uvc.c      ****     }
1637:../uvc.c      **** }
1638:../uvc.c      **** 
1639:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1640:../uvc.c      **** static void
1641:../uvc.c      **** CyFxUVCApplnDebugInit (
1642:../uvc.c      ****         void)
1643:../uvc.c      **** {
1644:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1645:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1646:../uvc.c      **** 
1647:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1648:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1649:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1650:../uvc.c      ****     {
1651:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1652:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1653:../uvc.c      ****     }
1654:../uvc.c      **** 
1655:../uvc.c      ****     /* Set UART Configuration */
1656:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1657:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1658:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1659:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1660:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1661:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1662:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1663:../uvc.c      **** 
1664:../uvc.c      ****     /* Set the UART configuration */
1665:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1667:../uvc.c      ****     {
1668:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1669:../uvc.c      ****     }
1670:../uvc.c      **** 
1671:../uvc.c      ****     /* Set the UART transfer */
1672:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1673:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1674:../uvc.c      ****     {
1675:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1676:../uvc.c      ****     }
1677:../uvc.c      **** 
1678:../uvc.c      ****     /* Initialize the Debug logger module. */
1679:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1680:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1681:../uvc.c      ****     {
1682:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1683:../uvc.c      ****     }
1684:../uvc.c      **** 
1685:../uvc.c      ****     /* Disable log message headers. */
1686:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1687:../uvc.c      **** }
1688:../uvc.c      **** 
1689:../uvc.c      **** /* I2C initialization. */
1690:../uvc.c      **** //static void
1691:../uvc.c      **** void
1692:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1693:../uvc.c      **** {
1694:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1695:../uvc.c      ****     CyU3PReturnStatus_t status;
1696:../uvc.c      **** 
1697:../uvc.c      ****     status = CyU3PI2cInit ();
1698:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1699:../uvc.c      ****     {
1700:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1701:../uvc.c      ****         CyFxAppErrorHandler (status);
1702:../uvc.c      ****     }
1703:../uvc.c      **** 
1704:../uvc.c      ****     /*  Set I2C Configuration */
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1706:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1708:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1709:../uvc.c      **** 
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1711:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1712:../uvc.c      ****     {
1713:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1714:../uvc.c      ****         CyFxAppErrorHandler (status);
1715:../uvc.c      ****     }
1716:../uvc.c      **** }
1717:../uvc.c      **** 
1718:../uvc.c      **** #ifdef BACKFLOW_DETECT
1719:../uvc.c      **** static void CyFxUvcAppPibCallback (
1720:../uvc.c      ****         CyU3PPibIntrType cbType,
1721:../uvc.c      ****         uint16_t cbArg)
1722:../uvc.c      **** {
1723:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1724:../uvc.c      ****     {
1725:../uvc.c      ****         if (!back_flow_detected)
1726:../uvc.c      ****         {
1727:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1728:../uvc.c      ****             back_flow_detected = 1;
1729:../uvc.c      ****         }
1730:../uvc.c      ****     }
1731:../uvc.c      **** }
1732:../uvc.c      **** #endif
1733:../uvc.c      **** 
1734:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1735:../uvc.c      **** static void
1736:../uvc.c      **** CyFxUvcAppDebugCallback (
1737:../uvc.c      ****         CyU3PDmaChannel   *handle,
1738:../uvc.c      ****         CyU3PDmaCbType_t   type,
1739:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1740:../uvc.c      **** {
1741:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1742:../uvc.c      ****     {
1743:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1744:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1745:../uvc.c      ****     }
1746:../uvc.c      **** }
1747:../uvc.c      **** #endif
1748:../uvc.c      **** 
1749:../uvc.c      **** #if 0
1750:../uvc.c      **** static void CyFxAppIntEpCb(
1751:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1752:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1753:../uvc.c      **** 		uint8_t  ebNum)
1754:../uvc.c      **** 		{
1755:../uvc.c      **** 			//CyBool_t value;
1756:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1757:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1758:../uvc.c      **** 
1759:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1760:../uvc.c      **** 		}
1761:../uvc.c      **** #endif
1762:../uvc.c      **** 
1763:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1764:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1765:../uvc.c      ****    configures the DMA module for the UVC Application */
1766:../uvc.c      **** static void
1767:../uvc.c      **** CyFxUVCApplnInit (void)
1768:../uvc.c      **** {
1769:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1770:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1771:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1772:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1773:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1774:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1775:../uvc.c      **** 
1776:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1777:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1778:../uvc.c      **** 
1779:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1780:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1781:../uvc.c      **** #endif
1782:../uvc.c      **** 
1783:../uvc.c      ****     /* Create UVC event group */
1784:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1785:../uvc.c      ****     if (apiRetStatus != 0)
1786:../uvc.c      ****     {
1787:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1788:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1789:../uvc.c      ****     }
1790:../uvc.c      **** 
1791:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1792:../uvc.c      ****     CyFxUvcAppPTZInit ();
1793:../uvc.c      **** #endif
1794:../uvc.c      **** 
1795:../uvc.c      ****     isUsbConnected = CyFalse;
1796:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1797:../uvc.c      **** 
1798:../uvc.c      ****     /* Init the GPIO module */
1799:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1800:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1801:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1802:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1803:../uvc.c      ****     gpioClock.halfDiv    = 0;
1804:../uvc.c      **** 
1805:../uvc.c      ****     /* Initialize Gpio interface */
1806:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1807:../uvc.c      ****     if (apiRetStatus != 0)
1808:../uvc.c      ****     {
1809:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1810:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1811:../uvc.c      ****     }
1812:../uvc.c      **** 
1813:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1814:../uvc.c      ****      * must use GpioOverride to configure it */
1815:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1816:../uvc.c      ****     if (apiRetStatus != 0)
1817:../uvc.c      ****     {
1818:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1819:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1820:../uvc.c      ****     }
1821:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1822:../uvc.c      ****     if (apiRetStatus != 0)
1823:../uvc.c      ****     {
1824:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1825:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1826:../uvc.c      ****     }
1827:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1828:../uvc.c      ****     if (apiRetStatus != 0)
1829:../uvc.c      ****     {
1830:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1831:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1832:../uvc.c      ****     }
1833:../uvc.c      **** 
1834:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1836:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1837:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1838:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1839:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1841:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1842:../uvc.c      ****     {
1843:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1844:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1845:../uvc.c      ****     }
1846:../uvc.c      **** 
1847:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1848:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1849:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1852:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1856:../uvc.c      ****     {
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1858:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1859:../uvc.c      ****     }
1860:../uvc.c      **** 
1861:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1862:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1863:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1864:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1865:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1866:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1867:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1870:../uvc.c      ****     {
1871:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1872:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1873:../uvc.c      ****     }
1874:../uvc.c      **** 
1875:../uvc.c      ****     /* Initialize the P-port. */
1876:../uvc.c      ****     pibclock.clkDiv      = 2;
1877:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1878:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1879:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1880:../uvc.c      **** 
1881:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1882:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1883:../uvc.c      ****     {
1884:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1885:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1886:../uvc.c      ****     }
1887:../uvc.c      **** 
1888:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1889:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1890:../uvc.c      **** 
1891:../uvc.c      **** #ifdef BACKFLOW_DETECT
1892:../uvc.c      ****     back_flow_detected = 0;
1893:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1894:../uvc.c      **** #endif
1895:../uvc.c      **** 
1896:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1897:../uvc.c      ****     SensorReset ();
1898:../uvc.c      ****     SensorInit ();
1899:../uvc.c      **** 
1900:../uvc.c      ****     /* USB initialization. */
1901:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1902:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1903:../uvc.c      ****     {
1904:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1905:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1906:../uvc.c      ****     }
1907:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1908:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1909:../uvc.c      **** 
1910:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1911:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1912:../uvc.c      **** 
1913:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1914:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1915:../uvc.c      **** 
1916:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1917:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1918:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1919:../uvc.c      **** 
1920:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1921:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1922:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1923:../uvc.c      **** 
1924:../uvc.c      ****     /* Configuration descriptors. */
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1926:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1927:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1928:../uvc.c      **** 
1929:../uvc.c      ****     /* String Descriptors */
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1931:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1933:../uvc.c      **** 
1934:../uvc.c      ****     /* Configure the status interrupt endpoint.
1935:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1936:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1937:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1938:../uvc.c      ****      */
1939:../uvc.c      ****     endPointConfig.enable   = 1;
1940:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1941:../uvc.c      ****     endPointConfig.pcktSize = 64;
1942:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1943:../uvc.c      ****     endPointConfig.streams  = 0;
1944:../uvc.c      ****     endPointConfig.burstLen = 1;
1945:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1947:../uvc.c      ****     {
1948:../uvc.c      ****         /* Error Handling */
1949:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1950:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1951:../uvc.c      ****     }
1952:../uvc.c      **** 
1953:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1954:../uvc.c      ****     dmaInterConfig.size           = 1024;
1955:../uvc.c      ****     dmaInterConfig.count          = 1;
1956:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1957:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1958:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1959:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1960:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1961:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1962:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1963:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1964:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1965:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1966:../uvc.c      ****             &dmaInterConfig);
1967:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1968:../uvc.c      ****     {
1969:../uvc.c      ****         /* Error handling */
1970:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1971:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1972:../uvc.c      ****     }
1973:../uvc.c      **** 
1974:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1975:../uvc.c      ****     if (glInterStaBuffer == 0)
1976:../uvc.c      ****     {
1977:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1978:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1979:../uvc.c      ****     }
1980:../uvc.c      **** 
1981:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1982:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1983:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1984:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1985:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1986:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1987:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1988:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1989:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1990:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
1991:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1992:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1993:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1994:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
1996:../uvc.c      ****             &dmaMultiConfig);
1997:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1998:../uvc.c      ****     {
1999:../uvc.c      ****         /* Error handling */
2000:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2001:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2002:../uvc.c      ****     }
2003:../uvc.c      **** 
2004:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2005:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2006:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2007:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2008:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2009:../uvc.c      ****      */
2010:../uvc.c      **** 
2011:../uvc.c      ****     endPointConfig.enable   = 1;
2012:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2013:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2014:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2015:../uvc.c      ****     endPointConfig.streams  = 0;
2016:../uvc.c      ****     endPointConfig.burstLen = 1;
2017:../uvc.c      **** 
2018:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2019:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2020:../uvc.c      ****     {
2021:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2022:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2023:../uvc.c      ****     }
2024:../uvc.c      **** 
2025:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2026:../uvc.c      **** 
2027:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2029:../uvc.c      ****     {
2030:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2031:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2032:../uvc.c      ****     }
2033:../uvc.c      **** 
2034:../uvc.c      ****     channelConfig.size           = 1024;
2035:../uvc.c      ****     channelConfig.count          = 1;
2036:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2037:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2038:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2039:../uvc.c      ****     channelConfig.prodHeader     = 0;
2040:../uvc.c      ****     channelConfig.prodFooter     = 0;
2041:../uvc.c      ****     channelConfig.consHeader     = 0;
2042:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2043:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2044:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2045:../uvc.c      **** 
2046:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2047:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2048:../uvc.c      ****     {
2049:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2050:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2051:../uvc.c      ****     }
2052:../uvc.c      **** 
2053:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2054:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2055:../uvc.c      ****     {
2056:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2057:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2058:../uvc.c      ****     }
2059:../uvc.c      **** 
2060:../uvc.c      ****     channelConfig.size           = 1024;
2061:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2062:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2063:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2064:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2065:../uvc.c      ****     channelConfig.prodHeader     = 0;
2066:../uvc.c      ****     channelConfig.prodFooter     = 0;
2067:../uvc.c      ****     channelConfig.consHeader     = 0;
2068:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2069:../uvc.c      ****     channelConfig.notification   = 0;
2070:../uvc.c      ****     channelConfig.cb             = 0;
2071:../uvc.c      **** 
2072:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2073:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2074:../uvc.c      ****     {
2075:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2076:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2077:../uvc.c      ****     }
2078:../uvc.c      **** 
2079:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2080:../uvc.c      ****     if (glDebugRspBuffer == 0)
2081:../uvc.c      ****     {
2082:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2083:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2084:../uvc.c      ****     }
2085:../uvc.c      **** #endif
2086:../uvc.c      **** 
2087:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2088:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2089:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2090:../uvc.c      ****     {
2091:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2092:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2093:../uvc.c      ****     }
2094:../uvc.c      **** 
2095:../uvc.c      ****     CyU3PBusyWait(100);
2096:../uvc.c      **** 
2097:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2098:../uvc.c      **** 
2099:../uvc.c      ****     endPointConfig.enable   = 1;
2100:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2101:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2102:../uvc.c      ****     {
2103:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2104:../uvc.c      ****     	endPointConfig.burstLen = 16;
2105:../uvc.c      ****     }
2106:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2107:../uvc.c      ****     {
2108:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2109:../uvc.c      ****     	endPointConfig.burstLen = 1;
2110:../uvc.c      ****     }
2111:../uvc.c      ****     endPointConfig.streams  = 0;
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2113:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2114:../uvc.c      ****     {
2115:../uvc.c      ****         /* Error Handling */
2116:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2117:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2118:../uvc.c      ****     }
2119:../uvc.c      **** #if 0    //for still image method 3 using
2120:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2121:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2122:../uvc.c      ****     {
2123:../uvc.c      ****         /* Error Handling */
2124:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2125:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2126:../uvc.c      ****     }
2127:../uvc.c      **** #endif
2128:../uvc.c      **** 
2129:../uvc.c      **** }
2130:../uvc.c      **** 
2131:../uvc.c      **** /*
2132:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2133:../uvc.c      ****  * streaming session is started.
2134:../uvc.c      ****  */
2135:../uvc.c      **** static void
2136:../uvc.c      **** CyFxUvcAppGpifInit (
2137:../uvc.c      ****         void)
2138:../uvc.c      **** {
2139:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2140:../uvc.c      **** 
2141:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2142:../uvc.c      ****     {
2143:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2144:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2145:../uvc.c      ****     }
2146:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2147:../uvc.c      ****     {
2148:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2149:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2150:../uvc.c      ****     }
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2152:../uvc.c      ****     {
2153:../uvc.c      ****         /* Error Handling */
2154:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2155:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2156:../uvc.c      ****     }
2157:../uvc.c      **** 
2158:../uvc.c      ****     /* Start the state machine from the designated start state. */
2159:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2160:../uvc.c      ****     {
2161:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2162:../uvc.c      ****     }
2163:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2164:../uvc.c      ****     {
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2166:../uvc.c      ****     }
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2168:../uvc.c      ****     {
2169:../uvc.c      ****         /* Error Handling */
2170:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2171:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2172:../uvc.c      ****     }
2173:../uvc.c      **** }
2174:../uvc.c      **** 
2175:../uvc.c      **** /*
2176:../uvc.c      ****  * Entry function for the UVC Application Thread
2177:../uvc.c      ****  */
2178:../uvc.c      **** 
2179:../uvc.c      **** uint32_t posTick;
2180:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2181:../uvc.c      **** 
2182:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2183:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2184:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2185:../uvc.c      **** }
2186:../uvc.c      **** 
2187:../uvc.c      **** 
2188:../uvc.c      **** void
2189:../uvc.c      **** UVCAppThread_Entry (
2190:../uvc.c      ****         uint32_t input)
2191:../uvc.c      **** {
2192:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2193:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2194:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2195:../uvc.c      ****     uint8_t i = 0;
2196:../uvc.c      ****     uint32_t flag;
2197:../uvc.c      ****     uint32_t prinflag = 0;
2198:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2199:../uvc.c      ****     uint32_t frameCnt = 0;
2200:../uvc.c      **** #endif
2201:../uvc.c      ****     /* Initialize the Uart Debug Module */
2202:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2203:../uvc.c      **** 
2204:../uvc.c      ****     /* Initialize the I2C interface */
2205:../uvc.c      **** 	while (i++ < 6){
2206:../uvc.c      **** 		CyU3PThreadSleep(500);
2207:../uvc.c      **** 	}
2208:../uvc.c      **** 
2209:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2210:../uvc.c      **** 
2211:../uvc.c      ****     /* Initialize the UVC Application */
2212:../uvc.c      ****     CyFxUVCApplnInit ();
2213:../uvc.c      **** 
2214:../uvc.c      ****     /*
2215:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2216:../uvc.c      **** 
2217:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2218:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2219:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2220:../uvc.c      **** 
2221:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2222:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2223:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2224:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2225:../uvc.c      **** 
2226:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2227:../uvc.c      ****        of handling the abort request.
2228:../uvc.c      ****      */
2229:../uvc.c      **** 
2230:../uvc.c      ****     for (;;)
2231:../uvc.c      ****     {
2232:../uvc.c      ****         /* Waiting for the Video Stream Event */
2233:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2234:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2235:../uvc.c      ****         {
2236:../uvc.c      **** #if 0 //test for new firmware no video bring up
2237:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2238:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2239:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2240:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2241:../uvc.c      ****             {
2242:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2243:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2244:../uvc.c      ****                 {
2245:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2246:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2247:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2248:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2249:../uvc.c      **** #endif
2250:../uvc.c      **** #endif
2251:../uvc.c      ****                     }
2252:../uvc.c      ****                 else
2253:../uvc.c      ****                 {
2254:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2255:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2256:../uvc.c      **** #ifdef USB_LOWRES_IMG
2257:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2258:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2259:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2260:../uvc.c      **** #endif
2261:../uvc.c      **** #endif
2262:../uvc.c      ****                 }
2263:../uvc.c      **** 
2264:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2265:../uvc.c      ****                 prodCount++;
2266:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2267:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2268:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2269:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2270:../uvc.c      ****                 {
2271:../uvc.c      ****                     prodCount--;
2272:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2273:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2274:../uvc.c      ****                 }
2275:../uvc.c      ****             }
2276:../uvc.c      **** #endif
2277:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2278:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2279:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2280:../uvc.c      ****             {
2281:../uvc.c      ****             	if(0&&(prinflag == 0)){
2282:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2283:../uvc.c      ****             		prinflag = 1;
2284:../uvc.c      ****             	}
2285:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2286:../uvc.c      ****             	fb=0;
2287:../uvc.c      ****             	pb=0;
2288:../uvc.c      ****             	pbc=0;
2289:../uvc.c      ****                 prodCount = 0;
2290:../uvc.c      ****                 consCount = 0;
2291:../uvc.c      ****                 hitFV     = CyFalse;
2292:../uvc.c      **** 
2293:../uvc.c      **** #ifdef BACKFLOW_DETECT
2294:../uvc.c      ****                 back_flow_detected = 0;
2295:../uvc.c      **** #endif
2296:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2297:../uvc.c      ****                 frameCnt++;
2298:../uvc.c      **** #endif
2299:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2300:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2301:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2302:../uvc.c      ****                 //}
2303:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2305:../uvc.c      ****                 if(stiflag){
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
2307:../uvc.c      ****                 	stiflag = CyFalse;
2308:../uvc.c      ****                 }else{
2309:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2310:../uvc.c      ****                 }
2311:../uvc.c      ****                 /* Reset the DMA channel. */
2312:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2313:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2314:../uvc.c      ****                 {
2315:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2316:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2317:../uvc.c      ****                 }
2318:../uvc.c      **** 
2319:../uvc.c      ****                 /* Start Channel Immediately */
2320:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2321:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2322:../uvc.c      ****                 {
2323:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2324:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2325:../uvc.c      ****                 }
2326:../uvc.c      **** 
2327:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2328:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2329:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2330:../uvc.c      ****                 }
2331:../uvc.c      ****         }
2332:../uvc.c      ****         else
2333:../uvc.c      ****         {
2334:../uvc.c      ****             /* If we have a stream abort request pending. */
2335:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2336:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2337:../uvc.c      ****             {
2338:../uvc.c      ****                 hitFV     = CyFalse;
2339:../uvc.c      ****                 prodCount = 0;
2340:../uvc.c      ****                 consCount = 0;
2341:../uvc.c      ****                 if(0&&(prinflag == 0)){
2342:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2343:../uvc.c      ****                 	prinflag = 1;
2344:../uvc.c      ****                 }
2345:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2346:../uvc.c      ****                 fb=0;
2347:../uvc.c      ****                 pb=0;
2348:../uvc.c      ****                 pbc=0;
2349:../uvc.c      **** 
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2351:../uvc.c      ****                 {
2352:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2353:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2354:../uvc.c      ****                     {
2355:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2356:../uvc.c      ****                     }
2357:../uvc.c      **** 
2358:../uvc.c      ****                     /* Flush the Endpoint memory */
2359:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2360:../uvc.c      ****                 }
2361:../uvc.c      **** 
2362:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2363:../uvc.c      ****             }
2364:../uvc.c      ****             else
2365:../uvc.c      ****             {
2366:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2367:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2368:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2369:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2370:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2371:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2372:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2373:../uvc.c      ****                 {
2374:../uvc.c      ****                     /* Error handling */
2375:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2376:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2377:../uvc.c      ****                 }
2378:../uvc.c      **** 
2379:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2380:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2381:../uvc.c      ****                 {
2382:../uvc.c      ****                     //for start up of the AF Lens
2383:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
2385:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2386:../uvc.c      ****                     CyU3PThreadSleep(500);
2387:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2388:../uvc.c      ****                    	CyU3PThreadSleep(300);
2389:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
2391:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2392:../uvc.c      ****                     CyU3PThreadSleep(500);
2393:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2394:../uvc.c      ****                     gpif_initialized = CyTrue;
2395:../uvc.c      ****                     CyU3PThreadSleep(200);
2396:../uvc.c      ****                     
2397:../uvc.c      ****                 }
2398:../uvc.c      ****                 else
2399:../uvc.c      ****                 {
2400:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2401:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2402:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2403:../uvc.c      ****                 }
2404:../uvc.c      ****             }
2405:../uvc.c      ****         }
2406:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2407:../uvc.c      **** 
2408:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2409:../uvc.c      ****         CyU3PThreadRelinquish ();
2410:../uvc.c      ****     }
2411:../uvc.c      **** }
2412:../uvc.c      **** 
2413:../uvc.c      **** /*
2414:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2415:../uvc.c      ****  */
2416:../uvc.c      **** 
2417:../uvc.c      **** static void
2418:../uvc.c      **** UVCHandleProcessingUnitRqts (
2419:../uvc.c      ****         void)
2420:../uvc.c      **** {
2421:../uvc.c      ****     uint8_t CtrlAdd;
2422:../uvc.c      **** #ifdef DbgInfo
2423:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2424:../uvc.c      **** #endif
2425:../uvc.c      ****     switch (wValue)
2426:../uvc.c      ****     {
2427:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2428:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2429:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2430:../uvc.c      ****     		break;
2431:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2432:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2433:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2434:../uvc.c      ****     		break;
2435:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2436:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2437:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2438:../uvc.c      **** 			break;
2439:../uvc.c      **** 
2440:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2441:../uvc.c      **** 
2442:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2443:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2444:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2445:../uvc.c      ****       		break;
2446:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2447:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2448:../uvc.c      ****      		ControlHandle(HueCtlID5);
2449:../uvc.c      ****      		break;
2450:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2451:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2452:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2453:../uvc.c      ****           		break;
2454:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2455:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2456:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2457:../uvc.c      ****           		break;
2458:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2459:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2460:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2461:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2462:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2463:../uvc.c      ****     		break;
2464:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2465:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2466:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2467:../uvc.c      ****     		break;
2468:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2469:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2470:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2471:../uvc.c      ****     		break;
2472:../uvc.c      **** 
2473:../uvc.c      ****         default:
2474:../uvc.c      ****             /*
2475:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2476:../uvc.c      ****              * other controls.
2477:../uvc.c      ****              */
2478:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2479:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2480:../uvc.c      ****             break;
2481:../uvc.c      ****     }
2482:../uvc.c      **** }
2483:../uvc.c      **** 
2484:../uvc.c      **** /*
2485:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2486:../uvc.c      ****  */
2487:../uvc.c      **** static void
2488:../uvc.c      **** UVCHandleCameraTerminalRqts (
2489:../uvc.c      ****         void)
2490:../uvc.c      **** {
2491:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2492:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2493:../uvc.c      ****     uint16_t readCount;
2494:../uvc.c      ****     uint16_t zoomVal;
2495:../uvc.c      ****     int32_t  panVal, tiltVal;
2496:../uvc.c      ****     CyBool_t sendData = CyFalse;
2497:../uvc.c      **** #endif
2498:../uvc.c      ****     uint8_t CtrlAdd;
2499:../uvc.c      **** 
2500:../uvc.c      ****     switch (wValue)
2501:../uvc.c      ****     {
2502:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2503:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2504:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2505:../uvc.c      ****     		break;
2506:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2507:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2508:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2509:../uvc.c      ****     		break;
2510:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2511:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2512:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2513:../uvc.c      **** 			break;
2514:../uvc.c      **** 
2515:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2516:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2517:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2518:../uvc.c      **** 			break;
2519:../uvc.c      **** 
2520:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2521:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2522:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2523:../uvc.c      ****       		break;
2524:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2525:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2526:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2527:../uvc.c      ****      		break;
2528:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2529:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2530:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2531:../uvc.c      ****           		break;
2532:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2533:../uvc.c      ****           		break;
2534:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2535:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2536:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2537:../uvc.c      ****      		break;
2538:../uvc.c      **** 
2539:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2540:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2541:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2542:../uvc.c      ****     		break;
2543:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2544:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2545:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2546:../uvc.c      ****     		break;
2547:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2548:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2549:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2550:../uvc.c      ****     		break;
2551:../uvc.c      **** 
2552:../uvc.c      ****         default:
2553:../uvc.c      ****             /*
2554:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2555:../uvc.c      ****              * other controls.
2556:../uvc.c      ****              */
2557:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2558:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2559:../uvc.c      ****             break;
2560:../uvc.c      ****     }
2561:../uvc.c      **** 
2562:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2563:../uvc.c      ****     switch (wValue)
2564:../uvc.c      ****     {
2565:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2566:../uvc.c      ****             switch (bRequest)
2567:../uvc.c      ****             {
2568:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2569:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2570:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2571:../uvc.c      ****                     break;
2572:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2573:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2574:../uvc.c      ****                     sendData = CyTrue;
2575:../uvc.c      ****                     break;
2576:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2577:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2578:../uvc.c      ****                     sendData = CyTrue;
2579:../uvc.c      ****                     break;
2580:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2581:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2582:../uvc.c      ****                     sendData = CyTrue;
2583:../uvc.c      ****                     break;
2584:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2585:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2586:../uvc.c      ****                     sendData = CyTrue;
2587:../uvc.c      ****                     break;
2588:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2589:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2590:../uvc.c      ****                     sendData = CyTrue;
2591:../uvc.c      ****                     break;
2592:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2593:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2594:../uvc.c      ****                             glEp0Buffer, &readCount);
2595:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2596:../uvc.c      ****                     {
2597:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2598:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2599:../uvc.c      ****                     }
2600:../uvc.c      ****                     break;
2601:../uvc.c      ****                 default:
2602:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2603:../uvc.c      ****                     break;
2604:../uvc.c      ****             }
2605:../uvc.c      **** 
2606:../uvc.c      ****             if (sendData)
2607:../uvc.c      ****             {
2608:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2609:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2610:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2611:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2612:../uvc.c      ****             }
2613:../uvc.c      ****             break;
2614:../uvc.c      **** 
2615:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2616:../uvc.c      ****             switch (bRequest)
2617:../uvc.c      ****             {
2618:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2619:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2620:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2621:../uvc.c      ****                     break;
2622:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2623:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2624:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2625:../uvc.c      ****                     sendData = CyTrue;
2626:../uvc.c      ****                     break;
2627:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2628:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2629:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2630:../uvc.c      ****                     sendData = CyTrue;
2631:../uvc.c      ****                     break;
2632:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2633:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2634:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2635:../uvc.c      ****                     sendData = CyTrue;
2636:../uvc.c      ****                     break;
2637:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2638:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2639:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2640:../uvc.c      ****                     sendData = CyTrue;
2641:../uvc.c      ****                     break;
2642:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2643:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2644:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2645:../uvc.c      ****                     sendData = CyTrue;
2646:../uvc.c      ****                     break;
2647:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2648:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2649:../uvc.c      ****                             glEp0Buffer, &readCount);
2650:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2651:../uvc.c      ****                     {
2652:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2653:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2654:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2655:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2656:../uvc.c      **** 
2657:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2658:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2659:../uvc.c      ****                     }
2660:../uvc.c      ****                     break;
2661:../uvc.c      ****                 default:
2662:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2663:../uvc.c      ****                     break;
2664:../uvc.c      ****             }
2665:../uvc.c      **** 
2666:../uvc.c      ****             if (sendData)
2667:../uvc.c      ****             {
2668:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2669:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2670:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2671:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2672:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2673:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2674:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2675:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2676:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2677:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2678:../uvc.c      ****             }
2679:../uvc.c      ****             break;
2680:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2681:../uvc.c      ****         default:
2682:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2683:../uvc.c      ****             break;
2684:../uvc.c      ****     }
2685:../uvc.c      **** #endif
2686:../uvc.c      **** }
2687:../uvc.c      **** 
2688:../uvc.c      **** /*
2689:../uvc.c      ****  * Handler for UVC Interface control requests.
2690:../uvc.c      ****  */
2691:../uvc.c      **** static void
2692:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2693:../uvc.c      ****         void)
2694:../uvc.c      **** {
2695:../uvc.c      **** 
2696:../uvc.c      ****     switch (wValue)
2697:../uvc.c      ****     {
2698:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2699:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2700:../uvc.c      ****     		break;
2701:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2702:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2703:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2704:../uvc.c      ****     		break;
2705:../uvc.c      ****     	default:
2706:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2707:../uvc.c      ****      		break;
2708:../uvc.c      ****     }
2709:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2710:../uvc.c      **** 
2711:../uvc.c      **** }
2712:../uvc.c      **** 
2713:../uvc.c      **** /*
2714:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2715:../uvc.c      ****  */
2716:../uvc.c      **** static void
2717:../uvc.c      **** UVCHandleExtensionUnitRqts (
2718:../uvc.c      ****         void)
2719:../uvc.c      **** {
2720:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2721:../uvc.c      **** 
2722:../uvc.c      **** #ifdef DbgInfo
2723:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2724:../uvc.c      **** #endif
2725:../uvc.c      ****     switch (wValue)
2726:../uvc.c      ****     {
2727:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2728:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2729:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2730:../uvc.c      ****     		break;
2731:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2732:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2733:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2734:../uvc.c      ****     		break;
2735:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2736:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2737:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2738:../uvc.c      ****      		break;
2739:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2740:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2741:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2742:../uvc.c      ****     		break;
2743:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2744:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2745:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2746:../uvc.c      ****     		break;
2747:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2748:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2749:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2750:../uvc.c      ****      		break;
2751:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2752:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2753:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2754:../uvc.c      ****     		break;
2755:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2756:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2757:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2758:../uvc.c      ****     		break;
2759:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2760:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2761:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2762:../uvc.c      ****      		break;
2763:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2764:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2765:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2766:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2767:../uvc.c      ****     		}else/* no support for 1080p camera */
2768:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2769:../uvc.c      ****     		break;
2770:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2771:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2772:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2773:../uvc.c      ****     		break;
2774:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2775:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2776:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2777:../uvc.c      ****     		break;
2778:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2779:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2780:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2781:../uvc.c      ****     		//break;
2782:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2783:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2784:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2785:../uvc.c      ****     		break;
2786:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2787:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2788:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2789:../uvc.c      ****     		break;
2790:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2791:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2792:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2793:../uvc.c      ****     		break;
2794:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2795:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2796:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2797:../uvc.c      ****     		break;
2798:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2799:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2800:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2801:../uvc.c      ****     		break;
2802:../uvc.c      ****    	default:
2803:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2804:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2805:../uvc.c      ****     		break;
2806:../uvc.c      ****     }
2807:../uvc.c      **** 
2808:../uvc.c      **** }
2809:../uvc.c      **** 
2810:../uvc.c      **** /*
2811:../uvc.c      ****  * Handler for the video streaming control requests.
2812:../uvc.c      ****  */
2813:../uvc.c      **** static void
2814:../uvc.c      **** UVCHandleVideoStreamingRqts (
2815:../uvc.c      ****         void)
2816:../uvc.c      **** {
2817:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2818:../uvc.c      ****     uint16_t readCount;
2819:../uvc.c      **** 
2820:../uvc.c      ****     switch (wValue)
2821:../uvc.c      ****     {
2822:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2823:../uvc.c      ****             switch (bRequest)
2824:../uvc.c      ****             {
2825:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2826:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2827:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2828:../uvc.c      ****                     break;
2829:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2830:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2831:../uvc.c      ****                     glEp0Buffer[1] = 0;
2832:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2833:../uvc.c      ****                     break;
2834:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2835:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2836:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2837:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2838:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2839:../uvc.c      ****                     {
2840:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2841:../uvc.c      ****                     }
2842:../uvc.c      ****                     else
2843:../uvc.c      ****                     {
2844:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2845:../uvc.c      ****                     }
2846:../uvc.c      ****                     break;
2847:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2848:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2849:../uvc.c      ****                             glCommitCtrl, &readCount);
2850:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2851:../uvc.c      ****                     {
2852:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2853:../uvc.c      ****                         {
2854:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2855:../uvc.c      ****                                active data structure. */
2856:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2857:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2858:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2859:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2860:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2861:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2862:../uvc.c      ****                         }
2863:../uvc.c      ****                     }
2864:../uvc.c      ****                     break;
2865:../uvc.c      ****                 default:
2866:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2867:../uvc.c      ****                     break;
2868:../uvc.c      ****             }
2869:../uvc.c      ****             break;
2870:../uvc.c      **** 
2871:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2872:../uvc.c      ****             switch (bRequest)
2873:../uvc.c      ****             {
2874:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2875:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2877:../uvc.c      ****                     break;
2878:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2879:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2880:../uvc.c      ****                     glEp0Buffer[1] = 0;
2881:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2882:../uvc.c      ****                     break;
2883:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2884:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2885:../uvc.c      ****                     {
2886:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2887:../uvc.c      ****                     }
2888:../uvc.c      ****                     else
2889:../uvc.c      ****                     {
2890:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2891:../uvc.c      ****                     }
2892:../uvc.c      ****                     break;
2893:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2894:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2895:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2896:../uvc.c      ****                        */
2897:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2898:../uvc.c      ****                             glCommitCtrl, &readCount);
2899:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2900:../uvc.c      ****                     {
2901:../uvc.c      **** #if 0
2902:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2903:../uvc.c      ****                         {
2904:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2905:../uvc.c      ****                         }
2906:../uvc.c      ****                         else
2907:../uvc.c      ****                         {
2908:../uvc.c      ****                             SensorScaling_VGA ();
2909:../uvc.c      ****                         }
2910:../uvc.c      **** #endif
2911:../uvc.c      ****                         /* We can start streaming video now. */
2912:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2913:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2914:../uvc.c      ****                         {
2915:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2916:../uvc.c      ****                         }
2917:../uvc.c      ****                     }
2918:../uvc.c      ****                     break;
2919:../uvc.c      **** 
2920:../uvc.c      ****                 default:
2921:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2922:../uvc.c      ****                     break;
2923:../uvc.c      ****             }
2924:../uvc.c      ****             break;
2925:../uvc.c      **** 
2926:../uvc.c      **** /* still image streaming handler */
2927:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2928:../uvc.c      ****                 switch (bRequest)
2929:../uvc.c      ****                 {
2930:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2931:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2932:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2933:../uvc.c      ****                         break;
2934:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2935:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2936:../uvc.c      ****                         glEp0Buffer[1] = 0;
2937:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2938:../uvc.c      ****                         break;
2939:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2940:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2941:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2942:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2943:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2944:../uvc.c      ****                         {
2945:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2946:../uvc.c      ****                         }
2947:../uvc.c      ****                         else
2948:../uvc.c      ****                         {
2949:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2950:../uvc.c      ****                         }
2951:../uvc.c      ****                         break;
2952:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2953:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2954:../uvc.c      ****                                 glCommitCtrl, &readCount);
2955:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2956:../uvc.c      ****                         {
2957:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
2958:../uvc.c      ****                             {
2959:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2960:../uvc.c      ****                                    active data structure. */
2961:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
2962:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
2963:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
2964:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
2965:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
2967:../uvc.c      ****                             }
2968:../uvc.c      ****                         }
2969:../uvc.c      ****                         break;
2970:../uvc.c      ****                     default:
2971:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2972:../uvc.c      ****                         break;
2973:../uvc.c      ****                 }
2974:../uvc.c      ****                 break;
2975:../uvc.c      **** 
2976:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
2977:../uvc.c      ****                 switch (bRequest)
2978:../uvc.c      ****                 {
2979:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2980:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2981:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2982:../uvc.c      ****                         break;
2983:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2984:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2985:../uvc.c      ****                         glEp0Buffer[1] = 0;
2986:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2987:../uvc.c      ****                         break;
2988:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2989:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2990:../uvc.c      ****                         {
2991:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2992:../uvc.c      ****                         }
2993:../uvc.c      ****                         else
2994:../uvc.c      ****                         {
2995:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2996:../uvc.c      ****                         }
2997:../uvc.c      ****                         break;
2998:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2999:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3000:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3001:../uvc.c      ****                            */
3002:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3003:../uvc.c      ****                                 glCommitCtrl, &readCount);
3004:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3005:../uvc.c      ****                         {
3006:../uvc.c      ****     #if 0
3007:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3008:../uvc.c      ****                             {
3009:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3010:../uvc.c      ****                             }
3011:../uvc.c      ****                             else
3012:../uvc.c      ****                             {
3013:../uvc.c      ****                                 SensorScaling_VGA ();
3014:../uvc.c      ****                             }
3015:../uvc.c      ****     #endif
3016:../uvc.c      ****                             /* We can start streaming video now. */
3017:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3018:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3019:../uvc.c      ****                             {
3020:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3021:../uvc.c      ****                             }
3022:../uvc.c      ****                         }
3023:../uvc.c      ****                         break;
3024:../uvc.c      **** 
3025:../uvc.c      ****                     default:
3026:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3027:../uvc.c      ****                         break;
3028:../uvc.c      ****                 }
3029:../uvc.c      ****                 break;
3030:../uvc.c      **** 
3031:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3032:../uvc.c      ****                 switch (bRequest)
3033:../uvc.c      ****                 {
3034:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3035:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3036:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3037:../uvc.c      ****                         break;
3038:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3039:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3040:../uvc.c      ****                         glEp0Buffer[1] = 0;
3041:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3042:../uvc.c      ****                         break;
3043:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3044:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3045:../uvc.c      ****                         {
3046:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3047:../uvc.c      ****                         }
3048:../uvc.c      ****                         else
3049:../uvc.c      ****                         {
3050:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3051:../uvc.c      ****                         }
3052:../uvc.c      ****                         break;
3053:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3054:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3055:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3056:../uvc.c      ****                            */
3057:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3058:../uvc.c      ****                                 glCommitCtrl, &readCount);
3059:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3060:../uvc.c      ****                         {
3061:../uvc.c      ****     #if 0
3062:../uvc.c      ****                             /* We can start streaming video now. */
3063:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3064:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3065:../uvc.c      ****                             {
3066:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3067:../uvc.c      ****                             }
3068:../uvc.c      ****     #endif
3069:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3070:../uvc.c      ****                         }else{
3071:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3072:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3073:../uvc.c      ****                         }
3074:../uvc.c      ****                         break;
3075:../uvc.c      **** 
3076:../uvc.c      ****                     default:
3077:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3078:../uvc.c      ****                         break;
3079:../uvc.c      ****                 }
3080:../uvc.c      ****                 break;
3081:../uvc.c      **** 
3082:../uvc.c      ****         default:
3083:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3084:../uvc.c      ****             break;
3085:../uvc.c      ****     }
3086:../uvc.c      **** }
3087:../uvc.c      **** 
3088:../uvc.c      **** /*
3089:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3090:../uvc.c      ****  */
3091:../uvc.c      **** void
3092:../uvc.c      **** UVCAppEP0Thread_Entry (
3093:../uvc.c      ****         uint32_t input)
3094:../uvc.c      **** {
3095:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3096:../uvc.c      ****     uint32_t eventFlag;
3097:../uvc.c      **** 	CyBool_t value;
3098:../uvc.c      **** 	CyBool_t *valueptr = &value;
3099:../uvc.c      **** 
3100:../uvc.c      **** 
3101:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3102:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3103:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3104:../uvc.c      **** 
3105:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3106:../uvc.c      **** #endif
3107:../uvc.c      **** 
3108:../uvc.c      ****     /* for interrupt status test */
3109:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3110:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3111:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3112:../uvc.c      **** 
3113:../uvc.c      ****     for (;;)
3114:../uvc.c      ****     {
3115:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3116:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3117:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3118:../uvc.c      ****         {
3119:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3120:../uvc.c      ****             if (!isUsbConnected)
3121:../uvc.c      ****             {
3122:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3123:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3124:../uvc.c      ****                 {
3125:../uvc.c      ****                     isUsbConnected = CyTrue;
3126:../uvc.c      ****                 }
3127:../uvc.c      ****             }
3128:../uvc.c      **** //#ifdef DbgInfo
3129:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3130:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3131:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3132:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3133:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3134:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3135:../uvc.c      **** //#endif
3136:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3137:../uvc.c      ****             {
3138:../uvc.c      ****             	switch ((wIndex >> 8))
3139:../uvc.c      ****                 {
3140:../uvc.c      **** 
3141:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3142:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3143:../uvc.c      ****                         break;
3144:../uvc.c      **** 
3145:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3146:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3147:../uvc.c      ****                         break;
3148:../uvc.c      **** 
3149:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3150:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3151:../uvc.c      ****                         break;
3152:../uvc.c      **** 
3153:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3154:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3155:../uvc.c      ****                         break;
3156:../uvc.c      **** 
3157:../uvc.c      ****                     default:
3158:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3159:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3160:../uvc.c      ****                         break;
3161:../uvc.c      ****                 }
3162:../uvc.c      ****             }
3163:../uvc.c      **** 
3164:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3165:../uvc.c      ****             {
3166:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3167:../uvc.c      **** 
3168:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3169:../uvc.c      ****                 {
3170:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3171:../uvc.c      ****                 }
3172:../uvc.c      ****                 else
3173:../uvc.c      ****                 {
3174:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3175:../uvc.c      ****                 }
3176:../uvc.c      ****             }
3177:../uvc.c      **** 
3178:../uvc.c      ****             /* handle interrupt status event */
3179:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3180:../uvc.c      ****             {
3181:../uvc.c      **** 
3182:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3183:../uvc.c      ****             	/** preparing interrupt status data **/
3184:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3185:../uvc.c      ****             	if(0&&!value){ //for HW sanp button check.
3186:../uvc.c      ****             		for(;;); //pause
3187:../uvc.c      ****             	}
3188:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3189:../uvc.c      **** 
3190:../uvc.c      **** #if 1 //for real button
3191:../uvc.c      **** 				if(value&&(!snapButFlag)){
3192:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3193:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3194:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3195:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3196:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3197:../uvc.c      **** 
3198:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3199:../uvc.c      **** 					interStabuf.size   = 1024;
3200:../uvc.c      **** 					interStabuf.status = 0;
3201:../uvc.c      **** 
3202:../uvc.c      **** 					interStabuf.count = 4;
3203:../uvc.c      **** 
3204:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3205:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3206:../uvc.c      **** 
3207:../uvc.c      **** 					/** send a interrupt status data **/
3208:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3209:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3210:../uvc.c      **** 					{
3211:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3212:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3213:../uvc.c      **** 					}
3214:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3215:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3216:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3217:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3218:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3219:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3220:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3221:../uvc.c      **** 
3222:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3223:../uvc.c      **** 					interStabuf.size   = 1024;
3224:../uvc.c      **** 					interStabuf.status = 0;
3225:../uvc.c      **** 
3226:../uvc.c      **** 					interStabuf.count = 4;
3227:../uvc.c      **** 
3228:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3229:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3230:../uvc.c      **** 
3231:../uvc.c      **** 					/** send a interrupt status data **/
3232:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3233:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3234:../uvc.c      **** 					{
3235:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3236:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3237:../uvc.c      **** 					}
3238:../uvc.c      **** 
3239:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3240:../uvc.c      **** 					stiflag = CyTrue;
3241:../uvc.c      **** 				}
3242:../uvc.c      **** #else			//for botton simulation
3243:../uvc.c      **** 				if(snapButFlag == 0x0f){
3244:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3245:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3246:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3247:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3248:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3249:../uvc.c      **** 
3250:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3251:../uvc.c      **** 					interStabuf.size   = 1024;
3252:../uvc.c      **** 					interStabuf.status = 0;
3253:../uvc.c      **** 
3254:../uvc.c      **** 					interStabuf.count = 4;
3255:../uvc.c      **** 
3256:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3257:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3258:../uvc.c      **** 
3259:../uvc.c      **** 					/** send a interrupt status data **/
3260:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3261:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3262:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3263:../uvc.c      **** 					{
3264:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3265:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3266:../uvc.c      **** 					}
3267:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3268:../uvc.c      **** 
3269:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3270:../uvc.c      **** 				}else if(!snapButFlag){
3271:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3272:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3273:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3274:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3275:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3276:../uvc.c      **** 
3277:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3278:../uvc.c      **** 					interStabuf.size   = 1024;
3279:../uvc.c      **** 					interStabuf.status = 0;
3280:../uvc.c      **** 
3281:../uvc.c      **** 					interStabuf.count = 4;
3282:../uvc.c      **** 
3283:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3284:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3285:../uvc.c      **** 
3286:../uvc.c      **** 					/** send a interrupt status data **/
3287:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3288:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3289:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3290:../uvc.c      **** 					{
3291:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3292:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3293:../uvc.c      **** 					}
3294:../uvc.c      **** 
3295:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3296:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3297:../uvc.c      **** 				}
3298:../uvc.c      **** #endif
3299:../uvc.c      **** 
3300:../uvc.c      ****             }
3301:../uvc.c      **** 
3302:../uvc.c      **** 
3303:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3304:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3305:../uvc.c      ****             {
3306:../uvc.c      ****                 /* Get the command buffer */
3307:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3308:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3309:../uvc.c      ****                 {
3310:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3311:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3312:../uvc.c      ****                 }
3313:../uvc.c      **** 
3314:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3315:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3316:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3317:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3318:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3319:../uvc.c      ****                  * register value high byte and register value low byte.
3320:../uvc.c      ****                  */
3321:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3322:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3323:../uvc.c      ****                 {
3324:../uvc.c      ****                     if (dmaInfo.count == 3)
3325:../uvc.c      ****                     {
3326:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3327:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3328:../uvc.c      ****                         dmaInfo.count = 3;
3329:../uvc.c      ****                     }
3330:../uvc.c      ****                     else if (dmaInfo.count == 4)
3331:../uvc.c      ****                     {
3332:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3333:../uvc.c      ****                         {
3334:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3335:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3336:../uvc.c      ****                         }
3337:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3338:../uvc.c      ****                     }
3339:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3340:../uvc.c      ****                 }
3341:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3342:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3343:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3344:../uvc.c      ****                  */
3345:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3346:../uvc.c      ****                 {
3347:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3348:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3349:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3350:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3351:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3352:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3353:../uvc.c      ****                         	break;
3354:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3355:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3356:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3357:../uvc.c      ****                         	break;*/
3358:../uvc.c      ****                     dmaInfo.count -= 2;
3359:../uvc.c      ****                 }
3360:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3361:../uvc.c      ****                 else
3362:../uvc.c      ****                 {
3363:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3364:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3365:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3366:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3367:../uvc.c      ****                 }
3368:../uvc.c      **** 
3369:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3370:../uvc.c      ****                 dmaInfo.size   = 1024;
3371:../uvc.c      ****                 dmaInfo.status = 0;
3372:../uvc.c      **** 
3373:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3374:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3375:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3376:../uvc.c      ****                 {
3377:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3378:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3379:../uvc.c      ****                 }
3380:../uvc.c      **** 
3381:../uvc.c      ****                 /* Wait until the response has gone out. */
3382:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3383:../uvc.c      **** 
3384:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3385:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3386:../uvc.c      ****                 {
3387:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3388:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3389:../uvc.c      ****                 }
3390:../uvc.c      ****             }
3391:../uvc.c      **** #endif
3392:../uvc.c      ****         }
3393:../uvc.c      ****         /* Allow other ready threads to run. */
3394:../uvc.c      ****         CyU3PThreadRelinquish ();
3395:../uvc.c      ****     }
3396:../uvc.c      **** }
3397:../uvc.c      **** 
3398:../uvc.c      **** /*
3399:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3400:../uvc.c      ****  * added 10/2013
3401:../uvc.c      ****  */
3402:../uvc.c      **** /*
3403:../uvc.c      **** static uint8_t timeDelay[64] = {
3404:../uvc.c      **** 
3405:../uvc.c      **** };
3406:../uvc.c      **** */
3407:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3407 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3408:../uvc.c      **** 
3409:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3410:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3411:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3412:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3413:../uvc.c      **** 	VdstateDes *lcStaDes;
3414:../uvc.c      **** 	uint32_t flag = 0;
3415:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3416:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3417:../uvc.c      **** 	uint8_t i;
3418:../uvc.c      **** 	uint16_t delaytime;
3419:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3420:../uvc.c      **** 
3421:../uvc.c      **** #if 0 //for test the command queue
3422:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3423:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3424:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3425:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3426:../uvc.c      **** 		lcCmdDes += 1;
3427:../uvc.c      **** 	}
3428:../uvc.c      **** #endif
3429:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3430:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3430 0
  36 0004 00229FE5 		ldr	r2, .L22
3414:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3414 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3407:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3407 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3430 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 E8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3414:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3414 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3430 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3431:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3431 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 CC119FE5 		ldr	r1, .L22+8
  71 0044 CC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3432:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3432 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3433:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3433 0
  79 005c AC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3434:../uvc.c      **** 
3435:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3435 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3436:../uvc.c      ****         /* Allow other ready threads to run. */
3437:../uvc.c      **** 
3438:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3438 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3435:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3435 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3439:../uvc.c      **** 	}
3440:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3440 0
  92 0078 98019FE5 		ldr	r0, .L22+12
  93 007c 98119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 88719FE5 		ldr	r7, .L22+20
  99 0094 88B19FE5 		ldr	fp, .L22+24
3441:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3442:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3443:../uvc.c      **** 	//CyU3PThreadSleep(100);
3444:../uvc.c      **** 	//SetCurCmd();
3445:../uvc.c      **** 	/*********** the loop of the thread ***********/
3446:../uvc.c      **** 	for(;;){
3447:../uvc.c      **** 
3448:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3448 0
 101 0098 0060E0E3 		mvn	r6, #0
3449:../uvc.c      **** /*  // for test GPIO output
3450:../uvc.c      **** 		if(trigger)
3451:../uvc.c      **** 		{
3452:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3453:../uvc.c      **** 			{
3454:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3455:../uvc.c      **** 			}
3456:../uvc.c      **** 
3457:../uvc.c      **** 		}else{
3458:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3459:../uvc.c      **** 			{
3460:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3461:../uvc.c      **** 			}
3462:../uvc.c      **** 
3463:../uvc.c      **** 		}
3464:../uvc.c      **** */
3465:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3466:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3467:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3468:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3469:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3470:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3471:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3472:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3473:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3474:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3475:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3476:../uvc.c      **** #endif
3477:../uvc.c      **** 				}
3478:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3479:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3480:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3481:../uvc.c      **** 			}
3482:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3483:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3484:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3485:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3486:../uvc.c      **** 
3487:../uvc.c      **** 				/*
3488:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3489:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3490:../uvc.c      **** 				*/
3491:../uvc.c      **** 
3492:../uvc.c      **** 				/* find a available command */
3493:../uvc.c      **** 				i = 0;
3494:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3494 0
 103 009c 0090A0E3 		mov	r9, #0
3495:../uvc.c      **** 					i++;
3496:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3497:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3498:../uvc.c      **** 				}
3499:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3500:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3501:../uvc.c      **** 					i = lcCmdDes->curNum;
3502:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3503:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3504:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3505:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3506:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3507:../uvc.c      **** 						case 0x20:
3508:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3509:../uvc.c      **** 							delaytime = 500;
3510:../uvc.c      **** 							break;
3511:../uvc.c      **** 						case 0x21:
3512:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3513:../uvc.c      **** 							delaytime = 500;
3514:../uvc.c      **** 							break;
3515:../uvc.c      **** 						case 0x22:
3516:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3517:../uvc.c      **** 							delaytime = 300;
3518:../uvc.c      **** 							break;
3519:../uvc.c      **** 						case 0x23:
3520:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3521:../uvc.c      **** 							delaytime = 300;
3522:../uvc.c      **** 							break;
3523:../uvc.c      **** 						default:
3524:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3525:../uvc.c      **** 							break;
3526:../uvc.c      **** 					}
3527:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3528:../uvc.c      **** 					/** timer's ticket modify **/
3529:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3530:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3531:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3532:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3533:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3534:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3535:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3536:../uvc.c      **** #endif
3537:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3538:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3539:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3540:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3541:../uvc.c      **** 						}else{
3542:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3543:../uvc.c      **** 						}
3544:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3545:../uvc.c      **** 					}else{
3546:../uvc.c      **** 						lcCmdDes->curNum ++;
3547:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3547 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3448:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3448 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 70019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3465:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3465 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3482:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3482 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3484:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3484 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3485:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3485 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3494:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3494 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3496:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3496 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3495:../uvc.c      **** 					i++;
 140              		.loc 1 3495 0
 141 00f4 011083E2 		add	r1, r3, #1
3494:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3494 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3495:../uvc.c      **** 					i++;
 144              		.loc 1 3495 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3494:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3494 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3500:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3500 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2900000A 		beq	.L6
 157              	.LVL10:
3502:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3502 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3506:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3506 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3502:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3502 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3506:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3506 0
 166 0128 20C042E2 		sub	ip, r2, #32
3502:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3502 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3503:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3503 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3504:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3504 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3505:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3505 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3506:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3506 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 58010000 		.word	.L9
 185 014c 58010000 		.word	.L9
 186 0150 A4010000 		.word	.L11
 187 0154 A4010000 		.word	.L11
 188              	.L9:
3512:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 189              		.loc 1 3512 0
 190 0158 5230A0E3 		mov	r3, #82
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3514:../uvc.c      **** 							break;
 193              		.loc 1 3514 0
 194 0160 7D1FA0E3 		mov	r1, #500
 195              	.LVL16:
 196              	.L13:
3529:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3529 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 A0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3530:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3530 0
 202 0170 98009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3537:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3537 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3546:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3546 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3547 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3537:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3537 0
 215 0190 1000000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3548:../uvc.c      **** 					}
3549:../uvc.c      **** 				}else{
3550:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3551:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3552:../uvc.c      **** 				}
3553:../uvc.c      **** 			}
3554:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3554 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3555:../uvc.c      **** /*
3556:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3557:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3558:../uvc.c      **** */
3559:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3560:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3561:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3562:../uvc.c      **** #endif
3563:../uvc.c      **** 
3564:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3565:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3566:../uvc.c      **** #if 0
3567:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3568:../uvc.c      **** 
3569:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3570:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3571:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3572:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3573:../uvc.c      **** 			    i = 0;
3574:../uvc.c      **** 				 switch(cmdCopyIdx)
3575:../uvc.c      **** 				 {
3576:../uvc.c      **** 					 case BrgtCtlID1:
3577:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3578:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3579:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3580:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3581:../uvc.c      **** 							 i++;
3582:../uvc.c      **** 						 }
3583:../uvc.c      **** 						 else{
3584:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3585:../uvc.c      **** 						 }
3586:../uvc.c      **** 
3587:../uvc.c      **** 						 CyU3PBusyWait(500);
3588:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3589:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3590:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3591:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3592:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3593:../uvc.c      **** 						 }
3594:../uvc.c      **** 						 else{
3595:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3596:../uvc.c      **** 						 }
3597:../uvc.c      **** 						 break;
3598:../uvc.c      **** 					 case HueCtlID5:
3599:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3600:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3601:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3602:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3603:../uvc.c      **** 						 }
3604:../uvc.c      **** 						 else{
3605:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3606:../uvc.c      **** 						 }
3607:../uvc.c      **** 						 break;
3608:../uvc.c      **** 					 case SaturCtlID6:
3609:../uvc.c      **** 					 case WBTLevCtlID10:
3610:../uvc.c      **** 					 default:
3611:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3612:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3613:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3614:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3615:../uvc.c      **** 						 }
3616:../uvc.c      **** 						 else{
3617:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3618:../uvc.c      **** 						 }
3619:../uvc.c      **** 						 break;
3620:../uvc.c      **** 				 }
3621:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3622:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3623:../uvc.c      **** 			}
3624:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3625:../uvc.c      **** #endif
3626:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3627:../uvc.c      **** 		/* Allow other ready threads to run. */
3628:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3629:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3629 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3630:../uvc.c      **** 		}
 224              		.loc 1 3630 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L11:
3520:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
 228              		.loc 1 3520 0
 229 01a4 8230A0E3 		mov	r3, #130
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3522:../uvc.c      **** 							break;
 232              		.loc 1 3522 0
 233 01ac 4B1FA0E3 		mov	r1, #300
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3524:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3524 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3525:../uvc.c      **** 							break;
 241              		.loc 1 3525 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L6:
3550:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 245              		.loc 1 3550 0
 246 01c0 FA1FA0E3 		mov	r1, #1000
 247 01c4 44009FE5 		ldr	r0, .L22+4
 248 01c8 FEFFFFEB 		bl	_txe_timer_change
3551:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 249              		.loc 1 3551 0
 250 01cc 3C009FE5 		ldr	r0, .L22+4
 251 01d0 FEFFFFEB 		bl	_txe_timer_activate
 252 01d4 EEFFFFEA 		b	.L17
 253              	.LVL25:
 254              	.L21:
3539:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 255              		.loc 1 3539 0
 256 01d8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3538:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 257              		.loc 1 3538 0
 258 01dc 3C9084E5 		str	r9, [r4, #60]
3539:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 259              		.loc 1 3539 0
 260 01e0 23005CE3 		cmp	ip, #35
3540:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 261              		.loc 1 3540 0
 262 01e4 20C04C82 		subhi	ip, ip, #32
 263 01e8 8CC08C80 		addhi	ip, ip, ip, asl #1
3542:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 264              		.loc 1 3542 0
 265 01ec 8CC08C90 		addls	ip, ip, ip, asl #1
3540:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 266              		.loc 1 3540 0
 267 01f0 8CC18B80 		addhi	ip, fp, ip, asl #3
3542:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 268              		.loc 1 3542 0
 269 01f4 8CC18B90 		addls	ip, fp, ip, asl #3
3540:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 270              		.loc 1 3540 0
 271 01f8 1090CC85 		strhib	r9, [ip, #16]
3542:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 272              		.loc 1 3542 0
 273 01fc 9091CC95 		strlsb	r9, [ip, #400]
3544:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 274              		.loc 1 3544 0
 275 0200 344094E5 		ldr	r4, [r4, #52]
 276              	.LVL26:
 277 0204 104085E5 		str	r4, [r5, #16]
 278 0208 E1FFFFEA 		b	.L17
 279              	.L23:
 280              		.align	2
 281              	.L22:
 282 020c 00000000 		.word	I2CCmdCb
 283 0210 00000000 		.word	I2CCmdTimer
 284 0214 00000000 		.word	.LC0
 285 0218 00000000 		.word	cmdQu
 286 021c 14000000 		.word	.LC1
 287 0220 00000000 		.word	statQu
 288 0224 00000000 		.word	.LANCHOR1
 289 0228 00000000 		.word	.LANCHOR0
 290              		.cfi_endproc
 291              	.LFE25:
 293              		.align	2
 294              		.global	I2CCmdCb
 296              	I2CCmdCb:
 297              	.LFB17:
2182:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 298              		.loc 1 2182 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 0
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302              		@ link register save eliminated.
 303              	.LVL27:
2184:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 304              		.loc 1 2184 0
 305 022c 08009FE5 		ldr	r0, .L25
 306              	.LVL28:
 307 0230 2010A0E3 		mov	r1, #32
 308 0234 0020A0E3 		mov	r2, #0
2185:../uvc.c      **** }
 309              		.loc 1 2185 0
2184:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 310              		.loc 1 2184 0
 311 0238 FEFFFFEA 		b	_txe_event_flags_set
 312              	.L26:
 313              		.align	2
 314              	.L25:
 315 023c 00000000 		.word	.LANCHOR0
 316              		.cfi_endproc
 317              	.LFE17:
 319              		.align	2
 320              		.global	CyFxUvcApplnDmaCallback
 322              	CyFxUvcApplnDmaCallback:
 323              	.LFB10:
1472:../uvc.c      **** {
 324              		.loc 1 1472 0
 325              		.cfi_startproc
 326              		@ args = 0, pretend = 0, frame = 0
 327              		@ frame_needed = 0, uses_anonymous_args = 0
 328              	.LVL29:
1476:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 329              		.loc 1 1476 0
 330 0240 080051E3 		cmp	r1, #8
1472:../uvc.c      **** {
 331              		.loc 1 1472 0
 332 0244 30402DE9 		stmfd	sp!, {r4, r5, lr}
 333              	.LCFI2:
 334              		.cfi_def_cfa_offset 12
 335 0248 0240A0E1 		mov	r4, r2
 336              		.cfi_offset 14, -4
 337              		.cfi_offset 5, -8
 338              		.cfi_offset 4, -12
 339 024c 0CD04DE2 		sub	sp, sp, #12
 340              	.LCFI3:
 341              		.cfi_def_cfa_offset 24
1476:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 342              		.loc 1 1476 0
 343 0250 0B00000A 		beq	.L32
1505:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 344              		.loc 1 1505 0
 345 0254 100051E3 		cmp	r1, #16
 346 0258 0700001A 		bne	.L27
1507:../uvc.c      ****         consCount++;
 347              		.loc 1 1507 0
 348 025c 04319FE5 		ldr	r3, .L34
1508:../uvc.c      ****         streamingStarted = CyTrue;
 349              		.loc 1 1508 0
 350 0260 0120A0E3 		mov	r2, #1
 351              	.LVL30:
1507:../uvc.c      ****         consCount++;
 352              		.loc 1 1507 0
 353 0264 B0C3D3E1 		ldrh	ip, [r3, #48]
1508:../uvc.c      ****         streamingStarted = CyTrue;
 354              		.loc 1 1508 0
 355 0268 342083E5 		str	r2, [r3, #52]
1507:../uvc.c      ****         consCount++;
 356              		.loc 1 1507 0
 357 026c 02008CE0 		add	r0, ip, r2
 358              	.LVL31:
 359 0270 0018A0E1 		mov	r1, r0, asl #16
 360              	.LVL32:
 361 0274 2128A0E1 		mov	r2, r1, lsr #16
 362 0278 B023C3E1 		strh	r2, [r3, #48]	@ movhi
 363              	.L27:
1510:../uvc.c      **** }
 364              		.loc 1 1510 0
 365 027c 0CD08DE2 		add	sp, sp, #12
 366 0280 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 367              	.LVL33:
 368              	.L32:
1478:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 369              		.loc 1 1478 0
 370 0284 B420D2E1 		ldrh	r2, [r2, #4]
 371 0288 DC309FE5 		ldr	r3, .L34+4
 372 028c 030052E1 		cmp	r2, r3
 373 0290 2900000A 		beq	.L33
1486:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 374              		.loc 1 1486 0
 375 0294 005094E5 		ldr	r5, [r4, #0]
 376              	.LVL34:
 377              	.LBB12:
 378              	.LBB13:
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 379              		.loc 1 1221 0
 380 0298 D0109FE5 		ldr	r1, .L34+8
 381              	.LVL35:
 382 029c 0C0045E2 		sub	r0, r5, #12
 383              	.LVL36:
 384 02a0 0C20A0E3 		mov	r2, #12
 385 02a4 FEFFFFEB 		bl	CyU3PMemCopy
 386              	.LVL37:
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 387              		.loc 1 1226 0
 388 02a8 0BC055E5 		ldrb	ip, [r5, #-11]	@ zero_extendqisi2
 389              	.LBE13:
 390              	.LBE12:
1487:../uvc.c      ****                 pb++;
 391              		.loc 1 1487 0
 392 02ac B4309FE5 		ldr	r3, .L34
 393              	.LBB15:
 394              	.LBB14:
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 395              		.loc 1 1226 0
 396 02b0 02108CE3 		orr	r1, ip, #2
 397 02b4 0B1045E5 		strb	r1, [r5, #-11]
 398              	.LBE14:
 399              	.LBE15:
1487:../uvc.c      ****                 pb++;
 400              		.loc 1 1487 0
 401 02b8 BA02D3E1 		ldrh	r0, [r3, #42]
1488:../uvc.c      ****                 pbc = input->buffer_p.count;
 402              		.loc 1 1488 0
 403 02bc B410D4E1 		ldrh	r1, [r4, #4]
1487:../uvc.c      ****                 pb++;
 404              		.loc 1 1487 0
 405 02c0 012080E2 		add	r2, r0, #1
 406 02c4 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
1488:../uvc.c      ****                 pbc = input->buffer_p.count;
 407              		.loc 1 1488 0
 408 02c8 BC12C3E1 		strh	r1, [r3, #44]	@ movhi
 409              	.LVL38:
 410              	.L30:
1493:../uvc.c      ****             prodCount++;
 411              		.loc 1 1493 0
 412 02cc BEE2D3E1 		ldrh	lr, [r3, #46]
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 413              		.loc 1 1494 0
 414 02d0 0C1081E2 		add	r1, r1, #12
1493:../uvc.c      ****             prodCount++;
 415              		.loc 1 1493 0
 416 02d4 01C08EE2 		add	ip, lr, #1
 417 02d8 0C08A0E1 		mov	r0, ip, asl #16
 418 02dc 20E8A0E1 		mov	lr, r0, lsr #16
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 419              		.loc 1 1494 0
 420 02e0 0128A0E1 		mov	r2, r1, asl #16
 421 02e4 2218A0E1 		mov	r1, r2, lsr #16
 422 02e8 84009FE5 		ldr	r0, .L34+12
 423 02ec 0020A0E3 		mov	r2, #0
1493:../uvc.c      ****             prodCount++;
 424              		.loc 1 1493 0
 425 02f0 BEE2C3E1 		strh	lr, [r3, #46]	@ movhi
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 426              		.loc 1 1494 0
 427 02f4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 428              	.LVL39:
1493:../uvc.c      ****             prodCount++;
 429              		.loc 1 1493 0
 430 02f8 68109FE5 		ldr	r1, .L34
1497:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 431              		.loc 1 1497 0
 432 02fc 002050E2 		subs	r2, r0, #0
 433 0300 DDFFFF0A 		beq	.L27
1499:../uvc.c      ****                 prodCount--;
 434              		.loc 1 1499 0
 435 0304 BEC2D1E1 		ldrh	ip, [r1, #46]
1500:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 436              		.loc 1 1500 0
 437 0308 B430D4E1 		ldrh	r3, [r4, #4]
1499:../uvc.c      ****                 prodCount--;
 438              		.loc 1 1499 0
 439 030c 01004CE2 		sub	r0, ip, #1
 440              	.LVL40:
 441 0310 00E8A0E1 		mov	lr, r0, asl #16
 442 0314 2EC8A0E1 		mov	ip, lr, lsr #16
 443 0318 BEC2C1E1 		strh	ip, [r1, #46]	@ movhi
1500:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 444              		.loc 1 1500 0
 445 031c BEE2D1E1 		ldrh	lr, [r1, #46]
 446 0320 B003D1E1 		ldrh	r0, [r1, #48]
 447 0324 4C109FE5 		ldr	r1, .L34+16
 448 0328 0EC060E0 		rsb	ip, r0, lr
 449 032c 0400A0E3 		mov	r0, #4
 450 0330 00C08DE5 		str	ip, [sp, #0]
 451 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 452              	.LVL41:
 453 0338 CFFFFFEA 		b	.L27
 454              	.LVL42:
 455              	.L33:
1480:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 456              		.loc 1 1480 0
 457 033c 00E094E5 		ldr	lr, [r4, #0]
 458              	.LBB16:
 459              	.LBB17:
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 460              		.loc 1 1221 0
 461 0340 28109FE5 		ldr	r1, .L34+8
 462              	.LVL43:
 463 0344 0C004EE2 		sub	r0, lr, #12
 464              	.LVL44:
 465 0348 0C20A0E3 		mov	r2, #12
 466 034c FEFFFFEB 		bl	CyU3PMemCopy
 467              	.LVL45:
 468              	.LBE17:
 469              	.LBE16:
1481:../uvc.c      ****                 fb++;
 470              		.loc 1 1481 0
 471 0350 10309FE5 		ldr	r3, .L34
 472 0354 B410D4E1 		ldrh	r1, [r4, #4]
 473 0358 B8C2D3E1 		ldrh	ip, [r3, #40]
 474 035c 01008CE2 		add	r0, ip, #1
 475 0360 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 476 0364 D8FFFFEA 		b	.L30
 477              	.L35:
 478              		.align	2
 479              	.L34:
 480 0368 00000000 		.word	.LANCHOR0
 481 036c F03F0000 		.word	16368
 482 0370 80040000 		.word	.LANCHOR1+1152
 483 0374 00000000 		.word	glChHandleUVCStream
 484 0378 38000000 		.word	.LC2
 485              		.cfi_endproc
 486              	.LFE10:
 488              		.align	2
 490              	CyFxUVCApplnUSBEventCB:
 491              	.LFB8:
1275:../uvc.c      **** {
 492              		.loc 1 1275 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 8
 495              		@ frame_needed = 0, uses_anonymous_args = 0
 496              	.LVL46:
1276:../uvc.c      ****     switch (evtype)
 497              		.loc 1 1276 0
 498 037c 020050E3 		cmp	r0, #2
1275:../uvc.c      **** {
 499              		.loc 1 1275 0
 500 0380 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 501              	.LCFI4:
 502              		.cfi_def_cfa_offset 16
 503 0384 0130A0E1 		mov	r3, r1
 504 0388 10D04DE2 		sub	sp, sp, #16
 505              	.LCFI5:
 506              		.cfi_def_cfa_offset 32
1275:../uvc.c      **** {
 507              		.loc 1 1275 0
 508 038c 0040A0E1 		mov	r4, r0
 509              		.cfi_offset 14, -4
 510              		.cfi_offset 6, -8
 511              		.cfi_offset 5, -12
 512              		.cfi_offset 4, -16
1276:../uvc.c      ****     switch (evtype)
 513              		.loc 1 1276 0
 514 0390 3600000A 		beq	.L39
 515 0394 040050E3 		cmp	r0, #4
 516 0398 1F00000A 		beq	.L40
 517 039c 010050E3 		cmp	r0, #1
 518 03a0 0100000A 		beq	.L42
 519              	.LVL47:
 520              	.L36:
1312:../uvc.c      **** }
 521              		.loc 1 1312 0
 522 03a4 10D08DE2 		add	sp, sp, #16
 523 03a8 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 524              	.LVL48:
 525              	.L42:
1297:../uvc.c      ****             gpif_initialized = 0;
 526              		.loc 1 1297 0
 527 03ac 28519FE5 		ldr	r5, .L43
1295:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 528              		.loc 1 1295 0
 529 03b0 0020A0E1 		mov	r2, r0
 530 03b4 24119FE5 		ldr	r1, .L43+4
 531              	.LVL49:
 532 03b8 0400A0E3 		mov	r0, #4
 533              	.LVL50:
 534 03bc FEFFFFEB 		bl	CyU3PDebugPrint
1296:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 535              		.loc 1 1296 0
 536 03c0 0400A0E1 		mov	r0, r4
 537 03c4 FEFFFFEB 		bl	CyU3PGpifDisable
1297:../uvc.c      ****             gpif_initialized = 0;
 538              		.loc 1 1297 0
 539 03c8 00C0A0E3 		mov	ip, #0
 540              	.LBB24:
 541              	.LBB25:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 542              		.loc 1 1259 0
 543 03cc 0410A0E1 		mov	r1, r4
 544 03d0 0500A0E1 		mov	r0, r5
 545 03d4 0220A0E3 		mov	r2, #2
 546 03d8 0C308DE2 		add	r3, sp, #12
 547              	.LBE25:
 548              	.LBE24:
1297:../uvc.c      ****             gpif_initialized = 0;
 549              		.loc 1 1297 0
 550 03dc 38C085E5 		str	ip, [r5, #56]
1298:../uvc.c      ****             isUsbConnected = CyFalse;
 551              		.loc 1 1298 0
 552 03e0 3CC085E5 		str	ip, [r5, #60]
1299:../uvc.c      ****             streamingStarted = CyFalse;
 553              		.loc 1 1299 0
 554 03e4 34C085E5 		str	ip, [r5, #52]
 555              	.LBB27:
 556              	.LBB26:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 557              		.loc 1 1259 0
 558 03e8 00C08DE5 		str	ip, [sp, #0]
 559 03ec FEFFFFEB 		bl	_txe_event_flags_get
 560 03f0 004050E2 		subs	r4, r0, #0
 561 03f4 EAFFFF1A 		bne	.L36
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 562              		.loc 1 1262 0
 563 03f8 0110E0E3 		mvn	r1, #1
 564 03fc 0220A0E3 		mov	r2, #2
 565 0400 0500A0E1 		mov	r0, r5
 566              	.L41:
 567 0404 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 568              		.loc 1 1265 0
 569 0408 0500A0E1 		mov	r0, r5
 570 040c 0210A0E3 		mov	r1, #2
 571 0410 0420A0E1 		mov	r2, r4
 572 0414 FEFFFFEB 		bl	_txe_event_flags_set
 573 0418 E1FFFFEA 		b	.L36
 574              	.LVL51:
 575              	.L40:
 576              	.LBE26:
 577              	.LBE27:
1281:../uvc.c      ****             gpif_initialized = 0;
 578              		.loc 1 1281 0
 579 041c B8509FE5 		ldr	r5, .L43
1279:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 580              		.loc 1 1279 0
 581 0420 BC109FE5 		ldr	r1, .L43+8
 582              	.LVL52:
 583 0424 0020A0E1 		mov	r2, r0
 584 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 585              	.LVL53:
1280:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 586              		.loc 1 1280 0
 587 042c 0100A0E3 		mov	r0, #1
 588 0430 FEFFFFEB 		bl	CyU3PGpifDisable
1281:../uvc.c      ****             gpif_initialized = 0;
 589              		.loc 1 1281 0
 590 0434 00C0A0E3 		mov	ip, #0
 591              	.LBB28:
 592              	.LBB29:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 593              		.loc 1 1259 0
 594 0438 0110A0E3 		mov	r1, #1
 595 043c 0220A0E3 		mov	r2, #2
 596 0440 0500A0E1 		mov	r0, r5
 597 0444 0C308DE2 		add	r3, sp, #12
 598              	.LBE29:
 599              	.LBE28:
1281:../uvc.c      ****             gpif_initialized = 0;
 600              		.loc 1 1281 0
 601 0448 38C085E5 		str	ip, [r5, #56]
1282:../uvc.c      ****             streamingStarted = CyFalse;
 602              		.loc 1 1282 0
 603 044c 34C085E5 		str	ip, [r5, #52]
 604              	.LBB31:
 605              	.LBB30:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 606              		.loc 1 1259 0
 607 0450 00C08DE5 		str	ip, [sp, #0]
 608 0454 FEFFFFEB 		bl	_txe_event_flags_get
 609 0458 004050E2 		subs	r4, r0, #0
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 610              		.loc 1 1262 0
 611 045c 0500A001 		moveq	r0, r5
 612 0460 0110E003 		mvneq	r1, #1
 613 0464 0220A003 		moveq	r2, #2
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 614              		.loc 1 1259 0
 615 0468 CDFFFF1A 		bne	.L36
 616 046c E4FFFFEA 		b	.L41
 617              	.LVL54:
 618              	.L39:
 619              	.LBE30:
 620              	.LBE31:
1289:../uvc.c      ****             gpif_initialized = 0;
 621              		.loc 1 1289 0
 622 0470 64509FE5 		ldr	r5, .L43
1287:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 623              		.loc 1 1287 0
 624 0474 0020A0E1 		mov	r2, r0
 625 0478 68109FE5 		ldr	r1, .L43+12
 626              	.LVL55:
 627 047c 0400A0E3 		mov	r0, #4
 628              	.LVL56:
 629 0480 FEFFFFEB 		bl	CyU3PDebugPrint
1288:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 630              		.loc 1 1288 0
 631 0484 0100A0E3 		mov	r0, #1
 632 0488 FEFFFFEB 		bl	CyU3PGpifDisable
1289:../uvc.c      ****             gpif_initialized = 0;
 633              		.loc 1 1289 0
 634 048c 0060A0E3 		mov	r6, #0
 635              	.LBB32:
 636              	.LBB33:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 637              		.loc 1 1259 0
 638 0490 0500A0E1 		mov	r0, r5
 639 0494 0110A0E3 		mov	r1, #1
 640 0498 0420A0E1 		mov	r2, r4
 641 049c 0C308DE2 		add	r3, sp, #12
 642              	.LBE33:
 643              	.LBE32:
1289:../uvc.c      ****             gpif_initialized = 0;
 644              		.loc 1 1289 0
 645 04a0 386085E5 		str	r6, [r5, #56]
1290:../uvc.c      ****             streamingStarted = CyFalse;
 646              		.loc 1 1290 0
 647 04a4 346085E5 		str	r6, [r5, #52]
 648              	.LBB35:
 649              	.LBB34:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 650              		.loc 1 1259 0
 651 04a8 00608DE5 		str	r6, [sp, #0]
 652 04ac FEFFFFEB 		bl	_txe_event_flags_get
 653 04b0 006050E2 		subs	r6, r0, #0
 654 04b4 BAFFFF1A 		bne	.L36
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 655              		.loc 1 1262 0
 656 04b8 0420A0E1 		mov	r2, r4
 657 04bc 0500A0E1 		mov	r0, r5
 658 04c0 0110E0E3 		mvn	r1, #1
 659 04c4 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 660              		.loc 1 1265 0
 661 04c8 0500A0E1 		mov	r0, r5
 662 04cc 0410A0E1 		mov	r1, r4
 663 04d0 0620A0E1 		mov	r2, r6
 664 04d4 FEFFFFEB 		bl	_txe_event_flags_set
 665 04d8 B1FFFFEA 		b	.L36
 666              	.L44:
 667              		.align	2
 668              	.L43:
 669 04dc 00000000 		.word	.LANCHOR0
 670 04e0 C4000000 		.word	.LC5
 671 04e4 80000000 		.word	.LC3
 672 04e8 A0000000 		.word	.LC4
 673              	.LBE34:
 674              	.LBE35:
 675              		.cfi_endproc
 676              	.LFE8:
 678              		.align	2
 680              	CyFxUVCApplnUSBSetupCB:
 681              	.LFB9:
1320:../uvc.c      **** {
 682              		.loc 1 1320 0
 683              		.cfi_startproc
 684              		@ args = 0, pretend = 0, frame = 8
 685              		@ frame_needed = 0, uses_anonymous_args = 0
 686              	.LVL57:
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 687              		.loc 1 1325 0
 688 04ec C0329FE5 		ldr	r3, .L70
1320:../uvc.c      **** {
 689              		.loc 1 1320 0
 690 04f0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 691              	.LCFI6:
 692              		.cfi_def_cfa_offset 24
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 693              		.loc 1 1326 0
 694 04f4 BCC29FE5 		ldr	ip, .L70+4
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 695              		.loc 1 1325 0
 696 04f8 FF4000E2 		and	r4, r0, #255
 697              		.cfi_offset 14, -4
 698              		.cfi_offset 8, -8
 699              		.cfi_offset 7, -12
 700              		.cfi_offset 6, -16
 701              		.cfi_offset 5, -20
 702              		.cfi_offset 4, -24
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 703              		.loc 1 1326 0
 704 04fc FF8C00E2 		and	r8, r0, #65280
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 705              		.loc 1 1327 0
 706 0500 2078A0E1 		mov	r7, r0, lsr #16
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 707              		.loc 1 1325 0
 708 0504 0040C3E5 		strb	r4, [r3, #0]
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 709              		.loc 1 1327 0
 710 0508 AC229FE5 		ldr	r2, .L70+8
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 711              		.loc 1 1328 0
 712 050c AC029FE5 		ldr	r0, .L70+12
 713              	.LVL58:
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 714              		.loc 1 1329 0
 715 0510 AC329FE5 		ldr	r3, .L70+16
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 716              		.loc 1 1328 0
 717 0514 0158A0E1 		mov	r5, r1, asl #16
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 718              		.loc 1 1326 0
 719 0518 2884A0E1 		mov	r8, r8, lsr #8
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 720              		.loc 1 1328 0
 721 051c 2558A0E1 		mov	r5, r5, lsr #16
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 722              		.loc 1 1329 0
 723 0520 2118A0E1 		mov	r1, r1, lsr #16
 724              	.LVL59:
1332:../uvc.c      ****     switch (bmReqType)
 725              		.loc 1 1332 0
 726 0524 020054E3 		cmp	r4, #2
1320:../uvc.c      **** {
 727              		.loc 1 1320 0
 728 0528 10D04DE2 		sub	sp, sp, #16
 729              	.LCFI7:
 730              		.cfi_def_cfa_offset 40
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 731              		.loc 1 1326 0
 732 052c 0080CCE5 		strb	r8, [ip, #0]
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 733              		.loc 1 1327 0
 734 0530 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 735              		.loc 1 1328 0
 736 0534 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 737              		.loc 1 1329 0
 738 0538 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1332:../uvc.c      ****     switch (bmReqType)
 739              		.loc 1 1332 0
 740 053c 4F00000A 		beq	.L48
 741 0540 0600009A 		bls	.L66
 742 0544 210054E3 		cmp	r4, #33
 743 0548 3A00000A 		beq	.L49
 744 054c A10054E3 		cmp	r4, #161
 745 0550 3800000A 		beq	.L49
 746              	.L63:
1321:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 747              		.loc 1 1321 0
 748 0554 0000A0E3 		mov	r0, #0
 749              	.LVL60:
 750              	.L46:
1459:../uvc.c      **** }
 751              		.loc 1 1459 0
 752 0558 10D08DE2 		add	sp, sp, #16
 753 055c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 754              	.LVL61:
 755              	.L66:
1332:../uvc.c      ****     switch (bmReqType)
 756              		.loc 1 1332 0
 757 0560 010054E3 		cmp	r4, #1
 758 0564 FAFFFF1A 		bne	.L63
1372:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 759              		.loc 1 1372 0
 760 0568 0B0058E3 		cmp	r8, #11
 761 056c F8FFFF1A 		bne	.L63
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 762              		.loc 1 1376 0
 763 0570 010055E3 		cmp	r5, #1
 764 0574 F6FFFF1A 		bne	.L63
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 765              		.loc 1 1376 0 is_stmt 0 discriminator 1
 766 0578 000057E3 		cmp	r7, #0
 767 057c F4FFFF1A 		bne	.L63
1381:../uvc.c      ****                     gpif_initialized = 0;
 768              		.loc 1 1381 0 is_stmt 1
 769 0580 40429FE5 		ldr	r4, .L70+20
1379:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 770              		.loc 1 1379 0
 771 0584 40129FE5 		ldr	r1, .L70+24
 772 0588 0400A0E3 		mov	r0, #4
 773 058c FEFFFFEB 		bl	CyU3PDebugPrint
1380:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 774              		.loc 1 1380 0
 775 0590 0500A0E1 		mov	r0, r5
 776 0594 FEFFFFEB 		bl	CyU3PGpifDisable
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 777              		.loc 1 1384 0
 778 0598 0510A0E1 		mov	r1, r5
 779 059c 8300A0E3 		mov	r0, #131
1381:../uvc.c      ****                     gpif_initialized = 0;
 780              		.loc 1 1381 0
 781 05a0 387084E5 		str	r7, [r4, #56]
1382:../uvc.c      ****                     streamingStarted = CyFalse;
 782              		.loc 1 1382 0
 783 05a4 347084E5 		str	r7, [r4, #52]
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 784              		.loc 1 1384 0
 785 05a8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1385:../uvc.c      ****                     CyU3PBusyWait (100);
 786              		.loc 1 1385 0
 787 05ac 6400A0E3 		mov	r0, #100
 788 05b0 FEFFFFEB 		bl	CyU3PBusyWait
1388:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 789              		.loc 1 1388 0
 790 05b4 14029FE5 		ldr	r0, .L70+28
 791 05b8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1389:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 792              		.loc 1 1389 0
 793 05bc 8300A0E3 		mov	r0, #131
 794 05c0 FEFFFFEB 		bl	CyU3PUsbFlushEp
1390:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 795              		.loc 1 1390 0
 796 05c4 0710A0E1 		mov	r1, r7
 797 05c8 8300A0E3 		mov	r0, #131
 798 05cc FEFFFFEB 		bl	CyU3PUsbSetEpNak
1391:../uvc.c      ****                     CyU3PBusyWait (100);
 799              		.loc 1 1391 0
 800 05d0 6400A0E3 		mov	r0, #100
 801 05d4 FEFFFFEB 		bl	CyU3PBusyWait
1394:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 802              		.loc 1 1394 0
 803 05d8 0710A0E1 		mov	r1, r7
 804 05dc 0520A0E1 		mov	r2, r5
 805 05e0 8300A0E3 		mov	r0, #131
 806 05e4 FEFFFFEB 		bl	CyU3PUsbStall
 807              	.LVL62:
1397:../uvc.c      ****                     CyU3PUsbAckSetup ();
 808              		.loc 1 1397 0
 809 05e8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1399:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 810              		.loc 1 1399 0
 811 05ec 405084E5 		str	r5, [r4, #64]
 812              	.LBB40:
 813              	.LBB41:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 814              		.loc 1 1259 0
 815 05f0 0400A0E1 		mov	r0, r4
 816 05f4 0510A0E1 		mov	r1, r5
 817 05f8 0220A0E3 		mov	r2, #2
 818 05fc 0C308DE2 		add	r3, sp, #12
 819 0600 00708DE5 		str	r7, [sp, #0]
 820 0604 FEFFFFEB 		bl	_txe_event_flags_get
 821 0608 006050E2 		subs	r6, r0, #0
 822 060c 2E00001A 		bne	.L61
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 823              		.loc 1 1262 0
 824 0610 0110E0E3 		mvn	r1, #1
 825 0614 0220A0E3 		mov	r2, #2
 826 0618 0400A0E1 		mov	r0, r4
 827 061c FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 828              		.loc 1 1265 0
 829 0620 0400A0E1 		mov	r0, r4
 830 0624 0210A0E3 		mov	r1, #2
 831 0628 0620A0E1 		mov	r2, r6
 832 062c FEFFFFEB 		bl	_txe_event_flags_set
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
 833              		.loc 1 1395 0
 834 0630 0500A0E1 		mov	r0, r5
 835 0634 C7FFFFEA 		b	.L46
 836              	.LVL63:
 837              	.L49:
 838              	.LBE41:
 839              	.LBE40:
1337:../uvc.c      ****             switch (wIndex & 0xFF)
 840              		.loc 1 1337 0
 841 0638 FF5015E2 		ands	r5, r5, #255
 842 063c 1A00001A 		bne	.L67
 843              	.LVL64:
1342:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 844              		.loc 1 1342 0
 845 0640 0520A0E1 		mov	r2, r5
 846 0644 7C019FE5 		ldr	r0, .L70+20
 847 0648 0410A0E3 		mov	r1, #4
 848 064c FEFFFFEB 		bl	_txe_event_flags_set
 849              	.LVL65:
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 850              		.loc 1 1344 0
 851 0650 002050E2 		subs	r2, r0, #0
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
 852              		.loc 1 1341 0
 853 0654 0100A003 		moveq	r0, #1
 854              	.LVL66:
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 855              		.loc 1 1344 0
 856 0658 BEFFFF0A 		beq	.L46
1346:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 857              		.loc 1 1346 0
 858 065c 70119FE5 		ldr	r1, .L70+32
 859 0660 0400A0E3 		mov	r0, #4
 860 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 861              	.LVL67:
1347:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 862              		.loc 1 1347 0
 863 0668 0500A0E1 		mov	r0, r5
 864 066c 0110A0E3 		mov	r1, #1
 865 0670 0520A0E1 		mov	r2, r5
 866 0674 FEFFFFEB 		bl	CyU3PUsbStall
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
 867              		.loc 1 1341 0
 868 0678 0100A0E3 		mov	r0, #1
 869 067c B5FFFFEA 		b	.L46
 870              	.LVL68:
 871              	.L48:
1407:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 872              		.loc 1 1407 0
 873 0680 010058E3 		cmp	r8, #1
 874 0684 B2FFFF1A 		bne	.L63
1409:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 875              		.loc 1 1409 0
 876 0688 830055E3 		cmp	r5, #131
 877 068c B0FFFF1A 		bne	.L63
1415:../uvc.c      ****                     if (streamingStarted == CyTrue)
 878              		.loc 1 1415 0
 879 0690 30719FE5 		ldr	r7, .L70+20
 880 0694 346097E5 		ldr	r6, [r7, #52]
 881 0698 010056E3 		cmp	r6, #1
 882 069c 1500000A 		beq	.L68
 883              	.LVL69:
1447:../uvc.c      ****                         CyU3PUsbAckSetup ();
 884              		.loc 1 1447 0
 885 06a0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1446:../uvc.c      ****                         uvcHandleReq = CyTrue;
 886              		.loc 1 1446 0
 887 06a4 0800A0E1 		mov	r0, r8
 888 06a8 AAFFFFEA 		b	.L46
 889              	.LVL70:
 890              	.L67:
1337:../uvc.c      ****             switch (wIndex & 0xFF)
 891              		.loc 1 1337 0
 892 06ac 010055E3 		cmp	r5, #1
 893 06b0 A7FFFF1A 		bne	.L63
 894              	.LVL71:
1355:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 895              		.loc 1 1355 0
 896 06b4 0020A0E3 		mov	r2, #0
 897 06b8 08019FE5 		ldr	r0, .L70+20
 898 06bc 0810A0E3 		mov	r1, #8
 899 06c0 FEFFFFEB 		bl	_txe_event_flags_set
 900              	.LVL72:
1357:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 901              		.loc 1 1357 0
 902 06c4 002050E2 		subs	r2, r0, #0
 903 06c8 0100001A 		bne	.L69
 904              	.LVL73:
 905              	.L61:
 906              	.LBB43:
 907              	.LBB42:
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1395 0
 909 06cc 0500A0E1 		mov	r0, r5
 910 06d0 A0FFFFEA 		b	.L46
 911              	.LVL74:
 912              	.L69:
 913              	.LBE42:
 914              	.LBE43:
1360:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 915              		.loc 1 1360 0
 916 06d4 FC109FE5 		ldr	r1, .L70+36
 917 06d8 0400A0E3 		mov	r0, #4
 918              	.LVL75:
 919 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 920              	.LVL76:
1361:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 921              		.loc 1 1361 0
 922 06e0 0000A0E3 		mov	r0, #0
 923 06e4 0510A0E1 		mov	r1, r5
 924 06e8 0020A0E1 		mov	r2, r0
 925 06ec FEFFFFEB 		bl	CyU3PUsbStall
1354:../uvc.c      ****                         uvcHandleReq = CyTrue;
 926              		.loc 1 1354 0
 927 06f0 0500A0E1 		mov	r0, r5
 928 06f4 97FFFFEA 		b	.L46
 929              	.LVL77:
 930              	.L68:
1417:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 931              		.loc 1 1417 0
 932 06f8 DC109FE5 		ldr	r1, .L70+40
 933 06fc 0400A0E3 		mov	r0, #4
 934 0700 FEFFFFEB 		bl	CyU3PDebugPrint
1421:../uvc.c      ****                         gpif_initialized = 0;
 935              		.loc 1 1421 0
 936 0704 0080A0E3 		mov	r8, #0
1420:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 937              		.loc 1 1420 0
 938 0708 0600A0E1 		mov	r0, r6
 939 070c FEFFFFEB 		bl	CyU3PGpifDisable
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 940              		.loc 1 1425 0
 941 0710 0610A0E1 		mov	r1, r6
 942 0714 0500A0E1 		mov	r0, r5
1421:../uvc.c      ****                         gpif_initialized = 0;
 943              		.loc 1 1421 0
 944 0718 388087E5 		str	r8, [r7, #56]
1422:../uvc.c      ****                         streamingStarted = CyFalse;
 945              		.loc 1 1422 0
 946 071c 348087E5 		str	r8, [r7, #52]
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 947              		.loc 1 1425 0
 948 0720 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1426:../uvc.c      ****                         CyU3PBusyWait (100);
 949              		.loc 1 1426 0
 950 0724 6400A0E3 		mov	r0, #100
 951 0728 FEFFFFEB 		bl	CyU3PBusyWait
1429:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 952              		.loc 1 1429 0
 953 072c 9C009FE5 		ldr	r0, .L70+28
 954 0730 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1430:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 955              		.loc 1 1430 0
 956 0734 0500A0E1 		mov	r0, r5
 957 0738 FEFFFFEB 		bl	CyU3PUsbFlushEp
1431:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 958              		.loc 1 1431 0
 959 073c 0810A0E1 		mov	r1, r8
 960 0740 0500A0E1 		mov	r0, r5
 961 0744 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1432:../uvc.c      ****                         CyU3PBusyWait (100);
 962              		.loc 1 1432 0
 963 0748 6400A0E3 		mov	r0, #100
 964 074c FEFFFFEB 		bl	CyU3PBusyWait
1435:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 965              		.loc 1 1435 0
 966 0750 0810A0E1 		mov	r1, r8
 967 0754 0620A0E1 		mov	r2, r6
 968 0758 0500A0E1 		mov	r0, r5
 969 075c FEFFFFEB 		bl	CyU3PUsbStall
 970              	.LVL78:
1439:../uvc.c      ****                         CyU3PUsbAckSetup ();
 971              		.loc 1 1439 0
 972 0760 FEFFFFEB 		bl	CyU3PUsbAckSetup
1441:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 973              		.loc 1 1441 0
 974 0764 406087E5 		str	r6, [r7, #64]
 975              	.LBB44:
 976              	.LBB45:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 977              		.loc 1 1259 0
 978 0768 0700A0E1 		mov	r0, r7
 979 076c 0610A0E1 		mov	r1, r6
 980 0770 0420A0E1 		mov	r2, r4
 981 0774 0C308DE2 		add	r3, sp, #12
 982 0778 00808DE5 		str	r8, [sp, #0]
 983 077c FEFFFFEB 		bl	_txe_event_flags_get
 984 0780 005050E2 		subs	r5, r0, #0
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
 985              		.loc 1 1437 0
 986 0784 0600A011 		movne	r0, r6
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 987              		.loc 1 1259 0
 988 0788 72FFFF1A 		bne	.L46
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 989              		.loc 1 1262 0
 990 078c 0110E0E3 		mvn	r1, #1
 991 0790 0420A0E1 		mov	r2, r4
 992 0794 0700A0E1 		mov	r0, r7
 993 0798 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 994              		.loc 1 1265 0
 995 079c 0700A0E1 		mov	r0, r7
 996 07a0 0410A0E1 		mov	r1, r4
 997 07a4 0520A0E1 		mov	r2, r5
 998 07a8 FEFFFFEB 		bl	_txe_event_flags_set
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
 999              		.loc 1 1437 0
 1000 07ac 0600A0E1 		mov	r0, r6
 1001 07b0 68FFFFEA 		b	.L46
 1002              	.L71:
 1003              		.align	2
 1004              	.L70:
 1005 07b4 00000000 		.word	bmReqType
 1006 07b8 00000000 		.word	bRequest
 1007 07bc 00000000 		.word	wValue
 1008 07c0 00000000 		.word	wIndex
 1009 07c4 00000000 		.word	wLength
 1010 07c8 00000000 		.word	.LANCHOR0
 1011 07cc 50010000 		.word	.LC8
 1012 07d0 00000000 		.word	glChHandleUVCStream
 1013 07d4 E4000000 		.word	.LC6
 1014 07d8 1C010000 		.word	.LC7
 1015 07dc 68010000 		.word	.LC9
 1016              	.LBE45:
 1017              	.LBE44:
 1018              		.cfi_endproc
 1019              	.LFE9:
 1021              		.align	2
 1022              		.global	CyFxGpifCB
 1024              	CyFxGpifCB:
 1025              	.LFB12:
1630:../uvc.c      **** {
 1026              		.loc 1 1630 0
 1027              		.cfi_startproc
 1028              		@ args = 0, pretend = 0, frame = 0
 1029              		@ frame_needed = 0, uses_anonymous_args = 0
 1030              	.LVL79:
1631:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1031              		.loc 1 1631 0
 1032 07e0 010050E3 		cmp	r0, #1
1630:../uvc.c      **** {
 1033              		.loc 1 1630 0
 1034 07e4 10402DE9 		stmfd	sp!, {r4, lr}
 1035              	.LCFI8:
 1036              		.cfi_def_cfa_offset 8
1630:../uvc.c      **** {
 1037              		.loc 1 1630 0
 1038 07e8 0120A0E1 		mov	r2, r1
1631:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1039              		.loc 1 1631 0
 1040 07ec 1080BD18 		ldmnefd	sp!, {r4, pc}
 1041              		.cfi_offset 14, -4
 1042              		.cfi_offset 4, -8
1633:../uvc.c      ****         hitFV = CyTrue;
 1043              		.loc 1 1633 0
 1044 07f0 D0109FE5 		ldr	r1, .L88
 1045              	.LVL80:
 1046              	.LBB50:
 1047              	.LBB52:
1530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1048              		.loc 1 1530 0
 1049 07f4 4830D1E5 		ldrb	r3, [r1, #72]	@ zero_extendqisi2
 1050              	.LBE52:
 1051              	.LBE50:
1633:../uvc.c      ****         hitFV = CyTrue;
 1052              		.loc 1 1633 0
 1053 07f8 440081E5 		str	r0, [r1, #68]
 1054              	.LVL81:
 1055              	.LBB56:
 1056              	.LBB51:
1530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1057              		.loc 1 1530 0
 1058 07fc 030053E3 		cmp	r3, #3
 1059 0800 2800000A 		beq	.L87
1554:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1060              		.loc 1 1554 0
 1061 0804 020053E3 		cmp	r3, #2
 1062 0808 1080BD18 		ldmnefd	sp!, {r4, pc}
1556:../uvc.c      ****         switch (stateId)
 1063              		.loc 1 1556 0
 1064 080c 080042E2 		sub	r0, r2, #8
 1065              	.LVL82:
 1066 0810 0A0050E3 		cmp	r0, #10
 1067 0814 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1068 0818 1B0000EA 		b	.L80
 1069              	.L82:
 1070 081c 4C080000 		.word	.L76
 1071 0820 8C080000 		.word	.L80
 1072 0824 8C080000 		.word	.L80
 1073 0828 48080000 		.word	.L72
 1074 082c 8C080000 		.word	.L80
 1075 0830 8C080000 		.word	.L80
 1076 0834 8C080000 		.word	.L80
 1077 0838 84080000 		.word	.L86
 1078 083c 8C080000 		.word	.L80
 1079 0840 8C080000 		.word	.L80
 1080 0844 48080000 		.word	.L72
 1081              	.LVL83:
 1082              	.L72:
 1083 0848 1080BDE8 		ldmfd	sp!, {r4, pc}
 1084              	.LVL84:
 1085              	.L76:
1540:../uvc.c      ****                 socket = 0;
 1086              		.loc 1 1540 0
 1087 084c 0010A0E3 		mov	r1, #0
 1088              	.L77:
 1089              	.LVL85:
1613:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1090              		.loc 1 1613 0
 1091 0850 74009FE5 		ldr	r0, .L88+4
 1092 0854 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1093              	.LVL86:
1614:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1094              		.loc 1 1614 0
 1095 0858 002050E2 		subs	r2, r0, #0
 1096 085c F9FFFF0A 		beq	.L72
1616:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1097              		.loc 1 1616 0
 1098 0860 0400A0E3 		mov	r0, #4
 1099              	.LVL87:
 1100 0864 64109FE5 		ldr	r1, .L88+8
 1101 0868 FEFFFFEB 		bl	CyU3PDebugPrint
 1102              	.LVL88:
 1103              	.L83:
 1104              	.LBB53:
 1105              	.LBB54:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1106              		.loc 1 1246 0
 1107 086c 60109FE5 		ldr	r1, .L88+12
 1108 0870 0400A0E3 		mov	r0, #4
 1109 0874 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 1110              		.loc 1 1247 0
 1111 0878 FA0FA0E3 		mov	r0, #1000
 1112 087c FEFFFFEB 		bl	_tx_thread_sleep
 1113 0880 F9FFFFEA 		b	.L83
 1114              	.LVL89:
 1115              	.L86:
 1116              	.LBE54:
 1117              	.LBE53:
1583:../uvc.c      ****                 socket = 1;
 1118              		.loc 1 1583 0
 1119 0884 0110A0E3 		mov	r1, #1
 1120 0888 F0FFFFEA 		b	.L77
 1121              	.L80:
1602:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1122              		.loc 1 1602 0
 1123 088c 44109FE5 		ldr	r1, .L88+16
 1124 0890 0100A0E3 		mov	r0, #1
 1125 0894 FEFFFFEB 		bl	CyU3PDebugPrint
 1126              	.LVL90:
 1127              	.LBE51:
 1128              	.LBE56:
1635:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1129              		.loc 1 1635 0
 1130 0898 3C109FE5 		ldr	r1, .L88+20
 1131 089c 0400A0E3 		mov	r0, #4
1637:../uvc.c      **** }
 1132              		.loc 1 1637 0
 1133 08a0 1040BDE8 		ldmfd	sp!, {r4, lr}
1635:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1134              		.loc 1 1635 0
 1135 08a4 FEFFFFEA 		b	CyU3PDebugPrint
 1136              	.LVL91:
 1137              	.L87:
 1138              	.LBB57:
 1139              	.LBB55:
1532:../uvc.c      ****         switch (stateId)
 1140              		.loc 1 1532 0
 1141 08a8 0B3042E2 		sub	r3, r2, #11
 1142 08ac 030053E3 		cmp	r3, #3
 1143 08b0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1144 08b4 F4FFFFEA 		b	.L80
 1145              	.L78:
 1146 08b8 4C080000 		.word	.L76
 1147 08bc 84080000 		.word	.L86
 1148 08c0 48080000 		.word	.L72
 1149 08c4 48080000 		.word	.L72
 1150              	.L89:
 1151              		.align	2
 1152              	.L88:
 1153 08c8 00000000 		.word	.LANCHOR0
 1154 08cc 00000000 		.word	glChHandleUVCStream
 1155 08d0 A4010000 		.word	.LC11
 1156 08d4 D4010000 		.word	.LC12
 1157 08d8 8C010000 		.word	.LC10
 1158 08dc E8010000 		.word	.LC13
 1159              	.LBE55:
 1160              	.LBE57:
 1161              		.cfi_endproc
 1162              	.LFE12:
 1164              		.align	2
 1165              		.global	I2CCmdHandler
 1167              	I2CCmdHandler:
 1168              	.LFB0:
 323:../uvc.c      **** void I2CCmdHandler(){
 1169              		.loc 1 323 0
 1170              		.cfi_startproc
 1171              		@ args = 0, pretend = 0, frame = 8
 1172              		@ frame_needed = 0, uses_anonymous_args = 0
 1173 08e0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1174              	.LCFI9:
 1175              		.cfi_def_cfa_offset 36
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1176              		.loc 1 326 0
 1177 08e4 08419FE5 		ldr	r4, .L96
 1178              		.cfi_offset 14, -4
 1179              		.cfi_offset 11, -8
 1180              		.cfi_offset 10, -12
 1181              		.cfi_offset 9, -16
 1182              		.cfi_offset 8, -20
 1183              		.cfi_offset 7, -24
 1184              		.cfi_offset 6, -28
 1185              		.cfi_offset 5, -32
 1186              		.cfi_offset 4, -36
 323:../uvc.c      **** void I2CCmdHandler(){
 1187              		.loc 1 323 0
 1188 08e8 34D04DE2 		sub	sp, sp, #52
 1189              	.LCFI10:
 1190              		.cfi_def_cfa_offset 88
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1191              		.loc 1 326 0
 1192 08ec 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1193              	.LVL92:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1194              		.loc 1 331 0
 1195 08f0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1196              		.loc 1 328 0
 1197 08f4 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1198              	.LVL93:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1199              		.loc 1 331 0
 1200 08f8 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1201 08fc 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1202 0900 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1203 0904 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1204 0908 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1205 090c 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1206 0910 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1207 0914 1C208DE5 		str	r2, [sp, #28]
 1208 0918 0400A0E3 		mov	r0, #4
 1209 091c 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 1210 0920 D0109FE5 		ldr	r1, .L96+4
 1211 0924 0520A0E1 		mov	r2, r5
 1212 0928 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1213 092c 08808DE5 		str	r8, [sp, #8]
 1214 0930 0CA08DE5 		str	sl, [sp, #12]
 1215 0934 10908DE5 		str	r9, [sp, #16]
 1216 0938 14B08DE5 		str	fp, [sp, #20]
 1217 093c 18608DE5 		str	r6, [sp, #24]
 1218 0940 20C08DE5 		str	ip, [sp, #32]
 1219 0944 FEFFFFEB 		bl	CyU3PDebugPrint
 1220              	.LVL94:
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1221              		.loc 1 335 0
 1222 0948 000055E3 		cmp	r5, #0
 1223 094c 0300000A 		beq	.L94
 360:../uvc.c      **** 	}else if(CmdType == 1){
 1224              		.loc 1 360 0
 1225 0950 010055E3 		cmp	r5, #1
 1226 0954 1600000A 		beq	.L95
 1227              	.LVL95:
 1228              	.L90:
 375:../uvc.c      **** }
 1229              		.loc 1 375 0
 1230 0958 34D08DE2 		add	sp, sp, #52
 1231 095c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1232              	.LVL96:
 1233              	.L94:
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1234              		.loc 1 351 0
 1235 0960 54C0D4E5 		ldrb	ip, [r4, #84]	@ zero_extendqisi2
 1236 0964 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1237 0968 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1238 096c 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1239              		.loc 1 337 0
 1240 0970 0FE0A0E3 		mov	lr, #15
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1241              		.loc 1 351 0
 1242 0974 00C08DE5 		str	ip, [sp, #0]
 1243 0978 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1244 097c 2CC08DE2 		add	ip, sp, #44
 1245 0980 010080E3 		orr	r0, r0, #1
 1246 0984 011081E3 		orr	r1, r1, #1
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1247              		.loc 1 337 0
 1248 0988 57E0C4E5 		strb	lr, [r4, #87]
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1249              		.loc 1 351 0
 1250 098c 04C08DE5 		str	ip, [sp, #4]
 1251 0990 FEFFFFEB 		bl	SensorRead2B
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1252              		.loc 1 352 0
 1253 0994 2C00DDE5 		ldrb	r0, [sp, #44]	@ zero_extendqisi2
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 1254              		.loc 1 353 0
 1255 0998 020056E3 		cmp	r6, #2
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1256              		.loc 1 352 0
 1257 099c 5500C4E5 		strb	r0, [r4, #85]
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1258              		.loc 1 354 0
 1259 09a0 2D00DD05 		ldreqb	r0, [sp, #45]	@ zero_extendqisi2
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1260              		.loc 1 356 0
 1261 09a4 0030E0E3 		mvn	r3, #0
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1262              		.loc 1 354 0
 1263 09a8 5600C405 		streqb	r0, [r4, #86]
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1264              		.loc 1 356 0
 1265 09ac 5730C4E5 		strb	r3, [r4, #87]
 1266 09b0 E8FFFFEA 		b	.L90
 1267              	.L95:
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1268              		.loc 1 369 0
 1269 09b4 54C0D4E5 		ldrb	ip, [r4, #84]	@ zero_extendqisi2
 1270 09b8 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1271 09bc 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 362:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1272              		.loc 1 362 0
 1273 09c0 5550D4E5 		ldrb	r5, [r4, #85]	@ zero_extendqisi2
 1274              	.LVL97:
 363:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1275              		.loc 1 363 0
 1276 09c4 56E0D4E5 		ldrb	lr, [r4, #86]	@ zero_extendqisi2
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1277              		.loc 1 369 0
 1278 09c8 00C08DE5 		str	ip, [sp, #0]
 1279 09cc 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1280 09d0 2CC08DE2 		add	ip, sp, #44
 1281 09d4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1282 09d8 FE1001E2 		and	r1, r1, #254
 1283 09dc FE0000E2 		and	r0, r0, #254
 362:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1284              		.loc 1 362 0
 1285 09e0 2C50CDE5 		strb	r5, [sp, #44]
 363:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1286              		.loc 1 363 0
 1287 09e4 2DE0CDE5 		strb	lr, [sp, #45]
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1288              		.loc 1 369 0
 1289 09e8 04C08DE5 		str	ip, [sp, #4]
 1290 09ec FEFFFFEB 		bl	SensorWrite2B
 1291 09f0 D8FFFFEA 		b	.L90
 1292              	.L97:
 1293              		.align	2
 1294              	.L96:
 1295 09f4 00000000 		.word	.LANCHOR0
 1296 09f8 FC010000 		.word	.LC14
 1297              		.cfi_endproc
 1298              	.LFE0:
 1300              		.align	2
 1301              		.global	setIrisauto
 1303              	setIrisauto:
 1304              	.LFB1:
 381:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1305              		.loc 1 381 0
 1306              		.cfi_startproc
 1307              		@ args = 0, pretend = 0, frame = 0
 1308              		@ frame_needed = 0, uses_anonymous_args = 0
 1309              	.LVL98:
 1310 09fc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1311              	.LCFI11:
 1312              		.cfi_def_cfa_offset 16
 1313 0a00 0160A0E1 		mov	r6, r1
 1314              		.cfi_offset 14, -4
 1315              		.cfi_offset 6, -8
 1316              		.cfi_offset 5, -12
 1317              		.cfi_offset 4, -16
 1318 0a04 08D04DE2 		sub	sp, sp, #8
 1319              	.LCFI12:
 1320              		.cfi_def_cfa_offset 24
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1321              		.loc 1 385 0
 1322 0a08 0050A0E3 		mov	r5, #0
 381:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1323              		.loc 1 381 0
 1324 0a0c 0040A0E1 		mov	r4, r0
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1325              		.loc 1 384 0
 1326 0a10 0010E0E3 		mvn	r1, #0
 1327              	.LVL99:
 1328 0a14 1C0090E5 		ldr	r0, [r0, #28]
 1329              	.LVL100:
 1330 0a18 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1331              		.loc 1 385 0
 1332 0a1c 060065E0 		rsb	r0, r5, r6
 1333 0a20 00C070E2 		rsbs	ip, r0, #0
 1334 0a24 00C0ACE0 		adc	ip, ip, r0
 1335 0a28 2010A0E3 		mov	r1, #32
 1336 0a2c 2720A0E3 		mov	r2, #39
 1337 0a30 3030A0E3 		mov	r3, #48
 1338 0a34 0400A0E1 		mov	r0, r4
 1339 0a38 00C08DE5 		str	ip, [sp, #0]
 1340 0a3c 04508DE5 		str	r5, [sp, #4]
 1341 0a40 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 1342              		.loc 1 386 0
 1343 0a44 050056E1 		cmp	r6, r5
 1344 0a48 0260A003 		moveq	r6, #2
 1345 0a4c 0560A011 		movne	r6, r5
 1346 0a50 0400A0E1 		mov	r0, r4
 1347 0a54 2110A0E3 		mov	r1, #33
 1348 0a58 2520A0E3 		mov	r2, #37
 1349 0a5c 3030A0E3 		mov	r3, #48
 1350 0a60 00608DE5 		str	r6, [sp, #0]
 1351 0a64 04508DE5 		str	r5, [sp, #4]
 1352 0a68 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1353              		.loc 1 387 0
 1354 0a6c 1C0094E5 		ldr	r0, [r4, #28]
 388:../uvc.c      **** }
 1355              		.loc 1 388 0
 1356 0a70 08D08DE2 		add	sp, sp, #8
 1357 0a74 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1358              		.loc 1 387 0
 1359 0a78 FEFFFFEA 		b	_txe_mutex_put
 1360              		.cfi_endproc
 1361              	.LFE1:
 1363              		.align	2
 1364              		.global	ControlHandle
 1366              	ControlHandle:
 1367              	.LFB2:
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1368              		.loc 1 390 0
 1369              		.cfi_startproc
 1370              		@ args = 0, pretend = 0, frame = 24
 1371              		@ frame_needed = 0, uses_anonymous_args = 0
 1372              	.LVL101:
 1373 0a7c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1374              	.LCFI13:
 1375              		.cfi_def_cfa_offset 36
 397:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1376              		.loc 1 397 0
 1377 0a80 230050E3 		cmp	r0, #35
 396:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1378              		.loc 1 396 0
 1379 0a84 207040E2 		sub	r7, r0, #32
 1380              		.cfi_offset 14, -4
 1381              		.cfi_offset 11, -8
 1382              		.cfi_offset 10, -12
 1383              		.cfi_offset 9, -16
 1384              		.cfi_offset 8, -20
 1385              		.cfi_offset 7, -24
 1386              		.cfi_offset 6, -28
 1387              		.cfi_offset 5, -32
 1388              		.cfi_offset 4, -36
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1389              		.loc 1 390 0
 1390 0a88 2CD04DE2 		sub	sp, sp, #44
 1391              	.LCFI14:
 1392              		.cfi_def_cfa_offset 80
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1393              		.loc 1 390 0
 1394 0a8c 0040A0E1 		mov	r4, r0
 396:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1395              		.loc 1 396 0
 1396 0a90 FF7007E2 		and	r7, r7, #255
 1397              	.LVL102:
 397:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1398              		.loc 1 397 0
 1399 0a94 2400009A 		bls	.L102
 398:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1400              		.loc 1 398 0
 1401 0a98 EC6E9FE5 		ldr	r6, .L206
 1402 0a9c 872087E0 		add	r2, r7, r7, asl #1
 1403 0aa0 8221A0E1 		mov	r2, r2, asl #3
 1404 0aa4 023086E0 		add	r3, r6, r2
 399:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1405              		.loc 1 399 0
 1406 0aa8 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 400:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1407              		.loc 1 400 0
 1408 0aac 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 401:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1409              		.loc 1 401 0
 1410 0ab0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 412:../uvc.c      ****     reqData = bRequest;
 1411              		.loc 1 412 0
 1412 0ab4 D43E9FE5 		ldr	r3, .L206+4
 398:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1413              		.loc 1 398 0
 1414 0ab8 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1415              	.LVL103:
 412:../uvc.c      ****     reqData = bRequest;
 1416              		.loc 1 412 0
 1417 0abc 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1418              	.LVL104:
 420:../uvc.c      ****     switch (bRequest)
 1419              		.loc 1 420 0
 1420 0ac0 830055E3 		cmp	r5, #131
 1421 0ac4 2300000A 		beq	.L108
 1422              	.LVL105:
 1423              	.L203:
 1424 0ac8 2C00009A 		bls	.L201
 1425 0acc 850055E3 		cmp	r5, #133
 1426 0ad0 8B00000A 		beq	.L110
 1427 0ad4 7900003A 		bcc	.L109
 1428 0ad8 860055E3 		cmp	r5, #134
 1429 0adc C800000A 		beq	.L111
 1430 0ae0 870055E3 		cmp	r5, #135
 1431 0ae4 BC00000A 		beq	.L202
 1432              	.L104:
 896:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1433              		.loc 1 896 0
 1434 0ae8 0000A0E3 		mov	r0, #0
 1435 0aec 0110A0E3 		mov	r1, #1
 1436 0af0 0020A0E1 		mov	r2, r0
 1437 0af4 FEFFFFEB 		bl	CyU3PUsbStall
 897:../uvc.c      **** 			  break;
 1438              		.loc 1 897 0
 1439 0af8 FFC0A0E3 		mov	ip, #255
 1440 0afc 0C70A0E1 		mov	r7, ip
 1441              	.LVL106:
 1442 0b00 0CE0A0E1 		mov	lr, ip
 1443 0b04 0C40A0E1 		mov	r4, ip
 1444              	.LVL107:
 1445              	.L114:
 899:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1446              		.loc 1 899 0
 1447 0b08 841E9FE5 		ldr	r1, .L206+8
 1448 0b0c 0520A0E1 		mov	r2, r5
 1449 0b10 0430A0E1 		mov	r3, r4
 1450 0b14 0400A0E3 		mov	r0, #4
 1451 0b18 00E08DE5 		str	lr, [sp, #0]
 1452 0b1c 80108DE9 		stmib	sp, {r7, ip}	@ phole stm
 1453 0b20 FEFFFFEB 		bl	CyU3PDebugPrint
 900:../uvc.c      **** }
 1454              		.loc 1 900 0
 1455 0b24 2CD08DE2 		add	sp, sp, #44
 1456 0b28 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1457              	.LVL108:
 1458              	.L102:
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1459              		.loc 1 403 0
 1460 0b2c 586E9FE5 		ldr	r6, .L206
 412:../uvc.c      ****     reqData = bRequest;
 1461              		.loc 1 412 0
 1462 0b30 583E9FE5 		ldr	r3, .L206+4
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1463              		.loc 1 403 0
 1464 0b34 805080E0 		add	r5, r0, r0, asl #1
 1465 0b38 850186E0 		add	r0, r6, r5, asl #3
 1466              	.LVL109:
 412:../uvc.c      ****     reqData = bRequest;
 1467              		.loc 1 412 0
 1468 0b3c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1469              		.loc 1 403 0
 1470 0b40 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1471              	.LVL110:
 420:../uvc.c      ****     switch (bRequest)
 1472              		.loc 1 420 0
 1473 0b44 830055E3 		cmp	r5, #131
 404:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1474              		.loc 1 404 0
 1475 0b48 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1476              	.LVL111:
 405:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1477              		.loc 1 405 0
 1478 0b4c 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1479              	.LVL112:
 406:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1480              		.loc 1 406 0
 1481 0b50 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1482              	.LVL113:
 420:../uvc.c      ****     switch (bRequest)
 1483              		.loc 1 420 0
 1484 0b54 DBFFFF1A 		bne	.L203
 1485              	.LVL114:
 1486              	.L108:
 543:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1487              		.loc 1 543 0
 1488 0b58 230054E3 		cmp	r4, #35
 1489 0b5c C600009A 		bls	.L136
 544:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1490              		.loc 1 544 0
 1491 0b60 870087E0 		add	r0, r7, r7, asl #1
 1492 0b64 806186E0 		add	r6, r6, r0, asl #3
 1493 0b68 28AE9FE5 		ldr	sl, .L206+12
 1494 0b6c 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
 545:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1495              		.loc 1 545 0
 1496 0b70 06E0D6E5 		ldrb	lr, [r6, #6]	@ zero_extendqisi2
 544:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1497              		.loc 1 544 0
 1498 0b74 58C0CAE5 		strb	ip, [sl, #88]
 545:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1499              		.loc 1 545 0
 1500 0b78 59E0CAE5 		strb	lr, [sl, #89]
 1501 0b7c 0B0000EA 		b	.L144
 1502              	.L201:
 420:../uvc.c      ****     switch (bRequest)
 1503              		.loc 1 420 0
 1504 0b80 810055E3 		cmp	r5, #129
 1505 0b84 6A00000A 		beq	.L106
 1506 0b88 1000009A 		bls	.L204
 524:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1507              		.loc 1 524 0
 1508 0b8c 230054E3 		cmp	r4, #35
 1509 0b90 AD00009A 		bls	.L133
 525:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1510              		.loc 1 525 0
 1511 0b94 87A087E0 		add	sl, r7, r7, asl #1
 1512 0b98 8A6186E0 		add	r6, r6, sl, asl #3
 1513 0b9c 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 1514 0ba0 F0AD9FE5 		ldr	sl, .L206+12
 526:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1515              		.loc 1 526 0
 1516 0ba4 0470D6E5 		ldrb	r7, [r6, #4]	@ zero_extendqisi2
 1517              	.LVL115:
 525:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1518              		.loc 1 525 0
 1519 0ba8 5840CAE5 		strb	r4, [sl, #88]
 526:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1520              		.loc 1 526 0
 1521 0bac 5970CAE5 		strb	r7, [sl, #89]
 1522              	.L144:
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1523              		.loc 1 602 0
 1524 0bb0 0800A0E1 		mov	r0, r8
 1525 0bb4 E01D9FE5 		ldr	r1, .L206+16
 1526 0bb8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1527              	.LVL116:
 604:../uvc.c      **** 			  break;
 1528              		.loc 1 604 0
 1529 0bbc FFC0A0E3 		mov	ip, #255
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1530              		.loc 1 602 0
 1531 0bc0 5870DAE5 		ldrb	r7, [sl, #88]	@ zero_extendqisi2
 604:../uvc.c      **** 			  break;
 1532              		.loc 1 604 0
 1533 0bc4 0CE0A0E1 		mov	lr, ip
 1534 0bc8 0C40A0E1 		mov	r4, ip
 1535 0bcc CDFFFFEA 		b	.L114
 1536              	.LVL117:
 1537              	.L204:
 420:../uvc.c      ****     switch (bRequest)
 1538              		.loc 1 420 0
 1539 0bd0 010055E3 		cmp	r5, #1
 1540 0bd4 C3FFFF1A 		bne	.L104
 606:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1541              		.loc 1 606 0
 1542 0bd8 B81D9FE5 		ldr	r1, .L206+12
 1543 0bdc 26208DE2 		add	r2, sp, #38
 1544 0be0 2000A0E3 		mov	r0, #32
 1545 0be4 581081E2 		add	r1, r1, #88
 1546 0be8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1547              	.LVL118:
 608:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1548              		.loc 1 608 0
 1549 0bec 002050E2 		subs	r2, r0, #0
 1550 0bf0 4103001A 		bne	.L146
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1551              		.loc 1 610 0
 1552 0bf4 9C3D9FE5 		ldr	r3, .L206+12
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1553              		.loc 1 611 0
 1554 0bf8 980D9FE5 		ldr	r0, .L206+12
 1555              	.LVL119:
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1556              		.loc 1 613 0
 1557 0bfc 94ED9FE5 		ldr	lr, .L206+12
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1558              		.loc 1 610 0
 1559 0c00 5830D3E5 		ldrb	r3, [r3, #88]	@ zero_extendqisi2
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1560              		.loc 1 611 0
 1561 0c04 59C0D0E5 		ldrb	ip, [r0, #89]	@ zero_extendqisi2
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1562              		.loc 1 613 0
 1563 0c08 5AE0DEE5 		ldrb	lr, [lr, #90]	@ zero_extendqisi2
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1564              		.loc 1 610 0
 1565 0c0c 14308DE5 		str	r3, [sp, #20]
 1566              	.LVL120:
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1567              		.loc 1 611 0
 1568 0c10 1CC08DE5 		str	ip, [sp, #28]
 1569              	.LVL121:
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1570              		.loc 1 613 0
 1571 0c14 18E08DE5 		str	lr, [sp, #24]
 1572              	.LVL122:
 617:../uvc.c      **** 				  switch(CtrlID)
 1573              		.loc 1 617 0
 1574 0c18 260054E3 		cmp	r4, #38
 1575 0c1c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1576 0c20 1B0300EA 		b	.L147
 1577              	.L163:
 1578 0c24 18180000 		.word	.L148
 1579 0c28 58170000 		.word	.L149
 1580 0c2c 94180000 		.word	.L147
 1581 0c30 94180000 		.word	.L147
 1582 0c34 F4160000 		.word	.L150
 1583 0c38 B4150000 		.word	.L151
 1584 0c3c 38150000 		.word	.L152
 1585 0c40 94180000 		.word	.L147
 1586 0c44 94180000 		.word	.L147
 1587 0c48 94180000 		.word	.L147
 1588 0c4c 94180000 		.word	.L147
 1589 0c50 B0140000 		.word	.L153
 1590 0c54 94180000 		.word	.L147
 1591 0c58 94180000 		.word	.L147
 1592 0c5c 94180000 		.word	.L147
 1593 0c60 94180000 		.word	.L147
 1594 0c64 2C140000 		.word	.L154
 1595 0c68 94180000 		.word	.L147
 1596 0c6c 94180000 		.word	.L147
 1597 0c70 94180000 		.word	.L147
 1598 0c74 94180000 		.word	.L147
 1599 0c78 94180000 		.word	.L147
 1600 0c7c 94180000 		.word	.L147
 1601 0c80 94180000 		.word	.L147
 1602 0c84 94180000 		.word	.L147
 1603 0c88 74130000 		.word	.L155
 1604 0c8c DC120000 		.word	.L156
 1605 0c90 94180000 		.word	.L147
 1606 0c94 CC120000 		.word	.L157
 1607 0c98 94180000 		.word	.L147
 1608 0c9c 70120000 		.word	.L158
 1609 0ca0 EC110000 		.word	.L159
 1610 0ca4 94180000 		.word	.L147
 1611 0ca8 94180000 		.word	.L147
 1612 0cac 94180000 		.word	.L147
 1613 0cb0 94180000 		.word	.L147
 1614 0cb4 50110000 		.word	.L160
 1615 0cb8 38110000 		.word	.L161
 1616 0cbc D4100000 		.word	.L162
 1617              	.LVL123:
 1618              	.L109:
 561:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1619              		.loc 1 561 0
 1620 0cc0 230054E3 		cmp	r4, #35
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1621              		.loc 1 562 0
 1622 0cc4 87708780 		addhi	r7, r7, r7, asl #1
 1623              	.LVL124:
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1624              		.loc 1 568 0
 1625 0cc8 84408490 		addls	r4, r4, r4, asl #1
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1626              		.loc 1 562 0
 1627 0ccc 87618680 		addhi	r6, r6, r7, asl #3
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1628              		.loc 1 568 0
 1629 0cd0 84618690 		addls	r6, r6, r4, asl #3
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1630              		.loc 1 562 0
 1631 0cd4 BCAC9F85 		ldrhi	sl, .L206+12
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1632              		.loc 1 568 0
 1633 0cd8 B8AC9F95 		ldrls	sl, .L206+12
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1634              		.loc 1 562 0
 1635 0cdc 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 563:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1636              		.loc 1 563 0
 1637 0ce0 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1638              		.loc 1 568 0
 1639 0ce4 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 569:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1640              		.loc 1 569 0
 1641 0ce8 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 570:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1642              		.loc 1 570 0
 1643 0cec 0030A0E3 		mov	r3, #0
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1644              		.loc 1 568 0
 1645 0cf0 5810CAE5 		strb	r1, [sl, #88]
 569:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1646              		.loc 1 569 0
 1647 0cf4 5920CAE5 		strb	r2, [sl, #89]
 570:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1648              		.loc 1 570 0
 1649 0cf8 5A30CAE5 		strb	r3, [sl, #90]
 571:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1650              		.loc 1 571 0
 1651 0cfc 5B30CAE5 		strb	r3, [sl, #91]
 1652 0d00 AAFFFFEA 		b	.L144
 1653              	.LVL125:
 1654              	.L110:
 424:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1655              		.loc 1 424 0
 1656 0d04 8C4C9FE5 		ldr	r4, .L206+12
 425:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1657              		.loc 1 425 0
 1658 0d08 00C0A0E3 		mov	ip, #0
 1659 0d0c 59C0C4E5 		strb	ip, [r4, #89]
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1660              		.loc 1 426 0
 1661 0d10 581084E2 		add	r1, r4, #88
 424:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1662              		.loc 1 424 0
 1663 0d14 5880C4E5 		strb	r8, [r4, #88]
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1664              		.loc 1 426 0
 1665 0d18 0200A0E3 		mov	r0, #2
 1666 0d1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1667              	.LVL126:
 428:../uvc.c      **** 			  break;
 1668              		.loc 1 428 0
 1669 0d20 FFC0A0E3 		mov	ip, #255
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1670              		.loc 1 426 0
 1671 0d24 5870D4E5 		ldrb	r7, [r4, #88]	@ zero_extendqisi2
 1672              	.LVL127:
 428:../uvc.c      **** 			  break;
 1673              		.loc 1 428 0
 1674 0d28 0CE0A0E1 		mov	lr, ip
 1675 0d2c 0C40A0E1 		mov	r4, ip
 1676 0d30 74FFFFEA 		b	.L114
 1677              	.LVL128:
 1678              	.L106:
 431:../uvc.c      **** 			 switch(CtrlID)
 1679              		.loc 1 431 0
 1680 0d34 011044E2 		sub	r1, r4, #1
 1681 0d38 250051E3 		cmp	r1, #37
 1682 0d3c 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1683 0d40 DA0000EA 		b	.L115
 1684              	.L123:
 1685 0d44 6C100000 		.word	.L116
 1686 0d48 B0100000 		.word	.L115
 1687 0d4c B0100000 		.word	.L115
 1688 0d50 B0100000 		.word	.L115
 1689 0d54 4C100000 		.word	.L117
 1690 0d58 B0100000 		.word	.L115
 1691 0d5c B0100000 		.word	.L115
 1692 0d60 B0100000 		.word	.L115
 1693 0d64 B0100000 		.word	.L115
 1694 0d68 B0100000 		.word	.L115
 1695 0d6c 28100000 		.word	.L118
 1696 0d70 B0100000 		.word	.L115
 1697 0d74 B0100000 		.word	.L115
 1698 0d78 B0100000 		.word	.L115
 1699 0d7c B0100000 		.word	.L115
 1700 0d80 B0100000 		.word	.L115
 1701 0d84 B0100000 		.word	.L115
 1702 0d88 B0100000 		.word	.L115
 1703 0d8c B0100000 		.word	.L115
 1704 0d90 B0100000 		.word	.L115
 1705 0d94 B0100000 		.word	.L115
 1706 0d98 B0100000 		.word	.L115
 1707 0d9c B0100000 		.word	.L115
 1708 0da0 B0100000 		.word	.L115
 1709 0da4 EC0F0000 		.word	.L119
 1710 0da8 B0100000 		.word	.L115
 1711 0dac B0100000 		.word	.L115
 1712 0db0 D00F0000 		.word	.L120
 1713 0db4 B0100000 		.word	.L115
 1714 0db8 B0100000 		.word	.L115
 1715 0dbc 340F0000 		.word	.L121
 1716 0dc0 B0100000 		.word	.L115
 1717 0dc4 B0100000 		.word	.L115
 1718 0dc8 B0100000 		.word	.L115
 1719 0dcc B0100000 		.word	.L115
 1720 0dd0 F80E0000 		.word	.L122
 1721 0dd4 F80E0000 		.word	.L122
 1722 0dd8 F80E0000 		.word	.L122
 1723              	.L202:
 588:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1724              		.loc 1 588 0
 1725 0ddc 230054E3 		cmp	r4, #35
 1726 0de0 3100009A 		bls	.L143
 589:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1727              		.loc 1 589 0
 1728 0de4 877087E0 		add	r7, r7, r7, asl #1
 1729              	.LVL129:
 1730 0de8 876186E0 		add	r6, r6, r7, asl #3
 1731 0dec A4AB9FE5 		ldr	sl, .L206+12
 1732 0df0 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 590:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1733              		.loc 1 590 0
 1734 0df4 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 589:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1735              		.loc 1 589 0
 1736 0df8 5820CAE5 		strb	r2, [sl, #88]
 590:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1737              		.loc 1 590 0
 1738 0dfc 5910CAE5 		strb	r1, [sl, #89]
 1739 0e00 6AFFFFEA 		b	.L144
 1740              	.LVL130:
 1741              	.L111:
 577:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1742              		.loc 1 577 0
 1743 0e04 230054E3 		cmp	r4, #35
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1744              		.loc 1 578 0
 1745 0e08 87708780 		addhi	r7, r7, r7, asl #1
 1746              	.LVL131:
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1747              		.loc 1 581 0
 1748 0e0c 84408490 		addls	r4, r4, r4, asl #1
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1749              		.loc 1 578 0
 1750 0e10 87618680 		addhi	r6, r6, r7, asl #3
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1751              		.loc 1 581 0
 1752 0e14 84618690 		addls	r6, r6, r4, asl #3
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1753              		.loc 1 578 0
 1754 0e18 788B9F85 		ldrhi	r8, .L206+12
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1755              		.loc 1 581 0
 1756 0e1c 748B9F95 		ldrls	r8, .L206+12
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1757              		.loc 1 578 0
 1758 0e20 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1759              		.loc 1 581 0
 1760 0e24 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1761              		.loc 1 583 0
 1762 0e28 0100A0E3 		mov	r0, #1
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1763              		.loc 1 581 0
 1764 0e2c 5830C8E5 		strb	r3, [r8, #88]
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1765              		.loc 1 583 0
 1766 0e30 641B9FE5 		ldr	r1, .L206+16
 1767 0e34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1768              	.LVL132:
 586:../uvc.c      **** 			  break;
 1769              		.loc 1 586 0
 1770 0e38 FFC0A0E3 		mov	ip, #255
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1771              		.loc 1 583 0
 1772 0e3c 5870D8E5 		ldrb	r7, [r8, #88]	@ zero_extendqisi2
 586:../uvc.c      **** 			  break;
 1773              		.loc 1 586 0
 1774 0e40 0CE0A0E1 		mov	lr, ip
 1775 0e44 0C40A0E1 		mov	r4, ip
 1776 0e48 2EFFFFEA 		b	.L114
 1777              	.LVL133:
 1778              	.L133:
 529:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1779              		.loc 1 529 0
 1780 0e4c 0B0054E3 		cmp	r4, #11
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1781              		.loc 1 536 0
 1782 0e50 84408410 		addne	r4, r4, r4, asl #1
 1783 0e54 84618610 		addne	r6, r6, r4, asl #3
 1784 0e58 38AB9F15 		ldrne	sl, .L206+12
 530:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1785              		.loc 1 530 0
 1786 0e5c 34AB9F05 		ldreq	sl, .L206+12
 1787 0e60 383B9F05 		ldreq	r3, .L206+20
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1788              		.loc 1 536 0
 1789 0e64 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 537:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1790              		.loc 1 537 0
 1791 0e68 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 530:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1792              		.loc 1 530 0
 1793 0e6c 58308A05 		streq	r3, [sl, #88]
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1794              		.loc 1 536 0
 1795 0e70 5820CA15 		strneb	r2, [sl, #88]
 537:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1796              		.loc 1 537 0
 1797 0e74 5930CA15 		strneb	r3, [sl, #89]
 1798 0e78 4CFFFFEA 		b	.L144
 1799              	.L136:
 547:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1800              		.loc 1 547 0
 1801 0e7c 0B0054E3 		cmp	r4, #11
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1802              		.loc 1 554 0
 1803 0e80 84408410 		addne	r4, r4, r4, asl #1
 1804 0e84 84618610 		addne	r6, r6, r4, asl #3
 1805 0e88 08AB9F15 		ldrne	sl, .L206+12
 548:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1806              		.loc 1 548 0
 1807 0e8c 04AB9F05 		ldreq	sl, .L206+12
 1808 0e90 0C3B9F05 		ldreq	r3, .L206+24
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1809              		.loc 1 554 0
 1810 0e94 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 555:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1811              		.loc 1 555 0
 1812 0e98 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 548:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1813              		.loc 1 548 0
 1814 0e9c 58308A05 		streq	r3, [sl, #88]
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1815              		.loc 1 554 0
 1816 0ea0 5820CA15 		strneb	r2, [sl, #88]
 555:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1817              		.loc 1 555 0
 1818 0ea4 5930CA15 		strneb	r3, [sl, #89]
 1819 0ea8 40FFFFEA 		b	.L144
 1820              	.L143:
 593:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1821              		.loc 1 593 0
 1822 0eac 0B0054E3 		cmp	r4, #11
 1823 0eb0 0700000A 		beq	.L205
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1824              		.loc 1 599 0
 1825 0eb4 84A084E0 		add	sl, r4, r4, asl #1
 1826 0eb8 8A6186E0 		add	r6, r6, sl, asl #3
 1827 0ebc 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1828 0ec0 D0AA9FE5 		ldr	sl, .L206+12
 600:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1829              		.loc 1 600 0
 1830 0ec4 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1831              		.loc 1 599 0
 1832 0ec8 5830CAE5 		strb	r3, [sl, #88]
 600:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1833              		.loc 1 600 0
 1834 0ecc 5900CAE5 		strb	r0, [sl, #89]
 1835 0ed0 36FFFFEA 		b	.L144
 1836              	.L205:
 594:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1837              		.loc 1 594 0
 1838 0ed4 BCAA9FE5 		ldr	sl, .L206+12
 1839 0ed8 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 596:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1840              		.loc 1 596 0
 1841 0edc 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 595:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1842              		.loc 1 595 0
 1843 0ee0 0040A0E3 		mov	r4, #0
 594:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1844              		.loc 1 594 0
 1845 0ee4 58C0CAE5 		strb	ip, [sl, #88]
 595:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1846              		.loc 1 595 0
 1847 0ee8 5940CAE5 		strb	r4, [sl, #89]
 596:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1848              		.loc 1 596 0
 1849 0eec 5AE0CAE5 		strb	lr, [sl, #90]
 597:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1850              		.loc 1 597 0
 1851 0ef0 5B40CAE5 		strb	r4, [sl, #91]
 1852 0ef4 2DFFFFEA 		b	.L144
 1853              	.L122:
 437:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1854              		.loc 1 437 0
 1855 0ef8 877087E0 		add	r7, r7, r7, asl #1
 1856              	.LVL134:
 1857 0efc 876186E0 		add	r6, r6, r7, asl #3
 1858 0f00 90EA9FE5 		ldr	lr, .L206+12
 1859 0f04 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 438:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1860              		.loc 1 438 0
 1861 0f08 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 437:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1862              		.loc 1 437 0
 1863 0f0c 5840CEE5 		strb	r4, [lr, #88]
 438:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1864              		.loc 1 438 0
 1865 0f10 5960CEE5 		strb	r6, [lr, #89]
 1866              	.LVL135:
 1867              	.L126:
 517:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1868              		.loc 1 517 0
 1869 0f14 0800A0E1 		mov	r0, r8
 1870 0f18 7C1A9FE5 		ldr	r1, .L206+16
 1871 0f1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 522:../uvc.c      **** 			  break;
 1872              		.loc 1 522 0
 1873 0f20 FFE0A0E3 		mov	lr, #255
 517:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1874              		.loc 1 517 0
 1875 0f24 0470A0E1 		mov	r7, r4
 1876 0f28 06C0A0E1 		mov	ip, r6
 522:../uvc.c      **** 			  break;
 1877              		.loc 1 522 0
 1878 0f2c 0E40A0E1 		mov	r4, lr
 1879              	.LVL136:
 1880 0f30 F4FEFFEA 		b	.L114
 1881              	.LVL137:
 1882              	.L121:
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1883              		.loc 1 458 0 discriminator 1
 1884 0f34 000058E3 		cmp	r8, #0
 1885 0f38 8C02000A 		beq	.L196
 456:../uvc.c      **** 					 break;
 1886              		.loc 1 456 0
 1887 0f3c 28E1A0E1 		mov	lr, r8, lsr #2
 1888 0f40 00005EE3 		cmp	lr, #0
 1889 0f44 03005813 		cmpne	r8, #3
 1890 0f48 0020A083 		movhi	r2, #0
 1891 0f4c 0120A093 		movls	r2, #1
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1892              		.loc 1 390 0
 1893 0f50 0E31A0E1 		mov	r3, lr, asl #2
 456:../uvc.c      **** 					 break;
 1894              		.loc 1 456 0
 1895 0f54 8902009A 		bls	.L184
 1896 0f58 3C1A9FE5 		ldr	r1, .L206+16
 1897 0f5c 0C0041E2 		sub	r0, r1, #12
 1898              	.LVL138:
 1899              	.L128:
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1900              		.loc 1 459 0 discriminator 2
 1901 0f60 044090E4 		ldr	r4, [r0], #4
 1902 0f64 01C082E2 		add	ip, r2, #1
 1903 0f68 FF200CE2 		and	r2, ip, #255
 1904 0f6c 02005EE1 		cmp	lr, r2
 1905 0f70 044081E4 		str	r4, [r1], #4
 1906 0f74 F9FFFF8A 		bhi	.L128
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1907              		.loc 1 459 0 is_stmt 0
 1908 0f78 030058E1 		cmp	r8, r3
 1909 0f7c 140A9F15 		ldrne	r0, .L206+12
 1910 0f80 7A02000A 		beq	.L196
 1911              	.L188:
 1912 0f84 03E080E0 		add	lr, r0, r3
 1913 0f88 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1914              		.loc 1 458 0 is_stmt 1
 1915 0f8c 016083E2 		add	r6, r3, #1
 1916 0f90 FF3006E2 		and	r3, r6, #255
 1917              	.LVL139:
 1918 0f94 030058E1 		cmp	r8, r3
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1919              		.loc 1 459 0
 1920 0f98 5810CEE5 		strb	r1, [lr, #88]
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1921              		.loc 1 458 0
 1922 0f9c F8FFFF8A 		bhi	.L188
 1923              	.LVL140:
 1924              	.L125:
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1925              		.loc 1 468 0
 1926 0fa0 5770D0E5 		ldrb	r7, [r0, #87]	@ zero_extendqisi2
 1927              	.LVL141:
 461:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1928              		.loc 1 461 0
 1929 0fa4 EC399FE5 		ldr	r3, .L206+12
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1930              		.loc 1 468 0
 1931 0fa8 FF0057E3 		cmp	r7, #255
 461:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1932              		.loc 1 461 0
 1933 0fac 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1934              	.LVL142:
 462:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1935              		.loc 1 462 0
 1936 0fb0 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 1937              	.LVL143:
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1938              		.loc 1 468 0
 1939 0fb4 D6FFFF0A 		beq	.L126
 470:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1940              		.loc 1 470 0
 1941 0fb8 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1942 0fbc E4199FE5 		ldr	r1, .L206+28
 1943 0fc0 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1944 0fc4 0400A0E3 		mov	r0, #4
 1945 0fc8 FEFFFFEB 		bl	CyU3PDebugPrint
 1946 0fcc D0FFFFEA 		b	.L126
 1947              	.LVL144:
 1948              	.L120:
 454:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 1949              		.loc 1 454 0
 1950 0fd0 C0399FE5 		ldr	r3, .L206+12
 444:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 1951              		.loc 1 444 0
 1952 0fd4 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 1953              	.LVL145:
 455:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1954              		.loc 1 455 0
 1955 0fd8 0020A0E3 		mov	r2, #0
 454:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 1956              		.loc 1 454 0
 1957 0fdc 5840C3E5 		strb	r4, [r3, #88]
 455:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1958              		.loc 1 455 0
 1959 0fe0 5920C3E5 		strb	r2, [r3, #89]
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 1960              		.loc 1 408 0
 1961 0fe4 FF60A0E3 		mov	r6, #255
 456:../uvc.c      **** 					 break;
 1962              		.loc 1 456 0
 1963 0fe8 C9FFFFEA 		b	.L126
 1964              	.LVL146:
 1965              	.L119:
 474:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1966              		.loc 1 474 0
 1967 0fec E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 1968 0ff0 A0C99FE5 		ldr	ip, .L206+12
 476:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1969              		.loc 1 476 0
 1970 0ff4 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 475:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1971              		.loc 1 475 0
 1972 0ff8 00E0A0E3 		mov	lr, #0
 474:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1973              		.loc 1 474 0
 1974 0ffc 5840CCE5 		strb	r4, [ip, #88]
 475:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1975              		.loc 1 475 0
 1976 1000 59E0CCE5 		strb	lr, [ip, #89]
 476:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1977              		.loc 1 476 0
 1978 1004 5A60CCE5 		strb	r6, [ip, #90]
 477:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1979              		.loc 1 477 0
 1980 1008 5BE0CCE5 		strb	lr, [ip, #91]
 1981              	.LVL147:
 480:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 1982              		.loc 1 480 0
 1983 100c 98199FE5 		ldr	r1, .L206+32
 1984 1010 0420A0E1 		mov	r2, r4
 1985 1014 0E30A0E1 		mov	r3, lr
 1986 1018 0400A0E3 		mov	r0, #4
 1987 101c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 1988 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 481:../uvc.c      **** 					 break;
 1989              		.loc 1 481 0
 1990 1024 BAFFFFEA 		b	.L126
 1991              	.LVL148:
 1992              	.L118:
 502:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 1993              		.loc 1 502 0
 1994 1028 68C99FE5 		ldr	ip, .L206+12
 1995 102c 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 504:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 1996              		.loc 1 504 0
 1997 1030 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 503:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1998              		.loc 1 503 0
 1999 1034 00E0A0E3 		mov	lr, #0
 502:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2000              		.loc 1 502 0
 2001 1038 5840CCE5 		strb	r4, [ip, #88]
 503:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2002              		.loc 1 503 0
 2003 103c 59E0CCE5 		strb	lr, [ip, #89]
 504:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2004              		.loc 1 504 0
 2005 1040 5A60CCE5 		strb	r6, [ip, #90]
 505:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2006              		.loc 1 505 0
 2007 1044 5BE0CCE5 		strb	lr, [ip, #91]
 2008              	.LVL149:
 508:../uvc.c      **** 					 break;
 2009              		.loc 1 508 0
 2010 1048 B1FFFFEA 		b	.L126
 2011              	.LVL150:
 2012              	.L117:
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2013              		.loc 1 497 0
 2014 104c 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 2015 1050 40799FE5 		ldr	r7, .L206+12
 2016              	.LVL151:
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2017              		.loc 1 498 0
 2018 1054 0060A0E3 		mov	r6, #0
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2019              		.loc 1 497 0
 2020 1058 804024E2 		eor	r4, r4, #128
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2021              		.loc 1 498 0
 2022 105c 5960C7E5 		strb	r6, [r7, #89]
 2023              	.LVL152:
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2024              		.loc 1 497 0
 2025 1060 5840C7E5 		strb	r4, [r7, #88]
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2026              		.loc 1 408 0
 2027 1064 FF60A0E3 		mov	r6, #255
 500:../uvc.c      **** 					 break;
 2028              		.loc 1 500 0
 2029 1068 A9FFFFEA 		b	.L126
 2030              	.LVL153:
 2031              	.L116:
 486:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2032              		.loc 1 486 0
 2033 106c A631D6E5 		ldrb	r3, [r6, #422]	@ zero_extendqisi2
 484:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2034              		.loc 1 484 0
 2035 1070 A511D6E5 		ldrb	r1, [r6, #421]	@ zero_extendqisi2
 2036              	.LVL154:
 486:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2037              		.loc 1 486 0
 2038 1074 020013E3 		tst	r3, #2
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2039              		.loc 1 489 0
 2040 1078 2111A001 		moveq	r1, r1, lsr #2
 2041              	.LVL155:
 2042 107c 811CE001 		mvneq	r1, r1, asl #25
 491:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2043              		.loc 1 491 0
 2044 1080 10299FE5 		ldr	r2, .L206+12
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2045              		.loc 1 487 0
 2046 1084 0333A011 		movne	r3, r3, asl #6
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2047              		.loc 1 489 0
 2048 1088 A11CE001 		mvneq	r1, r1, lsr #25
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2049              		.loc 1 487 0
 2050 108c 40400312 		andne	r4, r3, #64
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2051              		.loc 1 489 0
 2052 1090 03338101 		orreq	r3, r1, r3, asl #6
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2053              		.loc 1 487 0
 2054 1094 21418411 		orrne	r4, r4, r1, lsr #2
 2055              	.LVL156:
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2056              		.loc 1 489 0
 2057 1098 FF400302 		andeq	r4, r3, #255
 2058              	.LVL157:
 492:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2059              		.loc 1 492 0
 2060 109c 0000A0E3 		mov	r0, #0
 491:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2061              		.loc 1 491 0
 2062 10a0 5840C2E5 		strb	r4, [r2, #88]
 492:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2063              		.loc 1 492 0
 2064 10a4 5900C2E5 		strb	r0, [r2, #89]
 2065              	.LVL158:
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2066              		.loc 1 408 0
 2067 10a8 FF60A0E3 		mov	r6, #255
 494:../uvc.c      **** 					 break;
 2068              		.loc 1 494 0
 2069 10ac 98FFFFEA 		b	.L126
 2070              	.LVL159:
 2071              	.L115:
 511:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2072              		.loc 1 511 0
 2073 10b0 841084E0 		add	r1, r4, r4, asl #1
 2074 10b4 813186E0 		add	r3, r6, r1, asl #3
 2075 10b8 D8289FE5 		ldr	r2, .L206+12
 2076 10bc 8D41D3E5 		ldrb	r4, [r3, #397]	@ zero_extendqisi2
 512:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2077              		.loc 1 512 0
 2078 10c0 0000A0E3 		mov	r0, #0
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2079              		.loc 1 408 0
 2080 10c4 FF60A0E3 		mov	r6, #255
 511:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2081              		.loc 1 511 0
 2082 10c8 5840C2E5 		strb	r4, [r2, #88]
 512:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2083              		.loc 1 512 0
 2084 10cc 5900C2E5 		strb	r0, [r2, #89]
 2085              	.LVL160:
 514:../uvc.c      **** 					 break;
 2086              		.loc 1 514 0
 2087 10d0 8FFFFFEA 		b	.L126
 2088              	.LVL161:
 2089              	.L162:
 761:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2090              		.loc 1 761 0
 2091 10d4 D4489FE5 		ldr	r4, .L206+36
 2092 10d8 0010E0E3 		mvn	r1, #0
 2093 10dc 1C0094E5 		ldr	r0, [r4, #28]
 2094 10e0 FEFFFFEB 		bl	_txe_mutex_get
 2095              	.LVL162:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2096              		.loc 1 762 0
 2097 10e4 2610A0E3 		mov	r1, #38
 2098              	.L200:
 2099 10e8 14C09DE5 		ldr	ip, [sp, #20]
 2100 10ec 00E0A0E3 		mov	lr, #0
 2101 10f0 0A30A0E1 		mov	r3, sl
 2102 10f4 0920A0E1 		mov	r2, r9
 2103 10f8 0400A0E1 		mov	r0, r4
 2104 10fc 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2105 1100 FEFFFFEB 		bl	cmdSet
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2106              		.loc 1 763 0
 2107 1104 1C0094E5 		ldr	r0, [r4, #28]
 2108 1108 FEFFFFEB 		bl	_txe_mutex_put
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2109              		.loc 1 764 0
 2110 110c 14109DE5 		ldr	r1, [sp, #20]
 2111 1110 873087E0 		add	r3, r7, r7, asl #1
 2112 1114 836186E0 		add	r6, r6, r3, asl #3
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2113              		.loc 1 765 0
 2114 1118 0170A0E3 		mov	r7, #1
 2115              	.LVL163:
 766:../uvc.c      **** 							 break;
 2116              		.loc 1 766 0
 2117 111c FFC0A0E3 		mov	ip, #255
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2118              		.loc 1 765 0
 2119 1120 1070C6E5 		strb	r7, [r6, #16]
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2120              		.loc 1 764 0
 2121 1124 0D10C6E5 		strb	r1, [r6, #13]
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2122              		.loc 1 765 0
 2123 1128 0140A0E1 		mov	r4, r1
 2124 112c 18E09DE5 		ldr	lr, [sp, #24]
 766:../uvc.c      **** 							 break;
 2125              		.loc 1 766 0
 2126 1130 0C70A0E1 		mov	r7, ip
 2127 1134 73FEFFEA 		b	.L114
 2128              	.LVL164:
 2129              	.L161:
 753:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2130              		.loc 1 753 0
 2131 1138 70489FE5 		ldr	r4, .L206+36
 2132 113c 0010E0E3 		mvn	r1, #0
 2133 1140 1C0094E5 		ldr	r0, [r4, #28]
 2134 1144 FEFFFFEB 		bl	_txe_mutex_get
 2135              	.LVL165:
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2136              		.loc 1 754 0
 2137 1148 2510A0E3 		mov	r1, #37
 2138 114c E5FFFFEA 		b	.L200
 2139              	.LVL166:
 2140              	.L160:
 739:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2141              		.loc 1 739 0
 2142 1150 58489FE5 		ldr	r4, .L206+36
 2143 1154 0010E0E3 		mvn	r1, #0
 2144 1158 1C0094E5 		ldr	r0, [r4, #28]
 2145 115c FEFFFFEB 		bl	_txe_mutex_get
 2146              	.LVL167:
 738:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2147              		.loc 1 738 0
 2148 1160 14209DE5 		ldr	r2, [sp, #20]
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2149              		.loc 1 741 0
 2150 1164 2410A0E3 		mov	r1, #36
 738:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2151              		.loc 1 738 0
 2152 1168 7F8002E2 		and	r8, r2, #127
 2153 116c 18808DE5 		str	r8, [sp, #24]
 2154              	.LVL168:
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2155              		.loc 1 741 0
 2156 1170 18C09DE5 		ldr	ip, [sp, #24]
 2157 1174 0920A0E1 		mov	r2, r9
 2158 1178 0A30A0E1 		mov	r3, sl
 2159 117c 0400A0E1 		mov	r0, r4
 2160 1180 00C08DE5 		str	ip, [sp, #0]
 2161 1184 00C0A0E3 		mov	ip, #0
 2162 1188 04C08DE5 		str	ip, [sp, #4]
 2163 118c FEFFFFEB 		bl	cmdSet
 2164              	.LVL169:
 743:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2165              		.loc 1 743 0
 2166 1190 1CE09DE5 		ldr	lr, [sp, #28]
 2167 1194 0180A0E3 		mov	r8, #1
 2168 1198 2410A0E3 		mov	r1, #36
 2169 119c 0B20A0E1 		mov	r2, fp
 2170 11a0 0A30A0E1 		mov	r3, sl
 2171 11a4 0400A0E1 		mov	r0, r4
 2172 11a8 00E08DE5 		str	lr, [sp, #0]
 2173 11ac 04808DE5 		str	r8, [sp, #4]
 2174 11b0 FEFFFFEB 		bl	cmdSet
 744:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2175              		.loc 1 744 0
 2176 11b4 1C0094E5 		ldr	r0, [r4, #28]
 2177 11b8 FEFFFFEB 		bl	_txe_mutex_put
 2178              	.LVL170:
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2179              		.loc 1 747 0
 2180 11bc 18409DE5 		ldr	r4, [sp, #24]
 748:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2181              		.loc 1 748 0
 2182 11c0 1C009DE5 		ldr	r0, [sp, #28]
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2183              		.loc 1 747 0
 2184 11c4 87C087E0 		add	ip, r7, r7, asl #1
 2185 11c8 8C6186E0 		add	r6, r6, ip, asl #3
 750:../uvc.c      **** 							 break;
 2186              		.loc 1 750 0
 2187 11cc FFC0A0E3 		mov	ip, #255
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2188              		.loc 1 747 0
 2189 11d0 0D40C6E5 		strb	r4, [r6, #13]
 748:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2190              		.loc 1 748 0
 2191 11d4 0E00C6E5 		strb	r0, [r6, #14]
 749:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2192              		.loc 1 749 0
 2193 11d8 1080C6E5 		strb	r8, [r6, #16]
 2194 11dc 14409DE5 		ldr	r4, [sp, #20]
 2195 11e0 00E0A0E1 		mov	lr, r0
 750:../uvc.c      **** 							 break;
 2196              		.loc 1 750 0
 2197 11e4 0C70A0E1 		mov	r7, ip
 2198              	.LVL171:
 2199 11e8 46FEFFEA 		b	.L114
 2200              	.LVL172:
 2201              	.L159:
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2202              		.loc 1 710 0 discriminator 1
 2203 11ec 000058E3 		cmp	r8, #0
 2204 11f0 1800000A 		beq	.L165
 708:../uvc.c      **** 							 break;
 2205              		.loc 1 708 0
 2206 11f4 28E1A0E1 		mov	lr, r8, lsr #2
 2207 11f8 00005EE3 		cmp	lr, #0
 2208 11fc 03005813 		cmpne	r8, #3
 2209 1200 0020A083 		movhi	r2, #0
 2210 1204 0120A093 		movls	r2, #1
 2211              	.LVL173:
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2212              		.loc 1 390 0
 2213 1208 0E31A0E1 		mov	r3, lr, asl #2
 708:../uvc.c      **** 							 break;
 2214              		.loc 1 708 0
 2215 120c D901009A 		bls	.L185
 2216 1210 9C179FE5 		ldr	r1, .L206+40
 2217 1214 0C0081E2 		add	r0, r1, #12
 2218              	.LVL174:
 2219              	.L176:
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2220              		.loc 1 711 0 discriminator 2
 2221 1218 044090E4 		ldr	r4, [r0], #4
 2222 121c 012082E2 		add	r2, r2, #1
 2223 1220 FF2002E2 		and	r2, r2, #255
 2224 1224 02005EE1 		cmp	lr, r2
 2225 1228 044081E4 		str	r4, [r1], #4
 2226 122c F9FFFF8A 		bhi	.L176
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2227              		.loc 1 711 0 is_stmt 0
 2228 1230 030058E1 		cmp	r8, r3
 2229 1234 0700000A 		beq	.L165
 2230              	.LVL175:
 2231              	.L189:
 2232 1238 58E79FE5 		ldr	lr, .L206+12
 2233 123c 03708EE0 		add	r7, lr, r3
 2234 1240 5810D7E5 		ldrb	r1, [r7, #88]	@ zero_extendqisi2
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2235              		.loc 1 710 0 is_stmt 1
 2236 1244 013083E2 		add	r3, r3, #1
 2237 1248 FF3003E2 		and	r3, r3, #255
 2238              	.LVL176:
 2239 124c 030058E1 		cmp	r8, r3
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2240              		.loc 1 711 0
 2241 1250 4C10C7E5 		strb	r1, [r7, #76]
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2242              		.loc 1 710 0
 2243 1254 F7FFFF8A 		bhi	.L189
 2244              	.LVL177:
 2245              	.L165:
 713:../uvc.c      **** 					 		I2CCmdHandler();
 2246              		.loc 1 713 0
 2247 1258 FEFFFFEB 		bl	I2CCmdHandler
 714:../uvc.c      **** 							 break;
 2248              		.loc 1 714 0
 2249 125c FFC0A0E3 		mov	ip, #255
 713:../uvc.c      **** 					 		I2CCmdHandler();
 2250              		.loc 1 713 0
 2251 1260 14409DE5 		ldr	r4, [sp, #20]
 2252 1264 18E09DE5 		ldr	lr, [sp, #24]
 714:../uvc.c      **** 							 break;
 2253              		.loc 1 714 0
 2254 1268 0C70A0E1 		mov	r7, ip
 2255 126c 25FEFFEA 		b	.L114
 2256              	.LVL178:
 2257              	.L158:
 704:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2258              		.loc 1 704 0
 2259 1270 38779FE5 		ldr	r7, .L206+36
 2260              	.LVL179:
 2261 1274 0010E0E3 		mvn	r1, #0
 2262 1278 1C0097E5 		ldr	r0, [r7, #28]
 2263 127c FEFFFFEB 		bl	_txe_mutex_get
 2264              	.LVL180:
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2265              		.loc 1 705 0
 2266 1280 14009DE5 		ldr	r0, [sp, #20]
 2267 1284 00E0A0E3 		mov	lr, #0
 2268 1288 01C070E2 		rsbs	ip, r0, #1
 2269 128c 00C0A033 		movcc	ip, #0
 2270 1290 1E10A0E3 		mov	r1, #30
 2271 1294 0920A0E1 		mov	r2, r9
 2272 1298 0A30A0E1 		mov	r3, sl
 2273 129c 0700A0E1 		mov	r0, r7
 2274 12a0 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2275 12a4 FEFFFFEB 		bl	cmdSet
 706:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2276              		.loc 1 706 0
 2277 12a8 1C0097E5 		ldr	r0, [r7, #28]
 2278 12ac FEFFFFEB 		bl	_txe_mutex_put
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2279              		.loc 1 707 0
 2280 12b0 0140A0E3 		mov	r4, #1
 708:../uvc.c      **** 							 break;
 2281              		.loc 1 708 0
 2282 12b4 FFC0A0E3 		mov	ip, #255
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2283              		.loc 1 707 0
 2284 12b8 6044C6E5 		strb	r4, [r6, #1120]
 2285 12bc 18E09DE5 		ldr	lr, [sp, #24]
 2286 12c0 14409DE5 		ldr	r4, [sp, #20]
 708:../uvc.c      **** 							 break;
 2287              		.loc 1 708 0
 2288 12c4 0C70A0E1 		mov	r7, ip
 2289 12c8 0EFEFFEA 		b	.L114
 2290              	.LVL181:
 2291              	.L157:
 617:../uvc.c      **** 				  switch(CtrlID)
 2292              		.loc 1 617 0
 2293 12cc FFC0A0E3 		mov	ip, #255
 2294 12d0 0340A0E1 		mov	r4, r3
 2295 12d4 0C70A0E1 		mov	r7, ip
 2296              	.LVL182:
 2297 12d8 0AFEFFEA 		b	.L114
 2298              	.LVL183:
 2299              	.L156:
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2300              		.loc 1 671 0
 2301 12dc CC769FE5 		ldr	r7, .L206+36
 2302              	.LVL184:
 669:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2303              		.loc 1 669 0
 2304 12e0 FD33C6E5 		strb	r3, [r6, #1021]
 670:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2305              		.loc 1 670 0
 2306 12e4 0130A0E3 		mov	r3, #1
 2307 12e8 0034C6E5 		strb	r3, [r6, #1024]
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2308              		.loc 1 671 0
 2309 12ec 0010E0E3 		mvn	r1, #0
 2310 12f0 1C0097E5 		ldr	r0, [r7, #28]
 2311 12f4 FEFFFFEB 		bl	_txe_mutex_get
 2312              	.LVL185:
 672:../uvc.c      **** 							 if(WDRflag)
 2313              		.loc 1 672 0
 2314 12f8 10C696E5 		ldr	ip, [r6, #1552]
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2315              		.loc 1 673 0
 2316 12fc 1A10A0E3 		mov	r1, #26
 672:../uvc.c      **** 							 if(WDRflag)
 2317              		.loc 1 672 0
 2318 1300 00005CE3 		cmp	ip, #0
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2319              		.loc 1 673 0
 2320 1304 14C09D15 		ldrne	ip, [sp, #20]
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2321              		.loc 1 675 0
 2322 1308 14E09D05 		ldreq	lr, [sp, #20]
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2323              		.loc 1 673 0
 2324 130c 00C08D15 		strne	ip, [sp, #0]
 2325 1310 0B20A011 		movne	r2, fp
 2326 1314 00C0A013 		movne	ip, #0
 2327 1318 0A30A011 		movne	r3, sl
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2328              		.loc 1 675 0
 2329 131c 0920A001 		moveq	r2, r9
 2330 1320 0A30A001 		moveq	r3, sl
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2331              		.loc 1 673 0
 2332 1324 0700A0E1 		mov	r0, r7
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2333              		.loc 1 675 0
 2334 1328 04C08DE5 		str	ip, [sp, #4]
 2335 132c 00E08D05 		streq	lr, [sp, #0]
 2336 1330 FEFFFFEB 		bl	cmdSet
 676:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2337              		.loc 1 676 0
 2338 1334 1C0097E5 		ldr	r0, [r7, #28]
 2339 1338 FEFFFFEB 		bl	_txe_mutex_put
 677:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2340              		.loc 1 677 0
 2341 133c 54269FE5 		ldr	r2, .L206+12
 2342 1340 103696E5 		ldr	r3, [r6, #1552]
 2343 1344 5AC0D2E5 		ldrb	ip, [r2, #90]	@ zero_extendqisi2
 2344 1348 5BE0D2E5 		ldrb	lr, [r2, #91]	@ zero_extendqisi2
 2345 134c 14409DE5 		ldr	r4, [sp, #20]
 2346 1350 60169FE5 		ldr	r1, .L206+44
 2347 1354 0400A0E3 		mov	r0, #4
 2348              	.L199:
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2349              		.loc 1 873 0
 2350 1358 0420A0E1 		mov	r2, r4
 2351 135c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2352 1360 FEFFFFEB 		bl	CyU3PDebugPrint
 875:../uvc.c      **** 					 		 break;
 2353              		.loc 1 875 0
 2354 1364 FFC0A0E3 		mov	ip, #255
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2355              		.loc 1 873 0
 2356 1368 18E09DE5 		ldr	lr, [sp, #24]
 875:../uvc.c      **** 					 		 break;
 2357              		.loc 1 875 0
 2358 136c 0C70A0E1 		mov	r7, ip
 2359 1370 E4FDFFEA 		b	.L114
 2360              	.LVL186:
 2361              	.L155:
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2362              		.loc 1 658 0
 2363 1374 34469FE5 		ldr	r4, .L206+36
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2364              		.loc 1 654 0
 2365 1378 E533C6E5 		strb	r3, [r6, #997]
 655:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2366              		.loc 1 655 0
 2367 137c 18309DE5 		ldr	r3, [sp, #24]
 656:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2368              		.loc 1 656 0
 2369 1380 0170A0E3 		mov	r7, #1
 2370              	.LVL187:
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2371              		.loc 1 658 0
 2372 1384 0010E0E3 		mvn	r1, #0
 655:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2373              		.loc 1 655 0
 2374 1388 E633C6E5 		strb	r3, [r6, #998]
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2375              		.loc 1 658 0
 2376 138c 1C0094E5 		ldr	r0, [r4, #28]
 656:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2377              		.loc 1 656 0
 2378 1390 E873C6E5 		strb	r7, [r6, #1000]
 2379              	.LVL188:
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2380              		.loc 1 658 0
 2381 1394 FEFFFFEB 		bl	_txe_mutex_get
 2382              	.LVL189:
 659:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2383              		.loc 1 659 0
 2384 1398 14C09DE5 		ldr	ip, [sp, #20]
 2385 139c 1910A0E3 		mov	r1, #25
 2386 13a0 00C08DE5 		str	ip, [sp, #0]
 2387 13a4 0400A0E1 		mov	r0, r4
 2388 13a8 00C0A0E3 		mov	ip, #0
 2389 13ac 0920A0E1 		mov	r2, r9
 2390 13b0 0A30A0E1 		mov	r3, sl
 2391 13b4 04C08DE5 		str	ip, [sp, #4]
 2392 13b8 FEFFFFEB 		bl	cmdSet
 660:../uvc.c      **** 							 if(getData != 0){
 2393              		.loc 1 660 0
 2394 13bc 14109DE5 		ldr	r1, [sp, #20]
 2395 13c0 000051E3 		cmp	r1, #0
 2396 13c4 0700000A 		beq	.L172
 2397              	.LVL190:
 662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2398              		.loc 1 662 0
 2399 13c8 18E09DE5 		ldr	lr, [sp, #24]
 2400 13cc 0400A0E1 		mov	r0, r4
 2401 13d0 1910A0E3 		mov	r1, #25
 2402 13d4 0B20A0E1 		mov	r2, fp
 2403 13d8 0A30A0E1 		mov	r3, sl
 2404 13dc 00E08DE5 		str	lr, [sp, #0]
 2405 13e0 04708DE5 		str	r7, [sp, #4]
 2406 13e4 FEFFFFEB 		bl	cmdSet
 2407              	.LVL191:
 2408              	.L172:
 664:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2409              		.loc 1 664 0
 2410 13e8 1C0094E5 		ldr	r0, [r4, #28]
 2411 13ec FEFFFFEB 		bl	_txe_mutex_put
 665:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2412              		.loc 1 665 0
 2413 13f0 A0159FE5 		ldr	r1, .L206+12
 2414 13f4 9C059FE5 		ldr	r0, .L206+12
 2415 13f8 5A40D1E5 		ldrb	r4, [r1, #90]	@ zero_extendqisi2
 2416 13fc 5B70D0E5 		ldrb	r7, [r0, #91]	@ zero_extendqisi2
 2417 1400 5820D1E5 		ldrb	r2, [r1, #88]	@ zero_extendqisi2
 2418 1404 5930D1E5 		ldrb	r3, [r1, #89]	@ zero_extendqisi2
 2419 1408 0400A0E3 		mov	r0, #4
 2420 140c A8159FE5 		ldr	r1, .L206+48
 2421 1410 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2422 1414 FEFFFFEB 		bl	CyU3PDebugPrint
 666:../uvc.c      **** 							 break;
 2423              		.loc 1 666 0
 2424 1418 FFC0A0E3 		mov	ip, #255
 665:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2425              		.loc 1 665 0
 2426 141c 14409DE5 		ldr	r4, [sp, #20]
 2427 1420 18E09DE5 		ldr	lr, [sp, #24]
 666:../uvc.c      **** 							 break;
 2428              		.loc 1 666 0
 2429 1424 0C70A0E1 		mov	r7, ip
 2430 1428 B6FDFFEA 		b	.L114
 2431              	.LVL192:
 2432              	.L154:
 621:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2433              		.loc 1 621 0
 2434 142c 000053E2 		subs	r0, r3, #0
 620:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2435              		.loc 1 620 0
 2436 1430 0D03C6E5 		strb	r0, [r6, #781]
 2437 1434 50359FE5 		ldr	r3, .L206
 621:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2438              		.loc 1 621 0
 2439 1438 3701001A 		bne	.L166
 622:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2440              		.loc 1 622 0
 2441 143c B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2442              	.LVL193:
 2443 1440 020052E3 		cmp	r2, #2
 2444 1444 08005213 		cmpne	r2, #8
 2445 1448 0300000A 		beq	.L167
 623:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2446              		.loc 1 623 0
 2447 144c 010052E3 		cmp	r2, #1
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2448              		.loc 1 624 0
 2449 1450 07208202 		addeq	r2, r2, #7
 626:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2450              		.loc 1 626 0
 2451 1454 0220A013 		movne	r2, #2
 2452 1458 B524C3E5 		strb	r2, [r3, #1205]
 2453              	.LVL194:
 2454              	.L167:
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2455              		.loc 1 648 0
 2456 145c 4C459FE5 		ldr	r4, .L206+36
 646:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2457              		.loc 1 646 0
 2458 1460 0120A0E3 		mov	r2, #1
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2459              		.loc 1 648 0
 2460 1464 0010E0E3 		mvn	r1, #0
 2461 1468 1C0094E5 		ldr	r0, [r4, #28]
 646:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2462              		.loc 1 646 0
 2463 146c 1023C6E5 		strb	r2, [r6, #784]
 2464              	.LVL195:
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2465              		.loc 1 648 0
 2466 1470 FEFFFFEB 		bl	_txe_mutex_get
 649:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2467              		.loc 1 649 0
 2468 1474 14C09DE5 		ldr	ip, [sp, #20]
 2469 1478 00E0A0E3 		mov	lr, #0
 2470 147c 1010A0E3 		mov	r1, #16
 2471 1480 0920A0E1 		mov	r2, r9
 2472 1484 0A30A0E1 		mov	r3, sl
 2473 1488 0400A0E1 		mov	r0, r4
 2474 148c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2475 1490 FEFFFFEB 		bl	cmdSet
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2476              		.loc 1 650 0
 2477 1494 1C0094E5 		ldr	r0, [r4, #28]
 2478 1498 FEFFFFEB 		bl	_txe_mutex_put
 652:../uvc.c      **** 							 break;
 2479              		.loc 1 652 0
 2480 149c FFC0A0E3 		mov	ip, #255
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2481              		.loc 1 650 0
 2482 14a0 14409DE5 		ldr	r4, [sp, #20]
 2483 14a4 18E09DE5 		ldr	lr, [sp, #24]
 652:../uvc.c      **** 							 break;
 2484              		.loc 1 652 0
 2485 14a8 0C70A0E1 		mov	r7, ip
 2486 14ac 95FDFFEA 		b	.L114
 2487              	.LVL196:
 2488              	.L153:
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2489              		.loc 1 827 0
 2490 14b0 F8449FE5 		ldr	r4, .L206+36
 2491 14b4 0010E0E3 		mvn	r1, #0
 2492 14b8 1C0094E5 		ldr	r0, [r4, #28]
 2493 14bc FEFFFFEB 		bl	_txe_mutex_get
 2494              	.LVL197:
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2495              		.loc 1 828 0
 2496 14c0 14C09DE5 		ldr	ip, [sp, #20]
 2497 14c4 0B10A0E3 		mov	r1, #11
 2498 14c8 0920A0E1 		mov	r2, r9
 2499 14cc 0A30A0E1 		mov	r3, sl
 2500 14d0 0400A0E1 		mov	r0, r4
 2501 14d4 00C08DE5 		str	ip, [sp, #0]
 2502 14d8 00C0A0E3 		mov	ip, #0
 2503 14dc 04C08DE5 		str	ip, [sp, #4]
 2504 14e0 FEFFFFEB 		bl	cmdSet
 2505              	.LVL198:
 830:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2506              		.loc 1 830 0
 2507 14e4 18E09DE5 		ldr	lr, [sp, #24]
 2508 14e8 0170A0E3 		mov	r7, #1
 2509              	.LVL199:
 2510 14ec 0B20A0E1 		mov	r2, fp
 2511 14f0 0B10A0E3 		mov	r1, #11
 2512 14f4 0A30A0E1 		mov	r3, sl
 2513 14f8 0400A0E1 		mov	r0, r4
 2514 14fc 00E08DE5 		str	lr, [sp, #0]
 2515 1500 04708DE5 		str	r7, [sp, #4]
 2516 1504 FEFFFFEB 		bl	cmdSet
 831:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2517              		.loc 1 831 0
 2518 1508 1C0094E5 		ldr	r0, [r4, #28]
 2519 150c FEFFFFEB 		bl	_txe_mutex_put
 833:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2520              		.loc 1 833 0
 2521 1510 14009DE5 		ldr	r0, [sp, #20]
 834:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2522              		.loc 1 834 0
 2523 1514 18209DE5 		ldr	r2, [sp, #24]
 836:../uvc.c      **** 							 break;
 2524              		.loc 1 836 0
 2525 1518 FFC0A0E3 		mov	ip, #255
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2526              		.loc 1 835 0
 2527 151c 9872C6E5 		strb	r7, [r6, #664]
 833:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2528              		.loc 1 833 0
 2529 1520 8C04C6E5 		strb	r0, [r6, #1164]
 834:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2530              		.loc 1 834 0
 2531 1524 8E24C6E5 		strb	r2, [r6, #1166]
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2532              		.loc 1 835 0
 2533 1528 0040A0E1 		mov	r4, r0
 2534 152c 02E0A0E1 		mov	lr, r2
 836:../uvc.c      **** 							 break;
 2535              		.loc 1 836 0
 2536 1530 0C70A0E1 		mov	r7, ip
 2537 1534 73FDFFEA 		b	.L114
 2538              	.LVL200:
 2539              	.L152:
 813:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2540              		.loc 1 813 0
 2541 1538 70449FE5 		ldr	r4, .L206+36
 2542 153c 0010E0E3 		mvn	r1, #0
 2543 1540 1C0094E5 		ldr	r0, [r4, #28]
 2544 1544 FEFFFFEB 		bl	_txe_mutex_get
 2545              	.LVL201:
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2546              		.loc 1 814 0
 2547 1548 14C09DE5 		ldr	ip, [sp, #20]
 2548 154c 0610A0E3 		mov	r1, #6
 2549 1550 0920A0E1 		mov	r2, r9
 2550 1554 0A30A0E1 		mov	r3, sl
 2551 1558 0400A0E1 		mov	r0, r4
 2552 155c 00C08DE5 		str	ip, [sp, #0]
 2553 1560 00C0A0E3 		mov	ip, #0
 2554 1564 04C08DE5 		str	ip, [sp, #4]
 2555 1568 FEFFFFEB 		bl	cmdSet
 2556              	.LVL202:
 816:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2557              		.loc 1 816 0
 2558 156c 14E09DE5 		ldr	lr, [sp, #20]
 2559 1570 0170A0E3 		mov	r7, #1
 2560              	.LVL203:
 2561 1574 0610A0E3 		mov	r1, #6
 2562 1578 0B20A0E1 		mov	r2, fp
 2563 157c 0A30A0E1 		mov	r3, sl
 2564 1580 0400A0E1 		mov	r0, r4
 2565 1584 00E08DE5 		str	lr, [sp, #0]
 2566 1588 04708DE5 		str	r7, [sp, #4]
 2567 158c FEFFFFEB 		bl	cmdSet
 817:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2568              		.loc 1 817 0
 2569 1590 1C0094E5 		ldr	r0, [r4, #28]
 2570 1594 FEFFFFEB 		bl	_txe_mutex_put
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2571              		.loc 1 818 0
 2572 1598 14409DE5 		ldr	r4, [sp, #20]
 820:../uvc.c      **** 							 break;
 2573              		.loc 1 820 0
 2574 159c FFC0A0E3 		mov	ip, #255
 819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2575              		.loc 1 819 0
 2576 15a0 2072C6E5 		strb	r7, [r6, #544]
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2577              		.loc 1 818 0
 2578 15a4 1D42C6E5 		strb	r4, [r6, #541]
 819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2579              		.loc 1 819 0
 2580 15a8 18E09DE5 		ldr	lr, [sp, #24]
 820:../uvc.c      **** 							 break;
 2581              		.loc 1 820 0
 2582 15ac 0C70A0E1 		mov	r7, ip
 2583 15b0 54FDFFEA 		b	.L114
 2584              	.LVL204:
 2585              	.L151:
 793:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2586              		.loc 1 793 0
 2587 15b4 F4439FE5 		ldr	r4, .L206+36
 2588 15b8 0010E0E3 		mvn	r1, #0
 2589 15bc 1C0094E5 		ldr	r0, [r4, #28]
 2590 15c0 FEFFFFEB 		bl	_txe_mutex_get
 2591              	.LVL205:
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2592              		.loc 1 794 0
 2593 15c4 14309DE5 		ldr	r3, [sp, #20]
 2594 15c8 00C0A0E3 		mov	ip, #0
 2595 15cc 801043E2 		sub	r1, r3, #128
 2596 15d0 FF7001E2 		and	r7, r1, #255
 2597              	.LVL206:
 2598 15d4 0920A0E1 		mov	r2, r9
 2599 15d8 0510A0E3 		mov	r1, #5
 2600 15dc 0A30A0E1 		mov	r3, sl
 2601 15e0 0400A0E1 		mov	r0, r4
 2602 15e4 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2603 15e8 FEFFFFEB 		bl	cmdSet
 2604              	.LVL207:
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2605              		.loc 1 796 0
 2606 15ec 14009DE5 		ldr	r0, [sp, #20]
 2607 15f0 0510A0E3 		mov	r1, #5
 2608 15f4 767040E2 		sub	r7, r0, #118
 2609 15f8 FFC007E2 		and	ip, r7, #255
 2610 15fc DC20A0E3 		mov	r2, #220
 2611 1600 0170A0E3 		mov	r7, #1
 2612 1604 0A30A0E1 		mov	r3, sl
 2613 1608 0400A0E1 		mov	r0, r4
 2614 160c 00C08DE5 		str	ip, [sp, #0]
 2615 1610 04708DE5 		str	r7, [sp, #4]
 2616 1614 FEFFFFEB 		bl	cmdSet
 2617              	.LVL208:
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2618              		.loc 1 798 0
 2619 1618 14209DE5 		ldr	r2, [sp, #20]
 2620 161c 0510A0E3 		mov	r1, #5
 2621 1620 7E3082E2 		add	r3, r2, #126
 2622 1624 FFC003E2 		and	ip, r3, #255
 2623 1628 DE20A0E3 		mov	r2, #222
 2624 162c 0A30A0E1 		mov	r3, sl
 2625 1630 0400A0E1 		mov	r0, r4
 2626 1634 00C08DE5 		str	ip, [sp, #0]
 2627 1638 02C0A0E3 		mov	ip, #2
 2628 163c 04C08DE5 		str	ip, [sp, #4]
 2629 1640 FEFFFFEB 		bl	cmdSet
 2630              	.LVL209:
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2631              		.loc 1 800 0
 2632 1644 14109DE5 		ldr	r1, [sp, #20]
 2633 1648 03E0A0E3 		mov	lr, #3
 2634 164c 720081E2 		add	r0, r1, #114
 2635 1650 FFC000E2 		and	ip, r0, #255
 2636 1654 0510A0E3 		mov	r1, #5
 2637 1658 E020A0E3 		mov	r2, #224
 2638 165c 0A30A0E1 		mov	r3, sl
 2639 1660 0400A0E1 		mov	r0, r4
 2640 1664 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2641 1668 FEFFFFEB 		bl	cmdSet
 2642              	.LVL210:
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2643              		.loc 1 802 0
 2644 166c 14209DE5 		ldr	r2, [sp, #20]
 2645 1670 0510A0E3 		mov	r1, #5
 2646 1674 6F3042E2 		sub	r3, r2, #111
 2647 1678 FFC003E2 		and	ip, r3, #255
 2648 167c DD20A0E3 		mov	r2, #221
 2649 1680 0A30A0E1 		mov	r3, sl
 2650 1684 0400A0E1 		mov	r0, r4
 2651 1688 00C08DE5 		str	ip, [sp, #0]
 2652 168c 04C0A0E3 		mov	ip, #4
 2653 1690 04C08DE5 		str	ip, [sp, #4]
 2654 1694 FEFFFFEB 		bl	cmdSet
 2655              	.LVL211:
 804:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2656              		.loc 1 804 0
 2657 1698 F8129FE5 		ldr	r1, .L206+12
 2658 169c 05E0A0E3 		mov	lr, #5
 2659 16a0 5800D1E5 		ldrb	r0, [r1, #88]	@ zero_extendqisi2
 2660 16a4 0A30A0E1 		mov	r3, sl
 2661 16a8 7F2080E2 		add	r2, r0, #127
 2662 16ac FFC002E2 		and	ip, r2, #255
 2663 16b0 0E10A0E1 		mov	r1, lr
 2664 16b4 0B20A0E1 		mov	r2, fp
 2665 16b8 0400A0E1 		mov	r0, r4
 2666 16bc 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2667 16c0 FEFFFFEB 		bl	cmdSet
 805:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2668              		.loc 1 805 0
 2669 16c4 1C0094E5 		ldr	r0, [r4, #28]
 2670 16c8 FEFFFFEB 		bl	_txe_mutex_put
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2671              		.loc 1 807 0
 2672 16cc C4429FE5 		ldr	r4, .L206+12
 809:../uvc.c      **** 							 break;
 2673              		.loc 1 809 0
 2674 16d0 FFC0A0E3 		mov	ip, #255
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2675              		.loc 1 807 0
 2676 16d4 5830D4E5 		ldrb	r3, [r4, #88]	@ zero_extendqisi2
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2677              		.loc 1 808 0
 2678 16d8 0872C6E5 		strb	r7, [r6, #520]
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2679              		.loc 1 807 0
 2680 16dc 801043E2 		sub	r1, r3, #128
 2681 16e0 0512C6E5 		strb	r1, [r6, #517]
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2682              		.loc 1 808 0
 2683 16e4 14409DE5 		ldr	r4, [sp, #20]
 2684 16e8 18E09DE5 		ldr	lr, [sp, #24]
 809:../uvc.c      **** 							 break;
 2685              		.loc 1 809 0
 2686 16ec 0C70A0E1 		mov	r7, ip
 2687 16f0 04FDFFEA 		b	.L114
 2688              	.LVL212:
 2689              	.L150:
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2690              		.loc 1 845 0
 2691 16f4 B4429FE5 		ldr	r4, .L206+36
 839:../uvc.c      **** 							 Data0 = Data0 - 1;
 2692              		.loc 1 839 0
 2693 16f8 013043E2 		sub	r3, r3, #1
 2694 16fc FF7003E2 		and	r7, r3, #255
 2695              	.LVL213:
 843:../uvc.c      **** 								 Data0 = 1;
 2696              		.loc 1 843 0
 2697 1700 020057E3 		cmp	r7, #2
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2698              		.loc 1 845 0
 2699 1704 0010E0E3 		mvn	r1, #0
 2700 1708 1C0094E5 		ldr	r0, [r4, #28]
 843:../uvc.c      **** 								 Data0 = 1;
 2701              		.loc 1 843 0
 2702 170c 0170A083 		movhi	r7, #1
 2703              	.LVL214:
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2704              		.loc 1 845 0
 2705 1710 FEFFFFEB 		bl	_txe_mutex_get
 2706              	.LVL215:
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2707              		.loc 1 846 0
 2708 1714 00C0A0E3 		mov	ip, #0
 2709 1718 0410A0E3 		mov	r1, #4
 2710 171c 0920A0E1 		mov	r2, r9
 2711 1720 0A30A0E1 		mov	r3, sl
 2712 1724 0400A0E1 		mov	r0, r4
 2713 1728 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2714 172c FEFFFFEB 		bl	cmdSet
 847:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2715              		.loc 1 847 0
 2716 1730 1C0094E5 		ldr	r0, [r4, #28]
 2717 1734 FEFFFFEB 		bl	_txe_mutex_put
 851:../uvc.c      **** 							 break;
 2718              		.loc 1 851 0
 2719 1738 FFC0A0E3 		mov	ip, #255
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2720              		.loc 1 850 0
 2721 173c 0110A0E3 		mov	r1, #1
 849:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2722              		.loc 1 849 0
 2723 1740 ED71C6E5 		strb	r7, [r6, #493]
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2724              		.loc 1 850 0
 2725 1744 F011C6E5 		strb	r1, [r6, #496]
 2726 1748 14409DE5 		ldr	r4, [sp, #20]
 2727 174c 18E09DE5 		ldr	lr, [sp, #24]
 851:../uvc.c      **** 							 break;
 2728              		.loc 1 851 0
 2729 1750 0C70A0E1 		mov	r7, ip
 2730 1754 EBFCFFEA 		b	.L114
 2731              	.LVL216:
 2732              	.L149:
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2733              		.loc 1 769 0
 2734 1758 50729FE5 		ldr	r7, .L206+36
 2735              	.LVL217:
 2736 175c 0010E0E3 		mvn	r1, #0
 2737 1760 1C0097E5 		ldr	r0, [r7, #28]
 2738 1764 FEFFFFEB 		bl	_txe_mutex_get
 2739              	.LVL218:
 771:../uvc.c      **** 							  if(Data0&0x80){
 2740              		.loc 1 771 0
 2741 1768 14009DE5 		ldr	r0, [sp, #20]
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2742              		.loc 1 772 0
 2743 176c A6C1D6E5 		ldrb	ip, [r6, #422]	@ zero_extendqisi2
 771:../uvc.c      **** 							  if(Data0&0x80){
 2744              		.loc 1 771 0
 2745 1770 800010E3 		tst	r0, #128
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2746              		.loc 1 774 0
 2747 1774 2023A001 		moveq	r2, r0, lsr #6
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2748              		.loc 1 772 0
 2749 1778 802CA011 		movne	r2, r0, asl #25
 2750 177c 03C0CC13 		bicne	ip, ip, #3
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2751              		.loc 1 774 0
 2752 1780 03C0CC03 		biceq	ip, ip, #3
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2753              		.loc 1 778 0
 2754 1784 24029FE5 		ldr	r0, .L206+36
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2755              		.loc 1 774 0
 2756 1788 02208203 		orreq	r2, r2, #2
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2757              		.loc 1 772 0
 2758 178c A2CF8C11 		orrne	ip, ip, r2, lsr #31
 2759              	.LVL219:
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2760              		.loc 1 774 0
 2761 1790 0CC08201 		orreq	ip, r2, ip
 2762              	.LVL220:
 776:../uvc.c      **** 							 Data1 |= ~0x03;
 2763              		.loc 1 776 0
 2764 1794 0C4FE0E1 		mvn	r4, ip, asl #30
 2765 1798 243FE0E1 		mvn	r3, r4, lsr #30
 2766              	.LVL221:
 777:../uvc.c      **** 							 Data1 &= 0xC7;
 2767              		.loc 1 777 0
 2768 179c C71003E2 		and	r1, r3, #199
 2769 17a0 1C108DE5 		str	r1, [sp, #28]
 2770              	.LVL222:
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2771              		.loc 1 778 0
 2772 17a4 1C809DE5 		ldr	r8, [sp, #28]
 2773 17a8 00C0A0E3 		mov	ip, #0
 2774 17ac 0110A0E3 		mov	r1, #1
 2775 17b0 0B20A0E1 		mov	r2, fp
 2776 17b4 0A30A0E1 		mov	r3, sl
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2777              		.loc 1 782 0
 2778 17b8 0140A0E1 		mov	r4, r1
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2779              		.loc 1 778 0
 2780 17bc 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2781 17c0 FEFFFFEB 		bl	cmdSet
 2782              	.LVL223:
 781:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2783              		.loc 1 781 0
 2784 17c4 14209DE5 		ldr	r2, [sp, #20]
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2785              		.loc 1 782 0
 2786 17c8 0410A0E1 		mov	r1, r4
 781:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2787              		.loc 1 781 0
 2788 17cc 0281A0E1 		mov	r8, r2, asl #2
 2789 17d0 FF8008E2 		and	r8, r8, #255
 2790              	.LVL224:
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2791              		.loc 1 782 0
 2792 17d4 0920A0E1 		mov	r2, r9
 2793 17d8 0A30A0E1 		mov	r3, sl
 2794 17dc CC019FE5 		ldr	r0, .L206+36
 2795 17e0 04408DE5 		str	r4, [sp, #4]
 2796 17e4 00808DE5 		str	r8, [sp, #0]
 2797 17e8 FEFFFFEB 		bl	cmdSet
 783:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2798              		.loc 1 783 0
 2799 17ec 1C0097E5 		ldr	r0, [r7, #28]
 2800 17f0 FEFFFFEB 		bl	_txe_mutex_put
 786:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2801              		.loc 1 786 0
 2802 17f4 1C009DE5 		ldr	r0, [sp, #28]
 789:../uvc.c      **** 							 break;
 2803              		.loc 1 789 0
 2804 17f8 FFC0A0E3 		mov	ip, #255
 787:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2805              		.loc 1 787 0
 2806 17fc A841C6E5 		strb	r4, [r6, #424]
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2807              		.loc 1 785 0
 2808 1800 A581C6E5 		strb	r8, [r6, #421]
 786:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2809              		.loc 1 786 0
 2810 1804 A601C6E5 		strb	r0, [r6, #422]
 787:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2811              		.loc 1 787 0
 2812 1808 14409DE5 		ldr	r4, [sp, #20]
 2813 180c 18E09DE5 		ldr	lr, [sp, #24]
 789:../uvc.c      **** 							 break;
 2814              		.loc 1 789 0
 2815 1810 0C70A0E1 		mov	r7, ip
 2816 1814 BBFCFFEA 		b	.L114
 2817              	.LVL225:
 2818              	.L148:
 870:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2819              		.loc 1 870 0
 2820 1818 90719FE5 		ldr	r7, .L206+36
 2821              	.LVL226:
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2822              		.loc 1 853 0
 2823 181c 68019FE5 		ldr	r0, .L206
 854:../uvc.c      **** 							 if(Data0 == 3)
 2824              		.loc 1 854 0
 2825 1820 030053E3 		cmp	r3, #3
 855:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2826              		.loc 1 855 0
 2827 1824 0120A003 		moveq	r2, #1
 2828              	.LVL227:
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 2829              		.loc 1 857 0
 2830 1828 0020A013 		movne	r2, #0
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2831              		.loc 1 858 0
 2832 182c 01C0A0E3 		mov	ip, #1
 2833 1830 90C1C6E5 		strb	ip, [r6, #400]
 2834              	.LVL228:
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 2835              		.loc 1 857 0
 2836 1834 102680E5 		str	r2, [r0, #1552]
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2837              		.loc 1 853 0
 2838 1838 8D31C6E5 		strb	r3, [r6, #397]
 870:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2839              		.loc 1 870 0
 2840 183c 0010E0E3 		mvn	r1, #0
 2841 1840 1C0097E5 		ldr	r0, [r7, #28]
 2842 1844 FEFFFFEB 		bl	_txe_mutex_get
 871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2843              		.loc 1 871 0
 2844 1848 14E09DE5 		ldr	lr, [sp, #20]
 2845 184c 0040A0E3 		mov	r4, #0
 2846 1850 0410A0E1 		mov	r1, r4
 2847 1854 0920A0E1 		mov	r2, r9
 2848 1858 0A30A0E1 		mov	r3, sl
 2849 185c 0700A0E1 		mov	r0, r7
 2850 1860 00E08DE5 		str	lr, [sp, #0]
 2851 1864 04408DE5 		str	r4, [sp, #4]
 2852 1868 FEFFFFEB 		bl	cmdSet
 872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2853              		.loc 1 872 0
 2854 186c 1C0097E5 		ldr	r0, [r7, #28]
 2855 1870 FEFFFFEB 		bl	_txe_mutex_put
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2856              		.loc 1 873 0
 2857 1874 1C219FE5 		ldr	r2, .L206+12
 2858 1878 103696E5 		ldr	r3, [r6, #1552]
 2859 187c 5AC0D2E5 		ldrb	ip, [r2, #90]	@ zero_extendqisi2
 2860 1880 5BE0D2E5 		ldrb	lr, [r2, #91]	@ zero_extendqisi2
 2861 1884 14409DE5 		ldr	r4, [sp, #20]
 2862 1888 0400A0E3 		mov	r0, #4
 2863 188c 2C119FE5 		ldr	r1, .L206+52
 2864 1890 B0FEFFEA 		b	.L199
 2865              	.LVL229:
 2866              	.L147:
 879:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2867              		.loc 1 879 0
 2868 1894 14719FE5 		ldr	r7, .L206+36
 2869              	.LVL230:
 2870 1898 0010E0E3 		mvn	r1, #0
 2871 189c 1C0097E5 		ldr	r0, [r7, #28]
 2872 18a0 FEFFFFEB 		bl	_txe_mutex_get
 2873              	.LVL231:
 880:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2874              		.loc 1 880 0
 2875 18a4 14C09DE5 		ldr	ip, [sp, #20]
 2876 18a8 0410A0E1 		mov	r1, r4
 2877 18ac 0920A0E1 		mov	r2, r9
 2878 18b0 0A30A0E1 		mov	r3, sl
 2879 18b4 0700A0E1 		mov	r0, r7
 2880 18b8 00C08DE5 		str	ip, [sp, #0]
 2881 18bc 00C0A0E3 		mov	ip, #0
 2882 18c0 04C08DE5 		str	ip, [sp, #4]
 2883 18c4 FEFFFFEB 		bl	cmdSet
 881:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2884              		.loc 1 881 0
 2885 18c8 1C0097E5 		ldr	r0, [r7, #28]
 2886 18cc FEFFFFEB 		bl	_txe_mutex_put
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2887              		.loc 1 883 0
 2888 18d0 14209DE5 		ldr	r2, [sp, #20]
 2889 18d4 847084E0 		add	r7, r4, r4, asl #1
 2890 18d8 876186E0 		add	r6, r6, r7, asl #3
 885:../uvc.c      **** 							 break;
 2891              		.loc 1 885 0
 2892 18dc FFC0A0E3 		mov	ip, #255
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2893              		.loc 1 884 0
 2894 18e0 0130A0E3 		mov	r3, #1
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2895              		.loc 1 883 0
 2896 18e4 8D21C6E5 		strb	r2, [r6, #397]
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2897              		.loc 1 884 0
 2898 18e8 9031C6E5 		strb	r3, [r6, #400]
 2899 18ec 0240A0E1 		mov	r4, r2
 2900 18f0 18E09DE5 		ldr	lr, [sp, #24]
 885:../uvc.c      **** 							 break;
 2901              		.loc 1 885 0
 2902 18f4 0C70A0E1 		mov	r7, ip
 2903 18f8 82FCFFEA 		b	.L114
 2904              	.LVL232:
 2905              	.L146:
 888:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2906              		.loc 1 888 0
 2907 18fc 0400A0E3 		mov	r0, #4
 2908              	.LVL233:
 2909 1900 BC109FE5 		ldr	r1, .L206+56
 2910 1904 FEFFFFEB 		bl	CyU3PDebugPrint
 2911              	.LVL234:
 2912 1908 FFC0A0E3 		mov	ip, #255
 2913 190c 0C70A0E1 		mov	r7, ip
 2914              	.LVL235:
 2915 1910 0CE0A0E1 		mov	lr, ip
 2916 1914 0C40A0E1 		mov	r4, ip
 2917 1918 7AFCFFEA 		b	.L114
 2918              	.LVL236:
 2919              	.L166:
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2920              		.loc 1 631 0
 2921 191c B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2922              	.LVL237:
 630:../uvc.c      **** 								 Data1 = Data0 - 1;
 2923              		.loc 1 630 0
 2924 1920 017040E2 		sub	r7, r0, #1
 2925              	.LVL238:
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2926              		.loc 1 631 0
 2927 1924 040052E3 		cmp	r2, #4
 2928 1928 01005213 		cmpne	r2, #1
 630:../uvc.c      **** 								 Data1 = Data0 - 1;
 2929              		.loc 1 630 0
 2930 192c FF1007E2 		and	r1, r7, #255
 2931              	.LVL239:
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2932              		.loc 1 631 0
 2933 1930 0300000A 		beq	.L169
 632:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2934              		.loc 1 632 0
 2935 1934 080052E3 		cmp	r2, #8
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2936              		.loc 1 633 0
 2937 1938 0120A003 		moveq	r2, #1
 635:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2938              		.loc 1 635 0
 2939 193c 0420A013 		movne	r2, #4
 2940 1940 B524C3E5 		strb	r2, [r3, #1205]
 2941              	.L169:
 638:../uvc.c      **** 								 if(Data1 < 8){
 2942              		.loc 1 638 0
 2943 1944 070051E3 		cmp	r1, #7
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2944              		.loc 1 639 0
 2945 1948 78309F95 		ldrls	r3, .L206+60
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2946              		.loc 1 642 0
 2947 194c 0130A083 		movhi	r3, #1
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2948              		.loc 1 640 0
 2949 1950 81008390 		addls	r0, r3, r1, asl #1
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2950              		.loc 1 639 0
 2951 1954 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2952              		.loc 1 640 0
 2953 1958 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2954              		.loc 1 642 0
 2955 195c E534C685 		strhib	r3, [r6, #1253]
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2956              		.loc 1 643 0
 2957 1960 0030A083 		movhi	r3, #0
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2958              		.loc 1 639 0
 2959 1964 E524C695 		strlsb	r2, [r6, #1253]
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2960              		.loc 1 643 0
 2961 1968 E634C6E5 		strb	r3, [r6, #1254]
 2962 196c BAFEFFEA 		b	.L167
 2963              	.LVL240:
 2964              	.L196:
 2965 1970 20009FE5 		ldr	r0, .L206+12
 2966 1974 89FDFFEA 		b	.L125
 2967              	.LVL241:
 2968              	.L185:
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2969              		.loc 1 390 0
 2970 1978 0030A0E3 		mov	r3, #0
 2971 197c 2DFEFFEA 		b	.L189
 2972              	.LVL242:
 2973              	.L184:
 2974 1980 10009FE5 		ldr	r0, .L206+12
 2975 1984 0030A0E3 		mov	r3, #0
 2976 1988 7DFDFFEA 		b	.L188
 2977              	.L207:
 2978              		.align	2
 2979              	.L206:
 2980 198c 00000000 		.word	.LANCHOR1
 2981 1990 00000000 		.word	bRequest
 2982 1994 3C030000 		.word	.LC21
 2983 1998 00000000 		.word	.LANCHOR0
 2984 199c 58000000 		.word	.LANCHOR0+88
 2985 19a0 01000100 		.word	65537
 2986 19a4 FF00FF00 		.word	16711935
 2987 19a8 48020000 		.word	.LC15
 2988 19ac 84020000 		.word	.LC16
 2989 19b0 00000000 		.word	cmdQu
 2990 19b4 4C000000 		.word	.LANCHOR0+76
 2991 19b8 D8020000 		.word	.LC18
 2992 19bc AC020000 		.word	.LC17
 2993 19c0 F4020000 		.word	.LC19
 2994 19c4 0C030000 		.word	.LC20
 2995 19c8 00000000 		.word	.LANCHOR2
 2996              		.cfi_endproc
 2997              	.LFE2:
 2999              		.align	2
 3000              		.global	CTControlHandle
 3002              	CTControlHandle:
 3003              	.LFB3:
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3004              		.loc 1 904 0
 3005              		.cfi_startproc
 3006              		@ args = 0, pretend = 0, frame = 64
 3007              		@ frame_needed = 0, uses_anonymous_args = 0
 3008              	.LVL243:
 3009 19cc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3010              	.LCFI15:
 3011              		.cfi_def_cfa_offset 36
 923:../uvc.c      ****     reqData = bRequest;
 3012              		.loc 1 923 0
 3013 19d0 60A99FE5 		ldr	sl, .L293
 3014              		.cfi_offset 14, -4
 3015              		.cfi_offset 11, -8
 3016              		.cfi_offset 10, -12
 3017              		.cfi_offset 9, -16
 3018              		.cfi_offset 8, -20
 3019              		.cfi_offset 7, -24
 3020              		.cfi_offset 6, -28
 3021              		.cfi_offset 5, -32
 3022              		.cfi_offset 4, -36
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3023              		.loc 1 915 0
 3024 19d4 60899FE5 		ldr	r8, .L293+4
 923:../uvc.c      ****     reqData = bRequest;
 3025              		.loc 1 923 0
 3026 19d8 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3027              		.loc 1 915 0
 3028 19dc 8090A0E1 		mov	r9, r0, asl #1
 3029 19e0 002089E0 		add	r2, r9, r0
 3030 19e4 822188E0 		add	r2, r8, r2, asl #3
 925:../uvc.c      ****     switch (bRequest)
 3031              		.loc 1 925 0
 3032 19e8 830055E3 		cmp	r5, #131
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3033              		.loc 1 904 0
 3034 19ec 5CD04DE2 		sub	sp, sp, #92
 3035              	.LCFI16:
 3036              		.cfi_def_cfa_offset 128
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3037              		.loc 1 904 0
 3038 19f0 0060A0E1 		mov	r6, r0
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3039              		.loc 1 915 0
 3040 19f4 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3041              	.LVL244:
 916:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3042              		.loc 1 916 0
 3043 19f8 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3044              	.LVL245:
 918:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3045              		.loc 1 918 0
 3046 19fc 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3047              	.LVL246:
 925:../uvc.c      ****     switch (bRequest)
 3048              		.loc 1 925 0
 3049 1a00 7600000A 		beq	.L213
 3050 1a04 2100009A 		bls	.L288
 3051 1a08 850055E3 		cmp	r5, #133
 3052 1a0c 5900000A 		beq	.L215
 3053 1a10 4E00003A 		bcc	.L214
 3054 1a14 860055E3 		cmp	r5, #134
 3055 1a18 8000000A 		beq	.L216
 3056 1a1c 870055E3 		cmp	r5, #135
 3057 1a20 7600000A 		beq	.L289
 3058              	.L209:
1132:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3059              		.loc 1 1132 0
 3060 1a24 0000A0E3 		mov	r0, #0
 3061              	.LVL247:
 3062 1a28 0110A0E3 		mov	r1, #1
 3063 1a2c 0020A0E1 		mov	r2, r0
 3064 1a30 FEFFFFEB 		bl	CyU3PUsbStall
 3065              	.LVL248:
 3066 1a34 04499FE5 		ldr	r4, .L293+8
1133:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3067              		.loc 1 1133 0
 3068 1a38 0620A0E1 		mov	r2, r6
 3069 1a3c 0400A0E3 		mov	r0, #4
 3070 1a40 FC189FE5 		ldr	r1, .L293+12
 3071 1a44 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3072 1a48 FEFFFFEB 		bl	CyU3PDebugPrint
1134:../uvc.c      **** 			  break;
 3073              		.loc 1 1134 0
 3074 1a4c FFC0A0E3 		mov	ip, #255
 3075 1a50 0C60A0E1 		mov	r6, ip
 3076 1a54 0C80A0E1 		mov	r8, ip
 3077              	.LVL249:
 3078              	.L219:
1138:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3079              		.loc 1 1138 0
 3080 1a58 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3081 1a5c 08C08DE5 		str	ip, [sp, #8]
 3082 1a60 E0189FE5 		ldr	r1, .L293+16
 3083 1a64 FFC0A0E3 		mov	ip, #255
 3084 1a68 0520A0E1 		mov	r2, r5
 3085 1a6c 0830A0E1 		mov	r3, r8
 3086 1a70 0400A0E3 		mov	r0, #4
 3087 1a74 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3088 1a78 0CC08DE5 		str	ip, [sp, #12]
 3089 1a7c 10E08DE5 		str	lr, [sp, #16]
 3090 1a80 14708DE5 		str	r7, [sp, #20]
 3091 1a84 FEFFFFEB 		bl	CyU3PDebugPrint
1139:../uvc.c      **** }
 3092              		.loc 1 1139 0
 3093 1a88 5CD08DE2 		add	sp, sp, #92
 3094 1a8c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3095              	.LVL250:
 3096              	.L288:
 925:../uvc.c      ****     switch (bRequest)
 3097              		.loc 1 925 0
 3098 1a90 810055E3 		cmp	r5, #129
 3099 1a94 4200000A 		beq	.L211
 3100 1a98 1100009A 		bls	.L290
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3101              		.loc 1 954 0
 3102 1a9c 9C489FE5 		ldr	r4, .L293+8
 3103 1aa0 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3104              		.loc 1 955 0
 3105 1aa4 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3106              		.loc 1 956 0
 3107 1aa8 0A0050E3 		cmp	r0, #10
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3108              		.loc 1 954 0
 3109 1aac 5810C4E5 		strb	r1, [r4, #88]
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3110              		.loc 1 955 0
 3111 1ab0 5960C4E5 		strb	r6, [r4, #89]
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3112              		.loc 1 956 0
 3113 1ab4 2C00000A 		beq	.L287
 3114              	.LVL251:
 3115              	.L226:
 990:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3116              		.loc 1 990 0
 3117 1ab8 00E0A0E3 		mov	lr, #0
 3118 1abc 5AE0C4E5 		strb	lr, [r4, #90]
 3119              	.L227:
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3120              		.loc 1 991 0
 3121 1ac0 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3122              		.loc 1 992 0
 3123 1ac4 0700A0E1 		mov	r0, r7
 3124              	.LVL252:
 3125 1ac8 7C189FE5 		ldr	r1, .L293+20
 994:../uvc.c      **** 			  break;
 3126              		.loc 1 994 0
 3127 1acc FF60A0E3 		mov	r6, #255
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3128              		.loc 1 991 0
 3129 1ad0 5B30C4E5 		strb	r3, [r4, #91]
 994:../uvc.c      **** 			  break;
 3130              		.loc 1 994 0
 3131 1ad4 0680A0E1 		mov	r8, r6
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3132              		.loc 1 992 0
 3133 1ad8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3134              	.LVL253:
 3135 1adc 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 994:../uvc.c      **** 			  break;
 3136              		.loc 1 994 0
 3137 1ae0 DCFFFFEA 		b	.L219
 3138              	.LVL254:
 3139              	.L290:
 925:../uvc.c      ****     switch (bRequest)
 3140              		.loc 1 925 0
 3141 1ae4 010055E3 		cmp	r5, #1
 3142 1ae8 CDFFFF1A 		bne	.L209
 996:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3143              		.loc 1 996 0
 3144 1aec 4C489FE5 		ldr	r4, .L293+8
 3145 1af0 56208DE2 		add	r2, sp, #86
 3146 1af4 2000A0E3 		mov	r0, #32
 3147              	.LVL255:
 3148 1af8 581084E2 		add	r1, r4, #88
 3149 1afc 2C308DE5 		str	r3, [sp, #44]
 3150 1b00 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3151              	.LVL256:
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3152              		.loc 1 998 0
 3153 1b04 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3154              		.loc 1 999 0
 3155 1b08 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
1002:../uvc.c      **** 			  switch(CtrlID)
 3156              		.loc 1 1002 0
 3157 1b0c 012046E2 		sub	r2, r6, #1
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3158              		.loc 1 998 0
 3159 1b10 30008DE5 		str	r0, [sp, #48]
 3160              	.LVL257:
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3161              		.loc 1 999 0
 3162 1b14 34C08DE5 		str	ip, [sp, #52]
 3163              	.LVL258:
1002:../uvc.c      **** 			  switch(CtrlID)
 3164              		.loc 1 1002 0
 3165 1b18 2C309DE5 		ldr	r3, [sp, #44]
 3166 1b1c 090052E3 		cmp	r2, #9
 3167 1b20 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3168 1b24 550100EA 		b	.L228
 3169              	.L233:
 3170 1b28 3C200000 		.word	.L229
 3171 1b2c 80200000 		.word	.L228
 3172 1b30 4C1D0000 		.word	.L230
 3173 1b34 80200000 		.word	.L228
 3174 1b38 80200000 		.word	.L228
 3175 1b3c 80200000 		.word	.L228
 3176 1b40 C81C0000 		.word	.L231
 3177 1b44 80200000 		.word	.L228
 3178 1b48 80200000 		.word	.L228
 3179 1b4c 4C1C0000 		.word	.L232
 3180              	.LVL259:
 3181              	.L214:
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3182              		.loc 1 972 0
 3183 1b50 E8479FE5 		ldr	r4, .L293+8
 3184 1b54 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3185              		.loc 1 973 0
 3186 1b58 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3187              		.loc 1 974 0
 3188 1b5c 0A0050E3 		cmp	r0, #10
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3189              		.loc 1 972 0
 3190 1b60 5880C4E5 		strb	r8, [r4, #88]
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3191              		.loc 1 973 0
 3192 1b64 5920C4E5 		strb	r2, [r4, #89]
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3193              		.loc 1 974 0
 3194 1b68 D2FFFF1A 		bne	.L226
 3195              	.LVL260:
 3196              	.L287:
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3197              		.loc 1 989 0 discriminator 1
 3198 1b6c 0110A0E3 		mov	r1, #1
 3199 1b70 5A10C4E5 		strb	r1, [r4, #90]
 3200 1b74 D1FFFFEA 		b	.L227
 3201              	.LVL261:
 3202              	.L215:
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3203              		.loc 1 929 0
 3204 1b78 C0479FE5 		ldr	r4, .L293+8
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3205              		.loc 1 930 0
 3206 1b7c 0030A0E3 		mov	r3, #0
 3207              	.LVL262:
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3208              		.loc 1 931 0
 3209 1b80 0200A0E3 		mov	r0, #2
 3210              	.LVL263:
 3211 1b84 581084E2 		add	r1, r4, #88
 933:../uvc.c      **** 			  break;
 3212              		.loc 1 933 0
 3213 1b88 FF60A0E3 		mov	r6, #255
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3214              		.loc 1 929 0
 3215 1b8c 5870C4E5 		strb	r7, [r4, #88]
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3216              		.loc 1 930 0
 3217 1b90 5930C4E5 		strb	r3, [r4, #89]
 933:../uvc.c      **** 			  break;
 3218              		.loc 1 933 0
 3219 1b94 0680A0E1 		mov	r8, r6
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3220              		.loc 1 931 0
 3221 1b98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3222              	.LVL264:
 3223 1b9c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 933:../uvc.c      **** 			  break;
 3224              		.loc 1 933 0
 3225 1ba0 ACFFFFEA 		b	.L219
 3226              	.LVL265:
 3227              	.L211:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3228              		.loc 1 939 0
 3229 1ba4 94479FE5 		ldr	r4, .L293+8
 3230 1ba8 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3231              		.loc 1 940 0
 3232 1bac 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3233              		.loc 1 941 0
 3234 1bb0 0080A0E3 		mov	r8, #0
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3235              		.loc 1 947 0
 3236 1bb4 0700A0E1 		mov	r0, r7
 3237              	.LVL266:
 3238 1bb8 581084E2 		add	r1, r4, #88
 952:../uvc.c      **** 			  break;
 3239              		.loc 1 952 0
 3240 1bbc FF60A0E3 		mov	r6, #255
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3241              		.loc 1 940 0
 3242 1bc0 59C0C4E5 		strb	ip, [r4, #89]
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3243              		.loc 1 941 0
 3244 1bc4 5A80C4E5 		strb	r8, [r4, #90]
 942:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3245              		.loc 1 942 0
 3246 1bc8 5B80C4E5 		strb	r8, [r4, #91]
 3247              	.LVL267:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3248              		.loc 1 939 0
 3249 1bcc 58A0C4E5 		strb	sl, [r4, #88]
 952:../uvc.c      **** 			  break;
 3250              		.loc 1 952 0
 3251 1bd0 0680A0E1 		mov	r8, r6
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3252              		.loc 1 947 0
 3253 1bd4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3254              	.LVL268:
 3255 1bd8 0AC0A0E1 		mov	ip, sl
 952:../uvc.c      **** 			  break;
 3256              		.loc 1 952 0
 3257 1bdc 9DFFFFEA 		b	.L219
 3258              	.LVL269:
 3259              	.L213:
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3260              		.loc 1 963 0
 3261 1be0 58479FE5 		ldr	r4, .L293+8
 3262 1be4 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3263              	.LVL270:
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3264              		.loc 1 964 0
 3265 1be8 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3266              		.loc 1 965 0
 3267 1bec 0A0050E3 		cmp	r0, #10
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3268              		.loc 1 963 0
 3269 1bf0 5830C4E5 		strb	r3, [r4, #88]
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3270              		.loc 1 964 0
 3271 1bf4 59E0C4E5 		strb	lr, [r4, #89]
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3272              		.loc 1 965 0
 3273 1bf8 AEFFFF1A 		bne	.L226
 3274 1bfc DAFFFFEA 		b	.L287
 3275              	.LVL271:
 3276              	.L289:
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3277              		.loc 1 987 0
 3278 1c00 38479FE5 		ldr	r4, .L293+8
 3279 1c04 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3280              		.loc 1 988 0
 3281 1c08 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3282              		.loc 1 989 0
 3283 1c0c 0A0050E3 		cmp	r0, #10
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3284              		.loc 1 987 0
 3285 1c10 5860C4E5 		strb	r6, [r4, #88]
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3286              		.loc 1 988 0
 3287 1c14 59C0C4E5 		strb	ip, [r4, #89]
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3288              		.loc 1 989 0
 3289 1c18 A6FFFF1A 		bne	.L226
 3290 1c1c D2FFFFEA 		b	.L287
 3291              	.L216:
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3292              		.loc 1 981 0
 3293 1c20 18479FE5 		ldr	r4, .L293+8
 3294 1c24 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3295              	.LVL272:
 3296 1c28 0410A0E1 		mov	r1, r4
 3297 1c2c 5800E1E5 		strb	r0, [r1, #88]!
 985:../uvc.c      **** 			  break;
 3298              		.loc 1 985 0
 3299 1c30 FF60A0E3 		mov	r6, #255
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3300              		.loc 1 982 0
 3301 1c34 0100A0E3 		mov	r0, #1
 3302 1c38 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3303              	.LVL273:
 985:../uvc.c      **** 			  break;
 3304              		.loc 1 985 0
 3305 1c3c 0680A0E1 		mov	r8, r6
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3306              		.loc 1 982 0
 3307 1c40 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 985:../uvc.c      **** 			  break;
 3308              		.loc 1 985 0
 3309 1c44 0170A0E3 		mov	r7, #1
 3310 1c48 82FFFFEA 		b	.L219
 3311              	.LVL274:
 3312              	.L232:
1111:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3313              		.loc 1 1111 0
 3314 1c4c FC669FE5 		ldr	r6, .L293+24
 3315 1c50 0010E0E3 		mvn	r1, #0
 3316 1c54 1C0096E5 		ldr	r0, [r6, #28]
 3317 1c58 2C308DE5 		str	r3, [sp, #44]
 3318 1c5c FEFFFFEB 		bl	_txe_mutex_get
1112:../uvc.c      **** 					  if(getData == 1)
 3319              		.loc 1 1112 0
 3320 1c60 30E09DE5 		ldr	lr, [sp, #48]
 3321 1c64 2C309DE5 		ldr	r3, [sp, #44]
 3322 1c68 01005EE3 		cmp	lr, #1
 3323 1c6c A901000A 		beq	.L291
1114:../uvc.c      **** 					  else if(getData == 0xff)
 3324              		.loc 1 1114 0
 3325 1c70 FF005EE3 		cmp	lr, #255
 3326 1c74 9E01000A 		beq	.L292
1117:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 3327              		.loc 1 1117 0
 3328 1c78 0080A0E3 		mov	r8, #0
 3329 1c7c 0600A0E1 		mov	r0, r6
 3330 1c80 2310A0E3 		mov	r1, #35
 3331 1c84 0B20A0E1 		mov	r2, fp
 3332 1c88 00808DE5 		str	r8, [sp, #0]
 3333 1c8c 04808DE5 		str	r8, [sp, #4]
 3334 1c90 FEFFFFEB 		bl	cmdSet
 3335              	.L285:
1120:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3336              		.loc 1 1120 0
 3337 1c94 1C0096E5 		ldr	r0, [r6, #28]
 3338 1c98 FEFFFFEB 		bl	_txe_mutex_put
1122:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3339              		.loc 1 1122 0
 3340 1c9c 30809DE5 		ldr	r8, [sp, #48]
 3341 1ca0 34609DE5 		ldr	r6, [sp, #52]
 3342 1ca4 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3343 1ca8 0400A0E3 		mov	r0, #4
 3344 1cac A0169FE5 		ldr	r1, .L293+28
 3345 1cb0 0820A0E1 		mov	r2, r8
 3346 1cb4 0630A0E1 		mov	r3, r6
 3347 1cb8 00C08DE5 		str	ip, [sp, #0]
 3348 1cbc FEFFFFEB 		bl	CyU3PDebugPrint
1123:../uvc.c      **** 					  break;
 3349              		.loc 1 1123 0
 3350 1cc0 FFC0A0E3 		mov	ip, #255
 3351 1cc4 63FFFFEA 		b	.L219
 3352              	.LVL275:
 3353              	.L231:
1088:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3354              		.loc 1 1088 0
 3355 1cc8 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3356 1ccc 010058E3 		cmp	r8, #1
 3357 1cd0 08005813 		cmpne	r8, #8
 3358 1cd4 0000A013 		movne	r0, #0
 3359 1cd8 0100A003 		moveq	r0, #1
 3360 1cdc 8001001A 		bne	.L282
 3361              	.LVL276:
1091:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3362              		.loc 1 1091 0
 3363 1ce0 68869FE5 		ldr	r8, .L293+24
 3364 1ce4 0010E0E3 		mvn	r1, #0
 3365 1ce8 1C0098E5 		ldr	r0, [r8, #28]
 3366 1cec 2C308DE5 		str	r3, [sp, #44]
 3367 1cf0 FEFFFFEB 		bl	_txe_mutex_get
1092:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3368              		.loc 1 1092 0
 3369 1cf4 30A09DE5 		ldr	sl, [sp, #48]
 3370 1cf8 2210A0E3 		mov	r1, #34
 3371 1cfc 0B20A0E1 		mov	r2, fp
 3372 1d00 2C309DE5 		ldr	r3, [sp, #44]
 3373 1d04 00C0A0E3 		mov	ip, #0
 3374 1d08 0800A0E1 		mov	r0, r8
 3375 1d0c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3376 1d10 FEFFFFEB 		bl	cmdSet
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3377              		.loc 1 1093 0
 3378 1d14 1C0098E5 		ldr	r0, [r8, #28]
 3379 1d18 FEFFFFEB 		bl	_txe_mutex_put
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3380              		.loc 1 1096 0
 3381 1d1c 18069FE5 		ldr	r0, .L293+4
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3382              		.loc 1 1097 0
 3383 1d20 34209DE5 		ldr	r2, [sp, #52]
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3384              		.loc 1 1096 0
 3385 1d24 061089E0 		add	r1, r9, r6
 3386 1d28 813180E0 		add	r3, r0, r1, asl #3
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3387              		.loc 1 1098 0
 3388 1d2c 0160A0E3 		mov	r6, #1
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3389              		.loc 1 1096 0
 3390 1d30 9DA4C3E5 		strb	sl, [r3, #1181]
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3391              		.loc 1 1097 0
 3392 1d34 9E24C3E5 		strb	r2, [r3, #1182]
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3393              		.loc 1 1098 0
 3394 1d38 A064C3E5 		strb	r6, [r3, #1184]
 3395              	.LVL277:
 3396              	.L283:
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3397              		.loc 1 1100 0
 3398 1d3c 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3399 1d40 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1105:../uvc.c      **** 					  break;
 3400              		.loc 1 1105 0
 3401 1d44 FFC0A0E3 		mov	ip, #255
 3402 1d48 42FFFFEA 		b	.L219
 3403              	.LVL278:
 3404              	.L230:
1054:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3405              		.loc 1 1054 0
 3406 1d4c B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3407 1d50 010050E3 		cmp	r0, #1
 3408 1d54 04005013 		cmpne	r0, #4
 3409 1d58 5C01001A 		bne	.L240
1053:../uvc.c      **** 					  value = (value << 8)|Data0;
 3410              		.loc 1 1053 0
 3411 1d5c 30109DE5 		ldr	r1, [sp, #48]
 3412 1d60 34E09DE5 		ldr	lr, [sp, #52]
 3413 1d64 0E2481E1 		orr	r2, r1, lr, asl #8
1055:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3414              		.loc 1 1055 0
 3415 1d68 F90052E3 		cmp	r2, #249
 3416 1d6c 5701008A 		bhi	.L240
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3417              		.loc 1 1060 0
 3418 1d70 C8A042E2 		sub	sl, r2, #200
 3419 1d74 0AC8A0E1 		mov	ip, sl, asl #16
 3420 1d78 3CC08DE5 		str	ip, [sp, #60]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3421              		.loc 1 1062 0
 3422 1d7c 27A062E2 		rsb	sl, r2, #39
 3423 1d80 38A08DE5 		str	sl, [sp, #56]
 3424 1d84 3CA09DE5 		ldr	sl, [sp, #60]
 3425 1d88 C81062E2 		rsb	r1, r2, #200
 3426 1d8c C80052E3 		cmp	r2, #200
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3427              		.loc 1 1060 0
 3428 1d90 640042E2 		sub	r0, r2, #100
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3429              		.loc 1 1062 0
 3430 1d94 0118A0E1 		mov	r1, r1, asl #16
 3431 1d98 64E062E2 		rsb	lr, r2, #100
 3432 1d9c 2A18A081 		movhi	r1, sl, lsr #16
 3433 1da0 2118A091 		movls	r1, r1, lsr #16
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3434              		.loc 1 1060 0
 3435 1da4 00C8A0E1 		mov	ip, r0, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3436              		.loc 1 1062 0
 3437 1da8 640052E3 		cmp	r2, #100
 3438 1dac 0E08A0E1 		mov	r0, lr, asl #16
 3439 1db0 2C08A081 		movhi	r0, ip, lsr #16
 3440 1db4 38C09DE5 		ldr	ip, [sp, #56]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3441              		.loc 1 1060 0
 3442 1db8 14A042E2 		sub	sl, r2, #20
 3443 1dbc 38A08DE5 		str	sl, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3444              		.loc 1 1062 0
 3445 1dc0 2008A091 		movls	r0, r0, lsr #16
 3446 1dc4 14A062E2 		rsb	sl, r2, #20
 3447 1dc8 3CA08DE5 		str	sl, [sp, #60]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3448              		.loc 1 1060 0
 3449 1dcc 27E042E2 		sub	lr, r2, #39
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3450              		.loc 1 1062 0
 3451 1dd0 000051E1 		cmp	r1, r0
 3452 1dd4 01A0A031 		movcc	sl, r1
 3453 1dd8 00A0A021 		movcs	sl, r0
 3454 1ddc 0CC8A0E1 		mov	ip, ip, asl #16
 3455 1de0 270052E3 		cmp	r2, #39
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3456              		.loc 1 1060 0
 3457 1de4 0EE8A0E1 		mov	lr, lr, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3458              		.loc 1 1062 0
 3459 1de8 2CE8A091 		movls	lr, ip, lsr #16
 3460 1dec 64C59FE5 		ldr	ip, .L293+32
 3461 1df0 20A08DE5 		str	sl, [sp, #32]
 3462 1df4 01A06CE0 		rsb	sl, ip, r1
 3463 1df8 2EE8A081 		movhi	lr, lr, lsr #16
 3464 1dfc 00C07AE2 		rsbs	ip, sl, #0
 3465 1e00 0AC0ACE0 		adc	ip, ip, sl
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3466              		.loc 1 1060 0
 3467 1e04 38A09DE5 		ldr	sl, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3468              		.loc 1 1062 0
 3469 1e08 44C08DE5 		str	ip, [sp, #68]
 3470              	.LVL279:
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3471              		.loc 1 1060 0
 3472 1e0c 0AC8A0E1 		mov	ip, sl, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3473              		.loc 1 1062 0
 3474 1e10 3CA09DE5 		ldr	sl, [sp, #60]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3475              		.loc 1 1060 0
 3476 1e14 4CC08DE5 		str	ip, [sp, #76]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3477              		.loc 1 1062 0
 3478 1e18 0AC8A0E1 		mov	ip, sl, asl #16
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3479              		.loc 1 1060 0
 3480 1e1c 0AA042E2 		sub	sl, r2, #10
 3481 1e20 48A08DE5 		str	sl, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3482              		.loc 1 1062 0
 3483 1e24 20A09DE5 		ldr	sl, [sp, #32]
 3484 1e28 3CC08DE5 		str	ip, [sp, #60]
 3485 1e2c 0A005EE1 		cmp	lr, sl
 3486 1e30 0EA0A031 		movcc	sl, lr
 3487 1e34 0AC062E2 		rsb	ip, r2, #10
 3488 1e38 40C08DE5 		str	ip, [sp, #64]
 3489 1e3c 38A08DE5 		str	sl, [sp, #56]
 3490 1e40 3CC09DE5 		ldr	ip, [sp, #60]
 3491 1e44 4CA09DE5 		ldr	sl, [sp, #76]
 3492 1e48 140052E3 		cmp	r2, #20
 3493 1e4c 2CA8A091 		movls	sl, ip, lsr #16
 3494 1e50 2AA8A081 		movhi	sl, sl, lsr #16
 3495 1e54 44C09DE5 		ldr	ip, [sp, #68]
 3496 1e58 010050E1 		cmp	r0, r1
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3497              		.loc 1 1060 0
 3498 1e5c 48109DE5 		ldr	r1, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3499              		.loc 1 1062 0
 3500 1e60 01C0A033 		movcc	ip, #1
 3501 1e64 3CA08DE5 		str	sl, [sp, #60]
 3502 1e68 24C08DE5 		str	ip, [sp, #36]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3503              		.loc 1 1060 0
 3504 1e6c 01A8A0E1 		mov	sl, r1, asl #16
 3505 1e70 05C042E2 		sub	ip, r2, #5
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3506              		.loc 1 1062 0
 3507 1e74 051062E2 		rsb	r1, r2, #5
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3508              		.loc 1 1060 0
 3509 1e78 48A08DE5 		str	sl, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3510              		.loc 1 1062 0
 3511 1e7c 40009DE5 		ldr	r0, [sp, #64]
 3512 1e80 38A09DE5 		ldr	sl, [sp, #56]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3513              		.loc 1 1060 0
 3514 1e84 40C08DE5 		str	ip, [sp, #64]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3515              		.loc 1 1062 0
 3516 1e88 3CC09DE5 		ldr	ip, [sp, #60]
 3517 1e8c 4C108DE5 		str	r1, [sp, #76]
 3518 1e90 48109DE5 		ldr	r1, [sp, #72]
 3519 1e94 0008A0E1 		mov	r0, r0, asl #16
 3520 1e98 0A005CE1 		cmp	ip, sl
 3521 1e9c 0AC0A021 		movcs	ip, sl
 3522 1ea0 0A0052E3 		cmp	r2, #10
 3523 1ea4 20A09DE5 		ldr	sl, [sp, #32]
 3524 1ea8 2108A081 		movhi	r0, r1, lsr #16
 3525 1eac 2008A091 		movls	r0, r0, lsr #16
 3526 1eb0 48008DE5 		str	r0, [sp, #72]
 3527 1eb4 24009DE5 		ldr	r0, [sp, #36]
 3528 1eb8 0A005EE1 		cmp	lr, sl
 3529 1ebc 0200A033 		movcc	r0, #2
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3530              		.loc 1 1060 0
 3531 1ec0 02E042E2 		sub	lr, r2, #2
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3532              		.loc 1 1062 0
 3533 1ec4 44C08DE5 		str	ip, [sp, #68]
 3534 1ec8 24008DE5 		str	r0, [sp, #36]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3535              		.loc 1 1060 0
 3536 1ecc 40C09DE5 		ldr	ip, [sp, #64]
 3537 1ed0 1CE08DE5 		str	lr, [sp, #28]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3538              		.loc 1 1062 0
 3539 1ed4 44009DE5 		ldr	r0, [sp, #68]
 3540 1ed8 48E09DE5 		ldr	lr, [sp, #72]
 3541 1edc 4C109DE5 		ldr	r1, [sp, #76]
 3542 1ee0 02A062E2 		rsb	sl, r2, #2
 3543 1ee4 00005EE1 		cmp	lr, r0
 3544 1ee8 00E0A021 		movcs	lr, r0
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3545              		.loc 1 1060 0
 3546 1eec 0CC8A0E1 		mov	ip, ip, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3547              		.loc 1 1062 0
 3548 1ef0 050052E3 		cmp	r2, #5
 3549 1ef4 40A08DE5 		str	sl, [sp, #64]
 3550 1ef8 0118A0E1 		mov	r1, r1, asl #16
 3551 1efc 3CA09DE5 		ldr	sl, [sp, #60]
 3552 1f00 2C18A081 		movhi	r1, ip, lsr #16
 3553 1f04 38C09DE5 		ldr	ip, [sp, #56]
 3554 1f08 4CE08DE5 		str	lr, [sp, #76]
 3555 1f0c 24009DE5 		ldr	r0, [sp, #36]
 3556 1f10 40E09DE5 		ldr	lr, [sp, #64]
 3557 1f14 2118A091 		movls	r1, r1, lsr #16
 3558 1f18 0C005AE1 		cmp	sl, ip
 3559 1f1c 20108DE5 		str	r1, [sp, #32]
 3560 1f20 0300A033 		movcc	r0, #3
 3561 1f24 38008DE5 		str	r0, [sp, #56]
 3562 1f28 4CA09DE5 		ldr	sl, [sp, #76]
 3563 1f2c 0E08A0E1 		mov	r0, lr, asl #16
 3564 1f30 20E09DE5 		ldr	lr, [sp, #32]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3565              		.loc 1 1060 0
 3566 1f34 1C109DE5 		ldr	r1, [sp, #28]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3567              		.loc 1 1062 0
 3568 1f38 0A005EE1 		cmp	lr, sl
 3569 1f3c 0AE0A021 		movcs	lr, sl
 3570 1f40 44C09DE5 		ldr	ip, [sp, #68]
 3571 1f44 48A09DE5 		ldr	sl, [sp, #72]
 3572 1f48 020052E3 		cmp	r2, #2
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3573              		.loc 1 1060 0
 3574 1f4c 0118A0E1 		mov	r1, r1, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3575              		.loc 1 1062 0
 3576 1f50 2018A091 		movls	r1, r0, lsr #16
 3577 1f54 38009DE5 		ldr	r0, [sp, #56]
 3578 1f58 2118A081 		movhi	r1, r1, lsr #16
 3579 1f5c 0C005AE1 		cmp	sl, ip
 3580 1f60 0400A033 		movcc	r0, #4
 3581 1f64 40008DE5 		str	r0, [sp, #64]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3582              		.loc 1 1060 0
 3583 1f68 010042E2 		sub	r0, r2, #1
 3584 1f6c 38008DE5 		str	r0, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3585              		.loc 1 1062 0
 3586 1f70 4CA09DE5 		ldr	sl, [sp, #76]
 3587 1f74 20009DE5 		ldr	r0, [sp, #32]
 3588 1f78 01C062E2 		rsb	ip, r2, #1
 3589 1f7c 3CC08DE5 		str	ip, [sp, #60]
 3590 1f80 0A0050E1 		cmp	r0, sl
1069:../uvc.c      **** 						  shutter = shutter+index;
 3591              		.loc 1 1069 0
 3592 1f84 38A09DE5 		ldr	sl, [sp, #56]
 3593 1f88 3C009DE5 		ldr	r0, [sp, #60]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3594              		.loc 1 1062 0
 3595 1f8c 40C09DE5 		ldr	ip, [sp, #64]
 3596 1f90 05C0A033 		movcc	ip, #5
1069:../uvc.c      **** 						  shutter = shutter+index;
 3597              		.loc 1 1069 0
 3598 1f94 010052E3 		cmp	r2, #1
 3599 1f98 0028A091 		movls	r2, r0, asl #16
 3600 1f9c 0A28A081 		movhi	r2, sl, asl #16
 3601 1fa0 0E0051E1 		cmp	r1, lr
 3602 1fa4 01A0A031 		movcc	sl, r1
 3603 1fa8 0EA0A021 		movcs	sl, lr
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3604              		.loc 1 1062 0
 3605 1fac 0E0051E1 		cmp	r1, lr
 3606 1fb0 0C10A021 		movcs	r1, ip
 3607 1fb4 0610A033 		movcc	r1, #6
1069:../uvc.c      **** 						  shutter = shutter+index;
 3608              		.loc 1 1069 0
 3609 1fb8 22085AE1 		cmp	sl, r2, lsr #16
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3610              		.loc 1 1072 0
 3611 1fbc 8CA39FE5 		ldr	sl, .L293+24
1069:../uvc.c      **** 						  shutter = shutter+index;
 3612              		.loc 1 1069 0
 3613 1fc0 0120A091 		movls	r2, r1
 3614 1fc4 0720A083 		movhi	r2, #7
 3615 1fc8 012082E2 		add	r2, r2, #1
 3616 1fcc FFE002E2 		and	lr, r2, #255
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3617              		.loc 1 1072 0
 3618 1fd0 0010E0E3 		mvn	r1, #0
 3619 1fd4 1C009AE5 		ldr	r0, [sl, #28]
1069:../uvc.c      **** 						  shutter = shutter+index;
 3620              		.loc 1 1069 0
 3621 1fd8 38E08DE5 		str	lr, [sp, #56]
 3622              	.LVL280:
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3623              		.loc 1 1072 0
 3624 1fdc 2C308DE5 		str	r3, [sp, #44]
 3625 1fe0 FEFFFFEB 		bl	_txe_mutex_get
1073:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3626              		.loc 1 1073 0
 3627 1fe4 38C09DE5 		ldr	ip, [sp, #56]
 3628 1fe8 0310A0E3 		mov	r1, #3
 3629 1fec 0B20A0E1 		mov	r2, fp
 3630 1ff0 2C309DE5 		ldr	r3, [sp, #44]
 3631 1ff4 00C08DE5 		str	ip, [sp, #0]
 3632 1ff8 0A00A0E1 		mov	r0, sl
 3633 1ffc 00C0A0E3 		mov	ip, #0
 3634 2000 04C08DE5 		str	ip, [sp, #4]
 3635 2004 FEFFFFEB 		bl	cmdSet
1074:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3636              		.loc 1 1074 0
 3637 2008 1C009AE5 		ldr	r0, [sl, #28]
 3638 200c FEFFFFEB 		bl	_txe_mutex_put
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3639              		.loc 1 1077 0
 3640 2010 30009DE5 		ldr	r0, [sp, #48]
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3641              		.loc 1 1078 0
 3642 2014 34C09DE5 		ldr	ip, [sp, #52]
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3643              		.loc 1 1080 0
 3644 2018 38309DE5 		ldr	r3, [sp, #56]
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3645              		.loc 1 1077 0
 3646 201c 061089E0 		add	r1, r9, r6
 3647 2020 816188E0 		add	r6, r8, r1, asl #3
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3648              		.loc 1 1079 0
 3649 2024 0120A0E3 		mov	r2, #1
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3650              		.loc 1 1077 0
 3651 2028 9D04C6E5 		strb	r0, [r6, #1181]
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3652              		.loc 1 1078 0
 3653 202c 9EC4C6E5 		strb	ip, [r6, #1182]
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3654              		.loc 1 1079 0
 3655 2030 A024C6E5 		strb	r2, [r6, #1184]
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3656              		.loc 1 1080 0
 3657 2034 0D33C8E5 		strb	r3, [r8, #781]
 3658 2038 3FFFFFEA 		b	.L283
 3659              	.LVL281:
 3660              	.L229:
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3661              		.loc 1 1007 0
 3662 203c 062089E0 		add	r2, r9, r6
 3663 2040 826188E0 		add	r6, r8, r2, asl #3
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3664              		.loc 1 1008 0
 3665 2044 0110A0E3 		mov	r1, #1
1011:../uvc.c      **** 		  		    switch (getData){
 3666              		.loc 1 1011 0
 3667 2048 01E040E2 		sub	lr, r0, #1
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3668              		.loc 1 1007 0
 3669 204c 9D04C6E5 		strb	r0, [r6, #1181]
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3670              		.loc 1 1008 0
 3671 2050 A014C6E5 		strb	r1, [r6, #1184]
 3672              	.LVL282:
1011:../uvc.c      **** 		  		    switch (getData){
 3673              		.loc 1 1011 0
 3674 2054 07005EE3 		cmp	lr, #7
 3675 2058 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3676 205c 970000EA 		b	.L234
 3677              	.L239:
 3678 2060 54220000 		.word	.L235
 3679 2064 B8210000 		.word	.L236
 3680 2068 C0220000 		.word	.L234
 3681 206c 54210000 		.word	.L237
 3682 2070 C0220000 		.word	.L234
 3683 2074 C0220000 		.word	.L234
 3684 2078 C0220000 		.word	.L234
 3685 207c B4200000 		.word	.L238
 3686              	.LVL283:
 3687              	.L228:
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3688              		.loc 1 1127 0
 3689 2080 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3690              		.loc 1 1126 0
 3691 2084 30A09DE5 		ldr	sl, [sp, #48]
 3692 2088 069089E0 		add	r9, r9, r6
 3693 208c 89E188E0 		add	lr, r8, r9, asl #3
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3694              		.loc 1 1127 0
 3695 2090 0620A0E1 		mov	r2, r6
 3696 2094 0400A0E3 		mov	r0, #4
 3697 2098 BC129FE5 		ldr	r1, .L293+36
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3698              		.loc 1 1126 0
 3699 209c 9DA4CEE5 		strb	sl, [lr, #1181]
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3700              		.loc 1 1127 0
 3701 20a0 FEFFFFEB 		bl	CyU3PDebugPrint
1128:../uvc.c      **** 			  		 break;
 3702              		.loc 1 1128 0
 3703 20a4 FFC0A0E3 		mov	ip, #255
 3704 20a8 0C60A0E1 		mov	r6, ip
 3705 20ac 0C80A0E1 		mov	r8, ip
 3706 20b0 68FEFFEA 		b	.L219
 3707              	.LVL284:
 3708              	.L238:
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3709              		.loc 1 1030 0
 3710 20b4 94629FE5 		ldr	r6, .L293+24
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3711              		.loc 1 1028 0
 3712 20b8 00A0A0E3 		mov	sl, #0
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3713              		.loc 1 1030 0
 3714 20bc 1C0096E5 		ldr	r0, [r6, #28]
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3715              		.loc 1 1028 0
 3716 20c0 0DA3C8E5 		strb	sl, [r8, #781]
 3717              	.LVL285:
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3718              		.loc 1 1030 0
 3719 20c4 0010E0E3 		mvn	r1, #0
 3720 20c8 2C308DE5 		str	r3, [sp, #44]
 3721 20cc FEFFFFEB 		bl	_txe_mutex_get
1031:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3722              		.loc 1 1031 0
 3723 20d0 0B20A0E1 		mov	r2, fp
 3724 20d4 2C309DE5 		ldr	r3, [sp, #44]
 3725 20d8 1010A0E3 		mov	r1, #16
 3726 20dc 0600A0E1 		mov	r0, r6
 3727 20e0 00A08DE5 		str	sl, [sp, #0]
 3728 20e4 04A08DE5 		str	sl, [sp, #4]
 3729 20e8 FEFFFFEB 		bl	cmdSet
1032:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3730              		.loc 1 1032 0
 3731 20ec 1C0096E5 		ldr	r0, [r6, #28]
 3732 20f0 FEFFFFEB 		bl	_txe_mutex_put
 3733              	.LVL286:
 3734              	.LBB66:
 3735              	.LBB67:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3736              		.loc 1 384 0
 3737 20f4 0010E0E3 		mvn	r1, #0
 3738 20f8 1C0096E5 		ldr	r0, [r6, #28]
 3739 20fc FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3740              		.loc 1 385 0
 3741 2100 0180A0E3 		mov	r8, #1
 3742 2104 2010A0E3 		mov	r1, #32
 3743 2108 2720A0E3 		mov	r2, #39
 3744 210c 3030A0E3 		mov	r3, #48
 3745 2110 0600A0E1 		mov	r0, r6
 3746 2114 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3747 2118 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3748              		.loc 1 386 0
 3749 211c 02C0A0E3 		mov	ip, #2
 3750 2120 2110A0E3 		mov	r1, #33
 3751 2124 2520A0E3 		mov	r2, #37
 3752 2128 3030A0E3 		mov	r3, #48
 3753 212c 0600A0E1 		mov	r0, r6
 3754 2130 00C08DE5 		str	ip, [sp, #0]
 3755 2134 04A08DE5 		str	sl, [sp, #4]
 3756 2138 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3757              		.loc 1 387 0
 3758 213c 1C0096E5 		ldr	r0, [r6, #28]
 3759 2140 FEFFFFEB 		bl	_txe_mutex_put
 3760              	.LBE67:
 3761              	.LBE66:
1034:../uvc.c      **** 							break;
 3762              		.loc 1 1034 0
 3763 2144 FFC0A0E3 		mov	ip, #255
 3764 2148 0C60A0E1 		mov	r6, ip
 3765 214c 0880A0E3 		mov	r8, #8
 3766 2150 40FEFFEA 		b	.L219
 3767              	.LVL287:
 3768              	.L237:
 3769              	.LBB68:
 3770              	.LBB69:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3771              		.loc 1 384 0
 3772 2154 F4819FE5 		ldr	r8, .L293+24
 3773 2158 0010E0E3 		mvn	r1, #0
 3774 215c 1C0098E5 		ldr	r0, [r8, #28]
 3775 2160 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3776              		.loc 1 385 0
 3777 2164 0060A0E3 		mov	r6, #0
 3778 2168 2010A0E3 		mov	r1, #32
 3779 216c 2720A0E3 		mov	r2, #39
 3780 2170 3030A0E3 		mov	r3, #48
 3781 2174 0800A0E1 		mov	r0, r8
 3782 2178 00608DE5 		str	r6, [sp, #0]
 3783 217c 04608DE5 		str	r6, [sp, #4]
 3784 2180 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3785              		.loc 1 386 0
 3786 2184 2110A0E3 		mov	r1, #33
 3787 2188 2520A0E3 		mov	r2, #37
 3788 218c 3030A0E3 		mov	r3, #48
 3789 2190 0800A0E1 		mov	r0, r8
 3790 2194 00608DE5 		str	r6, [sp, #0]
 3791 2198 04608DE5 		str	r6, [sp, #4]
 3792 219c FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3793              		.loc 1 387 0
 3794 21a0 1C0098E5 		ldr	r0, [r8, #28]
 3795 21a4 FEFFFFEB 		bl	_txe_mutex_put
 3796 21a8 FFC0A0E3 		mov	ip, #255
 3797 21ac 0C60A0E1 		mov	r6, ip
 3798 21b0 0480A0E3 		mov	r8, #4
 3799 21b4 27FEFFEA 		b	.L219
 3800              	.LVL288:
 3801              	.L236:
 3802              	.LBE69:
 3803              	.LBE68:
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3804              		.loc 1 1018 0
 3805 21b8 90A19FE5 		ldr	sl, .L293+24
1016:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3806              		.loc 1 1016 0
 3807 21bc 0060A0E3 		mov	r6, #0
 3808 21c0 0D63C8E5 		strb	r6, [r8, #781]
 3809              	.LVL289:
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3810              		.loc 1 1018 0
 3811 21c4 0010E0E3 		mvn	r1, #0
 3812 21c8 1C009AE5 		ldr	r0, [sl, #28]
 3813 21cc 2C308DE5 		str	r3, [sp, #44]
 3814 21d0 FEFFFFEB 		bl	_txe_mutex_get
1019:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3815              		.loc 1 1019 0
 3816 21d4 0B20A0E1 		mov	r2, fp
 3817 21d8 2C309DE5 		ldr	r3, [sp, #44]
 3818 21dc 1010A0E3 		mov	r1, #16
 3819 21e0 0A00A0E1 		mov	r0, sl
 3820 21e4 00608DE5 		str	r6, [sp, #0]
 3821 21e8 04608DE5 		str	r6, [sp, #4]
 3822 21ec FEFFFFEB 		bl	cmdSet
1020:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3823              		.loc 1 1020 0
 3824 21f0 1C009AE5 		ldr	r0, [sl, #28]
 3825 21f4 FEFFFFEB 		bl	_txe_mutex_put
 3826              	.LVL290:
 3827              	.LBB70:
 3828              	.LBB71:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3829              		.loc 1 384 0
 3830 21f8 0010E0E3 		mvn	r1, #0
 3831 21fc 1C009AE5 		ldr	r0, [sl, #28]
 3832 2200 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3833              		.loc 1 385 0
 3834 2204 2010A0E3 		mov	r1, #32
 3835 2208 2720A0E3 		mov	r2, #39
 3836 220c 3030A0E3 		mov	r3, #48
 3837 2210 0A00A0E1 		mov	r0, sl
 3838 2214 00608DE5 		str	r6, [sp, #0]
 3839 2218 04608DE5 		str	r6, [sp, #4]
 3840 221c FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3841              		.loc 1 386 0
 3842 2220 2110A0E3 		mov	r1, #33
 3843 2224 2520A0E3 		mov	r2, #37
 3844 2228 3030A0E3 		mov	r3, #48
 3845 222c 0A00A0E1 		mov	r0, sl
 3846 2230 00608DE5 		str	r6, [sp, #0]
 3847 2234 04608DE5 		str	r6, [sp, #4]
 3848 2238 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3849              		.loc 1 387 0
 3850 223c 1C009AE5 		ldr	r0, [sl, #28]
 3851 2240 FEFFFFEB 		bl	_txe_mutex_put
 3852 2244 FFC0A0E3 		mov	ip, #255
 3853 2248 0C60A0E1 		mov	r6, ip
 3854 224c 0280A0E3 		mov	r8, #2
 3855 2250 00FEFFEA 		b	.L219
 3856              	.LVL291:
 3857              	.L235:
 3858              	.LBE71:
 3859              	.LBE70:
 3860              	.LBB72:
 3861              	.LBB73:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3862              		.loc 1 384 0
 3863 2254 F4609FE5 		ldr	r6, .L293+24
 3864 2258 0010E0E3 		mvn	r1, #0
 3865 225c 1C0096E5 		ldr	r0, [r6, #28]
 3866 2260 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3867              		.loc 1 385 0
 3868 2264 0080A0E3 		mov	r8, #0
 3869 2268 01A0A0E3 		mov	sl, #1
 3870 226c 2010A0E3 		mov	r1, #32
 3871 2270 2720A0E3 		mov	r2, #39
 3872 2274 3030A0E3 		mov	r3, #48
 3873 2278 0600A0E1 		mov	r0, r6
 3874 227c 04808DE5 		str	r8, [sp, #4]
 3875 2280 00A08DE5 		str	sl, [sp, #0]
 3876 2284 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3877              		.loc 1 386 0
 3878 2288 02C0A0E3 		mov	ip, #2
 3879 228c 2110A0E3 		mov	r1, #33
 3880 2290 2520A0E3 		mov	r2, #37
 3881 2294 3030A0E3 		mov	r3, #48
 3882 2298 0600A0E1 		mov	r0, r6
 3883 229c 00C08DE5 		str	ip, [sp, #0]
 3884 22a0 04808DE5 		str	r8, [sp, #4]
 3885 22a4 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3886              		.loc 1 387 0
 3887 22a8 1C0096E5 		ldr	r0, [r6, #28]
 3888 22ac FEFFFFEB 		bl	_txe_mutex_put
 3889              	.LBE73:
 3890              	.LBE72:
1014:../uvc.c      **** 							break;
 3891              		.loc 1 1014 0
 3892 22b0 FFC0A0E3 		mov	ip, #255
 3893 22b4 0C60A0E1 		mov	r6, ip
 3894 22b8 0A80A0E1 		mov	r8, sl
 3895 22bc E5FDFFEA 		b	.L219
 3896              	.LVL292:
 3897              	.L234:
1011:../uvc.c      **** 		  		    switch (getData){
 3898              		.loc 1 1011 0
 3899 22c0 FFC0A0E3 		mov	ip, #255
 3900 22c4 0080A0E1 		mov	r8, r0
 3901 22c8 0C60A0E1 		mov	r6, ip
 3902 22cc E1FDFFEA 		b	.L219
 3903              	.LVL293:
 3904              	.L240:
1082:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3905              		.loc 1 1082 0
 3906 22d0 0000A0E3 		mov	r0, #0
 3907 22d4 0110A0E3 		mov	r1, #1
 3908 22d8 0020A0E1 		mov	r2, r0
 3909 22dc FEFFFFEB 		bl	CyU3PUsbStall
 3910              	.LVL294:
 3911 22e0 95FEFFEA 		b	.L283
 3912              	.LVL295:
 3913              	.L282:
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3914              		.loc 1 1100 0
 3915 22e4 0110A0E3 		mov	r1, #1
 3916 22e8 0020A0E1 		mov	r2, r0
 3917 22ec FEFFFFEB 		bl	CyU3PUsbStall
 3918 22f0 91FEFFEA 		b	.L283
 3919              	.LVL296:
 3920              	.L292:
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3921              		.loc 1 1115 0
 3922 22f4 08E0A0E3 		mov	lr, #8
 3923 22f8 00C0A0E3 		mov	ip, #0
 3924 22fc 0600A0E1 		mov	r0, r6
 3925 2300 2310A0E3 		mov	r1, #35
 3926 2304 0B20A0E1 		mov	r2, fp
 3927 2308 00E08DE5 		str	lr, [sp, #0]
 3928 230c 04C08DE5 		str	ip, [sp, #4]
 3929 2310 FEFFFFEB 		bl	cmdSet
 3930 2314 5EFEFFEA 		b	.L285
 3931              	.L291:
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3932              		.loc 1 1113 0
 3933 2318 0480A0E3 		mov	r8, #4
 3934 231c 00E0A0E3 		mov	lr, #0
 3935 2320 0600A0E1 		mov	r0, r6
 3936 2324 2310A0E3 		mov	r1, #35
 3937 2328 0B20A0E1 		mov	r2, fp
 3938 232c 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3939 2330 FEFFFFEB 		bl	cmdSet
 3940 2334 56FEFFEA 		b	.L285
 3941              	.L294:
 3942              		.align	2
 3943              	.L293:
 3944 2338 00000000 		.word	bRequest
 3945 233c 00000000 		.word	.LANCHOR1
 3946 2340 00000000 		.word	.LANCHOR0
 3947 2344 D8030000 		.word	.LC24
 3948 2348 FC030000 		.word	.LC25
 3949 234c 58000000 		.word	.LANCHOR0+88
 3950 2350 00000000 		.word	cmdQu
 3951 2354 8C030000 		.word	.LC22
 3952 2358 FFFF0000 		.word	65535
 3953 235c B4030000 		.word	.LC23
 3954              		.cfi_endproc
 3955              	.LFE3:
 3957              		.align	2
 3958              		.global	UVCAppEP0Thread_Entry
 3960              	UVCAppEP0Thread_Entry:
 3961              	.LFB24:
3094:../uvc.c      **** {
 3962              		.loc 1 3094 0
 3963              		.cfi_startproc
 3964              		@ args = 0, pretend = 0, frame = 32
 3965              		@ frame_needed = 0, uses_anonymous_args = 0
 3966              	.LVL297:
 3967 2360 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3968              	.LCFI17:
 3969              		.cfi_def_cfa_offset 36
 3970 2364 DC499FE5 		ldr	r4, .L442
 3971              		.cfi_offset 14, -4
 3972              		.cfi_offset 11, -8
 3973              		.cfi_offset 10, -12
 3974              		.cfi_offset 9, -16
 3975              		.cfi_offset 8, -20
 3976              		.cfi_offset 7, -24
 3977              		.cfi_offset 6, -28
 3978              		.cfi_offset 5, -32
 3979              		.cfi_offset 4, -36
 3980 2368 DC699FE5 		ldr	r6, .L442+4
 3981 236c DC899FE5 		ldr	r8, .L442+8
 3982 2370 DC999FE5 		ldr	r9, .L442+12
 3983 2374 DCA99FE5 		ldr	sl, .L442+16
 3984 2378 DC799FE5 		ldr	r7, .L442+20
 3985 237c 3CD04DE2 		sub	sp, sp, #60
 3986              	.LCFI18:
 3987              		.cfi_def_cfa_offset 96
 3988              	.LVL298:
3116:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 3989              		.loc 1 3116 0
 3990 2380 0450A0E1 		mov	r5, r4
 3991              	.LVL299:
 3992              	.L419:
 3993 2384 00C0E0E3 		mvn	ip, #0
 3994 2388 B8099FE5 		ldr	r0, .L442
 3995 238c 4C10A0E3 		mov	r1, #76
 3996 2390 0120A0E3 		mov	r2, #1
 3997 2394 30308DE2 		add	r3, sp, #48
 3998 2398 00C08DE5 		str	ip, [sp, #0]
 3999 239c FEFFFFEB 		bl	_txe_event_flags_get
 4000 23a0 000050E3 		cmp	r0, #0
 4001 23a4 3000001A 		bne	.L296
3120:../uvc.c      ****             if (!isUsbConnected)
 4002              		.loc 1 3120 0
 4003 23a8 3C3095E5 		ldr	r3, [r5, #60]
 4004 23ac 000053E3 		cmp	r3, #0
 4005 23b0 8900000A 		beq	.L433
 4006              	.L297:
3129:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4007              		.loc 1 3129 0
 4008 23b4 30309DE5 		ldr	r3, [sp, #48]
 4009 23b8 0C0013E3 		tst	r3, #12
 4010 23bc 7200001A 		bne	.L434
 4011              	.L298:
3136:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4012              		.loc 1 3136 0
 4013 23c0 040013E3 		tst	r3, #4
 4014 23c4 1C00000A 		beq	.L299
3138:../uvc.c      ****             	switch ((wIndex >> 8))
 4015              		.loc 1 3138 0
 4016 23c8 B0E0DAE1 		ldrh	lr, [sl, #0]
 4017 23cc 2E24A0E1 		mov	r2, lr, lsr #8
 4018 23d0 030052E3 		cmp	r2, #3
 4019 23d4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4020 23d8 120000EA 		b	.L300
 4021              	.L305:
 4022 23dc 28240000 		.word	.L300
 4023 23e0 0C250000 		.word	.L302
 4024 23e4 EC230000 		.word	.L303
 4025 23e8 48250000 		.word	.L304
 4026              	.L303:
 4027              	.LBB88:
 4028              	.LBB90:
2425:../uvc.c      ****     switch (wValue)
 4029              		.loc 1 2425 0
 4030 23ec B020D9E1 		ldrh	r2, [r9, #0]
 4031 23f0 060C52E3 		cmp	r2, #1536
 4032 23f4 D901000A 		beq	.L311
 4033 23f8 CC00008A 		bhi	.L317
 4034 23fc 030C52E3 		cmp	r2, #768
 4035 2400 D201000A 		beq	.L309
 4036 2404 C901008A 		bhi	.L318
 4037 2408 010C52E3 		cmp	r2, #256
 4038 240c 6801000A 		beq	.L307
 4039 2410 020C52E3 		cmp	r2, #512
 4040 2414 6201000A 		beq	.L435
 4041              	.L320:
 4042              	.LBE90:
 4043              	.LBE88:
 4044              	.LBB93:
 4045              	.LBB97:
2557:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4046              		.loc 1 2557 0
 4047 2418 40199FE5 		ldr	r1, .L442+24
 4048 241c 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4049 2420 0400A0E3 		mov	r0, #4
 4050 2424 FEFFFFEB 		bl	CyU3PDebugPrint
 4051              	.L300:
 4052              	.LBE97:
 4053              	.LBE93:
3159:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4054              		.loc 1 3159 0
 4055 2428 0000A0E3 		mov	r0, #0
 4056 242c 0110A0E3 		mov	r1, #1
 4057 2430 0020A0E1 		mov	r2, r0
 4058 2434 FEFFFFEB 		bl	CyU3PUsbStall
 4059 2438 30309DE5 		ldr	r3, [sp, #48]
 4060              	.L299:
3164:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4061              		.loc 1 3164 0
 4062 243c 080013E3 		tst	r3, #8
 4063 2440 0700000A 		beq	.L361
3168:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4064              		.loc 1 3168 0
 4065 2444 B030DAE1 		ldrh	r3, [sl, #0]
 4066 2448 010053E3 		cmp	r3, #1
 4067 244c 6800000A 		beq	.L362
 4068              	.L363:
 4069              	.LBB102:
 4070              	.LBB108:
3083:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4071              		.loc 1 3083 0
 4072 2450 0000A0E3 		mov	r0, #0
 4073 2454 0110A0E3 		mov	r1, #1
 4074 2458 0020A0E1 		mov	r2, r0
 4075 245c FEFFFFEB 		bl	CyU3PUsbStall
 4076              	.L423:
 4077 2460 30309DE5 		ldr	r3, [sp, #48]
 4078              	.L361:
 4079              	.LBE108:
 4080              	.LBE102:
3179:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4081              		.loc 1 3179 0
 4082 2464 400013E3 		tst	r3, #64
 4083 2468 0100001A 		bne	.L436
 4084              	.L296:
3394:../uvc.c      ****         CyU3PThreadRelinquish ();
 4085              		.loc 1 3394 0
 4086 246c FEFFFFEB 		bl	_txe_thread_relinquish
3395:../uvc.c      ****     }
 4087              		.loc 1 3395 0
 4088 2470 C3FFFFEA 		b	.L419
 4089              	.L436:
3184:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4090              		.loc 1 3184 0
 4091 2474 1800A0E3 		mov	r0, #24
 4092 2478 2C108DE2 		add	r1, sp, #44
 4093 247c FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3191:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4094              		.loc 1 3191 0
 4095 2480 2C209DE5 		ldr	r2, [sp, #44]
 4096 2484 000052E3 		cmp	r2, #0
 4097 2488 6D00000A 		beq	.L414
3191:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4098              		.loc 1 3191 0 is_stmt 0 discriminator 1
 4099 248c 6336D6E5 		ldrb	r3, [r6, #1635]	@ zero_extendqisi2
 4100 2490 000053E3 		cmp	r3, #0
 4101 2494 F4FFFF1A 		bne	.L296
3193:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4102              		.loc 1 3193 0 is_stmt 1
 4103 2498 002097E5 		ldr	r2, [r7, #0]
 4104 249c 02B0A0E3 		mov	fp, #2
 4105 24a0 00B0C2E5 		strb	fp, [r2, #0]
3194:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4106              		.loc 1 3194 0
 4107 24a4 001097E5 		ldr	r1, [r7, #0]
 4108 24a8 01B0A0E3 		mov	fp, #1
 4109 24ac 01B0C1E5 		strb	fp, [r1, #1]
3195:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4110              		.loc 1 3195 0
 4111 24b0 000097E5 		ldr	r0, [r7, #0]
3199:../uvc.c      **** 					interStabuf.size   = 1024;
 4112              		.loc 1 3199 0
 4113 24b4 01EBA0E3 		mov	lr, #1024	@ movhi
3195:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4114              		.loc 1 3195 0
 4115 24b8 0230C0E5 		strb	r3, [r0, #2]
3196:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4116              		.loc 1 3196 0
 4117 24bc 00C097E5 		ldr	ip, [r7, #0]
3205:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4118              		.loc 1 3205 0
 4119 24c0 0010E0E3 		mvn	r1, #0
3196:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4120              		.loc 1 3196 0
 4121 24c4 0330CCE5 		strb	r3, [ip, #3]
3198:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4122              		.loc 1 3198 0
 4123 24c8 002097E5 		ldr	r2, [r7, #0]
3202:../uvc.c      **** 					interStabuf.count = 4;
 4124              		.loc 1 3202 0
 4125 24cc 04C0A0E3 		mov	ip, #4	@ movhi
3205:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4126              		.loc 1 3205 0
 4127 24d0 8C089FE5 		ldr	r0, .L442+28
3198:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4128              		.loc 1 3198 0
 4129 24d4 20208DE5 		str	r2, [sp, #32]
3199:../uvc.c      **** 					interStabuf.size   = 1024;
 4130              		.loc 1 3199 0
 4131 24d8 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3200:../uvc.c      **** 					interStabuf.status = 0;
 4132              		.loc 1 3200 0
 4133 24dc B832CDE1 		strh	r3, [sp, #40]	@ movhi
3202:../uvc.c      **** 					interStabuf.count = 4;
 4134              		.loc 1 3202 0
 4135 24e0 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
3205:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4136              		.loc 1 3205 0
 4137 24e4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3208:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4138              		.loc 1 3208 0
 4139 24e8 74089FE5 		ldr	r0, .L442+28
 4140 24ec 20108DE2 		add	r1, sp, #32
 4141 24f0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4142              	.LVL300:
3209:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4143              		.loc 1 3209 0
 4144 24f4 002050E2 		subs	r2, r0, #0
 4145 24f8 6701001A 		bne	.L437
3214:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4146              		.loc 1 3214 0
 4147 24fc 48389FE5 		ldr	r3, .L442+4
 4148 2500 63B6C3E5 		strb	fp, [r3, #1635]
3394:../uvc.c      ****         CyU3PThreadRelinquish ();
 4149              		.loc 1 3394 0
 4150 2504 FEFFFFEB 		bl	_txe_thread_relinquish
 4151              	.LVL301:
 4152 2508 9DFFFFEA 		b	.L419
 4153              	.L302:
 4154              	.LBB114:
 4155              	.LBB98:
2500:../uvc.c      ****     switch (wValue)
 4156              		.loc 1 2500 0
 4157 250c B020D9E1 		ldrh	r2, [r9, #0]
 4158 2510 060C52E3 		cmp	r2, #1536
 4159 2514 D500000A 		beq	.L326
 4160 2518 8F00008A 		bhi	.L332
 4161 251c 030C52E3 		cmp	r2, #768
 4162 2520 1701000A 		beq	.L323
 4163 2524 0E01008A 		bhi	.L333
 4164 2528 010C52E3 		cmp	r2, #256
 4165 252c 5601000A 		beq	.L321
 4166 2530 020C52E3 		cmp	r2, #512
 4167 2534 B7FFFF1A 		bne	.L320
 4168              	.LVL302:
2508:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4169              		.loc 1 2508 0
 4170 2538 0100A0E3 		mov	r0, #1
 4171 253c FEFFFFEB 		bl	CTControlHandle
 4172              	.LVL303:
 4173 2540 30309DE5 		ldr	r3, [sp, #48]
 4174 2544 BCFFFFEA 		b	.L299
 4175              	.L304:
 4176              	.LBE98:
 4177              	.LBE114:
 4178              	.LBB115:
 4179              	.LBB120:
2725:../uvc.c      ****     switch (wValue)
 4180              		.loc 1 2725 0
 4181 2548 B020D9E1 		ldrh	r2, [r9, #0]
 4182 254c 090C52E3 		cmp	r2, #2304
 4183 2550 EE01000A 		beq	.L347
 4184 2554 8800008A 		bhi	.L356
 4185 2558 010B52E3 		cmp	r2, #1024
 4186 255c EF01000A 		beq	.L342
 4187 2560 8701008A 		bhi	.L357
 4188 2564 020C52E3 		cmp	r2, #512
 4189 2568 E401000A 		beq	.L340
 4190 256c 030C52E3 		cmp	r2, #768
 4191 2570 C301000A 		beq	.L341
 4192 2574 010C52E3 		cmp	r2, #256
 4193 2578 AAFFFF1A 		bne	.L300
 4194              	.LVL304:
2729:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4195              		.loc 1 2729 0
 4196 257c 1000A0E3 		mov	r0, #16
 4197 2580 FEFFFFEB 		bl	ControlHandle
 4198              	.LVL305:
 4199 2584 30309DE5 		ldr	r3, [sp, #48]
 4200 2588 ABFFFFEA 		b	.L299
 4201              	.L434:
 4202              	.LBE120:
 4203              	.LBE115:
3130:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4204              		.loc 1 3130 0
 4205 258c D4B79FE5 		ldr	fp, .L442+32
 4206 2590 B0C0D9E1 		ldrh	ip, [r9, #0]
 4207 2594 B000DAE1 		ldrh	r0, [sl, #0]
 4208 2598 CC179FE5 		ldr	r1, .L442+36
 4209 259c 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4210 25a0 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4211 25a4 0C008DE5 		str	r0, [sp, #12]
 4212 25a8 08C08DE5 		str	ip, [sp, #8]
 4213 25ac B0C0D1E1 		ldrh	ip, [r1, #0]
 4214 25b0 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4215 25b4 04B08DE5 		str	fp, [sp, #4]
 4216 25b8 0400A0E3 		mov	r0, #4
 4217 25bc AC179FE5 		ldr	r1, .L442+40
 4218 25c0 00B0A0E3 		mov	fp, #0
 4219 25c4 00E08DE5 		str	lr, [sp, #0]
 4220 25c8 10C08DE5 		str	ip, [sp, #16]
 4221 25cc 14B08DE5 		str	fp, [sp, #20]
 4222 25d0 FEFFFFEB 		bl	CyU3PDebugPrint
 4223 25d4 30309DE5 		ldr	r3, [sp, #48]
 4224 25d8 78FFFFEA 		b	.L298
 4225              	.L433:
3122:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4226              		.loc 1 3122 0
 4227 25dc FEFFFFEB 		bl	CyU3PUsbGetSpeed
3123:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4228              		.loc 1 3123 0
 4229 25e0 000050E3 		cmp	r0, #0
3122:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4230              		.loc 1 3122 0
 4231 25e4 4800C5E5 		strb	r0, [r5, #72]
3125:../uvc.c      ****                     isUsbConnected = CyTrue;
 4232              		.loc 1 3125 0
 4233 25e8 0100A013 		movne	r0, #1
 4234 25ec 3C008515 		strne	r0, [r5, #60]
 4235 25f0 6FFFFFEA 		b	.L297
 4236              	.L362:
 4237              	.LVL306:
 4238              	.LBB125:
 4239              	.LBB107:
2820:../uvc.c      ****     switch (wValue)
 4240              		.loc 1 2820 0
 4241 25f4 B020D9E1 		ldrh	r2, [r9, #0]
 4242 25f8 030C52E3 		cmp	r2, #768
 4243 25fc 8100000A 		beq	.L366
 4244 2600 3300008A 		bhi	.L369
 4245 2604 010C52E3 		cmp	r2, #256
 4246 2608 8B00000A 		beq	.L364
 4247 260c 020C52E3 		cmp	r2, #512
 4248 2610 8EFFFF1A 		bne	.L363
2872:../uvc.c      ****             switch (bRequest)
 4249              		.loc 1 2872 0
 4250 2614 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4251 2618 810053E3 		cmp	r3, #129
 4252 261c 8B00000A 		beq	.L408
 4253 2620 2601008A 		bhi	.L384
 4254 2624 010053E3 		cmp	r3, #1
 4255 2628 8401000A 		beq	.L438
 4256              	.L388:
2971:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4257              		.loc 1 2971 0
 4258 262c 0000A0E3 		mov	r0, #0
 4259 2630 0110A0E3 		mov	r1, #1
 4260 2634 0020A0E1 		mov	r2, r0
 4261 2638 FEFFFFEB 		bl	CyU3PUsbStall
 4262 263c 30309DE5 		ldr	r3, [sp, #48]
 4263 2640 87FFFFEA 		b	.L361
 4264              	.LVL307:
 4265              	.L414:
 4266              	.LBE107:
 4267              	.LBE125:
3215:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4268              		.loc 1 3215 0
 4269 2644 63E6D6E5 		ldrb	lr, [r6, #1635]	@ zero_extendqisi2
 4270 2648 00005EE3 		cmp	lr, #0
 4271 264c 86FFFF0A 		beq	.L296
3217:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4272              		.loc 1 3217 0
 4273 2650 003097E5 		ldr	r3, [r7, #0]
 4274 2654 02B0A0E3 		mov	fp, #2
 4275 2658 00B0C3E5 		strb	fp, [r3, #0]
3218:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4276              		.loc 1 3218 0
 4277 265c 001097E5 		ldr	r1, [r7, #0]
 4278 2660 01B0A0E3 		mov	fp, #1
 4279 2664 01B0C1E5 		strb	fp, [r1, #1]
3219:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4280              		.loc 1 3219 0
 4281 2668 000097E5 		ldr	r0, [r7, #0]
3223:../uvc.c      **** 					interStabuf.size   = 1024;
 4282              		.loc 1 3223 0
 4283 266c 01EBA0E3 		mov	lr, #1024	@ movhi
3219:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4284              		.loc 1 3219 0
 4285 2670 0220C0E5 		strb	r2, [r0, #2]
3220:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4286              		.loc 1 3220 0
 4287 2674 00C097E5 		ldr	ip, [r7, #0]
3229:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4288              		.loc 1 3229 0
 4289 2678 0010E0E3 		mvn	r1, #0
3220:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4290              		.loc 1 3220 0
 4291 267c 03B0CCE5 		strb	fp, [ip, #3]
3222:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4292              		.loc 1 3222 0
 4293 2680 003097E5 		ldr	r3, [r7, #0]
3224:../uvc.c      **** 					interStabuf.status = 0;
 4294              		.loc 1 3224 0
 4295 2684 02C0A0E1 		mov	ip, r2	@ movhi
 4296 2688 B822CDE1 		strh	r2, [sp, #40]	@ movhi
3229:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4297              		.loc 1 3229 0
 4298 268c D0069FE5 		ldr	r0, .L442+28
3226:../uvc.c      **** 					interStabuf.count = 4;
 4299              		.loc 1 3226 0
 4300 2690 0420A0E3 		mov	r2, #4	@ movhi
3222:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4301              		.loc 1 3222 0
 4302 2694 20308DE5 		str	r3, [sp, #32]
3226:../uvc.c      **** 					interStabuf.count = 4;
 4303              		.loc 1 3226 0
 4304 2698 B422CDE1 		strh	r2, [sp, #36]	@ movhi
3223:../uvc.c      **** 					interStabuf.size   = 1024;
 4305              		.loc 1 3223 0
 4306 269c B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3229:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4307              		.loc 1 3229 0
 4308 26a0 1CC08DE5 		str	ip, [sp, #28]
 4309 26a4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3232:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4310              		.loc 1 3232 0
 4311 26a8 B4069FE5 		ldr	r0, .L442+28
 4312 26ac 20108DE2 		add	r1, sp, #32
 4313 26b0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4314              	.LVL308:
3233:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4315              		.loc 1 3233 0
 4316 26b4 1C309DE5 		ldr	r3, [sp, #28]
 4317 26b8 002050E2 		subs	r2, r0, #0
 4318 26bc C000001A 		bne	.L439
3239:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4319              		.loc 1 3239 0
 4320 26c0 84269FE5 		ldr	r2, .L442+4
3240:../uvc.c      **** 					stiflag = CyTrue;
 4321              		.loc 1 3240 0
 4322 26c4 98B084E5 		str	fp, [r4, #152]
3239:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4323              		.loc 1 3239 0
 4324 26c8 6336C2E5 		strb	r3, [r2, #1635]
3394:../uvc.c      ****         CyU3PThreadRelinquish ();
 4325              		.loc 1 3394 0
 4326 26cc FEFFFFEB 		bl	_txe_thread_relinquish
 4327              	.LVL309:
 4328 26d0 2BFFFFEA 		b	.L419
 4329              	.LVL310:
 4330              	.L369:
 4331              	.LBB126:
 4332              	.LBB109:
2820:../uvc.c      ****     switch (wValue)
 4333              		.loc 1 2820 0
 4334 26d4 010B52E3 		cmp	r2, #1024
 4335 26d8 3800000A 		beq	.L367
 4336 26dc 050C52E3 		cmp	r2, #1280
 4337 26e0 5AFFFF1A 		bne	.L363
3032:../uvc.c      ****                 switch (bRequest)
 4338              		.loc 1 3032 0
 4339 26e4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4340 26e8 810052E3 		cmp	r2, #129
 4341 26ec 5700000A 		beq	.L408
 4342 26f0 1E01008A 		bhi	.L411
 4343 26f4 010052E3 		cmp	r2, #1
 4344 26f8 54FFFF1A 		bne	.L363
3057:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4345              		.loc 1 3057 0
 4346 26fc 2000A0E3 		mov	r0, #32
 4347 2700 6C169FE5 		ldr	r1, .L442+44
 4348 2704 36208DE2 		add	r2, sp, #54
 4349 2708 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4350              	.LVL311:
3059:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4351              		.loc 1 3059 0
 4352 270c 000050E3 		cmp	r0, #0
 4353 2710 8601001A 		bne	.L413
3069:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4354              		.loc 1 3069 0
 4355 2714 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 4356 2718 040080E2 		add	r0, r0, #4
 4357              	.LVL312:
 4358 271c 54169FE5 		ldr	r1, .L442+48
 4359 2720 B623DDE1 		ldrh	r2, [sp, #54]
 4360 2724 FEFFFFEB 		bl	CyU3PDebugPrint
 4361              	.LVL313:
 4362 2728 30309DE5 		ldr	r3, [sp, #48]
 4363 272c 4CFFFFEA 		b	.L361
 4364              	.L317:
 4365              	.LBE109:
 4366              	.LBE126:
 4367              	.LBB127:
 4368              	.LBB91:
2425:../uvc.c      ****     switch (wValue)
 4369              		.loc 1 2425 0
 4370 2730 0A0C52E3 		cmp	r2, #2560
 4371 2734 F500000A 		beq	.L314
 4372 2738 EA00008A 		bhi	.L319
 4373 273c 070C52E3 		cmp	r2, #1792
 4374 2740 E400000A 		beq	.L312
 4375 2744 020B52E3 		cmp	r2, #2048
 4376 2748 32FFFF1A 		bne	.L320
 4377              	.LVL314:
2456:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4378              		.loc 1 2456 0
 4379 274c 0700A0E3 		mov	r0, #7
 4380 2750 FEFFFFEB 		bl	ControlHandle
 4381              	.LVL315:
 4382 2754 30309DE5 		ldr	r3, [sp, #48]
 4383 2758 37FFFFEA 		b	.L299
 4384              	.L332:
 4385              	.LBE91:
 4386              	.LBE127:
 4387              	.LBB128:
 4388              	.LBB96:
2500:../uvc.c      ****     switch (wValue)
 4389              		.loc 1 2500 0
 4390 275c 090C52E3 		cmp	r2, #2304
 4391 2760 2601000A 		beq	.L328
 4392 2764 1B01008A 		bhi	.L334
 4393 2768 070C52E3 		cmp	r2, #1792
 4394 276c 0D01000A 		beq	.L327
 4395 2770 020B52E3 		cmp	r2, #2048
 4396 2774 27FFFF1A 		bne	.L320
 4397 2778 2FFFFFEA 		b	.L299
 4398              	.L356:
 4399              	.LBE96:
 4400              	.LBE128:
 4401              	.LBB129:
 4402              	.LBB119:
2725:../uvc.c      ****     switch (wValue)
 4403              		.loc 1 2725 0
 4404 277c 0F0C52E3 		cmp	r2, #3840
 4405 2780 5A01000A 		beq	.L351
 4406 2784 3D00008A 		bhi	.L359
 4407 2788 0B0C52E3 		cmp	r2, #2816
 4408 278c 5301000A 		beq	.L349
 4409 2790 0D0C52E3 		cmp	r2, #3328
 4410 2794 4D01000A 		beq	.L350
 4411 2798 0A0C52E3 		cmp	r2, #2560
 4412 279c 21FFFF1A 		bne	.L300
2768:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
 4413              		.loc 1 2768 0
 4414 27a0 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4415 27a4 00C0A0E3 		mov	ip, #0
 4416 27a8 0400A0E3 		mov	r0, #4
 4417 27ac C8159FE5 		ldr	r1, .L442+52
 4418 27b0 00C08DE5 		str	ip, [sp, #0]
 4419 27b4 FEFFFFEB 		bl	CyU3PDebugPrint
 4420 27b8 30309DE5 		ldr	r3, [sp, #48]
 4421 27bc 1EFFFFEA 		b	.L299
 4422              	.LVL316:
 4423              	.L367:
 4424              	.LBE119:
 4425              	.LBE129:
 4426              	.LBB130:
 4427              	.LBB106:
2977:../uvc.c      ****                 switch (bRequest)
 4428              		.loc 1 2977 0
 4429 27c0 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4430 27c4 81005BE3 		cmp	fp, #129
 4431 27c8 1300000A 		beq	.L399
 4432 27cc 8500008A 		bhi	.L402
 4433 27d0 01005BE3 		cmp	fp, #1
 4434 27d4 1DFFFF1A 		bne	.L363
3002:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4435              		.loc 1 3002 0
 4436 27d8 36208DE2 		add	r2, sp, #54
 4437 27dc 2000A0E3 		mov	r0, #32
 4438 27e0 8C159FE5 		ldr	r1, .L442+44
 4439 27e4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4440              	.LVL317:
3004:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4441              		.loc 1 3004 0
 4442 27e8 002050E2 		subs	r2, r0, #0
 4443 27ec 1BFFFF1A 		bne	.L423
3017:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4444              		.loc 1 3017 0
 4445 27f0 50059FE5 		ldr	r0, .L442
 4446              	.LVL318:
 4447 27f4 0B10A0E1 		mov	r1, fp
 4448 27f8 FEFFFFEB 		bl	_txe_event_flags_set
 4449              	.LVL319:
3018:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4450              		.loc 1 3018 0
 4451 27fc 002050E2 		subs	r2, r0, #0
 4452 2800 16FFFF0A 		beq	.L423
 4453 2804 190100EA 		b	.L405
 4454              	.LVL320:
 4455              	.L366:
2928:../uvc.c      ****                 switch (bRequest)
 4456              		.loc 1 2928 0
 4457 2808 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4458 280c 830052E3 		cmp	r2, #131
 4459 2810 9800008A 		bhi	.L393
 4460 2814 810052E3 		cmp	r2, #129
 4461 2818 7D00003A 		bcc	.L440
 4462              	.L399:
2989:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4463              		.loc 1 2989 0
 4464 281c 48B0D4E5 		ldrb	fp, [r4, #72]	@ zero_extendqisi2
2991:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4465              		.loc 1 2991 0
 4466 2820 0B00A0E3 		mov	r0, #11
2989:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4467              		.loc 1 2989 0
 4468 2824 03005BE3 		cmp	fp, #3
2991:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4469              		.loc 1 2991 0
 4470 2828 50159F05 		ldreq	r1, .L442+56
2995:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4471              		.loc 1 2995 0
 4472 282c 50159F15 		ldrne	r1, .L442+60
 4473 2830 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4474 2834 30309DE5 		ldr	r3, [sp, #48]
 4475 2838 09FFFFEA 		b	.L361
 4476              	.L364:
2823:../uvc.c      ****             switch (bRequest)
 4477              		.loc 1 2823 0
 4478 283c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4479 2840 830052E3 		cmp	r2, #131
 4480 2844 2F00008A 		bhi	.L375
 4481 2848 810052E3 		cmp	r2, #129
 4482 284c 1400003A 		bcc	.L441
 4483              	.L408:
3044:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4484              		.loc 1 3044 0
 4485 2850 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3046:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4486              		.loc 1 3046 0
 4487 2854 1A00A0E3 		mov	r0, #26
3044:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4488              		.loc 1 3044 0
 4489 2858 030052E3 		cmp	r2, #3
3046:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4490              		.loc 1 3046 0
 4491 285c 24159F05 		ldreq	r1, .L442+64
3050:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4492              		.loc 1 3050 0
 4493 2860 24159F15 		ldrne	r1, .L442+68
 4494 2864 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4495 2868 30309DE5 		ldr	r3, [sp, #48]
 4496 286c FCFEFFEA 		b	.L361
 4497              	.LVL321:
 4498              	.L326:
 4499              	.LBE106:
 4500              	.LBE130:
 4501              	.LBB131:
 4502              	.LBB99:
2526:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4503              		.loc 1 2526 0
 4504 2870 0500A0E3 		mov	r0, #5
 4505 2874 FEFFFFEB 		bl	CTControlHandle
 4506              	.LVL322:
 4507 2878 30309DE5 		ldr	r3, [sp, #48]
 4508 287c EEFEFFEA 		b	.L299
 4509              	.L359:
 4510              	.LBE99:
 4511              	.LBE131:
 4512              	.LBB132:
 4513              	.LBB121:
2725:../uvc.c      ****     switch (wValue)
 4514              		.loc 1 2725 0
 4515 2880 110C52E3 		cmp	r2, #4352
 4516 2884 E900000A 		beq	.L353
 4517 2888 2D00008A 		bhi	.L360
 4518 288c 010A52E3 		cmp	r2, #4096
 4519 2890 E4FEFF1A 		bne	.L300
 4520              	.LVL323:
2788:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4521              		.loc 1 2788 0
 4522 2894 1F00A0E3 		mov	r0, #31
 4523 2898 FEFFFFEB 		bl	ControlHandle
 4524              	.LVL324:
 4525 289c 30309DE5 		ldr	r3, [sp, #48]
 4526 28a0 E5FEFFEA 		b	.L299
 4527              	.LVL325:
 4528              	.L441:
 4529              	.LBE121:
 4530              	.LBE132:
 4531              	.LBB133:
 4532              	.LBB110:
2823:../uvc.c      ****             switch (bRequest)
 4533              		.loc 1 2823 0
 4534 28a4 010052E3 		cmp	r2, #1
 4535 28a8 5FFFFF1A 		bne	.L388
2848:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4536              		.loc 1 2848 0
 4537 28ac 2000A0E3 		mov	r0, #32
 4538 28b0 BC149FE5 		ldr	r1, .L442+44
 4539 28b4 36208DE2 		add	r2, sp, #54
 4540 28b8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4541              	.LVL326:
2850:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4542              		.loc 1 2850 0
 4543 28bc 000050E3 		cmp	r0, #0
 4544 28c0 E6FEFF1A 		bne	.L423
2852:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4545              		.loc 1 2852 0
 4546 28c4 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 4547 28c8 030053E3 		cmp	r3, #3
 4548 28cc E3FEFF1A 		bne	.L423
2856:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4549              		.loc 1 2856 0
 4550 28d0 7AE0D4E5 		ldrb	lr, [r4, #122]	@ zero_extendqisi2
2857:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4551              		.loc 1 2857 0
 4552 28d4 7BC0D4E5 		ldrb	ip, [r4, #123]	@ zero_extendqisi2
2858:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4553              		.loc 1 2858 0
 4554 28d8 7C00D4E5 		ldrb	r0, [r4, #124]	@ zero_extendqisi2
 4555              	.LVL327:
2859:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4556              		.loc 1 2859 0
 4557 28dc 7D10D4E5 		ldrb	r1, [r4, #125]	@ zero_extendqisi2
2860:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4558              		.loc 1 2860 0
 4559 28e0 7E20D4E5 		ldrb	r2, [r4, #126]	@ zero_extendqisi2
2861:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4560              		.loc 1 2861 0
 4561 28e4 7FB0D4E5 		ldrb	fp, [r4, #127]	@ zero_extendqisi2
2856:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4562              		.loc 1 2856 0
 4563 28e8 16E6C6E5 		strb	lr, [r6, #1558]
2857:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4564              		.loc 1 2857 0
 4565 28ec 17C6C6E5 		strb	ip, [r6, #1559]
2858:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4566              		.loc 1 2858 0
 4567 28f0 1806C6E5 		strb	r0, [r6, #1560]
2859:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4568              		.loc 1 2859 0
 4569 28f4 1916C6E5 		strb	r1, [r6, #1561]
2860:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4570              		.loc 1 2860 0
 4571 28f8 1A26C6E5 		strb	r2, [r6, #1562]
2861:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4572              		.loc 1 2861 0
 4573 28fc 1BB6C6E5 		strb	fp, [r6, #1563]
 4574 2900 30309DE5 		ldr	r3, [sp, #48]
 4575 2904 D6FEFFEA 		b	.L361
 4576              	.LVL328:
 4577              	.L375:
2823:../uvc.c      ****             switch (bRequest)
 4578              		.loc 1 2823 0
 4579 2908 860052E3 		cmp	r2, #134
 4580 290c 3900000A 		beq	.L426
 4581 2910 870052E3 		cmp	r2, #135
 4582 2914 CDFFFF0A 		beq	.L408
 4583              	.L432:
2928:../uvc.c      ****                 switch (bRequest)
 4584              		.loc 1 2928 0
 4585 2918 850052E3 		cmp	r2, #133
 4586 291c 42FFFF1A 		bne	.L388
 4587              	.L400:
2986:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4588              		.loc 1 2986 0
 4589 2920 68149FE5 		ldr	r1, .L442+72
 4590 2924 0200A0E3 		mov	r0, #2
2984:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4591              		.loc 1 2984 0
 4592 2928 1A30A0E3 		mov	r3, #26
 4593              	.L424:
3039:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4594              		.loc 1 3039 0
 4595 292c 5830C4E5 		strb	r3, [r4, #88]
3040:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4596              		.loc 1 3040 0
 4597 2930 0030A0E3 		mov	r3, #0
 4598 2934 5930C4E5 		strb	r3, [r4, #89]
3041:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4599              		.loc 1 3041 0
 4600 2938 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4601 293c 30309DE5 		ldr	r3, [sp, #48]
 4602 2940 C7FEFFEA 		b	.L361
 4603              	.LVL329:
 4604              	.L360:
 4605              	.LBE110:
 4606              	.LBE133:
 4607              	.LBB134:
 4608              	.LBB118:
2725:../uvc.c      ****     switch (wValue)
 4609              		.loc 1 2725 0
 4610 2944 120C52E3 		cmp	r2, #4608
 4611 2948 DC00000A 		beq	.L354
 4612 294c 130C52E3 		cmp	r2, #4864
 4613 2950 B4FEFF1A 		bne	.L300
 4614              	.LVL330:
2800:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 4615              		.loc 1 2800 0
 4616 2954 2600A0E3 		mov	r0, #38
 4617 2958 FEFFFFEB 		bl	ControlHandle
 4618              	.LVL331:
 4619 295c 30309DE5 		ldr	r3, [sp, #48]
 4620 2960 B5FEFFEA 		b	.L299
 4621              	.L333:
 4622              	.LBE118:
 4623              	.LBE134:
 4624              	.LBB135:
 4625              	.LBB95:
2500:../uvc.c      ****     switch (wValue)
 4626              		.loc 1 2500 0
 4627 2964 010B52E3 		cmp	r2, #1024
 4628 2968 0900000A 		beq	.L324
 4629 296c 050C52E3 		cmp	r2, #1280
 4630 2970 A8FEFF1A 		bne	.L320
 4631              	.LVL332:
2522:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4632              		.loc 1 2522 0
 4633 2974 0400A0E3 		mov	r0, #4
 4634 2978 FEFFFFEB 		bl	CTControlHandle
 4635              	.LVL333:
 4636 297c 30309DE5 		ldr	r3, [sp, #48]
 4637 2980 ADFEFFEA 		b	.L299
 4638              	.L323:
 4639              	.LVL334:
2512:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4640              		.loc 1 2512 0
 4641 2984 0200A0E3 		mov	r0, #2
 4642 2988 FEFFFFEB 		bl	CTControlHandle
 4643              	.LVL335:
 4644 298c 30309DE5 		ldr	r3, [sp, #48]
 4645 2990 A9FEFFEA 		b	.L299
 4646              	.L324:
 4647              	.LVL336:
2517:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4648              		.loc 1 2517 0
 4649 2994 0300A0E3 		mov	r0, #3
 4650 2998 FEFFFFEB 		bl	CTControlHandle
 4651              	.LVL337:
 4652 299c 30309DE5 		ldr	r3, [sp, #48]
 4653 29a0 A5FEFFEA 		b	.L299
 4654              	.L435:
 4655              	.LVL338:
 4656              	.LBE95:
 4657              	.LBE135:
 4658              	.LBB136:
 4659              	.LBB89:
2433:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4660              		.loc 1 2433 0
 4661 29a4 0100A0E3 		mov	r0, #1
 4662 29a8 FEFFFFEB 		bl	ControlHandle
 4663              	.LVL339:
 4664 29ac 30309DE5 		ldr	r3, [sp, #48]
 4665 29b0 A1FEFFEA 		b	.L299
 4666              	.L307:
 4667              	.LVL340:
2429:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4668              		.loc 1 2429 0
 4669 29b4 0000A0E3 		mov	r0, #0
 4670 29b8 FEFFFFEB 		bl	ControlHandle
 4671              	.LVL341:
 4672 29bc 30309DE5 		ldr	r3, [sp, #48]
 4673 29c0 9DFEFFEA 		b	.L299
 4674              	.LVL342:
 4675              	.L439:
 4676              	.LBE89:
 4677              	.LBE136:
3235:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4678              		.loc 1 3235 0
 4679 29c4 0400A0E3 		mov	r0, #4
 4680              	.LVL343:
 4681 29c8 C4139FE5 		ldr	r1, .L442+76
 4682 29cc FEFFFFEB 		bl	CyU3PDebugPrint
 4683              	.LVL344:
 4684              	.L418:
 4685              	.LBB137:
 4686              	.LBB138:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4687              		.loc 1 1246 0
 4688 29d0 C0139FE5 		ldr	r1, .L442+80
 4689 29d4 0400A0E3 		mov	r0, #4
 4690 29d8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 4691              		.loc 1 1247 0
 4692 29dc FA0FA0E3 		mov	r0, #1000
 4693 29e0 FEFFFFEB 		bl	_tx_thread_sleep
 4694 29e4 F9FFFFEA 		b	.L418
 4695              	.LVL345:
 4696              	.L402:
 4697              	.LBE138:
 4698              	.LBE137:
 4699              	.LBB139:
 4700              	.LBB105:
2977:../uvc.c      ****                 switch (bRequest)
 4701              		.loc 1 2977 0
 4702 29e8 85005BE3 		cmp	fp, #133
 4703 29ec CBFFFF0A 		beq	.L400
 4704 29f0 86005BE3 		cmp	fp, #134
 4705 29f4 95FEFF1A 		bne	.L363
 4706              	.L426:
2981:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4707              		.loc 1 2981 0
 4708 29f8 0300A0E1 		mov	r0, r3
 4709              	.L421:
2875:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4710              		.loc 1 2875 0
 4711 29fc 0330A0E3 		mov	r3, #3
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4712              		.loc 1 2876 0
 4713 2a00 88139FE5 		ldr	r1, .L442+72
2875:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4714              		.loc 1 2875 0
 4715 2a04 5830C4E5 		strb	r3, [r4, #88]
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4716              		.loc 1 2876 0
 4717 2a08 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4718 2a0c 30309DE5 		ldr	r3, [sp, #48]
 4719 2a10 93FEFFEA 		b	.L361
 4720              	.L440:
2928:../uvc.c      ****                 switch (bRequest)
 4721              		.loc 1 2928 0
 4722 2a14 010052E3 		cmp	r2, #1
 4723 2a18 03FFFF1A 		bne	.L388
2953:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4724              		.loc 1 2953 0
 4725 2a1c 2000A0E3 		mov	r0, #32
 4726 2a20 4C139FE5 		ldr	r1, .L442+44
 4727 2a24 36208DE2 		add	r2, sp, #54
 4728 2a28 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4729              	.LVL346:
2955:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4730              		.loc 1 2955 0
 4731 2a2c 000050E3 		cmp	r0, #0
 4732 2a30 8AFEFF1A 		bne	.L423
2957:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4733              		.loc 1 2957 0
 4734 2a34 48B0D5E5 		ldrb	fp, [r5, #72]	@ zero_extendqisi2
 4735 2a38 03005BE3 		cmp	fp, #3
 4736 2a3c 87FEFF1A 		bne	.L423
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4737              		.loc 1 2966 0
 4738 2a40 7E30D5E5 		ldrb	r3, [r5, #126]	@ zero_extendqisi2
2961:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4739              		.loc 1 2961 0
 4740 2a44 79E0D5E5 		ldrb	lr, [r5, #121]	@ zero_extendqisi2
2962:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4741              		.loc 1 2962 0
 4742 2a48 7AC0D5E5 		ldrb	ip, [r5, #122]	@ zero_extendqisi2
2963:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4743              		.loc 1 2963 0
 4744 2a4c 7B00D5E5 		ldrb	r0, [r5, #123]	@ zero_extendqisi2
 4745              	.LVL347:
2964:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4746              		.loc 1 2964 0
 4747 2a50 7C10D5E5 		ldrb	r1, [r5, #124]	@ zero_extendqisi2
2965:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4748              		.loc 1 2965 0
 4749 2a54 7D20D5E5 		ldrb	r2, [r5, #125]	@ zero_extendqisi2
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4750              		.loc 1 2966 0
 4751 2a58 5236C6E5 		strb	r3, [r6, #1618]
2961:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4752              		.loc 1 2961 0
 4753 2a5c 4DE6C6E5 		strb	lr, [r6, #1613]
2962:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4754              		.loc 1 2962 0
 4755 2a60 4EC6C6E5 		strb	ip, [r6, #1614]
2963:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4756              		.loc 1 2963 0
 4757 2a64 4F06C6E5 		strb	r0, [r6, #1615]
2964:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4758              		.loc 1 2964 0
 4759 2a68 5016C6E5 		strb	r1, [r6, #1616]
2965:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4760              		.loc 1 2965 0
 4761 2a6c 5126C6E5 		strb	r2, [r6, #1617]
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4762              		.loc 1 2966 0
 4763 2a70 30309DE5 		ldr	r3, [sp, #48]
 4764 2a74 7AFEFFEA 		b	.L361
 4765              	.LVL348:
 4766              	.L393:
2928:../uvc.c      ****                 switch (bRequest)
 4767              		.loc 1 2928 0
 4768 2a78 860052E3 		cmp	r2, #134
 4769 2a7c DDFFFF0A 		beq	.L426
 4770 2a80 870052E3 		cmp	r2, #135
 4771 2a84 A3FFFF1A 		bne	.L432
 4772 2a88 63FFFFEA 		b	.L399
 4773              	.LVL349:
 4774              	.L321:
 4775              	.LBE105:
 4776              	.LBE139:
 4777              	.LBB140:
 4778              	.LBB100:
2504:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4779              		.loc 1 2504 0
 4780 2a8c 0000A0E3 		mov	r0, #0
 4781 2a90 FEFFFFEB 		bl	CTControlHandle
 4782              	.LVL350:
 4783 2a94 30309DE5 		ldr	r3, [sp, #48]
 4784 2a98 67FEFFEA 		b	.L299
 4785              	.LVL351:
 4786              	.L437:
 4787              	.LBE100:
 4788              	.LBE140:
3211:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4789              		.loc 1 3211 0
 4790 2a9c 0400A0E3 		mov	r0, #4
 4791              	.LVL352:
 4792 2aa0 EC129FE5 		ldr	r1, .L442+76
 4793 2aa4 FEFFFFEB 		bl	CyU3PDebugPrint
 4794              	.LVL353:
 4795              	.L416:
 4796              	.LBB141:
 4797              	.LBB142:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4798              		.loc 1 1246 0
 4799 2aa8 E8129FE5 		ldr	r1, .L442+80
 4800 2aac 0400A0E3 		mov	r0, #4
 4801 2ab0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 4802              		.loc 1 1247 0
 4803 2ab4 FA0FA0E3 		mov	r0, #1000
 4804 2ab8 FEFFFFEB 		bl	_tx_thread_sleep
 4805 2abc F9FFFFEA 		b	.L416
 4806              	.LVL354:
 4807              	.L384:
 4808              	.LBE142:
 4809              	.LBE141:
 4810              	.LBB143:
 4811              	.LBB111:
2872:../uvc.c      ****             switch (bRequest)
 4812              		.loc 1 2872 0
 4813 2ac0 850053E3 		cmp	r3, #133
 4814 2ac4 95FFFF0A 		beq	.L400
 4815 2ac8 860053E3 		cmp	r3, #134
 4816 2acc D6FEFF1A 		bne	.L388
 4817              	.L427:
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4818              		.loc 1 2876 0
 4819 2ad0 0100A0E3 		mov	r0, #1
 4820 2ad4 C8FFFFEA 		b	.L421
 4821              	.LVL355:
 4822              	.L312:
 4823              	.LBE111:
 4824              	.LBE143:
 4825              	.LBB144:
 4826              	.LBB92:
2452:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4827              		.loc 1 2452 0
 4828 2ad8 0600A0E3 		mov	r0, #6
 4829 2adc FEFFFFEB 		bl	ControlHandle
 4830              	.LVL356:
 4831 2ae0 30309DE5 		ldr	r3, [sp, #48]
 4832 2ae4 54FEFFEA 		b	.L299
 4833              	.L319:
2425:../uvc.c      ****     switch (wValue)
 4834              		.loc 1 2425 0
 4835 2ae8 0D0C52E3 		cmp	r2, #3328
 4836 2aec 0700000A 		beq	.L314
 4837 2af0 0E0C52E3 		cmp	r2, #3584
 4838 2af4 0900000A 		beq	.L316
 4839 2af8 030B52E3 		cmp	r2, #3072
 4840 2afc 45FEFF1A 		bne	.L320
 4841              	.LVL357:
2466:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4842              		.loc 1 2466 0
 4843 2b00 0B00A0E3 		mov	r0, #11
 4844 2b04 FEFFFFEB 		bl	ControlHandle
 4845              	.LVL358:
 4846 2b08 30309DE5 		ldr	r3, [sp, #48]
 4847 2b0c 4AFEFFEA 		b	.L299
 4848              	.L314:
 4849              	.LVL359:
2462:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4850              		.loc 1 2462 0
 4851 2b10 0900A0E3 		mov	r0, #9
 4852 2b14 FEFFFFEB 		bl	ControlHandle
 4853              	.LVL360:
 4854 2b18 30309DE5 		ldr	r3, [sp, #48]
 4855 2b1c 46FEFFEA 		b	.L299
 4856              	.L316:
 4857              	.LVL361:
2470:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4858              		.loc 1 2470 0
 4859 2b20 0E00A0E3 		mov	r0, #14
 4860 2b24 FEFFFFEB 		bl	ControlHandle
 4861              	.LVL362:
 4862 2b28 30309DE5 		ldr	r3, [sp, #48]
 4863 2b2c 42FEFFEA 		b	.L299
 4864              	.L318:
2425:../uvc.c      ****     switch (wValue)
 4865              		.loc 1 2425 0
 4866 2b30 010B52E3 		cmp	r2, #1024
 4867 2b34 40FEFF0A 		beq	.L299
 4868 2b38 050C52E3 		cmp	r2, #1280
 4869 2b3c 35FEFF1A 		bne	.L320
 4870              	.LVL363:
2444:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4871              		.loc 1 2444 0
 4872 2b40 0400A0E3 		mov	r0, #4
 4873 2b44 FEFFFFEB 		bl	ControlHandle
 4874              	.LVL364:
 4875 2b48 30309DE5 		ldr	r3, [sp, #48]
 4876 2b4c 3AFEFFEA 		b	.L299
 4877              	.L309:
 4878              	.LVL365:
2437:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4879              		.loc 1 2437 0
 4880 2b50 0200A0E3 		mov	r0, #2
 4881 2b54 FEFFFFEB 		bl	ControlHandle
 4882              	.LVL366:
 4883 2b58 30309DE5 		ldr	r3, [sp, #48]
 4884 2b5c 36FEFFEA 		b	.L299
 4885              	.L311:
 4886              	.LVL367:
2448:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4887              		.loc 1 2448 0
 4888 2b60 0500A0E3 		mov	r0, #5
 4889 2b64 FEFFFFEB 		bl	ControlHandle
 4890              	.LVL368:
 4891 2b68 30309DE5 		ldr	r3, [sp, #48]
 4892 2b6c 32FEFFEA 		b	.L299
 4893              	.LVL369:
 4894              	.L411:
 4895              	.LBE92:
 4896              	.LBE144:
 4897              	.LBB145:
 4898              	.LBB104:
3032:../uvc.c      ****                 switch (bRequest)
 4899              		.loc 1 3032 0
 4900 2b70 850052E3 		cmp	r2, #133
 4901 2b74 4E00000A 		beq	.L409
 4902 2b78 860052E3 		cmp	r2, #134
 4903 2b7c 33FEFF1A 		bne	.L363
 4904 2b80 D2FFFFEA 		b	.L427
 4905              	.LVL370:
 4906              	.L357:
 4907              	.LBE104:
 4908              	.LBE145:
 4909              	.LBB146:
 4910              	.LBB122:
2725:../uvc.c      ****     switch (wValue)
 4911              		.loc 1 2725 0
 4912 2b84 060C52E3 		cmp	r2, #1536
 4913 2b88 4500000A 		beq	.L344
 4914 2b8c 0900008A 		bhi	.L358
 4915 2b90 050C52E3 		cmp	r2, #1280
 4916 2b94 23FEFF1A 		bne	.L300
 4917              	.LVL371:
2745:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4918              		.loc 1 2745 0
 4919 2b98 1400A0E3 		mov	r0, #20
 4920 2b9c FEFFFFEB 		bl	ControlHandle
 4921              	.LVL372:
 4922 2ba0 30309DE5 		ldr	r3, [sp, #48]
 4923 2ba4 24FEFFEA 		b	.L299
 4924              	.L327:
 4925              	.LVL373:
 4926              	.LBE122:
 4927              	.LBE146:
 4928              	.LBB147:
 4929              	.LBB94:
2530:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 4930              		.loc 1 2530 0
 4931 2ba8 0600A0E3 		mov	r0, #6
 4932 2bac FEFFFFEB 		bl	CTControlHandle
 4933              	.LVL374:
 4934 2bb0 30309DE5 		ldr	r3, [sp, #48]
 4935 2bb4 20FEFFEA 		b	.L299
 4936              	.L358:
 4937              	.LBE94:
 4938              	.LBE147:
 4939              	.LBB148:
 4940              	.LBB117:
2725:../uvc.c      ****     switch (wValue)
 4941              		.loc 1 2725 0
 4942 2bb8 070C52E3 		cmp	r2, #1792
 4943 2bbc 3400000A 		beq	.L345
 4944 2bc0 020B52E3 		cmp	r2, #2048
 4945 2bc4 17FEFF1A 		bne	.L300
 4946              	.LVL375:
2757:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 4947              		.loc 1 2757 0
 4948 2bc8 1700A0E3 		mov	r0, #23
 4949 2bcc FEFFFFEB 		bl	ControlHandle
 4950              	.LVL376:
 4951 2bd0 30309DE5 		ldr	r3, [sp, #48]
 4952 2bd4 18FEFFEA 		b	.L299
 4953              	.L334:
 4954              	.LBE117:
 4955              	.LBE148:
 4956              	.LBB149:
 4957              	.LBB101:
2500:../uvc.c      ****     switch (wValue)
 4958              		.loc 1 2500 0
 4959 2bd8 0B0C52E3 		cmp	r2, #2816
 4960 2bdc 0F00000A 		beq	.L330
 4961 2be0 030B52E3 		cmp	r2, #3072
 4962 2be4 0900000A 		beq	.L331
 4963 2be8 0A0C52E3 		cmp	r2, #2560
 4964 2bec 09FEFF1A 		bne	.L320
 4965              	.LVL377:
2541:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 4966              		.loc 1 2541 0
 4967 2bf0 0800A0E3 		mov	r0, #8
 4968 2bf4 FEFFFFEB 		bl	CTControlHandle
 4969              	.LVL378:
 4970 2bf8 30309DE5 		ldr	r3, [sp, #48]
 4971 2bfc 0EFEFFEA 		b	.L299
 4972              	.L328:
 4973              	.LVL379:
2536:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 4974              		.loc 1 2536 0
 4975 2c00 0700A0E3 		mov	r0, #7
 4976 2c04 FEFFFFEB 		bl	CTControlHandle
 4977              	.LVL380:
 4978 2c08 30309DE5 		ldr	r3, [sp, #48]
 4979 2c0c 0AFEFFEA 		b	.L299
 4980              	.L331:
 4981              	.LVL381:
2549:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 4982              		.loc 1 2549 0
 4983 2c10 0A00A0E3 		mov	r0, #10
 4984 2c14 FEFFFFEB 		bl	CTControlHandle
 4985              	.LVL382:
 4986 2c18 30309DE5 		ldr	r3, [sp, #48]
 4987 2c1c 06FEFFEA 		b	.L299
 4988              	.L330:
 4989              	.LVL383:
2545:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 4990              		.loc 1 2545 0
 4991 2c20 0900A0E3 		mov	r0, #9
 4992 2c24 FEFFFFEB 		bl	CTControlHandle
 4993              	.LVL384:
 4994 2c28 30309DE5 		ldr	r3, [sp, #48]
 4995 2c2c 02FEFFEA 		b	.L299
 4996              	.L353:
 4997              	.LVL385:
 4998              	.LBE101:
 4999              	.LBE149:
 5000              	.LBB150:
 5001              	.LBB123:
2792:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 5002              		.loc 1 2792 0
 5003 2c30 2400A0E3 		mov	r0, #36
 5004 2c34 FEFFFFEB 		bl	ControlHandle
 5005              	.LVL386:
 5006 2c38 30309DE5 		ldr	r3, [sp, #48]
 5007 2c3c FEFDFFEA 		b	.L299
 5008              	.LVL387:
 5009              	.L438:
 5010              	.LBE123:
 5011              	.LBE150:
 5012              	.LBB151:
 5013              	.LBB112:
2897:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5014              		.loc 1 2897 0
 5015 2c40 2000A0E3 		mov	r0, #32
 5016 2c44 28119FE5 		ldr	r1, .L442+44
 5017 2c48 36208DE2 		add	r2, sp, #54
 5018 2c4c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5019              	.LVL388:
2899:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5020              		.loc 1 2899 0
 5021 2c50 000050E3 		cmp	r0, #0
 5022 2c54 01FEFF1A 		bne	.L423
2912:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5023              		.loc 1 2912 0
 5024 2c58 0020A0E3 		mov	r2, #0
 5025 2c5c E4009FE5 		ldr	r0, .L442
 5026              	.LVL389:
 5027 2c60 0110A0E3 		mov	r1, #1
 5028 2c64 FEFFFFEB 		bl	_txe_event_flags_set
 5029              	.LVL390:
2913:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5030              		.loc 1 2913 0
 5031 2c68 002050E2 		subs	r2, r0, #0
 5032 2c6c FBFDFF0A 		beq	.L423
 5033              	.L405:
3020:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5034              		.loc 1 3020 0
 5035 2c70 0400A0E3 		mov	r0, #4
 5036              	.LVL391:
 5037 2c74 20119FE5 		ldr	r1, .L442+84
 5038 2c78 FEFFFFEB 		bl	CyU3PDebugPrint
 5039              	.LVL392:
 5040 2c7c 30309DE5 		ldr	r3, [sp, #48]
 5041 2c80 F7FDFFEA 		b	.L361
 5042              	.L341:
 5043              	.LVL393:
 5044              	.LBE112:
 5045              	.LBE151:
 5046              	.LBB152:
 5047              	.LBB116:
2737:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5048              		.loc 1 2737 0
 5049 2c84 1200A0E3 		mov	r0, #18
 5050 2c88 FEFFFFEB 		bl	ControlHandle
 5051              	.LVL394:
 5052 2c8c 30309DE5 		ldr	r3, [sp, #48]
 5053 2c90 E9FDFFEA 		b	.L299
 5054              	.L345:
 5055              	.LVL395:
2753:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5056              		.loc 1 2753 0
 5057 2c94 1600A0E3 		mov	r0, #22
 5058 2c98 FEFFFFEB 		bl	ControlHandle
 5059              	.LVL396:
 5060 2c9c 30309DE5 		ldr	r3, [sp, #48]
 5061 2ca0 E5FDFFEA 		b	.L299
 5062              	.L344:
 5063              	.LVL397:
2749:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5064              		.loc 1 2749 0
 5065 2ca4 1500A0E3 		mov	r0, #21
 5066 2ca8 FEFFFFEB 		bl	ControlHandle
 5067              	.LVL398:
 5068 2cac 30309DE5 		ldr	r3, [sp, #48]
 5069 2cb0 E1FDFFEA 		b	.L299
 5070              	.LVL399:
 5071              	.L409:
 5072              	.LBE116:
 5073              	.LBE152:
 5074              	.LBB153:
 5075              	.LBB103:
3041:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5076              		.loc 1 3041 0
 5077 2cb4 0200A0E3 		mov	r0, #2
 5078 2cb8 D0109FE5 		ldr	r1, .L442+72
 5079 2cbc 1AFFFFEA 		b	.L424
 5080              	.LVL400:
 5081              	.L354:
 5082              	.LBE103:
 5083              	.LBE153:
 5084              	.LBB154:
 5085              	.LBB124:
2796:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 5086              		.loc 1 2796 0
 5087 2cc0 2500A0E3 		mov	r0, #37
 5088 2cc4 FEFFFFEB 		bl	ControlHandle
 5089              	.LVL401:
 5090 2cc8 30309DE5 		ldr	r3, [sp, #48]
 5091 2ccc DAFDFFEA 		b	.L299
 5092              	.L350:
 5093              	.LVL402:
2776:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5094              		.loc 1 2776 0
 5095 2cd0 1C00A0E3 		mov	r0, #28
 5096 2cd4 FEFFFFEB 		bl	ControlHandle
 5097              	.LVL403:
 5098 2cd8 30309DE5 		ldr	r3, [sp, #48]
 5099 2cdc D6FDFFEA 		b	.L299
 5100              	.L349:
 5101              	.LVL404:
2772:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5102              		.loc 1 2772 0
 5103 2ce0 1A00A0E3 		mov	r0, #26
 5104 2ce4 FEFFFFEB 		bl	ControlHandle
 5105              	.LVL405:
 5106 2ce8 30309DE5 		ldr	r3, [sp, #48]
 5107 2cec D2FDFFEA 		b	.L299
 5108              	.L351:
 5109              	.LVL406:
2784:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5110              		.loc 1 2784 0
 5111 2cf0 1E00A0E3 		mov	r0, #30
 5112 2cf4 FEFFFFEB 		bl	ControlHandle
 5113              	.LVL407:
 5114 2cf8 30309DE5 		ldr	r3, [sp, #48]
 5115 2cfc CEFDFFEA 		b	.L299
 5116              	.L340:
 5117              	.LVL408:
2733:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5118              		.loc 1 2733 0
 5119 2d00 1100A0E3 		mov	r0, #17
 5120 2d04 FEFFFFEB 		bl	ControlHandle
 5121              	.LVL409:
 5122 2d08 30309DE5 		ldr	r3, [sp, #48]
 5123 2d0c CAFDFFEA 		b	.L299
 5124              	.L347:
 5125              	.LVL410:
2761:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5126              		.loc 1 2761 0
 5127 2d10 1800A0E3 		mov	r0, #24
 5128 2d14 FEFFFFEB 		bl	ControlHandle
 5129              	.LVL411:
 5130 2d18 30309DE5 		ldr	r3, [sp, #48]
 5131 2d1c C6FDFFEA 		b	.L299
 5132              	.L342:
 5133              	.LVL412:
2741:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5134              		.loc 1 2741 0
 5135 2d20 1300A0E3 		mov	r0, #19
 5136 2d24 FEFFFFEB 		bl	ControlHandle
 5137              	.LVL413:
 5138 2d28 30309DE5 		ldr	r3, [sp, #48]
 5139 2d2c C2FDFFEA 		b	.L299
 5140              	.LVL414:
 5141              	.L413:
 5142              	.LBE124:
 5143              	.LBE154:
 5144              	.LBB155:
 5145              	.LBB113:
3071:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5146              		.loc 1 3071 0
 5147 2d30 68109FE5 		ldr	r1, .L442+88
 5148 2d34 B623DDE1 		ldrh	r2, [sp, #54]
 5149 2d38 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 5150 2d3c 0400A0E3 		mov	r0, #4
 5151              	.LVL415:
 5152 2d40 FEFFFFEB 		bl	CyU3PDebugPrint
 5153 2d44 C1FDFFEA 		b	.L363
 5154              	.L443:
 5155              		.align	2
 5156              	.L442:
 5157 2d48 00000000 		.word	.LANCHOR0
 5158 2d4c 00000000 		.word	.LANCHOR1
 5159 2d50 00000000 		.word	bRequest
 5160 2d54 00000000 		.word	wValue
 5161 2d58 00000000 		.word	wIndex
 5162 2d5c 00000000 		.word	glInterStaBuffer
 5163 2d60 DC040000 		.word	.LC27
 5164 2d64 00000000 		.word	glChHandleInterStat
 5165 2d68 00000000 		.word	bmReqType
 5166 2d6c 00000000 		.word	wLength
 5167 2d70 60040000 		.word	.LC26
 5168 2d74 78000000 		.word	.LANCHOR0+120
 5169 2d78 70050000 		.word	.LC30
 5170 2d7c 08050000 		.word	.LC28
 5171 2d80 4C060000 		.word	.LANCHOR1+1612
 5172 2d84 58060000 		.word	.LANCHOR1+1624
 5173 2d88 14060000 		.word	.LANCHOR1+1556
 5174 2d8c 30060000 		.word	.LANCHOR1+1584
 5175 2d90 58000000 		.word	.LANCHOR0+88
 5176 2d94 C0050000 		.word	.LC32
 5177 2d98 D4010000 		.word	.LC12
 5178 2d9c 48050000 		.word	.LC29
 5179 2da0 98050000 		.word	.LC31
 5180              	.LBE113:
 5181              	.LBE155:
 5182              		.cfi_endproc
 5183              	.LFE24:
 5185              		.align	2
 5186              		.global	CamDefSet
 5188              	CamDefSet:
 5189              	.LFB4:
1143:../uvc.c      **** {
 5190              		.loc 1 1143 0
 5191              		.cfi_startproc
 5192              		@ args = 0, pretend = 0, frame = 24
 5193              		@ frame_needed = 0, uses_anonymous_args = 0
 5194              	.LVL416:
 5195 2da4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5196              	.LCFI19:
 5197              		.cfi_def_cfa_offset 36
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5198              		.loc 1 1149 0
 5199 2da8 AC429FE5 		ldr	r4, .L447
 5200              		.cfi_offset 14, -4
 5201              		.cfi_offset 11, -8
 5202              		.cfi_offset 10, -12
 5203              		.cfi_offset 9, -16
 5204              		.cfi_offset 8, -20
 5205              		.cfi_offset 7, -24
 5206              		.cfi_offset 6, -28
 5207              		.cfi_offset 5, -32
 5208              		.cfi_offset 4, -36
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5209              		.loc 1 1154 0
 5210 2dac AC229FE5 		ldr	r2, .L447+4
1151:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5211              		.loc 1 1151 0
 5212 2db0 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1143:../uvc.c      **** {
 5213              		.loc 1 1143 0
 5214 2db4 2CD04DE2 		sub	sp, sp, #44
 5215              	.LCFI20:
 5216              		.cfi_def_cfa_offset 80
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5217              		.loc 1 1154 0
 5218 2db8 1C0092E5 		ldr	r0, [r2, #28]
 5219 2dbc 0010E0E3 		mvn	r1, #0
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5220              		.loc 1 1156 0
 5221 2dc0 2963A0E1 		mov	r6, r9, lsr #6
1150:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5222              		.loc 1 1150 0
 5223 2dc4 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5224              		.loc 1 1149 0
 5225 2dc8 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5226              	.LVL417:
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5227              		.loc 1 1154 0
 5228 2dcc FEFFFFEB 		bl	_txe_mutex_get
1155:../uvc.c      ****     if(Data1&0x80){
 5229              		.loc 1 1155 0
 5230 2dd0 800019E3 		tst	r9, #128
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5231              		.loc 1 1156 0
 5232 2dd4 01600612 		andne	r6, r6, #1
 5233 2dd8 0660E011 		mvnne	r6, r6
 5234 2ddc 3B600612 		andne	r6, r6, #59
 5235 2de0 0660E011 		mvnne	r6, r6
 5236 2de4 FF600612 		andne	r6, r6, #255
 5237              	.LVL418:
1158:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5238              		.loc 1 1158 0
 5239 2de8 C6608603 		orreq	r6, r6, #198
 5240              	.LVL419:
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5241              		.loc 1 1162 0
 5242 2dec 0080A0E3 		mov	r8, #0
 5243 2df0 0A20A0E1 		mov	r2, sl
 5244 2df4 0730A0E1 		mov	r3, r7
 5245 2df8 0110A0E3 		mov	r1, #1
1160:../uvc.c      ****     Data0 = (Data0 << 2);
 5246              		.loc 1 1160 0
 5247 2dfc 0951A0E1 		mov	r5, r9, asl #2
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5248              		.loc 1 1162 0
 5249 2e00 58029FE5 		ldr	r0, .L447+4
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5250              		.loc 1 1165 0
 5251 2e04 0190A0E3 		mov	r9, #1
 5252              	.LVL420:
1160:../uvc.c      ****     Data0 = (Data0 << 2);
 5253              		.loc 1 1160 0
 5254 2e08 FF5005E2 		and	r5, r5, #255
 5255              	.LVL421:
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5256              		.loc 1 1162 0
 5257 2e0c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5258 2e10 FEFFFFEB 		bl	cmdSet
 5259              	.LVL422:
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5260              		.loc 1 1165 0
 5261 2e14 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5262 2e18 0910A0E1 		mov	r1, r9
 5263 2e1c 0730A0E1 		mov	r3, r7
 5264 2e20 38029FE5 		ldr	r0, .L447+4
 5265 2e24 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5266 2e28 FEFFFFEB 		bl	cmdSet
 5267              	.LVL423:
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5268              		.loc 1 1168 0
 5269 2e2c 0620A0E1 		mov	r2, r6
 5270 2e30 0530A0E1 		mov	r3, r5
 5271 2e34 28129FE5 		ldr	r1, .L447+8
 5272 2e38 0400A0E3 		mov	r0, #4
1167:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5273              		.loc 1 1167 0
 5274 2e3c A661C4E5 		strb	r6, [r4, #422]
1166:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5275              		.loc 1 1166 0
 5276 2e40 A551C4E5 		strb	r5, [r4, #421]
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5277              		.loc 1 1168 0
 5278 2e44 FEFFFFEB 		bl	CyU3PDebugPrint
 5279              	.LVL424:
1173:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5280              		.loc 1 1173 0
 5281 2e48 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5282              	.LVL425:
1174:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5283              		.loc 1 1174 0
 5284 2e4c B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5285 2e50 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5286 2e54 0210A0E3 		mov	r1, #2
 5287 2e58 00029FE5 		ldr	r0, .L447+4
 5288 2e5c 00B08DE5 		str	fp, [sp, #0]
 5289 2e60 04808DE5 		str	r8, [sp, #4]
 5290 2e64 FEFFFFEB 		bl	cmdSet
 5291              	.LVL426:
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5292              		.loc 1 1176 0
 5293 2e68 0B20A0E1 		mov	r2, fp
 5294 2e6c 0530A0E1 		mov	r3, r5
 5295 2e70 EC119FE5 		ldr	r1, .L447+8
 5296 2e74 0400A0E3 		mov	r0, #4
1175:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5297              		.loc 1 1175 0
 5298 2e78 BD51C4E5 		strb	r5, [r4, #445]
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5299              		.loc 1 1176 0
 5300 2e7c FEFFFFEB 		bl	CyU3PDebugPrint
 5301              	.LVL427:
1181:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5302              		.loc 1 1181 0
 5303 2e80 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1180:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5304              		.loc 1 1180 0
 5305 2e84 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5306              	.LVL428:
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5307              		.loc 1 1182 0
 5308 2e88 80B047E2 		sub	fp, r7, #128
 5309 2e8c FF100BE2 		and	r1, fp, #255
 5310 2e90 14108DE5 		str	r1, [sp, #20]
 5311 2e94 14C09DE5 		ldr	ip, [sp, #20]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5312              		.loc 1 1183 0
 5313 2e98 760047E2 		sub	r0, r7, #118
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5314              		.loc 1 1184 0
 5315 2e9c 7EE087E2 		add	lr, r7, #126
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5316              		.loc 1 1182 0
 5317 2ea0 0630A0E1 		mov	r3, r6
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5318              		.loc 1 1183 0
 5319 2ea4 18008DE5 		str	r0, [sp, #24]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5320              		.loc 1 1182 0
 5321 2ea8 0510A0E3 		mov	r1, #5
 5322 2eac DF20A0E3 		mov	r2, #223
 5323 2eb0 A8019FE5 		ldr	r0, .L447+4
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5324              		.loc 1 1184 0
 5325 2eb4 1CE08DE5 		str	lr, [sp, #28]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5326              		.loc 1 1182 0
 5327 2eb8 00C08DE5 		str	ip, [sp, #0]
 5328 2ebc 04808DE5 		str	r8, [sp, #4]
 5329 2ec0 FEFFFFEB 		bl	cmdSet
 5330              	.LVL429:
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5331              		.loc 1 1183 0
 5332 2ec4 18A09DE5 		ldr	sl, [sp, #24]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5333              		.loc 1 1185 0
 5334 2ec8 72E087E2 		add	lr, r7, #114
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5335              		.loc 1 1183 0
 5336 2ecc FFC00AE2 		and	ip, sl, #255
 5337 2ed0 0630A0E1 		mov	r3, r6
 5338 2ed4 0510A0E3 		mov	r1, #5
 5339 2ed8 DC20A0E3 		mov	r2, #220
 5340 2edc 7C019FE5 		ldr	r0, .L447+4
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5341              		.loc 1 1185 0
 5342 2ee0 20E08DE5 		str	lr, [sp, #32]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5343              		.loc 1 1183 0
 5344 2ee4 00C08DE5 		str	ip, [sp, #0]
 5345 2ee8 04908DE5 		str	r9, [sp, #4]
 5346 2eec FEFFFFEB 		bl	cmdSet
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5347              		.loc 1 1184 0
 5348 2ef0 1C009DE5 		ldr	r0, [sp, #28]
 5349 2ef4 02E0A0E3 		mov	lr, #2
 5350 2ef8 FFC000E2 		and	ip, r0, #255
 5351 2efc 0630A0E1 		mov	r3, r6
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5352              		.loc 1 1186 0
 5353 2f00 6FA047E2 		sub	sl, r7, #111
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5354              		.loc 1 1184 0
 5355 2f04 0510A0E3 		mov	r1, #5
 5356 2f08 DE20A0E3 		mov	r2, #222
 5357 2f0c 4C019FE5 		ldr	r0, .L447+4
 5358 2f10 04E08DE5 		str	lr, [sp, #4]
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5359              		.loc 1 1186 0
 5360 2f14 24A08DE5 		str	sl, [sp, #36]
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5361              		.loc 1 1184 0
 5362 2f18 00C08DE5 		str	ip, [sp, #0]
 5363 2f1c FEFFFFEB 		bl	cmdSet
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5364              		.loc 1 1185 0
 5365 2f20 20A09DE5 		ldr	sl, [sp, #32]
 5366 2f24 0630A0E1 		mov	r3, r6
 5367 2f28 FFC00AE2 		and	ip, sl, #255
 5368 2f2c 00C08DE5 		str	ip, [sp, #0]
 5369 2f30 0510A0E3 		mov	r1, #5
 5370 2f34 03C0A0E3 		mov	ip, #3
 5371 2f38 E020A0E3 		mov	r2, #224
 5372 2f3c 1C019FE5 		ldr	r0, .L447+4
 5373 2f40 04C08DE5 		str	ip, [sp, #4]
 5374 2f44 FEFFFFEB 		bl	cmdSet
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5375              		.loc 1 1186 0
 5376 2f48 24009DE5 		ldr	r0, [sp, #36]
 5377 2f4c 04A0A0E3 		mov	sl, #4
 5378 2f50 FFC000E2 		and	ip, r0, #255
 5379 2f54 0630A0E1 		mov	r3, r6
 5380 2f58 0510A0E3 		mov	r1, #5
 5381 2f5c DD20A0E3 		mov	r2, #221
 5382 2f60 F8009FE5 		ldr	r0, .L447+4
 5383 2f64 00C08DE5 		str	ip, [sp, #0]
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5384              		.loc 1 1187 0
 5385 2f68 7F7087E2 		add	r7, r7, #127
 5386              	.LVL430:
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5387              		.loc 1 1186 0
 5388 2f6c 04A08DE5 		str	sl, [sp, #4]
 5389 2f70 FEFFFFEB 		bl	cmdSet
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5390              		.loc 1 1187 0
 5391 2f74 05E0A0E3 		mov	lr, #5
 5392 2f78 0E10A0E1 		mov	r1, lr
 5393 2f7c 0630A0E1 		mov	r3, r6
 5394 2f80 E120A0E3 		mov	r2, #225
 5395 2f84 FF6007E2 		and	r6, r7, #255
 5396              	.LVL431:
 5397 2f88 D0009FE5 		ldr	r0, .L447+4
 5398 2f8c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5399 2f90 FEFFFFEB 		bl	cmdSet
 5400              	.LVL432:
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5401              		.loc 1 1188 0
 5402 2f94 14C09DE5 		ldr	ip, [sp, #20]
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5403              		.loc 1 1189 0
 5404 2f98 24E09DE5 		ldr	lr, [sp, #36]
 5405 2f9c 1C609DE5 		ldr	r6, [sp, #28]
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5406              		.loc 1 1188 0
 5407 2fa0 05C2C4E5 		strb	ip, [r4, #517]
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5408              		.loc 1 1189 0
 5409 2fa4 20C09DE5 		ldr	ip, [sp, #32]
 5410 2fa8 0B20A0E1 		mov	r2, fp
 5411 2fac 18309DE5 		ldr	r3, [sp, #24]
 5412 2fb0 B0109FE5 		ldr	r1, .L447+12
 5413 2fb4 0A00A0E1 		mov	r0, sl
 5414 2fb8 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5415 2fbc 0C708DE5 		str	r7, [sp, #12]
 5416 2fc0 FEFFFFEB 		bl	CyU3PDebugPrint
 5417              	.LVL433:
1193:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5418              		.loc 1 1193 0
 5419 2fc4 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5420              	.LVL434:
1194:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5421              		.loc 1 1194 0
 5422 2fc8 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5423              	.LVL435:
1195:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5424              		.loc 1 1195 0
 5425 2fcc 0730A0E1 		mov	r3, r7
 5426 2fd0 0610A0E3 		mov	r1, #6
 5427 2fd4 8520A0E3 		mov	r2, #133
 5428 2fd8 80009FE5 		ldr	r0, .L447+4
 5429 2fdc 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5430 2fe0 FEFFFFEB 		bl	cmdSet
1196:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5431              		.loc 1 1196 0
 5432 2fe4 0730A0E1 		mov	r3, r7
 5433 2fe8 0610A0E3 		mov	r1, #6
 5434 2fec 8620A0E3 		mov	r2, #134
 5435 2ff0 68009FE5 		ldr	r0, .L447+4
 5436 2ff4 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5437 2ff8 FEFFFFEB 		bl	cmdSet
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5438              		.loc 1 1198 0
 5439 2ffc 0620A0E1 		mov	r2, r6
 5440 3000 0530A0E1 		mov	r3, r5
 5441 3004 58109FE5 		ldr	r1, .L447+8
 5442 3008 0A00A0E1 		mov	r0, sl
1197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5443              		.loc 1 1197 0
 5444 300c 1D62C4E5 		strb	r6, [r4, #541]
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5445              		.loc 1 1198 0
 5446 3010 FEFFFFEB 		bl	CyU3PDebugPrint
 5447              	.LVL436:
1203:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5448              		.loc 1 1203 0
 5449 3014 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5450              	.LVL437:
1204:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5451              		.loc 1 1204 0
 5452 3018 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5453 301c 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5454 3020 0710A0E3 		mov	r1, #7
 5455 3024 34009FE5 		ldr	r0, .L447+4
 5456 3028 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5457 302c FEFFFFEB 		bl	cmdSet
 5458              	.LVL438:
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5459              		.loc 1 1206 0
 5460 3030 0530A0E1 		mov	r3, r5
 5461 3034 0A00A0E1 		mov	r0, sl
 5462 3038 24109FE5 		ldr	r1, .L447+8
 5463 303c 0620A0E1 		mov	r2, r6
1205:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5464              		.loc 1 1205 0
 5465 3040 3552C4E5 		strb	r5, [r4, #565]
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5466              		.loc 1 1206 0
 5467 3044 FEFFFFEB 		bl	CyU3PDebugPrint
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5468              		.loc 1 1208 0
 5469 3048 10309FE5 		ldr	r3, .L447+4
 5470 304c 1C0093E5 		ldr	r0, [r3, #28]
1211:../uvc.c      **** }
 5471              		.loc 1 1211 0
 5472 3050 2CD08DE2 		add	sp, sp, #44
 5473 3054 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5474              		.loc 1 1208 0
 5475 3058 FEFFFFEA 		b	_txe_mutex_put
 5476              	.L448:
 5477              		.align	2
 5478              	.L447:
 5479 305c 00000000 		.word	.LANCHOR1
 5480 3060 00000000 		.word	cmdQu
 5481 3064 F4050000 		.word	.LC33
 5482 3068 14060000 		.word	.LC34
 5483              		.cfi_endproc
 5484              	.LFE4:
 5486              		.align	2
 5487              		.global	CyFxUVCAddHeader
 5489              	CyFxUVCAddHeader:
 5490              	.LFB5:
1219:../uvc.c      **** {
 5491              		.loc 1 1219 0
 5492              		.cfi_startproc
 5493              		@ args = 0, pretend = 0, frame = 0
 5494              		@ frame_needed = 0, uses_anonymous_args = 0
 5495              	.LVL439:
 5496 306c 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5497              	.LCFI21:
 5498              		.cfi_def_cfa_offset 16
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5499              		.loc 1 1221 0
 5500 3070 0C20A0E3 		mov	r2, #12
1219:../uvc.c      **** {
 5501              		.loc 1 1219 0
 5502 3074 0150A0E1 		mov	r5, r1
 5503              		.cfi_offset 14, -4
 5504              		.cfi_offset 5, -8
 5505              		.cfi_offset 4, -12
 5506              		.cfi_offset 3, -16
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5507              		.loc 1 1221 0
 5508 3078 18109FE5 		ldr	r1, .L451
 5509              	.LVL440:
1219:../uvc.c      **** {
 5510              		.loc 1 1219 0
 5511 307c 0040A0E1 		mov	r4, r0
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5512              		.loc 1 1221 0
 5513 3080 FEFFFFEB 		bl	CyU3PMemCopy
 5514              	.LVL441:
1224:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5515              		.loc 1 1224 0
 5516 3084 020015E3 		tst	r5, #2
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5517              		.loc 1 1226 0
 5518 3088 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5519 308c 02308313 		orrne	r3, r3, #2
 5520 3090 0130C415 		strneb	r3, [r4, #1]
 5521 3094 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5522              	.L452:
 5523              		.align	2
 5524              	.L451:
 5525 3098 80040000 		.word	.LANCHOR1+1152
 5526              		.cfi_endproc
 5527              	.LFE5:
 5529              		.align	2
 5530              		.global	CyFxAppErrorHandler
 5532              	CyFxAppErrorHandler:
 5533              	.LFB6:
1236:../uvc.c      **** {
 5534              		.loc 1 1236 0
 5535              		.cfi_startproc
 5536              		@ args = 0, pretend = 0, frame = 0
 5537              		@ frame_needed = 0, uses_anonymous_args = 0
 5538              	.LVL442:
 5539 309c 08402DE9 		stmfd	sp!, {r3, lr}
 5540              	.LCFI22:
 5541              		.cfi_def_cfa_offset 8
 5542              	.LVL443:
 5543              	.L454:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5544              		.loc 1 1246 0 discriminator 1
 5545 30a0 10109FE5 		ldr	r1, .L455
 5546 30a4 0400A0E3 		mov	r0, #4
 5547              		.cfi_offset 14, -4
 5548              		.cfi_offset 3, -8
 5549 30a8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 5550              		.loc 1 1247 0 discriminator 1
 5551 30ac FA0FA0E3 		mov	r0, #1000
 5552 30b0 FEFFFFEB 		bl	_tx_thread_sleep
 5553 30b4 F9FFFFEA 		b	.L454
 5554              	.L456:
 5555              		.align	2
 5556              	.L455:
 5557 30b8 D4010000 		.word	.LC12
 5558              		.cfi_endproc
 5559              	.LFE6:
 5561              		.align	2
 5562              		.global	UVCAppThread_Entry
 5564              	UVCAppThread_Entry:
 5565              	.LFB18:
2191:../uvc.c      **** {
 5566              		.loc 1 2191 0
 5567              		.cfi_startproc
 5568              		@ args = 0, pretend = 0, frame = 176
 5569              		@ frame_needed = 0, uses_anonymous_args = 0
 5570              	.LVL444:
 5571 30bc F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5572              	.LCFI23:
 5573              		.cfi_def_cfa_offset 28
 5574 30c0 BCD04DE2 		sub	sp, sp, #188
 5575              	.LCFI24:
 5576              		.cfi_def_cfa_offset 216
 5577              	.LBB212:
 5578              	.LBB213:
1648:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5579              		.loc 1 1648 0
 5580              		.cfi_offset 14, -4
 5581              		.cfi_offset 10, -8
 5582              		.cfi_offset 8, -12
 5583              		.cfi_offset 7, -16
 5584              		.cfi_offset 6, -20
 5585              		.cfi_offset 5, -24
 5586              		.cfi_offset 4, -28
 5587 30c4 FEFFFFEB 		bl	CyU3PUartInit
 5588              	.LVL445:
1649:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5589              		.loc 1 1649 0
 5590 30c8 004050E2 		subs	r4, r0, #0
 5591 30cc 0400000A 		beq	.L458
1651:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5592              		.loc 1 1651 0
 5593 30d0 0400A0E3 		mov	r0, #4
 5594              	.LVL446:
 5595 30d4 A41A9FE5 		ldr	r1, .L552
 5596 30d8 FEFFFFEB 		bl	CyU3PDebugPrint
1652:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5597              		.loc 1 1652 0
 5598 30dc 0400A0E1 		mov	r0, r4
 5599 30e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5600              	.L458:
1656:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5601              		.loc 1 1656 0
 5602 30e4 98CA9FE5 		ldr	ip, .L552+4
1658:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5603              		.loc 1 1658 0
 5604 30e8 0030A0E3 		mov	r3, #0
1657:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5605              		.loc 1 1657 0
 5606 30ec 0120A0E3 		mov	r2, #1
1665:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5607              		.loc 1 1665 0
 5608 30f0 50008DE2 		add	r0, sp, #80
 5609 30f4 0310A0E1 		mov	r1, r3
1656:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5610              		.loc 1 1656 0
 5611 30f8 60C08DE5 		str	ip, [sp, #96]
1657:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5612              		.loc 1 1657 0
 5613 30fc 6420CDE5 		strb	r2, [sp, #100]
1658:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5614              		.loc 1 1658 0
 5615 3100 6530CDE5 		strb	r3, [sp, #101]
1659:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5616              		.loc 1 1659 0
 5617 3104 50208DE5 		str	r2, [sp, #80]
1660:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5618              		.loc 1 1660 0
 5619 3108 54308DE5 		str	r3, [sp, #84]
1661:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5620              		.loc 1 1661 0
 5621 310c 58308DE5 		str	r3, [sp, #88]
1662:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5622              		.loc 1 1662 0
 5623 3110 5C208DE5 		str	r2, [sp, #92]
1665:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5624              		.loc 1 1665 0
 5625 3114 FEFFFFEB 		bl	CyU3PUartSetConfig
 5626              	.LVL447:
1666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5627              		.loc 1 1666 0
 5628 3118 000050E3 		cmp	r0, #0
 5629 311c 0000000A 		beq	.L459
1668:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5630              		.loc 1 1668 0
 5631 3120 FEFFFFEB 		bl	CyFxAppErrorHandler
 5632              	.LVL448:
 5633              	.L459:
1672:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5634              		.loc 1 1672 0
 5635 3124 0000E0E3 		mvn	r0, #0
 5636 3128 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5637              	.LVL449:
1673:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5638              		.loc 1 1673 0
 5639 312c 000050E3 		cmp	r0, #0
 5640 3130 0000000A 		beq	.L460
1675:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5641              		.loc 1 1675 0
 5642 3134 FEFFFFEB 		bl	CyFxAppErrorHandler
 5643              	.LVL450:
 5644              	.L460:
1679:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5645              		.loc 1 1679 0
 5646 3138 0300A0E3 		mov	r0, #3
 5647 313c 0410A0E3 		mov	r1, #4
 5648 3140 FEFFFFEB 		bl	CyU3PDebugInit
 5649              	.LVL451:
1680:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5650              		.loc 1 1680 0
 5651 3144 000050E3 		cmp	r0, #0
 5652 3148 0000000A 		beq	.L461
1682:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5653              		.loc 1 1682 0
 5654 314c FEFFFFEB 		bl	CyFxAppErrorHandler
 5655              	.LVL452:
 5656              	.L461:
1686:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5657              		.loc 1 1686 0
 5658 3150 0000A0E3 		mov	r0, #0
 5659 3154 FEFFFFEB 		bl	CyU3PDebugPreamble
 5660              	.LVL453:
 5661              	.LBE213:
 5662              	.LBE212:
2206:../uvc.c      **** 		CyU3PThreadSleep(500);
 5663              		.loc 1 2206 0
 5664 3158 7D0FA0E3 		mov	r0, #500
 5665 315c FEFFFFEB 		bl	_tx_thread_sleep
 5666              	.LVL454:
 5667 3160 7D0FA0E3 		mov	r0, #500
 5668 3164 FEFFFFEB 		bl	_tx_thread_sleep
 5669 3168 7D0FA0E3 		mov	r0, #500
 5670 316c FEFFFFEB 		bl	_tx_thread_sleep
 5671 3170 7D0FA0E3 		mov	r0, #500
 5672 3174 FEFFFFEB 		bl	_tx_thread_sleep
 5673 3178 7D0FA0E3 		mov	r0, #500
 5674 317c FEFFFFEB 		bl	_tx_thread_sleep
 5675 3180 7D0FA0E3 		mov	r0, #500
 5676 3184 FEFFFFEB 		bl	_tx_thread_sleep
 5677              	.LBB214:
 5678              	.LBB215:
1697:../uvc.c      ****     status = CyU3PI2cInit ();
 5679              		.loc 1 1697 0
 5680 3188 FEFFFFEB 		bl	CyU3PI2cInit
 5681              	.LVL455:
1698:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5682              		.loc 1 1698 0
 5683 318c 002050E2 		subs	r2, r0, #0
 5684 3190 0201001A 		bne	.L527
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5685              		.loc 1 1705 0
 5686 3194 EC599FE5 		ldr	r5, .L552+8
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5687              		.loc 1 1707 0
 5688 3198 0040E0E3 		mvn	r4, #0
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5689              		.loc 1 1710 0
 5690 319c 0210A0E1 		mov	r1, r2
 5691 31a0 8C008DE2 		add	r0, sp, #140
 5692              	.LVL456:
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5693              		.loc 1 1705 0
 5694 31a4 8C508DE5 		str	r5, [sp, #140]
1706:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5695              		.loc 1 1706 0
 5696 31a8 90208DE5 		str	r2, [sp, #144]
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5697              		.loc 1 1707 0
 5698 31ac 94408DE5 		str	r4, [sp, #148]
1708:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5699              		.loc 1 1708 0
 5700 31b0 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5701              		.loc 1 1710 0
 5702 31b4 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5703              	.LVL457:
1711:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5704              		.loc 1 1711 0
 5705 31b8 001050E2 		subs	r1, r0, #0
 5706 31bc 0001001A 		bne	.L528
 5707              	.LBE215:
 5708              	.LBE214:
 5709              	.LBB221:
 5710              	.LBB224:
1784:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5711              		.loc 1 1784 0
 5712 31c0 C4699FE5 		ldr	r6, .L552+12
 5713 31c4 2820A0E3 		mov	r2, #40
 5714 31c8 0600A0E1 		mov	r0, r6
 5715              	.LVL458:
 5716 31cc FEFFFFEB 		bl	_txe_event_flags_create
 5717              	.LVL459:
1785:../uvc.c      ****     if (apiRetStatus != 0)
 5718              		.loc 1 1785 0
 5719 31d0 002050E2 		subs	r2, r0, #0
 5720 31d4 0301001A 		bne	.L529
1799:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5721              		.loc 1 1799 0
 5722 31d8 0280A0E3 		mov	r8, #2
1806:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5723              		.loc 1 1806 0
 5724 31dc 0210A0E1 		mov	r1, r2
 5725 31e0 9C008DE2 		add	r0, sp, #156
 5726              	.LVL460:
1802:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5727              		.loc 1 1802 0
 5728 31e4 017088E2 		add	r7, r8, #1
1795:../uvc.c      ****     isUsbConnected = CyFalse;
 5729              		.loc 1 1795 0
 5730 31e8 3C2086E5 		str	r2, [r6, #60]
1796:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5731              		.loc 1 1796 0
 5732 31ec 402086E5 		str	r2, [r6, #64]
1801:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5733              		.loc 1 1801 0
 5734 31f0 A420CDE5 		strb	r2, [sp, #164]
1803:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5735              		.loc 1 1803 0
 5736 31f4 A0208DE5 		str	r2, [sp, #160]
1799:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5737              		.loc 1 1799 0
 5738 31f8 9C80CDE5 		strb	r8, [sp, #156]
1800:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5739              		.loc 1 1800 0
 5740 31fc 9D80CDE5 		strb	r8, [sp, #157]
1802:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5741              		.loc 1 1802 0
 5742 3200 A570CDE5 		strb	r7, [sp, #165]
1806:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5743              		.loc 1 1806 0
 5744 3204 FEFFFFEB 		bl	CyU3PGpioInit
 5745              	.LVL461:
1807:../uvc.c      ****     if (apiRetStatus != 0)
 5746              		.loc 1 1807 0
 5747 3208 002050E2 		subs	r2, r0, #0
 5748 320c 7B01001A 		bne	.L530
1815:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5749              		.loc 1 1815 0
 5750 3210 1600A0E3 		mov	r0, #22
 5751              	.LVL462:
 5752 3214 0110A0E3 		mov	r1, #1
 5753 3218 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5754              	.LVL463:
1816:../uvc.c      ****     if (apiRetStatus != 0)
 5755              		.loc 1 1816 0
 5756 321c 002050E2 		subs	r2, r0, #0
 5757 3220 6D01001A 		bne	.L531
1821:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5758              		.loc 1 1821 0
 5759 3224 1400A0E3 		mov	r0, #20
 5760              	.LVL464:
 5761 3228 0110A0E3 		mov	r1, #1
 5762 322c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5763              	.LVL465:
1822:../uvc.c      ****     if (apiRetStatus != 0)
 5764              		.loc 1 1822 0
 5765 3230 002050E2 		subs	r2, r0, #0
 5766 3234 5F01001A 		bne	.L532
1827:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5767              		.loc 1 1827 0
 5768 3238 1800A0E3 		mov	r0, #24
 5769              	.LVL466:
 5770 323c 0110A0E3 		mov	r1, #1
 5771 3240 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5772              	.LVL467:
1828:../uvc.c      ****     if (apiRetStatus != 0)
 5773              		.loc 1 1828 0
 5774 3244 002050E2 		subs	r2, r0, #0
 5775 3248 5101001A 		bne	.L533
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5776              		.loc 1 1835 0
 5777 324c 0140A0E3 		mov	r4, #1
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5778              		.loc 1 1840 0
 5779 3250 1600A0E3 		mov	r0, #22
 5780              	.LVL468:
 5781 3254 68108DE2 		add	r1, sp, #104
1838:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5782              		.loc 1 1838 0
 5783 3258 74208DE5 		str	r2, [sp, #116]
1839:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5784              		.loc 1 1839 0
 5785 325c 7820CDE5 		strb	r2, [sp, #120]
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5786              		.loc 1 1835 0
 5787 3260 68408DE5 		str	r4, [sp, #104]
1836:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5788              		.loc 1 1836 0
 5789 3264 6C408DE5 		str	r4, [sp, #108]
1837:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5790              		.loc 1 1837 0
 5791 3268 70408DE5 		str	r4, [sp, #112]
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5792              		.loc 1 1840 0
 5793 326c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5794              	.LVL469:
1841:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5795              		.loc 1 1841 0
 5796 3270 002050E2 		subs	r2, r0, #0
 5797 3274 1B01001A 		bne	.L534
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5798              		.loc 1 1854 0
 5799 3278 1400A0E3 		mov	r0, #20
 5800              	.LVL470:
 5801 327c 68108DE2 		add	r1, sp, #104
1852:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5802              		.loc 1 1852 0
 5803 3280 74208DE5 		str	r2, [sp, #116]
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5804              		.loc 1 1853 0
 5805 3284 7820CDE5 		strb	r2, [sp, #120]
1849:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5806              		.loc 1 1849 0
 5807 3288 68408DE5 		str	r4, [sp, #104]
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5808              		.loc 1 1850 0
 5809 328c 6C408DE5 		str	r4, [sp, #108]
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5810              		.loc 1 1851 0
 5811 3290 70408DE5 		str	r4, [sp, #112]
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5812              		.loc 1 1854 0
 5813 3294 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5814              	.LVL471:
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5815              		.loc 1 1855 0
 5816 3298 002050E2 		subs	r2, r0, #0
 5817 329c 0801001A 		bne	.L535
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5818              		.loc 1 1868 0
 5819 32a0 1800A0E3 		mov	r0, #24
 5820              	.LVL472:
 5821 32a4 68108DE2 		add	r1, sp, #104
1863:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5822              		.loc 1 1863 0
 5823 32a8 68208DE5 		str	r2, [sp, #104]
1864:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5824              		.loc 1 1864 0
 5825 32ac 6C208DE5 		str	r2, [sp, #108]
1865:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5826              		.loc 1 1865 0
 5827 32b0 70208DE5 		str	r2, [sp, #112]
1867:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5828              		.loc 1 1867 0
 5829 32b4 7820CDE5 		strb	r2, [sp, #120]
1866:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5830              		.loc 1 1866 0
 5831 32b8 74408DE5 		str	r4, [sp, #116]
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5832              		.loc 1 1868 0
 5833 32bc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5834              	.LVL473:
1869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5835              		.loc 1 1869 0
 5836 32c0 002050E2 		subs	r2, r0, #0
 5837 32c4 F500001A 		bne	.L536
1878:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5838              		.loc 1 1878 0
 5839 32c8 00A0A0E3 		mov	sl, #0
1876:../uvc.c      ****     pibclock.clkDiv      = 2;
 5840              		.loc 1 1876 0
 5841 32cc 0270A0E3 		mov	r7, #2	@ movhi
1877:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5842              		.loc 1 1877 0
 5843 32d0 0380A0E3 		mov	r8, #3
1881:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5844              		.loc 1 1881 0
 5845 32d4 0100A0E3 		mov	r0, #1
 5846              	.LVL474:
 5847 32d8 7C108DE2 		add	r1, sp, #124
1876:../uvc.c      ****     pibclock.clkDiv      = 2;
 5848              		.loc 1 1876 0
 5849 32dc BC77CDE1 		strh	r7, [sp, #124]	@ movhi
1877:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5850              		.loc 1 1877 0
 5851 32e0 8880CDE5 		strb	r8, [sp, #136]
1878:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5852              		.loc 1 1878 0
 5853 32e4 84A08DE5 		str	sl, [sp, #132]
1879:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5854              		.loc 1 1879 0
 5855 32e8 80A08DE5 		str	sl, [sp, #128]
1881:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5856              		.loc 1 1881 0
 5857 32ec FEFFFFEB 		bl	CyU3PPibInit
 5858              	.LVL475:
1882:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5859              		.loc 1 1882 0
 5860 32f0 002050E2 		subs	r2, r0, #0
 5861 32f4 7A01001A 		bne	.L537
1889:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5862              		.loc 1 1889 0
 5863 32f8 90089FE5 		ldr	r0, .L552+16
 5864              	.LVL476:
 5865 32fc FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 5866              	.LVL477:
1897:../uvc.c      ****     SensorReset ();
 5867              		.loc 1 1897 0
 5868 3300 FEFFFFEB 		bl	SensorReset
1898:../uvc.c      ****     SensorInit ();
 5869              		.loc 1 1898 0
 5870 3304 FEFFFFEB 		bl	SensorInit
1901:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5871              		.loc 1 1901 0
 5872 3308 FEFFFFEB 		bl	CyU3PUsbStart
 5873              	.LVL478:
1902:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5874              		.loc 1 1902 0
 5875 330c 004050E2 		subs	r4, r0, #0
 5876 3310 6901001A 		bne	.L538
1908:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 5877              		.loc 1 1908 0
 5878 3314 0410A0E1 		mov	r1, r4
 5879 3318 74089FE5 		ldr	r0, .L552+20
 5880              	.LVL479:
 5881 331c FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 5882              	.LVL480:
1911:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 5883              		.loc 1 1911 0
 5884 3320 70089FE5 		ldr	r0, .L552+24
 5885 3324 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1917:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 5886              		.loc 1 1917 0
 5887 3328 6C289FE5 		ldr	r2, .L552+28
 5888 332c 0410A0E1 		mov	r1, r4
 5889 3330 0100A0E3 		mov	r0, #1
 5890 3334 FEFFFFEB 		bl	CyU3PUsbSetDesc
1918:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 5891              		.loc 1 1918 0
 5892 3338 0410A0E1 		mov	r1, r4
 5893 333c 5C289FE5 		ldr	r2, .L552+32
 5894 3340 0400A0E1 		mov	r0, r4
 5895 3344 FEFFFFEB 		bl	CyU3PUsbSetDesc
1921:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 5896              		.loc 1 1921 0
 5897 3348 0410A0E1 		mov	r1, r4
 5898 334c 50289FE5 		ldr	r2, .L552+36
 5899 3350 0200A0E3 		mov	r0, #2
 5900 3354 FEFFFFEB 		bl	CyU3PUsbSetDesc
1922:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 5901              		.loc 1 1922 0
 5902 3358 0410A0E1 		mov	r1, r4
 5903 335c 44289FE5 		ldr	r2, .L552+40
 5904 3360 0700A0E3 		mov	r0, #7
 5905 3364 FEFFFFEB 		bl	CyU3PUsbSetDesc
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 5906              		.loc 1 1925 0
 5907 3368 3C289FE5 		ldr	r2, .L552+44
 5908 336c 0410A0E1 		mov	r1, r4
 5909 3370 0400A0E3 		mov	r0, #4
 5910 3374 FEFFFFEB 		bl	CyU3PUsbSetDesc
1926:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 5911              		.loc 1 1926 0
 5912 3378 0410A0E1 		mov	r1, r4
 5913 337c 2C289FE5 		ldr	r2, .L552+48
 5914 3380 0800A0E1 		mov	r0, r8
 5915 3384 FEFFFFEB 		bl	CyU3PUsbSetDesc
1927:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5916              		.loc 1 1927 0
 5917 3388 0410A0E1 		mov	r1, r4
 5918 338c 20289FE5 		ldr	r2, .L552+52
 5919 3390 0600A0E3 		mov	r0, #6
 5920 3394 FEFFFFEB 		bl	CyU3PUsbSetDesc
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 5921              		.loc 1 1930 0
 5922 3398 0410A0E1 		mov	r1, r4
 5923 339c 14289FE5 		ldr	r2, .L552+56
 5924 33a0 0500A0E3 		mov	r0, #5
 5925 33a4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1931:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 5926              		.loc 1 1931 0
 5927 33a8 0110A0E3 		mov	r1, #1
 5928 33ac 08289FE5 		ldr	r2, .L552+60
 5929 33b0 0500A0E3 		mov	r0, #5
 5930 33b4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 5931              		.loc 1 1932 0
 5932 33b8 0210A0E3 		mov	r1, #2
 5933 33bc FC279FE5 		ldr	r2, .L552+64
 5934 33c0 0500A0E3 		mov	r0, #5
 5935 33c4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1939:../uvc.c      ****     endPointConfig.enable   = 1;
 5936              		.loc 1 1939 0
 5937 33c8 0150A0E3 		mov	r5, #1
1941:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5938              		.loc 1 1941 0
 5939 33cc 4020A0E3 		mov	r2, #64	@ movhi
1945:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5940              		.loc 1 1945 0
 5941 33d0 8200A0E3 		mov	r0, #130
 5942 33d4 A8108DE2 		add	r1, sp, #168
1939:../uvc.c      ****     endPointConfig.enable   = 1;
 5943              		.loc 1 1939 0
 5944 33d8 A8508DE5 		str	r5, [sp, #168]
1940:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 5945              		.loc 1 1940 0
 5946 33dc AC80CDE5 		strb	r8, [sp, #172]
1941:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5947              		.loc 1 1941 0
 5948 33e0 B02BCDE1 		strh	r2, [sp, #176]	@ movhi
1942:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 5949              		.loc 1 1942 0
 5950 33e4 B340CDE5 		strb	r4, [sp, #179]
1943:../uvc.c      ****     endPointConfig.streams  = 0;
 5951              		.loc 1 1943 0
 5952 33e8 BE4ACDE1 		strh	r4, [sp, #174]	@ movhi
1944:../uvc.c      ****     endPointConfig.burstLen = 1;
 5953              		.loc 1 1944 0
 5954 33ec B250CDE5 		strb	r5, [sp, #178]
1945:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5955              		.loc 1 1945 0
 5956 33f0 FEFFFFEB 		bl	CyU3PSetEpConfig
 5957              	.LVL481:
1946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5958              		.loc 1 1946 0
 5959 33f4 003050E2 		subs	r3, r0, #0
 5960 33f8 2501001A 		bne	.L539
1956:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5961              		.loc 1 1956 0
 5962 33fc C0C79FE5 		ldr	ip, .L552+68
1957:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5963              		.loc 1 1957 0
 5964 3400 C0E79FE5 		ldr	lr, .L552+72
1954:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5965              		.loc 1 1954 0
 5966 3404 018BA0E3 		mov	r8, #1024	@ movhi
1963:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5967              		.loc 1 1963 0
 5968 3408 10A0A0E3 		mov	sl, #16
1965:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5969              		.loc 1 1965 0
 5970 340c B8079FE5 		ldr	r0, .L552+76
 5971              	.LVL482:
 5972 3410 0410A0E3 		mov	r1, #4
 5973 3414 34208DE2 		add	r2, sp, #52
1954:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5974              		.loc 1 1954 0
 5975 3418 B483CDE1 		strh	r8, [sp, #52]	@ movhi
1955:../uvc.c      ****     dmaInterConfig.count          = 1;
 5976              		.loc 1 1955 0
 5977 341c B653CDE1 		strh	r5, [sp, #54]	@ movhi
1956:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5978              		.loc 1 1956 0
 5979 3420 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1957:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5980              		.loc 1 1957 0
 5981 3424 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1958:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 5982              		.loc 1 1958 0
 5983 3428 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1959:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 5984              		.loc 1 1959 0
 5985 342c BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1960:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 5986              		.loc 1 1960 0
 5987 3430 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1961:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 5988              		.loc 1 1961 0
 5989 3434 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1962:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 5990              		.loc 1 1962 0
 5991 3438 4440CDE5 		strb	r4, [sp, #68]
1963:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5992              		.loc 1 1963 0
 5993 343c 48A08DE5 		str	sl, [sp, #72]
1964:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 5994              		.loc 1 1964 0
 5995 3440 4C308DE5 		str	r3, [sp, #76]
1965:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5996              		.loc 1 1965 0
 5997 3444 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 5998              	.LVL483:
1967:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5999              		.loc 1 1967 0
 6000 3448 008050E2 		subs	r8, r0, #0
 6001 344c 0601001A 		bne	.L540
1974:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6002              		.loc 1 1974 0
 6003 3450 010BA0E3 		mov	r0, #1024
 6004              	.LVL484:
 6005 3454 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6006 3458 70179FE5 		ldr	r1, .L552+80
1975:../uvc.c      ****     if (glInterStaBuffer == 0)
 6007              		.loc 1 1975 0
 6008 345c 000050E3 		cmp	r0, #0
1974:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6009              		.loc 1 1974 0
 6010 3460 000081E5 		str	r0, [r1, #0]
1975:../uvc.c      ****     if (glInterStaBuffer == 0)
 6011              		.loc 1 1975 0
 6012 3464 3001000A 		beq	.L541
1983:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6013              		.loc 1 1983 0
 6014 3468 0430A0E3 		mov	r3, #4	@ movhi
 6015 346c BE30CDE1 		strh	r3, [sp, #14]	@ movhi
1987:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6016              		.loc 1 1987 0
 6017 3470 5C379FE5 		ldr	r3, .L552+84
1982:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6018              		.loc 1 1982 0
 6019 3474 01E9A0E3 		mov	lr, #16384	@ movhi
 6020 3478 BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
1986:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6021              		.loc 1 1986 0
 6022 347c 54E79FE5 		ldr	lr, .L552+88
1987:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6023              		.loc 1 1987 0
 6024 3480 BA31CDE1 		strh	r3, [sp, #26]	@ movhi
1994:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6025              		.loc 1 1994 0
 6026 3484 50379FE5 		ldr	r3, .L552+92
1985:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6027              		.loc 1 1985 0
 6028 3488 01CCA0E3 		mov	ip, #256	@ movhi
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6029              		.loc 1 1995 0
 6030 348c 0C208DE2 		add	r2, sp, #12
1985:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6031              		.loc 1 1985 0
 6032 3490 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
1986:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6033              		.loc 1 1986 0
 6034 3494 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
1989:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6035              		.loc 1 1989 0
 6036 3498 0CC0A0E3 		mov	ip, #12	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6037              		.loc 1 1990 0
 6038 349c 04E0A0E3 		mov	lr, #4	@ movhi
1992:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6039              		.loc 1 1992 0
 6040 34a0 2A40CDE5 		strb	r4, [sp, #42]
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6041              		.loc 1 1995 0
 6042 34a4 34079FE5 		ldr	r0, .L552+96
 6043 34a8 0710A0E3 		mov	r1, #7
1993:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6044              		.loc 1 1993 0
 6045 34ac 1840A0E3 		mov	r4, #24
1984:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6046              		.loc 1 1984 0
 6047 34b0 B071CDE1 		strh	r7, [sp, #16]	@ movhi
1988:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6048              		.loc 1 1988 0
 6049 34b4 B282CDE1 		strh	r8, [sp, #34]	@ movhi
1989:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6050              		.loc 1 1989 0
 6051 34b8 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6052              		.loc 1 1990 0
 6053 34bc B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
1991:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6054              		.loc 1 1991 0
 6055 34c0 B882CDE1 		strh	r8, [sp, #40]	@ movhi
1993:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6056              		.loc 1 1993 0
 6057 34c4 2C408DE5 		str	r4, [sp, #44]
1994:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6058              		.loc 1 1994 0
 6059 34c8 30308DE5 		str	r3, [sp, #48]
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6060              		.loc 1 1995 0
 6061 34cc FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6062              	.LVL485:
1997:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6063              		.loc 1 1997 0
 6064 34d0 002050E2 		subs	r2, r0, #0
 6065 34d4 0B01001A 		bne	.L542
2088:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6066              		.loc 1 2088 0
 6067 34d8 0500A0E1 		mov	r0, r5
 6068              	.LVL486:
 6069 34dc 0510A0E1 		mov	r1, r5
 6070 34e0 FEFFFFEB 		bl	CyU3PConnectState
 6071              	.LVL487:
2089:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6072              		.loc 1 2089 0
 6073 34e4 002050E2 		subs	r2, r0, #0
 6074 34e8 6300001A 		bne	.L543
2095:../uvc.c      ****     CyU3PBusyWait(100);
 6075              		.loc 1 2095 0
 6076 34ec 6400A0E3 		mov	r0, #100
 6077              	.LVL488:
 6078 34f0 FEFFFFEB 		bl	CyU3PBusyWait
 6079              	.LVL489:
2097:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6080              		.loc 1 2097 0
 6081 34f4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2099:../uvc.c      ****     endPointConfig.enable   = 1;
 6082              		.loc 1 2099 0
 6083 34f8 A8508DE5 		str	r5, [sp, #168]
2100:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6084              		.loc 1 2100 0
 6085 34fc AC70CDE5 		strb	r7, [sp, #172]
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6086              		.loc 1 2112 0
 6087 3500 A8108DE2 		add	r1, sp, #168
2101:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6088              		.loc 1 2101 0
 6089 3504 030050E3 		cmp	r0, #3
2097:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6090              		.loc 1 2097 0
 6091 3508 4800C6E5 		strb	r0, [r6, #72]
2108:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6092              		.loc 1 2108 0
 6093 350c 020CA013 		movne	r0, #512	@ movhi
2103:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6094              		.loc 1 2103 0
 6095 3510 017BA003 		moveq	r7, #1024	@ movhi
2108:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6096              		.loc 1 2108 0
 6097 3514 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2109:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6098              		.loc 1 2109 0
 6099 3518 B250CD15 		strneb	r5, [sp, #178]
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6100              		.loc 1 2112 0
 6101 351c 8300A0E3 		mov	r0, #131
2111:../uvc.c      ****     endPointConfig.streams  = 0;
 6102              		.loc 1 2111 0
 6103 3520 0050A0E3 		mov	r5, #0	@ movhi
2103:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6104              		.loc 1 2103 0
 6105 3524 B07BCD01 		streqh	r7, [sp, #176]	@ movhi
2104:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6106              		.loc 1 2104 0
 6107 3528 B2A0CD05 		streqb	sl, [sp, #178]
2111:../uvc.c      ****     endPointConfig.streams  = 0;
 6108              		.loc 1 2111 0
 6109 352c BE5ACDE1 		strh	r5, [sp, #174]	@ movhi
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6110              		.loc 1 2112 0
 6111 3530 FEFFFFEB 		bl	CyU3PSetEpConfig
 6112              	.LVL490:
2113:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6113              		.loc 1 2113 0
 6114 3534 002050E2 		subs	r2, r0, #0
 6115 3538 4600001A 		bne	.L524
 6116 353c A0869FE5 		ldr	r8, .L552+100
 6117              	.LBE224:
 6118              	.LBE221:
2233:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6119              		.loc 1 2233 0
 6120 3540 44569FE5 		ldr	r5, .L552+12
 6121 3544 0240A0E1 		mov	r4, r2
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6122              		.loc 1 2304 0
 6123 3548 0870A0E1 		mov	r7, r8
 6124              	.LVL491:
 6125              	.L498:
2233:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6126              		.loc 1 2233 0
 6127 354c 38069FE5 		ldr	r0, .L552+12
 6128 3550 0110A0E3 		mov	r1, #1
 6129 3554 0220A0E3 		mov	r2, #2
 6130 3558 B4308DE2 		add	r3, sp, #180
 6131 355c 00408DE5 		str	r4, [sp, #0]
 6132 3560 FEFFFFEB 		bl	_txe_event_flags_get
 6133 3564 000050E3 		cmp	r0, #0
 6134 3568 2700001A 		bne	.L500
2279:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6135              		.loc 1 2279 0
 6136 356c 44A095E5 		ldr	sl, [r5, #68]
 6137 3570 00005AE3 		cmp	sl, #0
 6138 3574 0300000A 		beq	.L501
2279:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6139              		.loc 1 2279 0 is_stmt 0 discriminator 1
 6140 3578 BE22D5E1 		ldrh	r2, [r5, #46]
 6141 357c B013D5E1 		ldrh	r1, [r5, #48]
 6142 3580 010052E1 		cmp	r2, r1
 6143 3584 6000000A 		beq	.L544
 6144              	.L501:
2406:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6145              		.loc 1 2406 0 is_stmt 1
 6146 3588 4010A0E3 		mov	r1, #64
 6147 358c 0020A0E3 		mov	r2, #0
 6148 3590 F4059FE5 		ldr	r0, .L552+12
 6149 3594 FEFFFFEB 		bl	_txe_event_flags_set
2409:../uvc.c      ****         CyU3PThreadRelinquish ();
 6150              		.loc 1 2409 0
 6151 3598 FEFFFFEB 		bl	_txe_thread_relinquish
2410:../uvc.c      ****     }
 6152              		.loc 1 2410 0
 6153 359c EAFFFFEA 		b	.L498
 6154              	.LVL492:
 6155              	.L527:
 6156              	.LBB259:
 6157              	.LBB220:
1700:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6158              		.loc 1 1700 0
 6159 35a0 0400A0E3 		mov	r0, #4
 6160              	.LVL493:
 6161 35a4 3C169FE5 		ldr	r1, .L552+104
 6162 35a8 FEFFFFEB 		bl	CyU3PDebugPrint
 6163              	.LVL494:
 6164              	.L463:
 6165              	.LBB216:
 6166              	.LBB217:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6167              		.loc 1 1246 0
 6168 35ac 38169FE5 		ldr	r1, .L552+108
 6169 35b0 0400A0E3 		mov	r0, #4
 6170 35b4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6171              		.loc 1 1247 0
 6172 35b8 FA0FA0E3 		mov	r0, #1000
 6173 35bc FEFFFFEB 		bl	_tx_thread_sleep
 6174 35c0 F9FFFFEA 		b	.L463
 6175              	.LVL495:
 6176              	.L528:
 6177              	.LBE217:
 6178              	.LBE216:
1713:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6179              		.loc 1 1713 0
 6180 35c4 0400A0E3 		mov	r0, #4
 6181              	.LVL496:
 6182 35c8 20169FE5 		ldr	r1, .L552+112
 6183              	.LVL497:
 6184 35cc FEFFFFEB 		bl	CyU3PDebugPrint
 6185              	.L465:
 6186              	.LBB218:
 6187              	.LBB219:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6188              		.loc 1 1246 0
 6189 35d0 14169FE5 		ldr	r1, .L552+108
 6190 35d4 0400A0E3 		mov	r0, #4
 6191 35d8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6192              		.loc 1 1247 0
 6193 35dc FA0FA0E3 		mov	r0, #1000
 6194 35e0 FEFFFFEB 		bl	_tx_thread_sleep
 6195 35e4 F9FFFFEA 		b	.L465
 6196              	.LVL498:
 6197              	.L529:
 6198              	.LBE219:
 6199              	.LBE218:
 6200              	.LBE220:
 6201              	.LBE259:
 6202              	.LBB260:
 6203              	.LBB223:
1787:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6204              		.loc 1 1787 0
 6205 35e8 0400A0E3 		mov	r0, #4
 6206              	.LVL499:
 6207 35ec 00169FE5 		ldr	r1, .L552+116
 6208 35f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6209              	.LVL500:
 6210              	.L467:
 6211              	.LBB233:
 6212              	.LBB234:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6213              		.loc 1 1246 0
 6214 35f4 F0159FE5 		ldr	r1, .L552+108
 6215 35f8 0400A0E3 		mov	r0, #4
 6216 35fc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6217              		.loc 1 1247 0
 6218 3600 FA0FA0E3 		mov	r0, #1000
 6219 3604 FEFFFFEB 		bl	_tx_thread_sleep
 6220 3608 F9FFFFEA 		b	.L467
 6221              	.LVL501:
 6222              	.L500:
 6223              	.LBE234:
 6224              	.LBE233:
 6225              	.LBE223:
 6226              	.LBE260:
2335:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6227              		.loc 1 2335 0
 6228 360c 78059FE5 		ldr	r0, .L552+12
 6229 3610 0210A0E3 		mov	r1, #2
 6230 3614 0320A0E3 		mov	r2, #3
 6231 3618 B4308DE2 		add	r3, sp, #180
 6232 361c 00408DE5 		str	r4, [sp, #0]
 6233 3620 FEFFFFEB 		bl	_txe_event_flags_get
 6234 3624 000050E3 		cmp	r0, #0
 6235 3628 DA00001A 		bne	.L508
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6236              		.loc 1 2350 0
 6237 362c 402095E5 		ldr	r2, [r5, #64]
2338:../uvc.c      ****                 hitFV     = CyFalse;
 6238              		.loc 1 2338 0
 6239 3630 444085E5 		str	r4, [r5, #68]
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6240              		.loc 1 2350 0
 6241 3634 000052E3 		cmp	r2, #0
2339:../uvc.c      ****                 prodCount = 0;
 6242              		.loc 1 2339 0
 6243 3638 BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2346:../uvc.c      ****                 fb=0;
 6244              		.loc 1 2346 0
 6245 363c B842C5E1 		strh	r4, [r5, #40]	@ movhi
2340:../uvc.c      ****                 consCount = 0;
 6246              		.loc 1 2340 0
 6247 3640 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2347:../uvc.c      ****                 pb=0;
 6248              		.loc 1 2347 0
 6249 3644 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2348:../uvc.c      ****                 pbc=0;
 6250              		.loc 1 2348 0
 6251 3648 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6252              		.loc 1 2350 0
 6253 364c BF00000A 		beq	.L545
 6254              	.L509:
2362:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6255              		.loc 1 2362 0
 6256 3650 404086E5 		str	r4, [r6, #64]
 6257 3654 CBFFFFEA 		b	.L501
 6258              	.LVL502:
 6259              	.L524:
 6260              	.LBB261:
 6261              	.LBB257:
2116:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6262              		.loc 1 2116 0
 6263 3658 0400A0E3 		mov	r0, #4
 6264              	.LVL503:
 6265 365c 94159FE5 		ldr	r1, .L552+120
 6266 3660 FEFFFFEB 		bl	CyU3PDebugPrint
 6267              	.LVL504:
 6268              	.L499:
 6269              	.LBB235:
 6270              	.LBB236:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6271              		.loc 1 1246 0
 6272 3664 80159FE5 		ldr	r1, .L552+108
 6273 3668 0400A0E3 		mov	r0, #4
 6274 366c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6275              		.loc 1 1247 0
 6276 3670 FA0FA0E3 		mov	r0, #1000
 6277 3674 FEFFFFEB 		bl	_tx_thread_sleep
 6278 3678 F9FFFFEA 		b	.L499
 6279              	.LVL505:
 6280              	.L543:
 6281              	.LBE236:
 6282              	.LBE235:
2091:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6283              		.loc 1 2091 0
 6284 367c 0400A0E3 		mov	r0, #4
 6285              	.LVL506:
 6286 3680 74159FE5 		ldr	r1, .L552+124
 6287 3684 FEFFFFEB 		bl	CyU3PDebugPrint
 6288              	.LVL507:
 6289              	.L495:
 6290              	.LBB237:
 6291              	.LBB238:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6292              		.loc 1 1246 0
 6293 3688 5C159FE5 		ldr	r1, .L552+108
 6294 368c 0400A0E3 		mov	r0, #4
 6295 3690 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6296              		.loc 1 1247 0
 6297 3694 FA0FA0E3 		mov	r0, #1000
 6298 3698 FEFFFFEB 		bl	_tx_thread_sleep
 6299 369c F9FFFFEA 		b	.L495
 6300              	.LVL508:
 6301              	.L536:
 6302              	.LBE238:
 6303              	.LBE237:
1871:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6304              		.loc 1 1871 0
 6305 36a0 0400A0E3 		mov	r0, #4
 6306              	.LVL509:
 6307 36a4 54159FE5 		ldr	r1, .L552+128
 6308 36a8 FEFFFFEB 		bl	CyU3PDebugPrint
 6309              	.LVL510:
 6310              	.L481:
 6311              	.LBB239:
 6312              	.LBB240:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6313              		.loc 1 1246 0
 6314 36ac 38159FE5 		ldr	r1, .L552+108
 6315 36b0 0400A0E3 		mov	r0, #4
 6316 36b4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6317              		.loc 1 1247 0
 6318 36b8 FA0FA0E3 		mov	r0, #1000
 6319 36bc FEFFFFEB 		bl	_tx_thread_sleep
 6320 36c0 F9FFFFEA 		b	.L481
 6321              	.LVL511:
 6322              	.L535:
 6323              	.LBE240:
 6324              	.LBE239:
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6325              		.loc 1 1857 0
 6326 36c4 0400A0E3 		mov	r0, #4
 6327              	.LVL512:
 6328 36c8 34159FE5 		ldr	r1, .L552+132
 6329 36cc FEFFFFEB 		bl	CyU3PDebugPrint
 6330              	.LVL513:
 6331              	.L479:
 6332              	.LBB241:
 6333              	.LBB242:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6334              		.loc 1 1246 0
 6335 36d0 14159FE5 		ldr	r1, .L552+108
 6336 36d4 0400A0E3 		mov	r0, #4
 6337 36d8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6338              		.loc 1 1247 0
 6339 36dc FA0FA0E3 		mov	r0, #1000
 6340 36e0 FEFFFFEB 		bl	_tx_thread_sleep
 6341 36e4 F9FFFFEA 		b	.L479
 6342              	.LVL514:
 6343              	.L534:
 6344              	.LBE242:
 6345              	.LBE241:
1843:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6346              		.loc 1 1843 0
 6347 36e8 0400A0E3 		mov	r0, #4
 6348              	.LVL515:
 6349 36ec 14159FE5 		ldr	r1, .L552+136
 6350 36f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6351              	.LVL516:
 6352              	.L477:
 6353              	.LBB243:
 6354              	.LBB244:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6355              		.loc 1 1246 0
 6356 36f4 F0149FE5 		ldr	r1, .L552+108
 6357 36f8 0400A0E3 		mov	r0, #4
 6358 36fc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6359              		.loc 1 1247 0
 6360 3700 FA0FA0E3 		mov	r0, #1000
 6361 3704 FEFFFFEB 		bl	_tx_thread_sleep
 6362 3708 F9FFFFEA 		b	.L477
 6363              	.LVL517:
 6364              	.L544:
 6365              	.LBE244:
 6366              	.LBE243:
 6367              	.LBE257:
 6368              	.LBE261:
2289:../uvc.c      ****                 prodCount = 0;
 6369              		.loc 1 2289 0
 6370 370c BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2290:../uvc.c      ****                 consCount = 0;
 6371              		.loc 1 2290 0
 6372 3710 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2291:../uvc.c      ****                 hitFV     = CyFalse;
 6373              		.loc 1 2291 0
 6374 3714 444085E5 		str	r4, [r5, #68]
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6375              		.loc 1 2304 0
 6376 3718 8104D8E5 		ldrb	r0, [r8, #1153]	@ zero_extendqisi2
2286:../uvc.c      ****             	fb=0;
 6377              		.loc 1 2286 0
 6378 371c B842C5E1 		strh	r4, [r5, #40]	@ movhi
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6379              		.loc 1 2304 0
 6380 3720 01E020E2 		eor	lr, r0, #1
 6381 3724 81E4C8E5 		strb	lr, [r8, #1153]
2305:../uvc.c      ****                 if(stiflag){
 6382              		.loc 1 2305 0
 6383 3728 983095E5 		ldr	r3, [r5, #152]
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6384              		.loc 1 2306 0
 6385 372c 81C4D7E5 		ldrb	ip, [r7, #1153]	@ zero_extendqisi2
2305:../uvc.c      ****                 if(stiflag){
 6386              		.loc 1 2305 0
 6387 3730 000053E3 		cmp	r3, #0
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6388              		.loc 1 2306 0
 6389 3734 20C08C13 		orrne	ip, ip, #32
2309:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6390              		.loc 1 2309 0
 6391 3738 DFC00C02 		andeq	ip, ip, #223
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6392              		.loc 1 2306 0
 6393 373c 81C4C715 		strneb	ip, [r7, #1153]
2309:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6394              		.loc 1 2309 0
 6395 3740 81C4C705 		streqb	ip, [r7, #1153]
2307:../uvc.c      ****                 	stiflag = CyFalse;
 6396              		.loc 1 2307 0
 6397 3744 98408515 		strne	r4, [r5, #152]
2287:../uvc.c      ****             	pb=0;
 6398              		.loc 1 2287 0
 6399 3748 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2288:../uvc.c      ****             	pbc=0;
 6400              		.loc 1 2288 0
 6401 374c BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2312:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6402              		.loc 1 2312 0
 6403 3750 88049FE5 		ldr	r0, .L552+96
 6404 3754 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6405              	.LVL518:
2313:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6406              		.loc 1 2313 0
 6407 3758 002050E2 		subs	r2, r0, #0
 6408 375c 3900001A 		bne	.L546
2320:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6409              		.loc 1 2320 0
 6410 3760 0210A0E1 		mov	r1, r2
 6411 3764 74049FE5 		ldr	r0, .L552+96
 6412              	.LVL519:
 6413 3768 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6414              	.LVL520:
2321:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6415              		.loc 1 2321 0
 6416 376c 002050E2 		subs	r2, r0, #0
 6417 3770 2B00001A 		bne	.L547
2329:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6418              		.loc 1 2329 0
 6419 3774 5C049FE5 		ldr	r0, .L552+88
 6420              	.LVL521:
 6421 3778 0210A0E1 		mov	r1, r2
 6422 377c 02A0A0E3 		mov	sl, #2
 6423 3780 0020A0E1 		mov	r2, r0
 6424              	.LVL522:
 6425 3784 0130A0E1 		mov	r3, r1
 6426 3788 00A08DE5 		str	sl, [sp, #0]
 6427 378c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6428              	.LVL523:
 6429 3790 7CFFFFEA 		b	.L501
 6430              	.LVL524:
 6431              	.L533:
 6432              	.LBB262:
 6433              	.LBB222:
1830:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6434              		.loc 1 1830 0
 6435 3794 0400A0E3 		mov	r0, #4
 6436              	.LVL525:
 6437 3798 6C149FE5 		ldr	r1, .L552+140
 6438 379c FEFFFFEB 		bl	CyU3PDebugPrint
 6439              	.LVL526:
 6440              	.L475:
 6441              	.LBB231:
 6442              	.LBB232:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6443              		.loc 1 1246 0
 6444 37a0 44149FE5 		ldr	r1, .L552+108
 6445 37a4 0400A0E3 		mov	r0, #4
 6446 37a8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6447              		.loc 1 1247 0
 6448 37ac FA0FA0E3 		mov	r0, #1000
 6449 37b0 FEFFFFEB 		bl	_tx_thread_sleep
 6450 37b4 F9FFFFEA 		b	.L475
 6451              	.LVL527:
 6452              	.L532:
 6453              	.LBE232:
 6454              	.LBE231:
1824:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6455              		.loc 1 1824 0
 6456 37b8 0400A0E3 		mov	r0, #4
 6457              	.LVL528:
 6458 37bc 4C149FE5 		ldr	r1, .L552+144
 6459 37c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6460              	.LVL529:
 6461              	.L473:
 6462              	.LBB229:
 6463              	.LBB230:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6464              		.loc 1 1246 0
 6465 37c4 20149FE5 		ldr	r1, .L552+108
 6466 37c8 0400A0E3 		mov	r0, #4
 6467 37cc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6468              		.loc 1 1247 0
 6469 37d0 FA0FA0E3 		mov	r0, #1000
 6470 37d4 FEFFFFEB 		bl	_tx_thread_sleep
 6471 37d8 F9FFFFEA 		b	.L473
 6472              	.LVL530:
 6473              	.L531:
 6474              	.LBE230:
 6475              	.LBE229:
1818:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6476              		.loc 1 1818 0
 6477 37dc 0400A0E3 		mov	r0, #4
 6478              	.LVL531:
 6479 37e0 2C149FE5 		ldr	r1, .L552+148
 6480 37e4 FEFFFFEB 		bl	CyU3PDebugPrint
 6481              	.LVL532:
 6482              	.L471:
 6483              	.LBB227:
 6484              	.LBB228:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6485              		.loc 1 1246 0
 6486 37e8 FC139FE5 		ldr	r1, .L552+108
 6487 37ec 0400A0E3 		mov	r0, #4
 6488 37f0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6489              		.loc 1 1247 0
 6490 37f4 FA0FA0E3 		mov	r0, #1000
 6491 37f8 FEFFFFEB 		bl	_tx_thread_sleep
 6492 37fc F9FFFFEA 		b	.L471
 6493              	.LVL533:
 6494              	.L530:
 6495              	.LBE228:
 6496              	.LBE227:
1809:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6497              		.loc 1 1809 0
 6498 3800 0400A0E3 		mov	r0, #4
 6499              	.LVL534:
 6500 3804 0C149FE5 		ldr	r1, .L552+152
 6501 3808 FEFFFFEB 		bl	CyU3PDebugPrint
 6502              	.LVL535:
 6503              	.L469:
 6504              	.LBB225:
 6505              	.LBB226:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6506              		.loc 1 1246 0
 6507 380c D8139FE5 		ldr	r1, .L552+108
 6508 3810 0400A0E3 		mov	r0, #4
 6509 3814 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6510              		.loc 1 1247 0
 6511 3818 FA0FA0E3 		mov	r0, #1000
 6512 381c FEFFFFEB 		bl	_tx_thread_sleep
 6513 3820 F9FFFFEA 		b	.L469
 6514              	.LVL536:
 6515              	.L547:
 6516              	.LBE226:
 6517              	.LBE225:
 6518              	.LBE222:
 6519              	.LBE262:
2323:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6520              		.loc 1 2323 0
 6521 3824 0400A0E3 		mov	r0, #4
 6522              	.LVL537:
 6523 3828 EC139FE5 		ldr	r1, .L552+156
 6524 382c FEFFFFEB 		bl	CyU3PDebugPrint
 6525              	.LVL538:
 6526              	.L507:
 6527              	.LBB263:
 6528              	.LBB264:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6529              		.loc 1 1246 0
 6530 3830 B4139FE5 		ldr	r1, .L552+108
 6531 3834 0400A0E3 		mov	r0, #4
 6532 3838 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6533              		.loc 1 1247 0
 6534 383c FA0FA0E3 		mov	r0, #1000
 6535 3840 FEFFFFEB 		bl	_tx_thread_sleep
 6536 3844 F9FFFFEA 		b	.L507
 6537              	.LVL539:
 6538              	.L546:
 6539              	.LBE264:
 6540              	.LBE263:
2315:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6541              		.loc 1 2315 0
 6542 3848 0400A0E3 		mov	r0, #4
 6543              	.LVL540:
 6544 384c CC139FE5 		ldr	r1, .L552+160
 6545 3850 FEFFFFEB 		bl	CyU3PDebugPrint
 6546              	.LVL541:
 6547              	.L505:
 6548              	.LBB265:
 6549              	.LBB266:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6550              		.loc 1 1246 0
 6551 3854 90139FE5 		ldr	r1, .L552+108
 6552 3858 0400A0E3 		mov	r0, #4
 6553 385c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6554              		.loc 1 1247 0
 6555 3860 FA0FA0E3 		mov	r0, #1000
 6556 3864 FEFFFFEB 		bl	_tx_thread_sleep
 6557 3868 F9FFFFEA 		b	.L505
 6558              	.LVL542:
 6559              	.L540:
 6560              	.LBE266:
 6561              	.LBE265:
 6562              	.LBB267:
 6563              	.LBB258:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6564              		.loc 1 1970 0
 6565 386c 0400A0E3 		mov	r0, #4
 6566              	.LVL543:
 6567 3870 AC139FE5 		ldr	r1, .L552+164
 6568 3874 0820A0E1 		mov	r2, r8
 6569 3878 FEFFFFEB 		bl	CyU3PDebugPrint
 6570              	.L489:
 6571              	.LBB245:
 6572              	.LBB246:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6573              		.loc 1 1246 0
 6574 387c 68139FE5 		ldr	r1, .L552+108
 6575 3880 0400A0E3 		mov	r0, #4
 6576 3884 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6577              		.loc 1 1247 0
 6578 3888 FA0FA0E3 		mov	r0, #1000
 6579 388c FEFFFFEB 		bl	_tx_thread_sleep
 6580 3890 F9FFFFEA 		b	.L489
 6581              	.LVL544:
 6582              	.L539:
 6583              	.LBE246:
 6584              	.LBE245:
1949:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6585              		.loc 1 1949 0
 6586 3894 0400A0E3 		mov	r0, #4
 6587              	.LVL545:
 6588 3898 58139FE5 		ldr	r1, .L552+120
 6589 389c 0320A0E1 		mov	r2, r3
 6590 38a0 FEFFFFEB 		bl	CyU3PDebugPrint
 6591              	.LVL546:
 6592              	.L487:
 6593              	.LBB247:
 6594              	.LBB248:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6595              		.loc 1 1246 0
 6596 38a4 40139FE5 		ldr	r1, .L552+108
 6597 38a8 0400A0E3 		mov	r0, #4
 6598 38ac FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6599              		.loc 1 1247 0
 6600 38b0 FA0FA0E3 		mov	r0, #1000
 6601 38b4 FEFFFFEB 		bl	_tx_thread_sleep
 6602 38b8 F9FFFFEA 		b	.L487
 6603              	.LVL547:
 6604              	.L538:
 6605              	.LBE248:
 6606              	.LBE247:
1904:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6607              		.loc 1 1904 0
 6608 38bc 0400A0E3 		mov	r0, #4
 6609 38c0 60139FE5 		ldr	r1, .L552+168
 6610 38c4 0420A0E1 		mov	r2, r4
 6611 38c8 FEFFFFEB 		bl	CyU3PDebugPrint
 6612              	.L485:
 6613              	.LBB249:
 6614              	.LBB250:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6615              		.loc 1 1246 0
 6616 38cc 18139FE5 		ldr	r1, .L552+108
 6617 38d0 0400A0E3 		mov	r0, #4
 6618 38d4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6619              		.loc 1 1247 0
 6620 38d8 FA0FA0E3 		mov	r0, #1000
 6621 38dc FEFFFFEB 		bl	_tx_thread_sleep
 6622 38e0 F9FFFFEA 		b	.L485
 6623              	.LVL548:
 6624              	.L537:
 6625              	.LBE250:
 6626              	.LBE249:
1884:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6627              		.loc 1 1884 0
 6628 38e4 0400A0E3 		mov	r0, #4
 6629              	.LVL549:
 6630 38e8 3C139FE5 		ldr	r1, .L552+172
 6631 38ec FEFFFFEB 		bl	CyU3PDebugPrint
 6632              	.LVL550:
 6633              	.L483:
 6634              	.LBB251:
 6635              	.LBB252:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6636              		.loc 1 1246 0
 6637 38f0 F4129FE5 		ldr	r1, .L552+108
 6638 38f4 0400A0E3 		mov	r0, #4
 6639 38f8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6640              		.loc 1 1247 0
 6641 38fc FA0FA0E3 		mov	r0, #1000
 6642 3900 FEFFFFEB 		bl	_tx_thread_sleep
 6643 3904 F9FFFFEA 		b	.L483
 6644              	.LVL551:
 6645              	.L542:
 6646              	.LBE252:
 6647              	.LBE251:
2000:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6648              		.loc 1 2000 0
 6649 3908 0400A0E3 		mov	r0, #4
 6650              	.LVL552:
 6651 390c 1C139FE5 		ldr	r1, .L552+176
 6652 3910 FEFFFFEB 		bl	CyU3PDebugPrint
 6653              	.LVL553:
 6654              	.L493:
 6655              	.LBB253:
 6656              	.LBB254:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6657              		.loc 1 1246 0
 6658 3914 D0129FE5 		ldr	r1, .L552+108
 6659 3918 0400A0E3 		mov	r0, #4
 6660 391c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6661              		.loc 1 1247 0
 6662 3920 FA0FA0E3 		mov	r0, #1000
 6663 3924 FEFFFFEB 		bl	_tx_thread_sleep
 6664 3928 F9FFFFEA 		b	.L493
 6665              	.LVL554:
 6666              	.L541:
 6667              	.LBE254:
 6668              	.LBE253:
1977:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6669              		.loc 1 1977 0
 6670 392c 040080E2 		add	r0, r0, #4
 6671 3930 FC129FE5 		ldr	r1, .L552+180
 6672 3934 FEFFFFEB 		bl	CyU3PDebugPrint
 6673              	.LVL555:
 6674              	.L491:
 6675              	.LBB255:
 6676              	.LBB256:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6677              		.loc 1 1246 0
 6678 3938 AC129FE5 		ldr	r1, .L552+108
 6679 393c 0400A0E3 		mov	r0, #4
 6680 3940 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6681              		.loc 1 1247 0
 6682 3944 FA0FA0E3 		mov	r0, #1000
 6683 3948 FEFFFFEB 		bl	_tx_thread_sleep
 6684 394c F9FFFFEA 		b	.L491
 6685              	.LVL556:
 6686              	.L545:
 6687              	.LBE256:
 6688              	.LBE255:
 6689              	.LBE258:
 6690              	.LBE267:
2352:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6691              		.loc 1 2352 0
 6692 3950 88029FE5 		ldr	r0, .L552+96
 6693 3954 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6694              	.LVL557:
2353:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6695              		.loc 1 2353 0
 6696 3958 000050E3 		cmp	r0, #0
 6697 395c 0200001A 		bne	.L525
2359:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6698              		.loc 1 2359 0
 6699 3960 8300A0E3 		mov	r0, #131
 6700              	.LVL558:
 6701 3964 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6702 3968 38FFFFEA 		b	.L509
 6703              	.L525:
 6704              	.LBB268:
 6705              	.LBB269:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6706              		.loc 1 1246 0
 6707 396c 78129FE5 		ldr	r1, .L552+108
 6708 3970 0400A0E3 		mov	r0, #4
 6709 3974 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6710              		.loc 1 1247 0
 6711 3978 FA0FA0E3 		mov	r0, #1000
 6712 397c FEFFFFEB 		bl	_tx_thread_sleep
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6713              		.loc 1 1246 0
 6714 3980 64129FE5 		ldr	r1, .L552+108
 6715 3984 0400A0E3 		mov	r0, #4
 6716 3988 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6717              		.loc 1 1247 0
 6718 398c FA0FA0E3 		mov	r0, #1000
 6719 3990 FEFFFFEB 		bl	_tx_thread_sleep
 6720 3994 F4FFFFEA 		b	.L525
 6721              	.L508:
 6722              	.LBE269:
 6723              	.LBE268:
2367:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6724              		.loc 1 2367 0
 6725 3998 00C0E0E3 		mvn	ip, #0
 6726 399c 0110A0E3 		mov	r1, #1
 6727 39a0 0220A0E3 		mov	r2, #2
 6728 39a4 B4308DE2 		add	r3, sp, #180
 6729 39a8 DC019FE5 		ldr	r0, .L552+12
 6730 39ac 00C08DE5 		str	ip, [sp, #0]
 6731 39b0 FEFFFFEB 		bl	_txe_event_flags_get
2371:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6732              		.loc 1 2371 0
 6733 39b4 0420A0E1 		mov	r2, r4
 6734 39b8 20029FE5 		ldr	r0, .L552+96
 6735 39bc 0410A0E1 		mov	r1, r4
 6736 39c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6737              	.LVL559:
2372:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6738              		.loc 1 2372 0
 6739 39c4 002050E2 		subs	r2, r0, #0
 6740 39c8 2F00001A 		bne	.L548
2380:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6741              		.loc 1 2380 0
 6742 39cc 383095E5 		ldr	r3, [r5, #56]
 6743 39d0 000053E3 		cmp	r3, #0
 6744 39d4 5800001A 		bne	.L514
2383:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6745              		.loc 1 2383 0
 6746 39d8 3010A0E3 		mov	r1, #48
 6747 39dc 0120A0E3 		mov	r2, #1
 6748 39e0 823083E2 		add	r3, r3, #130
 6749 39e4 2100A0E3 		mov	r0, #33
 6750              	.LVL560:
 6751 39e8 FEFFFFEB 		bl	SensorSetIrisControl
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
 6752              		.loc 1 2384 0
 6753 39ec 7D0FA0E3 		mov	r0, #500
 6754 39f0 FEFFFFEB 		bl	_tx_thread_sleep
2385:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6755              		.loc 1 2385 0
 6756 39f4 3010A0E3 		mov	r1, #48
 6757 39f8 0220A0E3 		mov	r2, #2
 6758 39fc 5230A0E3 		mov	r3, #82
 6759 3a00 2500A0E3 		mov	r0, #37
 6760 3a04 FEFFFFEB 		bl	SensorSetIrisControl
2386:../uvc.c      ****                     CyU3PThreadSleep(500);
 6761              		.loc 1 2386 0
 6762 3a08 7D0FA0E3 		mov	r0, #500
 6763 3a0c FEFFFFEB 		bl	_tx_thread_sleep
2387:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
 6764              		.loc 1 2387 0
 6765 3a10 3010A0E3 		mov	r1, #48
 6766 3a14 0A20A0E3 		mov	r2, #10
 6767 3a18 8230A0E3 		mov	r3, #130
 6768 3a1c 2300A0E3 		mov	r0, #35
 6769 3a20 FEFFFFEB 		bl	SensorSetIrisControl
2388:../uvc.c      ****                    	CyU3PThreadSleep(300);
 6770              		.loc 1 2388 0
 6771 3a24 4B0FA0E3 		mov	r0, #300
 6772 3a28 FEFFFFEB 		bl	_tx_thread_sleep
2389:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6773              		.loc 1 2389 0
 6774 3a2c 3010A0E3 		mov	r1, #48
 6775 3a30 0420A0E1 		mov	r2, r4
 6776 3a34 8230A0E3 		mov	r3, #130
 6777 3a38 2100A0E3 		mov	r0, #33
 6778 3a3c FEFFFFEB 		bl	SensorSetIrisControl
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
 6779              		.loc 1 2390 0
 6780 3a40 7D0FA0E3 		mov	r0, #500
 6781 3a44 FEFFFFEB 		bl	_tx_thread_sleep
2391:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6782              		.loc 1 2391 0
 6783 3a48 5230A0E3 		mov	r3, #82
 6784 3a4c 3010A0E3 		mov	r1, #48
 6785 3a50 0420A0E1 		mov	r2, r4
 6786 3a54 2500A0E3 		mov	r0, #37
 6787 3a58 FEFFFFEB 		bl	SensorSetIrisControl
2392:../uvc.c      ****                     CyU3PThreadSleep(500);
 6788              		.loc 1 2392 0
 6789 3a5c 7D0FA0E3 		mov	r0, #500
 6790 3a60 FEFFFFEB 		bl	_tx_thread_sleep
 6791              	.LVL561:
 6792              	.LBB270:
 6793              	.LBB272:
2141:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6794              		.loc 1 2141 0
 6795 3a64 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6796 3a68 030053E3 		cmp	r3, #3
 6797 3a6c 2B00000A 		beq	.L549
2146:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6798              		.loc 1 2146 0
 6799 3a70 020053E3 		cmp	r3, #2
 6800 3a74 0D00000A 		beq	.L550
 6801              	.LVL562:
 6802              	.L517:
 6803              	.LBE272:
 6804              	.LBE270:
2394:../uvc.c      ****                     gpif_initialized = CyTrue;
 6805              		.loc 1 2394 0
 6806 3a78 0110A0E3 		mov	r1, #1
2395:../uvc.c      ****                     CyU3PThreadSleep(200);
 6807              		.loc 1 2395 0
 6808 3a7c C800A0E3 		mov	r0, #200
2394:../uvc.c      ****                     gpif_initialized = CyTrue;
 6809              		.loc 1 2394 0
 6810 3a80 381086E5 		str	r1, [r6, #56]
2395:../uvc.c      ****                     CyU3PThreadSleep(200);
 6811              		.loc 1 2395 0
 6812 3a84 FEFFFFEB 		bl	_tx_thread_sleep
 6813 3a88 BEFEFFEA 		b	.L501
 6814              	.LVL563:
 6815              	.L548:
2375:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6816              		.loc 1 2375 0
 6817 3a8c 0400A0E3 		mov	r0, #4
 6818              	.LVL564:
 6819 3a90 A0119FE5 		ldr	r1, .L552+184
 6820 3a94 FEFFFFEB 		bl	CyU3PDebugPrint
 6821              	.LVL565:
 6822              	.L513:
 6823              	.LBB278:
 6824              	.LBB279:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6825              		.loc 1 1246 0
 6826 3a98 4C119FE5 		ldr	r1, .L552+108
 6827 3a9c 0400A0E3 		mov	r0, #4
 6828 3aa0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6829              		.loc 1 1247 0
 6830 3aa4 FA0FA0E3 		mov	r0, #1000
 6831 3aa8 FEFFFFEB 		bl	_tx_thread_sleep
 6832 3aac F9FFFFEA 		b	.L513
 6833              	.LVL566:
 6834              	.L550:
 6835              	.LBE279:
 6836              	.LBE278:
 6837              	.LBB280:
 6838              	.LBB271:
2148:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6839              		.loc 1 2148 0
 6840 3ab0 84119FE5 		ldr	r1, .L552+188
 6841 3ab4 0100A0E3 		mov	r0, #1
 6842 3ab8 FEFFFFEB 		bl	CyU3PDebugPrint
2149:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6843              		.loc 1 2149 0
 6844 3abc 7C019FE5 		ldr	r0, .L552+192
 6845 3ac0 FEFFFFEB 		bl	CyU3PGpifLoad
 6846 3ac4 0020A0E1 		mov	r2, r0
 6847              	.LVL567:
 6848              	.L516:
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6849              		.loc 1 2151 0
 6850 3ac8 000052E3 		cmp	r2, #0
 6851 3acc 2200001A 		bne	.L551
2159:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6852              		.loc 1 2159 0
 6853 3ad0 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6854 3ad4 030053E3 		cmp	r3, #3
 6855 3ad8 0100000A 		beq	.L526
2163:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6856              		.loc 1 2163 0
 6857 3adc 020053E3 		cmp	r3, #2
 6858 3ae0 E4FFFF1A 		bne	.L517
 6859              	.L526:
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6860              		.loc 1 2165 0
 6861 3ae4 0200A0E1 		mov	r0, r2
 6862              	.LVL568:
 6863 3ae8 0210A0E1 		mov	r1, r2
 6864 3aec FEFFFFEB 		bl	CyU3PGpifSMStart
 6865              	.LVL569:
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6866              		.loc 1 2167 0
 6867 3af0 000050E3 		cmp	r0, #0
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6868              		.loc 1 2165 0
 6869 3af4 0020A0E1 		mov	r2, r0
 6870              	.LVL570:
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6871              		.loc 1 2167 0
 6872 3af8 DEFFFF0A 		beq	.L517
2170:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6873              		.loc 1 2170 0
 6874 3afc 0400A0E3 		mov	r0, #4
 6875              	.LVL571:
 6876 3b00 3C119FE5 		ldr	r1, .L552+196
 6877 3b04 FEFFFFEB 		bl	CyU3PDebugPrint
 6878              	.LVL572:
 6879              	.L522:
 6880              	.LBB273:
 6881              	.LBB274:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6882              		.loc 1 1246 0
 6883 3b08 DC109FE5 		ldr	r1, .L552+108
 6884 3b0c 0400A0E3 		mov	r0, #4
 6885 3b10 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6886              		.loc 1 1247 0
 6887 3b14 FA0FA0E3 		mov	r0, #1000
 6888 3b18 FEFFFFEB 		bl	_tx_thread_sleep
 6889 3b1c F9FFFFEA 		b	.L522
 6890              	.LVL573:
 6891              	.L549:
 6892              	.LBE274:
 6893              	.LBE273:
2143:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6894              		.loc 1 2143 0
 6895 3b20 20119FE5 		ldr	r1, .L552+200
 6896 3b24 0100A0E3 		mov	r0, #1
 6897 3b28 FEFFFFEB 		bl	CyU3PDebugPrint
2144:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6898              		.loc 1 2144 0
 6899 3b2c 18019FE5 		ldr	r0, .L552+204
 6900 3b30 FEFFFFEB 		bl	CyU3PGpifLoad
 6901 3b34 0020A0E1 		mov	r2, r0
 6902              	.LVL574:
 6903 3b38 E2FFFFEA 		b	.L516
 6904              	.LVL575:
 6905              	.L514:
 6906              	.LBE271:
 6907              	.LBE280:
2402:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6908              		.loc 1 2402 0
 6909 3b3c 94009FE5 		ldr	r0, .L552+88
 6910              	.LVL576:
 6911 3b40 02E0A0E3 		mov	lr, #2
 6912 3b44 0410A0E1 		mov	r1, r4
 6913 3b48 0020A0E1 		mov	r2, r0
 6914              	.LVL577:
 6915 3b4c 0430A0E1 		mov	r3, r4
 6916 3b50 00E08DE5 		str	lr, [sp, #0]
 6917 3b54 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6918 3b58 8AFEFFEA 		b	.L501
 6919              	.LVL578:
 6920              	.L551:
 6921              	.LBB281:
 6922              	.LBB277:
2154:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6923              		.loc 1 2154 0
 6924 3b5c 0400A0E3 		mov	r0, #4
 6925              	.LVL579:
 6926 3b60 E8109FE5 		ldr	r1, .L552+208
 6927 3b64 FEFFFFEB 		bl	CyU3PDebugPrint
 6928              	.LVL580:
 6929              	.L519:
 6930              	.LBB275:
 6931              	.LBB276:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6932              		.loc 1 1246 0
 6933 3b68 7C109FE5 		ldr	r1, .L552+108
 6934 3b6c 0400A0E3 		mov	r0, #4
 6935 3b70 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6936              		.loc 1 1247 0
 6937 3b74 FA0FA0E3 		mov	r0, #1000
 6938 3b78 FEFFFFEB 		bl	_tx_thread_sleep
 6939 3b7c F9FFFFEA 		b	.L519
 6940              	.L553:
 6941              		.align	2
 6942              	.L552:
 6943 3b80 4C060000 		.word	.LC35
 6944 3b84 00C20100 		.word	115200
 6945 3b88 A0860100 		.word	100000
 6946 3b8c 00000000 		.word	.LANCHOR0
 6947 3b90 00000000 		.word	CyFxGpifCB
 6948 3b94 00000000 		.word	CyFxUVCApplnUSBSetupCB
 6949 3b98 00000000 		.word	CyFxUVCApplnUSBEventCB
 6950 3b9c 00000000 		.word	CyFxUSBDeviceDscr
 6951 3ba0 00000000 		.word	CyFxUSBDeviceDscrSS
 6952 3ba4 00000000 		.word	CyFxUSBDeviceQualDscr
 6953 3ba8 00000000 		.word	CyFxUSBBOSDscr
 6954 3bac 00000000 		.word	CyFxUSBHSConfigDscr
 6955 3bb0 00000000 		.word	CyFxUSBFSConfigDscr
 6956 3bb4 00000000 		.word	CyFxUSBSSConfigDscr
 6957 3bb8 00000000 		.word	CyFxUSBStringLangIDDscr
 6958 3bbc 00000000 		.word	CyFxUSBManufactureDscr
 6959 3bc0 00000000 		.word	CyFxUSBProductDscr
 6960 3bc4 013F0000 		.word	16129
 6961 3bc8 02030000 		.word	770
 6962 3bcc 00000000 		.word	glChHandleInterStat
 6963 3bd0 00000000 		.word	glInterStaBuffer
 6964 3bd4 03030000 		.word	771
 6965 3bd8 01010000 		.word	257
 6966 3bdc 00000000 		.word	CyFxUvcApplnDmaCallback
 6967 3be0 00000000 		.word	glChHandleUVCStream
 6968 3be4 00000000 		.word	.LANCHOR1
 6969 3be8 6C060000 		.word	.LC36
 6970 3bec D4010000 		.word	.LC12
 6971 3bf0 88060000 		.word	.LC37
 6972 3bf4 A4060000 		.word	.LC38
 6973 3bf8 74080000 		.word	.LC48
 6974 3bfc 50090000 		.word	.LC52
 6975 3c00 DC070000 		.word	.LC45
 6976 3c04 A8070000 		.word	.LC44
 6977 3c08 74070000 		.word	.LC43
 6978 3c0c 48070000 		.word	.LC42
 6979 3c10 1C070000 		.word	.LC41
 6980 3c14 F4060000 		.word	.LC40
 6981 3c18 D0060000 		.word	.LC39
 6982 3c1c A4090000 		.word	.LC54
 6983 3c20 78090000 		.word	.LC53
 6984 3c24 A8080000 		.word	.LC49
 6985 3c28 44080000 		.word	.LC47
 6986 3c2c 14080000 		.word	.LC46
 6987 3c30 20090000 		.word	.LC51
 6988 3c34 E8080000 		.word	.LC50
 6989 3c38 D8090000 		.word	.LC55
 6990 3c3c 1C0A0000 		.word	.LC57
 6991 3c40 2C000000 		.word	.LANCHOR2+44
 6992 3c44 640A0000 		.word	.LC59
 6993 3c48 0C0A0000 		.word	.LC56
 6994 3c4c 10000000 		.word	.LANCHOR2+16
 6995 3c50 2C0A0000 		.word	.LC58
 6996              	.LBE276:
 6997              	.LBE275:
 6998              	.LBE277:
 6999              	.LBE281:
 7000              		.cfi_endproc
 7001              	.LFE18:
 7003              		.align	2
 7004              		.global	CyFxUVCApplnI2CInit
 7006              	CyFxUVCApplnI2CInit:
 7007              	.LFB14:
1693:../uvc.c      **** {
 7008              		.loc 1 1693 0
 7009              		.cfi_startproc
 7010              		@ args = 0, pretend = 0, frame = 16
 7011              		@ frame_needed = 0, uses_anonymous_args = 0
 7012 3c54 04E02DE5 		str	lr, [sp, #-4]!
 7013              	.LCFI25:
 7014              		.cfi_def_cfa_offset 4
 7015 3c58 14D04DE2 		sub	sp, sp, #20
 7016              	.LCFI26:
 7017              		.cfi_def_cfa_offset 24
1697:../uvc.c      ****     status = CyU3PI2cInit ();
 7018              		.loc 1 1697 0
 7019              		.cfi_offset 14, -4
 7020 3c5c FEFFFFEB 		bl	CyU3PI2cInit
 7021              	.LVL581:
1698:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7022              		.loc 1 1698 0
 7023 3c60 002050E2 		subs	r2, r0, #0
 7024 3c64 0B00001A 		bne	.L559
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7025              		.loc 1 1705 0
 7026 3c68 70C09FE5 		ldr	ip, .L561
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7027              		.loc 1 1707 0
 7028 3c6c 0030E0E3 		mvn	r3, #0
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7029              		.loc 1 1710 0
 7030 3c70 0D00A0E1 		mov	r0, sp
 7031              	.LVL582:
 7032 3c74 0210A0E1 		mov	r1, r2
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7033              		.loc 1 1705 0
 7034 3c78 00C08DE5 		str	ip, [sp, #0]
1706:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7035              		.loc 1 1706 0
 7036 3c7c 0C008DE9 		stmib	sp, {r2, r3}	@ phole stm
1708:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7037              		.loc 1 1708 0
 7038 3c80 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7039              		.loc 1 1710 0
 7040 3c84 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7041              	.LVL583:
1711:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7042              		.loc 1 1711 0
 7043 3c88 000050E3 		cmp	r0, #0
 7044 3c8c 0A00001A 		bne	.L560
1716:../uvc.c      **** }
 7045              		.loc 1 1716 0
 7046 3c90 14D08DE2 		add	sp, sp, #20
 7047 3c94 04F09DE4 		ldmfd	sp!, {pc}
 7048              	.L559:
1700:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7049              		.loc 1 1700 0
 7050 3c98 0400A0E3 		mov	r0, #4
 7051              	.LVL584:
 7052 3c9c 40109FE5 		ldr	r1, .L561+4
 7053 3ca0 FEFFFFEB 		bl	CyU3PDebugPrint
 7054              	.LVL585:
 7055              	.L556:
 7056              	.LBB286:
 7057              	.LBB287:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7058              		.loc 1 1246 0
 7059 3ca4 3C109FE5 		ldr	r1, .L561+8
 7060 3ca8 0400A0E3 		mov	r0, #4
 7061 3cac FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 7062              		.loc 1 1247 0
 7063 3cb0 FA0FA0E3 		mov	r0, #1000
 7064 3cb4 FEFFFFEB 		bl	_tx_thread_sleep
 7065 3cb8 F9FFFFEA 		b	.L556
 7066              	.LVL586:
 7067              	.L560:
 7068              	.LBE287:
 7069              	.LBE286:
1713:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7070              		.loc 1 1713 0
 7071 3cbc 0400A0E3 		mov	r0, #4
 7072              	.LVL587:
 7073 3cc0 24109FE5 		ldr	r1, .L561+12
 7074 3cc4 FEFFFFEB 		bl	CyU3PDebugPrint
 7075              	.L558:
 7076              	.LBB288:
 7077              	.LBB289:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7078              		.loc 1 1246 0
 7079 3cc8 18109FE5 		ldr	r1, .L561+8
 7080 3ccc 0400A0E3 		mov	r0, #4
 7081 3cd0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 7082              		.loc 1 1247 0
 7083 3cd4 FA0FA0E3 		mov	r0, #1000
 7084 3cd8 FEFFFFEB 		bl	_tx_thread_sleep
 7085 3cdc F9FFFFEA 		b	.L558
 7086              	.L562:
 7087              		.align	2
 7088              	.L561:
 7089 3ce0 A0860100 		.word	100000
 7090 3ce4 6C060000 		.word	.LC36
 7091 3ce8 D4010000 		.word	.LC12
 7092 3cec 88060000 		.word	.LC37
 7093              	.LBE289:
 7094              	.LBE288:
 7095              		.cfi_endproc
 7096              	.LFE14:
 7098              		.align	2
 7099              		.global	CyFxApplicationDefine
 7101              	CyFxApplicationDefine:
 7102              	.LFB26:
3631:../uvc.c      **** }
3632:../uvc.c      **** 
3633:../uvc.c      **** 
3634:../uvc.c      **** /*
3635:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3636:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3637:../uvc.c      ****  */
3638:../uvc.c      **** void
3639:../uvc.c      **** CyFxApplicationDefine (
3640:../uvc.c      ****         void)
3641:../uvc.c      **** {
 7103              		.loc 1 3641 0
 7104              		.cfi_startproc
 7105              		@ args = 0, pretend = 0, frame = 40
 7106              		@ frame_needed = 0, uses_anonymous_args = 0
 7107              	.LVL588:
 7108 3cf0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7109              	.LCFI27:
 7110              		.cfi_def_cfa_offset 36
3642:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3643:../uvc.c      ****     uint32_t retThrdCreate;
3644:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3645:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3646:../uvc.c      **** 
3647:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3648:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7111              		.loc 1 3648 0
 7112 3cf4 010AA0E3 		mov	r0, #4096
3641:../uvc.c      **** {
 7113              		.loc 1 3641 0
 7114 3cf8 4CD04DE2 		sub	sp, sp, #76
 7115              	.LCFI28:
 7116              		.cfi_def_cfa_offset 112
 7117              		.loc 1 3648 0
 7118              		.cfi_offset 14, -4
 7119              		.cfi_offset 11, -8
 7120              		.cfi_offset 10, -12
 7121              		.cfi_offset 9, -16
 7122              		.cfi_offset 8, -20
 7123              		.cfi_offset 7, -24
 7124              		.cfi_offset 6, -28
 7125              		.cfi_offset 5, -32
 7126              		.cfi_offset 4, -36
 7127 3cfc FEFFFFEB 		bl	CyU3PMemAlloc
 7128 3d00 00A0A0E1 		mov	sl, r0
 7129              	.LVL589:
3649:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7130              		.loc 1 3649 0
 7131 3d04 010AA0E3 		mov	r0, #4096
 7132              	.LVL590:
 7133 3d08 FEFFFFEB 		bl	CyU3PMemAlloc
 7134 3d0c 00B0A0E1 		mov	fp, r0
 7135              	.LVL591:
3650:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7136              		.loc 1 3650 0
 7137 3d10 010AA0E3 		mov	r0, #4096
 7138              	.LVL592:
 7139 3d14 FEFFFFEB 		bl	CyU3PMemAlloc
3651:../uvc.c      **** 
3652:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7140              		.loc 1 3652 0
 7141 3d18 00005AE3 		cmp	sl, #0
 7142 3d1c 00005B13 		cmpne	fp, #0
 7143 3d20 0090A013 		movne	r9, #0
 7144 3d24 0190A003 		moveq	r9, #1
3650:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7145              		.loc 1 3650 0
 7146 3d28 24008DE5 		str	r0, [sp, #36]
 7147              	.LVL593:
 7148              		.loc 1 3652 0
 7149 3d2c 0000001A 		bne	.L567
 7150              	.LVL594:
 7151              	.L564:
 7152              	.L566:
 7153 3d30 FEFFFFEA 		b	.L566
 7154              	.L567:
 7155              		.loc 1 3652 0 is_stmt 0 discriminator 1
 7156 3d34 000050E3 		cmp	r0, #0
 7157 3d38 FCFFFF0A 		beq	.L564
3653:../uvc.c      ****         goto fatalErrorHandler;
3654:../uvc.c      **** 
3655:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3656:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7158              		.loc 1 3656 0 is_stmt 1
 7159 3d3c 28408DE2 		add	r4, sp, #40
 7160 3d40 0400A0E1 		mov	r0, r4
 7161 3d44 4010A0E3 		mov	r1, #64
 7162 3d48 18219FE5 		ldr	r2, .L568
 7163 3d4c FEFFFFEB 		bl	cmdbufCreate
 7164 3d50 0450A0E1 		mov	r5, r4
 7165 3d54 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7166 3d58 0C719FE5 		ldr	r7, .L568+4
3657:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7167              		.loc 1 3657 0
 7168 3d5c 0C819FE5 		ldr	r8, .L568+8
3656:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7169              		.loc 1 3656 0
 7170 3d60 07C0A0E1 		mov	ip, r7
 7171 3d64 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7172 3d68 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3658:../uvc.c      **** 
3659:../uvc.c      **** 	/****** initialize command descriptor ***********/
3660:../uvc.c      **** 	cmdquInit(cmdQuptr);
3661:../uvc.c      **** 	cmdquInit(statQuptr);
3662:../uvc.c      **** 
3663:../uvc.c      ****     /* Create the UVC application thread. */
3664:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7173              		.loc 1 3664 0
 7174 3d6c 0860A0E3 		mov	r6, #8
3656:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7175              		.loc 1 3656 0
 7176 3d70 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3657:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7177              		.loc 1 3657 0
 7178 3d74 F8209FE5 		ldr	r2, .L568+12
 7179 3d78 0400A0E1 		mov	r0, r4
 7180 3d7c 2010A0E3 		mov	r1, #32
 7181 3d80 FEFFFFEB 		bl	cmdbufCreate
 7182 3d84 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7183 3d88 08C0A0E1 		mov	ip, r8
 7184 3d8c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7185 3d90 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7186              		.loc 1 3664 0
 7187 3d94 0140A0E3 		mov	r4, #1
3657:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7188              		.loc 1 3657 0
 7189 3d98 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3660:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7190              		.loc 1 3660 0
 7191 3d9c 0700A0E1 		mov	r0, r7
 7192 3da0 FEFFFFEB 		bl	cmdquInit
3661:../uvc.c      **** 	cmdquInit(statQuptr);
 7193              		.loc 1 3661 0
 7194 3da4 0800A0E1 		mov	r0, r8
 7195 3da8 FEFFFFEB 		bl	cmdquInit
 7196              		.loc 1 3664 0
 7197 3dac A850A0E3 		mov	r5, #168
 7198 3db0 01CAA0E3 		mov	ip, #4096
 7199 3db4 BC009FE5 		ldr	r0, .L568+16
 7200 3db8 BC109FE5 		ldr	r1, .L568+20
 7201 3dbc BC209FE5 		ldr	r2, .L568+24
 7202 3dc0 0930A0E1 		mov	r3, r9
 7203 3dc4 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7204 3dc8 08608DE5 		str	r6, [sp, #8]
 7205 3dcc 0C608DE5 		str	r6, [sp, #12]
 7206 3dd0 10908DE5 		str	r9, [sp, #16]
 7207 3dd4 14408DE5 		str	r4, [sp, #20]
 7208 3dd8 18508DE5 		str	r5, [sp, #24]
 7209 3ddc FEFFFFEB 		bl	_txe_thread_create
 7210              	.LVL595:
3665:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3666:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3667:../uvc.c      ****             0,                                          /* No input parameter to thread */
3668:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3669:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3670:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3671:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3672:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3673:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3674:../uvc.c      ****             );
3675:../uvc.c      ****     if (retThrdCreate != 0)
 7211              		.loc 1 3675 0
 7212 3de0 00C050E2 		subs	ip, r0, #0
 7213 3de4 D1FFFF1A 		bne	.L564
3676:../uvc.c      ****     {
3677:../uvc.c      ****         goto fatalErrorHandler;
3678:../uvc.c      ****     }
3679:../uvc.c      **** 
3680:../uvc.c      ****     /* Create the control request handling thread. */
3681:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7214              		.loc 1 3681 0
 7215 3de8 0C30A0E1 		mov	r3, ip
 7216 3dec 027BA0E3 		mov	r7, #2048
 7217 3df0 8C009FE5 		ldr	r0, .L568+28
 7218              	.LVL596:
 7219 3df4 8C109FE5 		ldr	r1, .L568+32
 7220 3df8 8C209FE5 		ldr	r2, .L568+36
 7221 3dfc 10C08DE5 		str	ip, [sp, #16]
 7222 3e00 00B08DE5 		str	fp, [sp, #0]
 7223 3e04 04708DE5 		str	r7, [sp, #4]
 7224 3e08 08608DE5 		str	r6, [sp, #8]
 7225 3e0c 0C608DE5 		str	r6, [sp, #12]
 7226 3e10 14408DE5 		str	r4, [sp, #20]
 7227 3e14 18508DE5 		str	r5, [sp, #24]
 7228 3e18 FEFFFFEB 		bl	_txe_thread_create
 7229              	.LVL597:
3682:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3683:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3684:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3685:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3686:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3687:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3688:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3689:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3690:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3691:../uvc.c      ****             );
3692:../uvc.c      ****     if (retThrdCreate != 0)
 7230              		.loc 1 3692 0
 7231 3e1c 00C050E2 		subs	ip, r0, #0
 7232 3e20 C2FFFF1A 		bne	.L564
3693:../uvc.c      ****     {
3694:../uvc.c      ****         goto fatalErrorHandler;
3695:../uvc.c      ****     }
3696:../uvc.c      **** #if 1
3697:../uvc.c      ****     /* Create the I2C control command handling thread. */
3698:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7233              		.loc 1 3698 0
 7234 3e24 24E09DE5 		ldr	lr, [sp, #36]
 7235 3e28 60009FE5 		ldr	r0, .L568+40
 7236              	.LVL598:
 7237 3e2c 60109FE5 		ldr	r1, .L568+44
 7238 3e30 60209FE5 		ldr	r2, .L568+48
 7239 3e34 0C30A0E1 		mov	r3, ip
 7240 3e38 00E08DE5 		str	lr, [sp, #0]
 7241 3e3c 04708DE5 		str	r7, [sp, #4]
 7242 3e40 08608DE5 		str	r6, [sp, #8]
 7243 3e44 0C608DE5 		str	r6, [sp, #12]
 7244 3e48 10C08DE5 		str	ip, [sp, #16]
 7245 3e4c 14408DE5 		str	r4, [sp, #20]
 7246 3e50 18508DE5 		str	r5, [sp, #24]
 7247 3e54 FEFFFFEB 		bl	_txe_thread_create
 7248              	.LVL599:
3699:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3700:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3701:../uvc.c      ****             0,                                          /* No input parameter to thread */
3702:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3703:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3704:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3705:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3706:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3707:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3708:../uvc.c      ****             );
3709:../uvc.c      ****     if (retThrdCreate != 0)
 7249              		.loc 1 3709 0
 7250 3e58 000050E3 		cmp	r0, #0
 7251 3e5c B3FFFF1A 		bne	.L564
3710:../uvc.c      ****     {
3711:../uvc.c      ****         goto fatalErrorHandler;
3712:../uvc.c      ****     }
3713:../uvc.c      **** #endif
3714:../uvc.c      **** 
3715:../uvc.c      ****     return;
3716:../uvc.c      **** 
3717:../uvc.c      **** fatalErrorHandler:
3718:../uvc.c      ****     /* Add custom recovery or debug actions here */
3719:../uvc.c      ****     /* Loop indefinitely */
3720:../uvc.c      ****     while (1);
3721:../uvc.c      **** }
 7252              		.loc 1 3721 0
 7253 3e60 4CD08DE2 		add	sp, sp, #76
 7254 3e64 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7255              	.L569:
 7256              		.align	2
 7257              	.L568:
 7258 3e68 00000000 		.word	cmdQuMux
 7259 3e6c 00000000 		.word	cmdQu
 7260 3e70 00000000 		.word	statQu
 7261 3e74 00000000 		.word	staQuMux
 7262 3e78 9C000000 		.word	.LANCHOR0+156
 7263 3e7c 9C0A0000 		.word	.LC60
 7264 3e80 00000000 		.word	UVCAppThread_Entry
 7265 3e84 44010000 		.word	.LANCHOR0+324
 7266 3e88 B00A0000 		.word	.LC61
 7267 3e8c 00000000 		.word	UVCAppEP0Thread_Entry
 7268 3e90 EC010000 		.word	.LANCHOR0+492
 7269 3e94 C80A0000 		.word	.LC62
 7270 3e98 00000000 		.word	I2cAppThread_Entry
 7271              		.cfi_endproc
 7272              	.LFE26:
 7274              		.align	2
 7275              		.global	main
 7277              	main:
 7278              	.LFB27:
3722:../uvc.c      **** 
3723:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3724:../uvc.c      ****  * the ThreadX RTOS here.
3725:../uvc.c      ****  */
3726:../uvc.c      **** int
3727:../uvc.c      **** main (
3728:../uvc.c      ****         void)
3729:../uvc.c      **** {
 7279              		.loc 1 3729 0
 7280              		.cfi_startproc
 7281              		@ args = 0, pretend = 0, frame = 56
 7282              		@ frame_needed = 0, uses_anonymous_args = 0
 7283 3e9c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7284              	.LCFI29:
 7285              		.cfi_def_cfa_offset 12
3730:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3731:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3732:../uvc.c      **** 
3733:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3734:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3735:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3736:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3737:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3738:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7286              		.loc 1 3738 0
 7287 3ea0 0010A0E3 		mov	r1, #0
3729:../uvc.c      **** {
 7288              		.loc 1 3729 0
 7289 3ea4 3CD04DE2 		sub	sp, sp, #60
 7290              	.LCFI30:
 7291              		.cfi_def_cfa_offset 72
3735:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7292              		.loc 1 3735 0
 7293 3ea8 0220A0E3 		mov	r2, #2
3739:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7294              		.loc 1 3739 0
 7295 3eac 033081E2 		add	r3, r1, #3
3734:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7296              		.loc 1 3734 0
 7297 3eb0 0150A0E3 		mov	r5, #1
 7298              		.cfi_offset 14, -4
 7299              		.cfi_offset 5, -8
 7300              		.cfi_offset 4, -12
3740:../uvc.c      **** 
3741:../uvc.c      ****     /* Initialize the device */
3742:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7301              		.loc 1 3742 0
 7302 3eb4 28008DE2 		add	r0, sp, #40
3734:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7303              		.loc 1 3734 0
 7304 3eb8 28508DE5 		str	r5, [sp, #40]
3735:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7305              		.loc 1 3735 0
 7306 3ebc 2C20CDE5 		strb	r2, [sp, #44]
3736:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7307              		.loc 1 3736 0
 7308 3ec0 2D20CDE5 		strb	r2, [sp, #45]
3737:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7309              		.loc 1 3737 0
 7310 3ec4 2E20CDE5 		strb	r2, [sp, #46]
3738:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7311              		.loc 1 3738 0
 7312 3ec8 30108DE5 		str	r1, [sp, #48]
3739:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7313              		.loc 1 3739 0
 7314 3ecc 3430CDE5 		strb	r3, [sp, #52]
 7315              		.loc 1 3742 0
 7316 3ed0 FEFFFFEB 		bl	CyU3PDeviceInit
 7317              	.LVL600:
3743:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7318              		.loc 1 3743 0
 7319 3ed4 004050E2 		subs	r4, r0, #0
 7320 3ed8 0000000A 		beq	.L573
 7321              	.L571:
 7322              	.L572:
 7323 3edc FEFFFFEA 		b	.L572
 7324              	.L573:
3744:../uvc.c      ****     {
3745:../uvc.c      ****         goto handle_fatal_error;
3746:../uvc.c      ****     }
3747:../uvc.c      **** 
3748:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3749:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7325              		.loc 1 3749 0
 7326 3ee0 0410A0E1 		mov	r1, r4
 7327 3ee4 0420A0E1 		mov	r2, r4
 7328 3ee8 0500A0E1 		mov	r0, r5
 7329              	.LVL601:
 7330 3eec FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7331              	.LVL602:
3750:../uvc.c      **** 
3751:../uvc.c      ****     /* Configure the IO matrix for the device. */
3752:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3753:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3754:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3755:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3756:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3757:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3758:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3759:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3760:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3761:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3762:../uvc.c      **** 
3763:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7332              		.loc 1 3763 0
 7333 3ef0 0D00A0E1 		mov	r0, sp
3753:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7334              		.loc 1 3753 0
 7335 3ef4 1640CDE5 		strb	r4, [sp, #22]
3754:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7336              		.loc 1 3754 0
 7337 3ef8 18408DE5 		str	r4, [sp, #24]
3755:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7338              		.loc 1 3755 0
 7339 3efc 1C408DE5 		str	r4, [sp, #28]
3756:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7340              		.loc 1 3756 0
 7341 3f00 20408DE5 		str	r4, [sp, #32]
3757:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7342              		.loc 1 3757 0
 7343 3f04 24408DE5 		str	r4, [sp, #36]
3760:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7344              		.loc 1 3760 0
 7345 3f08 0C408DE5 		str	r4, [sp, #12]
3761:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7346              		.loc 1 3761 0
 7347 3f0c 10408DE5 		str	r4, [sp, #16]
3752:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7348              		.loc 1 3752 0
 7349 3f10 00508DE5 		str	r5, [sp, #0]
3758:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7350              		.loc 1 3758 0
 7351 3f14 04508DE5 		str	r5, [sp, #4]
3759:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7352              		.loc 1 3759 0
 7353 3f18 08508DE5 		str	r5, [sp, #8]
 7354              		.loc 1 3763 0
 7355 3f1c FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7356              	.LVL603:
3764:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7357              		.loc 1 3764 0
 7358 3f20 004050E2 		subs	r4, r0, #0
 7359 3f24 ECFFFF1A 		bne	.L571
3765:../uvc.c      ****     {
3766:../uvc.c      ****         goto handle_fatal_error;
3767:../uvc.c      ****     }
3768:../uvc.c      **** 
3769:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3770:../uvc.c      ****     CyU3PKernelEntry ();
 7360              		.loc 1 3770 0
 7361 3f28 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7362              	.LVL604:
3771:../uvc.c      **** 
3772:../uvc.c      ****     /* Dummy return to make the compiler happy */
3773:../uvc.c      ****     return 0;
3774:../uvc.c      **** 
3775:../uvc.c      **** handle_fatal_error:
3776:../uvc.c      ****     /* Cannot recover from this error. */
3777:../uvc.c      ****     while (1);
3778:../uvc.c      **** }
 7363              		.loc 1 3778 0
 7364 3f2c 0400A0E1 		mov	r0, r4
 7365 3f30 3CD08DE2 		add	sp, sp, #60
 7366 3f34 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7367              		.cfi_endproc
 7368              	.LFE27:
 7370              		.global	CyFxGpifTransition
 7371              		.global	CyFxGpifWavedata
 7372              		.global	CyFxGpifWavedataPosition
 7373              		.global	CyFxGpifRegValue
 7374              		.global	CyFxGpifConfig
 7375              		.global	CyFxGpifTransition_usb2
 7376              		.global	CyFxGpifWavedata_usb2
 7377              		.global	CyFxGpifWavedataPosition_usb2
 7378              		.global	CyFxGpifRegValue_usb2
 7379              		.global	CyFxGpifConfig_usb2
 7380              		.global	snapButFlag
 7381              		.global	testSnap
 7382              		.global	fb
 7383              		.global	pb
 7384              		.global	pbc
 7385              		.global	fbbak
 7386              		.global	pbbak
 7387              		.global	pbcbak
 7388              		.global	pbcpbak
 7389              		.global	isUsbConnected
 7390              		.global	usbSpeed
 7391              		.global	clearFeatureRqtReceived
 7392              		.global	streamingStarted
 7393              		.global	glProbeCtrl
 7394              		.global	glProbeStilCtrl
 7395              		.global	glProbeCtrl20
 7396              		.global	glProbeStilCtrl20
 7397              		.global	glUVCHeader
 7398              		.comm	glChHandleUVCStream,220,4
 7399              		.comm	glChHandleStillStream,220,4
 7400              		.comm	glChHandleInterStat,160,4
 7401              		.comm	glInterStaBuffer,4,4
 7402              		.comm	cmdQu,32,4
 7403              		.comm	statQu,32,4
 7404              		.comm	cmdQuMux,56,4
 7405              		.comm	staQuMux,56,4
 7406              		.comm	timMux,56,4
 7407              		.comm	bmReqType,1,1
 7408              		.comm	bRequest,1,1
 7409              		.comm	wValue,2,2
 7410              		.comm	wIndex,2,2
 7411              		.comm	wLength,2,2
 7412              		.comm	posTick,4,4
 7413              		.comm	I2CCmdTimer,44,4
 7414              		.section	.rodata
 7415              		.align	2
 7416              		.set	.LANCHOR2,. + 0
 7419              	ExTime:
 7420 0000 9C       		.byte	-100
 7421 0001 00       		.byte	0
 7422 0002 4E       		.byte	78
 7423 0003 00       		.byte	0
 7424 0004 27       		.byte	39
 7425 0005 00       		.byte	0
 7426 0006 14       		.byte	20
 7427 0007 00       		.byte	0
 7428 0008 0A       		.byte	10
 7429 0009 00       		.byte	0
 7430 000a 05       		.byte	5
 7431 000b 00       		.byte	0
 7432 000c 02       		.byte	2
 7433 000d 00       		.byte	0
 7434 000e 01       		.byte	1
 7435 000f 00       		.byte	0
 7438              	CyFxGpifConfig:
 7439 0010 0F00     		.short	15
 7440 0012 0000     		.space	2
 7441 0014 00000000 		.word	CyFxGpifWavedata
 7442 0018 00000000 		.word	CyFxGpifWavedataPosition
 7443 001c 0500     		.short	5
 7444 001e 0000     		.space	2
 7445 0020 00000000 		.word	CyFxGpifTransition
 7446 0024 4C00     		.short	76
 7447 0026 0000     		.space	2
 7448 0028 00000000 		.word	CyFxGpifRegValue
 7451              	CyFxGpifConfig_usb2:
 7452 002c 9300     		.short	147
 7453 002e 0000     		.space	2
 7454 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7455 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7456 0038 0800     		.short	8
 7457 003a 0000     		.space	2
 7458 003c 00000000 		.word	CyFxGpifTransition_usb2
 7459 0040 4C00     		.short	76
 7460 0042 0000     		.space	2
 7461 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7462              		.data
 7463              		.align	2
 7464              		.set	.LANCHOR1,. + 0
 7467              	ExUCtrlParArry:
 7468 0000 00       		.byte	0
 7469 0001 00       		.byte	0
 7470 0002 04       		.byte	4
 7471 0003 01       		.byte	1
 7472 0004 00       		.byte	0
 7473 0005 38       		.byte	56
 7474 0006 01       		.byte	1
 7475 0007 01       		.byte	1
 7476 0008 00       		.byte	0
 7477 0009 03       		.byte	3
 7478 000a 00       		.byte	0
 7479 000b 4E       		.byte	78
 7480 000c 00       		.byte	0
 7481 000d 4E       		.byte	78
 7482 000e 00       		.byte	0
 7483 000f 30       		.byte	48
 7484 0010 01       		.byte	1
 7485 0011 00       		.byte	0
 7486 0012 00       		.byte	0
 7487 0013 00000000 		.space	5
 7487      00
 7488 0018 00       		.byte	0
 7489 0019 00       		.byte	0
 7490 001a 01       		.byte	1
 7491 001b 00       		.byte	0
 7492 001c 00       		.byte	0
 7493 001d 00       		.byte	0
 7494 001e 00       		.byte	0
 7495 001f 01       		.byte	1
 7496 0020 00       		.byte	0
 7497 0021 03       		.byte	3
 7498 0022 00       		.byte	0
 7499 0023 00       		.byte	0
 7500 0024 00       		.byte	0
 7501 0025 00       		.byte	0
 7502 0026 00       		.byte	0
 7503 0027 30       		.byte	48
 7504 0028 01       		.byte	1
 7505 0029 00       		.byte	0
 7506 002a 00       		.byte	0
 7507 002b 00000000 		.space	5
 7507      00
 7508 0030 00       		.byte	0
 7509 0031 00       		.byte	0
 7510 0032 02       		.byte	2
 7511 0033 00       		.byte	0
 7512 0034 00       		.byte	0
 7513 0035 FF       		.byte	-1
 7514 0036 00       		.byte	0
 7515 0037 01       		.byte	1
 7516 0038 00       		.byte	0
 7517 0039 03       		.byte	3
 7518 003a 00       		.byte	0
 7519 003b 01       		.byte	1
 7520 003c 00       		.byte	0
 7521 003d 00       		.byte	0
 7522 003e 00       		.byte	0
 7523 003f 30       		.byte	48
 7524 0040 01       		.byte	1
 7525 0041 01       		.byte	1
 7526 0042 00       		.byte	0
 7527 0043 00000000 		.space	5
 7527      00
 7528 0048 00       		.byte	0
 7529 0049 00       		.byte	0
 7530 004a 02       		.byte	2
 7531 004b 00       		.byte	0
 7532 004c 00       		.byte	0
 7533 004d 00       		.byte	0
 7534 004e 00       		.byte	0
 7535 004f 00       		.byte	0
 7536 0050 00       		.byte	0
 7537 0051 03       		.byte	3
 7538 0052 00       		.byte	0
 7539 0053 00       		.byte	0
 7540 0054 00       		.byte	0
 7541 0055 00       		.byte	0
 7542 0056 00       		.byte	0
 7543 0057 30       		.byte	48
 7544 0058 01       		.byte	1
 7545 0059 01       		.byte	1
 7546 005a 00       		.byte	0
 7547 005b 00000000 		.space	5
 7547      00
 7548 0060 13       		.byte	19
 7549 0061 14       		.byte	20
 7550 0062 02       		.byte	2
 7551 0063 01       		.byte	1
 7552 0064 00       		.byte	0
 7553 0065 03       		.byte	3
 7554 0066 00       		.byte	0
 7555 0067 01       		.byte	1
 7556 0068 00       		.byte	0
 7557 0069 03       		.byte	3
 7558 006a 00       		.byte	0
 7559 006b 23       		.byte	35
 7560 006c 37       		.byte	55
 7561 006d 23       		.byte	35
 7562 006e 37       		.byte	55
 7563 006f 30       		.byte	48
 7564 0070 01       		.byte	1
 7565 0071 00       		.byte	0
 7566 0072 00       		.byte	0
 7567 0073 00000000 		.space	5
 7567      00
 7568 0078 11       		.byte	17
 7569 0079 00       		.byte	0
 7570 007a 02       		.byte	2
 7571 007b 01       		.byte	1
 7572 007c 00       		.byte	0
 7573 007d 03       		.byte	3
 7574 007e 00       		.byte	0
 7575 007f 01       		.byte	1
 7576 0080 00       		.byte	0
 7577 0081 03       		.byte	3
 7578 0082 00       		.byte	0
 7579 0083 01       		.byte	1
 7580 0084 00       		.byte	0
 7581 0085 01       		.byte	1
 7582 0086 00       		.byte	0
 7583 0087 30       		.byte	48
 7584 0088 01       		.byte	1
 7585 0089 01       		.byte	1
 7586 008a 00       		.byte	0
 7587 008b 00000000 		.space	5
 7587      00
 7588 0090 17       		.byte	23
 7589 0091 00       		.byte	0
 7590 0092 01       		.byte	1
 7591 0093 01       		.byte	1
 7592 0094 00       		.byte	0
 7593 0095 02       		.byte	2
 7594 0096 00       		.byte	0
 7595 0097 01       		.byte	1
 7596 0098 00       		.byte	0
 7597 0099 03       		.byte	3
 7598 009a 00       		.byte	0
 7599 009b 00       		.byte	0
 7600 009c 00       		.byte	0
 7601 009d 00       		.byte	0
 7602 009e 00       		.byte	0
 7603 009f 30       		.byte	48
 7604 00a0 01       		.byte	1
 7605 00a1 01       		.byte	1
 7606 00a2 00       		.byte	0
 7607 00a3 00000000 		.space	5
 7607      00
 7608 00a8 00       		.byte	0
 7609 00a9 00       		.byte	0
 7610 00aa 04       		.byte	4
 7611 00ab 01       		.byte	1
 7612 00ac 00       		.byte	0
 7613 00ad 38       		.byte	56
 7614 00ae 01       		.byte	1
 7615 00af 01       		.byte	1
 7616 00b0 00       		.byte	0
 7617 00b1 03       		.byte	3
 7618 00b2 00       		.byte	0
 7619 00b3 4E       		.byte	78
 7620 00b4 00       		.byte	0
 7621 00b5 4E       		.byte	78
 7622 00b6 00       		.byte	0
 7623 00b7 30       		.byte	48
 7624 00b8 01       		.byte	1
 7625 00b9 00       		.byte	0
 7626 00ba 00       		.byte	0
 7627 00bb 00000000 		.space	5
 7627      00
 7628 00c0 00       		.byte	0
 7629 00c1 00       		.byte	0
 7630 00c2 01       		.byte	1
 7631 00c3 00       		.byte	0
 7632 00c4 00       		.byte	0
 7633 00c5 00       		.byte	0
 7634 00c6 00       		.byte	0
 7635 00c7 01       		.byte	1
 7636 00c8 00       		.byte	0
 7637 00c9 03       		.byte	3
 7638 00ca 00       		.byte	0
 7639 00cb 00       		.byte	0
 7640 00cc 00       		.byte	0
 7641 00cd 00       		.byte	0
 7642 00ce 00       		.byte	0
 7643 00cf 30       		.byte	48
 7644 00d0 01       		.byte	1
 7645 00d1 00       		.byte	0
 7646 00d2 00       		.byte	0
 7647 00d3 00000000 		.space	5
 7647      00
 7648 00d8 00       		.byte	0
 7649 00d9 00       		.byte	0
 7650 00da 02       		.byte	2
 7651 00db 00       		.byte	0
 7652 00dc 00       		.byte	0
 7653 00dd 05       		.byte	5
 7654 00de 00       		.byte	0
 7655 00df 01       		.byte	1
 7656 00e0 00       		.byte	0
 7657 00e1 03       		.byte	3
 7658 00e2 00       		.byte	0
 7659 00e3 00       		.byte	0
 7660 00e4 00       		.byte	0
 7661 00e5 00       		.byte	0
 7662 00e6 00       		.byte	0
 7663 00e7 30       		.byte	48
 7664 00e8 01       		.byte	1
 7665 00e9 00       		.byte	0
 7666 00ea 00       		.byte	0
 7667 00eb 00000000 		.space	5
 7667      00
 7668 00f0 00       		.byte	0
 7669 00f1 00       		.byte	0
 7670 00f2 03       		.byte	3
 7671 00f3 00       		.byte	0
 7672 00f4 00       		.byte	0
 7673 00f5 0A       		.byte	10
 7674 00f6 00       		.byte	0
 7675 00f7 01       		.byte	1
 7676 00f8 00       		.byte	0
 7677 00f9 03       		.byte	3
 7678 00fa 00       		.byte	0
 7679 00fb 00       		.byte	0
 7680 00fc 00       		.byte	0
 7681 00fd 00       		.byte	0
 7682 00fe 00       		.byte	0
 7683 00ff 30       		.byte	48
 7684 0100 01       		.byte	1
 7685 0101 00       		.byte	0
 7686 0102 00       		.byte	0
 7687 0103 00000000 		.space	5
 7687      00
 7688 0108 00       		.byte	0
 7689 0109 00       		.byte	0
 7690 010a 02       		.byte	2
 7691 010b 00       		.byte	0
 7692 010c 00       		.byte	0
 7693 010d 40       		.byte	64
 7694 010e 00       		.byte	0
 7695 010f 01       		.byte	1
 7696 0110 00       		.byte	0
 7697 0111 03       		.byte	3
 7698 0112 00       		.byte	0
 7699 0113 0F       		.byte	15
 7700 0114 11       		.byte	17
 7701 0115 00       		.byte	0
 7702 0116 00       		.byte	0
 7703 0117 30       		.byte	48
 7704 0118 01       		.byte	1
 7705 0119 00       		.byte	0
 7706 011a 00       		.byte	0
 7707 011b 00000000 		.space	5
 7707      00
 7708 0120 00       		.byte	0
 7709 0121 00       		.byte	0
 7710 0122 02       		.byte	2
 7711 0123 00       		.byte	0
 7712 0124 00       		.byte	0
 7713 0125 64       		.byte	100
 7714 0126 00       		.byte	0
 7715 0127 01       		.byte	1
 7716 0128 00       		.byte	0
 7717 0129 03       		.byte	3
 7718 012a 00       		.byte	0
 7719 012b 00       		.byte	0
 7720 012c 00       		.byte	0
 7721 012d 00       		.byte	0
 7722 012e 00       		.byte	0
 7723 012f 30       		.byte	48
 7724 0130 01       		.byte	1
 7725 0131 00       		.byte	0
 7726 0132 00       		.byte	0
 7727 0133 00000000 		.space	5
 7727      00
 7728 0138 00       		.byte	0
 7729 0139 00       		.byte	0
 7730 013a 02       		.byte	2
 7731 013b 00       		.byte	0
 7732 013c 00       		.byte	0
 7733 013d 64       		.byte	100
 7734 013e 00       		.byte	0
 7735 013f 01       		.byte	1
 7736 0140 00       		.byte	0
 7737 0141 03       		.byte	3
 7738 0142 00       		.byte	0
 7739 0143 00       		.byte	0
 7740 0144 00       		.byte	0
 7741 0145 00       		.byte	0
 7742 0146 00       		.byte	0
 7743 0147 30       		.byte	48
 7744 0148 01       		.byte	1
 7745 0149 00       		.byte	0
 7746 014a 00       		.byte	0
 7747 014b 00000000 		.space	5
 7747      00
 7748 0150 00       		.byte	0
 7749 0151 00       		.byte	0
 7750 0152 02       		.byte	2
 7751 0153 00       		.byte	0
 7752 0154 00       		.byte	0
 7753 0155 64       		.byte	100
 7754 0156 00       		.byte	0
 7755 0157 01       		.byte	1
 7756 0158 00       		.byte	0
 7757 0159 03       		.byte	3
 7758 015a 00       		.byte	0
 7759 015b 00       		.byte	0
 7760 015c 00       		.byte	0
 7761 015d 00       		.byte	0
 7762 015e 00       		.byte	0
 7763 015f 30       		.byte	48
 7764 0160 01       		.byte	1
 7765 0161 00       		.byte	0
 7766 0162 00       		.byte	0
 7767 0163 00000000 		.space	5
 7767      00
 7768 0168 00       		.byte	0
 7769 0169 00       		.byte	0
 7770 016a 02       		.byte	2
 7771 016b 00       		.byte	0
 7772 016c 00       		.byte	0
 7773 016d 64       		.byte	100
 7774 016e 00       		.byte	0
 7775 016f 01       		.byte	1
 7776 0170 00       		.byte	0
 7777 0171 03       		.byte	3
 7778 0172 00       		.byte	0
 7779 0173 00       		.byte	0
 7780 0174 00       		.byte	0
 7781 0175 00       		.byte	0
 7782 0176 00       		.byte	0
 7783 0177 30       		.byte	48
 7784 0178 01       		.byte	1
 7785 0179 00       		.byte	0
 7786 017a 00       		.byte	0
 7787 017b 00000000 		.space	5
 7787      00
 7790              	CtrlParArry:
 7791 0180 10       		.byte	16
 7792 0181 10       		.byte	16
 7793 0182 02       		.byte	2
 7794 0183 00       		.byte	0
 7795 0184 00       		.byte	0
 7796 0185 03       		.byte	3
 7797 0186 00       		.byte	0
 7798 0187 01       		.byte	1
 7799 0188 00       		.byte	0
 7800 0189 03       		.byte	3
 7801 018a 00       		.byte	0
 7802 018b 00       		.byte	0
 7803 018c 00       		.byte	0
 7804 018d 03       		.byte	3
 7805 018e 00       		.byte	0
 7806 018f 30       		.byte	48
 7807 0190 01       		.byte	1
 7808 0191 00       		.byte	0
 7809 0192 00       		.byte	0
 7810 0193 00000000 		.space	5
 7810      00
 7811 0198 01       		.byte	1
 7812 0199 00       		.byte	0
 7813 019a 02       		.byte	2
 7814 019b 00       		.byte	0
 7815 019c 00       		.byte	0
 7816 019d FF       		.byte	-1
 7817 019e 00       		.byte	0
 7818 019f 01       		.byte	1
 7819 01a0 00       		.byte	0
 7820 01a1 03       		.byte	3
 7821 01a2 00       		.byte	0
 7822 01a3 76       		.byte	118
 7823 01a4 00       		.byte	0
 7824 01a5 76       		.byte	118
 7825 01a6 C7       		.byte	-57
 7826 01a7 C6       		.byte	-58
 7827 01a8 01       		.byte	1
 7828 01a9 01       		.byte	1
 7829 01aa 00       		.byte	0
 7830 01ab 00000000 		.space	5
 7830      00
 7831 01b0 02       		.byte	2
 7832 01b1 02       		.byte	2
 7833 01b2 02       		.byte	2
 7834 01b3 00       		.byte	0
 7835 01b4 00       		.byte	0
 7836 01b5 FF       		.byte	-1
 7837 01b6 00       		.byte	0
 7838 01b7 01       		.byte	1
 7839 01b8 00       		.byte	0
 7840 01b9 03       		.byte	3
 7841 01ba 00       		.byte	0
 7842 01bb 70       		.byte	112
 7843 01bc 00       		.byte	0
 7844 01bd 70       		.byte	112
 7845 01be 00       		.byte	0
 7846 01bf C6       		.byte	-58
 7847 01c0 01       		.byte	1
 7848 01c1 01       		.byte	1
 7849 01c2 00       		.byte	0
 7850 01c3 00000000 		.space	5
 7850      00
 7851 01c8 00       		.byte	0
 7852 01c9 00       		.byte	0
 7853 01ca 02       		.byte	2
 7854 01cb 00       		.byte	0
 7855 01cc 00       		.byte	0
 7856 01cd 64       		.byte	100
 7857 01ce 00       		.byte	0
 7858 01cf 01       		.byte	1
 7859 01d0 00       		.byte	0
 7860 01d1 03       		.byte	3
 7861 01d2 00       		.byte	0
 7862 01d3 00       		.byte	0
 7863 01d4 00       		.byte	0
 7864 01d5 00       		.byte	0
 7865 01d6 00       		.byte	0
 7866 01d7 30       		.byte	48
 7867 01d8 01       		.byte	1
 7868 01d9 00       		.byte	0
 7869 01da 00       		.byte	0
 7870 01db 00000000 		.space	5
 7870      00
 7871 01e0 07       		.byte	7
 7872 01e1 07       		.byte	7
 7873 01e2 02       		.byte	2
 7874 01e3 00       		.byte	0
 7875 01e4 00       		.byte	0
 7876 01e5 01       		.byte	1
 7877 01e6 00       		.byte	0
 7878 01e7 01       		.byte	1
 7879 01e8 00       		.byte	0
 7880 01e9 03       		.byte	3
 7881 01ea 00       		.byte	0
 7882 01eb 01       		.byte	1
 7883 01ec 00       		.byte	0
 7884 01ed 01       		.byte	1
 7885 01ee 00       		.byte	0
 7886 01ef 30       		.byte	48
 7887 01f0 01       		.byte	1
 7888 01f1 00       		.byte	0
 7889 01f2 00       		.byte	0
 7890 01f3 00000000 		.space	5
 7890      00
 7891 01f8 DF       		.byte	-33
 7892 01f9 E1       		.byte	-31
 7893 01fa 02       		.byte	2
 7894 01fb 00       		.byte	0
 7895 01fc 00       		.byte	0
 7896 01fd FF       		.byte	-1
 7897 01fe 00       		.byte	0
 7898 01ff 01       		.byte	1
 7899 0200 00       		.byte	0
 7900 0201 03       		.byte	3
 7901 0202 00       		.byte	0
 7902 0203 80       		.byte	-128
 7903 0204 00       		.byte	0
 7904 0205 00       		.byte	0
 7905 0206 00       		.byte	0
 7906 0207 C6       		.byte	-58
 7907 0208 01       		.byte	1
 7908 0209 01       		.byte	1
 7909 020a 00       		.byte	0
 7910 020b 00000000 		.space	5
 7910      00
 7911 0210 85       		.byte	-123
 7912 0211 86       		.byte	-122
 7913 0212 02       		.byte	2
 7914 0213 00       		.byte	0
 7915 0214 00       		.byte	0
 7916 0215 64       		.byte	100
 7917 0216 00       		.byte	0
 7918 0217 01       		.byte	1
 7919 0218 00       		.byte	0
 7920 0219 03       		.byte	3
 7921 021a 00       		.byte	0
 7922 021b 32       		.byte	50
 7923 021c 00       		.byte	0
 7924 021d 32       		.byte	50
 7925 021e 00       		.byte	0
 7926 021f F2       		.byte	-14
 7927 0220 01       		.byte	1
 7928 0221 01       		.byte	1
 7929 0222 00       		.byte	0
 7930 0223 00000000 		.space	5
 7930      00
 7931 0228 06       		.byte	6
 7932 0229 06       		.byte	6
 7933 022a 02       		.byte	2
 7934 022b 00       		.byte	0
 7935 022c 00       		.byte	0
 7936 022d 40       		.byte	64
 7937 022e 00       		.byte	0
 7938 022f 01       		.byte	1
 7939 0230 00       		.byte	0
 7940 0231 03       		.byte	3
 7941 0232 00       		.byte	0
 7942 0233 20       		.byte	32
 7943 0234 00       		.byte	0
 7944 0235 20       		.byte	32
 7945 0236 00       		.byte	0
 7946 0237 30       		.byte	48
 7947 0238 01       		.byte	1
 7948 0239 01       		.byte	1
 7949 023a 00       		.byte	0
 7950 023b 00000000 		.space	5
 7950      00
 7951 0240 00       		.byte	0
 7952 0241 00       		.byte	0
 7953 0242 02       		.byte	2
 7954 0243 00       		.byte	0
 7955 0244 00       		.byte	0
 7956 0245 64       		.byte	100
 7957 0246 00       		.byte	0
 7958 0247 01       		.byte	1
 7959 0248 00       		.byte	0
 7960 0249 03       		.byte	3
 7961 024a 00       		.byte	0
 7962 024b 00       		.byte	0
 7963 024c 00       		.byte	0
 7964 024d 00       		.byte	0
 7965 024e 00       		.byte	0
 7966 024f 30       		.byte	48
 7967 0250 01       		.byte	1
 7968 0251 00       		.byte	0
 7969 0252 00       		.byte	0
 7970 0253 00000000 		.space	5
 7970      00
 7971 0258 08       		.byte	8
 7972 0259 08       		.byte	8
 7973 025a 02       		.byte	2
 7974 025b 00       		.byte	0
 7975 025c 00       		.byte	0
 7976 025d 05       		.byte	5
 7977 025e 00       		.byte	0
 7978 025f 01       		.byte	1
 7979 0260 00       		.byte	0
 7980 0261 03       		.byte	3
 7981 0262 00       		.byte	0
 7982 0263 00       		.byte	0
 7983 0264 00       		.byte	0
 7984 0265 00       		.byte	0
 7985 0266 00       		.byte	0
 7986 0267 30       		.byte	48
 7987 0268 01       		.byte	1
 7988 0269 00       		.byte	0
 7989 026a 00       		.byte	0
 7990 026b 00000000 		.space	5
 7990      00
 7991 0270 00       		.byte	0
 7992 0271 00       		.byte	0
 7993 0272 02       		.byte	2
 7994 0273 00       		.byte	0
 7995 0274 00       		.byte	0
 7996 0275 40       		.byte	64
 7997 0276 00       		.byte	0
 7998 0277 01       		.byte	1
 7999 0278 00       		.byte	0
 8000 0279 03       		.byte	3
 8001 027a 00       		.byte	0
 8002 027b 00       		.byte	0
 8003 027c 00       		.byte	0
 8004 027d 00       		.byte	0
 8005 027e 00       		.byte	0
 8006 027f 30       		.byte	48
 8007 0280 01       		.byte	1
 8008 0281 00       		.byte	0
 8009 0282 00       		.byte	0
 8010 0283 00000000 		.space	5
 8010      00
 8011 0288 09       		.byte	9
 8012 0289 0A       		.byte	10
 8013 028a 04       		.byte	4
 8014 028b 00       		.byte	0
 8015 028c 00       		.byte	0
 8016 028d 40       		.byte	64
 8017 028e 00       		.byte	0
 8018 028f 01       		.byte	1
 8019 0290 00       		.byte	0
 8020 0291 03       		.byte	3
 8021 0292 00       		.byte	0
 8022 0293 20       		.byte	32
 8023 0294 38       		.byte	56
 8024 0295 20       		.byte	32
 8025 0296 38       		.byte	56
 8026 0297 30       		.byte	48
 8027 0298 01       		.byte	1
 8028 0299 00       		.byte	0
 8029 029a 00       		.byte	0
 8030 029b 00000000 		.space	5
 8030      00
 8031 02a0 00       		.byte	0
 8032 02a1 00       		.byte	0
 8033 02a2 02       		.byte	2
 8034 02a3 00       		.byte	0
 8035 02a4 00       		.byte	0
 8036 02a5 64       		.byte	100
 8037 02a6 00       		.byte	0
 8038 02a7 01       		.byte	1
 8039 02a8 00       		.byte	0
 8040 02a9 03       		.byte	3
 8041 02aa 00       		.byte	0
 8042 02ab 00       		.byte	0
 8043 02ac 00       		.byte	0
 8044 02ad 00       		.byte	0
 8045 02ae 00       		.byte	0
 8046 02af 30       		.byte	48
 8047 02b0 01       		.byte	1
 8048 02b1 00       		.byte	0
 8049 02b2 00       		.byte	0
 8050 02b3 00000000 		.space	5
 8050      00
 8051 02b8 00       		.byte	0
 8052 02b9 00       		.byte	0
 8053 02ba 02       		.byte	2
 8054 02bb 00       		.byte	0
 8055 02bc 00       		.byte	0
 8056 02bd 64       		.byte	100
 8057 02be 00       		.byte	0
 8058 02bf 01       		.byte	1
 8059 02c0 00       		.byte	0
 8060 02c1 03       		.byte	3
 8061 02c2 00       		.byte	0
 8062 02c3 00       		.byte	0
 8063 02c4 00       		.byte	0
 8064 02c5 00       		.byte	0
 8065 02c6 00       		.byte	0
 8066 02c7 30       		.byte	48
 8067 02c8 01       		.byte	1
 8068 02c9 00       		.byte	0
 8069 02ca 00       		.byte	0
 8070 02cb 00000000 		.space	5
 8070      00
 8071 02d0 2A       		.byte	42
 8072 02d1 2A       		.byte	42
 8073 02d2 02       		.byte	2
 8074 02d3 00       		.byte	0
 8075 02d4 00       		.byte	0
 8076 02d5 1B       		.byte	27
 8077 02d6 00       		.byte	0
 8078 02d7 01       		.byte	1
 8079 02d8 00       		.byte	0
 8080 02d9 03       		.byte	3
 8081 02da 00       		.byte	0
 8082 02db 00       		.byte	0
 8083 02dc 00       		.byte	0
 8084 02dd 00       		.byte	0
 8085 02de 00       		.byte	0
 8086 02df 30       		.byte	48
 8087 02e0 01       		.byte	1
 8088 02e1 00       		.byte	0
 8089 02e2 00       		.byte	0
 8090 02e3 00000000 		.space	5
 8090      00
 8091 02e8 00       		.byte	0
 8092 02e9 00       		.byte	0
 8093 02ea 02       		.byte	2
 8094 02eb 00       		.byte	0
 8095 02ec 00       		.byte	0
 8096 02ed 64       		.byte	100
 8097 02ee 00       		.byte	0
 8098 02ef 01       		.byte	1
 8099 02f0 00       		.byte	0
 8100 02f1 03       		.byte	3
 8101 02f2 00       		.byte	0
 8102 02f3 00       		.byte	0
 8103 02f4 00       		.byte	0
 8104 02f5 00       		.byte	0
 8105 02f6 00       		.byte	0
 8106 02f7 30       		.byte	48
 8107 02f8 01       		.byte	1
 8108 02f9 00       		.byte	0
 8109 02fa 00       		.byte	0
 8110 02fb 00000000 		.space	5
 8110      00
 8111 0300 00       		.byte	0
 8112 0301 00       		.byte	0
 8113 0302 02       		.byte	2
 8114 0303 00       		.byte	0
 8115 0304 00       		.byte	0
 8116 0305 12       		.byte	18
 8117 0306 00       		.byte	0
 8118 0307 01       		.byte	1
 8119 0308 00       		.byte	0
 8120 0309 03       		.byte	3
 8121 030a 00       		.byte	0
 8122 030b 00       		.byte	0
 8123 030c 00       		.byte	0
 8124 030d 00       		.byte	0
 8125 030e 00       		.byte	0
 8126 030f 30       		.byte	48
 8127 0310 01       		.byte	1
 8128 0311 00       		.byte	0
 8129 0312 00       		.byte	0
 8130 0313 00000000 		.space	5
 8130      00
 8131 0318 01       		.byte	1
 8132 0319 01       		.byte	1
 8133 031a 02       		.byte	2
 8134 031b 00       		.byte	0
 8135 031c 00       		.byte	0
 8136 031d 09       		.byte	9
 8137 031e 00       		.byte	0
 8138 031f 01       		.byte	1
 8139 0320 00       		.byte	0
 8140 0321 03       		.byte	3
 8141 0322 00       		.byte	0
 8142 0323 00       		.byte	0
 8143 0324 00       		.byte	0
 8144 0325 01       		.byte	1
 8145 0326 00       		.byte	0
 8146 0327 30       		.byte	48
 8147 0328 01       		.byte	1
 8148 0329 00       		.byte	0
 8149 032a 00       		.byte	0
 8150 032b 00000000 		.space	5
 8150      00
 8151 0330 05       		.byte	5
 8152 0331 05       		.byte	5
 8153 0332 02       		.byte	2
 8154 0333 00       		.byte	0
 8155 0334 00       		.byte	0
 8156 0335 03       		.byte	3
 8157 0336 00       		.byte	0
 8158 0337 01       		.byte	1
 8159 0338 00       		.byte	0
 8160 0339 03       		.byte	3
 8161 033a 00       		.byte	0
 8162 033b 00       		.byte	0
 8163 033c 00       		.byte	0
 8164 033d 03       		.byte	3
 8165 033e 00       		.byte	0
 8166 033f 30       		.byte	48
 8167 0340 01       		.byte	1
 8168 0341 00       		.byte	0
 8169 0342 00       		.byte	0
 8170 0343 00000000 		.space	5
 8170      00
 8171 0348 18       		.byte	24
 8172 0349 18       		.byte	24
 8173 034a 02       		.byte	2
 8174 034b 00       		.byte	0
 8175 034c 00       		.byte	0
 8176 034d 01       		.byte	1
 8177 034e 00       		.byte	0
 8178 034f 01       		.byte	1
 8179 0350 00       		.byte	0
 8180 0351 03       		.byte	3
 8181 0352 00       		.byte	0
 8182 0353 00       		.byte	0
 8183 0354 00       		.byte	0
 8184 0355 00       		.byte	0
 8185 0356 00       		.byte	0
 8186 0357 30       		.byte	48
 8187 0358 01       		.byte	1
 8188 0359 00       		.byte	0
 8189 035a 00       		.byte	0
 8190 035b 00000000 		.space	5
 8190      00
 8191 0360 19       		.byte	25
 8192 0361 19       		.byte	25
 8193 0362 01       		.byte	1
 8194 0363 00       		.byte	0
 8195 0364 00       		.byte	0
 8196 0365 40       		.byte	64
 8197 0366 00       		.byte	0
 8198 0367 01       		.byte	1
 8199 0368 00       		.byte	0
 8200 0369 03       		.byte	3
 8201 036a 00       		.byte	0
 8202 036b 20       		.byte	32
 8203 036c 00       		.byte	0
 8204 036d 20       		.byte	32
 8205 036e 00       		.byte	0
 8206 036f 30       		.byte	48
 8207 0370 01       		.byte	1
 8208 0371 00       		.byte	0
 8209 0372 00       		.byte	0
 8210 0373 00000000 		.space	5
 8210      00
 8211 0378 20       		.byte	32
 8212 0379 20       		.byte	32
 8213 037a 02       		.byte	2
 8214 037b 00       		.byte	0
 8215 037c 00       		.byte	0
 8216 037d 02       		.byte	2
 8217 037e 00       		.byte	0
 8218 037f 01       		.byte	1
 8219 0380 00       		.byte	0
 8220 0381 03       		.byte	3
 8221 0382 00       		.byte	0
 8222 0383 00       		.byte	0
 8223 0384 00       		.byte	0
 8224 0385 00       		.byte	0
 8225 0386 00       		.byte	0
 8226 0387 30       		.byte	48
 8227 0388 01       		.byte	1
 8228 0389 00       		.byte	0
 8229 038a 00       		.byte	0
 8230 038b 00000000 		.space	5
 8230      00
 8231 0390 22       		.byte	34
 8232 0391 22       		.byte	34
 8233 0392 02       		.byte	2
 8234 0393 00       		.byte	0
 8235 0394 00       		.byte	0
 8236 0395 3F       		.byte	63
 8237 0396 00       		.byte	0
 8238 0397 01       		.byte	1
 8239 0398 00       		.byte	0
 8240 0399 03       		.byte	3
 8241 039a 00       		.byte	0
 8242 039b 00       		.byte	0
 8243 039c 00       		.byte	0
 8244 039d 00       		.byte	0
 8245 039e 00       		.byte	0
 8246 039f 30       		.byte	48
 8247 03a0 01       		.byte	1
 8248 03a1 00       		.byte	0
 8249 03a2 00       		.byte	0
 8250 03a3 00000000 		.space	5
 8250      00
 8251 03a8 23       		.byte	35
 8252 03a9 23       		.byte	35
 8253 03aa 02       		.byte	2
 8254 03ab 00       		.byte	0
 8255 03ac 00       		.byte	0
 8256 03ad 64       		.byte	100
 8257 03ae 00       		.byte	0
 8258 03af 01       		.byte	1
 8259 03b0 00       		.byte	0
 8260 03b1 03       		.byte	3
 8261 03b2 00       		.byte	0
 8262 03b3 10       		.byte	16
 8263 03b4 00       		.byte	0
 8264 03b5 10       		.byte	16
 8265 03b6 00       		.byte	0
 8266 03b7 30       		.byte	48
 8267 03b8 01       		.byte	1
 8268 03b9 00       		.byte	0
 8269 03ba 00       		.byte	0
 8270 03bb 00000000 		.space	5
 8270      00
 8271 03c0 24       		.byte	36
 8272 03c1 24       		.byte	36
 8273 03c2 02       		.byte	2
 8274 03c3 00       		.byte	0
 8275 03c4 00       		.byte	0
 8276 03c5 64       		.byte	100
 8277 03c6 00       		.byte	0
 8278 03c7 01       		.byte	1
 8279 03c8 00       		.byte	0
 8280 03c9 03       		.byte	3
 8281 03ca 00       		.byte	0
 8282 03cb 10       		.byte	16
 8283 03cc 00       		.byte	0
 8284 03cd 10       		.byte	16
 8285 03ce 00       		.byte	0
 8286 03cf 30       		.byte	48
 8287 03d0 01       		.byte	1
 8288 03d1 00       		.byte	0
 8289 03d2 00       		.byte	0
 8290 03d3 00000000 		.space	5
 8290      00
 8291 03d8 02       		.byte	2
 8292 03d9 03       		.byte	3
 8293 03da 04       		.byte	4
 8294 03db 00       		.byte	0
 8295 03dc 00       		.byte	0
 8296 03dd 7F       		.byte	127
 8297 03de 00       		.byte	0
 8298 03df 01       		.byte	1
 8299 03e0 00       		.byte	0
 8300 03e1 03       		.byte	3
 8301 03e2 00       		.byte	0
 8302 03e3 00       		.byte	0
 8303 03e4 20       		.byte	32
 8304 03e5 00       		.byte	0
 8305 03e6 20       		.byte	32
 8306 03e7 30       		.byte	48
 8307 03e8 01       		.byte	1
 8308 03e9 00       		.byte	0
 8309 03ea 00       		.byte	0
 8310 03eb 00000000 		.space	5
 8310      00
 8311 03f0 04       		.byte	4
 8312 03f1 0C       		.byte	12
 8313 03f2 02       		.byte	2
 8314 03f3 00       		.byte	0
 8315 03f4 00       		.byte	0
 8316 03f5 40       		.byte	64
 8317 03f6 00       		.byte	0
 8318 03f7 01       		.byte	1
 8319 03f8 00       		.byte	0
 8320 03f9 03       		.byte	3
 8321 03fa 00       		.byte	0
 8322 03fb 20       		.byte	32
 8323 03fc 00       		.byte	0
 8324 03fd 20       		.byte	32
 8325 03fe 00       		.byte	0
 8326 03ff 30       		.byte	48
 8327 0400 01       		.byte	1
 8328 0401 00       		.byte	0
 8329 0402 00       		.byte	0
 8330 0403 00000000 		.space	5
 8330      00
 8331 0408 00       		.byte	0
 8332 0409 00       		.byte	0
 8333 040a 02       		.byte	2
 8334 040b 00       		.byte	0
 8335 040c 00       		.byte	0
 8336 040d 19       		.byte	25
 8337 040e 00       		.byte	0
 8338 040f 01       		.byte	1
 8339 0410 00       		.byte	0
 8340 0411 03       		.byte	3
 8341 0412 00       		.byte	0
 8342 0413 00       		.byte	0
 8343 0414 00       		.byte	0
 8344 0415 00       		.byte	0
 8345 0416 00       		.byte	0
 8346 0417 30       		.byte	48
 8347 0418 01       		.byte	1
 8348 0419 00       		.byte	0
 8349 041a 00       		.byte	0
 8350 041b 00000000 		.space	5
 8350      00
 8351 0420 10       		.byte	16
 8352 0421 10       		.byte	16
 8353 0422 02       		.byte	2
 8354 0423 00       		.byte	0
 8355 0424 00       		.byte	0
 8356 0425 06       		.byte	6
 8357 0426 00       		.byte	0
 8358 0427 01       		.byte	1
 8359 0428 00       		.byte	0
 8360 0429 03       		.byte	3
 8361 042a 00       		.byte	0
 8362 042b 00       		.byte	0
 8363 042c 00       		.byte	0
 8364 042d 00       		.byte	0
 8365 042e 00       		.byte	0
 8366 042f 30       		.byte	48
 8367 0430 01       		.byte	1
 8368 0431 00       		.byte	0
 8369 0432 00       		.byte	0
 8370 0433 00000000 		.space	5
 8370      00
 8371 0438 00       		.byte	0
 8372 0439 00       		.byte	0
 8373 043a 02       		.byte	2
 8374 043b 00       		.byte	0
 8375 043c 00       		.byte	0
 8376 043d 03       		.byte	3
 8377 043e 00       		.byte	0
 8378 043f 01       		.byte	1
 8379 0440 00       		.byte	0
 8380 0441 03       		.byte	3
 8381 0442 00       		.byte	0
 8382 0443 00       		.byte	0
 8383 0444 00       		.byte	0
 8384 0445 00       		.byte	0
 8385 0446 00       		.byte	0
 8386 0447 30       		.byte	48
 8387 0448 01       		.byte	1
 8388 0449 00       		.byte	0
 8389 044a 00       		.byte	0
 8390 044b 00000000 		.space	5
 8390      00
 8391 0450 50       		.byte	80
 8392 0451 50       		.byte	80
 8393 0452 01       		.byte	1
 8394 0453 00       		.byte	0
 8395 0454 00       		.byte	0
 8396 0455 03       		.byte	3
 8397 0456 00       		.byte	0
 8398 0457 01       		.byte	1
 8399 0458 00       		.byte	0
 8400 0459 03       		.byte	3
 8401 045a 00       		.byte	0
 8402 045b 00       		.byte	0
 8403 045c 00       		.byte	0
 8404 045d 00       		.byte	0
 8405 045e 00       		.byte	0
 8406 045f 30       		.byte	48
 8407 0460 01       		.byte	1
 8408 0461 00       		.byte	0
 8409 0462 00       		.byte	0
 8410 0463 00000000 		.space	5
 8410      00
 8411 0468 00       		.byte	0
 8412 0469 00       		.byte	0
 8413 046a 0B       		.byte	11
 8414 046b 00       		.byte	0
 8415 046c 00       		.byte	0
 8416 046d FF       		.byte	-1
 8417 046e FF       		.byte	-1
 8418 046f 01       		.byte	1
 8419 0470 00       		.byte	0
 8420 0471 03       		.byte	3
 8421 0472 00       		.byte	0
 8422 0473 00       		.byte	0
 8423 0474 00       		.byte	0
 8424 0475 00       		.byte	0
 8425 0476 00       		.byte	0
 8426 0477 00       		.byte	0
 8427 0478 01       		.byte	1
 8428 0479 00       		.byte	0
 8429 047a 00       		.byte	0
 8430 047b 00000000 		.space	5
 8430      00
 8433              	glUVCHeader:
 8434 0480 0C       		.byte	12
 8435 0481 8C       		.byte	-116
 8436 0482 00       		.byte	0
 8437 0483 00       		.byte	0
 8438 0484 00       		.byte	0
 8439 0485 00       		.byte	0
 8440 0486 00       		.byte	0
 8441 0487 00       		.byte	0
 8442 0488 00       		.byte	0
 8443 0489 00       		.byte	0
 8444 048a 00       		.byte	0
 8445 048b 00       		.byte	0
 8448              	WBMenuCmpArry:
 8449 048c 20       		.byte	32
 8450 048d 0F       		.byte	15
 8451 048e 38       		.byte	56
 8452 048f F0       		.byte	-16
 8455              	CTCtrlParArry:
 8456 0490 00       		.byte	0
 8457 0491 00       		.byte	0
 8458 0492 01       		.byte	1
 8459 0493 00       		.byte	0
 8460 0494 00       		.byte	0
 8461 0495 03       		.byte	3
 8462 0496 00       		.byte	0
 8463 0497 01       		.byte	1
 8464 0498 00       		.byte	0
 8465 0499 03       		.byte	3
 8466 049a 00       		.byte	0
 8467 049b 03       		.byte	3
 8468 049c 00       		.byte	0
 8469 049d 03       		.byte	3
 8470 049e 00       		.byte	0
 8471 049f 30       		.byte	48
 8472 04a0 01       		.byte	1
 8473 04a1 00       		.byte	0
 8474 04a2 00       		.byte	0
 8475 04a3 00000000 		.space	5
 8475      00
 8476 04a8 00       		.byte	0
 8477 04a9 00       		.byte	0
 8478 04aa 01       		.byte	1
 8479 04ab 01       		.byte	1
 8480 04ac 00       		.byte	0
 8481 04ad 0F       		.byte	15
 8482 04ae 00       		.byte	0
 8483 04af 0F       		.byte	15
 8484 04b0 00       		.byte	0
 8485 04b1 03       		.byte	3
 8486 04b2 00       		.byte	0
 8487 04b3 02       		.byte	2
 8488 04b4 00       		.byte	0
 8489 04b5 02       		.byte	2
 8490 04b6 00       		.byte	0
 8491 04b7 30       		.byte	48
 8492 04b8 01       		.byte	1
 8493 04b9 01       		.byte	1
 8494 04ba 00       		.byte	0
 8495 04bb 00000000 		.space	5
 8495      00
 8496 04c0 02       		.byte	2
 8497 04c1 00       		.byte	0
 8498 04c2 01       		.byte	1
 8499 04c3 00       		.byte	0
 8500 04c4 00       		.byte	0
 8501 04c5 01       		.byte	1
 8502 04c6 00       		.byte	0
 8503 04c7 01       		.byte	1
 8504 04c8 00       		.byte	0
 8505 04c9 03       		.byte	3
 8506 04ca 00       		.byte	0
 8507 04cb 00       		.byte	0
 8508 04cc 00       		.byte	0
 8509 04cd 00       		.byte	0
 8510 04ce 00       		.byte	0
 8511 04cf 30       		.byte	48
 8512 04d0 01       		.byte	1
 8513 04d1 01       		.byte	1
 8514 04d2 00       		.byte	0
 8515 04d3 00000000 		.space	5
 8515      00
 8516 04d8 00       		.byte	0
 8517 04d9 00       		.byte	0
 8518 04da 04       		.byte	4
 8519 04db 01       		.byte	1
 8520 04dc 00       		.byte	0
 8521 04dd 38       		.byte	56
 8522 04de 01       		.byte	1
 8523 04df 01       		.byte	1
 8524 04e0 00       		.byte	0
 8525 04e1 03       		.byte	3
 8526 04e2 00       		.byte	0
 8527 04e3 4E       		.byte	78
 8528 04e4 00       		.byte	0
 8529 04e5 4E       		.byte	78
 8530 04e6 00       		.byte	0
 8531 04e7 30       		.byte	48
 8532 04e8 01       		.byte	1
 8533 04e9 00       		.byte	0
 8534 04ea 00       		.byte	0
 8535 04eb 00000000 		.space	5
 8535      00
 8536 04f0 04       		.byte	4
 8537 04f1 00       		.byte	0
 8538 04f2 01       		.byte	1
 8539 04f3 00       		.byte	0
 8540 04f4 00       		.byte	0
 8541 04f5 00       		.byte	0
 8542 04f6 00       		.byte	0
 8543 04f7 01       		.byte	1
 8544 04f8 00       		.byte	0
 8545 04f9 03       		.byte	3
 8546 04fa 00       		.byte	0
 8547 04fb 00       		.byte	0
 8548 04fc 00       		.byte	0
 8549 04fd 00       		.byte	0
 8550 04fe 00       		.byte	0
 8551 04ff 30       		.byte	48
 8552 0500 01       		.byte	1
 8553 0501 00       		.byte	0
 8554 0502 00       		.byte	0
 8555 0503 00000000 		.space	5
 8555      00
 8556 0508 05       		.byte	5
 8557 0509 00       		.byte	0
 8558 050a 02       		.byte	2
 8559 050b 00       		.byte	0
 8560 050c 00       		.byte	0
 8561 050d FF       		.byte	-1
 8562 050e 00       		.byte	0
 8563 050f 01       		.byte	1
 8564 0510 00       		.byte	0
 8565 0511 03       		.byte	3
 8566 0512 00       		.byte	0
 8567 0513 01       		.byte	1
 8568 0514 00       		.byte	0
 8569 0515 00       		.byte	0
 8570 0516 00       		.byte	0
 8571 0517 30       		.byte	48
 8572 0518 01       		.byte	1
 8573 0519 01       		.byte	1
 8574 051a 00       		.byte	0
 8575 051b 00000000 		.space	5
 8575      00
 8576 0520 06       		.byte	6
 8577 0521 00       		.byte	0
 8578 0522 02       		.byte	2
 8579 0523 00       		.byte	0
 8580 0524 00       		.byte	0
 8581 0525 00       		.byte	0
 8582 0526 00       		.byte	0
 8583 0527 00       		.byte	0
 8584 0528 00       		.byte	0
 8585 0529 03       		.byte	3
 8586 052a 00       		.byte	0
 8587 052b 00       		.byte	0
 8588 052c 00       		.byte	0
 8589 052d 00       		.byte	0
 8590 052e 00       		.byte	0
 8591 052f 30       		.byte	48
 8592 0530 01       		.byte	1
 8593 0531 01       		.byte	1
 8594 0532 00       		.byte	0
 8595 0533 00000000 		.space	5
 8595      00
 8596 0538 23       		.byte	35
 8597 0539 00       		.byte	0
 8598 053a 02       		.byte	2
 8599 053b 00       		.byte	0
 8600 053c 00       		.byte	0
 8601 053d 30       		.byte	48
 8602 053e 00       		.byte	0
 8603 053f 01       		.byte	1
 8604 0540 00       		.byte	0
 8605 0541 03       		.byte	3
 8606 0542 0A       		.byte	10
 8607 0543 00       		.byte	0
 8608 0544 00       		.byte	0
 8609 0545 0A       		.byte	10
 8610 0546 00       		.byte	0
 8611 0547 30       		.byte	48
 8612 0548 01       		.byte	1
 8613 0549 01       		.byte	1
 8614 054a 00       		.byte	0
 8615 054b 00000000 		.space	5
 8615      00
 8616 0550 08       		.byte	8
 8617 0551 00       		.byte	0
 8618 0552 01       		.byte	1
 8619 0553 00       		.byte	0
 8620 0554 00       		.byte	0
 8621 0555 7F       		.byte	127
 8622 0556 00       		.byte	0
 8623 0557 01       		.byte	1
 8624 0558 00       		.byte	0
 8625 0559 03       		.byte	3
 8626 055a 00       		.byte	0
 8627 055b 00       		.byte	0
 8628 055c 00       		.byte	0
 8629 055d 00       		.byte	0
 8630 055e 00       		.byte	0
 8631 055f 30       		.byte	48
 8632 0560 01       		.byte	1
 8633 0561 00       		.byte	0
 8634 0562 00       		.byte	0
 8635 0563 00000000 		.space	5
 8635      00
 8636 0568 09       		.byte	9
 8637 0569 00       		.byte	0
 8638 056a 02       		.byte	2
 8639 056b 00       		.byte	0
 8640 056c 00       		.byte	0
 8641 056d 05       		.byte	5
 8642 056e 00       		.byte	0
 8643 056f 01       		.byte	1
 8644 0570 00       		.byte	0
 8645 0571 03       		.byte	3
 8646 0572 00       		.byte	0
 8647 0573 00       		.byte	0
 8648 0574 00       		.byte	0
 8649 0575 00       		.byte	0
 8650 0576 00       		.byte	0
 8651 0577 30       		.byte	48
 8652 0578 01       		.byte	1
 8653 0579 00       		.byte	0
 8654 057a 00       		.byte	0
 8655 057b 00000000 		.space	5
 8655      00
 8656 0580 10       		.byte	16
 8657 0581 00       		.byte	0
 8658 0582 03       		.byte	3
 8659 0583 00       		.byte	0
 8660 0584 00       		.byte	0
 8661 0585 00       		.byte	0
 8662 0586 00       		.byte	0
 8663 0587 00       		.byte	0
 8664 0588 00       		.byte	0
 8665 0589 03       		.byte	3
 8666 058a 00       		.byte	0
 8667 058b 00       		.byte	0
 8668 058c 00       		.byte	0
 8669 058d 00       		.byte	0
 8670 058e 00       		.byte	0
 8671 058f 30       		.byte	48
 8672 0590 01       		.byte	1
 8673 0591 00       		.byte	0
 8674 0592 00       		.byte	0
 8675 0593 00000000 		.space	5
 8675      00
 8676 0598 00       		.byte	0
 8677 0599 00       		.byte	0
 8678 059a 02       		.byte	2
 8679 059b 00       		.byte	0
 8680 059c 00       		.byte	0
 8681 059d 40       		.byte	64
 8682 059e 00       		.byte	0
 8683 059f 01       		.byte	1
 8684 05a0 00       		.byte	0
 8685 05a1 03       		.byte	3
 8686 05a2 00       		.byte	0
 8687 05a3 0F       		.byte	15
 8688 05a4 11       		.byte	17
 8689 05a5 00       		.byte	0
 8690 05a6 00       		.byte	0
 8691 05a7 30       		.byte	48
 8692 05a8 01       		.byte	1
 8693 05a9 00       		.byte	0
 8694 05aa 00       		.byte	0
 8695 05ab 00000000 		.space	5
 8695      00
 8696 05b0 00       		.byte	0
 8697 05b1 00       		.byte	0
 8698 05b2 02       		.byte	2
 8699 05b3 00       		.byte	0
 8700 05b4 00       		.byte	0
 8701 05b5 64       		.byte	100
 8702 05b6 00       		.byte	0
 8703 05b7 01       		.byte	1
 8704 05b8 00       		.byte	0
 8705 05b9 03       		.byte	3
 8706 05ba 00       		.byte	0
 8707 05bb 00       		.byte	0
 8708 05bc 00       		.byte	0
 8709 05bd 00       		.byte	0
 8710 05be 00       		.byte	0
 8711 05bf 30       		.byte	48
 8712 05c0 01       		.byte	1
 8713 05c1 00       		.byte	0
 8714 05c2 00       		.byte	0
 8715 05c3 00000000 		.space	5
 8715      00
 8716 05c8 00       		.byte	0
 8717 05c9 00       		.byte	0
 8718 05ca 02       		.byte	2
 8719 05cb 00       		.byte	0
 8720 05cc 00       		.byte	0
 8721 05cd 64       		.byte	100
 8722 05ce 00       		.byte	0
 8723 05cf 01       		.byte	1
 8724 05d0 00       		.byte	0
 8725 05d1 03       		.byte	3
 8726 05d2 00       		.byte	0
 8727 05d3 00       		.byte	0
 8728 05d4 00       		.byte	0
 8729 05d5 00       		.byte	0
 8730 05d6 00       		.byte	0
 8731 05d7 30       		.byte	48
 8732 05d8 01       		.byte	1
 8733 05d9 00       		.byte	0
 8734 05da 00       		.byte	0
 8735 05db 00000000 		.space	5
 8735      00
 8736 05e0 00       		.byte	0
 8737 05e1 00       		.byte	0
 8738 05e2 02       		.byte	2
 8739 05e3 00       		.byte	0
 8740 05e4 00       		.byte	0
 8741 05e5 64       		.byte	100
 8742 05e6 00       		.byte	0
 8743 05e7 01       		.byte	1
 8744 05e8 00       		.byte	0
 8745 05e9 03       		.byte	3
 8746 05ea 00       		.byte	0
 8747 05eb 00       		.byte	0
 8748 05ec 00       		.byte	0
 8749 05ed 00       		.byte	0
 8750 05ee 00       		.byte	0
 8751 05ef 30       		.byte	48
 8752 05f0 01       		.byte	1
 8753 05f1 00       		.byte	0
 8754 05f2 00       		.byte	0
 8755 05f3 00000000 		.space	5
 8755      00
 8756 05f8 00       		.byte	0
 8757 05f9 00       		.byte	0
 8758 05fa 02       		.byte	2
 8759 05fb 00       		.byte	0
 8760 05fc 00       		.byte	0
 8761 05fd 64       		.byte	100
 8762 05fe 00       		.byte	0
 8763 05ff 01       		.byte	1
 8764 0600 00       		.byte	0
 8765 0601 03       		.byte	3
 8766 0602 00       		.byte	0
 8767 0603 00       		.byte	0
 8768 0604 00       		.byte	0
 8769 0605 00       		.byte	0
 8770 0606 00       		.byte	0
 8771 0607 30       		.byte	48
 8772 0608 01       		.byte	1
 8773 0609 00       		.byte	0
 8774 060a 00       		.byte	0
 8775 060b 00000000 		.space	5
 8775      00
 8778              	WDRflag:
 8779 0610 01000000 		.word	1
 8782              	glProbeCtrl:
 8783 0614 00       		.byte	0
 8784 0615 00       		.byte	0
 8785 0616 01       		.byte	1
 8786 0617 01       		.byte	1
 8787 0618 15       		.byte	21
 8788 0619 16       		.byte	22
 8789 061a 05       		.byte	5
 8790 061b 00       		.byte	0
 8791 061c 00       		.byte	0
 8792 061d 00       		.byte	0
 8793 061e 00       		.byte	0
 8794 061f 00       		.byte	0
 8795 0620 00       		.byte	0
 8796 0621 00       		.byte	0
 8797 0622 00       		.byte	0
 8798 0623 00       		.byte	0
 8799 0624 00       		.byte	0
 8800 0625 00       		.byte	0
 8801 0626 00       		.byte	0
 8802 0627 48       		.byte	72
 8803 0628 3F       		.byte	63
 8804 0629 00       		.byte	0
 8805 062a 00       		.byte	0
 8806 062b 40       		.byte	64
 8807 062c 00       		.byte	0
 8808 062d 00       		.byte	0
 8809 062e 0000     		.space	2
 8812              	glProbeCtrl20:
 8813 0630 00       		.byte	0
 8814 0631 00       		.byte	0
 8815 0632 01       		.byte	1
 8816 0633 01       		.byte	1
 8817 0634 80       		.byte	-128
 8818 0635 1A       		.byte	26
 8819 0636 06       		.byte	6
 8820 0637 00       		.byte	0
 8821 0638 00       		.byte	0
 8822 0639 00       		.byte	0
 8823 063a 00       		.byte	0
 8824 063b 00       		.byte	0
 8825 063c 00       		.byte	0
 8826 063d 00       		.byte	0
 8827 063e 00       		.byte	0
 8828 063f 00       		.byte	0
 8829 0640 00       		.byte	0
 8830 0641 00       		.byte	0
 8831 0642 00       		.byte	0
 8832 0643 D2       		.byte	-46
 8833 0644 0F       		.byte	15
 8834 0645 00       		.byte	0
 8835 0646 00       		.byte	0
 8836 0647 40       		.byte	64
 8837 0648 00       		.byte	0
 8838 0649 00       		.byte	0
 8839 064a 0000     		.space	2
 8842              	glProbeStilCtrl:
 8843 064c 01       		.byte	1
 8844 064d 01       		.byte	1
 8845 064e 00       		.byte	0
 8846 064f 00       		.byte	0
 8847 0650 48       		.byte	72
 8848 0651 3F       		.byte	63
 8849 0652 00       		.byte	0
 8850 0653 00       		.byte	0
 8851 0654 40       		.byte	64
 8852 0655 00       		.byte	0
 8853 0656 00       		.byte	0
 8854 0657 00       		.space	1
 8857              	glProbeStilCtrl20:
 8858 0658 01       		.byte	1
 8859 0659 01       		.byte	1
 8860 065a 00       		.byte	0
 8861 065b 00       		.byte	0
 8862 065c D2       		.byte	-46
 8863 065d 0F       		.byte	15
 8864 065e 00       		.byte	0
 8865 065f 00       		.byte	0
 8866 0660 40       		.byte	64
 8867 0661 00       		.byte	0
 8868 0662 00       		.byte	0
 8871              	snapButFlag:
 8872 0663 01       		.byte	1
 8875              	CyFxGpifTransition:
 8876 0664 0000     		.short	0
 8877 0666 5555     		.short	21845
 8878 0668 8888     		.short	-30584
 8879 066a AAAA     		.short	-21846
 8880 066c 3333     		.short	13107
 8881 066e 0000     		.space	2
 8884              	CyFxGpifWavedata:
 8885 0670 0181731E 		.word	510886145
 8886 0674 00000000 		.word	0
 8887 0678 00000080 		.word	-2147483648
 8888 067c 00000000 		.word	0
 8889 0680 00000000 		.word	0
 8890 0684 00000000 		.word	0
 8891 0688 0201702E 		.word	779092226
 8892 068c 00010000 		.word	256
 8893 0690 A0000080 		.word	-2147483488
 8894 0694 00000000 		.word	0
 8895 0698 00000000 		.word	0
 8896 069c 00000000 		.word	0
 8897 06a0 0380722E 		.word	779255811
 8898 06a4 02010020 		.word	536871170
 8899 06a8 60000080 		.word	-2147483552
 8900 06ac 00000000 		.word	0
 8901 06b0 00000000 		.word	0
 8902 06b4 00000000 		.word	0
 8903 06b8 0460722E 		.word	779247620
 8904 06bc 02010024 		.word	603980034
 8905 06c0 90000080 		.word	-2147483504
 8906 06c4 0594731E 		.word	510891013
 8907 06c8 06000000 		.word	6
 8908 06cc 00000080 		.word	-2147483648
 8909 06d0 0380722E 		.word	779255811
 8910 06d4 02010020 		.word	536871170
 8911 06d8 60000080 		.word	-2147483552
 8912 06dc 0693731E 		.word	510890758
 8913 06e0 06000000 		.word	6
 8914 06e4 00000080 		.word	-2147483648
 8915 06e8 0720703E 		.word	1047535623
 8916 06ec 08010000 		.word	264
 8917 06f0 00000080 		.word	-2147483648
 8918 06f4 0820703E 		.word	1047535624
 8919 06f8 08010000 		.word	264
 8920 06fc 00000080 		.word	-2147483648
 8921 0700 0920703E 		.word	1047535625
 8922 0704 08010000 		.word	264
 8923 0708 00000080 		.word	-2147483648
 8924 070c 0A20703E 		.word	1047535626
 8925 0710 08010000 		.word	264
 8926 0714 00000080 		.word	-2147483648
 8927 0718 0380722E 		.word	779255811
 8928 071c 02010020 		.word	536871170
 8929 0720 60000080 		.word	-2147483552
 8930 0724 0B000000 		.word	11
 8931 0728 00000000 		.word	0
 8932 072c 00010080 		.word	-2147483392
 8933 0730 0460722E 		.word	779247620
 8934 0734 02010024 		.word	603980034
 8935 0738 90000080 		.word	-2147483504
 8936 073c 0D000000 		.word	13
 8937 0740 00000000 		.word	0
 8938 0744 00010080 		.word	-2147483392
 8939 0748 0460722E 		.word	779247620
 8940 074c 02010024 		.word	603980034
 8941 0750 90000080 		.word	-2147483504
 8942 0754 0C000000 		.word	12
 8943 0758 00000000 		.word	0
 8944 075c 00010080 		.word	-2147483392
 8945 0760 0380722E 		.word	779255811
 8946 0764 02010020 		.word	536871170
 8947 0768 60000080 		.word	-2147483552
 8948 076c 0E000000 		.word	14
 8949 0770 00000000 		.word	0
 8950 0774 00010080 		.word	-2147483392
 8951 0778 00000000 		.word	0
 8952 077c 00000000 		.word	0
 8953 0780 00000000 		.word	0
 8954 0784 00000000 		.word	0
 8955 0788 00000000 		.word	0
 8956 078c 00000000 		.word	0
 8959              	CyFxGpifWavedataPosition:
 8960 0790 00       		.byte	0
 8961 0791 01       		.byte	1
 8962 0792 02       		.byte	2
 8963 0793 03       		.byte	3
 8964 0794 04       		.byte	4
 8965 0795 05       		.byte	5
 8966 0796 06       		.byte	6
 8967 0797 07       		.byte	7
 8968 0798 08       		.byte	8
 8969 0799 09       		.byte	9
 8970 079a 0A       		.byte	10
 8971 079b 0B       		.byte	11
 8972 079c 0B       		.byte	11
 8973 079d 0B       		.byte	11
 8974 079e 0B       		.byte	11
 8975 079f 00       		.space	1
 8978              	CyFxGpifRegValue:
 8979 07a0 08830080 		.word	-2147450104
 8980 07a4 67000000 		.word	103
 8981 07a8 00000000 		.word	0
 8982 07ac 46000000 		.word	70
 8983 07b0 00000000 		.word	0
 8984 07b4 00000000 		.word	0
 8985 07b8 02000000 		.word	2
 8986 07bc 82000000 		.word	130
 8987 07c0 82070000 		.word	1922
 8988 07c4 40040000 		.word	1088
 8989 07c8 FCFF0000 		.word	65532
 8990 07cc 28000000 		.word	40
 8991 07d0 00000000 		.word	0
 8992 07d4 00000000 		.word	0
 8993 07d8 00000000 		.word	0
 8994 07dc 00000000 		.word	0
 8995 07e0 01000000 		.word	1
 8996 07e4 00000000 		.word	0
 8997 07e8 00000000 		.word	0
 8998 07ec 00000000 		.word	0
 8999 07f0 00000000 		.word	0
 9000 07f4 00000000 		.word	0
 9001 07f8 00000000 		.word	0
 9002 07fc 00000000 		.word	0
 9003 0800 00000000 		.word	0
 9004 0804 00000000 		.word	0
 9005 0808 00000000 		.word	0
 9006 080c 00000000 		.word	0
 9007 0810 00000000 		.word	0
 9008 0814 06000000 		.word	6
 9009 0818 00000000 		.word	0
 9010 081c FFFF0000 		.word	65535
 9011 0820 09010000 		.word	265
 9012 0824 00000000 		.word	0
 9013 0828 F71F0000 		.word	8183
 9014 082c 00000000 		.word	0
 9015 0830 FFFF0000 		.word	65535
 9016 0834 09010000 		.word	265
 9017 0838 00000000 		.word	0
 9018 083c F71F0000 		.word	8183
 9019 0840 00000000 		.word	0
 9020 0844 00000000 		.word	0
 9021 0848 00000000 		.word	0
 9022 084c 00000000 		.word	0
 9023 0850 00000000 		.word	0
 9024 0854 00000000 		.word	0
 9025 0858 00000000 		.word	0
 9026 085c 00000000 		.word	0
 9027 0860 00000000 		.word	0
 9028 0864 00000000 		.word	0
 9029 0868 00000000 		.word	0
 9030 086c 00000000 		.word	0
 9031 0870 00000000 		.word	0
 9032 0874 00000000 		.word	0
 9033 0878 00000000 		.word	0
 9034 087c 00000000 		.word	0
 9035 0880 00000000 		.word	0
 9036 0884 00000000 		.word	0
 9037 0888 00000000 		.word	0
 9038 088c 00000000 		.word	0
 9039 0890 00000000 		.word	0
 9040 0894 00000000 		.word	0
 9041 0898 00000000 		.word	0
 9042 089c 00040180 		.word	-2147417088
 9043 08a0 01040180 		.word	-2147417087
 9044 08a4 02040180 		.word	-2147417086
 9045 08a8 03040180 		.word	-2147417085
 9046 08ac 00000000 		.word	0
 9047 08b0 00000000 		.word	0
 9048 08b4 00000000 		.word	0
 9049 08b8 00000000 		.word	0
 9050 08bc 00000000 		.word	0
 9051 08c0 00000000 		.word	0
 9052 08c4 00000000 		.word	0
 9053 08c8 00000000 		.word	0
 9054 08cc C1FFFFFF 		.word	-63
 9057              	CyFxGpifTransition_usb2:
 9058 08d0 0000     		.short	0
 9059 08d2 5555     		.short	21845
 9060 08d4 AAAA     		.short	-21846
 9061 08d6 8888     		.short	-30584
 9062 08d8 1111     		.short	4369
 9063 08da 4444     		.short	17476
 9064 08dc 3333     		.short	13107
 9065 08de CCCC     		.short	-13108
 9068              	CyFxGpifWavedata_usb2:
 9069 08e0 0181731E 		.word	510886145
 9070 08e4 00000000 		.word	0
 9071 08e8 00000080 		.word	-2147483648
 9072 08ec 00000000 		.word	0
 9073 08f0 00000000 		.word	0
 9074 08f4 00000000 		.word	0
 9075 08f8 0201703E 		.word	1047527682
 9076 08fc 00010000 		.word	256
 9077 0900 A00000C0 		.word	-1073741664
 9078 0904 00000000 		.word	0
 9079 0908 00000000 		.word	0
 9080 090c 00000000 		.word	0
 9081 0910 0394731E 		.word	510891011
 9082 0914 04000020 		.word	536870916
 9083 0918 60004080 		.word	-2143289248
 9084 091c 00000000 		.word	0
 9085 0920 00000000 		.word	0
 9086 0924 00000000 		.word	0
 9087 0928 0620702E 		.word	779100166
 9088 092c 0C000000 		.word	12
 9089 0930 00000080 		.word	-2147483648
 9090 0934 0620702E 		.word	779100166
 9091 0938 0C000000 		.word	12
 9092 093c 00000080 		.word	-2147483648
 9093 0940 0394731E 		.word	510891011
 9094 0944 04000020 		.word	536870916
 9095 0948 60004080 		.word	-2143289248
 9096 094c 0620702E 		.word	779100166
 9097 0950 0C000000 		.word	12
 9098 0954 00000080 		.word	-2147483648
 9099 0958 0C93731E 		.word	510890764
 9100 095c 04000024 		.word	603979780
 9101 0960 90004080 		.word	-2143289200
 9102 0964 0D20702E 		.word	779100173
 9103 0968 0C000000 		.word	12
 9104 096c 00000080 		.word	-2147483648
 9105 0970 0780724E 		.word	1316126727
 9106 0974 0A000000 		.word	10
 9107 0978 00000080 		.word	-2147483648
 9108 097c 08000000 		.word	8
 9109 0980 00000000 		.word	0
 9110 0984 00010080 		.word	-2147483392
 9111 0988 0920702E 		.word	779100169
 9112 098c 0C010000 		.word	268
 9113 0990 00000080 		.word	-2147483648
 9114 0994 0A01701E 		.word	510656778
 9115 0998 0E000100 		.word	65550
 9116 099c 00000080 		.word	-2147483648
 9117 09a0 00000000 		.word	0
 9118 09a4 00000000 		.word	0
 9119 09a8 00000000 		.word	0
 9120 09ac 00000000 		.word	0
 9121 09b0 00000000 		.word	0
 9122 09b4 00000000 		.word	0
 9123 09b8 0394731E 		.word	510891011
 9124 09bc 04000020 		.word	536870916
 9125 09c0 60004080 		.word	-2143289248
 9126 09c4 08000000 		.word	8
 9127 09c8 00000000 		.word	0
 9128 09cc 00010080 		.word	-2147483392
 9129 09d0 0B000000 		.word	11
 9130 09d4 00000000 		.word	0
 9131 09d8 00010080 		.word	-2147483392
 9132 09dc 0C93731E 		.word	510890764
 9133 09e0 04000024 		.word	603979780
 9134 09e4 90004080 		.word	-2143289200
 9135 09e8 0D20702E 		.word	779100173
 9136 09ec 0C000000 		.word	12
 9137 09f0 00000080 		.word	-2147483648
 9138 09f4 0D20702E 		.word	779100173
 9139 09f8 0C000000 		.word	12
 9140 09fc 00000080 		.word	-2147483648
 9141 0a00 0E60724E 		.word	1316118542
 9142 0a04 0A000000 		.word	10
 9143 0a08 00000080 		.word	-2147483648
 9144 0a0c 0F000000 		.word	15
 9145 0a10 00000000 		.word	0
 9146 0a14 00010080 		.word	-2147483392
 9147 0a18 1020702E 		.word	779100176
 9148 0a1c 0C010000 		.word	268
 9149 0a20 00000080 		.word	-2147483648
 9150 0a24 1101701E 		.word	510656785
 9151 0a28 0E000100 		.word	65550
 9152 0a2c 00000080 		.word	-2147483648
 9153 0a30 0C93731E 		.word	510890764
 9154 0a34 04000024 		.word	603979780
 9155 0a38 90004080 		.word	-2143289200
 9156 0a3c 0F000000 		.word	15
 9157 0a40 00000000 		.word	0
 9158 0a44 00010080 		.word	-2147483392
 9159 0a48 12000000 		.word	18
 9160 0a4c 00000000 		.word	0
 9161 0a50 00010080 		.word	-2147483392
 9162 0a54 0394731E 		.word	510891011
 9163 0a58 04000020 		.word	536870916
 9164 0a5c 60004080 		.word	-2143289248
 9165 0a60 0480732E 		.word	779321348
 9166 0a64 02010000 		.word	258
 9167 0a68 000040C0 		.word	-1069547520
 9168 0a6c 0580732E 		.word	779321349
 9169 0a70 02010000 		.word	258
 9170 0a74 000040C0 		.word	-1069547520
 9171 0a78 0580732E 		.word	779321349
 9172 0a7c 02010000 		.word	258
 9173 0a80 000040C0 		.word	-1069547520
 9174 0a84 0480732E 		.word	779321348
 9175 0a88 02010000 		.word	258
 9176 0a8c 000040C0 		.word	-1069547520
 9179              	CyFxGpifWavedataPosition_usb2:
 9180 0a90 00       		.byte	0
 9181 0a91 01       		.byte	1
 9182 0a92 02       		.byte	2
 9183 0a93 03       		.byte	3
 9184 0a94 04       		.byte	4
 9185 0a95 05       		.byte	5
 9186 0a96 06       		.byte	6
 9187 0a97 07       		.byte	7
 9188 0a98 08       		.byte	8
 9189 0a99 09       		.byte	9
 9190 0a9a 0A       		.byte	10
 9191 0a9b 08       		.byte	8
 9192 0a9c 0B       		.byte	11
 9193 0a9d 0C       		.byte	12
 9194 0a9e 0D       		.byte	13
 9195 0a9f 08       		.byte	8
 9196 0aa0 0E       		.byte	14
 9197 0aa1 0F       		.byte	15
 9198 0aa2 08       		.byte	8
 9199 0aa3 08       		.byte	8
 9200 0aa4 08       		.byte	8
 9201 0aa5 08       		.byte	8
 9202 0aa6 08       		.byte	8
 9203 0aa7 08       		.byte	8
 9204 0aa8 08       		.byte	8
 9205 0aa9 08       		.byte	8
 9206 0aaa 08       		.byte	8
 9207 0aab 08       		.byte	8
 9208 0aac 08       		.byte	8
 9209 0aad 08       		.byte	8
 9210 0aae 08       		.byte	8
 9211 0aaf 08       		.byte	8
 9212 0ab0 08       		.byte	8
 9213 0ab1 08       		.byte	8
 9214 0ab2 08       		.byte	8
 9215 0ab3 08       		.byte	8
 9216 0ab4 08       		.byte	8
 9217 0ab5 08       		.byte	8
 9218 0ab6 08       		.byte	8
 9219 0ab7 08       		.byte	8
 9220 0ab8 08       		.byte	8
 9221 0ab9 08       		.byte	8
 9222 0aba 08       		.byte	8
 9223 0abb 08       		.byte	8
 9224 0abc 08       		.byte	8
 9225 0abd 08       		.byte	8
 9226 0abe 08       		.byte	8
 9227 0abf 08       		.byte	8
 9228 0ac0 08       		.byte	8
 9229 0ac1 08       		.byte	8
 9230 0ac2 08       		.byte	8
 9231 0ac3 08       		.byte	8
 9232 0ac4 08       		.byte	8
 9233 0ac5 08       		.byte	8
 9234 0ac6 08       		.byte	8
 9235 0ac7 08       		.byte	8
 9236 0ac8 08       		.byte	8
 9237 0ac9 08       		.byte	8
 9238 0aca 08       		.byte	8
 9239 0acb 08       		.byte	8
 9240 0acc 08       		.byte	8
 9241 0acd 08       		.byte	8
 9242 0ace 08       		.byte	8
 9243 0acf 08       		.byte	8
 9244 0ad0 08       		.byte	8
 9245 0ad1 08       		.byte	8
 9246 0ad2 08       		.byte	8
 9247 0ad3 08       		.byte	8
 9248 0ad4 08       		.byte	8
 9249 0ad5 08       		.byte	8
 9250 0ad6 08       		.byte	8
 9251 0ad7 08       		.byte	8
 9252 0ad8 08       		.byte	8
 9253 0ad9 08       		.byte	8
 9254 0ada 08       		.byte	8
 9255 0adb 08       		.byte	8
 9256 0adc 08       		.byte	8
 9257 0add 08       		.byte	8
 9258 0ade 08       		.byte	8
 9259 0adf 08       		.byte	8
 9260 0ae0 08       		.byte	8
 9261 0ae1 08       		.byte	8
 9262 0ae2 08       		.byte	8
 9263 0ae3 08       		.byte	8
 9264 0ae4 08       		.byte	8
 9265 0ae5 08       		.byte	8
 9266 0ae6 08       		.byte	8
 9267 0ae7 08       		.byte	8
 9268 0ae8 08       		.byte	8
 9269 0ae9 08       		.byte	8
 9270 0aea 08       		.byte	8
 9271 0aeb 08       		.byte	8
 9272 0aec 08       		.byte	8
 9273 0aed 08       		.byte	8
 9274 0aee 08       		.byte	8
 9275 0aef 08       		.byte	8
 9276 0af0 08       		.byte	8
 9277 0af1 08       		.byte	8
 9278 0af2 08       		.byte	8
 9279 0af3 08       		.byte	8
 9280 0af4 08       		.byte	8
 9281 0af5 08       		.byte	8
 9282 0af6 08       		.byte	8
 9283 0af7 08       		.byte	8
 9284 0af8 08       		.byte	8
 9285 0af9 08       		.byte	8
 9286 0afa 08       		.byte	8
 9287 0afb 08       		.byte	8
 9288 0afc 08       		.byte	8
 9289 0afd 08       		.byte	8
 9290 0afe 08       		.byte	8
 9291 0aff 08       		.byte	8
 9292 0b00 08       		.byte	8
 9293 0b01 08       		.byte	8
 9294 0b02 08       		.byte	8
 9295 0b03 08       		.byte	8
 9296 0b04 08       		.byte	8
 9297 0b05 08       		.byte	8
 9298 0b06 08       		.byte	8
 9299 0b07 08       		.byte	8
 9300 0b08 08       		.byte	8
 9301 0b09 08       		.byte	8
 9302 0b0a 08       		.byte	8
 9303 0b0b 08       		.byte	8
 9304 0b0c 08       		.byte	8
 9305 0b0d 08       		.byte	8
 9306 0b0e 08       		.byte	8
 9307 0b0f 08       		.byte	8
 9308 0b10 00       		.byte	0
 9309 0b11 01       		.byte	1
 9310 0b12 02       		.byte	2
 9311 0b13 10       		.byte	16
 9312 0b14 04       		.byte	4
 9313 0b15 05       		.byte	5
 9314 0b16 06       		.byte	6
 9315 0b17 07       		.byte	7
 9316 0b18 08       		.byte	8
 9317 0b19 09       		.byte	9
 9318 0b1a 0A       		.byte	10
 9319 0b1b 08       		.byte	8
 9320 0b1c 11       		.byte	17
 9321 0b1d 0C       		.byte	12
 9322 0b1e 0D       		.byte	13
 9323 0b1f 08       		.byte	8
 9324 0b20 0E       		.byte	14
 9325 0b21 0F       		.byte	15
 9326 0b22 08       		.byte	8
 9327 0b23 00       		.space	1
 9330              	CyFxGpifRegValue_usb2:
 9331 0b24 08830080 		.word	-2147450104
 9332 0b28 67000000 		.word	103
 9333 0b2c 01000000 		.word	1
 9334 0b30 46000000 		.word	70
 9335 0b34 00000000 		.word	0
 9336 0b38 00000000 		.word	0
 9337 0b3c 02000000 		.word	2
 9338 0b40 82000000 		.word	130
 9339 0b44 82070000 		.word	1922
 9340 0b48 40040000 		.word	1088
 9341 0b4c FCFF0000 		.word	65532
 9342 0b50 28000000 		.word	40
 9343 0b54 00000000 		.word	0
 9344 0b58 00000000 		.word	0
 9345 0b5c 00000000 		.word	0
 9346 0b60 00000000 		.word	0
 9347 0b64 01000000 		.word	1
 9348 0b68 00000000 		.word	0
 9349 0b6c 00000000 		.word	0
 9350 0b70 00000000 		.word	0
 9351 0b74 00000000 		.word	0
 9352 0b78 00000000 		.word	0
 9353 0b7c 00000000 		.word	0
 9354 0b80 00000000 		.word	0
 9355 0b84 00000000 		.word	0
 9356 0b88 00000000 		.word	0
 9357 0b8c 00000000 		.word	0
 9358 0b90 00000000 		.word	0
 9359 0b94 00000000 		.word	0
 9360 0b98 06000000 		.word	6
 9361 0b9c 00000000 		.word	0
 9362 0ba0 FFFF0000 		.word	65535
 9363 0ba4 09010000 		.word	265
 9364 0ba8 00000000 		.word	0
 9365 0bac F71F0000 		.word	8183
 9366 0bb0 00000000 		.word	0
 9367 0bb4 FFFF0000 		.word	65535
 9368 0bb8 09010000 		.word	265
 9369 0bbc 00000000 		.word	0
 9370 0bc0 F71F0000 		.word	8183
 9371 0bc4 00000000 		.word	0
 9372 0bc8 00000000 		.word	0
 9373 0bcc 00000000 		.word	0
 9374 0bd0 00000000 		.word	0
 9375 0bd4 00000000 		.word	0
 9376 0bd8 00000000 		.word	0
 9377 0bdc 00000000 		.word	0
 9378 0be0 00000000 		.word	0
 9379 0be4 00000000 		.word	0
 9380 0be8 00000000 		.word	0
 9381 0bec 00000000 		.word	0
 9382 0bf0 00000000 		.word	0
 9383 0bf4 00000000 		.word	0
 9384 0bf8 00000000 		.word	0
 9385 0bfc 00000000 		.word	0
 9386 0c00 00000000 		.word	0
 9387 0c04 00000000 		.word	0
 9388 0c08 00000000 		.word	0
 9389 0c0c 00000000 		.word	0
 9390 0c10 00000000 		.word	0
 9391 0c14 00000000 		.word	0
 9392 0c18 00000000 		.word	0
 9393 0c1c 00000000 		.word	0
 9394 0c20 00040180 		.word	-2147417088
 9395 0c24 01040180 		.word	-2147417087
 9396 0c28 02040180 		.word	-2147417086
 9397 0c2c 03040180 		.word	-2147417085
 9398 0c30 00000000 		.word	0
 9399 0c34 00000000 		.word	0
 9400 0c38 00000000 		.word	0
 9401 0c3c 00000000 		.word	0
 9402 0c40 00000000 		.word	0
 9403 0c44 00000000 		.word	0
 9404 0c48 00000000 		.word	0
 9405 0c4c 00000000 		.word	0
 9406 0c50 C1FFFFFF 		.word	-63
 9407              		.section	.rodata.str1.4,"aMS",%progbits,1
 9408              		.align	2
 9409              	.LC0:
 9410 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9410      7065722D 
 9410      74696D65 
 9410      72202564 
 9410      0D0A00
 9411 0013 00       		.space	1
 9412              	.LC1:
 9413 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9413      636F6D6D 
 9413      616E6420 
 9413      71756575 
 9413      65206973 
 9414 0037 00       		.space	1
 9415              	.LC2:
 9416 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9416      7220696E 
 9416      206D756C 
 9416      74696368 
 9416      616E6E65 
 9417 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 9417      2C20646D 
 9417      61446F6E 
 9417      65202578 
 9417      0D0A00
 9418 007e 0000     		.space	2
 9419              	.LC3:
 9420 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9420      5420656E 
 9420      636F756E 
 9420      74657265 
 9420      642E2E2E 
 9421              	.LC4:
 9422 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9422      454E4420 
 9422      656E636F 
 9422      756E7465 
 9422      7265642E 
 9423 00c2 0000     		.space	2
 9424              	.LC5:
 9425 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9425      64697363 
 9425      6F6E6E65 
 9425      63746564 
 9425      2E2E2E30 
 9426 00e3 00       		.space	1
 9427              	.LC6:
 9428 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9428      43595F46 
 9428      585F5556 
 9428      435F5649 
 9428      44454F5F 
 9429 0117 0A00     		.ascii	"\012\000"
 9430 0119 000000   		.space	3
 9431              	.LC7:
 9432 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9432      43595F46 
 9432      585F5556 
 9432      435F5649 
 9432      44454F5F 
 9433 014f 00       		.ascii	"\000"
 9434              	.LC8:
 9435 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9435      726E6174 
 9435      65207365 
 9435      7474696E 
 9435      6720302E 
 9436              	.LC9:
 9437 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9437      72206665 
 9437      61747572 
 9437      65207265 
 9437      71756573 
 9438 018b 00       		.space	1
 9439              	.LC10:
 9440 018c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9440      6F6D6D69 
 9440      74656F66 
 9440      20737461 
 9440      7465203D 
 9441              	.LC11:
 9442 01a4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9442      6E656C20 
 9442      53657420 
 9442      57726170 
 9442      55702066 
 9443 01d1 000000   		.space	3
 9444              	.LC12:
 9445 01d4 4572726F 		.ascii	"Error handler...\015\012\000"
 9445      72206861 
 9445      6E646C65 
 9445      722E2E2E 
 9445      0D0A00
 9446 01e7 00       		.space	1
 9447              	.LC13:
 9448 01e8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9448      69742045 
 9448      4F462066 
 9448      61696C65 
 9448      64210A00 
 9449              	.LC14:
 9450 01fc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9450      49324320 
 9450      636F6D6D 
 9450      616E6420 
 9450      69732030 
 9451 022f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9451      78257820 
 9451      30782578 
 9451      20307825 
 9451      78203078 
 9452              	.LC15:
 9453 0248 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9453      49324320 
 9453      63757272 
 9453      656E7420 
 9453      64617461 
 9454 027b 64202564 		.ascii	"d %d\015\012\000"
 9454      0D0A00
 9455 0282 0000     		.space	2
 9456              	.LC16:
 9457 0284 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9457      26414743 
 9457      2073656E 
 9457      7420746F 
 9457      20686F73 
 9458 02aa 0000     		.space	2
 9459              	.LC17:
 9460 02ac 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9460      26414743 
 9460      20676F74 
 9460      74656E20 
 9460      66726F6D 
 9461 02d6 0000     		.space	2
 9462              	.LC18:
 9463 02d8 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 9463      6C657665 
 9463      6C2E2025 
 9463      64202564 
 9463      3B202564 
 9464 02f2 0000     		.space	2
 9465              	.LC19:
 9466 02f4 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 9466      7365742E 
 9466      20256420 
 9466      25643B20 
 9466      25642025 
 9467              	.LC20:
 9468 030c 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9468      67657420 
 9468      64617461 
 9468      2066726F 
 9468      6D20686F 
 9469 0339 000000   		.space	3
 9470              	.LC21:
 9471 033c 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9471      52657175 
 9471      65737420 
 9471      30782578 
 9471      20706172 
 9472 036f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9472      6E642074 
 9472      6F20686F 
 9472      73742030 
 9472      78257820 
 9473 038a 0000     		.space	2
 9474              	.LC22:
 9475 038c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9475      204F7020 
 9475      72656365 
 9475      69766573 
 9475      20284354 
 9476 03b3 00       		.space	1
 9477              	.LC23:
 9478 03b4 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9478      756C7420 
 9478      73656C65 
 9478      63746F72 
 9478      20284354 
 9479 03d6 0000     		.space	2
 9480              	.LC24:
 9481 03d8 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9481      756C7420 
 9481      72657175 
 9481      65737420 
 9481      28435429 
 9482 03f9 000000   		.space	3
 9483              	.LC25:
 9484 03fc 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9484      52657175 
 9484      65737420 
 9484      30782578 
 9484      20706172 
 9485 042f 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9485      20307825 
 9485      78202F20 
 9485      73656E64 
 9485      20746F20 
 9486 045c 00       		.ascii	"\000"
 9487 045d 000000   		.space	3
 9488              	.LC26:
 9489 0460 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9489      73706565 
 9489      64203D20 
 9489      25642065 
 9489      76656E66 
 9490 0490 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9490      71756573 
 9490      74203D20 
 9490      30782578 
 9490      20775661 
 9491 04c0 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9491      203D2030 
 9491      78257820 
 9491      6973666C 
 9491      61672030 
 9492 04da 0000     		.space	2
 9493              	.LC27:
 9494 04dc 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9494      64656661 
 9494      756C7420 
 9494      73657475 
 9494      70207265 
 9495              	.LC28:
 9496 0508 54686520 		.ascii	"The host command is not correct for 1080p camera 0x"
 9496      686F7374 
 9496      20636F6D 
 9496      6D616E64 
 9496      20697320 
 9497 053b 25782030 		.ascii	"%x 0x%x %d\015\012\000"
 9497      78257820 
 9497      25640D0A 
 9497      00
 9498              	.LC29:
 9499 0548 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9499      43595F46 
 9499      585F5556 
 9499      435F5354 
 9499      5245414D 
 9500 056e 0000     		.space	2
 9501              	.LC30:
 9502 0570 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9502      55564320 
 9502      7374696C 
 9502      6C207472 
 9502      69676765 
 9503 0596 0000     		.space	2
 9504              	.LC31:
 9505 0598 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9505      7374696C 
 9505      6C207472 
 9505      69676765 
 9505      7220636F 
 9506 05bf 00       		.space	1
 9507              	.LC32:
 9508 05c0 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9508      65642074 
 9508      6F207365 
 9508      6E642069 
 9508      6E746572 
 9509 05f1 0A00     		.ascii	"\012\000"
 9510 05f3 00       		.space	1
 9511              	.LC33:
 9512 05f4 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9512      73657420 
 9512      64656620 
 9512      64617461 
 9512      20307825 
 9513 0613 00       		.space	1
 9514              	.LC34:
 9515 0614 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9515      73657420 
 9515      64656620 
 9515      64617461 
 9515      20307825 
 9516 0647 2E0D0A00 		.ascii	".\015\012\000"
 9517 064b 00       		.space	1
 9518              	.LC35:
 9519 064c 55415254 		.ascii	"UART initialization failed!\012\000"
 9519      20696E69 
 9519      7469616C 
 9519      697A6174 
 9519      696F6E20 
 9520 0669 000000   		.space	3
 9521              	.LC36:
 9522 066c 49324320 		.ascii	"I2C initialization failed!\012\000"
 9522      696E6974 
 9522      69616C69 
 9522      7A617469 
 9522      6F6E2066 
 9523              	.LC37:
 9524 0688 49324320 		.ascii	"I2C configuration failed!\012\000"
 9524      636F6E66 
 9524      69677572 
 9524      6174696F 
 9524      6E206661 
 9525 06a3 00       		.space	1
 9526              	.LC38:
 9527 06a4 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9527      43726561 
 9527      74652045 
 9527      76656E74 
 9527      20666169 
 9528 06ce 0000     		.space	2
 9529              	.LC39:
 9530 06d0 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9530      20496E69 
 9530      74206661 
 9530      696C6564 
 9530      2C204572 
 9531 06f3 00       		.space	1
 9532              	.LC40:
 9533 06f4 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9533      204F7665 
 9533      72726964 
 9533      65206661 
 9533      696C6564 
 9534 071b 00       		.space	1
 9535              	.LC41:
 9536 071c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9536      28323029 
 9536      204F7665 
 9536      72726964 
 9536      65206661 
 9537 0747 00       		.space	1
 9538              	.LC42:
 9539 0748 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9539      28323429 
 9539      204F7665 
 9539      72726964 
 9539      65206661 
 9540 0773 00       		.space	1
 9541              	.LC43:
 9542 0774 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9542      20536574 
 9542      20287265 
 9542      73657420 
 9542      32322920 
 9543 07a6 00       		.ascii	"\000"
 9544 07a7 00       		.space	1
 9545              	.LC44:
 9546 07a8 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9546      20536574 
 9546      2028706F 
 9546      77657220 
 9546      32302920 
 9547 07da 00       		.ascii	"\000"
 9548 07db 00       		.space	1
 9549              	.LC45:
 9550 07dc 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9550      20536574 
 9550      2028736E 
 9550      61702073 
 9550      686F7420 
 9551 080f 25640A00 		.ascii	"%d\012\000"
 9552 0813 00       		.space	1
 9553              	.LC46:
 9554 0814 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9554      46756E63 
 9554      74696F6E 
 9554      20466169 
 9554      6C656420 
 9555 0843 00       		.space	1
 9556              	.LC47:
 9557 0844 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9557      46756E63 
 9557      74696F6E 
 9557      20466169 
 9557      6C656420 
 9558 0873 00       		.space	1
 9559              	.LC48:
 9560 0874 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9560      53657420 
 9560      456E6470 
 9560      6F696E74 
 9560      20636F6E 
 9561 08a4 00       		.ascii	"\000"
 9562 08a5 000000   		.space	3
 9563              	.LC49:
 9564 08a8 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9564      496E7465 
 9564      72727570 
 9564      74205374 
 9564      61747573 
 9565 08db 20436F64 		.ascii	" Code = %d\012\000"
 9565      65203D20 
 9565      25640A00 
 9566 08e7 00       		.space	1
 9567              	.LC50:
 9568 08e8 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9568      65642074 
 9568      6F20616C 
 9568      6C6F6361 
 9568      7465206D 
 9569 091b 65720D0A 		.ascii	"er\015\012\000"
 9569      00
 9570              	.LC51:
 9571 0920 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9571      4368616E 
 9571      6E656C20 
 9571      43726561 
 9571      74696F6E 
 9572 094e 0000     		.space	2
 9573              	.LC52:
 9574 0950 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9574      436F6E6E 
 9574      65637420 
 9574      6661696C 
 9574      65642C20 
 9575 0975 000000   		.space	3
 9576              	.LC53:
 9577 0978 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9577      4368616E 
 9577      6E656C20 
 9577      52657365 
 9577      74204661 
 9578 09a3 00       		.space	1
 9579              	.LC54:
 9580 09a4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9580      4368616E 
 9580      6E656C20 
 9580      53657420 
 9580      5472616E 
 9581 09d5 00       		.ascii	"\000"
 9582 09d6 0000     		.space	2
 9583              	.LC55:
 9584 09d8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9584      4368616E 
 9584      6E656C20 
 9584      53657420 
 9584      5472616E 
 9585 0a09 0A00     		.ascii	"\012\000"
 9586 0a0b 00       		.space	1
 9587              	.LC56:
 9588 0a0c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9588      75706572 
 9588      20677069 
 9588      6600
 9589 0a1a 0000     		.space	2
 9590              	.LC57:
 9591 0a1c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9591      69676820 
 9591      67706966 
 9591      00
 9592 0a29 000000   		.space	3
 9593              	.LC58:
 9594 0a2c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9594      696E6720 
 9594      47504946 
 9594      20436F6E 
 9594      66696775 
 9595 0a5f 0A00     		.ascii	"\012\000"
 9596 0a61 000000   		.space	3
 9597              	.LC59:
 9598 0a64 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9598      74696E67 
 9598      20475049 
 9598      46207374 
 9598      61746520 
 9599 0a97 0D0A00   		.ascii	"\015\012\000"
 9600 0a9a 0000     		.space	2
 9601              	.LC60:
 9602 0a9c 33303A55 		.ascii	"30:UVC App Thread\000"
 9602      56432041 
 9602      70702054 
 9602      68726561 
 9602      6400
 9603 0aae 0000     		.space	2
 9604              	.LC61:
 9605 0ab0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9605      56432041 
 9605      70702045 
 9605      50302054 
 9605      68726561 
 9606 0ac6 0000     		.space	2
 9607              	.LC62:
 9608 0ac8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9608      32432041 
 9608      70702043 
 9608      54524C20 
 9608      54687265 
 9609 0adf 00       		.bss
 9610              		.align	2
 9611              		.set	.LANCHOR0,. + 0
 9614              	glFxUVCEvent:
 9615 0000 00000000 		.space	40
 9615      00000000 
 9615      00000000 
 9615      00000000 
 9615      00000000 
 9618              	fb:
 9619 0028 0000     		.space	2
 9622              	pb:
 9623 002a 0000     		.space	2
 9626              	pbc:
 9627 002c 0000     		.space	2
 9630              	prodCount:
 9631 002e 0000     		.space	2
 9634              	consCount:
 9635 0030 0000     		.space	2
 9636 0032 0000     		.space	2
 9639              	streamingStarted:
 9640 0034 00000000 		.space	4
 9643              	gpif_initialized:
 9644 0038 00000000 		.space	4
 9647              	isUsbConnected:
 9648 003c 00000000 		.space	4
 9651              	clearFeatureRqtReceived:
 9652 0040 00000000 		.space	4
 9655              	hitFV:
 9656 0044 00000000 		.space	4
 9659              	usbSpeed:
 9660 0048 00       		.space	1
 9661 0049 000000   		.space	3
 9664              	I2CCMDArry:
 9665 004c 00000000 		.space	12
 9665      00000000 
 9665      00000000 
 9668              	glEp0Buffer:
 9669 0058 00000000 		.space	32
 9669      00000000 
 9669      00000000 
 9669      00000000 
 9669      00000000 
 9672              	glCommitCtrl:
 9673 0078 00000000 		.space	32
 9673      00000000 
 9673      00000000 
 9673      00000000 
 9673      00000000 
 9676              	stiflag:
 9677 0098 00000000 		.space	4
 9680              	uvcAppThread:
 9681 009c 00000000 		.space	168
 9681      00000000 
 9681      00000000 
 9681      00000000 
 9681      00000000 
 9684              	uvcAppEP0Thread:
 9685 0144 00000000 		.space	168
 9685      00000000 
 9685      00000000 
 9685      00000000 
 9685      00000000 
 9688              	i2cAppThread:
 9689 01ec 00000000 		.space	168
 9689      00000000 
 9689      00000000 
 9689      00000000 
 9689      00000000 
 9692              	testSnap:
 9693 0294 00       		.space	1
 9694 0295 00       		.space	1
 9697              	fbbak:
 9698 0296 0000     		.space	2
 9701              	pbbak:
 9702 0298 0000     		.space	2
 9705              	pbcbak:
 9706 029a 0000     		.space	2
 9709              	pbcpbak:
 9710 029c 0000     		.space	2
 9711 029e 0000     		.text
 9712              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:282    .text:0000020c $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:296    .text:0000022c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:293    .text:0000022c $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:315    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:319    .text:00000240 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:322    .text:00000240 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:480    .text:00000368 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:488    .text:0000037c $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:490    .text:0000037c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:669    .text:000004dc $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:678    .text:000004ec $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:680    .text:000004ec CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1005   .text:000007b4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1021   .text:000007e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1024   .text:000007e0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1070   .text:0000081c $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1083   .text:00000848 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1146   .text:000008b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1153   .text:000008c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1164   .text:000008e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1167   .text:000008e0 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1295   .text:000009f4 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1300   .text:000009fc $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1303   .text:000009fc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1366   .text:00000a7c ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1578   .text:00000c24 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1620   .text:00000cc0 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1685   .text:00000d44 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:1725   .text:00000ddc $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:2980   .text:0000198c $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:2999   .text:000019cc $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:3002   .text:000019cc CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:3170   .text:00001b28 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:3183   .text:00001b50 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:3678   .text:00002060 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:3689   .text:00002080 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:3944   .text:00002338 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:3957   .text:00002360 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:3960   .text:00002360 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:4022   .text:000023dc $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:4030   .text:000023ec $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5157   .text:00002d48 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5185   .text:00002da4 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5188   .text:00002da4 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5479   .text:0000305c $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5486   .text:0000306c $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5489   .text:0000306c CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5525   .text:00003098 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5529   .text:0000309c $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5532   .text:0000309c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5557   .text:000030b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5561   .text:000030bc $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:5564   .text:000030bc UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:6943   .text:00003b80 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7003   .text:00003c54 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7006   .text:00003c54 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7089   .text:00003ce0 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7098   .text:00003cf0 $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7101   .text:00003cf0 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7258   .text:00003e68 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7274   .text:00003e9c $a
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7277   .text:00003e9c main
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8875   .data:00000664 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8884   .data:00000670 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8959   .data:00000790 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8978   .data:000007a0 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7438   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9057   .data:000008d0 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9068   .data:000008e0 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9179   .data:00000a90 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9330   .data:00000b24 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7451   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8871   .data:00000663 snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9692   .bss:00000294 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9618   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9622   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9626   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9697   .bss:00000296 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9701   .bss:00000298 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9705   .bss:0000029a pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9709   .bss:0000029c pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9647   .bss:0000003c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9659   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9651   .bss:00000040 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9639   .bss:00000034 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8782   .data:00000614 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8842   .data:0000064c glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8812   .data:00000630 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8857   .data:00000658 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8433   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7415   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7419   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7463   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7467   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:7790   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8448   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8455   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:8778   .data:00000610 WDRflag
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9408   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9610   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9614   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9630   .bss:0000002e prodCount
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9634   .bss:00000030 consCount
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9643   .bss:00000038 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9655   .bss:00000044 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9664   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9668   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9672   .bss:00000078 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9676   .bss:00000098 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9680   .bss:0000009c uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9684   .bss:00000144 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccZln8NO.s:9688   .bss:000001ec i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
