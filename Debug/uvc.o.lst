   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB17:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 141:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 145:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 146:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 147:../uvc.c      **** };
 148:../uvc.c      **** 
 149:../uvc.c      **** 
 150:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 151:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 152:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 154:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 155:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 156:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 157:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 158:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 159:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 160:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 161:../uvc.c      ****                                    with adjustable compression parameters */
 162:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 163:../uvc.c      ****                                    streaming with adjustable compression parameters */
 164:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 165:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 170:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 171:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 173:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 174:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 175:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 176:../uvc.c      **** };
 177:../uvc.c      **** 
 178:../uvc.c      **** 
 179:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 180:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 181:../uvc.c      **** 
 182:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 183:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 184:../uvc.c      **** {
 185:../uvc.c      ****     0x0C,                               /* Header Length */
 186:../uvc.c      ****     0x8C,                               /* Bit field header field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 188:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 189:../uvc.c      **** };
 190:../uvc.c      **** 
 191:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 192:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 193:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 194:../uvc.c      ****                                                            the current video frame. */
 195:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 196:../uvc.c      **** #ifndef CAM720
 197:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 198:../uvc.c      **** #else
 199:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 200:../uvc.c      **** #endif
 201:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 202:../uvc.c      **** 
 203:../uvc.c      **** /************ control parameters array ***********
 204:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 205:../uvc.c      ****  *    e.g.
 206:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 207:../uvc.c      ****  *     2nd D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 208:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 209:../uvc.c      ****  **************************************************/
 210:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 211:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 212:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 213:../uvc.c      **** #ifndef CAM720
 214:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 215:../uvc.c      **** #else
 216:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 217:../uvc.c      **** #endif
 218:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  63,     0, 1, 0, 3, 0, 31, 0, 
 219:../uvc.c      **** 		{/*2*/0x7/*ContrastReg*/  , 0x7/*ContrastReg*/   , 2,    16,   0,  64,     0, 1, 0, 3, 0, 40, 0, 
 220:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 221:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 222:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 223:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 224:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   14,    0, 1, 0, 3, 0,   0, 0,
 225:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*9*/0x8/*WBModeReg*/    , 0x8/*WBModeReg*/     , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 228:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 229:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 233:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 235:../uvc.c      **** #ifndef CAM720
 236:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 237:../uvc.c      **** #else
 238:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 239:../uvc.c      **** #endif
 240:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 241:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 242:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 244:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 246:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  255,    0, 1, 0, 3, 0,   0,32
 247:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg0     , 2,    0,    0,   63,    0, 1, 0, 3, 0,  32, 0
 248:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		/**********************************
 253:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 254:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 255:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 256:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 257:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 258:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 259:../uvc.c      **** 		 *
 260:../uvc.c      **** 		 *********************************/
 261:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 262:../uvc.c      **** };
 263:../uvc.c      **** 
 264:../uvc.c      **** #ifndef CAM720
 265:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 266:../uvc.c      **** #else
 267:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 268:../uvc.c      **** #endif
 269:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 270:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 271:../uvc.c      **** 
 272:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 273:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 274:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 275:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 276:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 277:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 278:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 279:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 280:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 281:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 282:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 285:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 287:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 288:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 289:../uvc.c      **** };
 290:../uvc.c      **** 
 291:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 292:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 293:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 294:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 295:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 296:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 297:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 298:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 299:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 300:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 302:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 303:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 304:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 308:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 309:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 310:../uvc.c      **** };
 311:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 312:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 313:../uvc.c      **** 
 314:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 315:../uvc.c      **** 
 316:../uvc.c      **** /*
 317:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 318:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 319:../uvc.c      ****  */
 320:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 321:../uvc.c      **** 		0xa0, 0x0f, 0xf, 0xf0
 322:../uvc.c      **** };
 323:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 324:../uvc.c      **** 		0
 325:../uvc.c      **** };
 326:../uvc.c      **** 
 327:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 328:../uvc.c      **** 
 329:../uvc.c      **** void I2CCmdHandler(){
 330:../uvc.c      **** 	uint8_t buf[2];
 331:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 332:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 333:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 334:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 335:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 336:../uvc.c      **** 
 337:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 338:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 339:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 340:../uvc.c      **** 
 341:../uvc.c      **** 	if(CmdType == 0)//I2C read
 342:../uvc.c      **** 	{
 343:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 344:../uvc.c      **** #if 0 //for debugging
 345:../uvc.c      **** 		/* test still image operation */
 346:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 347:../uvc.c      **** 			snapButFlag = 0; //press
 348:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 349:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 350:../uvc.c      **** 			snapButFlag = 0xf; //release
 351:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 352:../uvc.c      **** 		}
 353:../uvc.c      **** 
 354:../uvc.c      **** 		/* end of the test */
 355:../uvc.c      **** #endif
 356:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 357:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 358:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 359:../uvc.c      **** 			if(CmdDataLen == 2){
 360:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 361:../uvc.c      **** 			}
 362:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 363:../uvc.c      **** 		}else{//not support currently
 364:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 365:../uvc.c      **** 		}
 366:../uvc.c      **** 	}else if(CmdType == 1){
 367:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 368:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 369:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 370:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 371:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 372:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 373:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 374:../uvc.c      **** 			}
 375:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 376:../uvc.c      **** 		}else{//not support currently
 377:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 378:../uvc.c      **** 		}
 379:../uvc.c      **** 
 380:../uvc.c      **** 	}
 381:../uvc.c      **** }
 382:../uvc.c      **** 
 383:../uvc.c      **** /************************************
 384:../uvc.c      ****  * set Iris mode
 385:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 386:../uvc.c      ****  */
 387:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 388:../uvc.c      **** 	uint8_t dataIdx;
 389:../uvc.c      **** 	  dataIdx = 0;
 390:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 392:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 393:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 394:../uvc.c      **** }
 395:../uvc.c      **** 
 396:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 397:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 398:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 399:../uvc.c      ****     uint16_t readCount;
 400:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 401:../uvc.c      ****     uint8_t devAdd;
 402:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 403:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 404:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 405:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 406:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 407:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 408:../uvc.c      ****     }else{
 409:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 410:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 411:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 412:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 413:../uvc.c      ****     }
 414:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 415:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 416:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 417:../uvc.c      **** #endif
 418:../uvc.c      ****     reqData = bRequest;
 419:../uvc.c      ****     /*
 420:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 421:../uvc.c      ****      */
 422:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 423:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 424:../uvc.c      ****     	goto EndofSet;
 425:../uvc.c      ****     }
 426:../uvc.c      ****     switch (bRequest)
 427:../uvc.c      **** 		 {
 428:../uvc.c      **** 
 429:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 430:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 431:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 432:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 433:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 434:../uvc.c      **** 			  break;
 435:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 436:../uvc.c      **** 
 437:../uvc.c      **** 			 switch(CtrlID)
 438:../uvc.c      **** 			 {
 439:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 440:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 441:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 442:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 443:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 444:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 445:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 446:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 447:../uvc.c      **** 			 	 		 break;
 448:../uvc.c      **** 			 	 }
 449:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 450:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 451:../uvc.c      **** 					 if(CamMode == 1){//720p or invendo
 452:../uvc.c      **** 						if(sendData >= 3){
 453:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 454:../uvc.c      **** 							sendData = 0; //set back to default
 455:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 456:../uvc.c      **** 						}
 457:../uvc.c      **** 						sendData += 4;
 458:../uvc.c      **** 					 }
 459:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 460:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 461:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 462:../uvc.c      **** 					 break;
 463:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 464:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 465:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 466:../uvc.c      **** 			 		 }
 467:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 468:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 469:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 470:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 471:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 472:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 473:../uvc.c      **** #endif
 474:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 475:../uvc.c      **** 			 		 {
 476:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 477:../uvc.c      **** 			 		 }
 478:../uvc.c      **** 			 		 break;
 479:../uvc.c      **** 				 case ExtAexModCtlID9:
 480:../uvc.c      **** 
 481:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 482:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 483:../uvc.c      **** 						 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 484:../uvc.c      **** 		 	 		 }else{
 485:../uvc.c      **** 		 	 			//remove for invendo
 486:../uvc.c      **** 		 	 			//glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 487:../uvc.c      **** 		 	 			//glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 488:../uvc.c      **** 		 	 			//CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 489:../uvc.c      **** 
 490:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 491:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 492:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 493:../uvc.c      **** 		 	 		 }
 494:../uvc.c      **** 
 495:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 497:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 498:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 499:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 500:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 501:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 502:../uvc.c      **** 					 break;
 503:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 504:../uvc.c      **** 			 	 case BrgtCtlID1:
 505:../uvc.c      **** 
 506:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 507:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 508:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 509:../uvc.c      **** 		 	 		 }else{
 510:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 511:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 512:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 513:../uvc.c      **** 
 514:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 515:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 516:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 517:../uvc.c      **** 		 	 		 }
 518:../uvc.c      **** 
 519:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 520:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 521:../uvc.c      **** 					 }else{
 522:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 523:../uvc.c      **** 					 }
 524:../uvc.c      **** 
 525:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 526:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 527:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 528:../uvc.c      **** 					 break;
 529:../uvc.c      **** #endif
 530:../uvc.c      **** 				 case HueCtlID5://TODO check sensor register
 531:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 532:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 533:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 534:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 535:../uvc.c      **** 					 break;
 536:../uvc.c      **** 				 case WBTLevCtlID11:
 537:../uvc.c      **** 
 538:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 539:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 540:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 541:../uvc.c      **** 		 	 		 }else{
 542:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd1, devAdd);
 543:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 544:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 545:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 546:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 547:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 548:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 549:../uvc.c      **** 		 	 		 }
 550:../uvc.c      **** 
 551:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 552:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 553:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 554:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 555:../uvc.c      **** 					 break;
 556:../uvc.c      **** 				 case SaturCtlID6://TODO check sensor register
 557:../uvc.c      **** 				 default:
 558:../uvc.c      **** 
 559:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 560:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 561:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 562:../uvc.c      **** 		 	 		 }else{
 563:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 564:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 565:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 566:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 567:../uvc.c      **** 		 	 		 }
 568:../uvc.c      **** 
 569:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 570:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 571:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 572:../uvc.c      **** 					 break;
 573:../uvc.c      **** 			 }
 574:../uvc.c      **** 
 575:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 576:../uvc.c      **** 
 577:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 578:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 579:../uvc.c      **** #endif
 580:../uvc.c      **** 			  break;
 581:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 582:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 583:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 584:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 585:../uvc.c      **** 		 	 }
 586:../uvc.c      **** 
 587:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 588:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 589:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 590:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 591:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 592:../uvc.c      **** 			 }else
 593:../uvc.c      **** 			 {
 594:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 595:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 596:../uvc.c      **** 			 }
 597:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 598:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 599:../uvc.c      **** 			  break;
 600:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 601:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 602:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 603:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 604:../uvc.c      **** 		 	 }
 605:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 606:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 607:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 608:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 609:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 610:../uvc.c      **** 			 }else
 611:../uvc.c      **** 			 {
 612:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 613:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 614:../uvc.c      **** 			 }
 615:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 616:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 617:../uvc.c      **** 			  break;
 618:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 619:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 620:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 621:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 622:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 623:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 624:../uvc.c      **** 		 	 }
 625:../uvc.c      **** 		 	 else{
 626:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 627:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 628:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 629:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 630:../uvc.c      **** 		 	 }
 631:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 632:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 633:../uvc.c      **** 			  break;
 634:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 635:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 636:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 637:../uvc.c      **** 		 	 }
 638:../uvc.c      **** 		 	 else{
 639:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 640:../uvc.c      **** 		 	 }
 641:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 642:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 643:../uvc.c      **** 			  Len = 1;
 644:../uvc.c      **** 			  break;
 645:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 646:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 647:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 648:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 649:../uvc.c      **** 		 	 }
 650:../uvc.c      **** 
 651:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 652:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 653:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 654:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 655:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 656:../uvc.c      **** 			 }else{
 657:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 658:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 659:../uvc.c      **** 			 }
 660:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 661:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 662:../uvc.c      **** 			  break;
 663:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 664:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 665:../uvc.c      **** 				  glEp0Buffer, &readCount);
 666:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 667:../uvc.c      **** 			   {
 668:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 669:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 670:../uvc.c      **** 				  getData = glEp0Buffer[0];
 671:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 672:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 673:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 674:../uvc.c      **** #endif
 675:../uvc.c      **** 				  switch(CtrlID)
 676:../uvc.c      **** 					 {
 677:../uvc.c      **** 						 case ExtShutCtlID0:
 678:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 679:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 680:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 681:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 682:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 683:../uvc.c      **** 									 }else{
 684:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 685:../uvc.c      **** 									 }
 686:../uvc.c      **** 								 }
 687:../uvc.c      **** 							 }else{
 688:../uvc.c      **** 								 Data1 = Data0 - 1;
 689:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 690:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 691:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 692:../uvc.c      **** 									 }else{
 693:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 694:../uvc.c      **** 									 }
 695:../uvc.c      **** 								 }
 696:../uvc.c      **** 								 if(Data1 < 8){
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 698:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 699:../uvc.c      **** 								 }else{
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 701:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 702:../uvc.c      **** 								 }
 703:../uvc.c      **** 							 }
 704:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 705:../uvc.c      **** 							 dataIdx = 0;
 706:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 707:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 708:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 709:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 710:../uvc.c      **** 							 break;
 711:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 714:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 715:../uvc.c      **** 							 dataIdx = 0;
 716:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 717:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 718:../uvc.c      **** 							 if(1 || (getData != 0)){
 719:../uvc.c      **** 								 //dataIdx++;
 720:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 721:../uvc.c      **** 							 }
 722:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 723:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 724:../uvc.c      **** 							 break;
 725:../uvc.c      **** 						 case ExtExRefCtlID10:
 726:../uvc.c      **** 							 dataIdx = 0;
 727:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 728:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 729:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 730:../uvc.c      **** 							 if(WDRflag)
 731:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 732:../uvc.c      **** 							 else
 733:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 734:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 735:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 736:../uvc.c      **** 						 case ExtCamMCtlID12:
 737:../uvc.c      **** 							 /*
 738:../uvc.c      **** 							 dataIdx = 0;
 739:../uvc.c      **** 							 if(Data0 <= 3){
 740:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 741:../uvc.c      **** 								 Data1 = Data0;
 742:../uvc.c      **** 							 }else{
 743:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 744:../uvc.c      **** 								 Data1 = Data0-4;
 745:../uvc.c      **** 							 }
 746:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 747:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 748:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 749:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 750:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 751:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 752:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 753:../uvc.c      **** 							 */
 754:../uvc.c      **** 							 break;
 755:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 756:../uvc.c      **** 							 dataIdx = 0;
 757:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 758:../uvc.c      **** 								 Data0 = 1;
 759:../uvc.c      **** 							 }else{ //save current sensor parameters.
 760:../uvc.c      **** 								 Data0 = 0;
 761:../uvc.c      **** 							 }
 762:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 763:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 764:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 765:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 766:../uvc.c      **** 							 break;
 767:../uvc.c      **** 						 case ExtI2CCtlID15:
 768:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 769:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 770:../uvc.c      **** 					 		 }
 771:../uvc.c      **** 					 		I2CCmdHandler();
 772:../uvc.c      **** 							 break;
 773:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 774:../uvc.c      **** 							 dataIdx = 0;
 775:../uvc.c      **** #if 0 //seperate version
 776:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 777:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 778:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 779:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 780:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 781:../uvc.c      **** 							 }else{ //disable BLD window
 782:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 783:../uvc.c      **** 							 }
 784:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 786:../uvc.c      **** 							 dataIdx++;
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 788:../uvc.c      **** 							 dataIdx++;
 789:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 790:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 791:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 792:../uvc.c      **** 							 dataIdx++;
 793:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 794:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 795:../uvc.c      **** #else //combination version
 796:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 797:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 798:../uvc.c      **** 						     /* end test */
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 800:../uvc.c      **** 							 dataIdx++;
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 802:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 803:../uvc.c      **** 							 getData1 = Data1;
 804:../uvc.c      **** #endif
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 807:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 808:../uvc.c      **** 							 break;
 809:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 810:../uvc.c      **** 							 dataIdx = 0;
 811:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 812:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 813:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 815:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 816:../uvc.c      **** 							 break;
 817:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 818:../uvc.c      **** 							 dataIdx = 0;
 819:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 820:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 821:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 823:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 824:../uvc.c      **** 							 break;
 825:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 826:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 827:../uvc.c      **** 							 dataIdx = 0;
 828:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 829:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 830:../uvc.c      **** 							  if(Data0&0x80){
 831:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 832:../uvc.c      **** 							  }else{
 833:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 834:../uvc.c      **** 							  }
 835:../uvc.c      **** 							 Data1 |= ~0x03;
 836:../uvc.c      **** 							 Data1 &= 0xC7;
 837:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 838:../uvc.c      **** 						  	 dataIdx++;
 839:../uvc.c      **** 
 840:../uvc.c      **** 							 Data0 = (Data0 << 2);
 841:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 842:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 843:../uvc.c      **** 
 844:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 845:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 846:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 847:../uvc.c      **** 
 848:../uvc.c      **** 							 break;
 849:../uvc.c      **** #endif
 850:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 851:../uvc.c      **** 							 dataIdx = 0;
 852:../uvc.c      **** 
 853:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 854:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 855:../uvc.c      **** 							 dataIdx++;
 856:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 857:../uvc.c      **** 							 dataIdx++;
 858:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 859:../uvc.c      **** 							 dataIdx++;
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 861:../uvc.c      **** 							 dataIdx++;
 862:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 863:../uvc.c      **** 							 dataIdx++;
 864:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 865:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 866:../uvc.c      **** 
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 868:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 869:../uvc.c      **** 							 break;
 870:../uvc.c      **** 						 case SaturCtlID6:
 871:../uvc.c      **** 							 dataIdx = 0;
 872:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 875:../uvc.c      **** 							 dataIdx++;
 876:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 877:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 878:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 879:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 880:../uvc.c      **** 							 break;
 881:../uvc.c      **** 
 882:../uvc.c      **** 						 case WBTLevCtlID11:
 883:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue to 0x9 or low to 0xa
 884:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red to 0xa or high to 0x9
 885:../uvc.c      **** 							 dataIdx = 0;
 886:../uvc.c      **** 
 887:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 888:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 889:../uvc.c      **** 							 dataIdx++;
 890:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data1, dataIdx);  //Second
 891:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 892:../uvc.c      **** 
 893:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 894:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 895:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 896:../uvc.c      **** 							 break;
 897:../uvc.c      **** 						 case MFreqCtlID4:
 898:../uvc.c      **** 							 dataIdx = 0;
 899:../uvc.c      **** 							 Data0 = Data0 - 1;
 900:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 901:../uvc.c      **** 								 Data0 = 0;
 902:../uvc.c      **** 							 else if(Data0 >2)
 903:../uvc.c      **** 								 Data0 = 1;
 904:../uvc.c      **** 
 905:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 906:../uvc.c      **** 							 //remove for Invendo
 907:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 908:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 909:../uvc.c      **** 
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 911:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 912:../uvc.c      **** 							 break;
 913:../uvc.c      **** 					 	 case BLCCtlID0:
 914:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 915:../uvc.c      **** 							 if(Data0 == 3)
 916:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 917:../uvc.c      **** 							 else
 918:../uvc.c      **** 								 WDRflag = CyFalse;
 919:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 920:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 921:../uvc.c      **** 							 {
 922:../uvc.c      **** 								 if(Data0 < 2){
 923:../uvc.c      **** 					 				 ;//Data0 += 4;
 924:../uvc.c      **** 					 			 }else{
 925:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 926:../uvc.c      **** 									Data0 = 0; //set to default.
 927:../uvc.c      **** 					 			 }
 928:../uvc.c      **** 					 		 }
 929:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 930:../uvc.c      **** 							 dataIdx = 0;
 931:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 932:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 933:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 934:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 935:../uvc.c      **** 
 936:../uvc.c      **** 					 		 break;
 937:../uvc.c      **** 						 default:
 938:../uvc.c      **** 							 dataIdx = 0;
 939:../uvc.c      **** 
 940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 941:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 942:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 943:../uvc.c      **** 
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 945:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 946:../uvc.c      **** 							 break;
 947:../uvc.c      **** 					 }
 948:../uvc.c      **** 			   }else{
 949:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 950:../uvc.c      **** 			   }
 951:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 952:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 953:../uvc.c      **** #endif
 954:../uvc.c      **** 
 955:../uvc.c      **** 			  break;
 956:../uvc.c      **** 		  default:
 957:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 958:../uvc.c      **** 			  break;
 959:../uvc.c      **** 		 }
 960:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 961:../uvc.c      **** }
 962:../uvc.c      **** /************** CT control requests handler *************************/
 963:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 964:../uvc.c      **** 
 965:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 966:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 967:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 968:../uvc.c      ****     uint16_t readCount;
 969:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 970:../uvc.c      ****     uint16_t diff, value, diffRd;
 971:../uvc.c      ****     uint8_t i, shutter, index;
 972:../uvc.c      ****     diff = 0xffff;
 973:../uvc.c      ****     shutter = 1;
 974:../uvc.c      ****     index = 1;
 975:../uvc.c      **** 
 976:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 977:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 978:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 979:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 980:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 981:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 982:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 983:../uvc.c      **** #endif
 984:../uvc.c      ****     reqData = bRequest;
 985:../uvc.c      **** 
 986:../uvc.c      ****     switch (bRequest)
 987:../uvc.c      **** 		 {
 988:../uvc.c      **** 
 989:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 990:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 991:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 993:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 994:../uvc.c      **** 			  break;
 995:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 996:../uvc.c      **** 
 997:../uvc.c      **** 			 switch(CtrlID)
 998:../uvc.c      **** 			 {
 999:../uvc.c      **** 				 default:
1000:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1001:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1002:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1003:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1004:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1005:../uvc.c      **** 					 break;
1006:../uvc.c      **** 			 }
1007:../uvc.c      **** 
1008:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1009:../uvc.c      **** 
1010:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1011:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1012:../uvc.c      **** #endif
1013:../uvc.c      **** 			  break;
1014:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1015:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1016:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1017:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1018:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1019:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1020:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1021:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1022:../uvc.c      **** 			  break;
1023:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1024:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1025:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1026:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1027:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1028:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1029:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1030:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1031:../uvc.c      **** 			  break;
1032:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1033:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1034:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1035:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1036:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1037:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1040:../uvc.c      **** 			  break;
1041:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1042:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1043:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1044:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1045:../uvc.c      **** 			  Len = 1;
1046:../uvc.c      **** 			  break;
1047:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1048:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1049:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1050:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1051:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1052:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1053:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1054:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1055:../uvc.c      **** 			  break;
1056:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1057:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1058:../uvc.c      **** 			  glEp0Buffer, &readCount);
1059:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1060:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1061:../uvc.c      **** 			  value = Data1;
1062:../uvc.c      **** 
1063:../uvc.c      **** 			  switch(CtrlID)
1064:../uvc.c      **** 			  {
1065:../uvc.c      **** 		  	      case AutoExMCtlID1:
1066:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1067:../uvc.c      **** 
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1069:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1070:../uvc.c      **** 				    getData = glEp0Buffer[0];
1071:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1072:../uvc.c      **** 		  		    switch (getData){
1073:../uvc.c      **** 						case 1:
1074:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1075:../uvc.c      **** 							break;
1076:../uvc.c      **** 						case 2:
1077:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1078:../uvc.c      **** 							dataIdx = 0;
1079:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1080:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1081:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1082:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1083:../uvc.c      **** 
1084:../uvc.c      **** 							break;
1085:../uvc.c      **** 						case 4:
1086:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1087:../uvc.c      **** 							break;
1088:../uvc.c      **** 						case 8:
1089:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1090:../uvc.c      **** 			  		    	dataIdx = 0;
1091:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1092:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1093:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1094:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1095:../uvc.c      **** 							break;
1096:../uvc.c      **** 		  		    }
1097:../uvc.c      **** #if 0
1098:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1099:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1100:../uvc.c      **** 						  dataIdx = 0;
1101:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1102:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1103:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1104:../uvc.c      **** 		  		    }
1105:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1106:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1107:../uvc.c      **** 		  		    }
1108:../uvc.c      **** #endif
1109:../uvc.c      **** 				    break;
1110:../uvc.c      **** 
1111:../uvc.c      **** 			  	  case ExTmACtlID3:
1112:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1113:../uvc.c      **** 
1114:../uvc.c      **** 					  value = (value << 8)|Data0;
1115:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1116:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1117:../uvc.c      **** 					  {
1118:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1119:../uvc.c      **** 						  {
1120:../uvc.c      **** 							if(value > ShutValueArry[i]){
1121:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1122:../uvc.c      **** 							}else{
1123:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1124:../uvc.c      **** 							}
1125:../uvc.c      **** 							  if(diff > diffRd){
1126:../uvc.c      **** 								  diff = diffRd;
1127:../uvc.c      **** 								  index = i;
1128:../uvc.c      **** 							  }
1129:../uvc.c      **** 						  }
1130:../uvc.c      **** 						  shutter = shutter+index;
1131:../uvc.c      **** 
1132:../uvc.c      **** 						  dataIdx = 0;
1133:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1134:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1135:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1136:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1137:../uvc.c      **** 
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1140:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1141:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1142:../uvc.c      **** 					  }else{
1143:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1144:../uvc.c      **** 					  }
1145:../uvc.c      **** 					  getData = glEp0Buffer[0];
1146:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1147:../uvc.c      **** 					  break;
1148:../uvc.c      **** 			  	  case IriACtlID7:
1149:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1150:../uvc.c      **** 					  {
1151:../uvc.c      **** 							 dataIdx = 0;
1152:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1153:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1154:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1155:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1156:../uvc.c      **** 
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1159:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1160:../uvc.c      **** 					  }else{
1161:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1162:../uvc.c      **** 					  }
1163:../uvc.c      **** 					  getData = glEp0Buffer[0];
1164:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1165:../uvc.c      **** 
1166:../uvc.c      **** 					  break;
1167:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1168:../uvc.c      **** 					  getData = glEp0Buffer[0];
1169:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1170:../uvc.c      **** #if 1
1171:../uvc.c      **** 					  dataIdx = 0;
1172:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1173:../uvc.c      **** 					  if(getData == 1)
1174:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1175:../uvc.c      **** 					  else if(getData == 0xff)
1176:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1177:../uvc.c      **** 					  else
1178:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1179:../uvc.c      **** 					  //dataIdx++;
1180:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1181:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1182:../uvc.c      **** #endif
1183:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1184:../uvc.c      **** 					  break;
1185:../uvc.c      **** 
1186:../uvc.c      **** 			  	  default:
1187:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1188:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1189:../uvc.c      **** 			  		 break;
1190:../uvc.c      **** 			  }
1191:../uvc.c      **** 			  break;
1192:../uvc.c      **** 		  default:
1193:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1194:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1195:../uvc.c      **** 			  break;
1196:../uvc.c      **** 		 }
1197:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1198:../uvc.c      **** 
1199:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1200:../uvc.c      **** }
1201:../uvc.c      **** 
1202:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1203:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1204:../uvc.c      **** {
1205:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1206:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1207:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1208:../uvc.c      **** 
1209:../uvc.c      ****     CtrlID = BrgtCtlID1;
1210:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1211:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1212:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1213:../uvc.c      ****     Data1 = Data0;
1214:../uvc.c      **** 
1215:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1216:../uvc.c      ****     if(Data1&0x80){
1217:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1218:../uvc.c      ****     }else{
1219:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1220:../uvc.c      ****     }
1221:../uvc.c      ****     Data0 = (Data0 << 2);
1222:../uvc.c      **** 
1223:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1224:../uvc.c      **** 
1225:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1226:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1227:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1228:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1229:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1230:../uvc.c      **** 
1231:../uvc.c      ****     CtrlID = ConsCtlID2;
1232:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1233:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1234:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1235:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1236:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1237:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1238:../uvc.c      **** 
1239:../uvc.c      ****     CtrlID = HueCtlID5;
1240:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1241:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1242:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1248:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1249:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1250:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1251:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1252:../uvc.c      **** 
1253:../uvc.c      ****     CtrlID = SaturCtlID6;
1254:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1255:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1256:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1257:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1258:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1259:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1260:../uvc.c      **** 
1261:../uvc.c      ****     CtrlID = ShapCtlID7;
1262:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1263:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1264:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1265:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1266:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1267:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1268:../uvc.c      **** 
1269:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1270:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1271:../uvc.c      **** 	return;
1272:../uvc.c      **** }
1273:../uvc.c      **** 
1274:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1275:../uvc.c      **** void
1276:../uvc.c      **** CyFxUVCAddHeader (
1277:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1278:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1279:../uvc.c      ****         )
1280:../uvc.c      **** {
1281:../uvc.c      ****     /* Copy header to buffer */
1282:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1283:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1284:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1285:../uvc.c      **** 
1286:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1287:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1288:../uvc.c      ****     {
1289:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1290:../uvc.c      ****     }
1291:../uvc.c      **** }
1292:../uvc.c      **** 
1293:../uvc.c      **** 
1294:../uvc.c      **** /* Application Error Handler */
1295:../uvc.c      **** void
1296:../uvc.c      **** CyFxAppErrorHandler (
1297:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1298:../uvc.c      ****         )
1299:../uvc.c      **** {
1300:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1301:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1302:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1303:../uvc.c      **** 
1304:../uvc.c      ****        This function can be modified to take additional error handling actions such
1305:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1306:../uvc.c      ****      */
1307:../uvc.c      ****     for (;;)
1308:../uvc.c      ****     {
1309:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1310:../uvc.c      ****         CyU3PThreadSleep (1000);
1311:../uvc.c      ****     }
1312:../uvc.c      **** }
1313:../uvc.c      **** 
1314:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1315:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1316:../uvc.c      ****  */
1317:../uvc.c      **** static void
1318:../uvc.c      **** CyFxUVCApplnAbortHandler (
1319:../uvc.c      ****         void)
1320:../uvc.c      **** {
1321:../uvc.c      **** 	uint32_t flag;
1322:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1323:../uvc.c      **** 	{
1324:../uvc.c      ****         /* Clear the Video Stream Request Event */
1325:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1326:../uvc.c      **** 
1327:../uvc.c      ****         /* Set Video Stream Abort Event */
1328:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1329:../uvc.c      **** 	}
1330:../uvc.c      **** }
1331:../uvc.c      **** 
1332:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1333:../uvc.c      **** static void
1334:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1335:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1336:../uvc.c      ****         uint16_t             evdata  /* Event data */
1337:../uvc.c      ****         )
1338:../uvc.c      **** {
1339:../uvc.c      ****     switch (evtype)
1340:../uvc.c      ****     {
1341:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1342:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1343:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1344:../uvc.c      ****             gpif_initialized = 0;
1345:../uvc.c      ****             streamingStarted = CyFalse;
1346:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1347:../uvc.c      ****             break;
1348:../uvc.c      **** 
1349:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1350:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1351:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1352:../uvc.c      ****             gpif_initialized = 0;
1353:../uvc.c      ****             streamingStarted = CyFalse;
1354:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1355:../uvc.c      ****             break;
1356:../uvc.c      **** 
1357:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1358:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1359:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1360:../uvc.c      ****             gpif_initialized = 0;
1361:../uvc.c      ****             isUsbConnected = CyFalse;
1362:../uvc.c      ****             streamingStarted = CyFalse;
1363:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1364:../uvc.c      ****             break;
1365:../uvc.c      **** 
1366:../uvc.c      **** #ifdef BACKFLOW_DETECT
1367:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1368:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1369:../uvc.c      ****             break;
1370:../uvc.c      **** #endif
1371:../uvc.c      **** 
1372:../uvc.c      ****         default:
1373:../uvc.c      ****             break;
1374:../uvc.c      ****     }
1375:../uvc.c      **** }
1376:../uvc.c      **** 
1377:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1378:../uvc.c      **** static CyBool_t
1379:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1380:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1381:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1382:../uvc.c      ****         )
1383:../uvc.c      **** {
1384:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1385:../uvc.c      ****     uint32_t status;
1386:../uvc.c      **** 
1387:../uvc.c      ****     /* Obtain Request Type and Request */
1388:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1389:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1390:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1391:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1392:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1393:../uvc.c      **** 
1394:../uvc.c      ****     /* Check for UVC Class Requests */
1395:../uvc.c      ****     switch (bmReqType)
1396:../uvc.c      ****     {
1397:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1398:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1399:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1400:../uvc.c      ****             switch (wIndex & 0xFF)
1401:../uvc.c      ****             {
1402:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1403:../uvc.c      ****                     {
1404:../uvc.c      ****                         uvcHandleReq = CyTrue;
1405:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1406:../uvc.c      ****                                 CYU3P_EVENT_OR);
1407:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1408:../uvc.c      ****                         {
1409:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1410:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1411:../uvc.c      ****                         }
1412:../uvc.c      ****                     }
1413:../uvc.c      ****                     break;
1414:../uvc.c      **** 
1415:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1416:../uvc.c      ****                     {
1417:../uvc.c      ****                         uvcHandleReq = CyTrue;
1418:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1419:../uvc.c      ****                                 CYU3P_EVENT_OR);
1420:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1421:../uvc.c      ****                         {
1422:../uvc.c      ****                             /* Error handling */
1423:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1424:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1425:../uvc.c      ****                         }
1426:../uvc.c      ****                     }
1427:../uvc.c      ****                     break;
1428:../uvc.c      **** 
1429:../uvc.c      ****                 default:
1430:../uvc.c      ****                     break;
1431:../uvc.c      ****             }
1432:../uvc.c      ****             break;
1433:../uvc.c      **** 
1434:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1435:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1436:../uvc.c      ****             {
1437:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1438:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1439:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1440:../uvc.c      ****                 {
1441:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1442:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1443:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1444:../uvc.c      ****                     gpif_initialized = 0;
1445:../uvc.c      ****                     streamingStarted = CyFalse;
1446:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1447:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1448:../uvc.c      ****                     CyU3PBusyWait (100);
1449:../uvc.c      **** 
1450:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1451:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1452:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1453:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1454:../uvc.c      ****                     CyU3PBusyWait (100);
1455:../uvc.c      **** 
1456:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1457:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1458:../uvc.c      ****                     uvcHandleReq = CyTrue;
1459:../uvc.c      ****                     /* Complete Control request handshake */
1460:../uvc.c      ****                     CyU3PUsbAckSetup ();
1461:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1462:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1463:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1464:../uvc.c      **** 
1465:../uvc.c      ****                 }
1466:../uvc.c      ****             }
1467:../uvc.c      ****             break;
1468:../uvc.c      **** 
1469:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1470:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1471:../uvc.c      ****             {
1472:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1473:../uvc.c      ****                 {
1474:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1475:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1476:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1477:../uvc.c      ****                 	 * has started. */
1478:../uvc.c      ****                     if (streamingStarted == CyTrue)
1479:../uvc.c      ****                     {
1480:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1481:../uvc.c      **** 
1482:../uvc.c      ****                         /* Disable the GPIF state machine. */
1483:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1484:../uvc.c      ****                         gpif_initialized = 0;
1485:../uvc.c      ****                         streamingStarted = CyFalse;
1486:../uvc.c      **** 
1487:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1488:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1489:../uvc.c      ****                         CyU3PBusyWait (100);
1490:../uvc.c      **** 
1491:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1492:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1493:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1494:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1495:../uvc.c      ****                         CyU3PBusyWait (100);
1496:../uvc.c      **** 
1497:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1498:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1499:../uvc.c      **** 
1500:../uvc.c      ****                         uvcHandleReq = CyTrue;
1501:../uvc.c      ****                         /* Complete Control request handshake */
1502:../uvc.c      ****                         CyU3PUsbAckSetup ();
1503:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1504:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1505:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1506:../uvc.c      ****                     }
1507:../uvc.c      ****                     else
1508:../uvc.c      ****                     {
1509:../uvc.c      ****                         uvcHandleReq = CyTrue;
1510:../uvc.c      ****                         CyU3PUsbAckSetup ();
1511:../uvc.c      ****                     }
1512:../uvc.c      ****                 }
1513:../uvc.c      ****             }
1514:../uvc.c      ****             break;
1515:../uvc.c      **** 
1516:../uvc.c      ****         default:
1517:../uvc.c      ****             break;
1518:../uvc.c      ****     }
1519:../uvc.c      **** 
1520:../uvc.c      ****     /* Return status of request handling to the USB driver */
1521:../uvc.c      ****     return uvcHandleReq;
1522:../uvc.c      **** }
1523:../uvc.c      **** 
1524:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1525:../uvc.c      **** 
1526:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1527:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1528:../uvc.c      ****  */
1529:../uvc.c      **** void
1530:../uvc.c      **** CyFxUvcApplnDmaCallback (
1531:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1532:../uvc.c      ****         CyU3PDmaCbType_t      type,
1533:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1534:../uvc.c      ****         )
1535:../uvc.c      **** {
1536:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1537:../uvc.c      **** #if 1
1538:../uvc.c      ****     CyU3PReturnStatus_t status;
1539:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1540:../uvc.c      ****     {
1541:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1542:../uvc.c      ****             {
1543:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1544:../uvc.c      ****                 fb++;
1545:../uvc.c      ****             }
1546:../uvc.c      ****             else
1547:../uvc.c      ****             {
1548:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1549:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1550:../uvc.c      ****                 pb++;
1551:../uvc.c      ****                 pbc = input->buffer_p.count;
1552:../uvc.c      ****                // hitFV = CyTrue;
1553:../uvc.c      **** #if 1   //remove the still flag clearing here
1554:../uvc.c      ****                 if(stiflag == 0x0F){
1555:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1556:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1557:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1558:../uvc.c      ****                 	//stiflag = 0xAA;
1559:../uvc.c      ****                 	stiflag = 0x0;//set back to video
1560:../uvc.c      ****                 }
1561:../uvc.c      **** #endif
1562:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1563:../uvc.c      ****             }
1564:../uvc.c      **** 
1565:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1566:../uvc.c      ****             prodCount++;
1567:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1568:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1569:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1570:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1571:../uvc.c      ****             {
1572:../uvc.c      ****                 prodCount--;
1573:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1574:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1575:../uvc.c      ****             }
1576:../uvc.c      ****     }
1577:../uvc.c      **** #endif
1578:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1579:../uvc.c      ****     {
1580:../uvc.c      ****         consCount++;
1581:../uvc.c      ****         streamingStarted = CyTrue;
1582:../uvc.c      ****     }
1583:../uvc.c      **** }
1584:../uvc.c      **** 
1585:../uvc.c      **** /*
1586:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1587:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1588:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1589:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1590:../uvc.c      ****  * to commit the buffer.
1591:../uvc.c      ****  */
1592:../uvc.c      **** static uint8_t
1593:../uvc.c      **** CyFxUvcAppCommitEOF (
1594:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1595:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1596:../uvc.c      ****         )
1597:../uvc.c      **** {
1598:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1599:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1600:../uvc.c      **** 
1601:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1602:../uvc.c      **** 
1603:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1604:../uvc.c      ****     {
1605:../uvc.c      ****         switch (stateId)
1606:../uvc.c      ****         {
1607:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1608:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1609:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1610:../uvc.c      ****                 break;
1611:../uvc.c      **** 
1612:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1613:../uvc.c      ****                 socket = 0;
1614:../uvc.c      ****                 break;
1615:../uvc.c      **** 
1616:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1617:../uvc.c      ****                 socket = 1;
1618:../uvc.c      ****                 break;
1619:../uvc.c      **** 
1620:../uvc.c      ****             default:
1621:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1622:../uvc.c      ****                 /* Unexpected current state. Return error. */
1623:../uvc.c      ****                 return 1;
1624:../uvc.c      ****         }
1625:../uvc.c      ****     }
1626:../uvc.c      **** 
1627:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1628:../uvc.c      ****     {
1629:../uvc.c      ****         switch (stateId)
1630:../uvc.c      ****         {
1631:../uvc.c      **** #ifndef CAM720
1632:../uvc.c      **** #ifdef GPIFIIM
1633:../uvc.c      ****             case 13:
1634:../uvc.c      ****             case 24:
1635:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1636:../uvc.c      ****                 break;
1637:../uvc.c      **** 
1638:../uvc.c      ****             case 8:
1639:../uvc.c      ****                 socket = 0;
1640:../uvc.c      ****                 break;
1641:../uvc.c      **** 
1642:../uvc.c      ****             case 20:
1643:../uvc.c      ****                 socket = 1;
1644:../uvc.c      ****                 break;
1645:../uvc.c      **** #else
1646:../uvc.c      ****             case 11:
1647:../uvc.c      ****             case 18:
1648:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1649:../uvc.c      ****                 break;
1650:../uvc.c      **** 
1651:../uvc.c      ****             case 8:
1652:../uvc.c      ****                 socket = 0;
1653:../uvc.c      ****                 break;
1654:../uvc.c      **** 
1655:../uvc.c      ****             case 15:
1656:../uvc.c      ****                 socket = 1;
1657:../uvc.c      ****                 break;
1658:../uvc.c      **** #endif
1659:../uvc.c      **** #else
1660:../uvc.c      ****             case 11:
1661:../uvc.c      ****             case 18:
1662:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1663:../uvc.c      ****                 break;
1664:../uvc.c      **** 
1665:../uvc.c      ****             case 8:
1666:../uvc.c      ****                 socket = 0;
1667:../uvc.c      ****                 break;
1668:../uvc.c      **** 
1669:../uvc.c      ****             case 15:
1670:../uvc.c      ****                 socket = 1;
1671:../uvc.c      ****                 break;
1672:../uvc.c      **** 
1673:../uvc.c      **** #endif
1674:../uvc.c      ****              default:
1675:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1676:../uvc.c      ****                 /* Unexpected current state. Return error. */
1677:../uvc.c      ****                return 1;
1678:../uvc.c      ****         }
1679:../uvc.c      ****     }
1680:../uvc.c      **** 
1681:../uvc.c      ****     if (socket != 0xFF)
1682:../uvc.c      ****     {
1683:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1684:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1685:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1686:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1687:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1688:../uvc.c      ****         {
1689:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1690:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1691:../uvc.c      ****         }
1692:../uvc.c      ****     }
1693:../uvc.c      **** 
1694:../uvc.c      ****     return 0;
1695:../uvc.c      **** }
1696:../uvc.c      **** 
1697:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1698:../uvc.c      **** void
1699:../uvc.c      **** CyFxGpifCB (
1700:../uvc.c      ****         CyU3PGpifEventType event,
1701:../uvc.c      ****         uint8_t currentState
1702:../uvc.c      ****         )
1703:../uvc.c      **** {
1704:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1705:../uvc.c      ****     {
1706:../uvc.c      ****         //hitFV = CyTrue;
1707:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1708:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1709:../uvc.c      ****     }
1710:../uvc.c      **** }
1711:../uvc.c      **** 
1712:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1713:../uvc.c      **** static void
1714:../uvc.c      **** CyFxUVCApplnDebugInit (
1715:../uvc.c      ****         void)
1716:../uvc.c      **** {
1717:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1718:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1719:../uvc.c      **** 
1720:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1721:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1722:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1723:../uvc.c      ****     {
1724:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1725:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1726:../uvc.c      ****     }
1727:../uvc.c      **** 
1728:../uvc.c      ****     /* Set UART Configuration */
1729:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1730:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1731:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1732:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1733:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1734:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1735:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1736:../uvc.c      **** 
1737:../uvc.c      ****     /* Set the UART configuration */
1738:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1739:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1740:../uvc.c      ****     {
1741:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1742:../uvc.c      ****     }
1743:../uvc.c      **** 
1744:../uvc.c      ****     /* Set the UART transfer */
1745:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1746:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1747:../uvc.c      ****     {
1748:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1749:../uvc.c      ****     }
1750:../uvc.c      **** 
1751:../uvc.c      ****     /* Initialize the Debug logger module. */
1752:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1753:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1754:../uvc.c      ****     {
1755:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1756:../uvc.c      ****     }
1757:../uvc.c      **** 
1758:../uvc.c      ****     /* Disable log message headers. */
1759:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1760:../uvc.c      **** }
1761:../uvc.c      **** 
1762:../uvc.c      **** /* I2C initialization. */
1763:../uvc.c      **** //static void
1764:../uvc.c      **** void
1765:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1766:../uvc.c      **** {
1767:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1768:../uvc.c      ****     CyU3PReturnStatus_t status;
1769:../uvc.c      **** 
1770:../uvc.c      ****     status = CyU3PI2cInit ();
1771:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1772:../uvc.c      ****     {
1773:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1774:../uvc.c      ****         CyFxAppErrorHandler (status);
1775:../uvc.c      ****     }
1776:../uvc.c      **** 
1777:../uvc.c      ****     /*  Set I2C Configuration */
1778:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1779:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1780:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1781:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1782:../uvc.c      **** 
1783:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1784:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1785:../uvc.c      ****     {
1786:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1787:../uvc.c      ****         CyFxAppErrorHandler (status);
1788:../uvc.c      ****     }
1789:../uvc.c      **** }
1790:../uvc.c      **** 
1791:../uvc.c      **** #ifdef BACKFLOW_DETECT
1792:../uvc.c      **** static void CyFxUvcAppPibCallback (
1793:../uvc.c      ****         CyU3PPibIntrType cbType,
1794:../uvc.c      ****         uint16_t cbArg)
1795:../uvc.c      **** {
1796:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1797:../uvc.c      ****     {
1798:../uvc.c      ****         if (!back_flow_detected)
1799:../uvc.c      ****         {
1800:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1801:../uvc.c      ****             back_flow_detected = 1;
1802:../uvc.c      ****         }
1803:../uvc.c      ****     }
1804:../uvc.c      **** }
1805:../uvc.c      **** #endif
1806:../uvc.c      **** 
1807:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1808:../uvc.c      **** static void
1809:../uvc.c      **** CyFxUvcAppDebugCallback (
1810:../uvc.c      ****         CyU3PDmaChannel   *handle,
1811:../uvc.c      ****         CyU3PDmaCbType_t   type,
1812:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1813:../uvc.c      **** {
1814:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1815:../uvc.c      ****     {
1816:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1817:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1818:../uvc.c      ****     }
1819:../uvc.c      **** }
1820:../uvc.c      **** #endif
1821:../uvc.c      **** 
1822:../uvc.c      **** #if 0
1823:../uvc.c      **** static void CyFxAppIntEpCb(
1824:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1825:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1826:../uvc.c      **** 		uint8_t  ebNum)
1827:../uvc.c      **** 		{
1828:../uvc.c      **** 			//CyBool_t value;
1829:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1830:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1831:../uvc.c      **** 
1832:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1833:../uvc.c      **** 		}
1834:../uvc.c      **** #endif
1835:../uvc.c      **** 
1836:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1837:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1838:../uvc.c      ****    configures the DMA module for the UVC Application */
1839:../uvc.c      **** static void
1840:../uvc.c      **** CyFxUVCApplnInit (void)
1841:../uvc.c      **** {
1842:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1843:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1844:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1845:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1846:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1847:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1848:../uvc.c      **** 
1849:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1850:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1851:../uvc.c      **** 
1852:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1853:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1854:../uvc.c      **** #endif
1855:../uvc.c      **** 
1856:../uvc.c      ****     /* Create UVC event group */
1857:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1858:../uvc.c      ****     if (apiRetStatus != 0)
1859:../uvc.c      ****     {
1860:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1861:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1862:../uvc.c      ****     }
1863:../uvc.c      **** 
1864:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1865:../uvc.c      ****     CyFxUvcAppPTZInit ();
1866:../uvc.c      **** #endif
1867:../uvc.c      **** 
1868:../uvc.c      ****     isUsbConnected = CyFalse;
1869:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1870:../uvc.c      **** 
1871:../uvc.c      ****     /* Init the GPIO module */
1872:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1873:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1874:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1875:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1876:../uvc.c      ****     gpioClock.halfDiv    = 0;
1877:../uvc.c      **** 
1878:../uvc.c      ****     /* Initialize Gpio interface */
1879:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1880:../uvc.c      ****     if (apiRetStatus != 0)
1881:../uvc.c      ****     {
1882:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1884:../uvc.c      ****     }
1885:../uvc.c      **** 
1886:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1887:../uvc.c      ****      * must use GpioOverride to configure it */
1888:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1889:../uvc.c      ****     if (apiRetStatus != 0)
1890:../uvc.c      ****     {
1891:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1892:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1893:../uvc.c      ****     }
1894:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1895:../uvc.c      ****     if (apiRetStatus != 0)
1896:../uvc.c      ****     {
1897:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1898:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1899:../uvc.c      ****     }
1900:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1901:../uvc.c      ****     if (apiRetStatus != 0)
1902:../uvc.c      ****     {
1903:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1904:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1905:../uvc.c      ****     }
1906:../uvc.c      **** 
1907:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1908:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1909:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1910:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1911:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1912:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1913:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1914:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1915:../uvc.c      ****     {
1916:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1917:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1918:../uvc.c      ****     }
1919:../uvc.c      **** 
1920:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1921:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1922:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1923:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1924:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1925:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1926:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1927:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1928:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1929:../uvc.c      ****     {
1930:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1931:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1932:../uvc.c      ****     }
1933:../uvc.c      **** 
1934:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1935:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1936:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1937:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1938:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1939:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1940:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1941:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1942:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1943:../uvc.c      ****     {
1944:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1945:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1946:../uvc.c      ****     }
1947:../uvc.c      **** 
1948:../uvc.c      ****     /* Initialize the P-port. */
1949:../uvc.c      ****     pibclock.clkDiv      = 2;
1950:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1951:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1952:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1953:../uvc.c      **** 
1954:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1955:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1956:../uvc.c      ****     {
1957:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1958:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1959:../uvc.c      ****     }
1960:../uvc.c      **** 
1961:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1962:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1963:../uvc.c      **** 
1964:../uvc.c      **** #ifdef BACKFLOW_DETECT
1965:../uvc.c      ****     back_flow_detected = 0;
1966:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1967:../uvc.c      **** #endif
1968:../uvc.c      **** 
1969:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1970:../uvc.c      ****     SensorReset ();
1971:../uvc.c      ****     SensorInit ();
1972:../uvc.c      **** 
1973:../uvc.c      ****     /* USB initialization. */
1974:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1975:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1976:../uvc.c      ****     {
1977:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1978:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1979:../uvc.c      ****     }
1980:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1981:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1982:../uvc.c      **** 
1983:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1984:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1985:../uvc.c      **** 
1986:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1987:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1988:../uvc.c      **** 
1989:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1990:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1991:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1992:../uvc.c      **** 
1993:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1994:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1995:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1996:../uvc.c      **** 
1997:../uvc.c      ****     /* Configuration descriptors. */
1998:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1999:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2000:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2001:../uvc.c      **** 
2002:../uvc.c      ****     /* String Descriptors */
2003:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2004:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2005:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2006:../uvc.c      **** 
2007:../uvc.c      ****     /* Configure the status interrupt endpoint.
2008:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2009:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2010:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2011:../uvc.c      ****      */
2012:../uvc.c      ****     endPointConfig.enable   = 1;
2013:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2014:../uvc.c      ****     endPointConfig.pcktSize = 64;
2015:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2016:../uvc.c      ****     endPointConfig.streams  = 0;
2017:../uvc.c      ****     endPointConfig.burstLen = 1;
2018:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2019:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2020:../uvc.c      ****     {
2021:../uvc.c      ****         /* Error Handling */
2022:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2023:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2024:../uvc.c      ****     }
2025:../uvc.c      **** 
2026:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2027:../uvc.c      ****     dmaInterConfig.size           = 1024;
2028:../uvc.c      ****     dmaInterConfig.count          = 1;
2029:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2030:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2031:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2032:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2033:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2034:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2035:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2036:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2037:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2038:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2039:../uvc.c      ****             &dmaInterConfig);
2040:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2041:../uvc.c      ****     {
2042:../uvc.c      ****         /* Error handling */
2043:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2044:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2045:../uvc.c      ****     }
2046:../uvc.c      **** 
2047:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2048:../uvc.c      ****     if (glInterStaBuffer == 0)
2049:../uvc.c      ****     {
2050:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2051:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2052:../uvc.c      ****     }
2053:../uvc.c      **** 
2054:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2055:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2056:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2057:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2058:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2059:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2060:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2061:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2062:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2063:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2064:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2065:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2066:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2067:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2068:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2069:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2070:../uvc.c      ****             &dmaMultiConfig);
2071:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2072:../uvc.c      ****     {
2073:../uvc.c      ****         /* Error handling */
2074:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2075:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2076:../uvc.c      ****     }
2077:../uvc.c      **** 
2078:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2079:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2080:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2081:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2082:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2083:../uvc.c      ****      */
2084:../uvc.c      **** 
2085:../uvc.c      ****     endPointConfig.enable   = 1;
2086:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2087:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2088:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2089:../uvc.c      ****     endPointConfig.streams  = 0;
2090:../uvc.c      ****     endPointConfig.burstLen = 1;
2091:../uvc.c      **** 
2092:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2093:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2094:../uvc.c      ****     {
2095:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2096:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2097:../uvc.c      ****     }
2098:../uvc.c      **** 
2099:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2100:../uvc.c      **** 
2101:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2102:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2103:../uvc.c      ****     {
2104:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2105:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2106:../uvc.c      ****     }
2107:../uvc.c      **** 
2108:../uvc.c      ****     channelConfig.size           = 1024;
2109:../uvc.c      ****     channelConfig.count          = 1;
2110:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2111:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2112:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2113:../uvc.c      ****     channelConfig.prodHeader     = 0;
2114:../uvc.c      ****     channelConfig.prodFooter     = 0;
2115:../uvc.c      ****     channelConfig.consHeader     = 0;
2116:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2117:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2118:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2119:../uvc.c      **** 
2120:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2121:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2122:../uvc.c      ****     {
2123:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2124:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2125:../uvc.c      ****     }
2126:../uvc.c      **** 
2127:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2128:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2129:../uvc.c      ****     {
2130:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2131:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2132:../uvc.c      ****     }
2133:../uvc.c      **** 
2134:../uvc.c      ****     channelConfig.size           = 1024;
2135:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2136:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2137:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2138:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2139:../uvc.c      ****     channelConfig.prodHeader     = 0;
2140:../uvc.c      ****     channelConfig.prodFooter     = 0;
2141:../uvc.c      ****     channelConfig.consHeader     = 0;
2142:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2143:../uvc.c      ****     channelConfig.notification   = 0;
2144:../uvc.c      ****     channelConfig.cb             = 0;
2145:../uvc.c      **** 
2146:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2147:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2148:../uvc.c      ****     {
2149:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2150:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2151:../uvc.c      ****     }
2152:../uvc.c      **** 
2153:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2154:../uvc.c      ****     if (glDebugRspBuffer == 0)
2155:../uvc.c      ****     {
2156:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2157:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2158:../uvc.c      ****     }
2159:../uvc.c      **** #endif
2160:../uvc.c      **** 
2161:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2162:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2163:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2164:../uvc.c      ****     {
2165:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2166:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2167:../uvc.c      ****     }
2168:../uvc.c      **** 
2169:../uvc.c      ****     CyU3PBusyWait(100);
2170:../uvc.c      **** 
2171:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2172:../uvc.c      **** 
2173:../uvc.c      ****     endPointConfig.enable   = 1;
2174:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2175:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2176:../uvc.c      ****     {
2177:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2178:../uvc.c      ****     	endPointConfig.burstLen = 16;
2179:../uvc.c      ****     }
2180:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2181:../uvc.c      ****     {
2182:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2183:../uvc.c      ****     	endPointConfig.burstLen = 1;
2184:../uvc.c      ****     }
2185:../uvc.c      ****     endPointConfig.streams  = 0;
2186:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2187:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2188:../uvc.c      ****     {
2189:../uvc.c      ****         /* Error Handling */
2190:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2191:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2192:../uvc.c      ****     }
2193:../uvc.c      **** #if 0    //for still image method 3 using
2194:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2195:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2196:../uvc.c      ****     {
2197:../uvc.c      ****         /* Error Handling */
2198:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2199:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2200:../uvc.c      ****     }
2201:../uvc.c      **** #endif
2202:../uvc.c      **** 
2203:../uvc.c      **** }
2204:../uvc.c      **** 
2205:../uvc.c      **** /*
2206:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2207:../uvc.c      ****  * streaming session is started.
2208:../uvc.c      ****  */
2209:../uvc.c      **** static void
2210:../uvc.c      **** CyFxUvcAppGpifInit (
2211:../uvc.c      ****         void)
2212:../uvc.c      **** {
2213:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2214:../uvc.c      **** 
2215:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2216:../uvc.c      ****     {
2217:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2218:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2219:../uvc.c      ****     }
2220:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2221:../uvc.c      ****     {
2222:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2223:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2224:../uvc.c      ****     }
2225:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2226:../uvc.c      ****     {
2227:../uvc.c      ****         /* Error Handling */
2228:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2229:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2230:../uvc.c      ****     }
2231:../uvc.c      **** 
2232:../uvc.c      ****     /* Start the state machine from the designated start state. */
2233:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2234:../uvc.c      ****     {
2235:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2236:../uvc.c      ****     }
2237:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2238:../uvc.c      ****     {
2239:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2240:../uvc.c      ****     }
2241:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2242:../uvc.c      ****     {
2243:../uvc.c      ****         /* Error Handling */
2244:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2245:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2246:../uvc.c      ****     }
2247:../uvc.c      **** }
2248:../uvc.c      **** 
2249:../uvc.c      **** /*
2250:../uvc.c      ****  * Entry function for the UVC Application Thread
2251:../uvc.c      ****  */
2252:../uvc.c      **** 
2253:../uvc.c      **** uint32_t posTick;
2254:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2255:../uvc.c      **** 
2256:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 2256 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              		@ link register save eliminated.
  27              	.LVL0:
2257:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2258:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  28              		.loc 1 2258 0
  29 0000 08009FE5 		ldr	r0, .L2
  30              	.LVL1:
  31 0004 2010A0E3 		mov	r1, #32
  32 0008 0020A0E3 		mov	r2, #0
  33 000c FEFFFFEA 		b	_txe_event_flags_set
  34              	.LVL2:
  35              	.L3:
  36              		.align	2
  37              	.L2:
  38 0010 00000000 		.word	.LANCHOR0
  39              		.cfi_endproc
  40              	.LFE17:
  42              		.align	2
  43              		.global	I2cAppThread_Entry
  45              	I2cAppThread_Entry:
  46              	.LFB25:
2259:../uvc.c      **** }
2260:../uvc.c      **** 
2261:../uvc.c      **** 
2262:../uvc.c      **** void
2263:../uvc.c      **** UVCAppThread_Entry (
2264:../uvc.c      ****         uint32_t input)
2265:../uvc.c      **** {
2266:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2267:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2268:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2269:../uvc.c      ****     uint8_t i = 0;
2270:../uvc.c      ****     uint32_t flag;
2271:../uvc.c      ****     uint32_t prinflag = 0;
2272:../uvc.c      **** static uint8_t IMcount = 0;
2273:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2274:../uvc.c      ****     uint32_t frameCnt = 0;
2275:../uvc.c      **** #endif
2276:../uvc.c      ****     /* Initialize the Uart Debug Module */
2277:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2278:../uvc.c      **** 
2279:../uvc.c      ****     /* Initialize the I2C interface */
2280:../uvc.c      **** 	while (i++ < 6){
2281:../uvc.c      **** 		CyU3PThreadSleep(500);
2282:../uvc.c      **** 	}
2283:../uvc.c      **** 
2284:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2285:../uvc.c      **** 
2286:../uvc.c      ****     /* Initialize the UVC Application */
2287:../uvc.c      ****     CyFxUVCApplnInit ();
2288:../uvc.c      **** 
2289:../uvc.c      ****     /*
2290:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2291:../uvc.c      **** 
2292:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2293:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2294:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2295:../uvc.c      **** 
2296:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2297:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2298:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2299:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2300:../uvc.c      **** 
2301:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2302:../uvc.c      ****        of handling the abort request.
2303:../uvc.c      ****      */
2304:../uvc.c      **** 
2305:../uvc.c      ****     for (;;)
2306:../uvc.c      ****     {
2307:../uvc.c      ****         /* Waiting for the Video Stream Event */
2308:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2309:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2310:../uvc.c      ****         {
2311:../uvc.c      **** #if 0 //test for new firmware no video bring up
2312:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2313:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2314:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2315:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2316:../uvc.c      ****             {
2317:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2318:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2319:../uvc.c      ****                 {
2320:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2321:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2322:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2323:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2324:../uvc.c      **** #endif
2325:../uvc.c      **** #endif
2326:../uvc.c      ****                     }
2327:../uvc.c      ****                 else
2328:../uvc.c      ****                 {
2329:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2330:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2331:../uvc.c      **** #ifdef USB_LOWRES_IMG
2332:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2333:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2334:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2335:../uvc.c      **** #endif
2336:../uvc.c      **** #endif
2337:../uvc.c      ****                 }
2338:../uvc.c      **** 
2339:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2340:../uvc.c      ****                 prodCount++;
2341:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2342:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2343:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2344:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2345:../uvc.c      ****                 {
2346:../uvc.c      ****                     prodCount--;
2347:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2348:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2349:../uvc.c      ****                 }
2350:../uvc.c      ****             }
2351:../uvc.c      **** #endif
2352:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2353:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2354:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2355:../uvc.c      ****             {
2356:../uvc.c      ****             	if(0&&(prinflag == 0)){
2357:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2358:../uvc.c      ****             		prinflag = 1;
2359:../uvc.c      ****             	}
2360:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2361:../uvc.c      ****             	fb=0;
2362:../uvc.c      ****             	pb=0;
2363:../uvc.c      ****             	pbc=0;
2364:../uvc.c      ****                 prodCount = 0;
2365:../uvc.c      ****                 consCount = 0;
2366:../uvc.c      ****                 hitFV     = CyFalse;
2367:../uvc.c      **** 
2368:../uvc.c      **** #ifdef BACKFLOW_DETECT
2369:../uvc.c      ****                 back_flow_detected = 0;
2370:../uvc.c      **** #endif
2371:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2372:../uvc.c      ****                 frameCnt++;
2373:../uvc.c      **** #endif
2374:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2375:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2376:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2377:../uvc.c      ****                 //}
2378:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2379:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2380:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2381:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2382:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2383:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2384:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2385:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2386:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2387:../uvc.c      ****                 		stiflag = 0xFF;
2388:../uvc.c      ****                 		IMcount = 0;
2389:../uvc.c      ****                 	}
2390:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2391:../uvc.c      **** 
2392:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2393:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2394:../uvc.c      ****                 		stiflag = 0x0F;
2395:../uvc.c      ****                 		IMcount = 0;
2396:../uvc.c      ****                 		}
2397:../uvc.c      ****                  		/*if(IMcount > 0x4){
2398:../uvc.c      ****                 			stiflag = 0x0F;
2399:../uvc.c      ****                 			IMcount = 0;
2400:../uvc.c      ****                 		}*/
2401:../uvc.c      **** 
2402:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2403:../uvc.c      ****                     //CyU3PThreadSleep(400);
2404:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2405:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2406:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2407:../uvc.c      **** 
2408:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2409:../uvc.c      ****                 	{
2410:../uvc.c      ****                     switch (setRes)
2411:../uvc.c      ****                      {
2412:../uvc.c      ****                  	case 1: //720
2413:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2414:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2415:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0xb, 0x0);
2416:../uvc.c      ****                  		break;
2417:../uvc.c      ****                  	case 2: //960
2418:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2419:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2420:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0x0b, 0x1);
2421:../uvc.c      ****                  		break;
2422:../uvc.c      ****                  	default:
2423:../uvc.c      ****                  		break;
2424:../uvc.c      ****                      }
2425:../uvc.c      ****                     IMcount = 0;
2426:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2427:../uvc.c      ****                 	stiflag = 0x0;
2428:../uvc.c      ****                 	}
2429:../uvc.c      ****                 }
2430:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2431:../uvc.c      ****                 /* Reset the DMA channel. */
2432:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2433:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2434:../uvc.c      ****                 {
2435:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2436:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2437:../uvc.c      ****                 }
2438:../uvc.c      **** 
2439:../uvc.c      ****                 /* Start Channel Immediately */
2440:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2441:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2442:../uvc.c      ****                 {
2443:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2444:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2445:../uvc.c      ****                 }
2446:../uvc.c      **** 
2447:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2448:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2449:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2450:../uvc.c      ****                 }
2451:../uvc.c      ****         }
2452:../uvc.c      ****         else
2453:../uvc.c      ****         {
2454:../uvc.c      ****             /* If we have a stream abort request pending. */
2455:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2456:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2457:../uvc.c      ****             {
2458:../uvc.c      ****                 hitFV     = CyFalse;
2459:../uvc.c      ****                 prodCount = 0;
2460:../uvc.c      ****                 consCount = 0;
2461:../uvc.c      ****                 if(0&&(prinflag == 0)){
2462:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2463:../uvc.c      ****                 	prinflag = 1;
2464:../uvc.c      ****                 }
2465:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2466:../uvc.c      ****                 fb=0;
2467:../uvc.c      ****                 pb=0;
2468:../uvc.c      ****                 pbc=0;
2469:../uvc.c      **** 
2470:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2471:../uvc.c      ****                 {
2472:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2473:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2474:../uvc.c      ****                     {
2475:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2476:../uvc.c      ****                     }
2477:../uvc.c      **** 
2478:../uvc.c      ****                     /* Flush the Endpoint memory */
2479:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2480:../uvc.c      ****                 }
2481:../uvc.c      **** 
2482:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2483:../uvc.c      ****             }
2484:../uvc.c      ****             else
2485:../uvc.c      ****             {
2486:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2487:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2488:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2489:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2490:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2491:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2492:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2493:../uvc.c      ****                 {
2494:../uvc.c      ****                     /* Error handling */
2495:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2496:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2497:../uvc.c      ****                 }
2498:../uvc.c      **** 
2499:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2500:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2501:../uvc.c      ****                 {
2502:../uvc.c      **** #if 0
2503:../uvc.c      ****                 	//for start up of the AF Lens
2504:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2505:../uvc.c      ****                     CyU3PThreadSleep(500);
2506:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2507:../uvc.c      ****                     CyU3PThreadSleep(500);
2508:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2509:../uvc.c      ****                    	CyU3PThreadSleep(300);
2510:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2511:../uvc.c      ****                     CyU3PThreadSleep(500);
2512:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2513:../uvc.c      ****                     CyU3PThreadSleep(500);
2514:../uvc.c      **** #endif
2515:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2516:../uvc.c      ****                     gpif_initialized = CyTrue;
2517:../uvc.c      ****                     CyU3PThreadSleep(200);
2518:../uvc.c      ****                     
2519:../uvc.c      ****                 }
2520:../uvc.c      ****                 else
2521:../uvc.c      ****                 {
2522:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2523:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2524:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2525:../uvc.c      ****                 }
2526:../uvc.c      ****             }
2527:../uvc.c      ****         }
2528:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2529:../uvc.c      **** 
2530:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2531:../uvc.c      ****         CyU3PThreadRelinquish ();
2532:../uvc.c      ****     }
2533:../uvc.c      **** }
2534:../uvc.c      **** 
2535:../uvc.c      **** /*
2536:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2537:../uvc.c      ****  */
2538:../uvc.c      **** 
2539:../uvc.c      **** static void
2540:../uvc.c      **** UVCHandleProcessingUnitRqts (
2541:../uvc.c      ****         void)
2542:../uvc.c      **** {
2543:../uvc.c      ****     uint8_t CtrlAdd;
2544:../uvc.c      **** #ifdef DbgInfo
2545:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2546:../uvc.c      **** #endif
2547:../uvc.c      ****     switch (wValue)
2548:../uvc.c      ****     {
2549:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2550:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2551:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2552:../uvc.c      ****     		break;
2553:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2554:../uvc.c      ****         	CtrlAdd = CtrlParArry[ExtExRefCtlID10/*BrgtCtlID1*/][0]; //Exreference places brightness.
2555:../uvc.c      ****    			ControlHandle(ExtExRefCtlID10/*BrgtCtlID1*/);
2556:../uvc.c      ****     		break;
2557:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2558:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2559:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2560:../uvc.c      **** 			break;
2561:../uvc.c      **** 
2562:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2563:../uvc.c      **** 
2564:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2565:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2566:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2567:../uvc.c      ****       		break;
2568:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2569:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2570:../uvc.c      ****      		ControlHandle(HueCtlID5);
2571:../uvc.c      ****      		break;
2572:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2573:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2574:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2575:../uvc.c      ****           		break;
2576:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2577:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2578:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2579:../uvc.c      ****           		break;
2580:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2581:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2582:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2583:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2584:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2585:../uvc.c      ****     		break;
2586:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2587:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2588:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2589:../uvc.c      ****     		break;
2590:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2591:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2592:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2593:../uvc.c      ****     		break;
2594:../uvc.c      **** 
2595:../uvc.c      ****         default:
2596:../uvc.c      ****             /*
2597:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2598:../uvc.c      ****              * other controls.
2599:../uvc.c      ****              */
2600:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2601:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2602:../uvc.c      ****             break;
2603:../uvc.c      ****     }
2604:../uvc.c      **** }
2605:../uvc.c      **** 
2606:../uvc.c      **** /*
2607:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2608:../uvc.c      ****  */
2609:../uvc.c      **** static void
2610:../uvc.c      **** UVCHandleCameraTerminalRqts (
2611:../uvc.c      ****         void)
2612:../uvc.c      **** {
2613:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2614:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2615:../uvc.c      ****     uint16_t readCount;
2616:../uvc.c      ****     uint16_t zoomVal;
2617:../uvc.c      ****     int32_t  panVal, tiltVal;
2618:../uvc.c      ****     CyBool_t sendData = CyFalse;
2619:../uvc.c      **** #endif
2620:../uvc.c      ****     uint8_t CtrlAdd;
2621:../uvc.c      **** 
2622:../uvc.c      ****     switch (wValue)
2623:../uvc.c      ****     {
2624:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2625:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2626:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2627:../uvc.c      ****     		break;
2628:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2629:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2630:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2631:../uvc.c      ****     		break;
2632:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2633:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2634:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2635:../uvc.c      **** 			break;
2636:../uvc.c      **** 
2637:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2638:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2639:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2640:../uvc.c      **** 			break;
2641:../uvc.c      **** 
2642:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2643:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2644:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2645:../uvc.c      ****       		break;
2646:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2647:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2648:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2649:../uvc.c      ****      		break;
2650:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2651:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2652:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2653:../uvc.c      ****           		break;
2654:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2655:../uvc.c      ****           		break;
2656:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2657:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2658:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2659:../uvc.c      ****      		break;
2660:../uvc.c      **** 
2661:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2662:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2663:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2664:../uvc.c      ****     		break;
2665:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2666:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2667:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2668:../uvc.c      ****     		break;
2669:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2670:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2671:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2672:../uvc.c      ****     		break;
2673:../uvc.c      **** 
2674:../uvc.c      ****         default:
2675:../uvc.c      ****             /*
2676:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2677:../uvc.c      ****              * other controls.
2678:../uvc.c      ****              */
2679:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2680:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2681:../uvc.c      ****             break;
2682:../uvc.c      ****     }
2683:../uvc.c      **** 
2684:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2685:../uvc.c      ****     switch (wValue)
2686:../uvc.c      ****     {
2687:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2688:../uvc.c      ****             switch (bRequest)
2689:../uvc.c      ****             {
2690:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2691:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2692:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2693:../uvc.c      ****                     break;
2694:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2695:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2696:../uvc.c      ****                     sendData = CyTrue;
2697:../uvc.c      ****                     break;
2698:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2699:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2700:../uvc.c      ****                     sendData = CyTrue;
2701:../uvc.c      ****                     break;
2702:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2703:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2704:../uvc.c      ****                     sendData = CyTrue;
2705:../uvc.c      ****                     break;
2706:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2707:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2708:../uvc.c      ****                     sendData = CyTrue;
2709:../uvc.c      ****                     break;
2710:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2711:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2712:../uvc.c      ****                     sendData = CyTrue;
2713:../uvc.c      ****                     break;
2714:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2715:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2716:../uvc.c      ****                             glEp0Buffer, &readCount);
2717:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2718:../uvc.c      ****                     {
2719:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2720:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2721:../uvc.c      ****                     }
2722:../uvc.c      ****                     break;
2723:../uvc.c      ****                 default:
2724:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2725:../uvc.c      ****                     break;
2726:../uvc.c      ****             }
2727:../uvc.c      **** 
2728:../uvc.c      ****             if (sendData)
2729:../uvc.c      ****             {
2730:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2731:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2732:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2733:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2734:../uvc.c      ****             }
2735:../uvc.c      ****             break;
2736:../uvc.c      **** 
2737:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2738:../uvc.c      ****             switch (bRequest)
2739:../uvc.c      ****             {
2740:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2741:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2742:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2743:../uvc.c      ****                     break;
2744:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2745:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2746:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2747:../uvc.c      ****                     sendData = CyTrue;
2748:../uvc.c      ****                     break;
2749:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2750:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2751:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2752:../uvc.c      ****                     sendData = CyTrue;
2753:../uvc.c      ****                     break;
2754:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2755:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2756:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2757:../uvc.c      ****                     sendData = CyTrue;
2758:../uvc.c      ****                     break;
2759:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2760:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2761:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2762:../uvc.c      ****                     sendData = CyTrue;
2763:../uvc.c      ****                     break;
2764:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2765:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2766:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2767:../uvc.c      ****                     sendData = CyTrue;
2768:../uvc.c      ****                     break;
2769:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2770:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2771:../uvc.c      ****                             glEp0Buffer, &readCount);
2772:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2773:../uvc.c      ****                     {
2774:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2775:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2776:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2777:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2778:../uvc.c      **** 
2779:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2780:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2781:../uvc.c      ****                     }
2782:../uvc.c      ****                     break;
2783:../uvc.c      ****                 default:
2784:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2785:../uvc.c      ****                     break;
2786:../uvc.c      ****             }
2787:../uvc.c      **** 
2788:../uvc.c      ****             if (sendData)
2789:../uvc.c      ****             {
2790:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2791:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2792:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2793:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2794:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2795:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2796:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2797:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2798:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2799:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2800:../uvc.c      ****             }
2801:../uvc.c      ****             break;
2802:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2803:../uvc.c      ****         default:
2804:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2805:../uvc.c      ****             break;
2806:../uvc.c      ****     }
2807:../uvc.c      **** #endif
2808:../uvc.c      **** }
2809:../uvc.c      **** 
2810:../uvc.c      **** /*
2811:../uvc.c      ****  * Handler for UVC Interface control requests.
2812:../uvc.c      ****  */
2813:../uvc.c      **** static void
2814:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2815:../uvc.c      ****         void)
2816:../uvc.c      **** {
2817:../uvc.c      **** 
2818:../uvc.c      ****     switch (wValue)
2819:../uvc.c      ****     {
2820:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2821:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2822:../uvc.c      ****     		break;
2823:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2824:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2825:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2826:../uvc.c      ****     		break;
2827:../uvc.c      ****     	default:
2828:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2829:../uvc.c      ****      		break;
2830:../uvc.c      ****     }
2831:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2832:../uvc.c      **** 
2833:../uvc.c      **** }
2834:../uvc.c      **** 
2835:../uvc.c      **** /*
2836:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2837:../uvc.c      ****  */
2838:../uvc.c      **** static void
2839:../uvc.c      **** UVCHandleExtensionUnitRqts (
2840:../uvc.c      ****         void)
2841:../uvc.c      **** {
2842:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2843:../uvc.c      **** 
2844:../uvc.c      **** #ifdef DbgInfo
2845:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2846:../uvc.c      **** #endif
2847:../uvc.c      ****     switch (wValue)
2848:../uvc.c      ****     {
2849:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2850:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2851:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2852:../uvc.c      ****     		break;
2853:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2854:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2855:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2856:../uvc.c      ****     		break;
2857:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2858:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2859:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2860:../uvc.c      ****      		break;
2861:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2862:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2863:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2864:../uvc.c      ****     		break;
2865:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2866:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2867:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2868:../uvc.c      ****     		break;
2869:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2870:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2871:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2872:../uvc.c      ****      		break;
2873:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2874:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2875:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2876:../uvc.c      ****     		break;
2877:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2878:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2879:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2880:../uvc.c      ****     		break;
2881:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2882:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2883:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2884:../uvc.c      ****      		break;
2885:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2886:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2887:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2888:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2889:../uvc.c      ****     		}else/* no support for 1080p camera */
2890:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2891:../uvc.c      ****     		break;
2892:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2893:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2894:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2895:../uvc.c      ****     		break;
2896:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2897:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2898:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2899:../uvc.c      ****     		break;
2900:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2901:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2902:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2903:../uvc.c      ****     		//break;
2904:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2905:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2906:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2907:../uvc.c      ****     		break;
2908:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2909:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2910:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2911:../uvc.c      ****     		break;
2912:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2913:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2914:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2915:../uvc.c      ****     		break;
2916:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2917:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2918:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2919:../uvc.c      ****     		break;
2920:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2921:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2922:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2923:../uvc.c      ****     		break;
2924:../uvc.c      ****    	default:
2925:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2926:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2927:../uvc.c      ****     		break;
2928:../uvc.c      ****     }
2929:../uvc.c      **** 
2930:../uvc.c      **** }
2931:../uvc.c      **** 
2932:../uvc.c      **** /*
2933:../uvc.c      ****  * Handler for the video streaming control requests.
2934:../uvc.c      ****  */
2935:../uvc.c      **** static void
2936:../uvc.c      **** UVCHandleVideoStreamingRqts (
2937:../uvc.c      ****         void)
2938:../uvc.c      **** {
2939:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2940:../uvc.c      ****     uint16_t readCount;
2941:../uvc.c      **** 
2942:../uvc.c      ****     switch (wValue)
2943:../uvc.c      ****     {
2944:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2945:../uvc.c      ****             switch (bRequest)
2946:../uvc.c      ****             {
2947:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2948:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2949:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2950:../uvc.c      ****                     break;
2951:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2952:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2953:../uvc.c      ****                     glEp0Buffer[1] = 0;
2954:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2955:../uvc.c      ****                     break;
2956:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2957:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2958:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2959:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2960:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED)//supports both SS and HS
2961:../uvc.c      ****                     {
2962:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2963:../uvc.c      ****                     }
2964:../uvc.c      ****                     else
2965:../uvc.c      ****                     {
2966:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2967:../uvc.c      ****                     }
2968:../uvc.c      ****                     break;
2969:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2970:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2971:../uvc.c      ****                             glCommitCtrl, &readCount);
2972:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2973:../uvc.c      ****                     {
2974:../uvc.c      ****                         //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
2975:../uvc.c      ****                         {
2976:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2977:../uvc.c      ****                                active data structure. */
2978:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2979:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2980:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2981:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2982:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2983:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2984:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
2985:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
2986:../uvc.c      ****                         }
2987:../uvc.c      ****                     }
2988:../uvc.c      ****                     break;
2989:../uvc.c      ****                 default:
2990:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2991:../uvc.c      ****                     break;
2992:../uvc.c      ****             }
2993:../uvc.c      ****             break;
2994:../uvc.c      **** 
2995:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2996:../uvc.c      ****             switch (bRequest)
2997:../uvc.c      ****             {
2998:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2999:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3000:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3001:../uvc.c      ****                     break;
3002:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3003:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3004:../uvc.c      ****                     glEp0Buffer[1] = 0;
3005:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3006:../uvc.c      ****                     break;
3007:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3008:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED) //support both SS and HS
3009:../uvc.c      ****                     {
3010:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3011:../uvc.c      ****                     }
3012:../uvc.c      ****                     else
3013:../uvc.c      ****                     {
3014:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3015:../uvc.c      ****                     }
3016:../uvc.c      ****                     break;
3017:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3018:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3019:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3020:../uvc.c      ****                        */
3021:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3022:../uvc.c      ****                             glCommitCtrl, &readCount);
3023:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)//supports both SS and HS
3024:../uvc.c      ****                     {
3025:../uvc.c      ****                         if(setRes != glCommitCtrl[3])
3026:../uvc.c      ****                         {
3027:../uvc.c      ****                         switch (glCommitCtrl[3])
3028:../uvc.c      ****                          {
3029:../uvc.c      ****                          	case 1: //720 or 360
3030:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
3031:../uvc.c      ****                          		CyU3PThreadSleep(500);
3032:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
3033:../uvc.c      ****                          		break;
3034:../uvc.c      ****                          	case 2: //960 or 480
3035:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
3036:../uvc.c      ****                          		CyU3PThreadSleep(500);
3037:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
3038:../uvc.c      ****                          		break;
3039:../uvc.c      ****                          	default:
3040:../uvc.c      ****                          		break;
3041:../uvc.c      ****                          }                         
3042:../uvc.c      ****                         setRes = glCommitCtrl[3];
3043:../uvc.c      ****                         }
3044:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3045:../uvc.c      **** 
3046:../uvc.c      **** #if 0
3047:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3048:../uvc.c      ****                         {
3049:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3050:../uvc.c      ****                         }
3051:../uvc.c      ****                         else
3052:../uvc.c      ****                         {
3053:../uvc.c      ****                             SensorScaling_VGA ();
3054:../uvc.c      ****                         }
3055:../uvc.c      **** #endif
3056:../uvc.c      ****                         /* We can start streaming video now. */
3057:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3058:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3059:../uvc.c      ****                         {
3060:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3061:../uvc.c      ****                         }
3062:../uvc.c      ****                     }
3063:../uvc.c      ****                     break;
3064:../uvc.c      **** 
3065:../uvc.c      ****                 default:
3066:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3067:../uvc.c      ****                     break;
3068:../uvc.c      ****             }
3069:../uvc.c      ****             break;
3070:../uvc.c      **** 
3071:../uvc.c      **** /* still image streaming handler */
3072:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3073:../uvc.c      ****                 switch (bRequest)
3074:../uvc.c      ****                 {
3075:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3076:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3077:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3078:../uvc.c      ****                         break;
3079:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3080:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3081:../uvc.c      ****                         glEp0Buffer[1] = 0;
3082:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3083:../uvc.c      ****                         break;
3084:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3085:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3086:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3087:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3088:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3089:../uvc.c      ****                         {
3090:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3091:../uvc.c      ****                         }
3092:../uvc.c      ****                         else
3093:../uvc.c      ****                         {
3094:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3095:../uvc.c      ****                         }
3096:../uvc.c      ****                         break;
3097:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3098:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3099:../uvc.c      ****                                 glCommitCtrl, &readCount);
3100:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3101:../uvc.c      ****                         {
3102:../uvc.c      ****                             //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
3103:../uvc.c      ****                             {
3104:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3105:../uvc.c      ****                                    active data structure. */
3106:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3107:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3108:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3109:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3110:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3111:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3112:../uvc.c      ****                             }
3113:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3114:../uvc.c      ****                         }
3115:../uvc.c      ****                         break;
3116:../uvc.c      ****                     default:
3117:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3118:../uvc.c      ****                         break;
3119:../uvc.c      ****                 }
3120:../uvc.c      ****                 break;
3121:../uvc.c      **** 
3122:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3123:../uvc.c      ****                 switch (bRequest)
3124:../uvc.c      ****                 {
3125:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3126:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3127:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3128:../uvc.c      ****                         break;
3129:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3130:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3131:../uvc.c      ****                         glEp0Buffer[1] = 0;
3132:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3133:../uvc.c      ****                         break;
3134:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3135:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3136:../uvc.c      ****                         {
3137:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3138:../uvc.c      ****                         }
3139:../uvc.c      ****                         else
3140:../uvc.c      ****                         {
3141:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3142:../uvc.c      ****                         }
3143:../uvc.c      ****                         break;
3144:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3145:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3146:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3147:../uvc.c      ****                            */
3148:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3149:../uvc.c      ****                                 glCommitCtrl, &readCount);
3150:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3151:../uvc.c      ****                         {
3152:../uvc.c      ****     #if 0
3153:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3154:../uvc.c      ****                             {
3155:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3156:../uvc.c      ****                             }
3157:../uvc.c      ****                             else
3158:../uvc.c      ****                             {
3159:../uvc.c      ****                                 SensorScaling_VGA ();
3160:../uvc.c      ****                             }
3161:../uvc.c      ****                             /* We can start streaming video now. */
3162:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3163:../uvc.c      **** 
3164:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3165:../uvc.c      ****                             {
3166:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3167:../uvc.c      ****                             }
3168:../uvc.c      **** 	#endif
3169:../uvc.c      **** #if 0 //remove the still resolution set for invendo because the still res. is always the same as th
3170:../uvc.c      ****                            switch (glCommitCtrl[1])
3171:../uvc.c      ****                              {
3172:../uvc.c      ****                              	case 1: //720
3173:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*
3174:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3175:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3176:../uvc.c      ****                              		break;
3177:../uvc.c      ****                             	case 2: //960
3178:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*
3179:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3180:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3181:../uvc.c      ****                              		break;
3182:../uvc.c      ****                               	default:
3183:../uvc.c      ****                              		break;
3184:../uvc.c      ****                              }
3185:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3186:../uvc.c      **** 
3187:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3188:../uvc.c      **** #endif
3189:../uvc.c      ****                         }
3190:../uvc.c      ****                         break;
3191:../uvc.c      **** 
3192:../uvc.c      ****                     default:
3193:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3194:../uvc.c      ****                         break;
3195:../uvc.c      ****                 }
3196:../uvc.c      ****                 break;
3197:../uvc.c      **** 
3198:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3199:../uvc.c      ****                 switch (bRequest)
3200:../uvc.c      ****                 {
3201:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3202:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3203:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3204:../uvc.c      ****                         break;
3205:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3206:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3207:../uvc.c      ****                         glEp0Buffer[1] = 0;
3208:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3209:../uvc.c      ****                         break;
3210:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3211:../uvc.c      ****                         if (1 || usbSpeed == CY_U3P_SUPER_SPEED)// support both SS and HS
3212:../uvc.c      ****                         {
3213:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3214:../uvc.c      ****                         }
3215:../uvc.c      ****                         else
3216:../uvc.c      ****                         {
3217:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3218:../uvc.c      ****                         }
3219:../uvc.c      ****                         break;
3220:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3221:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3222:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3223:../uvc.c      ****                            */
3224:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3225:../uvc.c      ****                                 glCommitCtrl, &readCount);
3226:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3227:../uvc.c      ****                         {
3228:../uvc.c      ****     #if 1
3229:../uvc.c      ****                             /* We can start still streaming video now. */
3230:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3231:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3232:../uvc.c      ****                             {
3233:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3234:../uvc.c      ****                             }
3235:../uvc.c      ****     #endif
3236:../uvc.c      ****                             else{
3237:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3238:../uvc.c      ****                             //stillcont = 0;
3239:../uvc.c      ****                             }
3240:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3241:../uvc.c      ****                         }else{
3242:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3243:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3244:../uvc.c      ****                         }
3245:../uvc.c      ****                         break;
3246:../uvc.c      **** 
3247:../uvc.c      ****                     default:
3248:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3249:../uvc.c      ****                         break;
3250:../uvc.c      ****                 }
3251:../uvc.c      ****                 break;
3252:../uvc.c      **** 
3253:../uvc.c      ****         default:
3254:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3255:../uvc.c      ****             break;
3256:../uvc.c      ****     }
3257:../uvc.c      **** }
3258:../uvc.c      **** 
3259:../uvc.c      **** /*
3260:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3261:../uvc.c      ****  */
3262:../uvc.c      **** void
3263:../uvc.c      **** UVCAppEP0Thread_Entry (
3264:../uvc.c      ****         uint32_t input)
3265:../uvc.c      **** {
3266:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3267:../uvc.c      ****     uint32_t eventFlag;
3268:../uvc.c      **** 	CyBool_t value;
3269:../uvc.c      **** 	CyBool_t *valueptr = &value;
3270:../uvc.c      **** 
3271:../uvc.c      **** 
3272:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3273:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3274:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3275:../uvc.c      **** 
3276:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3277:../uvc.c      **** #endif
3278:../uvc.c      **** 
3279:../uvc.c      ****     /* for interrupt status test */
3280:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3281:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3282:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3283:../uvc.c      **** 
3284:../uvc.c      ****     for (;;)
3285:../uvc.c      ****     {
3286:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3287:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3288:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3289:../uvc.c      ****         {
3290:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3291:../uvc.c      ****             if (!isUsbConnected)
3292:../uvc.c      ****             {
3293:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3294:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3295:../uvc.c      ****                 {
3296:../uvc.c      ****                     isUsbConnected = CyTrue;
3297:../uvc.c      ****                 }
3298:../uvc.c      ****             }
3299:../uvc.c      **** //#ifdef DbgInfo
3300:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3301:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3302:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3303:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3304:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3305:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3306:../uvc.c      **** //#endif
3307:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3308:../uvc.c      ****             {
3309:../uvc.c      ****             	switch ((wIndex >> 8))
3310:../uvc.c      ****                 {
3311:../uvc.c      **** 
3312:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3313:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3314:../uvc.c      ****                         break;
3315:../uvc.c      **** 
3316:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3317:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3318:../uvc.c      ****                         break;
3319:../uvc.c      **** 
3320:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3321:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3322:../uvc.c      ****                         break;
3323:../uvc.c      **** 
3324:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3325:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3326:../uvc.c      ****                         break;
3327:../uvc.c      **** 
3328:../uvc.c      ****                     default:
3329:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3330:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3331:../uvc.c      ****                         break;
3332:../uvc.c      ****                 }
3333:../uvc.c      ****             }
3334:../uvc.c      **** 
3335:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3336:../uvc.c      ****             {
3337:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3338:../uvc.c      **** 
3339:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3340:../uvc.c      ****                 {
3341:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3342:../uvc.c      ****                 }
3343:../uvc.c      ****                 else
3344:../uvc.c      ****                 {
3345:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3346:../uvc.c      ****                 }
3347:../uvc.c      ****             }
3348:../uvc.c      **** 
3349:../uvc.c      ****             /* handle interrupt status event */
3350:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3351:../uvc.c      ****             {
3352:../uvc.c      **** 
3353:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3354:../uvc.c      ****             	/** preparing interrupt status data **/
3355:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3356:../uvc.c      **** 
3357:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3358:../uvc.c      **** 
3359:../uvc.c      **** #if 1 //for real button
3360:../uvc.c      **** 				if(value&&(!snapButFlag)){
3361:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3362:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3363:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3364:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3365:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3366:../uvc.c      **** 
3367:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3368:../uvc.c      **** 					interStabuf.size   = 1024;
3369:../uvc.c      **** 					interStabuf.status = 0;
3370:../uvc.c      **** 
3371:../uvc.c      **** 					interStabuf.count = 4;
3372:../uvc.c      **** 
3373:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3374:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3375:../uvc.c      **** 
3376:../uvc.c      **** 					/** send a interrupt status data **/
3377:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3378:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3379:../uvc.c      **** 					{
3380:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3381:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3382:../uvc.c      **** 					}
3383:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3384:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3385:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3386:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3387:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3388:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3389:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3390:../uvc.c      **** 
3391:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3392:../uvc.c      **** 					interStabuf.size   = 1024;
3393:../uvc.c      **** 					interStabuf.status = 0;
3394:../uvc.c      **** 
3395:../uvc.c      **** 					interStabuf.count = 4;
3396:../uvc.c      **** 
3397:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3398:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3399:../uvc.c      **** 
3400:../uvc.c      **** 					/** send a interrupt status data **/
3401:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3402:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3403:../uvc.c      **** 					{
3404:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3405:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3406:../uvc.c      **** 					}
3407:../uvc.c      **** 
3408:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3409:../uvc.c      **** 					stiflag = 0xFF;
3410:../uvc.c      **** 				}
3411:../uvc.c      **** #else			//for botton simulation
3412:../uvc.c      **** 				if(snapButFlag == 0x0f){
3413:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3414:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3415:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3416:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3417:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3418:../uvc.c      **** 
3419:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3420:../uvc.c      **** 					interStabuf.size   = 1024;
3421:../uvc.c      **** 					interStabuf.status = 0;
3422:../uvc.c      **** 
3423:../uvc.c      **** 					interStabuf.count = 4;
3424:../uvc.c      **** 
3425:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3426:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3427:../uvc.c      **** 
3428:../uvc.c      **** 					/** send a interrupt status data **/
3429:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3430:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3431:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3432:../uvc.c      **** 					{
3433:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3434:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3435:../uvc.c      **** 					}
3436:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3437:../uvc.c      **** 
3438:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3439:../uvc.c      **** 				}else if(!snapButFlag){
3440:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3441:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3442:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3443:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3444:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3445:../uvc.c      **** 
3446:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3447:../uvc.c      **** 					interStabuf.size   = 1024;
3448:../uvc.c      **** 					interStabuf.status = 0;
3449:../uvc.c      **** 
3450:../uvc.c      **** 					interStabuf.count = 4;
3451:../uvc.c      **** 
3452:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3453:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3454:../uvc.c      **** 
3455:../uvc.c      **** 					/** send a interrupt status data **/
3456:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3457:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3458:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3459:../uvc.c      **** 					{
3460:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3461:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3462:../uvc.c      **** 					}
3463:../uvc.c      **** 
3464:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3465:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3466:../uvc.c      **** 				}
3467:../uvc.c      **** #endif
3468:../uvc.c      **** 
3469:../uvc.c      ****             }
3470:../uvc.c      **** 
3471:../uvc.c      **** 
3472:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3473:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3474:../uvc.c      ****             {
3475:../uvc.c      ****                 /* Get the command buffer */
3476:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3477:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3478:../uvc.c      ****                 {
3479:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3480:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3481:../uvc.c      ****                 }
3482:../uvc.c      **** 
3483:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3484:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3485:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3486:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3487:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3488:../uvc.c      ****                  * register value high byte and register value low byte.
3489:../uvc.c      ****                  */
3490:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3491:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3492:../uvc.c      ****                 {
3493:../uvc.c      ****                     if (dmaInfo.count == 3)
3494:../uvc.c      ****                     {
3495:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3496:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3497:../uvc.c      ****                         dmaInfo.count = 3;
3498:../uvc.c      ****                     }
3499:../uvc.c      ****                     else if (dmaInfo.count == 4)
3500:../uvc.c      ****                     {
3501:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3502:../uvc.c      ****                         {
3503:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3504:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3505:../uvc.c      ****                         }
3506:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3507:../uvc.c      ****                     }
3508:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3509:../uvc.c      ****                 }
3510:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3511:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3512:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3513:../uvc.c      ****                  */
3514:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3515:../uvc.c      ****                 {
3516:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3517:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3518:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3519:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3520:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3521:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3522:../uvc.c      ****                         	break;
3523:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3524:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3525:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3526:../uvc.c      ****                         	break;*/
3527:../uvc.c      ****                     dmaInfo.count -= 2;
3528:../uvc.c      ****                 }
3529:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3530:../uvc.c      ****                 else
3531:../uvc.c      ****                 {
3532:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3533:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3534:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3535:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3536:../uvc.c      ****                 }
3537:../uvc.c      **** 
3538:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3539:../uvc.c      ****                 dmaInfo.size   = 1024;
3540:../uvc.c      ****                 dmaInfo.status = 0;
3541:../uvc.c      **** 
3542:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3543:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3544:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3545:../uvc.c      ****                 {
3546:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3547:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3548:../uvc.c      ****                 }
3549:../uvc.c      **** 
3550:../uvc.c      ****                 /* Wait until the response has gone out. */
3551:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3552:../uvc.c      **** 
3553:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3554:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3555:../uvc.c      ****                 {
3556:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3557:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3558:../uvc.c      ****                 }
3559:../uvc.c      ****             }
3560:../uvc.c      **** #endif
3561:../uvc.c      ****         }
3562:../uvc.c      ****         /* Allow other ready threads to run. */
3563:../uvc.c      ****         CyU3PThreadRelinquish ();
3564:../uvc.c      ****     }
3565:../uvc.c      **** }
3566:../uvc.c      **** 
3567:../uvc.c      **** /*
3568:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3569:../uvc.c      ****  * added 10/2013
3570:../uvc.c      ****  */
3571:../uvc.c      **** /*
3572:../uvc.c      **** static uint8_t timeDelay[64] = {
3573:../uvc.c      **** 
3574:../uvc.c      **** };
3575:../uvc.c      **** */
3576:../uvc.c      **** 
3577:../uvc.c      **** static uint8_t timercount = 0;
3578:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  47              		.loc 1 3578 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 8
  50              		@ frame_needed = 0, uses_anonymous_args = 0
  51              	.LVL3:
  52 0014 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
  53              	.LCFI0:
  54              		.cfi_def_cfa_offset 36
  55              		.cfi_offset 4, -36
  56              		.cfi_offset 5, -32
  57              		.cfi_offset 6, -28
  58              		.cfi_offset 7, -24
  59              		.cfi_offset 8, -20
  60              		.cfi_offset 9, -16
  61              		.cfi_offset 10, -12
  62              		.cfi_offset 11, -8
  63              		.cfi_offset 14, -4
3579:../uvc.c      **** 
3580:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3581:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3582:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3583:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3584:../uvc.c      **** 	VdstateDes *lcStaDes;
3585:../uvc.c      **** 	uint32_t flag = 0;
3586:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3587:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3588:../uvc.c      **** 	uint8_t i, curFlagIdx;
3589:../uvc.c      **** 	uint16_t delaytime;
3590:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3591:../uvc.c      **** 
3592:../uvc.c      **** #if 0 //for test the command queue
3593:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3594:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3595:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3596:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3597:../uvc.c      **** 		lcCmdDes += 1;
3598:../uvc.c      **** 	}
3599:../uvc.c      **** #endif
3600:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3601:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  64              		.loc 1 3601 0
  65 0018 38029FE5 		ldr	r0, .L27
  66              	.LVL4:
3578:../uvc.c      **** 
  67              		.loc 1 3578 0
  68 001c 1CD04DE2 		sub	sp, sp, #28
  69              	.LCFI1:
  70              		.cfi_def_cfa_offset 64
3585:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  71              		.loc 1 3585 0
  72 0020 00C0A0E3 		mov	ip, #0
  73              		.loc 1 3601 0
  74 0024 FA2FA0E3 		mov	r2, #1000
  75 0028 2C30A0E3 		mov	r3, #44
  76 002c 0C10A0E1 		mov	r1, ip
  77 0030 04C08DE5 		str	ip, [sp, #4]
  78 0034 08C08DE5 		str	ip, [sp, #8]
  79 0038 00208DE5 		str	r2, [sp]
  80 003c 0C308DE5 		str	r3, [sp, #12]
  81 0040 14229FE5 		ldr	r2, .L27+4
  82 0044 0B30A0E3 		mov	r3, #11
3585:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  83              		.loc 1 3585 0
  84 0048 14C08DE5 		str	ip, [sp, #20]
  85              	.LVL5:
  86              		.loc 1 3601 0
  87 004c FEFFFFEB 		bl	_txe_timer_create
  88              	.LVL6:
3602:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  89              		.loc 1 3602 0
  90 0050 FEFFFFEB 		bl	_tx_time_get
  91              	.LVL7:
3603:../uvc.c      **** 	CyU3PThreadSleep(50);
3604:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
3605:../uvc.c      **** 
3606:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  92              		.loc 1 3606 0
  93 0054 04529FE5 		ldr	r5, .L27+8
3602:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  94              		.loc 1 3602 0
  95 0058 04129FE5 		ldr	r1, .L27+12
  96 005c 0020A0E1 		mov	r2, r0
  97 0060 0400A0E3 		mov	r0, #4
  98 0064 FEFFFFEB 		bl	CyU3PDebugPrint
  99              	.LVL8:
3603:../uvc.c      **** 	CyU3PThreadSleep(50);
 100              		.loc 1 3603 0
 101 0068 3200A0E3 		mov	r0, #50
 102 006c FEFFFFEB 		bl	_tx_thread_sleep
 103              	.LVL9:
3604:../uvc.c      **** 
 104              		.loc 1 3604 0
 105 0070 E0019FE5 		ldr	r0, .L27
 106 0074 FEFFFFEB 		bl	_txe_timer_activate
 107              	.LVL10:
 108              		.loc 1 3606 0
 109 0078 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 110 007c 000052E3 		cmp	r2, #0
 111 0080 0300001A 		bne	.L5
 112              	.L6:
3607:../uvc.c      ****         /* Allow other ready threads to run. */
3608:../uvc.c      **** 
3609:../uvc.c      ****         CyU3PThreadRelinquish ();
 113              		.loc 1 3609 0
 114 0084 FEFFFFEB 		bl	_txe_thread_relinquish
 115              	.LVL11:
3606:../uvc.c      ****         /* Allow other ready threads to run. */
 116              		.loc 1 3606 0
 117 0088 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 118 008c 000052E3 		cmp	r2, #0
 119 0090 FBFFFF0A 		beq	.L6
 120              	.L5:
3610:../uvc.c      **** 	}
3611:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 121              		.loc 1 3611 0
 122 0094 103095E5 		ldr	r3, [r5, #16]
 123 0098 0400A0E3 		mov	r0, #4
 124 009c 3C3093E5 		ldr	r3, [r3, #60]
 125 00a0 C0119FE5 		ldr	r1, .L27+16
 126 00a4 FEFFFFEB 		bl	CyU3PDebugPrint
 127              	.LVL12:
 128 00a8 BC819FE5 		ldr	r8, .L27+20
 129 00ac BC619FE5 		ldr	r6, .L27+24
 130 00b0 BCA19FE5 		ldr	r10, .L27+28
3612:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3613:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3614:../uvc.c      **** 	//CyU3PThreadSleep(100);
3615:../uvc.c      **** 	//SetCurCmd();
3616:../uvc.c      **** 	/*********** the loop of the thread ***********/
3617:../uvc.c      **** 	for(;;){
3618:../uvc.c      **** 
3619:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 131              		.loc 1 3619 0
 132 00b4 0890A0E1 		mov	r9, r8
 133 00b8 0070E0E3 		mvn	r7, #0
 134              	.L21:
 135 00bc 14308DE2 		add	r3, sp, #20
 136 00c0 0320A0E3 		mov	r2, #3
 137 00c4 2010A0E3 		mov	r1, #32
 138 00c8 00708DE5 		str	r7, [sp]
 139 00cc 98019FE5 		ldr	r0, .L27+20
 140 00d0 FEFFFFEB 		bl	_txe_event_flags_get
 141              	.LVL13:
3620:../uvc.c      **** 		//CyU3PDebugPrint (4, "In I2C loop timercounter %d cmdFlag 0x%x\r\n", timercount, cmdFlag);
3621:../uvc.c      **** /*  // for test GPIO output
3622:../uvc.c      **** 		if(trigger)
3623:../uvc.c      **** 		{
3624:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3625:../uvc.c      **** 			{
3626:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3627:../uvc.c      **** 			}
3628:../uvc.c      **** 
3629:../uvc.c      **** 		}else{
3630:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3631:../uvc.c      **** 			{
3632:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3633:../uvc.c      **** 			}
3634:../uvc.c      **** 
3635:../uvc.c      **** 		}
3636:../uvc.c      **** */
3637:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 142              		.loc 1 3637 0
 143 00d4 0010E0E3 		mvn	r1, #0
 144 00d8 1C0096E5 		ldr	r0, [r6, #28]
 145 00dc FEFFFFEB 		bl	_txe_mutex_get
 146              	.LVL14:
3638:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3639:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3640:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3641:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3642:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3643:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3644:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3645:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3646:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3647:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3648:../uvc.c      **** #endif
3649:../uvc.c      **** 				}
3650:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3651:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3652:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3653:../uvc.c      **** 			}
3654:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 147              		.loc 1 3654 0
 148 00e0 1C0096E5 		ldr	r0, [r6, #28]
 149 00e4 FEFFFFEB 		bl	_txe_mutex_put
 150              	.LVL15:
3655:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3656:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 151              		.loc 1 3656 0
 152 00e8 1C0095E5 		ldr	r0, [r5, #28]
 153 00ec 0010E0E3 		mvn	r1, #0
 154 00f0 FEFFFFEB 		bl	_txe_mutex_get
 155              	.LVL16:
3657:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 156              		.loc 1 3657 0
 157 00f4 104095E5 		ldr	r4, [r5, #16]
 158              	.LVL17:
3658:../uvc.c      **** 
3659:../uvc.c      **** 				/*
3660:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3661:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3662:../uvc.c      **** 				*/
3663:../uvc.c      **** 
3664:../uvc.c      **** 				/* find a available command */
3665:../uvc.c      **** 				i = 0;
3666:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 159              		.loc 1 3666 0
 160 00f8 3C3094E5 		ldr	r3, [r4, #60]
 161 00fc 000053E3 		cmp	r3, #0
 162 0100 0900001A 		bne	.L7
 163 0104 40B0A0E3 		mov	fp, #64
 164 0108 010000EA 		b	.L10
 165              	.LVL18:
 166              	.L8:
 167              		.loc 1 3666 0 is_stmt 0 discriminator 2
 168 010c FFB013E2 		ands	fp, r3, #255
 169 0110 2D00000A 		beq	.L25
 170              	.L10:
3667:../uvc.c      **** 					i++;
3668:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 171              		.loc 1 3668 0 is_stmt 1
 172 0114 344094E5 		ldr	r4, [r4, #52]
 173              	.LVL19:
 174 0118 01304BE2 		sub	r3, fp, #1
3666:../uvc.c      **** 					i++;
 175              		.loc 1 3666 0
 176 011c 3C2094E5 		ldr	r2, [r4, #60]
 177 0120 000052E3 		cmp	r2, #0
 178 0124 F8FFFF0A 		beq	.L8
 179 0128 104085E5 		str	r4, [r5, #16]
 180              	.L7:
 181              	.LVL20:
 182 012c 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3669:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3670:../uvc.c      **** 				}
3671:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3672:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3673:../uvc.c      **** 					i = lcCmdDes->curNum;
3674:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3675:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3676:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3677:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3678:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 183              		.loc 1 3678 0
 184 0130 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 185 0134 833083E0 		add	r3, r3, r3, asl #1
 186 0138 833084E0 		add	r3, r4, r3, asl #1
 187 013c 20C04CE2 		sub	ip, ip, #32
3674:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 188              		.loc 1 3674 0
 189 0140 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 190              	.LVL21:
3675:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 191              		.loc 1 3675 0
 192 0144 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 193              	.LVL22:
3676:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 194              		.loc 1 3676 0
 195 0148 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 196              	.LVL23:
3677:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 197              		.loc 1 3677 0
 198 014c B8B0D3E1 		ldrh	fp, [r3, #8]
 199              	.LVL24:
 200              		.loc 1 3678 0
 201 0150 03005CE3 		cmp	ip, #3
 202 0154 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 203 0158 3B0000EA 		b	.L16
 204              	.L23:
 205 015c 6C010000 		.word	.L13
 206 0160 6C010000 		.word	.L13
 207 0164 BC010000 		.word	.L15
 208 0168 BC010000 		.word	.L15
 209              	.L13:
3679:../uvc.c      **** 						case 0x20:
3680:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3681:../uvc.c      **** 							delaytime = 500;
3682:../uvc.c      **** 							break;
3683:../uvc.c      **** 						case 0x21:
3684:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 210              		.loc 1 3684 0
 211 016c 5230A0E3 		mov	r3, #82
 212              	.LVL25:
 213 0170 FEFFFFEB 		bl	SensorSetIrisControl
 214              	.LVL26:
3685:../uvc.c      **** 							delaytime = 500;
3686:../uvc.c      **** 							break;
 215              		.loc 1 3686 0
 216 0174 7D1FA0E3 		mov	r1, #500
 217              	.LVL27:
 218              	.L12:
3687:../uvc.c      **** 						case 0x22:
3688:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3689:../uvc.c      **** 							delaytime = 300;
3690:../uvc.c      **** 							break;
3691:../uvc.c      **** 						case 0x23:
3692:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3693:../uvc.c      **** 							delaytime = 300;
3694:../uvc.c      **** 							break;
3695:../uvc.c      **** 						default:
3696:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3697:../uvc.c      **** 							break;
3698:../uvc.c      **** 					}
3699:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3700:../uvc.c      **** 					/** timer's ticket modify **/
3701:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 219              		.loc 1 3701 0
 220 0178 0020A0E3 		mov	r2, #0
 221 017c D4009FE5 		ldr	r0, .L27
 222 0180 FEFFFFEB 		bl	_txe_timer_change
 223              	.LVL28:
3702:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 224              		.loc 1 3702 0
 225 0184 CC009FE5 		ldr	r0, .L27
 226 0188 FEFFFFEB 		bl	_txe_timer_activate
 227              	.LVL29:
3703:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3704:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3705:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3706:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3707:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3708:../uvc.c      **** #endif
3709:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 228              		.loc 1 3709 0
 229 018c 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 230 0190 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 231 0194 030052E1 		cmp	r2, r3
 232 0198 1D00000A 		beq	.L26
3710:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3711:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3712:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3713:../uvc.c      **** 						}else{
3714:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3715:../uvc.c      **** 						}
3716:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3717:../uvc.c      **** 					}else{
3718:../uvc.c      **** 						lcCmdDes->curNum ++;
 233              		.loc 1 3718 0
 234 019c 013083E2 		add	r3, r3, #1
3719:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 235              		.loc 1 3719 0
 236 01a0 0F20A0E3 		mov	r2, #15
3718:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 237              		.loc 1 3718 0
 238 01a4 0130C4E5 		strb	r3, [r4, #1]
 239              		.loc 1 3719 0
 240 01a8 3C2084E5 		str	r2, [r4, #60]
 241              	.LVL30:
 242              	.L20:
3720:../uvc.c      **** 					}
3721:../uvc.c      **** 				}else{
3722:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0); //the free I2C commands timer pace (no setting comman
3723:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3724:../uvc.c      **** 					//CyU3PDebugPrint (4, "I2Ctimer counter %d", timercount);
3725:../uvc.c      **** 					if(timercount >= 3){
3726:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
3727:../uvc.c      **** 							curFlag[curFlagIdx] = 0;
3728:../uvc.c      **** 						}
3729:../uvc.c      **** 							timercount = 0;
3730:../uvc.c      **** 
3731:../uvc.c      **** 					}else{
3732:../uvc.c      **** 							timercount++;
3733:../uvc.c      **** 					}
3734:../uvc.c      **** 				}
3735:../uvc.c      **** 			}
3736:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 243              		.loc 1 3736 0
 244 01ac 1C0095E5 		ldr	r0, [r5, #28]
 245 01b0 FEFFFFEB 		bl	_txe_mutex_put
 246              	.LVL31:
3737:../uvc.c      **** /*
3738:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3739:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3740:../uvc.c      **** */
3741:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3742:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3743:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3744:../uvc.c      **** #endif
3745:../uvc.c      **** 
3746:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3747:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3748:../uvc.c      **** #if 0
3749:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3750:../uvc.c      **** 
3751:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3752:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3753:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3754:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3755:../uvc.c      **** 			    i = 0;
3756:../uvc.c      **** 				 switch(cmdCopyIdx)
3757:../uvc.c      **** 				 {
3758:../uvc.c      **** 					 case BrgtCtlID1:
3759:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3760:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3761:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3762:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3763:../uvc.c      **** 							 i++;
3764:../uvc.c      **** 						 }
3765:../uvc.c      **** 						 else{
3766:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3767:../uvc.c      **** 						 }
3768:../uvc.c      **** 
3769:../uvc.c      **** 						 CyU3PBusyWait(500);
3770:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3771:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3772:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3773:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3774:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3775:../uvc.c      **** 						 }
3776:../uvc.c      **** 						 else{
3777:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3778:../uvc.c      **** 						 }
3779:../uvc.c      **** 						 break;
3780:../uvc.c      **** 					 case HueCtlID5:
3781:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3782:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3783:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3784:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3785:../uvc.c      **** 						 }
3786:../uvc.c      **** 						 else{
3787:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3788:../uvc.c      **** 						 }
3789:../uvc.c      **** 						 break;
3790:../uvc.c      **** 					 case SaturCtlID6:
3791:../uvc.c      **** 					 case WBTLevCtlID10:
3792:../uvc.c      **** 					 default:
3793:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3794:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3795:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3796:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3797:../uvc.c      **** 						 }
3798:../uvc.c      **** 						 else{
3799:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3800:../uvc.c      **** 						 }
3801:../uvc.c      **** 						 break;
3802:../uvc.c      **** 				 }
3803:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3804:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3805:../uvc.c      **** 			}
3806:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3807:../uvc.c      **** #endif
3808:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3809:../uvc.c      **** 		/* Allow other ready threads to run. */
3810:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3811:../uvc.c      **** 			CyU3PThreadRelinquish ();
 247              		.loc 1 3811 0
 248 01b4 FEFFFFEB 		bl	_txe_thread_relinquish
 249              	.LVL32:
3812:../uvc.c      **** 		}
 250              		.loc 1 3812 0
 251 01b8 BFFFFFEA 		b	.L21
 252              	.LVL33:
 253              	.L15:
3692:../uvc.c      **** 							delaytime = 300;
 254              		.loc 1 3692 0
 255 01bc 8230A0E3 		mov	r3, #130
 256              	.LVL34:
 257 01c0 FEFFFFEB 		bl	SensorSetIrisControl
 258              	.LVL35:
3694:../uvc.c      **** 						default:
 259              		.loc 1 3694 0
 260 01c4 4B1FA0E3 		mov	r1, #300
 261 01c8 EAFFFFEA 		b	.L12
 262              	.LVL36:
 263              	.L25:
3722:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 264              		.loc 1 3722 0
 265 01cc 0B20A0E1 		mov	r2, fp
 266 01d0 FA1FA0E3 		mov	r1, #1000
 267 01d4 7C009FE5 		ldr	r0, .L27
 268 01d8 104085E5 		str	r4, [r5, #16]
 269 01dc FEFFFFEB 		bl	_txe_timer_change
 270              	.LVL37:
3723:../uvc.c      **** 					//CyU3PDebugPrint (4, "I2Ctimer counter %d", timercount);
 271              		.loc 1 3723 0
 272 01e0 70009FE5 		ldr	r0, .L27
 273 01e4 FEFFFFEB 		bl	_txe_timer_activate
 274              	.LVL38:
3725:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
 275              		.loc 1 3725 0
 276 01e8 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 277 01ec 020052E3 		cmp	r2, #2
3732:../uvc.c      **** 					}
 278              		.loc 1 3732 0
 279 01f0 01208292 		addls	r2, r2, #1
 280 01f4 2820C995 		strlsb	r2, [r9, #40]
3725:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
 281              		.loc 1 3725 0
 282 01f8 EBFFFF9A 		bls	.L20
 283 01fc 74009FE5 		ldr	r0, .L27+32
 284 0200 0B10A0E1 		mov	r1, fp
 285 0204 4020A0E3 		mov	r2, #64
 286 0208 FEFFFFEB 		bl	memset
 287              	.LVL39:
3729:../uvc.c      **** 
 288              		.loc 1 3729 0
 289 020c 28B0C9E5 		strb	fp, [r9, #40]
 290 0210 E5FFFFEA 		b	.L20
 291              	.LVL40:
 292              	.L26:
3711:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 293              		.loc 1 3711 0
 294 0214 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
3710:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 295              		.loc 1 3710 0
 296 0218 0020A0E3 		mov	r2, #0
3711:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 297              		.loc 1 3711 0
 298 021c 230053E3 		cmp	r3, #35
3712:../uvc.c      **** 						}else{
 299              		.loc 1 3712 0
 300 0220 20304382 		subhi	r3, r3, #32
 301 0224 83308380 		addhi	r3, r3, r3, asl #1
3714:../uvc.c      **** 						}
 302              		.loc 1 3714 0
 303 0228 83308390 		addls	r3, r3, r3, asl #1
3712:../uvc.c      **** 						}else{
 304              		.loc 1 3712 0
 305 022c 83318A80 		addhi	r3, r10, r3, asl #3
3714:../uvc.c      **** 						}
 306              		.loc 1 3714 0
 307 0230 83318A90 		addls	r3, r10, r3, asl #3
3712:../uvc.c      **** 						}else{
 308              		.loc 1 3712 0
 309 0234 1020C385 		strhib	r2, [r3, #16]
3714:../uvc.c      **** 						}
 310              		.loc 1 3714 0
 311 0238 9021C395 		strlsb	r2, [r3, #400]
3716:../uvc.c      **** 					}else{
 312              		.loc 1 3716 0
 313 023c 343094E5 		ldr	r3, [r4, #52]
3710:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 314              		.loc 1 3710 0
 315 0240 3C2084E5 		str	r2, [r4, #60]
3716:../uvc.c      **** 					}else{
 316              		.loc 1 3716 0
 317 0244 103085E5 		str	r3, [r5, #16]
 318 0248 D7FFFFEA 		b	.L20
 319              	.LVL41:
 320              	.L16:
3696:../uvc.c      **** 							break;
 321              		.loc 1 3696 0
 322 024c FEFFFFEB 		bl	SensorSetControl
 323              	.LVL42:
 324 0250 0B10A0E1 		mov	r1, fp
3697:../uvc.c      **** 					}
 325              		.loc 1 3697 0
 326 0254 C7FFFFEA 		b	.L12
 327              	.L28:
 328              		.align	2
 329              	.L27:
 330 0258 00000000 		.word	I2CCmdTimer
 331 025c 00000000 		.word	I2CCmdCb
 332 0260 00000000 		.word	cmdQu
 333 0264 00000000 		.word	.LC0
 334 0268 14000000 		.word	.LC1
 335 026c 00000000 		.word	.LANCHOR0
 336 0270 00000000 		.word	statQu
 337 0274 00000000 		.word	.LANCHOR1
 338 0278 2C000000 		.word	.LANCHOR0+44
 339              		.cfi_endproc
 340              	.LFE25:
 342              		.align	2
 343              		.global	CyFxUvcApplnDmaCallback
 345              	CyFxUvcApplnDmaCallback:
 346              	.LFB10:
1535:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 347              		.loc 1 1535 0
 348              		.cfi_startproc
 349              		@ args = 0, pretend = 0, frame = 0
 350              		@ frame_needed = 0, uses_anonymous_args = 0
 351              	.LVL43:
1539:../uvc.c      ****     {
 352              		.loc 1 1539 0
 353 027c 080051E3 		cmp	r1, #8
1535:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 354              		.loc 1 1535 0
 355 0280 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 356              	.LCFI2:
 357              		.cfi_def_cfa_offset 20
 358              		.cfi_offset 4, -20
 359              		.cfi_offset 5, -16
 360              		.cfi_offset 6, -12
 361              		.cfi_offset 7, -8
 362              		.cfi_offset 14, -4
 363 0284 0250A0E1 		mov	r5, r2
 364 0288 0CD04DE2 		sub	sp, sp, #12
 365              	.LCFI3:
 366              		.cfi_def_cfa_offset 32
1539:../uvc.c      ****     {
 367              		.loc 1 1539 0
 368 028c 0B00000A 		beq	.L40
1578:../uvc.c      ****     {
 369              		.loc 1 1578 0
 370 0290 100051E3 		cmp	r1, #16
 371 0294 0700001A 		bne	.L29
1580:../uvc.c      ****         streamingStarted = CyTrue;
 372              		.loc 1 1580 0
 373 0298 74319FE5 		ldr	r3, .L43
1581:../uvc.c      ****     }
 374              		.loc 1 1581 0
 375 029c 0110A0E3 		mov	r1, #1
 376              	.LVL44:
1580:../uvc.c      ****         streamingStarted = CyTrue;
 377              		.loc 1 1580 0
 378 02a0 BE27D3E1 		ldrh	r2, [r3, #126]
 379              	.LVL45:
1581:../uvc.c      ****     }
 380              		.loc 1 1581 0
 381 02a4 801083E5 		str	r1, [r3, #128]
1580:../uvc.c      ****         streamingStarted = CyTrue;
 382              		.loc 1 1580 0
 383 02a8 012082E0 		add	r2, r2, r1
 384 02ac 0228A0E1 		mov	r2, r2, asl #16
 385 02b0 2228A0E1 		mov	r2, r2, lsr #16
 386 02b4 BE27C3E1 		strh	r2, [r3, #126]	@ movhi
 387              	.LVL46:
 388              	.L29:
1583:../uvc.c      **** 
 389              		.loc 1 1583 0
 390 02b8 0CD08DE2 		add	sp, sp, #12
 391              		@ sp needed
 392 02bc F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 393              	.LVL47:
 394              	.L40:
1541:../uvc.c      ****             {
 395              		.loc 1 1541 0
 396 02c0 50319FE5 		ldr	r3, .L43+4
 397 02c4 B420D2E1 		ldrh	r2, [r2, #4]
 398              	.LVL48:
1543:../uvc.c      ****                 fb++;
 399              		.loc 1 1543 0
 400 02c8 006095E5 		ldr	r6, [r5]
1541:../uvc.c      ****             {
 401              		.loc 1 1541 0
 402 02cc 030052E1 		cmp	r2, r3
 403 02d0 3300000A 		beq	.L41
 404              	.LVL49:
 405              	.LBB6:
 406              	.LBB7:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 407              		.loc 1 1283 0
 408 02d4 40719FE5 		ldr	r7, .L43+8
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 409              		.loc 1 1282 0
 410 02d8 0010E0E3 		mvn	r1, #0
 411              	.LVL50:
 412 02dc 3C019FE5 		ldr	r0, .L43+12
 413              	.LVL51:
 414 02e0 FEFFFFEB 		bl	_txe_mutex_get
 415              	.LVL52:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 416              		.loc 1 1283 0
 417 02e4 121D87E2 		add	r1, r7, #1152
 418 02e8 0C20A0E3 		mov	r2, #12
 419 02ec 0C0046E2 		sub	r0, r6, #12
 420              	.LVL53:
 421 02f0 FEFFFFEB 		bl	CyU3PMemCopy
 422              	.LVL54:
1284:../uvc.c      **** 
 423              		.loc 1 1284 0
 424 02f4 24019FE5 		ldr	r0, .L43+12
 425 02f8 FEFFFFEB 		bl	_txe_mutex_put
 426              	.LVL55:
1289:../uvc.c      ****     }
 427              		.loc 1 1289 0
 428 02fc 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 429              	.LBE7:
 430              	.LBE6:
1550:../uvc.c      ****                 pbc = input->buffer_p.count;
 431              		.loc 1 1550 0
 432 0300 0C419FE5 		ldr	r4, .L43
 433              	.LBB9:
 434              	.LBB8:
1289:../uvc.c      ****     }
 435              		.loc 1 1289 0
 436 0304 023083E3 		orr	r3, r3, #2
 437 0308 0B3046E5 		strb	r3, [r6, #-11]
 438              	.LBE8:
 439              	.LBE9:
1554:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 440              		.loc 1 1554 0
 441 030c 741094E5 		ldr	r1, [r4, #116]
1550:../uvc.c      ****                 pbc = input->buffer_p.count;
 442              		.loc 1 1550 0
 443 0310 BE26D4E1 		ldrh	r2, [r4, #110]
1551:../uvc.c      ****                // hitFV = CyTrue;
 444              		.loc 1 1551 0
 445 0314 B430D5E1 		ldrh	r3, [r5, #4]
1550:../uvc.c      ****                 pbc = input->buffer_p.count;
 446              		.loc 1 1550 0
 447 0318 012082E2 		add	r2, r2, #1
1554:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 448              		.loc 1 1554 0
 449 031c 0F0051E3 		cmp	r1, #15
1550:../uvc.c      ****                 pbc = input->buffer_p.count;
 450              		.loc 1 1550 0
 451 0320 BE26C4E1 		strh	r2, [r4, #110]	@ movhi
1551:../uvc.c      ****                // hitFV = CyTrue;
 452              		.loc 1 1551 0
 453 0324 B037C4E1 		strh	r3, [r4, #112]	@ movhi
1554:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 454              		.loc 1 1554 0
 455 0328 2D00000A 		beq	.L42
 456              	.L33:
1562:../uvc.c      ****             }
 457              		.loc 1 1562 0
 458 032c 0120A0E3 		mov	r2, #1
 459 0330 782084E5 		str	r2, [r4, #120]
 460              	.LVL56:
 461              	.L32:
1566:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 462              		.loc 1 1566 0
 463 0334 BC27D4E1 		ldrh	r2, [r4, #124]
1567:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 464              		.loc 1 1567 0
 465 0338 0C1083E2 		add	r1, r3, #12
1566:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 466              		.loc 1 1566 0
 467 033c 013082E2 		add	r3, r2, #1
1567:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 468              		.loc 1 1567 0
 469 0340 0118A0E1 		mov	r1, r1, asl #16
1566:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 470              		.loc 1 1566 0
 471 0344 0338A0E1 		mov	r3, r3, asl #16
1567:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 472              		.loc 1 1567 0
 473 0348 2118A0E1 		mov	r1, r1, lsr #16
1566:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 474              		.loc 1 1566 0
 475 034c 2338A0E1 		mov	r3, r3, lsr #16
1567:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 476              		.loc 1 1567 0
 477 0350 0020A0E3 		mov	r2, #0
 478 0354 C8009FE5 		ldr	r0, .L43+16
1566:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 479              		.loc 1 1566 0
 480 0358 BC37C4E1 		strh	r3, [r4, #124]	@ movhi
1567:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 481              		.loc 1 1567 0
 482 035c FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 483              	.LVL57:
1566:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 484              		.loc 1 1566 0
 485 0360 AC109FE5 		ldr	r1, .L43
1570:../uvc.c      ****             {
 486              		.loc 1 1570 0
 487 0364 002050E2 		subs	r2, r0, #0
 488 0368 D2FFFF0A 		beq	.L29
1572:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 489              		.loc 1 1572 0
 490 036c BC07D1E1 		ldrh	r0, [r1, #124]
 491              	.LVL58:
1573:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 492              		.loc 1 1573 0
 493 0370 B430D5E1 		ldrh	r3, [r5, #4]
1572:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 494              		.loc 1 1572 0
 495 0374 010040E2 		sub	r0, r0, #1
 496 0378 0008A0E1 		mov	r0, r0, asl #16
 497 037c 2008A0E1 		mov	r0, r0, lsr #16
 498 0380 BC07C1E1 		strh	r0, [r1, #124]	@ movhi
1573:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 499              		.loc 1 1573 0
 500 0384 BC07D1E1 		ldrh	r0, [r1, #124]
 501 0388 BE17D1E1 		ldrh	r1, [r1, #126]
 502 038c 001061E0 		rsb	r1, r1, r0
 503 0390 00108DE5 		str	r1, [sp]
 504 0394 0400A0E3 		mov	r0, #4
 505 0398 88109FE5 		ldr	r1, .L43+20
 506 039c FEFFFFEB 		bl	CyU3PDebugPrint
 507              	.LVL59:
 508 03a0 C4FFFFEA 		b	.L29
 509              	.LVL60:
 510              	.L41:
 511              	.LBB10:
 512              	.LBB11:
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 513              		.loc 1 1282 0
 514 03a4 0010E0E3 		mvn	r1, #0
 515              	.LVL61:
 516              	.LBE11:
 517              	.LBE10:
1544:../uvc.c      ****             }
 518              		.loc 1 1544 0
 519 03a8 64409FE5 		ldr	r4, .L43
 520              	.LBB14:
 521              	.LBB12:
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 522              		.loc 1 1282 0
 523 03ac 6C009FE5 		ldr	r0, .L43+12
 524              	.LVL62:
 525 03b0 FEFFFFEB 		bl	_txe_mutex_get
 526              	.LVL63:
 527              	.LBE12:
 528              	.LBE14:
1543:../uvc.c      ****                 fb++;
 529              		.loc 1 1543 0
 530 03b4 0C6046E2 		sub	r6, r6, #12
 531              	.LVL64:
 532              	.LBB15:
 533              	.LBB13:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 534              		.loc 1 1283 0
 535 03b8 0C20A0E3 		mov	r2, #12
 536 03bc 0600A0E1 		mov	r0, r6
 537 03c0 64109FE5 		ldr	r1, .L43+24
 538 03c4 FEFFFFEB 		bl	CyU3PMemCopy
 539              	.LVL65:
1284:../uvc.c      **** 
 540              		.loc 1 1284 0
 541 03c8 50009FE5 		ldr	r0, .L43+12
 542 03cc FEFFFFEB 		bl	_txe_mutex_put
 543              	.LVL66:
 544              	.LBE13:
 545              	.LBE15:
1544:../uvc.c      ****             }
 546              		.loc 1 1544 0
 547 03d0 BC26D4E1 		ldrh	r2, [r4, #108]
 548 03d4 B430D5E1 		ldrh	r3, [r5, #4]
 549 03d8 012082E2 		add	r2, r2, #1
 550 03dc BC26C4E1 		strh	r2, [r4, #108]	@ movhi
 551 03e0 D3FFFFEA 		b	.L32
 552              	.LVL67:
 553              	.L42:
1555:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 554              		.loc 1 1555 0
 555 03e4 0010E0E3 		mvn	r1, #0
 556 03e8 30009FE5 		ldr	r0, .L43+12
 557 03ec FEFFFFEB 		bl	_txe_mutex_get
 558              	.LVL68:
1556:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 559              		.loc 1 1556 0
 560 03f0 8134D7E5 		ldrb	r3, [r7, #1153]	@ zero_extendqisi2
1557:../uvc.c      ****                 	//stiflag = 0xAA;
 561              		.loc 1 1557 0
 562 03f4 24009FE5 		ldr	r0, .L43+12
1556:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 563              		.loc 1 1556 0
 564 03f8 DF3003E2 		and	r3, r3, #223
 565 03fc 8134C7E5 		strb	r3, [r7, #1153]
1557:../uvc.c      ****                 	//stiflag = 0xAA;
 566              		.loc 1 1557 0
 567 0400 FEFFFFEB 		bl	_txe_mutex_put
 568              	.LVL69:
1559:../uvc.c      ****                 }
 569              		.loc 1 1559 0
 570 0404 0030A0E3 		mov	r3, #0
 571 0408 743084E5 		str	r3, [r4, #116]
 572 040c B430D5E1 		ldrh	r3, [r5, #4]
 573 0410 C5FFFFEA 		b	.L33
 574              	.L44:
 575              		.align	2
 576              	.L43:
 577 0414 00000000 		.word	.LANCHOR0
 578 0418 F03F0000 		.word	16368
 579 041c 00000000 		.word	.LANCHOR1
 580 0420 00000000 		.word	imgHdMux
 581 0424 00000000 		.word	glChHandleUVCStream
 582 0428 38000000 		.word	.LC2
 583 042c 80040000 		.word	.LANCHOR1+1152
 584              		.cfi_endproc
 585              	.LFE10:
 587              		.align	2
 589              	CyFxUVCApplnUSBEventCB:
 590              	.LFB8:
1338:../uvc.c      ****     switch (evtype)
 591              		.loc 1 1338 0
 592              		.cfi_startproc
 593              		@ args = 0, pretend = 0, frame = 8
 594              		@ frame_needed = 0, uses_anonymous_args = 0
 595              	.LVL70:
1339:../uvc.c      ****     {
 596              		.loc 1 1339 0
 597 0430 020050E3 		cmp	r0, #2
1338:../uvc.c      ****     switch (evtype)
 598              		.loc 1 1338 0
 599 0434 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 600              	.LCFI4:
 601              		.cfi_def_cfa_offset 16
 602              		.cfi_offset 4, -16
 603              		.cfi_offset 5, -12
 604              		.cfi_offset 6, -8
 605              		.cfi_offset 14, -4
 606 0438 0040A0E1 		mov	r4, r0
 607 043c 10D04DE2 		sub	sp, sp, #16
 608              	.LCFI5:
 609              		.cfi_def_cfa_offset 32
1339:../uvc.c      ****     {
 610              		.loc 1 1339 0
 611 0440 3D00000A 		beq	.L47
 612 0444 040050E3 		cmp	r0, #4
 613 0448 2000000A 		beq	.L48
 614 044c 010050E3 		cmp	r0, #1
 615 0450 0100000A 		beq	.L53
 616              	.LVL71:
 617              	.L45:
1375:../uvc.c      **** 
 618              		.loc 1 1375 0
 619 0454 10D08DE2 		add	sp, sp, #16
 620              		@ sp needed
 621 0458 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 622              	.LVL72:
 623              	.L53:
 624              	.LBB30:
 625              	.LBB31:
1358:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 626              		.loc 1 1358 0
 627 045c 0130A0E1 		mov	r3, r1
 628 0460 0420A0E1 		mov	r2, r4
1360:../uvc.c      ****             isUsbConnected = CyFalse;
 629              		.loc 1 1360 0
 630 0464 40519FE5 		ldr	r5, .L54
1358:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 631              		.loc 1 1358 0
 632 0468 40119FE5 		ldr	r1, .L54+4
 633              	.LVL73:
 634 046c 0400A0E3 		mov	r0, #4
 635              	.LVL74:
 636 0470 FEFFFFEB 		bl	CyU3PDebugPrint
 637              	.LVL75:
1359:../uvc.c      ****             gpif_initialized = 0;
 638              		.loc 1 1359 0
 639 0474 0400A0E1 		mov	r0, r4
 640 0478 FEFFFFEB 		bl	CyU3PGpifDisable
 641              	.LVL76:
1360:../uvc.c      ****             isUsbConnected = CyFalse;
 642              		.loc 1 1360 0
 643 047c 00C0A0E3 		mov	ip, #0
 644              	.LBB32:
 645              	.LBB33:
1322:../uvc.c      **** 	{
 646              		.loc 1 1322 0
 647 0480 00C08DE5 		str	ip, [sp]
 648 0484 0410A0E1 		mov	r1, r4
 649 0488 0500A0E1 		mov	r0, r5
 650 048c 0220A0E3 		mov	r2, #2
 651 0490 0C308DE2 		add	r3, sp, #12
 652              	.LBE33:
 653              	.LBE32:
1360:../uvc.c      ****             isUsbConnected = CyFalse;
 654              		.loc 1 1360 0
 655 0494 84C085E5 		str	ip, [r5, #132]
1361:../uvc.c      ****             streamingStarted = CyFalse;
 656              		.loc 1 1361 0
 657 0498 88C085E5 		str	ip, [r5, #136]
1362:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 658              		.loc 1 1362 0
 659 049c 80C085E5 		str	ip, [r5, #128]
 660              	.LBB37:
 661              	.LBB36:
1322:../uvc.c      **** 	{
 662              		.loc 1 1322 0
 663 04a0 FEFFFFEB 		bl	_txe_event_flags_get
 664              	.LVL77:
 665 04a4 004050E2 		subs	r4, r0, #0
 666 04a8 E9FFFF1A 		bne	.L45
 667              	.LBB34:
 668              	.LBB35:
1325:../uvc.c      **** 
 669              		.loc 1 1325 0
 670 04ac 0500A0E1 		mov	r0, r5
 671 04b0 0110E0E3 		mvn	r1, #1
 672 04b4 0220A0E3 		mov	r2, #2
 673 04b8 FEFFFFEB 		bl	_txe_event_flags_set
 674              	.LVL78:
1328:../uvc.c      **** 	}
 675              		.loc 1 1328 0
 676 04bc 0500A0E1 		mov	r0, r5
 677 04c0 0420A0E1 		mov	r2, r4
 678 04c4 0210A0E3 		mov	r1, #2
 679 04c8 FEFFFFEB 		bl	_txe_event_flags_set
 680              	.LVL79:
 681 04cc E0FFFFEA 		b	.L45
 682              	.LVL80:
 683              	.L48:
 684              	.LBE35:
 685              	.LBE34:
 686              	.LBE36:
 687              	.LBE37:
 688              	.LBE31:
 689              	.LBE30:
1342:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 690              		.loc 1 1342 0
 691 04d0 0130A0E1 		mov	r3, r1
 692 04d4 0020A0E1 		mov	r2, r0
 693 04d8 D4109FE5 		ldr	r1, .L54+8
 694              	.LVL81:
 695 04dc FEFFFFEB 		bl	CyU3PDebugPrint
 696              	.LVL82:
1344:../uvc.c      ****             streamingStarted = CyFalse;
 697              		.loc 1 1344 0
 698 04e0 C4409FE5 		ldr	r4, .L54
1343:../uvc.c      ****             gpif_initialized = 0;
 699              		.loc 1 1343 0
 700 04e4 0100A0E3 		mov	r0, #1
 701 04e8 FEFFFFEB 		bl	CyU3PGpifDisable
 702              	.LVL83:
1344:../uvc.c      ****             streamingStarted = CyFalse;
 703              		.loc 1 1344 0
 704 04ec 00C0A0E3 		mov	ip, #0
 705              	.LBB38:
 706              	.LBB39:
1322:../uvc.c      **** 	{
 707              		.loc 1 1322 0
 708 04f0 00C08DE5 		str	ip, [sp]
 709 04f4 0400A0E1 		mov	r0, r4
 710 04f8 0110A0E3 		mov	r1, #1
 711 04fc 0220A0E3 		mov	r2, #2
 712 0500 0C308DE2 		add	r3, sp, #12
 713              	.LBE39:
 714              	.LBE38:
1344:../uvc.c      ****             streamingStarted = CyFalse;
 715              		.loc 1 1344 0
 716 0504 84C084E5 		str	ip, [r4, #132]
1345:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 717              		.loc 1 1345 0
 718 0508 80C084E5 		str	ip, [r4, #128]
 719              	.LBB43:
 720              	.LBB42:
1322:../uvc.c      **** 	{
 721              		.loc 1 1322 0
 722 050c FEFFFFEB 		bl	_txe_event_flags_get
 723              	.LVL84:
 724 0510 005050E2 		subs	r5, r0, #0
 725 0514 CEFFFF1A 		bne	.L45
 726              	.LBB40:
 727              	.LBB41:
1325:../uvc.c      **** 
 728              		.loc 1 1325 0
 729 0518 0400A0E1 		mov	r0, r4
 730 051c 0110E0E3 		mvn	r1, #1
 731 0520 0220A0E3 		mov	r2, #2
 732 0524 FEFFFFEB 		bl	_txe_event_flags_set
 733              	.LVL85:
1328:../uvc.c      **** 	}
 734              		.loc 1 1328 0
 735 0528 0400A0E1 		mov	r0, r4
 736 052c 0520A0E1 		mov	r2, r5
 737 0530 0210A0E3 		mov	r1, #2
 738 0534 FEFFFFEB 		bl	_txe_event_flags_set
 739              	.LVL86:
 740 0538 C5FFFFEA 		b	.L45
 741              	.LVL87:
 742              	.L47:
 743              	.LBE41:
 744              	.LBE40:
 745              	.LBE42:
 746              	.LBE43:
1350:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 747              		.loc 1 1350 0
 748 053c 0130A0E1 		mov	r3, r1
 749 0540 0420A0E1 		mov	r2, r4
 750 0544 6C109FE5 		ldr	r1, .L54+12
 751              	.LVL88:
1352:../uvc.c      ****             streamingStarted = CyFalse;
 752              		.loc 1 1352 0
 753 0548 5C509FE5 		ldr	r5, .L54
1350:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 754              		.loc 1 1350 0
 755 054c 0400A0E3 		mov	r0, #4
 756              	.LVL89:
 757 0550 FEFFFFEB 		bl	CyU3PDebugPrint
 758              	.LVL90:
1351:../uvc.c      ****             gpif_initialized = 0;
 759              		.loc 1 1351 0
 760 0554 0100A0E3 		mov	r0, #1
 761 0558 FEFFFFEB 		bl	CyU3PGpifDisable
 762              	.LVL91:
1352:../uvc.c      ****             streamingStarted = CyFalse;
 763              		.loc 1 1352 0
 764 055c 00C0A0E3 		mov	ip, #0
 765              	.LBB44:
 766              	.LBB45:
1322:../uvc.c      **** 	{
 767              		.loc 1 1322 0
 768 0560 00C08DE5 		str	ip, [sp]
 769 0564 0500A0E1 		mov	r0, r5
 770 0568 0110A0E3 		mov	r1, #1
 771 056c 0420A0E1 		mov	r2, r4
 772 0570 0C308DE2 		add	r3, sp, #12
 773              	.LBE45:
 774              	.LBE44:
1352:../uvc.c      ****             streamingStarted = CyFalse;
 775              		.loc 1 1352 0
 776 0574 84C085E5 		str	ip, [r5, #132]
1353:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 777              		.loc 1 1353 0
 778 0578 80C085E5 		str	ip, [r5, #128]
 779              	.LBB49:
 780              	.LBB48:
1322:../uvc.c      **** 	{
 781              		.loc 1 1322 0
 782 057c FEFFFFEB 		bl	_txe_event_flags_get
 783              	.LVL92:
 784 0580 006050E2 		subs	r6, r0, #0
 785 0584 B2FFFF1A 		bne	.L45
 786              	.LBB46:
 787              	.LBB47:
1325:../uvc.c      **** 
 788              		.loc 1 1325 0
 789 0588 0420A0E1 		mov	r2, r4
 790 058c 0500A0E1 		mov	r0, r5
 791 0590 0110E0E3 		mvn	r1, #1
 792 0594 FEFFFFEB 		bl	_txe_event_flags_set
 793              	.LVL93:
1328:../uvc.c      **** 	}
 794              		.loc 1 1328 0
 795 0598 0500A0E1 		mov	r0, r5
 796 059c 0410A0E1 		mov	r1, r4
 797 05a0 0620A0E1 		mov	r2, r6
 798 05a4 FEFFFFEB 		bl	_txe_event_flags_set
 799              	.LVL94:
 800 05a8 A9FFFFEA 		b	.L45
 801              	.L55:
 802              		.align	2
 803              	.L54:
 804 05ac 00000000 		.word	.LANCHOR0
 805 05b0 C4000000 		.word	.LC5
 806 05b4 80000000 		.word	.LC3
 807 05b8 A0000000 		.word	.LC4
 808              	.LBE47:
 809              	.LBE46:
 810              	.LBE48:
 811              	.LBE49:
 812              		.cfi_endproc
 813              	.LFE8:
 815              		.align	2
 817              	CyFxUVCApplnUSBSetupCB:
 818              	.LFB9:
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 819              		.loc 1 1383 0
 820              		.cfi_startproc
 821              		@ args = 0, pretend = 0, frame = 8
 822              		@ frame_needed = 0, uses_anonymous_args = 0
 823              	.LVL95:
 824 05bc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 825              	.LCFI6:
 826              		.cfi_def_cfa_offset 28
 827              		.cfi_offset 4, -28
 828              		.cfi_offset 5, -24
 829              		.cfi_offset 6, -20
 830              		.cfi_offset 7, -16
 831              		.cfi_offset 8, -12
 832              		.cfi_offset 9, -8
 833              		.cfi_offset 14, -4
1392:../uvc.c      **** 
 834              		.loc 1 1392 0
 835 05c0 B0C29FE5 		ldr	ip, .L90
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 836              		.loc 1 1389 0
 837 05c4 B0929FE5 		ldr	r9, .L90+4
1391:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 838              		.loc 1 1391 0
 839 05c8 B0829FE5 		ldr	r8, .L90+8
1388:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 840              		.loc 1 1388 0
 841 05cc B0229FE5 		ldr	r2, .L90+12
1390:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 842              		.loc 1 1390 0
 843 05d0 B0329FE5 		ldr	r3, .L90+16
1391:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 844              		.loc 1 1391 0
 845 05d4 0168A0E1 		mov	r6, r1, asl #16
1388:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 846              		.loc 1 1388 0
 847 05d8 FF4000E2 		and	r4, r0, #255
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 848              		.loc 1 1389 0
 849 05dc FF5C00E2 		and	r5, r0, #65280
 850 05e0 2554A0E1 		mov	r5, r5, lsr #8
1391:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 851              		.loc 1 1391 0
 852 05e4 2668A0E1 		mov	r6, r6, lsr #16
1392:../uvc.c      **** 
 853              		.loc 1 1392 0
 854 05e8 2118A0E1 		mov	r1, r1, lsr #16
 855              	.LVL96:
1390:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 856              		.loc 1 1390 0
 857 05ec 2078A0E1 		mov	r7, r0, lsr #16
1395:../uvc.c      ****     {
 858              		.loc 1 1395 0
 859 05f0 020054E3 		cmp	r4, #2
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 860              		.loc 1 1383 0
 861 05f4 14D04DE2 		sub	sp, sp, #20
 862              	.LCFI7:
 863              		.cfi_def_cfa_offset 48
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 864              		.loc 1 1389 0
 865 05f8 0050C9E5 		strb	r5, [r9]
1391:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 866              		.loc 1 1391 0
 867 05fc B060C8E1 		strh	r6, [r8]	@ movhi
1392:../uvc.c      **** 
 868              		.loc 1 1392 0
 869 0600 B010CCE1 		strh	r1, [ip]	@ movhi
1388:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 870              		.loc 1 1388 0
 871 0604 0040C2E5 		strb	r4, [r2]
1390:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 872              		.loc 1 1390 0
 873 0608 B070C3E1 		strh	r7, [r3]	@ movhi
1395:../uvc.c      ****     {
 874              		.loc 1 1395 0
 875 060c 4A00000A 		beq	.L58
 876 0610 0600009A 		bls	.L87
 877 0614 210054E3 		cmp	r4, #33
 878 0618 3900000A 		beq	.L61
 879 061c A10054E3 		cmp	r4, #161
 880 0620 3700000A 		beq	.L61
 881              	.L75:
1384:../uvc.c      ****     uint32_t status;
 882              		.loc 1 1384 0
 883 0624 0000A0E3 		mov	r0, #0
 884              	.LVL97:
 885              	.L57:
1522:../uvc.c      **** 
 886              		.loc 1 1522 0
 887 0628 14D08DE2 		add	sp, sp, #20
 888              		@ sp needed
 889 062c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 890              	.LVL98:
 891              	.L87:
1395:../uvc.c      ****     {
 892              		.loc 1 1395 0
 893 0630 010054E3 		cmp	r4, #1
 894 0634 FAFFFF1A 		bne	.L75
1435:../uvc.c      ****             {
 895              		.loc 1 1435 0
 896 0638 0B0055E3 		cmp	r5, #11
 897 063c F8FFFF1A 		bne	.L75
1439:../uvc.c      ****                 {
 898              		.loc 1 1439 0
 899 0640 010056E3 		cmp	r6, #1
 900 0644 F6FFFF1A 		bne	.L75
1439:../uvc.c      ****                 {
 901              		.loc 1 1439 0 is_stmt 0 discriminator 1
 902 0648 000057E3 		cmp	r7, #0
 903 064c F4FFFF1A 		bne	.L75
1444:../uvc.c      ****                     streamingStarted = CyFalse;
 904              		.loc 1 1444 0 is_stmt 1
 905 0650 34429FE5 		ldr	r4, .L90+20
1442:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 906              		.loc 1 1442 0
 907 0654 34129FE5 		ldr	r1, .L90+24
 908 0658 0400A0E3 		mov	r0, #4
 909              	.LVL99:
 910 065c FEFFFFEB 		bl	CyU3PDebugPrint
 911              	.LVL100:
1443:../uvc.c      ****                     gpif_initialized = 0;
 912              		.loc 1 1443 0
 913 0660 0600A0E1 		mov	r0, r6
 914 0664 FEFFFFEB 		bl	CyU3PGpifDisable
 915              	.LVL101:
1447:../uvc.c      ****                     CyU3PBusyWait (100);
 916              		.loc 1 1447 0
 917 0668 0610A0E1 		mov	r1, r6
 918 066c 8300A0E3 		mov	r0, #131
1444:../uvc.c      ****                     streamingStarted = CyFalse;
 919              		.loc 1 1444 0
 920 0670 847084E5 		str	r7, [r4, #132]
1445:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 921              		.loc 1 1445 0
 922 0674 807084E5 		str	r7, [r4, #128]
1447:../uvc.c      ****                     CyU3PBusyWait (100);
 923              		.loc 1 1447 0
 924 0678 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 925              	.LVL102:
1448:../uvc.c      **** 
 926              		.loc 1 1448 0
 927 067c 6400A0E3 		mov	r0, #100
 928 0680 FEFFFFEB 		bl	CyFx3BusyWait
 929              	.LVL103:
1451:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 930              		.loc 1 1451 0
 931 0684 08029FE5 		ldr	r0, .L90+28
 932 0688 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 933              	.LVL104:
1452:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 934              		.loc 1 1452 0
 935 068c 8300A0E3 		mov	r0, #131
 936 0690 FEFFFFEB 		bl	CyU3PUsbFlushEp
 937              	.LVL105:
1453:../uvc.c      ****                     CyU3PBusyWait (100);
 938              		.loc 1 1453 0
 939 0694 0710A0E1 		mov	r1, r7
 940 0698 8300A0E3 		mov	r0, #131
 941 069c FEFFFFEB 		bl	CyU3PUsbSetEpNak
 942              	.LVL106:
1454:../uvc.c      **** 
 943              		.loc 1 1454 0
 944 06a0 6400A0E3 		mov	r0, #100
 945 06a4 FEFFFFEB 		bl	CyFx3BusyWait
 946              	.LVL107:
1457:../uvc.c      ****                     uvcHandleReq = CyTrue;
 947              		.loc 1 1457 0
 948 06a8 0710A0E1 		mov	r1, r7
 949 06ac 0620A0E1 		mov	r2, r6
 950 06b0 8300A0E3 		mov	r0, #131
 951 06b4 FEFFFFEB 		bl	CyU3PUsbStall
 952              	.LVL108:
1460:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 953              		.loc 1 1460 0
 954 06b8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 955              	.LVL109:
 956              	.LBB58:
 957              	.LBB59:
1322:../uvc.c      **** 	{
 958              		.loc 1 1322 0
 959 06bc 00708DE5 		str	r7, [sp]
 960 06c0 0610A0E1 		mov	r1, r6
 961 06c4 0400A0E1 		mov	r0, r4
 962 06c8 0220A0E3 		mov	r2, #2
 963 06cc 0C308DE2 		add	r3, sp, #12
 964              	.LBE59:
 965              	.LBE58:
1462:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 966              		.loc 1 1462 0
 967 06d0 8C6084E5 		str	r6, [r4, #140]
 968              	.LBB63:
 969              	.LBB62:
1322:../uvc.c      **** 	{
 970              		.loc 1 1322 0
 971 06d4 FEFFFFEB 		bl	_txe_event_flags_get
 972              	.LVL110:
 973 06d8 005050E2 		subs	r5, r0, #0
 974 06dc 1300001A 		bne	.L86
 975              	.LBB60:
 976              	.LBB61:
1325:../uvc.c      **** 
 977              		.loc 1 1325 0
 978 06e0 0400A0E1 		mov	r0, r4
 979 06e4 0110E0E3 		mvn	r1, #1
 980 06e8 0220A0E3 		mov	r2, #2
 981 06ec FEFFFFEB 		bl	_txe_event_flags_set
 982              	.LVL111:
1328:../uvc.c      **** 	}
 983              		.loc 1 1328 0
 984 06f0 0400A0E1 		mov	r0, r4
 985 06f4 0520A0E1 		mov	r2, r5
 986 06f8 0210A0E3 		mov	r1, #2
 987 06fc FEFFFFEB 		bl	_txe_event_flags_set
 988              	.LVL112:
 989 0700 0A0000EA 		b	.L86
 990              	.LVL113:
 991              	.L61:
 992              	.LBE61:
 993              	.LBE60:
 994              	.LBE62:
 995              	.LBE63:
1400:../uvc.c      ****             {
 996              		.loc 1 1400 0
 997 0704 FF6006E2 		and	r6, r6, #255
 998 0708 000056E3 		cmp	r6, #0
 999 070c 1500000A 		beq	.L62
 1000 0710 010056E3 		cmp	r6, #1
 1001 0714 C2FFFF1A 		bne	.L75
 1002              	.LVL114:
1418:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1003              		.loc 1 1418 0
 1004 0718 0020A0E3 		mov	r2, #0
 1005 071c 68019FE5 		ldr	r0, .L90+20
 1006              	.LVL115:
 1007 0720 0810A0E3 		mov	r1, #8
 1008 0724 FEFFFFEB 		bl	_txe_event_flags_set
 1009              	.LVL116:
1420:../uvc.c      ****                         {
 1010              		.loc 1 1420 0
 1011 0728 002050E2 		subs	r2, r0, #0
 1012 072c 1B00001A 		bne	.L88
 1013              	.LVL117:
 1014              	.L86:
1404:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1015              		.loc 1 1404 0
 1016 0730 0100A0E3 		mov	r0, #1
 1017              	.LVL118:
1522:../uvc.c      **** 
 1018              		.loc 1 1522 0
 1019 0734 14D08DE2 		add	sp, sp, #20
 1020              		@ sp needed
 1021 0738 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1022              	.LVL119:
 1023              	.L58:
1470:../uvc.c      ****             {
 1024              		.loc 1 1470 0
 1025 073c 010055E3 		cmp	r5, #1
 1026 0740 B7FFFF1A 		bne	.L75
1472:../uvc.c      ****                 {
 1027              		.loc 1 1472 0
 1028 0744 830056E3 		cmp	r6, #131
 1029 0748 B5FFFF1A 		bne	.L75
1478:../uvc.c      ****                     {
 1030              		.loc 1 1478 0
 1031 074c 38819FE5 		ldr	r8, .L90+20
 1032 0750 807098E5 		ldr	r7, [r8, #128]
 1033 0754 010057E3 		cmp	r7, #1
 1034 0758 1900000A 		beq	.L89
 1035              	.LVL120:
1510:../uvc.c      ****                     }
 1036              		.loc 1 1510 0
 1037 075c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1038              	.LVL121:
1509:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1039              		.loc 1 1509 0
 1040 0760 0500A0E1 		mov	r0, r5
 1041 0764 AFFFFFEA 		b	.L57
 1042              	.LVL122:
 1043              	.L62:
1405:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1044              		.loc 1 1405 0
 1045 0768 0620A0E1 		mov	r2, r6
 1046 076c 18019FE5 		ldr	r0, .L90+20
 1047              	.LVL123:
 1048 0770 0410A0E3 		mov	r1, #4
 1049 0774 FEFFFFEB 		bl	_txe_event_flags_set
 1050              	.LVL124:
1407:../uvc.c      ****                         {
 1051              		.loc 1 1407 0
 1052 0778 002050E2 		subs	r2, r0, #0
 1053 077c EBFFFF0A 		beq	.L86
1409:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1054              		.loc 1 1409 0
 1055 0780 10119FE5 		ldr	r1, .L90+32
 1056 0784 0400A0E3 		mov	r0, #4
 1057              	.LVL125:
 1058 0788 FEFFFFEB 		bl	CyU3PDebugPrint
 1059              	.LVL126:
1410:../uvc.c      ****                         }
 1060              		.loc 1 1410 0
 1061 078c 0600A0E1 		mov	r0, r6
 1062 0790 0620A0E1 		mov	r2, r6
 1063 0794 0110A0E3 		mov	r1, #1
 1064 0798 FEFFFFEB 		bl	CyU3PUsbStall
 1065              	.LVL127:
 1066 079c E3FFFFEA 		b	.L86
 1067              	.LVL128:
 1068              	.L88:
1423:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1069              		.loc 1 1423 0
 1070 07a0 F4109FE5 		ldr	r1, .L90+36
 1071 07a4 0400A0E3 		mov	r0, #4
 1072              	.LVL129:
 1073 07a8 FEFFFFEB 		bl	CyU3PDebugPrint
 1074              	.LVL130:
1424:../uvc.c      ****                         }
 1075              		.loc 1 1424 0
 1076 07ac 0000A0E3 		mov	r0, #0
 1077 07b0 0020A0E1 		mov	r2, r0
 1078 07b4 0610A0E1 		mov	r1, r6
 1079 07b8 FEFFFFEB 		bl	CyU3PUsbStall
 1080              	.LVL131:
1417:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1081              		.loc 1 1417 0
 1082 07bc 0600A0E1 		mov	r0, r6
 1083 07c0 98FFFFEA 		b	.L57
 1084              	.LVL132:
 1085              	.L89:
1480:../uvc.c      **** 
 1086              		.loc 1 1480 0
 1087 07c4 D4109FE5 		ldr	r1, .L90+40
 1088 07c8 0400A0E3 		mov	r0, #4
 1089              	.LVL133:
 1090 07cc FEFFFFEB 		bl	CyU3PDebugPrint
 1091              	.LVL134:
1483:../uvc.c      ****                         gpif_initialized = 0;
 1092              		.loc 1 1483 0
 1093 07d0 0700A0E1 		mov	r0, r7
 1094 07d4 FEFFFFEB 		bl	CyU3PGpifDisable
 1095              	.LVL135:
1484:../uvc.c      ****                         streamingStarted = CyFalse;
 1096              		.loc 1 1484 0
 1097 07d8 0050A0E3 		mov	r5, #0
1488:../uvc.c      ****                         CyU3PBusyWait (100);
 1098              		.loc 1 1488 0
 1099 07dc 0710A0E1 		mov	r1, r7
 1100 07e0 0600A0E1 		mov	r0, r6
1484:../uvc.c      ****                         streamingStarted = CyFalse;
 1101              		.loc 1 1484 0
 1102 07e4 845088E5 		str	r5, [r8, #132]
1485:../uvc.c      **** 
 1103              		.loc 1 1485 0
 1104 07e8 805088E5 		str	r5, [r8, #128]
1488:../uvc.c      ****                         CyU3PBusyWait (100);
 1105              		.loc 1 1488 0
 1106 07ec FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1107              	.LVL136:
1489:../uvc.c      **** 
 1108              		.loc 1 1489 0
 1109 07f0 6400A0E3 		mov	r0, #100
 1110 07f4 FEFFFFEB 		bl	CyFx3BusyWait
 1111              	.LVL137:
1492:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1112              		.loc 1 1492 0
 1113 07f8 94009FE5 		ldr	r0, .L90+28
 1114 07fc FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1115              	.LVL138:
1493:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1116              		.loc 1 1493 0
 1117 0800 0600A0E1 		mov	r0, r6
 1118 0804 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1119              	.LVL139:
1494:../uvc.c      ****                         CyU3PBusyWait (100);
 1120              		.loc 1 1494 0
 1121 0808 0510A0E1 		mov	r1, r5
 1122 080c 0600A0E1 		mov	r0, r6
 1123 0810 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1124              	.LVL140:
1495:../uvc.c      **** 
 1125              		.loc 1 1495 0
 1126 0814 6400A0E3 		mov	r0, #100
 1127 0818 FEFFFFEB 		bl	CyFx3BusyWait
 1128              	.LVL141:
1498:../uvc.c      **** 
 1129              		.loc 1 1498 0
 1130 081c 0510A0E1 		mov	r1, r5
 1131 0820 0720A0E1 		mov	r2, r7
 1132 0824 0600A0E1 		mov	r0, r6
 1133 0828 FEFFFFEB 		bl	CyU3PUsbStall
 1134              	.LVL142:
1502:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1135              		.loc 1 1502 0
 1136 082c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1137              	.LVL143:
 1138              	.LBB64:
 1139              	.LBB65:
1322:../uvc.c      **** 	{
 1140              		.loc 1 1322 0
 1141 0830 00508DE5 		str	r5, [sp]
 1142 0834 0710A0E1 		mov	r1, r7
 1143 0838 0800A0E1 		mov	r0, r8
 1144 083c 0420A0E1 		mov	r2, r4
 1145 0840 0C308DE2 		add	r3, sp, #12
 1146              	.LBE65:
 1147              	.LBE64:
1504:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1148              		.loc 1 1504 0
 1149 0844 8C7088E5 		str	r7, [r8, #140]
 1150              	.LBB69:
 1151              	.LBB68:
1322:../uvc.c      **** 	{
 1152              		.loc 1 1322 0
 1153 0848 FEFFFFEB 		bl	_txe_event_flags_get
 1154              	.LVL144:
 1155 084c 005050E2 		subs	r5, r0, #0
 1156 0850 B6FFFF1A 		bne	.L86
 1157              	.LBB66:
 1158              	.LBB67:
1325:../uvc.c      **** 
 1159              		.loc 1 1325 0
 1160 0854 0420A0E1 		mov	r2, r4
 1161 0858 0800A0E1 		mov	r0, r8
 1162 085c 0110E0E3 		mvn	r1, #1
 1163 0860 FEFFFFEB 		bl	_txe_event_flags_set
 1164              	.LVL145:
1328:../uvc.c      **** 	}
 1165              		.loc 1 1328 0
 1166 0864 0800A0E1 		mov	r0, r8
 1167 0868 0410A0E1 		mov	r1, r4
 1168 086c 0520A0E1 		mov	r2, r5
 1169 0870 FEFFFFEB 		bl	_txe_event_flags_set
 1170              	.LVL146:
 1171 0874 ADFFFFEA 		b	.L86
 1172              	.L91:
 1173              		.align	2
 1174              	.L90:
 1175 0878 00000000 		.word	wLength
 1176 087c 00000000 		.word	bRequest
 1177 0880 00000000 		.word	wIndex
 1178 0884 00000000 		.word	bmReqType
 1179 0888 00000000 		.word	wValue
 1180 088c 00000000 		.word	.LANCHOR0
 1181 0890 50010000 		.word	.LC8
 1182 0894 00000000 		.word	glChHandleUVCStream
 1183 0898 E4000000 		.word	.LC6
 1184 089c 1C010000 		.word	.LC7
 1185 08a0 68010000 		.word	.LC9
 1186              	.LBE67:
 1187              	.LBE66:
 1188              	.LBE68:
 1189              	.LBE69:
 1190              		.cfi_endproc
 1191              	.LFE9:
 1193              		.align	2
 1194              		.global	I2CCmdHandler
 1196              	I2CCmdHandler:
 1197              	.LFB0:
 329:../uvc.c      **** 	uint8_t buf[2];
 1198              		.loc 1 329 0
 1199              		.cfi_startproc
 1200              		@ args = 0, pretend = 0, frame = 8
 1201              		@ frame_needed = 0, uses_anonymous_args = 0
 1202 08a4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1203              	.LCFI8:
 1204              		.cfi_def_cfa_offset 36
 1205              		.cfi_offset 4, -36
 1206              		.cfi_offset 5, -32
 1207              		.cfi_offset 6, -28
 1208              		.cfi_offset 7, -24
 1209              		.cfi_offset 8, -20
 1210              		.cfi_offset 9, -16
 1211              		.cfi_offset 10, -12
 1212              		.cfi_offset 11, -8
 1213              		.cfi_offset 14, -4
 332:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1214              		.loc 1 332 0
 1215 08a8 14419FE5 		ldr	r4, .L98
 329:../uvc.c      **** 	uint8_t buf[2];
 1216              		.loc 1 329 0
 1217 08ac 34D04DE2 		sub	sp, sp, #52
 1218              	.LCFI9:
 1219              		.cfi_def_cfa_offset 88
 332:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1220              		.loc 1 332 0
 1221 08b0 9050D4E5 		ldrb	r5, [r4, #144]	@ zero_extendqisi2
 1222              	.LVL147:
 337:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1223              		.loc 1 337 0
 1224 08b4 9A10D4E5 		ldrb	r1, [r4, #154]	@ zero_extendqisi2
 334:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1225              		.loc 1 334 0
 1226 08b8 9860D4E5 		ldrb	r6, [r4, #152]	@ zero_extendqisi2
 1227              	.LVL148:
 337:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1228              		.loc 1 337 0
 1229 08bc 92B0D4E5 		ldrb	fp, [r4, #146]	@ zero_extendqisi2
 1230 08c0 93A0D4E5 		ldrb	r10, [r4, #147]	@ zero_extendqisi2
 1231 08c4 9490D4E5 		ldrb	r9, [r4, #148]	@ zero_extendqisi2
 1232 08c8 9580D4E5 		ldrb	r8, [r4, #149]	@ zero_extendqisi2
 1233 08cc 9670D4E5 		ldrb	r7, [r4, #150]	@ zero_extendqisi2
 1234 08d0 97E0D4E5 		ldrb	lr, [r4, #151]	@ zero_extendqisi2
 1235 08d4 99C0D4E5 		ldrb	ip, [r4, #153]	@ zero_extendqisi2
 1236 08d8 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
 1237 08dc 0400A0E3 		mov	r0, #4
 1238 08e0 20108DE5 		str	r1, [sp, #32]
 1239 08e4 0520A0E1 		mov	r2, r5
 1240 08e8 18608DE5 		str	r6, [sp, #24]
 1241 08ec 00B08DE5 		str	fp, [sp]
 1242 08f0 04A08DE5 		str	r10, [sp, #4]
 1243 08f4 08908DE5 		str	r9, [sp, #8]
 1244 08f8 0C808DE5 		str	r8, [sp, #12]
 1245 08fc 10708DE5 		str	r7, [sp, #16]
 1246 0900 14E08DE5 		str	lr, [sp, #20]
 1247 0904 1CC08DE5 		str	ip, [sp, #28]
 1248 0908 B8109FE5 		ldr	r1, .L98+4
 1249 090c FEFFFFEB 		bl	CyU3PDebugPrint
 1250              	.LVL149:
 341:../uvc.c      **** 	{
 1251              		.loc 1 341 0
 1252 0910 000055E3 		cmp	r5, #0
 1253 0914 0300000A 		beq	.L96
 366:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1254              		.loc 1 366 0
 1255 0918 010055E3 		cmp	r5, #1
 1256 091c 1700000A 		beq	.L97
 381:../uvc.c      **** 
 1257              		.loc 1 381 0
 1258 0920 34D08DE2 		add	sp, sp, #52
 1259              		@ sp needed
 1260 0924 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1261              	.LVL150:
 1262              	.L96:
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1263              		.loc 1 357 0
 1264 0928 9200D4E5 		ldrb	r0, [r4, #146]	@ zero_extendqisi2
 1265 092c 9310D4E5 		ldrb	r1, [r4, #147]	@ zero_extendqisi2
 1266 0930 98E0D4E5 		ldrb	lr, [r4, #152]	@ zero_extendqisi2
 1267 0934 28C08DE2 		add	ip, sp, #40
 1268 0938 9530D4E5 		ldrb	r3, [r4, #149]	@ zero_extendqisi2
 1269 093c 9420D4E5 		ldrb	r2, [r4, #148]	@ zero_extendqisi2
 1270 0940 04C08DE5 		str	ip, [sp, #4]
 343:../uvc.c      **** #if 0 //for debugging
 1271              		.loc 1 343 0
 1272 0944 0FC0A0E3 		mov	ip, #15
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1273              		.loc 1 357 0
 1274 0948 00E08DE5 		str	lr, [sp]
 1275 094c 011081E3 		orr	r1, r1, #1
 343:../uvc.c      **** #if 0 //for debugging
 1276              		.loc 1 343 0
 1277 0950 9BC0C4E5 		strb	ip, [r4, #155]
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1278              		.loc 1 357 0
 1279 0954 010080E3 		orr	r0, r0, #1
 1280 0958 FEFFFFEB 		bl	SensorRead2B
 1281              	.LVL151:
 358:../uvc.c      **** 			if(CmdDataLen == 2){
 1282              		.loc 1 358 0
 1283 095c 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
 359:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1284              		.loc 1 359 0
 1285 0960 020056E3 		cmp	r6, #2
 358:../uvc.c      **** 			if(CmdDataLen == 2){
 1286              		.loc 1 358 0
 1287 0964 9930C4E5 		strb	r3, [r4, #153]
 360:../uvc.c      **** 			}
 1288              		.loc 1 360 0
 1289 0968 2930DD05 		ldreqb	r3, [sp, #41]	@ zero_extendqisi2
 1290 096c 9A30C405 		streqb	r3, [r4, #154]
 362:../uvc.c      **** 		}else{//not support currently
 1291              		.loc 1 362 0
 1292 0970 0030E0E3 		mvn	r3, #0
 1293 0974 9B30C4E5 		strb	r3, [r4, #155]
 381:../uvc.c      **** 
 1294              		.loc 1 381 0
 1295 0978 34D08DE2 		add	sp, sp, #52
 1296              		@ sp needed
 1297 097c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1298              	.LVL152:
 1299              	.L97:
 375:../uvc.c      **** 		}else{//not support currently
 1300              		.loc 1 375 0
 1301 0980 9200D4E5 		ldrb	r0, [r4, #146]	@ zero_extendqisi2
 1302 0984 9310D4E5 		ldrb	r1, [r4, #147]	@ zero_extendqisi2
 1303 0988 9850D4E5 		ldrb	r5, [r4, #152]	@ zero_extendqisi2
 1304              	.LVL153:
 368:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1305              		.loc 1 368 0
 1306 098c 99E0D4E5 		ldrb	lr, [r4, #153]	@ zero_extendqisi2
 369:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1307              		.loc 1 369 0
 1308 0990 9AC0D4E5 		ldrb	ip, [r4, #154]	@ zero_extendqisi2
 375:../uvc.c      **** 		}else{//not support currently
 1309              		.loc 1 375 0
 1310 0994 9420D4E5 		ldrb	r2, [r4, #148]	@ zero_extendqisi2
 1311 0998 9530D4E5 		ldrb	r3, [r4, #149]	@ zero_extendqisi2
 1312 099c 28408DE2 		add	r4, sp, #40
 1313 09a0 FE1001E2 		and	r1, r1, #254
 1314 09a4 00508DE5 		str	r5, [sp]
 1315 09a8 04408DE5 		str	r4, [sp, #4]
 1316 09ac FE0000E2 		and	r0, r0, #254
 368:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1317              		.loc 1 368 0
 1318 09b0 28E0CDE5 		strb	lr, [sp, #40]
 369:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1319              		.loc 1 369 0
 1320 09b4 29C0CDE5 		strb	ip, [sp, #41]
 375:../uvc.c      **** 		}else{//not support currently
 1321              		.loc 1 375 0
 1322 09b8 FEFFFFEB 		bl	SensorWrite2B
 1323              	.LVL154:
 381:../uvc.c      **** 
 1324              		.loc 1 381 0
 1325 09bc 34D08DE2 		add	sp, sp, #52
 1326              		@ sp needed
 1327 09c0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1328              	.LVL155:
 1329              	.L99:
 1330              		.align	2
 1331              	.L98:
 1332 09c4 00000000 		.word	.LANCHOR0
 1333 09c8 8C010000 		.word	.LC10
 1334              		.cfi_endproc
 1335              	.LFE0:
 1337              		.align	2
 1338              		.global	setIrisauto
 1340              	setIrisauto:
 1341              	.LFB1:
 387:../uvc.c      **** 	uint8_t dataIdx;
 1342              		.loc 1 387 0
 1343              		.cfi_startproc
 1344              		@ args = 0, pretend = 0, frame = 0
 1345              		@ frame_needed = 0, uses_anonymous_args = 0
 1346              	.LVL156:
 1347 09cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1348              	.LCFI10:
 1349              		.cfi_def_cfa_offset 16
 1350              		.cfi_offset 4, -16
 1351              		.cfi_offset 5, -12
 1352              		.cfi_offset 6, -8
 1353              		.cfi_offset 14, -4
 1354 09d0 0150A0E1 		mov	r5, r1
 1355 09d4 08D04DE2 		sub	sp, sp, #8
 1356              	.LCFI11:
 1357              		.cfi_def_cfa_offset 24
 387:../uvc.c      **** 	uint8_t dataIdx;
 1358              		.loc 1 387 0
 1359 09d8 0040A0E1 		mov	r4, r0
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1360              		.loc 1 391 0
 1361 09dc 0060A0E3 		mov	r6, #0
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1362              		.loc 1 390 0
 1363 09e0 0010E0E3 		mvn	r1, #0
 1364              	.LVL157:
 1365 09e4 1C0090E5 		ldr	r0, [r0, #28]
 1366              	.LVL158:
 1367 09e8 FEFFFFEB 		bl	_txe_mutex_get
 1368              	.LVL159:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1369              		.loc 1 391 0
 1370 09ec 062055E0 		subs	r2, r5, r6
 1371 09f0 003072E2 		rsbs	r3, r2, #0
 1372 09f4 0230B3E0 		adcs	r3, r3, r2
 1373 09f8 00308DE5 		str	r3, [sp]
 1374 09fc 0400A0E1 		mov	r0, r4
 1375 0a00 04608DE5 		str	r6, [sp, #4]
 1376 0a04 2010A0E3 		mov	r1, #32
 1377 0a08 2720A0E3 		mov	r2, #39
 1378 0a0c 3030A0E3 		mov	r3, #48
 1379 0a10 FEFFFFEB 		bl	cmdSet
 1380              	.LVL160:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1381              		.loc 1 392 0
 1382 0a14 060055E1 		cmp	r5, r6
 1383 0a18 0250A003 		moveq	r5, #2
 1384 0a1c 0150A013 		movne	r5, #1
 1385 0a20 60008DE8 		stmia	sp, {r5, r6}
 1386 0a24 0400A0E1 		mov	r0, r4
 1387 0a28 2110A0E3 		mov	r1, #33
 1388 0a2c 2520A0E3 		mov	r2, #37
 1389 0a30 3030A0E3 		mov	r3, #48
 1390 0a34 FEFFFFEB 		bl	cmdSet
 1391              	.LVL161:
 393:../uvc.c      **** }
 1392              		.loc 1 393 0
 1393 0a38 1C0094E5 		ldr	r0, [r4, #28]
 394:../uvc.c      **** 
 1394              		.loc 1 394 0
 1395 0a3c 08D08DE2 		add	sp, sp, #8
 1396              		@ sp needed
 1397 0a40 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1398              	.LVL162:
 393:../uvc.c      **** }
 1399              		.loc 1 393 0
 1400 0a44 FEFFFFEA 		b	_txe_mutex_put
 1401              	.LVL163:
 1402              		.cfi_endproc
 1403              	.LFE1:
 1405              		.align	2
 1406              		.global	ControlHandle
 1408              	ControlHandle:
 1409              	.LFB2:
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1410              		.loc 1 396 0
 1411              		.cfi_startproc
 1412              		@ args = 0, pretend = 0, frame = 24
 1413              		@ frame_needed = 0, uses_anonymous_args = 0
 1414              	.LVL164:
 1415 0a48 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1416              	.LCFI12:
 1417              		.cfi_def_cfa_offset 36
 1418              		.cfi_offset 4, -36
 1419              		.cfi_offset 5, -32
 1420              		.cfi_offset 6, -28
 1421              		.cfi_offset 7, -24
 1422              		.cfi_offset 8, -20
 1423              		.cfi_offset 9, -16
 1424              		.cfi_offset 10, -12
 1425              		.cfi_offset 11, -8
 1426              		.cfi_offset 14, -4
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1427              		.loc 1 404 0
 1428 0a4c 9C6E9FE5 		ldr	r6, .L195
 402:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1429              		.loc 1 402 0
 1430 0a50 208040E2 		sub	r8, r0, #32
 403:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1431              		.loc 1 403 0
 1432 0a54 230050E3 		cmp	r0, #35
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1433              		.loc 1 396 0
 1434 0a58 2CD04DE2 		sub	sp, sp, #44
 1435              	.LCFI13:
 1436              		.cfi_def_cfa_offset 80
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1437              		.loc 1 396 0
 1438 0a5c 0040A0E1 		mov	r4, r0
 402:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1439              		.loc 1 402 0
 1440 0a60 FF8008E2 		and	r8, r8, #255
 1441              	.LVL165:
 403:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1442              		.loc 1 403 0
 1443 0a64 2A00009A 		bls	.L104
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1444              		.loc 1 404 0
 1445 0a68 882088E0 		add	r2, r8, r8, asl #1
 1446 0a6c 8221A0E1 		mov	r2, r2, asl #3
 1447 0a70 023086E0 		add	r3, r6, r2
 405:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1448              		.loc 1 405 0
 1449 0a74 01C0D3E5 		ldrb	ip, [r3, #1]	@ zero_extendqisi2
 406:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1450              		.loc 1 406 0
 1451 0a78 0FA0D3E5 		ldrb	r10, [r3, #15]	@ zero_extendqisi2
 407:../uvc.c      ****     }else{
 1452              		.loc 1 407 0
 1453 0a7c 0290D3E5 		ldrb	r9, [r3, #2]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 1454              		.loc 1 418 0
 1455 0a80 6C3E9FE5 		ldr	r3, .L195+4
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1456              		.loc 1 404 0
 1457 0a84 02B0D6E7 		ldrb	fp, [r6, r2]	@ zero_extendqisi2
 1458              	.LVL166:
 418:../uvc.c      ****     /*
 1459              		.loc 1 418 0
 1460 0a88 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 1461              	.LVL167:
 426:../uvc.c      **** 		 {
 1462              		.loc 1 426 0
 1463 0a8c 830055E3 		cmp	r5, #131
 1464 0a90 2900000A 		beq	.L107
 1465              	.LVL168:
 1466              	.L193:
 1467 0a94 3200009A 		bls	.L192
 1468 0a98 850055E3 		cmp	r5, #133
 1469 0a9c B800000A 		beq	.L112
 1470 0aa0 C300003A 		bcc	.L113
 1471 0aa4 860055E3 		cmp	r5, #134
 1472 0aa8 7500000A 		beq	.L114
 1473 0aac 870055E3 		cmp	r5, #135
 1474 0ab0 AA00001A 		bne	.L106
 646:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1475              		.loc 1 646 0
 1476 0ab4 230054E3 		cmp	r4, #35
 1477 0ab8 CD00009A 		bls	.L148
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1478              		.loc 1 647 0
 1479 0abc 888088E0 		add	r8, r8, r8, asl #1
 1480              	.LVL169:
 1481 0ac0 886186E0 		add	r6, r6, r8, asl #3
 1482 0ac4 2C7E9FE5 		ldr	r7, .L195+8
 1483 0ac8 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 648:../uvc.c      **** 		 	 }
 1484              		.loc 1 648 0
 1485 0acc 0C30D6E5 		ldrb	r3, [r6, #12]	@ zero_extendqisi2
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1486              		.loc 1 647 0
 1487 0ad0 9C20C7E5 		strb	r2, [r7, #156]
 648:../uvc.c      **** 		 	 }
 1488              		.loc 1 648 0
 1489 0ad4 9D30C7E5 		strb	r3, [r7, #157]
 1490              	.L149:
 660:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1491              		.loc 1 660 0
 1492 0ad8 0900A0E1 		mov	r0, r9
 1493              	.LVL170:
 1494 0adc 181E9FE5 		ldr	r1, .L195+12
 1495 0ae0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1496              	.LVL171:
 1497 0ae4 9C60D7E5 		ldrb	r6, [r7, #156]	@ zero_extendqisi2
 662:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 1498              		.loc 1 662 0
 1499 0ae8 FF80A0E3 		mov	r8, #255
 1500 0aec 0830A0E1 		mov	r3, r8
 1501 0af0 0840A0E1 		mov	r4, r8
 1502              	.LVL172:
 1503              	.L116:
 960:../uvc.c      **** }
 1504              		.loc 1 960 0
 1505 0af4 48018DE8 		stmia	sp, {r3, r6, r8}
 1506 0af8 001E9FE5 		ldr	r1, .L195+16
 1507 0afc 0520A0E1 		mov	r2, r5
 1508 0b00 0430A0E1 		mov	r3, r4
 1509 0b04 0400A0E3 		mov	r0, #4
 1510 0b08 FEFFFFEB 		bl	CyU3PDebugPrint
 1511              	.LVL173:
 961:../uvc.c      **** /************** CT control requests handler *************************/
 1512              		.loc 1 961 0
 1513 0b0c 2CD08DE2 		add	sp, sp, #44
 1514              		@ sp needed
 1515 0b10 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1516              	.LVL174:
 1517              	.L104:
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1518              		.loc 1 409 0
 1519 0b14 803080E0 		add	r3, r0, r0, asl #1
 1520 0b18 833186E0 		add	r3, r6, r3, asl #3
 1521 0b1c 80B1D3E5 		ldrb	fp, [r3, #384]	@ zero_extendqisi2
 1522              	.LVL175:
 410:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1523              		.loc 1 410 0
 1524 0b20 81C1D3E5 		ldrb	ip, [r3, #385]	@ zero_extendqisi2
 1525              	.LVL176:
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1526              		.loc 1 411 0
 1527 0b24 8FA1D3E5 		ldrb	r10, [r3, #399]	@ zero_extendqisi2
 1528              	.LVL177:
 412:../uvc.c      ****     }
 1529              		.loc 1 412 0
 1530 0b28 8291D3E5 		ldrb	r9, [r3, #386]	@ zero_extendqisi2
 1531              	.LVL178:
 418:../uvc.c      ****     /*
 1532              		.loc 1 418 0
 1533 0b2c C03D9FE5 		ldr	r3, .L195+4
 1534              	.LVL179:
 1535 0b30 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 1536              	.LVL180:
 426:../uvc.c      **** 		 {
 1537              		.loc 1 426 0
 1538 0b34 830055E3 		cmp	r5, #131
 1539 0b38 D5FFFF1A 		bne	.L193
 1540              	.LVL181:
 1541              	.L107:
 601:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1542              		.loc 1 601 0
 1543 0b3c 230054E3 		cmp	r4, #35
 1544 0b40 C100009A 		bls	.L141
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1545              		.loc 1 602 0
 1546 0b44 888088E0 		add	r8, r8, r8, asl #1
 1547              	.LVL182:
 1548 0b48 886186E0 		add	r6, r6, r8, asl #3
 1549 0b4c A47D9FE5 		ldr	r7, .L195+8
 1550 0b50 0520D6E5 		ldrb	r2, [r6, #5]	@ zero_extendqisi2
 603:../uvc.c      **** 		 	 }
 1551              		.loc 1 603 0
 1552 0b54 0630D6E5 		ldrb	r3, [r6, #6]	@ zero_extendqisi2
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1553              		.loc 1 602 0
 1554 0b58 9C20C7E5 		strb	r2, [r7, #156]
 603:../uvc.c      **** 		 	 }
 1555              		.loc 1 603 0
 1556 0b5c 9D30C7E5 		strb	r3, [r7, #157]
 1557 0b60 DCFFFFEA 		b	.L149
 1558              	.LVL183:
 1559              	.L192:
 426:../uvc.c      **** 		 {
 1560              		.loc 1 426 0
 1561 0b64 810055E3 		cmp	r5, #129
 1562 0b68 5600000A 		beq	.L109
 1563 0b6c 3A00008A 		bhi	.L110
 1564 0b70 010055E3 		cmp	r5, #1
 1565 0b74 7900001A 		bne	.L106
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 1566              		.loc 1 664 0
 1567 0b78 787D9FE5 		ldr	r7, .L195+8
 1568 0b7c 26208DE2 		add	r2, sp, #38
 1569 0b80 2000A0E3 		mov	r0, #32
 1570              	.LVL184:
 1571 0b84 9C1087E2 		add	r1, r7, #156
 1572 0b88 10C08DE5 		str	ip, [sp, #16]
 1573 0b8c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1574              	.LVL185:
 666:../uvc.c      **** 			   {
 1575              		.loc 1 666 0
 1576 0b90 10C09DE5 		ldr	ip, [sp, #16]
 1577 0b94 002050E2 		subs	r2, r0, #0
 1578 0b98 0C03001A 		bne	.L151
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1579              		.loc 1 668 0
 1580 0b9c 9C00D7E5 		ldrb	r0, [r7, #156]	@ zero_extendqisi2
 1581              	.LVL186:
 669:../uvc.c      **** 				  getData = glEp0Buffer[0];
 1582              		.loc 1 669 0
 1583 0ba0 9D20D7E5 		ldrb	r2, [r7, #157]	@ zero_extendqisi2
 1584              	.LVL187:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1585              		.loc 1 671 0
 1586 0ba4 9E30D7E5 		ldrb	r3, [r7, #158]	@ zero_extendqisi2
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1587              		.loc 1 668 0
 1588 0ba8 14008DE5 		str	r0, [sp, #20]
 1589              	.LVL188:
 669:../uvc.c      **** 				  getData = glEp0Buffer[0];
 1590              		.loc 1 669 0
 1591 0bac 1C208DE5 		str	r2, [sp, #28]
 1592              	.LVL189:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1593              		.loc 1 671 0
 1594 0bb0 18308DE5 		str	r3, [sp, #24]
 1595              	.LVL190:
 675:../uvc.c      **** 					 {
 1596              		.loc 1 675 0
 1597 0bb4 260054E3 		cmp	r4, #38
 1598 0bb8 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1599 0bbc E90200EA 		b	.L152
 1600              	.L154:
 1601 0bc0 CC130000 		.word	.L153
 1602 0bc4 68170000 		.word	.L152
 1603 0bc8 68170000 		.word	.L152
 1604 0bcc 68170000 		.word	.L152
 1605 0bd0 84130000 		.word	.L155
 1606 0bd4 3C120000 		.word	.L156
 1607 0bd8 B8110000 		.word	.L157
 1608 0bdc 68170000 		.word	.L152
 1609 0be0 68170000 		.word	.L152
 1610 0be4 68170000 		.word	.L152
 1611 0be8 68170000 		.word	.L152
 1612 0bec 2C110000 		.word	.L158
 1613 0bf0 68170000 		.word	.L152
 1614 0bf4 68170000 		.word	.L152
 1615 0bf8 68170000 		.word	.L152
 1616 0bfc 68170000 		.word	.L152
 1617 0c00 A4100000 		.word	.L159
 1618 0c04 68170000 		.word	.L152
 1619 0c08 68170000 		.word	.L152
 1620 0c0c 68170000 		.word	.L152
 1621 0c10 68170000 		.word	.L152
 1622 0c14 68170000 		.word	.L152
 1623 0c18 68170000 		.word	.L152
 1624 0c1c 68170000 		.word	.L152
 1625 0c20 68170000 		.word	.L152
 1626 0c24 A8150000 		.word	.L160
 1627 0c28 08150000 		.word	.L161
 1628 0c2c 68170000 		.word	.L152
 1629 0c30 F8140000 		.word	.L162
 1630 0c34 68170000 		.word	.L152
 1631 0c38 98140000 		.word	.L163
 1632 0c3c D0160000 		.word	.L164
 1633 0c40 68170000 		.word	.L152
 1634 0c44 68170000 		.word	.L152
 1635 0c48 68170000 		.word	.L152
 1636 0c4c 68170000 		.word	.L152
 1637 0c50 38160000 		.word	.L165
 1638 0c54 00170000 		.word	.L166
 1639 0c58 3C100000 		.word	.L167
 1640              	.LVL191:
 1641              	.L110:
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1642              		.loc 1 582 0
 1643 0c5c 230054E3 		cmp	r4, #35
 1644 0c60 6D00009A 		bls	.L138
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1645              		.loc 1 583 0
 1646 0c64 888088E0 		add	r8, r8, r8, asl #1
 1647              	.LVL192:
 1648 0c68 886186E0 		add	r6, r6, r8, asl #3
 1649 0c6c 847C9FE5 		ldr	r7, .L195+8
 1650 0c70 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 584:../uvc.c      **** 		 	 }
 1651              		.loc 1 584 0
 1652 0c74 0430D6E5 		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1653              		.loc 1 583 0
 1654 0c78 9C20C7E5 		strb	r2, [r7, #156]
 584:../uvc.c      **** 		 	 }
 1655              		.loc 1 584 0
 1656 0c7c 9D30C7E5 		strb	r3, [r7, #157]
 1657 0c80 94FFFFEA 		b	.L149
 1658              	.LVL193:
 1659              	.L114:
 635:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1660              		.loc 1 635 0
 1661 0c84 230054E3 		cmp	r4, #35
 636:../uvc.c      **** 		 	 }
 1662              		.loc 1 636 0
 1663 0c88 88808880 		addhi	r8, r8, r8, asl #1
 1664              	.LVL194:
 639:../uvc.c      **** 		 	 }
 1665              		.loc 1 639 0
 1666 0c8c 84408490 		addls	r4, r4, r4, asl #1
 636:../uvc.c      **** 		 	 }
 1667              		.loc 1 636 0
 1668 0c90 88618680 		addhi	r6, r6, r8, asl #3
 639:../uvc.c      **** 		 	 }
 1669              		.loc 1 639 0
 1670 0c94 84618690 		addls	r6, r6, r4, asl #3
 636:../uvc.c      **** 		 	 }
 1671              		.loc 1 636 0
 1672 0c98 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 639:../uvc.c      **** 		 	 }
 1673              		.loc 1 639 0
 1674 0c9c 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 1675 0ca0 506C9FE5 		ldr	r6, .L195+8
 644:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 1676              		.loc 1 644 0
 1677 0ca4 FF80A0E3 		mov	r8, #255
 1678 0ca8 0610A0E1 		mov	r1, r6
 1679 0cac 9C30E1E5 		strb	r3, [r1, #156]!
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1680              		.loc 1 641 0
 1681 0cb0 0100A0E3 		mov	r0, #1
 1682              	.LVL195:
 1683 0cb4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1684              	.LVL196:
 644:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 1685              		.loc 1 644 0
 1686 0cb8 0840A0E1 		mov	r4, r8
 1687 0cbc 9C60D6E5 		ldrb	r6, [r6, #156]	@ zero_extendqisi2
 1688 0cc0 0830A0E1 		mov	r3, r8
 1689 0cc4 8AFFFFEA 		b	.L116
 1690              	.LVL197:
 1691              	.L109:
 437:../uvc.c      **** 			 {
 1692              		.loc 1 437 0
 1693 0cc8 053044E2 		sub	r3, r4, #5
 1694 0ccc 210053E3 		cmp	r3, #33
 1695 0cd0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1696 0cd4 CA0000EA 		b	.L117
 1697              	.L119:
 1698 0cd8 840F0000 		.word	.L118
 1699 0cdc 04100000 		.word	.L117
 1700 0ce0 04100000 		.word	.L117
 1701 0ce4 04100000 		.word	.L117
 1702 0ce8 04100000 		.word	.L117
 1703 0cec 04100000 		.word	.L117
 1704 0cf0 A80F0000 		.word	.L120
 1705 0cf4 04100000 		.word	.L117
 1706 0cf8 04100000 		.word	.L117
 1707 0cfc 04100000 		.word	.L117
 1708 0d00 04100000 		.word	.L117
 1709 0d04 04100000 		.word	.L117
 1710 0d08 04100000 		.word	.L117
 1711 0d0c 04100000 		.word	.L117
 1712 0d10 04100000 		.word	.L117
 1713 0d14 04100000 		.word	.L117
 1714 0d18 04100000 		.word	.L117
 1715 0d1c 04100000 		.word	.L117
 1716 0d20 04100000 		.word	.L117
 1717 0d24 04100000 		.word	.L117
 1718 0d28 300F0000 		.word	.L121
 1719 0d2c 04100000 		.word	.L117
 1720 0d30 04100000 		.word	.L117
 1721 0d34 FC0E0000 		.word	.L122
 1722 0d38 04100000 		.word	.L117
 1723 0d3c 04100000 		.word	.L117
 1724 0d40 B40E0000 		.word	.L123
 1725 0d44 04100000 		.word	.L117
 1726 0d48 04100000 		.word	.L117
 1727 0d4c 04100000 		.word	.L117
 1728 0d50 04100000 		.word	.L117
 1729 0d54 7C0E0000 		.word	.L124
 1730 0d58 7C0E0000 		.word	.L124
 1731 0d5c 7C0E0000 		.word	.L124
 1732              	.L106:
 957:../uvc.c      **** 			  break;
 1733              		.loc 1 957 0
 1734 0d60 0000A0E3 		mov	r0, #0
 1735              	.LVL198:
 958:../uvc.c      **** 		 }
 1736              		.loc 1 958 0
 1737 0d64 FF80A0E3 		mov	r8, #255
 1738              	.LVL199:
 957:../uvc.c      **** 			  break;
 1739              		.loc 1 957 0
 1740 0d68 0020A0E1 		mov	r2, r0
 1741 0d6c 0110A0E3 		mov	r1, #1
 1742 0d70 FEFFFFEB 		bl	CyU3PUsbStall
 1743              	.LVL200:
 958:../uvc.c      **** 		 }
 1744              		.loc 1 958 0
 1745 0d74 0860A0E1 		mov	r6, r8
 1746 0d78 0830A0E1 		mov	r3, r8
 1747 0d7c 0840A0E1 		mov	r4, r8
 1748              	.LVL201:
 1749 0d80 5BFFFFEA 		b	.L116
 1750              	.LVL202:
 1751              	.L112:
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1752              		.loc 1 430 0
 1753 0d84 6C6B9FE5 		ldr	r6, .L195+8
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1754              		.loc 1 431 0
 1755 0d88 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1756              		.loc 1 432 0
 1757 0d8c 9C1086E2 		add	r1, r6, #156
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1758              		.loc 1 434 0
 1759 0d90 FF80A0E3 		mov	r8, #255
 1760              	.LVL203:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1761              		.loc 1 432 0
 1762 0d94 0200A0E3 		mov	r0, #2
 1763              	.LVL204:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1764              		.loc 1 431 0
 1765 0d98 9D30C6E5 		strb	r3, [r6, #157]
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1766              		.loc 1 430 0
 1767 0d9c 9C90C6E5 		strb	r9, [r6, #156]
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1768              		.loc 1 434 0
 1769 0da0 0840A0E1 		mov	r4, r8
 1770              	.LVL205:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1771              		.loc 1 432 0
 1772 0da4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1773              	.LVL206:
 1774 0da8 9C60D6E5 		ldrb	r6, [r6, #156]	@ zero_extendqisi2
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1775              		.loc 1 434 0
 1776 0dac 0830A0E1 		mov	r3, r8
 1777 0db0 4FFFFFEA 		b	.L116
 1778              	.LVL207:
 1779              	.L113:
 619:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1780              		.loc 1 619 0
 1781 0db4 230054E3 		cmp	r4, #35
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1782              		.loc 1 620 0
 1783 0db8 88808880 		addhi	r8, r8, r8, asl #1
 1784              	.LVL208:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1785              		.loc 1 626 0
 1786 0dbc 84408490 		addls	r4, r4, r4, asl #1
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1787              		.loc 1 620 0
 1788 0dc0 88618680 		addhi	r6, r6, r8, asl #3
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1789              		.loc 1 626 0
 1790 0dc4 84618690 		addls	r6, r6, r4, asl #3
 1791 0dc8 287B9FE5 		ldr	r7, .L195+8
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1792              		.loc 1 620 0
 1793 0dcc 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 1794              		.loc 1 621 0
 1795 0dd0 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1796              		.loc 1 626 0
 1797 0dd4 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1798              		.loc 1 627 0
 1799 0dd8 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1800              		.loc 1 628 0
 1801 0ddc 0030A0E3 		mov	r3, #0
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1802              		.loc 1 626 0
 1803 0de0 9C10C7E5 		strb	r1, [r7, #156]
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1804              		.loc 1 627 0
 1805 0de4 9D20C7E5 		strb	r2, [r7, #157]
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1806              		.loc 1 628 0
 1807 0de8 9E30C7E5 		strb	r3, [r7, #158]
 629:../uvc.c      **** 		 	 }
 1808              		.loc 1 629 0
 1809 0dec 9F30C7E5 		strb	r3, [r7, #159]
 1810 0df0 38FFFFEA 		b	.L149
 1811              	.LVL209:
 1812              	.L148:
 651:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1813              		.loc 1 651 0
 1814 0df4 0B0054E3 		cmp	r4, #11
 1815 0df8 7800000A 		beq	.L194
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1816              		.loc 1 657 0
 1817 0dfc 844084E0 		add	r4, r4, r4, asl #1
 1818 0e00 846186E0 		add	r6, r6, r4, asl #3
 1819 0e04 EC7A9FE5 		ldr	r7, .L195+8
 1820 0e08 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 1821              		.loc 1 658 0
 1822 0e0c 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1823              		.loc 1 657 0
 1824 0e10 9C20C7E5 		strb	r2, [r7, #156]
 658:../uvc.c      **** 			 }
 1825              		.loc 1 658 0
 1826 0e14 9D30C7E5 		strb	r3, [r7, #157]
 1827 0e18 2EFFFFEA 		b	.L149
 1828              	.L138:
 587:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1829              		.loc 1 587 0
 1830 0e1c 0B0054E3 		cmp	r4, #11
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1831              		.loc 1 594 0
 1832 0e20 84408410 		addne	r4, r4, r4, asl #1
 1833 0e24 84618610 		addne	r6, r6, r4, asl #3
 1834 0e28 C87A9F15 		ldrne	r7, .L195+8
 588:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1835              		.loc 1 588 0
 1836 0e2c C47A9F05 		ldreq	r7, .L195+8
 1837 0e30 CC3A9F05 		ldreq	r3, .L195+20
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1838              		.loc 1 594 0
 1839 0e34 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 1840              		.loc 1 595 0
 1841 0e38 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 588:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1842              		.loc 1 588 0
 1843 0e3c 9C308705 		streq	r3, [r7, #156]
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1844              		.loc 1 594 0
 1845 0e40 9C20C715 		strneb	r2, [r7, #156]
 595:../uvc.c      **** 			 }
 1846              		.loc 1 595 0
 1847 0e44 9D30C715 		strneb	r3, [r7, #157]
 1848 0e48 22FFFFEA 		b	.L149
 1849              	.L141:
 605:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1850              		.loc 1 605 0
 1851 0e4c 0B0054E3 		cmp	r4, #11
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1852              		.loc 1 612 0
 1853 0e50 84408410 		addne	r4, r4, r4, asl #1
 1854 0e54 84618610 		addne	r6, r6, r4, asl #3
 1855 0e58 987A9F15 		ldrne	r7, .L195+8
 606:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1856              		.loc 1 606 0
 1857 0e5c 947A9F05 		ldreq	r7, .L195+8
 1858 0e60 A03A9F05 		ldreq	r3, .L195+24
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1859              		.loc 1 612 0
 1860 0e64 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 1861              		.loc 1 613 0
 1862 0e68 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 606:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1863              		.loc 1 606 0
 1864 0e6c 9C308705 		streq	r3, [r7, #156]
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1865              		.loc 1 612 0
 1866 0e70 9C20C715 		strneb	r2, [r7, #156]
 613:../uvc.c      **** 			 }
 1867              		.loc 1 613 0
 1868 0e74 9D30C715 		strneb	r3, [r7, #157]
 1869 0e78 16FFFFEA 		b	.L149
 1870              	.L124:
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1871              		.loc 1 443 0
 1872 0e7c 888088E0 		add	r8, r8, r8, asl #1
 1873              	.LVL210:
 1874 0e80 886186E0 		add	r6, r6, r8, asl #3
 1875 0e84 0D20D6E5 		ldrb	r2, [r6, #13]	@ zero_extendqisi2
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 1876              		.loc 1 444 0
 1877 0e88 0E80D6E5 		ldrb	r8, [r6, #14]	@ zero_extendqisi2
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1878              		.loc 1 443 0
 1879 0e8c 643A9FE5 		ldr	r3, .L195+8
 1880 0e90 0260A0E1 		mov	r6, r2
 1881 0e94 9C20C3E5 		strb	r2, [r3, #156]
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 1882              		.loc 1 444 0
 1883 0e98 9D80C3E5 		strb	r8, [r3, #157]
 1884              	.LVL211:
 1885              	.L128:
 575:../uvc.c      **** 
 1886              		.loc 1 575 0
 1887 0e9c 0900A0E1 		mov	r0, r9
 1888 0ea0 541A9FE5 		ldr	r1, .L195+12
 1889 0ea4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1890              	.LVL212:
 580:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 1891              		.loc 1 580 0
 1892 0ea8 FF30A0E3 		mov	r3, #255
 1893 0eac 0340A0E1 		mov	r4, r3
 1894 0eb0 0FFFFFEA 		b	.L116
 1895              	.LVL213:
 1896              	.L123:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1897              		.loc 1 464 0 discriminator 1
 1898 0eb4 000059E3 		cmp	r9, #0
 1899 0eb8 0300000A 		beq	.L131
 1900 0ebc 380A9FE5 		ldr	r0, .L195+12
 1901              	.LVL214:
 1902 0ec0 0920A0E1 		mov	r2, r9
 1903 0ec4 0C1040E2 		sub	r1, r0, #12
 1904 0ec8 FEFFFFEB 		bl	memcpy
 1905              	.LVL215:
 1906              	.L131:
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1907              		.loc 1 467 0
 1908 0ecc 243A9FE5 		ldr	r3, .L195+8
 474:../uvc.c      **** 			 		 {
 1909              		.loc 1 474 0
 1910 0ed0 9B20D3E5 		ldrb	r2, [r3, #155]	@ zero_extendqisi2
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1911              		.loc 1 467 0
 1912 0ed4 A560D3E5 		ldrb	r6, [r3, #165]	@ zero_extendqisi2
 1913              	.LVL216:
 474:../uvc.c      **** 			 		 {
 1914              		.loc 1 474 0
 1915 0ed8 FF0052E3 		cmp	r2, #255
 468:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1916              		.loc 1 468 0
 1917 0edc A680D3E5 		ldrb	r8, [r3, #166]	@ zero_extendqisi2
 1918              	.LVL217:
 474:../uvc.c      **** 			 		 {
 1919              		.loc 1 474 0
 1920 0ee0 EDFFFF0A 		beq	.L128
 476:../uvc.c      **** 			 		 }
 1921              		.loc 1 476 0
 1922 0ee4 9920D3E5 		ldrb	r2, [r3, #153]	@ zero_extendqisi2
 1923 0ee8 1C1A9FE5 		ldr	r1, .L195+28
 1924 0eec 9A30D3E5 		ldrb	r3, [r3, #154]	@ zero_extendqisi2
 1925 0ef0 0400A0E3 		mov	r0, #4
 1926 0ef4 FEFFFFEB 		bl	CyU3PDebugPrint
 1927              	.LVL218:
 1928 0ef8 E7FFFFEA 		b	.L128
 1929              	.LVL219:
 1930              	.L122:
 450:../uvc.c      **** 					 if(CamMode == 1){//720p or invendo
 1931              		.loc 1 450 0
 1932 0efc 2D34D6E5 		ldrb	r3, [r6, #1069]	@ zero_extendqisi2
 1933              	.LVL220:
 1934 0f00 E8499FE5 		ldr	r4, .L195
 452:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 1935              		.loc 1 452 0
 1936 0f04 020053E3 		cmp	r3, #2
 1937 0f08 6F02008A 		bhi	.L129
 1938 0f0c 043083E2 		add	r3, r3, #4
 1939 0f10 FF3003E2 		and	r3, r3, #255
 1940 0f14 0360A0E1 		mov	r6, r3
 1941              	.LVL221:
 1942              	.L130:
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1943              		.loc 1 460 0
 1944 0f18 D8299FE5 		ldr	r2, .L195+8
 461:../uvc.c      **** 					 break;
 1945              		.loc 1 461 0
 1946 0f1c 0010A0E3 		mov	r1, #0
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1947              		.loc 1 460 0
 1948 0f20 9C30C2E5 		strb	r3, [r2, #156]
 461:../uvc.c      **** 					 break;
 1949              		.loc 1 461 0
 1950 0f24 9D10C2E5 		strb	r1, [r2, #157]
 462:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 1951              		.loc 1 462 0
 1952 0f28 FF80A0E3 		mov	r8, #255
 1953              	.LVL222:
 1954 0f2c DAFFFFEA 		b	.L128
 1955              	.LVL223:
 1956              	.L121:
 481:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1957              		.loc 1 481 0
 1958 0f30 C0799FE5 		ldr	r7, .L195+8
 1959 0f34 4530D7E5 		ldrb	r3, [r7, #69]	@ zero_extendqisi2
 1960 0f38 000053E3 		cmp	r3, #0
 1961 0f3c 4502000A 		beq	.L132
 1962 0f40 E6E3D6E5 		ldrb	lr, [r6, #998]	@ zero_extendqisi2
 1963              	.LVL224:
 1964              	.L133:
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1965              		.loc 1 495 0
 1966 0f44 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 496:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1967              		.loc 1 496 0
 1968 0f48 00C0A0E3 		mov	ip, #0
 501:../uvc.c      **** 					 break;
 1969              		.loc 1 501 0
 1970 0f4c 00E08DE5 		str	lr, [sp]
 1971 0f50 04C08DE5 		str	ip, [sp, #4]
 1972 0f54 0420A0E1 		mov	r2, r4
 1973 0f58 0C30A0E1 		mov	r3, ip
 1974 0f5c AC199FE5 		ldr	r1, .L195+32
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1975              		.loc 1 495 0
 1976 0f60 9C40C7E5 		strb	r4, [r7, #156]
 497:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1977              		.loc 1 497 0
 1978 0f64 9EE0C7E5 		strb	lr, [r7, #158]
 496:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1979              		.loc 1 496 0
 1980 0f68 9DC0C7E5 		strb	ip, [r7, #157]
 498:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 1981              		.loc 1 498 0
 1982 0f6c 9FC0C7E5 		strb	ip, [r7, #159]
 1983              	.LVL225:
 501:../uvc.c      **** 					 break;
 1984              		.loc 1 501 0
 1985 0f70 0400A0E3 		mov	r0, #4
 1986 0f74 0E80A0E1 		mov	r8, lr
 1987              	.LVL226:
 1988 0f78 0460A0E1 		mov	r6, r4
 1989 0f7c FEFFFFEB 		bl	CyU3PDebugPrint
 1990              	.LVL227:
 502:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 1991              		.loc 1 502 0
 1992 0f80 C5FFFFEA 		b	.L128
 1993              	.LVL228:
 1994              	.L118:
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1995              		.loc 1 532 0
 1996 0f84 0562D6E5 		ldrb	r6, [r6, #517]	@ zero_extendqisi2
 1997 0f88 68399FE5 		ldr	r3, .L195+8
 1998 0f8c 806046E2 		sub	r6, r6, #128
 1999 0f90 FF6006E2 		and	r6, r6, #255
 533:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2000              		.loc 1 533 0
 2001 0f94 0020A0E3 		mov	r2, #0
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2002              		.loc 1 532 0
 2003 0f98 9C60C3E5 		strb	r6, [r3, #156]
 533:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2004              		.loc 1 533 0
 2005 0f9c 9D20C3E5 		strb	r2, [r3, #157]
 2006              	.LVL229:
 535:../uvc.c      **** 				 case WBTLevCtlID11:
 2007              		.loc 1 535 0
 2008 0fa0 FF80A0E3 		mov	r8, #255
 2009              	.LVL230:
 2010 0fa4 BCFFFFEA 		b	.L128
 2011              	.LVL231:
 2012              	.L120:
 538:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2013              		.loc 1 538 0
 2014 0fa8 48799FE5 		ldr	r7, .L195+8
 2015 0fac 3730D7E5 		ldrb	r3, [r7, #55]	@ zero_extendqisi2
 2016 0fb0 000053E3 		cmp	r3, #0
 2017 0fb4 1702000A 		beq	.L134
 539:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2018              		.loc 1 539 0
 2019 0fb8 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 540:../uvc.c      **** 		 	 		 }else{
 2020              		.loc 1 540 0
 2021 0fbc 8E84D6E5 		ldrb	r8, [r6, #1166]	@ zero_extendqisi2
 2022              	.LVL232:
 2023 0fc0 0320A0E1 		mov	r2, r3
 539:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2024              		.loc 1 539 0
 2025 0fc4 9C30C7E5 		strb	r3, [r7, #156]
 540:../uvc.c      **** 		 	 		 }else{
 2026              		.loc 1 540 0
 2027 0fc8 9E80C7E5 		strb	r8, [r7, #158]
 2028              	.LVL233:
 2029              	.L135:
 551:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2030              		.loc 1 551 0
 2031 0fcc 0030A0E3 		mov	r3, #0
 2032 0fd0 0260A0E1 		mov	r6, r2
 2033 0fd4 9D30C7E5 		strb	r3, [r7, #157]
 552:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2034              		.loc 1 552 0
 2035 0fd8 9F30C7E5 		strb	r3, [r7, #159]
 2036              	.LVL234:
 555:../uvc.c      **** 				 case SaturCtlID6://TODO check sensor register
 2037              		.loc 1 555 0
 2038 0fdc AEFFFFEA 		b	.L128
 2039              	.LVL235:
 2040              	.L194:
 652:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2041              		.loc 1 652 0
 2042 0fe0 10799FE5 		ldr	r7, .L195+8
 2043 0fe4 9312D6E5 		ldrb	r1, [r6, #659]	@ zero_extendqisi2
 654:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2044              		.loc 1 654 0
 2045 0fe8 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 653:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2046              		.loc 1 653 0
 2047 0fec 0030A0E3 		mov	r3, #0
 652:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2048              		.loc 1 652 0
 2049 0ff0 9C10C7E5 		strb	r1, [r7, #156]
 654:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2050              		.loc 1 654 0
 2051 0ff4 9E20C7E5 		strb	r2, [r7, #158]
 653:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2052              		.loc 1 653 0
 2053 0ff8 9D30C7E5 		strb	r3, [r7, #157]
 655:../uvc.c      **** 			 }else{
 2054              		.loc 1 655 0
 2055 0ffc 9F30C7E5 		strb	r3, [r7, #159]
 2056 1000 B4FEFFEA 		b	.L149
 2057              	.L117:
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2058              		.loc 1 559 0
 2059 1004 EC789FE5 		ldr	r7, .L195+8
 2060 1008 048087E0 		add	r8, r7, r4
 2061              	.LVL236:
 2062 100c 2C30D8E5 		ldrb	r3, [r8, #44]	@ zero_extendqisi2
 2063 1010 000053E3 		cmp	r3, #0
 2064 1014 F501000A 		beq	.L136
 2065 1018 844084E0 		add	r4, r4, r4, asl #1
 2066 101c 846186E0 		add	r6, r6, r4, asl #3
 2067 1020 8D31D6E5 		ldrb	r3, [r6, #397]	@ zero_extendqisi2
 2068              	.LVL237:
 2069              	.L137:
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2070              		.loc 1 570 0
 2071 1024 0020A0E3 		mov	r2, #0
 2072 1028 0360A0E1 		mov	r6, r3
 572:../uvc.c      **** 			 }
 2073              		.loc 1 572 0
 2074 102c FF80A0E3 		mov	r8, #255
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2075              		.loc 1 569 0
 2076 1030 9C30C7E5 		strb	r3, [r7, #156]
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2077              		.loc 1 570 0
 2078 1034 9D20C7E5 		strb	r2, [r7, #157]
 2079              	.LVL238:
 572:../uvc.c      **** 			 }
 2080              		.loc 1 572 0
 2081 1038 97FFFFEA 		b	.L128
 2082              	.LVL239:
 2083              	.L167:
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2084              		.loc 1 819 0
 2085 103c D0489FE5 		ldr	r4, .L195+36
 2086 1040 0010E0E3 		mvn	r1, #0
 2087 1044 1C0094E5 		ldr	r0, [r4, #28]
 2088 1048 FEFFFFEB 		bl	_txe_mutex_get
 2089              	.LVL240:
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2090              		.loc 1 820 0
 2091 104c 14209DE5 		ldr	r2, [sp, #20]
 2092 1050 0010A0E3 		mov	r1, #0
 2093 1054 0A30A0E1 		mov	r3, r10
 2094 1058 00208DE5 		str	r2, [sp]
 2095 105c 0400A0E1 		mov	r0, r4
 2096 1060 0B20A0E1 		mov	r2, fp
 2097 1064 04108DE5 		str	r1, [sp, #4]
 2098 1068 2610A0E3 		mov	r1, #38
 2099 106c FEFFFFEB 		bl	cmdSet
 2100              	.LVL241:
 821:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2101              		.loc 1 821 0
 2102 1070 1C0094E5 		ldr	r0, [r4, #28]
 2103 1074 FEFFFFEB 		bl	_txe_mutex_put
 2104              	.LVL242:
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2105              		.loc 1 822 0
 2106 1078 14309DE5 		ldr	r3, [sp, #20]
 2107 107c 888088E0 		add	r8, r8, r8, asl #1
 2108              	.LVL243:
 2109 1080 886186E0 		add	r6, r6, r8, asl #3
 823:../uvc.c      **** 							 break;
 2110              		.loc 1 823 0
 2111 1084 0120A0E3 		mov	r2, #1
 824:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2112              		.loc 1 824 0
 2113 1088 FF80A0E3 		mov	r8, #255
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2114              		.loc 1 822 0
 2115 108c 0D30C6E5 		strb	r3, [r6, #13]
 2116 1090 0340A0E1 		mov	r4, r3
 823:../uvc.c      **** 							 break;
 2117              		.loc 1 823 0
 2118 1094 1020C6E5 		strb	r2, [r6, #16]
 2119 1098 18309DE5 		ldr	r3, [sp, #24]
 824:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2120              		.loc 1 824 0
 2121 109c 0860A0E1 		mov	r6, r8
 2122 10a0 93FEFFEA 		b	.L116
 2123              	.LVL244:
 2124              	.L159:
 678:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2125              		.loc 1 678 0
 2126 10a4 44389FE5 		ldr	r3, .L195
 679:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2127              		.loc 1 679 0
 2128 10a8 000050E3 		cmp	r0, #0
 678:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2129              		.loc 1 678 0
 2130 10ac 0D03C6E5 		strb	r0, [r6, #781]
 680:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2131              		.loc 1 680 0
 2132 10b0 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 679:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2133              		.loc 1 679 0
 2134 10b4 EF01001A 		bne	.L169
 680:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2135              		.loc 1 680 0
 2136 10b8 020052E3 		cmp	r2, #2
 2137 10bc 08005213 		cmpne	r2, #8
 2138 10c0 0300000A 		beq	.L170
 681:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2139              		.loc 1 681 0
 2140 10c4 010052E3 		cmp	r2, #1
 682:../uvc.c      **** 									 }else{
 2141              		.loc 1 682 0
 2142 10c8 0820A003 		moveq	r2, #8
 684:../uvc.c      **** 									 }
 2143              		.loc 1 684 0
 2144 10cc 0220A013 		movne	r2, #2
 2145 10d0 B524C3E5 		strb	r2, [r3, #1205]
 2146              	.LVL245:
 2147              	.L170:
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2148              		.loc 1 706 0
 2149 10d4 38489FE5 		ldr	r4, .L195+36
 704:../uvc.c      **** 							 dataIdx = 0;
 2150              		.loc 1 704 0
 2151 10d8 0130A0E3 		mov	r3, #1
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2152              		.loc 1 706 0
 2153 10dc 1C0094E5 		ldr	r0, [r4, #28]
 2154 10e0 0010E0E3 		mvn	r1, #0
 704:../uvc.c      **** 							 dataIdx = 0;
 2155              		.loc 1 704 0
 2156 10e4 1033C6E5 		strb	r3, [r6, #784]
 2157              	.LVL246:
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2158              		.loc 1 706 0
 2159 10e8 FEFFFFEB 		bl	_txe_mutex_get
 2160              	.LVL247:
 707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2161              		.loc 1 707 0
 2162 10ec 14209DE5 		ldr	r2, [sp, #20]
 2163 10f0 0010A0E3 		mov	r1, #0
 2164 10f4 0A30A0E1 		mov	r3, r10
 2165 10f8 00208DE5 		str	r2, [sp]
 2166 10fc 0400A0E1 		mov	r0, r4
 2167 1100 0B20A0E1 		mov	r2, fp
 2168 1104 04108DE5 		str	r1, [sp, #4]
 2169 1108 1010A0E3 		mov	r1, #16
 2170 110c FEFFFFEB 		bl	cmdSet
 2171              	.LVL248:
 710:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 2172              		.loc 1 710 0
 2173 1110 FF80A0E3 		mov	r8, #255
 2174              	.LVL249:
 708:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 2175              		.loc 1 708 0
 2176 1114 1C0094E5 		ldr	r0, [r4, #28]
 2177 1118 FEFFFFEB 		bl	_txe_mutex_put
 2178              	.LVL250:
 710:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 2179              		.loc 1 710 0
 2180 111c 0860A0E1 		mov	r6, r8
 2181 1120 14409DE5 		ldr	r4, [sp, #20]
 2182 1124 18309DE5 		ldr	r3, [sp, #24]
 2183 1128 71FEFFEA 		b	.L116
 2184              	.LVL251:
 2185              	.L158:
 887:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2186              		.loc 1 887 0
 2187 112c E0479FE5 		ldr	r4, .L195+36
 2188 1130 0010E0E3 		mvn	r1, #0
 2189 1134 1C0094E5 		ldr	r0, [r4, #28]
 2190 1138 10C08DE5 		str	ip, [sp, #16]
 2191 113c FEFFFFEB 		bl	_txe_mutex_get
 2192              	.LVL252:
 888:../uvc.c      **** 							 dataIdx++;
 2193              		.loc 1 888 0
 2194 1140 10C09DE5 		ldr	ip, [sp, #16]
 2195 1144 14009DE5 		ldr	r0, [sp, #20]
 2196 1148 0030A0E3 		mov	r3, #0
 2197 114c 0C20A0E1 		mov	r2, ip
 2198 1150 00008DE5 		str	r0, [sp]
 2199 1154 04308DE5 		str	r3, [sp, #4]
 2200 1158 0400A0E1 		mov	r0, r4
 2201 115c 0B10A0E3 		mov	r1, #11
 2202 1160 0A30A0E1 		mov	r3, r10
 2203 1164 FEFFFFEB 		bl	cmdSet
 2204              	.LVL253:
 890:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2205              		.loc 1 890 0
 2206 1168 18209DE5 		ldr	r2, [sp, #24]
 2207 116c 0170A0E3 		mov	r7, #1
 2208 1170 0A30A0E1 		mov	r3, r10
 2209 1174 00208DE5 		str	r2, [sp]
 2210 1178 0400A0E1 		mov	r0, r4
 2211 117c 0B20A0E1 		mov	r2, fp
 2212 1180 0B10A0E3 		mov	r1, #11
 2213 1184 04708DE5 		str	r7, [sp, #4]
 2214 1188 FEFFFFEB 		bl	cmdSet
 2215              	.LVL254:
 891:../uvc.c      **** 
 2216              		.loc 1 891 0
 2217 118c 1C0094E5 		ldr	r0, [r4, #28]
 2218 1190 FEFFFFEB 		bl	_txe_mutex_put
 2219              	.LVL255:
 894:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2220              		.loc 1 894 0
 2221 1194 18009DE5 		ldr	r0, [sp, #24]
 2222 1198 14409DE5 		ldr	r4, [sp, #20]
 896:../uvc.c      **** 						 case MFreqCtlID4:
 2223              		.loc 1 896 0
 2224 119c FF80A0E3 		mov	r8, #255
 2225              	.LVL256:
 895:../uvc.c      **** 							 break;
 2226              		.loc 1 895 0
 2227 11a0 9872C6E5 		strb	r7, [r6, #664]
 893:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2228              		.loc 1 893 0
 2229 11a4 8C44C6E5 		strb	r4, [r6, #1164]
 894:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2230              		.loc 1 894 0
 2231 11a8 8E04C6E5 		strb	r0, [r6, #1166]
 2232 11ac 0030A0E1 		mov	r3, r0
 896:../uvc.c      **** 						 case MFreqCtlID4:
 2233              		.loc 1 896 0
 2234 11b0 0860A0E1 		mov	r6, r8
 2235 11b4 4EFEFFEA 		b	.L116
 2236              	.LVL257:
 2237              	.L157:
 873:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2238              		.loc 1 873 0
 2239 11b8 54479FE5 		ldr	r4, .L195+36
 2240 11bc 0010E0E3 		mvn	r1, #0
 2241 11c0 1C0094E5 		ldr	r0, [r4, #28]
 2242 11c4 10C08DE5 		str	ip, [sp, #16]
 2243 11c8 FEFFFFEB 		bl	_txe_mutex_get
 2244              	.LVL258:
 874:../uvc.c      **** 							 dataIdx++;
 2245              		.loc 1 874 0
 2246 11cc 14009DE5 		ldr	r0, [sp, #20]
 2247 11d0 0030A0E3 		mov	r3, #0
 2248 11d4 00008DE5 		str	r0, [sp]
 2249 11d8 0B20A0E1 		mov	r2, fp
 2250 11dc 0400A0E1 		mov	r0, r4
 2251 11e0 04308DE5 		str	r3, [sp, #4]
 2252 11e4 0610A0E3 		mov	r1, #6
 2253 11e8 0A30A0E1 		mov	r3, r10
 2254 11ec FEFFFFEB 		bl	cmdSet
 2255              	.LVL259:
 876:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2256              		.loc 1 876 0
 2257 11f0 14209DE5 		ldr	r2, [sp, #20]
 2258 11f4 10C09DE5 		ldr	ip, [sp, #16]
 2259 11f8 0170A0E3 		mov	r7, #1
 2260 11fc 0A30A0E1 		mov	r3, r10
 2261 1200 00208DE5 		str	r2, [sp]
 2262 1204 0400A0E1 		mov	r0, r4
 2263 1208 0C20A0E1 		mov	r2, ip
 2264 120c 0610A0E3 		mov	r1, #6
 2265 1210 04708DE5 		str	r7, [sp, #4]
 2266 1214 FEFFFFEB 		bl	cmdSet
 2267              	.LVL260:
 877:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2268              		.loc 1 877 0
 2269 1218 1C0094E5 		ldr	r0, [r4, #28]
 2270 121c FEFFFFEB 		bl	_txe_mutex_put
 2271              	.LVL261:
 2272 1220 14409DE5 		ldr	r4, [sp, #20]
 880:../uvc.c      **** 
 2273              		.loc 1 880 0
 2274 1224 FF80A0E3 		mov	r8, #255
 2275              	.LVL262:
 879:../uvc.c      **** 							 break;
 2276              		.loc 1 879 0
 2277 1228 2072C6E5 		strb	r7, [r6, #544]
 878:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2278              		.loc 1 878 0
 2279 122c 1D42C6E5 		strb	r4, [r6, #541]
 2280 1230 18309DE5 		ldr	r3, [sp, #24]
 880:../uvc.c      **** 
 2281              		.loc 1 880 0
 2282 1234 0860A0E1 		mov	r6, r8
 2283 1238 2DFEFFEA 		b	.L116
 2284              	.LVL263:
 2285              	.L156:
 853:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2286              		.loc 1 853 0
 2287 123c D0469FE5 		ldr	r4, .L195+36
 2288 1240 0010E0E3 		mvn	r1, #0
 2289 1244 1C0094E5 		ldr	r0, [r4, #28]
 2290 1248 10C08DE5 		str	ip, [sp, #16]
 2291 124c FEFFFFEB 		bl	_txe_mutex_get
 2292              	.LVL264:
 854:../uvc.c      **** 							 dataIdx++;
 2293              		.loc 1 854 0
 2294 1250 14009DE5 		ldr	r0, [sp, #20]
 2295 1254 0030A0E3 		mov	r3, #0
 2296 1258 801040E2 		sub	r1, r0, #128
 2297 125c FF1001E2 		and	r1, r1, #255
 2298 1260 0B20A0E1 		mov	r2, fp
 2299 1264 00108DE5 		str	r1, [sp]
 2300 1268 0400A0E1 		mov	r0, r4
 2301 126c 04308DE5 		str	r3, [sp, #4]
 2302 1270 0510A0E3 		mov	r1, #5
 2303 1274 0A30A0E1 		mov	r3, r10
 2304 1278 FEFFFFEB 		bl	cmdSet
 2305              	.LVL265:
 856:../uvc.c      **** 							 dataIdx++;
 2306              		.loc 1 856 0
 2307 127c 14209DE5 		ldr	r2, [sp, #20]
 2308 1280 0190A0E3 		mov	r9, #1
 2309 1284 763042E2 		sub	r3, r2, #118
 2310 1288 FF3003E2 		and	r3, r3, #255
 2311 128c 00308DE5 		str	r3, [sp]
 2312 1290 0400A0E1 		mov	r0, r4
 2313 1294 0510A0E3 		mov	r1, #5
 2314 1298 DC20A0E3 		mov	r2, #220
 2315 129c 0A30A0E1 		mov	r3, r10
 2316 12a0 04908DE5 		str	r9, [sp, #4]
 2317 12a4 FEFFFFEB 		bl	cmdSet
 2318              	.LVL266:
 858:../uvc.c      **** 							 dataIdx++;
 2319              		.loc 1 858 0
 2320 12a8 14309DE5 		ldr	r3, [sp, #20]
 2321 12ac 0400A0E1 		mov	r0, r4
 2322 12b0 7E2083E2 		add	r2, r3, #126
 2323 12b4 FF2002E2 		and	r2, r2, #255
 2324 12b8 0230A0E3 		mov	r3, #2
 2325 12bc 00208DE5 		str	r2, [sp]
 2326 12c0 04308DE5 		str	r3, [sp, #4]
 2327 12c4 0510A0E3 		mov	r1, #5
 2328 12c8 DE20A0E3 		mov	r2, #222
 2329 12cc 0A30A0E1 		mov	r3, r10
 2330 12d0 FEFFFFEB 		bl	cmdSet
 2331              	.LVL267:
 860:../uvc.c      **** 							 dataIdx++;
 2332              		.loc 1 860 0
 2333 12d4 14009DE5 		ldr	r0, [sp, #20]
 2334 12d8 0330A0E3 		mov	r3, #3
 2335 12dc 722080E2 		add	r2, r0, #114
 2336 12e0 FF2002E2 		and	r2, r2, #255
 2337 12e4 00208DE5 		str	r2, [sp]
 2338 12e8 0400A0E1 		mov	r0, r4
 2339 12ec 04308DE5 		str	r3, [sp, #4]
 2340 12f0 0510A0E3 		mov	r1, #5
 2341 12f4 E020A0E3 		mov	r2, #224
 2342 12f8 0A30A0E1 		mov	r3, r10
 2343 12fc FEFFFFEB 		bl	cmdSet
 2344              	.LVL268:
 862:../uvc.c      **** 							 dataIdx++;
 2345              		.loc 1 862 0
 2346 1300 14309DE5 		ldr	r3, [sp, #20]
 2347 1304 0400A0E1 		mov	r0, r4
 2348 1308 6F2043E2 		sub	r2, r3, #111
 2349 130c FF2002E2 		and	r2, r2, #255
 2350 1310 0430A0E3 		mov	r3, #4
 2351 1314 00208DE5 		str	r2, [sp]
 2352 1318 04308DE5 		str	r3, [sp, #4]
 2353 131c 0510A0E3 		mov	r1, #5
 2354 1320 DD20A0E3 		mov	r2, #221
 2355 1324 0A30A0E1 		mov	r3, r10
 2356 1328 FEFFFFEB 		bl	cmdSet
 2357              	.LVL269:
 864:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2358              		.loc 1 864 0
 2359 132c 9C00D7E5 		ldrb	r0, [r7, #156]	@ zero_extendqisi2
 2360 1330 10C09DE5 		ldr	ip, [sp, #16]
 2361 1334 7F0080E2 		add	r0, r0, #127
 2362 1338 0510A0E3 		mov	r1, #5
 2363 133c FF0000E2 		and	r0, r0, #255
 2364 1340 0A30A0E1 		mov	r3, r10
 2365 1344 0C20A0E1 		mov	r2, ip
 2366 1348 00008DE5 		str	r0, [sp]
 2367 134c 04108DE5 		str	r1, [sp, #4]
 2368 1350 0400A0E1 		mov	r0, r4
 2369 1354 FEFFFFEB 		bl	cmdSet
 2370              	.LVL270:
 865:../uvc.c      **** 
 2371              		.loc 1 865 0
 2372 1358 1C0094E5 		ldr	r0, [r4, #28]
 2373 135c FEFFFFEB 		bl	_txe_mutex_put
 2374              	.LVL271:
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2375              		.loc 1 867 0
 2376 1360 9C30D7E5 		ldrb	r3, [r7, #156]	@ zero_extendqisi2
 869:../uvc.c      **** 						 case SaturCtlID6:
 2377              		.loc 1 869 0
 2378 1364 FF80A0E3 		mov	r8, #255
 2379              	.LVL272:
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2380              		.loc 1 867 0
 2381 1368 803043E2 		sub	r3, r3, #128
 2382 136c 0532C6E5 		strb	r3, [r6, #517]
 868:../uvc.c      **** 							 break;
 2383              		.loc 1 868 0
 2384 1370 0892C6E5 		strb	r9, [r6, #520]
 2385 1374 14409DE5 		ldr	r4, [sp, #20]
 2386 1378 18309DE5 		ldr	r3, [sp, #24]
 869:../uvc.c      **** 						 case SaturCtlID6:
 2387              		.loc 1 869 0
 2388 137c 0860A0E1 		mov	r6, r8
 2389 1380 DBFDFFEA 		b	.L116
 2390              	.LVL273:
 2391              	.L155:
 905:../uvc.c      **** 							 //remove for Invendo
 2392              		.loc 1 905 0
 2393 1384 88459FE5 		ldr	r4, .L195+36
 899:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 2394              		.loc 1 899 0
 2395 1388 017040E2 		sub	r7, r0, #1
 905:../uvc.c      **** 							 //remove for Invendo
 2396              		.loc 1 905 0
 2397 138c 0010E0E3 		mvn	r1, #0
 2398 1390 1C0094E5 		ldr	r0, [r4, #28]
 2399 1394 FEFFFFEB 		bl	_txe_mutex_get
 2400              	.LVL274:
 899:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 2401              		.loc 1 899 0
 2402 1398 FF7007E2 		and	r7, r7, #255
 2403              	.LVL275:
 908:../uvc.c      **** 
 2404              		.loc 1 908 0
 2405 139c 1C0094E5 		ldr	r0, [r4, #28]
 2406 13a0 FEFFFFEB 		bl	_txe_mutex_put
 2407              	.LVL276:
 903:../uvc.c      **** 
 2408              		.loc 1 903 0
 2409 13a4 020057E3 		cmp	r7, #2
 2410 13a8 0170A083 		movhi	r7, #1
 2411              	.LVL277:
 911:../uvc.c      **** 							 break;
 2412              		.loc 1 911 0
 2413 13ac 0120A0E3 		mov	r2, #1
 912:../uvc.c      **** 					 	 case BLCCtlID0:
 2414              		.loc 1 912 0
 2415 13b0 FF80A0E3 		mov	r8, #255
 2416              	.LVL278:
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2417              		.loc 1 910 0
 2418 13b4 ED71C6E5 		strb	r7, [r6, #493]
 911:../uvc.c      **** 							 break;
 2419              		.loc 1 911 0
 2420 13b8 F021C6E5 		strb	r2, [r6, #496]
 2421 13bc 14409DE5 		ldr	r4, [sp, #20]
 2422 13c0 18309DE5 		ldr	r3, [sp, #24]
 912:../uvc.c      **** 					 	 case BLCCtlID0:
 2423              		.loc 1 912 0
 2424 13c4 0860A0E1 		mov	r6, r8
 2425 13c8 C9FDFFEA 		b	.L116
 2426              	.LVL279:
 2427              	.L153:
 914:../uvc.c      **** 							 if(Data0 == 3)
 2428              		.loc 1 914 0
 2429 13cc 1C359FE5 		ldr	r3, .L195
 915:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2430              		.loc 1 915 0
 2431 13d0 030050E3 		cmp	r0, #3
 916:../uvc.c      **** 							 else
 2432              		.loc 1 916 0
 2433 13d4 0120A003 		moveq	r2, #1
 914:../uvc.c      **** 							 if(Data0 == 3)
 2434              		.loc 1 914 0
 2435 13d8 8D01C6E5 		strb	r0, [r6, #397]
 916:../uvc.c      **** 							 else
 2436              		.loc 1 916 0
 2437 13dc BC208705 		streq	r2, [r7, #188]
 919:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2438              		.loc 1 919 0
 2439 13e0 9021C305 		streqb	r2, [r3, #400]
 915:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2440              		.loc 1 915 0
 2441 13e4 0800000A 		beq	.L180
 922:../uvc.c      **** 					 				 ;//Data0 += 4;
 2442              		.loc 1 922 0
 2443 13e8 14009DE5 		ldr	r0, [sp, #20]
 918:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2444              		.loc 1 918 0
 2445 13ec 0010A0E3 		mov	r1, #0
 922:../uvc.c      **** 					 				 ;//Data0 += 4;
 2446              		.loc 1 922 0
 2447 13f0 010050E3 		cmp	r0, #1
 919:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2448              		.loc 1 919 0
 2449 13f4 0120A0E3 		mov	r2, #1
 2450 13f8 0040A091 		movls	r4, r0
 918:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2451              		.loc 1 918 0
 2452 13fc BC1087E5 		str	r1, [r7, #188]
 919:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2453              		.loc 1 919 0
 2454 1400 9021C3E5 		strb	r2, [r3, #400]
 922:../uvc.c      **** 					 				 ;//Data0 += 4;
 2455              		.loc 1 922 0
 2456 1404 0460A091 		movls	r6, r4
 2457 1408 0800009A 		bls	.L181
 2458              	.L180:
 925:../uvc.c      **** 									Data0 = 0; //set to default.
 2459              		.loc 1 925 0
 2460 140c 14409DE5 		ldr	r4, [sp, #20]
 2461 1410 0120A0E3 		mov	r2, #1
 2462 1414 0430A0E1 		mov	r3, r4
 2463 1418 0400A0E3 		mov	r0, #4
 2464 141c F4149FE5 		ldr	r1, .L195+40
 2465 1420 FEFFFFEB 		bl	CyU3PDebugPrint
 2466              	.LVL280:
 2467 1424 0020A0E3 		mov	r2, #0
 926:../uvc.c      **** 					 			 }
 2468              		.loc 1 926 0
 2469 1428 0260A0E1 		mov	r6, r2
 925:../uvc.c      **** 									Data0 = 0; //set to default.
 2470              		.loc 1 925 0
 2471 142c 14208DE5 		str	r2, [sp, #20]
 2472              	.LVL281:
 2473              	.L181:
 931:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2474              		.loc 1 931 0
 2475 1430 DC849FE5 		ldr	r8, .L195+36
 2476              	.LVL282:
 2477 1434 0010E0E3 		mvn	r1, #0
 2478 1438 1C0098E5 		ldr	r0, [r8, #28]
 2479 143c FEFFFFEB 		bl	_txe_mutex_get
 2480              	.LVL283:
 932:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2481              		.loc 1 932 0
 2482 1440 14309DE5 		ldr	r3, [sp, #20]
 2483 1444 0010A0E3 		mov	r1, #0
 2484 1448 0B20A0E1 		mov	r2, fp
 2485 144c 04108DE5 		str	r1, [sp, #4]
 2486 1450 00308DE5 		str	r3, [sp]
 2487 1454 0800A0E1 		mov	r0, r8
 2488 1458 0A30A0E1 		mov	r3, r10
 2489 145c FEFFFFEB 		bl	cmdSet
 2490              	.LVL284:
 933:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2491              		.loc 1 933 0
 2492 1460 1C0098E5 		ldr	r0, [r8, #28]
 2493 1464 FEFFFFEB 		bl	_txe_mutex_put
 2494              	.LVL285:
 934:../uvc.c      **** 
 2495              		.loc 1 934 0
 2496 1468 9E00D7E5 		ldrb	r0, [r7, #158]	@ zero_extendqisi2
 2497 146c 9F10D7E5 		ldrb	r1, [r7, #159]	@ zero_extendqisi2
 2498 1470 BC3097E5 		ldr	r3, [r7, #188]
 2499 1474 0620A0E1 		mov	r2, r6
 2500 1478 03008DE8 		stmia	sp, {r0, r1}
 2501 147c 98149FE5 		ldr	r1, .L195+44
 2502 1480 0400A0E3 		mov	r0, #4
 936:../uvc.c      **** 						 default:
 2503              		.loc 1 936 0
 2504 1484 FF80A0E3 		mov	r8, #255
 934:../uvc.c      **** 
 2505              		.loc 1 934 0
 2506 1488 FEFFFFEB 		bl	CyU3PDebugPrint
 2507              	.LVL286:
 936:../uvc.c      **** 						 default:
 2508              		.loc 1 936 0
 2509 148c 0860A0E1 		mov	r6, r8
 2510 1490 18309DE5 		ldr	r3, [sp, #24]
 2511 1494 96FDFFEA 		b	.L116
 2512              	.LVL287:
 2513              	.L163:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2514              		.loc 1 762 0
 2515 1498 74449FE5 		ldr	r4, .L195+36
 2516 149c 0010E0E3 		mvn	r1, #0
 2517 14a0 1C0094E5 		ldr	r0, [r4, #28]
 2518 14a4 FEFFFFEB 		bl	_txe_mutex_get
 2519              	.LVL288:
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2520              		.loc 1 763 0
 2521 14a8 14209DE5 		ldr	r2, [sp, #20]
 2522 14ac 0010A0E3 		mov	r1, #0
 2523 14b0 01C072E2 		rsbs	ip, r2, #1
 2524 14b4 00C0A033 		movcc	ip, #0
 2525 14b8 0B20A0E1 		mov	r2, fp
 2526 14bc 0A30A0E1 		mov	r3, r10
 2527 14c0 0400A0E1 		mov	r0, r4
 2528 14c4 00C08DE5 		str	ip, [sp]
 2529 14c8 04108DE5 		str	r1, [sp, #4]
 2530 14cc 1E10A0E3 		mov	r1, #30
 2531 14d0 FEFFFFEB 		bl	cmdSet
 2532              	.LVL289:
 764:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2533              		.loc 1 764 0
 2534 14d4 1C0094E5 		ldr	r0, [r4, #28]
 2535 14d8 FEFFFFEB 		bl	_txe_mutex_put
 2536              	.LVL290:
 766:../uvc.c      **** 						 case ExtI2CCtlID15:
 2537              		.loc 1 766 0
 2538 14dc FF80A0E3 		mov	r8, #255
 2539              	.LVL291:
 765:../uvc.c      **** 							 break;
 2540              		.loc 1 765 0
 2541 14e0 0120A0E3 		mov	r2, #1
 2542 14e4 6024C6E5 		strb	r2, [r6, #1120]
 2543 14e8 14409DE5 		ldr	r4, [sp, #20]
 2544 14ec 18309DE5 		ldr	r3, [sp, #24]
 766:../uvc.c      **** 						 case ExtI2CCtlID15:
 2545              		.loc 1 766 0
 2546 14f0 0860A0E1 		mov	r6, r8
 2547 14f4 7EFDFFEA 		b	.L116
 2548              	.LVL292:
 2549              	.L162:
 675:../uvc.c      **** 					 {
 2550              		.loc 1 675 0
 2551 14f8 FF80A0E3 		mov	r8, #255
 2552              	.LVL293:
 2553 14fc 0040A0E1 		mov	r4, r0
 2554              	.LVL294:
 2555 1500 0860A0E1 		mov	r6, r8
 2556 1504 7AFDFFEA 		b	.L116
 2557              	.LVL295:
 2558              	.L161:
 729:../uvc.c      **** 							 if(WDRflag)
 2559              		.loc 1 729 0
 2560 1508 04449FE5 		ldr	r4, .L195+36
 2561 150c 0020A0E1 		mov	r2, r0
 2562 1510 0010E0E3 		mvn	r1, #0
 728:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2563              		.loc 1 728 0
 2564 1514 0130A0E3 		mov	r3, #1
 729:../uvc.c      **** 							 if(WDRflag)
 2565              		.loc 1 729 0
 2566 1518 1C0094E5 		ldr	r0, [r4, #28]
 727:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2567              		.loc 1 727 0
 2568 151c FD23C6E5 		strb	r2, [r6, #1021]
 728:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2569              		.loc 1 728 0
 2570 1520 0034C6E5 		strb	r3, [r6, #1024]
 729:../uvc.c      **** 							 if(WDRflag)
 2571              		.loc 1 729 0
 2572 1524 10C08DE5 		str	ip, [sp, #16]
 2573 1528 FEFFFFEB 		bl	_txe_mutex_get
 2574              	.LVL296:
 730:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2575              		.loc 1 730 0
 2576 152c BC3097E5 		ldr	r3, [r7, #188]
 2577 1530 10C09DE5 		ldr	ip, [sp, #16]
 2578 1534 000053E3 		cmp	r3, #0
 731:../uvc.c      **** 							 else
 2579              		.loc 1 731 0
 2580 1538 14309D15 		ldrne	r3, [sp, #20]
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2581              		.loc 1 733 0
 2582 153c 14009D05 		ldreq	r0, [sp, #20]
 731:../uvc.c      **** 							 else
 2583              		.loc 1 731 0
 2584 1540 0010A013 		movne	r1, #0
 2585 1544 00308D15 		strne	r3, [sp]
 2586 1548 0C20A011 		movne	r2, ip
 2587 154c 0A30A011 		movne	r3, r10
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2588              		.loc 1 733 0
 2589 1550 0B20A001 		moveq	r2, fp
 735:../uvc.c      **** 						 case ExtCamMCtlID12:
 2590              		.loc 1 735 0
 2591 1554 FF80A0E3 		mov	r8, #255
 2592              	.LVL297:
 2593 1558 0860A0E1 		mov	r6, r8
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2594              		.loc 1 733 0
 2595 155c 09008D08 		stmeqia	sp, {r0, r3}
 731:../uvc.c      **** 							 else
 2596              		.loc 1 731 0
 2597 1560 04108D15 		strne	r1, [sp, #4]
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2598              		.loc 1 733 0
 2599 1564 0A30A001 		moveq	r3, r10
 2600 1568 1A10A0E3 		mov	r1, #26
 2601 156c 0400A0E1 		mov	r0, r4
 2602 1570 FEFFFFEB 		bl	cmdSet
 2603              	.LVL298:
 734:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2604              		.loc 1 734 0
 2605 1574 1C0094E5 		ldr	r0, [r4, #28]
 2606 1578 FEFFFFEB 		bl	_txe_mutex_put
 2607              	.LVL299:
 735:../uvc.c      **** 						 case ExtCamMCtlID12:
 2608              		.loc 1 735 0
 2609 157c 9E00D7E5 		ldrb	r0, [r7, #158]	@ zero_extendqisi2
 2610 1580 9F10D7E5 		ldrb	r1, [r7, #159]	@ zero_extendqisi2
 2611 1584 14409DE5 		ldr	r4, [sp, #20]
 2612 1588 BC3097E5 		ldr	r3, [r7, #188]
 2613 158c 0420A0E1 		mov	r2, r4
 2614 1590 03008DE8 		stmia	sp, {r0, r1}
 2615 1594 84139FE5 		ldr	r1, .L195+48
 2616 1598 0400A0E3 		mov	r0, #4
 2617 159c FEFFFFEB 		bl	CyU3PDebugPrint
 2618              	.LVL300:
 2619 15a0 18309DE5 		ldr	r3, [sp, #24]
 2620 15a4 52FDFFEA 		b	.L116
 2621              	.LVL301:
 2622              	.L160:
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2623              		.loc 1 716 0
 2624 15a8 64439FE5 		ldr	r4, .L195+36
 2625 15ac 0020A0E1 		mov	r2, r0
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2626              		.loc 1 712 0
 2627 15b0 E523C6E5 		strb	r2, [r6, #997]
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2628              		.loc 1 713 0
 2629 15b4 18209DE5 		ldr	r2, [sp, #24]
 714:../uvc.c      **** 							 dataIdx = 0;
 2630              		.loc 1 714 0
 2631 15b8 0130A0E3 		mov	r3, #1
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2632              		.loc 1 716 0
 2633 15bc 1C0094E5 		ldr	r0, [r4, #28]
 2634 15c0 0010E0E3 		mvn	r1, #0
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2635              		.loc 1 713 0
 2636 15c4 E623C6E5 		strb	r2, [r6, #998]
 714:../uvc.c      **** 							 dataIdx = 0;
 2637              		.loc 1 714 0
 2638 15c8 E833C6E5 		strb	r3, [r6, #1000]
 2639              	.LVL302:
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2640              		.loc 1 716 0
 2641 15cc 10C08DE5 		str	ip, [sp, #16]
 2642 15d0 FEFFFFEB 		bl	_txe_mutex_get
 2643              	.LVL303:
 720:../uvc.c      **** 							 }
 2644              		.loc 1 720 0
 2645 15d4 10C09DE5 		ldr	ip, [sp, #16]
 2646 15d8 18309DE5 		ldr	r3, [sp, #24]
 2647 15dc 0010A0E3 		mov	r1, #0
 2648 15e0 0C20A0E1 		mov	r2, ip
 2649 15e4 00308DE5 		str	r3, [sp]
 2650 15e8 0400A0E1 		mov	r0, r4
 2651 15ec 0A30A0E1 		mov	r3, r10
 2652 15f0 04108DE5 		str	r1, [sp, #4]
 2653 15f4 1910A0E3 		mov	r1, #25
 2654 15f8 FEFFFFEB 		bl	cmdSet
 2655              	.LVL304:
 722:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2656              		.loc 1 722 0
 2657 15fc 1C0094E5 		ldr	r0, [r4, #28]
 2658 1600 FEFFFFEB 		bl	_txe_mutex_put
 2659              	.LVL305:
 723:../uvc.c      **** 							 break;
 2660              		.loc 1 723 0
 2661 1604 9E00D7E5 		ldrb	r0, [r7, #158]	@ zero_extendqisi2
 2662 1608 9F10D7E5 		ldrb	r1, [r7, #159]	@ zero_extendqisi2
 2663 160c 9D30D7E5 		ldrb	r3, [r7, #157]	@ zero_extendqisi2
 2664 1610 9C20D7E5 		ldrb	r2, [r7, #156]	@ zero_extendqisi2
 724:../uvc.c      **** 						 case ExtExRefCtlID10:
 2665              		.loc 1 724 0
 2666 1614 FF80A0E3 		mov	r8, #255
 2667              	.LVL306:
 723:../uvc.c      **** 							 break;
 2668              		.loc 1 723 0
 2669 1618 03008DE8 		stmia	sp, {r0, r1}
 2670 161c 00139FE5 		ldr	r1, .L195+52
 2671 1620 0400A0E3 		mov	r0, #4
 2672 1624 FEFFFFEB 		bl	CyU3PDebugPrint
 2673              	.LVL307:
 724:../uvc.c      **** 						 case ExtExRefCtlID10:
 2674              		.loc 1 724 0
 2675 1628 0860A0E1 		mov	r6, r8
 2676 162c 14409DE5 		ldr	r4, [sp, #20]
 2677 1630 18309DE5 		ldr	r3, [sp, #24]
 2678 1634 2EFDFFEA 		b	.L116
 2679              	.LVL308:
 2680              	.L165:
 797:../uvc.c      **** 						     /* end test */
 2681              		.loc 1 797 0
 2682 1638 D4429FE5 		ldr	r4, .L195+36
 2683 163c 0010E0E3 		mvn	r1, #0
 2684 1640 1C0094E5 		ldr	r0, [r4, #28]
 2685 1644 10C08DE5 		str	ip, [sp, #16]
 2686 1648 FEFFFFEB 		bl	_txe_mutex_get
 2687              	.LVL309:
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2688              		.loc 1 796 0
 2689 164c 14309DE5 		ldr	r3, [sp, #20]
 799:../uvc.c      **** 							 dataIdx++;
 2690              		.loc 1 799 0
 2691 1650 0B20A0E1 		mov	r2, fp
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2692              		.loc 1 796 0
 2693 1654 7F7003E2 		and	r7, r3, #127
 2694              	.LVL310:
 799:../uvc.c      **** 							 dataIdx++;
 2695              		.loc 1 799 0
 2696 1658 0030A0E3 		mov	r3, #0
 2697 165c 0400A0E1 		mov	r0, r4
 2698 1660 04308DE5 		str	r3, [sp, #4]
 2699 1664 2410A0E3 		mov	r1, #36
 2700 1668 0A30A0E1 		mov	r3, r10
 2701 166c 00708DE5 		str	r7, [sp]
 2702 1670 FEFFFFEB 		bl	cmdSet
 2703              	.LVL311:
 801:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2704              		.loc 1 801 0
 2705 1674 1C009DE5 		ldr	r0, [sp, #28]
 2706 1678 10C09DE5 		ldr	ip, [sp, #16]
 2707 167c 0190A0E3 		mov	r9, #1
 2708 1680 0C20A0E1 		mov	r2, ip
 2709 1684 0A30A0E1 		mov	r3, r10
 2710 1688 00008DE5 		str	r0, [sp]
 2711 168c 2410A0E3 		mov	r1, #36
 2712 1690 0400A0E1 		mov	r0, r4
 2713 1694 04908DE5 		str	r9, [sp, #4]
 2714 1698 FEFFFFEB 		bl	cmdSet
 2715              	.LVL312:
 802:../uvc.c      **** 							 getData1 = Data1;
 2716              		.loc 1 802 0
 2717 169c 1C0094E5 		ldr	r0, [r4, #28]
 2718 16a0 FEFFFFEB 		bl	_txe_mutex_put
 2719              	.LVL313:
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2720              		.loc 1 806 0
 2721 16a4 1C209DE5 		ldr	r2, [sp, #28]
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2722              		.loc 1 805 0
 2723 16a8 888088E0 		add	r8, r8, r8, asl #1
 2724              	.LVL314:
 2725 16ac 886186E0 		add	r6, r6, r8, asl #3
 808:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 2726              		.loc 1 808 0
 2727 16b0 FF80A0E3 		mov	r8, #255
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2728              		.loc 1 805 0
 2729 16b4 0D70C6E5 		strb	r7, [r6, #13]
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2730              		.loc 1 806 0
 2731 16b8 0E20C6E5 		strb	r2, [r6, #14]
 807:../uvc.c      **** 							 break;
 2732              		.loc 1 807 0
 2733 16bc 1090C6E5 		strb	r9, [r6, #16]
 2734 16c0 14409DE5 		ldr	r4, [sp, #20]
 2735 16c4 0230A0E1 		mov	r3, r2
 808:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 2736              		.loc 1 808 0
 2737 16c8 0860A0E1 		mov	r6, r8
 2738 16cc 08FDFFEA 		b	.L116
 2739              	.LVL315:
 2740              	.L164:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2741              		.loc 1 768 0 discriminator 1
 2742 16d0 000059E3 		cmp	r9, #0
 2743 16d4 0300000A 		beq	.L177
 2744 16d8 48029FE5 		ldr	r0, .L195+56
 2745 16dc 0920A0E1 		mov	r2, r9
 2746 16e0 0C1080E2 		add	r1, r0, #12
 2747 16e4 FEFFFFEB 		bl	memcpy
 2748              	.LVL316:
 2749              	.L177:
 772:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 2750              		.loc 1 772 0
 2751 16e8 FF80A0E3 		mov	r8, #255
 2752              	.LVL317:
 771:../uvc.c      **** 							 break;
 2753              		.loc 1 771 0
 2754 16ec FEFFFFEB 		bl	I2CCmdHandler
 2755              	.LVL318:
 772:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 2756              		.loc 1 772 0
 2757 16f0 0860A0E1 		mov	r6, r8
 2758 16f4 14409DE5 		ldr	r4, [sp, #20]
 2759              	.LVL319:
 2760 16f8 18309DE5 		ldr	r3, [sp, #24]
 2761 16fc FCFCFFEA 		b	.L116
 2762              	.LVL320:
 2763              	.L166:
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2764              		.loc 1 811 0
 2765 1700 0C429FE5 		ldr	r4, .L195+36
 2766 1704 0010E0E3 		mvn	r1, #0
 2767 1708 1C0094E5 		ldr	r0, [r4, #28]
 2768 170c FEFFFFEB 		bl	_txe_mutex_get
 2769              	.LVL321:
 812:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2770              		.loc 1 812 0
 2771 1710 14309DE5 		ldr	r3, [sp, #20]
 2772 1714 0010A0E3 		mov	r1, #0
 2773 1718 0B20A0E1 		mov	r2, fp
 2774 171c 00308DE5 		str	r3, [sp]
 2775 1720 0400A0E1 		mov	r0, r4
 2776 1724 0A30A0E1 		mov	r3, r10
 2777 1728 04108DE5 		str	r1, [sp, #4]
 2778 172c 2510A0E3 		mov	r1, #37
 2779 1730 FEFFFFEB 		bl	cmdSet
 2780              	.LVL322:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2781              		.loc 1 813 0
 2782 1734 1C0094E5 		ldr	r0, [r4, #28]
 2783 1738 FEFFFFEB 		bl	_txe_mutex_put
 2784              	.LVL323:
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2785              		.loc 1 814 0
 2786 173c 14009DE5 		ldr	r0, [sp, #20]
 2787 1740 888088E0 		add	r8, r8, r8, asl #1
 2788              	.LVL324:
 2789 1744 886186E0 		add	r6, r6, r8, asl #3
 815:../uvc.c      **** 							 break;
 2790              		.loc 1 815 0
 2791 1748 0120A0E3 		mov	r2, #1
 816:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 2792              		.loc 1 816 0
 2793 174c FF80A0E3 		mov	r8, #255
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2794              		.loc 1 814 0
 2795 1750 0D00C6E5 		strb	r0, [r6, #13]
 815:../uvc.c      **** 							 break;
 2796              		.loc 1 815 0
 2797 1754 1020C6E5 		strb	r2, [r6, #16]
 2798 1758 0040A0E1 		mov	r4, r0
 2799 175c 18309DE5 		ldr	r3, [sp, #24]
 816:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 2800              		.loc 1 816 0
 2801 1760 0860A0E1 		mov	r6, r8
 2802 1764 E2FCFFEA 		b	.L116
 2803              	.LVL325:
 2804              	.L152:
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2805              		.loc 1 940 0
 2806 1768 A4719FE5 		ldr	r7, .L195+36
 2807 176c 0010E0E3 		mvn	r1, #0
 2808 1770 1C0097E5 		ldr	r0, [r7, #28]
 2809 1774 FEFFFFEB 		bl	_txe_mutex_get
 2810              	.LVL326:
 941:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2811              		.loc 1 941 0
 2812 1778 14009DE5 		ldr	r0, [sp, #20]
 2813 177c 0010A0E3 		mov	r1, #0
 2814 1780 0B20A0E1 		mov	r2, fp
 2815 1784 0A30A0E1 		mov	r3, r10
 2816 1788 00008DE5 		str	r0, [sp]
 2817 178c 04108DE5 		str	r1, [sp, #4]
 2818 1790 0700A0E1 		mov	r0, r7
 2819 1794 0410A0E1 		mov	r1, r4
 2820 1798 FEFFFFEB 		bl	cmdSet
 2821              	.LVL327:
 942:../uvc.c      **** 
 2822              		.loc 1 942 0
 2823 179c 1C0097E5 		ldr	r0, [r7, #28]
 2824 17a0 FEFFFFEB 		bl	_txe_mutex_put
 2825              	.LVL328:
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2826              		.loc 1 944 0
 2827 17a4 14309DE5 		ldr	r3, [sp, #20]
 2828 17a8 844084E0 		add	r4, r4, r4, asl #1
 2829 17ac 846186E0 		add	r6, r6, r4, asl #3
 945:../uvc.c      **** 							 break;
 2830              		.loc 1 945 0
 2831 17b0 0120A0E3 		mov	r2, #1
 946:../uvc.c      **** 					 }
 2832              		.loc 1 946 0
 2833 17b4 FF80A0E3 		mov	r8, #255
 2834              	.LVL329:
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2835              		.loc 1 944 0
 2836 17b8 8D31C6E5 		strb	r3, [r6, #397]
 2837 17bc 0340A0E1 		mov	r4, r3
 945:../uvc.c      **** 							 break;
 2838              		.loc 1 945 0
 2839 17c0 9021C6E5 		strb	r2, [r6, #400]
 2840 17c4 18309DE5 		ldr	r3, [sp, #24]
 946:../uvc.c      **** 					 }
 2841              		.loc 1 946 0
 2842 17c8 0860A0E1 		mov	r6, r8
 2843 17cc C8FCFFEA 		b	.L116
 2844              	.LVL330:
 2845              	.L151:
 949:../uvc.c      **** 			   }
 2846              		.loc 1 949 0
 2847 17d0 FF80A0E3 		mov	r8, #255
 2848              	.LVL331:
 2849 17d4 0400A0E3 		mov	r0, #4
 2850              	.LVL332:
 2851 17d8 4C119FE5 		ldr	r1, .L195+60
 2852 17dc FEFFFFEB 		bl	CyU3PDebugPrint
 2853              	.LVL333:
 2854 17e0 0860A0E1 		mov	r6, r8
 2855 17e4 0830A0E1 		mov	r3, r8
 2856 17e8 0840A0E1 		mov	r4, r8
 2857              	.LVL334:
 2858 17ec C0FCFFEA 		b	.L116
 2859              	.LVL335:
 2860              	.L136:
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 2861              		.loc 1 563 0
 2862 17f0 0B00A0E1 		mov	r0, fp
 2863              	.LVL336:
 2864 17f4 0A10A0E1 		mov	r1, r10
 2865 17f8 FEFFFFEB 		bl	SensorGetControl
 2866              	.LVL337:
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2867              		.loc 1 564 0
 2868 17fc 844084E0 		add	r4, r4, r4, asl #1
 2869              	.LVL338:
 2870 1800 846186E0 		add	r6, r6, r4, asl #3
 566:../uvc.c      **** 		 	 		 }
 2871              		.loc 1 566 0
 2872 1804 0120A0E3 		mov	r2, #1
 2873 1808 2C20C8E5 		strb	r2, [r8, #44]
 2874 180c 0030A0E1 		mov	r3, r0
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2875              		.loc 1 564 0
 2876 1810 8D01C6E5 		strb	r0, [r6, #397]
 2877 1814 02FEFFEA 		b	.L137
 2878              	.LVL339:
 2879              	.L134:
 542:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 2880              		.loc 1 542 0
 2881 1818 0C00A0E1 		mov	r0, ip
 2882              	.LVL340:
 2883 181c 0A10A0E1 		mov	r1, r10
 2884 1820 FEFFFFEB 		bl	SensorGetControl
 2885              	.LVL341:
 543:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 2886              		.loc 1 543 0
 2887 1824 0A10A0E1 		mov	r1, r10
 542:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 2888              		.loc 1 542 0
 2889 1828 0040A0E1 		mov	r4, r0
 2890              	.LVL342:
 543:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 2891              		.loc 1 543 0
 2892 182c 0B00A0E1 		mov	r0, fp
 2893              	.LVL343:
 2894 1830 FEFFFFEB 		bl	SensorGetControl
 2895              	.LVL344:
 548:../uvc.c      **** 		 	 		 }
 2896              		.loc 1 548 0
 2897 1834 0130A0E3 		mov	r3, #1
 2898 1838 0420A0E1 		mov	r2, r4
 544:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2899              		.loc 1 544 0
 2900 183c 9C40C7E5 		strb	r4, [r7, #156]
 545:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 2901              		.loc 1 545 0
 2902 1840 8C44C6E5 		strb	r4, [r6, #1164]
 548:../uvc.c      **** 		 	 		 }
 2903              		.loc 1 548 0
 2904 1844 3730C7E5 		strb	r3, [r7, #55]
 2905 1848 0080A0E1 		mov	r8, r0
 2906              	.LVL345:
 546:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 2907              		.loc 1 546 0
 2908 184c 9E00C7E5 		strb	r0, [r7, #158]
 547:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 2909              		.loc 1 547 0
 2910 1850 8E04C6E5 		strb	r0, [r6, #1166]
 2911 1854 DCFDFFEA 		b	.L135
 2912              	.LVL346:
 2913              	.L132:
 490:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 2914              		.loc 1 490 0
 2915 1858 0C00A0E1 		mov	r0, ip
 2916              	.LVL347:
 2917 185c 0A10A0E1 		mov	r1, r10
 2918 1860 FEFFFFEB 		bl	SensorGetControl
 2919              	.LVL348:
 492:../uvc.c      **** 		 	 		 }
 2920              		.loc 1 492 0
 2921 1864 0130A0E3 		mov	r3, #1
 2922 1868 4530C7E5 		strb	r3, [r7, #69]
 2923 186c 00E0A0E1 		mov	lr, r0
 491:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 2924              		.loc 1 491 0
 2925 1870 E603C6E5 		strb	r0, [r6, #998]
 2926 1874 B2FDFFEA 		b	.L133
 2927              	.LVL349:
 2928              	.L169:
 688:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2929              		.loc 1 688 0
 2930 1878 011040E2 		sub	r1, r0, #1
 689:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2931              		.loc 1 689 0
 2932 187c 040052E3 		cmp	r2, #4
 2933 1880 01005213 		cmpne	r2, #1
 688:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2934              		.loc 1 688 0
 2935 1884 FF1001E2 		and	r1, r1, #255
 2936              	.LVL350:
 689:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2937              		.loc 1 689 0
 2938 1888 0300000A 		beq	.L172
 690:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2939              		.loc 1 690 0
 2940 188c 080052E3 		cmp	r2, #8
 691:../uvc.c      **** 									 }else{
 2941              		.loc 1 691 0
 2942 1890 0120A003 		moveq	r2, #1
 693:../uvc.c      **** 									 }
 2943              		.loc 1 693 0
 2944 1894 0420A013 		movne	r2, #4
 2945 1898 B524C3E5 		strb	r2, [r3, #1205]
 2946              	.L172:
 696:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2947              		.loc 1 696 0
 2948 189c 070051E3 		cmp	r1, #7
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2949              		.loc 1 697 0
 2950 18a0 88309F95 		ldrls	r3, .L195+64
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2951              		.loc 1 700 0
 2952 18a4 0120A083 		movhi	r2, #1
 698:../uvc.c      **** 								 }else{
 2953              		.loc 1 698 0
 2954 18a8 81208390 		addls	r2, r3, r1, asl #1
 2955 18ac 0120D295 		ldrlsb	r2, [r2, #1]	@ zero_extendqisi2
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2956              		.loc 1 697 0
 2957 18b0 8130D397 		ldrlsb	r3, [r3, r1, asl #1]	@ zero_extendqisi2
 701:../uvc.c      **** 								 }
 2958              		.loc 1 701 0
 2959 18b4 0030A083 		movhi	r3, #0
 698:../uvc.c      **** 								 }else{
 2960              		.loc 1 698 0
 2961 18b8 E624C695 		strlsb	r2, [r6, #1254]
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2962              		.loc 1 697 0
 2963 18bc E534C695 		strlsb	r3, [r6, #1253]
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2964              		.loc 1 700 0
 2965 18c0 E524C685 		strhib	r2, [r6, #1253]
 701:../uvc.c      **** 								 }
 2966              		.loc 1 701 0
 2967 18c4 E634C685 		strhib	r3, [r6, #1254]
 2968 18c8 01FEFFEA 		b	.L170
 2969              	.LVL351:
 2970              	.L129:
 453:../uvc.c      **** 							sendData = 0; //set back to default
 2971              		.loc 1 453 0
 2972 18cc 0400A0E3 		mov	r0, #4
 2973              	.LVL352:
 2974 18d0 0120A0E3 		mov	r2, #1
 2975 18d4 3C109FE5 		ldr	r1, .L195+40
 455:../uvc.c      **** 						}
 2976              		.loc 1 455 0
 2977 18d8 0060A0E1 		mov	r6, r0
 453:../uvc.c      **** 							sendData = 0; //set back to default
 2978              		.loc 1 453 0
 2979 18dc FEFFFFEB 		bl	CyU3PDebugPrint
 2980              	.LVL353:
 455:../uvc.c      **** 						}
 2981              		.loc 1 455 0
 2982 18e0 0020A0E3 		mov	r2, #0
 2983 18e4 0630A0E1 		mov	r3, r6
 2984 18e8 2D24C4E5 		strb	r2, [r4, #1069]
 2985 18ec 89FDFFEA 		b	.L130
 2986              	.L196:
 2987              		.align	2
 2988              	.L195:
 2989 18f0 00000000 		.word	.LANCHOR1
 2990 18f4 00000000 		.word	bRequest
 2991 18f8 00000000 		.word	.LANCHOR0
 2992 18fc 9C000000 		.word	.LANCHOR0+156
 2993 1900 04030000 		.word	.LC18
 2994 1904 01000100 		.word	65537
 2995 1908 FF00FF00 		.word	16711935
 2996 190c 10020000 		.word	.LC12
 2997 1910 4C020000 		.word	.LC13
 2998 1914 00000000 		.word	cmdQu
 2999 1918 D8010000 		.word	.LC11
 3000 191c BC020000 		.word	.LC16
 3001 1920 A0020000 		.word	.LC15
 3002 1924 74020000 		.word	.LC14
 3003 1928 90000000 		.word	.LANCHOR0+144
 3004 192c D4020000 		.word	.LC17
 3005 1930 00000000 		.word	.LANCHOR2
 3006              		.cfi_endproc
 3007              	.LFE2:
 3009              		.align	2
 3010              		.global	CTControlHandle
 3012              	CTControlHandle:
 3013              	.LFB3:
 965:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3014              		.loc 1 965 0
 3015              		.cfi_startproc
 3016              		@ args = 0, pretend = 0, frame = 24
 3017              		@ frame_needed = 0, uses_anonymous_args = 0
 3018              	.LVL354:
 3019 1934 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3020              	.LCFI14:
 3021              		.cfi_def_cfa_offset 36
 3022              		.cfi_offset 4, -36
 3023              		.cfi_offset 5, -32
 3024              		.cfi_offset 6, -28
 3025              		.cfi_offset 7, -24
 3026              		.cfi_offset 8, -20
 3027              		.cfi_offset 9, -16
 3028              		.cfi_offset 10, -12
 3029              		.cfi_offset 11, -8
 3030              		.cfi_offset 14, -4
 984:../uvc.c      **** 
 3031              		.loc 1 984 0
 3032 1938 28B89FE5 		ldr	fp, .L235
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3033              		.loc 1 976 0
 3034 193c 28389FE5 		ldr	r3, .L235+4
 984:../uvc.c      **** 
 3035              		.loc 1 984 0
 3036 1940 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3037              		.loc 1 976 0
 3038 1944 8080A0E1 		mov	r8, r0, asl #1
 3039 1948 002088E0 		add	r2, r8, r0
 3040 194c 822183E0 		add	r2, r3, r2, asl #3
 986:../uvc.c      **** 		 {
 3041              		.loc 1 986 0
 3042 1950 830055E3 		cmp	r5, #131
 965:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3043              		.loc 1 965 0
 3044 1954 34D04DE2 		sub	sp, sp, #52
 3045              	.LCFI15:
 3046              		.cfi_def_cfa_offset 88
 965:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3047              		.loc 1 965 0
 3048 1958 0060A0E1 		mov	r6, r0
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3049              		.loc 1 976 0
 3050 195c 9F94D2E5 		ldrb	r9, [r2, #1183]	@ zero_extendqisi2
 3051              	.LVL355:
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 3052              		.loc 1 977 0
 3053 1960 90A4D2E5 		ldrb	r10, [r2, #1168]	@ zero_extendqisi2
 3054              	.LVL356:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 3055              		.loc 1 979 0
 3056 1964 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3057              	.LVL357:
 986:../uvc.c      **** 		 {
 3058              		.loc 1 986 0
 3059 1968 8000000A 		beq	.L199
 3060 196c 2600009A 		bls	.L233
 3061 1970 850055E3 		cmp	r5, #133
 3062 1974 7200000A 		beq	.L204
 3063 1978 5000003A 		bcc	.L205
 3064 197c 860055E3 		cmp	r5, #134
 3065 1980 4300000A 		beq	.L206
 3066 1984 870055E3 		cmp	r5, #135
 3067 1988 5F00001A 		bne	.L198
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3068              		.loc 1 1048 0
 3069 198c 9BC4D2E5 		ldrb	ip, [r2, #1179]	@ zero_extendqisi2
 3070 1990 D8479FE5 		ldr	r4, .L235+8
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3071              		.loc 1 1049 0
 3072 1994 9C24D2E5 		ldrb	r2, [r2, #1180]	@ zero_extendqisi2
 3073              	.LVL358:
 3074              	.L232:
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3075              		.loc 1 1026 0
 3076 1998 0A1056E2 		subs	r1, r6, #10
 3077 199c 006071E2 		rsbs	r6, r1, #0
 3078 19a0 0160B6E0 		adcs	r6, r6, r1
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3079              		.loc 1 1028 0
 3080 19a4 0030A0E3 		mov	r3, #0
 3081              	.LVL359:
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3082              		.loc 1 1029 0
 3083 19a8 9C1084E2 		add	r1, r4, #156
 3084 19ac 0700A0E1 		mov	r0, r7
 3085              	.LVL360:
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3086              		.loc 1 1026 0
 3087 19b0 9E60C4E5 		strb	r6, [r4, #158]
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3088              		.loc 1 1024 0
 3089 19b4 9CC0C4E5 		strb	ip, [r4, #156]
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3090              		.loc 1 1025 0
 3091 19b8 9D20C4E5 		strb	r2, [r4, #157]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3092              		.loc 1 1028 0
 3093 19bc 9F30C4E5 		strb	r3, [r4, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3094              		.loc 1 1029 0
 3095 19c0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3096              	.LVL361:
 3097 19c4 9C00D4E5 		ldrb	r0, [r4, #156]	@ zero_extendqisi2
1031:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 3098              		.loc 1 1031 0
 3099 19c8 FF80A0E3 		mov	r8, #255
 3100 19cc 0860A0E1 		mov	r6, r8
 3101              	.LVL362:
 3102              	.L208:
1199:../uvc.c      **** }
 3103              		.loc 1 1199 0
 3104 19d0 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 3105 19d4 FFC0A0E3 		mov	ip, #255
 3106 19d8 04108DE5 		str	r1, [sp, #4]
 3107 19dc 10108DE5 		str	r1, [sp, #16]
 3108 19e0 08008DE5 		str	r0, [sp, #8]
 3109 19e4 00808DE5 		str	r8, [sp]
 3110 19e8 14708DE5 		str	r7, [sp, #20]
 3111 19ec 0520A0E1 		mov	r2, r5
 3112 19f0 0630A0E1 		mov	r3, r6
 3113 19f4 0CC08DE5 		str	ip, [sp, #12]
 3114 19f8 74179FE5 		ldr	r1, .L235+12
 3115 19fc 0400A0E3 		mov	r0, #4
 3116 1a00 FEFFFFEB 		bl	CyU3PDebugPrint
 3117              	.LVL363:
1200:../uvc.c      **** 
 3118              		.loc 1 1200 0
 3119 1a04 34D08DE2 		add	sp, sp, #52
 3120              		@ sp needed
 3121 1a08 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 3122              	.LVL364:
 3123              	.L233:
 986:../uvc.c      **** 		 {
 3124              		.loc 1 986 0
 3125 1a0c 810055E3 		cmp	r5, #129
 3126 1a10 2E00000A 		beq	.L201
 3127 1a14 1A00008A 		bhi	.L202
 3128 1a18 010055E3 		cmp	r5, #1
 3129 1a1c 3A00001A 		bne	.L198
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 3130              		.loc 1 1057 0
 3131 1a20 48479FE5 		ldr	r4, .L235+8
 3132 1a24 2E208DE2 		add	r2, sp, #46
 3133              	.LVL365:
 3134 1a28 2000A0E3 		mov	r0, #32
 3135              	.LVL366:
 3136 1a2c 9C1084E2 		add	r1, r4, #156
 3137 1a30 18308DE5 		str	r3, [sp, #24]
 3138 1a34 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3139              	.LVL367:
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3140              		.loc 1 1059 0
 3141 1a38 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
1063:../uvc.c      **** 			  {
 3142              		.loc 1 1063 0
 3143 1a3c 012046E2 		sub	r2, r6, #1
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3144              		.loc 1 1059 0
 3145 1a40 1CC08DE5 		str	ip, [sp, #28]
 3146              	.LVL368:
1060:../uvc.c      **** 			  value = Data1;
 3147              		.loc 1 1060 0
 3148 1a44 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
1063:../uvc.c      **** 			  {
 3149              		.loc 1 1063 0
 3150 1a48 18309DE5 		ldr	r3, [sp, #24]
1060:../uvc.c      **** 			  value = Data1;
 3151              		.loc 1 1060 0
 3152 1a4c 20C08DE5 		str	ip, [sp, #32]
 3153              	.LVL369:
1063:../uvc.c      **** 			  {
 3154              		.loc 1 1063 0
 3155 1a50 090052E3 		cmp	r2, #9
 3156 1a54 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3157 1a58 1D0100EA 		b	.L209
 3158              	.L211:
 3159 1a5c 8C1E0000 		.word	.L210
 3160 1a60 D41E0000 		.word	.L209
 3161 1a64 8C1C0000 		.word	.L212
 3162 1a68 D41E0000 		.word	.L209
 3163 1a6c D41E0000 		.word	.L209
 3164 1a70 D41E0000 		.word	.L209
 3165 1a74 FC1B0000 		.word	.L213
 3166 1a78 D41E0000 		.word	.L209
 3167 1a7c D41E0000 		.word	.L209
 3168 1a80 801B0000 		.word	.L214
 3169              	.LVL370:
 3170              	.L202:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3171              		.loc 1 1015 0
 3172 1a84 93C4D2E5 		ldrb	ip, [r2, #1171]	@ zero_extendqisi2
 3173 1a88 E0469FE5 		ldr	r4, .L235+8
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3174              		.loc 1 1016 0
 3175 1a8c 9424D2E5 		ldrb	r2, [r2, #1172]	@ zero_extendqisi2
 3176              	.LVL371:
 3177 1a90 C0FFFFEA 		b	.L232
 3178              	.LVL372:
 3179              	.L206:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3180              		.loc 1 1042 0
 3181 1a94 D4469FE5 		ldr	r4, .L235+8
 3182 1a98 9934D2E5 		ldrb	r3, [r2, #1177]	@ zero_extendqisi2
 3183 1a9c 0410A0E1 		mov	r1, r4
 3184 1aa0 9C30E1E5 		strb	r3, [r1, #156]!
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3185              		.loc 1 1043 0
 3186 1aa4 0100A0E3 		mov	r0, #1
 3187              	.LVL373:
1046:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3188              		.loc 1 1046 0
 3189 1aa8 FF80A0E3 		mov	r8, #255
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3190              		.loc 1 1043 0
 3191 1aac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3192              	.LVL374:
1046:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3193              		.loc 1 1046 0
 3194 1ab0 0860A0E1 		mov	r6, r8
 3195 1ab4 9C00D4E5 		ldrb	r0, [r4, #156]	@ zero_extendqisi2
 3196 1ab8 0170A0E3 		mov	r7, #1
 3197 1abc C3FFFFEA 		b	.L208
 3198              	.LVL375:
 3199              	.L205:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3200              		.loc 1 1033 0
 3201 1ac0 97C4D2E5 		ldrb	ip, [r2, #1175]	@ zero_extendqisi2
 3202 1ac4 A4469FE5 		ldr	r4, .L235+8
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3203              		.loc 1 1034 0
 3204 1ac8 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 3205              	.LVL376:
 3206 1acc B1FFFFEA 		b	.L232
 3207              	.LVL377:
 3208              	.L201:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3209              		.loc 1 1000 0
 3210 1ad0 98469FE5 		ldr	r4, .L235+8
 3211 1ad4 9D94D2E5 		ldrb	r9, [r2, #1181]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3212              		.loc 1 1001 0
 3213 1ad8 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3214              		.loc 1 1002 0
 3215 1adc 0030A0E3 		mov	r3, #0
1008:../uvc.c      **** 
 3216              		.loc 1 1008 0
 3217 1ae0 9C1084E2 		add	r1, r4, #156
 3218 1ae4 0700A0E1 		mov	r0, r7
 3219              	.LVL378:
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3220              		.loc 1 1013 0
 3221 1ae8 FF80A0E3 		mov	r8, #255
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3222              		.loc 1 1001 0
 3223 1aec 9DC0C4E5 		strb	ip, [r4, #157]
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3224              		.loc 1 1000 0
 3225 1af0 9C90C4E5 		strb	r9, [r4, #156]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3226              		.loc 1 1002 0
 3227 1af4 9E30C4E5 		strb	r3, [r4, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3228              		.loc 1 1003 0
 3229 1af8 9F30C4E5 		strb	r3, [r4, #159]
 3230              	.LVL379:
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3231              		.loc 1 1013 0
 3232 1afc 0860A0E1 		mov	r6, r8
 3233              	.LVL380:
1008:../uvc.c      **** 
 3234              		.loc 1 1008 0
 3235 1b00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3236              	.LVL381:
 3237 1b04 0900A0E1 		mov	r0, r9
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3238              		.loc 1 1013 0
 3239 1b08 B0FFFFEA 		b	.L208
 3240              	.LVL382:
 3241              	.L198:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3242              		.loc 1 1193 0
 3243 1b0c 0000A0E3 		mov	r0, #0
 3244              	.LVL383:
 3245 1b10 0020A0E1 		mov	r2, r0
 3246              	.LVL384:
 3247 1b14 0110A0E3 		mov	r1, #1
 3248 1b18 FEFFFFEB 		bl	CyU3PUsbStall
 3249              	.LVL385:
1194:../uvc.c      **** 			  break;
 3250              		.loc 1 1194 0
 3251 1b1c 0620A0E1 		mov	r2, r6
 3252 1b20 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 3253 1b24 0400A0E3 		mov	r0, #4
 3254 1b28 48169FE5 		ldr	r1, .L235+16
 3255 1b2c FEFFFFEB 		bl	CyU3PDebugPrint
 3256              	.LVL386:
1195:../uvc.c      **** 		 }
 3257              		.loc 1 1195 0
 3258 1b30 FF00A0E3 		mov	r0, #255
 3259 1b34 34469FE5 		ldr	r4, .L235+8
 3260 1b38 0080A0E1 		mov	r8, r0
 3261 1b3c 0060A0E1 		mov	r6, r0
 3262 1b40 A2FFFFEA 		b	.L208
 3263              	.LVL387:
 3264              	.L204:
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3265              		.loc 1 990 0
 3266 1b44 24469FE5 		ldr	r4, .L235+8
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3267              		.loc 1 991 0
 3268 1b48 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3269              		.loc 1 992 0
 3270 1b4c 9C1084E2 		add	r1, r4, #156
 3271 1b50 0200A0E3 		mov	r0, #2
 3272              	.LVL388:
 994:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3273              		.loc 1 994 0
 3274 1b54 FF80A0E3 		mov	r8, #255
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3275              		.loc 1 990 0
 3276 1b58 9C70C4E5 		strb	r7, [r4, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3277              		.loc 1 991 0
 3278 1b5c 9D30C4E5 		strb	r3, [r4, #157]
 994:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3279              		.loc 1 994 0
 3280 1b60 0860A0E1 		mov	r6, r8
 3281              	.LVL389:
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3282              		.loc 1 992 0
 3283 1b64 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3284              	.LVL390:
 3285 1b68 9C00D4E5 		ldrb	r0, [r4, #156]	@ zero_extendqisi2
 994:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3286              		.loc 1 994 0
 3287 1b6c 97FFFFEA 		b	.L208
 3288              	.LVL391:
 3289              	.L199:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3290              		.loc 1 1024 0
 3291 1b70 95C4D2E5 		ldrb	ip, [r2, #1173]	@ zero_extendqisi2
 3292 1b74 F4459FE5 		ldr	r4, .L235+8
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3293              		.loc 1 1025 0
 3294 1b78 9624D2E5 		ldrb	r2, [r2, #1174]	@ zero_extendqisi2
 3295              	.LVL392:
 3296 1b7c 85FFFFEA 		b	.L232
 3297              	.LVL393:
 3298              	.L214:
1172:../uvc.c      **** 					  if(getData == 1)
 3299              		.loc 1 1172 0
 3300 1b80 F4659FE5 		ldr	r6, .L235+20
 3301 1b84 0010E0E3 		mvn	r1, #0
 3302 1b88 1C0096E5 		ldr	r0, [r6, #28]
 3303 1b8c FEFFFFEB 		bl	_txe_mutex_get
 3304              	.LVL394:
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3305              		.loc 1 1173 0
 3306 1b90 1CC09DE5 		ldr	ip, [sp, #28]
 3307 1b94 01005CE3 		cmp	ip, #1
1174:../uvc.c      **** 					  else if(getData == 0xff)
 3308              		.loc 1 1174 0
 3309 1b98 0400A003 		moveq	r0, #4
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3310              		.loc 1 1173 0
 3311 1b9c 6901000A 		beq	.L231
1175:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3312              		.loc 1 1175 0
 3313 1ba0 FF005CE3 		cmp	ip, #255
 3314 1ba4 6601000A 		beq	.L234
1178:../uvc.c      **** 					  //dataIdx++;
 3315              		.loc 1 1178 0
 3316 1ba8 0010A0E3 		mov	r1, #0
 3317 1bac 00108DE5 		str	r1, [sp]
 3318 1bb0 04108DE5 		str	r1, [sp, #4]
 3319 1bb4 0A20A0E1 		mov	r2, r10
 3320 1bb8 0930A0E1 		mov	r3, r9
 3321 1bbc 0600A0E1 		mov	r0, r6
 3322 1bc0 2310A0E3 		mov	r1, #35
 3323 1bc4 FEFFFFEB 		bl	cmdSet
 3324              	.LVL395:
 3325              	.L226:
1181:../uvc.c      **** #endif
 3326              		.loc 1 1181 0
 3327 1bc8 1C0096E5 		ldr	r0, [r6, #28]
 3328 1bcc FEFFFFEB 		bl	_txe_mutex_put
 3329              	.LVL396:
1183:../uvc.c      **** 					  break;
 3330              		.loc 1 1183 0
 3331 1bd0 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 3332 1bd4 1C609DE5 		ldr	r6, [sp, #28]
 3333 1bd8 20809DE5 		ldr	r8, [sp, #32]
 3334 1bdc 00108DE5 		str	r1, [sp]
 3335 1be0 0620A0E1 		mov	r2, r6
 3336 1be4 0830A0E1 		mov	r3, r8
 3337 1be8 0400A0E3 		mov	r0, #4
 3338 1bec 8C159FE5 		ldr	r1, .L235+24
 3339 1bf0 FEFFFFEB 		bl	CyU3PDebugPrint
 3340              	.LVL397:
1184:../uvc.c      **** 
 3341              		.loc 1 1184 0
 3342 1bf4 FF00A0E3 		mov	r0, #255
 3343 1bf8 74FFFFEA 		b	.L208
 3344              	.LVL398:
 3345              	.L213:
1149:../uvc.c      **** 					  {
 3346              		.loc 1 1149 0
 3347 1bfc B504D3E5 		ldrb	r0, [r3, #1205]	@ zero_extendqisi2
 3348 1c00 64C59FE5 		ldr	ip, .L235+4
 3349 1c04 010050E3 		cmp	r0, #1
 3350 1c08 08005013 		cmpne	r0, #8
 3351 1c0c 0000A013 		movne	r0, #0
 3352 1c10 0100A003 		moveq	r0, #1
 3353 1c14 4601001A 		bne	.L223
 3354              	.LVL399:
1152:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3355              		.loc 1 1152 0
 3356 1c18 5CB59FE5 		ldr	fp, .L235+20
 3357 1c1c 0010E0E3 		mvn	r1, #0
 3358 1c20 1C009BE5 		ldr	r0, [fp, #28]
 3359 1c24 18C08DE5 		str	ip, [sp, #24]
 3360 1c28 FEFFFFEB 		bl	_txe_mutex_get
 3361              	.LVL400:
1153:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3362              		.loc 1 1153 0
 3363 1c2c 1C009DE5 		ldr	r0, [sp, #28]
 3364 1c30 0010A0E3 		mov	r1, #0
 3365 1c34 0A20A0E1 		mov	r2, r10
 3366 1c38 0930A0E1 		mov	r3, r9
 3367 1c3c 00008DE5 		str	r0, [sp]
 3368 1c40 04108DE5 		str	r1, [sp, #4]
 3369 1c44 0B00A0E1 		mov	r0, fp
 3370 1c48 2210A0E3 		mov	r1, #34
 3371 1c4c FEFFFFEB 		bl	cmdSet
 3372              	.LVL401:
1154:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 3373              		.loc 1 1154 0
 3374 1c50 1C009BE5 		ldr	r0, [fp, #28]
 3375 1c54 FEFFFFEB 		bl	_txe_mutex_put
 3376              	.LVL402:
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3377              		.loc 1 1157 0
 3378 1c58 18C09DE5 		ldr	ip, [sp, #24]
 3379 1c5c 1C109DE5 		ldr	r1, [sp, #28]
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3380              		.loc 1 1158 0
 3381 1c60 20209DE5 		ldr	r2, [sp, #32]
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3382              		.loc 1 1157 0
 3383 1c64 066088E0 		add	r6, r8, r6
 3384 1c68 86C18CE0 		add	ip, ip, r6, asl #3
1159:../uvc.c      **** 					  }else{
 3385              		.loc 1 1159 0
 3386 1c6c 0130A0E3 		mov	r3, #1
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3387              		.loc 1 1157 0
 3388 1c70 9D14CCE5 		strb	r1, [ip, #1181]
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3389              		.loc 1 1158 0
 3390 1c74 9E24CCE5 		strb	r2, [ip, #1182]
1159:../uvc.c      **** 					  }else{
 3391              		.loc 1 1159 0
 3392 1c78 A034CCE5 		strb	r3, [ip, #1184]
 3393              	.LVL403:
 3394              	.L224:
 3395 1c7c 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 3396 1c80 9D80D4E5 		ldrb	r8, [r4, #157]	@ zero_extendqisi2
1166:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 3397              		.loc 1 1166 0
 3398 1c84 FF00A0E3 		mov	r0, #255
 3399 1c88 50FFFFEA 		b	.L208
 3400              	.LVL404:
 3401              	.L212:
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3402              		.loc 1 1115 0
 3403 1c8c B534D3E5 		ldrb	r3, [r3, #1205]	@ zero_extendqisi2
 3404 1c90 010053E3 		cmp	r3, #1
 3405 1c94 04005313 		cmpne	r3, #4
 3406 1c98 2001001A 		bne	.L221
1114:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3407              		.loc 1 1114 0
 3408 1c9c 1CC09DE5 		ldr	ip, [sp, #28]
 3409 1ca0 20009DE5 		ldr	r0, [sp, #32]
 3410 1ca4 00348CE1 		orr	r3, ip, r0, asl #8
1116:../uvc.c      **** 					  {
 3411              		.loc 1 1116 0
 3412 1ca8 F90053E3 		cmp	r3, #249
 3413 1cac 1B01008A 		bhi	.L221
 3414              	.LVL405:
1121:../uvc.c      **** 							}else{
 3415              		.loc 1 1121 0
 3416 1cb0 C80043E2 		sub	r0, r3, #200
 3417 1cb4 C80053E3 		cmp	r3, #200
1123:../uvc.c      **** 							}
 3418              		.loc 1 1123 0
 3419 1cb8 C82063E2 		rsb	r2, r3, #200
 3420 1cbc C0149FE5 		ldr	r1, .L235+28
 3421 1cc0 0208A091 		movls	r0, r2, asl #16
 3422 1cc4 0008A081 		movhi	r0, r0, asl #16
 3423 1cc8 642063E2 		rsb	r2, r3, #100
 3424 1ccc 640053E3 		cmp	r3, #100
1121:../uvc.c      **** 							}else{
 3425              		.loc 1 1121 0
 3426 1cd0 64C043E2 		sub	ip, r3, #100
 3427 1cd4 2008A0E1 		mov	r0, r0, lsr #16
 3428 1cd8 0C28A081 		movhi	r2, ip, asl #16
 3429 1cdc 0228A091 		movls	r2, r2, asl #16
 3430 1ce0 010050E1 		cmp	r0, r1
 3431 1ce4 00E0A031 		movcc	lr, r0
 3432 1ce8 01E0A021 		movcs	lr, r1
 3433 1cec 010050E1 		cmp	r0, r1
 3434 1cf0 27C043E2 		sub	ip, r3, #39
1123:../uvc.c      **** 							}
 3435              		.loc 1 1123 0
 3436 1cf4 271063E2 		rsb	r1, r3, #39
 3437 1cf8 00B0A033 		movcc	fp, #0
 3438 1cfc 01B0A023 		movcs	fp, #1
 3439 1d00 270053E3 		cmp	r3, #39
1121:../uvc.c      **** 							}else{
 3440              		.loc 1 1121 0
 3441 1d04 140043E2 		sub	r0, r3, #20
 3442 1d08 01C8A091 		movls	ip, r1, asl #16
 3443 1d0c 2228A0E1 		mov	r2, r2, lsr #16
1123:../uvc.c      **** 							}
 3444              		.loc 1 1123 0
 3445 1d10 141063E2 		rsb	r1, r3, #20
 3446 1d14 0CC8A081 		movhi	ip, ip, asl #16
 3447 1d18 140053E3 		cmp	r3, #20
 3448 1d1c 0018A081 		movhi	r1, r0, asl #16
 3449 1d20 0118A091 		movls	r1, r1, asl #16
 3450 1d24 0E0052E1 		cmp	r2, lr
1121:../uvc.c      **** 							}else{
 3451              		.loc 1 1121 0
 3452 1d28 0A0043E2 		sub	r0, r3, #10
 3453 1d2c 01B0A033 		movcc	fp, #1
 3454 1d30 2CC8A0E1 		mov	ip, ip, lsr #16
 3455 1d34 02005EE1 		cmp	lr, r2
 3456 1d38 0E20A031 		movcc	r2, lr
 3457 1d3c 0A0053E3 		cmp	r3, #10
 3458 1d40 21E8A0E1 		mov	lr, r1, lsr #16
1123:../uvc.c      **** 							}
 3459              		.loc 1 1123 0
 3460 1d44 0A1063E2 		rsb	r1, r3, #10
 3461 1d48 0118A091 		movls	r1, r1, asl #16
 3462 1d4c 0018A081 		movhi	r1, r0, asl #16
 3463 1d50 0C0052E1 		cmp	r2, ip
 3464 1d54 02B0A083 		movhi	fp, #2
 3465 1d58 24B08DE5 		str	fp, [sp, #36]
1121:../uvc.c      **** 							}else{
 3466              		.loc 1 1121 0
 3467 1d5c 050043E2 		sub	r0, r3, #5
 3468 1d60 02005CE1 		cmp	ip, r2
 3469 1d64 0C20A031 		movcc	r2, ip
 3470 1d68 21B8A0E1 		mov	fp, r1, lsr #16
1123:../uvc.c      **** 							}
 3471              		.loc 1 1123 0
 3472 1d6c 05C063E2 		rsb	ip, r3, #5
 3473 1d70 050053E3 		cmp	r3, #5
 3474 1d74 24109DE5 		ldr	r1, [sp, #36]
 3475 1d78 00C8A081 		movhi	ip, r0, asl #16
 3476 1d7c 0CC8A091 		movls	ip, ip, asl #16
 3477 1d80 0E0052E1 		cmp	r2, lr
 3478 1d84 0310A083 		movhi	r1, #3
 3479 1d88 24108DE5 		str	r1, [sp, #36]
 3480 1d8c 02005EE1 		cmp	lr, r2
 3481 1d90 0E00A031 		movcc	r0, lr
 3482 1d94 0200A021 		movcs	r0, r2
 3483 1d98 021063E2 		rsb	r1, r3, #2
1121:../uvc.c      **** 							}else{
 3484              		.loc 1 1121 0
 3485 1d9c 022043E2 		sub	r2, r3, #2
 3486 1da0 020053E3 		cmp	r3, #2
 3487 1da4 0128A091 		movls	r2, r1, asl #16
 3488 1da8 0228A081 		movhi	r2, r2, asl #16
 3489 1dac 0B0050E1 		cmp	r0, fp
 3490 1db0 24E09DE5 		ldr	lr, [sp, #36]
 3491 1db4 2CC8A0E1 		mov	ip, ip, lsr #16
 3492 1db8 04E0A083 		movhi	lr, #4
 3493 1dbc 00005BE1 		cmp	fp, r0
 3494 1dc0 0B00A031 		movcc	r0, fp
 3495 1dc4 00005CE1 		cmp	ip, r0
 3496 1dc8 0C10A031 		movcc	r1, ip
 3497 1dcc 0010A021 		movcs	r1, r0
 3498 1dd0 0C0050E1 		cmp	r0, ip
 3499 1dd4 05E0A083 		movhi	lr, #5
 3500 1dd8 01C043E2 		sub	ip, r3, #1
 3501 1ddc 010053E3 		cmp	r3, #1
1123:../uvc.c      **** 							}
 3502              		.loc 1 1123 0
 3503 1de0 010063E2 		rsb	r0, r3, #1
 3504 1de4 0C38A081 		movhi	r3, ip, asl #16
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3505              		.loc 1 1133 0
 3506 1de8 8CC39FE5 		ldr	ip, .L235+20
 3507 1dec 2228A0E1 		mov	r2, r2, lsr #16
 3508 1df0 0038A091 		movls	r3, r0, asl #16
 3509 1df4 010052E1 		cmp	r2, r1
 3510 1df8 0200A031 		movcc	r0, r2
 3511 1dfc 0100A021 		movcs	r0, r1
 3512 1e00 020051E1 		cmp	r1, r2
 3513 1e04 0E20A091 		movls	r2, lr
 3514 1e08 0620A083 		movhi	r2, #6
 3515              	.LVL406:
 3516 1e0c 0010E0E3 		mvn	r1, #0
 3517              	.LVL407:
 3518 1e10 230850E1 		cmp	r0, r3, lsr #16
 3519 1e14 1C009CE5 		ldr	r0, [ip, #28]
 3520 1e18 02B0A091 		movls	fp, r2
 3521 1e1c 07B0A083 		movhi	fp, #7
 3522              	.LVL408:
 3523 1e20 18C08DE5 		str	ip, [sp, #24]
 3524 1e24 FEFFFFEB 		bl	_txe_mutex_get
 3525              	.LVL409:
1134:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3526              		.loc 1 1134 0
 3527 1e28 18C09DE5 		ldr	ip, [sp, #24]
1130:../uvc.c      **** 
 3528              		.loc 1 1130 0
 3529 1e2c 01B08BE2 		add	fp, fp, #1
 3530              	.LVL410:
1134:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3531              		.loc 1 1134 0
 3532 1e30 0010A0E3 		mov	r1, #0
 3533 1e34 0A20A0E1 		mov	r2, r10
 3534 1e38 0930A0E1 		mov	r3, r9
 3535 1e3c 0C00A0E1 		mov	r0, ip
 3536 1e40 04108DE5 		str	r1, [sp, #4]
 3537 1e44 00B08DE5 		str	fp, [sp]
 3538 1e48 0310A0E3 		mov	r1, #3
 3539 1e4c FEFFFFEB 		bl	cmdSet
 3540              	.LVL411:
1135:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 3541              		.loc 1 1135 0
 3542 1e50 18C09DE5 		ldr	ip, [sp, #24]
 3543 1e54 1C009CE5 		ldr	r0, [ip, #28]
 3544 1e58 FEFFFFEB 		bl	_txe_mutex_put
 3545              	.LVL412:
1141:../uvc.c      **** 					  }else{
 3546              		.loc 1 1141 0
 3547 1e5c 08C39FE5 		ldr	ip, .L235+4
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3548              		.loc 1 1138 0
 3549 1e60 04239FE5 		ldr	r2, .L235+4
1141:../uvc.c      **** 					  }else{
 3550              		.loc 1 1141 0
 3551 1e64 0DB3CCE5 		strb	fp, [ip, #781]
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3552              		.loc 1 1138 0
 3553 1e68 1CC09DE5 		ldr	ip, [sp, #28]
 3554 1e6c 063088E0 		add	r3, r8, r6
 3555 1e70 833182E0 		add	r3, r2, r3, asl #3
 3556 1e74 9DC4C3E5 		strb	ip, [r3, #1181]
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3557              		.loc 1 1139 0
 3558 1e78 20C09DE5 		ldr	ip, [sp, #32]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3559              		.loc 1 1140 0
 3560 1e7c 0120A0E3 		mov	r2, #1
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3561              		.loc 1 1139 0
 3562 1e80 9EC4C3E5 		strb	ip, [r3, #1182]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3563              		.loc 1 1140 0
 3564 1e84 A024C3E5 		strb	r2, [r3, #1184]
1141:../uvc.c      **** 					  }else{
 3565              		.loc 1 1141 0
 3566 1e88 7BFFFFEA 		b	.L224
 3567              	.LVL413:
 3568              	.L210:
1072:../uvc.c      **** 						case 1:
 3569              		.loc 1 1072 0
 3570 1e8c 1CC09DE5 		ldr	ip, [sp, #28]
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3571              		.loc 1 1068 0
 3572 1e90 066088E0 		add	r6, r8, r6
 3573 1e94 866183E0 		add	r6, r3, r6, asl #3
1069:../uvc.c      **** 				    getData = glEp0Buffer[0];
 3574              		.loc 1 1069 0
 3575 1e98 0110A0E3 		mov	r1, #1
1072:../uvc.c      **** 						case 1:
 3576              		.loc 1 1072 0
 3577 1e9c 01204CE2 		sub	r2, ip, #1
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3578              		.loc 1 1068 0
 3579 1ea0 9DC4C6E5 		strb	ip, [r6, #1181]
1069:../uvc.c      **** 				    getData = glEp0Buffer[0];
 3580              		.loc 1 1069 0
 3581 1ea4 A014C6E5 		strb	r1, [r6, #1184]
 3582              	.LVL414:
1072:../uvc.c      **** 						case 1:
 3583              		.loc 1 1072 0
 3584 1ea8 070052E3 		cmp	r2, #7
 3585 1eac 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3586 1eb0 960000EA 		b	.L215
 3587              	.L217:
 3588 1eb4 AC200000 		.word	.L216
 3589 1eb8 10200000 		.word	.L218
 3590 1ebc 10210000 		.word	.L215
 3591 1ec0 A81F0000 		.word	.L219
 3592 1ec4 10210000 		.word	.L215
 3593 1ec8 10210000 		.word	.L215
 3594 1ecc 10210000 		.word	.L215
 3595 1ed0 081F0000 		.word	.L220
 3596              	.LVL415:
 3597              	.L209:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3598              		.loc 1 1187 0
 3599 1ed4 1CC09DE5 		ldr	ip, [sp, #28]
 3600 1ed8 068088E0 		add	r8, r8, r6
 3601 1edc 888183E0 		add	r8, r3, r8, asl #3
1188:../uvc.c      **** 			  		 break;
 3602              		.loc 1 1188 0
 3603 1ee0 0620A0E1 		mov	r2, r6
 3604 1ee4 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 3605 1ee8 0400A0E3 		mov	r0, #4
 3606 1eec 94129FE5 		ldr	r1, .L235+32
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3607              		.loc 1 1187 0
 3608 1ef0 9DC4C8E5 		strb	ip, [r8, #1181]
1188:../uvc.c      **** 			  		 break;
 3609              		.loc 1 1188 0
 3610 1ef4 FEFFFFEB 		bl	CyU3PDebugPrint
 3611              	.LVL416:
1189:../uvc.c      **** 			  }
 3612              		.loc 1 1189 0
 3613 1ef8 FF00A0E3 		mov	r0, #255
 3614 1efc 0080A0E1 		mov	r8, r0
 3615 1f00 0060A0E1 		mov	r6, r0
 3616 1f04 B1FEFFEA 		b	.L208
 3617              	.LVL417:
 3618              	.L220:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3619              		.loc 1 1091 0
 3620 1f08 6C629FE5 		ldr	r6, .L235+20
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 3621              		.loc 1 1089 0
 3622 1f0c 0080A0E3 		mov	r8, #0
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3623              		.loc 1 1091 0
 3624 1f10 1C0096E5 		ldr	r0, [r6, #28]
 3625 1f14 0010E0E3 		mvn	r1, #0
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 3626              		.loc 1 1089 0
 3627 1f18 0D83C3E5 		strb	r8, [r3, #781]
 3628              	.LVL418:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3629              		.loc 1 1091 0
 3630 1f1c FEFFFFEB 		bl	_txe_mutex_get
 3631              	.LVL419:
1092:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3632              		.loc 1 1092 0
 3633 1f20 0A20A0E1 		mov	r2, r10
 3634 1f24 0930A0E1 		mov	r3, r9
 3635 1f28 1010A0E3 		mov	r1, #16
 3636 1f2c 00808DE5 		str	r8, [sp]
 3637 1f30 04808DE5 		str	r8, [sp, #4]
 3638 1f34 0600A0E1 		mov	r0, r6
 3639 1f38 FEFFFFEB 		bl	cmdSet
 3640              	.LVL420:
1093:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 3641              		.loc 1 1093 0
 3642 1f3c 1C0096E5 		ldr	r0, [r6, #28]
 3643 1f40 FEFFFFEB 		bl	_txe_mutex_put
 3644              	.LVL421:
 3645              	.LBB78:
 3646              	.LBB79:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3647              		.loc 1 390 0
 3648 1f44 1C0096E5 		ldr	r0, [r6, #28]
 3649 1f48 0010E0E3 		mvn	r1, #0
 3650 1f4c FEFFFFEB 		bl	_txe_mutex_get
 3651              	.LVL422:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3652              		.loc 1 391 0
 3653 1f50 0130A0E3 		mov	r3, #1
 3654 1f54 04808DE5 		str	r8, [sp, #4]
 3655 1f58 0600A0E1 		mov	r0, r6
 3656 1f5c 00308DE5 		str	r3, [sp]
 3657 1f60 2010A0E3 		mov	r1, #32
 3658 1f64 2720A0E3 		mov	r2, #39
 3659 1f68 3030A0E3 		mov	r3, #48
 3660 1f6c FEFFFFEB 		bl	cmdSet
 3661              	.LVL423:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3662              		.loc 1 392 0
 3663 1f70 0230A0E3 		mov	r3, #2
 3664 1f74 04808DE5 		str	r8, [sp, #4]
 3665 1f78 0600A0E1 		mov	r0, r6
 3666 1f7c 00308DE5 		str	r3, [sp]
 3667 1f80 2110A0E3 		mov	r1, #33
 3668 1f84 2520A0E3 		mov	r2, #37
 3669 1f88 3030A0E3 		mov	r3, #48
 3670 1f8c FEFFFFEB 		bl	cmdSet
 3671              	.LVL424:
 393:../uvc.c      **** }
 3672              		.loc 1 393 0
 3673 1f90 1C0096E5 		ldr	r0, [r6, #28]
 3674 1f94 FEFFFFEB 		bl	_txe_mutex_put
 3675              	.LVL425:
 3676 1f98 FF00A0E3 		mov	r0, #255
 3677 1f9c 0080A0E1 		mov	r8, r0
 3678 1fa0 0860A0E3 		mov	r6, #8
 3679 1fa4 89FEFFEA 		b	.L208
 3680              	.LVL426:
 3681              	.L219:
 3682              	.LBE79:
 3683              	.LBE78:
 3684              	.LBB80:
 3685              	.LBB81:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3686              		.loc 1 390 0
 3687 1fa8 CC619FE5 		ldr	r6, .L235+20
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3688              		.loc 1 391 0
 3689 1fac 0080A0E3 		mov	r8, #0
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3690              		.loc 1 390 0
 3691 1fb0 0010E0E3 		mvn	r1, #0
 3692 1fb4 1C0096E5 		ldr	r0, [r6, #28]
 3693 1fb8 FEFFFFEB 		bl	_txe_mutex_get
 3694              	.LVL427:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3695              		.loc 1 391 0
 3696 1fbc 0600A0E1 		mov	r0, r6
 3697 1fc0 00808DE5 		str	r8, [sp]
 3698 1fc4 04808DE5 		str	r8, [sp, #4]
 3699 1fc8 2010A0E3 		mov	r1, #32
 3700 1fcc 2720A0E3 		mov	r2, #39
 3701 1fd0 3030A0E3 		mov	r3, #48
 3702 1fd4 FEFFFFEB 		bl	cmdSet
 3703              	.LVL428:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3704              		.loc 1 392 0
 3705 1fd8 0130A0E3 		mov	r3, #1
 3706 1fdc 04808DE5 		str	r8, [sp, #4]
 3707 1fe0 0600A0E1 		mov	r0, r6
 3708 1fe4 00308DE5 		str	r3, [sp]
 3709 1fe8 2110A0E3 		mov	r1, #33
 3710 1fec 2520A0E3 		mov	r2, #37
 3711 1ff0 3030A0E3 		mov	r3, #48
 3712 1ff4 FEFFFFEB 		bl	cmdSet
 3713              	.LVL429:
 393:../uvc.c      **** }
 3714              		.loc 1 393 0
 3715 1ff8 1C0096E5 		ldr	r0, [r6, #28]
 3716 1ffc FEFFFFEB 		bl	_txe_mutex_put
 3717              	.LVL430:
 3718 2000 FF00A0E3 		mov	r0, #255
 3719 2004 0080A0E1 		mov	r8, r0
 3720 2008 0460A0E3 		mov	r6, #4
 3721 200c 6FFEFFEA 		b	.L208
 3722              	.LVL431:
 3723              	.L218:
 3724              	.LBE81:
 3725              	.LBE80:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3726              		.loc 1 1079 0
 3727 2010 64619FE5 		ldr	r6, .L235+20
1077:../uvc.c      **** 							dataIdx = 0;
 3728              		.loc 1 1077 0
 3729 2014 0080A0E3 		mov	r8, #0
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3730              		.loc 1 1079 0
 3731 2018 1C0096E5 		ldr	r0, [r6, #28]
 3732 201c 0010E0E3 		mvn	r1, #0
1077:../uvc.c      **** 							dataIdx = 0;
 3733              		.loc 1 1077 0
 3734 2020 0D83C3E5 		strb	r8, [r3, #781]
 3735              	.LVL432:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3736              		.loc 1 1079 0
 3737 2024 FEFFFFEB 		bl	_txe_mutex_get
 3738              	.LVL433:
1080:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3739              		.loc 1 1080 0
 3740 2028 0A20A0E1 		mov	r2, r10
 3741 202c 0930A0E1 		mov	r3, r9
 3742 2030 1010A0E3 		mov	r1, #16
 3743 2034 00808DE5 		str	r8, [sp]
 3744 2038 04808DE5 		str	r8, [sp, #4]
 3745 203c 0600A0E1 		mov	r0, r6
 3746 2040 FEFFFFEB 		bl	cmdSet
 3747              	.LVL434:
1081:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 3748              		.loc 1 1081 0
 3749 2044 1C0096E5 		ldr	r0, [r6, #28]
 3750 2048 FEFFFFEB 		bl	_txe_mutex_put
 3751              	.LVL435:
 3752              	.LBB82:
 3753              	.LBB83:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3754              		.loc 1 390 0
 3755 204c 1C0096E5 		ldr	r0, [r6, #28]
 3756 2050 0010E0E3 		mvn	r1, #0
 3757 2054 FEFFFFEB 		bl	_txe_mutex_get
 3758              	.LVL436:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3759              		.loc 1 391 0
 3760 2058 00808DE5 		str	r8, [sp]
 3761 205c 04808DE5 		str	r8, [sp, #4]
 3762 2060 0600A0E1 		mov	r0, r6
 3763 2064 2010A0E3 		mov	r1, #32
 3764 2068 2720A0E3 		mov	r2, #39
 3765 206c 3030A0E3 		mov	r3, #48
 3766 2070 FEFFFFEB 		bl	cmdSet
 3767              	.LVL437:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3768              		.loc 1 392 0
 3769 2074 0130A0E3 		mov	r3, #1
 3770 2078 04808DE5 		str	r8, [sp, #4]
 3771 207c 0600A0E1 		mov	r0, r6
 3772 2080 00308DE5 		str	r3, [sp]
 3773 2084 2110A0E3 		mov	r1, #33
 3774 2088 2520A0E3 		mov	r2, #37
 3775 208c 3030A0E3 		mov	r3, #48
 3776 2090 FEFFFFEB 		bl	cmdSet
 3777              	.LVL438:
 393:../uvc.c      **** }
 3778              		.loc 1 393 0
 3779 2094 1C0096E5 		ldr	r0, [r6, #28]
 3780 2098 FEFFFFEB 		bl	_txe_mutex_put
 3781              	.LVL439:
 3782 209c FF00A0E3 		mov	r0, #255
 3783 20a0 0080A0E1 		mov	r8, r0
 3784 20a4 0260A0E3 		mov	r6, #2
 3785 20a8 48FEFFEA 		b	.L208
 3786              	.LVL440:
 3787              	.L216:
 3788              	.LBE83:
 3789              	.LBE82:
 3790              	.LBB84:
 3791              	.LBB85:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3792              		.loc 1 390 0
 3793 20ac C8809FE5 		ldr	r8, .L235+20
 3794 20b0 0010E0E3 		mvn	r1, #0
 3795 20b4 1C0098E5 		ldr	r0, [r8, #28]
 3796 20b8 FEFFFFEB 		bl	_txe_mutex_get
 3797              	.LVL441:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3798              		.loc 1 391 0
 3799 20bc 0090A0E3 		mov	r9, #0
 3800              	.LVL442:
 3801 20c0 0160A0E3 		mov	r6, #1
 3802 20c4 0800A0E1 		mov	r0, r8
 3803 20c8 2010A0E3 		mov	r1, #32
 3804 20cc 2720A0E3 		mov	r2, #39
 3805 20d0 3030A0E3 		mov	r3, #48
 3806 20d4 40028DE8 		stmia	sp, {r6, r9}
 3807 20d8 FEFFFFEB 		bl	cmdSet
 3808              	.LVL443:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3809              		.loc 1 392 0
 3810 20dc 0230A0E3 		mov	r3, #2
 3811 20e0 0800A0E1 		mov	r0, r8
 3812 20e4 00308DE5 		str	r3, [sp]
 3813 20e8 2110A0E3 		mov	r1, #33
 3814 20ec 2520A0E3 		mov	r2, #37
 3815 20f0 3030A0E3 		mov	r3, #48
 3816 20f4 04908DE5 		str	r9, [sp, #4]
 3817 20f8 FEFFFFEB 		bl	cmdSet
 3818              	.LVL444:
 393:../uvc.c      **** }
 3819              		.loc 1 393 0
 3820 20fc 1C0098E5 		ldr	r0, [r8, #28]
 3821 2100 FEFFFFEB 		bl	_txe_mutex_put
 3822              	.LVL445:
 3823 2104 FF00A0E3 		mov	r0, #255
 3824 2108 0080A0E1 		mov	r8, r0
 3825 210c 2FFEFFEA 		b	.L208
 3826              	.LVL446:
 3827              	.L215:
 3828              	.LBE85:
 3829              	.LBE84:
1072:../uvc.c      **** 						case 1:
 3830              		.loc 1 1072 0
 3831 2110 FF00A0E3 		mov	r0, #255
 3832 2114 0C60A0E1 		mov	r6, ip
 3833 2118 0080A0E1 		mov	r8, r0
 3834 211c 2BFEFFEA 		b	.L208
 3835              	.LVL447:
 3836              	.L221:
1143:../uvc.c      **** 					  }
 3837              		.loc 1 1143 0
 3838 2120 0000A0E3 		mov	r0, #0
 3839 2124 0020A0E1 		mov	r2, r0
 3840 2128 0110A0E3 		mov	r1, #1
 3841 212c FEFFFFEB 		bl	CyU3PUsbStall
 3842              	.LVL448:
 3843 2130 D1FEFFEA 		b	.L224
 3844              	.LVL449:
 3845              	.L223:
1161:../uvc.c      **** 					  }
 3846              		.loc 1 1161 0
 3847 2134 0020A0E1 		mov	r2, r0
 3848 2138 0110A0E3 		mov	r1, #1
 3849 213c FEFFFFEB 		bl	CyU3PUsbStall
 3850              	.LVL450:
 3851 2140 CDFEFFEA 		b	.L224
 3852              	.LVL451:
 3853              	.L234:
1176:../uvc.c      **** 					  else
 3854              		.loc 1 1176 0
 3855 2144 0800A0E3 		mov	r0, #8
 3856              	.L231:
 3857 2148 0010A0E3 		mov	r1, #0
 3858 214c 03008DE8 		stmia	sp, {r0, r1}
 3859 2150 0A20A0E1 		mov	r2, r10
 3860 2154 0930A0E1 		mov	r3, r9
 3861 2158 0600A0E1 		mov	r0, r6
 3862 215c 2310A0E3 		mov	r1, #35
 3863 2160 FEFFFFEB 		bl	cmdSet
 3864              	.LVL452:
 3865 2164 97FEFFEA 		b	.L226
 3866              	.L236:
 3867              		.align	2
 3868              	.L235:
 3869 2168 00000000 		.word	bRequest
 3870 216c 00000000 		.word	.LANCHOR1
 3871 2170 00000000 		.word	.LANCHOR0
 3872 2174 C4030000 		.word	.LC22
 3873 2178 A0030000 		.word	.LC21
 3874 217c 00000000 		.word	cmdQu
 3875 2180 54030000 		.word	.LC19
 3876 2184 FFFF0000 		.word	65535
 3877 2188 7C030000 		.word	.LC20
 3878              		.cfi_endproc
 3879              	.LFE3:
 3881              		.align	2
 3882              		.global	CamDefSet
 3884              	CamDefSet:
 3885              	.LFB4:
1204:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 3886              		.loc 1 1204 0
 3887              		.cfi_startproc
 3888              		@ args = 0, pretend = 0, frame = 24
 3889              		@ frame_needed = 0, uses_anonymous_args = 0
 3890              	.LVL453:
 3891 218c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3892              	.LCFI16:
 3893              		.cfi_def_cfa_offset 36
 3894              		.cfi_offset 4, -36
 3895              		.cfi_offset 5, -32
 3896              		.cfi_offset 6, -28
 3897              		.cfi_offset 7, -24
 3898              		.cfi_offset 8, -20
 3899              		.cfi_offset 9, -16
 3900              		.cfi_offset 10, -12
 3901              		.cfi_offset 11, -8
 3902              		.cfi_offset 14, -4
1210:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 3903              		.loc 1 1210 0
 3904 2190 AC429FE5 		ldr	r4, .L240
1215:../uvc.c      ****     if(Data1&0x80){
 3905              		.loc 1 1215 0
 3906 2194 AC229FE5 		ldr	r2, .L240+4
1212:../uvc.c      ****     Data1 = Data0;
 3907              		.loc 1 1212 0
 3908 2198 A351D4E5 		ldrb	r5, [r4, #419]	@ zero_extendqisi2
1204:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 3909              		.loc 1 1204 0
 3910 219c 2CD04DE2 		sub	sp, sp, #44
 3911              	.LCFI17:
 3912              		.cfi_def_cfa_offset 80
1215:../uvc.c      ****     if(Data1&0x80){
 3913              		.loc 1 1215 0
 3914 21a0 1C0092E5 		ldr	r0, [r2, #28]
 3915 21a4 0010E0E3 		mvn	r1, #0
1217:../uvc.c      ****     }else{
 3916              		.loc 1 1217 0
 3917 21a8 2563A0E1 		mov	r6, r5, lsr #6
1211:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 3918              		.loc 1 1211 0
 3919 21ac A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1210:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 3920              		.loc 1 1210 0
 3921 21b0 9991D4E5 		ldrb	r9, [r4, #409]	@ zero_extendqisi2
 3922              	.LVL454:
1215:../uvc.c      ****     if(Data1&0x80){
 3923              		.loc 1 1215 0
 3924 21b4 FEFFFFEB 		bl	_txe_mutex_get
 3925              	.LVL455:
1216:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 3926              		.loc 1 1216 0
 3927 21b8 800015E3 		tst	r5, #128
1217:../uvc.c      ****     }else{
 3928              		.loc 1 1217 0
 3929 21bc 01600612 		andne	r6, r6, #1
 3930 21c0 0660E011 		mvnne	r6, r6
 3931 21c4 3B600612 		andne	r6, r6, #59
 3932 21c8 0660E011 		mvnne	r6, r6
 3933 21cc FF600612 		andne	r6, r6, #255
 3934              	.LVL456:
1219:../uvc.c      ****     }
 3935              		.loc 1 1219 0
 3936 21d0 C6608603 		orreq	r6, r6, #198
 3937              	.LVL457:
1223:../uvc.c      **** 
 3938              		.loc 1 1223 0
 3939 21d4 0080A0E3 		mov	r8, #0
1221:../uvc.c      **** 
 3940              		.loc 1 1221 0
 3941 21d8 0551A0E1 		mov	r5, r5, asl #2
 3942              	.LVL458:
 3943 21dc FF5005E2 		and	r5, r5, #255
 3944              	.LVL459:
1226:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3945              		.loc 1 1226 0
 3946 21e0 01A0A0E3 		mov	r10, #1
1223:../uvc.c      **** 
 3947              		.loc 1 1223 0
 3948 21e4 00608DE5 		str	r6, [sp]
 3949 21e8 0920A0E1 		mov	r2, r9
 3950 21ec 0730A0E1 		mov	r3, r7
 3951 21f0 04808DE5 		str	r8, [sp, #4]
 3952 21f4 0110A0E3 		mov	r1, #1
 3953 21f8 48029FE5 		ldr	r0, .L240+4
 3954 21fc FEFFFFEB 		bl	cmdSet
 3955              	.LVL460:
1226:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3956              		.loc 1 1226 0
 3957 2200 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 3958 2204 0730A0E1 		mov	r3, r7
 3959 2208 0A10A0E1 		mov	r1, r10
 3960 220c 00508DE5 		str	r5, [sp]
 3961 2210 04A08DE5 		str	r10, [sp, #4]
 3962 2214 2C029FE5 		ldr	r0, .L240+4
 3963 2218 FEFFFFEB 		bl	cmdSet
 3964              	.LVL461:
1229:../uvc.c      **** 
 3965              		.loc 1 1229 0
 3966 221c 0620A0E1 		mov	r2, r6
 3967 2220 0530A0E1 		mov	r3, r5
 3968 2224 20129FE5 		ldr	r1, .L240+8
 3969 2228 0400A0E3 		mov	r0, #4
1228:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 3970              		.loc 1 1228 0
 3971 222c A661C4E5 		strb	r6, [r4, #422]
1227:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 3972              		.loc 1 1227 0
 3973 2230 A551C4E5 		strb	r5, [r4, #421]
1229:../uvc.c      **** 
 3974              		.loc 1 1229 0
 3975 2234 FEFFFFEB 		bl	CyU3PDebugPrint
 3976              	.LVL462:
1234:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 3977              		.loc 1 1234 0
 3978 2238 BB61D4E5 		ldrb	r6, [r4, #443]	@ zero_extendqisi2
 3979              	.LVL463:
1235:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3980              		.loc 1 1235 0
 3981 223c B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 3982 2240 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 3983 2244 40018DE8 		stmia	sp, {r6, r8}
 3984 2248 F8019FE5 		ldr	r0, .L240+4
 3985 224c 0210A0E3 		mov	r1, #2
 3986 2250 FEFFFFEB 		bl	cmdSet
 3987              	.LVL464:
1237:../uvc.c      **** 
 3988              		.loc 1 1237 0
 3989 2254 0620A0E1 		mov	r2, r6
 3990 2258 0530A0E1 		mov	r3, r5
 3991 225c E8119FE5 		ldr	r1, .L240+8
 3992 2260 0400A0E3 		mov	r0, #4
1236:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 3993              		.loc 1 1236 0
 3994 2264 BD51C4E5 		strb	r5, [r4, #445]
1237:../uvc.c      **** 
 3995              		.loc 1 1237 0
 3996 2268 FEFFFFEB 		bl	CyU3PDebugPrint
 3997              	.LVL465:
1242:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 3998              		.loc 1 1242 0
 3999 226c 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1241:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 4000              		.loc 1 1241 0
 4001 2270 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 4002              	.LVL466:
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4003              		.loc 1 1243 0
 4004 2274 80C047E2 		sub	ip, r7, #128
 4005 2278 FF300CE2 		and	r3, ip, #255
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4006              		.loc 1 1244 0
 4007 227c 76E047E2 		sub	lr, r7, #118
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4008              		.loc 1 1243 0
 4009 2280 18308DE5 		str	r3, [sp, #24]
 4010 2284 08018DE8 		stmia	sp, {r3, r8}
 4011 2288 B8019FE5 		ldr	r0, .L240+4
 4012 228c 0630A0E1 		mov	r3, r6
 4013 2290 0510A0E3 		mov	r1, #5
 4014 2294 DF20A0E3 		mov	r2, #223
 4015 2298 14C08DE5 		str	ip, [sp, #20]
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4016              		.loc 1 1244 0
 4017 229c 1CE08DE5 		str	lr, [sp, #28]
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4018              		.loc 1 1243 0
 4019 22a0 FEFFFFEB 		bl	cmdSet
 4020              	.LVL467:
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4021              		.loc 1 1244 0
 4022 22a4 1C209DE5 		ldr	r2, [sp, #28]
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4023              		.loc 1 1245 0
 4024 22a8 7EE087E2 		add	lr, r7, #126
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4025              		.loc 1 1244 0
 4026 22ac FF3002E2 		and	r3, r2, #255
 4027 22b0 08048DE8 		stmia	sp, {r3, r10}
 4028 22b4 8C019FE5 		ldr	r0, .L240+4
 4029 22b8 0630A0E1 		mov	r3, r6
 4030 22bc 0510A0E3 		mov	r1, #5
 4031 22c0 DC20A0E3 		mov	r2, #220
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4032              		.loc 1 1245 0
 4033 22c4 20E08DE5 		str	lr, [sp, #32]
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4034              		.loc 1 1244 0
 4035 22c8 FEFFFFEB 		bl	cmdSet
 4036              	.LVL468:
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4037              		.loc 1 1245 0
 4038 22cc 20209DE5 		ldr	r2, [sp, #32]
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4039              		.loc 1 1246 0
 4040 22d0 72E087E2 		add	lr, r7, #114
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4041              		.loc 1 1245 0
 4042 22d4 FF3002E2 		and	r3, r2, #255
 4043 22d8 0220A0E3 		mov	r2, #2
 4044 22dc 00308DE5 		str	r3, [sp]
 4045 22e0 04208DE5 		str	r2, [sp, #4]
 4046 22e4 0630A0E1 		mov	r3, r6
 4047 22e8 0510A0E3 		mov	r1, #5
 4048 22ec DE20A0E3 		mov	r2, #222
 4049 22f0 50019FE5 		ldr	r0, .L240+4
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4050              		.loc 1 1246 0
 4051 22f4 24E08DE5 		str	lr, [sp, #36]
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4052              		.loc 1 1245 0
 4053 22f8 FEFFFFEB 		bl	cmdSet
 4054              	.LVL469:
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4055              		.loc 1 1246 0
 4056 22fc 24209DE5 		ldr	r2, [sp, #36]
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4057              		.loc 1 1247 0
 4058 2300 6FB047E2 		sub	fp, r7, #111
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4059              		.loc 1 1246 0
 4060 2304 FF3002E2 		and	r3, r2, #255
 4061 2308 0320A0E3 		mov	r2, #3
 4062 230c 00308DE5 		str	r3, [sp]
 4063 2310 04208DE5 		str	r2, [sp, #4]
 4064 2314 0630A0E1 		mov	r3, r6
 4065 2318 0510A0E3 		mov	r1, #5
 4066 231c E020A0E3 		mov	r2, #224
 4067 2320 20019FE5 		ldr	r0, .L240+4
 4068 2324 FEFFFFEB 		bl	cmdSet
 4069              	.LVL470:
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4070              		.loc 1 1247 0
 4071 2328 0490A0E3 		mov	r9, #4
 4072 232c FF300BE2 		and	r3, fp, #255
1248:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 4073              		.loc 1 1248 0
 4074 2330 7F7087E2 		add	r7, r7, #127
 4075              	.LVL471:
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4076              		.loc 1 1247 0
 4077 2334 00308DE5 		str	r3, [sp]
 4078 2338 04908DE5 		str	r9, [sp, #4]
 4079 233c 0630A0E1 		mov	r3, r6
 4080 2340 0510A0E3 		mov	r1, #5
 4081 2344 DD20A0E3 		mov	r2, #221
 4082 2348 F8009FE5 		ldr	r0, .L240+4
 4083 234c FEFFFFEB 		bl	cmdSet
 4084              	.LVL472:
1248:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 4085              		.loc 1 1248 0
 4086 2350 FF2007E2 		and	r2, r7, #255
 4087 2354 0510A0E3 		mov	r1, #5
 4088 2358 0630A0E1 		mov	r3, r6
 4089 235c 00208DE5 		str	r2, [sp]
 4090 2360 04108DE5 		str	r1, [sp, #4]
 4091 2364 E120A0E3 		mov	r2, #225
 4092 2368 D8009FE5 		ldr	r0, .L240+4
 4093 236c FEFFFFEB 		bl	cmdSet
 4094              	.LVL473:
1250:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4095              		.loc 1 1250 0
 4096 2370 14C09DE5 		ldr	ip, [sp, #20]
 4097 2374 24E09DE5 		ldr	lr, [sp, #36]
 4098 2378 20309DE5 		ldr	r3, [sp, #32]
 4099 237c 0C20A0E1 		mov	r2, ip
1249:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 4100              		.loc 1 1249 0
 4101 2380 18C09DE5 		ldr	ip, [sp, #24]
1250:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4102              		.loc 1 1250 0
 4103 2384 04E08DE5 		str	lr, [sp, #4]
 4104 2388 00308DE5 		str	r3, [sp]
 4105 238c 0C708DE5 		str	r7, [sp, #12]
 4106 2390 1C309DE5 		ldr	r3, [sp, #28]
 4107 2394 08B08DE5 		str	fp, [sp, #8]
 4108 2398 0900A0E1 		mov	r0, r9
 4109 239c AC109FE5 		ldr	r1, .L240+12
1249:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 4110              		.loc 1 1249 0
 4111 23a0 05C2C4E5 		strb	ip, [r4, #517]
1250:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4112              		.loc 1 1250 0
 4113 23a4 FEFFFFEB 		bl	CyU3PDebugPrint
 4114              	.LVL474:
1255:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 4115              		.loc 1 1255 0
 4116 23a8 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 4117              	.LVL475:
1254:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 4118              		.loc 1 1254 0
 4119 23ac 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 4120              	.LVL476:
1256:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 4121              		.loc 1 1256 0
 4122 23b0 00608DE5 		str	r6, [sp]
 4123 23b4 0730A0E1 		mov	r3, r7
 4124 23b8 04808DE5 		str	r8, [sp, #4]
 4125 23bc 0610A0E3 		mov	r1, #6
 4126 23c0 8520A0E3 		mov	r2, #133
 4127 23c4 7C009FE5 		ldr	r0, .L240+4
 4128 23c8 FEFFFFEB 		bl	cmdSet
 4129              	.LVL477:
1257:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 4130              		.loc 1 1257 0
 4131 23cc 40048DE8 		stmia	sp, {r6, r10}
 4132 23d0 70009FE5 		ldr	r0, .L240+4
 4133 23d4 0730A0E1 		mov	r3, r7
 4134 23d8 0610A0E3 		mov	r1, #6
 4135 23dc 8620A0E3 		mov	r2, #134
 4136 23e0 FEFFFFEB 		bl	cmdSet
 4137              	.LVL478:
1259:../uvc.c      **** 
 4138              		.loc 1 1259 0
 4139 23e4 0620A0E1 		mov	r2, r6
 4140 23e8 0530A0E1 		mov	r3, r5
 4141 23ec 0900A0E1 		mov	r0, r9
 4142 23f0 54109FE5 		ldr	r1, .L240+8
1258:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4143              		.loc 1 1258 0
 4144 23f4 1D62C4E5 		strb	r6, [r4, #541]
1259:../uvc.c      **** 
 4145              		.loc 1 1259 0
 4146 23f8 FEFFFFEB 		bl	CyU3PDebugPrint
 4147              	.LVL479:
1264:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 4148              		.loc 1 1264 0
 4149 23fc 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 4150              	.LVL480:
1265:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 4151              		.loc 1 1265 0
 4152 2400 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 4153 2404 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 4154 2408 40018DE8 		stmia	sp, {r6, r8}
 4155 240c 34009FE5 		ldr	r0, .L240+4
 4156 2410 0710A0E3 		mov	r1, #7
 4157 2414 FEFFFFEB 		bl	cmdSet
 4158              	.LVL481:
1267:../uvc.c      **** 
 4159              		.loc 1 1267 0
 4160 2418 0620A0E1 		mov	r2, r6
 4161 241c 0530A0E1 		mov	r3, r5
 4162 2420 0900A0E1 		mov	r0, r9
 4163 2424 20109FE5 		ldr	r1, .L240+8
1266:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4164              		.loc 1 1266 0
 4165 2428 3552C4E5 		strb	r5, [r4, #565]
1267:../uvc.c      **** 
 4166              		.loc 1 1267 0
 4167 242c FEFFFFEB 		bl	CyU3PDebugPrint
 4168              	.LVL482:
1269:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 4169              		.loc 1 1269 0
 4170 2430 10209FE5 		ldr	r2, .L240+4
 4171 2434 1C0092E5 		ldr	r0, [r2, #28]
1272:../uvc.c      **** 
 4172              		.loc 1 1272 0
 4173 2438 2CD08DE2 		add	sp, sp, #44
 4174              		@ sp needed
 4175 243c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4176              	.LVL483:
1269:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 4177              		.loc 1 1269 0
 4178 2440 FEFFFFEA 		b	_txe_mutex_put
 4179              	.LVL484:
 4180              	.L241:
 4181              		.align	2
 4182              	.L240:
 4183 2444 00000000 		.word	.LANCHOR1
 4184 2448 00000000 		.word	cmdQu
 4185 244c 28040000 		.word	.LC23
 4186 2450 48040000 		.word	.LC24
 4187              		.cfi_endproc
 4188              	.LFE4:
 4190              		.align	2
 4191              		.global	CyFxUVCAddHeader
 4193              	CyFxUVCAddHeader:
 4194              	.LFB5:
1280:../uvc.c      ****     /* Copy header to buffer */
 4195              		.loc 1 1280 0
 4196              		.cfi_startproc
 4197              		@ args = 0, pretend = 0, frame = 0
 4198              		@ frame_needed = 0, uses_anonymous_args = 0
 4199              	.LVL485:
 4200 2454 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 4201              	.LCFI18:
 4202              		.cfi_def_cfa_offset 16
 4203              		.cfi_offset 3, -16
 4204              		.cfi_offset 4, -12
 4205              		.cfi_offset 5, -8
 4206              		.cfi_offset 14, -4
1280:../uvc.c      ****     /* Copy header to buffer */
 4207              		.loc 1 1280 0
 4208 2458 0040A0E1 		mov	r4, r0
 4209 245c 0150A0E1 		mov	r5, r1
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 4210              		.loc 1 1282 0
 4211 2460 30009FE5 		ldr	r0, .L247
 4212              	.LVL486:
 4213 2464 0010E0E3 		mvn	r1, #0
 4214              	.LVL487:
 4215 2468 FEFFFFEB 		bl	_txe_mutex_get
 4216              	.LVL488:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 4217              		.loc 1 1283 0
 4218 246c 0400A0E1 		mov	r0, r4
 4219 2470 24109FE5 		ldr	r1, .L247+4
 4220 2474 0C20A0E3 		mov	r2, #12
 4221 2478 FEFFFFEB 		bl	CyU3PMemCopy
 4222              	.LVL489:
1284:../uvc.c      **** 
 4223              		.loc 1 1284 0
 4224 247c 14009FE5 		ldr	r0, .L247
 4225 2480 FEFFFFEB 		bl	_txe_mutex_put
 4226              	.LVL490:
1287:../uvc.c      ****     {
 4227              		.loc 1 1287 0
 4228 2484 020015E3 		tst	r5, #2
1289:../uvc.c      ****     }
 4229              		.loc 1 1289 0
 4230 2488 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 4231 248c 02308313 		orrne	r3, r3, #2
 4232 2490 0130C415 		strneb	r3, [r4, #1]
 4233 2494 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 4234              	.L248:
 4235              		.align	2
 4236              	.L247:
 4237 2498 00000000 		.word	imgHdMux
 4238 249c 80040000 		.word	.LANCHOR1+1152
 4239              		.cfi_endproc
 4240              	.LFE5:
 4242              		.align	2
 4243              		.global	CyFxAppErrorHandler
 4245              	CyFxAppErrorHandler:
 4246              	.LFB6:
1299:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 4247              		.loc 1 1299 0
 4248              		.cfi_startproc
 4249              		@ Volatile: function does not return.
 4250              		@ args = 0, pretend = 0, frame = 0
 4251              		@ frame_needed = 0, uses_anonymous_args = 0
 4252              	.LVL491:
 4253 24a0 08402DE9 		stmfd	sp!, {r3, lr}
 4254              	.LCFI19:
 4255              		.cfi_def_cfa_offset 8
 4256              		.cfi_offset 3, -8
 4257              		.cfi_offset 14, -4
 4258              	.LVL492:
 4259              	.L250:
1309:../uvc.c      ****         CyU3PThreadSleep (1000);
 4260              		.loc 1 1309 0 discriminator 1
 4261 24a4 10109FE5 		ldr	r1, .L251
 4262 24a8 0400A0E3 		mov	r0, #4
 4263 24ac FEFFFFEB 		bl	CyU3PDebugPrint
 4264              	.LVL493:
1310:../uvc.c      ****     }
 4265              		.loc 1 1310 0 discriminator 1
 4266 24b0 FA0FA0E3 		mov	r0, #1000
 4267 24b4 FEFFFFEB 		bl	_tx_thread_sleep
 4268              	.LVL494:
 4269 24b8 F9FFFFEA 		b	.L250
 4270              	.L252:
 4271              		.align	2
 4272              	.L251:
 4273 24bc 80040000 		.word	.LC25
 4274              		.cfi_endproc
 4275              	.LFE6:
 4277              		.align	2
 4278              		.global	UVCAppEP0Thread_Entry
 4280              	UVCAppEP0Thread_Entry:
 4281              	.LFB24:
3265:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 4282              		.loc 1 3265 0
 4283              		.cfi_startproc
 4284              		@ args = 0, pretend = 0, frame = 80
 4285              		@ frame_needed = 0, uses_anonymous_args = 0
 4286              	.LVL495:
 4287 24c0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4288              	.LCFI20:
 4289              		.cfi_def_cfa_offset 36
 4290              		.cfi_offset 4, -36
 4291              		.cfi_offset 5, -32
 4292              		.cfi_offset 6, -28
 4293              		.cfi_offset 7, -24
 4294              		.cfi_offset 8, -20
 4295              		.cfi_offset 9, -16
 4296              		.cfi_offset 10, -12
 4297              		.cfi_offset 11, -8
 4298              		.cfi_offset 14, -4
 4299 24c4 ACBF9FE5 		ldr	fp, .L748
 4300 24c8 ACAF9FE5 		ldr	r10, .L748+4
 4301 24cc AC6F9FE5 		ldr	r6, .L748+8
3339:../uvc.c      ****                 {
 4302              		.loc 1 3339 0
 4303 24d0 AC5F9FE5 		ldr	r5, .L748+12
 4304              	.LBB134:
 4305              	.LBB135:
2942:../uvc.c      ****     {
 4306              		.loc 1 2942 0
 4307 24d4 AC9F9FE5 		ldr	r9, .L748+16
 4308              	.LBE135:
 4309              	.LBE134:
3265:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 4310              		.loc 1 3265 0
 4311 24d8 6CD04DE2 		sub	sp, sp, #108
 4312              	.LCFI21:
 4313              		.cfi_def_cfa_offset 144
 4314              	.LVL496:
3287:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 4315              		.loc 1 3287 0
 4316 24dc 0B40A0E1 		mov	r4, fp
 4317              	.LVL497:
 4318              	.L567:
 4319 24e0 0030E0E3 		mvn	r3, #0
 4320 24e4 00308DE5 		str	r3, [sp]
 4321 24e8 880F9FE5 		ldr	r0, .L748
 4322 24ec 4C10A0E3 		mov	r1, #76
 4323 24f0 0120A0E3 		mov	r2, #1
 4324 24f4 50308DE2 		add	r3, sp, #80
 4325              	.LVL498:
 4326 24f8 FEFFFFEB 		bl	_txe_event_flags_get
 4327              	.LVL499:
 4328 24fc 000050E3 		cmp	r0, #0
 4329 2500 5900001A 		bne	.L255
3291:../uvc.c      ****             {
 4330              		.loc 1 3291 0
 4331 2504 883094E5 		ldr	r3, [r4, #136]
 4332 2508 000053E3 		cmp	r3, #0
 4333 250c 8E00000A 		beq	.L710
 4334              	.L257:
3300:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4335              		.loc 1 3300 0
 4336 2510 50309DE5 		ldr	r3, [sp, #80]
 4337 2514 0C0013E3 		tst	r3, #12
 4338 2518 7600001A 		bne	.L711
 4339              	.L259:
3307:../uvc.c      ****             {
 4340              		.loc 1 3307 0
 4341 251c 040013E3 		tst	r3, #4
 4342 2520 1F00000A 		beq	.L260
3309:../uvc.c      ****                 {
 4343              		.loc 1 3309 0
 4344 2524 B020D5E1 		ldrh	r2, [r5]
 4345 2528 2224A0E1 		mov	r2, r2, lsr #8
 4346 252c 030052E3 		cmp	r2, #3
 4347 2530 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4348 2534 150000EA 		b	.L261
 4349              	.L263:
 4350 2538 90250000 		.word	.L261
 4351 253c 48250000 		.word	.L264
 4352 2540 74260000 		.word	.L265
 4353 2544 B0260000 		.word	.L266
 4354              	.L264:
 4355              	.LBB146:
 4356              	.LBB147:
2622:../uvc.c      ****     {
 4357              		.loc 1 2622 0
 4358 2548 B020D9E1 		ldrh	r2, [r9]
 4359 254c 060C52E3 		cmp	r2, #1536
 4360 2550 4102000A 		beq	.L296
 4361 2554 E200009A 		bls	.L712
 4362 2558 090C52E3 		cmp	r2, #2304
 4363 255c A202000A 		beq	.L304
 4364 2560 5A01009A 		bls	.L713
 4365 2564 0B0C52E3 		cmp	r2, #2816
 4366 2568 C402000A 		beq	.L307
 4367 256c 030B52E3 		cmp	r2, #3072
 4368 2570 6E02000A 		beq	.L308
 4369 2574 0A0C52E3 		cmp	r2, #2560
 4370 2578 D201000A 		beq	.L714
 4371              	.L295:
2679:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4372              		.loc 1 2679 0
 4373 257c 083F9FE5 		ldr	r3, .L748+20
 4374 2580 0400A0E3 		mov	r0, #4
 4375 2584 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 4376 2588 001F9FE5 		ldr	r1, .L748+24
 4377 258c FEFFFFEB 		bl	CyU3PDebugPrint
 4378              	.LVL500:
 4379              	.L261:
 4380              	.LBE147:
 4381              	.LBE146:
3330:../uvc.c      ****                         break;
 4382              		.loc 1 3330 0
 4383 2590 0000A0E3 		mov	r0, #0
 4384 2594 0020A0E1 		mov	r2, r0
 4385 2598 0110A0E3 		mov	r1, #1
 4386 259c FEFFFFEB 		bl	CyU3PUsbStall
 4387              	.LVL501:
 4388 25a0 50309DE5 		ldr	r3, [sp, #80]
 4389              	.L260:
3335:../uvc.c      ****             {
 4390              		.loc 1 3335 0
 4391 25a4 080013E3 		tst	r3, #8
 4392 25a8 0700000A 		beq	.L512
3339:../uvc.c      ****                 {
 4393              		.loc 1 3339 0
 4394 25ac B030D5E1 		ldrh	r3, [r5]
 4395 25b0 010053E3 		cmp	r3, #1
 4396 25b4 8A00000A 		beq	.L513
 4397              	.L514:
 4398              	.LBB320:
 4399              	.LBB136:
3254:../uvc.c      ****             break;
 4400              		.loc 1 3254 0
 4401 25b8 0000A0E3 		mov	r0, #0
 4402 25bc 0020A0E1 		mov	r2, r0
 4403 25c0 0110A0E3 		mov	r1, #1
 4404 25c4 FEFFFFEB 		bl	CyU3PUsbStall
 4405              	.LVL502:
 4406              	.L527:
 4407 25c8 50309DE5 		ldr	r3, [sp, #80]
 4408              	.L512:
 4409              	.LBE136:
 4410              	.LBE320:
3350:../uvc.c      ****             {
 4411              		.loc 1 3350 0
 4412 25cc 400013E3 		tst	r3, #64
 4413 25d0 2500000A 		beq	.L255
3355:../uvc.c      **** 
 4414              		.loc 1 3355 0
 4415 25d4 1800A0E3 		mov	r0, #24
 4416 25d8 58108DE2 		add	r1, sp, #88
 4417 25dc FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 4418              	.LVL503:
3360:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4419              		.loc 1 3360 0
 4420 25e0 58309DE5 		ldr	r3, [sp, #88]
 4421 25e4 000053E3 		cmp	r3, #0
 4422 25e8 5D00001A 		bne	.L715
3384:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4423              		.loc 1 3384 0
 4424 25ec 4326DAE5 		ldrb	r2, [r10, #1603]	@ zero_extendqisi2
 4425 25f0 000052E3 		cmp	r2, #0
 4426 25f4 1C00000A 		beq	.L255
3386:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4427              		.loc 1 3386 0
 4428 25f8 002096E5 		ldr	r2, [r6]
 4429 25fc 0210A0E3 		mov	r1, #2
 4430 2600 0010C2E5 		strb	r1, [r2]
3387:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4431              		.loc 1 3387 0
 4432 2604 001096E5 		ldr	r1, [r6]
 4433 2608 0120A0E3 		mov	r2, #1
 4434 260c 0120C1E5 		strb	r2, [r1, #1]
3388:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4435              		.loc 1 3388 0
 4436 2610 001096E5 		ldr	r1, [r6]
3392:../uvc.c      **** 					interStabuf.status = 0;
 4437              		.loc 1 3392 0
 4438 2614 01CBA0E3 		mov	ip, #1024
3388:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4439              		.loc 1 3388 0
 4440 2618 0230C1E5 		strb	r3, [r1, #2]
3389:../uvc.c      **** 
 4441              		.loc 1 3389 0
 4442 261c 001096E5 		ldr	r1, [r6]
3395:../uvc.c      **** 
 4443              		.loc 1 3395 0
 4444 2620 0480A0E3 		mov	r8, #4
3389:../uvc.c      **** 
 4445              		.loc 1 3389 0
 4446 2624 0320C1E5 		strb	r2, [r1, #3]
3391:../uvc.c      **** 					interStabuf.size   = 1024;
 4447              		.loc 1 3391 0
 4448 2628 002096E5 		ldr	r2, [r6]
3398:../uvc.c      **** 
 4449              		.loc 1 3398 0
 4450 262c 0010E0E3 		mvn	r1, #0
 4451 2630 5C0E9FE5 		ldr	r0, .L748+28
3393:../uvc.c      **** 
 4452              		.loc 1 3393 0
 4453 2634 B436CDE1 		strh	r3, [sp, #100]	@ movhi
3391:../uvc.c      **** 					interStabuf.size   = 1024;
 4454              		.loc 1 3391 0
 4455 2638 5C208DE5 		str	r2, [sp, #92]
3392:../uvc.c      **** 					interStabuf.status = 0;
 4456              		.loc 1 3392 0
 4457 263c B2C6CDE1 		strh	ip, [sp, #98]	@ movhi
3395:../uvc.c      **** 
 4458              		.loc 1 3395 0
 4459 2640 B086CDE1 		strh	r8, [sp, #96]	@ movhi
3398:../uvc.c      **** 
 4460              		.loc 1 3398 0
 4461 2644 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 4462              	.LVL504:
3401:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4463              		.loc 1 3401 0
 4464 2648 440E9FE5 		ldr	r0, .L748+28
 4465 264c 5C108DE2 		add	r1, sp, #92
 4466 2650 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4467              	.LVL505:
3402:../uvc.c      **** 					{
 4468              		.loc 1 3402 0
 4469 2654 000050E3 		cmp	r0, #0
 4470 2658 E905001A 		bne	.L716
3408:../uvc.c      **** 					stiflag = 0xFF;
 4471              		.loc 1 3408 0
 4472 265c 18EE9FE5 		ldr	lr, .L748+4
3409:../uvc.c      **** 				}
 4473              		.loc 1 3409 0
 4474 2660 FF30A0E3 		mov	r3, #255
3408:../uvc.c      **** 					stiflag = 0xFF;
 4475              		.loc 1 3408 0
 4476 2664 4306CEE5 		strb	r0, [lr, #1603]
3409:../uvc.c      **** 				}
 4477              		.loc 1 3409 0
 4478 2668 74308BE5 		str	r3, [fp, #116]
 4479              	.LVL506:
 4480              	.L255:
3563:../uvc.c      ****     }
 4481              		.loc 1 3563 0
 4482 266c FEFFFFEB 		bl	_txe_thread_relinquish
 4483              	.LVL507:
3564:../uvc.c      **** }
 4484              		.loc 1 3564 0
 4485 2670 9AFFFFEA 		b	.L567
 4486              	.L265:
 4487              	.LBB321:
 4488              	.LBB322:
2547:../uvc.c      ****     {
 4489              		.loc 1 2547 0
 4490 2674 B020D9E1 		ldrh	r2, [r9]
 4491 2678 060C52E3 		cmp	r2, #1536
 4492 267c 8D01000A 		beq	.L268
 4493 2680 8A00008A 		bhi	.L269
 4494 2684 030C52E3 		cmp	r2, #768
 4495 2688 8601000A 		beq	.L270
 4496 268c CC00008A 		bhi	.L271
 4497 2690 010C52E3 		cmp	r2, #256
 4498 2694 7B01000A 		beq	.L272
 4499 2698 020C52E3 		cmp	r2, #512
 4500 269c B6FFFF1A 		bne	.L295
 4501              	.L447:
 4502              	.LVL508:
 4503              	.LBE322:
 4504              	.LBE321:
 4505              	.LBB347:
 4506              	.LBB348:
2894:../uvc.c      ****     		break;
 4507              		.loc 1 2894 0
 4508 26a0 1A00A0E3 		mov	r0, #26
 4509 26a4 FEFFFFEB 		bl	ControlHandle
 4510              	.LVL509:
 4511 26a8 50309DE5 		ldr	r3, [sp, #80]
 4512 26ac BCFFFFEA 		b	.L260
 4513              	.L266:
2847:../uvc.c      ****     {
 4514              		.loc 1 2847 0
 4515 26b0 B030D9E1 		ldrh	r3, [r9]
 4516 26b4 090C53E3 		cmp	r3, #2304
 4517 26b8 4B03000A 		beq	.L433
 4518 26bc 6D00008A 		bhi	.L434
 4519 26c0 010B53E3 		cmp	r3, #1024
 4520 26c4 3103000A 		beq	.L435
 4521 26c8 EC00009A 		bls	.L717
 4522 26cc 060C53E3 		cmp	r3, #1536
 4523 26d0 0203000A 		beq	.L440
 4524 26d4 E202009A 		bls	.L718
 4525 26d8 070C53E3 		cmp	r3, #1792
 4526 26dc 0303000A 		beq	.L443
 4527 26e0 020B53E3 		cmp	r3, #2048
 4528 26e4 A9FFFF1A 		bne	.L261
 4529              	.LVL510:
2879:../uvc.c      ****     		break;
 4530              		.loc 1 2879 0
 4531 26e8 1700A0E3 		mov	r0, #23
 4532 26ec FEFFFFEB 		bl	ControlHandle
 4533              	.LVL511:
 4534 26f0 50309DE5 		ldr	r3, [sp, #80]
 4535 26f4 AAFFFFEA 		b	.L260
 4536              	.L711:
 4537              	.LBE348:
 4538              	.LBE347:
3301:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 4539              		.loc 1 3301 0
 4540 26f8 980D9FE5 		ldr	r0, .L748+32
 4541 26fc 881D9FE5 		ldr	r1, .L748+20
 4542 2700 942D9FE5 		ldr	r2, .L748+36
 4543 2704 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 4544 2708 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 4545 270c B010D2E1 		ldrh	r1, [r2]
 4546 2710 B0C0D9E1 		ldrh	ip, [r9]
 4547 2714 C020DBE5 		ldrb	r2, [fp, #192]	@ zero_extendqisi2
 4548 2718 00008DE5 		str	r0, [sp]
 4549 271c B000D5E1 		ldrh	r0, [r5]
 4550 2720 10108DE5 		str	r1, [sp, #16]
 4551 2724 0010A0E3 		mov	r1, #0
 4552 2728 0C008DE5 		str	r0, [sp, #12]
 4553 272c 14108DE5 		str	r1, [sp, #20]
 4554 2730 04E08DE5 		str	lr, [sp, #4]
 4555 2734 08C08DE5 		str	ip, [sp, #8]
 4556 2738 0400A0E3 		mov	r0, #4
 4557 273c 5C1D9FE5 		ldr	r1, .L748+40
 4558 2740 FEFFFFEB 		bl	CyU3PDebugPrint
 4559              	.LVL512:
 4560 2744 50309DE5 		ldr	r3, [sp, #80]
 4561 2748 73FFFFEA 		b	.L259
 4562              	.L710:
3293:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4563              		.loc 1 3293 0
 4564 274c FEFFFFEB 		bl	CyU3PUsbGetSpeed
 4565              	.LVL513:
3294:../uvc.c      ****                 {
 4566              		.loc 1 3294 0
 4567 2750 000050E3 		cmp	r0, #0
3296:../uvc.c      ****                 }
 4568              		.loc 1 3296 0
 4569 2754 0130A013 		movne	r3, #1
3293:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4570              		.loc 1 3293 0
 4571 2758 C000C4E5 		strb	r0, [r4, #192]
3296:../uvc.c      ****                 }
 4572              		.loc 1 3296 0
 4573 275c 88308415 		strne	r3, [r4, #136]
 4574 2760 6AFFFFEA 		b	.L257
 4575              	.L715:
3360:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4576              		.loc 1 3360 0 discriminator 1
 4577 2764 4336DAE5 		ldrb	r3, [r10, #1603]	@ zero_extendqisi2
 4578 2768 000053E3 		cmp	r3, #0
 4579 276c BEFFFF1A 		bne	.L255
3362:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4580              		.loc 1 3362 0
 4581 2770 002096E5 		ldr	r2, [r6]
 4582 2774 0210A0E3 		mov	r1, #2
 4583 2778 0010C2E5 		strb	r1, [r2]
3363:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4584              		.loc 1 3363 0
 4585 277c 002096E5 		ldr	r2, [r6]
 4586 2780 0170A0E3 		mov	r7, #1
 4587 2784 0170C2E5 		strb	r7, [r2, #1]
3364:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4588              		.loc 1 3364 0
 4589 2788 001096E5 		ldr	r1, [r6]
3368:../uvc.c      **** 					interStabuf.status = 0;
 4590              		.loc 1 3368 0
 4591 278c 012BA0E3 		mov	r2, #1024
3364:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4592              		.loc 1 3364 0
 4593 2790 0230C1E5 		strb	r3, [r1, #2]
3365:../uvc.c      **** 
 4594              		.loc 1 3365 0
 4595 2794 001096E5 		ldr	r1, [r6]
3371:../uvc.c      **** 
 4596              		.loc 1 3371 0
 4597 2798 0480A0E3 		mov	r8, #4
3365:../uvc.c      **** 
 4598              		.loc 1 3365 0
 4599 279c 0330C1E5 		strb	r3, [r1, #3]
3367:../uvc.c      **** 					interStabuf.size   = 1024;
 4600              		.loc 1 3367 0
 4601 27a0 001096E5 		ldr	r1, [r6]
3374:../uvc.c      **** 
 4602              		.loc 1 3374 0
 4603 27a4 E80C9FE5 		ldr	r0, .L748+28
3367:../uvc.c      **** 					interStabuf.size   = 1024;
 4604              		.loc 1 3367 0
 4605 27a8 5C108DE5 		str	r1, [sp, #92]
3374:../uvc.c      **** 
 4606              		.loc 1 3374 0
 4607 27ac 0010E0E3 		mvn	r1, #0
3369:../uvc.c      **** 
 4608              		.loc 1 3369 0
 4609 27b0 B436CDE1 		strh	r3, [sp, #100]	@ movhi
3368:../uvc.c      **** 					interStabuf.status = 0;
 4610              		.loc 1 3368 0
 4611 27b4 B226CDE1 		strh	r2, [sp, #98]	@ movhi
3371:../uvc.c      **** 
 4612              		.loc 1 3371 0
 4613 27b8 B086CDE1 		strh	r8, [sp, #96]	@ movhi
3374:../uvc.c      **** 
 4614              		.loc 1 3374 0
 4615 27bc FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 4616              	.LVL514:
3377:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4617              		.loc 1 3377 0
 4618 27c0 CC0C9FE5 		ldr	r0, .L748+28
 4619 27c4 5C108DE2 		add	r1, sp, #92
 4620 27c8 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4621              	.LVL515:
3378:../uvc.c      **** 					{
 4622              		.loc 1 3378 0
 4623 27cc 000050E3 		cmp	r0, #0
 4624 27d0 6B03001A 		bne	.L719
3383:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4625              		.loc 1 3383 0
 4626 27d4 A0CC9FE5 		ldr	ip, .L748+4
 4627 27d8 4376CCE5 		strb	r7, [ip, #1603]
3563:../uvc.c      ****     }
 4628              		.loc 1 3563 0
 4629 27dc FEFFFFEB 		bl	_txe_thread_relinquish
 4630              	.LVL516:
 4631 27e0 3EFFFFEA 		b	.L567
 4632              	.L513:
 4633              	.LVL517:
 4634              	.LBB434:
 4635              	.LBB137:
2942:../uvc.c      ****     {
 4636              		.loc 1 2942 0
 4637 27e4 B020D9E1 		ldrh	r2, [r9]
 4638 27e8 030C52E3 		cmp	r2, #768
 4639 27ec 4700000A 		beq	.L515
 4640 27f0 1200008A 		bhi	.L516
 4641 27f4 010C52E3 		cmp	r2, #256
 4642 27f8 5600000A 		beq	.L517
 4643 27fc 020C52E3 		cmp	r2, #512
 4644 2800 6CFFFF1A 		bne	.L514
2996:../uvc.c      ****             {
 4645              		.loc 1 2996 0
 4646 2804 803C9FE5 		ldr	r3, .L748+20
 4647 2808 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 4648 280c 810053E3 		cmp	r3, #129
 4649 2810 5800000A 		beq	.L555
 4650 2814 3C02009A 		bls	.L720
 4651 2818 850053E3 		cmp	r3, #133
 4652 281c 4500000A 		beq	.L551
 4653 2820 860053E3 		cmp	r3, #134
 4654 2824 63FFFF1A 		bne	.L514
 4655              	.L702:
3202:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4656              		.loc 1 3202 0
 4657 2828 0330A0E3 		mov	r3, #3
3203:../uvc.c      ****                         break;
 4658              		.loc 1 3203 0
 4659 282c C41C9FE5 		ldr	r1, .L748+128
 4660 2830 0100A0E3 		mov	r0, #1
3202:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4661              		.loc 1 3202 0
 4662 2834 9C30CBE5 		strb	r3, [fp, #156]
3203:../uvc.c      ****                         break;
 4663              		.loc 1 3203 0
 4664 2838 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4665              	.LVL518:
 4666 283c 61FFFFEA 		b	.L527
 4667              	.L516:
2942:../uvc.c      ****     {
 4668              		.loc 1 2942 0
 4669 2840 010B52E3 		cmp	r2, #1024
 4670 2844 4F00000A 		beq	.L519
 4671 2848 050C52E3 		cmp	r2, #1280
 4672 284c 59FFFF1A 		bne	.L514
3199:../uvc.c      ****                 {
 4673              		.loc 1 3199 0
 4674 2850 342C9FE5 		ldr	r2, .L748+20
 4675 2854 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4676 2858 810052E3 		cmp	r2, #129
 4677 285c 4500000A 		beq	.L555
 4678 2860 4902009A 		bls	.L721
 4679 2864 850052E3 		cmp	r2, #133
 4680 2868 FB02000A 		beq	.L558
 4681 286c 860052E3 		cmp	r2, #134
 4682 2870 ECFFFF0A 		beq	.L702
 4683 2874 4FFFFFEA 		b	.L514
 4684              	.LVL519:
 4685              	.L434:
 4686              	.LBE137:
 4687              	.LBE434:
 4688              	.LBB435:
 4689              	.LBB421:
2847:../uvc.c      ****     {
 4690              		.loc 1 2847 0
 4691 2878 0F0C53E3 		cmp	r3, #3840
 4692 287c DE02000A 		beq	.L445
 4693 2880 8800009A 		bls	.L722
 4694 2884 110C53E3 		cmp	r3, #4352
 4695 2888 9002000A 		beq	.L450
 4696 288c 5602009A 		bls	.L723
 4697 2890 120C53E3 		cmp	r3, #4608
 4698 2894 A102000A 		beq	.L453
 4699 2898 130C53E3 		cmp	r3, #4864
 4700 289c 3BFFFF1A 		bne	.L261
 4701              	.LVL520:
2922:../uvc.c      ****     		break;
 4702              		.loc 1 2922 0
 4703 28a0 2600A0E3 		mov	r0, #38
 4704 28a4 FEFFFFEB 		bl	ControlHandle
 4705              	.LVL521:
 4706 28a8 50309DE5 		ldr	r3, [sp, #80]
 4707 28ac 3CFFFFEA 		b	.L260
 4708              	.L269:
 4709              	.LBE421:
 4710              	.LBE435:
 4711              	.LBB436:
 4712              	.LBB337:
2547:../uvc.c      ****     {
 4713              		.loc 1 2547 0
 4714 28b0 0A0C52E3 		cmp	r2, #2560
 4715 28b4 EF00000A 		beq	.L275
 4716 28b8 6800009A 		bls	.L724
 4717 28bc 0D0C52E3 		cmp	r2, #3328
 4718 28c0 EC00000A 		beq	.L275
 4719 28c4 0E0C52E3 		cmp	r2, #3584
 4720 28c8 E600000A 		beq	.L279
 4721 28cc 030B52E3 		cmp	r2, #3072
 4722 28d0 29FFFF1A 		bne	.L295
 4723              	.LVL522:
2588:../uvc.c      ****     		break;
 4724              		.loc 1 2588 0
 4725 28d4 0B00A0E3 		mov	r0, #11
 4726 28d8 FEFFFFEB 		bl	ControlHandle
 4727              	.LVL523:
 4728 28dc 50309DE5 		ldr	r3, [sp, #80]
 4729 28e0 2FFFFFEA 		b	.L260
 4730              	.L712:
 4731              	.LBE337:
 4732              	.LBE436:
 4733              	.LBB437:
 4734              	.LBB308:
2622:../uvc.c      ****     {
 4735              		.loc 1 2622 0
 4736 28e4 030C52E3 		cmp	r2, #768
 4737 28e8 2E01000A 		beq	.L298
 4738 28ec 7C00008A 		bhi	.L299
 4739 28f0 010C52E3 		cmp	r2, #256
 4740 28f4 0F01000A 		beq	.L300
 4741 28f8 020C52E3 		cmp	r2, #512
 4742 28fc 1EFFFF1A 		bne	.L295
 4743              	.LVL524:
2630:../uvc.c      ****     		break;
 4744              		.loc 1 2630 0
 4745 2900 0100A0E3 		mov	r0, #1
 4746 2904 FEFFFFEB 		bl	CTControlHandle
 4747              	.LVL525:
 4748 2908 50309DE5 		ldr	r3, [sp, #80]
 4749 290c 24FFFFEA 		b	.L260
 4750              	.LVL526:
 4751              	.L515:
 4752              	.LBE308:
 4753              	.LBE437:
 4754              	.LBB438:
 4755              	.LBB138:
3073:../uvc.c      ****                 {
 4756              		.loc 1 3073 0
 4757 2910 742B9FE5 		ldr	r2, .L748+20
 4758 2914 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4759 2918 830052E3 		cmp	r2, #131
 4760 291c 8D00009A 		bls	.L725
 4761 2920 860052E3 		cmp	r2, #134
 4762 2924 2000000A 		beq	.L703
 4763 2928 870052E3 		cmp	r2, #135
 4764 292c C600000A 		beq	.L542
 4765              	.L706:
 4766 2930 850052E3 		cmp	r2, #133
 4767 2934 1FFFFF1A 		bne	.L514
 4768              	.L551:
3130:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4769              		.loc 1 3130 0
 4770 2938 1A20A0E3 		mov	r2, #26
3131:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4771              		.loc 1 3131 0
 4772 293c 0030A0E3 		mov	r3, #0
3132:../uvc.c      ****                         break;
 4773              		.loc 1 3132 0
 4774 2940 B01B9FE5 		ldr	r1, .L748+128
 4775 2944 0200A0E3 		mov	r0, #2
3130:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4776              		.loc 1 3130 0
 4777 2948 9C20CBE5 		strb	r2, [fp, #156]
3131:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4778              		.loc 1 3131 0
 4779 294c 9D30CBE5 		strb	r3, [fp, #157]
3132:../uvc.c      ****                         break;
 4780              		.loc 1 3132 0
 4781 2950 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4782              	.LVL527:
 4783 2954 1BFFFFEA 		b	.L527
 4784              	.L517:
2945:../uvc.c      ****             {
 4785              		.loc 1 2945 0
 4786 2958 2C2B9FE5 		ldr	r2, .L748+20
 4787 295c 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4788 2960 830052E3 		cmp	r2, #131
 4789 2964 9800009A 		bls	.L726
 4790 2968 860052E3 		cmp	r2, #134
 4791 296c 0E00000A 		beq	.L703
 4792 2970 870052E3 		cmp	r2, #135
 4793 2974 EDFFFF1A 		bne	.L706
 4794              	.L555:
3213:../uvc.c      ****                         }
 4795              		.loc 1 3213 0
 4796 2978 241B9FE5 		ldr	r1, .L748+44
 4797 297c 1A00A0E3 		mov	r0, #26
 4798 2980 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4799              	.LVL528:
 4800 2984 0FFFFFEA 		b	.L527
 4801              	.L519:
3123:../uvc.c      ****                 {
 4802              		.loc 1 3123 0
 4803 2988 FC2A9FE5 		ldr	r2, .L748+20
 4804 298c 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4805 2990 810052E3 		cmp	r2, #129
 4806 2994 AC00000A 		beq	.L542
 4807 2998 D401009A 		bls	.L727
 4808 299c 850052E3 		cmp	r2, #133
 4809 29a0 E4FFFF0A 		beq	.L551
 4810 29a4 860052E3 		cmp	r2, #134
 4811 29a8 02FFFF1A 		bne	.L514
 4812              	.L703:
3127:../uvc.c      ****                         break;
 4813              		.loc 1 3127 0
 4814 29ac 0300A0E1 		mov	r0, r3
 4815 29b0 401B9FE5 		ldr	r1, .L748+128
3126:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4816              		.loc 1 3126 0
 4817 29b4 0330A0E3 		mov	r3, #3
 4818 29b8 9C30CBE5 		strb	r3, [fp, #156]
3127:../uvc.c      ****                         break;
 4819              		.loc 1 3127 0
 4820 29bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4821              	.LVL529:
 4822 29c0 00FFFFEA 		b	.L527
 4823              	.LVL530:
 4824              	.L271:
 4825              	.LBE138:
 4826              	.LBE438:
 4827              	.LBB439:
 4828              	.LBB338:
2547:../uvc.c      ****     {
 4829              		.loc 1 2547 0
 4830 29c4 010B52E3 		cmp	r2, #1024
 4831 29c8 F5FEFF0A 		beq	.L260
 4832 29cc 050C52E3 		cmp	r2, #1280
 4833 29d0 E9FEFF1A 		bne	.L295
 4834              	.LVL531:
 4835              	.LBB323:
 4836              	.LBB324:
 418:../uvc.c      ****     /*
 4837              		.loc 1 418 0
 4838 29d4 B03A9FE5 		ldr	r3, .L748+20
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 4839              		.loc 1 409 0
 4840 29d8 E001DAE5 		ldrb	r0, [r10, #480]	@ zero_extendqisi2
 4841              	.LVL532:
 418:../uvc.c      ****     /*
 4842              		.loc 1 418 0
 4843 29dc 0070D3E5 		ldrb	r7, [r3]	@ zero_extendqisi2
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 4844              		.loc 1 411 0
 4845 29e0 EF11DAE5 		ldrb	r1, [r10, #495]	@ zero_extendqisi2
 4846              	.LVL533:
 426:../uvc.c      **** 		 {
 4847              		.loc 1 426 0
 4848 29e4 830057E3 		cmp	r7, #131
 412:../uvc.c      ****     }
 4849              		.loc 1 412 0
 4850 29e8 E281DAE5 		ldrb	r8, [r10, #482]	@ zero_extendqisi2
 4851              	.LVL534:
 426:../uvc.c      **** 		 {
 4852              		.loc 1 426 0
 4853 29ec 6006000A 		beq	.L282
 4854 29f0 C202009A 		bls	.L728
 4855 29f4 850057E3 		cmp	r7, #133
 4856 29f8 5806000A 		beq	.L287
 4857 29fc 1605003A 		bcc	.L288
 4858 2a00 860057E3 		cmp	r7, #134
 4859 2a04 4906000A 		beq	.L289
 4860 2a08 870057E3 		cmp	r7, #135
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 4861              		.loc 1 657 0
 4862 2a0c EB21DA05 		ldreqb	r2, [r10, #491]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 4863              		.loc 1 658 0
 4864 2a10 EC31DA05 		ldreqb	r3, [r10, #492]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 4865              		.loc 1 426 0
 4866 2a14 DC05001A 		bne	.L281
 4867              	.L676:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4868              		.loc 1 597 0
 4869 2a18 D81A9FE5 		ldr	r1, .L748+128
 4870 2a1c 0800A0E1 		mov	r0, r8
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 4871              		.loc 1 594 0
 4872 2a20 9C20CBE5 		strb	r2, [fp, #156]
 4873              	.L675:
 595:../uvc.c      **** 			 }
 4874              		.loc 1 595 0
 4875 2a24 9D30CBE5 		strb	r3, [fp, #157]
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4876              		.loc 1 597 0
 4877 2a28 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4878              	.LVL535:
 598:../uvc.c      **** 			  break;
 4879              		.loc 1 598 0
 4880 2a2c 9C20DBE5 		ldrb	r2, [fp, #156]	@ zero_extendqisi2
 4881              	.LVL536:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 4882              		.loc 1 414 0
 4883 2a30 FF80A0E3 		mov	r8, #255
 4884              	.LVL537:
 4885 2a34 0830A0E1 		mov	r3, r8
 4886              	.LVL538:
 4887              	.L291:
 960:../uvc.c      **** }
 4888              		.loc 1 960 0
 4889 2a38 04208DE5 		str	r2, [sp, #4]
 4890 2a3c FF10A0E3 		mov	r1, #255
 4891 2a40 0720A0E1 		mov	r2, r7
 4892              	.LVL539:
 4893 2a44 00808DE5 		str	r8, [sp]
 4894              	.LVL540:
 4895              	.L699:
 4896              	.LBE324:
 4897              	.LBE323:
 4898              	.LBE338:
 4899              	.LBE439:
 4900              	.LBB440:
 4901              	.LBB422:
 4902              	.LBB349:
 4903              	.LBB350:
 4904 2a48 08108DE5 		str	r1, [sp, #8]
 4905 2a4c 0400A0E3 		mov	r0, #4
 4906 2a50 841A9FE5 		ldr	r1, .L748+100
 4907 2a54 FEFFFFEB 		bl	CyU3PDebugPrint
 4908              	.LVL541:
 4909 2a58 50309DE5 		ldr	r3, [sp, #80]
 4910 2a5c D0FEFFEA 		b	.L260
 4911              	.L724:
 4912              	.LBE350:
 4913              	.LBE349:
 4914              	.LBE422:
 4915              	.LBE440:
 4916              	.LBB441:
 4917              	.LBB339:
2547:../uvc.c      ****     {
 4918              		.loc 1 2547 0
 4919 2a60 070C52E3 		cmp	r2, #1792
 4920 2a64 8B00000A 		beq	.L277
 4921 2a68 020B52E3 		cmp	r2, #2048
 4922 2a6c C2FEFF1A 		bne	.L295
 4923              	.LVL542:
2578:../uvc.c      ****           		break;
 4924              		.loc 1 2578 0
 4925 2a70 0700A0E3 		mov	r0, #7
 4926 2a74 FEFFFFEB 		bl	ControlHandle
 4927              	.LVL543:
 4928 2a78 50309DE5 		ldr	r3, [sp, #80]
 4929 2a7c C8FEFFEA 		b	.L260
 4930              	.L717:
 4931              	.LBE339:
 4932              	.LBE441:
 4933              	.LBB442:
 4934              	.LBB423:
2847:../uvc.c      ****     {
 4935              		.loc 1 2847 0
 4936 2a80 020C53E3 		cmp	r3, #512
 4937 2a84 2102000A 		beq	.L437
 4938 2a88 030C53E3 		cmp	r3, #768
 4939 2a8c 1B02000A 		beq	.L438
 4940 2a90 010C53E3 		cmp	r3, #256
 4941 2a94 BDFEFF1A 		bne	.L261
 4942              	.LVL544:
2851:../uvc.c      ****     		break;
 4943              		.loc 1 2851 0
 4944 2a98 1000A0E3 		mov	r0, #16
 4945 2a9c FEFFFFEB 		bl	ControlHandle
 4946              	.LVL545:
 4947 2aa0 50309DE5 		ldr	r3, [sp, #80]
 4948 2aa4 BEFEFFEA 		b	.L260
 4949              	.L722:
2847:../uvc.c      ****     {
 4950              		.loc 1 2847 0
 4951 2aa8 0B0C53E3 		cmp	r3, #2816
 4952 2aac FBFEFF0A 		beq	.L447
 4953 2ab0 0D0C53E3 		cmp	r3, #3328
 4954 2ab4 6402000A 		beq	.L448
 4955 2ab8 0A0C53E3 		cmp	r3, #2560
 4956 2abc B3FEFF1A 		bne	.L261
 4957              	.LVL546:
2888:../uvc.c      ****     		}else/* no support for 1080p camera */
 4958              		.loc 1 2888 0
 4959 2ac0 1900A0E3 		mov	r0, #25
 4960 2ac4 FEFFFFEB 		bl	ControlHandle
 4961              	.LVL547:
 4962 2ac8 50309DE5 		ldr	r3, [sp, #80]
 4963 2acc B4FEFFEA 		b	.L260
 4964              	.L713:
 4965              	.LBE423:
 4966              	.LBE442:
 4967              	.LBB443:
 4968              	.LBB309:
2622:../uvc.c      ****     {
 4969              		.loc 1 2622 0
 4970 2ad0 070C52E3 		cmp	r2, #1792
 4971 2ad4 C400000A 		beq	.L306
 4972 2ad8 020B52E3 		cmp	r2, #2048
 4973 2adc B0FEFF0A 		beq	.L260
 4974 2ae0 A5FEFFEA 		b	.L295
 4975              	.L299:
 4976 2ae4 010B52E3 		cmp	r2, #1024
 4977 2ae8 EC00000A 		beq	.L302
 4978 2aec 050C52E3 		cmp	r2, #1280
 4979 2af0 A1FEFF1A 		bne	.L295
 4980              	.LVL548:
 4981              	.LBB148:
 4982              	.LBB149:
 984:../uvc.c      **** 
 4983              		.loc 1 984 0
 4984 2af4 90C99FE5 		ldr	ip, .L748+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4985              		.loc 1 979 0
 4986 2af8 F284DAE5 		ldrb	r8, [r10, #1266]	@ zero_extendqisi2
 4987              	.LVL549:
 984:../uvc.c      **** 
 4988              		.loc 1 984 0
 4989 2afc 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 4990              	.LVL550:
 986:../uvc.c      **** 		 {
 4991              		.loc 1 986 0
 4992 2b00 830057E3 		cmp	r7, #131
 4993 2b04 A806000A 		beq	.L348
 4994 2b08 F702009A 		bls	.L729
 4995 2b0c 850057E3 		cmp	r7, #133
 4996 2b10 D901000A 		beq	.L410
 4997 2b14 2305003A 		bcc	.L354
 4998 2b18 860057E3 		cmp	r7, #134
 4999 2b1c 5006000A 		beq	.L355
 5000 2b20 870057E3 		cmp	r7, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5001              		.loc 1 1048 0
 5002 2b24 FB14DA05 		ldreqb	r1, [r10, #1275]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5003              		.loc 1 1049 0
 5004 2b28 FC24DA05 		ldreqb	r2, [r10, #1276]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5005              		.loc 1 986 0
 5006 2b2c DD05001A 		bne	.L347
 5007              	.LVL551:
 5008              	.L685:
 5009              	.LBE149:
 5010              	.LBE148:
 5011              	.LBB157:
 5012              	.LBB158:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5013              		.loc 1 1027 0
 5014 2b30 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5015              		.loc 1 1024 0
 5016 2b34 9C10CBE5 		strb	r1, [fp, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5017              		.loc 1 1029 0
 5018 2b38 0800A0E1 		mov	r0, r8
 5019 2b3c B4199FE5 		ldr	r1, .L748+128
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5020              		.loc 1 1025 0
 5021 2b40 9D20CBE5 		strb	r2, [fp, #157]
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5022              		.loc 1 1027 0
 5023 2b44 9E30CBE5 		strb	r3, [fp, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5024              		.loc 1 1028 0
 5025 2b48 9F30CBE5 		strb	r3, [fp, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5026              		.loc 1 1029 0
 5027 2b4c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5028              	.LVL552:
1030:../uvc.c      **** 			  break;
 5029              		.loc 1 1030 0
 5030 2b50 9C20DBE5 		ldrb	r2, [fp, #156]	@ zero_extendqisi2
 5031              	.LVL553:
 5032 2b54 CF0100EA 		b	.L414
 5033              	.LVL554:
 5034              	.L725:
 5035              	.LBE158:
 5036              	.LBE157:
 5037              	.LBE309:
 5038              	.LBE443:
 5039              	.LBB444:
 5040              	.LBB139:
3073:../uvc.c      ****                 {
 5041              		.loc 1 3073 0
 5042 2b58 810052E3 		cmp	r2, #129
 5043 2b5c 3A00002A 		bcs	.L542
 5044 2b60 010052E3 		cmp	r2, #1
 5045 2b64 93FEFF1A 		bne	.L514
3098:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5046              		.loc 1 3098 0
 5047 2b68 2000A0E3 		mov	r0, #32
 5048 2b6c 34199FE5 		ldr	r1, .L748+48
 5049 2b70 48208DE2 		add	r2, sp, #72
 5050 2b74 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5051              	.LVL555:
3100:../uvc.c      ****                         {
 5052              		.loc 1 3100 0
 5053 2b78 000050E3 		cmp	r0, #0
 5054 2b7c 91FEFF1A 		bne	.L527
3106:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5055              		.loc 1 3106 0
 5056 2b80 C510D4E5 		ldrb	r1, [r4, #197]	@ zero_extendqisi2
3107:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5057              		.loc 1 3107 0
 5058 2b84 C6C0D4E5 		ldrb	ip, [r4, #198]	@ zero_extendqisi2
3109:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5059              		.loc 1 3109 0
 5060 2b88 C800D4E5 		ldrb	r0, [r4, #200]	@ zero_extendqisi2
 5061              	.LVL556:
3108:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5062              		.loc 1 3108 0
 5063 2b8c C7E0D4E5 		ldrb	lr, [r4, #199]	@ zero_extendqisi2
3113:../uvc.c      ****                         }
 5064              		.loc 1 3113 0
 5065 2b90 C430D4E5 		ldrb	r3, [r4, #196]	@ zero_extendqisi2
3106:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5066              		.loc 1 3106 0
 5067 2b94 2D16CAE5 		strb	r1, [r10, #1581]
3113:../uvc.c      ****                         }
 5068              		.loc 1 3113 0
 5069 2b98 00108DE5 		str	r1, [sp]
3110:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5070              		.loc 1 3110 0
 5071 2b9c C910D4E5 		ldrb	r1, [r4, #201]	@ zero_extendqisi2
3107:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5072              		.loc 1 3107 0
 5073 2ba0 2EC6CAE5 		strb	ip, [r10, #1582]
3111:../uvc.c      ****                             }
 5074              		.loc 1 3111 0
 5075 2ba4 CAC0D4E5 		ldrb	ip, [r4, #202]	@ zero_extendqisi2
3109:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5076              		.loc 1 3109 0
 5077 2ba8 3006CAE5 		strb	r0, [r10, #1584]
3110:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5078              		.loc 1 3110 0
 5079 2bac 3116CAE5 		strb	r1, [r10, #1585]
3113:../uvc.c      ****                         }
 5080              		.loc 1 3113 0
 5081 2bb0 B824DDE1 		ldrh	r2, [sp, #72]
 5082 2bb4 F0189FE5 		ldr	r1, .L748+52
 5083 2bb8 0400A0E3 		mov	r0, #4
3108:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5084              		.loc 1 3108 0
 5085 2bbc 2FE6CAE5 		strb	lr, [r10, #1583]
3111:../uvc.c      ****                             }
 5086              		.loc 1 3111 0
 5087 2bc0 32C6CAE5 		strb	ip, [r10, #1586]
3113:../uvc.c      ****                         }
 5088              		.loc 1 3113 0
 5089 2bc4 FEFFFFEB 		bl	CyU3PDebugPrint
 5090              	.LVL557:
 5091 2bc8 7EFEFFEA 		b	.L527
 5092              	.LVL558:
 5093              	.L726:
2945:../uvc.c      ****             {
 5094              		.loc 1 2945 0
 5095 2bcc 810052E3 		cmp	r2, #129
 5096 2bd0 68FFFF2A 		bcs	.L555
 5097 2bd4 010052E3 		cmp	r2, #1
 5098 2bd8 76FEFF1A 		bne	.L514
2970:../uvc.c      ****                             glCommitCtrl, &readCount);
 5099              		.loc 1 2970 0
 5100 2bdc 2000A0E3 		mov	r0, #32
 5101 2be0 C0189FE5 		ldr	r1, .L748+48
 5102 2be4 48208DE2 		add	r2, sp, #72
 5103 2be8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5104              	.LVL559:
2972:../uvc.c      ****                     {
 5105              		.loc 1 2972 0
 5106 2bec 000050E3 		cmp	r0, #0
 5107 2bf0 74FEFF1A 		bne	.L527
2980:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 5108              		.loc 1 2980 0
 5109 2bf4 C8E0D4E5 		ldrb	lr, [r4, #200]	@ zero_extendqisi2
2982:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 5110              		.loc 1 2982 0
 5111 2bf8 CA00D4E5 		ldrb	r0, [r4, #202]	@ zero_extendqisi2
 5112              	.LVL560:
2983:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
 5113              		.loc 1 2983 0
 5114 2bfc CB10D4E5 		ldrb	r1, [r4, #203]	@ zero_extendqisi2
2979:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 5115              		.loc 1 2979 0
 5116 2c00 C770D4E5 		ldrb	r7, [r4, #199]	@ zero_extendqisi2
2981:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 5117              		.loc 1 2981 0
 5118 2c04 C9C0D4E5 		ldrb	ip, [r4, #201]	@ zero_extendqisi2
2984:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5119              		.loc 1 2984 0
 5120 2c08 C430D4E5 		ldrb	r3, [r4, #196]	@ zero_extendqisi2
2980:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 5121              		.loc 1 2980 0
 5122 2c0c 14E6CAE5 		strb	lr, [r10, #1556]
2984:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5123              		.loc 1 2984 0
 5124 2c10 0C008DE5 		str	r0, [sp, #12]
 5125 2c14 10108DE5 		str	r1, [sp, #16]
 5126 2c18 80408DE8 		stmia	sp, {r7, lr}
 5127 2c1c B824DDE1 		ldrh	r2, [sp, #72]
 5128 2c20 08C08DE5 		str	ip, [sp, #8]
2978:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 5129              		.loc 1 2978 0
 5130 2c24 C6E0D4E5 		ldrb	lr, [r4, #198]	@ zero_extendqisi2
2982:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 5131              		.loc 1 2982 0
 5132 2c28 1606CAE5 		strb	r0, [r10, #1558]
2983:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
 5133              		.loc 1 2983 0
 5134 2c2c 1716CAE5 		strb	r1, [r10, #1559]
2984:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5135              		.loc 1 2984 0
 5136 2c30 0400A0E3 		mov	r0, #4
 5137 2c34 74189FE5 		ldr	r1, .L748+56
2979:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 5138              		.loc 1 2979 0
 5139 2c38 1376CAE5 		strb	r7, [r10, #1555]
2981:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 5140              		.loc 1 2981 0
 5141 2c3c 15C6CAE5 		strb	ip, [r10, #1557]
2978:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 5142              		.loc 1 2978 0
 5143 2c40 12E6CAE5 		strb	lr, [r10, #1554]
2984:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5144              		.loc 1 2984 0
 5145 2c44 FEFFFFEB 		bl	CyU3PDebugPrint
 5146              	.LVL561:
 5147 2c48 5EFEFFEA 		b	.L527
 5148              	.LVL562:
 5149              	.L542:
3088:../uvc.c      ****                         {
 5150              		.loc 1 3088 0
 5151 2c4c C030DBE5 		ldrb	r3, [fp, #192]	@ zero_extendqisi2
3090:../uvc.c      ****                         }
 5152              		.loc 1 3090 0
 5153 2c50 0B00A0E3 		mov	r0, #11
3088:../uvc.c      ****                         {
 5154              		.loc 1 3088 0
 5155 2c54 030053E3 		cmp	r3, #3
3090:../uvc.c      ****                         }
 5156              		.loc 1 3090 0
 5157 2c58 54189F05 		ldreq	r1, .L748+60
3094:../uvc.c      ****                         }
 5158              		.loc 1 3094 0
 5159 2c5c 54189F15 		ldrne	r1, .L748+64
 5160 2c60 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5161              	.LVL563:
 5162 2c64 57FEFFEA 		b	.L527
 5163              	.LVL564:
 5164              	.L279:
 5165              	.LBE139:
 5166              	.LBE444:
 5167              	.LBB445:
 5168              	.LBB340:
2592:../uvc.c      ****     		break;
 5169              		.loc 1 2592 0
 5170 2c68 0E00A0E3 		mov	r0, #14
 5171 2c6c FEFFFFEB 		bl	ControlHandle
 5172              	.LVL565:
 5173 2c70 50309DE5 		ldr	r3, [sp, #80]
 5174 2c74 4AFEFFEA 		b	.L260
 5175              	.L275:
 5176              	.LVL566:
2584:../uvc.c      ****     		break;
 5177              		.loc 1 2584 0
 5178 2c78 0900A0E3 		mov	r0, #9
 5179 2c7c FEFFFFEB 		bl	ControlHandle
 5180              	.LVL567:
 5181 2c80 50309DE5 		ldr	r3, [sp, #80]
 5182 2c84 46FEFFEA 		b	.L260
 5183              	.L272:
 5184              	.LVL568:
2551:../uvc.c      ****     		break;
 5185              		.loc 1 2551 0
 5186 2c88 0000A0E3 		mov	r0, #0
 5187 2c8c FEFFFFEB 		bl	ControlHandle
 5188              	.LVL569:
 5189 2c90 50309DE5 		ldr	r3, [sp, #80]
 5190 2c94 42FEFFEA 		b	.L260
 5191              	.L277:
 5192              	.LVL570:
2574:../uvc.c      ****           		break;
 5193              		.loc 1 2574 0
 5194 2c98 0600A0E3 		mov	r0, #6
 5195 2c9c FEFFFFEB 		bl	ControlHandle
 5196              	.LVL571:
 5197 2ca0 50309DE5 		ldr	r3, [sp, #80]
 5198 2ca4 3EFEFFEA 		b	.L260
 5199              	.L270:
 5200              	.LVL572:
2559:../uvc.c      **** 			break;
 5201              		.loc 1 2559 0
 5202 2ca8 0200A0E3 		mov	r0, #2
 5203 2cac FEFFFFEB 		bl	ControlHandle
 5204              	.LVL573:
 5205 2cb0 50309DE5 		ldr	r3, [sp, #80]
 5206 2cb4 3AFEFFEA 		b	.L260
 5207              	.L268:
 5208              	.LVL574:
2570:../uvc.c      ****      		break;
 5209              		.loc 1 2570 0
 5210 2cb8 0500A0E3 		mov	r0, #5
 5211 2cbc FEFFFFEB 		bl	ControlHandle
 5212              	.LVL575:
 5213 2cc0 50309DE5 		ldr	r3, [sp, #80]
 5214 2cc4 36FEFFEA 		b	.L260
 5215              	.L714:
 5216              	.LVL576:
 5217              	.LBE340:
 5218              	.LBE445:
 5219              	.LBB446:
 5220              	.LBB310:
 5221              	.LBB168:
 5222              	.LBB169:
 984:../uvc.c      **** 
 5223              		.loc 1 984 0
 5224 2cc8 BCC79FE5 		ldr	ip, .L748+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5225              		.loc 1 979 0
 5226 2ccc 5285DAE5 		ldrb	r8, [r10, #1362]	@ zero_extendqisi2
 5227              	.LVL577:
 984:../uvc.c      **** 
 5228              		.loc 1 984 0
 5229 2cd0 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5230              	.LVL578:
 986:../uvc.c      **** 		 {
 5231              		.loc 1 986 0
 5232 2cd4 830057E3 		cmp	r7, #131
 5233 2cd8 2706000A 		beq	.L394
 5234 2cdc 6E02009A 		bls	.L730
 5235 2ce0 850057E3 		cmp	r7, #133
 5236 2ce4 6401000A 		beq	.L410
 5237 2ce8 F004003A 		bcc	.L400
 5238 2cec 860057E3 		cmp	r7, #134
 5239 2cf0 C805000A 		beq	.L401
 5240 2cf4 870057E3 		cmp	r7, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5241              		.loc 1 1048 0
 5242 2cf8 5B15DA05 		ldreqb	r1, [r10, #1371]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5243              		.loc 1 1049 0
 5244 2cfc 5C25DA05 		ldreqb	r2, [r10, #1372]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5245              		.loc 1 986 0
 5246 2d00 8AFFFF0A 		beq	.L685
 5247              	.L393:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5248              		.loc 1 1193 0
 5249 2d04 0000A0E3 		mov	r0, #0
 5250 2d08 0020A0E1 		mov	r2, r0
 5251 2d0c 0110A0E3 		mov	r1, #1
 5252 2d10 24C08DE5 		str	ip, [sp, #36]
 5253 2d14 FEFFFFEB 		bl	CyU3PUsbStall
 5254              	.LVL579:
1194:../uvc.c      **** 			  break;
 5255              		.loc 1 1194 0
 5256 2d18 24C09DE5 		ldr	ip, [sp, #36]
 5257 2d1c 0820A0E3 		mov	r2, #8
 5258 2d20 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5259 2d24 0400A0E3 		mov	r0, #4
 5260 2d28 C0179FE5 		ldr	r1, .L748+120
 5261 2d2c FEFFFFEB 		bl	CyU3PDebugPrint
 5262              	.LVL580:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5263              		.loc 1 980 0
 5264 2d30 FF20A0E3 		mov	r2, #255
 5265              	.LVL581:
 5266 2d34 570100EA 		b	.L414
 5267              	.LVL582:
 5268              	.L300:
 5269              	.LBE169:
 5270              	.LBE168:
 5271              	.LBB176:
 5272              	.LBB177:
 984:../uvc.c      **** 
 5273              		.loc 1 984 0
 5274 2d38 4CC79FE5 		ldr	ip, .L748+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5275              		.loc 1 979 0
 5276 2d3c 9284DAE5 		ldrb	r8, [r10, #1170]	@ zero_extendqisi2
 5277              	.LVL583:
 984:../uvc.c      **** 
 5278              		.loc 1 984 0
 5279 2d40 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5280              	.LVL584:
 986:../uvc.c      **** 		 {
 5281              		.loc 1 986 0
 5282 2d44 830057E3 		cmp	r7, #131
 5283 2d48 1306000A 		beq	.L311
 5284 2d4c 1502009A 		bls	.L731
 5285 2d50 850057E3 		cmp	r7, #133
 5286 2d54 4801000A 		beq	.L410
 5287 2d58 9504003A 		bcc	.L317
 5288 2d5c 860057E3 		cmp	r7, #134
 5289 2d60 B205000A 		beq	.L318
 5290 2d64 870057E3 		cmp	r7, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5291              		.loc 1 1048 0
 5292 2d68 9B14DA05 		ldreqb	r1, [r10, #1179]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5293              		.loc 1 1049 0
 5294 2d6c 9C24DA05 		ldreqb	r2, [r10, #1180]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5295              		.loc 1 986 0
 5296 2d70 6EFFFF0A 		beq	.L685
 5297              	.L310:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5298              		.loc 1 1193 0
 5299 2d74 0000A0E3 		mov	r0, #0
 5300 2d78 0020A0E1 		mov	r2, r0
 5301 2d7c 0110A0E3 		mov	r1, #1
 5302 2d80 24C08DE5 		str	ip, [sp, #36]
 5303 2d84 FEFFFFEB 		bl	CyU3PUsbStall
 5304              	.LVL585:
1194:../uvc.c      **** 			  break;
 5305              		.loc 1 1194 0
 5306 2d88 24C09DE5 		ldr	ip, [sp, #36]
 5307 2d8c 0020A0E3 		mov	r2, #0
 5308 2d90 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5309 2d94 0400A0E3 		mov	r0, #4
 5310 2d98 50179FE5 		ldr	r1, .L748+120
 5311 2d9c FEFFFFEB 		bl	CyU3PDebugPrint
 5312              	.LVL586:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5313              		.loc 1 980 0
 5314 2da0 FF20A0E3 		mov	r2, #255
 5315              	.LVL587:
 5316 2da4 3B0100EA 		b	.L414
 5317              	.LVL588:
 5318              	.L298:
 5319              	.LBE177:
 5320              	.LBE176:
 5321              	.LBB184:
 5322              	.LBB185:
 984:../uvc.c      **** 
 5323              		.loc 1 984 0
 5324 2da8 DCC69FE5 		ldr	ip, .L748+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5325              		.loc 1 979 0
 5326 2dac C284DAE5 		ldrb	r8, [r10, #1218]	@ zero_extendqisi2
 5327              	.LVL589:
 984:../uvc.c      **** 
 5328              		.loc 1 984 0
 5329 2db0 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5330              	.LVL590:
 986:../uvc.c      **** 		 {
 5331              		.loc 1 986 0
 5332 2db4 830057E3 		cmp	r7, #131
 5333 2db8 EB05000A 		beq	.L322
 5334 2dbc 0D02009A 		bls	.L732
 5335 2dc0 850057E3 		cmp	r7, #133
 5336 2dc4 2C01000A 		beq	.L410
 5337 2dc8 4804003A 		bcc	.L328
 5338 2dcc 860057E3 		cmp	r7, #134
 5339 2dd0 8505000A 		beq	.L329
 5340 2dd4 870057E3 		cmp	r7, #135
 5341 2dd8 3F05001A 		bne	.L321
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5342              		.loc 1 1048 0
 5343 2ddc 98E69FE5 		ldr	lr, .L748+4
 5344 2de0 CB14DEE5 		ldrb	r1, [lr, #1227]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5345              		.loc 1 1049 0
 5346 2de4 CC24DEE5 		ldrb	r2, [lr, #1228]	@ zero_extendqisi2
 5347 2de8 50FFFFEA 		b	.L685
 5348              	.LVL591:
 5349              	.L306:
 5350              	.LBE185:
 5351              	.LBE184:
 5352              	.LBB192:
 5353              	.LBB193:
 984:../uvc.c      **** 
 5354              		.loc 1 984 0
 5355 2dec 98C69FE5 		ldr	ip, .L748+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5356              		.loc 1 979 0
 5357 2df0 2285DAE5 		ldrb	r8, [r10, #1314]	@ zero_extendqisi2
 5358              	.LVL592:
 984:../uvc.c      **** 
 5359              		.loc 1 984 0
 5360 2df4 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5361              	.LVL593:
 986:../uvc.c      **** 		 {
 5362              		.loc 1 986 0
 5363 2df8 830057E3 		cmp	r7, #131
 5364 2dfc FC05000A 		beq	.L370
 5365 2e00 9602009A 		bls	.L733
 5366 2e04 850057E3 		cmp	r7, #133
 5367 2e08 1B01000A 		beq	.L410
 5368 2e0c 3304003A 		bcc	.L376
 5369 2e10 860057E3 		cmp	r7, #134
 5370 2e14 7D05000A 		beq	.L377
 5371 2e18 870057E3 		cmp	r7, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5372              		.loc 1 1048 0
 5373 2e1c 2B15DA05 		ldreqb	r1, [r10, #1323]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5374              		.loc 1 1049 0
 5375 2e20 2C25DA05 		ldreqb	r2, [r10, #1324]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5376              		.loc 1 986 0
 5377 2e24 41FFFF0A 		beq	.L685
 5378              	.L369:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5379              		.loc 1 1193 0
 5380 2e28 0000A0E3 		mov	r0, #0
 5381 2e2c 0020A0E1 		mov	r2, r0
 5382 2e30 0110A0E3 		mov	r1, #1
 5383 2e34 24C08DE5 		str	ip, [sp, #36]
 5384 2e38 FEFFFFEB 		bl	CyU3PUsbStall
 5385              	.LVL594:
1194:../uvc.c      **** 			  break;
 5386              		.loc 1 1194 0
 5387 2e3c 24C09DE5 		ldr	ip, [sp, #36]
 5388 2e40 0620A0E3 		mov	r2, #6
 5389 2e44 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5390 2e48 0400A0E3 		mov	r0, #4
 5391 2e4c 9C169FE5 		ldr	r1, .L748+120
 5392 2e50 FEFFFFEB 		bl	CyU3PDebugPrint
 5393              	.LVL595:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5394              		.loc 1 980 0
 5395 2e54 FF20A0E3 		mov	r2, #255
 5396              	.LVL596:
 5397 2e58 0E0100EA 		b	.L414
 5398              	.LVL597:
 5399              	.L296:
 5400              	.LBE193:
 5401              	.LBE192:
 5402              	.LBB200:
 5403              	.LBB201:
 984:../uvc.c      **** 
 5404              		.loc 1 984 0
 5405 2e5c 28C69FE5 		ldr	ip, .L748+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5406              		.loc 1 979 0
 5407 2e60 0A85DAE5 		ldrb	r8, [r10, #1290]	@ zero_extendqisi2
 5408              	.LVL598:
 984:../uvc.c      **** 
 5409              		.loc 1 984 0
 5410 2e64 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5411              	.LVL599:
 986:../uvc.c      **** 		 {
 5412              		.loc 1 986 0
 5413 2e68 830057E3 		cmp	r7, #131
 5414 2e6c E405000A 		beq	.L359
 5415 2e70 3102009A 		bls	.L734
 5416 2e74 850057E3 		cmp	r7, #133
 5417 2e78 FF00000A 		beq	.L410
 5418 2e7c 1304003A 		bcc	.L365
 5419 2e80 860057E3 		cmp	r7, #134
 5420 2e84 7805000A 		beq	.L366
 5421 2e88 870057E3 		cmp	r7, #135
 5422 2e8c C604001A 		bne	.L358
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5423              		.loc 1 1048 0
 5424 2e90 E4E59FE5 		ldr	lr, .L748+4
 5425 2e94 1315DEE5 		ldrb	r1, [lr, #1299]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5426              		.loc 1 1049 0
 5427 2e98 1425DEE5 		ldrb	r2, [lr, #1300]	@ zero_extendqisi2
 5428 2e9c 23FFFFEA 		b	.L685
 5429              	.LVL600:
 5430              	.L302:
 5431              	.LBE201:
 5432              	.LBE200:
 5433              	.LBB209:
 5434              	.LBB210:
 984:../uvc.c      **** 
 5435              		.loc 1 984 0
 5436 2ea0 E4C59FE5 		ldr	ip, .L748+20
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5437              		.loc 1 977 0
 5438 2ea4 D874DAE5 		ldrb	r7, [r10, #1240]	@ zero_extendqisi2
 984:../uvc.c      **** 
 5439              		.loc 1 984 0
 5440 2ea8 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5441              		.loc 1 977 0
 5442 2eac 30708DE5 		str	r7, [sp, #48]
 986:../uvc.c      **** 		 {
 5443              		.loc 1 986 0
 5444 2eb0 830058E3 		cmp	r8, #131
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5445              		.loc 1 976 0
 5446 2eb4 E734DAE5 		ldrb	r3, [r10, #1255]	@ zero_extendqisi2
 5447              	.LVL601:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5448              		.loc 1 979 0
 5449 2eb8 DA74DAE5 		ldrb	r7, [r10, #1242]	@ zero_extendqisi2
 5450              	.LVL602:
 986:../uvc.c      **** 		 {
 5451              		.loc 1 986 0
 5452 2ebc 9C05000A 		beq	.L333
 5453 2ec0 7A02009A 		bls	.L735
 5454 2ec4 850058E3 		cmp	r8, #133
 5455 2ec8 9D05000A 		beq	.L338
 5456 2ecc 5404003A 		bcc	.L339
 5457 2ed0 860058E3 		cmp	r8, #134
 5458 2ed4 6F05000A 		beq	.L340
 5459 2ed8 870058E3 		cmp	r8, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5460              		.loc 1 1048 0
 5461 2edc E314DA05 		ldreqb	r1, [r10, #1251]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5462              		.loc 1 1049 0
 5463 2ee0 E424DA05 		ldreqb	r2, [r10, #1252]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5464              		.loc 1 986 0
 5465 2ee4 CE04001A 		bne	.L332
 5466              	.L679:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5467              		.loc 1 1027 0
 5468 2ee8 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5469              		.loc 1 1024 0
 5470 2eec 9C10CBE5 		strb	r1, [fp, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5471              		.loc 1 1029 0
 5472 2ef0 0700A0E1 		mov	r0, r7
 5473 2ef4 FC159FE5 		ldr	r1, .L748+128
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5474              		.loc 1 1025 0
 5475 2ef8 9D20CBE5 		strb	r2, [fp, #157]
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5476              		.loc 1 1027 0
 5477 2efc 9E30CBE5 		strb	r3, [fp, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5478              		.loc 1 1028 0
 5479 2f00 9F30CBE5 		strb	r3, [fp, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5480              		.loc 1 1029 0
 5481 2f04 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5482              	.LVL603:
1030:../uvc.c      **** 			  break;
 5483              		.loc 1 1030 0
 5484 2f08 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
 5485              	.LVL604:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5486              		.loc 1 980 0
 5487 2f0c FF20A0E3 		mov	r2, #255
 5488 2f10 0230A0E1 		mov	r3, r2
 5489              	.LVL605:
 5490              	.L342:
1199:../uvc.c      **** }
 5491              		.loc 1 1199 0
 5492 2f14 9E10DBE5 		ldrb	r1, [fp, #158]	@ zero_extendqisi2
 5493 2f18 FF00A0E3 		mov	r0, #255
 5494 2f1c 00208DE5 		str	r2, [sp]
 5495 2f20 08C08DE5 		str	ip, [sp, #8]
 5496 2f24 14708DE5 		str	r7, [sp, #20]
 5497 2f28 0820A0E1 		mov	r2, r8
 5498              	.LVL606:
 5499 2f2c 260000EA 		b	.L700
 5500              	.LVL607:
 5501              	.L308:
 5502              	.LBE210:
 5503              	.LBE209:
 5504              	.LBB217:
 5505              	.LBB218:
 984:../uvc.c      **** 
 5506              		.loc 1 984 0
 5507 2f30 54C59FE5 		ldr	ip, .L748+20
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5508              		.loc 1 977 0
 5509 2f34 80E5DAE5 		ldrb	lr, [r10, #1408]	@ zero_extendqisi2
 984:../uvc.c      **** 
 5510              		.loc 1 984 0
 5511 2f38 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5512              		.loc 1 979 0
 5513 2f3c 8215DAE5 		ldrb	r1, [r10, #1410]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5514              		.loc 1 986 0
 5515 2f40 830057E3 		cmp	r7, #131
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5516              		.loc 1 976 0
 5517 2f44 8F35DAE5 		ldrb	r3, [r10, #1423]	@ zero_extendqisi2
 5518              	.LVL608:
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5519              		.loc 1 977 0
 5520 2f48 34E08DE5 		str	lr, [sp, #52]
 5521              	.LVL609:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5522              		.loc 1 979 0
 5523 2f4c 30108DE5 		str	r1, [sp, #48]
 5524              	.LVL610:
 986:../uvc.c      **** 		 {
 5525              		.loc 1 986 0
 5526 2f50 AF05000A 		beq	.L416
 5527 2f54 0D02009A 		bls	.L736
 5528 2f58 850057E3 		cmp	r7, #133
 5529 2f5c 0805000A 		beq	.L421
 5530 2f60 EE03003A 		bcc	.L422
 5531 2f64 860057E3 		cmp	r7, #134
 5532 2f68 5405000A 		beq	.L423
 5533 2f6c 870057E3 		cmp	r7, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5534              		.loc 1 1048 0
 5535 2f70 8B05DA05 		ldreqb	r0, [r10, #1419]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5536              		.loc 1 1049 0
 5537 2f74 8C15DA05 		ldreqb	r1, [r10, #1420]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5538              		.loc 1 986 0
 5539 2f78 BA04001A 		bne	.L415
 5540              	.L687:
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5541              		.loc 1 1026 0
 5542 2f7c 0120A0E3 		mov	r2, #1
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5543              		.loc 1 1028 0
 5544 2f80 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5545              		.loc 1 1024 0
 5546 2f84 9C00CBE5 		strb	r0, [fp, #156]
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5547              		.loc 1 1025 0
 5548 2f88 9D10CBE5 		strb	r1, [fp, #157]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5549              		.loc 1 1029 0
 5550 2f8c 30009DE5 		ldr	r0, [sp, #48]
 5551 2f90 60159FE5 		ldr	r1, .L748+128
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5552              		.loc 1 1026 0
 5553 2f94 9E20CBE5 		strb	r2, [fp, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5554              		.loc 1 1028 0
 5555 2f98 9F30CBE5 		strb	r3, [fp, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5556              		.loc 1 1029 0
 5557 2f9c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5558              	.LVL611:
1030:../uvc.c      **** 			  break;
 5559              		.loc 1 1030 0
 5560 2fa0 9C30DBE5 		ldrb	r3, [fp, #156]	@ zero_extendqisi2
 5561              	.LVL612:
 5562 2fa4 30209DE5 		ldr	r2, [sp, #48]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5563              		.loc 1 980 0
 5564 2fa8 FF80A0E3 		mov	r8, #255
 5565 2fac 08C0A0E1 		mov	ip, r8
 5566              	.LVL613:
 5567              	.L425:
1199:../uvc.c      **** }
 5568              		.loc 1 1199 0
 5569 2fb0 9E10DBE5 		ldrb	r1, [fp, #158]	@ zero_extendqisi2
 5570 2fb4 FF00A0E3 		mov	r0, #255
 5571 2fb8 08308DE5 		str	r3, [sp, #8]
 5572 2fbc 14208DE5 		str	r2, [sp, #20]
 5573 2fc0 0C30A0E1 		mov	r3, ip
 5574              	.LVL614:
 5575 2fc4 0720A0E1 		mov	r2, r7
 5576 2fc8 00808DE5 		str	r8, [sp]
 5577              	.LVL615:
 5578              	.L700:
 5579 2fcc 04108DE5 		str	r1, [sp, #4]
 5580 2fd0 10108DE5 		str	r1, [sp, #16]
 5581 2fd4 0C008DE5 		str	r0, [sp, #12]
 5582 2fd8 DC149FE5 		ldr	r1, .L748+68
 5583 2fdc 0400A0E3 		mov	r0, #4
 5584 2fe0 FEFFFFEB 		bl	CyU3PDebugPrint
 5585              	.LVL616:
 5586 2fe4 50309DE5 		ldr	r3, [sp, #80]
 5587 2fe8 6DFDFFEA 		b	.L260
 5588              	.L304:
 5589              	.LVL617:
 5590              	.LBE218:
 5591              	.LBE217:
 5592              	.LBB228:
 5593              	.LBB229:
 984:../uvc.c      **** 
 5594              		.loc 1 984 0
 5595 2fec 98C49FE5 		ldr	ip, .L748+20
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5596              		.loc 1 977 0
 5597 2ff0 38E5DAE5 		ldrb	lr, [r10, #1336]	@ zero_extendqisi2
 984:../uvc.c      **** 
 5598              		.loc 1 984 0
 5599 2ff4 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5600              		.loc 1 976 0
 5601 2ff8 4735DAE5 		ldrb	r3, [r10, #1351]	@ zero_extendqisi2
 5602              	.LVL618:
 986:../uvc.c      **** 		 {
 5603              		.loc 1 986 0
 5604 2ffc 830057E3 		cmp	r7, #131
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5605              		.loc 1 977 0
 5606 3000 30E08DE5 		str	lr, [sp, #48]
 5607              	.LVL619:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5608              		.loc 1 979 0
 5609 3004 3A85DAE5 		ldrb	r8, [r10, #1338]	@ zero_extendqisi2
 5610              	.LVL620:
 986:../uvc.c      **** 		 {
 5611              		.loc 1 986 0
 5612 3008 6B05000A 		beq	.L381
 5613 300c 7A02009A 		bls	.L737
 5614 3010 850057E3 		cmp	r7, #133
 5615 3014 6C05000A 		beq	.L386
 5616 3018 BC03003A 		bcc	.L387
 5617 301c 860057E3 		cmp	r7, #134
 5618 3020 0405000A 		beq	.L388
 5619 3024 870057E3 		cmp	r7, #135
 5620 3028 6C04001A 		bne	.L380
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5621              		.loc 1 1048 0
 5622 302c 48249FE5 		ldr	r2, .L748+4
 5623 3030 4315D2E5 		ldrb	r1, [r2, #1347]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5624              		.loc 1 1049 0
 5625 3034 4425D2E5 		ldrb	r2, [r2, #1348]	@ zero_extendqisi2
 5626              	.L683:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5627              		.loc 1 1027 0
 5628 3038 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5629              		.loc 1 1024 0
 5630 303c 9C10CBE5 		strb	r1, [fp, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5631              		.loc 1 1029 0
 5632 3040 0800A0E1 		mov	r0, r8
 5633 3044 AC149FE5 		ldr	r1, .L748+128
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5634              		.loc 1 1025 0
 5635 3048 9D20CBE5 		strb	r2, [fp, #157]
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5636              		.loc 1 1027 0
 5637 304c 9E30CBE5 		strb	r3, [fp, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5638              		.loc 1 1028 0
 5639 3050 9F30CBE5 		strb	r3, [fp, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5640              		.loc 1 1029 0
 5641 3054 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5642              	.LVL621:
1030:../uvc.c      **** 			  break;
 5643              		.loc 1 1030 0
 5644 3058 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
 5645              	.LVL622:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5646              		.loc 1 980 0
 5647 305c FF20A0E3 		mov	r2, #255
 5648 3060 0230A0E1 		mov	r3, r2
 5649              	.LVL623:
 5650              	.L390:
1199:../uvc.c      **** }
 5651              		.loc 1 1199 0
 5652 3064 9E10DBE5 		ldrb	r1, [fp, #158]	@ zero_extendqisi2
 5653 3068 FF00A0E3 		mov	r0, #255
 5654 306c 00208DE5 		str	r2, [sp]
 5655 3070 08C08DE5 		str	ip, [sp, #8]
 5656 3074 14808DE5 		str	r8, [sp, #20]
 5657 3078 0720A0E1 		mov	r2, r7
 5658              	.LVL624:
 5659 307c D2FFFFEA 		b	.L700
 5660              	.LVL625:
 5661              	.L307:
 5662              	.LBE229:
 5663              	.LBE228:
 5664              	.LBB238:
 5665              	.LBB159:
 984:../uvc.c      **** 
 5666              		.loc 1 984 0
 5667 3080 04C49FE5 		ldr	ip, .L748+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5668              		.loc 1 979 0
 5669 3084 6A85DAE5 		ldrb	r8, [r10, #1386]	@ zero_extendqisi2
 5670              	.LVL626:
 984:../uvc.c      **** 
 5671              		.loc 1 984 0
 5672 3088 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5673              	.LVL627:
 986:../uvc.c      **** 		 {
 5674              		.loc 1 986 0
 5675 308c 830057E3 		cmp	r7, #131
 5676 3090 3D05000A 		beq	.L405
 5677 3094 6C01009A 		bls	.L738
 5678 3098 850057E3 		cmp	r7, #133
 5679 309c 7600000A 		beq	.L410
 5680 30a0 9603003A 		bcc	.L411
 5681 30a4 860057E3 		cmp	r7, #134
 5682 30a8 1405000A 		beq	.L412
 5683 30ac 870057E3 		cmp	r7, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5684              		.loc 1 1048 0
 5685 30b0 7315DA05 		ldreqb	r1, [r10, #1395]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5686              		.loc 1 1049 0
 5687 30b4 7425DA05 		ldreqb	r2, [r10, #1396]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5688              		.loc 1 986 0
 5689 30b8 9CFEFF0A 		beq	.L685
 5690              	.L404:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5691              		.loc 1 1193 0
 5692 30bc 0000A0E3 		mov	r0, #0
 5693 30c0 0020A0E1 		mov	r2, r0
 5694 30c4 0110A0E3 		mov	r1, #1
 5695 30c8 24C08DE5 		str	ip, [sp, #36]
 5696 30cc FEFFFFEB 		bl	CyU3PUsbStall
 5697              	.LVL628:
1194:../uvc.c      **** 			  break;
 5698              		.loc 1 1194 0
 5699 30d0 24C09DE5 		ldr	ip, [sp, #36]
 5700 30d4 0920A0E3 		mov	r2, #9
 5701 30d8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5702 30dc 0400A0E3 		mov	r0, #4
 5703 30e0 08149FE5 		ldr	r1, .L748+120
 5704 30e4 FEFFFFEB 		bl	CyU3PDebugPrint
 5705              	.LVL629:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5706              		.loc 1 980 0
 5707 30e8 FF20A0E3 		mov	r2, #255
 5708 30ec 690000EA 		b	.L414
 5709              	.LVL630:
 5710              	.L727:
 5711              	.LBE159:
 5712              	.LBE238:
 5713              	.LBE310:
 5714              	.LBE446:
 5715              	.LBB447:
 5716              	.LBB140:
3123:../uvc.c      ****                 {
 5717              		.loc 1 3123 0
 5718 30f0 010052E3 		cmp	r2, #1
 5719 30f4 2FFDFF1A 		bne	.L514
3148:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5720              		.loc 1 3148 0
 5721 30f8 A8139FE5 		ldr	r1, .L748+48
 5722 30fc 48208DE2 		add	r2, sp, #72
 5723 3100 2000A0E3 		mov	r0, #32
 5724 3104 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5725              	.LVL631:
 5726 3108 2EFDFFEA 		b	.L527
 5727              	.LVL632:
 5728              	.L720:
2996:../uvc.c      ****             {
 5729              		.loc 1 2996 0
 5730 310c 010053E3 		cmp	r3, #1
 5731 3110 28FDFF1A 		bne	.L514
3021:../uvc.c      ****                             glCommitCtrl, &readCount);
 5732              		.loc 1 3021 0
 5733 3114 2000A0E3 		mov	r0, #32
 5734 3118 88139FE5 		ldr	r1, .L748+48
 5735 311c 48208DE2 		add	r2, sp, #72
 5736 3120 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5737              	.LVL633:
3023:../uvc.c      ****                     {
 5738              		.loc 1 3023 0
 5739 3124 000050E3 		cmp	r0, #0
 5740 3128 26FDFF1A 		bne	.L527
3025:../uvc.c      ****                         {
 5741              		.loc 1 3025 0
 5742 312c C770DBE5 		ldrb	r7, [fp, #199]	@ zero_extendqisi2
 5743 3130 E430DBE5 		ldrb	r3, [fp, #228]	@ zero_extendqisi2
 5744 3134 070053E1 		cmp	r3, r7
 5745 3138 0500000A 		beq	.L536
3027:../uvc.c      ****                          {
 5746              		.loc 1 3027 0
 5747 313c 010057E3 		cmp	r7, #1
 5748 3140 3705000A 		beq	.L538
 5749 3144 020057E3 		cmp	r7, #2
 5750 3148 DB03000A 		beq	.L539
 5751              	.LVL634:
 5752              	.L537:
3042:../uvc.c      ****                         }
 5753              		.loc 1 3042 0
 5754 314c C730DBE5 		ldrb	r3, [fp, #199]	@ zero_extendqisi2
 5755 3150 E430CBE5 		strb	r3, [fp, #228]
 5756              	.L536:
3044:../uvc.c      **** 
 5757              		.loc 1 3044 0
 5758 3154 64139FE5 		ldr	r1, .L748+72
 5759 3158 E420DBE5 		ldrb	r2, [fp, #228]	@ zero_extendqisi2
 5760 315c 0400A0E3 		mov	r0, #4
 5761 3160 FEFFFFEB 		bl	CyU3PDebugPrint
 5762              	.LVL635:
3057:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5763              		.loc 1 3057 0
 5764 3164 0020A0E3 		mov	r2, #0
 5765 3168 08039FE5 		ldr	r0, .L748
 5766 316c 0110A0E3 		mov	r1, #1
 5767 3170 FEFFFFEB 		bl	_txe_event_flags_set
 5768              	.LVL636:
3058:../uvc.c      ****                         {
 5769              		.loc 1 3058 0
 5770 3174 002050E2 		subs	r2, r0, #0
 5771 3178 12FDFF0A 		beq	.L527
3060:../uvc.c      ****                         }
 5772              		.loc 1 3060 0
 5773 317c 40139FE5 		ldr	r1, .L748+76
 5774 3180 0400A0E3 		mov	r0, #4
 5775              	.LVL637:
 5776 3184 FEFFFFEB 		bl	CyU3PDebugPrint
 5777              	.LVL638:
 5778 3188 0EFDFFEA 		b	.L527
 5779              	.LVL639:
 5780              	.L721:
3199:../uvc.c      ****                 {
 5781              		.loc 1 3199 0
 5782 318c 010052E3 		cmp	r2, #1
 5783 3190 08FDFF1A 		bne	.L514
3224:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5784              		.loc 1 3224 0
 5785 3194 2000A0E3 		mov	r0, #32
 5786 3198 08139FE5 		ldr	r1, .L748+48
 5787 319c 48208DE2 		add	r2, sp, #72
 5788 31a0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5789              	.LVL640:
3226:../uvc.c      ****                         {
 5790              		.loc 1 3226 0
 5791 31a4 000050E3 		cmp	r0, #0
 5792 31a8 0B03001A 		bne	.L560
3230:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5793              		.loc 1 3230 0
 5794 31ac 0020A0E3 		mov	r2, #0
 5795 31b0 C0029FE5 		ldr	r0, .L748
 5796              	.LVL641:
 5797 31b4 8010A0E3 		mov	r1, #128
 5798 31b8 FEFFFFEB 		bl	_txe_event_flags_set
 5799              	.LVL642:
3231:../uvc.c      ****                             {
 5800              		.loc 1 3231 0
 5801 31bc 002050E2 		subs	r2, r0, #0
3237:../uvc.c      ****                             //stillcont = 0;
 5802              		.loc 1 3237 0
 5803 31c0 F030A003 		moveq	r3, #240
 5804 31c4 74308405 		streq	r3, [r4, #116]
3231:../uvc.c      ****                             {
 5805              		.loc 1 3231 0
 5806 31c8 9404001A 		bne	.L739
 5807              	.LVL643:
 5808              	.L562:
3240:../uvc.c      ****                         }else{
 5809              		.loc 1 3240 0
 5810 31cc C510DBE5 		ldrb	r1, [fp, #197]	@ zero_extendqisi2
 5811 31d0 C430DBE5 		ldrb	r3, [fp, #196]	@ zero_extendqisi2
 5812 31d4 B824DDE1 		ldrh	r2, [sp, #72]
 5813 31d8 00108DE5 		str	r1, [sp]
 5814 31dc 0400A0E3 		mov	r0, #4
 5815 31e0 E0129FE5 		ldr	r1, .L748+80
 5816 31e4 FEFFFFEB 		bl	CyU3PDebugPrint
 5817              	.LVL644:
 5818 31e8 F6FCFFEA 		b	.L527
 5819              	.L723:
 5820              	.LBE140:
 5821              	.LBE447:
 5822              	.LBB448:
 5823              	.LBB424:
2847:../uvc.c      ****     {
 5824              		.loc 1 2847 0
 5825 31ec 010A53E3 		cmp	r3, #4096
 5826 31f0 E6FCFF1A 		bne	.L261
 5827              	.L478:
 5828              	.LVL645:
 5829              	.LBB360:
 5830              	.LBB361:
 418:../uvc.c      ****     /*
 5831              		.loc 1 418 0
 5832 31f4 90329FE5 		ldr	r3, .L748+20
 412:../uvc.c      ****     }
 5833              		.loc 1 412 0
 5834 31f8 6A74DAE5 		ldrb	r7, [r10, #1130]	@ zero_extendqisi2
 5835              	.LVL646:
 418:../uvc.c      ****     /*
 5836              		.loc 1 418 0
 5837 31fc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 5838              		.loc 1 426 0
 5839 3200 830053E3 		cmp	r3, #131
 418:../uvc.c      ****     /*
 5840              		.loc 1 418 0
 5841 3204 30308DE5 		str	r3, [sp, #48]
 5842              	.LVL647:
 426:../uvc.c      **** 		 {
 5843              		.loc 1 426 0
 5844 3208 1605000A 		beq	.L482
 5845 320c 2B02009A 		bls	.L740
 5846 3210 30C09DE5 		ldr	ip, [sp, #48]
 5847 3214 85005CE3 		cmp	ip, #133
 5848 3218 7E05000A 		beq	.L487
 5849 321c 7205003A 		bcc	.L488
 5850 3220 86005CE3 		cmp	ip, #134
 5851 3224 BF03000A 		beq	.L489
 5852 3228 87005CE3 		cmp	ip, #135
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 5853              		.loc 1 657 0
 5854 322c 7324DA05 		ldreqb	r2, [r10, #1139]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 5855              		.loc 1 658 0
 5856 3230 7434DA05 		ldreqb	r3, [r10, #1140]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 5857              		.loc 1 426 0
 5858 3234 7D05001A 		bne	.L481
 5859              	.L693:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5860              		.loc 1 597 0
 5861 3238 B8129FE5 		ldr	r1, .L748+128
 5862 323c 0700A0E1 		mov	r0, r7
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5863              		.loc 1 414 0
 5864 3240 FF80A0E3 		mov	r8, #255
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 5865              		.loc 1 594 0
 5866 3244 9C20CBE5 		strb	r2, [fp, #156]
 5867              	.L692:
 595:../uvc.c      **** 			 }
 5868              		.loc 1 595 0
 5869 3248 9D30CBE5 		strb	r3, [fp, #157]
 5870              	.L694:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5871              		.loc 1 597 0
 5872 324c 2C808DE5 		str	r8, [sp, #44]
 5873 3250 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5874              	.LVL648:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5875              		.loc 1 414 0
 5876 3254 0830A0E1 		mov	r3, r8
 598:../uvc.c      **** 			  break;
 5877              		.loc 1 598 0
 5878 3258 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
 5879              	.LVL649:
 5880 325c 2C209DE5 		ldr	r2, [sp, #44]
 5881 3260 570200EA 		b	.L491
 5882              	.LVL650:
 5883              	.L718:
 5884              	.LBE361:
 5885              	.LBE360:
2847:../uvc.c      ****     {
 5886              		.loc 1 2847 0
 5887 3264 050C53E3 		cmp	r3, #1280
 5888 3268 C8FCFF1A 		bne	.L261
 5889              	.LVL651:
2867:../uvc.c      ****     		break;
 5890              		.loc 1 2867 0
 5891 326c 1400A0E3 		mov	r0, #20
 5892 3270 FEFFFFEB 		bl	ControlHandle
 5893              	.LVL652:
 5894 3274 50309DE5 		ldr	r3, [sp, #80]
 5895 3278 C9FCFFEA 		b	.L260
 5896              	.L410:
 5897              	.LBE424:
 5898              	.LBE448:
 5899              	.LBB449:
 5900              	.LBB311:
 5901              	.LBB239:
 5902              	.LBB160:
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5903              		.loc 1 991 0
 5904 327c 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5905              		.loc 1 992 0
 5906 3280 0200A0E3 		mov	r0, #2
 5907 3284 6C129FE5 		ldr	r1, .L748+128
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5908              		.loc 1 990 0
 5909 3288 9C80CBE5 		strb	r8, [fp, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5910              		.loc 1 991 0
 5911 328c 9D30CBE5 		strb	r3, [fp, #157]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5912              		.loc 1 992 0
 5913 3290 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5914              	.LVL653:
 993:../uvc.c      **** 			  break;
 5915              		.loc 1 993 0
 5916 3294 9C20DBE5 		ldrb	r2, [fp, #156]	@ zero_extendqisi2
 5917              	.LVL654:
 5918              	.L414:
1199:../uvc.c      **** }
 5919              		.loc 1 1199 0
 5920 3298 9E10DBE5 		ldrb	r1, [fp, #158]	@ zero_extendqisi2
 5921 329c FF30A0E3 		mov	r3, #255
 5922 32a0 08208DE5 		str	r2, [sp, #8]
 5923 32a4 04108DE5 		str	r1, [sp, #4]
 5924 32a8 10108DE5 		str	r1, [sp, #16]
 5925 32ac 00308DE5 		str	r3, [sp]
 5926 32b0 0C308DE5 		str	r3, [sp, #12]
 5927 32b4 14808DE5 		str	r8, [sp, #20]
 5928 32b8 0720A0E1 		mov	r2, r7
 5929              	.LVL655:
 5930 32bc 0400A0E3 		mov	r0, #4
 5931 32c0 F4119FE5 		ldr	r1, .L748+68
 5932 32c4 FEFFFFEB 		bl	CyU3PDebugPrint
 5933              	.LVL656:
 5934 32c8 50309DE5 		ldr	r3, [sp, #80]
 5935 32cc B4FCFFEA 		b	.L260
 5936              	.LVL657:
 5937              	.L450:
 5938              	.LBE160:
 5939              	.LBE239:
 5940              	.LBE311:
 5941              	.LBE449:
 5942              	.LBB450:
 5943              	.LBB425:
2914:../uvc.c      ****     		break;
 5944              		.loc 1 2914 0
 5945 32d0 2400A0E3 		mov	r0, #36
 5946 32d4 FEFFFFEB 		bl	ControlHandle
 5947              	.LVL658:
 5948 32d8 50309DE5 		ldr	r3, [sp, #80]
 5949 32dc B0FCFFEA 		b	.L260
 5950              	.L440:
 5951              	.LVL659:
2871:../uvc.c      ****      		break;
 5952              		.loc 1 2871 0
 5953 32e0 1500A0E3 		mov	r0, #21
 5954 32e4 FEFFFFEB 		bl	ControlHandle
 5955              	.LVL660:
 5956 32e8 50309DE5 		ldr	r3, [sp, #80]
 5957 32ec ACFCFFEA 		b	.L260
 5958              	.L443:
 5959              	.LVL661:
2875:../uvc.c      ****     		break;
 5960              		.loc 1 2875 0
 5961 32f0 1600A0E3 		mov	r0, #22
 5962 32f4 FEFFFFEB 		bl	ControlHandle
 5963              	.LVL662:
 5964 32f8 50309DE5 		ldr	r3, [sp, #80]
 5965 32fc A8FCFFEA 		b	.L260
 5966              	.L438:
 5967              	.LVL663:
2859:../uvc.c      ****      		break;
 5968              		.loc 1 2859 0
 5969 3300 1200A0E3 		mov	r0, #18
 5970 3304 FEFFFFEB 		bl	ControlHandle
 5971              	.LVL664:
 5972 3308 50309DE5 		ldr	r3, [sp, #80]
 5973 330c A4FCFFEA 		b	.L260
 5974              	.L437:
 5975              	.LVL665:
2855:../uvc.c      ****     		break;
 5976              		.loc 1 2855 0
 5977 3310 1100A0E3 		mov	r0, #17
 5978 3314 FEFFFFEB 		bl	ControlHandle
 5979              	.LVL666:
 5980 3318 50309DE5 		ldr	r3, [sp, #80]
 5981 331c A0FCFFEA 		b	.L260
 5982              	.L453:
 5983              	.LVL667:
 5984              	.LBB367:
 5985              	.LBB368:
 418:../uvc.c      ****     /*
 5986              		.loc 1 418 0
 5987 3320 64219FE5 		ldr	r2, .L748+20
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 5988              		.loc 1 404 0
 5989 3324 7830DAE5 		ldrb	r3, [r10, #120]	@ zero_extendqisi2
 5990              	.LVL668:
 418:../uvc.c      ****     /*
 5991              		.loc 1 418 0
 5992 3328 0070D2E5 		ldrb	r7, [r2]	@ zero_extendqisi2
 406:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 5993              		.loc 1 406 0
 5994 332c 8780DAE5 		ldrb	r8, [r10, #135]	@ zero_extendqisi2
 5995              	.LVL669:
 426:../uvc.c      **** 		 {
 5996              		.loc 1 426 0
 5997 3330 830057E3 		cmp	r7, #131
 407:../uvc.c      ****     }else{
 5998              		.loc 1 407 0
 5999 3334 7AC0DAE5 		ldrb	ip, [r10, #122]	@ zero_extendqisi2
 6000              	.LVL670:
 426:../uvc.c      **** 		 {
 6001              		.loc 1 426 0
 6002 3338 CE04000A 		beq	.L501
 6003 333c 2802009A 		bls	.L741
 6004 3340 850057E3 		cmp	r7, #133
 6005 3344 FC04000A 		beq	.L506
 6006 3348 F004003A 		bcc	.L507
 6007 334c 860057E3 		cmp	r7, #134
 6008 3350 8403000A 		beq	.L508
 6009 3354 870057E3 		cmp	r7, #135
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 6010              		.loc 1 647 0
 6011 3358 83E0DA05 		ldreqb	lr, [r10, #131]	@ zero_extendqisi2
 648:../uvc.c      **** 		 	 }
 6012              		.loc 1 648 0
 6013 335c 8420DA05 		ldreqb	r2, [r10, #132]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 6014              		.loc 1 426 0
 6015 3360 1205001A 		bne	.L500
 6016              	.L697:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6017              		.loc 1 597 0
 6018 3364 8C119FE5 		ldr	r1, .L748+128
 6019 3368 0C00A0E1 		mov	r0, ip
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6020              		.loc 1 414 0
 6021 336c FF80A0E3 		mov	r8, #255
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 6022              		.loc 1 583 0
 6023 3370 9CE0CBE5 		strb	lr, [fp, #156]
 6024              	.L695:
 584:../uvc.c      **** 		 	 }
 6025              		.loc 1 584 0
 6026 3374 9D20CBE5 		strb	r2, [fp, #157]
 6027              	.L698:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6028              		.loc 1 414 0
 6029 3378 30808DE5 		str	r8, [sp, #48]
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6030              		.loc 1 597 0
 6031 337c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6032              	.LVL671:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6033              		.loc 1 414 0
 6034 3380 08C0A0E1 		mov	ip, r8
 598:../uvc.c      **** 			  break;
 6035              		.loc 1 598 0
 6036 3384 9C20DBE5 		ldrb	r2, [fp, #156]	@ zero_extendqisi2
 6037              	.LVL672:
 6038 3388 30309DE5 		ldr	r3, [sp, #48]
 6039 338c 3C0200EA 		b	.L510
 6040              	.LVL673:
 6041              	.L435:
 6042              	.LBE368:
 6043              	.LBE367:
 6044              	.LBB376:
 6045              	.LBB351:
 418:../uvc.c      ****     /*
 6046              		.loc 1 418 0
 6047 3390 F4209FE5 		ldr	r2, .L748+20
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6048              		.loc 1 409 0
 6049 3394 4833DAE5 		ldrb	r3, [r10, #840]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 6050              		.loc 1 418 0
 6051 3398 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6052              		.loc 1 409 0
 6053 339c 30308DE5 		str	r3, [sp, #48]
 6054              	.LVL674:
 426:../uvc.c      **** 		 {
 6055              		.loc 1 426 0
 6056 33a0 830058E3 		cmp	r8, #131
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 6057              		.loc 1 411 0
 6058 33a4 5733DAE5 		ldrb	r3, [r10, #855]	@ zero_extendqisi2
 6059              	.LVL675:
 412:../uvc.c      ****     }
 6060              		.loc 1 412 0
 6061 33a8 4A73DAE5 		ldrb	r7, [r10, #842]	@ zero_extendqisi2
 6062              	.LVL676:
 426:../uvc.c      **** 		 {
 6063              		.loc 1 426 0
 6064 33ac B504000A 		beq	.L456
 6065 33b0 3C02009A 		bls	.L742
 6066 33b4 850058E3 		cmp	r8, #133
 6067 33b8 9802000A 		beq	.L474
 6068 33bc C404003A 		bcc	.L462
 6069 33c0 860058E3 		cmp	r8, #134
 6070 33c4 6D03000A 		beq	.L463
 6071 33c8 870058E3 		cmp	r8, #135
 6072 33cc CF03001A 		bne	.L455
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 6073              		.loc 1 657 0
 6074 33d0 A4C09FE5 		ldr	ip, .L748+4
 6075 33d4 5323DCE5 		ldrb	r2, [ip, #851]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 6076              		.loc 1 658 0
 6077 33d8 5433DCE5 		ldrb	r3, [ip, #852]	@ zero_extendqisi2
 6078              	.LVL677:
 6079              	.L691:
 6080              	.LBE351:
 6081              	.LBE376:
 6082              	.LBB377:
 6083              	.LBB378:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6084              		.loc 1 597 0
 6085 33dc 0700A0E1 		mov	r0, r7
 6086 33e0 10119FE5 		ldr	r1, .L748+128
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 6087              		.loc 1 594 0
 6088 33e4 9C20CBE5 		strb	r2, [fp, #156]
 6089 33e8 900200EA 		b	.L690
 6090              	.L433:
 6091              	.LVL678:
 6092              	.LBE378:
 6093              	.LBE377:
2883:../uvc.c      ****      		break;
 6094              		.loc 1 2883 0
 6095 33ec 1800A0E3 		mov	r0, #24
 6096 33f0 FEFFFFEB 		bl	ControlHandle
 6097              	.LVL679:
 6098 33f4 50309DE5 		ldr	r3, [sp, #80]
 6099 33f8 69FCFFEA 		b	.L260
 6100              	.L445:
 6101              	.LVL680:
 6102              	.LBB390:
 6103              	.LBB379:
 418:../uvc.c      ****     /*
 6104              		.loc 1 418 0
 6105 33fc 88209FE5 		ldr	r2, .L748+20
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6106              		.loc 1 409 0
 6107 3400 5034DAE5 		ldrb	r3, [r10, #1104]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 6108              		.loc 1 418 0
 6109 3404 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6110              		.loc 1 409 0
 6111 3408 30308DE5 		str	r3, [sp, #48]
 6112              	.LVL681:
 426:../uvc.c      **** 		 {
 6113              		.loc 1 426 0
 6114 340c 830058E3 		cmp	r8, #131
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 6115              		.loc 1 411 0
 6116 3410 5F34DAE5 		ldrb	r3, [r10, #1119]	@ zero_extendqisi2
 6117              	.LVL682:
 412:../uvc.c      ****     }
 6118              		.loc 1 412 0
 6119 3414 5274DAE5 		ldrb	r7, [r10, #1106]	@ zero_extendqisi2
 6120              	.LVL683:
 426:../uvc.c      **** 		 {
 6121              		.loc 1 426 0
 6122 3418 8E04000A 		beq	.L469
 6123 341c 4702009A 		bls	.L743
 6124 3420 850058E3 		cmp	r8, #133
 6125 3424 7D02000A 		beq	.L474
 6126 3428 C904003A 		bcc	.L475
 6127 342c 860058E3 		cmp	r8, #134
 6128 3430 4203000A 		beq	.L476
 6129 3434 870058E3 		cmp	r8, #135
 6130 3438 B403001A 		bne	.L455
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 6131              		.loc 1 657 0
 6132 343c 38C09FE5 		ldr	ip, .L748+4
 6133 3440 5B24DCE5 		ldrb	r2, [ip, #1115]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 6134              		.loc 1 658 0
 6135 3444 5C34DCE5 		ldrb	r3, [ip, #1116]	@ zero_extendqisi2
 6136 3448 E3FFFFEA 		b	.L691
 6137              	.LVL684:
 6138              	.L448:
 6139              	.LBE379:
 6140              	.LBE390:
2898:../uvc.c      ****     		break;
 6141              		.loc 1 2898 0
 6142 344c 1C00A0E3 		mov	r0, #28
 6143 3450 FEFFFFEB 		bl	ControlHandle
 6144              	.LVL685:
 6145 3454 50309DE5 		ldr	r3, [sp, #80]
 6146 3458 51FCFFEA 		b	.L260
 6147              	.LVL686:
 6148              	.L558:
 6149              	.LBE425:
 6150              	.LBE450:
 6151              	.LBB451:
 6152              	.LBB141:
3207:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6153              		.loc 1 3207 0
 6154 345c 0020A0E3 		mov	r2, #0
3208:../uvc.c      ****                         break;
 6155              		.loc 1 3208 0
 6156 3460 90109FE5 		ldr	r1, .L748+128
 6157 3464 0200A0E3 		mov	r0, #2
3206:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6158              		.loc 1 3206 0
 6159 3468 9C30CBE5 		strb	r3, [fp, #156]
3207:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6160              		.loc 1 3207 0
 6161 346c 9D20CBE5 		strb	r2, [fp, #157]
3208:../uvc.c      ****                         break;
 6162              		.loc 1 3208 0
 6163 3470 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6164              	.LVL687:
 6165 3474 53FCFFEA 		b	.L527
 6166              	.L749:
 6167              		.align	2
 6168              	.L748:
 6169 3478 00000000 		.word	.LANCHOR0
 6170 347c 00000000 		.word	.LANCHOR1
 6171 3480 00000000 		.word	glInterStaBuffer
 6172 3484 00000000 		.word	wIndex
 6173 3488 00000000 		.word	wValue
 6174 348c 00000000 		.word	bRequest
 6175 3490 10050000 		.word	.LC27
 6176 3494 00000000 		.word	glChHandleInterStat
 6177 3498 00000000 		.word	bmReqType
 6178 349c 00000000 		.word	wLength
 6179 34a0 94040000 		.word	.LC26
 6180 34a4 10060000 		.word	.LANCHOR1+1552
 6181 34a8 C4000000 		.word	.LANCHOR0+196
 6182 34ac E4050000 		.word	.LC32
 6183 34b0 3C050000 		.word	.LC28
 6184 34b4 2C060000 		.word	.LANCHOR1+1580
 6185 34b8 38060000 		.word	.LANCHOR1+1592
 6186 34bc C4030000 		.word	.LC22
 6187 34c0 94050000 		.word	.LC30
 6188 34c4 BC050000 		.word	.LC31
 6189 34c8 34060000 		.word	.LC34
 6190 34cc 54030000 		.word	.LC19
 6191 34d0 7C030000 		.word	.LC20
 6192 34d4 FFFF0000 		.word	65535
 6193 34d8 10000000 		.word	.LANCHOR2+16
 6194 34dc 04030000 		.word	.LC18
 6195 34e0 00000000 		.word	cmdQu
 6196 34e4 60060000 		.word	.LC35
 6197 34e8 88060000 		.word	.LC36
 6198 34ec 70050000 		.word	.LC29
 6199 34f0 A0030000 		.word	.LC21
 6200 34f4 10060000 		.word	.LC33
 6201 34f8 9C000000 		.word	.LANCHOR0+156
 6202 34fc 00000000 		.word	.LANCHOR1
 6203              	.LVL688:
 6204              	.L728:
 6205              	.LBE141:
 6206              	.LBE451:
 6207              	.LBB452:
 6208              	.LBB341:
 6209              	.LBB331:
 6210              	.LBB325:
 426:../uvc.c      **** 		 {
 6211              		.loc 1 426 0
 6212 3500 810057E3 		cmp	r7, #129
 6213 3504 6202000A 		beq	.L284
 6214 3508 9103008A 		bhi	.L285
 6215 350c 010057E3 		cmp	r7, #1
 6216 3510 1D03001A 		bne	.L281
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6217              		.loc 1 664 0
 6218 3514 48208DE2 		add	r2, sp, #72
 6219 3518 2000A0E3 		mov	r0, #32
 6220 351c 2C101FE5 		ldr	r1, .L748+128
 6221 3520 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6222              	.LVL689:
 666:../uvc.c      **** 			   {
 6223              		.loc 1 666 0
 6224 3524 002050E2 		subs	r2, r0, #0
 6225 3528 3A05001A 		bne	.L293
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6226              		.loc 1 668 0
 6227 352c 9C30D4E5 		ldrb	r3, [r4, #156]	@ zero_extendqisi2
 6228              	.LVL690:
 905:../uvc.c      **** 							 //remove for Invendo
 6229              		.loc 1 905 0
 6230 3530 58201FE5 		ldr	r2, .L748+104
 899:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 6231              		.loc 1 899 0
 6232 3534 01C043E2 		sub	ip, r3, #1
 6233 3538 FFC00CE2 		and	ip, ip, #255
 903:../uvc.c      **** 
 6234              		.loc 1 903 0
 6235 353c 02005CE3 		cmp	ip, #2
 905:../uvc.c      **** 							 //remove for Invendo
 6236              		.loc 1 905 0
 6237 3540 1C0092E5 		ldr	r0, [r2, #28]
 6238              	.LVL691:
 903:../uvc.c      **** 
 6239              		.loc 1 903 0
 6240 3544 01C0A083 		movhi	ip, #1
 905:../uvc.c      **** 							 //remove for Invendo
 6241              		.loc 1 905 0
 6242 3548 0010E0E3 		mvn	r1, #0
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6243              		.loc 1 671 0
 6244 354c 9E80D4E5 		ldrb	r8, [r4, #158]	@ zero_extendqisi2
 6245              	.LVL692:
 905:../uvc.c      **** 							 //remove for Invendo
 6246              		.loc 1 905 0
 6247 3550 28308DE5 		str	r3, [sp, #40]
 6248 3554 24C08DE5 		str	ip, [sp, #36]
 6249 3558 2C208DE5 		str	r2, [sp, #44]
 6250 355c FEFFFFEB 		bl	_txe_mutex_get
 6251              	.LVL693:
 908:../uvc.c      **** 
 6252              		.loc 1 908 0
 6253 3560 2C209DE5 		ldr	r2, [sp, #44]
 6254 3564 1C0092E5 		ldr	r0, [r2, #28]
 6255 3568 FEFFFFEB 		bl	_txe_mutex_put
 6256              	.LVL694:
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 6257              		.loc 1 910 0
 6258 356c 24C09DE5 		ldr	ip, [sp, #36]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6259              		.loc 1 414 0
 6260 3570 FF20A0E3 		mov	r2, #255
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 6261              		.loc 1 910 0
 6262 3574 EDC1CAE5 		strb	ip, [r10, #493]
 911:../uvc.c      **** 							 break;
 6263              		.loc 1 911 0
 6264 3578 F071CAE5 		strb	r7, [r10, #496]
 6265 357c 28309DE5 		ldr	r3, [sp, #40]
 6266 3580 2CFDFFEA 		b	.L291
 6267              	.LVL695:
 6268              	.L719:
 6269 3584 0030A0E1 		mov	r3, r0
 6270              	.LBE325:
 6271              	.LBE331:
 6272              	.LBE341:
 6273              	.LBE452:
3380:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 6274              		.loc 1 3380 0
 6275 3588 0320A0E1 		mov	r2, r3
 6276 358c 0800A0E1 		mov	r0, r8
 6277              	.LVL696:
 6278 3590 B0101FE5 		ldr	r1, .L748+112
 6279 3594 28308DE5 		str	r3, [sp, #40]
 6280 3598 FEFFFFEB 		bl	CyU3PDebugPrint
 6281              	.LVL697:
3381:../uvc.c      **** 					}
 6282              		.loc 1 3381 0
 6283 359c 28309DE5 		ldr	r3, [sp, #40]
 6284 35a0 0300A0E1 		mov	r0, r3
 6285 35a4 FEFFFFEB 		bl	CyFxAppErrorHandler
 6286              	.LVL698:
 6287              	.L731:
 6288              	.LBB453:
 6289              	.LBB312:
 6290              	.LBB240:
 6291              	.LBB178:
 986:../uvc.c      **** 		 {
 6292              		.loc 1 986 0
 6293 35a8 810057E3 		cmp	r7, #129
 6294 35ac 9802000A 		beq	.L313
 6295 35b0 7F03008A 		bhi	.L314
 6296 35b4 010057E3 		cmp	r7, #1
 6297 35b8 EDFDFF1A 		bne	.L310
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6298              		.loc 1 1057 0
 6299 35bc CC101FE5 		ldr	r1, .L748+128
 6300 35c0 48208DE2 		add	r2, sp, #72
 6301 35c4 2000A0E3 		mov	r0, #32
 6302 35c8 24C08DE5 		str	ip, [sp, #36]
 6303 35cc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6304              	.LVL699:
1188:../uvc.c      **** 			  		 break;
 6305              		.loc 1 1188 0
 6306 35d0 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6307              		.loc 1 1187 0
 6308 35d4 9CE0DBE5 		ldrb	lr, [fp, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6309              		.loc 1 1188 0
 6310 35d8 0020A0E3 		mov	r2, #0
 6311 35dc 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6312 35e0 0400A0E3 		mov	r0, #4
 6313 35e4 1C111FE5 		ldr	r1, .L748+88
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6314              		.loc 1 1187 0
 6315 35e8 9DE4CAE5 		strb	lr, [r10, #1181]
1188:../uvc.c      **** 			  		 break;
 6316              		.loc 1 1188 0
 6317 35ec FEFFFFEB 		bl	CyU3PDebugPrint
 6318              	.LVL700:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6319              		.loc 1 980 0
 6320 35f0 FF20A0E3 		mov	r2, #255
 6321 35f4 27FFFFEA 		b	.L414
 6322              	.LVL701:
 6323              	.L732:
 6324              	.LBE178:
 6325              	.LBE240:
 6326              	.LBB241:
 6327              	.LBB186:
 986:../uvc.c      **** 		 {
 6328              		.loc 1 986 0
 6329 35f8 810057E3 		cmp	r7, #129
 6330 35fc A302000A 		beq	.L324
 6331 3600 7503008A 		bhi	.L325
 6332 3604 010057E3 		cmp	r7, #1
 6333 3608 3303001A 		bne	.L321
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6334              		.loc 1 1057 0
 6335 360c 1C111FE5 		ldr	r1, .L748+128
 6336 3610 48208DE2 		add	r2, sp, #72
 6337 3614 2000A0E3 		mov	r0, #32
 6338 3618 24C08DE5 		str	ip, [sp, #36]
 6339 361c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6340              	.LVL702:
1188:../uvc.c      **** 			  		 break;
 6341              		.loc 1 1188 0
 6342 3620 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6343              		.loc 1 1187 0
 6344 3624 9CE0DBE5 		ldrb	lr, [fp, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6345              		.loc 1 1188 0
 6346 3628 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6347              		.loc 1 1187 0
 6348 362c 38C11FE5 		ldr	ip, .L748+132
1188:../uvc.c      **** 			  		 break;
 6349              		.loc 1 1188 0
 6350 3630 0220A0E3 		mov	r2, #2
 6351 3634 0400A0E3 		mov	r0, #4
 6352 3638 70111FE5 		ldr	r1, .L748+88
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6353              		.loc 1 1187 0
 6354 363c CDE4CCE5 		strb	lr, [ip, #1229]
1188:../uvc.c      **** 			  		 break;
 6355              		.loc 1 1188 0
 6356 3640 FEFFFFEB 		bl	CyU3PDebugPrint
 6357              	.LVL703:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6358              		.loc 1 980 0
 6359 3644 FF20A0E3 		mov	r2, #255
 6360 3648 12FFFFEA 		b	.L414
 6361              	.LVL704:
 6362              	.L738:
 6363              	.LBE186:
 6364              	.LBE241:
 6365              	.LBB242:
 6366              	.LBB161:
 986:../uvc.c      **** 		 {
 6367              		.loc 1 986 0
 6368 364c 810057E3 		cmp	r7, #129
 6369 3650 9202000A 		beq	.L407
 6370 3654 A503008A 		bhi	.L408
 6371 3658 010057E3 		cmp	r7, #1
 6372 365c 96FEFF1A 		bne	.L404
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6373              		.loc 1 1057 0
 6374 3660 70111FE5 		ldr	r1, .L748+128
 6375 3664 48208DE2 		add	r2, sp, #72
 6376 3668 2000A0E3 		mov	r0, #32
 6377 366c 24C08DE5 		str	ip, [sp, #36]
 6378 3670 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6379              	.LVL705:
1188:../uvc.c      **** 			  		 break;
 6380              		.loc 1 1188 0
 6381 3674 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6382              		.loc 1 1187 0
 6383 3678 9CE0DBE5 		ldrb	lr, [fp, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6384              		.loc 1 1188 0
 6385 367c 0920A0E3 		mov	r2, #9
 6386 3680 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6387 3684 0400A0E3 		mov	r0, #4
 6388 3688 C0111FE5 		ldr	r1, .L748+88
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6389              		.loc 1 1187 0
 6390 368c 75E5CAE5 		strb	lr, [r10, #1397]
1188:../uvc.c      **** 			  		 break;
 6391              		.loc 1 1188 0
 6392 3690 FEFFFFEB 		bl	CyU3PDebugPrint
 6393              	.LVL706:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6394              		.loc 1 980 0
 6395 3694 FF20A0E3 		mov	r2, #255
 6396 3698 FEFEFFEA 		b	.L414
 6397              	.LVL707:
 6398              	.L730:
 6399              	.LBE161:
 6400              	.LBE242:
 6401              	.LBB243:
 6402              	.LBB170:
 986:../uvc.c      **** 		 {
 6403              		.loc 1 986 0
 6404 369c 810057E3 		cmp	r7, #129
 6405 36a0 7302000A 		beq	.L396
 6406 36a4 4603008A 		bhi	.L397
 6407 36a8 010057E3 		cmp	r7, #1
 6408 36ac 94FDFF1A 		bne	.L393
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6409              		.loc 1 1057 0
 6410 36b0 C0111FE5 		ldr	r1, .L748+128
 6411 36b4 48208DE2 		add	r2, sp, #72
 6412 36b8 2000A0E3 		mov	r0, #32
 6413 36bc 24C08DE5 		str	ip, [sp, #36]
 6414 36c0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6415              	.LVL708:
1188:../uvc.c      **** 			  		 break;
 6416              		.loc 1 1188 0
 6417 36c4 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6418              		.loc 1 1187 0
 6419 36c8 9CE0DBE5 		ldrb	lr, [fp, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6420              		.loc 1 1188 0
 6421 36cc 0820A0E3 		mov	r2, #8
 6422 36d0 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6423 36d4 0400A0E3 		mov	r0, #4
 6424 36d8 10121FE5 		ldr	r1, .L748+88
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6425              		.loc 1 1187 0
 6426 36dc 5DE5CAE5 		strb	lr, [r10, #1373]
1188:../uvc.c      **** 			  		 break;
 6427              		.loc 1 1188 0
 6428 36e0 FEFFFFEB 		bl	CyU3PDebugPrint
 6429              	.LVL709:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6430              		.loc 1 980 0
 6431 36e4 FF20A0E3 		mov	r2, #255
 6432 36e8 EAFEFFEA 		b	.L414
 6433              	.LVL710:
 6434              	.L729:
 6435              	.LBE170:
 6436              	.LBE243:
 6437              	.LBB244:
 6438              	.LBB150:
 986:../uvc.c      **** 		 {
 6439              		.loc 1 986 0
 6440 36ec 810057E3 		cmp	r7, #129
 6441 36f0 6202000A 		beq	.L350
 6442 36f4 3503008A 		bhi	.L351
 6443 36f8 010057E3 		cmp	r7, #1
 6444 36fc E902001A 		bne	.L347
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6445              		.loc 1 1057 0
 6446 3700 10121FE5 		ldr	r1, .L748+128
 6447 3704 48208DE2 		add	r2, sp, #72
 6448 3708 2000A0E3 		mov	r0, #32
 6449 370c 24C08DE5 		str	ip, [sp, #36]
 6450 3710 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6451              	.LVL711:
1188:../uvc.c      **** 			  		 break;
 6452              		.loc 1 1188 0
 6453 3714 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6454              		.loc 1 1187 0
 6455 3718 9CE0DBE5 		ldrb	lr, [fp, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6456              		.loc 1 1188 0
 6457 371c 0400A0E3 		mov	r0, #4
 6458 3720 0020A0E1 		mov	r2, r0
 6459 3724 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6460 3728 60121FE5 		ldr	r1, .L748+88
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6461              		.loc 1 1187 0
 6462 372c FDE4CAE5 		strb	lr, [r10, #1277]
1188:../uvc.c      **** 			  		 break;
 6463              		.loc 1 1188 0
 6464 3730 FEFFFFEB 		bl	CyU3PDebugPrint
 6465              	.LVL712:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6466              		.loc 1 980 0
 6467 3734 FF20A0E3 		mov	r2, #255
 6468 3738 D6FEFFEA 		b	.L414
 6469              	.LVL713:
 6470              	.L734:
 6471              	.LBE150:
 6472              	.LBE244:
 6473              	.LBB245:
 6474              	.LBB202:
 986:../uvc.c      **** 		 {
 6475              		.loc 1 986 0
 6476 373c 810057E3 		cmp	r7, #129
 6477 3740 F901000A 		beq	.L361
 6478 3744 7603008A 		bhi	.L362
 6479 3748 010057E3 		cmp	r7, #1
 6480 374c 9602001A 		bne	.L358
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6481              		.loc 1 1057 0
 6482 3750 60121FE5 		ldr	r1, .L748+128
 6483 3754 48208DE2 		add	r2, sp, #72
 6484 3758 2000A0E3 		mov	r0, #32
 6485 375c 24C08DE5 		str	ip, [sp, #36]
 6486 3760 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6487              	.LVL714:
1188:../uvc.c      **** 			  		 break;
 6488              		.loc 1 1188 0
 6489 3764 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6490              		.loc 1 1187 0
 6491 3768 9CE0DBE5 		ldrb	lr, [fp, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6492              		.loc 1 1188 0
 6493 376c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6494              		.loc 1 1187 0
 6495 3770 7CC21FE5 		ldr	ip, .L748+132
1188:../uvc.c      **** 			  		 break;
 6496              		.loc 1 1188 0
 6497 3774 0520A0E3 		mov	r2, #5
 6498 3778 0400A0E3 		mov	r0, #4
 6499 377c B4121FE5 		ldr	r1, .L748+88
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6500              		.loc 1 1187 0
 6501 3780 15E5CCE5 		strb	lr, [ip, #1301]
1188:../uvc.c      **** 			  		 break;
 6502              		.loc 1 1188 0
 6503 3784 FEFFFFEB 		bl	CyU3PDebugPrint
 6504              	.LVL715:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6505              		.loc 1 980 0
 6506 3788 FF20A0E3 		mov	r2, #255
 6507 378c C1FEFFEA 		b	.L414
 6508              	.LVL716:
 6509              	.L736:
 6510              	.LBE202:
 6511              	.LBE245:
 6512              	.LBB246:
 6513              	.LBB219:
 986:../uvc.c      **** 		 {
 6514              		.loc 1 986 0
 6515 3790 810057E3 		cmp	r7, #129
 6516 3794 F201000A 		beq	.L418
 6517 3798 5A03008A 		bhi	.L419
 6518 379c 010057E3 		cmp	r7, #1
 6519 37a0 B002001A 		bne	.L415
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6520              		.loc 1 1057 0
 6521 37a4 B4121FE5 		ldr	r1, .L748+128
 6522 37a8 48208DE2 		add	r2, sp, #72
 6523 37ac 2000A0E3 		mov	r0, #32
 6524 37b0 28308DE5 		str	r3, [sp, #40]
 6525 37b4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6526              	.LVL717:
1172:../uvc.c      **** 					  if(getData == 1)
 6527              		.loc 1 1172 0
 6528 37b8 E0E21FE5 		ldr	lr, .L748+104
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6529              		.loc 1 1059 0
 6530 37bc 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
 6531              	.LVL718:
1172:../uvc.c      **** 					  if(getData == 1)
 6532              		.loc 1 1172 0
 6533 37c0 1C009EE5 		ldr	r0, [lr, #28]
 6534 37c4 0010E0E3 		mvn	r1, #0
1060:../uvc.c      **** 			  value = Data1;
 6535              		.loc 1 1060 0
 6536 37c8 9D80DBE5 		ldrb	r8, [fp, #157]	@ zero_extendqisi2
 6537              	.LVL719:
1172:../uvc.c      **** 					  if(getData == 1)
 6538              		.loc 1 1172 0
 6539 37cc 24C08DE5 		str	ip, [sp, #36]
 6540 37d0 FEFFFFEB 		bl	_txe_mutex_get
 6541              	.LVL720:
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 6542              		.loc 1 1173 0
 6543 37d4 24C09DE5 		ldr	ip, [sp, #36]
 6544 37d8 28309DE5 		ldr	r3, [sp, #40]
 6545 37dc 01005CE3 		cmp	ip, #1
 6546 37e0 8204000A 		beq	.L744
1175:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 6547              		.loc 1 1175 0
 6548 37e4 FF005CE3 		cmp	ip, #255
1178:../uvc.c      **** 					  //dataIdx++;
 6549              		.loc 1 1178 0
 6550 37e8 0010A013 		movne	r1, #0
1176:../uvc.c      **** 					  else
 6551              		.loc 1 1176 0
 6552 37ec 0810A003 		moveq	r1, #8
 6553 37f0 0000A003 		moveq	r0, #0
 6554 37f4 00108D05 		streq	r1, [sp]
 6555 37f8 04008D05 		streq	r0, [sp, #4]
1178:../uvc.c      **** 					  //dataIdx++;
 6556              		.loc 1 1178 0
 6557 37fc 00108D15 		strne	r1, [sp]
 6558 3800 04108D15 		strne	r1, [sp, #4]
1176:../uvc.c      **** 					  else
 6559              		.loc 1 1176 0
 6560 3804 34209D05 		ldreq	r2, [sp, #52]
1178:../uvc.c      **** 					  //dataIdx++;
 6561              		.loc 1 1178 0
 6562 3808 34209D15 		ldrne	r2, [sp, #52]
 6563 380c 34031FE5 		ldr	r0, .L748+104
 6564 3810 2310A0E3 		mov	r1, #35
 6565 3814 24C08DE5 		str	ip, [sp, #36]
 6566 3818 FEFFFFEB 		bl	cmdSet
 6567              	.LVL721:
 6568 381c 24C09DE5 		ldr	ip, [sp, #36]
 6569              	.L427:
1181:../uvc.c      **** #endif
 6570              		.loc 1 1181 0
 6571 3820 48131FE5 		ldr	r1, .L748+104
 6572 3824 1C0091E5 		ldr	r0, [r1, #28]
 6573 3828 24C08DE5 		str	ip, [sp, #36]
 6574 382c FEFFFFEB 		bl	_txe_mutex_put
 6575              	.LVL722:
1183:../uvc.c      **** 					  break;
 6576              		.loc 1 1183 0
 6577 3830 9E30DBE5 		ldrb	r3, [fp, #158]	@ zero_extendqisi2
 6578 3834 24C09DE5 		ldr	ip, [sp, #36]
 6579 3838 00308DE5 		str	r3, [sp]
 6580 383c 0C20A0E1 		mov	r2, ip
 6581 3840 0830A0E1 		mov	r3, r8
 6582 3844 0400A0E3 		mov	r0, #4
 6583 3848 84131FE5 		ldr	r1, .L748+84
 6584 384c FEFFFFEB 		bl	CyU3PDebugPrint
 6585              	.LVL723:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6586              		.loc 1 980 0
 6587 3850 FF30A0E3 		mov	r3, #255
 6588 3854 24C09DE5 		ldr	ip, [sp, #36]
 6589 3858 30209DE5 		ldr	r2, [sp, #48]
 6590 385c D3FDFFEA 		b	.L425
 6591              	.LVL724:
 6592              	.L733:
 6593              	.LBE219:
 6594              	.LBE246:
 6595              	.LBB247:
 6596              	.LBB194:
 986:../uvc.c      **** 		 {
 6597              		.loc 1 986 0
 6598 3860 810057E3 		cmp	r7, #129
 6599 3864 E601000A 		beq	.L372
 6600 3868 0203008A 		bhi	.L373
 6601 386c 010057E3 		cmp	r7, #1
 6602 3870 6CFDFF1A 		bne	.L369
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6603              		.loc 1 1057 0
 6604 3874 84131FE5 		ldr	r1, .L748+128
 6605 3878 48208DE2 		add	r2, sp, #72
 6606 387c 2000A0E3 		mov	r0, #32
 6607 3880 24C08DE5 		str	ip, [sp, #36]
 6608 3884 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6609              	.LVL725:
1188:../uvc.c      **** 			  		 break;
 6610              		.loc 1 1188 0
 6611 3888 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6612              		.loc 1 1187 0
 6613 388c 9CE0DBE5 		ldrb	lr, [fp, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6614              		.loc 1 1188 0
 6615 3890 0620A0E3 		mov	r2, #6
 6616 3894 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6617 3898 0400A0E3 		mov	r0, #4
 6618 389c D4131FE5 		ldr	r1, .L748+88
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6619              		.loc 1 1187 0
 6620 38a0 2DE5CAE5 		strb	lr, [r10, #1325]
1188:../uvc.c      **** 			  		 break;
 6621              		.loc 1 1188 0
 6622 38a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6623              	.LVL726:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6624              		.loc 1 980 0
 6625 38a8 FF20A0E3 		mov	r2, #255
 6626 38ac 79FEFFEA 		b	.L414
 6627              	.LVL727:
 6628              	.L735:
 6629              	.LBE194:
 6630              	.LBE247:
 6631              	.LBB248:
 6632              	.LBB211:
 986:../uvc.c      **** 		 {
 6633              		.loc 1 986 0
 6634 38b0 810058E3 		cmp	r8, #129
 6635 38b4 DE01000A 		beq	.L335
 6636 38b8 F202008A 		bhi	.L336
 6637 38bc 010058E3 		cmp	r8, #1
 6638 38c0 5702001A 		bne	.L332
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6639              		.loc 1 1057 0
 6640 38c4 48208DE2 		add	r2, sp, #72
 6641 38c8 2000A0E3 		mov	r0, #32
 6642 38cc DC131FE5 		ldr	r1, .L748+128
 6643 38d0 28308DE5 		str	r3, [sp, #40]
 6644 38d4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6645              	.LVL728:
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6646              		.loc 1 1059 0
 6647 38d8 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6648              		.loc 1 1115 0
 6649 38dc B524DAE5 		ldrb	r2, [r10, #1205]	@ zero_extendqisi2
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6650              		.loc 1 1059 0
 6651 38e0 34C08DE5 		str	ip, [sp, #52]
 6652              	.LVL729:
1060:../uvc.c      **** 			  value = Data1;
 6653              		.loc 1 1060 0
 6654 38e4 9DC0DBE5 		ldrb	ip, [fp, #157]	@ zero_extendqisi2
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6655              		.loc 1 1115 0
 6656 38e8 010052E3 		cmp	r2, #1
 6657 38ec 04005213 		cmpne	r2, #4
1060:../uvc.c      **** 			  value = Data1;
 6658              		.loc 1 1060 0
 6659 38f0 38C08DE5 		str	ip, [sp, #56]
 6660              	.LVL730:
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6661              		.loc 1 1115 0
 6662 38f4 28309DE5 		ldr	r3, [sp, #40]
 6663 38f8 B603001A 		bne	.L343
1114:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 6664              		.loc 1 1114 0
 6665 38fc 34109DE5 		ldr	r1, [sp, #52]
 6666 3900 0CE481E1 		orr	lr, r1, ip, asl #8
1116:../uvc.c      **** 					  {
 6667              		.loc 1 1116 0
 6668 3904 F9005EE3 		cmp	lr, #249
 6669 3908 B203008A 		bhi	.L343
 6670 390c 40C41FE5 		ldr	ip, .L748+92
 6671 3910 0020A0E3 		mov	r2, #0
 6672 3914 0100A0E3 		mov	r0, #1
 6673 3918 20308DE5 		str	r3, [sp, #32]
 6674 391c 1C708DE5 		str	r7, [sp, #28]
 6675              	.LVL731:
 6676              	.L345:
1120:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 6677              		.loc 1 1120 0
 6678 3920 50741FE5 		ldr	r7, .L748+96
 6679 3924 8230A0E1 		mov	r3, r2, asl #1
 6680 3928 B33097E1 		ldrh	r3, [r7, r3]
 6681 392c FF1002E2 		and	r1, r2, #255
1121:../uvc.c      **** 							}else{
 6682              		.loc 1 1121 0
 6683 3930 0E7063E0 		rsb	r7, r3, lr
 6684 3934 03005EE1 		cmp	lr, r3
 6685 3938 3C108DE5 		str	r1, [sp, #60]
1123:../uvc.c      **** 							}
 6686              		.loc 1 1123 0
 6687 393c 03106EE0 		rsb	r1, lr, r3
 6688 3940 0138A091 		movls	r3, r1, asl #16
 6689 3944 0738A081 		movhi	r3, r7, asl #16
 6690 3948 3C709DE5 		ldr	r7, [sp, #60]
 6691 394c 2338A0E1 		mov	r3, r3, lsr #16
 6692 3950 0C0053E1 		cmp	r3, ip
 6693 3954 012082E2 		add	r2, r2, #1
 6694 3958 0700A031 		movcc	r0, r7
 6695              	.LVL732:
 6696 395c 0C0053E1 		cmp	r3, ip
 6697 3960 03C0A031 		movcc	ip, r3
 6698              	.LVL733:
1118:../uvc.c      **** 						  {
 6699              		.loc 1 1118 0
 6700 3964 080052E3 		cmp	r2, #8
 6701 3968 ECFFFF1A 		bne	.L345
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6702              		.loc 1 1133 0
 6703 396c 94C41FE5 		ldr	ip, .L748+104
 6704              	.LVL734:
 6705 3970 20309DE5 		ldr	r3, [sp, #32]
1130:../uvc.c      **** 
 6706              		.loc 1 1130 0
 6707 3974 012080E2 		add	r2, r0, #1
 6708 3978 FF2002E2 		and	r2, r2, #255
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6709              		.loc 1 1133 0
 6710 397c 1C009CE5 		ldr	r0, [ip, #28]
 6711              	.LVL735:
 6712 3980 0010E0E3 		mvn	r1, #0
1130:../uvc.c      **** 
 6713              		.loc 1 1130 0
 6714 3984 3C208DE5 		str	r2, [sp, #60]
 6715              	.LVL736:
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6716              		.loc 1 1133 0
 6717 3988 28308DE5 		str	r3, [sp, #40]
 6718 398c 24C08DE5 		str	ip, [sp, #36]
 6719 3990 1C709DE5 		ldr	r7, [sp, #28]
 6720 3994 FEFFFFEB 		bl	_txe_mutex_get
 6721              	.LVL737:
1134:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6722              		.loc 1 1134 0
 6723 3998 3CE09DE5 		ldr	lr, [sp, #60]
 6724 399c 24C09DE5 		ldr	ip, [sp, #36]
 6725 39a0 0010A0E3 		mov	r1, #0
 6726 39a4 28309DE5 		ldr	r3, [sp, #40]
 6727 39a8 00E08DE5 		str	lr, [sp]
 6728 39ac 30209DE5 		ldr	r2, [sp, #48]
 6729 39b0 0C00A0E1 		mov	r0, ip
 6730 39b4 04108DE5 		str	r1, [sp, #4]
 6731 39b8 0310A0E3 		mov	r1, #3
 6732 39bc FEFFFFEB 		bl	cmdSet
 6733              	.LVL738:
1135:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 6734              		.loc 1 1135 0
 6735 39c0 24C09DE5 		ldr	ip, [sp, #36]
 6736 39c4 1C009CE5 		ldr	r0, [ip, #28]
 6737 39c8 FEFFFFEB 		bl	_txe_mutex_put
 6738              	.LVL739:
1141:../uvc.c      **** 					  }else{
 6739              		.loc 1 1141 0
 6740 39cc 3CC09DE5 		ldr	ip, [sp, #60]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6741              		.loc 1 1140 0
 6742 39d0 0130A0E3 		mov	r3, #1
1141:../uvc.c      **** 					  }else{
 6743              		.loc 1 1141 0
 6744 39d4 0DC3CAE5 		strb	ip, [r10, #781]
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6745              		.loc 1 1138 0
 6746 39d8 34C09DE5 		ldr	ip, [sp, #52]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6747              		.loc 1 1140 0
 6748 39dc E834CAE5 		strb	r3, [r10, #1256]
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6749              		.loc 1 1138 0
 6750 39e0 E5C4CAE5 		strb	ip, [r10, #1253]
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 6751              		.loc 1 1139 0
 6752 39e4 38C09DE5 		ldr	ip, [sp, #56]
 6753 39e8 E6C4CAE5 		strb	ip, [r10, #1254]
 6754              	.LVL740:
 6755              	.L346:
1145:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 6756              		.loc 1 1145 0
 6757 39ec 9C30DBE5 		ldrb	r3, [fp, #156]	@ zero_extendqisi2
 6758              	.LVL741:
1146:../uvc.c      **** 					  break;
 6759              		.loc 1 1146 0
 6760 39f0 9D20DBE5 		ldrb	r2, [fp, #157]	@ zero_extendqisi2
 6761              	.LVL742:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6762              		.loc 1 980 0
 6763 39f4 FFC0A0E3 		mov	ip, #255
 6764 39f8 45FDFFEA 		b	.L342
 6765              	.LVL743:
 6766              	.L737:
 6767              	.LBE211:
 6768              	.LBE248:
 6769              	.LBB249:
 6770              	.LBB230:
 986:../uvc.c      **** 		 {
 6771              		.loc 1 986 0
 6772 39fc 810057E3 		cmp	r7, #129
 6773 3a00 6F01000A 		beq	.L383
 6774 3a04 C202008A 		bhi	.L384
 6775 3a08 010057E3 		cmp	r7, #1
 6776 3a0c F301001A 		bne	.L380
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6777              		.loc 1 1057 0
 6778 3a10 2000A0E3 		mov	r0, #32
 6779 3a14 24151FE5 		ldr	r1, .L748+128
 6780 3a18 48208DE2 		add	r2, sp, #72
 6781 3a1c 28308DE5 		str	r3, [sp, #40]
 6782 3a20 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6783              	.LVL744:
1149:../uvc.c      **** 					  {
 6784              		.loc 1 1149 0
 6785 3a24 30C51FE5 		ldr	ip, .L748+132
 6786 3a28 B504DCE5 		ldrb	r0, [ip, #1205]	@ zero_extendqisi2
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6787              		.loc 1 1059 0
 6788 3a2c 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
1149:../uvc.c      **** 					  {
 6789              		.loc 1 1149 0
 6790 3a30 010050E3 		cmp	r0, #1
 6791 3a34 08005013 		cmpne	r0, #8
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6792              		.loc 1 1059 0
 6793 3a38 34C08DE5 		str	ip, [sp, #52]
 6794              	.LVL745:
1060:../uvc.c      **** 			  value = Data1;
 6795              		.loc 1 1060 0
 6796 3a3c 9DC0DBE5 		ldrb	ip, [fp, #157]	@ zero_extendqisi2
1149:../uvc.c      **** 					  {
 6797              		.loc 1 1149 0
 6798 3a40 0000A013 		movne	r0, #0
 6799 3a44 0100A003 		moveq	r0, #1
1060:../uvc.c      **** 			  value = Data1;
 6800              		.loc 1 1060 0
 6801 3a48 38C08DE5 		str	ip, [sp, #56]
 6802              	.LVL746:
1149:../uvc.c      **** 					  {
 6803              		.loc 1 1149 0
 6804 3a4c C303001A 		bne	.L391
 6805              	.LVL747:
1152:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 6806              		.loc 1 1152 0
 6807 3a50 78C51FE5 		ldr	ip, .L748+104
 6808 3a54 0010E0E3 		mvn	r1, #0
 6809 3a58 1C009CE5 		ldr	r0, [ip, #28]
 6810 3a5c 24C08DE5 		str	ip, [sp, #36]
 6811 3a60 FEFFFFEB 		bl	_txe_mutex_get
 6812              	.LVL748:
1153:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6813              		.loc 1 1153 0
 6814 3a64 34E09DE5 		ldr	lr, [sp, #52]
 6815 3a68 24C09DE5 		ldr	ip, [sp, #36]
 6816 3a6c 0010A0E3 		mov	r1, #0
 6817 3a70 00E08DE5 		str	lr, [sp]
 6818 3a74 30209DE5 		ldr	r2, [sp, #48]
 6819 3a78 28309DE5 		ldr	r3, [sp, #40]
 6820 3a7c 0C00A0E1 		mov	r0, ip
 6821 3a80 04108DE5 		str	r1, [sp, #4]
 6822 3a84 2210A0E3 		mov	r1, #34
 6823 3a88 FEFFFFEB 		bl	cmdSet
 6824              	.LVL749:
1154:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 6825              		.loc 1 1154 0
 6826 3a8c 24C09DE5 		ldr	ip, [sp, #36]
 6827 3a90 1C009CE5 		ldr	r0, [ip, #28]
 6828 3a94 FEFFFFEB 		bl	_txe_mutex_put
 6829              	.LVL750:
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6830              		.loc 1 1157 0
 6831 3a98 A4E51FE5 		ldr	lr, .L748+132
 6832 3a9c 34C09DE5 		ldr	ip, [sp, #52]
1159:../uvc.c      **** 					  }else{
 6833              		.loc 1 1159 0
 6834 3aa0 4875CEE5 		strb	r7, [lr, #1352]
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6835              		.loc 1 1157 0
 6836 3aa4 45C5CEE5 		strb	ip, [lr, #1349]
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 6837              		.loc 1 1158 0
 6838 3aa8 38C09DE5 		ldr	ip, [sp, #56]
 6839 3aac 46C5CEE5 		strb	ip, [lr, #1350]
 6840              	.LVL751:
 6841              	.L392:
1163:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 6842              		.loc 1 1163 0
 6843 3ab0 9C30DBE5 		ldrb	r3, [fp, #156]	@ zero_extendqisi2
 6844              	.LVL752:
1164:../uvc.c      **** 
 6845              		.loc 1 1164 0
 6846 3ab4 9D20DBE5 		ldrb	r2, [fp, #157]	@ zero_extendqisi2
 6847              	.LVL753:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6848              		.loc 1 980 0
 6849 3ab8 FFC0A0E3 		mov	ip, #255
 6850 3abc 68FDFFEA 		b	.L390
 6851              	.LVL754:
 6852              	.L740:
 6853              	.LBE230:
 6854              	.LBE249:
 6855              	.LBE312:
 6856              	.LBE453:
 6857              	.LBB454:
 6858              	.LBB426:
 6859              	.LBB391:
 6860              	.LBB362:
 426:../uvc.c      **** 		 {
 6861              		.loc 1 426 0
 6862 3ac0 810053E3 		cmp	r3, #129
 6863 3ac4 6203000A 		beq	.L484
 6864 3ac8 9301008A 		bhi	.L485
 6865 3acc 010053E3 		cmp	r3, #1
 6866 3ad0 5603001A 		bne	.L481
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6867              		.loc 1 664 0
 6868 3ad4 48208DE2 		add	r2, sp, #72
 6869 3ad8 2000A0E3 		mov	r0, #32
 6870 3adc EC151FE5 		ldr	r1, .L748+128
 6871 3ae0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6872              	.LVL755:
 666:../uvc.c      **** 			   {
 6873              		.loc 1 666 0
 6874 3ae4 002050E2 		subs	r2, r0, #0
 6875 3ae8 D103001A 		bne	.L496
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6876              		.loc 1 768 0
 6877 3aec 000057E3 		cmp	r7, #0
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6878              		.loc 1 668 0
 6879 3af0 9C30D4E5 		ldrb	r3, [r4, #156]	@ zero_extendqisi2
 6880              	.LVL756:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6881              		.loc 1 671 0
 6882 3af4 9E20D4E5 		ldrb	r2, [r4, #158]	@ zero_extendqisi2
 6883              	.LVL757:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6884              		.loc 1 768 0
 6885 3af8 2A00000A 		beq	.L498
 6886 3afc 010057E3 		cmp	r7, #1
 769:../uvc.c      **** 					 		 }
 6887              		.loc 1 769 0
 6888 3b00 9030C4E5 		strb	r3, [r4, #144]
 6889              	.LVL758:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6890              		.loc 1 768 0
 6891 3b04 2700009A 		bls	.L498
 769:../uvc.c      **** 					 		 }
 6892              		.loc 1 769 0
 6893 3b08 9D10D4E5 		ldrb	r1, [r4, #157]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6894              		.loc 1 768 0
 6895 3b0c 020057E3 		cmp	r7, #2
 769:../uvc.c      **** 					 		 }
 6896              		.loc 1 769 0
 6897 3b10 9110C4E5 		strb	r1, [r4, #145]
 6898              	.LVL759:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6899              		.loc 1 768 0
 6900 3b14 2300000A 		beq	.L498
 6901 3b18 030057E3 		cmp	r7, #3
 769:../uvc.c      **** 					 		 }
 6902              		.loc 1 769 0
 6903 3b1c 9220C4E5 		strb	r2, [r4, #146]
 6904              	.LVL760:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6905              		.loc 1 768 0
 6906 3b20 2000000A 		beq	.L498
 769:../uvc.c      **** 					 		 }
 6907              		.loc 1 769 0
 6908 3b24 9F10D4E5 		ldrb	r1, [r4, #159]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6909              		.loc 1 768 0
 6910 3b28 040057E3 		cmp	r7, #4
 769:../uvc.c      **** 					 		 }
 6911              		.loc 1 769 0
 6912 3b2c 9310C4E5 		strb	r1, [r4, #147]
 6913              	.LVL761:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6914              		.loc 1 768 0
 6915 3b30 1C00000A 		beq	.L498
 769:../uvc.c      **** 					 		 }
 6916              		.loc 1 769 0
 6917 3b34 A010D4E5 		ldrb	r1, [r4, #160]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6918              		.loc 1 768 0
 6919 3b38 050057E3 		cmp	r7, #5
 769:../uvc.c      **** 					 		 }
 6920              		.loc 1 769 0
 6921 3b3c 9410C4E5 		strb	r1, [r4, #148]
 6922              	.LVL762:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6923              		.loc 1 768 0
 6924 3b40 1800000A 		beq	.L498
 769:../uvc.c      **** 					 		 }
 6925              		.loc 1 769 0
 6926 3b44 A110D4E5 		ldrb	r1, [r4, #161]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6927              		.loc 1 768 0
 6928 3b48 060057E3 		cmp	r7, #6
 769:../uvc.c      **** 					 		 }
 6929              		.loc 1 769 0
 6930 3b4c 9510C4E5 		strb	r1, [r4, #149]
 6931              	.LVL763:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6932              		.loc 1 768 0
 6933 3b50 1400000A 		beq	.L498
 769:../uvc.c      **** 					 		 }
 6934              		.loc 1 769 0
 6935 3b54 A210DBE5 		ldrb	r1, [fp, #162]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6936              		.loc 1 768 0
 6937 3b58 070057E3 		cmp	r7, #7
 769:../uvc.c      **** 					 		 }
 6938              		.loc 1 769 0
 6939 3b5c 9610CBE5 		strb	r1, [fp, #150]
 6940              	.LVL764:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6941              		.loc 1 768 0
 6942 3b60 1000000A 		beq	.L498
 769:../uvc.c      **** 					 		 }
 6943              		.loc 1 769 0
 6944 3b64 A310D4E5 		ldrb	r1, [r4, #163]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6945              		.loc 1 768 0
 6946 3b68 080057E3 		cmp	r7, #8
 769:../uvc.c      **** 					 		 }
 6947              		.loc 1 769 0
 6948 3b6c 9710C4E5 		strb	r1, [r4, #151]
 6949              	.LVL765:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6950              		.loc 1 768 0
 6951 3b70 0C00000A 		beq	.L498
 769:../uvc.c      **** 					 		 }
 6952              		.loc 1 769 0
 6953 3b74 A410D4E5 		ldrb	r1, [r4, #164]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6954              		.loc 1 768 0
 6955 3b78 090057E3 		cmp	r7, #9
 769:../uvc.c      **** 					 		 }
 6956              		.loc 1 769 0
 6957 3b7c 9810C4E5 		strb	r1, [r4, #152]
 6958              	.LVL766:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6959              		.loc 1 768 0
 6960 3b80 0800000A 		beq	.L498
 769:../uvc.c      **** 					 		 }
 6961              		.loc 1 769 0
 6962 3b84 A510D4E5 		ldrb	r1, [r4, #165]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6963              		.loc 1 768 0
 6964 3b88 0A0057E3 		cmp	r7, #10
 769:../uvc.c      **** 					 		 }
 6965              		.loc 1 769 0
 6966 3b8c 9910C4E5 		strb	r1, [r4, #153]
 6967              	.LVL767:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6968              		.loc 1 768 0
 6969 3b90 0400000A 		beq	.L498
 769:../uvc.c      **** 					 		 }
 6970              		.loc 1 769 0
 6971 3b94 A610D4E5 		ldrb	r1, [r4, #166]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6972              		.loc 1 768 0
 6973 3b98 0B0057E3 		cmp	r7, #11
 769:../uvc.c      **** 					 		 }
 6974              		.loc 1 769 0
 6975 3b9c 9A10C4E5 		strb	r1, [r4, #154]
 6976              	.LVL768:
 6977 3ba0 A710D415 		ldrneb	r1, [r4, #167]	@ zero_extendqisi2
 6978 3ba4 9B10C415 		strneb	r1, [r4, #155]
 6979              	.LVL769:
 6980              	.L498:
 771:../uvc.c      **** 							 break;
 6981              		.loc 1 771 0
 6982 3ba8 2C208DE5 		str	r2, [sp, #44]
 6983 3bac 28308DE5 		str	r3, [sp, #40]
 6984 3bb0 FEFFFFEB 		bl	I2CCmdHandler
 6985              	.LVL770:
 6986 3bb4 2C209DE5 		ldr	r2, [sp, #44]
 6987 3bb8 28309DE5 		ldr	r3, [sp, #40]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6988              		.loc 1 414 0
 6989 3bbc FF80A0E3 		mov	r8, #255
 6990 3bc0 08C0A0E1 		mov	ip, r8
 6991              	.LVL771:
 6992              	.L491:
 960:../uvc.c      **** }
 6993              		.loc 1 960 0
 6994 3bc4 04108DE8 		stmia	sp, {r2, ip}
 6995 3bc8 F4161FE5 		ldr	r1, .L748+100
 6996 3bcc 08808DE5 		str	r8, [sp, #8]
 6997 3bd0 30209DE5 		ldr	r2, [sp, #48]
 6998              	.LVL772:
 6999 3bd4 0400A0E3 		mov	r0, #4
 7000 3bd8 FEFFFFEB 		bl	CyU3PDebugPrint
 7001              	.LVL773:
 7002 3bdc 50309DE5 		ldr	r3, [sp, #80]
 7003 3be0 6FFAFFEA 		b	.L260
 7004              	.LVL774:
 7005              	.L741:
 7006              	.LBE362:
 7007              	.LBE391:
 7008              	.LBB392:
 7009              	.LBB369:
 426:../uvc.c      **** 		 {
 7010              		.loc 1 426 0
 7011 3be4 810057E3 		cmp	r7, #129
 7012 3be8 E202000A 		beq	.L503
 7013 3bec 4701008A 		bhi	.L504
 7014 3bf0 010057E3 		cmp	r7, #1
 7015 3bf4 ED02001A 		bne	.L500
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 7016              		.loc 1 664 0
 7017 3bf8 48208DE2 		add	r2, sp, #72
 7018 3bfc 2000A0E3 		mov	r0, #32
 7019 3c00 10171FE5 		ldr	r1, .L748+128
 7020 3c04 28308DE5 		str	r3, [sp, #40]
 7021 3c08 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 7022              	.LVL775:
 666:../uvc.c      **** 			   {
 7023              		.loc 1 666 0
 7024 3c0c 002050E2 		subs	r2, r0, #0
 7025 3c10 6203001A 		bne	.L511
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 7026              		.loc 1 811 0
 7027 3c14 3CE71FE5 		ldr	lr, .L748+104
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 7028              		.loc 1 668 0
 7029 3c18 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
 7030              	.LVL776:
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 7031              		.loc 1 811 0
 7032 3c1c 1C009EE5 		ldr	r0, [lr, #28]
 7033              	.LVL777:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7034              		.loc 1 671 0
 7035 3c20 9EE0D4E5 		ldrb	lr, [r4, #158]	@ zero_extendqisi2
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 7036              		.loc 1 811 0
 7037 3c24 0010E0E3 		mvn	r1, #0
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7038              		.loc 1 671 0
 7039 3c28 30E08DE5 		str	lr, [sp, #48]
 7040              	.LVL778:
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 7041              		.loc 1 811 0
 7042 3c2c 2C208DE5 		str	r2, [sp, #44]
 7043 3c30 24C08DE5 		str	ip, [sp, #36]
 7044 3c34 FEFFFFEB 		bl	_txe_mutex_get
 7045              	.LVL779:
 812:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 7046              		.loc 1 812 0
 7047 3c38 24C09DE5 		ldr	ip, [sp, #36]
 7048 3c3c 2C209DE5 		ldr	r2, [sp, #44]
 7049 3c40 28309DE5 		ldr	r3, [sp, #40]
 7050 3c44 00C08DE5 		str	ip, [sp]
 7051 3c48 04208DE5 		str	r2, [sp, #4]
 7052 3c4c 2510A0E3 		mov	r1, #37
 7053 3c50 0320A0E1 		mov	r2, r3
 7054 3c54 7C071FE5 		ldr	r0, .L748+104
 7055 3c58 0830A0E1 		mov	r3, r8
 7056 3c5c FEFFFFEB 		bl	cmdSet
 7057              	.LVL780:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 7058              		.loc 1 813 0
 7059 3c60 88171FE5 		ldr	r1, .L748+104
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7060              		.loc 1 414 0
 7061 3c64 FF80A0E3 		mov	r8, #255
 7062              	.LVL781:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 7063              		.loc 1 813 0
 7064 3c68 1C0091E5 		ldr	r0, [r1, #28]
 7065 3c6c FEFFFFEB 		bl	_txe_mutex_put
 7066              	.LVL782:
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 7067              		.loc 1 814 0
 7068 3c70 24C09DE5 		ldr	ip, [sp, #36]
 7069 3c74 30309DE5 		ldr	r3, [sp, #48]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7070              		.loc 1 414 0
 7071 3c78 0820A0E1 		mov	r2, r8
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 7072              		.loc 1 814 0
 7073 3c7c 85C0CAE5 		strb	ip, [r10, #133]
 815:../uvc.c      **** 							 break;
 7074              		.loc 1 815 0
 7075 3c80 8870CAE5 		strb	r7, [r10, #136]
 7076              	.LVL783:
 7077              	.L510:
 960:../uvc.c      **** }
 7078              		.loc 1 960 0
 7079 3c84 00308DE5 		str	r3, [sp]
 7080 3c88 04018DE9 		stmib	sp, {r2, r8}
 7081 3c8c B8171FE5 		ldr	r1, .L748+100
 7082 3c90 0C30A0E1 		mov	r3, ip
 7083 3c94 0720A0E1 		mov	r2, r7
 7084              	.LVL784:
 7085 3c98 0400A0E3 		mov	r0, #4
 7086 3c9c FEFFFFEB 		bl	CyU3PDebugPrint
 7087              	.LVL785:
 7088 3ca0 50309DE5 		ldr	r3, [sp, #80]
 7089 3ca4 3EFAFFEA 		b	.L260
 7090              	.LVL786:
 7091              	.L742:
 7092              	.LBE369:
 7093              	.LBE392:
 7094              	.LBB393:
 7095              	.LBB352:
 426:../uvc.c      **** 		 {
 7096              		.loc 1 426 0
 7097 3ca8 810058E3 		cmp	r8, #129
 7098 3cac 7902000A 		beq	.L458
 7099 3cb0 0E01008A 		bhi	.L459
 7100 3cb4 010058E3 		cmp	r8, #1
 7101 3cb8 9401001A 		bne	.L455
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 7102              		.loc 1 664 0
 7103 3cbc 48208DE2 		add	r2, sp, #72
 7104 3cc0 2000A0E3 		mov	r0, #32
 7105 3cc4 D4171FE5 		ldr	r1, .L748+128
 7106 3cc8 28308DE5 		str	r3, [sp, #40]
 7107 3ccc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 7108              	.LVL787:
 666:../uvc.c      **** 			   {
 7109              		.loc 1 666 0
 7110 3cd0 002050E2 		subs	r2, r0, #0
 7111 3cd4 2A03001A 		bne	.L480
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7112              		.loc 1 940 0
 7113 3cd8 00E81FE5 		ldr	lr, .L748+104
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 7114              		.loc 1 668 0
 7115 3cdc 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
 7116              	.LVL788:
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7117              		.loc 1 940 0
 7118 3ce0 1C009EE5 		ldr	r0, [lr, #28]
 7119              	.LVL789:
 7120 3ce4 0010E0E3 		mvn	r1, #0
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7121              		.loc 1 671 0
 7122 3ce8 9E70D4E5 		ldrb	r7, [r4, #158]	@ zero_extendqisi2
 7123              	.LVL790:
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7124              		.loc 1 940 0
 7125 3cec 2C208DE5 		str	r2, [sp, #44]
 7126 3cf0 24C08DE5 		str	ip, [sp, #36]
 7127 3cf4 FEFFFFEB 		bl	_txe_mutex_get
 7128              	.LVL791:
 941:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 7129              		.loc 1 941 0
 7130 3cf8 24C09DE5 		ldr	ip, [sp, #36]
 7131 3cfc 2C209DE5 		ldr	r2, [sp, #44]
 7132 3d00 00C08DE5 		str	ip, [sp]
 7133 3d04 28309DE5 		ldr	r3, [sp, #40]
 7134 3d08 04208DE5 		str	r2, [sp, #4]
 7135 3d0c 1310A0E3 		mov	r1, #19
 7136 3d10 30209DE5 		ldr	r2, [sp, #48]
 7137 3d14 3C081FE5 		ldr	r0, .L748+104
 7138 3d18 FEFFFFEB 		bl	cmdSet
 7139              	.LVL792:
 942:../uvc.c      **** 
 7140              		.loc 1 942 0
 7141 3d1c 44181FE5 		ldr	r1, .L748+104
 7142 3d20 1C0091E5 		ldr	r0, [r1, #28]
 7143 3d24 FEFFFFEB 		bl	_txe_mutex_put
 7144              	.LVL793:
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 7145              		.loc 1 944 0
 7146 3d28 24C09DE5 		ldr	ip, [sp, #36]
 7147 3d2c 38281FE5 		ldr	r2, .L748+132
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7148              		.loc 1 414 0
 7149 3d30 FF30A0E3 		mov	r3, #255
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 7150              		.loc 1 944 0
 7151 3d34 55C3C2E5 		strb	ip, [r2, #853]
 945:../uvc.c      **** 							 break;
 7152              		.loc 1 945 0
 7153 3d38 5883C2E5 		strb	r8, [r2, #856]
 7154 3d3c 400000EA 		b	.L465
 7155              	.LVL794:
 7156              	.L743:
 7157              	.LBE352:
 7158              	.LBE393:
 7159              	.LBB394:
 7160              	.LBB380:
 426:../uvc.c      **** 		 {
 7161              		.loc 1 426 0
 7162 3d40 810058E3 		cmp	r8, #129
 7163 3d44 8602000A 		beq	.L471
 7164 3d48 EC00008A 		bhi	.L472
 7165 3d4c 010058E3 		cmp	r8, #1
 7166 3d50 6E01001A 		bne	.L455
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 7167              		.loc 1 664 0
 7168 3d54 48208DE2 		add	r2, sp, #72
 7169 3d58 2000A0E3 		mov	r0, #32
 7170 3d5c 6C181FE5 		ldr	r1, .L748+128
 7171 3d60 28308DE5 		str	r3, [sp, #40]
 7172 3d64 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 7173              	.LVL795:
 666:../uvc.c      **** 			   {
 7174              		.loc 1 666 0
 7175 3d68 002050E2 		subs	r2, r0, #0
 7176 3d6c 0403001A 		bne	.L480
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7177              		.loc 1 762 0
 7178 3d70 98E81FE5 		ldr	lr, .L748+104
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 7179              		.loc 1 668 0
 7180 3d74 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
 7181              	.LVL796:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7182              		.loc 1 762 0
 7183 3d78 1C009EE5 		ldr	r0, [lr, #28]
 7184              	.LVL797:
 7185 3d7c 0010E0E3 		mvn	r1, #0
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7186              		.loc 1 671 0
 7187 3d80 9E70D4E5 		ldrb	r7, [r4, #158]	@ zero_extendqisi2
 7188              	.LVL798:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7189              		.loc 1 762 0
 7190 3d84 2C208DE5 		str	r2, [sp, #44]
 7191 3d88 24C08DE5 		str	ip, [sp, #36]
 7192 3d8c FEFFFFEB 		bl	_txe_mutex_get
 7193              	.LVL799:
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 7194              		.loc 1 763 0
 7195 3d90 24C09DE5 		ldr	ip, [sp, #36]
 7196 3d94 2C209DE5 		ldr	r2, [sp, #44]
 7197 3d98 01107CE2 		rsbs	r1, ip, #1
 7198 3d9c 0010A033 		movcc	r1, #0
 7199 3da0 28309DE5 		ldr	r3, [sp, #40]
 7200 3da4 04208DE5 		str	r2, [sp, #4]
 7201 3da8 00108DE5 		str	r1, [sp]
 7202 3dac 30209DE5 		ldr	r2, [sp, #48]
 7203 3db0 1E10A0E3 		mov	r1, #30
 7204 3db4 DC081FE5 		ldr	r0, .L748+104
 7205 3db8 FEFFFFEB 		bl	cmdSet
 7206              	.LVL800:
 764:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 7207              		.loc 1 764 0
 7208 3dbc E4181FE5 		ldr	r1, .L748+104
 7209 3dc0 1C0091E5 		ldr	r0, [r1, #28]
 7210 3dc4 FEFFFFEB 		bl	_txe_mutex_put
 7211              	.LVL801:
 765:../uvc.c      **** 							 break;
 7212              		.loc 1 765 0
 7213 3dc8 D4281FE5 		ldr	r2, .L748+132
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7214              		.loc 1 414 0
 7215 3dcc FF30A0E3 		mov	r3, #255
 765:../uvc.c      **** 							 break;
 7216              		.loc 1 765 0
 7217 3dd0 6084C2E5 		strb	r8, [r2, #1120]
 7218 3dd4 24C09DE5 		ldr	ip, [sp, #36]
 7219 3dd8 190000EA 		b	.L465
 7220              	.LVL802:
 7221              	.L560:
 7222              	.LBE380:
 7223              	.LBE394:
 7224              	.LBE426:
 7225              	.LBE454:
 7226              	.LBB455:
 7227              	.LBB142:
3242:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 7228              		.loc 1 3242 0
 7229 3ddc B824DDE1 		ldrh	r2, [sp, #72]
 7230 3de0 04191FE5 		ldr	r1, .L748+108
 7231 3de4 C430DBE5 		ldrb	r3, [fp, #196]	@ zero_extendqisi2
 7232 3de8 0400A0E3 		mov	r0, #4
 7233              	.LVL803:
 7234 3dec FEFFFFEB 		bl	CyU3PDebugPrint
 7235              	.LVL804:
3243:../uvc.c      ****                         }
 7236              		.loc 1 3243 0
 7237 3df0 0000A0E3 		mov	r0, #0
 7238 3df4 0020A0E1 		mov	r2, r0
 7239 3df8 0110A0E3 		mov	r1, #1
 7240 3dfc FEFFFFEB 		bl	CyU3PUsbStall
 7241              	.LVL805:
 7242 3e00 F0F9FFEA 		b	.L527
 7243              	.LVL806:
 7244              	.L716:
 7245 3e04 0070A0E1 		mov	r7, r0
 7246              	.LBE142:
 7247              	.LBE455:
3404:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 7248              		.loc 1 3404 0
 7249 3e08 28191FE5 		ldr	r1, .L748+112
 7250 3e0c 0800A0E1 		mov	r0, r8
 7251              	.LVL807:
 7252 3e10 0720A0E1 		mov	r2, r7
 7253 3e14 FEFFFFEB 		bl	CyU3PDebugPrint
 7254              	.LVL808:
3405:../uvc.c      **** 					}
 7255              		.loc 1 3405 0
 7256 3e18 0700A0E1 		mov	r0, r7
 7257 3e1c FEFFFFEB 		bl	CyFxAppErrorHandler
 7258              	.LVL809:
 7259              	.L474:
 7260              	.LBB456:
 7261              	.LBB427:
 7262              	.LBB395:
 7263              	.LBB381:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7264              		.loc 1 432 0
 7265 3e20 30191FE5 		ldr	r1, .L748+128
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 7266              		.loc 1 431 0
 7267 3e24 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7268              		.loc 1 432 0
 7269 3e28 0200A0E3 		mov	r0, #2
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 7270              		.loc 1 430 0
 7271 3e2c 9C70CBE5 		strb	r7, [fp, #156]
 7272              	.L690:
 595:../uvc.c      **** 			 }
 7273              		.loc 1 595 0
 7274 3e30 9D30CBE5 		strb	r3, [fp, #157]
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7275              		.loc 1 597 0
 7276 3e34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7277              	.LVL810:
 598:../uvc.c      **** 			  break;
 7278              		.loc 1 598 0
 7279 3e38 9C30DBE5 		ldrb	r3, [fp, #156]	@ zero_extendqisi2
 7280              	.LVL811:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7281              		.loc 1 414 0
 7282 3e3c FF70A0E3 		mov	r7, #255
 7283 3e40 07C0A0E1 		mov	ip, r7
 7284              	.LVL812:
 7285              	.L465:
 7286              	.LBE381:
 7287              	.LBE395:
 7288              	.LBB396:
 7289              	.LBB353:
 960:../uvc.c      **** }
 7290              		.loc 1 960 0
 7291 3e44 04308DE5 		str	r3, [sp, #4]
 7292 3e48 FF10A0E3 		mov	r1, #255
 7293 3e4c 00708DE5 		str	r7, [sp]
 7294 3e50 0820A0E1 		mov	r2, r8
 7295 3e54 0C30A0E1 		mov	r3, ip
 7296              	.LVL813:
 7297 3e58 FAFAFFEA 		b	.L699
 7298              	.LVL814:
 7299              	.L288:
 7300              	.LBE353:
 7301              	.LBE396:
 7302              	.LBE427:
 7303              	.LBE456:
 7304              	.LBB457:
 7305              	.LBB342:
 7306              	.LBB332:
 7307              	.LBB326:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 7308              		.loc 1 626 0
 7309 3e5c E711DAE5 		ldrb	r1, [r10, #487]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 7310              		.loc 1 627 0
 7311 3e60 E821DAE5 		ldrb	r2, [r10, #488]	@ zero_extendqisi2
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 7312              		.loc 1 628 0
 7313 3e64 0030A0E3 		mov	r3, #0
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7314              		.loc 1 631 0
 7315 3e68 0800A0E1 		mov	r0, r8
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 7316              		.loc 1 626 0
 7317 3e6c 9C10CBE5 		strb	r1, [fp, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7318              		.loc 1 414 0
 7319 3e70 FF80A0E3 		mov	r8, #255
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7320              		.loc 1 631 0
 7321 3e74 84191FE5 		ldr	r1, .L748+128
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 7322              		.loc 1 627 0
 7323 3e78 9D20CBE5 		strb	r2, [fp, #157]
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 7324              		.loc 1 628 0
 7325 3e7c 9E30CBE5 		strb	r3, [fp, #158]
 629:../uvc.c      **** 		 	 }
 7326              		.loc 1 629 0
 7327 3e80 9F30CBE5 		strb	r3, [fp, #159]
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7328              		.loc 1 631 0
 7329 3e84 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7330              	.LVL815:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7331              		.loc 1 414 0
 7332 3e88 0830A0E1 		mov	r3, r8
 632:../uvc.c      **** 			  break;
 7333              		.loc 1 632 0
 7334 3e8c 9C20DBE5 		ldrb	r2, [fp, #156]	@ zero_extendqisi2
 7335              	.LVL816:
 7336 3e90 E8FAFFEA 		b	.L291
 7337              	.LVL817:
 7338              	.L284:
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 7339              		.loc 1 559 0
 7340 3e94 3030DBE5 		ldrb	r3, [fp, #48]	@ zero_extendqisi2
 7341 3e98 000053E3 		cmp	r3, #0
 7342 3e9c B302000A 		beq	.L745
 7343              	.LVL818:
 7344              	.L292:
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7345              		.loc 1 569 0
 7346 3ea0 ED21DAE5 		ldrb	r2, [r10, #493]	@ zero_extendqisi2
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7347              		.loc 1 570 0
 7348 3ea4 0030A0E3 		mov	r3, #0
 575:../uvc.c      **** 
 7349              		.loc 1 575 0
 7350 3ea8 0800A0E1 		mov	r0, r8
 7351 3eac BC191FE5 		ldr	r1, .L748+128
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7352              		.loc 1 414 0
 7353 3eb0 FF80A0E3 		mov	r8, #255
 7354              	.LVL819:
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7355              		.loc 1 569 0
 7356 3eb4 9C20CBE5 		strb	r2, [fp, #156]
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7357              		.loc 1 570 0
 7358 3eb8 9D30CBE5 		strb	r3, [fp, #157]
 7359              	.LVL820:
 575:../uvc.c      **** 
 7360              		.loc 1 575 0
 7361 3ebc 2C208DE5 		str	r2, [sp, #44]
 7362 3ec0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7363              	.LVL821:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7364              		.loc 1 414 0
 7365 3ec4 0830A0E1 		mov	r3, r8
 7366 3ec8 2C209DE5 		ldr	r2, [sp, #44]
 7367 3ecc D9FAFFEA 		b	.L291
 7368              	.LVL822:
 7369              	.L365:
 7370              	.LBE326:
 7371              	.LBE332:
 7372              	.LBE342:
 7373              	.LBE457:
 7374              	.LBB458:
 7375              	.LBB313:
 7376              	.LBB250:
 7377              	.LBB203:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7378              		.loc 1 1033 0
 7379 3ed0 DC291FE5 		ldr	r2, .L748+132
 7380 3ed4 0F15D2E5 		ldrb	r1, [r2, #1295]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7381              		.loc 1 1034 0
 7382 3ed8 1025D2E5 		ldrb	r2, [r2, #1296]	@ zero_extendqisi2
 7383 3edc 13FBFFEA 		b	.L685
 7384              	.LVL823:
 7385              	.L376:
 7386              	.LBE203:
 7387              	.LBE250:
 7388              	.LBB251:
 7389              	.LBB195:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7390              		.loc 1 1033 0
 7391 3ee0 ECC91FE5 		ldr	ip, .L748+132
 7392 3ee4 2715DCE5 		ldrb	r1, [ip, #1319]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7393              		.loc 1 1034 0
 7394 3ee8 2825DCE5 		ldrb	r2, [ip, #1320]	@ zero_extendqisi2
 7395 3eec 0FFBFFEA 		b	.L685
 7396              	.LVL824:
 7397              	.L328:
 7398              	.LBE195:
 7399              	.LBE251:
 7400              	.LBB252:
 7401              	.LBB187:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7402              		.loc 1 1033 0
 7403 3ef0 FC291FE5 		ldr	r2, .L748+132
 7404 3ef4 C714D2E5 		ldrb	r1, [r2, #1223]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7405              		.loc 1 1034 0
 7406 3ef8 C824D2E5 		ldrb	r2, [r2, #1224]	@ zero_extendqisi2
 7407 3efc 0BFBFFEA 		b	.L685
 7408              	.LVL825:
 7409              	.L411:
 7410              	.LBE187:
 7411              	.LBE252:
 7412              	.LBB253:
 7413              	.LBB162:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7414              		.loc 1 1033 0
 7415 3f00 0CCA1FE5 		ldr	ip, .L748+132
 7416 3f04 6F15DCE5 		ldrb	r1, [ip, #1391]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7417              		.loc 1 1034 0
 7418 3f08 7025DCE5 		ldrb	r2, [ip, #1392]	@ zero_extendqisi2
 7419 3f0c 07FBFFEA 		b	.L685
 7420              	.LVL826:
 7421              	.L387:
 7422              	.LBE162:
 7423              	.LBE253:
 7424              	.LBB254:
 7425              	.LBB231:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7426              		.loc 1 1033 0
 7427 3f10 1CCA1FE5 		ldr	ip, .L748+132
 7428 3f14 3F15DCE5 		ldrb	r1, [ip, #1343]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7429              		.loc 1 1034 0
 7430 3f18 4025DCE5 		ldrb	r2, [ip, #1344]	@ zero_extendqisi2
 7431 3f1c 45FCFFEA 		b	.L683
 7432              	.LVL827:
 7433              	.L422:
 7434              	.LBE231:
 7435              	.LBE254:
 7436              	.LBB255:
 7437              	.LBB220:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7438              		.loc 1 1033 0
 7439 3f20 8705DAE5 		ldrb	r0, [r10, #1415]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7440              		.loc 1 1034 0
 7441 3f24 8815DAE5 		ldrb	r1, [r10, #1416]	@ zero_extendqisi2
 7442 3f28 13FCFFEA 		b	.L687
 7443              	.LVL828:
 7444              	.L361:
 7445              	.LBE220:
 7446              	.LBE255:
 7447              	.LBB256:
 7448              	.LBB204:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7449              		.loc 1 1000 0
 7450 3f2c 383A1FE5 		ldr	r3, .L748+132
 7451 3f30 1525D3E5 		ldrb	r2, [r3, #1301]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7452              		.loc 1 1001 0
 7453 3f34 1615D3E5 		ldrb	r1, [r3, #1302]	@ zero_extendqisi2
 7454              	.LVL829:
 7455              	.L704:
 7456              	.LBE204:
 7457              	.LBE256:
 7458              	.LBB257:
 7459              	.LBB163:
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7460              		.loc 1 1002 0
 7461 3f38 0030A0E3 		mov	r3, #0
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7462              		.loc 1 1001 0
 7463 3f3c 9D10CBE5 		strb	r1, [fp, #157]
1008:../uvc.c      **** 
 7464              		.loc 1 1008 0
 7465 3f40 0800A0E1 		mov	r0, r8
 7466 3f44 541A1FE5 		ldr	r1, .L748+128
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7467              		.loc 1 1000 0
 7468 3f48 9C20CBE5 		strb	r2, [fp, #156]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7469              		.loc 1 1002 0
 7470 3f4c 9E30CBE5 		strb	r3, [fp, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7471              		.loc 1 1003 0
 7472 3f50 9F30CBE5 		strb	r3, [fp, #159]
 7473              	.LVL830:
1008:../uvc.c      **** 
 7474              		.loc 1 1008 0
 7475 3f54 2C208DE5 		str	r2, [sp, #44]
 7476 3f58 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7477              	.LVL831:
 7478 3f5c 2C209DE5 		ldr	r2, [sp, #44]
 7479 3f60 CCFCFFEA 		b	.L414
 7480              	.LVL832:
 7481              	.L418:
 7482              	.LBE163:
 7483              	.LBE257:
 7484              	.LBB258:
 7485              	.LBB221:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7486              		.loc 1 1000 0
 7487 3f64 70EA1FE5 		ldr	lr, .L748+132
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7488              		.loc 1 1002 0
 7489 3f68 0020A0E3 		mov	r2, #0
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7490              		.loc 1 1001 0
 7491 3f6c 8E15DEE5 		ldrb	r1, [lr, #1422]	@ zero_extendqisi2
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7492              		.loc 1 1000 0
 7493 3f70 8D35DEE5 		ldrb	r3, [lr, #1421]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7494              		.loc 1 1001 0
 7495 3f74 9D10CBE5 		strb	r1, [fp, #157]
1008:../uvc.c      **** 
 7496              		.loc 1 1008 0
 7497 3f78 30009DE5 		ldr	r0, [sp, #48]
 7498 3f7c 8C1A1FE5 		ldr	r1, .L748+128
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7499              		.loc 1 980 0
 7500 3f80 FF80A0E3 		mov	r8, #255
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7501              		.loc 1 1000 0
 7502 3f84 9C30CBE5 		strb	r3, [fp, #156]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7503              		.loc 1 1002 0
 7504 3f88 9E20CBE5 		strb	r2, [fp, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7505              		.loc 1 1003 0
 7506 3f8c 9F20CBE5 		strb	r2, [fp, #159]
 7507              	.LVL833:
1008:../uvc.c      **** 
 7508              		.loc 1 1008 0
 7509 3f90 28308DE5 		str	r3, [sp, #40]
 7510 3f94 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7511              	.LVL834:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7512              		.loc 1 980 0
 7513 3f98 08C0A0E1 		mov	ip, r8
 7514 3f9c 28309DE5 		ldr	r3, [sp, #40]
 7515 3fa0 30209DE5 		ldr	r2, [sp, #48]
 7516 3fa4 01FCFFEA 		b	.L425
 7517              	.LVL835:
 7518              	.L354:
 7519              	.LBE221:
 7520              	.LBE258:
 7521              	.LBB259:
 7522              	.LBB151:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7523              		.loc 1 1033 0
 7524 3fa8 F714DAE5 		ldrb	r1, [r10, #1271]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7525              		.loc 1 1034 0
 7526 3fac F824DAE5 		ldrb	r2, [r10, #1272]	@ zero_extendqisi2
 7527 3fb0 DEFAFFEA 		b	.L685
 7528              	.LVL836:
 7529              	.L317:
 7530              	.LBE151:
 7531              	.LBE259:
 7532              	.LBB260:
 7533              	.LBB179:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7534              		.loc 1 1033 0
 7535 3fb4 C02A1FE5 		ldr	r2, .L748+132
 7536 3fb8 9714D2E5 		ldrb	r1, [r2, #1175]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7537              		.loc 1 1034 0
 7538 3fbc 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 7539 3fc0 DAFAFFEA 		b	.L685
 7540              	.LVL837:
 7541              	.L383:
 7542              	.LBE179:
 7543              	.LBE260:
 7544              	.LBB261:
 7545              	.LBB232:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7546              		.loc 1 1000 0
 7547 3fc4 D01A1FE5 		ldr	r1, .L748+132
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7548              		.loc 1 1002 0
 7549 3fc8 0030A0E3 		mov	r3, #0
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7550              		.loc 1 1000 0
 7551 3fcc 45C5D1E5 		ldrb	ip, [r1, #1349]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7552              		.loc 1 1001 0
 7553 3fd0 4625D1E5 		ldrb	r2, [r1, #1350]	@ zero_extendqisi2
1008:../uvc.c      **** 
 7554              		.loc 1 1008 0
 7555 3fd4 0800A0E1 		mov	r0, r8
 7556 3fd8 E81A1FE5 		ldr	r1, .L748+128
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7557              		.loc 1 1000 0
 7558 3fdc 9CC0CBE5 		strb	ip, [fp, #156]
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7559              		.loc 1 1001 0
 7560 3fe0 9D20CBE5 		strb	r2, [fp, #157]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7561              		.loc 1 1002 0
 7562 3fe4 9E30CBE5 		strb	r3, [fp, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7563              		.loc 1 1003 0
 7564 3fe8 9F30CBE5 		strb	r3, [fp, #159]
 7565              	.LVL838:
1008:../uvc.c      **** 
 7566              		.loc 1 1008 0
 7567 3fec 24C08DE5 		str	ip, [sp, #36]
 7568 3ff0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7569              	.LVL839:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7570              		.loc 1 980 0
 7571 3ff4 FF20A0E3 		mov	r2, #255
 7572 3ff8 0230A0E1 		mov	r3, r2
 7573 3ffc 24C09DE5 		ldr	ip, [sp, #36]
 7574 4000 17FCFFEA 		b	.L390
 7575              	.LVL840:
 7576              	.L372:
 7577              	.LBE232:
 7578              	.LBE261:
 7579              	.LBB262:
 7580              	.LBB196:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7581              		.loc 1 1000 0
 7582 4004 10EB1FE5 		ldr	lr, .L748+132
 7583 4008 2D25DEE5 		ldrb	r2, [lr, #1325]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7584              		.loc 1 1001 0
 7585 400c 2E15DEE5 		ldrb	r1, [lr, #1326]	@ zero_extendqisi2
 7586 4010 C8FFFFEA 		b	.L704
 7587              	.LVL841:
 7588              	.L313:
 7589              	.LBE196:
 7590              	.LBE262:
 7591              	.LBB263:
 7592              	.LBB180:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7593              		.loc 1 1000 0
 7594 4014 203B1FE5 		ldr	r3, .L748+132
 7595 4018 9D24D3E5 		ldrb	r2, [r3, #1181]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7596              		.loc 1 1001 0
 7597 401c 9E14D3E5 		ldrb	r1, [r3, #1182]	@ zero_extendqisi2
 7598 4020 C4FFFFEA 		b	.L704
 7599              	.LVL842:
 7600              	.L339:
 7601              	.LBE180:
 7602              	.LBE263:
 7603              	.LBB264:
 7604              	.LBB212:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7605              		.loc 1 1033 0
 7606 4024 30CB1FE5 		ldr	ip, .L748+132
 7607 4028 DF14DCE5 		ldrb	r1, [ip, #1247]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7608              		.loc 1 1034 0
 7609 402c E024DCE5 		ldrb	r2, [ip, #1248]	@ zero_extendqisi2
 7610 4030 ACFBFFEA 		b	.L679
 7611              	.L335:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7612              		.loc 1 1000 0
 7613 4034 40EB1FE5 		ldr	lr, .L748+132
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7614              		.loc 1 1002 0
 7615 4038 0030A0E3 		mov	r3, #0
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7616              		.loc 1 1000 0
 7617 403c E5C4DEE5 		ldrb	ip, [lr, #1253]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7618              		.loc 1 1001 0
 7619 4040 E624DEE5 		ldrb	r2, [lr, #1254]	@ zero_extendqisi2
1008:../uvc.c      **** 
 7620              		.loc 1 1008 0
 7621 4044 0700A0E1 		mov	r0, r7
 7622 4048 581B1FE5 		ldr	r1, .L748+128
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7623              		.loc 1 1000 0
 7624 404c 9CC0CBE5 		strb	ip, [fp, #156]
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7625              		.loc 1 1001 0
 7626 4050 9D20CBE5 		strb	r2, [fp, #157]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7627              		.loc 1 1002 0
 7628 4054 9E30CBE5 		strb	r3, [fp, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7629              		.loc 1 1003 0
 7630 4058 9F30CBE5 		strb	r3, [fp, #159]
 7631              	.LVL843:
1008:../uvc.c      **** 
 7632              		.loc 1 1008 0
 7633 405c 24C08DE5 		str	ip, [sp, #36]
 7634 4060 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7635              	.LVL844:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7636              		.loc 1 980 0
 7637 4064 FF20A0E3 		mov	r2, #255
 7638 4068 0230A0E1 		mov	r3, r2
 7639 406c 24C09DE5 		ldr	ip, [sp, #36]
 7640 4070 A7FBFFEA 		b	.L342
 7641              	.LVL845:
 7642              	.L396:
 7643              	.LBE212:
 7644              	.LBE264:
 7645              	.LBB265:
 7646              	.LBB171:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7647              		.loc 1 1000 0
 7648 4074 5D25DAE5 		ldrb	r2, [r10, #1373]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7649              		.loc 1 1001 0
 7650 4078 5E15DAE5 		ldrb	r1, [r10, #1374]	@ zero_extendqisi2
 7651 407c ADFFFFEA 		b	.L704
 7652              	.LVL846:
 7653              	.L350:
 7654              	.LBE171:
 7655              	.LBE265:
 7656              	.LBB266:
 7657              	.LBB152:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7658              		.loc 1 1000 0
 7659 4080 8CEB1FE5 		ldr	lr, .L748+132
 7660 4084 FD24DEE5 		ldrb	r2, [lr, #1277]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7661              		.loc 1 1001 0
 7662 4088 FE14DEE5 		ldrb	r1, [lr, #1278]	@ zero_extendqisi2
 7663 408c A9FFFFEA 		b	.L704
 7664              	.LVL847:
 7665              	.L324:
 7666              	.LBE152:
 7667              	.LBE266:
 7668              	.LBB267:
 7669              	.LBB188:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7670              		.loc 1 1000 0
 7671 4090 9C3B1FE5 		ldr	r3, .L748+132
 7672 4094 CD24D3E5 		ldrb	r2, [r3, #1229]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7673              		.loc 1 1001 0
 7674 4098 CE14D3E5 		ldrb	r1, [r3, #1230]	@ zero_extendqisi2
 7675 409c A5FFFFEA 		b	.L704
 7676              	.LVL848:
 7677              	.L407:
 7678              	.LBE188:
 7679              	.LBE267:
 7680              	.LBB268:
 7681              	.LBB164:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7682              		.loc 1 1000 0
 7683 40a0 AC1B1FE5 		ldr	r1, .L748+132
 7684 40a4 7525D1E5 		ldrb	r2, [r1, #1397]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7685              		.loc 1 1001 0
 7686 40a8 7615D1E5 		ldrb	r1, [r1, #1398]	@ zero_extendqisi2
 7687 40ac A1FFFFEA 		b	.L704
 7688              	.LVL849:
 7689              	.L400:
 7690              	.LBE164:
 7691              	.LBE268:
 7692              	.LBB269:
 7693              	.LBB172:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7694              		.loc 1 1033 0
 7695 40b0 5715DAE5 		ldrb	r1, [r10, #1367]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7696              		.loc 1 1034 0
 7697 40b4 5825DAE5 		ldrb	r2, [r10, #1368]	@ zero_extendqisi2
 7698 40b8 9CFAFFEA 		b	.L685
 7699              	.LVL850:
 7700              	.L539:
 7701              	.LBE172:
 7702              	.LBE269:
 7703              	.LBE313:
 7704              	.LBE458:
 7705              	.LBB459:
 7706              	.LBB143:
3035:../uvc.c      ****                          		CyU3PThreadSleep(500);
 7707              		.loc 1 3035 0
 7708 40bc 3010A0E3 		mov	r1, #48
 7709 40c0 0020A0E3 		mov	r2, #0
 7710 40c4 5230A0E3 		mov	r3, #82
 7711 40c8 0B00A0E3 		mov	r0, #11
 7712              	.LVL851:
 7713 40cc FEFFFFEB 		bl	SensorSetIrisControl
 7714              	.LVL852:
3036:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
 7715              		.loc 1 3036 0
 7716 40d0 7D0FA0E3 		mov	r0, #500
 7717 40d4 FEFFFFEB 		bl	_tx_thread_sleep
 7718              	.LVL853:
3037:../uvc.c      ****                          		break;
 7719              		.loc 1 3037 0
 7720 40d8 F41B1FE5 		ldr	r1, .L748+116
 7721 40dc 0020A0E3 		mov	r2, #0
 7722 40e0 0B30A0E3 		mov	r3, #11
 7723 40e4 0400A0E3 		mov	r0, #4
 7724 40e8 FEFFFFEB 		bl	CyU3PDebugPrint
 7725              	.LVL854:
 7726 40ec 16FCFFEA 		b	.L537
 7727              	.LVL855:
 7728              	.L459:
 7729              	.LBE143:
 7730              	.LBE459:
 7731              	.LBB460:
 7732              	.LBB428:
 7733              	.LBB397:
 7734              	.LBB354:
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7735              		.loc 1 594 0
 7736 40f0 FCEB1FE5 		ldr	lr, .L748+132
 7737 40f4 4B23DEE5 		ldrb	r2, [lr, #843]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 7738              		.loc 1 595 0
 7739 40f8 4C33DEE5 		ldrb	r3, [lr, #844]	@ zero_extendqisi2
 7740 40fc B6FCFFEA 		b	.L691
 7741              	.LVL856:
 7742              	.L472:
 7743              	.LBE354:
 7744              	.LBE397:
 7745              	.LBB398:
 7746              	.LBB382:
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7747              		.loc 1 594 0
 7748 4100 0CEC1FE5 		ldr	lr, .L748+132
 7749 4104 5324DEE5 		ldrb	r2, [lr, #1107]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 7750              		.loc 1 595 0
 7751 4108 5434DEE5 		ldrb	r3, [lr, #1108]	@ zero_extendqisi2
 7752 410c B2FCFFEA 		b	.L691
 7753              	.LVL857:
 7754              	.L504:
 7755              	.LBE382:
 7756              	.LBE398:
 7757              	.LBB399:
 7758              	.LBB370:
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 7759              		.loc 1 583 0
 7760 4110 7BE0DAE5 		ldrb	lr, [r10, #123]	@ zero_extendqisi2
 584:../uvc.c      **** 		 	 }
 7761              		.loc 1 584 0
 7762 4114 7C20DAE5 		ldrb	r2, [r10, #124]	@ zero_extendqisi2
 7763 4118 91FCFFEA 		b	.L697
 7764              	.LVL858:
 7765              	.L485:
 7766              	.LBE370:
 7767              	.LBE399:
 7768              	.LBB400:
 7769              	.LBB363:
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7770              		.loc 1 594 0
 7771 411c 6B24DAE5 		ldrb	r2, [r10, #1131]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 7772              		.loc 1 595 0
 7773 4120 6C34DAE5 		ldrb	r3, [r10, #1132]	@ zero_extendqisi2
 7774 4124 43FCFFEA 		b	.L693
 7775              	.L489:
 639:../uvc.c      **** 		 	 }
 7776              		.loc 1 639 0
 7777 4128 7134DAE5 		ldrb	r3, [r10, #1137]	@ zero_extendqisi2
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7778              		.loc 1 641 0
 7779 412c 0100A0E3 		mov	r0, #1
 7780 4130 401C1FE5 		ldr	r1, .L748+128
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7781              		.loc 1 414 0
 7782 4134 FF80A0E3 		mov	r8, #255
 639:../uvc.c      **** 		 	 }
 7783              		.loc 1 639 0
 7784 4138 9C30CBE5 		strb	r3, [fp, #156]
 7785 413c 42FCFFEA 		b	.L694
 7786              	.LVL859:
 7787              	.L476:
 7788              	.LBE363:
 7789              	.LBE400:
 7790              	.LBB401:
 7791              	.LBB383:
 7792 4140 4C7C1FE5 		ldr	r7, .L748+132
 7793 4144 5934D7E5 		ldrb	r3, [r7, #1113]	@ zero_extendqisi2
 7794              	.LVL860:
 7795              	.L709:
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7796              		.loc 1 641 0
 7797 4148 0100A0E3 		mov	r0, #1
 7798 414c 5C1C1FE5 		ldr	r1, .L748+128
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7799              		.loc 1 414 0
 7800 4150 FF70A0E3 		mov	r7, #255
 639:../uvc.c      **** 		 	 }
 7801              		.loc 1 639 0
 7802 4154 9C30CBE5 		strb	r3, [fp, #156]
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7803              		.loc 1 641 0
 7804 4158 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7805              	.LVL861:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7806              		.loc 1 414 0
 7807 415c 07C0A0E1 		mov	ip, r7
 642:../uvc.c      **** 			  Len = 1;
 7808              		.loc 1 642 0
 7809 4160 9C30DBE5 		ldrb	r3, [fp, #156]	@ zero_extendqisi2
 7810              	.LVL862:
 7811 4164 36FFFFEA 		b	.L465
 7812              	.LVL863:
 7813              	.L508:
 7814              	.LBE383:
 7815              	.LBE401:
 7816              	.LBB402:
 7817              	.LBB371:
 636:../uvc.c      **** 		 	 }
 7818              		.loc 1 636 0
 7819 4168 8120DAE5 		ldrb	r2, [r10, #129]	@ zero_extendqisi2
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7820              		.loc 1 641 0
 7821 416c 0100A0E3 		mov	r0, #1
 7822 4170 801C1FE5 		ldr	r1, .L748+128
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7823              		.loc 1 414 0
 7824 4174 FF80A0E3 		mov	r8, #255
 636:../uvc.c      **** 		 	 }
 7825              		.loc 1 636 0
 7826 4178 9C20CBE5 		strb	r2, [fp, #156]
 7827 417c 7DFCFFEA 		b	.L698
 7828              	.LVL864:
 7829              	.L463:
 7830              	.LBE371:
 7831              	.LBE402:
 7832              	.LBB403:
 7833              	.LBB355:
 639:../uvc.c      **** 		 	 }
 7834              		.loc 1 639 0
 7835 4180 8C7C1FE5 		ldr	r7, .L748+132
 7836 4184 5133D7E5 		ldrb	r3, [r7, #849]	@ zero_extendqisi2
 7837 4188 EEFFFFEA 		b	.L709
 7838              	.LVL865:
 7839              	.L281:
 7840              	.LBE355:
 7841              	.LBE403:
 7842              	.LBE428:
 7843              	.LBE460:
 7844              	.LBB461:
 7845              	.LBB343:
 7846              	.LBB333:
 7847              	.LBB327:
 957:../uvc.c      **** 			  break;
 7848              		.loc 1 957 0
 7849 418c 0000A0E3 		mov	r0, #0
 7850 4190 0020A0E1 		mov	r2, r0
 7851 4194 0110A0E3 		mov	r1, #1
 7852 4198 FEFFFFEB 		bl	CyU3PUsbStall
 7853              	.LVL866:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7854              		.loc 1 414 0
 7855 419c FF20A0E3 		mov	r2, #255
 7856 41a0 0280A0E1 		mov	r8, r2
 7857              	.LVL867:
 7858 41a4 0230A0E1 		mov	r3, r2
 7859 41a8 22FAFFEA 		b	.L291
 7860              	.LVL868:
 7861              	.L358:
 7862              	.LBE327:
 7863              	.LBE333:
 7864              	.LBE343:
 7865              	.LBE461:
 7866              	.LBB462:
 7867              	.LBB314:
 7868              	.LBB270:
 7869              	.LBB205:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7870              		.loc 1 1193 0
 7871 41ac 0000A0E3 		mov	r0, #0
 7872 41b0 0020A0E1 		mov	r2, r0
 7873 41b4 0110A0E3 		mov	r1, #1
 7874 41b8 24C08DE5 		str	ip, [sp, #36]
 7875 41bc FEFFFFEB 		bl	CyU3PUsbStall
 7876              	.LVL869:
1194:../uvc.c      **** 			  break;
 7877              		.loc 1 1194 0
 7878 41c0 24C09DE5 		ldr	ip, [sp, #36]
 7879 41c4 0520A0E3 		mov	r2, #5
 7880 41c8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7881 41cc 0400A0E3 		mov	r0, #4
 7882 41d0 E81C1FE5 		ldr	r1, .L748+120
 7883 41d4 FEFFFFEB 		bl	CyU3PDebugPrint
 7884              	.LVL870:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7885              		.loc 1 980 0
 7886 41d8 FF20A0E3 		mov	r2, #255
 7887              	.LVL871:
 7888 41dc 2DFCFFEA 		b	.L414
 7889              	.LVL872:
 7890              	.L380:
 7891              	.LBE205:
 7892              	.LBE270:
 7893              	.LBB271:
 7894              	.LBB233:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7895              		.loc 1 1193 0
 7896 41e0 0000A0E3 		mov	r0, #0
 7897 41e4 0020A0E1 		mov	r2, r0
 7898 41e8 0110A0E3 		mov	r1, #1
 7899 41ec 24C08DE5 		str	ip, [sp, #36]
 7900 41f0 FEFFFFEB 		bl	CyU3PUsbStall
 7901              	.LVL873:
1194:../uvc.c      **** 			  break;
 7902              		.loc 1 1194 0
 7903 41f4 24C09DE5 		ldr	ip, [sp, #36]
 7904 41f8 0720A0E3 		mov	r2, #7
 7905 41fc 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7906 4200 0400A0E3 		mov	r0, #4
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7907              		.loc 1 980 0
 7908 4204 FFC0A0E3 		mov	ip, #255
1194:../uvc.c      **** 			  break;
 7909              		.loc 1 1194 0
 7910 4208 201D1FE5 		ldr	r1, .L748+120
 7911 420c 24C08DE5 		str	ip, [sp, #36]
 7912 4210 FEFFFFEB 		bl	CyU3PDebugPrint
 7913              	.LVL874:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7914              		.loc 1 980 0
 7915 4214 24C09DE5 		ldr	ip, [sp, #36]
 7916 4218 0C20A0E1 		mov	r2, ip
 7917 421c 0C30A0E1 		mov	r3, ip
 7918 4220 8FFBFFEA 		b	.L390
 7919              	.LVL875:
 7920              	.L332:
 7921              	.LBE233:
 7922              	.LBE271:
 7923              	.LBB272:
 7924              	.LBB213:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7925              		.loc 1 1193 0
 7926 4224 0000A0E3 		mov	r0, #0
 7927 4228 0020A0E1 		mov	r2, r0
 7928 422c 0110A0E3 		mov	r1, #1
 7929 4230 24C08DE5 		str	ip, [sp, #36]
 7930 4234 FEFFFFEB 		bl	CyU3PUsbStall
 7931              	.LVL876:
1194:../uvc.c      **** 			  break;
 7932              		.loc 1 1194 0
 7933 4238 24C09DE5 		ldr	ip, [sp, #36]
 7934 423c 0320A0E3 		mov	r2, #3
 7935 4240 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7936 4244 0400A0E3 		mov	r0, #4
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7937              		.loc 1 980 0
 7938 4248 FFC0A0E3 		mov	ip, #255
1194:../uvc.c      **** 			  break;
 7939              		.loc 1 1194 0
 7940 424c 641D1FE5 		ldr	r1, .L748+120
 7941 4250 24C08DE5 		str	ip, [sp, #36]
 7942 4254 FEFFFFEB 		bl	CyU3PDebugPrint
 7943              	.LVL877:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7944              		.loc 1 980 0
 7945 4258 24C09DE5 		ldr	ip, [sp, #36]
 7946 425c 0C20A0E1 		mov	r2, ip
 7947 4260 0C30A0E1 		mov	r3, ip
 7948 4264 2AFBFFEA 		b	.L342
 7949              	.LVL878:
 7950              	.L415:
 7951              	.LBE213:
 7952              	.LBE272:
 7953              	.LBB273:
 7954              	.LBB222:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7955              		.loc 1 1193 0
 7956 4268 0000A0E3 		mov	r0, #0
 7957 426c 0020A0E1 		mov	r2, r0
 7958 4270 0110A0E3 		mov	r1, #1
 7959 4274 24C08DE5 		str	ip, [sp, #36]
 7960 4278 FEFFFFEB 		bl	CyU3PUsbStall
 7961              	.LVL879:
1194:../uvc.c      **** 			  break;
 7962              		.loc 1 1194 0
 7963 427c 24C09DE5 		ldr	ip, [sp, #36]
 7964 4280 0A20A0E3 		mov	r2, #10
 7965 4284 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7966 4288 0400A0E3 		mov	r0, #4
 7967 428c A41D1FE5 		ldr	r1, .L748+120
 7968 4290 FEFFFFEB 		bl	CyU3PDebugPrint
 7969              	.LVL880:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7970              		.loc 1 980 0
 7971 4294 FF30A0E3 		mov	r3, #255
 7972 4298 0380A0E1 		mov	r8, r3
 7973 429c 03C0A0E1 		mov	ip, r3
 7974 42a0 30209DE5 		ldr	r2, [sp, #48]
 7975 42a4 41FBFFEA 		b	.L425
 7976              	.LVL881:
 7977              	.L347:
 7978              	.LBE222:
 7979              	.LBE273:
 7980              	.LBB274:
 7981              	.LBB153:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7982              		.loc 1 1193 0
 7983 42a8 0000A0E3 		mov	r0, #0
 7984 42ac 0020A0E1 		mov	r2, r0
 7985 42b0 0110A0E3 		mov	r1, #1
 7986 42b4 24C08DE5 		str	ip, [sp, #36]
 7987 42b8 FEFFFFEB 		bl	CyU3PUsbStall
 7988              	.LVL882:
1194:../uvc.c      **** 			  break;
 7989              		.loc 1 1194 0
 7990 42bc 24C09DE5 		ldr	ip, [sp, #36]
 7991 42c0 0400A0E3 		mov	r0, #4
 7992 42c4 0020A0E1 		mov	r2, r0
 7993 42c8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7994 42cc E41D1FE5 		ldr	r1, .L748+120
 7995 42d0 FEFFFFEB 		bl	CyU3PDebugPrint
 7996              	.LVL883:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7997              		.loc 1 980 0
 7998 42d4 FF20A0E3 		mov	r2, #255
 7999              	.LVL884:
 8000 42d8 EEFBFFEA 		b	.L414
 8001              	.LVL885:
 8002              	.L321:
 8003              	.LBE153:
 8004              	.LBE274:
 8005              	.LBB275:
 8006              	.LBB189:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8007              		.loc 1 1193 0
 8008 42dc 0000A0E3 		mov	r0, #0
 8009 42e0 0020A0E1 		mov	r2, r0
 8010 42e4 0110A0E3 		mov	r1, #1
 8011 42e8 24C08DE5 		str	ip, [sp, #36]
 8012 42ec FEFFFFEB 		bl	CyU3PUsbStall
 8013              	.LVL886:
1194:../uvc.c      **** 			  break;
 8014              		.loc 1 1194 0
 8015 42f0 24C09DE5 		ldr	ip, [sp, #36]
 8016 42f4 0220A0E3 		mov	r2, #2
 8017 42f8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8018 42fc 0400A0E3 		mov	r0, #4
 8019 4300 181E1FE5 		ldr	r1, .L748+120
 8020 4304 FEFFFFEB 		bl	CyU3PDebugPrint
 8021              	.LVL887:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8022              		.loc 1 980 0
 8023 4308 FF20A0E3 		mov	r2, #255
 8024              	.LVL888:
 8025 430c E1FBFFEA 		b	.L414
 8026              	.LVL889:
 8027              	.L455:
 8028              	.LBE189:
 8029              	.LBE275:
 8030              	.LBE314:
 8031              	.LBE462:
 8032              	.LBB463:
 8033              	.LBB429:
 8034              	.LBB404:
 8035              	.LBB356:
 957:../uvc.c      **** 			  break;
 8036              		.loc 1 957 0
 8037 4310 0000A0E3 		mov	r0, #0
 8038 4314 0020A0E1 		mov	r2, r0
 8039 4318 0110A0E3 		mov	r1, #1
 8040 431c FEFFFFEB 		bl	CyU3PUsbStall
 8041              	.LVL890:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8042              		.loc 1 414 0
 8043 4320 FF30A0E3 		mov	r3, #255
 8044 4324 0370A0E1 		mov	r7, r3
 8045 4328 03C0A0E1 		mov	ip, r3
 8046 432c C4FEFFEA 		b	.L465
 8047              	.LVL891:
 8048              	.L289:
 8049              	.LBE356:
 8050              	.LBE404:
 8051              	.LBE429:
 8052              	.LBE463:
 8053              	.LBB464:
 8054              	.LBB344:
 8055              	.LBB334:
 8056              	.LBB328:
 639:../uvc.c      **** 		 	 }
 8057              		.loc 1 639 0
 8058 4330 E931DAE5 		ldrb	r3, [r10, #489]	@ zero_extendqisi2
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8059              		.loc 1 641 0
 8060 4334 0100A0E3 		mov	r0, #1
 8061 4338 481E1FE5 		ldr	r1, .L748+128
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8062              		.loc 1 414 0
 8063 433c FF80A0E3 		mov	r8, #255
 639:../uvc.c      **** 		 	 }
 8064              		.loc 1 639 0
 8065 4340 9C30CBE5 		strb	r3, [fp, #156]
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8066              		.loc 1 641 0
 8067 4344 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8068              	.LVL892:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8069              		.loc 1 414 0
 8070 4348 0830A0E1 		mov	r3, r8
 642:../uvc.c      **** 			  Len = 1;
 8071              		.loc 1 642 0
 8072 434c 9C20DBE5 		ldrb	r2, [fp, #156]	@ zero_extendqisi2
 8073              	.LVL893:
 8074 4350 B8F9FFEA 		b	.L291
 8075              	.LVL894:
 8076              	.L285:
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 8077              		.loc 1 594 0
 8078 4354 E321DAE5 		ldrb	r2, [r10, #483]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 8079              		.loc 1 595 0
 8080 4358 E431DAE5 		ldrb	r3, [r10, #484]	@ zero_extendqisi2
 8081 435c ADF9FFEA 		b	.L676
 8082              	.L287:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8083              		.loc 1 431 0
 8084 4360 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8085              		.loc 1 432 0
 8086 4364 0200A0E3 		mov	r0, #2
 8087 4368 781E1FE5 		ldr	r1, .L748+128
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8088              		.loc 1 430 0
 8089 436c 9C80CBE5 		strb	r8, [fp, #156]
 8090 4370 ABF9FFEA 		b	.L675
 8091              	.L282:
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8092              		.loc 1 612 0
 8093 4374 801E1FE5 		ldr	r1, .L748+132
 8094 4378 E521D1E5 		ldrb	r2, [r1, #485]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 8095              		.loc 1 613 0
 8096 437c E631D1E5 		ldrb	r3, [r1, #486]	@ zero_extendqisi2
 8097 4380 A4F9FFEA 		b	.L676
 8098              	.LVL895:
 8099              	.L421:
 8100              	.LBE328:
 8101              	.LBE334:
 8102              	.LBE344:
 8103              	.LBE464:
 8104              	.LBB465:
 8105              	.LBB315:
 8106              	.LBB276:
 8107              	.LBB223:
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8108              		.loc 1 990 0
 8109 4384 30C09DE5 		ldr	ip, [sp, #48]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8110              		.loc 1 991 0
 8111 4388 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8112              		.loc 1 992 0
 8113 438c 0200A0E3 		mov	r0, #2
 8114 4390 A01E1FE5 		ldr	r1, .L748+128
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8115              		.loc 1 980 0
 8116 4394 FF80A0E3 		mov	r8, #255
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8117              		.loc 1 990 0
 8118 4398 9CC0CBE5 		strb	ip, [fp, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8119              		.loc 1 991 0
 8120 439c 9D30CBE5 		strb	r3, [fp, #157]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8121              		.loc 1 992 0
 8122 43a0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8123              	.LVL896:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8124              		.loc 1 980 0
 8125 43a4 08C0A0E1 		mov	ip, r8
 993:../uvc.c      **** 			  break;
 8126              		.loc 1 993 0
 8127 43a8 9C30DBE5 		ldrb	r3, [fp, #156]	@ zero_extendqisi2
 8128              	.LVL897:
 8129 43ac 30209DE5 		ldr	r2, [sp, #48]
 8130 43b0 FEFAFFEA 		b	.L425
 8131              	.LVL898:
 8132              	.L314:
 8133              	.LBE223:
 8134              	.LBE276:
 8135              	.LBB277:
 8136              	.LBB181:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8137              		.loc 1 1015 0
 8138 43b4 C0CE1FE5 		ldr	ip, .L748+132
 8139 43b8 9314DCE5 		ldrb	r1, [ip, #1171]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8140              		.loc 1 1016 0
 8141 43bc 9424DCE5 		ldrb	r2, [ip, #1172]	@ zero_extendqisi2
 8142 43c0 DAF9FFEA 		b	.L685
 8143              	.LVL899:
 8144              	.L397:
 8145              	.LBE181:
 8146              	.LBE277:
 8147              	.LBB278:
 8148              	.LBB173:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8149              		.loc 1 1015 0
 8150 43c4 5315DAE5 		ldrb	r1, [r10, #1363]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8151              		.loc 1 1016 0
 8152 43c8 5425DAE5 		ldrb	r2, [r10, #1364]	@ zero_extendqisi2
 8153 43cc D7F9FFEA 		b	.L685
 8154              	.LVL900:
 8155              	.L351:
 8156              	.LBE173:
 8157              	.LBE278:
 8158              	.LBB279:
 8159              	.LBB154:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8160              		.loc 1 1015 0
 8161 43d0 F314DAE5 		ldrb	r1, [r10, #1267]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8162              		.loc 1 1016 0
 8163 43d4 F424DAE5 		ldrb	r2, [r10, #1268]	@ zero_extendqisi2
 8164 43d8 D4F9FFEA 		b	.L685
 8165              	.LVL901:
 8166              	.L325:
 8167              	.LBE154:
 8168              	.LBE279:
 8169              	.LBB280:
 8170              	.LBB190:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8171              		.loc 1 1015 0
 8172 43dc E8CE1FE5 		ldr	ip, .L748+132
 8173 43e0 C314DCE5 		ldrb	r1, [ip, #1219]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8174              		.loc 1 1016 0
 8175 43e4 C424DCE5 		ldrb	r2, [ip, #1220]	@ zero_extendqisi2
 8176 43e8 D0F9FFEA 		b	.L685
 8177              	.L329:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8178              		.loc 1 1042 0
 8179 43ec F8CE1FE5 		ldr	ip, .L748+132
 8180 43f0 C934DCE5 		ldrb	r3, [ip, #1225]	@ zero_extendqisi2
 8181              	.LVL902:
 8182              	.L705:
 8183              	.LBE190:
 8184              	.LBE280:
 8185              	.LBB281:
 8186              	.LBB165:
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8187              		.loc 1 1043 0
 8188 43f4 0100A0E3 		mov	r0, #1
 8189 43f8 081F1FE5 		ldr	r1, .L748+128
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8190              		.loc 1 1042 0
 8191 43fc 9C30CBE5 		strb	r3, [fp, #156]
1045:../uvc.c      **** 			  break;
 8192              		.loc 1 1045 0
 8193 4400 0180A0E3 		mov	r8, #1
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8194              		.loc 1 1043 0
 8195 4404 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8196              	.LVL903:
1044:../uvc.c      **** 			  Len = 1;
 8197              		.loc 1 1044 0
 8198 4408 9C20DBE5 		ldrb	r2, [fp, #156]	@ zero_extendqisi2
 8199              	.LVL904:
 8200 440c A1FBFFEA 		b	.L414
 8201              	.LVL905:
 8202              	.L377:
 8203              	.LBE165:
 8204              	.LBE281:
 8205              	.LBB282:
 8206              	.LBB197:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8207              		.loc 1 1042 0
 8208 4410 2935DAE5 		ldrb	r3, [r10, #1321]	@ zero_extendqisi2
 8209 4414 F6FFFFEA 		b	.L705
 8210              	.LVL906:
 8211              	.L401:
 8212              	.LBE197:
 8213              	.LBE282:
 8214              	.LBB283:
 8215              	.LBB174:
 8216 4418 5935DAE5 		ldrb	r3, [r10, #1369]	@ zero_extendqisi2
 8217 441c F4FFFFEA 		b	.L705
 8218              	.LVL907:
 8219              	.L739:
 8220              	.LBE174:
 8221              	.LBE283:
 8222              	.LBE315:
 8223              	.LBE465:
 8224              	.LBB466:
 8225              	.LBB144:
3233:../uvc.c      ****                             }
 8226              		.loc 1 3233 0
 8227 4420 341F1FE5 		ldr	r1, .L748+124
 8228 4424 0400A0E3 		mov	r0, #4
 8229              	.LVL908:
 8230 4428 FEFFFFEB 		bl	CyU3PDebugPrint
 8231              	.LVL909:
 8232 442c 66FBFFEA 		b	.L562
 8233              	.LVL910:
 8234              	.L318:
 8235              	.LBE144:
 8236              	.LBE466:
 8237              	.LBB467:
 8238              	.LBB316:
 8239              	.LBB284:
 8240              	.LBB182:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8241              		.loc 1 1042 0
 8242 4430 9934DAE5 		ldrb	r3, [r10, #1177]	@ zero_extendqisi2
 8243 4434 EEFFFFEA 		b	.L705
 8244              	.LVL911:
 8245              	.L388:
 8246              	.LBE182:
 8247              	.LBE284:
 8248              	.LBB285:
 8249              	.LBB234:
 8250 4438 44EF1FE5 		ldr	lr, .L748+132
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8251              		.loc 1 1043 0
 8252 443c 0100A0E3 		mov	r0, #1
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8253              		.loc 1 1042 0
 8254 4440 4135DEE5 		ldrb	r3, [lr, #1345]	@ zero_extendqisi2
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8255              		.loc 1 1043 0
 8256 4444 541F1FE5 		ldr	r1, .L748+128
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8257              		.loc 1 1042 0
 8258 4448 9C30CBE5 		strb	r3, [fp, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8259              		.loc 1 1043 0
 8260 444c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8261              	.LVL912:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8262              		.loc 1 980 0
 8263 4450 FF20A0E3 		mov	r2, #255
 8264 4454 0230A0E1 		mov	r3, r2
1044:../uvc.c      **** 			  Len = 1;
 8265              		.loc 1 1044 0
 8266 4458 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
 8267              	.LVL913:
1045:../uvc.c      **** 			  break;
 8268              		.loc 1 1045 0
 8269 445c 0180A0E3 		mov	r8, #1
 8270 4460 FFFAFFEA 		b	.L390
 8271              	.LVL914:
 8272              	.L355:
 8273              	.LBE234:
 8274              	.LBE285:
 8275              	.LBB286:
 8276              	.LBB155:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8277              		.loc 1 1042 0
 8278 4464 F934DAE5 		ldrb	r3, [r10, #1273]	@ zero_extendqisi2
 8279 4468 E1FFFFEA 		b	.L705
 8280              	.LVL915:
 8281              	.L366:
 8282              	.LBE155:
 8283              	.LBE286:
 8284              	.LBB287:
 8285              	.LBB206:
 8286 446c 78CF1FE5 		ldr	ip, .L748+132
 8287 4470 1135DCE5 		ldrb	r3, [ip, #1297]	@ zero_extendqisi2
 8288 4474 DEFFFFEA 		b	.L705
 8289              	.LVL916:
 8290              	.L373:
 8291              	.LBE206:
 8292              	.LBE287:
 8293              	.LBB288:
 8294              	.LBB198:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8295              		.loc 1 1015 0
 8296 4478 842F1FE5 		ldr	r2, .L748+132
 8297 447c 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8298              		.loc 1 1016 0
 8299 4480 2425D2E5 		ldrb	r2, [r2, #1316]	@ zero_extendqisi2
 8300 4484 A9F9FFEA 		b	.L685
 8301              	.LVL917:
 8302              	.L336:
 8303              	.LBE198:
 8304              	.LBE288:
 8305              	.LBB289:
 8306              	.LBB214:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8307              		.loc 1 1015 0
 8308 4488 942F1FE5 		ldr	r2, .L748+132
 8309 448c DB14D2E5 		ldrb	r1, [r2, #1243]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8310              		.loc 1 1016 0
 8311 4490 DC24D2E5 		ldrb	r2, [r2, #1244]	@ zero_extendqisi2
 8312 4494 93FAFFEA 		b	.L679
 8313              	.L340:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8314              		.loc 1 1042 0
 8315 4498 E134DAE5 		ldrb	r3, [r10, #1249]	@ zero_extendqisi2
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8316              		.loc 1 1043 0
 8317 449c 0100A0E3 		mov	r0, #1
 8318 44a0 B01F1FE5 		ldr	r1, .L748+128
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8319              		.loc 1 1042 0
 8320 44a4 9C30CBE5 		strb	r3, [fp, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8321              		.loc 1 1043 0
 8322 44a8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8323              	.LVL918:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8324              		.loc 1 980 0
 8325 44ac FF20A0E3 		mov	r2, #255
 8326 44b0 0230A0E1 		mov	r3, r2
1044:../uvc.c      **** 			  Len = 1;
 8327              		.loc 1 1044 0
 8328 44b4 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
 8329              	.LVL919:
1045:../uvc.c      **** 			  break;
 8330              		.loc 1 1045 0
 8331 44b8 0170A0E3 		mov	r7, #1
 8332 44bc 94FAFFEA 		b	.L342
 8333              	.LVL920:
 8334              	.L423:
 8335              	.LBE214:
 8336              	.LBE289:
 8337              	.LBB290:
 8338              	.LBB224:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8339              		.loc 1 1042 0
 8340 44c0 8935DAE5 		ldrb	r3, [r10, #1417]	@ zero_extendqisi2
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8341              		.loc 1 1043 0
 8342 44c4 0100A0E3 		mov	r0, #1
 8343 44c8 D81F1FE5 		ldr	r1, .L748+128
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8344              		.loc 1 980 0
 8345 44cc FF80A0E3 		mov	r8, #255
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8346              		.loc 1 1042 0
 8347 44d0 9C30CBE5 		strb	r3, [fp, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8348              		.loc 1 1043 0
 8349 44d4 24808DE5 		str	r8, [sp, #36]
 8350 44d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8351              	.LVL921:
1045:../uvc.c      **** 			  break;
 8352              		.loc 1 1045 0
 8353 44dc 0120A0E3 		mov	r2, #1
 8354 44e0 30208DE5 		str	r2, [sp, #48]
 8355              	.LVL922:
1044:../uvc.c      **** 			  Len = 1;
 8356              		.loc 1 1044 0
 8357 44e4 9C30DBE5 		ldrb	r3, [fp, #156]	@ zero_extendqisi2
 8358              	.LVL923:
 8359 44e8 24C09DE5 		ldr	ip, [sp, #36]
 8360 44ec AFFAFFEA 		b	.L425
 8361              	.LVL924:
 8362              	.L408:
 8363              	.LBE224:
 8364              	.LBE290:
 8365              	.LBB291:
 8366              	.LBB166:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8367              		.loc 1 1015 0
 8368 44f0 FC2F1FE5 		ldr	r2, .L748+132
 8369 44f4 6B15D2E5 		ldrb	r1, [r2, #1387]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8370              		.loc 1 1016 0
 8371 44f8 6C25D2E5 		ldrb	r2, [r2, #1388]	@ zero_extendqisi2
 8372 44fc 8BF9FFEA 		b	.L685
 8373              	.L412:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8374              		.loc 1 1042 0
 8375 4500 7135DAE5 		ldrb	r3, [r10, #1393]	@ zero_extendqisi2
 8376 4504 BAFFFFEA 		b	.L705
 8377              	.LVL925:
 8378              	.L419:
 8379              	.LBE166:
 8380              	.LBE291:
 8381              	.LBB292:
 8382              	.LBB225:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8383              		.loc 1 1015 0
 8384 4508 8305DAE5 		ldrb	r0, [r10, #1411]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8385              		.loc 1 1016 0
 8386 450c 8415DAE5 		ldrb	r1, [r10, #1412]	@ zero_extendqisi2
 8387 4510 99FAFFEA 		b	.L687
 8388              	.LVL926:
 8389              	.L384:
 8390              	.LBE225:
 8391              	.LBE292:
 8392              	.LBB293:
 8393              	.LBB235:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8394              		.loc 1 1015 0
 8395 4514 38259FE5 		ldr	r2, .L750
 8396 4518 3B15D2E5 		ldrb	r1, [r2, #1339]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8397              		.loc 1 1016 0
 8398 451c 3C25D2E5 		ldrb	r2, [r2, #1340]	@ zero_extendqisi2
 8399 4520 C4FAFFEA 		b	.L683
 8400              	.LVL927:
 8401              	.L362:
 8402              	.LBE235:
 8403              	.LBE293:
 8404              	.LBB294:
 8405              	.LBB207:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8406              		.loc 1 1015 0
 8407 4524 28C59FE5 		ldr	ip, .L750
 8408 4528 0B15DCE5 		ldrb	r1, [ip, #1291]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8409              		.loc 1 1016 0
 8410 452c 0C25DCE5 		ldrb	r2, [ip, #1292]	@ zero_extendqisi2
 8411 4530 7EF9FFEA 		b	.L685
 8412              	.LVL928:
 8413              	.L333:
 8414              	.LBE207:
 8415              	.LBE294:
 8416              	.LBB295:
 8417              	.LBB215:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8418              		.loc 1 1024 0
 8419 4534 18359FE5 		ldr	r3, .L750
 8420 4538 DD14D3E5 		ldrb	r1, [r3, #1245]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8421              		.loc 1 1025 0
 8422 453c DE24D3E5 		ldrb	r2, [r3, #1246]	@ zero_extendqisi2
 8423 4540 68FAFFEA 		b	.L679
 8424              	.L338:
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8425              		.loc 1 991 0
 8426 4544 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8427              		.loc 1 992 0
 8428 4548 0200A0E3 		mov	r0, #2
 8429 454c 04159FE5 		ldr	r1, .L750+4
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8430              		.loc 1 991 0
 8431 4550 9D30CBE5 		strb	r3, [fp, #157]
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8432              		.loc 1 990 0
 8433 4554 9C70CBE5 		strb	r7, [fp, #156]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8434              		.loc 1 992 0
 8435 4558 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8436              	.LVL929:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8437              		.loc 1 980 0
 8438 455c FF20A0E3 		mov	r2, #255
 8439 4560 0230A0E1 		mov	r3, r2
 993:../uvc.c      **** 			  break;
 8440              		.loc 1 993 0
 8441 4564 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
 8442              	.LVL930:
 8443 4568 69FAFFEA 		b	.L342
 8444              	.LVL931:
 8445              	.L322:
 8446              	.LBE215:
 8447              	.LBE295:
 8448              	.LBB296:
 8449              	.LBB191:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8450              		.loc 1 1024 0
 8451 456c E0E49FE5 		ldr	lr, .L750
 8452 4570 C514DEE5 		ldrb	r1, [lr, #1221]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8453              		.loc 1 1025 0
 8454 4574 C624DEE5 		ldrb	r2, [lr, #1222]	@ zero_extendqisi2
 8455 4578 6CF9FFEA 		b	.L685
 8456              	.LVL932:
 8457              	.L394:
 8458              	.LBE191:
 8459              	.LBE296:
 8460              	.LBB297:
 8461              	.LBB175:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8462              		.loc 1 1024 0
 8463 457c D0E49FE5 		ldr	lr, .L750
 8464 4580 5515DEE5 		ldrb	r1, [lr, #1365]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8465              		.loc 1 1025 0
 8466 4584 5625DEE5 		ldrb	r2, [lr, #1366]	@ zero_extendqisi2
 8467 4588 68F9FFEA 		b	.L685
 8468              	.LVL933:
 8469              	.L405:
 8470              	.LBE175:
 8471              	.LBE297:
 8472              	.LBB298:
 8473              	.LBB167:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8474              		.loc 1 1024 0
 8475 458c C0349FE5 		ldr	r3, .L750
 8476 4590 6D15D3E5 		ldrb	r1, [r3, #1389]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8477              		.loc 1 1025 0
 8478 4594 6E25D3E5 		ldrb	r2, [r3, #1390]	@ zero_extendqisi2
 8479 4598 64F9FFEA 		b	.L685
 8480              	.LVL934:
 8481              	.L311:
 8482              	.LBE167:
 8483              	.LBE298:
 8484              	.LBB299:
 8485              	.LBB183:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8486              		.loc 1 1024 0
 8487 459c B0E49FE5 		ldr	lr, .L750
 8488 45a0 9514DEE5 		ldrb	r1, [lr, #1173]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8489              		.loc 1 1025 0
 8490 45a4 9624DEE5 		ldrb	r2, [lr, #1174]	@ zero_extendqisi2
 8491 45a8 60F9FFEA 		b	.L685
 8492              	.LVL935:
 8493              	.L348:
 8494              	.LBE183:
 8495              	.LBE299:
 8496              	.LBB300:
 8497              	.LBB156:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8498              		.loc 1 1024 0
 8499 45ac A0249FE5 		ldr	r2, .L750
 8500 45b0 F514D2E5 		ldrb	r1, [r2, #1269]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8501              		.loc 1 1025 0
 8502 45b4 F624D2E5 		ldrb	r2, [r2, #1270]	@ zero_extendqisi2
 8503 45b8 5CF9FFEA 		b	.L685
 8504              	.LVL936:
 8505              	.L381:
 8506              	.LBE156:
 8507              	.LBE300:
 8508              	.LBB301:
 8509              	.LBB236:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8510              		.loc 1 1024 0
 8511 45bc 90349FE5 		ldr	r3, .L750
 8512 45c0 3D15D3E5 		ldrb	r1, [r3, #1341]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8513              		.loc 1 1025 0
 8514 45c4 3E25D3E5 		ldrb	r2, [r3, #1342]	@ zero_extendqisi2
 8515 45c8 9AFAFFEA 		b	.L683
 8516              	.L386:
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8517              		.loc 1 991 0
 8518 45cc 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8519              		.loc 1 992 0
 8520 45d0 0200A0E3 		mov	r0, #2
 8521 45d4 7C149FE5 		ldr	r1, .L750+4
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8522              		.loc 1 991 0
 8523 45d8 9D30CBE5 		strb	r3, [fp, #157]
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8524              		.loc 1 990 0
 8525 45dc 9C80CBE5 		strb	r8, [fp, #156]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8526              		.loc 1 992 0
 8527 45e0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8528              	.LVL937:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8529              		.loc 1 980 0
 8530 45e4 FF20A0E3 		mov	r2, #255
 8531 45e8 0230A0E1 		mov	r3, r2
 993:../uvc.c      **** 			  break;
 8532              		.loc 1 993 0
 8533 45ec 9CC0DBE5 		ldrb	ip, [fp, #156]	@ zero_extendqisi2
 8534              	.LVL938:
 8535 45f0 9BFAFFEA 		b	.L390
 8536              	.LVL939:
 8537              	.L370:
 8538              	.LBE236:
 8539              	.LBE301:
 8540              	.LBB302:
 8541              	.LBB199:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8542              		.loc 1 1024 0
 8543 45f4 58349FE5 		ldr	r3, .L750
 8544 45f8 2515D3E5 		ldrb	r1, [r3, #1317]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8545              		.loc 1 1025 0
 8546 45fc 2625D3E5 		ldrb	r2, [r3, #1318]	@ zero_extendqisi2
 8547 4600 4AF9FFEA 		b	.L685
 8548              	.LVL940:
 8549              	.L359:
 8550              	.LBE199:
 8551              	.LBE302:
 8552              	.LBB303:
 8553              	.LBB208:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8554              		.loc 1 1024 0
 8555 4604 48E49FE5 		ldr	lr, .L750
 8556 4608 0D15DEE5 		ldrb	r1, [lr, #1293]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8557              		.loc 1 1025 0
 8558 460c 0E25DEE5 		ldrb	r2, [lr, #1294]	@ zero_extendqisi2
 8559 4610 46F9FFEA 		b	.L685
 8560              	.LVL941:
 8561              	.L416:
 8562              	.LBE208:
 8563              	.LBE303:
 8564              	.LBB304:
 8565              	.LBB226:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8566              		.loc 1 1024 0
 8567 4614 38149FE5 		ldr	r1, .L750
 8568 4618 8505D1E5 		ldrb	r0, [r1, #1413]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8569              		.loc 1 1025 0
 8570 461c 8615D1E5 		ldrb	r1, [r1, #1414]	@ zero_extendqisi2
 8571 4620 55FAFFEA 		b	.L687
 8572              	.LVL942:
 8573              	.L538:
 8574              	.LBE226:
 8575              	.LBE304:
 8576              	.LBE316:
 8577              	.LBE467:
 8578              	.LBB468:
 8579              	.LBB145:
3030:../uvc.c      ****                          		CyU3PThreadSleep(500);
 8580              		.loc 1 3030 0
 8581 4624 0720A0E1 		mov	r2, r7
 8582 4628 3010A0E3 		mov	r1, #48
 8583 462c 5230A0E3 		mov	r3, #82
 8584 4630 0B00A0E3 		mov	r0, #11
 8585              	.LVL943:
 8586 4634 FEFFFFEB 		bl	SensorSetIrisControl
 8587              	.LVL944:
3031:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
 8588              		.loc 1 3031 0
 8589 4638 7D0FA0E3 		mov	r0, #500
 8590 463c FEFFFFEB 		bl	_tx_thread_sleep
 8591              	.LVL945:
3032:../uvc.c      ****                          		break;
 8592              		.loc 1 3032 0
 8593 4640 0720A0E1 		mov	r2, r7
 8594 4644 10149FE5 		ldr	r1, .L750+8
 8595 4648 0B30A0E3 		mov	r3, #11
 8596 464c 0400A0E3 		mov	r0, #4
 8597 4650 FEFFFFEB 		bl	CyU3PDebugPrint
 8598              	.LVL946:
 8599 4654 BCFAFFEA 		b	.L537
 8600              	.LVL947:
 8601              	.L469:
 8602              	.LBE145:
 8603              	.LBE468:
 8604              	.LBB469:
 8605              	.LBB430:
 8606              	.LBB405:
 8607              	.LBB384:
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8608              		.loc 1 612 0
 8609 4658 F4139FE5 		ldr	r1, .L750
 8610 465c 5524D1E5 		ldrb	r2, [r1, #1109]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 8611              		.loc 1 613 0
 8612 4660 5634D1E5 		ldrb	r3, [r1, #1110]	@ zero_extendqisi2
 8613 4664 5CFBFFEA 		b	.L691
 8614              	.LVL948:
 8615              	.L482:
 8616              	.LBE384:
 8617              	.LBE405:
 8618              	.LBB406:
 8619              	.LBB364:
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8620              		.loc 1 612 0
 8621 4668 E4E39FE5 		ldr	lr, .L750
 8622 466c 6D24DEE5 		ldrb	r2, [lr, #1133]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 8623              		.loc 1 613 0
 8624 4670 6E34DEE5 		ldrb	r3, [lr, #1134]	@ zero_extendqisi2
 8625 4674 EFFAFFEA 		b	.L693
 8626              	.LVL949:
 8627              	.L501:
 8628              	.LBE364:
 8629              	.LBE406:
 8630              	.LBB407:
 8631              	.LBB372:
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 8632              		.loc 1 602 0
 8633 4678 D4139FE5 		ldr	r1, .L750
 8634 467c 7DE0D1E5 		ldrb	lr, [r1, #125]	@ zero_extendqisi2
 603:../uvc.c      **** 		 	 }
 8635              		.loc 1 603 0
 8636 4680 7E20D1E5 		ldrb	r2, [r1, #126]	@ zero_extendqisi2
 8637 4684 36FBFFEA 		b	.L697
 8638              	.LVL950:
 8639              	.L456:
 8640              	.LBE372:
 8641              	.LBE407:
 8642              	.LBB408:
 8643              	.LBB357:
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8644              		.loc 1 612 0
 8645 4688 C4139FE5 		ldr	r1, .L750
 8646 468c 4D23D1E5 		ldrb	r2, [r1, #845]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 8647              		.loc 1 613 0
 8648 4690 4E33D1E5 		ldrb	r3, [r1, #846]	@ zero_extendqisi2
 8649 4694 50FBFFEA 		b	.L691
 8650              	.L458:
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 8651              		.loc 1 559 0
 8652 4698 3F20DBE5 		ldrb	r2, [fp, #63]	@ zero_extendqisi2
 8653 469c 000052E3 		cmp	r2, #0
 8654 46a0 CA00000A 		beq	.L746
 8655              	.LVL951:
 8656              	.L466:
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8657              		.loc 1 569 0
 8658 46a4 5533DAE5 		ldrb	r3, [r10, #853]	@ zero_extendqisi2
 8659              	.LVL952:
 8660              	.L707:
 8661              	.LBE357:
 8662              	.LBE408:
 8663              	.LBB409:
 8664              	.LBB385:
 575:../uvc.c      **** 
 8665              		.loc 1 575 0
 8666 46a8 0700A0E1 		mov	r0, r7
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 8667              		.loc 1 570 0
 8668 46ac 0020A0E3 		mov	r2, #0
 575:../uvc.c      **** 
 8669              		.loc 1 575 0
 8670 46b0 A0139FE5 		ldr	r1, .L750+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8671              		.loc 1 414 0
 8672 46b4 FF70A0E3 		mov	r7, #255
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8673              		.loc 1 569 0
 8674 46b8 9C30CBE5 		strb	r3, [fp, #156]
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 8675              		.loc 1 570 0
 8676 46bc 9D20CBE5 		strb	r2, [fp, #157]
 8677              	.LVL953:
 575:../uvc.c      **** 
 8678              		.loc 1 575 0
 8679 46c0 28308DE5 		str	r3, [sp, #40]
 8680 46c4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8681              	.LVL954:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8682              		.loc 1 414 0
 8683 46c8 07C0A0E1 		mov	ip, r7
 8684 46cc 28309DE5 		ldr	r3, [sp, #40]
 8685 46d0 DBFDFFEA 		b	.L465
 8686              	.LVL955:
 8687              	.L462:
 8688              	.LBE385:
 8689              	.LBE409:
 8690              	.LBB410:
 8691              	.LBB358:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8692              		.loc 1 626 0
 8693 46d4 78239FE5 		ldr	r2, .L750
 8694 46d8 4F13D2E5 		ldrb	r1, [r2, #847]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8695              		.loc 1 627 0
 8696 46dc 5023D2E5 		ldrb	r2, [r2, #848]	@ zero_extendqisi2
 8697              	.LVL956:
 8698              	.L708:
 8699              	.LBE358:
 8700              	.LBE410:
 8701              	.LBB411:
 8702              	.LBB386:
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8703              		.loc 1 628 0
 8704 46e0 0030A0E3 		mov	r3, #0
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8705              		.loc 1 631 0
 8706 46e4 0700A0E1 		mov	r0, r7
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8707              		.loc 1 626 0
 8708 46e8 9C10CBE5 		strb	r1, [fp, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8709              		.loc 1 414 0
 8710 46ec FF70A0E3 		mov	r7, #255
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8711              		.loc 1 631 0
 8712 46f0 60139FE5 		ldr	r1, .L750+4
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8713              		.loc 1 628 0
 8714 46f4 9E30CBE5 		strb	r3, [fp, #158]
 629:../uvc.c      **** 		 	 }
 8715              		.loc 1 629 0
 8716 46f8 9F30CBE5 		strb	r3, [fp, #159]
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8717              		.loc 1 627 0
 8718 46fc 9D20CBE5 		strb	r2, [fp, #157]
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8719              		.loc 1 631 0
 8720 4700 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8721              	.LVL957:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8722              		.loc 1 414 0
 8723 4704 07C0A0E1 		mov	ip, r7
 632:../uvc.c      **** 			  break;
 8724              		.loc 1 632 0
 8725 4708 9C30DBE5 		ldrb	r3, [fp, #156]	@ zero_extendqisi2
 8726              	.LVL958:
 8727 470c CCFDFFEA 		b	.L465
 8728              	.LVL959:
 8729              	.L507:
 8730              	.LBE386:
 8731              	.LBE411:
 8732              	.LBB412:
 8733              	.LBB373:
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 8734              		.loc 1 620 0
 8735 4710 7F30DAE5 		ldrb	r3, [r10, #127]	@ zero_extendqisi2
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 8736              		.loc 1 621 0
 8737 4714 80E0DAE5 		ldrb	lr, [r10, #128]	@ zero_extendqisi2
 622:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 8738              		.loc 1 622 0
 8739 4718 0020A0E3 		mov	r2, #0
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8740              		.loc 1 631 0
 8741 471c 0C00A0E1 		mov	r0, ip
 8742 4720 30139FE5 		ldr	r1, .L750+4
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 8743              		.loc 1 620 0
 8744 4724 9C30CBE5 		strb	r3, [fp, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8745              		.loc 1 414 0
 8746 4728 FF80A0E3 		mov	r8, #255
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 8747              		.loc 1 621 0
 8748 472c 9DE0CBE5 		strb	lr, [fp, #157]
 622:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 8749              		.loc 1 622 0
 8750 4730 9E20CBE5 		strb	r2, [fp, #158]
 623:../uvc.c      **** 		 	 }
 8751              		.loc 1 623 0
 8752 4734 9F20CBE5 		strb	r2, [fp, #159]
 8753 4738 0EFBFFEA 		b	.L698
 8754              	.L506:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8755              		.loc 1 431 0
 8756 473c 0020A0E3 		mov	r2, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8757              		.loc 1 432 0
 8758 4740 0200A0E3 		mov	r0, #2
 8759 4744 0C139FE5 		ldr	r1, .L750+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8760              		.loc 1 414 0
 8761 4748 FF80A0E3 		mov	r8, #255
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8762              		.loc 1 430 0
 8763 474c 9CC0CBE5 		strb	ip, [fp, #156]
 8764 4750 07FBFFEA 		b	.L695
 8765              	.LVL960:
 8766              	.L475:
 8767              	.LBE373:
 8768              	.LBE412:
 8769              	.LBB413:
 8770              	.LBB387:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8771              		.loc 1 626 0
 8772 4754 F8229FE5 		ldr	r2, .L750
 8773 4758 5714D2E5 		ldrb	r1, [r2, #1111]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8774              		.loc 1 627 0
 8775 475c 5824D2E5 		ldrb	r2, [r2, #1112]	@ zero_extendqisi2
 8776 4760 DEFFFFEA 		b	.L708
 8777              	.L471:
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 8778              		.loc 1 559 0
 8779 4764 4A20DBE5 		ldrb	r2, [fp, #74]	@ zero_extendqisi2
 8780 4768 000052E3 		cmp	r2, #0
 8781 476c 8F00000A 		beq	.L747
 8782              	.LVL961:
 8783              	.L479:
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8784              		.loc 1 569 0
 8785 4770 5D34DAE5 		ldrb	r3, [r10, #1117]	@ zero_extendqisi2
 8786 4774 CBFFFFEA 		b	.L707
 8787              	.LVL962:
 8788              	.L503:
 8789              	.LBE387:
 8790              	.LBE413:
 8791              	.LBB414:
 8792              	.LBB374:
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 8793              		.loc 1 443 0
 8794 4778 8520DAE5 		ldrb	r2, [r10, #133]	@ zero_extendqisi2
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 8795              		.loc 1 444 0
 8796 477c 8680DAE5 		ldrb	r8, [r10, #134]	@ zero_extendqisi2
 575:../uvc.c      **** 
 8797              		.loc 1 575 0
 8798 4780 0C00A0E1 		mov	r0, ip
 8799 4784 CC129FE5 		ldr	r1, .L750+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8800              		.loc 1 414 0
 8801 4788 FFC0A0E3 		mov	ip, #255
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 8802              		.loc 1 443 0
 8803 478c 9C20CBE5 		strb	r2, [fp, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8804              		.loc 1 414 0
 8805 4790 30C08DE5 		str	ip, [sp, #48]
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 8806              		.loc 1 444 0
 8807 4794 9D80CBE5 		strb	r8, [fp, #157]
 8808              	.LVL963:
 575:../uvc.c      **** 
 8809              		.loc 1 575 0
 8810 4798 2C208DE5 		str	r2, [sp, #44]
 8811 479c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8812              	.LVL964:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8813              		.loc 1 414 0
 8814 47a0 30C09DE5 		ldr	ip, [sp, #48]
 8815 47a4 2C209DE5 		ldr	r2, [sp, #44]
 8816 47a8 0C30A0E1 		mov	r3, ip
 8817 47ac 34FDFFEA 		b	.L510
 8818              	.LVL965:
 8819              	.L500:
 957:../uvc.c      **** 			  break;
 8820              		.loc 1 957 0
 8821 47b0 0000A0E3 		mov	r0, #0
 8822 47b4 0020A0E1 		mov	r2, r0
 8823 47b8 0110A0E3 		mov	r1, #1
 8824 47bc FEFFFFEB 		bl	CyU3PUsbStall
 8825              	.LVL966:
 8826              	.L696:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8827              		.loc 1 414 0
 8828 47c0 FF80A0E3 		mov	r8, #255
 8829              	.LVL967:
 8830 47c4 0820A0E1 		mov	r2, r8
 8831 47c8 30808DE5 		str	r8, [sp, #48]
 8832 47cc 08C0A0E1 		mov	ip, r8
 8833 47d0 0830A0E1 		mov	r3, r8
 8834 47d4 2AFDFFEA 		b	.L510
 8835              	.LVL968:
 8836              	.L343:
 8837              	.LBE374:
 8838              	.LBE414:
 8839              	.LBE430:
 8840              	.LBE469:
 8841              	.LBB470:
 8842              	.LBB317:
 8843              	.LBB305:
 8844              	.LBB216:
1143:../uvc.c      **** 					  }
 8845              		.loc 1 1143 0
 8846 47d8 0000A0E3 		mov	r0, #0
 8847 47dc 0020A0E1 		mov	r2, r0
 8848 47e0 0110A0E3 		mov	r1, #1
 8849 47e4 FEFFFFEB 		bl	CyU3PUsbStall
 8850              	.LVL969:
 8851 47e8 7FFCFFEA 		b	.L346
 8852              	.LVL970:
 8853              	.L488:
 8854              	.LBE216:
 8855              	.LBE305:
 8856              	.LBE317:
 8857              	.LBE470:
 8858              	.LBB471:
 8859              	.LBB431:
 8860              	.LBB415:
 8861              	.LBB365:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8862              		.loc 1 626 0
 8863 47ec 6FC4DAE5 		ldrb	ip, [r10, #1135]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8864              		.loc 1 627 0
 8865 47f0 7024DAE5 		ldrb	r2, [r10, #1136]	@ zero_extendqisi2
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8866              		.loc 1 628 0
 8867 47f4 0030A0E3 		mov	r3, #0
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8868              		.loc 1 631 0
 8869 47f8 0700A0E1 		mov	r0, r7
 8870 47fc 54129FE5 		ldr	r1, .L750+4
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8871              		.loc 1 626 0
 8872 4800 9CC0CBE5 		strb	ip, [fp, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8873              		.loc 1 414 0
 8874 4804 FF80A0E3 		mov	r8, #255
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8875              		.loc 1 627 0
 8876 4808 9D20CBE5 		strb	r2, [fp, #157]
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8877              		.loc 1 628 0
 8878 480c 9E30CBE5 		strb	r3, [fp, #158]
 629:../uvc.c      **** 		 	 }
 8879              		.loc 1 629 0
 8880 4810 9F30CBE5 		strb	r3, [fp, #159]
 8881 4814 8CFAFFEA 		b	.L694
 8882              	.L487:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8883              		.loc 1 431 0
 8884 4818 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8885              		.loc 1 432 0
 8886 481c 0200A0E3 		mov	r0, #2
 8887 4820 30129FE5 		ldr	r1, .L750+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8888              		.loc 1 414 0
 8889 4824 FF80A0E3 		mov	r8, #255
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8890              		.loc 1 430 0
 8891 4828 9C70CBE5 		strb	r7, [fp, #156]
 8892 482c 85FAFFEA 		b	.L692
 8893              	.L481:
 957:../uvc.c      **** 			  break;
 8894              		.loc 1 957 0
 8895 4830 0000A0E3 		mov	r0, #0
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8896              		.loc 1 414 0
 8897 4834 FF80A0E3 		mov	r8, #255
 957:../uvc.c      **** 			  break;
 8898              		.loc 1 957 0
 8899 4838 0020A0E1 		mov	r2, r0
 8900 483c 0110A0E3 		mov	r1, #1
 8901 4840 FEFFFFEB 		bl	CyU3PUsbStall
 8902              	.LVL971:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8903              		.loc 1 414 0
 8904 4844 08C0A0E1 		mov	ip, r8
 8905 4848 0820A0E1 		mov	r2, r8
 8906 484c 0830A0E1 		mov	r3, r8
 8907 4850 DBFCFFEA 		b	.L491
 8908              	.LVL972:
 8909              	.L484:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8910              		.loc 1 464 0
 8911 4854 000057E3 		cmp	r7, #0
 8912 4858 2C00000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 8913              		.loc 1 465 0
 8914 485c 9030DBE5 		ldrb	r3, [fp, #144]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8915              		.loc 1 464 0
 8916 4860 010057E3 		cmp	r7, #1
 465:../uvc.c      **** 			 		 }
 8917              		.loc 1 465 0
 8918 4864 9C30CBE5 		strb	r3, [fp, #156]
 8919              	.LVL973:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8920              		.loc 1 464 0
 8921 4868 2800009A 		bls	.L493
 465:../uvc.c      **** 			 		 }
 8922              		.loc 1 465 0
 8923 486c 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8924              		.loc 1 464 0
 8925 4870 020057E3 		cmp	r7, #2
 465:../uvc.c      **** 			 		 }
 8926              		.loc 1 465 0
 8927 4874 9D30C4E5 		strb	r3, [r4, #157]
 8928              	.LVL974:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8929              		.loc 1 464 0
 8930 4878 2400000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 8931              		.loc 1 465 0
 8932 487c 9230D4E5 		ldrb	r3, [r4, #146]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8933              		.loc 1 464 0
 8934 4880 030057E3 		cmp	r7, #3
 465:../uvc.c      **** 			 		 }
 8935              		.loc 1 465 0
 8936 4884 9E30C4E5 		strb	r3, [r4, #158]
 8937              	.LVL975:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8938              		.loc 1 464 0
 8939 4888 2000000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 8940              		.loc 1 465 0
 8941 488c 9330D4E5 		ldrb	r3, [r4, #147]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8942              		.loc 1 464 0
 8943 4890 040057E3 		cmp	r7, #4
 465:../uvc.c      **** 			 		 }
 8944              		.loc 1 465 0
 8945 4894 9F30C4E5 		strb	r3, [r4, #159]
 8946              	.LVL976:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8947              		.loc 1 464 0
 8948 4898 1C00000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 8949              		.loc 1 465 0
 8950 489c 9430D4E5 		ldrb	r3, [r4, #148]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8951              		.loc 1 464 0
 8952 48a0 050057E3 		cmp	r7, #5
 465:../uvc.c      **** 			 		 }
 8953              		.loc 1 465 0
 8954 48a4 A030C4E5 		strb	r3, [r4, #160]
 8955              	.LVL977:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8956              		.loc 1 464 0
 8957 48a8 1800000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 8958              		.loc 1 465 0
 8959 48ac 9530D4E5 		ldrb	r3, [r4, #149]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8960              		.loc 1 464 0
 8961 48b0 060057E3 		cmp	r7, #6
 465:../uvc.c      **** 			 		 }
 8962              		.loc 1 465 0
 8963 48b4 A130C4E5 		strb	r3, [r4, #161]
 8964              	.LVL978:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8965              		.loc 1 464 0
 8966 48b8 1400000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 8967              		.loc 1 465 0
 8968 48bc 9630D4E5 		ldrb	r3, [r4, #150]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8969              		.loc 1 464 0
 8970 48c0 070057E3 		cmp	r7, #7
 465:../uvc.c      **** 			 		 }
 8971              		.loc 1 465 0
 8972 48c4 A230C4E5 		strb	r3, [r4, #162]
 8973              	.LVL979:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8974              		.loc 1 464 0
 8975 48c8 1000000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 8976              		.loc 1 465 0
 8977 48cc 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8978              		.loc 1 464 0
 8979 48d0 080057E3 		cmp	r7, #8
 465:../uvc.c      **** 			 		 }
 8980              		.loc 1 465 0
 8981 48d4 A330C4E5 		strb	r3, [r4, #163]
 8982              	.LVL980:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8983              		.loc 1 464 0
 8984 48d8 0C00000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 8985              		.loc 1 465 0
 8986 48dc 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8987              		.loc 1 464 0
 8988 48e0 090057E3 		cmp	r7, #9
 465:../uvc.c      **** 			 		 }
 8989              		.loc 1 465 0
 8990 48e4 A430C4E5 		strb	r3, [r4, #164]
 8991              	.LVL981:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8992              		.loc 1 464 0
 8993 48e8 0800000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 8994              		.loc 1 465 0
 8995 48ec 9930DBE5 		ldrb	r3, [fp, #153]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8996              		.loc 1 464 0
 8997 48f0 0A0057E3 		cmp	r7, #10
 465:../uvc.c      **** 			 		 }
 8998              		.loc 1 465 0
 8999 48f4 A530CBE5 		strb	r3, [fp, #165]
 9000              	.LVL982:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 9001              		.loc 1 464 0
 9002 48f8 0400000A 		beq	.L493
 465:../uvc.c      **** 			 		 }
 9003              		.loc 1 465 0
 9004 48fc 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 9005              		.loc 1 464 0
 9006 4900 0B0057E3 		cmp	r7, #11
 465:../uvc.c      **** 			 		 }
 9007              		.loc 1 465 0
 9008 4904 A630C4E5 		strb	r3, [r4, #166]
 9009              	.LVL983:
 9010 4908 9B30D415 		ldrneb	r3, [r4, #155]	@ zero_extendqisi2
 9011 490c A730C415 		strneb	r3, [r4, #167]
 9012              	.LVL984:
 9013              	.L493:
 474:../uvc.c      **** 			 		 {
 9014              		.loc 1 474 0
 9015 4910 9B30DBE5 		ldrb	r3, [fp, #155]	@ zero_extendqisi2
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 9016              		.loc 1 467 0
 9017 4914 A5C0DBE5 		ldrb	ip, [fp, #165]	@ zero_extendqisi2
 9018              	.LVL985:
 474:../uvc.c      **** 			 		 {
 9019              		.loc 1 474 0
 9020 4918 FF0053E3 		cmp	r3, #255
 468:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9021              		.loc 1 468 0
 9022 491c A680DBE5 		ldrb	r8, [fp, #166]	@ zero_extendqisi2
 9023              	.LVL986:
 474:../uvc.c      **** 			 		 {
 9024              		.loc 1 474 0
 9025 4920 0600000A 		beq	.L495
 476:../uvc.c      **** 			 		 }
 9026              		.loc 1 476 0
 9027 4924 9920D4E5 		ldrb	r2, [r4, #153]	@ zero_extendqisi2
 9028 4928 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
 9029 492c 0400A0E3 		mov	r0, #4
 9030 4930 28119FE5 		ldr	r1, .L750+12
 9031 4934 24C08DE5 		str	ip, [sp, #36]
 9032 4938 FEFFFFEB 		bl	CyU3PDebugPrint
 9033              	.LVL987:
 9034 493c 24C09DE5 		ldr	ip, [sp, #36]
 9035              	.L495:
 9036              	.LVL988:
 575:../uvc.c      **** 
 9037              		.loc 1 575 0
 9038 4940 0700A0E1 		mov	r0, r7
 9039 4944 0C119FE5 		ldr	r1, .L750+4
 9040 4948 24C08DE5 		str	ip, [sp, #36]
 9041 494c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9042              	.LVL989:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9043              		.loc 1 414 0
 9044 4950 FF20A0E3 		mov	r2, #255
 9045 4954 0230A0E1 		mov	r3, r2
 9046 4958 24C09DE5 		ldr	ip, [sp, #36]
 9047 495c 98FCFFEA 		b	.L491
 9048              	.LVL990:
 9049              	.L391:
 9050              	.LBE365:
 9051              	.LBE415:
 9052              	.LBE431:
 9053              	.LBE471:
 9054              	.LBB472:
 9055              	.LBB318:
 9056              	.LBB306:
 9057              	.LBB237:
1161:../uvc.c      **** 					  }
 9058              		.loc 1 1161 0
 9059 4960 0020A0E1 		mov	r2, r0
 9060 4964 0710A0E1 		mov	r1, r7
 9061 4968 FEFFFFEB 		bl	CyU3PUsbStall
 9062              	.LVL991:
 9063 496c 4FFCFFEA 		b	.L392
 9064              	.LVL992:
 9065              	.L745:
 9066              	.LBE237:
 9067              	.LBE306:
 9068              	.LBE318:
 9069              	.LBE472:
 9070              	.LBB473:
 9071              	.LBB345:
 9072              	.LBB335:
 9073              	.LBB329:
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 9074              		.loc 1 563 0
 9075 4970 FEFFFFEB 		bl	SensorGetControl
 9076              	.LVL993:
 566:../uvc.c      **** 		 	 		 }
 9077              		.loc 1 566 0
 9078 4974 0130A0E3 		mov	r3, #1
 9079 4978 3030CBE5 		strb	r3, [fp, #48]
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9080              		.loc 1 564 0
 9081 497c ED01CAE5 		strb	r0, [r10, #493]
 9082 4980 46FDFFEA 		b	.L292
 9083              	.LVL994:
 9084              	.L480:
 9085              	.LBE329:
 9086              	.LBE335:
 9087              	.LBE345:
 9088              	.LBE473:
 9089              	.LBB474:
 9090              	.LBB432:
 9091              	.LBB416:
 9092              	.LBB388:
 949:../uvc.c      **** 			   }
 9093              		.loc 1 949 0
 9094 4984 0400A0E3 		mov	r0, #4
 9095 4988 D4109FE5 		ldr	r1, .L750+16
 9096 498c FEFFFFEB 		bl	CyU3PDebugPrint
 9097              	.LVL995:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9098              		.loc 1 414 0
 9099 4990 FF30A0E3 		mov	r3, #255
 9100 4994 0370A0E1 		mov	r7, r3
 9101 4998 03C0A0E1 		mov	ip, r3
 9102 499c 28FDFFEA 		b	.L465
 9103              	.LVL996:
 9104              	.L511:
 9105              	.LBE388:
 9106              	.LBE416:
 9107              	.LBB417:
 9108              	.LBB375:
 949:../uvc.c      **** 			   }
 9109              		.loc 1 949 0
 9110 49a0 BC109FE5 		ldr	r1, .L750+16
 9111 49a4 0400A0E3 		mov	r0, #4
 9112              	.LVL997:
 9113 49a8 FEFFFFEB 		bl	CyU3PDebugPrint
 9114              	.LVL998:
 9115 49ac 83FFFFEA 		b	.L696
 9116              	.LVL999:
 9117              	.L747:
 9118              	.LBE375:
 9119              	.LBE417:
 9120              	.LBB418:
 9121              	.LBB389:
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 9122              		.loc 1 563 0
 9123 49b0 0310A0E1 		mov	r1, r3
 9124 49b4 30009DE5 		ldr	r0, [sp, #48]
 9125 49b8 FEFFFFEB 		bl	SensorGetControl
 9126              	.LVL1000:
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9127              		.loc 1 564 0
 9128 49bc 90C09FE5 		ldr	ip, .L750
 566:../uvc.c      **** 		 	 		 }
 9129              		.loc 1 566 0
 9130 49c0 0130A0E3 		mov	r3, #1
 9131 49c4 4A30C4E5 		strb	r3, [r4, #74]
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9132              		.loc 1 564 0
 9133 49c8 5D04CCE5 		strb	r0, [ip, #1117]
 9134 49cc 67FFFFEA 		b	.L479
 9135              	.LVL1001:
 9136              	.L746:
 9137              	.LBE389:
 9138              	.LBE418:
 9139              	.LBB419:
 9140              	.LBB359:
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 9141              		.loc 1 563 0
 9142 49d0 0310A0E1 		mov	r1, r3
 9143 49d4 30009DE5 		ldr	r0, [sp, #48]
 9144 49d8 FEFFFFEB 		bl	SensorGetControl
 9145              	.LVL1002:
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9146              		.loc 1 564 0
 9147 49dc 70C09FE5 		ldr	ip, .L750
 566:../uvc.c      **** 		 	 		 }
 9148              		.loc 1 566 0
 9149 49e0 0130A0E3 		mov	r3, #1
 9150 49e4 3F30C4E5 		strb	r3, [r4, #63]
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9151              		.loc 1 564 0
 9152 49e8 5503CCE5 		strb	r0, [ip, #853]
 9153 49ec 2CFFFFEA 		b	.L466
 9154              	.LVL1003:
 9155              	.L744:
 9156              	.LBE359:
 9157              	.LBE419:
 9158              	.LBE432:
 9159              	.LBE474:
 9160              	.LBB475:
 9161              	.LBB319:
 9162              	.LBB307:
 9163              	.LBB227:
1174:../uvc.c      **** 					  else if(getData == 0xff)
 9164              		.loc 1 1174 0
 9165 49f0 0410A0E3 		mov	r1, #4
 9166 49f4 0000A0E3 		mov	r0, #0
 9167 49f8 00108DE5 		str	r1, [sp]
 9168 49fc 04008DE5 		str	r0, [sp, #4]
 9169 4a00 34209DE5 		ldr	r2, [sp, #52]
 9170 4a04 5C009FE5 		ldr	r0, .L750+20
 9171 4a08 2310A0E3 		mov	r1, #35
 9172 4a0c FEFFFFEB 		bl	cmdSet
 9173              	.LVL1004:
 9174 4a10 24C09DE5 		ldr	ip, [sp, #36]
 9175 4a14 81FBFFEA 		b	.L427
 9176              	.LVL1005:
 9177              	.L293:
 9178              	.LBE227:
 9179              	.LBE307:
 9180              	.LBE319:
 9181              	.LBE475:
 9182              	.LBB476:
 9183              	.LBB346:
 9184              	.LBB336:
 9185              	.LBB330:
 949:../uvc.c      **** 			   }
 9186              		.loc 1 949 0
 9187 4a18 0400A0E3 		mov	r0, #4
 9188              	.LVL1006:
 9189 4a1c 40109FE5 		ldr	r1, .L750+16
 9190 4a20 FEFFFFEB 		bl	CyU3PDebugPrint
 9191              	.LVL1007:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9192              		.loc 1 414 0
 9193 4a24 FF20A0E3 		mov	r2, #255
 9194 4a28 0280A0E1 		mov	r8, r2
 9195              	.LVL1008:
 9196 4a2c 0230A0E1 		mov	r3, r2
 9197 4a30 00F8FFEA 		b	.L291
 9198              	.LVL1009:
 9199              	.L496:
 9200              	.LBE330:
 9201              	.LBE336:
 9202              	.LBE346:
 9203              	.LBE476:
 9204              	.LBB477:
 9205              	.LBB433:
 9206              	.LBB420:
 9207              	.LBB366:
 9208 4a34 FF80A0E3 		mov	r8, #255
 949:../uvc.c      **** 			   }
 9209              		.loc 1 949 0
 9210 4a38 0400A0E3 		mov	r0, #4
 9211              	.LVL1010:
 9212 4a3c 20109FE5 		ldr	r1, .L750+16
 9213 4a40 FEFFFFEB 		bl	CyU3PDebugPrint
 9214              	.LVL1011:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9215              		.loc 1 414 0
 9216 4a44 08C0A0E1 		mov	ip, r8
 9217 4a48 0820A0E1 		mov	r2, r8
 9218 4a4c 0830A0E1 		mov	r3, r8
 9219 4a50 5BFCFFEA 		b	.L491
 9220              	.L751:
 9221              		.align	2
 9222              	.L750:
 9223 4a54 00000000 		.word	.LANCHOR1
 9224 4a58 9C000000 		.word	.LANCHOR0+156
 9225 4a5c 70050000 		.word	.LC29
 9226 4a60 10020000 		.word	.LC12
 9227 4a64 D4020000 		.word	.LC17
 9228 4a68 00000000 		.word	cmdQu
 9229              	.LBE366:
 9230              	.LBE420:
 9231              	.LBE433:
 9232              	.LBE477:
 9233              		.cfi_endproc
 9234              	.LFE24:
 9236              		.align	2
 9237              		.global	CyFxGpifCB
 9239              	CyFxGpifCB:
 9240              	.LFB12:
1703:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 9241              		.loc 1 1703 0
 9242              		.cfi_startproc
 9243              		@ args = 0, pretend = 0, frame = 0
 9244              		@ frame_needed = 0, uses_anonymous_args = 0
1704:../uvc.c      ****     {
 9245              		.loc 1 1704 0
 9246 4a6c 010050E3 		cmp	r0, #1
1703:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 9247              		.loc 1 1703 0
 9248 4a70 10402DE9 		stmfd	sp!, {r4, lr}
 9249              	.LCFI22:
 9250              		.cfi_def_cfa_offset 8
 9251              		.cfi_offset 4, -8
 9252              		.cfi_offset 14, -4
1704:../uvc.c      ****     {
 9253              		.loc 1 1704 0
 9254 4a74 1080BD18 		ldmnefd	sp!, {r4, pc}
 9255              	.LBB482:
 9256              	.LBB483:
1603:../uvc.c      ****     {
 9257              		.loc 1 1603 0
 9258 4a78 C4309FE5 		ldr	r3, .L770
 9259 4a7c C030D3E5 		ldrb	r3, [r3, #192]	@ zero_extendqisi2
 9260 4a80 030053E3 		cmp	r3, #3
 9261 4a84 1000000A 		beq	.L769
1627:../uvc.c      ****     {
 9262              		.loc 1 1627 0
 9263 4a88 020053E3 		cmp	r3, #2
 9264 4a8c 1080BD18 		ldmnefd	sp!, {r4, pc}
1629:../uvc.c      ****         {
 9265              		.loc 1 1629 0
 9266 4a90 083041E2 		sub	r3, r1, #8
 9267 4a94 0A0053E3 		cmp	r3, #10
 9268 4a98 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 9269 4a9c 200000EA 		b	.L762
 9270              	.L764:
 9271 4aa0 1C4B0000 		.word	.L756
 9272 4aa4 244B0000 		.word	.L762
 9273 4aa8 244B0000 		.word	.L762
 9274 4aac EC4A0000 		.word	.L752
 9275 4ab0 244B0000 		.word	.L762
 9276 4ab4 244B0000 		.word	.L762
 9277 4ab8 244B0000 		.word	.L762
 9278 4abc F04A0000 		.word	.L768
 9279 4ac0 244B0000 		.word	.L762
 9280 4ac4 244B0000 		.word	.L762
 9281 4ac8 EC4A0000 		.word	.L752
 9282              	.L769:
1605:../uvc.c      ****         {
 9283              		.loc 1 1605 0
 9284 4acc 0B3041E2 		sub	r3, r1, #11
 9285 4ad0 030053E3 		cmp	r3, #3
 9286 4ad4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 9287 4ad8 110000EA 		b	.L762
 9288              	.L757:
 9289 4adc 1C4B0000 		.word	.L756
 9290 4ae0 F04A0000 		.word	.L768
 9291 4ae4 EC4A0000 		.word	.L752
 9292 4ae8 EC4A0000 		.word	.L752
 9293              	.L752:
 9294 4aec 1080BDE8 		ldmfd	sp!, {r4, pc}
 9295              	.L768:
1629:../uvc.c      ****         {
 9296              		.loc 1 1629 0
 9297 4af0 0110A0E3 		mov	r1, #1
 9298              	.L758:
1686:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 9299              		.loc 1 1686 0
 9300 4af4 4C009FE5 		ldr	r0, .L770+4
 9301 4af8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
1687:../uvc.c      ****         {
 9302              		.loc 1 1687 0
 9303 4afc 004050E2 		subs	r4, r0, #0
 9304 4b00 1080BD08 		ldmeqfd	sp!, {r4, pc}
1689:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 9305              		.loc 1 1689 0
 9306 4b04 0400A0E3 		mov	r0, #4
 9307 4b08 3C109FE5 		ldr	r1, .L770+8
 9308 4b0c 0420A0E1 		mov	r2, r4
 9309 4b10 FEFFFFEB 		bl	CyU3PDebugPrint
1690:../uvc.c      ****         }
 9310              		.loc 1 1690 0
 9311 4b14 0400A0E1 		mov	r0, r4
 9312 4b18 FEFFFFEB 		bl	CyFxAppErrorHandler
 9313              	.L756:
1605:../uvc.c      ****         {
 9314              		.loc 1 1605 0
 9315 4b1c 0010A0E3 		mov	r1, #0
 9316 4b20 F3FFFFEA 		b	.L758
 9317              	.L762:
1675:../uvc.c      ****                 /* Unexpected current state. Return error. */
 9318              		.loc 1 1675 0
 9319 4b24 0120A0E1 		mov	r2, r1
 9320 4b28 0100A0E3 		mov	r0, #1
 9321 4b2c 1C109FE5 		ldr	r1, .L770+12
 9322 4b30 FEFFFFEB 		bl	CyU3PDebugPrint
 9323              	.LBE483:
 9324              	.LBE482:
 9325              	.LBB484:
 9326              	.LBB485:
1708:../uvc.c      ****     }
 9327              		.loc 1 1708 0
 9328 4b34 0400A0E3 		mov	r0, #4
 9329 4b38 14109FE5 		ldr	r1, .L770+16
 9330              	.LBE485:
 9331              	.LBE484:
1710:../uvc.c      **** 
 9332              		.loc 1 1710 0
 9333 4b3c 1040BDE8 		ldmfd	sp!, {r4, lr}
 9334              	.LBB487:
 9335              	.LBB486:
1708:../uvc.c      ****     }
 9336              		.loc 1 1708 0
 9337 4b40 FEFFFFEA 		b	CyU3PDebugPrint
 9338              	.L771:
 9339              		.align	2
 9340              	.L770:
 9341 4b44 00000000 		.word	.LANCHOR0
 9342 4b48 00000000 		.word	glChHandleUVCStream
 9343 4b4c D4060000 		.word	.LC38
 9344 4b50 BC060000 		.word	.LC37
 9345 4b54 04070000 		.word	.LC39
 9346              	.LBE486:
 9347              	.LBE487:
 9348              		.cfi_endproc
 9349              	.LFE12:
 9351              		.align	2
 9352              		.global	CyFxUVCApplnI2CInit
 9354              	CyFxUVCApplnI2CInit:
 9355              	.LFB14:
1766:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
 9356              		.loc 1 1766 0
 9357              		.cfi_startproc
 9358              		@ args = 0, pretend = 0, frame = 16
 9359              		@ frame_needed = 0, uses_anonymous_args = 0
 9360 4b58 10402DE9 		stmfd	sp!, {r4, lr}
 9361              	.LCFI23:
 9362              		.cfi_def_cfa_offset 8
 9363              		.cfi_offset 4, -8
 9364              		.cfi_offset 14, -4
 9365 4b5c 10D04DE2 		sub	sp, sp, #16
 9366              	.LCFI24:
 9367              		.cfi_def_cfa_offset 24
1770:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 9368              		.loc 1 1770 0
 9369 4b60 FEFFFFEB 		bl	CyU3PI2cInit
 9370              	.LVL1012:
1771:../uvc.c      ****     {
 9371              		.loc 1 1771 0
 9372 4b64 004050E2 		subs	r4, r0, #0
 9373 4b68 0B00001A 		bne	.L775
1778:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 9374              		.loc 1 1778 0
 9375 4b6c 50209FE5 		ldr	r2, .L777
1780:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 9376              		.loc 1 1780 0
 9377 4b70 0030E0E3 		mvn	r3, #0
1783:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 9378              		.loc 1 1783 0
 9379 4b74 0410A0E1 		mov	r1, r4
 9380 4b78 0D00A0E1 		mov	r0, sp
 9381              	.LVL1013:
1778:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 9382              		.loc 1 1778 0
 9383 4b7c 14008DE8 		stmia	sp, {r2, r4}
1780:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 9384              		.loc 1 1780 0
 9385 4b80 08308DE5 		str	r3, [sp, #8]
1781:../uvc.c      **** 
 9386              		.loc 1 1781 0
 9387 4b84 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1783:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 9388              		.loc 1 1783 0
 9389 4b88 FEFFFFEB 		bl	CyU3PI2cSetConfig
 9390              	.LVL1014:
1784:../uvc.c      ****     {
 9391              		.loc 1 1784 0
 9392 4b8c 004050E2 		subs	r4, r0, #0
 9393 4b90 0600001A 		bne	.L776
1789:../uvc.c      **** 
 9394              		.loc 1 1789 0
 9395 4b94 10D08DE2 		add	sp, sp, #16
 9396              		@ sp needed
 9397 4b98 1080BDE8 		ldmfd	sp!, {r4, pc}
 9398              	.L775:
1773:../uvc.c      ****         CyFxAppErrorHandler (status);
 9399              		.loc 1 1773 0
 9400 4b9c 0400A0E3 		mov	r0, #4
 9401              	.LVL1015:
 9402 4ba0 20109FE5 		ldr	r1, .L777+4
 9403 4ba4 FEFFFFEB 		bl	CyU3PDebugPrint
 9404              	.LVL1016:
1774:../uvc.c      ****     }
 9405              		.loc 1 1774 0
 9406 4ba8 0400A0E1 		mov	r0, r4
 9407 4bac FEFFFFEB 		bl	CyFxAppErrorHandler
 9408              	.LVL1017:
 9409              	.L776:
1786:../uvc.c      ****         CyFxAppErrorHandler (status);
 9410              		.loc 1 1786 0
 9411 4bb0 0400A0E3 		mov	r0, #4
 9412              	.LVL1018:
 9413 4bb4 10109FE5 		ldr	r1, .L777+8
 9414 4bb8 FEFFFFEB 		bl	CyU3PDebugPrint
 9415              	.LVL1019:
1787:../uvc.c      ****     }
 9416              		.loc 1 1787 0
 9417 4bbc 0400A0E1 		mov	r0, r4
 9418 4bc0 FEFFFFEB 		bl	CyFxAppErrorHandler
 9419              	.LVL1020:
 9420              	.L778:
 9421              		.align	2
 9422              	.L777:
 9423 4bc4 A0860100 		.word	100000
 9424 4bc8 18070000 		.word	.LC40
 9425 4bcc 34070000 		.word	.LC41
 9426              		.cfi_endproc
 9427              	.LFE14:
 9429              		.align	2
 9430              		.global	UVCAppThread_Entry
 9432              	UVCAppThread_Entry:
 9433              	.LFB18:
2265:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 9434              		.loc 1 2265 0
 9435              		.cfi_startproc
 9436              		@ args = 0, pretend = 0, frame = 128
 9437              		@ frame_needed = 0, uses_anonymous_args = 0
 9438              	.LVL1021:
 9439 4bd0 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 9440              	.LCFI25:
 9441              		.cfi_def_cfa_offset 32
 9442              		.cfi_offset 4, -32
 9443              		.cfi_offset 5, -28
 9444              		.cfi_offset 6, -24
 9445              		.cfi_offset 7, -20
 9446              		.cfi_offset 8, -16
 9447              		.cfi_offset 9, -12
 9448              		.cfi_offset 10, -8
 9449              		.cfi_offset 14, -4
 9450 4bd4 88D04DE2 		sub	sp, sp, #136
 9451              	.LCFI26:
 9452              		.cfi_def_cfa_offset 168
 9453              	.LBB494:
 9454              	.LBB495:
1721:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9455              		.loc 1 1721 0
 9456 4bd8 FEFFFFEB 		bl	CyU3PUartInit
 9457              	.LVL1022:
1722:../uvc.c      ****     {
 9458              		.loc 1 1722 0
 9459 4bdc 004050E2 		subs	r4, r0, #0
 9460 4be0 DF01001A 		bne	.L839
1729:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 9461              		.loc 1 1729 0
 9462 4be4 08299FE5 		ldr	r2, .L868
1730:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 9463              		.loc 1 1730 0
 9464 4be8 0130A0E3 		mov	r3, #1
1738:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9465              		.loc 1 1738 0
 9466 4bec 0410A0E1 		mov	r1, r4
 9467 4bf0 60008DE2 		add	r0, sp, #96
 9468              	.LVL1023:
1731:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 9469              		.loc 1 1731 0
 9470 4bf4 7540CDE5 		strb	r4, [sp, #117]
1733:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 9471              		.loc 1 1733 0
 9472 4bf8 64408DE5 		str	r4, [sp, #100]
1734:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 9473              		.loc 1 1734 0
 9474 4bfc 68408DE5 		str	r4, [sp, #104]
1729:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 9475              		.loc 1 1729 0
 9476 4c00 70208DE5 		str	r2, [sp, #112]
1730:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 9477              		.loc 1 1730 0
 9478 4c04 7430CDE5 		strb	r3, [sp, #116]
1732:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 9479              		.loc 1 1732 0
 9480 4c08 60308DE5 		str	r3, [sp, #96]
1735:../uvc.c      **** 
 9481              		.loc 1 1735 0
 9482 4c0c 6C308DE5 		str	r3, [sp, #108]
1738:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9483              		.loc 1 1738 0
 9484 4c10 FEFFFFEB 		bl	CyU3PUartSetConfig
 9485              	.LVL1024:
1739:../uvc.c      ****     {
 9486              		.loc 1 1739 0
 9487 4c14 000050E3 		cmp	r0, #0
 9488 4c18 AD01001A 		bne	.L838
1745:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9489              		.loc 1 1745 0
 9490 4c1c 0000E0E3 		mvn	r0, #0
 9491              	.LVL1025:
 9492 4c20 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 9493              	.LVL1026:
1746:../uvc.c      ****     {
 9494              		.loc 1 1746 0
 9495 4c24 000050E3 		cmp	r0, #0
 9496 4c28 A901001A 		bne	.L838
1752:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9497              		.loc 1 1752 0
 9498 4c2c 0300A0E3 		mov	r0, #3
 9499              	.LVL1027:
 9500 4c30 0410A0E3 		mov	r1, #4
 9501 4c34 FEFFFFEB 		bl	CyU3PDebugInit
 9502              	.LVL1028:
1753:../uvc.c      ****     {
 9503              		.loc 1 1753 0
 9504 4c38 000050E3 		cmp	r0, #0
 9505 4c3c A401001A 		bne	.L838
1759:../uvc.c      **** }
 9506              		.loc 1 1759 0
 9507 4c40 FEFFFFEB 		bl	CyU3PDebugPreamble
 9508              	.LVL1029:
 9509 4c44 0640A0E3 		mov	r4, #6
 9510              	.LVL1030:
 9511              	.L785:
 9512              	.LBE495:
 9513              	.LBE494:
2281:../uvc.c      **** 	}
 9514              		.loc 1 2281 0
 9515 4c48 7D0FA0E3 		mov	r0, #500
 9516 4c4c 014044E2 		sub	r4, r4, #1
 9517 4c50 FEFFFFEB 		bl	_tx_thread_sleep
 9518              	.LVL1031:
2280:../uvc.c      **** 		CyU3PThreadSleep(500);
 9519              		.loc 1 2280 0
 9520 4c54 FF4014E2 		ands	r4, r4, #255
 9521 4c58 FAFFFF1A 		bne	.L785
 9522              	.LBB497:
 9523              	.LBB498:
1857:../uvc.c      ****     if (apiRetStatus != 0)
 9524              		.loc 1 1857 0
 9525 4c5c 94789FE5 		ldr	r7, .L868+4
 9526              	.LBE498:
 9527              	.LBE497:
2284:../uvc.c      **** 
 9528              		.loc 1 2284 0
 9529 4c60 FEFFFFEB 		bl	CyFxUVCApplnI2CInit
 9530              	.LVL1032:
 9531              	.LBB502:
 9532              	.LBB499:
1857:../uvc.c      ****     if (apiRetStatus != 0)
 9533              		.loc 1 1857 0
 9534 4c64 0410A0E1 		mov	r1, r4
 9535 4c68 0700A0E1 		mov	r0, r7
 9536 4c6c 2820A0E3 		mov	r2, #40
 9537 4c70 FEFFFFEB 		bl	_txe_event_flags_create
 9538              	.LVL1033:
1858:../uvc.c      ****     {
 9539              		.loc 1 1858 0
 9540 4c74 005050E2 		subs	r5, r0, #0
 9541 4c78 FF01001A 		bne	.L840
1872:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 9542              		.loc 1 1872 0
 9543 4c7c 0260A0E3 		mov	r6, #2
1875:../uvc.c      ****     gpioClock.halfDiv    = 0;
 9544              		.loc 1 1875 0
 9545 4c80 0380A0E3 		mov	r8, #3
1879:../uvc.c      ****     if (apiRetStatus != 0)
 9546              		.loc 1 1879 0
 9547 4c84 14008DE2 		add	r0, sp, #20
 9548              	.LVL1034:
 9549 4c88 0410A0E1 		mov	r1, r4
1868:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 9550              		.loc 1 1868 0
 9551 4c8c 884087E5 		str	r4, [r7, #136]
1869:../uvc.c      **** 
 9552              		.loc 1 1869 0
 9553 4c90 8C4087E5 		str	r4, [r7, #140]
1874:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 9554              		.loc 1 1874 0
 9555 4c94 1C40CDE5 		strb	r4, [sp, #28]
1876:../uvc.c      **** 
 9556              		.loc 1 1876 0
 9557 4c98 18408DE5 		str	r4, [sp, #24]
1872:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 9558              		.loc 1 1872 0
 9559 4c9c 1460CDE5 		strb	r6, [sp, #20]
1873:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 9560              		.loc 1 1873 0
 9561 4ca0 1560CDE5 		strb	r6, [sp, #21]
1875:../uvc.c      ****     gpioClock.halfDiv    = 0;
 9562              		.loc 1 1875 0
 9563 4ca4 1D80CDE5 		strb	r8, [sp, #29]
1879:../uvc.c      ****     if (apiRetStatus != 0)
 9564              		.loc 1 1879 0
 9565 4ca8 FEFFFFEB 		bl	CyU3PGpioInit
 9566              	.LVL1035:
1880:../uvc.c      ****     {
 9567              		.loc 1 1880 0
 9568 4cac 005050E2 		subs	r5, r0, #0
 9569 4cb0 EB01001A 		bne	.L841
1888:../uvc.c      ****     if (apiRetStatus != 0)
 9570              		.loc 1 1888 0
 9571 4cb4 1600A0E3 		mov	r0, #22
 9572              	.LVL1036:
 9573 4cb8 0110A0E3 		mov	r1, #1
 9574 4cbc FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9575              	.LVL1037:
1889:../uvc.c      ****     {
 9576              		.loc 1 1889 0
 9577 4cc0 005050E2 		subs	r5, r0, #0
 9578 4cc4 E001001A 		bne	.L842
1894:../uvc.c      ****     if (apiRetStatus != 0)
 9579              		.loc 1 1894 0
 9580 4cc8 1400A0E3 		mov	r0, #20
 9581              	.LVL1038:
 9582 4ccc 0110A0E3 		mov	r1, #1
 9583 4cd0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9584              	.LVL1039:
1895:../uvc.c      ****     {
 9585              		.loc 1 1895 0
 9586 4cd4 005050E2 		subs	r5, r0, #0
 9587 4cd8 D501001A 		bne	.L843
1900:../uvc.c      ****     if (apiRetStatus != 0)
 9588              		.loc 1 1900 0
 9589 4cdc 1800A0E3 		mov	r0, #24
 9590              	.LVL1040:
 9591 4ce0 0110A0E3 		mov	r1, #1
 9592 4ce4 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9593              	.LVL1041:
1901:../uvc.c      ****     {
 9594              		.loc 1 1901 0
 9595 4ce8 005050E2 		subs	r5, r0, #0
 9596 4cec FA01001A 		bne	.L844
1908:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9597              		.loc 1 1908 0
 9598 4cf0 0150A0E3 		mov	r5, #1
1913:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9599              		.loc 1 1913 0
 9600 4cf4 30108DE2 		add	r1, sp, #48
 9601 4cf8 1600A0E3 		mov	r0, #22
 9602              	.LVL1042:
1911:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9603              		.loc 1 1911 0
 9604 4cfc 3C408DE5 		str	r4, [sp, #60]
1912:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 9605              		.loc 1 1912 0
 9606 4d00 4040CDE5 		strb	r4, [sp, #64]
1908:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9607              		.loc 1 1908 0
 9608 4d04 30508DE5 		str	r5, [sp, #48]
1909:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 9609              		.loc 1 1909 0
 9610 4d08 34508DE5 		str	r5, [sp, #52]
1910:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 9611              		.loc 1 1910 0
 9612 4d0c 38508DE5 		str	r5, [sp, #56]
1913:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9613              		.loc 1 1913 0
 9614 4d10 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9615              	.LVL1043:
1914:../uvc.c      ****     {
 9616              		.loc 1 1914 0
 9617 4d14 009050E2 		subs	r9, r0, #0
 9618 4d18 E901001A 		bne	.L845
1927:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9619              		.loc 1 1927 0
 9620 4d1c 1400A0E3 		mov	r0, #20
 9621              	.LVL1044:
 9622 4d20 30108DE2 		add	r1, sp, #48
1922:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9623              		.loc 1 1922 0
 9624 4d24 30508DE5 		str	r5, [sp, #48]
1923:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 9625              		.loc 1 1923 0
 9626 4d28 34508DE5 		str	r5, [sp, #52]
1924:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 9627              		.loc 1 1924 0
 9628 4d2c 38508DE5 		str	r5, [sp, #56]
1925:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9629              		.loc 1 1925 0
 9630 4d30 3C408DE5 		str	r4, [sp, #60]
1926:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 9631              		.loc 1 1926 0
 9632 4d34 4040CDE5 		strb	r4, [sp, #64]
1927:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9633              		.loc 1 1927 0
 9634 4d38 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9635              	.LVL1045:
1928:../uvc.c      ****     {
 9636              		.loc 1 1928 0
 9637 4d3c 009050E2 		subs	r9, r0, #0
 9638 4d40 D901001A 		bne	.L846
1941:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9639              		.loc 1 1941 0
 9640 4d44 30108DE2 		add	r1, sp, #48
 9641 4d48 1800A0E3 		mov	r0, #24
 9642              	.LVL1046:
1936:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 9643              		.loc 1 1936 0
 9644 4d4c 30408DE5 		str	r4, [sp, #48]
1937:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 9645              		.loc 1 1937 0
 9646 4d50 34408DE5 		str	r4, [sp, #52]
1938:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 9647              		.loc 1 1938 0
 9648 4d54 38408DE5 		str	r4, [sp, #56]
1939:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9649              		.loc 1 1939 0
 9650 4d58 3C508DE5 		str	r5, [sp, #60]
1940:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 9651              		.loc 1 1940 0
 9652 4d5c 4040CDE5 		strb	r4, [sp, #64]
1941:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9653              		.loc 1 1941 0
 9654 4d60 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9655              	.LVL1047:
1942:../uvc.c      ****     {
 9656              		.loc 1 1942 0
 9657 4d64 009050E2 		subs	r9, r0, #0
 9658 4d68 C901001A 		bne	.L847
1954:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9659              		.loc 1 1954 0
 9660 4d6c 0500A0E1 		mov	r0, r5
 9661              	.LVL1048:
 9662 4d70 20108DE2 		add	r1, sp, #32
1951:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 9663              		.loc 1 1951 0
 9664 4d74 28408DE5 		str	r4, [sp, #40]
1952:../uvc.c      **** 
 9665              		.loc 1 1952 0
 9666 4d78 24408DE5 		str	r4, [sp, #36]
1949:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 9667              		.loc 1 1949 0
 9668 4d7c B062CDE1 		strh	r6, [sp, #32]	@ movhi
1950:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 9669              		.loc 1 1950 0
 9670 4d80 2C80CDE5 		strb	r8, [sp, #44]
1954:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9671              		.loc 1 1954 0
 9672 4d84 FEFFFFEB 		bl	CyU3PPibInit
 9673              	.LVL1049:
1955:../uvc.c      ****     {
 9674              		.loc 1 1955 0
 9675 4d88 004050E2 		subs	r4, r0, #0
 9676 4d8c A201001A 		bne	.L848
1962:../uvc.c      **** 
 9677              		.loc 1 1962 0
 9678 4d90 64079FE5 		ldr	r0, .L868+8
 9679              	.LVL1050:
 9680 4d94 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 9681              	.LVL1051:
1970:../uvc.c      ****     SensorInit ();
 9682              		.loc 1 1970 0
 9683 4d98 FEFFFFEB 		bl	SensorReset
 9684              	.LVL1052:
1971:../uvc.c      **** 
 9685              		.loc 1 1971 0
 9686 4d9c FEFFFFEB 		bl	SensorInit
 9687              	.LVL1053:
1974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9688              		.loc 1 1974 0
 9689 4da0 FEFFFFEB 		bl	CyU3PUsbStart
 9690              	.LVL1054:
1975:../uvc.c      ****     {
 9691              		.loc 1 1975 0
 9692 4da4 004050E2 		subs	r4, r0, #0
 9693 4da8 9501001A 		bne	.L849
1981:../uvc.c      **** 
 9694              		.loc 1 1981 0
 9695 4dac 0410A0E1 		mov	r1, r4
 9696 4db0 48079FE5 		ldr	r0, .L868+12
 9697              	.LVL1055:
 9698 4db4 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 9699              	.LVL1056:
1984:../uvc.c      **** 
 9700              		.loc 1 1984 0
 9701 4db8 44079FE5 		ldr	r0, .L868+16
 9702 4dbc FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 9703              	.LVL1057:
1990:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 9704              		.loc 1 1990 0
 9705 4dc0 0410A0E1 		mov	r1, r4
 9706 4dc4 3C279FE5 		ldr	r2, .L868+20
 9707 4dc8 0100A0E3 		mov	r0, #1
 9708 4dcc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9709              	.LVL1058:
1991:../uvc.c      **** 
 9710              		.loc 1 1991 0
 9711 4dd0 0410A0E1 		mov	r1, r4
 9712 4dd4 0400A0E1 		mov	r0, r4
 9713 4dd8 2C279FE5 		ldr	r2, .L868+24
 9714 4ddc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9715              	.LVL1059:
1994:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 9716              		.loc 1 1994 0
 9717 4de0 0410A0E1 		mov	r1, r4
 9718 4de4 24279FE5 		ldr	r2, .L868+28
 9719 4de8 0200A0E3 		mov	r0, #2
 9720 4dec FEFFFFEB 		bl	CyU3PUsbSetDesc
 9721              	.LVL1060:
1995:../uvc.c      **** 
 9722              		.loc 1 1995 0
 9723 4df0 0410A0E1 		mov	r1, r4
 9724 4df4 18279FE5 		ldr	r2, .L868+32
 9725 4df8 0700A0E3 		mov	r0, #7
 9726 4dfc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9727              	.LVL1061:
1998:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 9728              		.loc 1 1998 0
 9729 4e00 0410A0E1 		mov	r1, r4
 9730 4e04 0C279FE5 		ldr	r2, .L868+36
 9731 4e08 0400A0E3 		mov	r0, #4
 9732 4e0c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9733              	.LVL1062:
1999:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 9734              		.loc 1 1999 0
 9735 4e10 0410A0E1 		mov	r1, r4
 9736 4e14 00279FE5 		ldr	r2, .L868+40
 9737 4e18 0300A0E3 		mov	r0, #3
 9738 4e1c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9739              	.LVL1063:
2000:../uvc.c      **** 
 9740              		.loc 1 2000 0
 9741 4e20 0410A0E1 		mov	r1, r4
 9742 4e24 F4269FE5 		ldr	r2, .L868+44
 9743 4e28 0600A0E3 		mov	r0, #6
 9744 4e2c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9745              	.LVL1064:
2003:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 9746              		.loc 1 2003 0
 9747 4e30 0410A0E1 		mov	r1, r4
 9748 4e34 E8269FE5 		ldr	r2, .L868+48
 9749 4e38 0500A0E3 		mov	r0, #5
 9750 4e3c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9751              	.LVL1065:
2004:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 9752              		.loc 1 2004 0
 9753 4e40 0110A0E3 		mov	r1, #1
 9754 4e44 DC269FE5 		ldr	r2, .L868+52
 9755 4e48 0500A0E3 		mov	r0, #5
 9756 4e4c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9757              	.LVL1066:
2005:../uvc.c      **** 
 9758              		.loc 1 2005 0
 9759 4e50 0210A0E3 		mov	r1, #2
 9760 4e54 D0269FE5 		ldr	r2, .L868+56
 9761 4e58 0500A0E3 		mov	r0, #5
 9762 4e5c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9763              	.LVL1067:
2012:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 9764              		.loc 1 2012 0
 9765 4e60 0150A0E3 		mov	r5, #1
2013:../uvc.c      ****     endPointConfig.pcktSize = 64;
 9766              		.loc 1 2013 0
 9767 4e64 0320A0E3 		mov	r2, #3
2014:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 9768              		.loc 1 2014 0
 9769 4e68 4030A0E3 		mov	r3, #64
2018:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9770              		.loc 1 2018 0
 9771 4e6c 08108DE2 		add	r1, sp, #8
 9772 4e70 8200A0E3 		mov	r0, #130
2015:../uvc.c      ****     endPointConfig.streams  = 0;
 9773              		.loc 1 2015 0
 9774 4e74 1340CDE5 		strb	r4, [sp, #19]
2016:../uvc.c      ****     endPointConfig.burstLen = 1;
 9775              		.loc 1 2016 0
 9776 4e78 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2012:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 9777              		.loc 1 2012 0
 9778 4e7c 08508DE5 		str	r5, [sp, #8]
2017:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 9779              		.loc 1 2017 0
 9780 4e80 1250CDE5 		strb	r5, [sp, #18]
2013:../uvc.c      ****     endPointConfig.pcktSize = 64;
 9781              		.loc 1 2013 0
 9782 4e84 0C20CDE5 		strb	r2, [sp, #12]
2014:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 9783              		.loc 1 2014 0
 9784 4e88 B031CDE1 		strh	r3, [sp, #16]	@ movhi
2018:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9785              		.loc 1 2018 0
 9786 4e8c FEFFFFEB 		bl	CyU3PSetEpConfig
 9787              	.LVL1068:
2019:../uvc.c      ****     {
 9788              		.loc 1 2019 0
 9789 4e90 004050E2 		subs	r4, r0, #0
2022:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 9790              		.loc 1 2022 0
 9791 4e94 0400A013 		movne	r0, #4
 9792              	.LVL1069:
2019:../uvc.c      ****     {
 9793              		.loc 1 2019 0
 9794 4e98 3D01001A 		bne	.L836
2027:../uvc.c      ****     dmaInterConfig.count          = 1;
 9795              		.loc 1 2027 0
 9796 4e9c 8CC69FE5 		ldr	ip, .L868+60
 9797 4ea0 413BA0E3 		mov	r3, #66560
2036:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 9798              		.loc 1 2036 0
 9799 4ea4 1060A0E3 		mov	r6, #16
2038:../uvc.c      ****             &dmaInterConfig);
 9800              		.loc 1 2038 0
 9801 4ea8 84069FE5 		ldr	r0, .L868+64
 9802 4eac 0410A0E3 		mov	r1, #4
 9803 4eb0 44208DE2 		add	r2, sp, #68
2027:../uvc.c      ****     dmaInterConfig.count          = 1;
 9804              		.loc 1 2027 0
 9805 4eb4 4C408DE5 		str	r4, [sp, #76]
 9806 4eb8 50408DE5 		str	r4, [sp, #80]
2035:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 9807              		.loc 1 2035 0
 9808 4ebc 5440CDE5 		strb	r4, [sp, #84]
2037:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 9809              		.loc 1 2037 0
 9810 4ec0 5C408DE5 		str	r4, [sp, #92]
2027:../uvc.c      ****     dmaInterConfig.count          = 1;
 9811              		.loc 1 2027 0
 9812 4ec4 48C08DE5 		str	ip, [sp, #72]
 9813 4ec8 44308DE5 		str	r3, [sp, #68]
2036:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 9814              		.loc 1 2036 0
 9815 4ecc 58608DE5 		str	r6, [sp, #88]
2038:../uvc.c      ****             &dmaInterConfig);
 9816              		.loc 1 2038 0
 9817 4ed0 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 9818              	.LVL1070:
2040:../uvc.c      ****     {
 9819              		.loc 1 2040 0
 9820 4ed4 004050E2 		subs	r4, r0, #0
 9821 4ed8 4301001A 		bne	.L850
2047:../uvc.c      ****     if (glInterStaBuffer == 0)
 9822              		.loc 1 2047 0
 9823 4edc 010BA0E3 		mov	r0, #1024
 9824              	.LVL1071:
 9825 4ee0 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 9826              	.LVL1072:
 9827 4ee4 4C369FE5 		ldr	r3, .L868+68
2048:../uvc.c      ****     {
 9828              		.loc 1 2048 0
 9829 4ee8 000050E3 		cmp	r0, #0
2047:../uvc.c      ****     if (glInterStaBuffer == 0)
 9830              		.loc 1 2047 0
 9831 4eec 000083E5 		str	r0, [r3]
2048:../uvc.c      ****     {
 9832              		.loc 1 2048 0
 9833 4ef0 3801000A 		beq	.L851
2055:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 9834              		.loc 1 2055 0
 9835 4ef4 0410A0E1 		mov	r1, r4
 9836 4ef8 0420A0E1 		mov	r2, r4
 9837 4efc 3830A0E3 		mov	r3, #56
 9838 4f00 34069FE5 		ldr	r0, .L868+72
 9839 4f04 FEFFFFEB 		bl	_txe_mutex_create
 9840              	.LVL1073:
2060:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 9841              		.loc 1 2060 0
 9842 4f08 30169FE5 		ldr	r1, .L868+76
2061:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 9843              		.loc 1 2061 0
 9844 4f0c 30269FE5 		ldr	r2, .L868+80
2068:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 9845              		.loc 1 2068 0
 9846 4f10 30A69FE5 		ldr	r10, .L868+84
2057:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 9847              		.loc 1 2057 0
 9848 4f14 0460A0E3 		mov	r6, #4
2059:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 9849              		.loc 1 2059 0
 9850 4f18 01ECA0E3 		mov	lr, #256
2063:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 9851              		.loc 1 2063 0
 9852 4f1c 0CC0A0E3 		mov	ip, #12
2067:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 9853              		.loc 1 2067 0
 9854 4f20 1830A0E3 		mov	r3, #24
2060:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 9855              		.loc 1 2060 0
 9856 4f24 B816CDE1 		strh	r1, [sp, #104]	@ movhi
2061:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 9857              		.loc 1 2061 0
 9858 4f28 BE26CDE1 		strh	r2, [sp, #110]	@ movhi
2056:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 9859              		.loc 1 2056 0
 9860 4f2c 0199A0E3 		mov	r9, #16384
2058:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 9861              		.loc 1 2058 0
 9862 4f30 0280A0E3 		mov	r8, #2
2069:../uvc.c      ****             &dmaMultiConfig);
 9863              		.loc 1 2069 0
 9864 4f34 10069FE5 		ldr	r0, .L868+88
 9865 4f38 0710A0E3 		mov	r1, #7
 9866 4f3c 60208DE2 		add	r2, sp, #96
2062:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 9867              		.loc 1 2062 0
 9868 4f40 B647CDE1 		strh	r4, [sp, #118]	@ movhi
2065:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 9869              		.loc 1 2065 0
 9870 4f44 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
2066:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 9871              		.loc 1 2066 0
 9872 4f48 7E40CDE5 		strb	r4, [sp, #126]
2068:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 9873              		.loc 1 2068 0
 9874 4f4c 84A08DE5 		str	r10, [sp, #132]
2056:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 9875              		.loc 1 2056 0
 9876 4f50 B096CDE1 		strh	r9, [sp, #96]	@ movhi
2057:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 9877              		.loc 1 2057 0
 9878 4f54 B266CDE1 		strh	r6, [sp, #98]	@ movhi
2064:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 9879              		.loc 1 2064 0
 9880 4f58 BA67CDE1 		strh	r6, [sp, #122]	@ movhi
2058:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 9881              		.loc 1 2058 0
 9882 4f5c B486CDE1 		strh	r8, [sp, #100]	@ movhi
2059:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 9883              		.loc 1 2059 0
 9884 4f60 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
2063:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 9885              		.loc 1 2063 0
 9886 4f64 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
2067:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 9887              		.loc 1 2067 0
 9888 4f68 80308DE5 		str	r3, [sp, #128]
2069:../uvc.c      ****             &dmaMultiConfig);
 9889              		.loc 1 2069 0
 9890 4f6c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 9891              	.LVL1074:
2071:../uvc.c      ****     {
 9892              		.loc 1 2071 0
 9893 4f70 004050E2 		subs	r4, r0, #0
 9894 4f74 1101001A 		bne	.L852
2162:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9895              		.loc 1 2162 0
 9896 4f78 0500A0E1 		mov	r0, r5
 9897              	.LVL1075:
 9898 4f7c 0510A0E1 		mov	r1, r5
 9899 4f80 FEFFFFEB 		bl	CyU3PConnectState
 9900              	.LVL1076:
2163:../uvc.c      ****     {
 9901              		.loc 1 2163 0
 9902 4f84 004050E2 		subs	r4, r0, #0
 9903 4f88 0601001A 		bne	.L853
2169:../uvc.c      **** 
 9904              		.loc 1 2169 0
 9905 4f8c 6400A0E3 		mov	r0, #100
 9906              	.LVL1077:
 9907 4f90 FEFFFFEB 		bl	CyFx3BusyWait
 9908              	.LVL1078:
2171:../uvc.c      **** 
 9909              		.loc 1 2171 0
 9910 4f94 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 9911              	.LVL1079:
2186:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9912              		.loc 1 2186 0
 9913 4f98 08108DE2 		add	r1, sp, #8
2185:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 9914              		.loc 1 2185 0
 9915 4f9c BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2173:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 9916              		.loc 1 2173 0
 9917 4fa0 08508DE5 		str	r5, [sp, #8]
2174:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 9918              		.loc 1 2174 0
 9919 4fa4 0C80CDE5 		strb	r8, [sp, #12]
2178:../uvc.c      ****     }
 9920              		.loc 1 2178 0
 9921 4fa8 030050E3 		cmp	r0, #3
2171:../uvc.c      **** 
 9922              		.loc 1 2171 0
 9923 4fac 0030A0E1 		mov	r3, r0
2178:../uvc.c      ****     }
 9924              		.loc 1 2178 0
 9925 4fb0 01C0A013 		movne	ip, #1
 9926 4fb4 10C0A003 		moveq	ip, #16
 9927 4fb8 022CA013 		movne	r2, #512
 9928 4fbc 012BA003 		moveq	r2, #1024
2186:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9929              		.loc 1 2186 0
 9930 4fc0 8300A0E3 		mov	r0, #131
2171:../uvc.c      **** 
 9931              		.loc 1 2171 0
 9932 4fc4 C030C7E5 		strb	r3, [r7, #192]
 9933 4fc8 12C0CDE5 		strb	ip, [sp, #18]
 9934 4fcc B021CDE1 		strh	r2, [sp, #16]	@ movhi
2186:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9935              		.loc 1 2186 0
 9936 4fd0 FEFFFFEB 		bl	CyU3PSetEpConfig
 9937              	.LVL1080:
2187:../uvc.c      ****     {
 9938              		.loc 1 2187 0
 9939 4fd4 004050E2 		subs	r4, r0, #0
 9940              	.LBE499:
 9941              	.LBE502:
2308:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9942              		.loc 1 2308 0
 9943 4fd8 18459F05 		ldreq	r4, .L868+4
 9944              	.LBB503:
 9945              	.LBB500:
2187:../uvc.c      ****     {
 9946              		.loc 1 2187 0
 9947 4fdc 0C00000A 		beq	.L823
 9948 4fe0 EA0000EA 		b	.L867
 9949              	.LVL1081:
 9950              	.L856:
 9951              	.LBE500:
 9952              	.LBE503:
2354:../uvc.c      ****             {
 9953              		.loc 1 2354 0
 9954 4fe4 783094E5 		ldr	r3, [r4, #120]
 9955 4fe8 050053E1 		cmp	r3, r5
 9956 4fec 0300000A 		beq	.L804
2354:../uvc.c      ****             {
 9957              		.loc 1 2354 0 is_stmt 0 discriminator 1
 9958 4ff0 BC27D4E1 		ldrh	r2, [r4, #124]
 9959 4ff4 BE37D4E1 		ldrh	r3, [r4, #126]
 9960 4ff8 030052E1 		cmp	r2, r3
 9961 4ffc 3B00000A 		beq	.L855
 9962              	.L804:
2528:../uvc.c      **** 
 9963              		.loc 1 2528 0 is_stmt 1
 9964 5000 4010A0E3 		mov	r1, #64
 9965 5004 0020A0E3 		mov	r2, #0
 9966 5008 E8049FE5 		ldr	r0, .L868+4
 9967 500c FEFFFFEB 		bl	_txe_event_flags_set
 9968              	.LVL1082:
2531:../uvc.c      ****     }
 9969              		.loc 1 2531 0
 9970 5010 FEFFFFEB 		bl	_txe_thread_relinquish
 9971              	.LVL1083:
 9972              	.L823:
2308:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9973              		.loc 1 2308 0
 9974 5014 0050A0E3 		mov	r5, #0
 9975 5018 00508DE5 		str	r5, [sp]
 9976 501c D4049FE5 		ldr	r0, .L868+4
 9977 5020 0110A0E3 		mov	r1, #1
 9978 5024 0220A0E3 		mov	r2, #2
 9979 5028 60308DE2 		add	r3, sp, #96
 9980 502c FEFFFFEB 		bl	_txe_event_flags_get
 9981              	.LVL1084:
 9982 5030 006050E2 		subs	r6, r0, #0
 9983 5034 EAFFFF0A 		beq	.L856
2455:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9984              		.loc 1 2455 0
 9985 5038 00508DE5 		str	r5, [sp]
 9986 503c B4049FE5 		ldr	r0, .L868+4
 9987 5040 0210A0E3 		mov	r1, #2
 9988 5044 0320A0E3 		mov	r2, #3
 9989 5048 60308DE2 		add	r3, sp, #96
 9990 504c FEFFFFEB 		bl	_txe_event_flags_get
 9991              	.LVL1085:
 9992 5050 000050E3 		cmp	r0, #0
 9993 5054 0B00001A 		bne	.L815
2470:../uvc.c      ****                 {
 9994              		.loc 1 2470 0
 9995 5058 8C3094E5 		ldr	r3, [r4, #140]
2458:../uvc.c      ****                 prodCount = 0;
 9996              		.loc 1 2458 0
 9997 505c 780084E5 		str	r0, [r4, #120]
2470:../uvc.c      ****                 {
 9998              		.loc 1 2470 0
 9999 5060 000053E3 		cmp	r3, #0
2459:../uvc.c      ****                 consCount = 0;
 10000              		.loc 1 2459 0
 10001 5064 BC07C4E1 		strh	r0, [r4, #124]	@ movhi
2466:../uvc.c      ****                 pb=0;
 10002              		.loc 1 2466 0
 10003 5068 BC06C4E1 		strh	r0, [r4, #108]	@ movhi
2460:../uvc.c      ****                 if(0&&(prinflag == 0)){
 10004              		.loc 1 2460 0
 10005 506c BE07C4E1 		strh	r0, [r4, #126]	@ movhi
2467:../uvc.c      ****                 pbc=0;
 10006              		.loc 1 2467 0
 10007 5070 BE06C4E1 		strh	r0, [r4, #110]	@ movhi
2468:../uvc.c      **** 
 10008              		.loc 1 2468 0
 10009 5074 B007C4E1 		strh	r0, [r4, #112]	@ movhi
2470:../uvc.c      ****                 {
 10010              		.loc 1 2470 0
 10011 5078 4600000A 		beq	.L857
 10012              	.L816:
2482:../uvc.c      ****             }
 10013              		.loc 1 2482 0
 10014 507c 0030A0E3 		mov	r3, #0
 10015 5080 8C3087E5 		str	r3, [r7, #140]
 10016 5084 DDFFFFEA 		b	.L804
 10017              	.L815:
2487:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 10018              		.loc 1 2487 0
 10019 5088 0030E0E3 		mvn	r3, #0
 10020 508c 00308DE5 		str	r3, [sp]
 10021 5090 0110A0E3 		mov	r1, #1
 10022 5094 0220A0E3 		mov	r2, #2
 10023 5098 60308DE2 		add	r3, sp, #96
 10024 509c 54049FE5 		ldr	r0, .L868+4
 10025 50a0 FEFFFFEB 		bl	_txe_event_flags_get
 10026              	.LVL1086:
2491:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 10027              		.loc 1 2491 0
 10028 50a4 0510A0E1 		mov	r1, r5
 10029 50a8 0520A0E1 		mov	r2, r5
 10030 50ac 98049FE5 		ldr	r0, .L868+88
 10031 50b0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 10032              	.LVL1087:
2492:../uvc.c      ****                 {
 10033              		.loc 1 2492 0
 10034 50b4 005050E2 		subs	r5, r0, #0
 10035 50b8 9300001A 		bne	.L858
2500:../uvc.c      ****                 {
 10036              		.loc 1 2500 0
 10037 50bc 843094E5 		ldr	r3, [r4, #132]
 10038 50c0 000053E3 		cmp	r3, #0
 10039 50c4 2B00001A 		bne	.L814
 10040              	.LVL1088:
 10041              	.LBB504:
 10042              	.LBB505:
2215:../uvc.c      ****     {
 10043              		.loc 1 2215 0
 10044 50c8 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 10045 50cc 030053E3 		cmp	r3, #3
 10046 50d0 6800000A 		beq	.L859
2220:../uvc.c      ****     {
 10047              		.loc 1 2220 0
 10048 50d4 020053E3 		cmp	r3, #2
 10049 50d8 7E00000A 		beq	.L860
 10050              	.LVL1089:
 10051              	.L821:
 10052              	.LBE505:
 10053              	.LBE504:
2516:../uvc.c      ****                     CyU3PThreadSleep(200);
 10054              		.loc 1 2516 0
 10055 50dc 0130A0E3 		mov	r3, #1
2517:../uvc.c      ****                     
 10056              		.loc 1 2517 0
 10057 50e0 C800A0E3 		mov	r0, #200
2516:../uvc.c      ****                     CyU3PThreadSleep(200);
 10058              		.loc 1 2516 0
 10059 50e4 843087E5 		str	r3, [r7, #132]
2517:../uvc.c      ****                     
 10060              		.loc 1 2517 0
 10061 50e8 FEFFFFEB 		bl	_tx_thread_sleep
 10062              	.LVL1090:
 10063 50ec C3FFFFEA 		b	.L804
 10064              	.L855:
2380:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 10065              		.loc 1 2380 0
 10066 50f0 58549FE5 		ldr	r5, .L868+92
2379:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 10067              		.loc 1 2379 0
 10068 50f4 40049FE5 		ldr	r0, .L868+72
 10069 50f8 0010E0E3 		mvn	r1, #0
2364:../uvc.c      ****                 consCount = 0;
 10070              		.loc 1 2364 0
 10071 50fc BC67C4E1 		strh	r6, [r4, #124]	@ movhi
2361:../uvc.c      ****             	pb=0;
 10072              		.loc 1 2361 0
 10073 5100 BC66C4E1 		strh	r6, [r4, #108]	@ movhi
2365:../uvc.c      ****                 hitFV     = CyFalse;
 10074              		.loc 1 2365 0
 10075 5104 BE67C4E1 		strh	r6, [r4, #126]	@ movhi
2362:../uvc.c      ****             	pbc=0;
 10076              		.loc 1 2362 0
 10077 5108 BE66C4E1 		strh	r6, [r4, #110]	@ movhi
2363:../uvc.c      ****                 prodCount = 0;
 10078              		.loc 1 2363 0
 10079 510c B067C4E1 		strh	r6, [r4, #112]	@ movhi
2366:../uvc.c      **** 
 10080              		.loc 1 2366 0
 10081 5110 786084E5 		str	r6, [r4, #120]
2379:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 10082              		.loc 1 2379 0
 10083 5114 FEFFFFEB 		bl	_txe_mutex_get
 10084              	.LVL1091:
2380:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 10085              		.loc 1 2380 0
 10086 5118 8134D5E5 		ldrb	r3, [r5, #1153]	@ zero_extendqisi2
 10087 511c 013023E2 		eor	r3, r3, #1
 10088 5120 8134C5E5 		strb	r3, [r5, #1153]
2382:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 10089              		.loc 1 2382 0
 10090 5124 743094E5 		ldr	r3, [r4, #116]
 10091 5128 F00053E3 		cmp	r3, #240
 10092 512c 4500000A 		beq	.L861
 10093              	.L805:
2390:../uvc.c      **** 
 10094              		.loc 1 2390 0
 10095 5130 743097E5 		ldr	r3, [r7, #116]
 10096 5134 FF0053E3 		cmp	r3, #255
 10097 5138 1D00000A 		beq	.L862
2402:../uvc.c      ****                     //CyU3PThreadSleep(400);
 10098              		.loc 1 2402 0
 10099 513c 743094E5 		ldr	r3, [r4, #116]
 10100 5140 AA0053E3 		cmp	r3, #170
 10101 5144 2700000A 		beq	.L863
 10102              	.L806:
2430:../uvc.c      ****                 /* Reset the DMA channel. */
 10103              		.loc 1 2430 0
 10104 5148 EC039FE5 		ldr	r0, .L868+72
 10105 514c FEFFFFEB 		bl	_txe_mutex_put
 10106              	.LVL1092:
2432:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 10107              		.loc 1 2432 0
 10108 5150 F4039FE5 		ldr	r0, .L868+88
 10109 5154 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 10110              	.LVL1093:
2433:../uvc.c      ****                 {
 10111              		.loc 1 2433 0
 10112 5158 005050E2 		subs	r5, r0, #0
 10113 515c 7A00001A 		bne	.L864
2440:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 10114              		.loc 1 2440 0
 10115 5160 0510A0E1 		mov	r1, r5
 10116 5164 0520A0E1 		mov	r2, r5
 10117 5168 DC039FE5 		ldr	r0, .L868+88
 10118              	.LVL1094:
 10119 516c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 10120              	.LVL1095:
2441:../uvc.c      ****                 {
 10121              		.loc 1 2441 0
 10122 5170 005050E2 		subs	r5, r0, #0
 10123 5174 5E00001A 		bne	.L865
 10124              	.L814:
2449:../uvc.c      ****                 }
 10125              		.loc 1 2449 0
 10126 5178 C0039FE5 		ldr	r0, .L868+76
 10127              	.LVL1096:
 10128 517c 0230A0E3 		mov	r3, #2
 10129 5180 0010A0E3 		mov	r1, #0
 10130 5184 00308DE5 		str	r3, [sp]
 10131 5188 0020A0E1 		mov	r2, r0
 10132 518c 0130A0E1 		mov	r3, r1
 10133 5190 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 10134              	.LVL1097:
 10135 5194 99FFFFEA 		b	.L804
 10136              	.LVL1098:
 10137              	.L857:
2472:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 10138              		.loc 1 2472 0
 10139 5198 AC039FE5 		ldr	r0, .L868+88
 10140 519c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 10141              	.LVL1099:
2473:../uvc.c      ****                     {
 10142              		.loc 1 2473 0
 10143 51a0 000050E3 		cmp	r0, #0
 10144 51a4 4A00001A 		bne	.L838
2479:../uvc.c      ****                 }
 10145              		.loc 1 2479 0
 10146 51a8 8300A0E3 		mov	r0, #131
 10147              	.LVL1100:
 10148 51ac FEFFFFEB 		bl	CyU3PUsbFlushEp
 10149              	.LVL1101:
 10150 51b0 B1FFFFEA 		b	.L816
 10151              	.L862:
2392:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 10152              		.loc 1 2392 0
 10153 51b4 E530D4E5 		ldrb	r3, [r4, #229]	@ zero_extendqisi2
 10154 51b8 020053E3 		cmp	r3, #2
 10155 51bc 013083E2 		add	r3, r3, #1
 10156 51c0 E530C4E5 		strb	r3, [r4, #229]
 10157 51c4 DFFFFF9A 		bls	.L806
2393:../uvc.c      ****                 		stiflag = 0x0F;
 10158              		.loc 1 2393 0
 10159 51c8 8114D5E5 		ldrb	r1, [r5, #1153]	@ zero_extendqisi2
2394:../uvc.c      ****                 		IMcount = 0;
 10160              		.loc 1 2394 0
 10161 51cc 0F30A0E3 		mov	r3, #15
2393:../uvc.c      ****                 		stiflag = 0x0F;
 10162              		.loc 1 2393 0
 10163 51d0 201081E3 		orr	r1, r1, #32
2395:../uvc.c      ****                 		}
 10164              		.loc 1 2395 0
 10165 51d4 0020A0E3 		mov	r2, #0
2393:../uvc.c      ****                 		stiflag = 0x0F;
 10166              		.loc 1 2393 0
 10167 51d8 8114C5E5 		strb	r1, [r5, #1153]
2395:../uvc.c      ****                 		}
 10168              		.loc 1 2395 0
 10169 51dc E520C4E5 		strb	r2, [r4, #229]
2394:../uvc.c      ****                 		IMcount = 0;
 10170              		.loc 1 2394 0
 10171 51e0 743084E5 		str	r3, [r4, #116]
 10172 51e4 D7FFFFEA 		b	.L806
 10173              	.L863:
2408:../uvc.c      ****                 	{
 10174              		.loc 1 2408 0
 10175 51e8 E530D4E5 		ldrb	r3, [r4, #229]	@ zero_extendqisi2
 10176 51ec 020053E3 		cmp	r3, #2
 10177 51f0 013083E2 		add	r3, r3, #1
 10178 51f4 E530C4E5 		strb	r3, [r4, #229]
 10179 51f8 D2FFFF9A 		bls	.L806
2410:../uvc.c      ****                      {
 10180              		.loc 1 2410 0
 10181 51fc E420D4E5 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 10182 5200 010052E3 		cmp	r2, #1
 10183 5204 4600000A 		beq	.L811
 10184 5208 020052E3 		cmp	r2, #2
 10185 520c 0900001A 		bne	.L810
2418:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 10186              		.loc 1 2418 0
 10187 5210 3010A0E3 		mov	r1, #48
 10188 5214 0020A0E3 		mov	r2, #0
 10189 5218 5230A0E3 		mov	r3, #82
 10190 521c 0B00A0E3 		mov	r0, #11
 10191 5220 FEFFFFEB 		bl	SensorSetIrisControl
 10192              	.LVL1102:
2420:../uvc.c      ****                  		break;
 10193              		.loc 1 2420 0
 10194 5224 0400A0E3 		mov	r0, #4
 10195 5228 24139FE5 		ldr	r1, .L868+96
 10196 522c 0B20A0E3 		mov	r2, #11
 10197 5230 0130A0E3 		mov	r3, #1
 10198 5234 FEFFFFEB 		bl	CyU3PDebugPrint
 10199              	.LVL1103:
 10200              	.L810:
2425:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 10201              		.loc 1 2425 0
 10202 5238 0030A0E3 		mov	r3, #0
 10203 523c E530C7E5 		strb	r3, [r7, #229]
2427:../uvc.c      ****                 	}
 10204              		.loc 1 2427 0
 10205 5240 743087E5 		str	r3, [r7, #116]
 10206 5244 BFFFFFEA 		b	.L806
 10207              	.L861:
2382:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 10208              		.loc 1 2382 0 discriminator 1
 10209 5248 00608DE5 		str	r6, [sp]
 10210 524c A4029FE5 		ldr	r0, .L868+4
 10211 5250 8010A0E3 		mov	r1, #128
 10212 5254 0320A0E3 		mov	r2, #3
 10213 5258 60308DE2 		add	r3, sp, #96
 10214 525c FEFFFFEB 		bl	_txe_event_flags_get
 10215              	.LVL1104:
 10216 5260 000050E3 		cmp	r0, #0
 10217 5264 B1FFFF1A 		bne	.L805
2387:../uvc.c      ****                 		IMcount = 0;
 10218              		.loc 1 2387 0
 10219 5268 FF30A0E3 		mov	r3, #255
2388:../uvc.c      ****                 	}
 10220              		.loc 1 2388 0
 10221 526c E500C4E5 		strb	r0, [r4, #229]
2387:../uvc.c      ****                 		IMcount = 0;
 10222              		.loc 1 2387 0
 10223 5270 743084E5 		str	r3, [r4, #116]
2388:../uvc.c      ****                 	}
 10224              		.loc 1 2388 0
 10225 5274 B3FFFFEA 		b	.L806
 10226              	.LVL1105:
 10227              	.L859:
 10228              	.LBB508:
 10229              	.LBB506:
2217:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 10230              		.loc 1 2217 0
 10231 5278 D8129FE5 		ldr	r1, .L868+100
 10232 527c 0100A0E3 		mov	r0, #1
 10233              	.LVL1106:
 10234 5280 FEFFFFEB 		bl	CyU3PDebugPrint
 10235              	.LVL1107:
2218:../uvc.c      ****     }
 10236              		.loc 1 2218 0
 10237 5284 D0029FE5 		ldr	r0, .L868+104
 10238 5288 FEFFFFEB 		bl	CyU3PGpifLoad
 10239              	.LVL1108:
 10240 528c 0050A0E1 		mov	r5, r0
 10241              	.LVL1109:
 10242              	.L820:
2225:../uvc.c      ****     {
 10243              		.loc 1 2225 0
 10244 5290 000055E3 		cmp	r5, #0
 10245 5294 3700001A 		bne	.L866
 10246              	.LVL1110:
2237:../uvc.c      ****     {
 10247              		.loc 1 2237 0
 10248 5298 C030D7E5 		ldrb	r3, [r7, #192]	@ zero_extendqisi2
 10249 529c 023043E2 		sub	r3, r3, #2
 10250 52a0 FF3003E2 		and	r3, r3, #255
 10251 52a4 010053E3 		cmp	r3, #1
 10252 52a8 8BFFFF8A 		bhi	.L821
2235:../uvc.c      ****     }
 10253              		.loc 1 2235 0
 10254 52ac 0500A0E1 		mov	r0, r5
 10255 52b0 0510A0E1 		mov	r1, r5
 10256 52b4 FEFFFFEB 		bl	CyU3PGpifSMStart
 10257              	.LVL1111:
2241:../uvc.c      ****     {
 10258              		.loc 1 2241 0
 10259 52b8 005050E2 		subs	r5, r0, #0
 10260 52bc 86FFFF0A 		beq	.L821
2244:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10261              		.loc 1 2244 0
 10262 52c0 0400A0E3 		mov	r0, #4
 10263              	.LVL1112:
 10264 52c4 94129FE5 		ldr	r1, .L868+108
 10265 52c8 0520A0E1 		mov	r2, r5
 10266 52cc FEFFFFEB 		bl	CyU3PDebugPrint
 10267              	.LVL1113:
2245:../uvc.c      ****     }
 10268              		.loc 1 2245 0
 10269 52d0 0500A0E1 		mov	r0, r5
 10270              	.LVL1114:
 10271              	.L838:
2229:../uvc.c      ****     }
 10272              		.loc 1 2229 0
 10273 52d4 FEFFFFEB 		bl	CyFxAppErrorHandler
 10274              	.LVL1115:
 10275              	.L860:
2222:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 10276              		.loc 1 2222 0
 10277 52d8 84129FE5 		ldr	r1, .L868+112
 10278 52dc 0100A0E3 		mov	r0, #1
 10279              	.LVL1116:
 10280 52e0 FEFFFFEB 		bl	CyU3PDebugPrint
 10281              	.LVL1117:
2223:../uvc.c      ****     }
 10282              		.loc 1 2223 0
 10283 52e4 7C029FE5 		ldr	r0, .L868+116
 10284 52e8 FEFFFFEB 		bl	CyU3PGpifLoad
 10285              	.LVL1118:
 10286 52ec 0050A0E1 		mov	r5, r0
 10287              	.LVL1119:
 10288 52f0 E6FFFFEA 		b	.L820
 10289              	.LVL1120:
 10290              	.L865:
 10291              	.LBE506:
 10292              	.LBE508:
2443:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10293              		.loc 1 2443 0
 10294 52f4 0400A0E3 		mov	r0, #4
 10295              	.LVL1121:
 10296 52f8 6C129FE5 		ldr	r1, .L868+120
 10297 52fc 0520A0E1 		mov	r2, r5
 10298 5300 FEFFFFEB 		bl	CyU3PDebugPrint
 10299              	.LVL1122:
2444:../uvc.c      ****                 }
 10300              		.loc 1 2444 0
 10301 5304 0500A0E1 		mov	r0, r5
 10302 5308 FEFFFFEB 		bl	CyFxAppErrorHandler
 10303              	.LVL1123:
 10304              	.L858:
2495:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10305              		.loc 1 2495 0
 10306 530c 0400A0E3 		mov	r0, #4
 10307              	.LVL1124:
 10308 5310 58129FE5 		ldr	r1, .L868+124
 10309 5314 0520A0E1 		mov	r2, r5
 10310 5318 FEFFFFEB 		bl	CyU3PDebugPrint
 10311              	.LVL1125:
2496:../uvc.c      ****                 }
 10312              		.loc 1 2496 0
 10313 531c 0500A0E1 		mov	r0, r5
 10314 5320 FEFFFFEB 		bl	CyFxAppErrorHandler
 10315              	.LVL1126:
 10316              	.L811:
2413:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 10317              		.loc 1 2413 0
 10318 5324 3010A0E3 		mov	r1, #48
 10319 5328 5230A0E3 		mov	r3, #82
 10320 532c 0B00A0E3 		mov	r0, #11
 10321 5330 FEFFFFEB 		bl	SensorSetIrisControl
 10322              	.LVL1127:
2415:../uvc.c      ****                  		break;
 10323              		.loc 1 2415 0
 10324 5334 18129FE5 		ldr	r1, .L868+96
 10325 5338 0B20A0E3 		mov	r2, #11
 10326 533c 0030A0E3 		mov	r3, #0
 10327 5340 0400A0E3 		mov	r0, #4
 10328 5344 FEFFFFEB 		bl	CyU3PDebugPrint
 10329              	.LVL1128:
2416:../uvc.c      ****                  	case 2: //960
 10330              		.loc 1 2416 0
 10331 5348 BAFFFFEA 		b	.L810
 10332              	.LVL1129:
 10333              	.L864:
2435:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10334              		.loc 1 2435 0
 10335 534c 0400A0E3 		mov	r0, #4
 10336              	.LVL1130:
 10337 5350 1C129FE5 		ldr	r1, .L868+128
 10338 5354 0520A0E1 		mov	r2, r5
 10339 5358 FEFFFFEB 		bl	CyU3PDebugPrint
 10340              	.LVL1131:
2436:../uvc.c      ****                 }
 10341              		.loc 1 2436 0
 10342 535c 0500A0E1 		mov	r0, r5
 10343 5360 FEFFFFEB 		bl	CyFxAppErrorHandler
 10344              	.LVL1132:
 10345              	.L839:
 10346              	.LBB509:
 10347              	.LBB496:
1724:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10348              		.loc 1 1724 0
 10349 5364 0400A0E3 		mov	r0, #4
 10350              	.LVL1133:
 10351 5368 08129FE5 		ldr	r1, .L868+132
 10352 536c FEFFFFEB 		bl	CyU3PDebugPrint
 10353              	.LVL1134:
1725:../uvc.c      ****     }
 10354              		.loc 1 1725 0
 10355 5370 0400A0E1 		mov	r0, r4
 10356 5374 FEFFFFEB 		bl	CyFxAppErrorHandler
 10357              	.LVL1135:
 10358              	.L866:
 10359              	.LBE496:
 10360              	.LBE509:
 10361              	.LBB510:
 10362              	.LBB507:
2228:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10363              		.loc 1 2228 0
 10364 5378 0400A0E3 		mov	r0, #4
 10365              	.LVL1136:
 10366 537c F8119FE5 		ldr	r1, .L868+136
 10367 5380 0520A0E1 		mov	r2, r5
 10368 5384 FEFFFFEB 		bl	CyU3PDebugPrint
 10369              	.LVL1137:
2229:../uvc.c      ****     }
 10370              		.loc 1 2229 0
 10371 5388 0500A0E1 		mov	r0, r5
 10372 538c D0FFFFEA 		b	.L838
 10373              	.LVL1138:
 10374              	.L867:
 10375              	.LBE507:
 10376              	.LBE510:
 10377              	.LBB511:
 10378              	.LBB501:
2190:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10379              		.loc 1 2190 0
 10380 5390 0600A0E1 		mov	r0, r6
 10381              	.LVL1139:
 10382              	.L836:
 10383 5394 E4119FE5 		ldr	r1, .L868+140
 10384 5398 0420A0E1 		mov	r2, r4
 10385 539c FEFFFFEB 		bl	CyU3PDebugPrint
 10386              	.LVL1140:
2191:../uvc.c      ****     }
 10387              		.loc 1 2191 0
 10388 53a0 0400A0E1 		mov	r0, r4
 10389 53a4 CAFFFFEA 		b	.L838
 10390              	.LVL1141:
 10391              	.L853:
2165:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10392              		.loc 1 2165 0
 10393 53a8 0600A0E1 		mov	r0, r6
 10394              	.LVL1142:
 10395 53ac D0119FE5 		ldr	r1, .L868+144
 10396 53b0 0420A0E1 		mov	r2, r4
 10397 53b4 FEFFFFEB 		bl	CyU3PDebugPrint
 10398              	.LVL1143:
2166:../uvc.c      ****     }
 10399              		.loc 1 2166 0
 10400 53b8 0400A0E1 		mov	r0, r4
 10401 53bc FEFFFFEB 		bl	CyFxAppErrorHandler
 10402              	.LVL1144:
 10403              	.L852:
2074:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10404              		.loc 1 2074 0
 10405 53c0 0600A0E1 		mov	r0, r6
 10406              	.LVL1145:
 10407 53c4 BC119FE5 		ldr	r1, .L868+148
 10408 53c8 0420A0E1 		mov	r2, r4
 10409 53cc FEFFFFEB 		bl	CyU3PDebugPrint
 10410              	.LVL1146:
2075:../uvc.c      ****     }
 10411              		.loc 1 2075 0
 10412 53d0 0400A0E1 		mov	r0, r4
 10413 53d4 FEFFFFEB 		bl	CyFxAppErrorHandler
 10414              	.LVL1147:
 10415              	.L851:
2050:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 10416              		.loc 1 2050 0
 10417 53d8 0400A0E3 		mov	r0, #4
 10418 53dc A8119FE5 		ldr	r1, .L868+152
 10419 53e0 FEFFFFEB 		bl	CyU3PDebugPrint
 10420              	.LVL1148:
2051:../uvc.c      ****     }
 10421              		.loc 1 2051 0
 10422 53e4 0600A0E1 		mov	r0, r6
 10423 53e8 FEFFFFEB 		bl	CyFxAppErrorHandler
 10424              	.LVL1149:
 10425              	.L850:
2043:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10426              		.loc 1 2043 0
 10427 53ec 0400A0E3 		mov	r0, #4
 10428              	.LVL1150:
 10429 53f0 98119FE5 		ldr	r1, .L868+156
 10430 53f4 0420A0E1 		mov	r2, r4
 10431 53f8 FEFFFFEB 		bl	CyU3PDebugPrint
 10432              	.LVL1151:
2044:../uvc.c      ****     }
 10433              		.loc 1 2044 0
 10434 53fc 0400A0E1 		mov	r0, r4
 10435 5400 FEFFFFEB 		bl	CyFxAppErrorHandler
 10436              	.LVL1152:
 10437              	.L849:
1977:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10438              		.loc 1 1977 0
 10439 5404 0400A0E3 		mov	r0, #4
 10440              	.LVL1153:
 10441 5408 84119FE5 		ldr	r1, .L868+160
 10442 540c 0420A0E1 		mov	r2, r4
 10443 5410 FEFFFFEB 		bl	CyU3PDebugPrint
 10444              	.LVL1154:
1978:../uvc.c      ****     }
 10445              		.loc 1 1978 0
 10446 5414 0400A0E1 		mov	r0, r4
 10447 5418 FEFFFFEB 		bl	CyFxAppErrorHandler
 10448              	.LVL1155:
 10449              	.L848:
1957:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10450              		.loc 1 1957 0
 10451 541c 0400A0E3 		mov	r0, #4
 10452              	.LVL1156:
 10453 5420 70119FE5 		ldr	r1, .L868+164
 10454 5424 0420A0E1 		mov	r2, r4
 10455 5428 FEFFFFEB 		bl	CyU3PDebugPrint
 10456              	.LVL1157:
1958:../uvc.c      ****     }
 10457              		.loc 1 1958 0
 10458 542c 0400A0E1 		mov	r0, r4
 10459 5430 FEFFFFEB 		bl	CyFxAppErrorHandler
 10460              	.LVL1158:
 10461              	.L843:
1897:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10462              		.loc 1 1897 0
 10463 5434 0400A0E3 		mov	r0, #4
 10464              	.LVL1159:
 10465 5438 5C119FE5 		ldr	r1, .L868+168
 10466 543c 0520A0E1 		mov	r2, r5
 10467 5440 FEFFFFEB 		bl	CyU3PDebugPrint
 10468              	.LVL1160:
1898:../uvc.c      ****     }
 10469              		.loc 1 1898 0
 10470 5444 0500A0E1 		mov	r0, r5
 10471 5448 FEFFFFEB 		bl	CyFxAppErrorHandler
 10472              	.LVL1161:
 10473              	.L842:
1891:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10474              		.loc 1 1891 0
 10475 544c 0400A0E3 		mov	r0, #4
 10476              	.LVL1162:
 10477 5450 48119FE5 		ldr	r1, .L868+172
 10478 5454 0520A0E1 		mov	r2, r5
 10479 5458 FEFFFFEB 		bl	CyU3PDebugPrint
 10480              	.LVL1163:
1892:../uvc.c      ****     }
 10481              		.loc 1 1892 0
 10482 545c 0500A0E1 		mov	r0, r5
 10483 5460 FEFFFFEB 		bl	CyFxAppErrorHandler
 10484              	.LVL1164:
 10485              	.L841:
1882:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10486              		.loc 1 1882 0
 10487 5464 0400A0E3 		mov	r0, #4
 10488              	.LVL1165:
 10489 5468 34119FE5 		ldr	r1, .L868+176
 10490 546c 0520A0E1 		mov	r2, r5
 10491 5470 FEFFFFEB 		bl	CyU3PDebugPrint
 10492              	.LVL1166:
1883:../uvc.c      ****     }
 10493              		.loc 1 1883 0
 10494 5474 0500A0E1 		mov	r0, r5
 10495 5478 FEFFFFEB 		bl	CyFxAppErrorHandler
 10496              	.LVL1167:
 10497              	.L840:
1860:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10498              		.loc 1 1860 0
 10499 547c 0400A0E3 		mov	r0, #4
 10500              	.LVL1168:
 10501 5480 20119FE5 		ldr	r1, .L868+180
 10502 5484 0520A0E1 		mov	r2, r5
 10503 5488 FEFFFFEB 		bl	CyU3PDebugPrint
 10504              	.LVL1169:
1861:../uvc.c      ****     }
 10505              		.loc 1 1861 0
 10506 548c 0500A0E1 		mov	r0, r5
 10507 5490 FEFFFFEB 		bl	CyFxAppErrorHandler
 10508              	.LVL1170:
 10509              	.L847:
1944:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10510              		.loc 1 1944 0
 10511 5494 0400A0E3 		mov	r0, #4
 10512              	.LVL1171:
 10513 5498 0C119FE5 		ldr	r1, .L868+184
 10514 549c 0920A0E1 		mov	r2, r9
 10515 54a0 FEFFFFEB 		bl	CyU3PDebugPrint
 10516              	.LVL1172:
1945:../uvc.c      ****     }
 10517              		.loc 1 1945 0
 10518 54a4 0900A0E1 		mov	r0, r9
 10519 54a8 FEFFFFEB 		bl	CyFxAppErrorHandler
 10520              	.LVL1173:
 10521              	.L846:
1930:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10522              		.loc 1 1930 0
 10523 54ac 0400A0E3 		mov	r0, #4
 10524              	.LVL1174:
 10525 54b0 F8109FE5 		ldr	r1, .L868+188
 10526 54b4 0920A0E1 		mov	r2, r9
 10527 54b8 FEFFFFEB 		bl	CyU3PDebugPrint
 10528              	.LVL1175:
1931:../uvc.c      ****     }
 10529              		.loc 1 1931 0
 10530 54bc 0900A0E1 		mov	r0, r9
 10531 54c0 FEFFFFEB 		bl	CyFxAppErrorHandler
 10532              	.LVL1176:
 10533              	.L845:
1916:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10534              		.loc 1 1916 0
 10535 54c4 0400A0E3 		mov	r0, #4
 10536              	.LVL1177:
 10537 54c8 E4109FE5 		ldr	r1, .L868+192
 10538 54cc 0920A0E1 		mov	r2, r9
 10539 54d0 FEFFFFEB 		bl	CyU3PDebugPrint
 10540              	.LVL1178:
1917:../uvc.c      ****     }
 10541              		.loc 1 1917 0
 10542 54d4 0900A0E1 		mov	r0, r9
 10543 54d8 FEFFFFEB 		bl	CyFxAppErrorHandler
 10544              	.LVL1179:
 10545              	.L844:
1903:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10546              		.loc 1 1903 0
 10547 54dc 0400A0E3 		mov	r0, #4
 10548              	.LVL1180:
 10549 54e0 D0109FE5 		ldr	r1, .L868+196
 10550 54e4 0520A0E1 		mov	r2, r5
 10551 54e8 FEFFFFEB 		bl	CyU3PDebugPrint
 10552              	.LVL1181:
1904:../uvc.c      ****     }
 10553              		.loc 1 1904 0
 10554 54ec 0500A0E1 		mov	r0, r5
 10555 54f0 FEFFFFEB 		bl	CyFxAppErrorHandler
 10556              	.LVL1182:
 10557              	.L869:
 10558              		.align	2
 10559              	.L868:
 10560 54f4 00C20100 		.word	115200
 10561 54f8 00000000 		.word	.LANCHOR0
 10562 54fc 00000000 		.word	CyFxGpifCB
 10563 5500 00000000 		.word	CyFxUVCApplnUSBSetupCB
 10564 5504 00000000 		.word	CyFxUVCApplnUSBEventCB
 10565 5508 00000000 		.word	CyFxUSBDeviceDscr
 10566 550c 00000000 		.word	CyFxUSBDeviceDscrSS
 10567 5510 00000000 		.word	CyFxUSBDeviceQualDscr
 10568 5514 00000000 		.word	CyFxUSBBOSDscr
 10569 5518 00000000 		.word	CyFxUSBHSConfigDscr
 10570 551c 00000000 		.word	CyFxUSBFSConfigDscr
 10571 5520 00000000 		.word	CyFxUSBSSConfigDscr
 10572 5524 00000000 		.word	CyFxUSBStringLangIDDscr
 10573 5528 00000000 		.word	CyFxUSBManufactureDscr
 10574 552c 00000000 		.word	CyFxUSBProductDscr
 10575 5530 013F0203 		.word	50478849
 10576 5534 00000000 		.word	glChHandleInterStat
 10577 5538 00000000 		.word	glInterStaBuffer
 10578 553c 00000000 		.word	imgHdMux
 10579 5540 01010000 		.word	257
 10580 5544 03030000 		.word	771
 10581 5548 00000000 		.word	CyFxUvcApplnDmaCallback
 10582 554c 00000000 		.word	glChHandleUVCStream
 10583 5550 00000000 		.word	.LANCHOR1
 10584 5554 440A0000 		.word	.LC58
 10585 5558 FC0A0000 		.word	.LC62
 10586 555c 20000000 		.word	.LANCHOR2+32
 10587 5560 540B0000 		.word	.LC65
 10588 5564 0C0B0000 		.word	.LC63
 10589 5568 3C000000 		.word	.LANCHOR2+60
 10590 556c 940A0000 		.word	.LC60
 10591 5570 C80A0000 		.word	.LC61
 10592 5574 680A0000 		.word	.LC59
 10593 5578 50070000 		.word	.LC42
 10594 557c 1C0B0000 		.word	.LC64
 10595 5580 40090000 		.word	.LC53
 10596 5584 1C0A0000 		.word	.LC57
 10597 5588 EC090000 		.word	.LC56
 10598 558c B4090000 		.word	.LC55
 10599 5590 74090000 		.word	.LC54
 10600 5594 10090000 		.word	.LC52
 10601 5598 E0080000 		.word	.LC51
 10602 559c E8070000 		.word	.LC46
 10603 55a0 C0070000 		.word	.LC45
 10604 55a4 9C070000 		.word	.LC44
 10605 55a8 70070000 		.word	.LC43
 10606 55ac A8080000 		.word	.LC50
 10607 55b0 74080000 		.word	.LC49
 10608 55b4 40080000 		.word	.LC48
 10609 55b8 14080000 		.word	.LC47
 10610              	.LBE501:
 10611              	.LBE511:
 10612              		.cfi_endproc
 10613              	.LFE18:
 10615              		.align	2
 10616              		.global	CyFxApplicationDefine
 10618              	CyFxApplicationDefine:
 10619              	.LFB26:
3813:../uvc.c      **** }
3814:../uvc.c      **** 
3815:../uvc.c      **** 
3816:../uvc.c      **** /*
3817:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3818:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3819:../uvc.c      ****  */
3820:../uvc.c      **** void
3821:../uvc.c      **** CyFxApplicationDefine (
3822:../uvc.c      ****         void)
3823:../uvc.c      **** {
 10620              		.loc 1 3823 0
 10621              		.cfi_startproc
 10622              		@ args = 0, pretend = 0, frame = 40
 10623              		@ frame_needed = 0, uses_anonymous_args = 0
 10624              	.LVL1183:
 10625 55bc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 10626              	.LCFI27:
 10627              		.cfi_def_cfa_offset 36
 10628              		.cfi_offset 4, -36
 10629              		.cfi_offset 5, -32
 10630              		.cfi_offset 6, -28
 10631              		.cfi_offset 7, -24
 10632              		.cfi_offset 8, -20
 10633              		.cfi_offset 9, -16
 10634              		.cfi_offset 10, -12
 10635              		.cfi_offset 11, -8
 10636              		.cfi_offset 14, -4
3824:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3825:../uvc.c      ****     uint32_t retThrdCreate;
3826:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3827:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3828:../uvc.c      **** 
3829:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3830:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10637              		.loc 1 3830 0
 10638 55c0 010AA0E3 		mov	r0, #4096
3823:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 10639              		.loc 1 3823 0
 10640 55c4 4CD04DE2 		sub	sp, sp, #76
 10641              	.LCFI28:
 10642              		.cfi_def_cfa_offset 112
 10643              		.loc 1 3830 0
 10644 55c8 FEFFFFEB 		bl	CyU3PMemAlloc
 10645              	.LVL1184:
 10646 55cc 00A0A0E1 		mov	r10, r0
 10647              	.LVL1185:
3831:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10648              		.loc 1 3831 0
 10649 55d0 010AA0E3 		mov	r0, #4096
 10650              	.LVL1186:
 10651 55d4 FEFFFFEB 		bl	CyU3PMemAlloc
 10652              	.LVL1187:
 10653 55d8 0090A0E1 		mov	r9, r0
 10654              	.LVL1188:
3832:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10655              		.loc 1 3832 0
 10656 55dc 010AA0E3 		mov	r0, #4096
 10657              	.LVL1189:
 10658 55e0 FEFFFFEB 		bl	CyU3PMemAlloc
 10659              	.LVL1190:
3833:../uvc.c      **** 
3834:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 10660              		.loc 1 3834 0
 10661 55e4 000059E3 		cmp	r9, #0
 10662 55e8 00005A13 		cmpne	r10, #0
 10663 55ec 00C0A013 		movne	ip, #0
 10664 55f0 01C0A003 		moveq	ip, #1
3832:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10665              		.loc 1 3832 0
 10666 55f4 00B0A0E1 		mov	fp, r0
 10667              	.LVL1191:
 10668              		.loc 1 3834 0
 10669 55f8 0000001A 		bne	.L881
 10670              	.LVL1192:
 10671              	.L871:
 10672              	.L873:
 10673 55fc FEFFFFEA 		b	.L873
 10674              	.LVL1193:
 10675              	.L881:
 10676              		.loc 1 3834 0 is_stmt 0 discriminator 1
 10677 5600 000050E3 		cmp	r0, #0
 10678 5604 FCFFFF0A 		beq	.L871
3835:../uvc.c      ****         goto fatalErrorHandler;
3836:../uvc.c      **** 
3837:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3838:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 10679              		.loc 1 3838 0 is_stmt 1
 10680 5608 28008DE2 		add	r0, sp, #40
 10681              	.LVL1194:
 10682 560c 4010A0E3 		mov	r1, #64
 10683 5610 0C219FE5 		ldr	r2, .L882
 10684 5614 28708DE2 		add	r7, sp, #40
 10685 5618 24C08DE5 		str	ip, [sp, #36]
 10686 561c FEFFFFEB 		bl	cmdbufCreate
 10687              	.LVL1195:
 10688 5620 0F00B7E8 		ldmia	r7!, {r0, r1, r2, r3}
 10689 5624 FC509FE5 		ldr	r5, .L882+4
3839:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10690              		.loc 1 3839 0
 10691 5628 FC409FE5 		ldr	r4, .L882+8
3838:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10692              		.loc 1 3838 0
 10693 562c 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 10694 5630 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
3840:../uvc.c      **** 
3841:../uvc.c      **** 	/****** initialize command descriptor ***********/
3842:../uvc.c      **** 	cmdquInit(cmdQuptr);
3843:../uvc.c      **** 	cmdquInit(statQuptr);
3844:../uvc.c      **** 
3845:../uvc.c      ****     /* Create the UVC application thread. */
3846:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 10695              		.loc 1 3846 0
 10696 5634 0860A0E3 		mov	r6, #8
3838:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10697              		.loc 1 3838 0
 10698 5638 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
3839:../uvc.c      **** 
 10699              		.loc 1 3839 0
 10700 563c EC209FE5 		ldr	r2, .L882+12
 10701 5640 28008DE2 		add	r0, sp, #40
 10702 5644 2010A0E3 		mov	r1, #32
 10703 5648 FEFFFFEB 		bl	cmdbufCreate
 10704              	.LVL1196:
 10705 564c 28E08DE2 		add	lr, sp, #40
 10706 5650 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 10707              		.loc 1 3846 0
 10708 5654 0180A0E3 		mov	r8, #1
3839:../uvc.c      **** 
 10709              		.loc 1 3839 0
 10710 5658 0F00A4E8 		stmia	r4!, {r0, r1, r2, r3}
 10711 565c 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
 10712              		.loc 1 3846 0
 10713 5660 A870A0E3 		mov	r7, #168
3839:../uvc.c      **** 
 10714              		.loc 1 3839 0
 10715 5664 0F0084E8 		stmia	r4, {r0, r1, r2, r3}
3842:../uvc.c      **** 	cmdquInit(statQuptr);
 10716              		.loc 1 3842 0
 10717 5668 100045E2 		sub	r0, r5, #16
 10718 566c FEFFFFEB 		bl	cmdquInit
 10719              	.LVL1197:
3843:../uvc.c      **** 
 10720              		.loc 1 3843 0
 10721 5670 100044E2 		sub	r0, r4, #16
 10722 5674 FEFFFFEB 		bl	cmdquInit
 10723              	.LVL1198:
 10724              		.loc 1 3846 0
 10725 5678 24C09DE5 		ldr	ip, [sp, #36]
 10726 567c 012AA0E3 		mov	r2, #4096
 10727 5680 0C30A0E1 		mov	r3, ip
 10728 5684 44008DE9 		stmib	sp, {r2, r6}
 10729 5688 A4009FE5 		ldr	r0, .L882+16
 10730 568c 00A08DE5 		str	r10, [sp]
 10731 5690 10C08DE5 		str	ip, [sp, #16]
 10732 5694 0C608DE5 		str	r6, [sp, #12]
 10733 5698 14808DE5 		str	r8, [sp, #20]
 10734 569c 18708DE5 		str	r7, [sp, #24]
 10735 56a0 90109FE5 		ldr	r1, .L882+20
 10736 56a4 90209FE5 		ldr	r2, .L882+24
 10737 56a8 FEFFFFEB 		bl	_txe_thread_create
 10738              	.LVL1199:
3847:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3848:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3849:../uvc.c      ****             0,                                          /* No input parameter to thread */
3850:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3851:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3852:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3853:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3854:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3855:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3856:../uvc.c      ****             );
3857:../uvc.c      ****     if (retThrdCreate != 0)
 10739              		.loc 1 3857 0
 10740 56ac 003050E2 		subs	r3, r0, #0
 10741 56b0 D1FFFF1A 		bne	.L871
3858:../uvc.c      ****     {
3859:../uvc.c      ****         goto fatalErrorHandler;
3860:../uvc.c      ****     }
3861:../uvc.c      **** 
3862:../uvc.c      ****     /* Create the control request handling thread. */
3863:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 10742              		.loc 1 3863 0
 10743 56b4 024BA0E3 		mov	r4, #2048
 10744 56b8 10308DE5 		str	r3, [sp, #16]
 10745 56bc 00908DE5 		str	r9, [sp]
 10746 56c0 08608DE5 		str	r6, [sp, #8]
 10747 56c4 0C608DE5 		str	r6, [sp, #12]
 10748 56c8 14808DE5 		str	r8, [sp, #20]
 10749 56cc 18708DE5 		str	r7, [sp, #24]
 10750 56d0 04408DE5 		str	r4, [sp, #4]
 10751 56d4 64009FE5 		ldr	r0, .L882+28
 10752              	.LVL1200:
 10753 56d8 64109FE5 		ldr	r1, .L882+32
 10754 56dc 64209FE5 		ldr	r2, .L882+36
 10755 56e0 FEFFFFEB 		bl	_txe_thread_create
 10756              	.LVL1201:
3864:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3865:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3866:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3867:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3868:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3869:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3870:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3871:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3872:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3873:../uvc.c      ****             );
3874:../uvc.c      ****     if (retThrdCreate != 0)
 10757              		.loc 1 3874 0
 10758 56e4 003050E2 		subs	r3, r0, #0
 10759 56e8 C3FFFF1A 		bne	.L871
3875:../uvc.c      ****     {
3876:../uvc.c      ****         goto fatalErrorHandler;
3877:../uvc.c      ****     }
3878:../uvc.c      **** #if 1
3879:../uvc.c      ****     /* Create the I2C control command handling thread. */
3880:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 10760              		.loc 1 3880 0
 10761 56ec 00B08DE5 		str	fp, [sp]
 10762 56f0 50008DE9 		stmib	sp, {r4, r6}
 10763 56f4 50009FE5 		ldr	r0, .L882+40
 10764              	.LVL1202:
 10765 56f8 0C608DE5 		str	r6, [sp, #12]
 10766 56fc 10308DE5 		str	r3, [sp, #16]
 10767 5700 14808DE5 		str	r8, [sp, #20]
 10768 5704 18708DE5 		str	r7, [sp, #24]
 10769 5708 40109FE5 		ldr	r1, .L882+44
 10770 570c 40209FE5 		ldr	r2, .L882+48
 10771 5710 FEFFFFEB 		bl	_txe_thread_create
 10772              	.LVL1203:
3881:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3882:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3883:../uvc.c      ****             0,                                          /* No input parameter to thread */
3884:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3885:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3886:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3887:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3888:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3889:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3890:../uvc.c      ****             );
3891:../uvc.c      ****     if (retThrdCreate != 0)
 10773              		.loc 1 3891 0
 10774 5714 000050E3 		cmp	r0, #0
 10775 5718 B7FFFF1A 		bne	.L871
3892:../uvc.c      ****     {
3893:../uvc.c      ****         goto fatalErrorHandler;
3894:../uvc.c      ****     }
3895:../uvc.c      **** #endif
3896:../uvc.c      **** 
3897:../uvc.c      ****     return;
3898:../uvc.c      **** 
3899:../uvc.c      **** fatalErrorHandler:
3900:../uvc.c      ****     /* Add custom recovery or debug actions here */
3901:../uvc.c      ****     /* Loop indefinitely */
3902:../uvc.c      ****     while (1);
3903:../uvc.c      **** }
 10776              		.loc 1 3903 0
 10777 571c 4CD08DE2 		add	sp, sp, #76
 10778              		@ sp needed
 10779 5720 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 10780              	.LVL1204:
 10781              	.L883:
 10782              		.align	2
 10783              	.L882:
 10784 5724 00000000 		.word	cmdQuMux
 10785 5728 00000000 		.word	cmdQu
 10786 572c 00000000 		.word	statQu
 10787 5730 00000000 		.word	staQuMux
 10788 5734 E8000000 		.word	.LANCHOR0+232
 10789 5738 8C0B0000 		.word	.LC66
 10790 573c 00000000 		.word	UVCAppThread_Entry
 10791 5740 90010000 		.word	.LANCHOR0+400
 10792 5744 A00B0000 		.word	.LC67
 10793 5748 00000000 		.word	UVCAppEP0Thread_Entry
 10794 574c 38020000 		.word	.LANCHOR0+568
 10795 5750 B80B0000 		.word	.LC68
 10796 5754 00000000 		.word	I2cAppThread_Entry
 10797              		.cfi_endproc
 10798              	.LFE26:
 10800              		.section	.text.startup,"ax",%progbits
 10801              		.align	2
 10802              		.global	main
 10804              	main:
 10805              	.LFB27:
3904:../uvc.c      **** 
3905:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3906:../uvc.c      ****  * the ThreadX RTOS here.
3907:../uvc.c      ****  */
3908:../uvc.c      **** int
3909:../uvc.c      **** main (
3910:../uvc.c      ****         void)
3911:../uvc.c      **** {
 10806              		.loc 1 3911 0
 10807              		.cfi_startproc
 10808              		@ args = 0, pretend = 0, frame = 56
 10809              		@ frame_needed = 0, uses_anonymous_args = 0
 10810 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 10811              	.LCFI29:
 10812              		.cfi_def_cfa_offset 12
 10813              		.cfi_offset 4, -12
 10814              		.cfi_offset 5, -8
 10815              		.cfi_offset 14, -4
 10816 0004 3CD04DE2 		sub	sp, sp, #60
 10817              	.LCFI30:
 10818              		.cfi_def_cfa_offset 72
3912:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3913:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3914:../uvc.c      **** 
3915:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3916:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3917:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10819              		.loc 1 3917 0
 10820 0008 0230A0E3 		mov	r3, #2
3918:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3919:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3920:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 10821              		.loc 1 3920 0
 10822 000c 0010A0E3 		mov	r1, #0
3921:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 10823              		.loc 1 3921 0
 10824 0010 0320A0E3 		mov	r2, #3
3916:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10825              		.loc 1 3916 0
 10826 0014 0150A0E3 		mov	r5, #1
3922:../uvc.c      **** 
3923:../uvc.c      ****     /* Initialize the device */
3924:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 10827              		.loc 1 3924 0
 10828 0018 0D00A0E1 		mov	r0, sp
3916:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10829              		.loc 1 3916 0
 10830 001c 00508DE5 		str	r5, [sp]
3917:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 10831              		.loc 1 3917 0
 10832 0020 0430CDE5 		strb	r3, [sp, #4]
3918:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 10833              		.loc 1 3918 0
 10834 0024 0530CDE5 		strb	r3, [sp, #5]
3919:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 10835              		.loc 1 3919 0
 10836 0028 0630CDE5 		strb	r3, [sp, #6]
3920:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 10837              		.loc 1 3920 0
 10838 002c 08108DE5 		str	r1, [sp, #8]
3921:../uvc.c      **** 
 10839              		.loc 1 3921 0
 10840 0030 0C20CDE5 		strb	r2, [sp, #12]
 10841              		.loc 1 3924 0
 10842 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 10843              	.LVL1205:
3925:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10844              		.loc 1 3925 0
 10845 0038 004050E2 		subs	r4, r0, #0
 10846 003c 0000000A 		beq	.L889
 10847              	.L885:
 10848              	.L886:
 10849 0040 FEFFFFEA 		b	.L886
 10850              	.L889:
3926:../uvc.c      ****     {
3927:../uvc.c      ****         goto handle_fatal_error;
3928:../uvc.c      ****     }
3929:../uvc.c      **** 
3930:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3931:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 10851              		.loc 1 3931 0
 10852 0044 0410A0E1 		mov	r1, r4
 10853 0048 0420A0E1 		mov	r2, r4
 10854 004c 0500A0E1 		mov	r0, r5
 10855              	.LVL1206:
 10856 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 10857              	.LVL1207:
3932:../uvc.c      **** 
3933:../uvc.c      ****     /* Configure the IO matrix for the device. */
3934:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3935:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3936:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3937:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3938:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3939:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3940:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3941:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3942:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3943:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3944:../uvc.c      **** 
3945:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 10858              		.loc 1 3945 0
 10859 0054 10008DE2 		add	r0, sp, #16
3935:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 10860              		.loc 1 3935 0
 10861 0058 2640CDE5 		strb	r4, [sp, #38]
3936:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 10862              		.loc 1 3936 0
 10863 005c 28408DE5 		str	r4, [sp, #40]
3937:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 10864              		.loc 1 3937 0
 10865 0060 2C408DE5 		str	r4, [sp, #44]
3938:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 10866              		.loc 1 3938 0
 10867 0064 30408DE5 		str	r4, [sp, #48]
3939:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 10868              		.loc 1 3939 0
 10869 0068 34408DE5 		str	r4, [sp, #52]
3942:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 10870              		.loc 1 3942 0
 10871 006c 1C408DE5 		str	r4, [sp, #28]
3943:../uvc.c      **** 
 10872              		.loc 1 3943 0
 10873 0070 20408DE5 		str	r4, [sp, #32]
3934:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 10874              		.loc 1 3934 0
 10875 0074 10508DE5 		str	r5, [sp, #16]
3940:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 10876              		.loc 1 3940 0
 10877 0078 14508DE5 		str	r5, [sp, #20]
3941:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 10878              		.loc 1 3941 0
 10879 007c 18508DE5 		str	r5, [sp, #24]
 10880              		.loc 1 3945 0
 10881 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 10882              	.LVL1208:
3946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10883              		.loc 1 3946 0
 10884 0084 004050E2 		subs	r4, r0, #0
 10885 0088 ECFFFF1A 		bne	.L885
3947:../uvc.c      ****     {
3948:../uvc.c      ****         goto handle_fatal_error;
3949:../uvc.c      ****     }
3950:../uvc.c      **** 
3951:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3952:../uvc.c      ****     CyU3PKernelEntry ();
 10886              		.loc 1 3952 0
 10887 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 10888              	.LVL1209:
3953:../uvc.c      **** 
3954:../uvc.c      ****     /* Dummy return to make the compiler happy */
3955:../uvc.c      ****     return 0;
3956:../uvc.c      **** 
3957:../uvc.c      **** handle_fatal_error:
3958:../uvc.c      ****     /* Cannot recover from this error. */
3959:../uvc.c      ****     while (1);
3960:../uvc.c      **** }
 10889              		.loc 1 3960 0
 10890 0090 0400A0E1 		mov	r0, r4
 10891 0094 3CD08DE2 		add	sp, sp, #60
 10892              		@ sp needed
 10893 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 10894              		.cfi_endproc
 10895              	.LFE27:
 10897              		.comm	I2CCmdTimer,44,4
 10898              		.comm	posTick,4,4
 10899              		.global	glUVCHeader
 10900              		.global	glProbeStilCtrl20
 10901              		.global	glProbeCtrl20
 10902              		.global	glProbeStilCtrl
 10903              		.global	glProbeCtrl
 10904              		.global	streamingStarted
 10905              		.global	clearFeatureRqtReceived
 10906              		.global	usbSpeed
 10907              		.global	isUsbConnected
 10908              		.global	pbcpbak
 10909              		.global	pbcbak
 10910              		.global	pbbak
 10911              		.global	fbbak
 10912              		.global	pbc
 10913              		.global	pb
 10914              		.global	fb
 10915              		.comm	wLength,2,2
 10916              		.comm	wIndex,2,2
 10917              		.comm	wValue,2,2
 10918              		.comm	bRequest,1,1
 10919              		.comm	bmReqType,1,1
 10920              		.comm	imgHdMux,56,4
 10921              		.comm	timMux,56,4
 10922              		.comm	staQuMux,56,4
 10923              		.comm	cmdQuMux,56,4
 10924              		.comm	statQu,32,4
 10925              		.comm	cmdQu,32,4
 10926              		.global	testSnap
 10927              		.global	snapButFlag
 10928              		.comm	glInterStaBuffer,4,4
 10929              		.comm	glChHandleInterStat,172,4
 10930              		.comm	glChHandleStillStream,232,4
 10931              		.comm	glChHandleUVCStream,232,4
 10932              		.global	CyFxGpifConfig_usb2
 10933              		.global	CyFxGpifRegValue_usb2
 10934              		.global	CyFxGpifWavedataPosition_usb2
 10935              		.global	CyFxGpifWavedata_usb2
 10936              		.global	CyFxGpifTransition_usb2
 10937              		.global	CyFxGpifConfig
 10938              		.global	CyFxGpifRegValue
 10939              		.global	CyFxGpifWavedataPosition
 10940              		.global	CyFxGpifWavedata
 10941              		.global	CyFxGpifTransition
 10942              		.section	.rodata
 10943              		.align	2
 10944              		.set	.LANCHOR2,. + 0
 10947              	ExTime:
 10948 0000 9C       		.byte	-100
 10949 0001 00       		.byte	0
 10950 0002 4E       		.byte	78
 10951 0003 00       		.byte	0
 10952 0004 27       		.byte	39
 10953 0005 00       		.byte	0
 10954 0006 14       		.byte	20
 10955 0007 00       		.byte	0
 10956 0008 0A       		.byte	10
 10957 0009 00       		.byte	0
 10958 000a 05       		.byte	5
 10959 000b 00       		.byte	0
 10960 000c 02       		.byte	2
 10961 000d 00       		.byte	0
 10962 000e 01       		.byte	1
 10963 000f 00       		.byte	0
 10966              	ShutValueArry:
 10967 0010 C800     		.short	200
 10968 0012 6400     		.short	100
 10969 0014 2700     		.short	39
 10970 0016 1400     		.short	20
 10971 0018 0A00     		.short	10
 10972 001a 0500     		.short	5
 10973 001c 0200     		.short	2
 10974 001e 0100     		.short	1
 10977              	CyFxGpifConfig:
 10978 0020 0F00     		.short	15
 10979 0022 0000     		.space	2
 10980 0024 00000000 		.word	CyFxGpifWavedata
 10981 0028 00000000 		.word	CyFxGpifWavedataPosition
 10982 002c 0500     		.short	5
 10983 002e 0000     		.space	2
 10984 0030 00000000 		.word	CyFxGpifTransition
 10985 0034 4C00     		.short	76
 10986 0036 0000     		.space	2
 10987 0038 00000000 		.word	CyFxGpifRegValue
 10990              	CyFxGpifConfig_usb2:
 10991 003c 9300     		.short	147
 10992 003e 0000     		.space	2
 10993 0040 00000000 		.word	CyFxGpifWavedata_usb2
 10994 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 10995 0048 0800     		.short	8
 10996 004a 0000     		.space	2
 10997 004c 00000000 		.word	CyFxGpifTransition_usb2
 10998 0050 4C00     		.short	76
 10999 0052 0000     		.space	2
 11000 0054 00000000 		.word	CyFxGpifRegValue_usb2
 11001              		.data
 11002              		.align	2
 11003              		.set	.LANCHOR1,. + 0
 11006              	ExUCtrlParArry:
 11007 0000 00       		.byte	0
 11008 0001 00       		.byte	0
 11009 0002 04       		.byte	4
 11010 0003 01       		.byte	1
 11011 0004 00       		.byte	0
 11012 0005 38       		.byte	56
 11013 0006 01       		.byte	1
 11014 0007 01       		.byte	1
 11015 0008 00       		.byte	0
 11016 0009 03       		.byte	3
 11017 000a 00       		.byte	0
 11018 000b 4E       		.byte	78
 11019 000c 00       		.byte	0
 11020 000d 4E       		.byte	78
 11021 000e 00       		.byte	0
 11022 000f 30       		.byte	48
 11023 0010 01       		.byte	1
 11024 0011 00       		.byte	0
 11025 0012 00       		.byte	0
 11026 0013 00000000 		.space	5
 11026      00
 11027 0018 00       		.byte	0
 11028 0019 00       		.byte	0
 11029 001a 01       		.byte	1
 11030 001b 00       		.byte	0
 11031 001c 00       		.byte	0
 11032 001d 00       		.byte	0
 11033 001e 00       		.byte	0
 11034 001f 01       		.byte	1
 11035 0020 00       		.byte	0
 11036 0021 03       		.byte	3
 11037 0022 00       		.byte	0
 11038 0023 00       		.byte	0
 11039 0024 00       		.byte	0
 11040 0025 00       		.byte	0
 11041 0026 00       		.byte	0
 11042 0027 30       		.byte	48
 11043 0028 01       		.byte	1
 11044 0029 00       		.byte	0
 11045 002a 00       		.byte	0
 11046 002b 00000000 		.space	5
 11046      00
 11047 0030 00       		.byte	0
 11048 0031 00       		.byte	0
 11049 0032 02       		.byte	2
 11050 0033 00       		.byte	0
 11051 0034 00       		.byte	0
 11052 0035 FF       		.byte	-1
 11053 0036 00       		.byte	0
 11054 0037 01       		.byte	1
 11055 0038 00       		.byte	0
 11056 0039 03       		.byte	3
 11057 003a 00       		.byte	0
 11058 003b 01       		.byte	1
 11059 003c 00       		.byte	0
 11060 003d 00       		.byte	0
 11061 003e 00       		.byte	0
 11062 003f 30       		.byte	48
 11063 0040 01       		.byte	1
 11064 0041 01       		.byte	1
 11065 0042 00       		.byte	0
 11066 0043 00000000 		.space	5
 11066      00
 11067 0048 00       		.byte	0
 11068 0049 00       		.byte	0
 11069 004a 02       		.byte	2
 11070 004b 00       		.byte	0
 11071 004c 00       		.byte	0
 11072 004d 00       		.byte	0
 11073 004e 00       		.byte	0
 11074 004f 00       		.byte	0
 11075 0050 00       		.byte	0
 11076 0051 03       		.byte	3
 11077 0052 00       		.byte	0
 11078 0053 00       		.byte	0
 11079 0054 00       		.byte	0
 11080 0055 00       		.byte	0
 11081 0056 00       		.byte	0
 11082 0057 30       		.byte	48
 11083 0058 01       		.byte	1
 11084 0059 01       		.byte	1
 11085 005a 00       		.byte	0
 11086 005b 00000000 		.space	5
 11086      00
 11087 0060 13       		.byte	19
 11088 0061 14       		.byte	20
 11089 0062 02       		.byte	2
 11090 0063 01       		.byte	1
 11091 0064 00       		.byte	0
 11092 0065 03       		.byte	3
 11093 0066 00       		.byte	0
 11094 0067 01       		.byte	1
 11095 0068 00       		.byte	0
 11096 0069 03       		.byte	3
 11097 006a 00       		.byte	0
 11098 006b 23       		.byte	35
 11099 006c 37       		.byte	55
 11100 006d 23       		.byte	35
 11101 006e 37       		.byte	55
 11102 006f 30       		.byte	48
 11103 0070 01       		.byte	1
 11104 0071 00       		.byte	0
 11105 0072 00       		.byte	0
 11106 0073 00000000 		.space	5
 11106      00
 11107 0078 11       		.byte	17
 11108 0079 00       		.byte	0
 11109 007a 02       		.byte	2
 11110 007b 01       		.byte	1
 11111 007c 00       		.byte	0
 11112 007d 03       		.byte	3
 11113 007e 00       		.byte	0
 11114 007f 01       		.byte	1
 11115 0080 00       		.byte	0
 11116 0081 03       		.byte	3
 11117 0082 00       		.byte	0
 11118 0083 01       		.byte	1
 11119 0084 00       		.byte	0
 11120 0085 01       		.byte	1
 11121 0086 00       		.byte	0
 11122 0087 30       		.byte	48
 11123 0088 01       		.byte	1
 11124 0089 01       		.byte	1
 11125 008a 00       		.byte	0
 11126 008b 00000000 		.space	5
 11126      00
 11127 0090 17       		.byte	23
 11128 0091 00       		.byte	0
 11129 0092 01       		.byte	1
 11130 0093 01       		.byte	1
 11131 0094 00       		.byte	0
 11132 0095 02       		.byte	2
 11133 0096 00       		.byte	0
 11134 0097 01       		.byte	1
 11135 0098 00       		.byte	0
 11136 0099 03       		.byte	3
 11137 009a 00       		.byte	0
 11138 009b 00       		.byte	0
 11139 009c 00       		.byte	0
 11140 009d 00       		.byte	0
 11141 009e 00       		.byte	0
 11142 009f 30       		.byte	48
 11143 00a0 01       		.byte	1
 11144 00a1 01       		.byte	1
 11145 00a2 00       		.byte	0
 11146 00a3 00000000 		.space	5
 11146      00
 11147 00a8 00       		.byte	0
 11148 00a9 00       		.byte	0
 11149 00aa 04       		.byte	4
 11150 00ab 01       		.byte	1
 11151 00ac 00       		.byte	0
 11152 00ad 38       		.byte	56
 11153 00ae 01       		.byte	1
 11154 00af 01       		.byte	1
 11155 00b0 00       		.byte	0
 11156 00b1 03       		.byte	3
 11157 00b2 00       		.byte	0
 11158 00b3 4E       		.byte	78
 11159 00b4 00       		.byte	0
 11160 00b5 4E       		.byte	78
 11161 00b6 00       		.byte	0
 11162 00b7 30       		.byte	48
 11163 00b8 01       		.byte	1
 11164 00b9 00       		.byte	0
 11165 00ba 00       		.byte	0
 11166 00bb 00000000 		.space	5
 11166      00
 11167 00c0 00       		.byte	0
 11168 00c1 00       		.byte	0
 11169 00c2 01       		.byte	1
 11170 00c3 00       		.byte	0
 11171 00c4 00       		.byte	0
 11172 00c5 00       		.byte	0
 11173 00c6 00       		.byte	0
 11174 00c7 01       		.byte	1
 11175 00c8 00       		.byte	0
 11176 00c9 03       		.byte	3
 11177 00ca 00       		.byte	0
 11178 00cb 00       		.byte	0
 11179 00cc 00       		.byte	0
 11180 00cd 00       		.byte	0
 11181 00ce 00       		.byte	0
 11182 00cf 30       		.byte	48
 11183 00d0 01       		.byte	1
 11184 00d1 00       		.byte	0
 11185 00d2 00       		.byte	0
 11186 00d3 00000000 		.space	5
 11186      00
 11187 00d8 00       		.byte	0
 11188 00d9 00       		.byte	0
 11189 00da 02       		.byte	2
 11190 00db 00       		.byte	0
 11191 00dc 00       		.byte	0
 11192 00dd 05       		.byte	5
 11193 00de 00       		.byte	0
 11194 00df 01       		.byte	1
 11195 00e0 00       		.byte	0
 11196 00e1 03       		.byte	3
 11197 00e2 00       		.byte	0
 11198 00e3 00       		.byte	0
 11199 00e4 00       		.byte	0
 11200 00e5 00       		.byte	0
 11201 00e6 00       		.byte	0
 11202 00e7 30       		.byte	48
 11203 00e8 01       		.byte	1
 11204 00e9 00       		.byte	0
 11205 00ea 00       		.byte	0
 11206 00eb 00000000 		.space	5
 11206      00
 11207 00f0 00       		.byte	0
 11208 00f1 00       		.byte	0
 11209 00f2 03       		.byte	3
 11210 00f3 00       		.byte	0
 11211 00f4 00       		.byte	0
 11212 00f5 0A       		.byte	10
 11213 00f6 00       		.byte	0
 11214 00f7 01       		.byte	1
 11215 00f8 00       		.byte	0
 11216 00f9 03       		.byte	3
 11217 00fa 00       		.byte	0
 11218 00fb 00       		.byte	0
 11219 00fc 00       		.byte	0
 11220 00fd 00       		.byte	0
 11221 00fe 00       		.byte	0
 11222 00ff 30       		.byte	48
 11223 0100 01       		.byte	1
 11224 0101 00       		.byte	0
 11225 0102 00       		.byte	0
 11226 0103 00000000 		.space	5
 11226      00
 11227 0108 00       		.byte	0
 11228 0109 00       		.byte	0
 11229 010a 02       		.byte	2
 11230 010b 00       		.byte	0
 11231 010c 00       		.byte	0
 11232 010d 40       		.byte	64
 11233 010e 00       		.byte	0
 11234 010f 01       		.byte	1
 11235 0110 00       		.byte	0
 11236 0111 03       		.byte	3
 11237 0112 00       		.byte	0
 11238 0113 0F       		.byte	15
 11239 0114 11       		.byte	17
 11240 0115 00       		.byte	0
 11241 0116 00       		.byte	0
 11242 0117 30       		.byte	48
 11243 0118 01       		.byte	1
 11244 0119 00       		.byte	0
 11245 011a 00       		.byte	0
 11246 011b 00000000 		.space	5
 11246      00
 11247 0120 00       		.byte	0
 11248 0121 00       		.byte	0
 11249 0122 02       		.byte	2
 11250 0123 00       		.byte	0
 11251 0124 00       		.byte	0
 11252 0125 64       		.byte	100
 11253 0126 00       		.byte	0
 11254 0127 01       		.byte	1
 11255 0128 00       		.byte	0
 11256 0129 03       		.byte	3
 11257 012a 00       		.byte	0
 11258 012b 00       		.byte	0
 11259 012c 00       		.byte	0
 11260 012d 00       		.byte	0
 11261 012e 00       		.byte	0
 11262 012f 30       		.byte	48
 11263 0130 01       		.byte	1
 11264 0131 00       		.byte	0
 11265 0132 00       		.byte	0
 11266 0133 00000000 		.space	5
 11266      00
 11267 0138 00       		.byte	0
 11268 0139 00       		.byte	0
 11269 013a 02       		.byte	2
 11270 013b 00       		.byte	0
 11271 013c 00       		.byte	0
 11272 013d 64       		.byte	100
 11273 013e 00       		.byte	0
 11274 013f 01       		.byte	1
 11275 0140 00       		.byte	0
 11276 0141 03       		.byte	3
 11277 0142 00       		.byte	0
 11278 0143 00       		.byte	0
 11279 0144 00       		.byte	0
 11280 0145 00       		.byte	0
 11281 0146 00       		.byte	0
 11282 0147 30       		.byte	48
 11283 0148 01       		.byte	1
 11284 0149 00       		.byte	0
 11285 014a 00       		.byte	0
 11286 014b 00000000 		.space	5
 11286      00
 11287 0150 00       		.byte	0
 11288 0151 00       		.byte	0
 11289 0152 02       		.byte	2
 11290 0153 00       		.byte	0
 11291 0154 00       		.byte	0
 11292 0155 64       		.byte	100
 11293 0156 00       		.byte	0
 11294 0157 01       		.byte	1
 11295 0158 00       		.byte	0
 11296 0159 03       		.byte	3
 11297 015a 00       		.byte	0
 11298 015b 00       		.byte	0
 11299 015c 00       		.byte	0
 11300 015d 00       		.byte	0
 11301 015e 00       		.byte	0
 11302 015f 30       		.byte	48
 11303 0160 01       		.byte	1
 11304 0161 00       		.byte	0
 11305 0162 00       		.byte	0
 11306 0163 00000000 		.space	5
 11306      00
 11307 0168 00       		.byte	0
 11308 0169 00       		.byte	0
 11309 016a 02       		.byte	2
 11310 016b 00       		.byte	0
 11311 016c 00       		.byte	0
 11312 016d 64       		.byte	100
 11313 016e 00       		.byte	0
 11314 016f 01       		.byte	1
 11315 0170 00       		.byte	0
 11316 0171 03       		.byte	3
 11317 0172 00       		.byte	0
 11318 0173 00       		.byte	0
 11319 0174 00       		.byte	0
 11320 0175 00       		.byte	0
 11321 0176 00       		.byte	0
 11322 0177 30       		.byte	48
 11323 0178 01       		.byte	1
 11324 0179 00       		.byte	0
 11325 017a 00       		.byte	0
 11326 017b 00000000 		.space	5
 11326      00
 11329              	CtrlParArry:
 11330 0180 10       		.byte	16
 11331 0181 10       		.byte	16
 11332 0182 02       		.byte	2
 11333 0183 00       		.byte	0
 11334 0184 00       		.byte	0
 11335 0185 03       		.byte	3
 11336 0186 00       		.byte	0
 11337 0187 01       		.byte	1
 11338 0188 00       		.byte	0
 11339 0189 03       		.byte	3
 11340 018a 00       		.byte	0
 11341 018b 00       		.byte	0
 11342 018c 00       		.byte	0
 11343 018d 00       		.byte	0
 11344 018e 00       		.byte	0
 11345 018f 30       		.byte	48
 11346 0190 01       		.byte	1
 11347 0191 00       		.byte	0
 11348 0192 00       		.byte	0
 11349 0193 00000000 		.space	5
 11349      00
 11350 0198 01       		.byte	1
 11351 0199 00       		.byte	0
 11352 019a 02       		.byte	2
 11353 019b 00       		.byte	0
 11354 019c 00       		.byte	0
 11355 019d 3F       		.byte	63
 11356 019e 00       		.byte	0
 11357 019f 01       		.byte	1
 11358 01a0 00       		.byte	0
 11359 01a1 03       		.byte	3
 11360 01a2 00       		.byte	0
 11361 01a3 1F       		.byte	31
 11362 01a4 00       		.byte	0
 11363 01a5 1F       		.byte	31
 11364 01a6 C7       		.byte	-57
 11365 01a7 30       		.byte	48
 11366 01a8 01       		.byte	1
 11367 01a9 01       		.byte	1
 11368 01aa 00       		.byte	0
 11369 01ab 00000000 		.space	5
 11369      00
 11370 01b0 07       		.byte	7
 11371 01b1 07       		.byte	7
 11372 01b2 02       		.byte	2
 11373 01b3 10       		.byte	16
 11374 01b4 00       		.byte	0
 11375 01b5 40       		.byte	64
 11376 01b6 00       		.byte	0
 11377 01b7 01       		.byte	1
 11378 01b8 00       		.byte	0
 11379 01b9 03       		.byte	3
 11380 01ba 00       		.byte	0
 11381 01bb 28       		.byte	40
 11382 01bc 00       		.byte	0
 11383 01bd 28       		.byte	40
 11384 01be 00       		.byte	0
 11385 01bf 30       		.byte	48
 11386 01c0 01       		.byte	1
 11387 01c1 01       		.byte	1
 11388 01c2 00       		.byte	0
 11389 01c3 00000000 		.space	5
 11389      00
 11390 01c8 00       		.byte	0
 11391 01c9 00       		.byte	0
 11392 01ca 02       		.byte	2
 11393 01cb 00       		.byte	0
 11394 01cc 00       		.byte	0
 11395 01cd 64       		.byte	100
 11396 01ce 00       		.byte	0
 11397 01cf 01       		.byte	1
 11398 01d0 00       		.byte	0
 11399 01d1 03       		.byte	3
 11400 01d2 00       		.byte	0
 11401 01d3 00       		.byte	0
 11402 01d4 00       		.byte	0
 11403 01d5 00       		.byte	0
 11404 01d6 00       		.byte	0
 11405 01d7 30       		.byte	48
 11406 01d8 01       		.byte	1
 11407 01d9 00       		.byte	0
 11408 01da 00       		.byte	0
 11409 01db 00000000 		.space	5
 11409      00
 11410 01e0 07       		.byte	7
 11411 01e1 07       		.byte	7
 11412 01e2 02       		.byte	2
 11413 01e3 00       		.byte	0
 11414 01e4 00       		.byte	0
 11415 01e5 01       		.byte	1
 11416 01e6 00       		.byte	0
 11417 01e7 01       		.byte	1
 11418 01e8 00       		.byte	0
 11419 01e9 03       		.byte	3
 11420 01ea 00       		.byte	0
 11421 01eb 01       		.byte	1
 11422 01ec 00       		.byte	0
 11423 01ed 01       		.byte	1
 11424 01ee 00       		.byte	0
 11425 01ef 30       		.byte	48
 11426 01f0 01       		.byte	1
 11427 01f1 00       		.byte	0
 11428 01f2 00       		.byte	0
 11429 01f3 00000000 		.space	5
 11429      00
 11430 01f8 DF       		.byte	-33
 11431 01f9 E1       		.byte	-31
 11432 01fa 02       		.byte	2
 11433 01fb 00       		.byte	0
 11434 01fc 00       		.byte	0
 11435 01fd FF       		.byte	-1
 11436 01fe 00       		.byte	0
 11437 01ff 01       		.byte	1
 11438 0200 00       		.byte	0
 11439 0201 03       		.byte	3
 11440 0202 00       		.byte	0
 11441 0203 80       		.byte	-128
 11442 0204 00       		.byte	0
 11443 0205 00       		.byte	0
 11444 0206 00       		.byte	0
 11445 0207 C6       		.byte	-58
 11446 0208 01       		.byte	1
 11447 0209 01       		.byte	1
 11448 020a 00       		.byte	0
 11449 020b 00000000 		.space	5
 11449      00
 11450 0210 85       		.byte	-123
 11451 0211 86       		.byte	-122
 11452 0212 02       		.byte	2
 11453 0213 00       		.byte	0
 11454 0214 00       		.byte	0
 11455 0215 64       		.byte	100
 11456 0216 00       		.byte	0
 11457 0217 01       		.byte	1
 11458 0218 00       		.byte	0
 11459 0219 03       		.byte	3
 11460 021a 00       		.byte	0
 11461 021b 32       		.byte	50
 11462 021c 00       		.byte	0
 11463 021d 32       		.byte	50
 11464 021e 00       		.byte	0
 11465 021f F2       		.byte	-14
 11466 0220 01       		.byte	1
 11467 0221 01       		.byte	1
 11468 0222 00       		.byte	0
 11469 0223 00000000 		.space	5
 11469      00
 11470 0228 06       		.byte	6
 11471 0229 06       		.byte	6
 11472 022a 02       		.byte	2
 11473 022b 00       		.byte	0
 11474 022c 00       		.byte	0
 11475 022d 0E       		.byte	14
 11476 022e 00       		.byte	0
 11477 022f 01       		.byte	1
 11478 0230 00       		.byte	0
 11479 0231 03       		.byte	3
 11480 0232 00       		.byte	0
 11481 0233 00       		.byte	0
 11482 0234 00       		.byte	0
 11483 0235 00       		.byte	0
 11484 0236 00       		.byte	0
 11485 0237 30       		.byte	48
 11486 0238 01       		.byte	1
 11487 0239 01       		.byte	1
 11488 023a 00       		.byte	0
 11489 023b 00000000 		.space	5
 11489      00
 11490 0240 00       		.byte	0
 11491 0241 00       		.byte	0
 11492 0242 02       		.byte	2
 11493 0243 00       		.byte	0
 11494 0244 00       		.byte	0
 11495 0245 64       		.byte	100
 11496 0246 00       		.byte	0
 11497 0247 01       		.byte	1
 11498 0248 00       		.byte	0
 11499 0249 03       		.byte	3
 11500 024a 00       		.byte	0
 11501 024b 00       		.byte	0
 11502 024c 00       		.byte	0
 11503 024d 00       		.byte	0
 11504 024e 00       		.byte	0
 11505 024f 30       		.byte	48
 11506 0250 01       		.byte	1
 11507 0251 00       		.byte	0
 11508 0252 00       		.byte	0
 11509 0253 00000000 		.space	5
 11509      00
 11510 0258 08       		.byte	8
 11511 0259 08       		.byte	8
 11512 025a 02       		.byte	2
 11513 025b 00       		.byte	0
 11514 025c 00       		.byte	0
 11515 025d 05       		.byte	5
 11516 025e 00       		.byte	0
 11517 025f 01       		.byte	1
 11518 0260 00       		.byte	0
 11519 0261 03       		.byte	3
 11520 0262 00       		.byte	0
 11521 0263 00       		.byte	0
 11522 0264 00       		.byte	0
 11523 0265 00       		.byte	0
 11524 0266 00       		.byte	0
 11525 0267 30       		.byte	48
 11526 0268 01       		.byte	1
 11527 0269 00       		.byte	0
 11528 026a 00       		.byte	0
 11529 026b 00000000 		.space	5
 11529      00
 11530 0270 00       		.byte	0
 11531 0271 00       		.byte	0
 11532 0272 02       		.byte	2
 11533 0273 00       		.byte	0
 11534 0274 00       		.byte	0
 11535 0275 40       		.byte	64
 11536 0276 00       		.byte	0
 11537 0277 01       		.byte	1
 11538 0278 00       		.byte	0
 11539 0279 03       		.byte	3
 11540 027a 00       		.byte	0
 11541 027b 00       		.byte	0
 11542 027c 00       		.byte	0
 11543 027d 00       		.byte	0
 11544 027e 00       		.byte	0
 11545 027f 30       		.byte	48
 11546 0280 01       		.byte	1
 11547 0281 00       		.byte	0
 11548 0282 00       		.byte	0
 11549 0283 00000000 		.space	5
 11549      00
 11550 0288 09       		.byte	9
 11551 0289 0A       		.byte	10
 11552 028a 04       		.byte	4
 11553 028b 00       		.byte	0
 11554 028c 00       		.byte	0
 11555 028d 40       		.byte	64
 11556 028e 00       		.byte	0
 11557 028f 01       		.byte	1
 11558 0290 00       		.byte	0
 11559 0291 03       		.byte	3
 11560 0292 00       		.byte	0
 11561 0293 20       		.byte	32
 11562 0294 38       		.byte	56
 11563 0295 20       		.byte	32
 11564 0296 38       		.byte	56
 11565 0297 30       		.byte	48
 11566 0298 01       		.byte	1
 11567 0299 00       		.byte	0
 11568 029a 00       		.byte	0
 11569 029b 00000000 		.space	5
 11569      00
 11570 02a0 00       		.byte	0
 11571 02a1 00       		.byte	0
 11572 02a2 02       		.byte	2
 11573 02a3 00       		.byte	0
 11574 02a4 00       		.byte	0
 11575 02a5 64       		.byte	100
 11576 02a6 00       		.byte	0
 11577 02a7 01       		.byte	1
 11578 02a8 00       		.byte	0
 11579 02a9 03       		.byte	3
 11580 02aa 00       		.byte	0
 11581 02ab 00       		.byte	0
 11582 02ac 00       		.byte	0
 11583 02ad 00       		.byte	0
 11584 02ae 00       		.byte	0
 11585 02af 30       		.byte	48
 11586 02b0 01       		.byte	1
 11587 02b1 00       		.byte	0
 11588 02b2 00       		.byte	0
 11589 02b3 00000000 		.space	5
 11589      00
 11590 02b8 00       		.byte	0
 11591 02b9 00       		.byte	0
 11592 02ba 02       		.byte	2
 11593 02bb 00       		.byte	0
 11594 02bc 00       		.byte	0
 11595 02bd 64       		.byte	100
 11596 02be 00       		.byte	0
 11597 02bf 01       		.byte	1
 11598 02c0 00       		.byte	0
 11599 02c1 03       		.byte	3
 11600 02c2 00       		.byte	0
 11601 02c3 00       		.byte	0
 11602 02c4 00       		.byte	0
 11603 02c5 00       		.byte	0
 11604 02c6 00       		.byte	0
 11605 02c7 30       		.byte	48
 11606 02c8 01       		.byte	1
 11607 02c9 00       		.byte	0
 11608 02ca 00       		.byte	0
 11609 02cb 00000000 		.space	5
 11609      00
 11610 02d0 2A       		.byte	42
 11611 02d1 2A       		.byte	42
 11612 02d2 02       		.byte	2
 11613 02d3 00       		.byte	0
 11614 02d4 00       		.byte	0
 11615 02d5 1B       		.byte	27
 11616 02d6 00       		.byte	0
 11617 02d7 01       		.byte	1
 11618 02d8 00       		.byte	0
 11619 02d9 03       		.byte	3
 11620 02da 00       		.byte	0
 11621 02db 00       		.byte	0
 11622 02dc 00       		.byte	0
 11623 02dd 00       		.byte	0
 11624 02de 00       		.byte	0
 11625 02df 30       		.byte	48
 11626 02e0 01       		.byte	1
 11627 02e1 00       		.byte	0
 11628 02e2 00       		.byte	0
 11629 02e3 00000000 		.space	5
 11629      00
 11630 02e8 00       		.byte	0
 11631 02e9 00       		.byte	0
 11632 02ea 02       		.byte	2
 11633 02eb 00       		.byte	0
 11634 02ec 00       		.byte	0
 11635 02ed 64       		.byte	100
 11636 02ee 00       		.byte	0
 11637 02ef 01       		.byte	1
 11638 02f0 00       		.byte	0
 11639 02f1 03       		.byte	3
 11640 02f2 00       		.byte	0
 11641 02f3 00       		.byte	0
 11642 02f4 00       		.byte	0
 11643 02f5 00       		.byte	0
 11644 02f6 00       		.byte	0
 11645 02f7 30       		.byte	48
 11646 02f8 01       		.byte	1
 11647 02f9 00       		.byte	0
 11648 02fa 00       		.byte	0
 11649 02fb 00000000 		.space	5
 11649      00
 11650 0300 00       		.byte	0
 11651 0301 00       		.byte	0
 11652 0302 02       		.byte	2
 11653 0303 00       		.byte	0
 11654 0304 00       		.byte	0
 11655 0305 12       		.byte	18
 11656 0306 00       		.byte	0
 11657 0307 01       		.byte	1
 11658 0308 00       		.byte	0
 11659 0309 03       		.byte	3
 11660 030a 00       		.byte	0
 11661 030b 00       		.byte	0
 11662 030c 00       		.byte	0
 11663 030d 00       		.byte	0
 11664 030e 00       		.byte	0
 11665 030f 30       		.byte	48
 11666 0310 01       		.byte	1
 11667 0311 00       		.byte	0
 11668 0312 00       		.byte	0
 11669 0313 00000000 		.space	5
 11669      00
 11670 0318 01       		.byte	1
 11671 0319 01       		.byte	1
 11672 031a 02       		.byte	2
 11673 031b 00       		.byte	0
 11674 031c 00       		.byte	0
 11675 031d 09       		.byte	9
 11676 031e 00       		.byte	0
 11677 031f 01       		.byte	1
 11678 0320 00       		.byte	0
 11679 0321 03       		.byte	3
 11680 0322 00       		.byte	0
 11681 0323 00       		.byte	0
 11682 0324 00       		.byte	0
 11683 0325 01       		.byte	1
 11684 0326 00       		.byte	0
 11685 0327 30       		.byte	48
 11686 0328 01       		.byte	1
 11687 0329 00       		.byte	0
 11688 032a 00       		.byte	0
 11689 032b 00000000 		.space	5
 11689      00
 11690 0330 05       		.byte	5
 11691 0331 05       		.byte	5
 11692 0332 02       		.byte	2
 11693 0333 00       		.byte	0
 11694 0334 00       		.byte	0
 11695 0335 03       		.byte	3
 11696 0336 00       		.byte	0
 11697 0337 01       		.byte	1
 11698 0338 00       		.byte	0
 11699 0339 03       		.byte	3
 11700 033a 00       		.byte	0
 11701 033b 00       		.byte	0
 11702 033c 00       		.byte	0
 11703 033d 00       		.byte	0
 11704 033e 00       		.byte	0
 11705 033f 30       		.byte	48
 11706 0340 01       		.byte	1
 11707 0341 00       		.byte	0
 11708 0342 00       		.byte	0
 11709 0343 00000000 		.space	5
 11709      00
 11710 0348 18       		.byte	24
 11711 0349 18       		.byte	24
 11712 034a 02       		.byte	2
 11713 034b 00       		.byte	0
 11714 034c 00       		.byte	0
 11715 034d 01       		.byte	1
 11716 034e 00       		.byte	0
 11717 034f 01       		.byte	1
 11718 0350 00       		.byte	0
 11719 0351 03       		.byte	3
 11720 0352 00       		.byte	0
 11721 0353 00       		.byte	0
 11722 0354 00       		.byte	0
 11723 0355 00       		.byte	0
 11724 0356 00       		.byte	0
 11725 0357 30       		.byte	48
 11726 0358 01       		.byte	1
 11727 0359 00       		.byte	0
 11728 035a 00       		.byte	0
 11729 035b 00000000 		.space	5
 11729      00
 11730 0360 19       		.byte	25
 11731 0361 19       		.byte	25
 11732 0362 01       		.byte	1
 11733 0363 00       		.byte	0
 11734 0364 00       		.byte	0
 11735 0365 40       		.byte	64
 11736 0366 00       		.byte	0
 11737 0367 01       		.byte	1
 11738 0368 00       		.byte	0
 11739 0369 03       		.byte	3
 11740 036a 00       		.byte	0
 11741 036b 20       		.byte	32
 11742 036c 00       		.byte	0
 11743 036d 20       		.byte	32
 11744 036e 00       		.byte	0
 11745 036f 30       		.byte	48
 11746 0370 01       		.byte	1
 11747 0371 00       		.byte	0
 11748 0372 00       		.byte	0
 11749 0373 00000000 		.space	5
 11749      00
 11750 0378 20       		.byte	32
 11751 0379 20       		.byte	32
 11752 037a 02       		.byte	2
 11753 037b 00       		.byte	0
 11754 037c 00       		.byte	0
 11755 037d 02       		.byte	2
 11756 037e 00       		.byte	0
 11757 037f 01       		.byte	1
 11758 0380 00       		.byte	0
 11759 0381 03       		.byte	3
 11760 0382 00       		.byte	0
 11761 0383 00       		.byte	0
 11762 0384 00       		.byte	0
 11763 0385 00       		.byte	0
 11764 0386 00       		.byte	0
 11765 0387 30       		.byte	48
 11766 0388 01       		.byte	1
 11767 0389 00       		.byte	0
 11768 038a 00       		.byte	0
 11769 038b 00000000 		.space	5
 11769      00
 11770 0390 22       		.byte	34
 11771 0391 22       		.byte	34
 11772 0392 02       		.byte	2
 11773 0393 00       		.byte	0
 11774 0394 00       		.byte	0
 11775 0395 3F       		.byte	63
 11776 0396 00       		.byte	0
 11777 0397 01       		.byte	1
 11778 0398 00       		.byte	0
 11779 0399 03       		.byte	3
 11780 039a 00       		.byte	0
 11781 039b 00       		.byte	0
 11782 039c 00       		.byte	0
 11783 039d 00       		.byte	0
 11784 039e 00       		.byte	0
 11785 039f 30       		.byte	48
 11786 03a0 01       		.byte	1
 11787 03a1 00       		.byte	0
 11788 03a2 00       		.byte	0
 11789 03a3 00000000 		.space	5
 11789      00
 11790 03a8 23       		.byte	35
 11791 03a9 23       		.byte	35
 11792 03aa 02       		.byte	2
 11793 03ab 00       		.byte	0
 11794 03ac 00       		.byte	0
 11795 03ad 64       		.byte	100
 11796 03ae 00       		.byte	0
 11797 03af 01       		.byte	1
 11798 03b0 00       		.byte	0
 11799 03b1 03       		.byte	3
 11800 03b2 00       		.byte	0
 11801 03b3 10       		.byte	16
 11802 03b4 00       		.byte	0
 11803 03b5 10       		.byte	16
 11804 03b6 00       		.byte	0
 11805 03b7 30       		.byte	48
 11806 03b8 01       		.byte	1
 11807 03b9 00       		.byte	0
 11808 03ba 00       		.byte	0
 11809 03bb 00000000 		.space	5
 11809      00
 11810 03c0 24       		.byte	36
 11811 03c1 24       		.byte	36
 11812 03c2 02       		.byte	2
 11813 03c3 00       		.byte	0
 11814 03c4 00       		.byte	0
 11815 03c5 64       		.byte	100
 11816 03c6 00       		.byte	0
 11817 03c7 01       		.byte	1
 11818 03c8 00       		.byte	0
 11819 03c9 03       		.byte	3
 11820 03ca 00       		.byte	0
 11821 03cb 10       		.byte	16
 11822 03cc 00       		.byte	0
 11823 03cd 10       		.byte	16
 11824 03ce 00       		.byte	0
 11825 03cf 30       		.byte	48
 11826 03d0 01       		.byte	1
 11827 03d1 00       		.byte	0
 11828 03d2 00       		.byte	0
 11829 03d3 00000000 		.space	5
 11829      00
 11830 03d8 02       		.byte	2
 11831 03d9 03       		.byte	3
 11832 03da 04       		.byte	4
 11833 03db 00       		.byte	0
 11834 03dc 00       		.byte	0
 11835 03dd FF       		.byte	-1
 11836 03de 00       		.byte	0
 11837 03df 01       		.byte	1
 11838 03e0 00       		.byte	0
 11839 03e1 03       		.byte	3
 11840 03e2 00       		.byte	0
 11841 03e3 00       		.byte	0
 11842 03e4 20       		.byte	32
 11843 03e5 00       		.byte	0
 11844 03e6 20       		.byte	32
 11845 03e7 30       		.byte	48
 11846 03e8 01       		.byte	1
 11847 03e9 00       		.byte	0
 11848 03ea 00       		.byte	0
 11849 03eb 00000000 		.space	5
 11849      00
 11850 03f0 04       		.byte	4
 11851 03f1 04       		.byte	4
 11852 03f2 02       		.byte	2
 11853 03f3 00       		.byte	0
 11854 03f4 00       		.byte	0
 11855 03f5 3F       		.byte	63
 11856 03f6 00       		.byte	0
 11857 03f7 01       		.byte	1
 11858 03f8 00       		.byte	0
 11859 03f9 03       		.byte	3
 11860 03fa 00       		.byte	0
 11861 03fb 20       		.byte	32
 11862 03fc 00       		.byte	0
 11863 03fd 20       		.byte	32
 11864 03fe 00       		.byte	0
 11865 03ff 30       		.byte	48
 11866 0400 01       		.byte	1
 11867 0401 00       		.byte	0
 11868 0402 00       		.byte	0
 11869 0403 00000000 		.space	5
 11869      00
 11870 0408 00       		.byte	0
 11871 0409 00       		.byte	0
 11872 040a 02       		.byte	2
 11873 040b 00       		.byte	0
 11874 040c 00       		.byte	0
 11875 040d 19       		.byte	25
 11876 040e 00       		.byte	0
 11877 040f 01       		.byte	1
 11878 0410 00       		.byte	0
 11879 0411 03       		.byte	3
 11880 0412 00       		.byte	0
 11881 0413 00       		.byte	0
 11882 0414 00       		.byte	0
 11883 0415 00       		.byte	0
 11884 0416 00       		.byte	0
 11885 0417 30       		.byte	48
 11886 0418 01       		.byte	1
 11887 0419 00       		.byte	0
 11888 041a 00       		.byte	0
 11889 041b 00000000 		.space	5
 11889      00
 11890 0420 10       		.byte	16
 11891 0421 10       		.byte	16
 11892 0422 02       		.byte	2
 11893 0423 00       		.byte	0
 11894 0424 00       		.byte	0
 11895 0425 06       		.byte	6
 11896 0426 00       		.byte	0
 11897 0427 01       		.byte	1
 11898 0428 00       		.byte	0
 11899 0429 03       		.byte	3
 11900 042a 00       		.byte	0
 11901 042b 00       		.byte	0
 11902 042c 00       		.byte	0
 11903 042d 00       		.byte	0
 11904 042e 00       		.byte	0
 11905 042f 30       		.byte	48
 11906 0430 01       		.byte	1
 11907 0431 00       		.byte	0
 11908 0432 00       		.byte	0
 11909 0433 00000000 		.space	5
 11909      00
 11910 0438 00       		.byte	0
 11911 0439 00       		.byte	0
 11912 043a 02       		.byte	2
 11913 043b 00       		.byte	0
 11914 043c 00       		.byte	0
 11915 043d 03       		.byte	3
 11916 043e 00       		.byte	0
 11917 043f 01       		.byte	1
 11918 0440 00       		.byte	0
 11919 0441 03       		.byte	3
 11920 0442 00       		.byte	0
 11921 0443 00       		.byte	0
 11922 0444 00       		.byte	0
 11923 0445 00       		.byte	0
 11924 0446 00       		.byte	0
 11925 0447 30       		.byte	48
 11926 0448 01       		.byte	1
 11927 0449 00       		.byte	0
 11928 044a 00       		.byte	0
 11929 044b 00000000 		.space	5
 11929      00
 11930 0450 50       		.byte	80
 11931 0451 50       		.byte	80
 11932 0452 01       		.byte	1
 11933 0453 00       		.byte	0
 11934 0454 00       		.byte	0
 11935 0455 03       		.byte	3
 11936 0456 00       		.byte	0
 11937 0457 01       		.byte	1
 11938 0458 00       		.byte	0
 11939 0459 03       		.byte	3
 11940 045a 00       		.byte	0
 11941 045b 00       		.byte	0
 11942 045c 00       		.byte	0
 11943 045d 00       		.byte	0
 11944 045e 00       		.byte	0
 11945 045f 30       		.byte	48
 11946 0460 01       		.byte	1
 11947 0461 00       		.byte	0
 11948 0462 00       		.byte	0
 11949 0463 00000000 		.space	5
 11949      00
 11950 0468 00       		.byte	0
 11951 0469 00       		.byte	0
 11952 046a 0B       		.byte	11
 11953 046b 00       		.byte	0
 11954 046c 00       		.byte	0
 11955 046d FF       		.byte	-1
 11956 046e FF       		.byte	-1
 11957 046f 01       		.byte	1
 11958 0470 00       		.byte	0
 11959 0471 03       		.byte	3
 11960 0472 00       		.byte	0
 11961 0473 00       		.byte	0
 11962 0474 00       		.byte	0
 11963 0475 00       		.byte	0
 11964 0476 00       		.byte	0
 11965 0477 00       		.byte	0
 11966 0478 01       		.byte	1
 11967 0479 00       		.byte	0
 11968 047a 00       		.byte	0
 11969 047b 00000000 		.space	5
 11969      00
 11972              	glUVCHeader:
 11973 0480 0C       		.byte	12
 11974 0481 8C       		.byte	-116
 11975 0482 00       		.byte	0
 11976 0483 00       		.byte	0
 11977 0484 00       		.byte	0
 11978 0485 00       		.byte	0
 11979 0486 00       		.byte	0
 11980 0487 00       		.byte	0
 11981 0488 00       		.byte	0
 11982 0489 00       		.byte	0
 11983 048a 00       		.byte	0
 11984 048b 00       		.byte	0
 11987              	WBMenuCmpArry:
 11988 048c A0       		.byte	-96
 11989 048d 0F       		.byte	15
 11990 048e 0F       		.byte	15
 11991 048f F0       		.byte	-16
 11994              	CTCtrlParArry:
 11995 0490 00       		.byte	0
 11996 0491 00       		.byte	0
 11997 0492 01       		.byte	1
 11998 0493 00       		.byte	0
 11999 0494 00       		.byte	0
 12000 0495 03       		.byte	3
 12001 0496 00       		.byte	0
 12002 0497 01       		.byte	1
 12003 0498 00       		.byte	0
 12004 0499 03       		.byte	3
 12005 049a 00       		.byte	0
 12006 049b 03       		.byte	3
 12007 049c 00       		.byte	0
 12008 049d 03       		.byte	3
 12009 049e 00       		.byte	0
 12010 049f 30       		.byte	48
 12011 04a0 01       		.byte	1
 12012 04a1 00       		.byte	0
 12013 04a2 00       		.byte	0
 12014 04a3 00000000 		.space	5
 12014      00
 12015 04a8 00       		.byte	0
 12016 04a9 00       		.byte	0
 12017 04aa 01       		.byte	1
 12018 04ab 01       		.byte	1
 12019 04ac 00       		.byte	0
 12020 04ad 0F       		.byte	15
 12021 04ae 00       		.byte	0
 12022 04af 0F       		.byte	15
 12023 04b0 00       		.byte	0
 12024 04b1 03       		.byte	3
 12025 04b2 00       		.byte	0
 12026 04b3 02       		.byte	2
 12027 04b4 00       		.byte	0
 12028 04b5 02       		.byte	2
 12029 04b6 00       		.byte	0
 12030 04b7 30       		.byte	48
 12031 04b8 01       		.byte	1
 12032 04b9 01       		.byte	1
 12033 04ba 00       		.byte	0
 12034 04bb 00000000 		.space	5
 12034      00
 12035 04c0 02       		.byte	2
 12036 04c1 00       		.byte	0
 12037 04c2 01       		.byte	1
 12038 04c3 00       		.byte	0
 12039 04c4 00       		.byte	0
 12040 04c5 01       		.byte	1
 12041 04c6 00       		.byte	0
 12042 04c7 01       		.byte	1
 12043 04c8 00       		.byte	0
 12044 04c9 03       		.byte	3
 12045 04ca 00       		.byte	0
 12046 04cb 00       		.byte	0
 12047 04cc 00       		.byte	0
 12048 04cd 00       		.byte	0
 12049 04ce 00       		.byte	0
 12050 04cf 30       		.byte	48
 12051 04d0 01       		.byte	1
 12052 04d1 01       		.byte	1
 12053 04d2 00       		.byte	0
 12054 04d3 00000000 		.space	5
 12054      00
 12055 04d8 00       		.byte	0
 12056 04d9 00       		.byte	0
 12057 04da 04       		.byte	4
 12058 04db 01       		.byte	1
 12059 04dc 00       		.byte	0
 12060 04dd 38       		.byte	56
 12061 04de 01       		.byte	1
 12062 04df 01       		.byte	1
 12063 04e0 00       		.byte	0
 12064 04e1 03       		.byte	3
 12065 04e2 00       		.byte	0
 12066 04e3 4E       		.byte	78
 12067 04e4 00       		.byte	0
 12068 04e5 4E       		.byte	78
 12069 04e6 00       		.byte	0
 12070 04e7 30       		.byte	48
 12071 04e8 01       		.byte	1
 12072 04e9 00       		.byte	0
 12073 04ea 00       		.byte	0
 12074 04eb 00000000 		.space	5
 12074      00
 12075 04f0 04       		.byte	4
 12076 04f1 00       		.byte	0
 12077 04f2 01       		.byte	1
 12078 04f3 00       		.byte	0
 12079 04f4 00       		.byte	0
 12080 04f5 00       		.byte	0
 12081 04f6 00       		.byte	0
 12082 04f7 01       		.byte	1
 12083 04f8 00       		.byte	0
 12084 04f9 03       		.byte	3
 12085 04fa 00       		.byte	0
 12086 04fb 00       		.byte	0
 12087 04fc 00       		.byte	0
 12088 04fd 00       		.byte	0
 12089 04fe 00       		.byte	0
 12090 04ff 30       		.byte	48
 12091 0500 01       		.byte	1
 12092 0501 00       		.byte	0
 12093 0502 00       		.byte	0
 12094 0503 00000000 		.space	5
 12094      00
 12095 0508 05       		.byte	5
 12096 0509 00       		.byte	0
 12097 050a 02       		.byte	2
 12098 050b 00       		.byte	0
 12099 050c 00       		.byte	0
 12100 050d FF       		.byte	-1
 12101 050e 00       		.byte	0
 12102 050f 01       		.byte	1
 12103 0510 00       		.byte	0
 12104 0511 03       		.byte	3
 12105 0512 00       		.byte	0
 12106 0513 01       		.byte	1
 12107 0514 00       		.byte	0
 12108 0515 00       		.byte	0
 12109 0516 00       		.byte	0
 12110 0517 30       		.byte	48
 12111 0518 01       		.byte	1
 12112 0519 01       		.byte	1
 12113 051a 00       		.byte	0
 12114 051b 00000000 		.space	5
 12114      00
 12115 0520 06       		.byte	6
 12116 0521 00       		.byte	0
 12117 0522 02       		.byte	2
 12118 0523 00       		.byte	0
 12119 0524 00       		.byte	0
 12120 0525 00       		.byte	0
 12121 0526 00       		.byte	0
 12122 0527 00       		.byte	0
 12123 0528 00       		.byte	0
 12124 0529 03       		.byte	3
 12125 052a 00       		.byte	0
 12126 052b 00       		.byte	0
 12127 052c 00       		.byte	0
 12128 052d 00       		.byte	0
 12129 052e 00       		.byte	0
 12130 052f 30       		.byte	48
 12131 0530 01       		.byte	1
 12132 0531 01       		.byte	1
 12133 0532 00       		.byte	0
 12134 0533 00000000 		.space	5
 12134      00
 12135 0538 23       		.byte	35
 12136 0539 00       		.byte	0
 12137 053a 02       		.byte	2
 12138 053b 00       		.byte	0
 12139 053c 00       		.byte	0
 12140 053d 30       		.byte	48
 12141 053e 00       		.byte	0
 12142 053f 01       		.byte	1
 12143 0540 00       		.byte	0
 12144 0541 03       		.byte	3
 12145 0542 0A       		.byte	10
 12146 0543 00       		.byte	0
 12147 0544 00       		.byte	0
 12148 0545 0A       		.byte	10
 12149 0546 00       		.byte	0
 12150 0547 30       		.byte	48
 12151 0548 01       		.byte	1
 12152 0549 01       		.byte	1
 12153 054a 00       		.byte	0
 12154 054b 00000000 		.space	5
 12154      00
 12155 0550 08       		.byte	8
 12156 0551 00       		.byte	0
 12157 0552 01       		.byte	1
 12158 0553 00       		.byte	0
 12159 0554 00       		.byte	0
 12160 0555 7F       		.byte	127
 12161 0556 00       		.byte	0
 12162 0557 01       		.byte	1
 12163 0558 00       		.byte	0
 12164 0559 03       		.byte	3
 12165 055a 00       		.byte	0
 12166 055b 00       		.byte	0
 12167 055c 00       		.byte	0
 12168 055d 00       		.byte	0
 12169 055e 00       		.byte	0
 12170 055f 30       		.byte	48
 12171 0560 01       		.byte	1
 12172 0561 00       		.byte	0
 12173 0562 00       		.byte	0
 12174 0563 00000000 		.space	5
 12174      00
 12175 0568 09       		.byte	9
 12176 0569 00       		.byte	0
 12177 056a 02       		.byte	2
 12178 056b 00       		.byte	0
 12179 056c 00       		.byte	0
 12180 056d 05       		.byte	5
 12181 056e 00       		.byte	0
 12182 056f 01       		.byte	1
 12183 0570 00       		.byte	0
 12184 0571 03       		.byte	3
 12185 0572 00       		.byte	0
 12186 0573 00       		.byte	0
 12187 0574 00       		.byte	0
 12188 0575 00       		.byte	0
 12189 0576 00       		.byte	0
 12190 0577 30       		.byte	48
 12191 0578 01       		.byte	1
 12192 0579 00       		.byte	0
 12193 057a 00       		.byte	0
 12194 057b 00000000 		.space	5
 12194      00
 12195 0580 10       		.byte	16
 12196 0581 00       		.byte	0
 12197 0582 03       		.byte	3
 12198 0583 00       		.byte	0
 12199 0584 00       		.byte	0
 12200 0585 00       		.byte	0
 12201 0586 00       		.byte	0
 12202 0587 00       		.byte	0
 12203 0588 00       		.byte	0
 12204 0589 03       		.byte	3
 12205 058a 00       		.byte	0
 12206 058b 00       		.byte	0
 12207 058c 00       		.byte	0
 12208 058d 00       		.byte	0
 12209 058e 00       		.byte	0
 12210 058f 30       		.byte	48
 12211 0590 01       		.byte	1
 12212 0591 00       		.byte	0
 12213 0592 00       		.byte	0
 12214 0593 00000000 		.space	5
 12214      00
 12215 0598 00       		.byte	0
 12216 0599 00       		.byte	0
 12217 059a 02       		.byte	2
 12218 059b 00       		.byte	0
 12219 059c 00       		.byte	0
 12220 059d 40       		.byte	64
 12221 059e 00       		.byte	0
 12222 059f 01       		.byte	1
 12223 05a0 00       		.byte	0
 12224 05a1 03       		.byte	3
 12225 05a2 00       		.byte	0
 12226 05a3 0F       		.byte	15
 12227 05a4 11       		.byte	17
 12228 05a5 00       		.byte	0
 12229 05a6 00       		.byte	0
 12230 05a7 30       		.byte	48
 12231 05a8 01       		.byte	1
 12232 05a9 00       		.byte	0
 12233 05aa 00       		.byte	0
 12234 05ab 00000000 		.space	5
 12234      00
 12235 05b0 00       		.byte	0
 12236 05b1 00       		.byte	0
 12237 05b2 02       		.byte	2
 12238 05b3 00       		.byte	0
 12239 05b4 00       		.byte	0
 12240 05b5 64       		.byte	100
 12241 05b6 00       		.byte	0
 12242 05b7 01       		.byte	1
 12243 05b8 00       		.byte	0
 12244 05b9 03       		.byte	3
 12245 05ba 00       		.byte	0
 12246 05bb 00       		.byte	0
 12247 05bc 00       		.byte	0
 12248 05bd 00       		.byte	0
 12249 05be 00       		.byte	0
 12250 05bf 30       		.byte	48
 12251 05c0 01       		.byte	1
 12252 05c1 00       		.byte	0
 12253 05c2 00       		.byte	0
 12254 05c3 00000000 		.space	5
 12254      00
 12255 05c8 00       		.byte	0
 12256 05c9 00       		.byte	0
 12257 05ca 02       		.byte	2
 12258 05cb 00       		.byte	0
 12259 05cc 00       		.byte	0
 12260 05cd 64       		.byte	100
 12261 05ce 00       		.byte	0
 12262 05cf 01       		.byte	1
 12263 05d0 00       		.byte	0
 12264 05d1 03       		.byte	3
 12265 05d2 00       		.byte	0
 12266 05d3 00       		.byte	0
 12267 05d4 00       		.byte	0
 12268 05d5 00       		.byte	0
 12269 05d6 00       		.byte	0
 12270 05d7 30       		.byte	48
 12271 05d8 01       		.byte	1
 12272 05d9 00       		.byte	0
 12273 05da 00       		.byte	0
 12274 05db 00000000 		.space	5
 12274      00
 12275 05e0 00       		.byte	0
 12276 05e1 00       		.byte	0
 12277 05e2 02       		.byte	2
 12278 05e3 00       		.byte	0
 12279 05e4 00       		.byte	0
 12280 05e5 64       		.byte	100
 12281 05e6 00       		.byte	0
 12282 05e7 01       		.byte	1
 12283 05e8 00       		.byte	0
 12284 05e9 03       		.byte	3
 12285 05ea 00       		.byte	0
 12286 05eb 00       		.byte	0
 12287 05ec 00       		.byte	0
 12288 05ed 00       		.byte	0
 12289 05ee 00       		.byte	0
 12290 05ef 30       		.byte	48
 12291 05f0 01       		.byte	1
 12292 05f1 00       		.byte	0
 12293 05f2 00       		.byte	0
 12294 05f3 00000000 		.space	5
 12294      00
 12295 05f8 00       		.byte	0
 12296 05f9 00       		.byte	0
 12297 05fa 02       		.byte	2
 12298 05fb 00       		.byte	0
 12299 05fc 00       		.byte	0
 12300 05fd 64       		.byte	100
 12301 05fe 00       		.byte	0
 12302 05ff 01       		.byte	1
 12303 0600 00       		.byte	0
 12304 0601 03       		.byte	3
 12305 0602 00       		.byte	0
 12306 0603 00       		.byte	0
 12307 0604 00       		.byte	0
 12308 0605 00       		.byte	0
 12309 0606 00       		.byte	0
 12310 0607 30       		.byte	48
 12311 0608 01       		.byte	1
 12312 0609 00       		.byte	0
 12313 060a 00       		.byte	0
 12314 060b 00000000 		.space	5
 12314      00
 12317              	glProbeCtrl:
 12318 0610 00       		.byte	0
 12319 0611 00       		.byte	0
 12320 0612 01       		.byte	1
 12321 0613 01       		.byte	1
 12322 0614 15       		.byte	21
 12323 0615 16       		.byte	22
 12324 0616 05       		.byte	5
 12325 0617 00       		.byte	0
 12326 0618 00       		.byte	0
 12327 0619 00       		.byte	0
 12328 061a 00       		.byte	0
 12329 061b 00       		.byte	0
 12330 061c 00       		.byte	0
 12331 061d 00       		.byte	0
 12332 061e 00       		.byte	0
 12333 061f 00       		.byte	0
 12334 0620 00       		.byte	0
 12335 0621 00       		.byte	0
 12336 0622 00       		.byte	0
 12337 0623 48       		.byte	72
 12338 0624 3F       		.byte	63
 12339 0625 00       		.byte	0
 12340 0626 00       		.byte	0
 12341 0627 40       		.byte	64
 12342 0628 00       		.byte	0
 12343 0629 00       		.byte	0
 12344 062a 0000     		.space	2
 12347              	glProbeStilCtrl:
 12348 062c 01       		.byte	1
 12349 062d 01       		.byte	1
 12350 062e 00       		.byte	0
 12351 062f 00       		.byte	0
 12352 0630 48       		.byte	72
 12353 0631 3F       		.byte	63
 12354 0632 00       		.byte	0
 12355 0633 00       		.byte	0
 12356 0634 40       		.byte	64
 12357 0635 00       		.byte	0
 12358 0636 00       		.byte	0
 12359 0637 00       		.space	1
 12362              	glProbeStilCtrl20:
 12363 0638 01       		.byte	1
 12364 0639 01       		.byte	1
 12365 063a 00       		.byte	0
 12366 063b 00       		.byte	0
 12367 063c D2       		.byte	-46
 12368 063d 0F       		.byte	15
 12369 063e 00       		.byte	0
 12370 063f 00       		.byte	0
 12371 0640 40       		.byte	64
 12372 0641 00       		.byte	0
 12373 0642 00       		.byte	0
 12376              	snapButFlag:
 12377 0643 01       		.byte	1
 12380              	glProbeCtrl20:
 12381 0644 00       		.byte	0
 12382 0645 00       		.byte	0
 12383 0646 01       		.byte	1
 12384 0647 01       		.byte	1
 12385 0648 80       		.byte	-128
 12386 0649 1A       		.byte	26
 12387 064a 06       		.byte	6
 12388 064b 00       		.byte	0
 12389 064c 00       		.byte	0
 12390 064d 00       		.byte	0
 12391 064e 00       		.byte	0
 12392 064f 00       		.byte	0
 12393 0650 00       		.byte	0
 12394 0651 00       		.byte	0
 12395 0652 00       		.byte	0
 12396 0653 00       		.byte	0
 12397 0654 00       		.byte	0
 12398 0655 00       		.byte	0
 12399 0656 00       		.byte	0
 12400 0657 D2       		.byte	-46
 12401 0658 0F       		.byte	15
 12402 0659 00       		.byte	0
 12403 065a 00       		.byte	0
 12404 065b 40       		.byte	64
 12405 065c 00       		.byte	0
 12406 065d 00       		.byte	0
 12407 065e 0000     		.space	2
 12410              	CyFxGpifRegValue_usb2:
 12411 0660 08830080 		.word	-2147450104
 12412 0664 67000000 		.word	103
 12413 0668 01000000 		.word	1
 12414 066c 46000000 		.word	70
 12415 0670 00000000 		.word	0
 12416 0674 00000000 		.word	0
 12417 0678 02000000 		.word	2
 12418 067c 82000000 		.word	130
 12419 0680 82070000 		.word	1922
 12420 0684 40040000 		.word	1088
 12421 0688 FCFF0000 		.word	65532
 12422 068c 28000000 		.word	40
 12423 0690 00000000 		.word	0
 12424 0694 00000000 		.word	0
 12425 0698 00000000 		.word	0
 12426 069c 00000000 		.word	0
 12427 06a0 01000000 		.word	1
 12428 06a4 00000000 		.word	0
 12429 06a8 00000000 		.word	0
 12430 06ac 00000000 		.word	0
 12431 06b0 00000000 		.word	0
 12432 06b4 00000000 		.word	0
 12433 06b8 00000000 		.word	0
 12434 06bc 00000000 		.word	0
 12435 06c0 00000000 		.word	0
 12436 06c4 00000000 		.word	0
 12437 06c8 00000000 		.word	0
 12438 06cc 00000000 		.word	0
 12439 06d0 00000000 		.word	0
 12440 06d4 06000000 		.word	6
 12441 06d8 00000000 		.word	0
 12442 06dc FFFF0000 		.word	65535
 12443 06e0 09010000 		.word	265
 12444 06e4 00000000 		.word	0
 12445 06e8 F71F0000 		.word	8183
 12446 06ec 00000000 		.word	0
 12447 06f0 FFFF0000 		.word	65535
 12448 06f4 09010000 		.word	265
 12449 06f8 00000000 		.word	0
 12450 06fc F71F0000 		.word	8183
 12451 0700 00000000 		.word	0
 12452 0704 00000000 		.word	0
 12453 0708 00000000 		.word	0
 12454 070c 00000000 		.word	0
 12455 0710 00000000 		.word	0
 12456 0714 00000000 		.word	0
 12457 0718 00000000 		.word	0
 12458 071c 00000000 		.word	0
 12459 0720 00000000 		.word	0
 12460 0724 00000000 		.word	0
 12461 0728 00000000 		.word	0
 12462 072c 00000000 		.word	0
 12463 0730 00000000 		.word	0
 12464 0734 00000000 		.word	0
 12465 0738 00000000 		.word	0
 12466 073c 00000000 		.word	0
 12467 0740 00000000 		.word	0
 12468 0744 00000000 		.word	0
 12469 0748 00000000 		.word	0
 12470 074c 00000000 		.word	0
 12471 0750 00000000 		.word	0
 12472 0754 00000000 		.word	0
 12473 0758 00000000 		.word	0
 12474 075c 00040180 		.word	-2147417088
 12475 0760 01040180 		.word	-2147417087
 12476 0764 02040180 		.word	-2147417086
 12477 0768 03040180 		.word	-2147417085
 12478 076c 00000000 		.word	0
 12479 0770 00000000 		.word	0
 12480 0774 00000000 		.word	0
 12481 0778 00000000 		.word	0
 12482 077c 00000000 		.word	0
 12483 0780 00000000 		.word	0
 12484 0784 00000000 		.word	0
 12485 0788 00000000 		.word	0
 12486 078c C1FFFFFF 		.word	-63
 12489              	CyFxGpifWavedataPosition_usb2:
 12490 0790 00       		.byte	0
 12491 0791 01       		.byte	1
 12492 0792 02       		.byte	2
 12493 0793 03       		.byte	3
 12494 0794 04       		.byte	4
 12495 0795 05       		.byte	5
 12496 0796 06       		.byte	6
 12497 0797 07       		.byte	7
 12498 0798 08       		.byte	8
 12499 0799 09       		.byte	9
 12500 079a 0A       		.byte	10
 12501 079b 08       		.byte	8
 12502 079c 0B       		.byte	11
 12503 079d 0C       		.byte	12
 12504 079e 0D       		.byte	13
 12505 079f 08       		.byte	8
 12506 07a0 0E       		.byte	14
 12507 07a1 0F       		.byte	15
 12508 07a2 08       		.byte	8
 12509 07a3 08       		.byte	8
 12510 07a4 08       		.byte	8
 12511 07a5 08       		.byte	8
 12512 07a6 08       		.byte	8
 12513 07a7 08       		.byte	8
 12514 07a8 08       		.byte	8
 12515 07a9 08       		.byte	8
 12516 07aa 08       		.byte	8
 12517 07ab 08       		.byte	8
 12518 07ac 08       		.byte	8
 12519 07ad 08       		.byte	8
 12520 07ae 08       		.byte	8
 12521 07af 08       		.byte	8
 12522 07b0 08       		.byte	8
 12523 07b1 08       		.byte	8
 12524 07b2 08       		.byte	8
 12525 07b3 08       		.byte	8
 12526 07b4 08       		.byte	8
 12527 07b5 08       		.byte	8
 12528 07b6 08       		.byte	8
 12529 07b7 08       		.byte	8
 12530 07b8 08       		.byte	8
 12531 07b9 08       		.byte	8
 12532 07ba 08       		.byte	8
 12533 07bb 08       		.byte	8
 12534 07bc 08       		.byte	8
 12535 07bd 08       		.byte	8
 12536 07be 08       		.byte	8
 12537 07bf 08       		.byte	8
 12538 07c0 08       		.byte	8
 12539 07c1 08       		.byte	8
 12540 07c2 08       		.byte	8
 12541 07c3 08       		.byte	8
 12542 07c4 08       		.byte	8
 12543 07c5 08       		.byte	8
 12544 07c6 08       		.byte	8
 12545 07c7 08       		.byte	8
 12546 07c8 08       		.byte	8
 12547 07c9 08       		.byte	8
 12548 07ca 08       		.byte	8
 12549 07cb 08       		.byte	8
 12550 07cc 08       		.byte	8
 12551 07cd 08       		.byte	8
 12552 07ce 08       		.byte	8
 12553 07cf 08       		.byte	8
 12554 07d0 08       		.byte	8
 12555 07d1 08       		.byte	8
 12556 07d2 08       		.byte	8
 12557 07d3 08       		.byte	8
 12558 07d4 08       		.byte	8
 12559 07d5 08       		.byte	8
 12560 07d6 08       		.byte	8
 12561 07d7 08       		.byte	8
 12562 07d8 08       		.byte	8
 12563 07d9 08       		.byte	8
 12564 07da 08       		.byte	8
 12565 07db 08       		.byte	8
 12566 07dc 08       		.byte	8
 12567 07dd 08       		.byte	8
 12568 07de 08       		.byte	8
 12569 07df 08       		.byte	8
 12570 07e0 08       		.byte	8
 12571 07e1 08       		.byte	8
 12572 07e2 08       		.byte	8
 12573 07e3 08       		.byte	8
 12574 07e4 08       		.byte	8
 12575 07e5 08       		.byte	8
 12576 07e6 08       		.byte	8
 12577 07e7 08       		.byte	8
 12578 07e8 08       		.byte	8
 12579 07e9 08       		.byte	8
 12580 07ea 08       		.byte	8
 12581 07eb 08       		.byte	8
 12582 07ec 08       		.byte	8
 12583 07ed 08       		.byte	8
 12584 07ee 08       		.byte	8
 12585 07ef 08       		.byte	8
 12586 07f0 08       		.byte	8
 12587 07f1 08       		.byte	8
 12588 07f2 08       		.byte	8
 12589 07f3 08       		.byte	8
 12590 07f4 08       		.byte	8
 12591 07f5 08       		.byte	8
 12592 07f6 08       		.byte	8
 12593 07f7 08       		.byte	8
 12594 07f8 08       		.byte	8
 12595 07f9 08       		.byte	8
 12596 07fa 08       		.byte	8
 12597 07fb 08       		.byte	8
 12598 07fc 08       		.byte	8
 12599 07fd 08       		.byte	8
 12600 07fe 08       		.byte	8
 12601 07ff 08       		.byte	8
 12602 0800 08       		.byte	8
 12603 0801 08       		.byte	8
 12604 0802 08       		.byte	8
 12605 0803 08       		.byte	8
 12606 0804 08       		.byte	8
 12607 0805 08       		.byte	8
 12608 0806 08       		.byte	8
 12609 0807 08       		.byte	8
 12610 0808 08       		.byte	8
 12611 0809 08       		.byte	8
 12612 080a 08       		.byte	8
 12613 080b 08       		.byte	8
 12614 080c 08       		.byte	8
 12615 080d 08       		.byte	8
 12616 080e 08       		.byte	8
 12617 080f 08       		.byte	8
 12618 0810 00       		.byte	0
 12619 0811 01       		.byte	1
 12620 0812 02       		.byte	2
 12621 0813 10       		.byte	16
 12622 0814 04       		.byte	4
 12623 0815 05       		.byte	5
 12624 0816 06       		.byte	6
 12625 0817 07       		.byte	7
 12626 0818 08       		.byte	8
 12627 0819 09       		.byte	9
 12628 081a 0A       		.byte	10
 12629 081b 08       		.byte	8
 12630 081c 11       		.byte	17
 12631 081d 0C       		.byte	12
 12632 081e 0D       		.byte	13
 12633 081f 08       		.byte	8
 12634 0820 0E       		.byte	14
 12635 0821 0F       		.byte	15
 12636 0822 08       		.byte	8
 12637 0823 00       		.space	1
 12640              	CyFxGpifWavedata_usb2:
 12641 0824 0181731E 		.word	510886145
 12642 0828 00000000 		.word	0
 12643 082c 00000080 		.word	-2147483648
 12644 0830 00000000 		.word	0
 12645 0834 00000000 		.word	0
 12646 0838 00000000 		.word	0
 12647 083c 0201703E 		.word	1047527682
 12648 0840 00010000 		.word	256
 12649 0844 A00000C0 		.word	-1073741664
 12650 0848 00000000 		.word	0
 12651 084c 00000000 		.word	0
 12652 0850 00000000 		.word	0
 12653 0854 0394731E 		.word	510891011
 12654 0858 04000020 		.word	536870916
 12655 085c 60004080 		.word	-2143289248
 12656 0860 00000000 		.word	0
 12657 0864 00000000 		.word	0
 12658 0868 00000000 		.word	0
 12659 086c 0620702E 		.word	779100166
 12660 0870 0C000000 		.word	12
 12661 0874 00000080 		.word	-2147483648
 12662 0878 0620702E 		.word	779100166
 12663 087c 0C000000 		.word	12
 12664 0880 00000080 		.word	-2147483648
 12665 0884 0394731E 		.word	510891011
 12666 0888 04000020 		.word	536870916
 12667 088c 60004080 		.word	-2143289248
 12668 0890 0620702E 		.word	779100166
 12669 0894 0C000000 		.word	12
 12670 0898 00000080 		.word	-2147483648
 12671 089c 0C93731E 		.word	510890764
 12672 08a0 04000024 		.word	603979780
 12673 08a4 90004080 		.word	-2143289200
 12674 08a8 0D20702E 		.word	779100173
 12675 08ac 0C000000 		.word	12
 12676 08b0 00000080 		.word	-2147483648
 12677 08b4 0780724E 		.word	1316126727
 12678 08b8 0A000000 		.word	10
 12679 08bc 00000080 		.word	-2147483648
 12680 08c0 08000000 		.word	8
 12681 08c4 00000000 		.word	0
 12682 08c8 00010080 		.word	-2147483392
 12683 08cc 0920702E 		.word	779100169
 12684 08d0 0C010000 		.word	268
 12685 08d4 00000080 		.word	-2147483648
 12686 08d8 0A01701E 		.word	510656778
 12687 08dc 0E000100 		.word	65550
 12688 08e0 00000080 		.word	-2147483648
 12689 08e4 00000000 		.word	0
 12690 08e8 00000000 		.word	0
 12691 08ec 00000000 		.word	0
 12692 08f0 00000000 		.word	0
 12693 08f4 00000000 		.word	0
 12694 08f8 00000000 		.word	0
 12695 08fc 0394731E 		.word	510891011
 12696 0900 04000020 		.word	536870916
 12697 0904 60004080 		.word	-2143289248
 12698 0908 08000000 		.word	8
 12699 090c 00000000 		.word	0
 12700 0910 00010080 		.word	-2147483392
 12701 0914 0B000000 		.word	11
 12702 0918 00000000 		.word	0
 12703 091c 00010080 		.word	-2147483392
 12704 0920 0C93731E 		.word	510890764
 12705 0924 04000024 		.word	603979780
 12706 0928 90004080 		.word	-2143289200
 12707 092c 0D20702E 		.word	779100173
 12708 0930 0C000000 		.word	12
 12709 0934 00000080 		.word	-2147483648
 12710 0938 0D20702E 		.word	779100173
 12711 093c 0C000000 		.word	12
 12712 0940 00000080 		.word	-2147483648
 12713 0944 0E60724E 		.word	1316118542
 12714 0948 0A000000 		.word	10
 12715 094c 00000080 		.word	-2147483648
 12716 0950 0F000000 		.word	15
 12717 0954 00000000 		.word	0
 12718 0958 00010080 		.word	-2147483392
 12719 095c 1020702E 		.word	779100176
 12720 0960 0C010000 		.word	268
 12721 0964 00000080 		.word	-2147483648
 12722 0968 1101701E 		.word	510656785
 12723 096c 0E000100 		.word	65550
 12724 0970 00000080 		.word	-2147483648
 12725 0974 0C93731E 		.word	510890764
 12726 0978 04000024 		.word	603979780
 12727 097c 90004080 		.word	-2143289200
 12728 0980 0F000000 		.word	15
 12729 0984 00000000 		.word	0
 12730 0988 00010080 		.word	-2147483392
 12731 098c 12000000 		.word	18
 12732 0990 00000000 		.word	0
 12733 0994 00010080 		.word	-2147483392
 12734 0998 0394731E 		.word	510891011
 12735 099c 04000020 		.word	536870916
 12736 09a0 60004080 		.word	-2143289248
 12737 09a4 0480732E 		.word	779321348
 12738 09a8 02010000 		.word	258
 12739 09ac 000040C0 		.word	-1069547520
 12740 09b0 0580732E 		.word	779321349
 12741 09b4 02010000 		.word	258
 12742 09b8 000040C0 		.word	-1069547520
 12743 09bc 0580732E 		.word	779321349
 12744 09c0 02010000 		.word	258
 12745 09c4 000040C0 		.word	-1069547520
 12746 09c8 0480732E 		.word	779321348
 12747 09cc 02010000 		.word	258
 12748 09d0 000040C0 		.word	-1069547520
 12751              	CyFxGpifTransition_usb2:
 12752 09d4 0000     		.short	0
 12753 09d6 5555     		.short	21845
 12754 09d8 AAAA     		.short	-21846
 12755 09da 8888     		.short	-30584
 12756 09dc 1111     		.short	4369
 12757 09de 4444     		.short	17476
 12758 09e0 3333     		.short	13107
 12759 09e2 CCCC     		.short	-13108
 12762              	CyFxGpifRegValue:
 12763 09e4 08830080 		.word	-2147450104
 12764 09e8 67000000 		.word	103
 12765 09ec 00000000 		.word	0
 12766 09f0 46000000 		.word	70
 12767 09f4 00000000 		.word	0
 12768 09f8 00000000 		.word	0
 12769 09fc 02000000 		.word	2
 12770 0a00 82000000 		.word	130
 12771 0a04 82070000 		.word	1922
 12772 0a08 40040000 		.word	1088
 12773 0a0c FCFF0000 		.word	65532
 12774 0a10 28000000 		.word	40
 12775 0a14 00000000 		.word	0
 12776 0a18 00000000 		.word	0
 12777 0a1c 00000000 		.word	0
 12778 0a20 00000000 		.word	0
 12779 0a24 01000000 		.word	1
 12780 0a28 00000000 		.word	0
 12781 0a2c 00000000 		.word	0
 12782 0a30 00000000 		.word	0
 12783 0a34 00000000 		.word	0
 12784 0a38 00000000 		.word	0
 12785 0a3c 00000000 		.word	0
 12786 0a40 00000000 		.word	0
 12787 0a44 00000000 		.word	0
 12788 0a48 00000000 		.word	0
 12789 0a4c 00000000 		.word	0
 12790 0a50 00000000 		.word	0
 12791 0a54 00000000 		.word	0
 12792 0a58 06000000 		.word	6
 12793 0a5c 00000000 		.word	0
 12794 0a60 FFFF0000 		.word	65535
 12795 0a64 09010000 		.word	265
 12796 0a68 00000000 		.word	0
 12797 0a6c F71F0000 		.word	8183
 12798 0a70 00000000 		.word	0
 12799 0a74 FFFF0000 		.word	65535
 12800 0a78 09010000 		.word	265
 12801 0a7c 00000000 		.word	0
 12802 0a80 F71F0000 		.word	8183
 12803 0a84 00000000 		.word	0
 12804 0a88 00000000 		.word	0
 12805 0a8c 00000000 		.word	0
 12806 0a90 00000000 		.word	0
 12807 0a94 00000000 		.word	0
 12808 0a98 00000000 		.word	0
 12809 0a9c 00000000 		.word	0
 12810 0aa0 00000000 		.word	0
 12811 0aa4 00000000 		.word	0
 12812 0aa8 00000000 		.word	0
 12813 0aac 00000000 		.word	0
 12814 0ab0 00000000 		.word	0
 12815 0ab4 00000000 		.word	0
 12816 0ab8 00000000 		.word	0
 12817 0abc 00000000 		.word	0
 12818 0ac0 00000000 		.word	0
 12819 0ac4 00000000 		.word	0
 12820 0ac8 00000000 		.word	0
 12821 0acc 00000000 		.word	0
 12822 0ad0 00000000 		.word	0
 12823 0ad4 00000000 		.word	0
 12824 0ad8 00000000 		.word	0
 12825 0adc 00000000 		.word	0
 12826 0ae0 00040180 		.word	-2147417088
 12827 0ae4 01040180 		.word	-2147417087
 12828 0ae8 02040180 		.word	-2147417086
 12829 0aec 03040180 		.word	-2147417085
 12830 0af0 00000000 		.word	0
 12831 0af4 00000000 		.word	0
 12832 0af8 00000000 		.word	0
 12833 0afc 00000000 		.word	0
 12834 0b00 00000000 		.word	0
 12835 0b04 00000000 		.word	0
 12836 0b08 00000000 		.word	0
 12837 0b0c 00000000 		.word	0
 12838 0b10 C1FFFFFF 		.word	-63
 12841              	CyFxGpifWavedataPosition:
 12842 0b14 00       		.byte	0
 12843 0b15 01       		.byte	1
 12844 0b16 02       		.byte	2
 12845 0b17 03       		.byte	3
 12846 0b18 04       		.byte	4
 12847 0b19 05       		.byte	5
 12848 0b1a 06       		.byte	6
 12849 0b1b 07       		.byte	7
 12850 0b1c 08       		.byte	8
 12851 0b1d 09       		.byte	9
 12852 0b1e 0A       		.byte	10
 12853 0b1f 0B       		.byte	11
 12854 0b20 0B       		.byte	11
 12855 0b21 0B       		.byte	11
 12856 0b22 0B       		.byte	11
 12857 0b23 00       		.space	1
 12860              	CyFxGpifWavedata:
 12861 0b24 0181731E 		.word	510886145
 12862 0b28 00000000 		.word	0
 12863 0b2c 00000080 		.word	-2147483648
 12864 0b30 00000000 		.word	0
 12865 0b34 00000000 		.word	0
 12866 0b38 00000000 		.word	0
 12867 0b3c 0201702E 		.word	779092226
 12868 0b40 00010000 		.word	256
 12869 0b44 A0000080 		.word	-2147483488
 12870 0b48 00000000 		.word	0
 12871 0b4c 00000000 		.word	0
 12872 0b50 00000000 		.word	0
 12873 0b54 0380722E 		.word	779255811
 12874 0b58 02010020 		.word	536871170
 12875 0b5c 60000080 		.word	-2147483552
 12876 0b60 00000000 		.word	0
 12877 0b64 00000000 		.word	0
 12878 0b68 00000000 		.word	0
 12879 0b6c 0460722E 		.word	779247620
 12880 0b70 02010024 		.word	603980034
 12881 0b74 90000080 		.word	-2147483504
 12882 0b78 0594731E 		.word	510891013
 12883 0b7c 06000000 		.word	6
 12884 0b80 00000080 		.word	-2147483648
 12885 0b84 0380722E 		.word	779255811
 12886 0b88 02010020 		.word	536871170
 12887 0b8c 60000080 		.word	-2147483552
 12888 0b90 0693731E 		.word	510890758
 12889 0b94 06000000 		.word	6
 12890 0b98 00000080 		.word	-2147483648
 12891 0b9c 0720703E 		.word	1047535623
 12892 0ba0 08010000 		.word	264
 12893 0ba4 00000080 		.word	-2147483648
 12894 0ba8 0820703E 		.word	1047535624
 12895 0bac 08010000 		.word	264
 12896 0bb0 00000080 		.word	-2147483648
 12897 0bb4 0920703E 		.word	1047535625
 12898 0bb8 08010000 		.word	264
 12899 0bbc 00000080 		.word	-2147483648
 12900 0bc0 0A20703E 		.word	1047535626
 12901 0bc4 08010000 		.word	264
 12902 0bc8 00000080 		.word	-2147483648
 12903 0bcc 0380722E 		.word	779255811
 12904 0bd0 02010020 		.word	536871170
 12905 0bd4 60000080 		.word	-2147483552
 12906 0bd8 0B000000 		.word	11
 12907 0bdc 00000000 		.word	0
 12908 0be0 00010080 		.word	-2147483392
 12909 0be4 0460722E 		.word	779247620
 12910 0be8 02010024 		.word	603980034
 12911 0bec 90000080 		.word	-2147483504
 12912 0bf0 0D000000 		.word	13
 12913 0bf4 00000000 		.word	0
 12914 0bf8 00010080 		.word	-2147483392
 12915 0bfc 0460722E 		.word	779247620
 12916 0c00 02010024 		.word	603980034
 12917 0c04 90000080 		.word	-2147483504
 12918 0c08 0C000000 		.word	12
 12919 0c0c 00000000 		.word	0
 12920 0c10 00010080 		.word	-2147483392
 12921 0c14 0380722E 		.word	779255811
 12922 0c18 02010020 		.word	536871170
 12923 0c1c 60000080 		.word	-2147483552
 12924 0c20 0E000000 		.word	14
 12925 0c24 00000000 		.word	0
 12926 0c28 00010080 		.word	-2147483392
 12927 0c2c 00000000 		.word	0
 12928 0c30 00000000 		.word	0
 12929 0c34 00000000 		.word	0
 12930 0c38 00000000 		.word	0
 12931 0c3c 00000000 		.word	0
 12932 0c40 00000000 		.word	0
 12935              	CyFxGpifTransition:
 12936 0c44 0000     		.short	0
 12937 0c46 5555     		.short	21845
 12938 0c48 8888     		.short	-30584
 12939 0c4a AAAA     		.short	-21846
 12940 0c4c 3333     		.short	13107
 12941 0c4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 12942              		.align	2
 12943              	.LC0:
 12944 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 12944      7065722D 
 12944      74696D65 
 12944      72202564 
 12944      0D0A00
 12945 0013 00       		.space	1
 12946              	.LC1:
 12947 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 12947      636F6D6D 
 12947      616E6420 
 12947      71756575 
 12947      65206973 
 12948 0037 00       		.space	1
 12949              	.LC2:
 12950 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 12950      7220696E 
 12950      206D756C 
 12950      74696368 
 12950      616E6E65 
 12951 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 12951      2C20646D 
 12951      61446F6E 
 12951      65202578 
 12951      0D0A00
 12952 007e 0000     		.space	2
 12953              	.LC3:
 12954 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 12954      5420656E 
 12954      636F756E 
 12954      74657265 
 12954      642E2E2E 
 12955              	.LC4:
 12956 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 12956      454E4420 
 12956      656E636F 
 12956      756E7465 
 12956      7265642E 
 12957 00c2 0000     		.space	2
 12958              	.LC5:
 12959 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 12959      64697363 
 12959      6F6E6E65 
 12959      63746564 
 12959      2E2E2E30 
 12960 00e3 00       		.space	1
 12961              	.LC6:
 12962 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 12962      43595F46 
 12962      585F5556 
 12962      435F5649 
 12962      44454F5F 
 12963 0117 0A00     		.ascii	"\012\000"
 12964 0119 000000   		.space	3
 12965              	.LC7:
 12966 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 12966      43595F46 
 12966      585F5556 
 12966      435F5649 
 12966      44454F5F 
 12967 014f 00       		.ascii	"\000"
 12968              	.LC8:
 12969 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 12969      726E6174 
 12969      65207365 
 12969      7474696E 
 12969      6720302E 
 12970              	.LC9:
 12971 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 12971      72206665 
 12971      61747572 
 12971      65207265 
 12971      71756573 
 12972 018b 00       		.space	1
 12973              	.LC10:
 12974 018c 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 12974      49324320 
 12974      636F6D6D 
 12974      616E6420 
 12974      69732030 
 12975 01bf 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 12975      78257820 
 12975      30782578 
 12975      20307825 
 12975      78203078 
 12976              	.LC11:
 12977 01d8 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 12977      206C6967 
 12977      68742063 
 12977      6F6D7065 
 12977      6E736174 
 12978 020b 25640D0A 		.ascii	"%d\015\012\000"
 12978      00
 12979              	.LC12:
 12980 0210 54686520 		.ascii	"The I2C current data is not available. try again. %"
 12980      49324320 
 12980      63757272 
 12980      656E7420 
 12980      64617461 
 12981 0243 64202564 		.ascii	"d %d\015\012\000"
 12981      0D0A00
 12982 024a 0000     		.space	2
 12983              	.LC13:
 12984 024c 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 12984      26414743 
 12984      2073656E 
 12984      7420746F 
 12984      20686F73 
 12985 0272 0000     		.space	2
 12986              	.LC14:
 12987 0274 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 12987      26414743 
 12987      20676F74 
 12987      74656E20 
 12987      66726F6D 
 12988 029e 0000     		.space	2
 12989              	.LC15:
 12990 02a0 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 12990      6C657665 
 12990      6C2E2025 
 12990      64202564 
 12990      3B202564 
 12991 02ba 0000     		.space	2
 12992              	.LC16:
 12993 02bc 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 12993      7365742E 
 12993      20256420 
 12993      25643B20 
 12993      25642025 
 12994              	.LC17:
 12995 02d4 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 12995      67657420 
 12995      64617461 
 12995      2066726F 
 12995      6D20686F 
 12996 0301 000000   		.space	3
 12997              	.LC18:
 12998 0304 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 12998      52657175 
 12998      65737420 
 12998      30782578 
 12998      20706172 
 12999 0337 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 12999      6E642074 
 12999      6F20686F 
 12999      73742030 
 12999      78257820 
 13000 0352 0000     		.space	2
 13001              	.LC19:
 13002 0354 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 13002      204F7020 
 13002      72656365 
 13002      69766573 
 13002      20284354 
 13003 037b 00       		.space	1
 13004              	.LC20:
 13005 037c 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 13005      756C7420 
 13005      73656C65 
 13005      63746F72 
 13005      20284354 
 13006 039e 0000     		.space	2
 13007              	.LC21:
 13008 03a0 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 13008      756C7420 
 13008      72657175 
 13008      65737420 
 13008      28435429 
 13009 03c1 000000   		.space	3
 13010              	.LC22:
 13011 03c4 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 13011      52657175 
 13011      65737420 
 13011      30782578 
 13011      20706172 
 13012 03f7 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 13012      20307825 
 13012      78202F20 
 13012      73656E64 
 13012      20746F20 
 13013 0424 00       		.ascii	"\000"
 13014 0425 000000   		.space	3
 13015              	.LC23:
 13016 0428 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 13016      73657420 
 13016      64656620 
 13016      64617461 
 13016      20307825 
 13017 0447 00       		.space	1
 13018              	.LC24:
 13019 0448 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 13019      73657420 
 13019      64656620 
 13019      64617461 
 13019      20307825 
 13020 047b 2E0D0A00 		.ascii	".\015\012\000"
 13021 047f 00       		.space	1
 13022              	.LC25:
 13023 0480 4572726F 		.ascii	"Error handler...\015\012\000"
 13023      72206861 
 13023      6E646C65 
 13023      722E2E2E 
 13023      0D0A00
 13024 0493 00       		.space	1
 13025              	.LC26:
 13026 0494 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 13026      73706565 
 13026      64203D20 
 13026      25642065 
 13026      76656E66 
 13027 04c4 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 13027      71756573 
 13027      74203D20 
 13027      30782578 
 13027      20775661 
 13028 04f4 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 13028      203D2030 
 13028      78257820 
 13028      6973666C 
 13028      61672030 
 13029 050e 0000     		.space	2
 13030              	.LC27:
 13031 0510 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 13031      64656661 
 13031      756C7420 
 13031      73657475 
 13031      70207265 
 13032              	.LC28:
 13033 053c 47657420 		.ascii	"Get UVC Prob(set) control %d %d %d %d %d %d %d\015\012"
 13033      55564320 
 13033      50726F62 
 13033      28736574 
 13033      2920636F 
 13034 056c 00       		.ascii	"\000"
 13035 056d 000000   		.space	3
 13036              	.LC29:
 13037 0570 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 13037      74686520 
 13037      76696465 
 13037      6F206D6F 
 13037      64652066 
 13038 0591 000000   		.space	3
 13039              	.LC30:
 13040 0594 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 13040      74686520 
 13040      76696465 
 13040      6F206D6F 
 13040      64652066 
 13041 05b9 000000   		.space	3
 13042              	.LC31:
 13043 05bc 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 13043      43595F46 
 13043      585F5556 
 13043      435F5354 
 13043      5245414D 
 13044 05e2 0000     		.space	2
 13045              	.LC32:
 13046 05e4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 13046      55564320 
 13046      7374696C 
 13046      6C205072 
 13046      6F622873 
 13047 060f 00       		.space	1
 13048              	.LC33:
 13049 0610 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 13049      43595F46 
 13049      585F5556 
 13049      435F5354 
 13049      494C5F45 
 13050              	.LC34:
 13051 0634 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 13051      55564320 
 13051      7374696C 
 13051      6C207472 
 13051      69676765 
 13052 065d 000000   		.space	3
 13053              	.LC35:
 13054 0660 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 13054      7374696C 
 13054      6C207472 
 13054      69676765 
 13054      7220636F 
 13055 0687 00       		.space	1
 13056              	.LC36:
 13057 0688 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 13057      65642074 
 13057      6F207365 
 13057      6E642069 
 13057      6E746572 
 13058 06b9 0A00     		.ascii	"\012\000"
 13059 06bb 00       		.space	1
 13060              	.LC37:
 13061 06bc 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 13061      6F6D6D69 
 13061      74656F66 
 13061      20737461 
 13061      7465203D 
 13062              	.LC38:
 13063 06d4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 13063      6E656C20 
 13063      53657420 
 13063      57726170 
 13063      55702066 
 13064 0701 000000   		.space	3
 13065              	.LC39:
 13066 0704 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 13066      69742045 
 13066      4F462066 
 13066      61696C65 
 13066      64210A00 
 13067              	.LC40:
 13068 0718 49324320 		.ascii	"I2C initialization failed!\012\000"
 13068      696E6974 
 13068      69616C69 
 13068      7A617469 
 13068      6F6E2066 
 13069              	.LC41:
 13070 0734 49324320 		.ascii	"I2C configuration failed!\012\000"
 13070      636F6E66 
 13070      69677572 
 13070      6174696F 
 13070      6E206661 
 13071 074f 00       		.space	1
 13072              	.LC42:
 13073 0750 55415254 		.ascii	"UART initialization failed!\012\000"
 13073      20696E69 
 13073      7469616C 
 13073      697A6174 
 13073      696F6E20 
 13074 076d 000000   		.space	3
 13075              	.LC43:
 13076 0770 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 13076      43726561 
 13076      74652045 
 13076      76656E74 
 13076      20666169 
 13077 079a 0000     		.space	2
 13078              	.LC44:
 13079 079c 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 13079      20496E69 
 13079      74206661 
 13079      696C6564 
 13079      2C204572 
 13080 07bf 00       		.space	1
 13081              	.LC45:
 13082 07c0 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 13082      204F7665 
 13082      72726964 
 13082      65206661 
 13082      696C6564 
 13083 07e7 00       		.space	1
 13084              	.LC46:
 13085 07e8 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 13085      28323029 
 13085      204F7665 
 13085      72726964 
 13085      65206661 
 13086 0813 00       		.space	1
 13087              	.LC47:
 13088 0814 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 13088      28323429 
 13088      204F7665 
 13088      72726964 
 13088      65206661 
 13089 083f 00       		.space	1
 13090              	.LC48:
 13091 0840 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 13091      20536574 
 13091      20287265 
 13091      73657420 
 13091      32322920 
 13092 0872 00       		.ascii	"\000"
 13093 0873 00       		.space	1
 13094              	.LC49:
 13095 0874 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 13095      20536574 
 13095      2028706F 
 13095      77657220 
 13095      32302920 
 13096 08a6 00       		.ascii	"\000"
 13097 08a7 00       		.space	1
 13098              	.LC50:
 13099 08a8 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 13099      20536574 
 13099      2028736E 
 13099      61702073 
 13099      686F7420 
 13100 08db 25640A00 		.ascii	"%d\012\000"
 13101 08df 00       		.space	1
 13102              	.LC51:
 13103 08e0 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 13103      46756E63 
 13103      74696F6E 
 13103      20466169 
 13103      6C656420 
 13104 090f 00       		.space	1
 13105              	.LC52:
 13106 0910 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 13106      46756E63 
 13106      74696F6E 
 13106      20466169 
 13106      6C656420 
 13107 093f 00       		.space	1
 13108              	.LC53:
 13109 0940 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 13109      53657420 
 13109      456E6470 
 13109      6F696E74 
 13109      20636F6E 
 13110 0970 00       		.ascii	"\000"
 13111 0971 000000   		.space	3
 13112              	.LC54:
 13113 0974 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 13113      496E7465 
 13113      72727570 
 13113      74205374 
 13113      61747573 
 13114 09a7 20436F64 		.ascii	" Code = %d\012\000"
 13114      65203D20 
 13114      25640A00 
 13115 09b3 00       		.space	1
 13116              	.LC55:
 13117 09b4 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 13117      65642074 
 13117      6F20616C 
 13117      6C6F6361 
 13117      7465206D 
 13118 09e7 65720D0A 		.ascii	"er\015\012\000"
 13118      00
 13119              	.LC56:
 13120 09ec 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 13120      4368616E 
 13120      6E656C20 
 13120      43726561 
 13120      74696F6E 
 13121 0a1a 0000     		.space	2
 13122              	.LC57:
 13123 0a1c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 13123      436F6E6E 
 13123      65637420 
 13123      6661696C 
 13123      65642C20 
 13124 0a41 000000   		.space	3
 13125              	.LC58:
 13126 0a44 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 13126      74686520 
 13126      76696465 
 13126      6F206D6F 
 13126      64652066 
 13127 0a66 0000     		.space	2
 13128              	.LC59:
 13129 0a68 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 13129      4368616E 
 13129      6E656C20 
 13129      52657365 
 13129      74204661 
 13130 0a93 00       		.space	1
 13131              	.LC60:
 13132 0a94 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 13132      4368616E 
 13132      6E656C20 
 13132      53657420 
 13132      5472616E 
 13133 0ac5 00       		.ascii	"\000"
 13134 0ac6 0000     		.space	2
 13135              	.LC61:
 13136 0ac8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 13136      4368616E 
 13136      6E656C20 
 13136      53657420 
 13136      5472616E 
 13137 0af9 0A00     		.ascii	"\012\000"
 13138 0afb 00       		.space	1
 13139              	.LC62:
 13140 0afc 0D0A2073 		.ascii	"\015\012 super gpif\000"
 13140      75706572 
 13140      20677069 
 13140      6600
 13141 0b0a 0000     		.space	2
 13142              	.LC63:
 13143 0b0c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 13143      69676820 
 13143      67706966 
 13143      00
 13144 0b19 000000   		.space	3
 13145              	.LC64:
 13146 0b1c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 13146      696E6720 
 13146      47504946 
 13146      20436F6E 
 13146      66696775 
 13147 0b4f 0A00     		.ascii	"\012\000"
 13148 0b51 000000   		.space	3
 13149              	.LC65:
 13150 0b54 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 13150      74696E67 
 13150      20475049 
 13150      46207374 
 13150      61746520 
 13151 0b87 0D0A00   		.ascii	"\015\012\000"
 13152 0b8a 0000     		.space	2
 13153              	.LC66:
 13154 0b8c 33303A55 		.ascii	"30:UVC App Thread\000"
 13154      56432041 
 13154      70702054 
 13154      68726561 
 13154      6400
 13155 0b9e 0000     		.space	2
 13156              	.LC67:
 13157 0ba0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 13157      56432041 
 13157      70702045 
 13157      50302054 
 13157      68726561 
 13158 0bb6 0000     		.space	2
 13159              	.LC68:
 13160 0bb8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 13160      32432041 
 13160      70702043 
 13160      54524C20 
 13160      54687265 
 13161 0bcf 00       		.bss
 13162              		.align	2
 13163              		.set	.LANCHOR0,. + 0
 13166              	glFxUVCEvent:
 13167 0000 00000000 		.space	40
 13167      00000000 
 13167      00000000 
 13167      00000000 
 13167      00000000 
 13170              	timercount:
 13171 0028 00       		.space	1
 13172 0029 000000   		.space	3
 13175              	curFlag:
 13176 002c 00000000 		.space	64
 13176      00000000 
 13176      00000000 
 13176      00000000 
 13176      00000000 
 13179              	fb:
 13180 006c 0000     		.space	2
 13183              	pb:
 13184 006e 0000     		.space	2
 13187              	pbc:
 13188 0070 0000     		.space	2
 13189 0072 0000     		.space	2
 13192              	stiflag:
 13193 0074 00000000 		.space	4
 13196              	hitFV:
 13197 0078 00000000 		.space	4
 13200              	prodCount:
 13201 007c 0000     		.space	2
 13204              	consCount:
 13205 007e 0000     		.space	2
 13208              	streamingStarted:
 13209 0080 00000000 		.space	4
 13212              	gpif_initialized:
 13213 0084 00000000 		.space	4
 13216              	isUsbConnected:
 13217 0088 00000000 		.space	4
 13220              	clearFeatureRqtReceived:
 13221 008c 00000000 		.space	4
 13224              	I2CCMDArry:
 13225 0090 00000000 		.space	12
 13225      00000000 
 13225      00000000 
 13228              	glEp0Buffer:
 13229 009c 00000000 		.space	32
 13229      00000000 
 13229      00000000 
 13229      00000000 
 13229      00000000 
 13232              	WDRflag:
 13233 00bc 00000000 		.space	4
 13236              	usbSpeed:
 13237 00c0 00       		.space	1
 13238 00c1 000000   		.space	3
 13241              	glCommitCtrl:
 13242 00c4 00000000 		.space	32
 13242      00000000 
 13242      00000000 
 13242      00000000 
 13242      00000000 
 13245              	setRes:
 13246 00e4 00       		.space	1
 13249              	IMcount.8108:
 13250 00e5 00       		.space	1
 13251 00e6 0000     		.space	2
 13254              	uvcAppThread:
 13255 00e8 00000000 		.space	168
 13255      00000000 
 13255      00000000 
 13255      00000000 
 13255      00000000 
 13258              	uvcAppEP0Thread:
 13259 0190 00000000 		.space	168
 13259      00000000 
 13259      00000000 
 13259      00000000 
 13259      00000000 
 13262              	i2cAppThread:
 13263 0238 00000000 		.space	168
 13263      00000000 
 13263      00000000 
 13263      00000000 
 13263      00000000 
 13266              	pbcpbak:
 13267 02e0 0000     		.space	2
 13270              	pbcbak:
 13271 02e2 0000     		.space	2
 13274              	pbbak:
 13275 02e4 0000     		.space	2
 13278              	fbbak:
 13279 02e6 0000     		.space	2
 13282              	testSnap:
 13283 02e8 00       		.space	1
 13284 02e9 000000   		.text
 13285              	.Letext0:
 13286              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 13287              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13288              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 13289              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 13290              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 13291              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13292              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13293              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13294              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13295              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13296              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13297              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13298              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13299              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13300              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13301              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13302              		.file 18 "../cmdqu.h"
 13303              		.file 19 "../uvc.h"
 13304              		.file 20 "../cyfxgpif2config.h"
 13305              		.file 21 "../cyfxgpif2config_usb2_720.h"
 13306              		.file 22 "../sensor.h"
 13307              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:38     .text:00000010 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:42     .text:00000014 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:45     .text:00000014 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:205    .text:0000015c $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:211    .text:0000016c $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:330    .text:00000258 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:342    .text:0000027c $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:345    .text:0000027c CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:577    .text:00000414 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:587    .text:00000430 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:589    .text:00000430 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:804    .text:000005ac $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:815    .text:000005bc $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:817    .text:000005bc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1175   .text:00000878 $d
                            *COM*:00000002 wLength
                            *COM*:00000001 bRequest
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
                            *COM*:00000002 wValue
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1193   .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1196   .text:000008a4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1332   .text:000009c4 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1337   .text:000009cc $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1340   .text:000009cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1408   .text:00000a48 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1601   .text:00000bc0 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1643   .text:00000c5c $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1698   .text:00000cd8 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:1734   .text:00000d60 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:2989   .text:000018f0 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:3009   .text:00001934 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:3012   .text:00001934 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:3159   .text:00001a5c $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:3172   .text:00001a84 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:3588   .text:00001eb4 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:3599   .text:00001ed4 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:3869   .text:00002168 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:3881   .text:0000218c $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:3884   .text:0000218c CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4183   .text:00002444 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4190   .text:00002454 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4193   .text:00002454 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4237   .text:00002498 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4242   .text:000024a0 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4245   .text:000024a0 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4273   .text:000024bc $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4277   .text:000024c0 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4280   .text:000024c0 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4350   .text:00002538 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:4358   .text:00002548 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:6169   .text:00003478 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000ac glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:6212   .text:00003500 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9223   .text:00004a54 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9236   .text:00004a6c $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9239   .text:00004a6c CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9271   .text:00004aa0 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9284   .text:00004acc $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9289   .text:00004adc $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9294   .text:00004aec $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9341   .text:00004b44 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9351   .text:00004b58 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9354   .text:00004b58 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9423   .text:00004bc4 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9429   .text:00004bd0 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:9432   .text:00004bd0 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10560  .text:000054f4 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10615  .text:000055bc $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10618  .text:000055bc CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10784  .text:00005724 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10801  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10804  .text.startup:00000000 main
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:11972  .data:00000480 glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12362  .data:00000638 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12380  .data:00000644 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12347  .data:0000062c glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12317  .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13208  .bss:00000080 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13220  .bss:0000008c clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13236  .bss:000000c0 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13216  .bss:00000088 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13266  .bss:000002e0 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13270  .bss:000002e2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13274  .bss:000002e4 pbbak
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13278  .bss:000002e6 fbbak
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13187  .bss:00000070 pbc
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13183  .bss:0000006e pb
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13179  .bss:0000006c fb
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13282  .bss:000002e8 testSnap
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12376  .data:00000643 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10990  .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12410  .data:00000660 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12489  .data:00000790 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12640  .data:00000824 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12751  .data:000009d4 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10977  .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12762  .data:000009e4 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12841  .data:00000b14 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12860  .data:00000b24 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12935  .data:00000c44 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10943  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10947  .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:10966  .rodata:00000010 ShutValueArry
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:11002  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:11006  .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:11329  .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:11987  .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:11994  .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:12942  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13162  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13166  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13170  .bss:00000028 timercount
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13175  .bss:0000002c curFlag
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13192  .bss:00000074 stiflag
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13196  .bss:00000078 hitFV
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13200  .bss:0000007c prodCount
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13204  .bss:0000007e consCount
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13212  .bss:00000084 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13224  .bss:00000090 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13228  .bss:0000009c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13232  .bss:000000bc WDRflag
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13241  .bss:000000c4 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13245  .bss:000000e4 setRes
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13249  .bss:000000e5 IMcount.8108
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13254  .bss:000000e8 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13258  .bss:00000190 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cckxFwYr.s:13262  .bss:00000238 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_event_flags_set
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
memset
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
memcpy
SensorGetControl
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetWrapUp
CyU3PI2cInit
CyU3PI2cSetConfig
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
