   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** 
 105:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 106:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 107:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 108:../uvc.c      ****                                                            received. */
 109:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 110:../uvc.c      **** #ifdef BACKFLOW_DETECT
 111:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 112:../uvc.c      **** #endif
 113:../uvc.c      **** 
 114:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 115:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 116:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 117:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 118:../uvc.c      **** #endif
 119:../uvc.c      **** 
 120:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 121:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 122:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 123:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 125:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 126:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 127:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 128:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 129:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 131:../uvc.c      ****                                    with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 133:../uvc.c      ****                                    streaming with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 135:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 136:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 137:../uvc.c      **** };
 138:../uvc.c      **** 
 139:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 140:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 141:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 143:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 144:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 145:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 146:../uvc.c      **** };
 147:../uvc.c      **** 
 148:../uvc.c      **** 
 149:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 150:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 151:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 152:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 154:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 155:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 156:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 157:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 158:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 159:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 160:../uvc.c      ****                                    with adjustable compression parameters */
 161:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 162:../uvc.c      ****                                    streaming with adjustable compression parameters */
 163:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 164:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 169:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 170:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 171:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 172:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 173:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 174:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 175:../uvc.c      **** };
 176:../uvc.c      **** 
 177:../uvc.c      **** 
 178:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 179:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 180:../uvc.c      **** 
 181:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 182:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 183:../uvc.c      **** {
 184:../uvc.c      ****     0x0C,                               /* Header Length */
 185:../uvc.c      ****     0x8C,                               /* Bit field header field */
 186:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 188:../uvc.c      **** };
 189:../uvc.c      **** 
 190:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 191:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 192:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 193:../uvc.c      ****                                                            the current video frame. */
 194:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 195:../uvc.c      **** #define isWBMamu   0  // Is white balance control manual mode.
 196:../uvc.c      **** 
 197:../uvc.c      **** /************ control parameters array ***********
 198:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 199:../uvc.c      ****  *    e.g.
 200:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 201:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 202:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 203:../uvc.c      ****  **************************************************/
 204:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 205:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 206:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 207:../uvc.c      **** #ifndef CAM720
 208:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   3,
 209:../uvc.c      **** #else
 210:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 211:../uvc.c      **** #endif
 212:../uvc.c      **** 		{BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0, 118,
 213:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 214:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 215:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 216:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 217:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 218:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 219:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 220:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 221:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 222:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 223:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 224:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 225:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 226:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 227:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 228:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 229:../uvc.c      **** #ifndef CAM720
 230:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   3,
 231:../uvc.c      **** #else
 232:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 233:../uvc.c      **** #endif
 234:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 235:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 236:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 237:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 238:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 239:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 240:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 241:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 242:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0,   0,
 244:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 245:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 246:../uvc.c      **** 		/**********************************
 247:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 248:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 249:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 250:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 251:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 252:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 253:../uvc.c      **** 		 *
 254:../uvc.c      **** 		 *********************************/
 255:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 256:../uvc.c      **** };
 257:../uvc.c      **** 
 258:../uvc.c      **** #ifndef CAM720
 259:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 260:../uvc.c      **** #else
 261:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 262:../uvc.c      **** #endif
 263:../uvc.c      **** 
 264:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 265:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 266:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 267:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 268:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 269:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 270:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 271:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 272:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 273:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 274:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 275:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 276:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 277:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 278:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 279:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 280:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 281:../uvc.c      **** };
 282:../uvc.c      **** 
 283:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 284:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 285:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 286:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 287:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 288:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 289:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 290:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 291:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 292:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 293:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 294:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 295:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 296:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 297:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 298:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 299:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 300:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 301:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 302:../uvc.c      **** };
 303:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 304:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 305:../uvc.c      **** /*
 306:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 307:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 308:../uvc.c      ****  */
 309:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 310:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 311:../uvc.c      **** };
 312:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 313:../uvc.c      **** 		0
 314:../uvc.c      **** };
 315:../uvc.c      **** 
 316:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 317:../uvc.c      **** 
 318:../uvc.c      **** void I2CCmdHandler(){
 319:../uvc.c      **** 	uint8_t buf[2];
 320:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 321:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 322:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 323:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 324:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 325:../uvc.c      **** 
 326:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 327:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 328:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 329:../uvc.c      **** 
 330:../uvc.c      **** 	if(CmdType == 0)//I2C read
 331:../uvc.c      **** 	{
 332:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 333:../uvc.c      **** #if 0 //for debugging
 334:../uvc.c      **** 		/* test still image operation */
 335:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 336:../uvc.c      **** 			snapButFlag = 0; //press
 337:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 338:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 339:../uvc.c      **** 			snapButFlag = 0xf; //release
 340:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 341:../uvc.c      **** 		}
 342:../uvc.c      **** 
 343:../uvc.c      **** 		/* end of the test */
 344:../uvc.c      **** #endif
 345:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 346:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 347:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 348:../uvc.c      **** 			if(CmdDataLen == 2){
 349:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 350:../uvc.c      **** 			}
 351:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 352:../uvc.c      **** 		}else{//not support currently
 353:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 354:../uvc.c      **** 		}
 355:../uvc.c      **** 	}else if(CmdType == 1){
 356:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 357:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 358:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 359:../uvc.c      **** 				cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 360:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 361:../uvc.c      **** 			}
 362:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 363:../uvc.c      **** 		}else{//not support currently
 364:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 365:../uvc.c      **** 		}
 366:../uvc.c      **** 
 367:../uvc.c      **** 	}
 368:../uvc.c      **** }
 369:../uvc.c      **** 
 370:../uvc.c      **** /************************************
 371:../uvc.c      ****  * set Iris mode
 372:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 373:../uvc.c      ****  */
 374:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 375:../uvc.c      **** 	uint8_t dataIdx;
 376:../uvc.c      **** 	  dataIdx = 0;
 377:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 378:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 379:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 380:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 381:../uvc.c      **** }
 382:../uvc.c      **** 
 383:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 384:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 385:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 386:../uvc.c      ****     uint16_t readCount;
 387:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 388:../uvc.c      ****     uint8_t devAdd;
 389:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 390:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 391:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 392:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 393:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 394:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 395:../uvc.c      ****     }else{
 396:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 397:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 398:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 399:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 400:../uvc.c      ****     }
 401:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 402:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 403:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 404:../uvc.c      **** #endif
 405:../uvc.c      ****     reqData = bRequest;
 406:../uvc.c      ****     /*
 407:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 408:../uvc.c      ****      */
 409:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 410:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 411:../uvc.c      ****     	goto EndofSet;
 412:../uvc.c      ****     }
 413:../uvc.c      ****     switch (bRequest)
 414:../uvc.c      **** 		 {
 415:../uvc.c      **** 
 416:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 417:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 418:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 419:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 420:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 421:../uvc.c      **** 			  break;
 422:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 423:../uvc.c      **** 
 424:../uvc.c      **** 			 switch(CtrlID)
 425:../uvc.c      **** 			 {
 426:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 427:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 428:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 429:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 430:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 431:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 432:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 433:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 434:../uvc.c      **** 			 	 		 break;
 435:../uvc.c      **** 			 	 }
 436:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 437:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 438:../uvc.c      **** 					 if(CamMode == 1){//720p
 439:../uvc.c      **** 						if(sendData >= 3){
 440:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 441:../uvc.c      **** 							sendData = 0; //set back to default
 442:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 443:../uvc.c      **** 						}
 444:../uvc.c      **** 						sendData += 4;
 445:../uvc.c      **** 					 }
 446:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 447:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 448:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 449:../uvc.c      **** 					 break;
 450:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 451:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 452:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 453:../uvc.c      **** 			 		 }
 454:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 455:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 456:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 457:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 458:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 459:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 460:../uvc.c      **** #endif
 461:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 462:../uvc.c      **** 			 		 {
 463:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 464:../uvc.c      **** 			 		 }
 465:../uvc.c      **** 			 		 break;
 466:../uvc.c      **** 				 case ExtAexModCtlID9:
 467:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 468:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 469:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 470:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 471:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 472:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 473:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 474:../uvc.c      **** 					 break;
 475:../uvc.c      **** 
 476:../uvc.c      **** 			 	 case BrgtCtlID1:
 477:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 478:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 479:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 480:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 481:../uvc.c      **** 					 }else{
 482:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 483:../uvc.c      **** 					 }
 484:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 485:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 486:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 487:../uvc.c      **** 					 break;
 488:../uvc.c      **** 				 case HueCtlID5:
 489:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 490:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 491:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 492:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 493:../uvc.c      **** 					 break;
 494:../uvc.c      **** 				 case WBTLevCtlID11:
 495:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 497:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 498:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 499:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 500:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 501:../uvc.c      **** 					 break;
 502:../uvc.c      **** 				 case SaturCtlID6:
 503:../uvc.c      **** 				 default:
 504:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 505:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 506:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 507:../uvc.c      **** 					 break;
 508:../uvc.c      **** 			 }
 509:../uvc.c      **** 
 510:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 511:../uvc.c      **** 
 512:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 513:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 514:../uvc.c      **** #endif
 515:../uvc.c      **** 			  break;
 516:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 517:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 518:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 519:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 520:../uvc.c      **** 		 	 }
 521:../uvc.c      **** 
 522:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 523:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 524:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 525:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 526:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 527:../uvc.c      **** 			 }else
 528:../uvc.c      **** 			 {
 529:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 530:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 531:../uvc.c      **** 			 }
 532:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 533:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 534:../uvc.c      **** 			  break;
 535:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 536:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 537:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 538:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 539:../uvc.c      **** 		 	 }
 540:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 541:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 542:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 543:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 544:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 545:../uvc.c      **** 			 }else
 546:../uvc.c      **** 			 {
 547:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 548:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 549:../uvc.c      **** 			 }
 550:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 551:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 552:../uvc.c      **** 			  break;
 553:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 554:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 555:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 556:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 557:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 558:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 559:../uvc.c      **** 		 	 }
 560:../uvc.c      **** 		 	 else{
 561:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 562:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 563:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 564:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 565:../uvc.c      **** 		 	 }
 566:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 567:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 568:../uvc.c      **** 			  break;
 569:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 570:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 571:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 572:../uvc.c      **** 		 	 }
 573:../uvc.c      **** 		 	 else{
 574:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 575:../uvc.c      **** 		 	 }
 576:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 577:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 578:../uvc.c      **** 			  Len = 1;
 579:../uvc.c      **** 			  break;
 580:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 581:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 584:../uvc.c      **** 		 	 }
 585:../uvc.c      **** 
 586:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 587:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 588:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 589:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 590:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 591:../uvc.c      **** 			 }else{
 592:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 594:../uvc.c      **** 			 }
 595:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 597:../uvc.c      **** 			  break;
 598:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 599:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 600:../uvc.c      **** 				  glEp0Buffer, &readCount);
 601:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 602:../uvc.c      **** 			   {
 603:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 604:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 605:../uvc.c      **** 				  getData = glEp0Buffer[0];
 606:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 607:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 608:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 609:../uvc.c      **** #endif
 610:../uvc.c      **** 				  switch(CtrlID)
 611:../uvc.c      **** 					 {
 612:../uvc.c      **** 						 case ExtShutCtlID0:
 613:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 614:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 615:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 616:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 617:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 618:../uvc.c      **** 									 }else{
 619:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 620:../uvc.c      **** 									 }
 621:../uvc.c      **** 								 }
 622:../uvc.c      **** 							 }else{
 623:../uvc.c      **** 								 Data1 = Data0 - 1;
 624:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 625:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 626:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 627:../uvc.c      **** 									 }else{
 628:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 629:../uvc.c      **** 									 }
 630:../uvc.c      **** 								 }
 631:../uvc.c      **** 								 if(Data1 < 8){
 632:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 633:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 634:../uvc.c      **** 								 }else{
 635:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 636:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 637:../uvc.c      **** 								 }
 638:../uvc.c      **** 							 }
 639:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 640:../uvc.c      **** 							 dataIdx = 0;
 641:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 642:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 643:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 644:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 645:../uvc.c      **** 							 break;
 646:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 647:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 648:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 650:../uvc.c      **** 							 dataIdx = 0;
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 652:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 653:../uvc.c      **** 							 if(getData != 0){
 654:../uvc.c      **** 								 dataIdx++;
 655:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 656:../uvc.c      **** 							 }
 657:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 658:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 659:../uvc.c      **** 							 break;
 660:../uvc.c      **** 						 case ExtCamMCtlID12:
 661:../uvc.c      **** 							 /*
 662:../uvc.c      **** 							 dataIdx = 0;
 663:../uvc.c      **** 							 if(Data0 <= 3){
 664:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 665:../uvc.c      **** 								 Data1 = Data0;
 666:../uvc.c      **** 							 }else{
 667:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 668:../uvc.c      **** 								 Data1 = Data0-4;
 669:../uvc.c      **** 							 }
 670:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 671:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 672:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 673:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 674:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 675:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 676:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 677:../uvc.c      **** 							 */
 678:../uvc.c      **** 							 break;
 679:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 680:../uvc.c      **** 							 dataIdx = 0;
 681:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 682:../uvc.c      **** 								 Data0 = 1;
 683:../uvc.c      **** 							 }else{ //save current sensor parameters.
 684:../uvc.c      **** 								 Data0 = 0;
 685:../uvc.c      **** 							 }
 686:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 687:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 688:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 689:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 690:../uvc.c      **** 							 break;
 691:../uvc.c      **** 						 case ExtI2CCtlID15:
 692:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 693:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 694:../uvc.c      **** 					 		 }
 695:../uvc.c      **** 					 		I2CCmdHandler();
 696:../uvc.c      **** 							 break;
 697:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 698:../uvc.c      **** 							 dataIdx = 0;
 699:../uvc.c      **** #if 0 //seperate version
 700:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 701:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 702:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 703:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 704:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 705:../uvc.c      **** 							 }else{ //disable BLD window
 706:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 707:../uvc.c      **** 							 }
 708:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 709:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 710:../uvc.c      **** 							 dataIdx++;
 711:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 712:../uvc.c      **** 							 dataIdx++;
 713:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 714:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 715:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 716:../uvc.c      **** 							 dataIdx++;
 717:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 718:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 719:../uvc.c      **** #else //combination version
 720:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 721:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 722:../uvc.c      **** 						     /* end test */
 723:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 724:../uvc.c      **** 							 dataIdx++;
 725:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 726:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 727:../uvc.c      **** 							 getData1 = Data1;
 728:../uvc.c      **** #endif
 729:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 730:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 731:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 732:../uvc.c      **** 							 break;
 733:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 734:../uvc.c      **** 							 dataIdx = 0;
 735:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 736:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 737:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 738:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 739:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 740:../uvc.c      **** 							 break;
 741:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 742:../uvc.c      **** 							 dataIdx = 0;
 743:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 744:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 745:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 746:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 748:../uvc.c      **** 							 break;
 749:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 750:../uvc.c      **** 							 dataIdx = 0;
 751:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 752:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 753:../uvc.c      **** 							  if(Data0&0x80){
 754:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 755:../uvc.c      **** 							  }else{
 756:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 757:../uvc.c      **** 							  }
 758:../uvc.c      **** 							 Data1 |= ~0x03;
 759:../uvc.c      **** 							 Data1 &= 0xC7;
 760:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 761:../uvc.c      **** 						  	 dataIdx++;
 762:../uvc.c      **** 
 763:../uvc.c      **** 							 Data0 = (Data0 << 2);
 764:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 765:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 766:../uvc.c      **** 
 767:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 768:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 769:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 770:../uvc.c      **** 
 771:../uvc.c      **** 							 break;
 772:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 773:../uvc.c      **** 							 dataIdx = 0;
 774:../uvc.c      **** 
 775:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 776:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 777:../uvc.c      **** 							 dataIdx++;
 778:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 779:../uvc.c      **** 							 dataIdx++;
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 781:../uvc.c      **** 							 dataIdx++;
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 783:../uvc.c      **** 							 dataIdx++;
 784:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 785:../uvc.c      **** 							 dataIdx++;
 786:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 787:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 788:../uvc.c      **** 
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 791:../uvc.c      **** 							 break;
 792:../uvc.c      **** 						 case SaturCtlID6:
 793:../uvc.c      **** 							 dataIdx = 0;
 794:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 795:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 797:../uvc.c      **** 							 dataIdx++;
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 799:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 800:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 801:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 802:../uvc.c      **** 							 break;
 803:../uvc.c      **** 
 804:../uvc.c      **** 						 case WBTLevCtlID11:
 805:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 806:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 807:../uvc.c      **** 							 dataIdx = 0;
 808:../uvc.c      **** 
 809:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 810:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 811:../uvc.c      **** 							 dataIdx++;
 812:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 813:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 814:../uvc.c      **** 
 815:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 816:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 818:../uvc.c      **** 							 break;
 819:../uvc.c      **** 						 case MFreqCtlID4:
 820:../uvc.c      **** 							 dataIdx = 0;
 821:../uvc.c      **** 							 Data0 = Data0 - 1;
 822:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 823:../uvc.c      **** 								 Data0 = 0;
 824:../uvc.c      **** 							 else if(Data0 >2)
 825:../uvc.c      **** 								 Data0 = 1;
 826:../uvc.c      **** 
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 830:../uvc.c      **** 
 831:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 832:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 833:../uvc.c      **** 							 break;
 834:../uvc.c      **** 					 	 case BLCCtlID0:
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 836:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 837:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 838:../uvc.c      **** 							 {
 839:../uvc.c      **** 								 if(Data0 < 2){
 840:../uvc.c      **** 					 				 //Data0 += 4;
 841:../uvc.c      **** 					 			 }else{
 842:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 843:../uvc.c      **** 									Data0 = 0; //set to default.
 844:../uvc.c      **** 					 			 }
 845:../uvc.c      **** 					 		 }
 846:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 847:../uvc.c      **** 							 dataIdx = 0;
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 851:../uvc.c      **** 
 852:../uvc.c      **** 					 		 break;
 853:../uvc.c      **** 						 default:
 854:../uvc.c      **** 							 dataIdx = 0;
 855:../uvc.c      **** 
 856:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 857:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 858:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 859:../uvc.c      **** 
 860:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 862:../uvc.c      **** 							 break;
 863:../uvc.c      **** 					 }
 864:../uvc.c      **** 			   }else{
 865:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 866:../uvc.c      **** 			   }
 867:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 868:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 869:../uvc.c      **** #endif
 870:../uvc.c      **** 
 871:../uvc.c      **** 			  break;
 872:../uvc.c      **** 		  default:
 873:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 874:../uvc.c      **** 			  break;
 875:../uvc.c      **** 		 }
 876:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 877:../uvc.c      **** }
 878:../uvc.c      **** /************** CT control requests handler *************************/
 879:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 880:../uvc.c      **** 
 881:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 882:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 883:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 884:../uvc.c      ****     uint16_t readCount;
 885:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 886:../uvc.c      ****     uint16_t diff, value, diffRd;
 887:../uvc.c      ****     uint8_t i, shutter, index;
 888:../uvc.c      ****     diff = 0xffff;
 889:../uvc.c      ****     shutter = 1;
 890:../uvc.c      ****     index = 1;
 891:../uvc.c      **** 
 892:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 893:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 894:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 895:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 896:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 897:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 898:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 899:../uvc.c      **** #endif
 900:../uvc.c      ****     reqData = bRequest;
 901:../uvc.c      **** 
 902:../uvc.c      ****     switch (bRequest)
 903:../uvc.c      **** 		 {
 904:../uvc.c      **** 
 905:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 906:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 907:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 908:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 909:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 910:../uvc.c      **** 			  break;
 911:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 912:../uvc.c      **** 
 913:../uvc.c      **** 			 switch(CtrlID)
 914:../uvc.c      **** 			 {
 915:../uvc.c      **** 				 default:
 916:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 917:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 918:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 919:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 920:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 921:../uvc.c      **** 					 break;
 922:../uvc.c      **** 			 }
 923:../uvc.c      **** 
 924:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 925:../uvc.c      **** 
 926:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 927:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 928:../uvc.c      **** #endif
 929:../uvc.c      **** 			  break;
 930:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 931:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 932:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 933:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 934:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 935:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 936:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 937:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 938:../uvc.c      **** 			  break;
 939:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 940:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 941:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 942:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 943:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 944:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 945:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 946:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 947:../uvc.c      **** 			  break;
 948:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 949:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 950:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 951:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 952:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 953:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 954:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 955:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 956:../uvc.c      **** 			  break;
 957:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 958:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 960:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 961:../uvc.c      **** 			  Len = 1;
 962:../uvc.c      **** 			  break;
 963:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 964:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 965:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 966:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 967:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 968:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 969:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 970:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 971:../uvc.c      **** 			  break;
 972:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 973:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 974:../uvc.c      **** 			  glEp0Buffer, &readCount);
 975:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 976:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 977:../uvc.c      **** 			  value = Data1;
 978:../uvc.c      **** 
 979:../uvc.c      **** 			  switch(CtrlID)
 980:../uvc.c      **** 			  {
 981:../uvc.c      **** 		  	      case AutoExMCtlID1:
 982:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
 983:../uvc.c      **** 
 984:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 985:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 986:../uvc.c      **** 				    getData = glEp0Buffer[0];
 987:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
 988:../uvc.c      **** 		  		    switch (getData){
 989:../uvc.c      **** 						case 1:
 990:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
 991:../uvc.c      **** 							break;
 992:../uvc.c      **** 						case 2:
 993:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 994:../uvc.c      **** 							dataIdx = 0;
 995:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 996:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 997:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 998:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 999:../uvc.c      **** 
1000:../uvc.c      **** 							break;
1001:../uvc.c      **** 						case 4:
1002:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1003:../uvc.c      **** 							break;
1004:../uvc.c      **** 						case 8:
1005:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1006:../uvc.c      **** 			  		    	dataIdx = 0;
1007:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1008:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1009:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1010:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1011:../uvc.c      **** 							break;
1012:../uvc.c      **** 		  		    }
1013:../uvc.c      **** #if 0
1014:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1015:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1016:../uvc.c      **** 						  dataIdx = 0;
1017:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1018:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1019:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1020:../uvc.c      **** 		  		    }
1021:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1022:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1023:../uvc.c      **** 		  		    }
1024:../uvc.c      **** #endif
1025:../uvc.c      **** 				    break;
1026:../uvc.c      **** 
1027:../uvc.c      **** 			  	  case ExTmACtlID3:
1028:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1029:../uvc.c      **** 
1030:../uvc.c      **** 					  value = (value << 8)|Data0;
1031:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1032:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1033:../uvc.c      **** 					  {
1034:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1035:../uvc.c      **** 						  {
1036:../uvc.c      **** 							if(value > ShutValueArry[i]){
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1038:../uvc.c      **** 							}else{
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1040:../uvc.c      **** 							}
1041:../uvc.c      **** 							  if(diff > diffRd){
1042:../uvc.c      **** 								  diff = diffRd;
1043:../uvc.c      **** 								  index = i;
1044:../uvc.c      **** 							  }
1045:../uvc.c      **** 						  }
1046:../uvc.c      **** 						  shutter = shutter+index;
1047:../uvc.c      **** 
1048:../uvc.c      **** 						  dataIdx = 0;
1049:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1050:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1051:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1052:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1053:../uvc.c      **** 
1054:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1055:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1056:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1057:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1058:../uvc.c      **** 					  }else{
1059:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1060:../uvc.c      **** 					  }
1061:../uvc.c      **** 					  getData = glEp0Buffer[0];
1062:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1063:../uvc.c      **** 					  break;
1064:../uvc.c      **** 			  	  case IriACtlID7:
1065:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1066:../uvc.c      **** 					  {
1067:../uvc.c      **** 							 dataIdx = 0;
1068:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1069:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1070:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1071:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1072:../uvc.c      **** 
1073:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1074:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1075:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1076:../uvc.c      **** 					  }else{
1077:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1078:../uvc.c      **** 					  }
1079:../uvc.c      **** 					  getData = glEp0Buffer[0];
1080:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1081:../uvc.c      **** 
1082:../uvc.c      **** 					  break;
1083:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1084:../uvc.c      **** 					  getData = glEp0Buffer[0];
1085:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1086:../uvc.c      **** #if 1
1087:../uvc.c      **** 					  dataIdx = 0;
1088:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1089:../uvc.c      **** 					  if(getData == 1)
1090:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1091:../uvc.c      **** 					  else if(getData == 0xff)
1092:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1093:../uvc.c      **** 					  else
1094:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1095:../uvc.c      **** 					  //dataIdx++;
1096:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1097:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1098:../uvc.c      **** #endif
1099:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1100:../uvc.c      **** 					  break;
1101:../uvc.c      **** 
1102:../uvc.c      **** 			  	  default:
1103:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1104:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1105:../uvc.c      **** 			  		 break;
1106:../uvc.c      **** 			  }
1107:../uvc.c      **** 			  break;
1108:../uvc.c      **** 		  default:
1109:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1110:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1111:../uvc.c      **** 			  break;
1112:../uvc.c      **** 		 }
1113:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1114:../uvc.c      **** 
1115:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1116:../uvc.c      **** }
1117:../uvc.c      **** 
1118:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1119:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1120:../uvc.c      **** {
1121:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1122:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1123:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1124:../uvc.c      **** 
1125:../uvc.c      ****     CtrlID = BrgtCtlID1;
1126:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1127:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1128:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1129:../uvc.c      ****     Data1 = Data0;
1130:../uvc.c      **** 
1131:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1132:../uvc.c      ****     if(Data1&0x80){
1133:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1134:../uvc.c      ****     }else{
1135:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1136:../uvc.c      ****     }
1137:../uvc.c      ****     Data0 = (Data0 << 2);
1138:../uvc.c      **** 
1139:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1140:../uvc.c      **** 
1141:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1142:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1143:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1144:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1145:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1146:../uvc.c      **** 
1147:../uvc.c      ****     CtrlID = ConsCtlID2;
1148:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1149:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1150:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1151:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1152:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1153:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1154:../uvc.c      **** 
1155:../uvc.c      ****     CtrlID = HueCtlID5;
1156:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1157:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1158:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1159:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1160:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1161:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1162:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1163:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1164:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1165:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1167:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1168:../uvc.c      **** 
1169:../uvc.c      ****     CtrlID = SaturCtlID6;
1170:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1171:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1172:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1173:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1174:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1175:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1176:../uvc.c      **** 
1177:../uvc.c      ****     CtrlID = ShapCtlID7;
1178:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1179:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1180:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1181:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1182:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1183:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1184:../uvc.c      **** 
1185:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1186:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1187:../uvc.c      **** 	return;
1188:../uvc.c      **** }
1189:../uvc.c      **** 
1190:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1191:../uvc.c      **** void
1192:../uvc.c      **** CyFxUVCAddHeader (
1193:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1194:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1195:../uvc.c      ****         )
1196:../uvc.c      **** {
1197:../uvc.c      ****     /* Copy header to buffer */
1198:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1199:../uvc.c      **** 
1200:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1201:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1202:../uvc.c      ****     {
1203:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1204:../uvc.c      ****     }
1205:../uvc.c      **** }
1206:../uvc.c      **** 
1207:../uvc.c      **** 
1208:../uvc.c      **** /* Application Error Handler */
1209:../uvc.c      **** void
1210:../uvc.c      **** CyFxAppErrorHandler (
1211:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1212:../uvc.c      ****         )
1213:../uvc.c      **** {
1214:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1215:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1216:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1217:../uvc.c      **** 
1218:../uvc.c      ****        This function can be modified to take additional error handling actions such
1219:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1220:../uvc.c      ****      */
1221:../uvc.c      ****     for (;;)
1222:../uvc.c      ****     {
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
1225:../uvc.c      ****     }
1226:../uvc.c      **** }
1227:../uvc.c      **** 
1228:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1229:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1230:../uvc.c      ****  */
1231:../uvc.c      **** static void
1232:../uvc.c      **** CyFxUVCApplnAbortHandler (
1233:../uvc.c      ****         void)
1234:../uvc.c      **** {
1235:../uvc.c      **** 	uint32_t flag;
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1237:../uvc.c      **** 	{
1238:../uvc.c      ****         /* Clear the Video Stream Request Event */
1239:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1240:../uvc.c      **** 
1241:../uvc.c      ****         /* Set Video Stream Abort Event */
1242:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1243:../uvc.c      **** 	}
1244:../uvc.c      **** }
1245:../uvc.c      **** 
1246:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1247:../uvc.c      **** static void
1248:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1249:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1250:../uvc.c      ****         uint16_t             evdata  /* Event data */
1251:../uvc.c      ****         )
1252:../uvc.c      **** {
1253:../uvc.c      ****     switch (evtype)
1254:../uvc.c      ****     {
1255:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1256:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1257:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1258:../uvc.c      ****             gpif_initialized = 0;
1259:../uvc.c      ****             streamingStarted = CyFalse;
1260:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1261:../uvc.c      ****             break;
1262:../uvc.c      **** 
1263:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1264:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1265:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1266:../uvc.c      ****             gpif_initialized = 0;
1267:../uvc.c      ****             streamingStarted = CyFalse;
1268:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1269:../uvc.c      ****             break;
1270:../uvc.c      **** 
1271:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1272:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1273:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1274:../uvc.c      ****             gpif_initialized = 0;
1275:../uvc.c      ****             isUsbConnected = CyFalse;
1276:../uvc.c      ****             streamingStarted = CyFalse;
1277:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1278:../uvc.c      ****             break;
1279:../uvc.c      **** 
1280:../uvc.c      **** #ifdef BACKFLOW_DETECT
1281:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1282:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1283:../uvc.c      ****             break;
1284:../uvc.c      **** #endif
1285:../uvc.c      **** 
1286:../uvc.c      ****         default:
1287:../uvc.c      ****             break;
1288:../uvc.c      ****     }
1289:../uvc.c      **** }
1290:../uvc.c      **** 
1291:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1292:../uvc.c      **** static CyBool_t
1293:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1294:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1295:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1296:../uvc.c      ****         )
1297:../uvc.c      **** {
1298:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1299:../uvc.c      ****     uint32_t status;
1300:../uvc.c      **** 
1301:../uvc.c      ****     /* Obtain Request Type and Request */
1302:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1303:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1304:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1305:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1306:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1307:../uvc.c      **** 
1308:../uvc.c      ****     /* Check for UVC Class Requests */
1309:../uvc.c      ****     switch (bmReqType)
1310:../uvc.c      ****     {
1311:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1312:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1313:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1314:../uvc.c      ****             switch (wIndex & 0xFF)
1315:../uvc.c      ****             {
1316:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1317:../uvc.c      ****                     {
1318:../uvc.c      ****                         uvcHandleReq = CyTrue;
1319:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1320:../uvc.c      ****                                 CYU3P_EVENT_OR);
1321:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1322:../uvc.c      ****                         {
1323:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1324:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1325:../uvc.c      ****                         }
1326:../uvc.c      ****                     }
1327:../uvc.c      ****                     break;
1328:../uvc.c      **** 
1329:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1330:../uvc.c      ****                     {
1331:../uvc.c      ****                         uvcHandleReq = CyTrue;
1332:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1333:../uvc.c      ****                                 CYU3P_EVENT_OR);
1334:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1335:../uvc.c      ****                         {
1336:../uvc.c      ****                             /* Error handling */
1337:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1338:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1339:../uvc.c      ****                         }
1340:../uvc.c      ****                     }
1341:../uvc.c      ****                     break;
1342:../uvc.c      **** 
1343:../uvc.c      ****                 default:
1344:../uvc.c      ****                     break;
1345:../uvc.c      ****             }
1346:../uvc.c      ****             break;
1347:../uvc.c      **** 
1348:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1349:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1350:../uvc.c      ****             {
1351:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1352:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1353:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1354:../uvc.c      ****                 {
1355:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1356:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1357:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1358:../uvc.c      ****                     gpif_initialized = 0;
1359:../uvc.c      ****                     streamingStarted = CyFalse;
1360:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1361:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1362:../uvc.c      ****                     CyU3PBusyWait (100);
1363:../uvc.c      **** 
1364:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1365:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1366:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1367:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1368:../uvc.c      ****                     CyU3PBusyWait (100);
1369:../uvc.c      **** 
1370:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1371:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1372:../uvc.c      ****                     uvcHandleReq = CyTrue;
1373:../uvc.c      ****                     /* Complete Control request handshake */
1374:../uvc.c      ****                     CyU3PUsbAckSetup ();
1375:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1376:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1377:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1378:../uvc.c      **** 
1379:../uvc.c      ****                 }
1380:../uvc.c      ****             }
1381:../uvc.c      ****             break;
1382:../uvc.c      **** 
1383:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1384:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1385:../uvc.c      ****             {
1386:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1387:../uvc.c      ****                 {
1388:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1389:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1390:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1391:../uvc.c      ****                 	 * has started. */
1392:../uvc.c      ****                     if (streamingStarted == CyTrue)
1393:../uvc.c      ****                     {
1394:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1395:../uvc.c      **** 
1396:../uvc.c      ****                         /* Disable the GPIF state machine. */
1397:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1398:../uvc.c      ****                         gpif_initialized = 0;
1399:../uvc.c      ****                         streamingStarted = CyFalse;
1400:../uvc.c      **** 
1401:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1402:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1403:../uvc.c      ****                         CyU3PBusyWait (100);
1404:../uvc.c      **** 
1405:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1406:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1407:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1408:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1409:../uvc.c      ****                         CyU3PBusyWait (100);
1410:../uvc.c      **** 
1411:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1412:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1413:../uvc.c      **** 
1414:../uvc.c      ****                         uvcHandleReq = CyTrue;
1415:../uvc.c      ****                         /* Complete Control request handshake */
1416:../uvc.c      ****                         CyU3PUsbAckSetup ();
1417:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1418:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1419:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1420:../uvc.c      ****                     }
1421:../uvc.c      ****                     else
1422:../uvc.c      ****                     {
1423:../uvc.c      ****                         uvcHandleReq = CyTrue;
1424:../uvc.c      ****                         CyU3PUsbAckSetup ();
1425:../uvc.c      ****                     }
1426:../uvc.c      ****                 }
1427:../uvc.c      ****             }
1428:../uvc.c      ****             break;
1429:../uvc.c      **** 
1430:../uvc.c      ****         default:
1431:../uvc.c      ****             break;
1432:../uvc.c      ****     }
1433:../uvc.c      **** 
1434:../uvc.c      ****     /* Return status of request handling to the USB driver */
1435:../uvc.c      ****     return uvcHandleReq;
1436:../uvc.c      **** }
1437:../uvc.c      **** 
1438:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1439:../uvc.c      **** 
1440:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1441:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1442:../uvc.c      ****  */
1443:../uvc.c      **** void
1444:../uvc.c      **** CyFxUvcApplnDmaCallback (
1445:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1446:../uvc.c      ****         CyU3PDmaCbType_t      type,
1447:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1448:../uvc.c      ****         )
1449:../uvc.c      **** {
1450:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1451:../uvc.c      **** #if 1
1452:../uvc.c      ****     CyU3PReturnStatus_t status;
1453:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1454:../uvc.c      ****     {
1455:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1456:../uvc.c      ****             {
1457:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1458:../uvc.c      ****                 fb++;
1459:../uvc.c      ****             }
1460:../uvc.c      ****             else
1461:../uvc.c      ****             {
1462:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1463:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1464:../uvc.c      ****                 pb++;
1465:../uvc.c      ****                 pbc = input->buffer_p.count;
1466:../uvc.c      ****                // hitFV = CyTrue;
1467:../uvc.c      ****             }
1468:../uvc.c      **** 
1469:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1470:../uvc.c      ****             prodCount++;
1471:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1472:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1473:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1474:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1475:../uvc.c      ****             {
1476:../uvc.c      ****                 prodCount--;
1477:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1478:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1479:../uvc.c      ****             }
1480:../uvc.c      ****     }
1481:../uvc.c      **** #endif
1482:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1483:../uvc.c      ****     {
1484:../uvc.c      ****         consCount++;
1485:../uvc.c      ****         streamingStarted = CyTrue;
1486:../uvc.c      ****     }
1487:../uvc.c      **** }
1488:../uvc.c      **** 
1489:../uvc.c      **** /*
1490:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1491:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1492:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1493:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1494:../uvc.c      ****  * to commit the buffer.
1495:../uvc.c      ****  */
1496:../uvc.c      **** static uint8_t
1497:../uvc.c      **** CyFxUvcAppCommitEOF (
1498:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1499:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1500:../uvc.c      ****         )
1501:../uvc.c      **** {
1502:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1503:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1504:../uvc.c      **** 
1505:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1506:../uvc.c      **** 
1507:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1508:../uvc.c      ****     {
1509:../uvc.c      ****         switch (stateId)
1510:../uvc.c      ****         {
1511:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1512:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1513:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1514:../uvc.c      ****                 break;
1515:../uvc.c      **** 
1516:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1517:../uvc.c      ****                 socket = 0;
1518:../uvc.c      ****                 break;
1519:../uvc.c      **** 
1520:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1521:../uvc.c      ****                 socket = 1;
1522:../uvc.c      ****                 break;
1523:../uvc.c      **** 
1524:../uvc.c      ****             default:
1525:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1526:../uvc.c      ****                 /* Unexpected current state. Return error. */
1527:../uvc.c      ****                 return 1;
1528:../uvc.c      ****         }
1529:../uvc.c      ****     }
1530:../uvc.c      **** 
1531:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1532:../uvc.c      ****     {
1533:../uvc.c      ****         switch (stateId)
1534:../uvc.c      ****         {
1535:../uvc.c      **** #ifndef CAM720
1536:../uvc.c      **** #ifdef GPIFIIM
1537:../uvc.c      ****             case 13:
1538:../uvc.c      ****             case 24:
1539:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1540:../uvc.c      ****                 break;
1541:../uvc.c      **** 
1542:../uvc.c      ****             case 8:
1543:../uvc.c      ****                 socket = 0;
1544:../uvc.c      ****                 break;
1545:../uvc.c      **** 
1546:../uvc.c      ****             case 20:
1547:../uvc.c      ****                 socket = 1;
1548:../uvc.c      ****                 break;
1549:../uvc.c      **** #else
1550:../uvc.c      ****             case 11:
1551:../uvc.c      ****             case 18:
1552:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1553:../uvc.c      ****                 break;
1554:../uvc.c      **** 
1555:../uvc.c      ****             case 8:
1556:../uvc.c      ****                 socket = 0;
1557:../uvc.c      ****                 break;
1558:../uvc.c      **** 
1559:../uvc.c      ****             case 15:
1560:../uvc.c      ****                 socket = 1;
1561:../uvc.c      ****                 break;
1562:../uvc.c      **** #endif
1563:../uvc.c      **** #else
1564:../uvc.c      ****             case 11:
1565:../uvc.c      ****             case 18:
1566:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1567:../uvc.c      ****                 break;
1568:../uvc.c      **** 
1569:../uvc.c      ****             case 8:
1570:../uvc.c      ****                 socket = 0;
1571:../uvc.c      ****                 break;
1572:../uvc.c      **** 
1573:../uvc.c      ****             case 15:
1574:../uvc.c      ****                 socket = 1;
1575:../uvc.c      ****                 break;
1576:../uvc.c      **** 
1577:../uvc.c      **** #endif
1578:../uvc.c      ****              default:
1579:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1580:../uvc.c      ****                 /* Unexpected current state. Return error. */
1581:../uvc.c      ****                return 1;
1582:../uvc.c      ****         }
1583:../uvc.c      ****     }
1584:../uvc.c      **** 
1585:../uvc.c      ****     if (socket != 0xFF)
1586:../uvc.c      ****     {
1587:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1588:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1589:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1590:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1591:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1592:../uvc.c      ****         {
1593:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1594:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1595:../uvc.c      ****         }
1596:../uvc.c      ****     }
1597:../uvc.c      **** 
1598:../uvc.c      ****     return 0;
1599:../uvc.c      **** }
1600:../uvc.c      **** 
1601:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1602:../uvc.c      **** void
1603:../uvc.c      **** CyFxGpifCB (
1604:../uvc.c      ****         CyU3PGpifEventType event,
1605:../uvc.c      ****         uint8_t currentState
1606:../uvc.c      ****         )
1607:../uvc.c      **** {
1608:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1609:../uvc.c      ****     {
1610:../uvc.c      ****         hitFV = CyTrue;
1611:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1612:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1613:../uvc.c      ****     }
1614:../uvc.c      **** }
1615:../uvc.c      **** 
1616:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1617:../uvc.c      **** static void
1618:../uvc.c      **** CyFxUVCApplnDebugInit (
1619:../uvc.c      ****         void)
1620:../uvc.c      **** {
1621:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1622:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1623:../uvc.c      **** 
1624:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1625:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1626:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1627:../uvc.c      ****     {
1628:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1629:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1630:../uvc.c      ****     }
1631:../uvc.c      **** 
1632:../uvc.c      ****     /* Set UART Configuration */
1633:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1634:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1635:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1636:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1637:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1638:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1639:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1640:../uvc.c      **** 
1641:../uvc.c      ****     /* Set the UART configuration */
1642:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1643:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1644:../uvc.c      ****     {
1645:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1646:../uvc.c      ****     }
1647:../uvc.c      **** 
1648:../uvc.c      ****     /* Set the UART transfer */
1649:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1650:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1651:../uvc.c      ****     {
1652:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1653:../uvc.c      ****     }
1654:../uvc.c      **** 
1655:../uvc.c      ****     /* Initialize the Debug logger module. */
1656:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1657:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1658:../uvc.c      ****     {
1659:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1660:../uvc.c      ****     }
1661:../uvc.c      **** 
1662:../uvc.c      ****     /* Disable log message headers. */
1663:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1664:../uvc.c      **** }
1665:../uvc.c      **** 
1666:../uvc.c      **** /* I2C initialization. */
1667:../uvc.c      **** //static void
1668:../uvc.c      **** void
1669:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1670:../uvc.c      **** {
1671:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1672:../uvc.c      ****     CyU3PReturnStatus_t status;
1673:../uvc.c      **** 
1674:../uvc.c      ****     status = CyU3PI2cInit ();
1675:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1676:../uvc.c      ****     {
1677:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1678:../uvc.c      ****         CyFxAppErrorHandler (status);
1679:../uvc.c      ****     }
1680:../uvc.c      **** 
1681:../uvc.c      ****     /*  Set I2C Configuration */
1682:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1683:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1684:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1685:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1686:../uvc.c      **** 
1687:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1688:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1689:../uvc.c      ****     {
1690:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1691:../uvc.c      ****         CyFxAppErrorHandler (status);
1692:../uvc.c      ****     }
1693:../uvc.c      **** }
1694:../uvc.c      **** 
1695:../uvc.c      **** #ifdef BACKFLOW_DETECT
1696:../uvc.c      **** static void CyFxUvcAppPibCallback (
1697:../uvc.c      ****         CyU3PPibIntrType cbType,
1698:../uvc.c      ****         uint16_t cbArg)
1699:../uvc.c      **** {
1700:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1701:../uvc.c      ****     {
1702:../uvc.c      ****         if (!back_flow_detected)
1703:../uvc.c      ****         {
1704:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1705:../uvc.c      ****             back_flow_detected = 1;
1706:../uvc.c      ****         }
1707:../uvc.c      ****     }
1708:../uvc.c      **** }
1709:../uvc.c      **** #endif
1710:../uvc.c      **** 
1711:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1712:../uvc.c      **** static void
1713:../uvc.c      **** CyFxUvcAppDebugCallback (
1714:../uvc.c      ****         CyU3PDmaChannel   *handle,
1715:../uvc.c      ****         CyU3PDmaCbType_t   type,
1716:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1717:../uvc.c      **** {
1718:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1719:../uvc.c      ****     {
1720:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1721:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1722:../uvc.c      ****     }
1723:../uvc.c      **** }
1724:../uvc.c      **** #endif
1725:../uvc.c      **** 
1726:../uvc.c      **** #if 0
1727:../uvc.c      **** static void CyFxAppIntEpCb(
1728:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1729:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1730:../uvc.c      **** 		uint8_t  ebNum)
1731:../uvc.c      **** 		{
1732:../uvc.c      **** 			//CyBool_t value;
1733:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1734:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1735:../uvc.c      **** 
1736:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1737:../uvc.c      **** 		}
1738:../uvc.c      **** #endif
1739:../uvc.c      **** 
1740:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1741:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1742:../uvc.c      ****    configures the DMA module for the UVC Application */
1743:../uvc.c      **** static void
1744:../uvc.c      **** CyFxUVCApplnInit (void)
1745:../uvc.c      **** {
1746:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1747:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1748:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1749:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1750:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1751:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1752:../uvc.c      **** 
1753:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1754:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1755:../uvc.c      **** 
1756:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1757:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1758:../uvc.c      **** #endif
1759:../uvc.c      **** 
1760:../uvc.c      ****     /* Create UVC event group */
1761:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1762:../uvc.c      ****     if (apiRetStatus != 0)
1763:../uvc.c      ****     {
1764:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1765:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1766:../uvc.c      ****     }
1767:../uvc.c      **** 
1768:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1769:../uvc.c      ****     CyFxUvcAppPTZInit ();
1770:../uvc.c      **** #endif
1771:../uvc.c      **** 
1772:../uvc.c      ****     isUsbConnected = CyFalse;
1773:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1774:../uvc.c      **** 
1775:../uvc.c      ****     /* Init the GPIO module */
1776:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1777:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1778:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1779:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1780:../uvc.c      ****     gpioClock.halfDiv    = 0;
1781:../uvc.c      **** 
1782:../uvc.c      ****     /* Initialize Gpio interface */
1783:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1784:../uvc.c      ****     if (apiRetStatus != 0)
1785:../uvc.c      ****     {
1786:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1787:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1788:../uvc.c      ****     }
1789:../uvc.c      **** 
1790:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1791:../uvc.c      ****      * must use GpioOverride to configure it */
1792:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1793:../uvc.c      ****     if (apiRetStatus != 0)
1794:../uvc.c      ****     {
1795:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1796:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1797:../uvc.c      ****     }
1798:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1799:../uvc.c      ****     if (apiRetStatus != 0)
1800:../uvc.c      ****     {
1801:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1802:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1803:../uvc.c      ****     }
1804:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1805:../uvc.c      ****     if (apiRetStatus != 0)
1806:../uvc.c      ****     {
1807:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1808:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1809:../uvc.c      ****     }
1810:../uvc.c      **** 
1811:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1812:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1813:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1814:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1815:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1816:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1817:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1818:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1819:../uvc.c      ****     {
1820:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1821:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1822:../uvc.c      ****     }
1823:../uvc.c      **** 
1824:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1825:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1826:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1827:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1828:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1829:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1830:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1831:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1832:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1833:../uvc.c      ****     {
1834:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1835:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1836:../uvc.c      ****     }
1837:../uvc.c      **** 
1838:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1839:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1840:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1841:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1842:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1843:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1844:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1845:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1846:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1847:../uvc.c      ****     {
1848:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1849:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1850:../uvc.c      ****     }
1851:../uvc.c      **** 
1852:../uvc.c      ****     /* Initialize the P-port. */
1853:../uvc.c      ****     pibclock.clkDiv      = 2;
1854:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1855:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1856:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1857:../uvc.c      **** 
1858:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1859:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1860:../uvc.c      ****     {
1861:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1862:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1863:../uvc.c      ****     }
1864:../uvc.c      **** 
1865:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1866:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1867:../uvc.c      **** 
1868:../uvc.c      **** #ifdef BACKFLOW_DETECT
1869:../uvc.c      ****     back_flow_detected = 0;
1870:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1871:../uvc.c      **** #endif
1872:../uvc.c      **** 
1873:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1874:../uvc.c      ****     SensorReset ();
1875:../uvc.c      ****     SensorInit ();
1876:../uvc.c      **** 
1877:../uvc.c      ****     /* USB initialization. */
1878:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1879:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1880:../uvc.c      ****     {
1881:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1882:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1883:../uvc.c      ****     }
1884:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1885:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1886:../uvc.c      **** 
1887:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1888:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1889:../uvc.c      **** 
1890:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1891:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1892:../uvc.c      **** 
1893:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1894:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1895:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1896:../uvc.c      **** 
1897:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1898:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1899:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1900:../uvc.c      **** 
1901:../uvc.c      ****     /* Configuration descriptors. */
1902:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1903:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1904:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1905:../uvc.c      **** 
1906:../uvc.c      ****     /* String Descriptors */
1907:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1908:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1909:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1910:../uvc.c      **** 
1911:../uvc.c      ****     /* Configure the status interrupt endpoint.
1912:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1913:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1914:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1915:../uvc.c      ****      */
1916:../uvc.c      ****     endPointConfig.enable   = 1;
1917:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1918:../uvc.c      ****     endPointConfig.pcktSize = 64;
1919:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1920:../uvc.c      ****     endPointConfig.streams  = 0;
1921:../uvc.c      ****     endPointConfig.burstLen = 1;
1922:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1923:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1924:../uvc.c      ****     {
1925:../uvc.c      ****         /* Error Handling */
1926:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1927:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1928:../uvc.c      ****     }
1929:../uvc.c      **** 
1930:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1931:../uvc.c      ****     dmaInterConfig.size           = 1024;
1932:../uvc.c      ****     dmaInterConfig.count          = 1;
1933:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1934:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1935:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1936:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1937:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1938:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1939:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1940:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1941:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1942:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1943:../uvc.c      ****             &dmaInterConfig);
1944:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1945:../uvc.c      ****     {
1946:../uvc.c      ****         /* Error handling */
1947:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1948:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1949:../uvc.c      ****     }
1950:../uvc.c      **** 
1951:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1952:../uvc.c      ****     if (glInterStaBuffer == 0)
1953:../uvc.c      ****     {
1954:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1955:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1956:../uvc.c      ****     }
1957:../uvc.c      **** 
1958:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1959:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1960:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1961:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1962:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1963:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1964:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1965:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1966:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1967:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
1968:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1969:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1970:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1971:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1972:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
1973:../uvc.c      ****             &dmaMultiConfig);
1974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1975:../uvc.c      ****     {
1976:../uvc.c      ****         /* Error handling */
1977:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
1978:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1979:../uvc.c      ****     }
1980:../uvc.c      **** 
1981:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1982:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
1983:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
1984:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
1985:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
1986:../uvc.c      ****      */
1987:../uvc.c      **** 
1988:../uvc.c      ****     endPointConfig.enable   = 1;
1989:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
1990:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
1991:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1992:../uvc.c      ****     endPointConfig.streams  = 0;
1993:../uvc.c      ****     endPointConfig.burstLen = 1;
1994:../uvc.c      **** 
1995:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
1996:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1997:../uvc.c      ****     {
1998:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
1999:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2000:../uvc.c      ****     }
2001:../uvc.c      **** 
2002:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2003:../uvc.c      **** 
2004:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2005:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2006:../uvc.c      ****     {
2007:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2008:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2009:../uvc.c      ****     }
2010:../uvc.c      **** 
2011:../uvc.c      ****     channelConfig.size           = 1024;
2012:../uvc.c      ****     channelConfig.count          = 1;
2013:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2014:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2015:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2016:../uvc.c      ****     channelConfig.prodHeader     = 0;
2017:../uvc.c      ****     channelConfig.prodFooter     = 0;
2018:../uvc.c      ****     channelConfig.consHeader     = 0;
2019:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2020:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2021:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2022:../uvc.c      **** 
2023:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2024:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2025:../uvc.c      ****     {
2026:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2027:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2028:../uvc.c      ****     }
2029:../uvc.c      **** 
2030:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2031:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2032:../uvc.c      ****     {
2033:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2034:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2035:../uvc.c      ****     }
2036:../uvc.c      **** 
2037:../uvc.c      ****     channelConfig.size           = 1024;
2038:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2039:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2040:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2041:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2042:../uvc.c      ****     channelConfig.prodHeader     = 0;
2043:../uvc.c      ****     channelConfig.prodFooter     = 0;
2044:../uvc.c      ****     channelConfig.consHeader     = 0;
2045:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2046:../uvc.c      ****     channelConfig.notification   = 0;
2047:../uvc.c      ****     channelConfig.cb             = 0;
2048:../uvc.c      **** 
2049:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2050:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2051:../uvc.c      ****     {
2052:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2053:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2054:../uvc.c      ****     }
2055:../uvc.c      **** 
2056:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2057:../uvc.c      ****     if (glDebugRspBuffer == 0)
2058:../uvc.c      ****     {
2059:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2060:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2061:../uvc.c      ****     }
2062:../uvc.c      **** #endif
2063:../uvc.c      **** 
2064:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2065:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2066:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2067:../uvc.c      ****     {
2068:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2069:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2070:../uvc.c      ****     }
2071:../uvc.c      **** 
2072:../uvc.c      ****     CyU3PBusyWait(100);
2073:../uvc.c      **** 
2074:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2075:../uvc.c      **** 
2076:../uvc.c      ****     endPointConfig.enable   = 1;
2077:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2078:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2079:../uvc.c      ****     {
2080:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2081:../uvc.c      ****     	endPointConfig.burstLen = 16;
2082:../uvc.c      ****     }
2083:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2084:../uvc.c      ****     {
2085:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2086:../uvc.c      ****     	endPointConfig.burstLen = 1;
2087:../uvc.c      ****     }
2088:../uvc.c      ****     endPointConfig.streams  = 0;
2089:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2090:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2091:../uvc.c      ****     {
2092:../uvc.c      ****         /* Error Handling */
2093:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2094:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2095:../uvc.c      ****     }
2096:../uvc.c      **** #if 0    //for still image method 3 using
2097:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2098:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2099:../uvc.c      ****     {
2100:../uvc.c      ****         /* Error Handling */
2101:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2102:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2103:../uvc.c      ****     }
2104:../uvc.c      **** #endif
2105:../uvc.c      **** 
2106:../uvc.c      **** }
2107:../uvc.c      **** 
2108:../uvc.c      **** /*
2109:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2110:../uvc.c      ****  * streaming session is started.
2111:../uvc.c      ****  */
2112:../uvc.c      **** static void
2113:../uvc.c      **** CyFxUvcAppGpifInit (
2114:../uvc.c      ****         void)
2115:../uvc.c      **** {
2116:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2117:../uvc.c      **** 
2118:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2119:../uvc.c      ****     {
2120:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2121:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2122:../uvc.c      ****     }
2123:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2124:../uvc.c      ****     {
2125:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2126:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2127:../uvc.c      ****     }
2128:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2129:../uvc.c      ****     {
2130:../uvc.c      ****         /* Error Handling */
2131:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2132:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2133:../uvc.c      ****     }
2134:../uvc.c      **** 
2135:../uvc.c      ****     /* Start the state machine from the designated start state. */
2136:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2137:../uvc.c      ****     {
2138:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2139:../uvc.c      ****     }
2140:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2141:../uvc.c      ****     {
2142:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2143:../uvc.c      ****     }
2144:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2145:../uvc.c      ****     {
2146:../uvc.c      ****         /* Error Handling */
2147:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2148:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2149:../uvc.c      ****     }
2150:../uvc.c      **** }
2151:../uvc.c      **** 
2152:../uvc.c      **** /*
2153:../uvc.c      ****  * Entry function for the UVC Application Thread
2154:../uvc.c      ****  */
2155:../uvc.c      **** 
2156:../uvc.c      **** uint32_t posTick;
2157:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2158:../uvc.c      **** 
2159:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2160:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2161:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2162:../uvc.c      **** }
2163:../uvc.c      **** 
2164:../uvc.c      **** 
2165:../uvc.c      **** void
2166:../uvc.c      **** UVCAppThread_Entry (
2167:../uvc.c      ****         uint32_t input)
2168:../uvc.c      **** {
2169:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2170:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2171:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2172:../uvc.c      ****     uint8_t i = 0;
2173:../uvc.c      ****     uint32_t flag;
2174:../uvc.c      ****     uint32_t prinflag = 0;
2175:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2176:../uvc.c      ****     uint32_t frameCnt = 0;
2177:../uvc.c      **** #endif
2178:../uvc.c      ****     /* Initialize the Uart Debug Module */
2179:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2180:../uvc.c      **** 
2181:../uvc.c      ****     /* Initialize the I2C interface */
2182:../uvc.c      **** 	while (i++ < 6){
2183:../uvc.c      **** 		CyU3PThreadSleep(500);
2184:../uvc.c      **** 	}
2185:../uvc.c      **** 
2186:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2187:../uvc.c      **** 
2188:../uvc.c      ****     /* Initialize the UVC Application */
2189:../uvc.c      ****     CyFxUVCApplnInit ();
2190:../uvc.c      **** 
2191:../uvc.c      ****     /*
2192:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2193:../uvc.c      **** 
2194:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2195:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2196:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2197:../uvc.c      **** 
2198:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2199:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2200:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2201:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2202:../uvc.c      **** 
2203:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2204:../uvc.c      ****        of handling the abort request.
2205:../uvc.c      ****      */
2206:../uvc.c      **** 
2207:../uvc.c      ****     for (;;)
2208:../uvc.c      ****     {
2209:../uvc.c      ****         /* Waiting for the Video Stream Event */
2210:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2211:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2212:../uvc.c      ****         {
2213:../uvc.c      **** #if 0 //test for new firmware no video bring up
2214:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2215:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2216:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2217:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2218:../uvc.c      ****             {
2219:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2220:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2221:../uvc.c      ****                 {
2222:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2223:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2224:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2225:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2226:../uvc.c      **** #endif
2227:../uvc.c      **** #endif
2228:../uvc.c      ****                     }
2229:../uvc.c      ****                 else
2230:../uvc.c      ****                 {
2231:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2232:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2233:../uvc.c      **** #ifdef USB_LOWRES_IMG
2234:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2235:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2236:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2237:../uvc.c      **** #endif
2238:../uvc.c      **** #endif
2239:../uvc.c      ****                 }
2240:../uvc.c      **** 
2241:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2242:../uvc.c      ****                 prodCount++;
2243:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2244:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2245:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2246:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2247:../uvc.c      ****                 {
2248:../uvc.c      ****                     prodCount--;
2249:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2250:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2251:../uvc.c      ****                 }
2252:../uvc.c      ****             }
2253:../uvc.c      **** #endif
2254:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2255:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2256:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2257:../uvc.c      ****             {
2258:../uvc.c      ****             	if(0&&(prinflag == 0)){
2259:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2260:../uvc.c      ****             		prinflag = 1;
2261:../uvc.c      ****             	}
2262:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2263:../uvc.c      ****             	fb=0;
2264:../uvc.c      ****             	pb=0;
2265:../uvc.c      ****             	pbc=0;
2266:../uvc.c      ****                 prodCount = 0;
2267:../uvc.c      ****                 consCount = 0;
2268:../uvc.c      ****                 hitFV     = CyFalse;
2269:../uvc.c      **** 
2270:../uvc.c      **** #ifdef BACKFLOW_DETECT
2271:../uvc.c      ****                 back_flow_detected = 0;
2272:../uvc.c      **** #endif
2273:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2274:../uvc.c      ****                 frameCnt++;
2275:../uvc.c      **** #endif
2276:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2277:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2278:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2279:../uvc.c      ****                 //}
2280:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2281:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2282:../uvc.c      ****                 if(stiflag){
2283:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
2284:../uvc.c      ****                 	stiflag = CyFalse;
2285:../uvc.c      ****                 }else{
2286:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2287:../uvc.c      ****                 }
2288:../uvc.c      ****                 /* Reset the DMA channel. */
2289:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2290:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2291:../uvc.c      ****                 {
2292:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2293:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2294:../uvc.c      ****                 }
2295:../uvc.c      **** 
2296:../uvc.c      ****                 /* Start Channel Immediately */
2297:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2298:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2299:../uvc.c      ****                 {
2300:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2301:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2302:../uvc.c      ****                 }
2303:../uvc.c      **** 
2304:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2305:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2306:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2307:../uvc.c      ****                 }
2308:../uvc.c      ****         }
2309:../uvc.c      ****         else
2310:../uvc.c      ****         {
2311:../uvc.c      ****             /* If we have a stream abort request pending. */
2312:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2313:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2314:../uvc.c      ****             {
2315:../uvc.c      ****                 hitFV     = CyFalse;
2316:../uvc.c      ****                 prodCount = 0;
2317:../uvc.c      ****                 consCount = 0;
2318:../uvc.c      ****                 if(0&&(prinflag == 0)){
2319:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2320:../uvc.c      ****                 	prinflag = 1;
2321:../uvc.c      ****                 }
2322:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2323:../uvc.c      ****                 fb=0;
2324:../uvc.c      ****                 pb=0;
2325:../uvc.c      ****                 pbc=0;
2326:../uvc.c      **** 
2327:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2328:../uvc.c      ****                 {
2329:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2330:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2331:../uvc.c      ****                     {
2332:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2333:../uvc.c      ****                     }
2334:../uvc.c      **** 
2335:../uvc.c      ****                     /* Flush the Endpoint memory */
2336:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2337:../uvc.c      ****                 }
2338:../uvc.c      **** 
2339:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2340:../uvc.c      ****             }
2341:../uvc.c      ****             else
2342:../uvc.c      ****             {
2343:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2344:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2345:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2346:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2347:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2348:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2349:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2350:../uvc.c      ****                 {
2351:../uvc.c      ****                     /* Error handling */
2352:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2353:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2354:../uvc.c      ****                 }
2355:../uvc.c      **** 
2356:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2357:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2358:../uvc.c      ****                 {
2359:../uvc.c      ****                     //for start up of the AF Lens
2360:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2361:../uvc.c      ****                     CyU3PThreadSleep(500);
2362:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2363:../uvc.c      ****                     CyU3PThreadSleep(500);
2364:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2365:../uvc.c      ****                    	CyU3PThreadSleep(300);
2366:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2367:../uvc.c      ****                     CyU3PThreadSleep(500);
2368:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2369:../uvc.c      ****                     CyU3PThreadSleep(500);
2370:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2371:../uvc.c      ****                     gpif_initialized = CyTrue;
2372:../uvc.c      ****                     CyU3PThreadSleep(200);
2373:../uvc.c      ****                     
2374:../uvc.c      ****                 }
2375:../uvc.c      ****                 else
2376:../uvc.c      ****                 {
2377:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2378:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2379:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2380:../uvc.c      ****                 }
2381:../uvc.c      ****             }
2382:../uvc.c      ****         }
2383:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2384:../uvc.c      **** 
2385:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2386:../uvc.c      ****         CyU3PThreadRelinquish ();
2387:../uvc.c      ****     }
2388:../uvc.c      **** }
2389:../uvc.c      **** 
2390:../uvc.c      **** /*
2391:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2392:../uvc.c      ****  */
2393:../uvc.c      **** 
2394:../uvc.c      **** static void
2395:../uvc.c      **** UVCHandleProcessingUnitRqts (
2396:../uvc.c      ****         void)
2397:../uvc.c      **** {
2398:../uvc.c      ****     uint8_t CtrlAdd;
2399:../uvc.c      **** #ifdef DbgInfo
2400:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2401:../uvc.c      **** #endif
2402:../uvc.c      ****     switch (wValue)
2403:../uvc.c      ****     {
2404:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2405:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2406:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2407:../uvc.c      ****     		break;
2408:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2409:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2410:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2411:../uvc.c      ****     		break;
2412:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2413:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2414:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2415:../uvc.c      **** 			break;
2416:../uvc.c      **** 
2417:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2418:../uvc.c      **** 
2419:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2420:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2421:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2422:../uvc.c      ****       		break;
2423:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2424:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2425:../uvc.c      ****      		ControlHandle(HueCtlID5);
2426:../uvc.c      ****      		break;
2427:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2428:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2429:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2430:../uvc.c      ****           		break;
2431:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2432:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2433:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2434:../uvc.c      ****           		break;
2435:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2436:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2437:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2438:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2439:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2440:../uvc.c      ****     		break;
2441:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2442:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2443:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2444:../uvc.c      ****     		break;
2445:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2446:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2447:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2448:../uvc.c      ****     		break;
2449:../uvc.c      **** 
2450:../uvc.c      ****         default:
2451:../uvc.c      ****             /*
2452:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2453:../uvc.c      ****              * other controls.
2454:../uvc.c      ****              */
2455:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2456:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2457:../uvc.c      ****             break;
2458:../uvc.c      ****     }
2459:../uvc.c      **** }
2460:../uvc.c      **** 
2461:../uvc.c      **** /*
2462:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2463:../uvc.c      ****  */
2464:../uvc.c      **** static void
2465:../uvc.c      **** UVCHandleCameraTerminalRqts (
2466:../uvc.c      ****         void)
2467:../uvc.c      **** {
2468:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2469:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2470:../uvc.c      ****     uint16_t readCount;
2471:../uvc.c      ****     uint16_t zoomVal;
2472:../uvc.c      ****     int32_t  panVal, tiltVal;
2473:../uvc.c      ****     CyBool_t sendData = CyFalse;
2474:../uvc.c      **** #endif
2475:../uvc.c      ****     uint8_t CtrlAdd;
2476:../uvc.c      **** 
2477:../uvc.c      ****     switch (wValue)
2478:../uvc.c      ****     {
2479:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2480:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2481:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2482:../uvc.c      ****     		break;
2483:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2484:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2485:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2486:../uvc.c      ****     		break;
2487:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2488:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2489:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2490:../uvc.c      **** 			break;
2491:../uvc.c      **** 
2492:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2493:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2494:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2495:../uvc.c      **** 			break;
2496:../uvc.c      **** 
2497:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2498:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2499:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2500:../uvc.c      ****       		break;
2501:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2502:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2503:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2504:../uvc.c      ****      		break;
2505:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2506:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2507:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2508:../uvc.c      ****           		break;
2509:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2510:../uvc.c      ****           		break;
2511:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2512:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2513:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2514:../uvc.c      ****      		break;
2515:../uvc.c      **** 
2516:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2517:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2518:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2519:../uvc.c      ****     		break;
2520:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2521:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2522:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2523:../uvc.c      ****     		break;
2524:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2525:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2526:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2527:../uvc.c      ****     		break;
2528:../uvc.c      **** 
2529:../uvc.c      ****         default:
2530:../uvc.c      ****             /*
2531:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2532:../uvc.c      ****              * other controls.
2533:../uvc.c      ****              */
2534:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2535:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2536:../uvc.c      ****             break;
2537:../uvc.c      ****     }
2538:../uvc.c      **** 
2539:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2540:../uvc.c      ****     switch (wValue)
2541:../uvc.c      ****     {
2542:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2543:../uvc.c      ****             switch (bRequest)
2544:../uvc.c      ****             {
2545:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2546:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2547:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2548:../uvc.c      ****                     break;
2549:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2550:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2551:../uvc.c      ****                     sendData = CyTrue;
2552:../uvc.c      ****                     break;
2553:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2554:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2555:../uvc.c      ****                     sendData = CyTrue;
2556:../uvc.c      ****                     break;
2557:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2558:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2559:../uvc.c      ****                     sendData = CyTrue;
2560:../uvc.c      ****                     break;
2561:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2562:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2563:../uvc.c      ****                     sendData = CyTrue;
2564:../uvc.c      ****                     break;
2565:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2566:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2567:../uvc.c      ****                     sendData = CyTrue;
2568:../uvc.c      ****                     break;
2569:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2570:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2571:../uvc.c      ****                             glEp0Buffer, &readCount);
2572:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2573:../uvc.c      ****                     {
2574:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2575:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2576:../uvc.c      ****                     }
2577:../uvc.c      ****                     break;
2578:../uvc.c      ****                 default:
2579:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2580:../uvc.c      ****                     break;
2581:../uvc.c      ****             }
2582:../uvc.c      **** 
2583:../uvc.c      ****             if (sendData)
2584:../uvc.c      ****             {
2585:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2586:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2587:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2588:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2589:../uvc.c      ****             }
2590:../uvc.c      ****             break;
2591:../uvc.c      **** 
2592:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2593:../uvc.c      ****             switch (bRequest)
2594:../uvc.c      ****             {
2595:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2596:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2597:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2598:../uvc.c      ****                     break;
2599:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2600:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2601:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2602:../uvc.c      ****                     sendData = CyTrue;
2603:../uvc.c      ****                     break;
2604:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2605:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2606:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2607:../uvc.c      ****                     sendData = CyTrue;
2608:../uvc.c      ****                     break;
2609:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2610:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2611:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2612:../uvc.c      ****                     sendData = CyTrue;
2613:../uvc.c      ****                     break;
2614:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2615:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2616:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2617:../uvc.c      ****                     sendData = CyTrue;
2618:../uvc.c      ****                     break;
2619:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2620:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2621:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2622:../uvc.c      ****                     sendData = CyTrue;
2623:../uvc.c      ****                     break;
2624:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2625:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2626:../uvc.c      ****                             glEp0Buffer, &readCount);
2627:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2628:../uvc.c      ****                     {
2629:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2630:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2631:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2632:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2633:../uvc.c      **** 
2634:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2635:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2636:../uvc.c      ****                     }
2637:../uvc.c      ****                     break;
2638:../uvc.c      ****                 default:
2639:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2640:../uvc.c      ****                     break;
2641:../uvc.c      ****             }
2642:../uvc.c      **** 
2643:../uvc.c      ****             if (sendData)
2644:../uvc.c      ****             {
2645:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2646:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2647:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2648:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2649:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2650:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2651:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2652:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2653:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2654:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2655:../uvc.c      ****             }
2656:../uvc.c      ****             break;
2657:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2658:../uvc.c      ****         default:
2659:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2660:../uvc.c      ****             break;
2661:../uvc.c      ****     }
2662:../uvc.c      **** #endif
2663:../uvc.c      **** }
2664:../uvc.c      **** 
2665:../uvc.c      **** /*
2666:../uvc.c      ****  * Handler for UVC Interface control requests.
2667:../uvc.c      ****  */
2668:../uvc.c      **** static void
2669:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2670:../uvc.c      ****         void)
2671:../uvc.c      **** {
2672:../uvc.c      **** 
2673:../uvc.c      ****     switch (wValue)
2674:../uvc.c      ****     {
2675:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2676:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2677:../uvc.c      ****     		break;
2678:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2679:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2680:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2681:../uvc.c      ****     		break;
2682:../uvc.c      ****     	default:
2683:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2684:../uvc.c      ****      		break;
2685:../uvc.c      ****     }
2686:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2687:../uvc.c      **** 
2688:../uvc.c      **** }
2689:../uvc.c      **** 
2690:../uvc.c      **** /*
2691:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2692:../uvc.c      ****  */
2693:../uvc.c      **** static void
2694:../uvc.c      **** UVCHandleExtensionUnitRqts (
2695:../uvc.c      ****         void)
2696:../uvc.c      **** {
2697:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2698:../uvc.c      **** 
2699:../uvc.c      **** #ifdef DbgInfo
2700:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2701:../uvc.c      **** #endif
2702:../uvc.c      ****     switch (wValue)
2703:../uvc.c      ****     {
2704:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2705:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2706:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2707:../uvc.c      ****     		break;
2708:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2709:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2710:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2711:../uvc.c      ****     		break;
2712:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2713:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2714:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2715:../uvc.c      ****      		break;
2716:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2717:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2718:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2719:../uvc.c      ****     		break;
2720:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2721:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2722:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2723:../uvc.c      ****     		break;
2724:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2725:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2726:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2727:../uvc.c      ****      		break;
2728:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2729:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2730:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2731:../uvc.c      ****     		break;
2732:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2733:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2734:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2735:../uvc.c      ****     		break;
2736:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2737:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2738:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2739:../uvc.c      ****      		break;
2740:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2741:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2742:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2743:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2744:../uvc.c      ****     		}else/* no support for 1080p camera */
2745:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2746:../uvc.c      ****     		break;
2747:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2748:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2749:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2750:../uvc.c      ****     		break;
2751:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2752:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2753:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2754:../uvc.c      ****     		break;
2755:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2756:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2757:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2758:../uvc.c      ****     		//break;
2759:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2760:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2761:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2762:../uvc.c      ****     		break;
2763:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2764:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2765:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2766:../uvc.c      ****     		break;
2767:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2768:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2769:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2770:../uvc.c      ****     		break;
2771:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2772:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2773:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2774:../uvc.c      ****     		break;
2775:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2776:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2777:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2778:../uvc.c      ****     		break;
2779:../uvc.c      ****    	default:
2780:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2781:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2782:../uvc.c      ****     		break;
2783:../uvc.c      ****     }
2784:../uvc.c      **** 
2785:../uvc.c      **** }
2786:../uvc.c      **** 
2787:../uvc.c      **** /*
2788:../uvc.c      ****  * Handler for the video streaming control requests.
2789:../uvc.c      ****  */
2790:../uvc.c      **** static void
2791:../uvc.c      **** UVCHandleVideoStreamingRqts (
2792:../uvc.c      ****         void)
2793:../uvc.c      **** {
2794:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2795:../uvc.c      ****     uint16_t readCount;
2796:../uvc.c      **** 
2797:../uvc.c      ****     switch (wValue)
2798:../uvc.c      ****     {
2799:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2800:../uvc.c      ****             switch (bRequest)
2801:../uvc.c      ****             {
2802:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2803:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2804:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2805:../uvc.c      ****                     break;
2806:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2807:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2808:../uvc.c      ****                     glEp0Buffer[1] = 0;
2809:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2810:../uvc.c      ****                     break;
2811:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2812:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2813:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2814:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2815:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2816:../uvc.c      ****                     {
2817:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2818:../uvc.c      ****                     }
2819:../uvc.c      ****                     else
2820:../uvc.c      ****                     {
2821:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2822:../uvc.c      ****                     }
2823:../uvc.c      ****                     break;
2824:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2825:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2826:../uvc.c      ****                             glCommitCtrl, &readCount);
2827:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2828:../uvc.c      ****                     {
2829:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2830:../uvc.c      ****                         {
2831:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2832:../uvc.c      ****                                active data structure. */
2833:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2834:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2835:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2836:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2837:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2838:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2839:../uvc.c      ****                         }
2840:../uvc.c      ****                     }
2841:../uvc.c      ****                     break;
2842:../uvc.c      ****                 default:
2843:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2844:../uvc.c      ****                     break;
2845:../uvc.c      ****             }
2846:../uvc.c      ****             break;
2847:../uvc.c      **** 
2848:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2849:../uvc.c      ****             switch (bRequest)
2850:../uvc.c      ****             {
2851:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2852:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2853:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2854:../uvc.c      ****                     break;
2855:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2856:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2857:../uvc.c      ****                     glEp0Buffer[1] = 0;
2858:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2859:../uvc.c      ****                     break;
2860:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2861:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2862:../uvc.c      ****                     {
2863:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2864:../uvc.c      ****                     }
2865:../uvc.c      ****                     else
2866:../uvc.c      ****                     {
2867:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2868:../uvc.c      ****                     }
2869:../uvc.c      ****                     break;
2870:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2871:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2872:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2873:../uvc.c      ****                        */
2874:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2875:../uvc.c      ****                             glCommitCtrl, &readCount);
2876:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2877:../uvc.c      ****                     {
2878:../uvc.c      **** #if 0
2879:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2880:../uvc.c      ****                         {
2881:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2882:../uvc.c      ****                         }
2883:../uvc.c      ****                         else
2884:../uvc.c      ****                         {
2885:../uvc.c      ****                             SensorScaling_VGA ();
2886:../uvc.c      ****                         }
2887:../uvc.c      **** #endif
2888:../uvc.c      ****                         /* We can start streaming video now. */
2889:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2890:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2891:../uvc.c      ****                         {
2892:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2893:../uvc.c      ****                         }
2894:../uvc.c      ****                     }
2895:../uvc.c      ****                     break;
2896:../uvc.c      **** 
2897:../uvc.c      ****                 default:
2898:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2899:../uvc.c      ****                     break;
2900:../uvc.c      ****             }
2901:../uvc.c      ****             break;
2902:../uvc.c      **** 
2903:../uvc.c      **** /* still image streaming handler */
2904:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2905:../uvc.c      ****                 switch (bRequest)
2906:../uvc.c      ****                 {
2907:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2908:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2909:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2910:../uvc.c      ****                         break;
2911:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2912:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2913:../uvc.c      ****                         glEp0Buffer[1] = 0;
2914:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2915:../uvc.c      ****                         break;
2916:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2917:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2918:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2919:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2920:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2921:../uvc.c      ****                         {
2922:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2923:../uvc.c      ****                         }
2924:../uvc.c      ****                         else
2925:../uvc.c      ****                         {
2926:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2927:../uvc.c      ****                         }
2928:../uvc.c      ****                         break;
2929:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2930:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2931:../uvc.c      ****                                 glCommitCtrl, &readCount);
2932:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2933:../uvc.c      ****                         {
2934:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
2935:../uvc.c      ****                             {
2936:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2937:../uvc.c      ****                                    active data structure. */
2938:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
2939:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
2940:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
2941:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
2942:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
2943:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
2944:../uvc.c      ****                             }
2945:../uvc.c      ****                         }
2946:../uvc.c      ****                         break;
2947:../uvc.c      ****                     default:
2948:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2949:../uvc.c      ****                         break;
2950:../uvc.c      ****                 }
2951:../uvc.c      ****                 break;
2952:../uvc.c      **** 
2953:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
2954:../uvc.c      ****                 switch (bRequest)
2955:../uvc.c      ****                 {
2956:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2957:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2958:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2959:../uvc.c      ****                         break;
2960:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2961:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2962:../uvc.c      ****                         glEp0Buffer[1] = 0;
2963:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2964:../uvc.c      ****                         break;
2965:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2966:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2967:../uvc.c      ****                         {
2968:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2969:../uvc.c      ****                         }
2970:../uvc.c      ****                         else
2971:../uvc.c      ****                         {
2972:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2973:../uvc.c      ****                         }
2974:../uvc.c      ****                         break;
2975:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2976:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
2977:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
2978:../uvc.c      ****                            */
2979:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2980:../uvc.c      ****                                 glCommitCtrl, &readCount);
2981:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2982:../uvc.c      ****                         {
2983:../uvc.c      ****     #if 0
2984:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
2985:../uvc.c      ****                             {
2986:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
2987:../uvc.c      ****                             }
2988:../uvc.c      ****                             else
2989:../uvc.c      ****                             {
2990:../uvc.c      ****                                 SensorScaling_VGA ();
2991:../uvc.c      ****                             }
2992:../uvc.c      ****     #endif
2993:../uvc.c      ****                             /* We can start streaming video now. */
2994:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
2995:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
2996:../uvc.c      ****                             {
2997:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
2998:../uvc.c      ****                             }
2999:../uvc.c      ****                         }
3000:../uvc.c      ****                         break;
3001:../uvc.c      **** 
3002:../uvc.c      ****                     default:
3003:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3004:../uvc.c      ****                         break;
3005:../uvc.c      ****                 }
3006:../uvc.c      ****                 break;
3007:../uvc.c      **** 
3008:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3009:../uvc.c      ****                 switch (bRequest)
3010:../uvc.c      ****                 {
3011:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3012:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3013:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3014:../uvc.c      ****                         break;
3015:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3016:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3017:../uvc.c      ****                         glEp0Buffer[1] = 0;
3018:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3019:../uvc.c      ****                         break;
3020:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3021:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3022:../uvc.c      ****                         {
3023:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3024:../uvc.c      ****                         }
3025:../uvc.c      ****                         else
3026:../uvc.c      ****                         {
3027:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3028:../uvc.c      ****                         }
3029:../uvc.c      ****                         break;
3030:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3031:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3032:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3033:../uvc.c      ****                            */
3034:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3035:../uvc.c      ****                                 glCommitCtrl, &readCount);
3036:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3037:../uvc.c      ****                         {
3038:../uvc.c      ****     #if 0
3039:../uvc.c      ****                             /* We can start streaming video now. */
3040:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3041:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3042:../uvc.c      ****                             {
3043:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3044:../uvc.c      ****                             }
3045:../uvc.c      ****     #endif
3046:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3047:../uvc.c      ****                         }else{
3048:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3049:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3050:../uvc.c      ****                         }
3051:../uvc.c      ****                         break;
3052:../uvc.c      **** 
3053:../uvc.c      ****                     default:
3054:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3055:../uvc.c      ****                         break;
3056:../uvc.c      ****                 }
3057:../uvc.c      ****                 break;
3058:../uvc.c      **** 
3059:../uvc.c      ****         default:
3060:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3061:../uvc.c      ****             break;
3062:../uvc.c      ****     }
3063:../uvc.c      **** }
3064:../uvc.c      **** 
3065:../uvc.c      **** /*
3066:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3067:../uvc.c      ****  */
3068:../uvc.c      **** void
3069:../uvc.c      **** UVCAppEP0Thread_Entry (
3070:../uvc.c      ****         uint32_t input)
3071:../uvc.c      **** {
3072:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3073:../uvc.c      ****     uint32_t eventFlag;
3074:../uvc.c      **** 	CyBool_t value;
3075:../uvc.c      **** 	CyBool_t *valueptr = &value;
3076:../uvc.c      **** 
3077:../uvc.c      **** 
3078:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3079:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3080:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3081:../uvc.c      **** 
3082:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3083:../uvc.c      **** #endif
3084:../uvc.c      **** 
3085:../uvc.c      ****     /* for interrupt status test */
3086:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3087:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3088:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3089:../uvc.c      **** 
3090:../uvc.c      ****     for (;;)
3091:../uvc.c      ****     {
3092:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3093:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3094:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3095:../uvc.c      ****         {
3096:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3097:../uvc.c      ****             if (!isUsbConnected)
3098:../uvc.c      ****             {
3099:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3100:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3101:../uvc.c      ****                 {
3102:../uvc.c      ****                     isUsbConnected = CyTrue;
3103:../uvc.c      ****                 }
3104:../uvc.c      ****             }
3105:../uvc.c      **** //#ifdef DbgInfo
3106:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3107:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3108:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3109:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3110:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3111:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3112:../uvc.c      **** //#endif
3113:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3114:../uvc.c      ****             {
3115:../uvc.c      ****             	switch ((wIndex >> 8))
3116:../uvc.c      ****                 {
3117:../uvc.c      **** 
3118:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3119:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3120:../uvc.c      ****                         break;
3121:../uvc.c      **** 
3122:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3123:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3124:../uvc.c      ****                         break;
3125:../uvc.c      **** 
3126:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3127:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3128:../uvc.c      ****                         break;
3129:../uvc.c      **** 
3130:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3131:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3132:../uvc.c      ****                         break;
3133:../uvc.c      **** 
3134:../uvc.c      ****                     default:
3135:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3136:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3137:../uvc.c      ****                         break;
3138:../uvc.c      ****                 }
3139:../uvc.c      ****             }
3140:../uvc.c      **** 
3141:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3142:../uvc.c      ****             {
3143:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3144:../uvc.c      **** 
3145:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3146:../uvc.c      ****                 {
3147:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3148:../uvc.c      ****                 }
3149:../uvc.c      ****                 else
3150:../uvc.c      ****                 {
3151:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3152:../uvc.c      ****                 }
3153:../uvc.c      ****             }
3154:../uvc.c      **** 
3155:../uvc.c      ****             /* handle interrupt status event */
3156:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3157:../uvc.c      ****             {
3158:../uvc.c      **** 
3159:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3160:../uvc.c      ****             	/** preparing interrupt status data **/
3161:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3162:../uvc.c      **** 
3163:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3164:../uvc.c      **** 
3165:../uvc.c      **** #if 1 //for real button
3166:../uvc.c      **** 				if(value&&(!snapButFlag)){
3167:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3168:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3169:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3170:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3171:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3172:../uvc.c      **** 
3173:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3174:../uvc.c      **** 					interStabuf.size   = 1024;
3175:../uvc.c      **** 					interStabuf.status = 0;
3176:../uvc.c      **** 
3177:../uvc.c      **** 					interStabuf.count = 4;
3178:../uvc.c      **** 
3179:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3180:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3181:../uvc.c      **** 
3182:../uvc.c      **** 					/** send a interrupt status data **/
3183:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3184:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3185:../uvc.c      **** 					{
3186:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3187:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3188:../uvc.c      **** 					}
3189:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3190:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3191:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3192:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3193:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3194:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3195:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3196:../uvc.c      **** 
3197:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3198:../uvc.c      **** 					interStabuf.size   = 1024;
3199:../uvc.c      **** 					interStabuf.status = 0;
3200:../uvc.c      **** 
3201:../uvc.c      **** 					interStabuf.count = 4;
3202:../uvc.c      **** 
3203:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3204:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3205:../uvc.c      **** 
3206:../uvc.c      **** 					/** send a interrupt status data **/
3207:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3208:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3209:../uvc.c      **** 					{
3210:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3211:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3212:../uvc.c      **** 					}
3213:../uvc.c      **** 
3214:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3215:../uvc.c      **** 					stiflag = CyTrue;
3216:../uvc.c      **** 				}
3217:../uvc.c      **** #else			//for botton simulation
3218:../uvc.c      **** 				if(snapButFlag == 0x0f){
3219:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3220:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3221:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3222:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3223:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3224:../uvc.c      **** 
3225:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3226:../uvc.c      **** 					interStabuf.size   = 1024;
3227:../uvc.c      **** 					interStabuf.status = 0;
3228:../uvc.c      **** 
3229:../uvc.c      **** 					interStabuf.count = 4;
3230:../uvc.c      **** 
3231:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3232:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3233:../uvc.c      **** 
3234:../uvc.c      **** 					/** send a interrupt status data **/
3235:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3236:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3237:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3238:../uvc.c      **** 					{
3239:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3240:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3241:../uvc.c      **** 					}
3242:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3243:../uvc.c      **** 
3244:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3245:../uvc.c      **** 				}else if(!snapButFlag){
3246:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3247:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3248:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3249:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3250:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3251:../uvc.c      **** 
3252:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3253:../uvc.c      **** 					interStabuf.size   = 1024;
3254:../uvc.c      **** 					interStabuf.status = 0;
3255:../uvc.c      **** 
3256:../uvc.c      **** 					interStabuf.count = 4;
3257:../uvc.c      **** 
3258:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3259:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3260:../uvc.c      **** 
3261:../uvc.c      **** 					/** send a interrupt status data **/
3262:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3263:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3264:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3265:../uvc.c      **** 					{
3266:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3267:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3268:../uvc.c      **** 					}
3269:../uvc.c      **** 
3270:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3271:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3272:../uvc.c      **** 				}
3273:../uvc.c      **** #endif
3274:../uvc.c      **** 
3275:../uvc.c      ****             }
3276:../uvc.c      **** 
3277:../uvc.c      **** 
3278:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3279:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3280:../uvc.c      ****             {
3281:../uvc.c      ****                 /* Get the command buffer */
3282:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3283:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3284:../uvc.c      ****                 {
3285:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3286:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3287:../uvc.c      ****                 }
3288:../uvc.c      **** 
3289:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3290:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3291:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3292:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3293:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3294:../uvc.c      ****                  * register value high byte and register value low byte.
3295:../uvc.c      ****                  */
3296:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3297:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3298:../uvc.c      ****                 {
3299:../uvc.c      ****                     if (dmaInfo.count == 3)
3300:../uvc.c      ****                     {
3301:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3302:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3303:../uvc.c      ****                         dmaInfo.count = 3;
3304:../uvc.c      ****                     }
3305:../uvc.c      ****                     else if (dmaInfo.count == 4)
3306:../uvc.c      ****                     {
3307:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3308:../uvc.c      ****                         {
3309:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3310:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3311:../uvc.c      ****                         }
3312:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3313:../uvc.c      ****                     }
3314:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3315:../uvc.c      ****                 }
3316:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3317:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3318:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3319:../uvc.c      ****                  */
3320:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3321:../uvc.c      ****                 {
3322:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3323:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3324:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3325:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3326:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3327:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3328:../uvc.c      ****                         	break;
3329:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3330:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3331:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3332:../uvc.c      ****                         	break;*/
3333:../uvc.c      ****                     dmaInfo.count -= 2;
3334:../uvc.c      ****                 }
3335:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3336:../uvc.c      ****                 else
3337:../uvc.c      ****                 {
3338:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3339:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3340:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3341:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3342:../uvc.c      ****                 }
3343:../uvc.c      **** 
3344:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3345:../uvc.c      ****                 dmaInfo.size   = 1024;
3346:../uvc.c      ****                 dmaInfo.status = 0;
3347:../uvc.c      **** 
3348:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3349:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3350:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3351:../uvc.c      ****                 {
3352:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3353:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3354:../uvc.c      ****                 }
3355:../uvc.c      **** 
3356:../uvc.c      ****                 /* Wait until the response has gone out. */
3357:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3358:../uvc.c      **** 
3359:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3360:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3361:../uvc.c      ****                 {
3362:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3363:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3364:../uvc.c      ****                 }
3365:../uvc.c      ****             }
3366:../uvc.c      **** #endif
3367:../uvc.c      ****         }
3368:../uvc.c      ****         /* Allow other ready threads to run. */
3369:../uvc.c      ****         CyU3PThreadRelinquish ();
3370:../uvc.c      ****     }
3371:../uvc.c      **** }
3372:../uvc.c      **** 
3373:../uvc.c      **** /*
3374:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3375:../uvc.c      ****  * added 10/2013
3376:../uvc.c      ****  */
3377:../uvc.c      **** /*
3378:../uvc.c      **** static uint8_t timeDelay[64] = {
3379:../uvc.c      **** 
3380:../uvc.c      **** };
3381:../uvc.c      **** */
3382:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3382 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3383:../uvc.c      **** 
3384:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3385:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3386:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3387:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3388:../uvc.c      **** 	VdstateDes *lcStaDes;
3389:../uvc.c      **** 	uint32_t flag = 0;
3390:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3391:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3392:../uvc.c      **** 	uint8_t i;
3393:../uvc.c      **** 	uint16_t delaytime;
3394:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3395:../uvc.c      **** 
3396:../uvc.c      **** #if 0 //for test the command queue
3397:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3398:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3399:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3400:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3401:../uvc.c      **** 		lcCmdDes += 1;
3402:../uvc.c      **** 	}
3403:../uvc.c      **** #endif
3404:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3405:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3405 0
  36 0004 10229FE5 		ldr	r2, .L22
3389:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3389 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3382:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3382 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3405 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3389:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3389 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3405 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3406:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3406 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3407:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3407 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3408:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3408 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3409:../uvc.c      **** 
3410:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3410 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3411:../uvc.c      ****         /* Allow other ready threads to run. */
3412:../uvc.c      **** 
3413:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3413 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3410:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3410 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3414:../uvc.c      **** 	}
3415:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3415 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3416:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3417:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3418:../uvc.c      **** 	//CyU3PThreadSleep(100);
3419:../uvc.c      **** 	//SetCurCmd();
3420:../uvc.c      **** 	/*********** the loop of the thread ***********/
3421:../uvc.c      **** 	for(;;){
3422:../uvc.c      **** 
3423:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3423 0
 101 0098 0060E0E3 		mvn	r6, #0
3424:../uvc.c      **** /*  // for test GPIO output
3425:../uvc.c      **** 		if(trigger)
3426:../uvc.c      **** 		{
3427:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3428:../uvc.c      **** 			{
3429:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3430:../uvc.c      **** 			}
3431:../uvc.c      **** 
3432:../uvc.c      **** 		}else{
3433:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3434:../uvc.c      **** 			{
3435:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3436:../uvc.c      **** 			}
3437:../uvc.c      **** 
3438:../uvc.c      **** 		}
3439:../uvc.c      **** */
3440:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3441:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3442:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3443:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3444:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3445:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3446:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3447:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3448:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3449:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3450:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3451:../uvc.c      **** #endif
3452:../uvc.c      **** 				}
3453:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3454:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3455:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3456:../uvc.c      **** 			}
3457:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3458:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3459:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3460:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3461:../uvc.c      **** 
3462:../uvc.c      **** 				/*
3463:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3464:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3465:../uvc.c      **** 				*/
3466:../uvc.c      **** 
3467:../uvc.c      **** 				/* find a available command */
3468:../uvc.c      **** 				i = 0;
3469:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3469 0
 103 009c 0090A0E3 		mov	r9, #0
3470:../uvc.c      **** 					i++;
3471:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3472:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3473:../uvc.c      **** 				}
3474:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3475:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3476:../uvc.c      **** 					i = lcCmdDes->curNum;
3477:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3478:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3479:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3480:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3481:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3482:../uvc.c      **** 						case 20:
3483:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3484:../uvc.c      **** 							delaytime = 500;
3485:../uvc.c      **** 							break;
3486:../uvc.c      **** 						case 21:
3487:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3488:../uvc.c      **** 							delaytime = 500;
3489:../uvc.c      **** 							break;
3490:../uvc.c      **** 						case 22:
3491:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3492:../uvc.c      **** 							delaytime = 300;
3493:../uvc.c      **** 							break;
3494:../uvc.c      **** 						case 23:
3495:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3496:../uvc.c      **** 							delaytime = 300;
3497:../uvc.c      **** 							break;
3498:../uvc.c      **** 						default:
3499:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3500:../uvc.c      **** 							break;
3501:../uvc.c      **** 					}
3502:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3503:../uvc.c      **** 					/** timer's ticket modify **/
3504:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3505:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3506:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3507:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3508:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3509:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3510:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3511:../uvc.c      **** #endif
3512:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3513:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3514:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3515:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3516:../uvc.c      **** 						}else{
3517:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3518:../uvc.c      **** 						}
3519:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3520:../uvc.c      **** 					}else{
3521:../uvc.c      **** 						lcCmdDes->curNum ++;
3522:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3522 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3423:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3423 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3440:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3440 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3457:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3457 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3459:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3459 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3460:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3460 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3469:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3469 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3471:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3471 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3470:../uvc.c      **** 					i++;
 140              		.loc 1 3470 0
 141 00f4 011083E2 		add	r1, r3, #1
3469:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3469 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3470:../uvc.c      **** 					i++;
 144              		.loc 1 3470 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3469:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3469 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3475:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3475 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3477:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3477 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3481:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3481 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3477:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3477 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3481:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3481 0
 166 0128 14C042E2 		sub	ip, r2, #20
3477:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3477 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3478:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3478 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3479:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3479 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3480:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3480 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3481:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3481 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.LVL15:
 189              	.L11:
3495:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 190              		.loc 1 3495 0
 191 0158 8230A0E3 		mov	r3, #130
 192 015c FEFFFFEB 		bl	SensorSetIrisControl
 193              	.LVL16:
3497:../uvc.c      **** 							break;
 194              		.loc 1 3497 0
 195 0160 4B1FA0E3 		mov	r1, #300
 196              	.LVL17:
 197              	.L13:
3504:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 198              		.loc 1 3504 0
 199 0164 0020A0E3 		mov	r2, #0
 200 0168 B0009FE5 		ldr	r0, .L22+4
 201 016c FEFFFFEB 		bl	_txe_timer_change
3505:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 202              		.loc 1 3505 0
 203 0170 A8009FE5 		ldr	r0, .L22+4
 204 0174 FEFFFFEB 		bl	_txe_timer_activate
 205              	.LVL18:
3512:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 206              		.loc 1 3512 0
 207 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 208 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 209 0180 000051E1 		cmp	r1, r0
3521:../uvc.c      **** 						lcCmdDes->curNum ++;
 210              		.loc 1 3521 0
 211 0184 01008012 		addne	r0, r0, #1
 212 0188 0100C415 		strneb	r0, [r4, #1]
 213              		.loc 1 3522 0
 214 018c 3C808415 		strne	r8, [r4, #60]
3512:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 215              		.loc 1 3512 0
 216 0190 1400000A 		beq	.L21
 217              	.LVL19:
 218              	.L17:
3523:../uvc.c      **** 					}
3524:../uvc.c      **** 				}else{
3525:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3526:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3527:../uvc.c      **** 				}
3528:../uvc.c      **** 			}
3529:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 219              		.loc 1 3529 0
 220 0194 1C0095E5 		ldr	r0, [r5, #28]
 221 0198 FEFFFFEB 		bl	_txe_mutex_put
 222              	.LVL20:
3530:../uvc.c      **** /*
3531:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3532:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3533:../uvc.c      **** */
3534:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3535:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3536:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3537:../uvc.c      **** #endif
3538:../uvc.c      **** 
3539:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3540:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3541:../uvc.c      **** #if 0
3542:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3543:../uvc.c      **** 
3544:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3545:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3546:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3547:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3548:../uvc.c      **** 			    i = 0;
3549:../uvc.c      **** 				 switch(cmdCopyIdx)
3550:../uvc.c      **** 				 {
3551:../uvc.c      **** 					 case BrgtCtlID1:
3552:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3553:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3554:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3555:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3556:../uvc.c      **** 							 i++;
3557:../uvc.c      **** 						 }
3558:../uvc.c      **** 						 else{
3559:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3560:../uvc.c      **** 						 }
3561:../uvc.c      **** 
3562:../uvc.c      **** 						 CyU3PBusyWait(500);
3563:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3564:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3565:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3566:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3567:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3568:../uvc.c      **** 						 }
3569:../uvc.c      **** 						 else{
3570:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3571:../uvc.c      **** 						 }
3572:../uvc.c      **** 						 break;
3573:../uvc.c      **** 					 case HueCtlID5:
3574:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3575:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3576:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3577:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3578:../uvc.c      **** 						 }
3579:../uvc.c      **** 						 else{
3580:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3581:../uvc.c      **** 						 }
3582:../uvc.c      **** 						 break;
3583:../uvc.c      **** 					 case SaturCtlID6:
3584:../uvc.c      **** 					 case WBTLevCtlID10:
3585:../uvc.c      **** 					 default:
3586:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3587:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3588:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3589:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3590:../uvc.c      **** 						 }
3591:../uvc.c      **** 						 else{
3592:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3593:../uvc.c      **** 						 }
3594:../uvc.c      **** 						 break;
3595:../uvc.c      **** 				 }
3596:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3597:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3598:../uvc.c      **** 			}
3599:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3600:../uvc.c      **** #endif
3601:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3602:../uvc.c      **** 		/* Allow other ready threads to run. */
3603:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3604:../uvc.c      **** 			CyU3PThreadRelinquish ();
 223              		.loc 1 3604 0
 224 019c FEFFFFEB 		bl	_txe_thread_relinquish
3605:../uvc.c      **** 		}
 225              		.loc 1 3605 0
 226 01a0 BFFFFFEA 		b	.L18
 227              	.LVL21:
 228              	.L9:
3487:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 229              		.loc 1 3487 0
 230 01a4 5230A0E3 		mov	r3, #82
 231 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 232              	.LVL22:
3489:../uvc.c      **** 							break;
 233              		.loc 1 3489 0
 234 01ac 7D1FA0E3 		mov	r1, #500
 235 01b0 EBFFFFEA 		b	.L13
 236              	.LVL23:
 237              	.L7:
3499:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 238              		.loc 1 3499 0
 239 01b4 FEFFFFEB 		bl	SensorSetControl
 240              	.LVL24:
 241 01b8 0A10A0E1 		mov	r1, sl
3500:../uvc.c      **** 							break;
 242              		.loc 1 3500 0
 243 01bc E8FFFFEA 		b	.L13
 244              	.LVL25:
 245              	.L8:
3483:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 246              		.loc 1 3483 0
 247 01c0 8230A0E3 		mov	r3, #130
 248 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 249              	.LVL26:
3485:../uvc.c      **** 							break;
 250              		.loc 1 3485 0
 251 01c8 7D1FA0E3 		mov	r1, #500
 252 01cc E4FFFFEA 		b	.L13
 253              	.LVL27:
 254              	.L6:
3525:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 255              		.loc 1 3525 0
 256 01d0 FA1FA0E3 		mov	r1, #1000
 257 01d4 44009FE5 		ldr	r0, .L22+4
 258 01d8 FEFFFFEB 		bl	_txe_timer_change
3526:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 259              		.loc 1 3526 0
 260 01dc 3C009FE5 		ldr	r0, .L22+4
 261 01e0 FEFFFFEB 		bl	_txe_timer_activate
 262 01e4 EAFFFFEA 		b	.L17
 263              	.LVL28:
 264              	.L21:
3514:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 265              		.loc 1 3514 0
 266 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3513:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 267              		.loc 1 3513 0
 268 01ec 3C9084E5 		str	r9, [r4, #60]
3514:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 269              		.loc 1 3514 0
 270 01f0 1F005CE3 		cmp	ip, #31
3515:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 271              		.loc 1 3515 0
 272 01f4 20C04C82 		subhi	ip, ip, #32
 273 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3517:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 274              		.loc 1 3517 0
 275 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3515:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 276              		.loc 1 3515 0
 277 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3517:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 278              		.loc 1 3517 0
 279 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3515:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 280              		.loc 1 3515 0
 281 0208 1090CC85 		strhib	r9, [ip, #16]
3517:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 282              		.loc 1 3517 0
 283 020c 9091CC95 		strlsb	r9, [ip, #400]
3519:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 284              		.loc 1 3519 0
 285 0210 344094E5 		ldr	r4, [r4, #52]
 286              	.LVL29:
 287 0214 104085E5 		str	r4, [r5, #16]
 288 0218 DDFFFFEA 		b	.L17
 289              	.L23:
 290              		.align	2
 291              	.L22:
 292 021c 00000000 		.word	I2CCmdCb
 293 0220 00000000 		.word	I2CCmdTimer
 294 0224 00000000 		.word	.LC0
 295 0228 00000000 		.word	cmdQu
 296 022c 14000000 		.word	.LC1
 297 0230 00000000 		.word	statQu
 298 0234 00000000 		.word	.LANCHOR1
 299 0238 00000000 		.word	.LANCHOR0
 300              		.cfi_endproc
 301              	.LFE25:
 303              		.align	2
 304              		.global	I2CCmdCb
 306              	I2CCmdCb:
 307              	.LFB17:
2159:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 308              		.loc 1 2159 0
 309              		.cfi_startproc
 310              		@ args = 0, pretend = 0, frame = 0
 311              		@ frame_needed = 0, uses_anonymous_args = 0
 312              		@ link register save eliminated.
 313              	.LVL30:
2161:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 314              		.loc 1 2161 0
 315 023c 08009FE5 		ldr	r0, .L25
 316              	.LVL31:
 317 0240 2010A0E3 		mov	r1, #32
 318 0244 0020A0E3 		mov	r2, #0
2162:../uvc.c      **** }
 319              		.loc 1 2162 0
2161:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 320              		.loc 1 2161 0
 321 0248 FEFFFFEA 		b	_txe_event_flags_set
 322              	.L26:
 323              		.align	2
 324              	.L25:
 325 024c 00000000 		.word	.LANCHOR0
 326              		.cfi_endproc
 327              	.LFE17:
 329              		.align	2
 330              		.global	CyFxUvcApplnDmaCallback
 332              	CyFxUvcApplnDmaCallback:
 333              	.LFB10:
1449:../uvc.c      **** {
 334              		.loc 1 1449 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 0
 337              		@ frame_needed = 0, uses_anonymous_args = 0
 338              	.LVL32:
1453:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 339              		.loc 1 1453 0
 340 0250 080051E3 		cmp	r1, #8
1449:../uvc.c      **** {
 341              		.loc 1 1449 0
 342 0254 30402DE9 		stmfd	sp!, {r4, r5, lr}
 343              	.LCFI2:
 344              		.cfi_def_cfa_offset 12
 345 0258 0240A0E1 		mov	r4, r2
 346              		.cfi_offset 14, -4
 347              		.cfi_offset 5, -8
 348              		.cfi_offset 4, -12
 349 025c 0CD04DE2 		sub	sp, sp, #12
 350              	.LCFI3:
 351              		.cfi_def_cfa_offset 24
1453:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 352              		.loc 1 1453 0
 353 0260 0B00000A 		beq	.L32
1482:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 354              		.loc 1 1482 0
 355 0264 100051E3 		cmp	r1, #16
 356 0268 0700001A 		bne	.L27
1484:../uvc.c      ****         consCount++;
 357              		.loc 1 1484 0
 358 026c 04319FE5 		ldr	r3, .L34
1485:../uvc.c      ****         streamingStarted = CyTrue;
 359              		.loc 1 1485 0
 360 0270 0120A0E3 		mov	r2, #1
 361              	.LVL33:
1484:../uvc.c      ****         consCount++;
 362              		.loc 1 1484 0
 363 0274 B0C3D3E1 		ldrh	ip, [r3, #48]
1485:../uvc.c      ****         streamingStarted = CyTrue;
 364              		.loc 1 1485 0
 365 0278 342083E5 		str	r2, [r3, #52]
1484:../uvc.c      ****         consCount++;
 366              		.loc 1 1484 0
 367 027c 02008CE0 		add	r0, ip, r2
 368              	.LVL34:
 369 0280 0018A0E1 		mov	r1, r0, asl #16
 370              	.LVL35:
 371 0284 2128A0E1 		mov	r2, r1, lsr #16
 372 0288 B023C3E1 		strh	r2, [r3, #48]	@ movhi
 373              	.L27:
1487:../uvc.c      **** }
 374              		.loc 1 1487 0
 375 028c 0CD08DE2 		add	sp, sp, #12
 376 0290 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 377              	.LVL36:
 378              	.L32:
1455:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 379              		.loc 1 1455 0
 380 0294 B420D2E1 		ldrh	r2, [r2, #4]
 381 0298 DC309FE5 		ldr	r3, .L34+4
 382 029c 030052E1 		cmp	r2, r3
 383 02a0 2900000A 		beq	.L33
1463:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 384              		.loc 1 1463 0
 385 02a4 005094E5 		ldr	r5, [r4, #0]
 386              	.LVL37:
 387              	.LBB12:
 388              	.LBB13:
1198:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 389              		.loc 1 1198 0
 390 02a8 D0109FE5 		ldr	r1, .L34+8
 391              	.LVL38:
 392 02ac 0C0045E2 		sub	r0, r5, #12
 393              	.LVL39:
 394 02b0 0C20A0E3 		mov	r2, #12
 395 02b4 FEFFFFEB 		bl	CyU3PMemCopy
 396              	.LVL40:
1203:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 397              		.loc 1 1203 0
 398 02b8 0BC055E5 		ldrb	ip, [r5, #-11]	@ zero_extendqisi2
 399              	.LBE13:
 400              	.LBE12:
1464:../uvc.c      ****                 pb++;
 401              		.loc 1 1464 0
 402 02bc B4309FE5 		ldr	r3, .L34
 403              	.LBB15:
 404              	.LBB14:
1203:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 405              		.loc 1 1203 0
 406 02c0 02108CE3 		orr	r1, ip, #2
 407 02c4 0B1045E5 		strb	r1, [r5, #-11]
 408              	.LBE14:
 409              	.LBE15:
1464:../uvc.c      ****                 pb++;
 410              		.loc 1 1464 0
 411 02c8 BA02D3E1 		ldrh	r0, [r3, #42]
1465:../uvc.c      ****                 pbc = input->buffer_p.count;
 412              		.loc 1 1465 0
 413 02cc B410D4E1 		ldrh	r1, [r4, #4]
1464:../uvc.c      ****                 pb++;
 414              		.loc 1 1464 0
 415 02d0 012080E2 		add	r2, r0, #1
 416 02d4 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
1465:../uvc.c      ****                 pbc = input->buffer_p.count;
 417              		.loc 1 1465 0
 418 02d8 BC12C3E1 		strh	r1, [r3, #44]	@ movhi
 419              	.LVL41:
 420              	.L30:
1470:../uvc.c      ****             prodCount++;
 421              		.loc 1 1470 0
 422 02dc BEE2D3E1 		ldrh	lr, [r3, #46]
1471:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 423              		.loc 1 1471 0
 424 02e0 0C1081E2 		add	r1, r1, #12
1470:../uvc.c      ****             prodCount++;
 425              		.loc 1 1470 0
 426 02e4 01C08EE2 		add	ip, lr, #1
 427 02e8 0C08A0E1 		mov	r0, ip, asl #16
 428 02ec 20E8A0E1 		mov	lr, r0, lsr #16
1471:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 429              		.loc 1 1471 0
 430 02f0 0128A0E1 		mov	r2, r1, asl #16
 431 02f4 2218A0E1 		mov	r1, r2, lsr #16
 432 02f8 84009FE5 		ldr	r0, .L34+12
 433 02fc 0020A0E3 		mov	r2, #0
1470:../uvc.c      ****             prodCount++;
 434              		.loc 1 1470 0
 435 0300 BEE2C3E1 		strh	lr, [r3, #46]	@ movhi
1471:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 436              		.loc 1 1471 0
 437 0304 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 438              	.LVL42:
1470:../uvc.c      ****             prodCount++;
 439              		.loc 1 1470 0
 440 0308 68109FE5 		ldr	r1, .L34
1474:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 441              		.loc 1 1474 0
 442 030c 002050E2 		subs	r2, r0, #0
 443 0310 DDFFFF0A 		beq	.L27
1476:../uvc.c      ****                 prodCount--;
 444              		.loc 1 1476 0
 445 0314 BEC2D1E1 		ldrh	ip, [r1, #46]
1477:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 446              		.loc 1 1477 0
 447 0318 B430D4E1 		ldrh	r3, [r4, #4]
1476:../uvc.c      ****                 prodCount--;
 448              		.loc 1 1476 0
 449 031c 01004CE2 		sub	r0, ip, #1
 450              	.LVL43:
 451 0320 00E8A0E1 		mov	lr, r0, asl #16
 452 0324 2EC8A0E1 		mov	ip, lr, lsr #16
 453 0328 BEC2C1E1 		strh	ip, [r1, #46]	@ movhi
1477:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 454              		.loc 1 1477 0
 455 032c BEE2D1E1 		ldrh	lr, [r1, #46]
 456 0330 B003D1E1 		ldrh	r0, [r1, #48]
 457 0334 4C109FE5 		ldr	r1, .L34+16
 458 0338 0EC060E0 		rsb	ip, r0, lr
 459 033c 0400A0E3 		mov	r0, #4
 460 0340 00C08DE5 		str	ip, [sp, #0]
 461 0344 FEFFFFEB 		bl	CyU3PDebugPrint
 462              	.LVL44:
 463 0348 CFFFFFEA 		b	.L27
 464              	.LVL45:
 465              	.L33:
1457:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 466              		.loc 1 1457 0
 467 034c 00E094E5 		ldr	lr, [r4, #0]
 468              	.LBB16:
 469              	.LBB17:
1198:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 470              		.loc 1 1198 0
 471 0350 28109FE5 		ldr	r1, .L34+8
 472              	.LVL46:
 473 0354 0C004EE2 		sub	r0, lr, #12
 474              	.LVL47:
 475 0358 0C20A0E3 		mov	r2, #12
 476 035c FEFFFFEB 		bl	CyU3PMemCopy
 477              	.LVL48:
 478              	.LBE17:
 479              	.LBE16:
1458:../uvc.c      ****                 fb++;
 480              		.loc 1 1458 0
 481 0360 10309FE5 		ldr	r3, .L34
 482 0364 B410D4E1 		ldrh	r1, [r4, #4]
 483 0368 B8C2D3E1 		ldrh	ip, [r3, #40]
 484 036c 01008CE2 		add	r0, ip, #1
 485 0370 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 486 0374 D8FFFFEA 		b	.L30
 487              	.L35:
 488              		.align	2
 489              	.L34:
 490 0378 00000000 		.word	.LANCHOR0
 491 037c F03F0000 		.word	16368
 492 0380 80040000 		.word	.LANCHOR1+1152
 493 0384 00000000 		.word	glChHandleUVCStream
 494 0388 38000000 		.word	.LC2
 495              		.cfi_endproc
 496              	.LFE10:
 498              		.align	2
 500              	CyFxUVCApplnUSBEventCB:
 501              	.LFB8:
1252:../uvc.c      **** {
 502              		.loc 1 1252 0
 503              		.cfi_startproc
 504              		@ args = 0, pretend = 0, frame = 8
 505              		@ frame_needed = 0, uses_anonymous_args = 0
 506              	.LVL49:
1253:../uvc.c      ****     switch (evtype)
 507              		.loc 1 1253 0
 508 038c 020050E3 		cmp	r0, #2
1252:../uvc.c      **** {
 509              		.loc 1 1252 0
 510 0390 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 511              	.LCFI4:
 512              		.cfi_def_cfa_offset 16
 513 0394 0130A0E1 		mov	r3, r1
 514 0398 10D04DE2 		sub	sp, sp, #16
 515              	.LCFI5:
 516              		.cfi_def_cfa_offset 32
1252:../uvc.c      **** {
 517              		.loc 1 1252 0
 518 039c 0040A0E1 		mov	r4, r0
 519              		.cfi_offset 14, -4
 520              		.cfi_offset 6, -8
 521              		.cfi_offset 5, -12
 522              		.cfi_offset 4, -16
1253:../uvc.c      ****     switch (evtype)
 523              		.loc 1 1253 0
 524 03a0 3600000A 		beq	.L39
 525 03a4 040050E3 		cmp	r0, #4
 526 03a8 1F00000A 		beq	.L40
 527 03ac 010050E3 		cmp	r0, #1
 528 03b0 0100000A 		beq	.L42
 529              	.LVL50:
 530              	.L36:
1289:../uvc.c      **** }
 531              		.loc 1 1289 0
 532 03b4 10D08DE2 		add	sp, sp, #16
 533 03b8 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 534              	.LVL51:
 535              	.L42:
1274:../uvc.c      ****             gpif_initialized = 0;
 536              		.loc 1 1274 0
 537 03bc 28519FE5 		ldr	r5, .L43
1272:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 538              		.loc 1 1272 0
 539 03c0 0020A0E1 		mov	r2, r0
 540 03c4 24119FE5 		ldr	r1, .L43+4
 541              	.LVL52:
 542 03c8 0400A0E3 		mov	r0, #4
 543              	.LVL53:
 544 03cc FEFFFFEB 		bl	CyU3PDebugPrint
1273:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 545              		.loc 1 1273 0
 546 03d0 0400A0E1 		mov	r0, r4
 547 03d4 FEFFFFEB 		bl	CyU3PGpifDisable
1274:../uvc.c      ****             gpif_initialized = 0;
 548              		.loc 1 1274 0
 549 03d8 00C0A0E3 		mov	ip, #0
 550              	.LBB24:
 551              	.LBB25:
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 552              		.loc 1 1236 0
 553 03dc 0410A0E1 		mov	r1, r4
 554 03e0 0500A0E1 		mov	r0, r5
 555 03e4 0220A0E3 		mov	r2, #2
 556 03e8 0C308DE2 		add	r3, sp, #12
 557              	.LBE25:
 558              	.LBE24:
1274:../uvc.c      ****             gpif_initialized = 0;
 559              		.loc 1 1274 0
 560 03ec 38C085E5 		str	ip, [r5, #56]
1275:../uvc.c      ****             isUsbConnected = CyFalse;
 561              		.loc 1 1275 0
 562 03f0 3CC085E5 		str	ip, [r5, #60]
1276:../uvc.c      ****             streamingStarted = CyFalse;
 563              		.loc 1 1276 0
 564 03f4 34C085E5 		str	ip, [r5, #52]
 565              	.LBB27:
 566              	.LBB26:
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 567              		.loc 1 1236 0
 568 03f8 00C08DE5 		str	ip, [sp, #0]
 569 03fc FEFFFFEB 		bl	_txe_event_flags_get
 570 0400 004050E2 		subs	r4, r0, #0
 571 0404 EAFFFF1A 		bne	.L36
1239:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 572              		.loc 1 1239 0
 573 0408 0110E0E3 		mvn	r1, #1
 574 040c 0220A0E3 		mov	r2, #2
 575 0410 0500A0E1 		mov	r0, r5
 576              	.L41:
 577 0414 FEFFFFEB 		bl	_txe_event_flags_set
1242:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 578              		.loc 1 1242 0
 579 0418 0500A0E1 		mov	r0, r5
 580 041c 0210A0E3 		mov	r1, #2
 581 0420 0420A0E1 		mov	r2, r4
 582 0424 FEFFFFEB 		bl	_txe_event_flags_set
 583 0428 E1FFFFEA 		b	.L36
 584              	.LVL54:
 585              	.L40:
 586              	.LBE26:
 587              	.LBE27:
1258:../uvc.c      ****             gpif_initialized = 0;
 588              		.loc 1 1258 0
 589 042c B8509FE5 		ldr	r5, .L43
1256:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 590              		.loc 1 1256 0
 591 0430 BC109FE5 		ldr	r1, .L43+8
 592              	.LVL55:
 593 0434 0020A0E1 		mov	r2, r0
 594 0438 FEFFFFEB 		bl	CyU3PDebugPrint
 595              	.LVL56:
1257:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 596              		.loc 1 1257 0
 597 043c 0100A0E3 		mov	r0, #1
 598 0440 FEFFFFEB 		bl	CyU3PGpifDisable
1258:../uvc.c      ****             gpif_initialized = 0;
 599              		.loc 1 1258 0
 600 0444 00C0A0E3 		mov	ip, #0
 601              	.LBB28:
 602              	.LBB29:
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 603              		.loc 1 1236 0
 604 0448 0110A0E3 		mov	r1, #1
 605 044c 0220A0E3 		mov	r2, #2
 606 0450 0500A0E1 		mov	r0, r5
 607 0454 0C308DE2 		add	r3, sp, #12
 608              	.LBE29:
 609              	.LBE28:
1258:../uvc.c      ****             gpif_initialized = 0;
 610              		.loc 1 1258 0
 611 0458 38C085E5 		str	ip, [r5, #56]
1259:../uvc.c      ****             streamingStarted = CyFalse;
 612              		.loc 1 1259 0
 613 045c 34C085E5 		str	ip, [r5, #52]
 614              	.LBB31:
 615              	.LBB30:
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 616              		.loc 1 1236 0
 617 0460 00C08DE5 		str	ip, [sp, #0]
 618 0464 FEFFFFEB 		bl	_txe_event_flags_get
 619 0468 004050E2 		subs	r4, r0, #0
1239:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 620              		.loc 1 1239 0
 621 046c 0500A001 		moveq	r0, r5
 622 0470 0110E003 		mvneq	r1, #1
 623 0474 0220A003 		moveq	r2, #2
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 624              		.loc 1 1236 0
 625 0478 CDFFFF1A 		bne	.L36
 626 047c E4FFFFEA 		b	.L41
 627              	.LVL57:
 628              	.L39:
 629              	.LBE30:
 630              	.LBE31:
1266:../uvc.c      ****             gpif_initialized = 0;
 631              		.loc 1 1266 0
 632 0480 64509FE5 		ldr	r5, .L43
1264:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 633              		.loc 1 1264 0
 634 0484 0020A0E1 		mov	r2, r0
 635 0488 68109FE5 		ldr	r1, .L43+12
 636              	.LVL58:
 637 048c 0400A0E3 		mov	r0, #4
 638              	.LVL59:
 639 0490 FEFFFFEB 		bl	CyU3PDebugPrint
1265:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 640              		.loc 1 1265 0
 641 0494 0100A0E3 		mov	r0, #1
 642 0498 FEFFFFEB 		bl	CyU3PGpifDisable
1266:../uvc.c      ****             gpif_initialized = 0;
 643              		.loc 1 1266 0
 644 049c 0060A0E3 		mov	r6, #0
 645              	.LBB32:
 646              	.LBB33:
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 647              		.loc 1 1236 0
 648 04a0 0500A0E1 		mov	r0, r5
 649 04a4 0110A0E3 		mov	r1, #1
 650 04a8 0420A0E1 		mov	r2, r4
 651 04ac 0C308DE2 		add	r3, sp, #12
 652              	.LBE33:
 653              	.LBE32:
1266:../uvc.c      ****             gpif_initialized = 0;
 654              		.loc 1 1266 0
 655 04b0 386085E5 		str	r6, [r5, #56]
1267:../uvc.c      ****             streamingStarted = CyFalse;
 656              		.loc 1 1267 0
 657 04b4 346085E5 		str	r6, [r5, #52]
 658              	.LBB35:
 659              	.LBB34:
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 660              		.loc 1 1236 0
 661 04b8 00608DE5 		str	r6, [sp, #0]
 662 04bc FEFFFFEB 		bl	_txe_event_flags_get
 663 04c0 006050E2 		subs	r6, r0, #0
 664 04c4 BAFFFF1A 		bne	.L36
1239:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 665              		.loc 1 1239 0
 666 04c8 0420A0E1 		mov	r2, r4
 667 04cc 0500A0E1 		mov	r0, r5
 668 04d0 0110E0E3 		mvn	r1, #1
 669 04d4 FEFFFFEB 		bl	_txe_event_flags_set
1242:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 670              		.loc 1 1242 0
 671 04d8 0500A0E1 		mov	r0, r5
 672 04dc 0410A0E1 		mov	r1, r4
 673 04e0 0620A0E1 		mov	r2, r6
 674 04e4 FEFFFFEB 		bl	_txe_event_flags_set
 675 04e8 B1FFFFEA 		b	.L36
 676              	.L44:
 677              		.align	2
 678              	.L43:
 679 04ec 00000000 		.word	.LANCHOR0
 680 04f0 C4000000 		.word	.LC5
 681 04f4 80000000 		.word	.LC3
 682 04f8 A0000000 		.word	.LC4
 683              	.LBE34:
 684              	.LBE35:
 685              		.cfi_endproc
 686              	.LFE8:
 688              		.align	2
 690              	CyFxUVCApplnUSBSetupCB:
 691              	.LFB9:
1297:../uvc.c      **** {
 692              		.loc 1 1297 0
 693              		.cfi_startproc
 694              		@ args = 0, pretend = 0, frame = 8
 695              		@ frame_needed = 0, uses_anonymous_args = 0
 696              	.LVL60:
1302:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 697              		.loc 1 1302 0
 698 04fc C0329FE5 		ldr	r3, .L70
1297:../uvc.c      **** {
 699              		.loc 1 1297 0
 700 0500 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 701              	.LCFI6:
 702              		.cfi_def_cfa_offset 24
1303:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 703              		.loc 1 1303 0
 704 0504 BCC29FE5 		ldr	ip, .L70+4
1302:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 705              		.loc 1 1302 0
 706 0508 FF4000E2 		and	r4, r0, #255
 707              		.cfi_offset 14, -4
 708              		.cfi_offset 8, -8
 709              		.cfi_offset 7, -12
 710              		.cfi_offset 6, -16
 711              		.cfi_offset 5, -20
 712              		.cfi_offset 4, -24
1303:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 713              		.loc 1 1303 0
 714 050c FF8C00E2 		and	r8, r0, #65280
1304:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 715              		.loc 1 1304 0
 716 0510 2078A0E1 		mov	r7, r0, lsr #16
1302:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 717              		.loc 1 1302 0
 718 0514 0040C3E5 		strb	r4, [r3, #0]
1304:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 719              		.loc 1 1304 0
 720 0518 AC229FE5 		ldr	r2, .L70+8
1305:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 721              		.loc 1 1305 0
 722 051c AC029FE5 		ldr	r0, .L70+12
 723              	.LVL61:
1306:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 724              		.loc 1 1306 0
 725 0520 AC329FE5 		ldr	r3, .L70+16
1305:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 726              		.loc 1 1305 0
 727 0524 0158A0E1 		mov	r5, r1, asl #16
1303:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 728              		.loc 1 1303 0
 729 0528 2884A0E1 		mov	r8, r8, lsr #8
1305:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 730              		.loc 1 1305 0
 731 052c 2558A0E1 		mov	r5, r5, lsr #16
1306:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 732              		.loc 1 1306 0
 733 0530 2118A0E1 		mov	r1, r1, lsr #16
 734              	.LVL62:
1309:../uvc.c      ****     switch (bmReqType)
 735              		.loc 1 1309 0
 736 0534 020054E3 		cmp	r4, #2
1297:../uvc.c      **** {
 737              		.loc 1 1297 0
 738 0538 10D04DE2 		sub	sp, sp, #16
 739              	.LCFI7:
 740              		.cfi_def_cfa_offset 40
1303:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 741              		.loc 1 1303 0
 742 053c 0080CCE5 		strb	r8, [ip, #0]
1304:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 743              		.loc 1 1304 0
 744 0540 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1305:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 745              		.loc 1 1305 0
 746 0544 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1306:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 747              		.loc 1 1306 0
 748 0548 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1309:../uvc.c      ****     switch (bmReqType)
 749              		.loc 1 1309 0
 750 054c 4F00000A 		beq	.L48
 751 0550 0600009A 		bls	.L66
 752 0554 210054E3 		cmp	r4, #33
 753 0558 3A00000A 		beq	.L49
 754 055c A10054E3 		cmp	r4, #161
 755 0560 3800000A 		beq	.L49
 756              	.L63:
1298:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 757              		.loc 1 1298 0
 758 0564 0000A0E3 		mov	r0, #0
 759              	.LVL63:
 760              	.L46:
1436:../uvc.c      **** }
 761              		.loc 1 1436 0
 762 0568 10D08DE2 		add	sp, sp, #16
 763 056c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 764              	.LVL64:
 765              	.L66:
1309:../uvc.c      ****     switch (bmReqType)
 766              		.loc 1 1309 0
 767 0570 010054E3 		cmp	r4, #1
 768 0574 FAFFFF1A 		bne	.L63
1349:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 769              		.loc 1 1349 0
 770 0578 0B0058E3 		cmp	r8, #11
 771 057c F8FFFF1A 		bne	.L63
1353:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 772              		.loc 1 1353 0
 773 0580 010055E3 		cmp	r5, #1
 774 0584 F6FFFF1A 		bne	.L63
1353:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 775              		.loc 1 1353 0 is_stmt 0 discriminator 1
 776 0588 000057E3 		cmp	r7, #0
 777 058c F4FFFF1A 		bne	.L63
1358:../uvc.c      ****                     gpif_initialized = 0;
 778              		.loc 1 1358 0 is_stmt 1
 779 0590 40429FE5 		ldr	r4, .L70+20
1356:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 780              		.loc 1 1356 0
 781 0594 40129FE5 		ldr	r1, .L70+24
 782 0598 0400A0E3 		mov	r0, #4
 783 059c FEFFFFEB 		bl	CyU3PDebugPrint
1357:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 784              		.loc 1 1357 0
 785 05a0 0500A0E1 		mov	r0, r5
 786 05a4 FEFFFFEB 		bl	CyU3PGpifDisable
1361:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 787              		.loc 1 1361 0
 788 05a8 0510A0E1 		mov	r1, r5
 789 05ac 8300A0E3 		mov	r0, #131
1358:../uvc.c      ****                     gpif_initialized = 0;
 790              		.loc 1 1358 0
 791 05b0 387084E5 		str	r7, [r4, #56]
1359:../uvc.c      ****                     streamingStarted = CyFalse;
 792              		.loc 1 1359 0
 793 05b4 347084E5 		str	r7, [r4, #52]
1361:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 794              		.loc 1 1361 0
 795 05b8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1362:../uvc.c      ****                     CyU3PBusyWait (100);
 796              		.loc 1 1362 0
 797 05bc 6400A0E3 		mov	r0, #100
 798 05c0 FEFFFFEB 		bl	CyU3PBusyWait
1365:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 799              		.loc 1 1365 0
 800 05c4 14029FE5 		ldr	r0, .L70+28
 801 05c8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1366:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 802              		.loc 1 1366 0
 803 05cc 8300A0E3 		mov	r0, #131
 804 05d0 FEFFFFEB 		bl	CyU3PUsbFlushEp
1367:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 805              		.loc 1 1367 0
 806 05d4 0710A0E1 		mov	r1, r7
 807 05d8 8300A0E3 		mov	r0, #131
 808 05dc FEFFFFEB 		bl	CyU3PUsbSetEpNak
1368:../uvc.c      ****                     CyU3PBusyWait (100);
 809              		.loc 1 1368 0
 810 05e0 6400A0E3 		mov	r0, #100
 811 05e4 FEFFFFEB 		bl	CyU3PBusyWait
1371:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 812              		.loc 1 1371 0
 813 05e8 0710A0E1 		mov	r1, r7
 814 05ec 0520A0E1 		mov	r2, r5
 815 05f0 8300A0E3 		mov	r0, #131
 816 05f4 FEFFFFEB 		bl	CyU3PUsbStall
 817              	.LVL65:
1374:../uvc.c      ****                     CyU3PUsbAckSetup ();
 818              		.loc 1 1374 0
 819 05f8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1376:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 820              		.loc 1 1376 0
 821 05fc 405084E5 		str	r5, [r4, #64]
 822              	.LBB40:
 823              	.LBB41:
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 824              		.loc 1 1236 0
 825 0600 0400A0E1 		mov	r0, r4
 826 0604 0510A0E1 		mov	r1, r5
 827 0608 0220A0E3 		mov	r2, #2
 828 060c 0C308DE2 		add	r3, sp, #12
 829 0610 00708DE5 		str	r7, [sp, #0]
 830 0614 FEFFFFEB 		bl	_txe_event_flags_get
 831 0618 006050E2 		subs	r6, r0, #0
 832 061c 2E00001A 		bne	.L61
1239:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 833              		.loc 1 1239 0
 834 0620 0110E0E3 		mvn	r1, #1
 835 0624 0220A0E3 		mov	r2, #2
 836 0628 0400A0E1 		mov	r0, r4
 837 062c FEFFFFEB 		bl	_txe_event_flags_set
1242:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 838              		.loc 1 1242 0
 839 0630 0400A0E1 		mov	r0, r4
 840 0634 0210A0E3 		mov	r1, #2
 841 0638 0620A0E1 		mov	r2, r6
 842 063c FEFFFFEB 		bl	_txe_event_flags_set
1372:../uvc.c      ****                     uvcHandleReq = CyTrue;
 843              		.loc 1 1372 0
 844 0640 0500A0E1 		mov	r0, r5
 845 0644 C7FFFFEA 		b	.L46
 846              	.LVL66:
 847              	.L49:
 848              	.LBE41:
 849              	.LBE40:
1314:../uvc.c      ****             switch (wIndex & 0xFF)
 850              		.loc 1 1314 0
 851 0648 FF5015E2 		ands	r5, r5, #255
 852 064c 1A00001A 		bne	.L67
 853              	.LVL67:
1319:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 854              		.loc 1 1319 0
 855 0650 0520A0E1 		mov	r2, r5
 856 0654 7C019FE5 		ldr	r0, .L70+20
 857 0658 0410A0E3 		mov	r1, #4
 858 065c FEFFFFEB 		bl	_txe_event_flags_set
 859              	.LVL68:
1321:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 860              		.loc 1 1321 0
 861 0660 002050E2 		subs	r2, r0, #0
1318:../uvc.c      ****                         uvcHandleReq = CyTrue;
 862              		.loc 1 1318 0
 863 0664 0100A003 		moveq	r0, #1
 864              	.LVL69:
1321:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 865              		.loc 1 1321 0
 866 0668 BEFFFF0A 		beq	.L46
1323:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 867              		.loc 1 1323 0
 868 066c 70119FE5 		ldr	r1, .L70+32
 869 0670 0400A0E3 		mov	r0, #4
 870 0674 FEFFFFEB 		bl	CyU3PDebugPrint
 871              	.LVL70:
1324:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 872              		.loc 1 1324 0
 873 0678 0500A0E1 		mov	r0, r5
 874 067c 0110A0E3 		mov	r1, #1
 875 0680 0520A0E1 		mov	r2, r5
 876 0684 FEFFFFEB 		bl	CyU3PUsbStall
1318:../uvc.c      ****                         uvcHandleReq = CyTrue;
 877              		.loc 1 1318 0
 878 0688 0100A0E3 		mov	r0, #1
 879 068c B5FFFFEA 		b	.L46
 880              	.LVL71:
 881              	.L48:
1384:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 882              		.loc 1 1384 0
 883 0690 010058E3 		cmp	r8, #1
 884 0694 B2FFFF1A 		bne	.L63
1386:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 885              		.loc 1 1386 0
 886 0698 830055E3 		cmp	r5, #131
 887 069c B0FFFF1A 		bne	.L63
1392:../uvc.c      ****                     if (streamingStarted == CyTrue)
 888              		.loc 1 1392 0
 889 06a0 30719FE5 		ldr	r7, .L70+20
 890 06a4 346097E5 		ldr	r6, [r7, #52]
 891 06a8 010056E3 		cmp	r6, #1
 892 06ac 1500000A 		beq	.L68
 893              	.LVL72:
1424:../uvc.c      ****                         CyU3PUsbAckSetup ();
 894              		.loc 1 1424 0
 895 06b0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1423:../uvc.c      ****                         uvcHandleReq = CyTrue;
 896              		.loc 1 1423 0
 897 06b4 0800A0E1 		mov	r0, r8
 898 06b8 AAFFFFEA 		b	.L46
 899              	.LVL73:
 900              	.L67:
1314:../uvc.c      ****             switch (wIndex & 0xFF)
 901              		.loc 1 1314 0
 902 06bc 010055E3 		cmp	r5, #1
 903 06c0 A7FFFF1A 		bne	.L63
 904              	.LVL74:
1332:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 905              		.loc 1 1332 0
 906 06c4 0020A0E3 		mov	r2, #0
 907 06c8 08019FE5 		ldr	r0, .L70+20
 908 06cc 0810A0E3 		mov	r1, #8
 909 06d0 FEFFFFEB 		bl	_txe_event_flags_set
 910              	.LVL75:
1334:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 911              		.loc 1 1334 0
 912 06d4 002050E2 		subs	r2, r0, #0
 913 06d8 0100001A 		bne	.L69
 914              	.LVL76:
 915              	.L61:
 916              	.LBB43:
 917              	.LBB42:
1372:../uvc.c      ****                     uvcHandleReq = CyTrue;
 918              		.loc 1 1372 0
 919 06dc 0500A0E1 		mov	r0, r5
 920 06e0 A0FFFFEA 		b	.L46
 921              	.LVL77:
 922              	.L69:
 923              	.LBE42:
 924              	.LBE43:
1337:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 925              		.loc 1 1337 0
 926 06e4 FC109FE5 		ldr	r1, .L70+36
 927 06e8 0400A0E3 		mov	r0, #4
 928              	.LVL78:
 929 06ec FEFFFFEB 		bl	CyU3PDebugPrint
 930              	.LVL79:
1338:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 931              		.loc 1 1338 0
 932 06f0 0000A0E3 		mov	r0, #0
 933 06f4 0510A0E1 		mov	r1, r5
 934 06f8 0020A0E1 		mov	r2, r0
 935 06fc FEFFFFEB 		bl	CyU3PUsbStall
1331:../uvc.c      ****                         uvcHandleReq = CyTrue;
 936              		.loc 1 1331 0
 937 0700 0500A0E1 		mov	r0, r5
 938 0704 97FFFFEA 		b	.L46
 939              	.LVL80:
 940              	.L68:
1394:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 941              		.loc 1 1394 0
 942 0708 DC109FE5 		ldr	r1, .L70+40
 943 070c 0400A0E3 		mov	r0, #4
 944 0710 FEFFFFEB 		bl	CyU3PDebugPrint
1398:../uvc.c      ****                         gpif_initialized = 0;
 945              		.loc 1 1398 0
 946 0714 0080A0E3 		mov	r8, #0
1397:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 947              		.loc 1 1397 0
 948 0718 0600A0E1 		mov	r0, r6
 949 071c FEFFFFEB 		bl	CyU3PGpifDisable
1402:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 950              		.loc 1 1402 0
 951 0720 0610A0E1 		mov	r1, r6
 952 0724 0500A0E1 		mov	r0, r5
1398:../uvc.c      ****                         gpif_initialized = 0;
 953              		.loc 1 1398 0
 954 0728 388087E5 		str	r8, [r7, #56]
1399:../uvc.c      ****                         streamingStarted = CyFalse;
 955              		.loc 1 1399 0
 956 072c 348087E5 		str	r8, [r7, #52]
1402:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 957              		.loc 1 1402 0
 958 0730 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1403:../uvc.c      ****                         CyU3PBusyWait (100);
 959              		.loc 1 1403 0
 960 0734 6400A0E3 		mov	r0, #100
 961 0738 FEFFFFEB 		bl	CyU3PBusyWait
1406:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 962              		.loc 1 1406 0
 963 073c 9C009FE5 		ldr	r0, .L70+28
 964 0740 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1407:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 965              		.loc 1 1407 0
 966 0744 0500A0E1 		mov	r0, r5
 967 0748 FEFFFFEB 		bl	CyU3PUsbFlushEp
1408:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 968              		.loc 1 1408 0
 969 074c 0810A0E1 		mov	r1, r8
 970 0750 0500A0E1 		mov	r0, r5
 971 0754 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1409:../uvc.c      ****                         CyU3PBusyWait (100);
 972              		.loc 1 1409 0
 973 0758 6400A0E3 		mov	r0, #100
 974 075c FEFFFFEB 		bl	CyU3PBusyWait
1412:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 975              		.loc 1 1412 0
 976 0760 0810A0E1 		mov	r1, r8
 977 0764 0620A0E1 		mov	r2, r6
 978 0768 0500A0E1 		mov	r0, r5
 979 076c FEFFFFEB 		bl	CyU3PUsbStall
 980              	.LVL81:
1416:../uvc.c      ****                         CyU3PUsbAckSetup ();
 981              		.loc 1 1416 0
 982 0770 FEFFFFEB 		bl	CyU3PUsbAckSetup
1418:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 983              		.loc 1 1418 0
 984 0774 406087E5 		str	r6, [r7, #64]
 985              	.LBB44:
 986              	.LBB45:
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 987              		.loc 1 1236 0
 988 0778 0700A0E1 		mov	r0, r7
 989 077c 0610A0E1 		mov	r1, r6
 990 0780 0420A0E1 		mov	r2, r4
 991 0784 0C308DE2 		add	r3, sp, #12
 992 0788 00808DE5 		str	r8, [sp, #0]
 993 078c FEFFFFEB 		bl	_txe_event_flags_get
 994 0790 005050E2 		subs	r5, r0, #0
1414:../uvc.c      ****                         uvcHandleReq = CyTrue;
 995              		.loc 1 1414 0
 996 0794 0600A011 		movne	r0, r6
1236:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 997              		.loc 1 1236 0
 998 0798 72FFFF1A 		bne	.L46
1239:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 999              		.loc 1 1239 0
 1000 079c 0110E0E3 		mvn	r1, #1
 1001 07a0 0420A0E1 		mov	r2, r4
 1002 07a4 0700A0E1 		mov	r0, r7
 1003 07a8 FEFFFFEB 		bl	_txe_event_flags_set
1242:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1004              		.loc 1 1242 0
 1005 07ac 0700A0E1 		mov	r0, r7
 1006 07b0 0410A0E1 		mov	r1, r4
 1007 07b4 0520A0E1 		mov	r2, r5
 1008 07b8 FEFFFFEB 		bl	_txe_event_flags_set
1414:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1009              		.loc 1 1414 0
 1010 07bc 0600A0E1 		mov	r0, r6
 1011 07c0 68FFFFEA 		b	.L46
 1012              	.L71:
 1013              		.align	2
 1014              	.L70:
 1015 07c4 00000000 		.word	bmReqType
 1016 07c8 00000000 		.word	bRequest
 1017 07cc 00000000 		.word	wValue
 1018 07d0 00000000 		.word	wIndex
 1019 07d4 00000000 		.word	wLength
 1020 07d8 00000000 		.word	.LANCHOR0
 1021 07dc 50010000 		.word	.LC8
 1022 07e0 00000000 		.word	glChHandleUVCStream
 1023 07e4 E4000000 		.word	.LC6
 1024 07e8 1C010000 		.word	.LC7
 1025 07ec 68010000 		.word	.LC9
 1026              	.LBE45:
 1027              	.LBE44:
 1028              		.cfi_endproc
 1029              	.LFE9:
 1031              		.align	2
 1032              		.global	CyFxGpifCB
 1034              	CyFxGpifCB:
 1035              	.LFB12:
1607:../uvc.c      **** {
 1036              		.loc 1 1607 0
 1037              		.cfi_startproc
 1038              		@ args = 0, pretend = 0, frame = 0
 1039              		@ frame_needed = 0, uses_anonymous_args = 0
 1040              	.LVL82:
1608:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1041              		.loc 1 1608 0
 1042 07f0 010050E3 		cmp	r0, #1
1607:../uvc.c      **** {
 1043              		.loc 1 1607 0
 1044 07f4 10402DE9 		stmfd	sp!, {r4, lr}
 1045              	.LCFI8:
 1046              		.cfi_def_cfa_offset 8
1607:../uvc.c      **** {
 1047              		.loc 1 1607 0
 1048 07f8 0120A0E1 		mov	r2, r1
1608:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1049              		.loc 1 1608 0
 1050 07fc 1080BD18 		ldmnefd	sp!, {r4, pc}
 1051              		.cfi_offset 14, -4
 1052              		.cfi_offset 4, -8
1610:../uvc.c      ****         hitFV = CyTrue;
 1053              		.loc 1 1610 0
 1054 0800 D0109FE5 		ldr	r1, .L88
 1055              	.LVL83:
 1056              	.LBB50:
 1057              	.LBB52:
1507:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1058              		.loc 1 1507 0
 1059 0804 4830D1E5 		ldrb	r3, [r1, #72]	@ zero_extendqisi2
 1060              	.LBE52:
 1061              	.LBE50:
1610:../uvc.c      ****         hitFV = CyTrue;
 1062              		.loc 1 1610 0
 1063 0808 440081E5 		str	r0, [r1, #68]
 1064              	.LVL84:
 1065              	.LBB56:
 1066              	.LBB51:
1507:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1067              		.loc 1 1507 0
 1068 080c 030053E3 		cmp	r3, #3
 1069 0810 2800000A 		beq	.L87
1531:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1070              		.loc 1 1531 0
 1071 0814 020053E3 		cmp	r3, #2
 1072 0818 1080BD18 		ldmnefd	sp!, {r4, pc}
1533:../uvc.c      ****         switch (stateId)
 1073              		.loc 1 1533 0
 1074 081c 080042E2 		sub	r0, r2, #8
 1075              	.LVL85:
 1076 0820 0A0050E3 		cmp	r0, #10
 1077 0824 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1078 0828 1B0000EA 		b	.L80
 1079              	.L82:
 1080 082c 5C080000 		.word	.L76
 1081 0830 9C080000 		.word	.L80
 1082 0834 9C080000 		.word	.L80
 1083 0838 58080000 		.word	.L72
 1084 083c 9C080000 		.word	.L80
 1085 0840 9C080000 		.word	.L80
 1086 0844 9C080000 		.word	.L80
 1087 0848 94080000 		.word	.L86
 1088 084c 9C080000 		.word	.L80
 1089 0850 9C080000 		.word	.L80
 1090 0854 58080000 		.word	.L72
 1091              	.LVL86:
 1092              	.L72:
 1093 0858 1080BDE8 		ldmfd	sp!, {r4, pc}
 1094              	.LVL87:
 1095              	.L76:
1517:../uvc.c      ****                 socket = 0;
 1096              		.loc 1 1517 0
 1097 085c 0010A0E3 		mov	r1, #0
 1098              	.L77:
 1099              	.LVL88:
1590:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1100              		.loc 1 1590 0
 1101 0860 74009FE5 		ldr	r0, .L88+4
 1102 0864 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1103              	.LVL89:
1591:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1104              		.loc 1 1591 0
 1105 0868 002050E2 		subs	r2, r0, #0
 1106 086c F9FFFF0A 		beq	.L72
1593:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1107              		.loc 1 1593 0
 1108 0870 0400A0E3 		mov	r0, #4
 1109              	.LVL90:
 1110 0874 64109FE5 		ldr	r1, .L88+8
 1111 0878 FEFFFFEB 		bl	CyU3PDebugPrint
 1112              	.LVL91:
 1113              	.L83:
 1114              	.LBB53:
 1115              	.LBB54:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1116              		.loc 1 1223 0
 1117 087c 60109FE5 		ldr	r1, .L88+12
 1118 0880 0400A0E3 		mov	r0, #4
 1119 0884 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 1120              		.loc 1 1224 0
 1121 0888 FA0FA0E3 		mov	r0, #1000
 1122 088c FEFFFFEB 		bl	_tx_thread_sleep
 1123 0890 F9FFFFEA 		b	.L83
 1124              	.LVL92:
 1125              	.L86:
 1126              	.LBE54:
 1127              	.LBE53:
1560:../uvc.c      ****                 socket = 1;
 1128              		.loc 1 1560 0
 1129 0894 0110A0E3 		mov	r1, #1
 1130 0898 F0FFFFEA 		b	.L77
 1131              	.L80:
1579:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1132              		.loc 1 1579 0
 1133 089c 44109FE5 		ldr	r1, .L88+16
 1134 08a0 0100A0E3 		mov	r0, #1
 1135 08a4 FEFFFFEB 		bl	CyU3PDebugPrint
 1136              	.LVL93:
 1137              	.LBE51:
 1138              	.LBE56:
1612:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1139              		.loc 1 1612 0
 1140 08a8 3C109FE5 		ldr	r1, .L88+20
 1141 08ac 0400A0E3 		mov	r0, #4
1614:../uvc.c      **** }
 1142              		.loc 1 1614 0
 1143 08b0 1040BDE8 		ldmfd	sp!, {r4, lr}
1612:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1144              		.loc 1 1612 0
 1145 08b4 FEFFFFEA 		b	CyU3PDebugPrint
 1146              	.LVL94:
 1147              	.L87:
 1148              	.LBB57:
 1149              	.LBB55:
1509:../uvc.c      ****         switch (stateId)
 1150              		.loc 1 1509 0
 1151 08b8 0B3042E2 		sub	r3, r2, #11
 1152 08bc 030053E3 		cmp	r3, #3
 1153 08c0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1154 08c4 F4FFFFEA 		b	.L80
 1155              	.L78:
 1156 08c8 5C080000 		.word	.L76
 1157 08cc 94080000 		.word	.L86
 1158 08d0 58080000 		.word	.L72
 1159 08d4 58080000 		.word	.L72
 1160              	.L89:
 1161              		.align	2
 1162              	.L88:
 1163 08d8 00000000 		.word	.LANCHOR0
 1164 08dc 00000000 		.word	glChHandleUVCStream
 1165 08e0 A4010000 		.word	.LC11
 1166 08e4 D4010000 		.word	.LC12
 1167 08e8 8C010000 		.word	.LC10
 1168 08ec E8010000 		.word	.LC13
 1169              	.LBE55:
 1170              	.LBE57:
 1171              		.cfi_endproc
 1172              	.LFE12:
 1174              		.align	2
 1175              		.global	I2CCmdHandler
 1177              	I2CCmdHandler:
 1178              	.LFB0:
 318:../uvc.c      **** void I2CCmdHandler(){
 1179              		.loc 1 318 0
 1180              		.cfi_startproc
 1181              		@ args = 0, pretend = 0, frame = 8
 1182              		@ frame_needed = 0, uses_anonymous_args = 0
 1183 08f0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1184              	.LCFI9:
 1185              		.cfi_def_cfa_offset 36
 321:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1186              		.loc 1 321 0
 1187 08f4 E8409FE5 		ldr	r4, .L96
 1188              		.cfi_offset 14, -4
 1189              		.cfi_offset 11, -8
 1190              		.cfi_offset 10, -12
 1191              		.cfi_offset 9, -16
 1192              		.cfi_offset 8, -20
 1193              		.cfi_offset 7, -24
 1194              		.cfi_offset 6, -28
 1195              		.cfi_offset 5, -32
 1196              		.cfi_offset 4, -36
 318:../uvc.c      **** void I2CCmdHandler(){
 1197              		.loc 1 318 0
 1198 08f8 34D04DE2 		sub	sp, sp, #52
 1199              	.LCFI10:
 1200              		.cfi_def_cfa_offset 88
 321:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1201              		.loc 1 321 0
 1202 08fc 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1203              	.LVL95:
 326:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1204              		.loc 1 326 0
 1205 0900 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 323:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1206              		.loc 1 323 0
 1207 0904 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1208              	.LVL96:
 326:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1209              		.loc 1 326 0
 1210 0908 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1211 090c 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1212 0910 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1213 0914 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1214 0918 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1215 091c 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1216 0920 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1217 0924 1C208DE5 		str	r2, [sp, #28]
 1218 0928 0400A0E3 		mov	r0, #4
 1219 092c 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 1220 0930 B0109FE5 		ldr	r1, .L96+4
 1221 0934 0520A0E1 		mov	r2, r5
 1222 0938 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1223 093c 08808DE5 		str	r8, [sp, #8]
 1224 0940 0CA08DE5 		str	sl, [sp, #12]
 1225 0944 10908DE5 		str	r9, [sp, #16]
 1226 0948 14B08DE5 		str	fp, [sp, #20]
 1227 094c 18608DE5 		str	r6, [sp, #24]
 1228 0950 20C08DE5 		str	ip, [sp, #32]
 1229 0954 FEFFFFEB 		bl	CyU3PDebugPrint
 1230              	.LVL97:
 330:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1231              		.loc 1 330 0
 1232 0958 000055E3 		cmp	r5, #0
 1233 095c 0300000A 		beq	.L94
 355:../uvc.c      **** 	}else if(CmdType == 1){
 1234              		.loc 1 355 0
 1235 0960 010055E3 		cmp	r5, #1
 1236 0964 1400000A 		beq	.L95
 1237              	.L90:
 368:../uvc.c      **** }
 1238              		.loc 1 368 0
 1239 0968 34D08DE2 		add	sp, sp, #52
 1240 096c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1241              	.L94:
 346:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1242              		.loc 1 346 0
 1243 0970 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1244 0974 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1245 0978 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 332:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1246              		.loc 1 332 0
 1247 097c 0FE0A0E3 		mov	lr, #15
 346:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1248              		.loc 1 346 0
 1249 0980 2CC08DE2 		add	ip, sp, #44
 1250 0984 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1251 0988 010080E3 		orr	r0, r0, #1
 1252 098c 011081E3 		orr	r1, r1, #1
 332:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1253              		.loc 1 332 0
 1254 0990 57E0C4E5 		strb	lr, [r4, #87]
 346:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1255              		.loc 1 346 0
 1256 0994 00C08DE5 		str	ip, [sp, #0]
 1257 0998 FEFFFFEB 		bl	SensorRead2B
 347:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1258              		.loc 1 347 0
 1259 099c 2C00DDE5 		ldrb	r0, [sp, #44]	@ zero_extendqisi2
 348:../uvc.c      **** 			if(CmdDataLen == 2){
 1260              		.loc 1 348 0
 1261 09a0 020056E3 		cmp	r6, #2
 347:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1262              		.loc 1 347 0
 1263 09a4 5500C4E5 		strb	r0, [r4, #85]
 349:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1264              		.loc 1 349 0
 1265 09a8 2D00DD05 		ldreqb	r0, [sp, #45]	@ zero_extendqisi2
 351:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1266              		.loc 1 351 0
 1267 09ac 0030E0E3 		mvn	r3, #0
 349:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1268              		.loc 1 349 0
 1269 09b0 5600C405 		streqb	r0, [r4, #86]
 351:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1270              		.loc 1 351 0
 1271 09b4 5730C4E5 		strb	r3, [r4, #87]
 1272 09b8 EAFFFFEA 		b	.L90
 1273              	.L95:
 362:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1274              		.loc 1 362 0
 1275 09bc 4E10D4E5 		ldrb	r1, [r4, #78]	@ zero_extendqisi2
 1276 09c0 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1277 09c4 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1278 09c8 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1279 09cc 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1280 09d0 FE0001E2 		and	r0, r1, #254
 1281 09d4 FE100EE2 		and	r1, lr, #254
 1282 09d8 00C08DE5 		str	ip, [sp, #0]
 1283 09dc FEFFFFEB 		bl	SensorWrite2B
 1284 09e0 E0FFFFEA 		b	.L90
 1285              	.L97:
 1286              		.align	2
 1287              	.L96:
 1288 09e4 00000000 		.word	.LANCHOR0
 1289 09e8 FC010000 		.word	.LC14
 1290              		.cfi_endproc
 1291              	.LFE0:
 1293              		.align	2
 1294              		.global	setIrisauto
 1296              	setIrisauto:
 1297              	.LFB1:
 374:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1298              		.loc 1 374 0
 1299              		.cfi_startproc
 1300              		@ args = 0, pretend = 0, frame = 0
 1301              		@ frame_needed = 0, uses_anonymous_args = 0
 1302              	.LVL98:
 1303 09ec 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1304              	.LCFI11:
 1305              		.cfi_def_cfa_offset 16
 1306 09f0 0160A0E1 		mov	r6, r1
 1307              		.cfi_offset 14, -4
 1308              		.cfi_offset 6, -8
 1309              		.cfi_offset 5, -12
 1310              		.cfi_offset 4, -16
 1311 09f4 08D04DE2 		sub	sp, sp, #8
 1312              	.LCFI12:
 1313              		.cfi_def_cfa_offset 24
 378:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1314              		.loc 1 378 0
 1315 09f8 0050A0E3 		mov	r5, #0
 374:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1316              		.loc 1 374 0
 1317 09fc 0040A0E1 		mov	r4, r0
 377:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1318              		.loc 1 377 0
 1319 0a00 0010E0E3 		mvn	r1, #0
 1320              	.LVL99:
 1321 0a04 1C0090E5 		ldr	r0, [r0, #28]
 1322              	.LVL100:
 1323 0a08 FEFFFFEB 		bl	_txe_mutex_get
 378:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1324              		.loc 1 378 0
 1325 0a0c 060065E0 		rsb	r0, r5, r6
 1326 0a10 00C070E2 		rsbs	ip, r0, #0
 1327 0a14 00C0ACE0 		adc	ip, ip, r0
 1328 0a18 1410A0E3 		mov	r1, #20
 1329 0a1c 2720A0E3 		mov	r2, #39
 1330 0a20 3030A0E3 		mov	r3, #48
 1331 0a24 0400A0E1 		mov	r0, r4
 1332 0a28 00C08DE5 		str	ip, [sp, #0]
 1333 0a2c 04508DE5 		str	r5, [sp, #4]
 1334 0a30 FEFFFFEB 		bl	cmdSet
 379:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1335              		.loc 1 379 0
 1336 0a34 050056E1 		cmp	r6, r5
 1337 0a38 0260A003 		moveq	r6, #2
 1338 0a3c 0560A011 		movne	r6, r5
 1339 0a40 0400A0E1 		mov	r0, r4
 1340 0a44 1510A0E3 		mov	r1, #21
 1341 0a48 2520A0E3 		mov	r2, #37
 1342 0a4c 3030A0E3 		mov	r3, #48
 1343 0a50 00608DE5 		str	r6, [sp, #0]
 1344 0a54 04508DE5 		str	r5, [sp, #4]
 1345 0a58 FEFFFFEB 		bl	cmdSet
 380:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1346              		.loc 1 380 0
 1347 0a5c 1C0094E5 		ldr	r0, [r4, #28]
 381:../uvc.c      **** }
 1348              		.loc 1 381 0
 1349 0a60 08D08DE2 		add	sp, sp, #8
 1350 0a64 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 380:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1351              		.loc 1 380 0
 1352 0a68 FEFFFFEA 		b	_txe_mutex_put
 1353              		.cfi_endproc
 1354              	.LFE1:
 1356              		.align	2
 1357              		.global	ControlHandle
 1359              	ControlHandle:
 1360              	.LFB2:
 383:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1361              		.loc 1 383 0
 1362              		.cfi_startproc
 1363              		@ args = 0, pretend = 0, frame = 24
 1364              		@ frame_needed = 0, uses_anonymous_args = 0
 1365              	.LVL101:
 1366 0a6c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1367              	.LCFI13:
 1368              		.cfi_def_cfa_offset 36
 390:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1369              		.loc 1 390 0
 1370 0a70 1F0050E3 		cmp	r0, #31
 389:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1371              		.loc 1 389 0
 1372 0a74 207040E2 		sub	r7, r0, #32
 1373              		.cfi_offset 14, -4
 1374              		.cfi_offset 11, -8
 1375              		.cfi_offset 10, -12
 1376              		.cfi_offset 9, -16
 1377              		.cfi_offset 8, -20
 1378              		.cfi_offset 7, -24
 1379              		.cfi_offset 6, -28
 1380              		.cfi_offset 5, -32
 1381              		.cfi_offset 4, -36
 383:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1382              		.loc 1 383 0
 1383 0a78 2CD04DE2 		sub	sp, sp, #44
 1384              	.LCFI14:
 1385              		.cfi_def_cfa_offset 80
 383:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1386              		.loc 1 383 0
 1387 0a7c 0040A0E1 		mov	r4, r0
 389:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1388              		.loc 1 389 0
 1389 0a80 FF7007E2 		and	r7, r7, #255
 1390              	.LVL102:
 390:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1391              		.loc 1 390 0
 1392 0a84 2300009A 		bls	.L102
 391:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1393              		.loc 1 391 0
 1394 0a88 E86D9FE5 		ldr	r6, .L201
 1395 0a8c 872087E0 		add	r2, r7, r7, asl #1
 1396 0a90 8221A0E1 		mov	r2, r2, asl #3
 1397 0a94 023086E0 		add	r3, r6, r2
 392:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1398              		.loc 1 392 0
 1399 0a98 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 393:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1400              		.loc 1 393 0
 1401 0a9c 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 394:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1402              		.loc 1 394 0
 1403 0aa0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 405:../uvc.c      ****     reqData = bRequest;
 1404              		.loc 1 405 0
 1405 0aa4 D03D9FE5 		ldr	r3, .L201+4
 391:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1406              		.loc 1 391 0
 1407 0aa8 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1408              	.LVL103:
 405:../uvc.c      ****     reqData = bRequest;
 1409              		.loc 1 405 0
 1410 0aac 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1411              	.LVL104:
 413:../uvc.c      ****     switch (bRequest)
 1412              		.loc 1 413 0
 1413 0ab0 830055E3 		cmp	r5, #131
 1414 0ab4 2200000A 		beq	.L108
 1415              	.LVL105:
 1416              	.L198:
 1417 0ab8 2B00009A 		bls	.L196
 1418 0abc 850055E3 		cmp	r5, #133
 1419 0ac0 8400000A 		beq	.L110
 1420 0ac4 7200003A 		bcc	.L109
 1421 0ac8 860055E3 		cmp	r5, #134
 1422 0acc BD00000A 		beq	.L111
 1423 0ad0 870055E3 		cmp	r5, #135
 1424 0ad4 B100000A 		beq	.L197
 1425              	.L104:
 873:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1426              		.loc 1 873 0
 1427 0ad8 0000A0E3 		mov	r0, #0
 1428 0adc 0110A0E3 		mov	r1, #1
 1429 0ae0 0020A0E1 		mov	r2, r0
 1430 0ae4 FEFFFFEB 		bl	CyU3PUsbStall
 874:../uvc.c      **** 			  break;
 1431              		.loc 1 874 0
 1432 0ae8 FFE0A0E3 		mov	lr, #255
 1433 0aec 0E40A0E1 		mov	r4, lr
 1434 0af0 0EC0A0E1 		mov	ip, lr
 1435 0af4 0E30A0E1 		mov	r3, lr
 1436              	.LVL106:
 1437              	.L114:
 876:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1438              		.loc 1 876 0
 1439 0af8 801D9FE5 		ldr	r1, .L201+8
 1440 0afc 0520A0E1 		mov	r2, r5
 1441 0b00 0400A0E3 		mov	r0, #4
 1442 0b04 00C08DE5 		str	ip, [sp, #0]
 1443 0b08 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1444 0b0c FEFFFFEB 		bl	CyU3PDebugPrint
 877:../uvc.c      **** }
 1445              		.loc 1 877 0
 1446 0b10 2CD08DE2 		add	sp, sp, #44
 1447 0b14 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1448              	.LVL107:
 1449              	.L102:
 396:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1450              		.loc 1 396 0
 1451 0b18 586D9FE5 		ldr	r6, .L201
 405:../uvc.c      ****     reqData = bRequest;
 1452              		.loc 1 405 0
 1453 0b1c 583D9FE5 		ldr	r3, .L201+4
 396:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1454              		.loc 1 396 0
 1455 0b20 805080E0 		add	r5, r0, r0, asl #1
 1456 0b24 850186E0 		add	r0, r6, r5, asl #3
 1457              	.LVL108:
 405:../uvc.c      ****     reqData = bRequest;
 1458              		.loc 1 405 0
 1459 0b28 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 396:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1460              		.loc 1 396 0
 1461 0b2c 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1462              	.LVL109:
 413:../uvc.c      ****     switch (bRequest)
 1463              		.loc 1 413 0
 1464 0b30 830055E3 		cmp	r5, #131
 397:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1465              		.loc 1 397 0
 1466 0b34 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1467              	.LVL110:
 398:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1468              		.loc 1 398 0
 1469 0b38 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1470              	.LVL111:
 399:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1471              		.loc 1 399 0
 1472 0b3c 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1473              	.LVL112:
 413:../uvc.c      ****     switch (bRequest)
 1474              		.loc 1 413 0
 1475 0b40 DCFFFF1A 		bne	.L198
 1476              	.LVL113:
 1477              	.L108:
 536:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1478              		.loc 1 536 0
 1479 0b44 1F0054E3 		cmp	r4, #31
 1480 0b48 BC00009A 		bls	.L136
 537:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1481              		.loc 1 537 0
 1482 0b4c 877087E0 		add	r7, r7, r7, asl #1
 1483              	.LVL114:
 1484 0b50 876186E0 		add	r6, r6, r7, asl #3
 1485 0b54 28AD9FE5 		ldr	sl, .L201+12
 1486 0b58 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 538:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1487              		.loc 1 538 0
 1488 0b5c 06C0D6E5 		ldrb	ip, [r6, #6]	@ zero_extendqisi2
 537:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1489              		.loc 1 537 0
 1490 0b60 5800CAE5 		strb	r0, [sl, #88]
 538:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1491              		.loc 1 538 0
 1492 0b64 59C0CAE5 		strb	ip, [sl, #89]
 1493 0b68 0B0000EA 		b	.L144
 1494              	.LVL115:
 1495              	.L196:
 413:../uvc.c      ****     switch (bRequest)
 1496              		.loc 1 413 0
 1497 0b6c 810055E3 		cmp	r5, #129
 1498 0b70 6400000A 		beq	.L106
 1499 0b74 1000009A 		bls	.L199
 517:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1500              		.loc 1 517 0
 1501 0b78 1F0054E3 		cmp	r4, #31
 1502 0b7c A300009A 		bls	.L133
 518:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1503              		.loc 1 518 0
 1504 0b80 877087E0 		add	r7, r7, r7, asl #1
 1505              	.LVL116:
 1506 0b84 876186E0 		add	r6, r6, r7, asl #3
 1507 0b88 F4AC9FE5 		ldr	sl, .L201+12
 1508 0b8c 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 519:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1509              		.loc 1 519 0
 1510 0b90 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
 518:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1511              		.loc 1 518 0
 1512 0b94 5840CAE5 		strb	r4, [sl, #88]
 519:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1513              		.loc 1 519 0
 1514 0b98 59E0CAE5 		strb	lr, [sl, #89]
 1515              	.L144:
 595:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1516              		.loc 1 595 0
 1517 0b9c 0800A0E1 		mov	r0, r8
 1518 0ba0 E01C9FE5 		ldr	r1, .L201+16
 1519 0ba4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1520              	.LVL117:
 597:../uvc.c      **** 			  break;
 1521              		.loc 1 597 0
 1522 0ba8 FFE0A0E3 		mov	lr, #255
 595:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1523              		.loc 1 595 0
 1524 0bac 5840DAE5 		ldrb	r4, [sl, #88]	@ zero_extendqisi2
 597:../uvc.c      **** 			  break;
 1525              		.loc 1 597 0
 1526 0bb0 0EC0A0E1 		mov	ip, lr
 1527 0bb4 0E30A0E1 		mov	r3, lr
 1528 0bb8 CEFFFFEA 		b	.L114
 1529              	.LVL118:
 1530              	.L199:
 413:../uvc.c      ****     switch (bRequest)
 1531              		.loc 1 413 0
 1532 0bbc 010055E3 		cmp	r5, #1
 1533 0bc0 C4FFFF1A 		bne	.L104
 599:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1534              		.loc 1 599 0
 1535 0bc4 B81C9FE5 		ldr	r1, .L201+12
 1536 0bc8 26208DE2 		add	r2, sp, #38
 1537 0bcc 2000A0E3 		mov	r0, #32
 1538 0bd0 581081E2 		add	r1, r1, #88
 1539 0bd4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1540              	.LVL119:
 601:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1541              		.loc 1 601 0
 1542 0bd8 002050E2 		subs	r2, r0, #0
 1543 0bdc 0103001A 		bne	.L146
 604:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1544              		.loc 1 604 0
 1545 0be0 9C2C9FE5 		ldr	r2, .L201+12
 603:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1546              		.loc 1 603 0
 1547 0be4 98EC9FE5 		ldr	lr, .L201+12
 606:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1548              		.loc 1 606 0
 1549 0be8 5A00D2E5 		ldrb	r0, [r2, #90]	@ zero_extendqisi2
 1550              	.LVL120:
 603:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1551              		.loc 1 603 0
 1552 0bec 5830DEE5 		ldrb	r3, [lr, #88]	@ zero_extendqisi2
 604:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1553              		.loc 1 604 0
 1554 0bf0 59C0D2E5 		ldrb	ip, [r2, #89]	@ zero_extendqisi2
 603:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1555              		.loc 1 603 0
 1556 0bf4 18308DE5 		str	r3, [sp, #24]
 1557              	.LVL121:
 606:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1558              		.loc 1 606 0
 1559 0bf8 1C008DE5 		str	r0, [sp, #28]
 1560              	.LVL122:
 610:../uvc.c      **** 				  switch(CtrlID)
 1561              		.loc 1 610 0
 1562 0bfc 220054E3 		cmp	r4, #34
 1563 0c00 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1564 0c04 DD0200EA 		b	.L147
 1565              	.L162:
 1566 0c08 44170000 		.word	.L148
 1567 0c0c 88160000 		.word	.L149
 1568 0c10 80170000 		.word	.L147
 1569 0c14 80170000 		.word	.L147
 1570 0c18 24160000 		.word	.L150
 1571 0c1c E0140000 		.word	.L151
 1572 0c20 60140000 		.word	.L152
 1573 0c24 80170000 		.word	.L147
 1574 0c28 80170000 		.word	.L147
 1575 0c2c 80170000 		.word	.L147
 1576 0c30 80170000 		.word	.L147
 1577 0c34 DC130000 		.word	.L153
 1578 0c38 80170000 		.word	.L147
 1579 0c3c 80170000 		.word	.L147
 1580 0c40 80170000 		.word	.L147
 1581 0c44 80170000 		.word	.L147
 1582 0c48 44130000 		.word	.L154
 1583 0c4c 80170000 		.word	.L147
 1584 0c50 80170000 		.word	.L147
 1585 0c54 80170000 		.word	.L147
 1586 0c58 80170000 		.word	.L147
 1587 0c5c 80170000 		.word	.L147
 1588 0c60 80170000 		.word	.L147
 1589 0c64 80170000 		.word	.L147
 1590 0c68 80170000 		.word	.L147
 1591 0c6c 88120000 		.word	.L155
 1592 0c70 80170000 		.word	.L147
 1593 0c74 80170000 		.word	.L147
 1594 0c78 CC130000 		.word	.L156
 1595 0c7c 80170000 		.word	.L147
 1596 0c80 2C120000 		.word	.L157
 1597 0c84 A8110000 		.word	.L158
 1598 0c88 10110000 		.word	.L159
 1599 0c8c F8100000 		.word	.L160
 1600 0c90 94100000 		.word	.L161
 1601              	.LVL123:
 1602              	.L109:
 554:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1603              		.loc 1 554 0
 1604 0c94 1F0054E3 		cmp	r4, #31
 555:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1605              		.loc 1 555 0
 1606 0c98 87708780 		addhi	r7, r7, r7, asl #1
 1607              	.LVL124:
 561:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1608              		.loc 1 561 0
 1609 0c9c 84408490 		addls	r4, r4, r4, asl #1
 555:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1610              		.loc 1 555 0
 1611 0ca0 87618680 		addhi	r6, r6, r7, asl #3
 561:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1612              		.loc 1 561 0
 1613 0ca4 84618690 		addls	r6, r6, r4, asl #3
 555:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1614              		.loc 1 555 0
 1615 0ca8 D4AB9F85 		ldrhi	sl, .L201+12
 561:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1616              		.loc 1 561 0
 1617 0cac D0AB9F95 		ldrls	sl, .L201+12
 555:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1618              		.loc 1 555 0
 1619 0cb0 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 556:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1620              		.loc 1 556 0
 1621 0cb4 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 561:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1622              		.loc 1 561 0
 1623 0cb8 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 562:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1624              		.loc 1 562 0
 1625 0cbc 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 563:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1626              		.loc 1 563 0
 1627 0cc0 0030A0E3 		mov	r3, #0
 561:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1628              		.loc 1 561 0
 1629 0cc4 5810CAE5 		strb	r1, [sl, #88]
 562:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1630              		.loc 1 562 0
 1631 0cc8 5920CAE5 		strb	r2, [sl, #89]
 563:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1632              		.loc 1 563 0
 1633 0ccc 5A30CAE5 		strb	r3, [sl, #90]
 564:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1634              		.loc 1 564 0
 1635 0cd0 5B30CAE5 		strb	r3, [sl, #91]
 1636 0cd4 B0FFFFEA 		b	.L144
 1637              	.LVL125:
 1638              	.L110:
 417:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1639              		.loc 1 417 0
 1640 0cd8 A44B9FE5 		ldr	r4, .L201+12
 418:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1641              		.loc 1 418 0
 1642 0cdc 00C0A0E3 		mov	ip, #0
 1643 0ce0 59C0C4E5 		strb	ip, [r4, #89]
 419:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1644              		.loc 1 419 0
 1645 0ce4 581084E2 		add	r1, r4, #88
 417:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1646              		.loc 1 417 0
 1647 0ce8 5880C4E5 		strb	r8, [r4, #88]
 419:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1648              		.loc 1 419 0
 1649 0cec 0200A0E3 		mov	r0, #2
 1650 0cf0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1651              	.LVL126:
 421:../uvc.c      **** 			  break;
 1652              		.loc 1 421 0
 1653 0cf4 FFE0A0E3 		mov	lr, #255
 419:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1654              		.loc 1 419 0
 1655 0cf8 5840D4E5 		ldrb	r4, [r4, #88]	@ zero_extendqisi2
 421:../uvc.c      **** 			  break;
 1656              		.loc 1 421 0
 1657 0cfc 0EC0A0E1 		mov	ip, lr
 1658 0d00 0E30A0E1 		mov	r3, lr
 1659 0d04 7BFFFFEA 		b	.L114
 1660              	.LVL127:
 1661              	.L106:
 424:../uvc.c      **** 			 switch(CtrlID)
 1662              		.loc 1 424 0
 1663 0d08 011044E2 		sub	r1, r4, #1
 1664 0d0c 210051E3 		cmp	r1, #33
 1665 0d10 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1666 0d14 D50000EA 		b	.L115
 1667              	.L123:
 1668 0d18 2C100000 		.word	.L116
 1669 0d1c 70100000 		.word	.L115
 1670 0d20 70100000 		.word	.L115
 1671 0d24 70100000 		.word	.L115
 1672 0d28 0C100000 		.word	.L117
 1673 0d2c 70100000 		.word	.L115
 1674 0d30 70100000 		.word	.L115
 1675 0d34 70100000 		.word	.L115
 1676 0d38 70100000 		.word	.L115
 1677 0d3c 70100000 		.word	.L115
 1678 0d40 E80F0000 		.word	.L118
 1679 0d44 70100000 		.word	.L115
 1680 0d48 70100000 		.word	.L115
 1681 0d4c 70100000 		.word	.L115
 1682 0d50 70100000 		.word	.L115
 1683 0d54 70100000 		.word	.L115
 1684 0d58 70100000 		.word	.L115
 1685 0d5c 70100000 		.word	.L115
 1686 0d60 70100000 		.word	.L115
 1687 0d64 70100000 		.word	.L115
 1688 0d68 70100000 		.word	.L115
 1689 0d6c 70100000 		.word	.L115
 1690 0d70 70100000 		.word	.L115
 1691 0d74 70100000 		.word	.L115
 1692 0d78 AC0F0000 		.word	.L119
 1693 0d7c 70100000 		.word	.L115
 1694 0d80 70100000 		.word	.L115
 1695 0d84 900F0000 		.word	.L120
 1696 0d88 70100000 		.word	.L115
 1697 0d8c 70100000 		.word	.L115
 1698 0d90 F40E0000 		.word	.L121
 1699 0d94 BC0E0000 		.word	.L122
 1700 0d98 BC0E0000 		.word	.L122
 1701 0d9c BC0E0000 		.word	.L122
 1702              	.L197:
 581:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1703              		.loc 1 581 0
 1704 0da0 1F0054E3 		cmp	r4, #31
 1705 0da4 3100009A 		bls	.L143
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1706              		.loc 1 582 0
 1707 0da8 877087E0 		add	r7, r7, r7, asl #1
 1708              	.LVL128:
 1709 0dac 876186E0 		add	r6, r6, r7, asl #3
 1710 0db0 CCAA9FE5 		ldr	sl, .L201+12
 1711 0db4 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1712              		.loc 1 583 0
 1713 0db8 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1714              		.loc 1 582 0
 1715 0dbc 5820CAE5 		strb	r2, [sl, #88]
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1716              		.loc 1 583 0
 1717 0dc0 5910CAE5 		strb	r1, [sl, #89]
 1718 0dc4 74FFFFEA 		b	.L144
 1719              	.LVL129:
 1720              	.L111:
 570:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1721              		.loc 1 570 0
 1722 0dc8 1F0054E3 		cmp	r4, #31
 574:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1723              		.loc 1 574 0
 1724 0dcc 84408490 		addls	r4, r4, r4, asl #1
 571:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1725              		.loc 1 571 0
 1726 0dd0 87708780 		addhi	r7, r7, r7, asl #1
 1727              	.LVL130:
 574:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1728              		.loc 1 574 0
 1729 0dd4 84618690 		addls	r6, r6, r4, asl #3
 571:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1730              		.loc 1 571 0
 1731 0dd8 87618680 		addhi	r6, r6, r7, asl #3
 1732 0ddc A08A9F85 		ldrhi	r8, .L201+12
 1733 0de0 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 574:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1734              		.loc 1 574 0
 1735 0de4 988A9F95 		ldrls	r8, .L201+12
 1736 0de8 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 576:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1737              		.loc 1 576 0
 1738 0dec 0100A0E3 		mov	r0, #1
 574:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1739              		.loc 1 574 0
 1740 0df0 5830C8E5 		strb	r3, [r8, #88]
 576:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1741              		.loc 1 576 0
 1742 0df4 8C1A9FE5 		ldr	r1, .L201+16
 1743 0df8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1744              	.LVL131:
 579:../uvc.c      **** 			  break;
 1745              		.loc 1 579 0
 1746 0dfc FFE0A0E3 		mov	lr, #255
 576:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1747              		.loc 1 576 0
 1748 0e00 5840D8E5 		ldrb	r4, [r8, #88]	@ zero_extendqisi2
 579:../uvc.c      **** 			  break;
 1749              		.loc 1 579 0
 1750 0e04 0EC0A0E1 		mov	ip, lr
 1751 0e08 0E30A0E1 		mov	r3, lr
 1752 0e0c 39FFFFEA 		b	.L114
 1753              	.LVL132:
 1754              	.L133:
 522:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1755              		.loc 1 522 0
 1756 0e10 0B0054E3 		cmp	r4, #11
 529:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1757              		.loc 1 529 0
 1758 0e14 84408410 		addne	r4, r4, r4, asl #1
 1759 0e18 84618610 		addne	r6, r6, r4, asl #3
 1760 0e1c 60AA9F15 		ldrne	sl, .L201+12
 523:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1761              		.loc 1 523 0
 1762 0e20 5CAA9F05 		ldreq	sl, .L201+12
 1763 0e24 603A9F05 		ldreq	r3, .L201+20
 529:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1764              		.loc 1 529 0
 1765 0e28 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 530:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1766              		.loc 1 530 0
 1767 0e2c 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 523:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1768              		.loc 1 523 0
 1769 0e30 58308A05 		streq	r3, [sl, #88]
 529:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1770              		.loc 1 529 0
 1771 0e34 5820CA15 		strneb	r2, [sl, #88]
 530:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1772              		.loc 1 530 0
 1773 0e38 5930CA15 		strneb	r3, [sl, #89]
 1774 0e3c 56FFFFEA 		b	.L144
 1775              	.L136:
 540:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1776              		.loc 1 540 0
 1777 0e40 0B0054E3 		cmp	r4, #11
 547:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1778              		.loc 1 547 0
 1779 0e44 84408410 		addne	r4, r4, r4, asl #1
 1780 0e48 84618610 		addne	r6, r6, r4, asl #3
 1781 0e4c 30AA9F15 		ldrne	sl, .L201+12
 541:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1782              		.loc 1 541 0
 1783 0e50 2CAA9F05 		ldreq	sl, .L201+12
 1784 0e54 343A9F05 		ldreq	r3, .L201+24
 547:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1785              		.loc 1 547 0
 1786 0e58 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 548:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1787              		.loc 1 548 0
 1788 0e5c 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 541:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1789              		.loc 1 541 0
 1790 0e60 58308A05 		streq	r3, [sl, #88]
 547:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1791              		.loc 1 547 0
 1792 0e64 5820CA15 		strneb	r2, [sl, #88]
 548:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1793              		.loc 1 548 0
 1794 0e68 5930CA15 		strneb	r3, [sl, #89]
 1795 0e6c 4AFFFFEA 		b	.L144
 1796              	.L143:
 586:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1797              		.loc 1 586 0
 1798 0e70 0B0054E3 		cmp	r4, #11
 1799 0e74 0700000A 		beq	.L200
 592:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1800              		.loc 1 592 0
 1801 0e78 84A084E0 		add	sl, r4, r4, asl #1
 1802 0e7c 8A6186E0 		add	r6, r6, sl, asl #3
 1803 0e80 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1804 0e84 F8A99FE5 		ldr	sl, .L201+12
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1805              		.loc 1 593 0
 1806 0e88 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 592:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1807              		.loc 1 592 0
 1808 0e8c 5830CAE5 		strb	r3, [sl, #88]
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1809              		.loc 1 593 0
 1810 0e90 5900CAE5 		strb	r0, [sl, #89]
 1811 0e94 40FFFFEA 		b	.L144
 1812              	.L200:
 587:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1813              		.loc 1 587 0
 1814 0e98 E4A99FE5 		ldr	sl, .L201+12
 1815 0e9c 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 589:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1816              		.loc 1 589 0
 1817 0ea0 9442D6E5 		ldrb	r4, [r6, #660]	@ zero_extendqisi2
 588:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1818              		.loc 1 588 0
 1819 0ea4 00E0A0E3 		mov	lr, #0
 587:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1820              		.loc 1 587 0
 1821 0ea8 58C0CAE5 		strb	ip, [sl, #88]
 588:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1822              		.loc 1 588 0
 1823 0eac 59E0CAE5 		strb	lr, [sl, #89]
 589:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1824              		.loc 1 589 0
 1825 0eb0 5A40CAE5 		strb	r4, [sl, #90]
 590:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1826              		.loc 1 590 0
 1827 0eb4 5BE0CAE5 		strb	lr, [sl, #91]
 1828 0eb8 37FFFFEA 		b	.L144
 1829              	.L122:
 430:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1830              		.loc 1 430 0
 1831 0ebc 877087E0 		add	r7, r7, r7, asl #1
 1832              	.LVL133:
 1833 0ec0 876186E0 		add	r6, r6, r7, asl #3
 1834 0ec4 B8E99FE5 		ldr	lr, .L201+12
 1835 0ec8 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 431:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1836              		.loc 1 431 0
 1837 0ecc 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 430:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1838              		.loc 1 430 0
 1839 0ed0 5840CEE5 		strb	r4, [lr, #88]
 431:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1840              		.loc 1 431 0
 1841 0ed4 5960CEE5 		strb	r6, [lr, #89]
 1842              	.LVL134:
 1843              	.L126:
 510:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1844              		.loc 1 510 0
 1845 0ed8 0800A0E1 		mov	r0, r8
 1846 0edc A4199FE5 		ldr	r1, .L201+16
 1847 0ee0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 515:../uvc.c      **** 			  break;
 1848              		.loc 1 515 0
 1849 0ee4 FFC0A0E3 		mov	ip, #255
 510:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1850              		.loc 1 510 0
 1851 0ee8 06E0A0E1 		mov	lr, r6
 515:../uvc.c      **** 			  break;
 1852              		.loc 1 515 0
 1853 0eec 0C30A0E1 		mov	r3, ip
 1854 0ef0 00FFFFEA 		b	.L114
 1855              	.LVL135:
 1856              	.L121:
 451:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1857              		.loc 1 451 0 discriminator 1
 1858 0ef4 000058E3 		cmp	r8, #0
 1859 0ef8 5702000A 		beq	.L191
 449:../uvc.c      **** 					 break;
 1860              		.loc 1 449 0
 1861 0efc 28E1A0E1 		mov	lr, r8, lsr #2
 1862 0f00 00005EE3 		cmp	lr, #0
 1863 0f04 03005813 		cmpne	r8, #3
 1864 0f08 0020A083 		movhi	r2, #0
 1865 0f0c 0120A093 		movls	r2, #1
 383:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1866              		.loc 1 383 0
 1867 0f10 0E31A0E1 		mov	r3, lr, asl #2
 449:../uvc.c      **** 					 break;
 1868              		.loc 1 449 0
 1869 0f14 5402009A 		bls	.L179
 1870 0f18 68199FE5 		ldr	r1, .L201+16
 1871 0f1c 0C0041E2 		sub	r0, r1, #12
 1872              	.LVL136:
 1873              	.L128:
 452:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1874              		.loc 1 452 0 discriminator 2
 1875 0f20 044090E4 		ldr	r4, [r0], #4
 1876 0f24 01C082E2 		add	ip, r2, #1
 1877 0f28 FF200CE2 		and	r2, ip, #255
 1878 0f2c 02005EE1 		cmp	lr, r2
 1879 0f30 044081E4 		str	r4, [r1], #4
 1880 0f34 F9FFFF8A 		bhi	.L128
 452:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1881              		.loc 1 452 0 is_stmt 0
 1882 0f38 030058E1 		cmp	r8, r3
 1883 0f3c 40099F15 		ldrne	r0, .L201+12
 1884 0f40 4502000A 		beq	.L191
 1885              	.L183:
 1886 0f44 03E080E0 		add	lr, r0, r3
 1887 0f48 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 451:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1888              		.loc 1 451 0 is_stmt 1
 1889 0f4c 016083E2 		add	r6, r3, #1
 1890 0f50 FF3006E2 		and	r3, r6, #255
 1891              	.LVL137:
 1892 0f54 030058E1 		cmp	r8, r3
 452:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1893              		.loc 1 452 0
 1894 0f58 5810CEE5 		strb	r1, [lr, #88]
 451:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1895              		.loc 1 451 0
 1896 0f5c F8FFFF8A 		bhi	.L183
 1897              	.LVL138:
 1898              	.L125:
 461:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1899              		.loc 1 461 0
 1900 0f60 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 454:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1901              		.loc 1 454 0
 1902 0f64 18399FE5 		ldr	r3, .L201+12
 461:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1903              		.loc 1 461 0
 1904 0f68 FF0052E3 		cmp	r2, #255
 454:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1905              		.loc 1 454 0
 1906 0f6c 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1907              	.LVL139:
 455:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1908              		.loc 1 455 0
 1909 0f70 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 1910              	.LVL140:
 461:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1911              		.loc 1 461 0
 1912 0f74 D7FFFF0A 		beq	.L126
 463:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1913              		.loc 1 463 0
 1914 0f78 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1915 0f7c 10199FE5 		ldr	r1, .L201+28
 1916 0f80 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1917 0f84 0400A0E3 		mov	r0, #4
 1918 0f88 FEFFFFEB 		bl	CyU3PDebugPrint
 1919 0f8c D1FFFFEA 		b	.L126
 1920              	.LVL141:
 1921              	.L120:
 447:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 1922              		.loc 1 447 0
 1923 0f90 EC389FE5 		ldr	r3, .L201+12
 437:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 1924              		.loc 1 437 0
 1925 0f94 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 1926              	.LVL142:
 448:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1927              		.loc 1 448 0
 1928 0f98 0020A0E3 		mov	r2, #0
 447:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 1929              		.loc 1 447 0
 1930 0f9c 5840C3E5 		strb	r4, [r3, #88]
 448:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1931              		.loc 1 448 0
 1932 0fa0 5920C3E5 		strb	r2, [r3, #89]
 401:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 1933              		.loc 1 401 0
 1934 0fa4 FF60A0E3 		mov	r6, #255
 449:../uvc.c      **** 					 break;
 1935              		.loc 1 449 0
 1936 0fa8 CAFFFFEA 		b	.L126
 1937              	.LVL143:
 1938              	.L119:
 467:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1939              		.loc 1 467 0
 1940 0fac E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 1941 0fb0 CCC89FE5 		ldr	ip, .L201+12
 469:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1942              		.loc 1 469 0
 1943 0fb4 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 468:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1944              		.loc 1 468 0
 1945 0fb8 00E0A0E3 		mov	lr, #0
 467:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1946              		.loc 1 467 0
 1947 0fbc 5840CCE5 		strb	r4, [ip, #88]
 468:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1948              		.loc 1 468 0
 1949 0fc0 59E0CCE5 		strb	lr, [ip, #89]
 469:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1950              		.loc 1 469 0
 1951 0fc4 5A60CCE5 		strb	r6, [ip, #90]
 470:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1952              		.loc 1 470 0
 1953 0fc8 5BE0CCE5 		strb	lr, [ip, #91]
 1954              	.LVL144:
 473:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 1955              		.loc 1 473 0
 1956 0fcc C4189FE5 		ldr	r1, .L201+32
 1957 0fd0 0420A0E1 		mov	r2, r4
 1958 0fd4 0E30A0E1 		mov	r3, lr
 1959 0fd8 0400A0E3 		mov	r0, #4
 1960 0fdc 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 1961 0fe0 FEFFFFEB 		bl	CyU3PDebugPrint
 474:../uvc.c      **** 					 break;
 1962              		.loc 1 474 0
 1963 0fe4 BBFFFFEA 		b	.L126
 1964              	.LVL145:
 1965              	.L118:
 495:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 1966              		.loc 1 495 0
 1967 0fe8 94089FE5 		ldr	r0, .L201+12
 1968 0fec 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 497:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 1969              		.loc 1 497 0
 1970 0ff0 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1971              		.loc 1 496 0
 1972 0ff4 00C0A0E3 		mov	ip, #0
 495:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 1973              		.loc 1 495 0
 1974 0ff8 5840C0E5 		strb	r4, [r0, #88]
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1975              		.loc 1 496 0
 1976 0ffc 59C0C0E5 		strb	ip, [r0, #89]
 497:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 1977              		.loc 1 497 0
 1978 1000 5A60C0E5 		strb	r6, [r0, #90]
 498:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1979              		.loc 1 498 0
 1980 1004 5BC0C0E5 		strb	ip, [r0, #91]
 1981              	.LVL146:
 501:../uvc.c      **** 					 break;
 1982              		.loc 1 501 0
 1983 1008 B2FFFFEA 		b	.L126
 1984              	.LVL147:
 1985              	.L117:
 490:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 1986              		.loc 1 490 0
 1987 100c 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 1988 1010 6CE89FE5 		ldr	lr, .L201+12
 1989 1014 804024E2 		eor	r4, r4, #128
 491:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1990              		.loc 1 491 0
 1991 1018 0020A0E3 		mov	r2, #0
 490:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 1992              		.loc 1 490 0
 1993 101c 5840CEE5 		strb	r4, [lr, #88]
 491:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1994              		.loc 1 491 0
 1995 1020 5920CEE5 		strb	r2, [lr, #89]
 1996              	.LVL148:
 401:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 1997              		.loc 1 401 0
 1998 1024 FF60A0E3 		mov	r6, #255
 493:../uvc.c      **** 					 break;
 1999              		.loc 1 493 0
 2000 1028 AAFFFFEA 		b	.L126
 2001              	.LVL149:
 2002              	.L116:
 479:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2003              		.loc 1 479 0
 2004 102c A611D6E5 		ldrb	r1, [r6, #422]	@ zero_extendqisi2
 477:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2005              		.loc 1 477 0
 2006 1030 A561D6E5 		ldrb	r6, [r6, #421]	@ zero_extendqisi2
 2007              	.LVL150:
 479:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2008              		.loc 1 479 0
 2009 1034 020011E3 		tst	r1, #2
 482:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2010              		.loc 1 482 0
 2011 1038 2661A001 		moveq	r6, r6, lsr #2
 2012              	.LVL151:
 2013 103c 866CE001 		mvneq	r6, r6, asl #25
 2014 1040 A66CE001 		mvneq	r6, r6, lsr #25
 484:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2015              		.loc 1 484 0
 2016 1044 38389FE5 		ldr	r3, .L201+12
 480:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2017              		.loc 1 480 0
 2018 1048 0113A011 		movne	r1, r1, asl #6
 2019 104c 40400112 		andne	r4, r1, #64
 482:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2020              		.loc 1 482 0
 2021 1050 01138601 		orreq	r1, r6, r1, asl #6
 480:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2022              		.loc 1 480 0
 2023 1054 26418411 		orrne	r4, r4, r6, lsr #2
 2024              	.LVL152:
 482:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2025              		.loc 1 482 0
 2026 1058 FF400102 		andeq	r4, r1, #255
 2027              	.LVL153:
 485:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2028              		.loc 1 485 0
 2029 105c 0000A0E3 		mov	r0, #0
 484:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2030              		.loc 1 484 0
 2031 1060 5840C3E5 		strb	r4, [r3, #88]
 485:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2032              		.loc 1 485 0
 2033 1064 5900C3E5 		strb	r0, [r3, #89]
 2034              	.LVL154:
 401:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2035              		.loc 1 401 0
 2036 1068 FF60A0E3 		mov	r6, #255
 487:../uvc.c      **** 					 break;
 2037              		.loc 1 487 0
 2038 106c 99FFFFEA 		b	.L126
 2039              	.LVL155:
 2040              	.L115:
 504:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2041              		.loc 1 504 0
 2042 1070 842084E0 		add	r2, r4, r4, asl #1
 2043 1074 826186E0 		add	r6, r6, r2, asl #3
 2044 1078 04389FE5 		ldr	r3, .L201+12
 2045 107c 8D41D6E5 		ldrb	r4, [r6, #397]	@ zero_extendqisi2
 505:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2046              		.loc 1 505 0
 2047 1080 0010A0E3 		mov	r1, #0
 401:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2048              		.loc 1 401 0
 2049 1084 FF60A0E3 		mov	r6, #255
 504:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2050              		.loc 1 504 0
 2051 1088 5840C3E5 		strb	r4, [r3, #88]
 505:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2052              		.loc 1 505 0
 2053 108c 5910C3E5 		strb	r1, [r3, #89]
 2054              	.LVL156:
 507:../uvc.c      **** 					 break;
 2055              		.loc 1 507 0
 2056 1090 90FFFFEA 		b	.L126
 2057              	.LVL157:
 2058              	.L161:
 743:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2059              		.loc 1 743 0
 2060 1094 00489FE5 		ldr	r4, .L201+36
 2061 1098 0010E0E3 		mvn	r1, #0
 2062 109c 1C0094E5 		ldr	r0, [r4, #28]
 2063 10a0 FEFFFFEB 		bl	_txe_mutex_get
 2064              	.LVL158:
 744:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2065              		.loc 1 744 0
 2066 10a4 2210A0E3 		mov	r1, #34
 2067              	.L195:
 2068 10a8 18C09DE5 		ldr	ip, [sp, #24]
 2069 10ac 00E0A0E3 		mov	lr, #0
 2070 10b0 0A30A0E1 		mov	r3, sl
 2071 10b4 0920A0E1 		mov	r2, r9
 2072 10b8 0400A0E1 		mov	r0, r4
 2073 10bc 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2074 10c0 FEFFFFEB 		bl	cmdSet
 745:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2075              		.loc 1 745 0
 2076 10c4 1C0094E5 		ldr	r0, [r4, #28]
 2077 10c8 FEFFFFEB 		bl	_txe_mutex_put
 746:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2078              		.loc 1 746 0
 2079 10cc 18109DE5 		ldr	r1, [sp, #24]
 2080 10d0 877087E0 		add	r7, r7, r7, asl #1
 2081              	.LVL159:
 2082 10d4 876186E0 		add	r6, r6, r7, asl #3
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2083              		.loc 1 747 0
 2084 10d8 0130A0E3 		mov	r3, #1
 748:../uvc.c      **** 							 break;
 2085              		.loc 1 748 0
 2086 10dc FFE0A0E3 		mov	lr, #255
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2087              		.loc 1 747 0
 2088 10e0 1030C6E5 		strb	r3, [r6, #16]
 746:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2089              		.loc 1 746 0
 2090 10e4 0D10C6E5 		strb	r1, [r6, #13]
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2091              		.loc 1 747 0
 2092 10e8 0130A0E1 		mov	r3, r1
 2093 10ec 1CC09DE5 		ldr	ip, [sp, #28]
 748:../uvc.c      **** 							 break;
 2094              		.loc 1 748 0
 2095 10f0 0E40A0E1 		mov	r4, lr
 2096 10f4 7FFEFFEA 		b	.L114
 2097              	.LVL160:
 2098              	.L160:
 735:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2099              		.loc 1 735 0
 2100 10f8 9C479FE5 		ldr	r4, .L201+36
 2101 10fc 0010E0E3 		mvn	r1, #0
 2102 1100 1C0094E5 		ldr	r0, [r4, #28]
 2103 1104 FEFFFFEB 		bl	_txe_mutex_get
 2104              	.LVL161:
 736:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2105              		.loc 1 736 0
 2106 1108 2110A0E3 		mov	r1, #33
 2107 110c E5FFFFEA 		b	.L195
 2108              	.LVL162:
 2109              	.L159:
 721:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2110              		.loc 1 721 0
 2111 1110 84479FE5 		ldr	r4, .L201+36
 2112 1114 0010E0E3 		mvn	r1, #0
 2113 1118 1C0094E5 		ldr	r0, [r4, #28]
 2114 111c 14C08DE5 		str	ip, [sp, #20]
 2115 1120 FEFFFFEB 		bl	_txe_mutex_get
 2116              	.LVL163:
 720:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2117              		.loc 1 720 0
 2118 1124 18209DE5 		ldr	r2, [sp, #24]
 723:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2119              		.loc 1 723 0
 2120 1128 00E0A0E3 		mov	lr, #0
 720:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2121              		.loc 1 720 0
 2122 112c 7F8002E2 		and	r8, r2, #127
 2123 1130 1C808DE5 		str	r8, [sp, #28]
 2124              	.LVL164:
 723:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2125              		.loc 1 723 0
 2126 1134 1CC09DE5 		ldr	ip, [sp, #28]
 2127 1138 2010A0E3 		mov	r1, #32
 2128 113c 0920A0E1 		mov	r2, r9
 2129 1140 0A30A0E1 		mov	r3, sl
 2130 1144 0400A0E1 		mov	r0, r4
 2131 1148 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2132 114c FEFFFFEB 		bl	cmdSet
 2133              	.LVL165:
 725:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2134              		.loc 1 725 0
 2135 1150 14C09DE5 		ldr	ip, [sp, #20]
 2136 1154 0A30A0E1 		mov	r3, sl
 2137 1158 0180A0E3 		mov	r8, #1
 2138 115c 2010A0E3 		mov	r1, #32
 2139 1160 0B20A0E1 		mov	r2, fp
 2140 1164 0400A0E1 		mov	r0, r4
 2141 1168 00C08DE5 		str	ip, [sp, #0]
 2142 116c 04808DE5 		str	r8, [sp, #4]
 2143 1170 FEFFFFEB 		bl	cmdSet
 726:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2144              		.loc 1 726 0
 2145 1174 1C0094E5 		ldr	r0, [r4, #28]
 2146 1178 FEFFFFEB 		bl	_txe_mutex_put
 2147              	.LVL166:
 729:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2148              		.loc 1 729 0
 2149 117c 1C009DE5 		ldr	r0, [sp, #28]
 2150 1180 877087E0 		add	r7, r7, r7, asl #1
 2151              	.LVL167:
 2152 1184 876186E0 		add	r6, r6, r7, asl #3
 2153 1188 0D00C6E5 		strb	r0, [r6, #13]
 730:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2154              		.loc 1 730 0
 2155 118c 14C09DE5 		ldr	ip, [sp, #20]
 732:../uvc.c      **** 							 break;
 2156              		.loc 1 732 0
 2157 1190 FFE0A0E3 		mov	lr, #255
 730:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2158              		.loc 1 730 0
 2159 1194 0EC0C6E5 		strb	ip, [r6, #14]
 731:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2160              		.loc 1 731 0
 2161 1198 1080C6E5 		strb	r8, [r6, #16]
 2162 119c 18309DE5 		ldr	r3, [sp, #24]
 732:../uvc.c      **** 							 break;
 2163              		.loc 1 732 0
 2164 11a0 0E40A0E1 		mov	r4, lr
 2165 11a4 53FEFFEA 		b	.L114
 2166              	.LVL168:
 2167              	.L158:
 692:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2168              		.loc 1 692 0 discriminator 1
 2169 11a8 000058E3 		cmp	r8, #0
 2170 11ac 1800000A 		beq	.L164
 690:../uvc.c      **** 							 break;
 2171              		.loc 1 690 0
 2172 11b0 28E1A0E1 		mov	lr, r8, lsr #2
 2173 11b4 00005EE3 		cmp	lr, #0
 2174 11b8 03005813 		cmpne	r8, #3
 2175 11bc 0020A083 		movhi	r2, #0
 2176 11c0 0120A093 		movls	r2, #1
 383:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2177              		.loc 1 383 0
 2178 11c4 0E31A0E1 		mov	r3, lr, asl #2
 690:../uvc.c      **** 							 break;
 2179              		.loc 1 690 0
 2180 11c8 A501009A 		bls	.L180
 2181 11cc CC169FE5 		ldr	r1, .L201+40
 2182 11d0 0C0081E2 		add	r0, r1, #12
 2183              	.LVL169:
 2184              	.L173:
 693:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2185              		.loc 1 693 0 discriminator 2
 2186 11d4 044090E4 		ldr	r4, [r0], #4
 2187 11d8 012082E2 		add	r2, r2, #1
 2188 11dc FF2002E2 		and	r2, r2, #255
 2189 11e0 02005EE1 		cmp	lr, r2
 2190 11e4 044081E4 		str	r4, [r1], #4
 2191 11e8 F9FFFF8A 		bhi	.L173
 693:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2192              		.loc 1 693 0 is_stmt 0
 2193 11ec 030058E1 		cmp	r8, r3
 2194 11f0 0700000A 		beq	.L164
 2195              	.LVL170:
 2196              	.L184:
 2197 11f4 88C69FE5 		ldr	ip, .L201+12
 2198 11f8 03E08CE0 		add	lr, ip, r3
 2199 11fc 5810DEE5 		ldrb	r1, [lr, #88]	@ zero_extendqisi2
 692:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2200              		.loc 1 692 0 is_stmt 1
 2201 1200 013083E2 		add	r3, r3, #1
 2202 1204 FF3003E2 		and	r3, r3, #255
 2203              	.LVL171:
 2204 1208 030058E1 		cmp	r8, r3
 693:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2205              		.loc 1 693 0
 2206 120c 4C10CEE5 		strb	r1, [lr, #76]
 692:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2207              		.loc 1 692 0
 2208 1210 F7FFFF8A 		bhi	.L184
 2209              	.LVL172:
 2210              	.L164:
 695:../uvc.c      **** 					 		I2CCmdHandler();
 2211              		.loc 1 695 0
 2212 1214 FEFFFFEB 		bl	I2CCmdHandler
 696:../uvc.c      **** 							 break;
 2213              		.loc 1 696 0
 2214 1218 FFE0A0E3 		mov	lr, #255
 695:../uvc.c      **** 					 		I2CCmdHandler();
 2215              		.loc 1 695 0
 2216 121c 18309DE5 		ldr	r3, [sp, #24]
 2217 1220 1CC09DE5 		ldr	ip, [sp, #28]
 696:../uvc.c      **** 							 break;
 2218              		.loc 1 696 0
 2219 1224 0E40A0E1 		mov	r4, lr
 2220 1228 32FEFFEA 		b	.L114
 2221              	.LVL173:
 2222              	.L157:
 686:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2223              		.loc 1 686 0
 2224 122c 68469FE5 		ldr	r4, .L201+36
 2225 1230 0010E0E3 		mvn	r1, #0
 2226 1234 1C0094E5 		ldr	r0, [r4, #28]
 2227 1238 FEFFFFEB 		bl	_txe_mutex_get
 2228              	.LVL174:
 687:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2229              		.loc 1 687 0
 2230 123c 18009DE5 		ldr	r0, [sp, #24]
 2231 1240 00E0A0E3 		mov	lr, #0
 2232 1244 01C070E2 		rsbs	ip, r0, #1
 2233 1248 00C0A033 		movcc	ip, #0
 2234 124c 0A30A0E1 		mov	r3, sl
 2235 1250 1E10A0E3 		mov	r1, #30
 2236 1254 0920A0E1 		mov	r2, r9
 2237 1258 0400A0E1 		mov	r0, r4
 2238 125c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2239 1260 FEFFFFEB 		bl	cmdSet
 688:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2240              		.loc 1 688 0
 2241 1264 1C0094E5 		ldr	r0, [r4, #28]
 2242 1268 FEFFFFEB 		bl	_txe_mutex_put
 689:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2243              		.loc 1 689 0
 2244 126c 0130A0E3 		mov	r3, #1
 690:../uvc.c      **** 							 break;
 2245              		.loc 1 690 0
 2246 1270 FFE0A0E3 		mov	lr, #255
 689:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2247              		.loc 1 689 0
 2248 1274 6034C6E5 		strb	r3, [r6, #1120]
 2249 1278 1CC09DE5 		ldr	ip, [sp, #28]
 2250 127c 18309DE5 		ldr	r3, [sp, #24]
 690:../uvc.c      **** 							 break;
 2251              		.loc 1 690 0
 2252 1280 0E40A0E1 		mov	r4, lr
 2253 1284 1BFEFFEA 		b	.L114
 2254              	.LVL175:
 2255              	.L155:
 648:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2256              		.loc 1 648 0
 2257 1288 1C209DE5 		ldr	r2, [sp, #28]
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2258              		.loc 1 651 0
 2259 128c 08469FE5 		ldr	r4, .L201+36
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2260              		.loc 1 649 0
 2261 1290 0170A0E3 		mov	r7, #1
 2262              	.LVL176:
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2263              		.loc 1 651 0
 2264 1294 0010E0E3 		mvn	r1, #0
 647:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2265              		.loc 1 647 0
 2266 1298 E533C6E5 		strb	r3, [r6, #997]
 648:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2267              		.loc 1 648 0
 2268 129c E623C6E5 		strb	r2, [r6, #998]
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2269              		.loc 1 651 0
 2270 12a0 1C0094E5 		ldr	r0, [r4, #28]
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2271              		.loc 1 649 0
 2272 12a4 E873C6E5 		strb	r7, [r6, #1000]
 2273              	.LVL177:
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2274              		.loc 1 651 0
 2275 12a8 FEFFFFEB 		bl	_txe_mutex_get
 2276              	.LVL178:
 652:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2277              		.loc 1 652 0
 2278 12ac 18C09DE5 		ldr	ip, [sp, #24]
 2279 12b0 0400A0E1 		mov	r0, r4
 2280 12b4 00C08DE5 		str	ip, [sp, #0]
 2281 12b8 1910A0E3 		mov	r1, #25
 2282 12bc 00C0A0E3 		mov	ip, #0
 2283 12c0 0920A0E1 		mov	r2, r9
 2284 12c4 0A30A0E1 		mov	r3, sl
 2285 12c8 04C08DE5 		str	ip, [sp, #4]
 2286 12cc FEFFFFEB 		bl	cmdSet
 653:../uvc.c      **** 							 if(getData != 0){
 2287              		.loc 1 653 0
 2288 12d0 18009DE5 		ldr	r0, [sp, #24]
 2289 12d4 000050E3 		cmp	r0, #0
 2290 12d8 0700000A 		beq	.L171
 2291              	.LVL179:
 655:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2292              		.loc 1 655 0
 2293 12dc 1CE09DE5 		ldr	lr, [sp, #28]
 2294 12e0 0400A0E1 		mov	r0, r4
 2295 12e4 1910A0E3 		mov	r1, #25
 2296 12e8 0B20A0E1 		mov	r2, fp
 2297 12ec 0A30A0E1 		mov	r3, sl
 2298 12f0 00E08DE5 		str	lr, [sp, #0]
 2299 12f4 04708DE5 		str	r7, [sp, #4]
 2300 12f8 FEFFFFEB 		bl	cmdSet
 2301              	.LVL180:
 2302              	.L171:
 657:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2303              		.loc 1 657 0
 2304 12fc 1C0094E5 		ldr	r0, [r4, #28]
 2305 1300 FEFFFFEB 		bl	_txe_mutex_put
 658:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2306              		.loc 1 658 0
 2307 1304 78059FE5 		ldr	r0, .L201+12
 2308 1308 74159FE5 		ldr	r1, .L201+12
 2309 130c 5AC0D0E5 		ldrb	ip, [r0, #90]	@ zero_extendqisi2
 2310 1310 5B40D1E5 		ldrb	r4, [r1, #91]	@ zero_extendqisi2
 2311 1314 5930D0E5 		ldrb	r3, [r0, #89]	@ zero_extendqisi2
 2312 1318 5820D0E5 		ldrb	r2, [r0, #88]	@ zero_extendqisi2
 2313 131c 80159FE5 		ldr	r1, .L201+44
 2314 1320 0400A0E3 		mov	r0, #4
 2315 1324 00C08DE5 		str	ip, [sp, #0]
 2316 1328 04408DE5 		str	r4, [sp, #4]
 2317 132c FEFFFFEB 		bl	CyU3PDebugPrint
 659:../uvc.c      **** 							 break;
 2318              		.loc 1 659 0
 2319 1330 FFE0A0E3 		mov	lr, #255
 658:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2320              		.loc 1 658 0
 2321 1334 18309DE5 		ldr	r3, [sp, #24]
 2322 1338 1CC09DE5 		ldr	ip, [sp, #28]
 659:../uvc.c      **** 							 break;
 2323              		.loc 1 659 0
 2324 133c 0E40A0E1 		mov	r4, lr
 2325 1340 ECFDFFEA 		b	.L114
 2326              	.LVL181:
 2327              	.L154:
 614:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2328              		.loc 1 614 0
 2329 1344 001053E2 		subs	r1, r3, #0
 613:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2330              		.loc 1 613 0
 2331 1348 0D13C6E5 		strb	r1, [r6, #781]
 2332 134c 24359FE5 		ldr	r3, .L201
 614:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2333              		.loc 1 614 0
 2334 1350 2C01001A 		bne	.L165
 615:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2335              		.loc 1 615 0
 2336 1354 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2337 1358 020052E3 		cmp	r2, #2
 2338 135c 08005213 		cmpne	r2, #8
 2339 1360 0300000A 		beq	.L166
 616:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2340              		.loc 1 616 0
 2341 1364 010052E3 		cmp	r2, #1
 617:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2342              		.loc 1 617 0
 2343 1368 07208202 		addeq	r2, r2, #7
 619:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2344              		.loc 1 619 0
 2345 136c 0220A013 		movne	r2, #2
 2346 1370 B524C3E5 		strb	r2, [r3, #1205]
 2347              	.LVL182:
 2348              	.L166:
 641:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2349              		.loc 1 641 0
 2350 1374 20459FE5 		ldr	r4, .L201+36
 639:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2351              		.loc 1 639 0
 2352 1378 0130A0E3 		mov	r3, #1
 641:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2353              		.loc 1 641 0
 2354 137c 0010E0E3 		mvn	r1, #0
 639:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2355              		.loc 1 639 0
 2356 1380 1033C6E5 		strb	r3, [r6, #784]
 2357              	.LVL183:
 641:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2358              		.loc 1 641 0
 2359 1384 1C0094E5 		ldr	r0, [r4, #28]
 2360 1388 FEFFFFEB 		bl	_txe_mutex_get
 642:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2361              		.loc 1 642 0
 2362 138c 18C09DE5 		ldr	ip, [sp, #24]
 2363 1390 1010A0E3 		mov	r1, #16
 2364 1394 00C08DE5 		str	ip, [sp, #0]
 2365 1398 0920A0E1 		mov	r2, r9
 2366 139c 0A30A0E1 		mov	r3, sl
 2367 13a0 0400A0E1 		mov	r0, r4
 2368 13a4 00C0A0E3 		mov	ip, #0
 2369              	.L194:
 849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2370              		.loc 1 849 0
 2371 13a8 04C08DE5 		str	ip, [sp, #4]
 2372 13ac FEFFFFEB 		bl	cmdSet
 850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2373              		.loc 1 850 0
 2374 13b0 1C0094E5 		ldr	r0, [r4, #28]
 2375 13b4 FEFFFFEB 		bl	_txe_mutex_put
 852:../uvc.c      **** 					 		 break;
 2376              		.loc 1 852 0
 2377 13b8 FFE0A0E3 		mov	lr, #255
 850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2378              		.loc 1 850 0
 2379 13bc 18309DE5 		ldr	r3, [sp, #24]
 2380 13c0 1CC09DE5 		ldr	ip, [sp, #28]
 852:../uvc.c      **** 					 		 break;
 2381              		.loc 1 852 0
 2382 13c4 0E40A0E1 		mov	r4, lr
 2383 13c8 CAFDFFEA 		b	.L114
 2384              	.LVL184:
 2385              	.L156:
 610:../uvc.c      **** 				  switch(CtrlID)
 2386              		.loc 1 610 0
 2387 13cc FFE0A0E3 		mov	lr, #255
 2388 13d0 00C0A0E1 		mov	ip, r0
 2389              	.LVL185:
 2390 13d4 0E40A0E1 		mov	r4, lr
 2391 13d8 C6FDFFEA 		b	.L114
 2392              	.LVL186:
 2393              	.L153:
 809:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2394              		.loc 1 809 0
 2395 13dc B8449FE5 		ldr	r4, .L201+36
 2396 13e0 0010E0E3 		mvn	r1, #0
 2397 13e4 1C0094E5 		ldr	r0, [r4, #28]
 2398 13e8 FEFFFFEB 		bl	_txe_mutex_get
 810:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2399              		.loc 1 810 0
 2400 13ec 18C09DE5 		ldr	ip, [sp, #24]
 2401 13f0 0B10A0E3 		mov	r1, #11
 2402 13f4 0920A0E1 		mov	r2, r9
 2403 13f8 0A30A0E1 		mov	r3, sl
 2404 13fc 0400A0E1 		mov	r0, r4
 2405 1400 00C08DE5 		str	ip, [sp, #0]
 2406 1404 00C0A0E3 		mov	ip, #0
 2407 1408 04C08DE5 		str	ip, [sp, #4]
 2408 140c FEFFFFEB 		bl	cmdSet
 2409              	.LVL187:
 812:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2410              		.loc 1 812 0
 2411 1410 1CE09DE5 		ldr	lr, [sp, #28]
 2412 1414 0B20A0E1 		mov	r2, fp
 2413 1418 0A30A0E1 		mov	r3, sl
 2414 141c 0170A0E3 		mov	r7, #1
 2415              	.LVL188:
 2416 1420 0B10A0E3 		mov	r1, #11
 2417 1424 0400A0E1 		mov	r0, r4
 2418 1428 00E08DE5 		str	lr, [sp, #0]
 2419 142c 04708DE5 		str	r7, [sp, #4]
 2420 1430 FEFFFFEB 		bl	cmdSet
 813:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2421              		.loc 1 813 0
 2422 1434 1C0094E5 		ldr	r0, [r4, #28]
 2423 1438 FEFFFFEB 		bl	_txe_mutex_put
 816:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2424              		.loc 1 816 0
 2425 143c 1C209DE5 		ldr	r2, [sp, #28]
 815:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2426              		.loc 1 815 0
 2427 1440 18309DE5 		ldr	r3, [sp, #24]
 818:../uvc.c      **** 							 break;
 2428              		.loc 1 818 0
 2429 1444 FFE0A0E3 		mov	lr, #255
 815:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2430              		.loc 1 815 0
 2431 1448 8C34C6E5 		strb	r3, [r6, #1164]
 816:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2432              		.loc 1 816 0
 2433 144c 8E24C6E5 		strb	r2, [r6, #1166]
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2434              		.loc 1 817 0
 2435 1450 9872C6E5 		strb	r7, [r6, #664]
 2436 1454 02C0A0E1 		mov	ip, r2
 818:../uvc.c      **** 							 break;
 2437              		.loc 1 818 0
 2438 1458 0E40A0E1 		mov	r4, lr
 2439 145c A5FDFFEA 		b	.L114
 2440              	.LVL189:
 2441              	.L152:
 795:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2442              		.loc 1 795 0
 2443 1460 34449FE5 		ldr	r4, .L201+36
 2444 1464 0010E0E3 		mvn	r1, #0
 2445 1468 1C0094E5 		ldr	r0, [r4, #28]
 2446 146c FEFFFFEB 		bl	_txe_mutex_get
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2447              		.loc 1 796 0
 2448 1470 18C09DE5 		ldr	ip, [sp, #24]
 2449 1474 0610A0E3 		mov	r1, #6
 2450 1478 0920A0E1 		mov	r2, r9
 2451 147c 0A30A0E1 		mov	r3, sl
 2452 1480 0400A0E1 		mov	r0, r4
 2453 1484 00C08DE5 		str	ip, [sp, #0]
 2454 1488 00C0A0E3 		mov	ip, #0
 2455 148c 04C08DE5 		str	ip, [sp, #4]
 2456 1490 FEFFFFEB 		bl	cmdSet
 2457              	.LVL190:
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2458              		.loc 1 798 0
 2459 1494 18E09DE5 		ldr	lr, [sp, #24]
 2460 1498 0A30A0E1 		mov	r3, sl
 2461 149c 0170A0E3 		mov	r7, #1
 2462              	.LVL191:
 2463 14a0 0610A0E3 		mov	r1, #6
 2464 14a4 0B20A0E1 		mov	r2, fp
 2465 14a8 0400A0E1 		mov	r0, r4
 2466 14ac 00E08DE5 		str	lr, [sp, #0]
 2467 14b0 04708DE5 		str	r7, [sp, #4]
 2468 14b4 FEFFFFEB 		bl	cmdSet
 799:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2469              		.loc 1 799 0
 2470 14b8 1C0094E5 		ldr	r0, [r4, #28]
 2471 14bc FEFFFFEB 		bl	_txe_mutex_put
 800:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2472              		.loc 1 800 0
 2473 14c0 18409DE5 		ldr	r4, [sp, #24]
 802:../uvc.c      **** 							 break;
 2474              		.loc 1 802 0
 2475 14c4 FFE0A0E3 		mov	lr, #255
 800:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2476              		.loc 1 800 0
 2477 14c8 1D42C6E5 		strb	r4, [r6, #541]
 801:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2478              		.loc 1 801 0
 2479 14cc 0430A0E1 		mov	r3, r4
 2480 14d0 2072C6E5 		strb	r7, [r6, #544]
 2481 14d4 1CC09DE5 		ldr	ip, [sp, #28]
 802:../uvc.c      **** 							 break;
 2482              		.loc 1 802 0
 2483 14d8 0E40A0E1 		mov	r4, lr
 2484 14dc 85FDFFEA 		b	.L114
 2485              	.LVL192:
 2486              	.L151:
 775:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2487              		.loc 1 775 0
 2488 14e0 B4439FE5 		ldr	r4, .L201+36
 2489 14e4 0010E0E3 		mvn	r1, #0
 2490 14e8 1C0094E5 		ldr	r0, [r4, #28]
 2491 14ec FEFFFFEB 		bl	_txe_mutex_get
 2492              	.LVL193:
 776:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2493              		.loc 1 776 0
 2494 14f0 18109DE5 		ldr	r1, [sp, #24]
 2495 14f4 00E0A0E3 		mov	lr, #0
 2496 14f8 802041E2 		sub	r2, r1, #128
 2497 14fc FFC002E2 		and	ip, r2, #255
 2498 1500 0510A0E3 		mov	r1, #5
 2499 1504 0920A0E1 		mov	r2, r9
 2500 1508 0A30A0E1 		mov	r3, sl
 2501 150c 0400A0E1 		mov	r0, r4
 2502 1510 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2503 1514 FEFFFFEB 		bl	cmdSet
 2504              	.LVL194:
 778:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2505              		.loc 1 778 0
 2506 1518 18009DE5 		ldr	r0, [sp, #24]
 2507 151c 0510A0E3 		mov	r1, #5
 2508 1520 767040E2 		sub	r7, r0, #118
 2509              	.LVL195:
 2510 1524 FFC007E2 		and	ip, r7, #255
 2511 1528 DC20A0E3 		mov	r2, #220
 2512 152c 0170A0E3 		mov	r7, #1
 2513 1530 0A30A0E1 		mov	r3, sl
 2514 1534 0400A0E1 		mov	r0, r4
 2515 1538 00C08DE5 		str	ip, [sp, #0]
 2516 153c 04708DE5 		str	r7, [sp, #4]
 2517 1540 FEFFFFEB 		bl	cmdSet
 2518              	.LVL196:
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2519              		.loc 1 780 0
 2520 1544 18309DE5 		ldr	r3, [sp, #24]
 2521 1548 DE20A0E3 		mov	r2, #222
 2522 154c 7E1083E2 		add	r1, r3, #126
 2523 1550 FFC001E2 		and	ip, r1, #255
 2524 1554 0A30A0E1 		mov	r3, sl
 2525 1558 0510A0E3 		mov	r1, #5
 2526 155c 0400A0E1 		mov	r0, r4
 2527 1560 00C08DE5 		str	ip, [sp, #0]
 2528 1564 02C0A0E3 		mov	ip, #2
 2529 1568 04C08DE5 		str	ip, [sp, #4]
 2530 156c FEFFFFEB 		bl	cmdSet
 2531              	.LVL197:
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2532              		.loc 1 782 0
 2533 1570 18209DE5 		ldr	r2, [sp, #24]
 2534 1574 0510A0E3 		mov	r1, #5
 2535 1578 720082E2 		add	r0, r2, #114
 2536 157c FFC000E2 		and	ip, r0, #255
 2537 1580 E020A0E3 		mov	r2, #224
 2538 1584 0A30A0E1 		mov	r3, sl
 2539 1588 0400A0E1 		mov	r0, r4
 2540 158c 00C08DE5 		str	ip, [sp, #0]
 2541 1590 03C0A0E3 		mov	ip, #3
 2542 1594 04C08DE5 		str	ip, [sp, #4]
 2543 1598 FEFFFFEB 		bl	cmdSet
 2544              	.LVL198:
 784:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2545              		.loc 1 784 0
 2546 159c 18309DE5 		ldr	r3, [sp, #24]
 2547 15a0 DD20A0E3 		mov	r2, #221
 2548 15a4 6F1043E2 		sub	r1, r3, #111
 2549 15a8 FFC001E2 		and	ip, r1, #255
 2550 15ac 0A30A0E1 		mov	r3, sl
 2551 15b0 0510A0E3 		mov	r1, #5
 2552 15b4 0400A0E1 		mov	r0, r4
 2553 15b8 00C08DE5 		str	ip, [sp, #0]
 2554 15bc 04C0A0E3 		mov	ip, #4
 2555 15c0 04C08DE5 		str	ip, [sp, #4]
 2556 15c4 FEFFFFEB 		bl	cmdSet
 2557              	.LVL199:
 786:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2558              		.loc 1 786 0
 2559 15c8 B4229FE5 		ldr	r2, .L201+12
 2560 15cc 05E0A0E3 		mov	lr, #5
 2561 15d0 5800D2E5 		ldrb	r0, [r2, #88]	@ zero_extendqisi2
 2562 15d4 0E10A0E1 		mov	r1, lr
 2563 15d8 7F3080E2 		add	r3, r0, #127
 2564 15dc FFC003E2 		and	ip, r3, #255
 2565 15e0 0B20A0E1 		mov	r2, fp
 2566 15e4 0A30A0E1 		mov	r3, sl
 2567 15e8 0400A0E1 		mov	r0, r4
 2568 15ec 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2569 15f0 FEFFFFEB 		bl	cmdSet
 787:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2570              		.loc 1 787 0
 2571 15f4 1C0094E5 		ldr	r0, [r4, #28]
 2572 15f8 FEFFFFEB 		bl	_txe_mutex_put
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2573              		.loc 1 789 0
 2574 15fc 80129FE5 		ldr	r1, .L201+12
 791:../uvc.c      **** 							 break;
 2575              		.loc 1 791 0
 2576 1600 FFE0A0E3 		mov	lr, #255
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2577              		.loc 1 789 0
 2578 1604 58C0D1E5 		ldrb	ip, [r1, #88]	@ zero_extendqisi2
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2579              		.loc 1 790 0
 2580 1608 0872C6E5 		strb	r7, [r6, #520]
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2581              		.loc 1 789 0
 2582 160c 80204CE2 		sub	r2, ip, #128
 2583 1610 0522C6E5 		strb	r2, [r6, #517]
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2584              		.loc 1 790 0
 2585 1614 18309DE5 		ldr	r3, [sp, #24]
 2586 1618 1CC09DE5 		ldr	ip, [sp, #28]
 791:../uvc.c      **** 							 break;
 2587              		.loc 1 791 0
 2588 161c 0E40A0E1 		mov	r4, lr
 2589 1620 34FDFFEA 		b	.L114
 2590              	.LVL200:
 2591              	.L150:
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2592              		.loc 1 827 0
 2593 1624 70429FE5 		ldr	r4, .L201+36
 821:../uvc.c      **** 							 Data0 = Data0 - 1;
 2594              		.loc 1 821 0
 2595 1628 017043E2 		sub	r7, r3, #1
 2596              	.LVL201:
 2597 162c FF7007E2 		and	r7, r7, #255
 2598              	.LVL202:
 825:../uvc.c      **** 								 Data0 = 1;
 2599              		.loc 1 825 0
 2600 1630 020057E3 		cmp	r7, #2
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2601              		.loc 1 827 0
 2602 1634 0010E0E3 		mvn	r1, #0
 2603 1638 1C0094E5 		ldr	r0, [r4, #28]
 825:../uvc.c      **** 								 Data0 = 1;
 2604              		.loc 1 825 0
 2605 163c 0170A083 		movhi	r7, #1
 2606              	.LVL203:
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2607              		.loc 1 827 0
 2608 1640 FEFFFFEB 		bl	_txe_mutex_get
 2609              	.LVL204:
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2610              		.loc 1 828 0
 2611 1644 00C0A0E3 		mov	ip, #0
 2612 1648 0A30A0E1 		mov	r3, sl
 2613 164c 0410A0E3 		mov	r1, #4
 2614 1650 0920A0E1 		mov	r2, r9
 2615 1654 0400A0E1 		mov	r0, r4
 2616 1658 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2617 165c FEFFFFEB 		bl	cmdSet
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2618              		.loc 1 829 0
 2619 1660 1C0094E5 		ldr	r0, [r4, #28]
 2620 1664 FEFFFFEB 		bl	_txe_mutex_put
 833:../uvc.c      **** 							 break;
 2621              		.loc 1 833 0
 2622 1668 FFE0A0E3 		mov	lr, #255
 832:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2623              		.loc 1 832 0
 2624 166c 0100A0E3 		mov	r0, #1
 831:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2625              		.loc 1 831 0
 2626 1670 ED71C6E5 		strb	r7, [r6, #493]
 832:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2627              		.loc 1 832 0
 2628 1674 F001C6E5 		strb	r0, [r6, #496]
 2629 1678 18309DE5 		ldr	r3, [sp, #24]
 2630 167c 1CC09DE5 		ldr	ip, [sp, #28]
 833:../uvc.c      **** 							 break;
 2631              		.loc 1 833 0
 2632 1680 0E40A0E1 		mov	r4, lr
 2633 1684 1BFDFFEA 		b	.L114
 2634              	.LVL205:
 2635              	.L149:
 751:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2636              		.loc 1 751 0
 2637 1688 0C729FE5 		ldr	r7, .L201+36
 2638              	.LVL206:
 2639 168c 0010E0E3 		mvn	r1, #0
 2640 1690 1C0097E5 		ldr	r0, [r7, #28]
 2641 1694 FEFFFFEB 		bl	_txe_mutex_get
 2642              	.LVL207:
 753:../uvc.c      **** 							  if(Data0&0x80){
 2643              		.loc 1 753 0
 2644 1698 18809DE5 		ldr	r8, [sp, #24]
 754:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2645              		.loc 1 754 0
 2646 169c A601D6E5 		ldrb	r0, [r6, #422]	@ zero_extendqisi2
 753:../uvc.c      **** 							  if(Data0&0x80){
 2647              		.loc 1 753 0
 2648 16a0 800018E3 		tst	r8, #128
 756:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2649              		.loc 1 756 0
 2650 16a4 2843A001 		moveq	r4, r8, lsr #6
 754:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2651              		.loc 1 754 0
 2652 16a8 884CA011 		movne	r4, r8, asl #25
 756:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2653              		.loc 1 756 0
 2654 16ac 02408403 		orreq	r4, r4, #2
 754:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2655              		.loc 1 754 0
 2656 16b0 0300C013 		bicne	r0, r0, #3
 756:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2657              		.loc 1 756 0
 2658 16b4 0300C003 		biceq	r0, r0, #3
 754:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2659              		.loc 1 754 0
 2660 16b8 A44F8011 		orrne	r4, r0, r4, lsr #31
 756:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2661              		.loc 1 756 0
 2662 16bc 00408401 		orreq	r4, r4, r0
 2663              	.LVL208:
 758:../uvc.c      **** 							 Data1 |= ~0x03;
 2664              		.loc 1 758 0
 2665 16c0 043FE0E1 		mvn	r3, r4, asl #30
 2666 16c4 231FE0E1 		mvn	r1, r3, lsr #30
 2667              	.LVL209:
 759:../uvc.c      **** 							 Data1 &= 0xC7;
 2668              		.loc 1 759 0
 2669 16c8 C7C001E2 		and	ip, r1, #199
 2670              	.LVL210:
 760:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2671              		.loc 1 760 0
 2672 16cc 00E0A0E3 		mov	lr, #0
 2673 16d0 0110A0E3 		mov	r1, #1
 2674 16d4 0B20A0E1 		mov	r2, fp
 2675 16d8 0A30A0E1 		mov	r3, sl
 2676 16dc B8019FE5 		ldr	r0, .L201+36
 764:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2677              		.loc 1 764 0
 2678 16e0 0140A0E1 		mov	r4, r1
 760:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2679              		.loc 1 760 0
 2680 16e4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2681 16e8 14C08DE5 		str	ip, [sp, #20]
 2682 16ec FEFFFFEB 		bl	cmdSet
 2683              	.LVL211:
 763:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2684              		.loc 1 763 0
 2685 16f0 18209DE5 		ldr	r2, [sp, #24]
 764:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2686              		.loc 1 764 0
 2687 16f4 0410A0E1 		mov	r1, r4
 763:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2688              		.loc 1 763 0
 2689 16f8 0281A0E1 		mov	r8, r2, asl #2
 764:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2690              		.loc 1 764 0
 2691 16fc 0A30A0E1 		mov	r3, sl
 763:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2692              		.loc 1 763 0
 2693 1700 FF8008E2 		and	r8, r8, #255
 2694              	.LVL212:
 764:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2695              		.loc 1 764 0
 2696 1704 0920A0E1 		mov	r2, r9
 2697 1708 8C019FE5 		ldr	r0, .L201+36
 2698 170c 04408DE5 		str	r4, [sp, #4]
 2699 1710 00808DE5 		str	r8, [sp, #0]
 2700 1714 FEFFFFEB 		bl	cmdSet
 765:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2701              		.loc 1 765 0
 2702 1718 1C0097E5 		ldr	r0, [r7, #28]
 2703 171c FEFFFFEB 		bl	_txe_mutex_put
 767:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2704              		.loc 1 767 0
 2705 1720 A581C6E5 		strb	r8, [r6, #421]
 768:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2706              		.loc 1 768 0
 2707 1724 14009DE5 		ldr	r0, [sp, #20]
 771:../uvc.c      **** 							 break;
 2708              		.loc 1 771 0
 2709 1728 FFE0A0E3 		mov	lr, #255
 769:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2710              		.loc 1 769 0
 2711 172c A841C6E5 		strb	r4, [r6, #424]
 768:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2712              		.loc 1 768 0
 2713 1730 A601C6E5 		strb	r0, [r6, #422]
 769:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2714              		.loc 1 769 0
 2715 1734 18309DE5 		ldr	r3, [sp, #24]
 2716 1738 1CC09DE5 		ldr	ip, [sp, #28]
 771:../uvc.c      **** 							 break;
 2717              		.loc 1 771 0
 2718 173c 0E40A0E1 		mov	r4, lr
 2719 1740 ECFCFFEA 		b	.L114
 2720              	.LVL213:
 2721              	.L148:
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2722              		.loc 1 848 0
 2723 1744 50419FE5 		ldr	r4, .L201+36
 836:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2724              		.loc 1 836 0
 2725 1748 0120A0E3 		mov	r2, #1
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2726              		.loc 1 848 0
 2727 174c 0010E0E3 		mvn	r1, #0
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2728              		.loc 1 835 0
 2729 1750 8D31C6E5 		strb	r3, [r6, #397]
 836:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2730              		.loc 1 836 0
 2731 1754 9021C6E5 		strb	r2, [r6, #400]
 2732              	.LVL214:
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2733              		.loc 1 848 0
 2734 1758 1C0094E5 		ldr	r0, [r4, #28]
 2735 175c FEFFFFEB 		bl	_txe_mutex_get
 2736              	.LVL215:
 849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2737              		.loc 1 849 0
 2738 1760 18E09DE5 		ldr	lr, [sp, #24]
 2739 1764 00C0A0E3 		mov	ip, #0
 2740 1768 0C10A0E1 		mov	r1, ip
 2741 176c 0920A0E1 		mov	r2, r9
 2742 1770 0A30A0E1 		mov	r3, sl
 2743 1774 0400A0E1 		mov	r0, r4
 2744 1778 00E08DE5 		str	lr, [sp, #0]
 2745 177c 09FFFFEA 		b	.L194
 2746              	.LVL216:
 2747              	.L147:
 856:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2748              		.loc 1 856 0
 2749 1780 14719FE5 		ldr	r7, .L201+36
 2750              	.LVL217:
 2751 1784 0010E0E3 		mvn	r1, #0
 2752 1788 1C0097E5 		ldr	r0, [r7, #28]
 2753 178c FEFFFFEB 		bl	_txe_mutex_get
 2754              	.LVL218:
 857:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2755              		.loc 1 857 0
 2756 1790 18C09DE5 		ldr	ip, [sp, #24]
 2757 1794 0410A0E1 		mov	r1, r4
 2758 1798 0A30A0E1 		mov	r3, sl
 2759 179c 0920A0E1 		mov	r2, r9
 2760 17a0 00C08DE5 		str	ip, [sp, #0]
 2761 17a4 0700A0E1 		mov	r0, r7
 2762 17a8 00C0A0E3 		mov	ip, #0
 2763 17ac 04C08DE5 		str	ip, [sp, #4]
 2764 17b0 FEFFFFEB 		bl	cmdSet
 858:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2765              		.loc 1 858 0
 2766 17b4 1C0097E5 		ldr	r0, [r7, #28]
 2767 17b8 FEFFFFEB 		bl	_txe_mutex_put
 860:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2768              		.loc 1 860 0
 2769 17bc 18109DE5 		ldr	r1, [sp, #24]
 2770 17c0 840084E0 		add	r0, r4, r4, asl #1
 2771 17c4 806186E0 		add	r6, r6, r0, asl #3
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2772              		.loc 1 861 0
 2773 17c8 0130A0E3 		mov	r3, #1
 862:../uvc.c      **** 							 break;
 2774              		.loc 1 862 0
 2775 17cc FFE0A0E3 		mov	lr, #255
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2776              		.loc 1 861 0
 2777 17d0 9031C6E5 		strb	r3, [r6, #400]
 860:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2778              		.loc 1 860 0
 2779 17d4 8D11C6E5 		strb	r1, [r6, #397]
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2780              		.loc 1 861 0
 2781 17d8 0130A0E1 		mov	r3, r1
 2782 17dc 1CC09DE5 		ldr	ip, [sp, #28]
 862:../uvc.c      **** 							 break;
 2783              		.loc 1 862 0
 2784 17e0 0E40A0E1 		mov	r4, lr
 2785 17e4 C3FCFFEA 		b	.L114
 2786              	.LVL219:
 2787              	.L146:
 865:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2788              		.loc 1 865 0
 2789 17e8 0400A0E3 		mov	r0, #4
 2790              	.LVL220:
 2791 17ec B4109FE5 		ldr	r1, .L201+48
 2792 17f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2793              	.LVL221:
 2794 17f4 FFE0A0E3 		mov	lr, #255
 2795 17f8 0E40A0E1 		mov	r4, lr
 2796 17fc 0EC0A0E1 		mov	ip, lr
 2797 1800 0E30A0E1 		mov	r3, lr
 2798 1804 BBFCFFEA 		b	.L114
 2799              	.LVL222:
 2800              	.L165:
 624:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2801              		.loc 1 624 0
 2802 1808 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 623:../uvc.c      **** 								 Data1 = Data0 - 1;
 2803              		.loc 1 623 0
 2804 180c 014041E2 		sub	r4, r1, #1
 624:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2805              		.loc 1 624 0
 2806 1810 040052E3 		cmp	r2, #4
 2807 1814 01005213 		cmpne	r2, #1
 623:../uvc.c      **** 								 Data1 = Data0 - 1;
 2808              		.loc 1 623 0
 2809 1818 FF1004E2 		and	r1, r4, #255
 2810              	.LVL223:
 624:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2811              		.loc 1 624 0
 2812 181c 0300000A 		beq	.L168
 625:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2813              		.loc 1 625 0
 2814 1820 080052E3 		cmp	r2, #8
 626:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2815              		.loc 1 626 0
 2816 1824 0120A003 		moveq	r2, #1
 628:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2817              		.loc 1 628 0
 2818 1828 0420A013 		movne	r2, #4
 2819 182c B524C3E5 		strb	r2, [r3, #1205]
 2820              	.L168:
 631:../uvc.c      **** 								 if(Data1 < 8){
 2821              		.loc 1 631 0
 2822 1830 070051E3 		cmp	r1, #7
 632:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2823              		.loc 1 632 0
 2824 1834 70309F95 		ldrls	r3, .L201+52
 635:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2825              		.loc 1 635 0
 2826 1838 0130A083 		movhi	r3, #1
 633:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2827              		.loc 1 633 0
 2828 183c 81008390 		addls	r0, r3, r1, asl #1
 632:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2829              		.loc 1 632 0
 2830 1840 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 633:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2831              		.loc 1 633 0
 2832 1844 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 635:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2833              		.loc 1 635 0
 2834 1848 E534C685 		strhib	r3, [r6, #1253]
 636:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2835              		.loc 1 636 0
 2836 184c 0030A083 		movhi	r3, #0
 632:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2837              		.loc 1 632 0
 2838 1850 E524C695 		strlsb	r2, [r6, #1253]
 636:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2839              		.loc 1 636 0
 2840 1854 E634C6E5 		strb	r3, [r6, #1254]
 2841 1858 C5FEFFEA 		b	.L166
 2842              	.LVL224:
 2843              	.L191:
 2844 185c 20009FE5 		ldr	r0, .L201+12
 2845 1860 BEFDFFEA 		b	.L125
 2846              	.LVL225:
 2847              	.L180:
 383:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2848              		.loc 1 383 0
 2849 1864 0030A0E3 		mov	r3, #0
 2850 1868 61FEFFEA 		b	.L184
 2851              	.LVL226:
 2852              	.L179:
 2853 186c 10009FE5 		ldr	r0, .L201+12
 2854 1870 0030A0E3 		mov	r3, #0
 2855 1874 B2FDFFEA 		b	.L183
 2856              	.L202:
 2857              		.align	2
 2858              	.L201:
 2859 1878 00000000 		.word	.LANCHOR1
 2860 187c 00000000 		.word	bRequest
 2861 1880 08030000 		.word	.LC19
 2862 1884 00000000 		.word	.LANCHOR0
 2863 1888 58000000 		.word	.LANCHOR0+88
 2864 188c 01000100 		.word	65537
 2865 1890 FF00FF00 		.word	16711935
 2866 1894 48020000 		.word	.LC15
 2867 1898 84020000 		.word	.LC16
 2868 189c 00000000 		.word	cmdQu
 2869 18a0 4C000000 		.word	.LANCHOR0+76
 2870 18a4 AC020000 		.word	.LC17
 2871 18a8 D8020000 		.word	.LC18
 2872 18ac 00000000 		.word	.LANCHOR2
 2873              		.cfi_endproc
 2874              	.LFE2:
 2876              		.align	2
 2877              		.global	CTControlHandle
 2879              	CTControlHandle:
 2880              	.LFB3:
 881:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 2881              		.loc 1 881 0
 2882              		.cfi_startproc
 2883              		@ args = 0, pretend = 0, frame = 64
 2884              		@ frame_needed = 0, uses_anonymous_args = 0
 2885              	.LVL227:
 2886 18b0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2887              	.LCFI15:
 2888              		.cfi_def_cfa_offset 36
 900:../uvc.c      ****     reqData = bRequest;
 2889              		.loc 1 900 0
 2890 18b4 60A99FE5 		ldr	sl, .L288
 2891              		.cfi_offset 14, -4
 2892              		.cfi_offset 11, -8
 2893              		.cfi_offset 10, -12
 2894              		.cfi_offset 9, -16
 2895              		.cfi_offset 8, -20
 2896              		.cfi_offset 7, -24
 2897              		.cfi_offset 6, -28
 2898              		.cfi_offset 5, -32
 2899              		.cfi_offset 4, -36
 892:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 2900              		.loc 1 892 0
 2901 18b8 60899FE5 		ldr	r8, .L288+4
 900:../uvc.c      ****     reqData = bRequest;
 2902              		.loc 1 900 0
 2903 18bc 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 892:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 2904              		.loc 1 892 0
 2905 18c0 8090A0E1 		mov	r9, r0, asl #1
 2906 18c4 002089E0 		add	r2, r9, r0
 2907 18c8 822188E0 		add	r2, r8, r2, asl #3
 902:../uvc.c      ****     switch (bRequest)
 2908              		.loc 1 902 0
 2909 18cc 830055E3 		cmp	r5, #131
 881:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 2910              		.loc 1 881 0
 2911 18d0 5CD04DE2 		sub	sp, sp, #92
 2912              	.LCFI16:
 2913              		.cfi_def_cfa_offset 128
 881:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 2914              		.loc 1 881 0
 2915 18d4 0060A0E1 		mov	r6, r0
 892:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 2916              		.loc 1 892 0
 2917 18d8 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 2918              	.LVL228:
 893:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 2919              		.loc 1 893 0
 2920 18dc 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 2921              	.LVL229:
 895:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 2922              		.loc 1 895 0
 2923 18e0 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 2924              	.LVL230:
 902:../uvc.c      ****     switch (bRequest)
 2925              		.loc 1 902 0
 2926 18e4 7600000A 		beq	.L208
 2927 18e8 2100009A 		bls	.L283
 2928 18ec 850055E3 		cmp	r5, #133
 2929 18f0 5900000A 		beq	.L210
 2930 18f4 4E00003A 		bcc	.L209
 2931 18f8 860055E3 		cmp	r5, #134
 2932 18fc 8000000A 		beq	.L211
 2933 1900 870055E3 		cmp	r5, #135
 2934 1904 7600000A 		beq	.L284
 2935              	.L204:
1109:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 2936              		.loc 1 1109 0
 2937 1908 0000A0E3 		mov	r0, #0
 2938              	.LVL231:
 2939 190c 0110A0E3 		mov	r1, #1
 2940 1910 0020A0E1 		mov	r2, r0
 2941 1914 FEFFFFEB 		bl	CyU3PUsbStall
 2942              	.LVL232:
 2943 1918 04499FE5 		ldr	r4, .L288+8
1110:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 2944              		.loc 1 1110 0
 2945 191c 0620A0E1 		mov	r2, r6
 2946 1920 0400A0E3 		mov	r0, #4
 2947 1924 FC189FE5 		ldr	r1, .L288+12
 2948 1928 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 2949 192c FEFFFFEB 		bl	CyU3PDebugPrint
1111:../uvc.c      **** 			  break;
 2950              		.loc 1 1111 0
 2951 1930 FFC0A0E3 		mov	ip, #255
 2952 1934 0C60A0E1 		mov	r6, ip
 2953 1938 0C80A0E1 		mov	r8, ip
 2954              	.LVL233:
 2955              	.L214:
1115:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 2956              		.loc 1 1115 0
 2957 193c 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 2958 1940 08C08DE5 		str	ip, [sp, #8]
 2959 1944 E0189FE5 		ldr	r1, .L288+16
 2960 1948 FFC0A0E3 		mov	ip, #255
 2961 194c 0520A0E1 		mov	r2, r5
 2962 1950 0830A0E1 		mov	r3, r8
 2963 1954 0400A0E3 		mov	r0, #4
 2964 1958 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2965 195c 0CC08DE5 		str	ip, [sp, #12]
 2966 1960 10E08DE5 		str	lr, [sp, #16]
 2967 1964 14708DE5 		str	r7, [sp, #20]
 2968 1968 FEFFFFEB 		bl	CyU3PDebugPrint
1116:../uvc.c      **** }
 2969              		.loc 1 1116 0
 2970 196c 5CD08DE2 		add	sp, sp, #92
 2971 1970 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 2972              	.LVL234:
 2973              	.L283:
 902:../uvc.c      ****     switch (bRequest)
 2974              		.loc 1 902 0
 2975 1974 810055E3 		cmp	r5, #129
 2976 1978 4200000A 		beq	.L206
 2977 197c 1100009A 		bls	.L285
 931:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 2978              		.loc 1 931 0
 2979 1980 9C489FE5 		ldr	r4, .L288+8
 2980 1984 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 932:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 2981              		.loc 1 932 0
 2982 1988 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 933:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 2983              		.loc 1 933 0
 2984 198c 0A0050E3 		cmp	r0, #10
 931:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 2985              		.loc 1 931 0
 2986 1990 5810C4E5 		strb	r1, [r4, #88]
 932:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 2987              		.loc 1 932 0
 2988 1994 5960C4E5 		strb	r6, [r4, #89]
 933:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 2989              		.loc 1 933 0
 2990 1998 2C00000A 		beq	.L282
 2991              	.LVL235:
 2992              	.L221:
 967:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 2993              		.loc 1 967 0
 2994 199c 00E0A0E3 		mov	lr, #0
 2995 19a0 5AE0C4E5 		strb	lr, [r4, #90]
 2996              	.L222:
 968:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2997              		.loc 1 968 0
 2998 19a4 0030A0E3 		mov	r3, #0
 969:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2999              		.loc 1 969 0
 3000 19a8 0700A0E1 		mov	r0, r7
 3001              	.LVL236:
 3002 19ac 7C189FE5 		ldr	r1, .L288+20
 971:../uvc.c      **** 			  break;
 3003              		.loc 1 971 0
 3004 19b0 FF60A0E3 		mov	r6, #255
 968:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3005              		.loc 1 968 0
 3006 19b4 5B30C4E5 		strb	r3, [r4, #91]
 971:../uvc.c      **** 			  break;
 3007              		.loc 1 971 0
 3008 19b8 0680A0E1 		mov	r8, r6
 969:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3009              		.loc 1 969 0
 3010 19bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3011              	.LVL237:
 3012 19c0 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 971:../uvc.c      **** 			  break;
 3013              		.loc 1 971 0
 3014 19c4 DCFFFFEA 		b	.L214
 3015              	.LVL238:
 3016              	.L285:
 902:../uvc.c      ****     switch (bRequest)
 3017              		.loc 1 902 0
 3018 19c8 010055E3 		cmp	r5, #1
 3019 19cc CDFFFF1A 		bne	.L204
 973:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3020              		.loc 1 973 0
 3021 19d0 4C489FE5 		ldr	r4, .L288+8
 3022 19d4 56208DE2 		add	r2, sp, #86
 3023 19d8 2000A0E3 		mov	r0, #32
 3024              	.LVL239:
 3025 19dc 581084E2 		add	r1, r4, #88
 3026 19e0 2C308DE5 		str	r3, [sp, #44]
 3027 19e4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3028              	.LVL240:
 975:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3029              		.loc 1 975 0
 3030 19e8 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 976:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3031              		.loc 1 976 0
 3032 19ec 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
 979:../uvc.c      **** 			  switch(CtrlID)
 3033              		.loc 1 979 0
 3034 19f0 012046E2 		sub	r2, r6, #1
 975:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3035              		.loc 1 975 0
 3036 19f4 30008DE5 		str	r0, [sp, #48]
 3037              	.LVL241:
 976:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3038              		.loc 1 976 0
 3039 19f8 34C08DE5 		str	ip, [sp, #52]
 3040              	.LVL242:
 979:../uvc.c      **** 			  switch(CtrlID)
 3041              		.loc 1 979 0
 3042 19fc 2C309DE5 		ldr	r3, [sp, #44]
 3043 1a00 090052E3 		cmp	r2, #9
 3044 1a04 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3045 1a08 550100EA 		b	.L223
 3046              	.L228:
 3047 1a0c 201F0000 		.word	.L224
 3048 1a10 641F0000 		.word	.L223
 3049 1a14 301C0000 		.word	.L225
 3050 1a18 641F0000 		.word	.L223
 3051 1a1c 641F0000 		.word	.L223
 3052 1a20 641F0000 		.word	.L223
 3053 1a24 AC1B0000 		.word	.L226
 3054 1a28 641F0000 		.word	.L223
 3055 1a2c 641F0000 		.word	.L223
 3056 1a30 301B0000 		.word	.L227
 3057              	.LVL243:
 3058              	.L209:
 949:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3059              		.loc 1 949 0
 3060 1a34 E8479FE5 		ldr	r4, .L288+8
 3061 1a38 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 950:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3062              		.loc 1 950 0
 3063 1a3c 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 951:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3064              		.loc 1 951 0
 3065 1a40 0A0050E3 		cmp	r0, #10
 949:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3066              		.loc 1 949 0
 3067 1a44 5880C4E5 		strb	r8, [r4, #88]
 950:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3068              		.loc 1 950 0
 3069 1a48 5920C4E5 		strb	r2, [r4, #89]
 951:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3070              		.loc 1 951 0
 3071 1a4c D2FFFF1A 		bne	.L221
 3072              	.LVL244:
 3073              	.L282:
 966:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3074              		.loc 1 966 0 discriminator 1
 3075 1a50 0110A0E3 		mov	r1, #1
 3076 1a54 5A10C4E5 		strb	r1, [r4, #90]
 3077 1a58 D1FFFFEA 		b	.L222
 3078              	.LVL245:
 3079              	.L210:
 906:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3080              		.loc 1 906 0
 3081 1a5c C0479FE5 		ldr	r4, .L288+8
 907:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3082              		.loc 1 907 0
 3083 1a60 0030A0E3 		mov	r3, #0
 3084              	.LVL246:
 908:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3085              		.loc 1 908 0
 3086 1a64 0200A0E3 		mov	r0, #2
 3087              	.LVL247:
 3088 1a68 581084E2 		add	r1, r4, #88
 910:../uvc.c      **** 			  break;
 3089              		.loc 1 910 0
 3090 1a6c FF60A0E3 		mov	r6, #255
 906:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3091              		.loc 1 906 0
 3092 1a70 5870C4E5 		strb	r7, [r4, #88]
 907:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3093              		.loc 1 907 0
 3094 1a74 5930C4E5 		strb	r3, [r4, #89]
 910:../uvc.c      **** 			  break;
 3095              		.loc 1 910 0
 3096 1a78 0680A0E1 		mov	r8, r6
 908:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3097              		.loc 1 908 0
 3098 1a7c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3099              	.LVL248:
 3100 1a80 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 910:../uvc.c      **** 			  break;
 3101              		.loc 1 910 0
 3102 1a84 ACFFFFEA 		b	.L214
 3103              	.LVL249:
 3104              	.L206:
 916:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3105              		.loc 1 916 0
 3106 1a88 94479FE5 		ldr	r4, .L288+8
 3107 1a8c 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 917:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3108              		.loc 1 917 0
 3109 1a90 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 918:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3110              		.loc 1 918 0
 3111 1a94 0080A0E3 		mov	r8, #0
 924:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3112              		.loc 1 924 0
 3113 1a98 0700A0E1 		mov	r0, r7
 3114              	.LVL250:
 3115 1a9c 581084E2 		add	r1, r4, #88
 929:../uvc.c      **** 			  break;
 3116              		.loc 1 929 0
 3117 1aa0 FF60A0E3 		mov	r6, #255
 917:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3118              		.loc 1 917 0
 3119 1aa4 59C0C4E5 		strb	ip, [r4, #89]
 918:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3120              		.loc 1 918 0
 3121 1aa8 5A80C4E5 		strb	r8, [r4, #90]
 919:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3122              		.loc 1 919 0
 3123 1aac 5B80C4E5 		strb	r8, [r4, #91]
 3124              	.LVL251:
 916:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3125              		.loc 1 916 0
 3126 1ab0 58A0C4E5 		strb	sl, [r4, #88]
 929:../uvc.c      **** 			  break;
 3127              		.loc 1 929 0
 3128 1ab4 0680A0E1 		mov	r8, r6
 924:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3129              		.loc 1 924 0
 3130 1ab8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3131              	.LVL252:
 3132 1abc 0AC0A0E1 		mov	ip, sl
 929:../uvc.c      **** 			  break;
 3133              		.loc 1 929 0
 3134 1ac0 9DFFFFEA 		b	.L214
 3135              	.LVL253:
 3136              	.L208:
 940:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3137              		.loc 1 940 0
 3138 1ac4 58479FE5 		ldr	r4, .L288+8
 3139 1ac8 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3140              	.LVL254:
 941:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3141              		.loc 1 941 0
 3142 1acc 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 942:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3143              		.loc 1 942 0
 3144 1ad0 0A0050E3 		cmp	r0, #10
 940:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3145              		.loc 1 940 0
 3146 1ad4 5830C4E5 		strb	r3, [r4, #88]
 941:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3147              		.loc 1 941 0
 3148 1ad8 59E0C4E5 		strb	lr, [r4, #89]
 942:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3149              		.loc 1 942 0
 3150 1adc AEFFFF1A 		bne	.L221
 3151 1ae0 DAFFFFEA 		b	.L282
 3152              	.LVL255:
 3153              	.L284:
 964:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3154              		.loc 1 964 0
 3155 1ae4 38479FE5 		ldr	r4, .L288+8
 3156 1ae8 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 965:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3157              		.loc 1 965 0
 3158 1aec 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 966:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3159              		.loc 1 966 0
 3160 1af0 0A0050E3 		cmp	r0, #10
 964:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3161              		.loc 1 964 0
 3162 1af4 5860C4E5 		strb	r6, [r4, #88]
 965:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3163              		.loc 1 965 0
 3164 1af8 59C0C4E5 		strb	ip, [r4, #89]
 966:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3165              		.loc 1 966 0
 3166 1afc A6FFFF1A 		bne	.L221
 3167 1b00 D2FFFFEA 		b	.L282
 3168              	.L211:
 958:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3169              		.loc 1 958 0
 3170 1b04 18479FE5 		ldr	r4, .L288+8
 3171 1b08 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3172              	.LVL256:
 3173 1b0c 0410A0E1 		mov	r1, r4
 3174 1b10 5800E1E5 		strb	r0, [r1, #88]!
 962:../uvc.c      **** 			  break;
 3175              		.loc 1 962 0
 3176 1b14 FF60A0E3 		mov	r6, #255
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3177              		.loc 1 959 0
 3178 1b18 0100A0E3 		mov	r0, #1
 3179 1b1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3180              	.LVL257:
 962:../uvc.c      **** 			  break;
 3181              		.loc 1 962 0
 3182 1b20 0680A0E1 		mov	r8, r6
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3183              		.loc 1 959 0
 3184 1b24 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 962:../uvc.c      **** 			  break;
 3185              		.loc 1 962 0
 3186 1b28 0170A0E3 		mov	r7, #1
 3187 1b2c 82FFFFEA 		b	.L214
 3188              	.LVL258:
 3189              	.L227:
1088:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3190              		.loc 1 1088 0
 3191 1b30 FC669FE5 		ldr	r6, .L288+24
 3192 1b34 0010E0E3 		mvn	r1, #0
 3193 1b38 1C0096E5 		ldr	r0, [r6, #28]
 3194 1b3c 2C308DE5 		str	r3, [sp, #44]
 3195 1b40 FEFFFFEB 		bl	_txe_mutex_get
1089:../uvc.c      **** 					  if(getData == 1)
 3196              		.loc 1 1089 0
 3197 1b44 30E09DE5 		ldr	lr, [sp, #48]
 3198 1b48 2C309DE5 		ldr	r3, [sp, #44]
 3199 1b4c 01005EE3 		cmp	lr, #1
 3200 1b50 A901000A 		beq	.L286
1091:../uvc.c      **** 					  else if(getData == 0xff)
 3201              		.loc 1 1091 0
 3202 1b54 FF005EE3 		cmp	lr, #255
 3203 1b58 9E01000A 		beq	.L287
1094:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3204              		.loc 1 1094 0
 3205 1b5c 0080A0E3 		mov	r8, #0
 3206 1b60 0600A0E1 		mov	r0, r6
 3207 1b64 1710A0E3 		mov	r1, #23
 3208 1b68 0B20A0E1 		mov	r2, fp
 3209 1b6c 00808DE5 		str	r8, [sp, #0]
 3210 1b70 04808DE5 		str	r8, [sp, #4]
 3211 1b74 FEFFFFEB 		bl	cmdSet
 3212              	.L280:
1097:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3213              		.loc 1 1097 0
 3214 1b78 1C0096E5 		ldr	r0, [r6, #28]
 3215 1b7c FEFFFFEB 		bl	_txe_mutex_put
1099:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3216              		.loc 1 1099 0
 3217 1b80 30809DE5 		ldr	r8, [sp, #48]
 3218 1b84 34609DE5 		ldr	r6, [sp, #52]
 3219 1b88 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3220 1b8c 0400A0E3 		mov	r0, #4
 3221 1b90 A0169FE5 		ldr	r1, .L288+28
 3222 1b94 0820A0E1 		mov	r2, r8
 3223 1b98 0630A0E1 		mov	r3, r6
 3224 1b9c 00C08DE5 		str	ip, [sp, #0]
 3225 1ba0 FEFFFFEB 		bl	CyU3PDebugPrint
1100:../uvc.c      **** 					  break;
 3226              		.loc 1 1100 0
 3227 1ba4 FFC0A0E3 		mov	ip, #255
 3228 1ba8 63FFFFEA 		b	.L214
 3229              	.LVL259:
 3230              	.L226:
1065:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3231              		.loc 1 1065 0
 3232 1bac B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3233 1bb0 010058E3 		cmp	r8, #1
 3234 1bb4 08005813 		cmpne	r8, #8
 3235 1bb8 0000A013 		movne	r0, #0
 3236 1bbc 0100A003 		moveq	r0, #1
 3237 1bc0 8001001A 		bne	.L277
 3238              	.LVL260:
1068:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3239              		.loc 1 1068 0
 3240 1bc4 68869FE5 		ldr	r8, .L288+24
 3241 1bc8 0010E0E3 		mvn	r1, #0
 3242 1bcc 1C0098E5 		ldr	r0, [r8, #28]
 3243 1bd0 2C308DE5 		str	r3, [sp, #44]
 3244 1bd4 FEFFFFEB 		bl	_txe_mutex_get
1069:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3245              		.loc 1 1069 0
 3246 1bd8 30A09DE5 		ldr	sl, [sp, #48]
 3247 1bdc 1610A0E3 		mov	r1, #22
 3248 1be0 0B20A0E1 		mov	r2, fp
 3249 1be4 2C309DE5 		ldr	r3, [sp, #44]
 3250 1be8 00C0A0E3 		mov	ip, #0
 3251 1bec 0800A0E1 		mov	r0, r8
 3252 1bf0 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3253 1bf4 FEFFFFEB 		bl	cmdSet
1070:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3254              		.loc 1 1070 0
 3255 1bf8 1C0098E5 		ldr	r0, [r8, #28]
 3256 1bfc FEFFFFEB 		bl	_txe_mutex_put
1073:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3257              		.loc 1 1073 0
 3258 1c00 18069FE5 		ldr	r0, .L288+4
1074:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3259              		.loc 1 1074 0
 3260 1c04 34209DE5 		ldr	r2, [sp, #52]
1073:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3261              		.loc 1 1073 0
 3262 1c08 061089E0 		add	r1, r9, r6
 3263 1c0c 813180E0 		add	r3, r0, r1, asl #3
1075:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3264              		.loc 1 1075 0
 3265 1c10 0160A0E3 		mov	r6, #1
1073:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3266              		.loc 1 1073 0
 3267 1c14 9DA4C3E5 		strb	sl, [r3, #1181]
1074:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3268              		.loc 1 1074 0
 3269 1c18 9E24C3E5 		strb	r2, [r3, #1182]
1075:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3270              		.loc 1 1075 0
 3271 1c1c A064C3E5 		strb	r6, [r3, #1184]
 3272              	.LVL261:
 3273              	.L278:
1077:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3274              		.loc 1 1077 0
 3275 1c20 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3276 1c24 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1082:../uvc.c      **** 					  break;
 3277              		.loc 1 1082 0
 3278 1c28 FFC0A0E3 		mov	ip, #255
 3279 1c2c 42FFFFEA 		b	.L214
 3280              	.LVL262:
 3281              	.L225:
1031:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3282              		.loc 1 1031 0
 3283 1c30 B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3284 1c34 010050E3 		cmp	r0, #1
 3285 1c38 04005013 		cmpne	r0, #4
 3286 1c3c 5C01001A 		bne	.L235
1030:../uvc.c      **** 					  value = (value << 8)|Data0;
 3287              		.loc 1 1030 0
 3288 1c40 30109DE5 		ldr	r1, [sp, #48]
 3289 1c44 34E09DE5 		ldr	lr, [sp, #52]
 3290 1c48 0E2481E1 		orr	r2, r1, lr, asl #8
1032:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3291              		.loc 1 1032 0
 3292 1c4c F90052E3 		cmp	r2, #249
 3293 1c50 5701008A 		bhi	.L235
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3294              		.loc 1 1037 0
 3295 1c54 C8A042E2 		sub	sl, r2, #200
 3296 1c58 0AC8A0E1 		mov	ip, sl, asl #16
 3297 1c5c 3CC08DE5 		str	ip, [sp, #60]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3298              		.loc 1 1039 0
 3299 1c60 27A062E2 		rsb	sl, r2, #39
 3300 1c64 38A08DE5 		str	sl, [sp, #56]
 3301 1c68 3CA09DE5 		ldr	sl, [sp, #60]
 3302 1c6c C81062E2 		rsb	r1, r2, #200
 3303 1c70 C80052E3 		cmp	r2, #200
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3304              		.loc 1 1037 0
 3305 1c74 640042E2 		sub	r0, r2, #100
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3306              		.loc 1 1039 0
 3307 1c78 0118A0E1 		mov	r1, r1, asl #16
 3308 1c7c 64E062E2 		rsb	lr, r2, #100
 3309 1c80 2A18A081 		movhi	r1, sl, lsr #16
 3310 1c84 2118A091 		movls	r1, r1, lsr #16
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3311              		.loc 1 1037 0
 3312 1c88 00C8A0E1 		mov	ip, r0, asl #16
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3313              		.loc 1 1039 0
 3314 1c8c 640052E3 		cmp	r2, #100
 3315 1c90 0E08A0E1 		mov	r0, lr, asl #16
 3316 1c94 2C08A081 		movhi	r0, ip, lsr #16
 3317 1c98 38C09DE5 		ldr	ip, [sp, #56]
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3318              		.loc 1 1037 0
 3319 1c9c 14A042E2 		sub	sl, r2, #20
 3320 1ca0 38A08DE5 		str	sl, [sp, #56]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3321              		.loc 1 1039 0
 3322 1ca4 2008A091 		movls	r0, r0, lsr #16
 3323 1ca8 14A062E2 		rsb	sl, r2, #20
 3324 1cac 3CA08DE5 		str	sl, [sp, #60]
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3325              		.loc 1 1037 0
 3326 1cb0 27E042E2 		sub	lr, r2, #39
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3327              		.loc 1 1039 0
 3328 1cb4 000051E1 		cmp	r1, r0
 3329 1cb8 01A0A031 		movcc	sl, r1
 3330 1cbc 00A0A021 		movcs	sl, r0
 3331 1cc0 0CC8A0E1 		mov	ip, ip, asl #16
 3332 1cc4 270052E3 		cmp	r2, #39
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3333              		.loc 1 1037 0
 3334 1cc8 0EE8A0E1 		mov	lr, lr, asl #16
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3335              		.loc 1 1039 0
 3336 1ccc 2CE8A091 		movls	lr, ip, lsr #16
 3337 1cd0 64C59FE5 		ldr	ip, .L288+32
 3338 1cd4 20A08DE5 		str	sl, [sp, #32]
 3339 1cd8 01A06CE0 		rsb	sl, ip, r1
 3340 1cdc 2EE8A081 		movhi	lr, lr, lsr #16
 3341 1ce0 00C07AE2 		rsbs	ip, sl, #0
 3342 1ce4 0AC0ACE0 		adc	ip, ip, sl
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3343              		.loc 1 1037 0
 3344 1ce8 38A09DE5 		ldr	sl, [sp, #56]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3345              		.loc 1 1039 0
 3346 1cec 44C08DE5 		str	ip, [sp, #68]
 3347              	.LVL263:
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3348              		.loc 1 1037 0
 3349 1cf0 0AC8A0E1 		mov	ip, sl, asl #16
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3350              		.loc 1 1039 0
 3351 1cf4 3CA09DE5 		ldr	sl, [sp, #60]
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3352              		.loc 1 1037 0
 3353 1cf8 4CC08DE5 		str	ip, [sp, #76]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3354              		.loc 1 1039 0
 3355 1cfc 0AC8A0E1 		mov	ip, sl, asl #16
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3356              		.loc 1 1037 0
 3357 1d00 0AA042E2 		sub	sl, r2, #10
 3358 1d04 48A08DE5 		str	sl, [sp, #72]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3359              		.loc 1 1039 0
 3360 1d08 20A09DE5 		ldr	sl, [sp, #32]
 3361 1d0c 3CC08DE5 		str	ip, [sp, #60]
 3362 1d10 0A005EE1 		cmp	lr, sl
 3363 1d14 0EA0A031 		movcc	sl, lr
 3364 1d18 0AC062E2 		rsb	ip, r2, #10
 3365 1d1c 40C08DE5 		str	ip, [sp, #64]
 3366 1d20 38A08DE5 		str	sl, [sp, #56]
 3367 1d24 3CC09DE5 		ldr	ip, [sp, #60]
 3368 1d28 4CA09DE5 		ldr	sl, [sp, #76]
 3369 1d2c 140052E3 		cmp	r2, #20
 3370 1d30 2CA8A091 		movls	sl, ip, lsr #16
 3371 1d34 2AA8A081 		movhi	sl, sl, lsr #16
 3372 1d38 44C09DE5 		ldr	ip, [sp, #68]
 3373 1d3c 010050E1 		cmp	r0, r1
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3374              		.loc 1 1037 0
 3375 1d40 48109DE5 		ldr	r1, [sp, #72]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3376              		.loc 1 1039 0
 3377 1d44 01C0A033 		movcc	ip, #1
 3378 1d48 3CA08DE5 		str	sl, [sp, #60]
 3379 1d4c 24C08DE5 		str	ip, [sp, #36]
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3380              		.loc 1 1037 0
 3381 1d50 01A8A0E1 		mov	sl, r1, asl #16
 3382 1d54 05C042E2 		sub	ip, r2, #5
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3383              		.loc 1 1039 0
 3384 1d58 051062E2 		rsb	r1, r2, #5
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3385              		.loc 1 1037 0
 3386 1d5c 48A08DE5 		str	sl, [sp, #72]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3387              		.loc 1 1039 0
 3388 1d60 40009DE5 		ldr	r0, [sp, #64]
 3389 1d64 38A09DE5 		ldr	sl, [sp, #56]
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3390              		.loc 1 1037 0
 3391 1d68 40C08DE5 		str	ip, [sp, #64]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3392              		.loc 1 1039 0
 3393 1d6c 3CC09DE5 		ldr	ip, [sp, #60]
 3394 1d70 4C108DE5 		str	r1, [sp, #76]
 3395 1d74 48109DE5 		ldr	r1, [sp, #72]
 3396 1d78 0008A0E1 		mov	r0, r0, asl #16
 3397 1d7c 0A005CE1 		cmp	ip, sl
 3398 1d80 0AC0A021 		movcs	ip, sl
 3399 1d84 0A0052E3 		cmp	r2, #10
 3400 1d88 20A09DE5 		ldr	sl, [sp, #32]
 3401 1d8c 2108A081 		movhi	r0, r1, lsr #16
 3402 1d90 2008A091 		movls	r0, r0, lsr #16
 3403 1d94 48008DE5 		str	r0, [sp, #72]
 3404 1d98 24009DE5 		ldr	r0, [sp, #36]
 3405 1d9c 0A005EE1 		cmp	lr, sl
 3406 1da0 0200A033 		movcc	r0, #2
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3407              		.loc 1 1037 0
 3408 1da4 02E042E2 		sub	lr, r2, #2
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3409              		.loc 1 1039 0
 3410 1da8 44C08DE5 		str	ip, [sp, #68]
 3411 1dac 24008DE5 		str	r0, [sp, #36]
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3412              		.loc 1 1037 0
 3413 1db0 40C09DE5 		ldr	ip, [sp, #64]
 3414 1db4 1CE08DE5 		str	lr, [sp, #28]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3415              		.loc 1 1039 0
 3416 1db8 44009DE5 		ldr	r0, [sp, #68]
 3417 1dbc 48E09DE5 		ldr	lr, [sp, #72]
 3418 1dc0 4C109DE5 		ldr	r1, [sp, #76]
 3419 1dc4 02A062E2 		rsb	sl, r2, #2
 3420 1dc8 00005EE1 		cmp	lr, r0
 3421 1dcc 00E0A021 		movcs	lr, r0
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3422              		.loc 1 1037 0
 3423 1dd0 0CC8A0E1 		mov	ip, ip, asl #16
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3424              		.loc 1 1039 0
 3425 1dd4 050052E3 		cmp	r2, #5
 3426 1dd8 40A08DE5 		str	sl, [sp, #64]
 3427 1ddc 0118A0E1 		mov	r1, r1, asl #16
 3428 1de0 3CA09DE5 		ldr	sl, [sp, #60]
 3429 1de4 2C18A081 		movhi	r1, ip, lsr #16
 3430 1de8 38C09DE5 		ldr	ip, [sp, #56]
 3431 1dec 4CE08DE5 		str	lr, [sp, #76]
 3432 1df0 24009DE5 		ldr	r0, [sp, #36]
 3433 1df4 40E09DE5 		ldr	lr, [sp, #64]
 3434 1df8 2118A091 		movls	r1, r1, lsr #16
 3435 1dfc 0C005AE1 		cmp	sl, ip
 3436 1e00 20108DE5 		str	r1, [sp, #32]
 3437 1e04 0300A033 		movcc	r0, #3
 3438 1e08 38008DE5 		str	r0, [sp, #56]
 3439 1e0c 4CA09DE5 		ldr	sl, [sp, #76]
 3440 1e10 0E08A0E1 		mov	r0, lr, asl #16
 3441 1e14 20E09DE5 		ldr	lr, [sp, #32]
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3442              		.loc 1 1037 0
 3443 1e18 1C109DE5 		ldr	r1, [sp, #28]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3444              		.loc 1 1039 0
 3445 1e1c 0A005EE1 		cmp	lr, sl
 3446 1e20 0AE0A021 		movcs	lr, sl
 3447 1e24 44C09DE5 		ldr	ip, [sp, #68]
 3448 1e28 48A09DE5 		ldr	sl, [sp, #72]
 3449 1e2c 020052E3 		cmp	r2, #2
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3450              		.loc 1 1037 0
 3451 1e30 0118A0E1 		mov	r1, r1, asl #16
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3452              		.loc 1 1039 0
 3453 1e34 2018A091 		movls	r1, r0, lsr #16
 3454 1e38 38009DE5 		ldr	r0, [sp, #56]
 3455 1e3c 2118A081 		movhi	r1, r1, lsr #16
 3456 1e40 0C005AE1 		cmp	sl, ip
 3457 1e44 0400A033 		movcc	r0, #4
 3458 1e48 40008DE5 		str	r0, [sp, #64]
1037:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3459              		.loc 1 1037 0
 3460 1e4c 010042E2 		sub	r0, r2, #1
 3461 1e50 38008DE5 		str	r0, [sp, #56]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3462              		.loc 1 1039 0
 3463 1e54 4CA09DE5 		ldr	sl, [sp, #76]
 3464 1e58 20009DE5 		ldr	r0, [sp, #32]
 3465 1e5c 01C062E2 		rsb	ip, r2, #1
 3466 1e60 3CC08DE5 		str	ip, [sp, #60]
 3467 1e64 0A0050E1 		cmp	r0, sl
1046:../uvc.c      **** 						  shutter = shutter+index;
 3468              		.loc 1 1046 0
 3469 1e68 38A09DE5 		ldr	sl, [sp, #56]
 3470 1e6c 3C009DE5 		ldr	r0, [sp, #60]
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3471              		.loc 1 1039 0
 3472 1e70 40C09DE5 		ldr	ip, [sp, #64]
 3473 1e74 05C0A033 		movcc	ip, #5
1046:../uvc.c      **** 						  shutter = shutter+index;
 3474              		.loc 1 1046 0
 3475 1e78 010052E3 		cmp	r2, #1
 3476 1e7c 0028A091 		movls	r2, r0, asl #16
 3477 1e80 0A28A081 		movhi	r2, sl, asl #16
 3478 1e84 0E0051E1 		cmp	r1, lr
 3479 1e88 01A0A031 		movcc	sl, r1
 3480 1e8c 0EA0A021 		movcs	sl, lr
1039:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3481              		.loc 1 1039 0
 3482 1e90 0E0051E1 		cmp	r1, lr
 3483 1e94 0C10A021 		movcs	r1, ip
 3484 1e98 0610A033 		movcc	r1, #6
1046:../uvc.c      **** 						  shutter = shutter+index;
 3485              		.loc 1 1046 0
 3486 1e9c 22085AE1 		cmp	sl, r2, lsr #16
1049:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3487              		.loc 1 1049 0
 3488 1ea0 8CA39FE5 		ldr	sl, .L288+24
1046:../uvc.c      **** 						  shutter = shutter+index;
 3489              		.loc 1 1046 0
 3490 1ea4 0120A091 		movls	r2, r1
 3491 1ea8 0720A083 		movhi	r2, #7
 3492 1eac 012082E2 		add	r2, r2, #1
 3493 1eb0 FFE002E2 		and	lr, r2, #255
1049:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3494              		.loc 1 1049 0
 3495 1eb4 0010E0E3 		mvn	r1, #0
 3496 1eb8 1C009AE5 		ldr	r0, [sl, #28]
1046:../uvc.c      **** 						  shutter = shutter+index;
 3497              		.loc 1 1046 0
 3498 1ebc 38E08DE5 		str	lr, [sp, #56]
 3499              	.LVL264:
1049:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3500              		.loc 1 1049 0
 3501 1ec0 2C308DE5 		str	r3, [sp, #44]
 3502 1ec4 FEFFFFEB 		bl	_txe_mutex_get
1050:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3503              		.loc 1 1050 0
 3504 1ec8 38C09DE5 		ldr	ip, [sp, #56]
 3505 1ecc 0310A0E3 		mov	r1, #3
 3506 1ed0 0B20A0E1 		mov	r2, fp
 3507 1ed4 2C309DE5 		ldr	r3, [sp, #44]
 3508 1ed8 00C08DE5 		str	ip, [sp, #0]
 3509 1edc 0A00A0E1 		mov	r0, sl
 3510 1ee0 00C0A0E3 		mov	ip, #0
 3511 1ee4 04C08DE5 		str	ip, [sp, #4]
 3512 1ee8 FEFFFFEB 		bl	cmdSet
1051:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3513              		.loc 1 1051 0
 3514 1eec 1C009AE5 		ldr	r0, [sl, #28]
 3515 1ef0 FEFFFFEB 		bl	_txe_mutex_put
1054:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3516              		.loc 1 1054 0
 3517 1ef4 30009DE5 		ldr	r0, [sp, #48]
1055:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3518              		.loc 1 1055 0
 3519 1ef8 34C09DE5 		ldr	ip, [sp, #52]
1057:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3520              		.loc 1 1057 0
 3521 1efc 38309DE5 		ldr	r3, [sp, #56]
1054:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3522              		.loc 1 1054 0
 3523 1f00 061089E0 		add	r1, r9, r6
 3524 1f04 816188E0 		add	r6, r8, r1, asl #3
1056:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3525              		.loc 1 1056 0
 3526 1f08 0120A0E3 		mov	r2, #1
1054:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3527              		.loc 1 1054 0
 3528 1f0c 9D04C6E5 		strb	r0, [r6, #1181]
1055:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3529              		.loc 1 1055 0
 3530 1f10 9EC4C6E5 		strb	ip, [r6, #1182]
1056:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3531              		.loc 1 1056 0
 3532 1f14 A024C6E5 		strb	r2, [r6, #1184]
1057:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3533              		.loc 1 1057 0
 3534 1f18 0D33C8E5 		strb	r3, [r8, #781]
 3535 1f1c 3FFFFFEA 		b	.L278
 3536              	.LVL265:
 3537              	.L224:
 984:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3538              		.loc 1 984 0
 3539 1f20 062089E0 		add	r2, r9, r6
 3540 1f24 826188E0 		add	r6, r8, r2, asl #3
 985:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3541              		.loc 1 985 0
 3542 1f28 0110A0E3 		mov	r1, #1
 988:../uvc.c      **** 		  		    switch (getData){
 3543              		.loc 1 988 0
 3544 1f2c 01E040E2 		sub	lr, r0, #1
 984:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3545              		.loc 1 984 0
 3546 1f30 9D04C6E5 		strb	r0, [r6, #1181]
 985:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3547              		.loc 1 985 0
 3548 1f34 A014C6E5 		strb	r1, [r6, #1184]
 3549              	.LVL266:
 988:../uvc.c      **** 		  		    switch (getData){
 3550              		.loc 1 988 0
 3551 1f38 07005EE3 		cmp	lr, #7
 3552 1f3c 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3553 1f40 970000EA 		b	.L229
 3554              	.L234:
 3555 1f44 38210000 		.word	.L230
 3556 1f48 9C200000 		.word	.L231
 3557 1f4c A4210000 		.word	.L229
 3558 1f50 38200000 		.word	.L232
 3559 1f54 A4210000 		.word	.L229
 3560 1f58 A4210000 		.word	.L229
 3561 1f5c A4210000 		.word	.L229
 3562 1f60 981F0000 		.word	.L233
 3563              	.LVL267:
 3564              	.L223:
1104:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3565              		.loc 1 1104 0
 3566 1f64 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1103:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3567              		.loc 1 1103 0
 3568 1f68 30A09DE5 		ldr	sl, [sp, #48]
 3569 1f6c 069089E0 		add	r9, r9, r6
 3570 1f70 89E188E0 		add	lr, r8, r9, asl #3
1104:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3571              		.loc 1 1104 0
 3572 1f74 0620A0E1 		mov	r2, r6
 3573 1f78 0400A0E3 		mov	r0, #4
 3574 1f7c BC129FE5 		ldr	r1, .L288+36
1103:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3575              		.loc 1 1103 0
 3576 1f80 9DA4CEE5 		strb	sl, [lr, #1181]
1104:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3577              		.loc 1 1104 0
 3578 1f84 FEFFFFEB 		bl	CyU3PDebugPrint
1105:../uvc.c      **** 			  		 break;
 3579              		.loc 1 1105 0
 3580 1f88 FFC0A0E3 		mov	ip, #255
 3581 1f8c 0C60A0E1 		mov	r6, ip
 3582 1f90 0C80A0E1 		mov	r8, ip
 3583 1f94 68FEFFEA 		b	.L214
 3584              	.LVL268:
 3585              	.L233:
1007:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3586              		.loc 1 1007 0
 3587 1f98 94629FE5 		ldr	r6, .L288+24
1005:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3588              		.loc 1 1005 0
 3589 1f9c 00A0A0E3 		mov	sl, #0
1007:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3590              		.loc 1 1007 0
 3591 1fa0 1C0096E5 		ldr	r0, [r6, #28]
1005:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3592              		.loc 1 1005 0
 3593 1fa4 0DA3C8E5 		strb	sl, [r8, #781]
 3594              	.LVL269:
1007:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3595              		.loc 1 1007 0
 3596 1fa8 0010E0E3 		mvn	r1, #0
 3597 1fac 2C308DE5 		str	r3, [sp, #44]
 3598 1fb0 FEFFFFEB 		bl	_txe_mutex_get
1008:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3599              		.loc 1 1008 0
 3600 1fb4 0B20A0E1 		mov	r2, fp
 3601 1fb8 2C309DE5 		ldr	r3, [sp, #44]
 3602 1fbc 1010A0E3 		mov	r1, #16
 3603 1fc0 0600A0E1 		mov	r0, r6
 3604 1fc4 00A08DE5 		str	sl, [sp, #0]
 3605 1fc8 04A08DE5 		str	sl, [sp, #4]
 3606 1fcc FEFFFFEB 		bl	cmdSet
1009:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3607              		.loc 1 1009 0
 3608 1fd0 1C0096E5 		ldr	r0, [r6, #28]
 3609 1fd4 FEFFFFEB 		bl	_txe_mutex_put
 3610              	.LVL270:
 3611              	.LBB66:
 3612              	.LBB67:
 377:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3613              		.loc 1 377 0
 3614 1fd8 0010E0E3 		mvn	r1, #0
 3615 1fdc 1C0096E5 		ldr	r0, [r6, #28]
 3616 1fe0 FEFFFFEB 		bl	_txe_mutex_get
 378:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3617              		.loc 1 378 0
 3618 1fe4 0180A0E3 		mov	r8, #1
 3619 1fe8 1410A0E3 		mov	r1, #20
 3620 1fec 2720A0E3 		mov	r2, #39
 3621 1ff0 3030A0E3 		mov	r3, #48
 3622 1ff4 0600A0E1 		mov	r0, r6
 3623 1ff8 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3624 1ffc FEFFFFEB 		bl	cmdSet
 379:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3625              		.loc 1 379 0
 3626 2000 02C0A0E3 		mov	ip, #2
 3627 2004 1510A0E3 		mov	r1, #21
 3628 2008 2520A0E3 		mov	r2, #37
 3629 200c 3030A0E3 		mov	r3, #48
 3630 2010 0600A0E1 		mov	r0, r6
 3631 2014 00C08DE5 		str	ip, [sp, #0]
 3632 2018 04A08DE5 		str	sl, [sp, #4]
 3633 201c FEFFFFEB 		bl	cmdSet
 380:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3634              		.loc 1 380 0
 3635 2020 1C0096E5 		ldr	r0, [r6, #28]
 3636 2024 FEFFFFEB 		bl	_txe_mutex_put
 3637              	.LBE67:
 3638              	.LBE66:
1011:../uvc.c      **** 							break;
 3639              		.loc 1 1011 0
 3640 2028 FFC0A0E3 		mov	ip, #255
 3641 202c 0C60A0E1 		mov	r6, ip
 3642 2030 0880A0E3 		mov	r8, #8
 3643 2034 40FEFFEA 		b	.L214
 3644              	.LVL271:
 3645              	.L232:
 3646              	.LBB68:
 3647              	.LBB69:
 377:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3648              		.loc 1 377 0
 3649 2038 F4819FE5 		ldr	r8, .L288+24
 3650 203c 0010E0E3 		mvn	r1, #0
 3651 2040 1C0098E5 		ldr	r0, [r8, #28]
 3652 2044 FEFFFFEB 		bl	_txe_mutex_get
 378:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3653              		.loc 1 378 0
 3654 2048 0060A0E3 		mov	r6, #0
 3655 204c 1410A0E3 		mov	r1, #20
 3656 2050 2720A0E3 		mov	r2, #39
 3657 2054 3030A0E3 		mov	r3, #48
 3658 2058 0800A0E1 		mov	r0, r8
 3659 205c 00608DE5 		str	r6, [sp, #0]
 3660 2060 04608DE5 		str	r6, [sp, #4]
 3661 2064 FEFFFFEB 		bl	cmdSet
 379:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3662              		.loc 1 379 0
 3663 2068 1510A0E3 		mov	r1, #21
 3664 206c 2520A0E3 		mov	r2, #37
 3665 2070 3030A0E3 		mov	r3, #48
 3666 2074 0800A0E1 		mov	r0, r8
 3667 2078 00608DE5 		str	r6, [sp, #0]
 3668 207c 04608DE5 		str	r6, [sp, #4]
 3669 2080 FEFFFFEB 		bl	cmdSet
 380:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3670              		.loc 1 380 0
 3671 2084 1C0098E5 		ldr	r0, [r8, #28]
 3672 2088 FEFFFFEB 		bl	_txe_mutex_put
 3673 208c FFC0A0E3 		mov	ip, #255
 3674 2090 0C60A0E1 		mov	r6, ip
 3675 2094 0480A0E3 		mov	r8, #4
 3676 2098 27FEFFEA 		b	.L214
 3677              	.LVL272:
 3678              	.L231:
 3679              	.LBE69:
 3680              	.LBE68:
 995:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3681              		.loc 1 995 0
 3682 209c 90A19FE5 		ldr	sl, .L288+24
 993:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3683              		.loc 1 993 0
 3684 20a0 0060A0E3 		mov	r6, #0
 3685 20a4 0D63C8E5 		strb	r6, [r8, #781]
 3686              	.LVL273:
 995:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3687              		.loc 1 995 0
 3688 20a8 0010E0E3 		mvn	r1, #0
 3689 20ac 1C009AE5 		ldr	r0, [sl, #28]
 3690 20b0 2C308DE5 		str	r3, [sp, #44]
 3691 20b4 FEFFFFEB 		bl	_txe_mutex_get
 996:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3692              		.loc 1 996 0
 3693 20b8 0B20A0E1 		mov	r2, fp
 3694 20bc 2C309DE5 		ldr	r3, [sp, #44]
 3695 20c0 1010A0E3 		mov	r1, #16
 3696 20c4 0A00A0E1 		mov	r0, sl
 3697 20c8 00608DE5 		str	r6, [sp, #0]
 3698 20cc 04608DE5 		str	r6, [sp, #4]
 3699 20d0 FEFFFFEB 		bl	cmdSet
 997:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3700              		.loc 1 997 0
 3701 20d4 1C009AE5 		ldr	r0, [sl, #28]
 3702 20d8 FEFFFFEB 		bl	_txe_mutex_put
 3703              	.LVL274:
 3704              	.LBB70:
 3705              	.LBB71:
 377:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3706              		.loc 1 377 0
 3707 20dc 0010E0E3 		mvn	r1, #0
 3708 20e0 1C009AE5 		ldr	r0, [sl, #28]
 3709 20e4 FEFFFFEB 		bl	_txe_mutex_get
 378:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3710              		.loc 1 378 0
 3711 20e8 1410A0E3 		mov	r1, #20
 3712 20ec 2720A0E3 		mov	r2, #39
 3713 20f0 3030A0E3 		mov	r3, #48
 3714 20f4 0A00A0E1 		mov	r0, sl
 3715 20f8 00608DE5 		str	r6, [sp, #0]
 3716 20fc 04608DE5 		str	r6, [sp, #4]
 3717 2100 FEFFFFEB 		bl	cmdSet
 379:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3718              		.loc 1 379 0
 3719 2104 1510A0E3 		mov	r1, #21
 3720 2108 2520A0E3 		mov	r2, #37
 3721 210c 3030A0E3 		mov	r3, #48
 3722 2110 0A00A0E1 		mov	r0, sl
 3723 2114 00608DE5 		str	r6, [sp, #0]
 3724 2118 04608DE5 		str	r6, [sp, #4]
 3725 211c FEFFFFEB 		bl	cmdSet
 380:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3726              		.loc 1 380 0
 3727 2120 1C009AE5 		ldr	r0, [sl, #28]
 3728 2124 FEFFFFEB 		bl	_txe_mutex_put
 3729 2128 FFC0A0E3 		mov	ip, #255
 3730 212c 0C60A0E1 		mov	r6, ip
 3731 2130 0280A0E3 		mov	r8, #2
 3732 2134 00FEFFEA 		b	.L214
 3733              	.LVL275:
 3734              	.L230:
 3735              	.LBE71:
 3736              	.LBE70:
 3737              	.LBB72:
 3738              	.LBB73:
 377:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3739              		.loc 1 377 0
 3740 2138 F4609FE5 		ldr	r6, .L288+24
 3741 213c 0010E0E3 		mvn	r1, #0
 3742 2140 1C0096E5 		ldr	r0, [r6, #28]
 3743 2144 FEFFFFEB 		bl	_txe_mutex_get
 378:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3744              		.loc 1 378 0
 3745 2148 0080A0E3 		mov	r8, #0
 3746 214c 01A0A0E3 		mov	sl, #1
 3747 2150 1410A0E3 		mov	r1, #20
 3748 2154 2720A0E3 		mov	r2, #39
 3749 2158 3030A0E3 		mov	r3, #48
 3750 215c 0600A0E1 		mov	r0, r6
 3751 2160 04808DE5 		str	r8, [sp, #4]
 3752 2164 00A08DE5 		str	sl, [sp, #0]
 3753 2168 FEFFFFEB 		bl	cmdSet
 379:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3754              		.loc 1 379 0
 3755 216c 02C0A0E3 		mov	ip, #2
 3756 2170 1510A0E3 		mov	r1, #21
 3757 2174 2520A0E3 		mov	r2, #37
 3758 2178 3030A0E3 		mov	r3, #48
 3759 217c 0600A0E1 		mov	r0, r6
 3760 2180 00C08DE5 		str	ip, [sp, #0]
 3761 2184 04808DE5 		str	r8, [sp, #4]
 3762 2188 FEFFFFEB 		bl	cmdSet
 380:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3763              		.loc 1 380 0
 3764 218c 1C0096E5 		ldr	r0, [r6, #28]
 3765 2190 FEFFFFEB 		bl	_txe_mutex_put
 3766              	.LBE73:
 3767              	.LBE72:
 991:../uvc.c      **** 							break;
 3768              		.loc 1 991 0
 3769 2194 FFC0A0E3 		mov	ip, #255
 3770 2198 0C60A0E1 		mov	r6, ip
 3771 219c 0A80A0E1 		mov	r8, sl
 3772 21a0 E5FDFFEA 		b	.L214
 3773              	.LVL276:
 3774              	.L229:
 988:../uvc.c      **** 		  		    switch (getData){
 3775              		.loc 1 988 0
 3776 21a4 FFC0A0E3 		mov	ip, #255
 3777 21a8 0080A0E1 		mov	r8, r0
 3778 21ac 0C60A0E1 		mov	r6, ip
 3779 21b0 E1FDFFEA 		b	.L214
 3780              	.LVL277:
 3781              	.L235:
1059:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3782              		.loc 1 1059 0
 3783 21b4 0000A0E3 		mov	r0, #0
 3784 21b8 0110A0E3 		mov	r1, #1
 3785 21bc 0020A0E1 		mov	r2, r0
 3786 21c0 FEFFFFEB 		bl	CyU3PUsbStall
 3787              	.LVL278:
 3788 21c4 95FEFFEA 		b	.L278
 3789              	.LVL279:
 3790              	.L277:
1077:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3791              		.loc 1 1077 0
 3792 21c8 0110A0E3 		mov	r1, #1
 3793 21cc 0020A0E1 		mov	r2, r0
 3794 21d0 FEFFFFEB 		bl	CyU3PUsbStall
 3795 21d4 91FEFFEA 		b	.L278
 3796              	.LVL280:
 3797              	.L287:
1092:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3798              		.loc 1 1092 0
 3799 21d8 08E0A0E3 		mov	lr, #8
 3800 21dc 00C0A0E3 		mov	ip, #0
 3801 21e0 0600A0E1 		mov	r0, r6
 3802 21e4 1710A0E3 		mov	r1, #23
 3803 21e8 0B20A0E1 		mov	r2, fp
 3804 21ec 00E08DE5 		str	lr, [sp, #0]
 3805 21f0 04C08DE5 		str	ip, [sp, #4]
 3806 21f4 FEFFFFEB 		bl	cmdSet
 3807 21f8 5EFEFFEA 		b	.L280
 3808              	.L286:
1090:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3809              		.loc 1 1090 0
 3810 21fc 0480A0E3 		mov	r8, #4
 3811 2200 00E0A0E3 		mov	lr, #0
 3812 2204 0600A0E1 		mov	r0, r6
 3813 2208 1710A0E3 		mov	r1, #23
 3814 220c 0B20A0E1 		mov	r2, fp
 3815 2210 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3816 2214 FEFFFFEB 		bl	cmdSet
 3817 2218 56FEFFEA 		b	.L280
 3818              	.L289:
 3819              		.align	2
 3820              	.L288:
 3821 221c 00000000 		.word	bRequest
 3822 2220 00000000 		.word	.LANCHOR1
 3823 2224 00000000 		.word	.LANCHOR0
 3824 2228 A4030000 		.word	.LC22
 3825 222c C8030000 		.word	.LC23
 3826 2230 58000000 		.word	.LANCHOR0+88
 3827 2234 00000000 		.word	cmdQu
 3828 2238 58030000 		.word	.LC20
 3829 223c FFFF0000 		.word	65535
 3830 2240 80030000 		.word	.LC21
 3831              		.cfi_endproc
 3832              	.LFE3:
 3834              		.align	2
 3835              		.global	UVCAppEP0Thread_Entry
 3837              	UVCAppEP0Thread_Entry:
 3838              	.LFB24:
3071:../uvc.c      **** {
 3839              		.loc 1 3071 0
 3840              		.cfi_startproc
 3841              		@ args = 0, pretend = 0, frame = 32
 3842              		@ frame_needed = 0, uses_anonymous_args = 0
 3843              	.LVL281:
 3844 2244 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3845              	.LCFI17:
 3846              		.cfi_def_cfa_offset 36
 3847 2248 DC499FE5 		ldr	r4, .L437
 3848              		.cfi_offset 14, -4
 3849              		.cfi_offset 11, -8
 3850              		.cfi_offset 10, -12
 3851              		.cfi_offset 9, -16
 3852              		.cfi_offset 8, -20
 3853              		.cfi_offset 7, -24
 3854              		.cfi_offset 6, -28
 3855              		.cfi_offset 5, -32
 3856              		.cfi_offset 4, -36
 3857 224c DC699FE5 		ldr	r6, .L437+4
 3858 2250 DC899FE5 		ldr	r8, .L437+8
 3859 2254 DC999FE5 		ldr	r9, .L437+12
 3860 2258 DCA99FE5 		ldr	sl, .L437+16
 3861 225c DC799FE5 		ldr	r7, .L437+20
 3862 2260 3CD04DE2 		sub	sp, sp, #60
 3863              	.LCFI18:
 3864              		.cfi_def_cfa_offset 96
 3865              	.LVL282:
3093:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 3866              		.loc 1 3093 0
 3867 2264 0450A0E1 		mov	r5, r4
 3868              	.LVL283:
 3869              	.L414:
 3870 2268 00C0E0E3 		mvn	ip, #0
 3871 226c B8099FE5 		ldr	r0, .L437
 3872 2270 4C10A0E3 		mov	r1, #76
 3873 2274 0120A0E3 		mov	r2, #1
 3874 2278 30308DE2 		add	r3, sp, #48
 3875 227c 00C08DE5 		str	ip, [sp, #0]
 3876 2280 FEFFFFEB 		bl	_txe_event_flags_get
 3877 2284 000050E3 		cmp	r0, #0
 3878 2288 3000001A 		bne	.L291
3097:../uvc.c      ****             if (!isUsbConnected)
 3879              		.loc 1 3097 0
 3880 228c 3C3095E5 		ldr	r3, [r5, #60]
 3881 2290 000053E3 		cmp	r3, #0
 3882 2294 8900000A 		beq	.L428
 3883              	.L292:
3106:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 3884              		.loc 1 3106 0
 3885 2298 30309DE5 		ldr	r3, [sp, #48]
 3886 229c 0C0013E3 		tst	r3, #12
 3887 22a0 7200001A 		bne	.L429
 3888              	.L293:
3113:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 3889              		.loc 1 3113 0
 3890 22a4 040013E3 		tst	r3, #4
 3891 22a8 1C00000A 		beq	.L294
3115:../uvc.c      ****             	switch ((wIndex >> 8))
 3892              		.loc 1 3115 0
 3893 22ac B0E0DAE1 		ldrh	lr, [sl, #0]
 3894 22b0 2E24A0E1 		mov	r2, lr, lsr #8
 3895 22b4 030052E3 		cmp	r2, #3
 3896 22b8 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3897 22bc 120000EA 		b	.L295
 3898              	.L300:
 3899 22c0 0C230000 		.word	.L295
 3900 22c4 F0230000 		.word	.L297
 3901 22c8 D0220000 		.word	.L298
 3902 22cc 2C240000 		.word	.L299
 3903              	.L298:
 3904              	.LBB88:
 3905              	.LBB90:
2402:../uvc.c      ****     switch (wValue)
 3906              		.loc 1 2402 0
 3907 22d0 B020D9E1 		ldrh	r2, [r9, #0]
 3908 22d4 060C52E3 		cmp	r2, #1536
 3909 22d8 D901000A 		beq	.L306
 3910 22dc CC00008A 		bhi	.L312
 3911 22e0 030C52E3 		cmp	r2, #768
 3912 22e4 D201000A 		beq	.L304
 3913 22e8 C901008A 		bhi	.L313
 3914 22ec 010C52E3 		cmp	r2, #256
 3915 22f0 6801000A 		beq	.L302
 3916 22f4 020C52E3 		cmp	r2, #512
 3917 22f8 6201000A 		beq	.L430
 3918              	.L315:
 3919              	.LBE90:
 3920              	.LBE88:
 3921              	.LBB93:
 3922              	.LBB97:
2534:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 3923              		.loc 1 2534 0
 3924 22fc 40199FE5 		ldr	r1, .L437+24
 3925 2300 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 3926 2304 0400A0E3 		mov	r0, #4
 3927 2308 FEFFFFEB 		bl	CyU3PDebugPrint
 3928              	.L295:
 3929              	.LBE97:
 3930              	.LBE93:
3136:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 3931              		.loc 1 3136 0
 3932 230c 0000A0E3 		mov	r0, #0
 3933 2310 0110A0E3 		mov	r1, #1
 3934 2314 0020A0E1 		mov	r2, r0
 3935 2318 FEFFFFEB 		bl	CyU3PUsbStall
 3936 231c 30309DE5 		ldr	r3, [sp, #48]
 3937              	.L294:
3141:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 3938              		.loc 1 3141 0
 3939 2320 080013E3 		tst	r3, #8
 3940 2324 0700000A 		beq	.L356
3145:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 3941              		.loc 1 3145 0
 3942 2328 B030DAE1 		ldrh	r3, [sl, #0]
 3943 232c 010053E3 		cmp	r3, #1
 3944 2330 6800000A 		beq	.L357
 3945              	.L358:
 3946              	.LBB102:
 3947              	.LBB108:
3060:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 3948              		.loc 1 3060 0
 3949 2334 0000A0E3 		mov	r0, #0
 3950 2338 0110A0E3 		mov	r1, #1
 3951 233c 0020A0E1 		mov	r2, r0
 3952 2340 FEFFFFEB 		bl	CyU3PUsbStall
 3953              	.L418:
 3954 2344 30309DE5 		ldr	r3, [sp, #48]
 3955              	.L356:
 3956              	.LBE108:
 3957              	.LBE102:
3156:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 3958              		.loc 1 3156 0
 3959 2348 400013E3 		tst	r3, #64
 3960 234c 0100001A 		bne	.L431
 3961              	.L291:
3369:../uvc.c      ****         CyU3PThreadRelinquish ();
 3962              		.loc 1 3369 0
 3963 2350 FEFFFFEB 		bl	_txe_thread_relinquish
3370:../uvc.c      ****     }
 3964              		.loc 1 3370 0
 3965 2354 C3FFFFEA 		b	.L414
 3966              	.L431:
3161:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 3967              		.loc 1 3161 0
 3968 2358 1800A0E3 		mov	r0, #24
 3969 235c 2C108DE2 		add	r1, sp, #44
 3970 2360 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3166:../uvc.c      **** 				if(value&&(!snapButFlag)){
 3971              		.loc 1 3166 0
 3972 2364 2C209DE5 		ldr	r2, [sp, #44]
 3973 2368 000052E3 		cmp	r2, #0
 3974 236c 6D00000A 		beq	.L409
3166:../uvc.c      **** 				if(value&&(!snapButFlag)){
 3975              		.loc 1 3166 0 is_stmt 0 discriminator 1
 3976 2370 5F36D6E5 		ldrb	r3, [r6, #1631]	@ zero_extendqisi2
 3977 2374 000053E3 		cmp	r3, #0
 3978 2378 F4FFFF1A 		bne	.L291
3168:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 3979              		.loc 1 3168 0 is_stmt 1
 3980 237c 002097E5 		ldr	r2, [r7, #0]
 3981 2380 02B0A0E3 		mov	fp, #2
 3982 2384 00B0C2E5 		strb	fp, [r2, #0]
3169:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 3983              		.loc 1 3169 0
 3984 2388 001097E5 		ldr	r1, [r7, #0]
 3985 238c 01B0A0E3 		mov	fp, #1
 3986 2390 01B0C1E5 		strb	fp, [r1, #1]
3170:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 3987              		.loc 1 3170 0
 3988 2394 000097E5 		ldr	r0, [r7, #0]
3174:../uvc.c      **** 					interStabuf.size   = 1024;
 3989              		.loc 1 3174 0
 3990 2398 01EBA0E3 		mov	lr, #1024	@ movhi
3170:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 3991              		.loc 1 3170 0
 3992 239c 0230C0E5 		strb	r3, [r0, #2]
3171:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 3993              		.loc 1 3171 0
 3994 23a0 00C097E5 		ldr	ip, [r7, #0]
3180:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 3995              		.loc 1 3180 0
 3996 23a4 0010E0E3 		mvn	r1, #0
3171:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 3997              		.loc 1 3171 0
 3998 23a8 0330CCE5 		strb	r3, [ip, #3]
3173:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 3999              		.loc 1 3173 0
 4000 23ac 002097E5 		ldr	r2, [r7, #0]
3177:../uvc.c      **** 					interStabuf.count = 4;
 4001              		.loc 1 3177 0
 4002 23b0 04C0A0E3 		mov	ip, #4	@ movhi
3180:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4003              		.loc 1 3180 0
 4004 23b4 8C089FE5 		ldr	r0, .L437+28
3173:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4005              		.loc 1 3173 0
 4006 23b8 20208DE5 		str	r2, [sp, #32]
3174:../uvc.c      **** 					interStabuf.size   = 1024;
 4007              		.loc 1 3174 0
 4008 23bc B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3175:../uvc.c      **** 					interStabuf.status = 0;
 4009              		.loc 1 3175 0
 4010 23c0 B832CDE1 		strh	r3, [sp, #40]	@ movhi
3177:../uvc.c      **** 					interStabuf.count = 4;
 4011              		.loc 1 3177 0
 4012 23c4 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
3180:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4013              		.loc 1 3180 0
 4014 23c8 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3183:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4015              		.loc 1 3183 0
 4016 23cc 74089FE5 		ldr	r0, .L437+28
 4017 23d0 20108DE2 		add	r1, sp, #32
 4018 23d4 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4019              	.LVL284:
3184:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4020              		.loc 1 3184 0
 4021 23d8 002050E2 		subs	r2, r0, #0
 4022 23dc 6701001A 		bne	.L432
3189:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4023              		.loc 1 3189 0
 4024 23e0 48389FE5 		ldr	r3, .L437+4
 4025 23e4 5FB6C3E5 		strb	fp, [r3, #1631]
3369:../uvc.c      ****         CyU3PThreadRelinquish ();
 4026              		.loc 1 3369 0
 4027 23e8 FEFFFFEB 		bl	_txe_thread_relinquish
 4028              	.LVL285:
 4029 23ec 9DFFFFEA 		b	.L414
 4030              	.L297:
 4031              	.LBB114:
 4032              	.LBB98:
2477:../uvc.c      ****     switch (wValue)
 4033              		.loc 1 2477 0
 4034 23f0 B020D9E1 		ldrh	r2, [r9, #0]
 4035 23f4 060C52E3 		cmp	r2, #1536
 4036 23f8 D500000A 		beq	.L321
 4037 23fc 8F00008A 		bhi	.L327
 4038 2400 030C52E3 		cmp	r2, #768
 4039 2404 1701000A 		beq	.L318
 4040 2408 0E01008A 		bhi	.L328
 4041 240c 010C52E3 		cmp	r2, #256
 4042 2410 5601000A 		beq	.L316
 4043 2414 020C52E3 		cmp	r2, #512
 4044 2418 B7FFFF1A 		bne	.L315
 4045              	.LVL286:
2485:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4046              		.loc 1 2485 0
 4047 241c 0100A0E3 		mov	r0, #1
 4048 2420 FEFFFFEB 		bl	CTControlHandle
 4049              	.LVL287:
 4050 2424 30309DE5 		ldr	r3, [sp, #48]
 4051 2428 BCFFFFEA 		b	.L294
 4052              	.L299:
 4053              	.LBE98:
 4054              	.LBE114:
 4055              	.LBB115:
 4056              	.LBB120:
2702:../uvc.c      ****     switch (wValue)
 4057              		.loc 1 2702 0
 4058 242c B020D9E1 		ldrh	r2, [r9, #0]
 4059 2430 090C52E3 		cmp	r2, #2304
 4060 2434 EE01000A 		beq	.L342
 4061 2438 8800008A 		bhi	.L351
 4062 243c 010B52E3 		cmp	r2, #1024
 4063 2440 EF01000A 		beq	.L337
 4064 2444 8701008A 		bhi	.L352
 4065 2448 020C52E3 		cmp	r2, #512
 4066 244c E401000A 		beq	.L335
 4067 2450 030C52E3 		cmp	r2, #768
 4068 2454 C301000A 		beq	.L336
 4069 2458 010C52E3 		cmp	r2, #256
 4070 245c AAFFFF1A 		bne	.L295
 4071              	.LVL288:
2706:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4072              		.loc 1 2706 0
 4073 2460 1000A0E3 		mov	r0, #16
 4074 2464 FEFFFFEB 		bl	ControlHandle
 4075              	.LVL289:
 4076 2468 30309DE5 		ldr	r3, [sp, #48]
 4077 246c ABFFFFEA 		b	.L294
 4078              	.L429:
 4079              	.LBE120:
 4080              	.LBE115:
3107:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4081              		.loc 1 3107 0
 4082 2470 D4B79FE5 		ldr	fp, .L437+32
 4083 2474 B0C0D9E1 		ldrh	ip, [r9, #0]
 4084 2478 B000DAE1 		ldrh	r0, [sl, #0]
 4085 247c CC179FE5 		ldr	r1, .L437+36
 4086 2480 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4087 2484 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4088 2488 0C008DE5 		str	r0, [sp, #12]
 4089 248c 08C08DE5 		str	ip, [sp, #8]
 4090 2490 B0C0D1E1 		ldrh	ip, [r1, #0]
 4091 2494 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4092 2498 04B08DE5 		str	fp, [sp, #4]
 4093 249c 0400A0E3 		mov	r0, #4
 4094 24a0 AC179FE5 		ldr	r1, .L437+40
 4095 24a4 00B0A0E3 		mov	fp, #0
 4096 24a8 00E08DE5 		str	lr, [sp, #0]
 4097 24ac 10C08DE5 		str	ip, [sp, #16]
 4098 24b0 14B08DE5 		str	fp, [sp, #20]
 4099 24b4 FEFFFFEB 		bl	CyU3PDebugPrint
 4100 24b8 30309DE5 		ldr	r3, [sp, #48]
 4101 24bc 78FFFFEA 		b	.L293
 4102              	.L428:
3099:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4103              		.loc 1 3099 0
 4104 24c0 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3100:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4105              		.loc 1 3100 0
 4106 24c4 000050E3 		cmp	r0, #0
3099:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4107              		.loc 1 3099 0
 4108 24c8 4800C5E5 		strb	r0, [r5, #72]
3102:../uvc.c      ****                     isUsbConnected = CyTrue;
 4109              		.loc 1 3102 0
 4110 24cc 0100A013 		movne	r0, #1
 4111 24d0 3C008515 		strne	r0, [r5, #60]
 4112 24d4 6FFFFFEA 		b	.L292
 4113              	.L357:
 4114              	.LVL290:
 4115              	.LBB125:
 4116              	.LBB107:
2797:../uvc.c      ****     switch (wValue)
 4117              		.loc 1 2797 0
 4118 24d8 B020D9E1 		ldrh	r2, [r9, #0]
 4119 24dc 030C52E3 		cmp	r2, #768
 4120 24e0 8100000A 		beq	.L361
 4121 24e4 3300008A 		bhi	.L364
 4122 24e8 010C52E3 		cmp	r2, #256
 4123 24ec 8B00000A 		beq	.L359
 4124 24f0 020C52E3 		cmp	r2, #512
 4125 24f4 8EFFFF1A 		bne	.L358
2849:../uvc.c      ****             switch (bRequest)
 4126              		.loc 1 2849 0
 4127 24f8 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4128 24fc 810053E3 		cmp	r3, #129
 4129 2500 8B00000A 		beq	.L403
 4130 2504 2601008A 		bhi	.L379
 4131 2508 010053E3 		cmp	r3, #1
 4132 250c 8401000A 		beq	.L433
 4133              	.L383:
2948:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4134              		.loc 1 2948 0
 4135 2510 0000A0E3 		mov	r0, #0
 4136 2514 0110A0E3 		mov	r1, #1
 4137 2518 0020A0E1 		mov	r2, r0
 4138 251c FEFFFFEB 		bl	CyU3PUsbStall
 4139 2520 30309DE5 		ldr	r3, [sp, #48]
 4140 2524 87FFFFEA 		b	.L356
 4141              	.LVL291:
 4142              	.L409:
 4143              	.LBE107:
 4144              	.LBE125:
3190:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4145              		.loc 1 3190 0
 4146 2528 5FE6D6E5 		ldrb	lr, [r6, #1631]	@ zero_extendqisi2
 4147 252c 00005EE3 		cmp	lr, #0
 4148 2530 86FFFF0A 		beq	.L291
3192:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4149              		.loc 1 3192 0
 4150 2534 003097E5 		ldr	r3, [r7, #0]
 4151 2538 02B0A0E3 		mov	fp, #2
 4152 253c 00B0C3E5 		strb	fp, [r3, #0]
3193:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4153              		.loc 1 3193 0
 4154 2540 001097E5 		ldr	r1, [r7, #0]
 4155 2544 01B0A0E3 		mov	fp, #1
 4156 2548 01B0C1E5 		strb	fp, [r1, #1]
3194:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4157              		.loc 1 3194 0
 4158 254c 000097E5 		ldr	r0, [r7, #0]
3198:../uvc.c      **** 					interStabuf.size   = 1024;
 4159              		.loc 1 3198 0
 4160 2550 01EBA0E3 		mov	lr, #1024	@ movhi
3194:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4161              		.loc 1 3194 0
 4162 2554 0220C0E5 		strb	r2, [r0, #2]
3195:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4163              		.loc 1 3195 0
 4164 2558 00C097E5 		ldr	ip, [r7, #0]
3204:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4165              		.loc 1 3204 0
 4166 255c 0010E0E3 		mvn	r1, #0
3195:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4167              		.loc 1 3195 0
 4168 2560 03B0CCE5 		strb	fp, [ip, #3]
3197:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4169              		.loc 1 3197 0
 4170 2564 003097E5 		ldr	r3, [r7, #0]
3199:../uvc.c      **** 					interStabuf.status = 0;
 4171              		.loc 1 3199 0
 4172 2568 02C0A0E1 		mov	ip, r2	@ movhi
 4173 256c B822CDE1 		strh	r2, [sp, #40]	@ movhi
3204:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4174              		.loc 1 3204 0
 4175 2570 D0069FE5 		ldr	r0, .L437+28
3201:../uvc.c      **** 					interStabuf.count = 4;
 4176              		.loc 1 3201 0
 4177 2574 0420A0E3 		mov	r2, #4	@ movhi
3197:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4178              		.loc 1 3197 0
 4179 2578 20308DE5 		str	r3, [sp, #32]
3201:../uvc.c      **** 					interStabuf.count = 4;
 4180              		.loc 1 3201 0
 4181 257c B422CDE1 		strh	r2, [sp, #36]	@ movhi
3198:../uvc.c      **** 					interStabuf.size   = 1024;
 4182              		.loc 1 3198 0
 4183 2580 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3204:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4184              		.loc 1 3204 0
 4185 2584 1CC08DE5 		str	ip, [sp, #28]
 4186 2588 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3207:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4187              		.loc 1 3207 0
 4188 258c B4069FE5 		ldr	r0, .L437+28
 4189 2590 20108DE2 		add	r1, sp, #32
 4190 2594 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4191              	.LVL292:
3208:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4192              		.loc 1 3208 0
 4193 2598 1C309DE5 		ldr	r3, [sp, #28]
 4194 259c 002050E2 		subs	r2, r0, #0
 4195 25a0 C000001A 		bne	.L434
3214:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4196              		.loc 1 3214 0
 4197 25a4 84269FE5 		ldr	r2, .L437+4
3215:../uvc.c      **** 					stiflag = CyTrue;
 4198              		.loc 1 3215 0
 4199 25a8 98B084E5 		str	fp, [r4, #152]
3214:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4200              		.loc 1 3214 0
 4201 25ac 5F36C2E5 		strb	r3, [r2, #1631]
3369:../uvc.c      ****         CyU3PThreadRelinquish ();
 4202              		.loc 1 3369 0
 4203 25b0 FEFFFFEB 		bl	_txe_thread_relinquish
 4204              	.LVL293:
 4205 25b4 2BFFFFEA 		b	.L414
 4206              	.LVL294:
 4207              	.L364:
 4208              	.LBB126:
 4209              	.LBB109:
2797:../uvc.c      ****     switch (wValue)
 4210              		.loc 1 2797 0
 4211 25b8 010B52E3 		cmp	r2, #1024
 4212 25bc 3800000A 		beq	.L362
 4213 25c0 050C52E3 		cmp	r2, #1280
 4214 25c4 5AFFFF1A 		bne	.L358
3009:../uvc.c      ****                 switch (bRequest)
 4215              		.loc 1 3009 0
 4216 25c8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4217 25cc 810052E3 		cmp	r2, #129
 4218 25d0 5700000A 		beq	.L403
 4219 25d4 1E01008A 		bhi	.L406
 4220 25d8 010052E3 		cmp	r2, #1
 4221 25dc 54FFFF1A 		bne	.L358
3034:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4222              		.loc 1 3034 0
 4223 25e0 2000A0E3 		mov	r0, #32
 4224 25e4 6C169FE5 		ldr	r1, .L437+44
 4225 25e8 36208DE2 		add	r2, sp, #54
 4226 25ec FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4227              	.LVL295:
3036:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4228              		.loc 1 3036 0
 4229 25f0 000050E3 		cmp	r0, #0
 4230 25f4 8601001A 		bne	.L408
3046:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4231              		.loc 1 3046 0
 4232 25f8 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 4233 25fc 040080E2 		add	r0, r0, #4
 4234              	.LVL296:
 4235 2600 54169FE5 		ldr	r1, .L437+48
 4236 2604 B623DDE1 		ldrh	r2, [sp, #54]
 4237 2608 FEFFFFEB 		bl	CyU3PDebugPrint
 4238              	.LVL297:
 4239 260c 30309DE5 		ldr	r3, [sp, #48]
 4240 2610 4CFFFFEA 		b	.L356
 4241              	.L312:
 4242              	.LBE109:
 4243              	.LBE126:
 4244              	.LBB127:
 4245              	.LBB91:
2402:../uvc.c      ****     switch (wValue)
 4246              		.loc 1 2402 0
 4247 2614 0A0C52E3 		cmp	r2, #2560
 4248 2618 F500000A 		beq	.L309
 4249 261c EA00008A 		bhi	.L314
 4250 2620 070C52E3 		cmp	r2, #1792
 4251 2624 E400000A 		beq	.L307
 4252 2628 020B52E3 		cmp	r2, #2048
 4253 262c 32FFFF1A 		bne	.L315
 4254              	.LVL298:
2433:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4255              		.loc 1 2433 0
 4256 2630 0700A0E3 		mov	r0, #7
 4257 2634 FEFFFFEB 		bl	ControlHandle
 4258              	.LVL299:
 4259 2638 30309DE5 		ldr	r3, [sp, #48]
 4260 263c 37FFFFEA 		b	.L294
 4261              	.L327:
 4262              	.LBE91:
 4263              	.LBE127:
 4264              	.LBB128:
 4265              	.LBB96:
2477:../uvc.c      ****     switch (wValue)
 4266              		.loc 1 2477 0
 4267 2640 090C52E3 		cmp	r2, #2304
 4268 2644 2601000A 		beq	.L323
 4269 2648 1B01008A 		bhi	.L329
 4270 264c 070C52E3 		cmp	r2, #1792
 4271 2650 0D01000A 		beq	.L322
 4272 2654 020B52E3 		cmp	r2, #2048
 4273 2658 27FFFF1A 		bne	.L315
 4274 265c 2FFFFFEA 		b	.L294
 4275              	.L351:
 4276              	.LBE96:
 4277              	.LBE128:
 4278              	.LBB129:
 4279              	.LBB119:
2702:../uvc.c      ****     switch (wValue)
 4280              		.loc 1 2702 0
 4281 2660 0F0C52E3 		cmp	r2, #3840
 4282 2664 5A01000A 		beq	.L346
 4283 2668 3D00008A 		bhi	.L354
 4284 266c 0B0C52E3 		cmp	r2, #2816
 4285 2670 5301000A 		beq	.L344
 4286 2674 0D0C52E3 		cmp	r2, #3328
 4287 2678 4D01000A 		beq	.L345
 4288 267c 0A0C52E3 		cmp	r2, #2560
 4289 2680 21FFFF1A 		bne	.L295
2745:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
 4290              		.loc 1 2745 0
 4291 2684 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4292 2688 00C0A0E3 		mov	ip, #0
 4293 268c 0400A0E3 		mov	r0, #4
 4294 2690 C8159FE5 		ldr	r1, .L437+52
 4295 2694 00C08DE5 		str	ip, [sp, #0]
 4296 2698 FEFFFFEB 		bl	CyU3PDebugPrint
 4297 269c 30309DE5 		ldr	r3, [sp, #48]
 4298 26a0 1EFFFFEA 		b	.L294
 4299              	.LVL300:
 4300              	.L362:
 4301              	.LBE119:
 4302              	.LBE129:
 4303              	.LBB130:
 4304              	.LBB106:
2954:../uvc.c      ****                 switch (bRequest)
 4305              		.loc 1 2954 0
 4306 26a4 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4307 26a8 81005BE3 		cmp	fp, #129
 4308 26ac 1300000A 		beq	.L394
 4309 26b0 8500008A 		bhi	.L397
 4310 26b4 01005BE3 		cmp	fp, #1
 4311 26b8 1DFFFF1A 		bne	.L358
2979:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4312              		.loc 1 2979 0
 4313 26bc 36208DE2 		add	r2, sp, #54
 4314 26c0 2000A0E3 		mov	r0, #32
 4315 26c4 8C159FE5 		ldr	r1, .L437+44
 4316 26c8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4317              	.LVL301:
2981:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4318              		.loc 1 2981 0
 4319 26cc 002050E2 		subs	r2, r0, #0
 4320 26d0 1BFFFF1A 		bne	.L418
2994:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4321              		.loc 1 2994 0
 4322 26d4 50059FE5 		ldr	r0, .L437
 4323              	.LVL302:
 4324 26d8 0B10A0E1 		mov	r1, fp
 4325 26dc FEFFFFEB 		bl	_txe_event_flags_set
 4326              	.LVL303:
2995:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4327              		.loc 1 2995 0
 4328 26e0 002050E2 		subs	r2, r0, #0
 4329 26e4 16FFFF0A 		beq	.L418
 4330 26e8 190100EA 		b	.L400
 4331              	.LVL304:
 4332              	.L361:
2905:../uvc.c      ****                 switch (bRequest)
 4333              		.loc 1 2905 0
 4334 26ec 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4335 26f0 830052E3 		cmp	r2, #131
 4336 26f4 9800008A 		bhi	.L388
 4337 26f8 810052E3 		cmp	r2, #129
 4338 26fc 7D00003A 		bcc	.L435
 4339              	.L394:
2966:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4340              		.loc 1 2966 0
 4341 2700 48B0D4E5 		ldrb	fp, [r4, #72]	@ zero_extendqisi2
2968:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4342              		.loc 1 2968 0
 4343 2704 0B00A0E3 		mov	r0, #11
2966:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4344              		.loc 1 2966 0
 4345 2708 03005BE3 		cmp	fp, #3
2968:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4346              		.loc 1 2968 0
 4347 270c 50159F05 		ldreq	r1, .L437+56
2972:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4348              		.loc 1 2972 0
 4349 2710 50159F15 		ldrne	r1, .L437+60
 4350 2714 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4351 2718 30309DE5 		ldr	r3, [sp, #48]
 4352 271c 09FFFFEA 		b	.L356
 4353              	.L359:
2800:../uvc.c      ****             switch (bRequest)
 4354              		.loc 1 2800 0
 4355 2720 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4356 2724 830052E3 		cmp	r2, #131
 4357 2728 2F00008A 		bhi	.L370
 4358 272c 810052E3 		cmp	r2, #129
 4359 2730 1400003A 		bcc	.L436
 4360              	.L403:
3021:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4361              		.loc 1 3021 0
 4362 2734 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3023:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4363              		.loc 1 3023 0
 4364 2738 1A00A0E3 		mov	r0, #26
3021:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4365              		.loc 1 3021 0
 4366 273c 030052E3 		cmp	r2, #3
3023:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4367              		.loc 1 3023 0
 4368 2740 24159F05 		ldreq	r1, .L437+64
3027:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4369              		.loc 1 3027 0
 4370 2744 24159F15 		ldrne	r1, .L437+68
 4371 2748 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4372 274c 30309DE5 		ldr	r3, [sp, #48]
 4373 2750 FCFEFFEA 		b	.L356
 4374              	.LVL305:
 4375              	.L321:
 4376              	.LBE106:
 4377              	.LBE130:
 4378              	.LBB131:
 4379              	.LBB99:
2503:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4380              		.loc 1 2503 0
 4381 2754 0500A0E3 		mov	r0, #5
 4382 2758 FEFFFFEB 		bl	CTControlHandle
 4383              	.LVL306:
 4384 275c 30309DE5 		ldr	r3, [sp, #48]
 4385 2760 EEFEFFEA 		b	.L294
 4386              	.L354:
 4387              	.LBE99:
 4388              	.LBE131:
 4389              	.LBB132:
 4390              	.LBB121:
2702:../uvc.c      ****     switch (wValue)
 4391              		.loc 1 2702 0
 4392 2764 110C52E3 		cmp	r2, #4352
 4393 2768 E900000A 		beq	.L348
 4394 276c 2D00008A 		bhi	.L355
 4395 2770 010A52E3 		cmp	r2, #4096
 4396 2774 E4FEFF1A 		bne	.L295
 4397              	.LVL307:
2765:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4398              		.loc 1 2765 0
 4399 2778 1F00A0E3 		mov	r0, #31
 4400 277c FEFFFFEB 		bl	ControlHandle
 4401              	.LVL308:
 4402 2780 30309DE5 		ldr	r3, [sp, #48]
 4403 2784 E5FEFFEA 		b	.L294
 4404              	.LVL309:
 4405              	.L436:
 4406              	.LBE121:
 4407              	.LBE132:
 4408              	.LBB133:
 4409              	.LBB110:
2800:../uvc.c      ****             switch (bRequest)
 4410              		.loc 1 2800 0
 4411 2788 010052E3 		cmp	r2, #1
 4412 278c 5FFFFF1A 		bne	.L383
2825:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4413              		.loc 1 2825 0
 4414 2790 2000A0E3 		mov	r0, #32
 4415 2794 BC149FE5 		ldr	r1, .L437+44
 4416 2798 36208DE2 		add	r2, sp, #54
 4417 279c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4418              	.LVL310:
2827:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4419              		.loc 1 2827 0
 4420 27a0 000050E3 		cmp	r0, #0
 4421 27a4 E6FEFF1A 		bne	.L418
2829:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4422              		.loc 1 2829 0
 4423 27a8 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 4424 27ac 030053E3 		cmp	r3, #3
 4425 27b0 E3FEFF1A 		bne	.L418
2833:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4426              		.loc 1 2833 0
 4427 27b4 7AE0D4E5 		ldrb	lr, [r4, #122]	@ zero_extendqisi2
2834:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4428              		.loc 1 2834 0
 4429 27b8 7BC0D4E5 		ldrb	ip, [r4, #123]	@ zero_extendqisi2
2835:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4430              		.loc 1 2835 0
 4431 27bc 7C00D4E5 		ldrb	r0, [r4, #124]	@ zero_extendqisi2
 4432              	.LVL311:
2836:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4433              		.loc 1 2836 0
 4434 27c0 7D10D4E5 		ldrb	r1, [r4, #125]	@ zero_extendqisi2
2837:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4435              		.loc 1 2837 0
 4436 27c4 7E20D4E5 		ldrb	r2, [r4, #126]	@ zero_extendqisi2
2838:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4437              		.loc 1 2838 0
 4438 27c8 7FB0D4E5 		ldrb	fp, [r4, #127]	@ zero_extendqisi2
2833:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4439              		.loc 1 2833 0
 4440 27cc 12E6C6E5 		strb	lr, [r6, #1554]
2834:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4441              		.loc 1 2834 0
 4442 27d0 13C6C6E5 		strb	ip, [r6, #1555]
2835:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4443              		.loc 1 2835 0
 4444 27d4 1406C6E5 		strb	r0, [r6, #1556]
2836:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4445              		.loc 1 2836 0
 4446 27d8 1516C6E5 		strb	r1, [r6, #1557]
2837:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4447              		.loc 1 2837 0
 4448 27dc 1626C6E5 		strb	r2, [r6, #1558]
2838:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4449              		.loc 1 2838 0
 4450 27e0 17B6C6E5 		strb	fp, [r6, #1559]
 4451 27e4 30309DE5 		ldr	r3, [sp, #48]
 4452 27e8 D6FEFFEA 		b	.L356
 4453              	.LVL312:
 4454              	.L370:
2800:../uvc.c      ****             switch (bRequest)
 4455              		.loc 1 2800 0
 4456 27ec 860052E3 		cmp	r2, #134
 4457 27f0 3900000A 		beq	.L421
 4458 27f4 870052E3 		cmp	r2, #135
 4459 27f8 CDFFFF0A 		beq	.L403
 4460              	.L427:
2905:../uvc.c      ****                 switch (bRequest)
 4461              		.loc 1 2905 0
 4462 27fc 850052E3 		cmp	r2, #133
 4463 2800 42FFFF1A 		bne	.L383
 4464              	.L395:
2963:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4465              		.loc 1 2963 0
 4466 2804 68149FE5 		ldr	r1, .L437+72
 4467 2808 0200A0E3 		mov	r0, #2
2961:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4468              		.loc 1 2961 0
 4469 280c 1A30A0E3 		mov	r3, #26
 4470              	.L419:
3016:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4471              		.loc 1 3016 0
 4472 2810 5830C4E5 		strb	r3, [r4, #88]
3017:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4473              		.loc 1 3017 0
 4474 2814 0030A0E3 		mov	r3, #0
 4475 2818 5930C4E5 		strb	r3, [r4, #89]
3018:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4476              		.loc 1 3018 0
 4477 281c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4478 2820 30309DE5 		ldr	r3, [sp, #48]
 4479 2824 C7FEFFEA 		b	.L356
 4480              	.LVL313:
 4481              	.L355:
 4482              	.LBE110:
 4483              	.LBE133:
 4484              	.LBB134:
 4485              	.LBB118:
2702:../uvc.c      ****     switch (wValue)
 4486              		.loc 1 2702 0
 4487 2828 120C52E3 		cmp	r2, #4608
 4488 282c DC00000A 		beq	.L349
 4489 2830 130C52E3 		cmp	r2, #4864
 4490 2834 B4FEFF1A 		bne	.L295
 4491              	.LVL314:
2777:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4492              		.loc 1 2777 0
 4493 2838 2200A0E3 		mov	r0, #34
 4494 283c FEFFFFEB 		bl	ControlHandle
 4495              	.LVL315:
 4496 2840 30309DE5 		ldr	r3, [sp, #48]
 4497 2844 B5FEFFEA 		b	.L294
 4498              	.L328:
 4499              	.LBE118:
 4500              	.LBE134:
 4501              	.LBB135:
 4502              	.LBB95:
2477:../uvc.c      ****     switch (wValue)
 4503              		.loc 1 2477 0
 4504 2848 010B52E3 		cmp	r2, #1024
 4505 284c 0900000A 		beq	.L319
 4506 2850 050C52E3 		cmp	r2, #1280
 4507 2854 A8FEFF1A 		bne	.L315
 4508              	.LVL316:
2499:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4509              		.loc 1 2499 0
 4510 2858 0400A0E3 		mov	r0, #4
 4511 285c FEFFFFEB 		bl	CTControlHandle
 4512              	.LVL317:
 4513 2860 30309DE5 		ldr	r3, [sp, #48]
 4514 2864 ADFEFFEA 		b	.L294
 4515              	.L318:
 4516              	.LVL318:
2489:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4517              		.loc 1 2489 0
 4518 2868 0200A0E3 		mov	r0, #2
 4519 286c FEFFFFEB 		bl	CTControlHandle
 4520              	.LVL319:
 4521 2870 30309DE5 		ldr	r3, [sp, #48]
 4522 2874 A9FEFFEA 		b	.L294
 4523              	.L319:
 4524              	.LVL320:
2494:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4525              		.loc 1 2494 0
 4526 2878 0300A0E3 		mov	r0, #3
 4527 287c FEFFFFEB 		bl	CTControlHandle
 4528              	.LVL321:
 4529 2880 30309DE5 		ldr	r3, [sp, #48]
 4530 2884 A5FEFFEA 		b	.L294
 4531              	.L430:
 4532              	.LVL322:
 4533              	.LBE95:
 4534              	.LBE135:
 4535              	.LBB136:
 4536              	.LBB89:
2410:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4537              		.loc 1 2410 0
 4538 2888 0100A0E3 		mov	r0, #1
 4539 288c FEFFFFEB 		bl	ControlHandle
 4540              	.LVL323:
 4541 2890 30309DE5 		ldr	r3, [sp, #48]
 4542 2894 A1FEFFEA 		b	.L294
 4543              	.L302:
 4544              	.LVL324:
2406:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4545              		.loc 1 2406 0
 4546 2898 0000A0E3 		mov	r0, #0
 4547 289c FEFFFFEB 		bl	ControlHandle
 4548              	.LVL325:
 4549 28a0 30309DE5 		ldr	r3, [sp, #48]
 4550 28a4 9DFEFFEA 		b	.L294
 4551              	.LVL326:
 4552              	.L434:
 4553              	.LBE89:
 4554              	.LBE136:
3210:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4555              		.loc 1 3210 0
 4556 28a8 0400A0E3 		mov	r0, #4
 4557              	.LVL327:
 4558 28ac C4139FE5 		ldr	r1, .L437+76
 4559 28b0 FEFFFFEB 		bl	CyU3PDebugPrint
 4560              	.LVL328:
 4561              	.L413:
 4562              	.LBB137:
 4563              	.LBB138:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4564              		.loc 1 1223 0
 4565 28b4 C0139FE5 		ldr	r1, .L437+80
 4566 28b8 0400A0E3 		mov	r0, #4
 4567 28bc FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 4568              		.loc 1 1224 0
 4569 28c0 FA0FA0E3 		mov	r0, #1000
 4570 28c4 FEFFFFEB 		bl	_tx_thread_sleep
 4571 28c8 F9FFFFEA 		b	.L413
 4572              	.LVL329:
 4573              	.L397:
 4574              	.LBE138:
 4575              	.LBE137:
 4576              	.LBB139:
 4577              	.LBB105:
2954:../uvc.c      ****                 switch (bRequest)
 4578              		.loc 1 2954 0
 4579 28cc 85005BE3 		cmp	fp, #133
 4580 28d0 CBFFFF0A 		beq	.L395
 4581 28d4 86005BE3 		cmp	fp, #134
 4582 28d8 95FEFF1A 		bne	.L358
 4583              	.L421:
2958:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4584              		.loc 1 2958 0
 4585 28dc 0300A0E1 		mov	r0, r3
 4586              	.L416:
2852:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4587              		.loc 1 2852 0
 4588 28e0 0330A0E3 		mov	r3, #3
2853:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4589              		.loc 1 2853 0
 4590 28e4 88139FE5 		ldr	r1, .L437+72
2852:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4591              		.loc 1 2852 0
 4592 28e8 5830C4E5 		strb	r3, [r4, #88]
2853:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4593              		.loc 1 2853 0
 4594 28ec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4595 28f0 30309DE5 		ldr	r3, [sp, #48]
 4596 28f4 93FEFFEA 		b	.L356
 4597              	.L435:
2905:../uvc.c      ****                 switch (bRequest)
 4598              		.loc 1 2905 0
 4599 28f8 010052E3 		cmp	r2, #1
 4600 28fc 03FFFF1A 		bne	.L383
2930:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4601              		.loc 1 2930 0
 4602 2900 2000A0E3 		mov	r0, #32
 4603 2904 4C139FE5 		ldr	r1, .L437+44
 4604 2908 36208DE2 		add	r2, sp, #54
 4605 290c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4606              	.LVL330:
2932:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4607              		.loc 1 2932 0
 4608 2910 000050E3 		cmp	r0, #0
 4609 2914 8AFEFF1A 		bne	.L418
2934:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4610              		.loc 1 2934 0
 4611 2918 48B0D5E5 		ldrb	fp, [r5, #72]	@ zero_extendqisi2
 4612 291c 03005BE3 		cmp	fp, #3
 4613 2920 87FEFF1A 		bne	.L418
2943:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4614              		.loc 1 2943 0
 4615 2924 7E30D5E5 		ldrb	r3, [r5, #126]	@ zero_extendqisi2
2938:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4616              		.loc 1 2938 0
 4617 2928 79E0D5E5 		ldrb	lr, [r5, #121]	@ zero_extendqisi2
2939:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4618              		.loc 1 2939 0
 4619 292c 7AC0D5E5 		ldrb	ip, [r5, #122]	@ zero_extendqisi2
2940:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4620              		.loc 1 2940 0
 4621 2930 7B00D5E5 		ldrb	r0, [r5, #123]	@ zero_extendqisi2
 4622              	.LVL331:
2941:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4623              		.loc 1 2941 0
 4624 2934 7C10D5E5 		ldrb	r1, [r5, #124]	@ zero_extendqisi2
2942:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4625              		.loc 1 2942 0
 4626 2938 7D20D5E5 		ldrb	r2, [r5, #125]	@ zero_extendqisi2
2943:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4627              		.loc 1 2943 0
 4628 293c 4E36C6E5 		strb	r3, [r6, #1614]
2938:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4629              		.loc 1 2938 0
 4630 2940 49E6C6E5 		strb	lr, [r6, #1609]
2939:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4631              		.loc 1 2939 0
 4632 2944 4AC6C6E5 		strb	ip, [r6, #1610]
2940:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4633              		.loc 1 2940 0
 4634 2948 4B06C6E5 		strb	r0, [r6, #1611]
2941:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4635              		.loc 1 2941 0
 4636 294c 4C16C6E5 		strb	r1, [r6, #1612]
2942:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4637              		.loc 1 2942 0
 4638 2950 4D26C6E5 		strb	r2, [r6, #1613]
2943:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4639              		.loc 1 2943 0
 4640 2954 30309DE5 		ldr	r3, [sp, #48]
 4641 2958 7AFEFFEA 		b	.L356
 4642              	.LVL332:
 4643              	.L388:
2905:../uvc.c      ****                 switch (bRequest)
 4644              		.loc 1 2905 0
 4645 295c 860052E3 		cmp	r2, #134
 4646 2960 DDFFFF0A 		beq	.L421
 4647 2964 870052E3 		cmp	r2, #135
 4648 2968 A3FFFF1A 		bne	.L427
 4649 296c 63FFFFEA 		b	.L394
 4650              	.LVL333:
 4651              	.L316:
 4652              	.LBE105:
 4653              	.LBE139:
 4654              	.LBB140:
 4655              	.LBB100:
2481:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4656              		.loc 1 2481 0
 4657 2970 0000A0E3 		mov	r0, #0
 4658 2974 FEFFFFEB 		bl	CTControlHandle
 4659              	.LVL334:
 4660 2978 30309DE5 		ldr	r3, [sp, #48]
 4661 297c 67FEFFEA 		b	.L294
 4662              	.LVL335:
 4663              	.L432:
 4664              	.LBE100:
 4665              	.LBE140:
3186:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4666              		.loc 1 3186 0
 4667 2980 0400A0E3 		mov	r0, #4
 4668              	.LVL336:
 4669 2984 EC129FE5 		ldr	r1, .L437+76
 4670 2988 FEFFFFEB 		bl	CyU3PDebugPrint
 4671              	.LVL337:
 4672              	.L411:
 4673              	.LBB141:
 4674              	.LBB142:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4675              		.loc 1 1223 0
 4676 298c E8129FE5 		ldr	r1, .L437+80
 4677 2990 0400A0E3 		mov	r0, #4
 4678 2994 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 4679              		.loc 1 1224 0
 4680 2998 FA0FA0E3 		mov	r0, #1000
 4681 299c FEFFFFEB 		bl	_tx_thread_sleep
 4682 29a0 F9FFFFEA 		b	.L411
 4683              	.LVL338:
 4684              	.L379:
 4685              	.LBE142:
 4686              	.LBE141:
 4687              	.LBB143:
 4688              	.LBB111:
2849:../uvc.c      ****             switch (bRequest)
 4689              		.loc 1 2849 0
 4690 29a4 850053E3 		cmp	r3, #133
 4691 29a8 95FFFF0A 		beq	.L395
 4692 29ac 860053E3 		cmp	r3, #134
 4693 29b0 D6FEFF1A 		bne	.L383
 4694              	.L422:
2853:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4695              		.loc 1 2853 0
 4696 29b4 0100A0E3 		mov	r0, #1
 4697 29b8 C8FFFFEA 		b	.L416
 4698              	.LVL339:
 4699              	.L307:
 4700              	.LBE111:
 4701              	.LBE143:
 4702              	.LBB144:
 4703              	.LBB92:
2429:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4704              		.loc 1 2429 0
 4705 29bc 0600A0E3 		mov	r0, #6
 4706 29c0 FEFFFFEB 		bl	ControlHandle
 4707              	.LVL340:
 4708 29c4 30309DE5 		ldr	r3, [sp, #48]
 4709 29c8 54FEFFEA 		b	.L294
 4710              	.L314:
2402:../uvc.c      ****     switch (wValue)
 4711              		.loc 1 2402 0
 4712 29cc 0D0C52E3 		cmp	r2, #3328
 4713 29d0 0700000A 		beq	.L309
 4714 29d4 0E0C52E3 		cmp	r2, #3584
 4715 29d8 0900000A 		beq	.L311
 4716 29dc 030B52E3 		cmp	r2, #3072
 4717 29e0 45FEFF1A 		bne	.L315
 4718              	.LVL341:
2443:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4719              		.loc 1 2443 0
 4720 29e4 0B00A0E3 		mov	r0, #11
 4721 29e8 FEFFFFEB 		bl	ControlHandle
 4722              	.LVL342:
 4723 29ec 30309DE5 		ldr	r3, [sp, #48]
 4724 29f0 4AFEFFEA 		b	.L294
 4725              	.L309:
 4726              	.LVL343:
2439:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4727              		.loc 1 2439 0
 4728 29f4 0900A0E3 		mov	r0, #9
 4729 29f8 FEFFFFEB 		bl	ControlHandle
 4730              	.LVL344:
 4731 29fc 30309DE5 		ldr	r3, [sp, #48]
 4732 2a00 46FEFFEA 		b	.L294
 4733              	.L311:
 4734              	.LVL345:
2447:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4735              		.loc 1 2447 0
 4736 2a04 0E00A0E3 		mov	r0, #14
 4737 2a08 FEFFFFEB 		bl	ControlHandle
 4738              	.LVL346:
 4739 2a0c 30309DE5 		ldr	r3, [sp, #48]
 4740 2a10 42FEFFEA 		b	.L294
 4741              	.L313:
2402:../uvc.c      ****     switch (wValue)
 4742              		.loc 1 2402 0
 4743 2a14 010B52E3 		cmp	r2, #1024
 4744 2a18 40FEFF0A 		beq	.L294
 4745 2a1c 050C52E3 		cmp	r2, #1280
 4746 2a20 35FEFF1A 		bne	.L315
 4747              	.LVL347:
2421:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4748              		.loc 1 2421 0
 4749 2a24 0400A0E3 		mov	r0, #4
 4750 2a28 FEFFFFEB 		bl	ControlHandle
 4751              	.LVL348:
 4752 2a2c 30309DE5 		ldr	r3, [sp, #48]
 4753 2a30 3AFEFFEA 		b	.L294
 4754              	.L304:
 4755              	.LVL349:
2414:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4756              		.loc 1 2414 0
 4757 2a34 0200A0E3 		mov	r0, #2
 4758 2a38 FEFFFFEB 		bl	ControlHandle
 4759              	.LVL350:
 4760 2a3c 30309DE5 		ldr	r3, [sp, #48]
 4761 2a40 36FEFFEA 		b	.L294
 4762              	.L306:
 4763              	.LVL351:
2425:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4764              		.loc 1 2425 0
 4765 2a44 0500A0E3 		mov	r0, #5
 4766 2a48 FEFFFFEB 		bl	ControlHandle
 4767              	.LVL352:
 4768 2a4c 30309DE5 		ldr	r3, [sp, #48]
 4769 2a50 32FEFFEA 		b	.L294
 4770              	.LVL353:
 4771              	.L406:
 4772              	.LBE92:
 4773              	.LBE144:
 4774              	.LBB145:
 4775              	.LBB104:
3009:../uvc.c      ****                 switch (bRequest)
 4776              		.loc 1 3009 0
 4777 2a54 850052E3 		cmp	r2, #133
 4778 2a58 4E00000A 		beq	.L404
 4779 2a5c 860052E3 		cmp	r2, #134
 4780 2a60 33FEFF1A 		bne	.L358
 4781 2a64 D2FFFFEA 		b	.L422
 4782              	.LVL354:
 4783              	.L352:
 4784              	.LBE104:
 4785              	.LBE145:
 4786              	.LBB146:
 4787              	.LBB122:
2702:../uvc.c      ****     switch (wValue)
 4788              		.loc 1 2702 0
 4789 2a68 060C52E3 		cmp	r2, #1536
 4790 2a6c 4500000A 		beq	.L339
 4791 2a70 0900008A 		bhi	.L353
 4792 2a74 050C52E3 		cmp	r2, #1280
 4793 2a78 23FEFF1A 		bne	.L295
 4794              	.LVL355:
2722:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4795              		.loc 1 2722 0
 4796 2a7c 1400A0E3 		mov	r0, #20
 4797 2a80 FEFFFFEB 		bl	ControlHandle
 4798              	.LVL356:
 4799 2a84 30309DE5 		ldr	r3, [sp, #48]
 4800 2a88 24FEFFEA 		b	.L294
 4801              	.L322:
 4802              	.LVL357:
 4803              	.LBE122:
 4804              	.LBE146:
 4805              	.LBB147:
 4806              	.LBB94:
2507:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 4807              		.loc 1 2507 0
 4808 2a8c 0600A0E3 		mov	r0, #6
 4809 2a90 FEFFFFEB 		bl	CTControlHandle
 4810              	.LVL358:
 4811 2a94 30309DE5 		ldr	r3, [sp, #48]
 4812 2a98 20FEFFEA 		b	.L294
 4813              	.L353:
 4814              	.LBE94:
 4815              	.LBE147:
 4816              	.LBB148:
 4817              	.LBB117:
2702:../uvc.c      ****     switch (wValue)
 4818              		.loc 1 2702 0
 4819 2a9c 070C52E3 		cmp	r2, #1792
 4820 2aa0 3400000A 		beq	.L340
 4821 2aa4 020B52E3 		cmp	r2, #2048
 4822 2aa8 17FEFF1A 		bne	.L295
 4823              	.LVL359:
2734:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 4824              		.loc 1 2734 0
 4825 2aac 1700A0E3 		mov	r0, #23
 4826 2ab0 FEFFFFEB 		bl	ControlHandle
 4827              	.LVL360:
 4828 2ab4 30309DE5 		ldr	r3, [sp, #48]
 4829 2ab8 18FEFFEA 		b	.L294
 4830              	.L329:
 4831              	.LBE117:
 4832              	.LBE148:
 4833              	.LBB149:
 4834              	.LBB101:
2477:../uvc.c      ****     switch (wValue)
 4835              		.loc 1 2477 0
 4836 2abc 0B0C52E3 		cmp	r2, #2816
 4837 2ac0 0F00000A 		beq	.L325
 4838 2ac4 030B52E3 		cmp	r2, #3072
 4839 2ac8 0900000A 		beq	.L326
 4840 2acc 0A0C52E3 		cmp	r2, #2560
 4841 2ad0 09FEFF1A 		bne	.L315
 4842              	.LVL361:
2518:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 4843              		.loc 1 2518 0
 4844 2ad4 0800A0E3 		mov	r0, #8
 4845 2ad8 FEFFFFEB 		bl	CTControlHandle
 4846              	.LVL362:
 4847 2adc 30309DE5 		ldr	r3, [sp, #48]
 4848 2ae0 0EFEFFEA 		b	.L294
 4849              	.L323:
 4850              	.LVL363:
2513:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 4851              		.loc 1 2513 0
 4852 2ae4 0700A0E3 		mov	r0, #7
 4853 2ae8 FEFFFFEB 		bl	CTControlHandle
 4854              	.LVL364:
 4855 2aec 30309DE5 		ldr	r3, [sp, #48]
 4856 2af0 0AFEFFEA 		b	.L294
 4857              	.L326:
 4858              	.LVL365:
2526:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 4859              		.loc 1 2526 0
 4860 2af4 0A00A0E3 		mov	r0, #10
 4861 2af8 FEFFFFEB 		bl	CTControlHandle
 4862              	.LVL366:
 4863 2afc 30309DE5 		ldr	r3, [sp, #48]
 4864 2b00 06FEFFEA 		b	.L294
 4865              	.L325:
 4866              	.LVL367:
2522:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 4867              		.loc 1 2522 0
 4868 2b04 0900A0E3 		mov	r0, #9
 4869 2b08 FEFFFFEB 		bl	CTControlHandle
 4870              	.LVL368:
 4871 2b0c 30309DE5 		ldr	r3, [sp, #48]
 4872 2b10 02FEFFEA 		b	.L294
 4873              	.L348:
 4874              	.LVL369:
 4875              	.LBE101:
 4876              	.LBE149:
 4877              	.LBB150:
 4878              	.LBB123:
2769:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 4879              		.loc 1 2769 0
 4880 2b14 2000A0E3 		mov	r0, #32
 4881 2b18 FEFFFFEB 		bl	ControlHandle
 4882              	.LVL370:
 4883 2b1c 30309DE5 		ldr	r3, [sp, #48]
 4884 2b20 FEFDFFEA 		b	.L294
 4885              	.LVL371:
 4886              	.L433:
 4887              	.LBE123:
 4888              	.LBE150:
 4889              	.LBB151:
 4890              	.LBB112:
2874:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4891              		.loc 1 2874 0
 4892 2b24 2000A0E3 		mov	r0, #32
 4893 2b28 28119FE5 		ldr	r1, .L437+44
 4894 2b2c 36208DE2 		add	r2, sp, #54
 4895 2b30 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4896              	.LVL372:
2876:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4897              		.loc 1 2876 0
 4898 2b34 000050E3 		cmp	r0, #0
 4899 2b38 01FEFF1A 		bne	.L418
2889:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 4900              		.loc 1 2889 0
 4901 2b3c 0020A0E3 		mov	r2, #0
 4902 2b40 E4009FE5 		ldr	r0, .L437
 4903              	.LVL373:
 4904 2b44 0110A0E3 		mov	r1, #1
 4905 2b48 FEFFFFEB 		bl	_txe_event_flags_set
 4906              	.LVL374:
2890:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 4907              		.loc 1 2890 0
 4908 2b4c 002050E2 		subs	r2, r0, #0
 4909 2b50 FBFDFF0A 		beq	.L418
 4910              	.L400:
2997:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4911              		.loc 1 2997 0
 4912 2b54 0400A0E3 		mov	r0, #4
 4913              	.LVL375:
 4914 2b58 20119FE5 		ldr	r1, .L437+84
 4915 2b5c FEFFFFEB 		bl	CyU3PDebugPrint
 4916              	.LVL376:
 4917 2b60 30309DE5 		ldr	r3, [sp, #48]
 4918 2b64 F7FDFFEA 		b	.L356
 4919              	.L336:
 4920              	.LVL377:
 4921              	.LBE112:
 4922              	.LBE151:
 4923              	.LBB152:
 4924              	.LBB116:
2714:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 4925              		.loc 1 2714 0
 4926 2b68 1200A0E3 		mov	r0, #18
 4927 2b6c FEFFFFEB 		bl	ControlHandle
 4928              	.LVL378:
 4929 2b70 30309DE5 		ldr	r3, [sp, #48]
 4930 2b74 E9FDFFEA 		b	.L294
 4931              	.L340:
 4932              	.LVL379:
2730:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 4933              		.loc 1 2730 0
 4934 2b78 1600A0E3 		mov	r0, #22
 4935 2b7c FEFFFFEB 		bl	ControlHandle
 4936              	.LVL380:
 4937 2b80 30309DE5 		ldr	r3, [sp, #48]
 4938 2b84 E5FDFFEA 		b	.L294
 4939              	.L339:
 4940              	.LVL381:
2726:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 4941              		.loc 1 2726 0
 4942 2b88 1500A0E3 		mov	r0, #21
 4943 2b8c FEFFFFEB 		bl	ControlHandle
 4944              	.LVL382:
 4945 2b90 30309DE5 		ldr	r3, [sp, #48]
 4946 2b94 E1FDFFEA 		b	.L294
 4947              	.LVL383:
 4948              	.L404:
 4949              	.LBE116:
 4950              	.LBE152:
 4951              	.LBB153:
 4952              	.LBB103:
3018:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4953              		.loc 1 3018 0
 4954 2b98 0200A0E3 		mov	r0, #2
 4955 2b9c D0109FE5 		ldr	r1, .L437+72
 4956 2ba0 1AFFFFEA 		b	.L419
 4957              	.LVL384:
 4958              	.L349:
 4959              	.LBE103:
 4960              	.LBE153:
 4961              	.LBB154:
 4962              	.LBB124:
2773:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 4963              		.loc 1 2773 0
 4964 2ba4 2100A0E3 		mov	r0, #33
 4965 2ba8 FEFFFFEB 		bl	ControlHandle
 4966              	.LVL385:
 4967 2bac 30309DE5 		ldr	r3, [sp, #48]
 4968 2bb0 DAFDFFEA 		b	.L294
 4969              	.L345:
 4970              	.LVL386:
2753:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 4971              		.loc 1 2753 0
 4972 2bb4 1C00A0E3 		mov	r0, #28
 4973 2bb8 FEFFFFEB 		bl	ControlHandle
 4974              	.LVL387:
 4975 2bbc 30309DE5 		ldr	r3, [sp, #48]
 4976 2bc0 D6FDFFEA 		b	.L294
 4977              	.L344:
 4978              	.LVL388:
2749:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 4979              		.loc 1 2749 0
 4980 2bc4 1A00A0E3 		mov	r0, #26
 4981 2bc8 FEFFFFEB 		bl	ControlHandle
 4982              	.LVL389:
 4983 2bcc 30309DE5 		ldr	r3, [sp, #48]
 4984 2bd0 D2FDFFEA 		b	.L294
 4985              	.L346:
 4986              	.LVL390:
2761:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 4987              		.loc 1 2761 0
 4988 2bd4 1E00A0E3 		mov	r0, #30
 4989 2bd8 FEFFFFEB 		bl	ControlHandle
 4990              	.LVL391:
 4991 2bdc 30309DE5 		ldr	r3, [sp, #48]
 4992 2be0 CEFDFFEA 		b	.L294
 4993              	.L335:
 4994              	.LVL392:
2710:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 4995              		.loc 1 2710 0
 4996 2be4 1100A0E3 		mov	r0, #17
 4997 2be8 FEFFFFEB 		bl	ControlHandle
 4998              	.LVL393:
 4999 2bec 30309DE5 		ldr	r3, [sp, #48]
 5000 2bf0 CAFDFFEA 		b	.L294
 5001              	.L342:
 5002              	.LVL394:
2738:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5003              		.loc 1 2738 0
 5004 2bf4 1800A0E3 		mov	r0, #24
 5005 2bf8 FEFFFFEB 		bl	ControlHandle
 5006              	.LVL395:
 5007 2bfc 30309DE5 		ldr	r3, [sp, #48]
 5008 2c00 C6FDFFEA 		b	.L294
 5009              	.L337:
 5010              	.LVL396:
2718:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5011              		.loc 1 2718 0
 5012 2c04 1300A0E3 		mov	r0, #19
 5013 2c08 FEFFFFEB 		bl	ControlHandle
 5014              	.LVL397:
 5015 2c0c 30309DE5 		ldr	r3, [sp, #48]
 5016 2c10 C2FDFFEA 		b	.L294
 5017              	.LVL398:
 5018              	.L408:
 5019              	.LBE124:
 5020              	.LBE154:
 5021              	.LBB155:
 5022              	.LBB113:
3048:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5023              		.loc 1 3048 0
 5024 2c14 68109FE5 		ldr	r1, .L437+88
 5025 2c18 B623DDE1 		ldrh	r2, [sp, #54]
 5026 2c1c 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 5027 2c20 0400A0E3 		mov	r0, #4
 5028              	.LVL399:
 5029 2c24 FEFFFFEB 		bl	CyU3PDebugPrint
 5030 2c28 C1FDFFEA 		b	.L358
 5031              	.L438:
 5032              		.align	2
 5033              	.L437:
 5034 2c2c 00000000 		.word	.LANCHOR0
 5035 2c30 00000000 		.word	.LANCHOR1
 5036 2c34 00000000 		.word	bRequest
 5037 2c38 00000000 		.word	wValue
 5038 2c3c 00000000 		.word	wIndex
 5039 2c40 00000000 		.word	glInterStaBuffer
 5040 2c44 A8040000 		.word	.LC25
 5041 2c48 00000000 		.word	glChHandleInterStat
 5042 2c4c 00000000 		.word	bmReqType
 5043 2c50 00000000 		.word	wLength
 5044 2c54 2C040000 		.word	.LC24
 5045 2c58 78000000 		.word	.LANCHOR0+120
 5046 2c5c 3C050000 		.word	.LC28
 5047 2c60 D4040000 		.word	.LC26
 5048 2c64 48060000 		.word	.LANCHOR1+1608
 5049 2c68 54060000 		.word	.LANCHOR1+1620
 5050 2c6c 10060000 		.word	.LANCHOR1+1552
 5051 2c70 2C060000 		.word	.LANCHOR1+1580
 5052 2c74 58000000 		.word	.LANCHOR0+88
 5053 2c78 8C050000 		.word	.LC30
 5054 2c7c D4010000 		.word	.LC12
 5055 2c80 14050000 		.word	.LC27
 5056 2c84 64050000 		.word	.LC29
 5057              	.LBE113:
 5058              	.LBE155:
 5059              		.cfi_endproc
 5060              	.LFE24:
 5062              		.align	2
 5063              		.global	CamDefSet
 5065              	CamDefSet:
 5066              	.LFB4:
1120:../uvc.c      **** {
 5067              		.loc 1 1120 0
 5068              		.cfi_startproc
 5069              		@ args = 0, pretend = 0, frame = 24
 5070              		@ frame_needed = 0, uses_anonymous_args = 0
 5071              	.LVL400:
 5072 2c88 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5073              	.LCFI19:
 5074              		.cfi_def_cfa_offset 36
1126:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5075              		.loc 1 1126 0
 5076 2c8c AC429FE5 		ldr	r4, .L442
 5077              		.cfi_offset 14, -4
 5078              		.cfi_offset 11, -8
 5079              		.cfi_offset 10, -12
 5080              		.cfi_offset 9, -16
 5081              		.cfi_offset 8, -20
 5082              		.cfi_offset 7, -24
 5083              		.cfi_offset 6, -28
 5084              		.cfi_offset 5, -32
 5085              		.cfi_offset 4, -36
1131:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5086              		.loc 1 1131 0
 5087 2c90 AC229FE5 		ldr	r2, .L442+4
1128:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5088              		.loc 1 1128 0
 5089 2c94 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1120:../uvc.c      **** {
 5090              		.loc 1 1120 0
 5091 2c98 2CD04DE2 		sub	sp, sp, #44
 5092              	.LCFI20:
 5093              		.cfi_def_cfa_offset 80
1131:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5094              		.loc 1 1131 0
 5095 2c9c 1C0092E5 		ldr	r0, [r2, #28]
 5096 2ca0 0010E0E3 		mvn	r1, #0
1133:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5097              		.loc 1 1133 0
 5098 2ca4 2963A0E1 		mov	r6, r9, lsr #6
1127:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5099              		.loc 1 1127 0
 5100 2ca8 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1126:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5101              		.loc 1 1126 0
 5102 2cac 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5103              	.LVL401:
1131:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5104              		.loc 1 1131 0
 5105 2cb0 FEFFFFEB 		bl	_txe_mutex_get
1132:../uvc.c      ****     if(Data1&0x80){
 5106              		.loc 1 1132 0
 5107 2cb4 800019E3 		tst	r9, #128
1133:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5108              		.loc 1 1133 0
 5109 2cb8 01600612 		andne	r6, r6, #1
 5110 2cbc 0660E011 		mvnne	r6, r6
 5111 2cc0 3B600612 		andne	r6, r6, #59
 5112 2cc4 0660E011 		mvnne	r6, r6
 5113 2cc8 FF600612 		andne	r6, r6, #255
 5114              	.LVL402:
1135:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5115              		.loc 1 1135 0
 5116 2ccc C6608603 		orreq	r6, r6, #198
 5117              	.LVL403:
1139:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5118              		.loc 1 1139 0
 5119 2cd0 0080A0E3 		mov	r8, #0
 5120 2cd4 0A20A0E1 		mov	r2, sl
 5121 2cd8 0730A0E1 		mov	r3, r7
 5122 2cdc 0110A0E3 		mov	r1, #1
1137:../uvc.c      ****     Data0 = (Data0 << 2);
 5123              		.loc 1 1137 0
 5124 2ce0 0951A0E1 		mov	r5, r9, asl #2
1139:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5125              		.loc 1 1139 0
 5126 2ce4 58029FE5 		ldr	r0, .L442+4
1142:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5127              		.loc 1 1142 0
 5128 2ce8 0190A0E3 		mov	r9, #1
 5129              	.LVL404:
1137:../uvc.c      ****     Data0 = (Data0 << 2);
 5130              		.loc 1 1137 0
 5131 2cec FF5005E2 		and	r5, r5, #255
 5132              	.LVL405:
1139:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5133              		.loc 1 1139 0
 5134 2cf0 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5135 2cf4 FEFFFFEB 		bl	cmdSet
 5136              	.LVL406:
1142:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5137              		.loc 1 1142 0
 5138 2cf8 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5139 2cfc 0910A0E1 		mov	r1, r9
 5140 2d00 0730A0E1 		mov	r3, r7
 5141 2d04 38029FE5 		ldr	r0, .L442+4
 5142 2d08 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5143 2d0c FEFFFFEB 		bl	cmdSet
 5144              	.LVL407:
1145:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5145              		.loc 1 1145 0
 5146 2d10 0620A0E1 		mov	r2, r6
 5147 2d14 0530A0E1 		mov	r3, r5
 5148 2d18 28129FE5 		ldr	r1, .L442+8
 5149 2d1c 0400A0E3 		mov	r0, #4
1144:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5150              		.loc 1 1144 0
 5151 2d20 A661C4E5 		strb	r6, [r4, #422]
1143:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5152              		.loc 1 1143 0
 5153 2d24 A551C4E5 		strb	r5, [r4, #421]
1145:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5154              		.loc 1 1145 0
 5155 2d28 FEFFFFEB 		bl	CyU3PDebugPrint
 5156              	.LVL408:
1150:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5157              		.loc 1 1150 0
 5158 2d2c BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5159              	.LVL409:
1151:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5160              		.loc 1 1151 0
 5161 2d30 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5162 2d34 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5163 2d38 0210A0E3 		mov	r1, #2
 5164 2d3c 00029FE5 		ldr	r0, .L442+4
 5165 2d40 00B08DE5 		str	fp, [sp, #0]
 5166 2d44 04808DE5 		str	r8, [sp, #4]
 5167 2d48 FEFFFFEB 		bl	cmdSet
 5168              	.LVL410:
1153:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5169              		.loc 1 1153 0
 5170 2d4c 0B20A0E1 		mov	r2, fp
 5171 2d50 0530A0E1 		mov	r3, r5
 5172 2d54 EC119FE5 		ldr	r1, .L442+8
 5173 2d58 0400A0E3 		mov	r0, #4
1152:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5174              		.loc 1 1152 0
 5175 2d5c BD51C4E5 		strb	r5, [r4, #445]
1153:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5176              		.loc 1 1153 0
 5177 2d60 FEFFFFEB 		bl	CyU3PDebugPrint
 5178              	.LVL411:
1158:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5179              		.loc 1 1158 0
 5180 2d64 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1157:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5181              		.loc 1 1157 0
 5182 2d68 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5183              	.LVL412:
1159:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5184              		.loc 1 1159 0
 5185 2d6c 80B047E2 		sub	fp, r7, #128
 5186 2d70 FF100BE2 		and	r1, fp, #255
 5187 2d74 14108DE5 		str	r1, [sp, #20]
 5188 2d78 14C09DE5 		ldr	ip, [sp, #20]
1160:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5189              		.loc 1 1160 0
 5190 2d7c 760047E2 		sub	r0, r7, #118
1161:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5191              		.loc 1 1161 0
 5192 2d80 7EE087E2 		add	lr, r7, #126
1159:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5193              		.loc 1 1159 0
 5194 2d84 0630A0E1 		mov	r3, r6
1160:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5195              		.loc 1 1160 0
 5196 2d88 18008DE5 		str	r0, [sp, #24]
1159:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5197              		.loc 1 1159 0
 5198 2d8c 0510A0E3 		mov	r1, #5
 5199 2d90 DF20A0E3 		mov	r2, #223
 5200 2d94 A8019FE5 		ldr	r0, .L442+4
1161:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5201              		.loc 1 1161 0
 5202 2d98 1CE08DE5 		str	lr, [sp, #28]
1159:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5203              		.loc 1 1159 0
 5204 2d9c 00C08DE5 		str	ip, [sp, #0]
 5205 2da0 04808DE5 		str	r8, [sp, #4]
 5206 2da4 FEFFFFEB 		bl	cmdSet
 5207              	.LVL413:
1160:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5208              		.loc 1 1160 0
 5209 2da8 18A09DE5 		ldr	sl, [sp, #24]
1162:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5210              		.loc 1 1162 0
 5211 2dac 72E087E2 		add	lr, r7, #114
1160:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5212              		.loc 1 1160 0
 5213 2db0 FFC00AE2 		and	ip, sl, #255
 5214 2db4 0630A0E1 		mov	r3, r6
 5215 2db8 0510A0E3 		mov	r1, #5
 5216 2dbc DC20A0E3 		mov	r2, #220
 5217 2dc0 7C019FE5 		ldr	r0, .L442+4
1162:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5218              		.loc 1 1162 0
 5219 2dc4 20E08DE5 		str	lr, [sp, #32]
1160:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5220              		.loc 1 1160 0
 5221 2dc8 00C08DE5 		str	ip, [sp, #0]
 5222 2dcc 04908DE5 		str	r9, [sp, #4]
 5223 2dd0 FEFFFFEB 		bl	cmdSet
1161:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5224              		.loc 1 1161 0
 5225 2dd4 1C009DE5 		ldr	r0, [sp, #28]
 5226 2dd8 02E0A0E3 		mov	lr, #2
 5227 2ddc FFC000E2 		and	ip, r0, #255
 5228 2de0 0630A0E1 		mov	r3, r6
1163:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5229              		.loc 1 1163 0
 5230 2de4 6FA047E2 		sub	sl, r7, #111
1161:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5231              		.loc 1 1161 0
 5232 2de8 0510A0E3 		mov	r1, #5
 5233 2dec DE20A0E3 		mov	r2, #222
 5234 2df0 4C019FE5 		ldr	r0, .L442+4
 5235 2df4 04E08DE5 		str	lr, [sp, #4]
1163:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5236              		.loc 1 1163 0
 5237 2df8 24A08DE5 		str	sl, [sp, #36]
1161:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5238              		.loc 1 1161 0
 5239 2dfc 00C08DE5 		str	ip, [sp, #0]
 5240 2e00 FEFFFFEB 		bl	cmdSet
1162:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5241              		.loc 1 1162 0
 5242 2e04 20A09DE5 		ldr	sl, [sp, #32]
 5243 2e08 0630A0E1 		mov	r3, r6
 5244 2e0c FFC00AE2 		and	ip, sl, #255
 5245 2e10 00C08DE5 		str	ip, [sp, #0]
 5246 2e14 0510A0E3 		mov	r1, #5
 5247 2e18 03C0A0E3 		mov	ip, #3
 5248 2e1c E020A0E3 		mov	r2, #224
 5249 2e20 1C019FE5 		ldr	r0, .L442+4
 5250 2e24 04C08DE5 		str	ip, [sp, #4]
 5251 2e28 FEFFFFEB 		bl	cmdSet
1163:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5252              		.loc 1 1163 0
 5253 2e2c 24009DE5 		ldr	r0, [sp, #36]
 5254 2e30 04A0A0E3 		mov	sl, #4
 5255 2e34 FFC000E2 		and	ip, r0, #255
 5256 2e38 0630A0E1 		mov	r3, r6
 5257 2e3c 0510A0E3 		mov	r1, #5
 5258 2e40 DD20A0E3 		mov	r2, #221
 5259 2e44 F8009FE5 		ldr	r0, .L442+4
 5260 2e48 00C08DE5 		str	ip, [sp, #0]
1164:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5261              		.loc 1 1164 0
 5262 2e4c 7F7087E2 		add	r7, r7, #127
 5263              	.LVL414:
1163:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5264              		.loc 1 1163 0
 5265 2e50 04A08DE5 		str	sl, [sp, #4]
 5266 2e54 FEFFFFEB 		bl	cmdSet
1164:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5267              		.loc 1 1164 0
 5268 2e58 05E0A0E3 		mov	lr, #5
 5269 2e5c 0E10A0E1 		mov	r1, lr
 5270 2e60 0630A0E1 		mov	r3, r6
 5271 2e64 E120A0E3 		mov	r2, #225
 5272 2e68 FF6007E2 		and	r6, r7, #255
 5273              	.LVL415:
 5274 2e6c D0009FE5 		ldr	r0, .L442+4
 5275 2e70 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5276 2e74 FEFFFFEB 		bl	cmdSet
 5277              	.LVL416:
1165:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5278              		.loc 1 1165 0
 5279 2e78 14C09DE5 		ldr	ip, [sp, #20]
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5280              		.loc 1 1166 0
 5281 2e7c 24E09DE5 		ldr	lr, [sp, #36]
 5282 2e80 1C609DE5 		ldr	r6, [sp, #28]
1165:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5283              		.loc 1 1165 0
 5284 2e84 05C2C4E5 		strb	ip, [r4, #517]
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5285              		.loc 1 1166 0
 5286 2e88 20C09DE5 		ldr	ip, [sp, #32]
 5287 2e8c 0B20A0E1 		mov	r2, fp
 5288 2e90 18309DE5 		ldr	r3, [sp, #24]
 5289 2e94 B0109FE5 		ldr	r1, .L442+12
 5290 2e98 0A00A0E1 		mov	r0, sl
 5291 2e9c 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5292 2ea0 0C708DE5 		str	r7, [sp, #12]
 5293 2ea4 FEFFFFEB 		bl	CyU3PDebugPrint
 5294              	.LVL417:
1170:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5295              		.loc 1 1170 0
 5296 2ea8 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5297              	.LVL418:
1171:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5298              		.loc 1 1171 0
 5299 2eac 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5300              	.LVL419:
1172:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5301              		.loc 1 1172 0
 5302 2eb0 0730A0E1 		mov	r3, r7
 5303 2eb4 0610A0E3 		mov	r1, #6
 5304 2eb8 8520A0E3 		mov	r2, #133
 5305 2ebc 80009FE5 		ldr	r0, .L442+4
 5306 2ec0 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5307 2ec4 FEFFFFEB 		bl	cmdSet
1173:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5308              		.loc 1 1173 0
 5309 2ec8 0730A0E1 		mov	r3, r7
 5310 2ecc 0610A0E3 		mov	r1, #6
 5311 2ed0 8620A0E3 		mov	r2, #134
 5312 2ed4 68009FE5 		ldr	r0, .L442+4
 5313 2ed8 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5314 2edc FEFFFFEB 		bl	cmdSet
1175:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5315              		.loc 1 1175 0
 5316 2ee0 0620A0E1 		mov	r2, r6
 5317 2ee4 0530A0E1 		mov	r3, r5
 5318 2ee8 58109FE5 		ldr	r1, .L442+8
 5319 2eec 0A00A0E1 		mov	r0, sl
1174:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5320              		.loc 1 1174 0
 5321 2ef0 1D62C4E5 		strb	r6, [r4, #541]
1175:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5322              		.loc 1 1175 0
 5323 2ef4 FEFFFFEB 		bl	CyU3PDebugPrint
 5324              	.LVL420:
1180:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5325              		.loc 1 1180 0
 5326 2ef8 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5327              	.LVL421:
1181:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5328              		.loc 1 1181 0
 5329 2efc 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5330 2f00 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5331 2f04 0710A0E3 		mov	r1, #7
 5332 2f08 34009FE5 		ldr	r0, .L442+4
 5333 2f0c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5334 2f10 FEFFFFEB 		bl	cmdSet
 5335              	.LVL422:
1183:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5336              		.loc 1 1183 0
 5337 2f14 0530A0E1 		mov	r3, r5
 5338 2f18 0A00A0E1 		mov	r0, sl
 5339 2f1c 24109FE5 		ldr	r1, .L442+8
 5340 2f20 0620A0E1 		mov	r2, r6
1182:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5341              		.loc 1 1182 0
 5342 2f24 3552C4E5 		strb	r5, [r4, #565]
1183:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5343              		.loc 1 1183 0
 5344 2f28 FEFFFFEB 		bl	CyU3PDebugPrint
1185:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5345              		.loc 1 1185 0
 5346 2f2c 10309FE5 		ldr	r3, .L442+4
 5347 2f30 1C0093E5 		ldr	r0, [r3, #28]
1188:../uvc.c      **** }
 5348              		.loc 1 1188 0
 5349 2f34 2CD08DE2 		add	sp, sp, #44
 5350 2f38 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1185:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5351              		.loc 1 1185 0
 5352 2f3c FEFFFFEA 		b	_txe_mutex_put
 5353              	.L443:
 5354              		.align	2
 5355              	.L442:
 5356 2f40 00000000 		.word	.LANCHOR1
 5357 2f44 00000000 		.word	cmdQu
 5358 2f48 C0050000 		.word	.LC31
 5359 2f4c E0050000 		.word	.LC32
 5360              		.cfi_endproc
 5361              	.LFE4:
 5363              		.align	2
 5364              		.global	CyFxUVCAddHeader
 5366              	CyFxUVCAddHeader:
 5367              	.LFB5:
1196:../uvc.c      **** {
 5368              		.loc 1 1196 0
 5369              		.cfi_startproc
 5370              		@ args = 0, pretend = 0, frame = 0
 5371              		@ frame_needed = 0, uses_anonymous_args = 0
 5372              	.LVL423:
 5373 2f50 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5374              	.LCFI21:
 5375              		.cfi_def_cfa_offset 16
1198:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5376              		.loc 1 1198 0
 5377 2f54 0C20A0E3 		mov	r2, #12
1196:../uvc.c      **** {
 5378              		.loc 1 1196 0
 5379 2f58 0150A0E1 		mov	r5, r1
 5380              		.cfi_offset 14, -4
 5381              		.cfi_offset 5, -8
 5382              		.cfi_offset 4, -12
 5383              		.cfi_offset 3, -16
1198:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5384              		.loc 1 1198 0
 5385 2f5c 18109FE5 		ldr	r1, .L446
 5386              	.LVL424:
1196:../uvc.c      **** {
 5387              		.loc 1 1196 0
 5388 2f60 0040A0E1 		mov	r4, r0
1198:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5389              		.loc 1 1198 0
 5390 2f64 FEFFFFEB 		bl	CyU3PMemCopy
 5391              	.LVL425:
1201:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5392              		.loc 1 1201 0
 5393 2f68 020015E3 		tst	r5, #2
1203:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5394              		.loc 1 1203 0
 5395 2f6c 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5396 2f70 02308313 		orrne	r3, r3, #2
 5397 2f74 0130C415 		strneb	r3, [r4, #1]
 5398 2f78 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5399              	.L447:
 5400              		.align	2
 5401              	.L446:
 5402 2f7c 80040000 		.word	.LANCHOR1+1152
 5403              		.cfi_endproc
 5404              	.LFE5:
 5406              		.align	2
 5407              		.global	CyFxAppErrorHandler
 5409              	CyFxAppErrorHandler:
 5410              	.LFB6:
1213:../uvc.c      **** {
 5411              		.loc 1 1213 0
 5412              		.cfi_startproc
 5413              		@ args = 0, pretend = 0, frame = 0
 5414              		@ frame_needed = 0, uses_anonymous_args = 0
 5415              	.LVL426:
 5416 2f80 08402DE9 		stmfd	sp!, {r3, lr}
 5417              	.LCFI22:
 5418              		.cfi_def_cfa_offset 8
 5419              	.LVL427:
 5420              	.L449:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5421              		.loc 1 1223 0 discriminator 1
 5422 2f84 10109FE5 		ldr	r1, .L450
 5423 2f88 0400A0E3 		mov	r0, #4
 5424              		.cfi_offset 14, -4
 5425              		.cfi_offset 3, -8
 5426 2f8c FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 5427              		.loc 1 1224 0 discriminator 1
 5428 2f90 FA0FA0E3 		mov	r0, #1000
 5429 2f94 FEFFFFEB 		bl	_tx_thread_sleep
 5430 2f98 F9FFFFEA 		b	.L449
 5431              	.L451:
 5432              		.align	2
 5433              	.L450:
 5434 2f9c D4010000 		.word	.LC12
 5435              		.cfi_endproc
 5436              	.LFE6:
 5438              		.align	2
 5439              		.global	UVCAppThread_Entry
 5441              	UVCAppThread_Entry:
 5442              	.LFB18:
2168:../uvc.c      **** {
 5443              		.loc 1 2168 0
 5444              		.cfi_startproc
 5445              		@ args = 0, pretend = 0, frame = 176
 5446              		@ frame_needed = 0, uses_anonymous_args = 0
 5447              	.LVL428:
 5448 2fa0 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5449              	.LCFI23:
 5450              		.cfi_def_cfa_offset 28
 5451 2fa4 BCD04DE2 		sub	sp, sp, #188
 5452              	.LCFI24:
 5453              		.cfi_def_cfa_offset 216
 5454              	.LBB212:
 5455              	.LBB213:
1625:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5456              		.loc 1 1625 0
 5457              		.cfi_offset 14, -4
 5458              		.cfi_offset 10, -8
 5459              		.cfi_offset 8, -12
 5460              		.cfi_offset 7, -16
 5461              		.cfi_offset 6, -20
 5462              		.cfi_offset 5, -24
 5463              		.cfi_offset 4, -28
 5464 2fa8 FEFFFFEB 		bl	CyU3PUartInit
 5465              	.LVL429:
1626:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5466              		.loc 1 1626 0
 5467 2fac 004050E2 		subs	r4, r0, #0
 5468 2fb0 0400000A 		beq	.L453
1628:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5469              		.loc 1 1628 0
 5470 2fb4 0400A0E3 		mov	r0, #4
 5471              	.LVL430:
 5472 2fb8 A41A9FE5 		ldr	r1, .L547
 5473 2fbc FEFFFFEB 		bl	CyU3PDebugPrint
1629:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5474              		.loc 1 1629 0
 5475 2fc0 0400A0E1 		mov	r0, r4
 5476 2fc4 FEFFFFEB 		bl	CyFxAppErrorHandler
 5477              	.L453:
1633:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5478              		.loc 1 1633 0
 5479 2fc8 98CA9FE5 		ldr	ip, .L547+4
1635:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5480              		.loc 1 1635 0
 5481 2fcc 0030A0E3 		mov	r3, #0
1634:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5482              		.loc 1 1634 0
 5483 2fd0 0120A0E3 		mov	r2, #1
1642:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5484              		.loc 1 1642 0
 5485 2fd4 50008DE2 		add	r0, sp, #80
 5486 2fd8 0310A0E1 		mov	r1, r3
1633:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5487              		.loc 1 1633 0
 5488 2fdc 60C08DE5 		str	ip, [sp, #96]
1634:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5489              		.loc 1 1634 0
 5490 2fe0 6420CDE5 		strb	r2, [sp, #100]
1635:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5491              		.loc 1 1635 0
 5492 2fe4 6530CDE5 		strb	r3, [sp, #101]
1636:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5493              		.loc 1 1636 0
 5494 2fe8 50208DE5 		str	r2, [sp, #80]
1637:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5495              		.loc 1 1637 0
 5496 2fec 54308DE5 		str	r3, [sp, #84]
1638:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5497              		.loc 1 1638 0
 5498 2ff0 58308DE5 		str	r3, [sp, #88]
1639:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5499              		.loc 1 1639 0
 5500 2ff4 5C208DE5 		str	r2, [sp, #92]
1642:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5501              		.loc 1 1642 0
 5502 2ff8 FEFFFFEB 		bl	CyU3PUartSetConfig
 5503              	.LVL431:
1643:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5504              		.loc 1 1643 0
 5505 2ffc 000050E3 		cmp	r0, #0
 5506 3000 0000000A 		beq	.L454
1645:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5507              		.loc 1 1645 0
 5508 3004 FEFFFFEB 		bl	CyFxAppErrorHandler
 5509              	.LVL432:
 5510              	.L454:
1649:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5511              		.loc 1 1649 0
 5512 3008 0000E0E3 		mvn	r0, #0
 5513 300c FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5514              	.LVL433:
1650:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5515              		.loc 1 1650 0
 5516 3010 000050E3 		cmp	r0, #0
 5517 3014 0000000A 		beq	.L455
1652:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5518              		.loc 1 1652 0
 5519 3018 FEFFFFEB 		bl	CyFxAppErrorHandler
 5520              	.LVL434:
 5521              	.L455:
1656:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5522              		.loc 1 1656 0
 5523 301c 0300A0E3 		mov	r0, #3
 5524 3020 0410A0E3 		mov	r1, #4
 5525 3024 FEFFFFEB 		bl	CyU3PDebugInit
 5526              	.LVL435:
1657:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5527              		.loc 1 1657 0
 5528 3028 000050E3 		cmp	r0, #0
 5529 302c 0000000A 		beq	.L456
1659:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5530              		.loc 1 1659 0
 5531 3030 FEFFFFEB 		bl	CyFxAppErrorHandler
 5532              	.LVL436:
 5533              	.L456:
1663:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5534              		.loc 1 1663 0
 5535 3034 0000A0E3 		mov	r0, #0
 5536 3038 FEFFFFEB 		bl	CyU3PDebugPreamble
 5537              	.LVL437:
 5538              	.LBE213:
 5539              	.LBE212:
2183:../uvc.c      **** 		CyU3PThreadSleep(500);
 5540              		.loc 1 2183 0
 5541 303c 7D0FA0E3 		mov	r0, #500
 5542 3040 FEFFFFEB 		bl	_tx_thread_sleep
 5543              	.LVL438:
 5544 3044 7D0FA0E3 		mov	r0, #500
 5545 3048 FEFFFFEB 		bl	_tx_thread_sleep
 5546 304c 7D0FA0E3 		mov	r0, #500
 5547 3050 FEFFFFEB 		bl	_tx_thread_sleep
 5548 3054 7D0FA0E3 		mov	r0, #500
 5549 3058 FEFFFFEB 		bl	_tx_thread_sleep
 5550 305c 7D0FA0E3 		mov	r0, #500
 5551 3060 FEFFFFEB 		bl	_tx_thread_sleep
 5552 3064 7D0FA0E3 		mov	r0, #500
 5553 3068 FEFFFFEB 		bl	_tx_thread_sleep
 5554              	.LBB214:
 5555              	.LBB215:
1674:../uvc.c      ****     status = CyU3PI2cInit ();
 5556              		.loc 1 1674 0
 5557 306c FEFFFFEB 		bl	CyU3PI2cInit
 5558              	.LVL439:
1675:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5559              		.loc 1 1675 0
 5560 3070 002050E2 		subs	r2, r0, #0
 5561 3074 0201001A 		bne	.L522
1682:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5562              		.loc 1 1682 0
 5563 3078 EC599FE5 		ldr	r5, .L547+8
1684:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5564              		.loc 1 1684 0
 5565 307c 0040E0E3 		mvn	r4, #0
1687:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5566              		.loc 1 1687 0
 5567 3080 0210A0E1 		mov	r1, r2
 5568 3084 8C008DE2 		add	r0, sp, #140
 5569              	.LVL440:
1682:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5570              		.loc 1 1682 0
 5571 3088 8C508DE5 		str	r5, [sp, #140]
1683:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5572              		.loc 1 1683 0
 5573 308c 90208DE5 		str	r2, [sp, #144]
1684:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5574              		.loc 1 1684 0
 5575 3090 94408DE5 		str	r4, [sp, #148]
1685:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5576              		.loc 1 1685 0
 5577 3094 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1687:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5578              		.loc 1 1687 0
 5579 3098 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5580              	.LVL441:
1688:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5581              		.loc 1 1688 0
 5582 309c 001050E2 		subs	r1, r0, #0
 5583 30a0 0001001A 		bne	.L523
 5584              	.LBE215:
 5585              	.LBE214:
 5586              	.LBB221:
 5587              	.LBB224:
1761:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5588              		.loc 1 1761 0
 5589 30a4 C4699FE5 		ldr	r6, .L547+12
 5590 30a8 2820A0E3 		mov	r2, #40
 5591 30ac 0600A0E1 		mov	r0, r6
 5592              	.LVL442:
 5593 30b0 FEFFFFEB 		bl	_txe_event_flags_create
 5594              	.LVL443:
1762:../uvc.c      ****     if (apiRetStatus != 0)
 5595              		.loc 1 1762 0
 5596 30b4 002050E2 		subs	r2, r0, #0
 5597 30b8 0301001A 		bne	.L524
1776:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5598              		.loc 1 1776 0
 5599 30bc 0280A0E3 		mov	r8, #2
1783:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5600              		.loc 1 1783 0
 5601 30c0 0210A0E1 		mov	r1, r2
 5602 30c4 9C008DE2 		add	r0, sp, #156
 5603              	.LVL444:
1779:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5604              		.loc 1 1779 0
 5605 30c8 017088E2 		add	r7, r8, #1
1772:../uvc.c      ****     isUsbConnected = CyFalse;
 5606              		.loc 1 1772 0
 5607 30cc 3C2086E5 		str	r2, [r6, #60]
1773:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5608              		.loc 1 1773 0
 5609 30d0 402086E5 		str	r2, [r6, #64]
1778:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5610              		.loc 1 1778 0
 5611 30d4 A420CDE5 		strb	r2, [sp, #164]
1780:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5612              		.loc 1 1780 0
 5613 30d8 A0208DE5 		str	r2, [sp, #160]
1776:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5614              		.loc 1 1776 0
 5615 30dc 9C80CDE5 		strb	r8, [sp, #156]
1777:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5616              		.loc 1 1777 0
 5617 30e0 9D80CDE5 		strb	r8, [sp, #157]
1779:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5618              		.loc 1 1779 0
 5619 30e4 A570CDE5 		strb	r7, [sp, #165]
1783:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5620              		.loc 1 1783 0
 5621 30e8 FEFFFFEB 		bl	CyU3PGpioInit
 5622              	.LVL445:
1784:../uvc.c      ****     if (apiRetStatus != 0)
 5623              		.loc 1 1784 0
 5624 30ec 002050E2 		subs	r2, r0, #0
 5625 30f0 7B01001A 		bne	.L525
1792:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5626              		.loc 1 1792 0
 5627 30f4 1600A0E3 		mov	r0, #22
 5628              	.LVL446:
 5629 30f8 0110A0E3 		mov	r1, #1
 5630 30fc FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5631              	.LVL447:
1793:../uvc.c      ****     if (apiRetStatus != 0)
 5632              		.loc 1 1793 0
 5633 3100 002050E2 		subs	r2, r0, #0
 5634 3104 6D01001A 		bne	.L526
1798:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5635              		.loc 1 1798 0
 5636 3108 1400A0E3 		mov	r0, #20
 5637              	.LVL448:
 5638 310c 0110A0E3 		mov	r1, #1
 5639 3110 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5640              	.LVL449:
1799:../uvc.c      ****     if (apiRetStatus != 0)
 5641              		.loc 1 1799 0
 5642 3114 002050E2 		subs	r2, r0, #0
 5643 3118 5F01001A 		bne	.L527
1804:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5644              		.loc 1 1804 0
 5645 311c 1800A0E3 		mov	r0, #24
 5646              	.LVL450:
 5647 3120 0110A0E3 		mov	r1, #1
 5648 3124 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5649              	.LVL451:
1805:../uvc.c      ****     if (apiRetStatus != 0)
 5650              		.loc 1 1805 0
 5651 3128 002050E2 		subs	r2, r0, #0
 5652 312c 5101001A 		bne	.L528
1812:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5653              		.loc 1 1812 0
 5654 3130 0140A0E3 		mov	r4, #1
1817:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5655              		.loc 1 1817 0
 5656 3134 1600A0E3 		mov	r0, #22
 5657              	.LVL452:
 5658 3138 68108DE2 		add	r1, sp, #104
1815:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5659              		.loc 1 1815 0
 5660 313c 74208DE5 		str	r2, [sp, #116]
1816:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5661              		.loc 1 1816 0
 5662 3140 7820CDE5 		strb	r2, [sp, #120]
1812:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5663              		.loc 1 1812 0
 5664 3144 68408DE5 		str	r4, [sp, #104]
1813:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5665              		.loc 1 1813 0
 5666 3148 6C408DE5 		str	r4, [sp, #108]
1814:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5667              		.loc 1 1814 0
 5668 314c 70408DE5 		str	r4, [sp, #112]
1817:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5669              		.loc 1 1817 0
 5670 3150 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5671              	.LVL453:
1818:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5672              		.loc 1 1818 0
 5673 3154 002050E2 		subs	r2, r0, #0
 5674 3158 1B01001A 		bne	.L529
1831:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5675              		.loc 1 1831 0
 5676 315c 1400A0E3 		mov	r0, #20
 5677              	.LVL454:
 5678 3160 68108DE2 		add	r1, sp, #104
1829:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5679              		.loc 1 1829 0
 5680 3164 74208DE5 		str	r2, [sp, #116]
1830:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5681              		.loc 1 1830 0
 5682 3168 7820CDE5 		strb	r2, [sp, #120]
1826:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5683              		.loc 1 1826 0
 5684 316c 68408DE5 		str	r4, [sp, #104]
1827:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5685              		.loc 1 1827 0
 5686 3170 6C408DE5 		str	r4, [sp, #108]
1828:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5687              		.loc 1 1828 0
 5688 3174 70408DE5 		str	r4, [sp, #112]
1831:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5689              		.loc 1 1831 0
 5690 3178 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5691              	.LVL455:
1832:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5692              		.loc 1 1832 0
 5693 317c 002050E2 		subs	r2, r0, #0
 5694 3180 0801001A 		bne	.L530
1845:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5695              		.loc 1 1845 0
 5696 3184 1800A0E3 		mov	r0, #24
 5697              	.LVL456:
 5698 3188 68108DE2 		add	r1, sp, #104
1840:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5699              		.loc 1 1840 0
 5700 318c 68208DE5 		str	r2, [sp, #104]
1841:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5701              		.loc 1 1841 0
 5702 3190 6C208DE5 		str	r2, [sp, #108]
1842:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5703              		.loc 1 1842 0
 5704 3194 70208DE5 		str	r2, [sp, #112]
1844:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5705              		.loc 1 1844 0
 5706 3198 7820CDE5 		strb	r2, [sp, #120]
1843:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5707              		.loc 1 1843 0
 5708 319c 74408DE5 		str	r4, [sp, #116]
1845:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5709              		.loc 1 1845 0
 5710 31a0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5711              	.LVL457:
1846:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5712              		.loc 1 1846 0
 5713 31a4 002050E2 		subs	r2, r0, #0
 5714 31a8 F500001A 		bne	.L531
1855:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5715              		.loc 1 1855 0
 5716 31ac 00A0A0E3 		mov	sl, #0
1853:../uvc.c      ****     pibclock.clkDiv      = 2;
 5717              		.loc 1 1853 0
 5718 31b0 0270A0E3 		mov	r7, #2	@ movhi
1854:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5719              		.loc 1 1854 0
 5720 31b4 0380A0E3 		mov	r8, #3
1858:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5721              		.loc 1 1858 0
 5722 31b8 0100A0E3 		mov	r0, #1
 5723              	.LVL458:
 5724 31bc 7C108DE2 		add	r1, sp, #124
1853:../uvc.c      ****     pibclock.clkDiv      = 2;
 5725              		.loc 1 1853 0
 5726 31c0 BC77CDE1 		strh	r7, [sp, #124]	@ movhi
1854:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5727              		.loc 1 1854 0
 5728 31c4 8880CDE5 		strb	r8, [sp, #136]
1855:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5729              		.loc 1 1855 0
 5730 31c8 84A08DE5 		str	sl, [sp, #132]
1856:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5731              		.loc 1 1856 0
 5732 31cc 80A08DE5 		str	sl, [sp, #128]
1858:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5733              		.loc 1 1858 0
 5734 31d0 FEFFFFEB 		bl	CyU3PPibInit
 5735              	.LVL459:
1859:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5736              		.loc 1 1859 0
 5737 31d4 002050E2 		subs	r2, r0, #0
 5738 31d8 7A01001A 		bne	.L532
1866:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5739              		.loc 1 1866 0
 5740 31dc 90089FE5 		ldr	r0, .L547+16
 5741              	.LVL460:
 5742 31e0 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 5743              	.LVL461:
1874:../uvc.c      ****     SensorReset ();
 5744              		.loc 1 1874 0
 5745 31e4 FEFFFFEB 		bl	SensorReset
1875:../uvc.c      ****     SensorInit ();
 5746              		.loc 1 1875 0
 5747 31e8 FEFFFFEB 		bl	SensorInit
1878:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5748              		.loc 1 1878 0
 5749 31ec FEFFFFEB 		bl	CyU3PUsbStart
 5750              	.LVL462:
1879:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5751              		.loc 1 1879 0
 5752 31f0 004050E2 		subs	r4, r0, #0
 5753 31f4 6901001A 		bne	.L533
1885:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 5754              		.loc 1 1885 0
 5755 31f8 0410A0E1 		mov	r1, r4
 5756 31fc 74089FE5 		ldr	r0, .L547+20
 5757              	.LVL463:
 5758 3200 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 5759              	.LVL464:
1888:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 5760              		.loc 1 1888 0
 5761 3204 70089FE5 		ldr	r0, .L547+24
 5762 3208 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1894:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 5763              		.loc 1 1894 0
 5764 320c 6C289FE5 		ldr	r2, .L547+28
 5765 3210 0410A0E1 		mov	r1, r4
 5766 3214 0100A0E3 		mov	r0, #1
 5767 3218 FEFFFFEB 		bl	CyU3PUsbSetDesc
1895:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 5768              		.loc 1 1895 0
 5769 321c 0410A0E1 		mov	r1, r4
 5770 3220 5C289FE5 		ldr	r2, .L547+32
 5771 3224 0400A0E1 		mov	r0, r4
 5772 3228 FEFFFFEB 		bl	CyU3PUsbSetDesc
1898:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 5773              		.loc 1 1898 0
 5774 322c 0410A0E1 		mov	r1, r4
 5775 3230 50289FE5 		ldr	r2, .L547+36
 5776 3234 0200A0E3 		mov	r0, #2
 5777 3238 FEFFFFEB 		bl	CyU3PUsbSetDesc
1899:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 5778              		.loc 1 1899 0
 5779 323c 0410A0E1 		mov	r1, r4
 5780 3240 44289FE5 		ldr	r2, .L547+40
 5781 3244 0700A0E3 		mov	r0, #7
 5782 3248 FEFFFFEB 		bl	CyU3PUsbSetDesc
1902:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 5783              		.loc 1 1902 0
 5784 324c 3C289FE5 		ldr	r2, .L547+44
 5785 3250 0410A0E1 		mov	r1, r4
 5786 3254 0400A0E3 		mov	r0, #4
 5787 3258 FEFFFFEB 		bl	CyU3PUsbSetDesc
1903:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 5788              		.loc 1 1903 0
 5789 325c 0410A0E1 		mov	r1, r4
 5790 3260 2C289FE5 		ldr	r2, .L547+48
 5791 3264 0800A0E1 		mov	r0, r8
 5792 3268 FEFFFFEB 		bl	CyU3PUsbSetDesc
1904:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5793              		.loc 1 1904 0
 5794 326c 0410A0E1 		mov	r1, r4
 5795 3270 20289FE5 		ldr	r2, .L547+52
 5796 3274 0600A0E3 		mov	r0, #6
 5797 3278 FEFFFFEB 		bl	CyU3PUsbSetDesc
1907:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 5798              		.loc 1 1907 0
 5799 327c 0410A0E1 		mov	r1, r4
 5800 3280 14289FE5 		ldr	r2, .L547+56
 5801 3284 0500A0E3 		mov	r0, #5
 5802 3288 FEFFFFEB 		bl	CyU3PUsbSetDesc
1908:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 5803              		.loc 1 1908 0
 5804 328c 0110A0E3 		mov	r1, #1
 5805 3290 08289FE5 		ldr	r2, .L547+60
 5806 3294 0500A0E3 		mov	r0, #5
 5807 3298 FEFFFFEB 		bl	CyU3PUsbSetDesc
1909:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 5808              		.loc 1 1909 0
 5809 329c 0210A0E3 		mov	r1, #2
 5810 32a0 FC279FE5 		ldr	r2, .L547+64
 5811 32a4 0500A0E3 		mov	r0, #5
 5812 32a8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1916:../uvc.c      ****     endPointConfig.enable   = 1;
 5813              		.loc 1 1916 0
 5814 32ac 0150A0E3 		mov	r5, #1
1918:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5815              		.loc 1 1918 0
 5816 32b0 4020A0E3 		mov	r2, #64	@ movhi
1922:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5817              		.loc 1 1922 0
 5818 32b4 8200A0E3 		mov	r0, #130
 5819 32b8 A8108DE2 		add	r1, sp, #168
1916:../uvc.c      ****     endPointConfig.enable   = 1;
 5820              		.loc 1 1916 0
 5821 32bc A8508DE5 		str	r5, [sp, #168]
1917:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 5822              		.loc 1 1917 0
 5823 32c0 AC80CDE5 		strb	r8, [sp, #172]
1918:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5824              		.loc 1 1918 0
 5825 32c4 B02BCDE1 		strh	r2, [sp, #176]	@ movhi
1919:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 5826              		.loc 1 1919 0
 5827 32c8 B340CDE5 		strb	r4, [sp, #179]
1920:../uvc.c      ****     endPointConfig.streams  = 0;
 5828              		.loc 1 1920 0
 5829 32cc BE4ACDE1 		strh	r4, [sp, #174]	@ movhi
1921:../uvc.c      ****     endPointConfig.burstLen = 1;
 5830              		.loc 1 1921 0
 5831 32d0 B250CDE5 		strb	r5, [sp, #178]
1922:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5832              		.loc 1 1922 0
 5833 32d4 FEFFFFEB 		bl	CyU3PSetEpConfig
 5834              	.LVL465:
1923:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5835              		.loc 1 1923 0
 5836 32d8 003050E2 		subs	r3, r0, #0
 5837 32dc 2501001A 		bne	.L534
1933:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5838              		.loc 1 1933 0
 5839 32e0 C0C79FE5 		ldr	ip, .L547+68
1934:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5840              		.loc 1 1934 0
 5841 32e4 C0E79FE5 		ldr	lr, .L547+72
1931:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5842              		.loc 1 1931 0
 5843 32e8 018BA0E3 		mov	r8, #1024	@ movhi
1940:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5844              		.loc 1 1940 0
 5845 32ec 10A0A0E3 		mov	sl, #16
1942:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5846              		.loc 1 1942 0
 5847 32f0 B8079FE5 		ldr	r0, .L547+76
 5848              	.LVL466:
 5849 32f4 0410A0E3 		mov	r1, #4
 5850 32f8 34208DE2 		add	r2, sp, #52
1931:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5851              		.loc 1 1931 0
 5852 32fc B483CDE1 		strh	r8, [sp, #52]	@ movhi
1932:../uvc.c      ****     dmaInterConfig.count          = 1;
 5853              		.loc 1 1932 0
 5854 3300 B653CDE1 		strh	r5, [sp, #54]	@ movhi
1933:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5855              		.loc 1 1933 0
 5856 3304 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1934:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5857              		.loc 1 1934 0
 5858 3308 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1935:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 5859              		.loc 1 1935 0
 5860 330c BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1936:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 5861              		.loc 1 1936 0
 5862 3310 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1937:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 5863              		.loc 1 1937 0
 5864 3314 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1938:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 5865              		.loc 1 1938 0
 5866 3318 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1939:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 5867              		.loc 1 1939 0
 5868 331c 4440CDE5 		strb	r4, [sp, #68]
1940:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5869              		.loc 1 1940 0
 5870 3320 48A08DE5 		str	sl, [sp, #72]
1941:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 5871              		.loc 1 1941 0
 5872 3324 4C308DE5 		str	r3, [sp, #76]
1942:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5873              		.loc 1 1942 0
 5874 3328 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 5875              	.LVL467:
1944:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5876              		.loc 1 1944 0
 5877 332c 008050E2 		subs	r8, r0, #0
 5878 3330 0601001A 		bne	.L535
1951:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 5879              		.loc 1 1951 0
 5880 3334 010BA0E3 		mov	r0, #1024
 5881              	.LVL468:
 5882 3338 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 5883 333c 70179FE5 		ldr	r1, .L547+80
1952:../uvc.c      ****     if (glInterStaBuffer == 0)
 5884              		.loc 1 1952 0
 5885 3340 000050E3 		cmp	r0, #0
1951:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 5886              		.loc 1 1951 0
 5887 3344 000081E5 		str	r0, [r1, #0]
1952:../uvc.c      ****     if (glInterStaBuffer == 0)
 5888              		.loc 1 1952 0
 5889 3348 3001000A 		beq	.L536
1960:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 5890              		.loc 1 1960 0
 5891 334c 0430A0E3 		mov	r3, #4	@ movhi
 5892 3350 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
1964:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 5893              		.loc 1 1964 0
 5894 3354 5C379FE5 		ldr	r3, .L547+84
1959:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 5895              		.loc 1 1959 0
 5896 3358 01E9A0E3 		mov	lr, #16384	@ movhi
 5897 335c BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
1963:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 5898              		.loc 1 1963 0
 5899 3360 54E79FE5 		ldr	lr, .L547+88
1964:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 5900              		.loc 1 1964 0
 5901 3364 BA31CDE1 		strh	r3, [sp, #26]	@ movhi
1971:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 5902              		.loc 1 1971 0
 5903 3368 50379FE5 		ldr	r3, .L547+92
1962:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 5904              		.loc 1 1962 0
 5905 336c 01CCA0E3 		mov	ip, #256	@ movhi
1972:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 5906              		.loc 1 1972 0
 5907 3370 0C208DE2 		add	r2, sp, #12
1962:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 5908              		.loc 1 1962 0
 5909 3374 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
1963:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 5910              		.loc 1 1963 0
 5911 3378 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
1966:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 5912              		.loc 1 1966 0
 5913 337c 0CC0A0E3 		mov	ip, #12	@ movhi
1967:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 5914              		.loc 1 1967 0
 5915 3380 04E0A0E3 		mov	lr, #4	@ movhi
1969:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 5916              		.loc 1 1969 0
 5917 3384 2A40CDE5 		strb	r4, [sp, #42]
1972:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 5918              		.loc 1 1972 0
 5919 3388 34079FE5 		ldr	r0, .L547+96
 5920 338c 0710A0E3 		mov	r1, #7
1970:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 5921              		.loc 1 1970 0
 5922 3390 1840A0E3 		mov	r4, #24
1961:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 5923              		.loc 1 1961 0
 5924 3394 B071CDE1 		strh	r7, [sp, #16]	@ movhi
1965:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 5925              		.loc 1 1965 0
 5926 3398 B282CDE1 		strh	r8, [sp, #34]	@ movhi
1966:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 5927              		.loc 1 1966 0
 5928 339c B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
1967:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 5929              		.loc 1 1967 0
 5930 33a0 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
1968:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 5931              		.loc 1 1968 0
 5932 33a4 B882CDE1 		strh	r8, [sp, #40]	@ movhi
1970:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 5933              		.loc 1 1970 0
 5934 33a8 2C408DE5 		str	r4, [sp, #44]
1971:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 5935              		.loc 1 1971 0
 5936 33ac 30308DE5 		str	r3, [sp, #48]
1972:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 5937              		.loc 1 1972 0
 5938 33b0 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 5939              	.LVL469:
1974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5940              		.loc 1 1974 0
 5941 33b4 002050E2 		subs	r2, r0, #0
 5942 33b8 0B01001A 		bne	.L537
2065:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 5943              		.loc 1 2065 0
 5944 33bc 0500A0E1 		mov	r0, r5
 5945              	.LVL470:
 5946 33c0 0510A0E1 		mov	r1, r5
 5947 33c4 FEFFFFEB 		bl	CyU3PConnectState
 5948              	.LVL471:
2066:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5949              		.loc 1 2066 0
 5950 33c8 002050E2 		subs	r2, r0, #0
 5951 33cc 6300001A 		bne	.L538
2072:../uvc.c      ****     CyU3PBusyWait(100);
 5952              		.loc 1 2072 0
 5953 33d0 6400A0E3 		mov	r0, #100
 5954              	.LVL472:
 5955 33d4 FEFFFFEB 		bl	CyU3PBusyWait
 5956              	.LVL473:
2074:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 5957              		.loc 1 2074 0
 5958 33d8 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2076:../uvc.c      ****     endPointConfig.enable   = 1;
 5959              		.loc 1 2076 0
 5960 33dc A8508DE5 		str	r5, [sp, #168]
2077:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 5961              		.loc 1 2077 0
 5962 33e0 AC70CDE5 		strb	r7, [sp, #172]
2089:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 5963              		.loc 1 2089 0
 5964 33e4 A8108DE2 		add	r1, sp, #168
2078:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 5965              		.loc 1 2078 0
 5966 33e8 030050E3 		cmp	r0, #3
2074:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 5967              		.loc 1 2074 0
 5968 33ec 4800C6E5 		strb	r0, [r6, #72]
2085:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 5969              		.loc 1 2085 0
 5970 33f0 020CA013 		movne	r0, #512	@ movhi
2080:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 5971              		.loc 1 2080 0
 5972 33f4 017BA003 		moveq	r7, #1024	@ movhi
2085:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 5973              		.loc 1 2085 0
 5974 33f8 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2086:../uvc.c      ****     	endPointConfig.burstLen = 1;
 5975              		.loc 1 2086 0
 5976 33fc B250CD15 		strneb	r5, [sp, #178]
2089:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 5977              		.loc 1 2089 0
 5978 3400 8300A0E3 		mov	r0, #131
2088:../uvc.c      ****     endPointConfig.streams  = 0;
 5979              		.loc 1 2088 0
 5980 3404 0050A0E3 		mov	r5, #0	@ movhi
2080:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 5981              		.loc 1 2080 0
 5982 3408 B07BCD01 		streqh	r7, [sp, #176]	@ movhi
2081:../uvc.c      ****     	endPointConfig.burstLen = 16;
 5983              		.loc 1 2081 0
 5984 340c B2A0CD05 		streqb	sl, [sp, #178]
2088:../uvc.c      ****     endPointConfig.streams  = 0;
 5985              		.loc 1 2088 0
 5986 3410 BE5ACDE1 		strh	r5, [sp, #174]	@ movhi
2089:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 5987              		.loc 1 2089 0
 5988 3414 FEFFFFEB 		bl	CyU3PSetEpConfig
 5989              	.LVL474:
2090:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5990              		.loc 1 2090 0
 5991 3418 002050E2 		subs	r2, r0, #0
 5992 341c 4600001A 		bne	.L519
 5993 3420 A0869FE5 		ldr	r8, .L547+100
 5994              	.LBE224:
 5995              	.LBE221:
2210:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 5996              		.loc 1 2210 0
 5997 3424 44569FE5 		ldr	r5, .L547+12
 5998 3428 0240A0E1 		mov	r4, r2
2281:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 5999              		.loc 1 2281 0
 6000 342c 0870A0E1 		mov	r7, r8
 6001              	.LVL475:
 6002              	.L493:
2210:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6003              		.loc 1 2210 0
 6004 3430 38069FE5 		ldr	r0, .L547+12
 6005 3434 0110A0E3 		mov	r1, #1
 6006 3438 0220A0E3 		mov	r2, #2
 6007 343c B4308DE2 		add	r3, sp, #180
 6008 3440 00408DE5 		str	r4, [sp, #0]
 6009 3444 FEFFFFEB 		bl	_txe_event_flags_get
 6010 3448 000050E3 		cmp	r0, #0
 6011 344c 2700001A 		bne	.L495
2256:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6012              		.loc 1 2256 0
 6013 3450 44A095E5 		ldr	sl, [r5, #68]
 6014 3454 00005AE3 		cmp	sl, #0
 6015 3458 0300000A 		beq	.L496
2256:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6016              		.loc 1 2256 0 is_stmt 0 discriminator 1
 6017 345c BE22D5E1 		ldrh	r2, [r5, #46]
 6018 3460 B013D5E1 		ldrh	r1, [r5, #48]
 6019 3464 010052E1 		cmp	r2, r1
 6020 3468 6000000A 		beq	.L539
 6021              	.L496:
2383:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6022              		.loc 1 2383 0 is_stmt 1
 6023 346c 4010A0E3 		mov	r1, #64
 6024 3470 0020A0E3 		mov	r2, #0
 6025 3474 F4059FE5 		ldr	r0, .L547+12
 6026 3478 FEFFFFEB 		bl	_txe_event_flags_set
2386:../uvc.c      ****         CyU3PThreadRelinquish ();
 6027              		.loc 1 2386 0
 6028 347c FEFFFFEB 		bl	_txe_thread_relinquish
2387:../uvc.c      ****     }
 6029              		.loc 1 2387 0
 6030 3480 EAFFFFEA 		b	.L493
 6031              	.LVL476:
 6032              	.L522:
 6033              	.LBB259:
 6034              	.LBB220:
1677:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6035              		.loc 1 1677 0
 6036 3484 0400A0E3 		mov	r0, #4
 6037              	.LVL477:
 6038 3488 3C169FE5 		ldr	r1, .L547+104
 6039 348c FEFFFFEB 		bl	CyU3PDebugPrint
 6040              	.LVL478:
 6041              	.L458:
 6042              	.LBB216:
 6043              	.LBB217:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6044              		.loc 1 1223 0
 6045 3490 38169FE5 		ldr	r1, .L547+108
 6046 3494 0400A0E3 		mov	r0, #4
 6047 3498 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6048              		.loc 1 1224 0
 6049 349c FA0FA0E3 		mov	r0, #1000
 6050 34a0 FEFFFFEB 		bl	_tx_thread_sleep
 6051 34a4 F9FFFFEA 		b	.L458
 6052              	.LVL479:
 6053              	.L523:
 6054              	.LBE217:
 6055              	.LBE216:
1690:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6056              		.loc 1 1690 0
 6057 34a8 0400A0E3 		mov	r0, #4
 6058              	.LVL480:
 6059 34ac 20169FE5 		ldr	r1, .L547+112
 6060              	.LVL481:
 6061 34b0 FEFFFFEB 		bl	CyU3PDebugPrint
 6062              	.L460:
 6063              	.LBB218:
 6064              	.LBB219:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6065              		.loc 1 1223 0
 6066 34b4 14169FE5 		ldr	r1, .L547+108
 6067 34b8 0400A0E3 		mov	r0, #4
 6068 34bc FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6069              		.loc 1 1224 0
 6070 34c0 FA0FA0E3 		mov	r0, #1000
 6071 34c4 FEFFFFEB 		bl	_tx_thread_sleep
 6072 34c8 F9FFFFEA 		b	.L460
 6073              	.LVL482:
 6074              	.L524:
 6075              	.LBE219:
 6076              	.LBE218:
 6077              	.LBE220:
 6078              	.LBE259:
 6079              	.LBB260:
 6080              	.LBB223:
1764:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6081              		.loc 1 1764 0
 6082 34cc 0400A0E3 		mov	r0, #4
 6083              	.LVL483:
 6084 34d0 00169FE5 		ldr	r1, .L547+116
 6085 34d4 FEFFFFEB 		bl	CyU3PDebugPrint
 6086              	.LVL484:
 6087              	.L462:
 6088              	.LBB233:
 6089              	.LBB234:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6090              		.loc 1 1223 0
 6091 34d8 F0159FE5 		ldr	r1, .L547+108
 6092 34dc 0400A0E3 		mov	r0, #4
 6093 34e0 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6094              		.loc 1 1224 0
 6095 34e4 FA0FA0E3 		mov	r0, #1000
 6096 34e8 FEFFFFEB 		bl	_tx_thread_sleep
 6097 34ec F9FFFFEA 		b	.L462
 6098              	.LVL485:
 6099              	.L495:
 6100              	.LBE234:
 6101              	.LBE233:
 6102              	.LBE223:
 6103              	.LBE260:
2312:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6104              		.loc 1 2312 0
 6105 34f0 78059FE5 		ldr	r0, .L547+12
 6106 34f4 0210A0E3 		mov	r1, #2
 6107 34f8 0320A0E3 		mov	r2, #3
 6108 34fc B4308DE2 		add	r3, sp, #180
 6109 3500 00408DE5 		str	r4, [sp, #0]
 6110 3504 FEFFFFEB 		bl	_txe_event_flags_get
 6111 3508 000050E3 		cmp	r0, #0
 6112 350c DA00001A 		bne	.L503
2327:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6113              		.loc 1 2327 0
 6114 3510 402095E5 		ldr	r2, [r5, #64]
2315:../uvc.c      ****                 hitFV     = CyFalse;
 6115              		.loc 1 2315 0
 6116 3514 444085E5 		str	r4, [r5, #68]
2327:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6117              		.loc 1 2327 0
 6118 3518 000052E3 		cmp	r2, #0
2316:../uvc.c      ****                 prodCount = 0;
 6119              		.loc 1 2316 0
 6120 351c BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2323:../uvc.c      ****                 fb=0;
 6121              		.loc 1 2323 0
 6122 3520 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2317:../uvc.c      ****                 consCount = 0;
 6123              		.loc 1 2317 0
 6124 3524 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2324:../uvc.c      ****                 pb=0;
 6125              		.loc 1 2324 0
 6126 3528 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2325:../uvc.c      ****                 pbc=0;
 6127              		.loc 1 2325 0
 6128 352c BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2327:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6129              		.loc 1 2327 0
 6130 3530 BF00000A 		beq	.L540
 6131              	.L504:
2339:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6132              		.loc 1 2339 0
 6133 3534 404086E5 		str	r4, [r6, #64]
 6134 3538 CBFFFFEA 		b	.L496
 6135              	.LVL486:
 6136              	.L519:
 6137              	.LBB261:
 6138              	.LBB257:
2093:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6139              		.loc 1 2093 0
 6140 353c 0400A0E3 		mov	r0, #4
 6141              	.LVL487:
 6142 3540 94159FE5 		ldr	r1, .L547+120
 6143 3544 FEFFFFEB 		bl	CyU3PDebugPrint
 6144              	.LVL488:
 6145              	.L494:
 6146              	.LBB235:
 6147              	.LBB236:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6148              		.loc 1 1223 0
 6149 3548 80159FE5 		ldr	r1, .L547+108
 6150 354c 0400A0E3 		mov	r0, #4
 6151 3550 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6152              		.loc 1 1224 0
 6153 3554 FA0FA0E3 		mov	r0, #1000
 6154 3558 FEFFFFEB 		bl	_tx_thread_sleep
 6155 355c F9FFFFEA 		b	.L494
 6156              	.LVL489:
 6157              	.L538:
 6158              	.LBE236:
 6159              	.LBE235:
2068:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6160              		.loc 1 2068 0
 6161 3560 0400A0E3 		mov	r0, #4
 6162              	.LVL490:
 6163 3564 74159FE5 		ldr	r1, .L547+124
 6164 3568 FEFFFFEB 		bl	CyU3PDebugPrint
 6165              	.LVL491:
 6166              	.L490:
 6167              	.LBB237:
 6168              	.LBB238:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6169              		.loc 1 1223 0
 6170 356c 5C159FE5 		ldr	r1, .L547+108
 6171 3570 0400A0E3 		mov	r0, #4
 6172 3574 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6173              		.loc 1 1224 0
 6174 3578 FA0FA0E3 		mov	r0, #1000
 6175 357c FEFFFFEB 		bl	_tx_thread_sleep
 6176 3580 F9FFFFEA 		b	.L490
 6177              	.LVL492:
 6178              	.L531:
 6179              	.LBE238:
 6180              	.LBE237:
1848:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6181              		.loc 1 1848 0
 6182 3584 0400A0E3 		mov	r0, #4
 6183              	.LVL493:
 6184 3588 54159FE5 		ldr	r1, .L547+128
 6185 358c FEFFFFEB 		bl	CyU3PDebugPrint
 6186              	.LVL494:
 6187              	.L476:
 6188              	.LBB239:
 6189              	.LBB240:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6190              		.loc 1 1223 0
 6191 3590 38159FE5 		ldr	r1, .L547+108
 6192 3594 0400A0E3 		mov	r0, #4
 6193 3598 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6194              		.loc 1 1224 0
 6195 359c FA0FA0E3 		mov	r0, #1000
 6196 35a0 FEFFFFEB 		bl	_tx_thread_sleep
 6197 35a4 F9FFFFEA 		b	.L476
 6198              	.LVL495:
 6199              	.L530:
 6200              	.LBE240:
 6201              	.LBE239:
1834:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6202              		.loc 1 1834 0
 6203 35a8 0400A0E3 		mov	r0, #4
 6204              	.LVL496:
 6205 35ac 34159FE5 		ldr	r1, .L547+132
 6206 35b0 FEFFFFEB 		bl	CyU3PDebugPrint
 6207              	.LVL497:
 6208              	.L474:
 6209              	.LBB241:
 6210              	.LBB242:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6211              		.loc 1 1223 0
 6212 35b4 14159FE5 		ldr	r1, .L547+108
 6213 35b8 0400A0E3 		mov	r0, #4
 6214 35bc FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6215              		.loc 1 1224 0
 6216 35c0 FA0FA0E3 		mov	r0, #1000
 6217 35c4 FEFFFFEB 		bl	_tx_thread_sleep
 6218 35c8 F9FFFFEA 		b	.L474
 6219              	.LVL498:
 6220              	.L529:
 6221              	.LBE242:
 6222              	.LBE241:
1820:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6223              		.loc 1 1820 0
 6224 35cc 0400A0E3 		mov	r0, #4
 6225              	.LVL499:
 6226 35d0 14159FE5 		ldr	r1, .L547+136
 6227 35d4 FEFFFFEB 		bl	CyU3PDebugPrint
 6228              	.LVL500:
 6229              	.L472:
 6230              	.LBB243:
 6231              	.LBB244:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6232              		.loc 1 1223 0
 6233 35d8 F0149FE5 		ldr	r1, .L547+108
 6234 35dc 0400A0E3 		mov	r0, #4
 6235 35e0 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6236              		.loc 1 1224 0
 6237 35e4 FA0FA0E3 		mov	r0, #1000
 6238 35e8 FEFFFFEB 		bl	_tx_thread_sleep
 6239 35ec F9FFFFEA 		b	.L472
 6240              	.LVL501:
 6241              	.L539:
 6242              	.LBE244:
 6243              	.LBE243:
 6244              	.LBE257:
 6245              	.LBE261:
2266:../uvc.c      ****                 prodCount = 0;
 6246              		.loc 1 2266 0
 6247 35f0 BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2267:../uvc.c      ****                 consCount = 0;
 6248              		.loc 1 2267 0
 6249 35f4 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2268:../uvc.c      ****                 hitFV     = CyFalse;
 6250              		.loc 1 2268 0
 6251 35f8 444085E5 		str	r4, [r5, #68]
2281:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6252              		.loc 1 2281 0
 6253 35fc 8104D8E5 		ldrb	r0, [r8, #1153]	@ zero_extendqisi2
2263:../uvc.c      ****             	fb=0;
 6254              		.loc 1 2263 0
 6255 3600 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2281:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6256              		.loc 1 2281 0
 6257 3604 01E020E2 		eor	lr, r0, #1
 6258 3608 81E4C8E5 		strb	lr, [r8, #1153]
2282:../uvc.c      ****                 if(stiflag){
 6259              		.loc 1 2282 0
 6260 360c 983095E5 		ldr	r3, [r5, #152]
2283:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6261              		.loc 1 2283 0
 6262 3610 81C4D7E5 		ldrb	ip, [r7, #1153]	@ zero_extendqisi2
2282:../uvc.c      ****                 if(stiflag){
 6263              		.loc 1 2282 0
 6264 3614 000053E3 		cmp	r3, #0
2283:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6265              		.loc 1 2283 0
 6266 3618 20C08C13 		orrne	ip, ip, #32
2286:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6267              		.loc 1 2286 0
 6268 361c DFC00C02 		andeq	ip, ip, #223
2283:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6269              		.loc 1 2283 0
 6270 3620 81C4C715 		strneb	ip, [r7, #1153]
2286:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6271              		.loc 1 2286 0
 6272 3624 81C4C705 		streqb	ip, [r7, #1153]
2284:../uvc.c      ****                 	stiflag = CyFalse;
 6273              		.loc 1 2284 0
 6274 3628 98408515 		strne	r4, [r5, #152]
2264:../uvc.c      ****             	pb=0;
 6275              		.loc 1 2264 0
 6276 362c BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2265:../uvc.c      ****             	pbc=0;
 6277              		.loc 1 2265 0
 6278 3630 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2289:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6279              		.loc 1 2289 0
 6280 3634 88049FE5 		ldr	r0, .L547+96
 6281 3638 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6282              	.LVL502:
2290:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6283              		.loc 1 2290 0
 6284 363c 002050E2 		subs	r2, r0, #0
 6285 3640 3900001A 		bne	.L541
2297:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6286              		.loc 1 2297 0
 6287 3644 0210A0E1 		mov	r1, r2
 6288 3648 74049FE5 		ldr	r0, .L547+96
 6289              	.LVL503:
 6290 364c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6291              	.LVL504:
2298:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6292              		.loc 1 2298 0
 6293 3650 002050E2 		subs	r2, r0, #0
 6294 3654 2B00001A 		bne	.L542
2306:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6295              		.loc 1 2306 0
 6296 3658 5C049FE5 		ldr	r0, .L547+88
 6297              	.LVL505:
 6298 365c 0210A0E1 		mov	r1, r2
 6299 3660 02A0A0E3 		mov	sl, #2
 6300 3664 0020A0E1 		mov	r2, r0
 6301              	.LVL506:
 6302 3668 0130A0E1 		mov	r3, r1
 6303 366c 00A08DE5 		str	sl, [sp, #0]
 6304 3670 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6305              	.LVL507:
 6306 3674 7CFFFFEA 		b	.L496
 6307              	.LVL508:
 6308              	.L528:
 6309              	.LBB262:
 6310              	.LBB222:
1807:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6311              		.loc 1 1807 0
 6312 3678 0400A0E3 		mov	r0, #4
 6313              	.LVL509:
 6314 367c 6C149FE5 		ldr	r1, .L547+140
 6315 3680 FEFFFFEB 		bl	CyU3PDebugPrint
 6316              	.LVL510:
 6317              	.L470:
 6318              	.LBB231:
 6319              	.LBB232:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6320              		.loc 1 1223 0
 6321 3684 44149FE5 		ldr	r1, .L547+108
 6322 3688 0400A0E3 		mov	r0, #4
 6323 368c FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6324              		.loc 1 1224 0
 6325 3690 FA0FA0E3 		mov	r0, #1000
 6326 3694 FEFFFFEB 		bl	_tx_thread_sleep
 6327 3698 F9FFFFEA 		b	.L470
 6328              	.LVL511:
 6329              	.L527:
 6330              	.LBE232:
 6331              	.LBE231:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6332              		.loc 1 1801 0
 6333 369c 0400A0E3 		mov	r0, #4
 6334              	.LVL512:
 6335 36a0 4C149FE5 		ldr	r1, .L547+144
 6336 36a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6337              	.LVL513:
 6338              	.L468:
 6339              	.LBB229:
 6340              	.LBB230:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6341              		.loc 1 1223 0
 6342 36a8 20149FE5 		ldr	r1, .L547+108
 6343 36ac 0400A0E3 		mov	r0, #4
 6344 36b0 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6345              		.loc 1 1224 0
 6346 36b4 FA0FA0E3 		mov	r0, #1000
 6347 36b8 FEFFFFEB 		bl	_tx_thread_sleep
 6348 36bc F9FFFFEA 		b	.L468
 6349              	.LVL514:
 6350              	.L526:
 6351              	.LBE230:
 6352              	.LBE229:
1795:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6353              		.loc 1 1795 0
 6354 36c0 0400A0E3 		mov	r0, #4
 6355              	.LVL515:
 6356 36c4 2C149FE5 		ldr	r1, .L547+148
 6357 36c8 FEFFFFEB 		bl	CyU3PDebugPrint
 6358              	.LVL516:
 6359              	.L466:
 6360              	.LBB227:
 6361              	.LBB228:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6362              		.loc 1 1223 0
 6363 36cc FC139FE5 		ldr	r1, .L547+108
 6364 36d0 0400A0E3 		mov	r0, #4
 6365 36d4 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6366              		.loc 1 1224 0
 6367 36d8 FA0FA0E3 		mov	r0, #1000
 6368 36dc FEFFFFEB 		bl	_tx_thread_sleep
 6369 36e0 F9FFFFEA 		b	.L466
 6370              	.LVL517:
 6371              	.L525:
 6372              	.LBE228:
 6373              	.LBE227:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6374              		.loc 1 1786 0
 6375 36e4 0400A0E3 		mov	r0, #4
 6376              	.LVL518:
 6377 36e8 0C149FE5 		ldr	r1, .L547+152
 6378 36ec FEFFFFEB 		bl	CyU3PDebugPrint
 6379              	.LVL519:
 6380              	.L464:
 6381              	.LBB225:
 6382              	.LBB226:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6383              		.loc 1 1223 0
 6384 36f0 D8139FE5 		ldr	r1, .L547+108
 6385 36f4 0400A0E3 		mov	r0, #4
 6386 36f8 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6387              		.loc 1 1224 0
 6388 36fc FA0FA0E3 		mov	r0, #1000
 6389 3700 FEFFFFEB 		bl	_tx_thread_sleep
 6390 3704 F9FFFFEA 		b	.L464
 6391              	.LVL520:
 6392              	.L542:
 6393              	.LBE226:
 6394              	.LBE225:
 6395              	.LBE222:
 6396              	.LBE262:
2300:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6397              		.loc 1 2300 0
 6398 3708 0400A0E3 		mov	r0, #4
 6399              	.LVL521:
 6400 370c EC139FE5 		ldr	r1, .L547+156
 6401 3710 FEFFFFEB 		bl	CyU3PDebugPrint
 6402              	.LVL522:
 6403              	.L502:
 6404              	.LBB263:
 6405              	.LBB264:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6406              		.loc 1 1223 0
 6407 3714 B4139FE5 		ldr	r1, .L547+108
 6408 3718 0400A0E3 		mov	r0, #4
 6409 371c FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6410              		.loc 1 1224 0
 6411 3720 FA0FA0E3 		mov	r0, #1000
 6412 3724 FEFFFFEB 		bl	_tx_thread_sleep
 6413 3728 F9FFFFEA 		b	.L502
 6414              	.LVL523:
 6415              	.L541:
 6416              	.LBE264:
 6417              	.LBE263:
2292:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6418              		.loc 1 2292 0
 6419 372c 0400A0E3 		mov	r0, #4
 6420              	.LVL524:
 6421 3730 CC139FE5 		ldr	r1, .L547+160
 6422 3734 FEFFFFEB 		bl	CyU3PDebugPrint
 6423              	.LVL525:
 6424              	.L500:
 6425              	.LBB265:
 6426              	.LBB266:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6427              		.loc 1 1223 0
 6428 3738 90139FE5 		ldr	r1, .L547+108
 6429 373c 0400A0E3 		mov	r0, #4
 6430 3740 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6431              		.loc 1 1224 0
 6432 3744 FA0FA0E3 		mov	r0, #1000
 6433 3748 FEFFFFEB 		bl	_tx_thread_sleep
 6434 374c F9FFFFEA 		b	.L500
 6435              	.LVL526:
 6436              	.L535:
 6437              	.LBE266:
 6438              	.LBE265:
 6439              	.LBB267:
 6440              	.LBB258:
1947:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6441              		.loc 1 1947 0
 6442 3750 0400A0E3 		mov	r0, #4
 6443              	.LVL527:
 6444 3754 AC139FE5 		ldr	r1, .L547+164
 6445 3758 0820A0E1 		mov	r2, r8
 6446 375c FEFFFFEB 		bl	CyU3PDebugPrint
 6447              	.L484:
 6448              	.LBB245:
 6449              	.LBB246:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6450              		.loc 1 1223 0
 6451 3760 68139FE5 		ldr	r1, .L547+108
 6452 3764 0400A0E3 		mov	r0, #4
 6453 3768 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6454              		.loc 1 1224 0
 6455 376c FA0FA0E3 		mov	r0, #1000
 6456 3770 FEFFFFEB 		bl	_tx_thread_sleep
 6457 3774 F9FFFFEA 		b	.L484
 6458              	.LVL528:
 6459              	.L534:
 6460              	.LBE246:
 6461              	.LBE245:
1926:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6462              		.loc 1 1926 0
 6463 3778 0400A0E3 		mov	r0, #4
 6464              	.LVL529:
 6465 377c 58139FE5 		ldr	r1, .L547+120
 6466 3780 0320A0E1 		mov	r2, r3
 6467 3784 FEFFFFEB 		bl	CyU3PDebugPrint
 6468              	.LVL530:
 6469              	.L482:
 6470              	.LBB247:
 6471              	.LBB248:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6472              		.loc 1 1223 0
 6473 3788 40139FE5 		ldr	r1, .L547+108
 6474 378c 0400A0E3 		mov	r0, #4
 6475 3790 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6476              		.loc 1 1224 0
 6477 3794 FA0FA0E3 		mov	r0, #1000
 6478 3798 FEFFFFEB 		bl	_tx_thread_sleep
 6479 379c F9FFFFEA 		b	.L482
 6480              	.LVL531:
 6481              	.L533:
 6482              	.LBE248:
 6483              	.LBE247:
1881:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6484              		.loc 1 1881 0
 6485 37a0 0400A0E3 		mov	r0, #4
 6486 37a4 60139FE5 		ldr	r1, .L547+168
 6487 37a8 0420A0E1 		mov	r2, r4
 6488 37ac FEFFFFEB 		bl	CyU3PDebugPrint
 6489              	.L480:
 6490              	.LBB249:
 6491              	.LBB250:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6492              		.loc 1 1223 0
 6493 37b0 18139FE5 		ldr	r1, .L547+108
 6494 37b4 0400A0E3 		mov	r0, #4
 6495 37b8 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6496              		.loc 1 1224 0
 6497 37bc FA0FA0E3 		mov	r0, #1000
 6498 37c0 FEFFFFEB 		bl	_tx_thread_sleep
 6499 37c4 F9FFFFEA 		b	.L480
 6500              	.LVL532:
 6501              	.L532:
 6502              	.LBE250:
 6503              	.LBE249:
1861:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6504              		.loc 1 1861 0
 6505 37c8 0400A0E3 		mov	r0, #4
 6506              	.LVL533:
 6507 37cc 3C139FE5 		ldr	r1, .L547+172
 6508 37d0 FEFFFFEB 		bl	CyU3PDebugPrint
 6509              	.LVL534:
 6510              	.L478:
 6511              	.LBB251:
 6512              	.LBB252:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6513              		.loc 1 1223 0
 6514 37d4 F4129FE5 		ldr	r1, .L547+108
 6515 37d8 0400A0E3 		mov	r0, #4
 6516 37dc FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6517              		.loc 1 1224 0
 6518 37e0 FA0FA0E3 		mov	r0, #1000
 6519 37e4 FEFFFFEB 		bl	_tx_thread_sleep
 6520 37e8 F9FFFFEA 		b	.L478
 6521              	.LVL535:
 6522              	.L537:
 6523              	.LBE252:
 6524              	.LBE251:
1977:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6525              		.loc 1 1977 0
 6526 37ec 0400A0E3 		mov	r0, #4
 6527              	.LVL536:
 6528 37f0 1C139FE5 		ldr	r1, .L547+176
 6529 37f4 FEFFFFEB 		bl	CyU3PDebugPrint
 6530              	.LVL537:
 6531              	.L488:
 6532              	.LBB253:
 6533              	.LBB254:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6534              		.loc 1 1223 0
 6535 37f8 D0129FE5 		ldr	r1, .L547+108
 6536 37fc 0400A0E3 		mov	r0, #4
 6537 3800 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6538              		.loc 1 1224 0
 6539 3804 FA0FA0E3 		mov	r0, #1000
 6540 3808 FEFFFFEB 		bl	_tx_thread_sleep
 6541 380c F9FFFFEA 		b	.L488
 6542              	.LVL538:
 6543              	.L536:
 6544              	.LBE254:
 6545              	.LBE253:
1954:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6546              		.loc 1 1954 0
 6547 3810 040080E2 		add	r0, r0, #4
 6548 3814 FC129FE5 		ldr	r1, .L547+180
 6549 3818 FEFFFFEB 		bl	CyU3PDebugPrint
 6550              	.LVL539:
 6551              	.L486:
 6552              	.LBB255:
 6553              	.LBB256:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6554              		.loc 1 1223 0
 6555 381c AC129FE5 		ldr	r1, .L547+108
 6556 3820 0400A0E3 		mov	r0, #4
 6557 3824 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6558              		.loc 1 1224 0
 6559 3828 FA0FA0E3 		mov	r0, #1000
 6560 382c FEFFFFEB 		bl	_tx_thread_sleep
 6561 3830 F9FFFFEA 		b	.L486
 6562              	.LVL540:
 6563              	.L540:
 6564              	.LBE256:
 6565              	.LBE255:
 6566              	.LBE258:
 6567              	.LBE267:
2329:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6568              		.loc 1 2329 0
 6569 3834 88029FE5 		ldr	r0, .L547+96
 6570 3838 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6571              	.LVL541:
2330:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6572              		.loc 1 2330 0
 6573 383c 000050E3 		cmp	r0, #0
 6574 3840 0200001A 		bne	.L520
2336:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6575              		.loc 1 2336 0
 6576 3844 8300A0E3 		mov	r0, #131
 6577              	.LVL542:
 6578 3848 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6579 384c 38FFFFEA 		b	.L504
 6580              	.L520:
 6581              	.LBB268:
 6582              	.LBB269:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6583              		.loc 1 1223 0
 6584 3850 78129FE5 		ldr	r1, .L547+108
 6585 3854 0400A0E3 		mov	r0, #4
 6586 3858 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6587              		.loc 1 1224 0
 6588 385c FA0FA0E3 		mov	r0, #1000
 6589 3860 FEFFFFEB 		bl	_tx_thread_sleep
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6590              		.loc 1 1223 0
 6591 3864 64129FE5 		ldr	r1, .L547+108
 6592 3868 0400A0E3 		mov	r0, #4
 6593 386c FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6594              		.loc 1 1224 0
 6595 3870 FA0FA0E3 		mov	r0, #1000
 6596 3874 FEFFFFEB 		bl	_tx_thread_sleep
 6597 3878 F4FFFFEA 		b	.L520
 6598              	.L503:
 6599              	.LBE269:
 6600              	.LBE268:
2344:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6601              		.loc 1 2344 0
 6602 387c 00C0E0E3 		mvn	ip, #0
 6603 3880 0110A0E3 		mov	r1, #1
 6604 3884 0220A0E3 		mov	r2, #2
 6605 3888 B4308DE2 		add	r3, sp, #180
 6606 388c DC019FE5 		ldr	r0, .L547+12
 6607 3890 00C08DE5 		str	ip, [sp, #0]
 6608 3894 FEFFFFEB 		bl	_txe_event_flags_get
2348:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6609              		.loc 1 2348 0
 6610 3898 0420A0E1 		mov	r2, r4
 6611 389c 20029FE5 		ldr	r0, .L547+96
 6612 38a0 0410A0E1 		mov	r1, r4
 6613 38a4 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6614              	.LVL543:
2349:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6615              		.loc 1 2349 0
 6616 38a8 002050E2 		subs	r2, r0, #0
 6617 38ac 2F00001A 		bne	.L543
2357:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6618              		.loc 1 2357 0
 6619 38b0 383095E5 		ldr	r3, [r5, #56]
 6620 38b4 000053E3 		cmp	r3, #0
 6621 38b8 5800001A 		bne	.L509
2360:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6622              		.loc 1 2360 0
 6623 38bc 3010A0E3 		mov	r1, #48
 6624 38c0 0120A0E3 		mov	r2, #1
 6625 38c4 823083E2 		add	r3, r3, #130
 6626 38c8 2100A0E3 		mov	r0, #33
 6627              	.LVL544:
 6628 38cc FEFFFFEB 		bl	SensorSetIrisControl
2361:../uvc.c      ****                     CyU3PThreadSleep(500);
 6629              		.loc 1 2361 0
 6630 38d0 7D0FA0E3 		mov	r0, #500
 6631 38d4 FEFFFFEB 		bl	_tx_thread_sleep
2362:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6632              		.loc 1 2362 0
 6633 38d8 3010A0E3 		mov	r1, #48
 6634 38dc 0220A0E3 		mov	r2, #2
 6635 38e0 5230A0E3 		mov	r3, #82
 6636 38e4 2500A0E3 		mov	r0, #37
 6637 38e8 FEFFFFEB 		bl	SensorSetIrisControl
2363:../uvc.c      ****                     CyU3PThreadSleep(500);
 6638              		.loc 1 2363 0
 6639 38ec 7D0FA0E3 		mov	r0, #500
 6640 38f0 FEFFFFEB 		bl	_tx_thread_sleep
2364:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
 6641              		.loc 1 2364 0
 6642 38f4 3010A0E3 		mov	r1, #48
 6643 38f8 0A20A0E3 		mov	r2, #10
 6644 38fc 8230A0E3 		mov	r3, #130
 6645 3900 2300A0E3 		mov	r0, #35
 6646 3904 FEFFFFEB 		bl	SensorSetIrisControl
2365:../uvc.c      ****                    	CyU3PThreadSleep(300);
 6647              		.loc 1 2365 0
 6648 3908 4B0FA0E3 		mov	r0, #300
 6649 390c FEFFFFEB 		bl	_tx_thread_sleep
2366:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6650              		.loc 1 2366 0
 6651 3910 3010A0E3 		mov	r1, #48
 6652 3914 0420A0E1 		mov	r2, r4
 6653 3918 8230A0E3 		mov	r3, #130
 6654 391c 2100A0E3 		mov	r0, #33
 6655 3920 FEFFFFEB 		bl	SensorSetIrisControl
2367:../uvc.c      ****                     CyU3PThreadSleep(500);
 6656              		.loc 1 2367 0
 6657 3924 7D0FA0E3 		mov	r0, #500
 6658 3928 FEFFFFEB 		bl	_tx_thread_sleep
2368:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6659              		.loc 1 2368 0
 6660 392c 5230A0E3 		mov	r3, #82
 6661 3930 3010A0E3 		mov	r1, #48
 6662 3934 0420A0E1 		mov	r2, r4
 6663 3938 2500A0E3 		mov	r0, #37
 6664 393c FEFFFFEB 		bl	SensorSetIrisControl
2369:../uvc.c      ****                     CyU3PThreadSleep(500);
 6665              		.loc 1 2369 0
 6666 3940 7D0FA0E3 		mov	r0, #500
 6667 3944 FEFFFFEB 		bl	_tx_thread_sleep
 6668              	.LVL545:
 6669              	.LBB270:
 6670              	.LBB272:
2118:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6671              		.loc 1 2118 0
 6672 3948 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6673 394c 030053E3 		cmp	r3, #3
 6674 3950 2B00000A 		beq	.L544
2123:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6675              		.loc 1 2123 0
 6676 3954 020053E3 		cmp	r3, #2
 6677 3958 0D00000A 		beq	.L545
 6678              	.LVL546:
 6679              	.L512:
 6680              	.LBE272:
 6681              	.LBE270:
2371:../uvc.c      ****                     gpif_initialized = CyTrue;
 6682              		.loc 1 2371 0
 6683 395c 0110A0E3 		mov	r1, #1
2372:../uvc.c      ****                     CyU3PThreadSleep(200);
 6684              		.loc 1 2372 0
 6685 3960 C800A0E3 		mov	r0, #200
2371:../uvc.c      ****                     gpif_initialized = CyTrue;
 6686              		.loc 1 2371 0
 6687 3964 381086E5 		str	r1, [r6, #56]
2372:../uvc.c      ****                     CyU3PThreadSleep(200);
 6688              		.loc 1 2372 0
 6689 3968 FEFFFFEB 		bl	_tx_thread_sleep
 6690 396c BEFEFFEA 		b	.L496
 6691              	.LVL547:
 6692              	.L543:
2352:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6693              		.loc 1 2352 0
 6694 3970 0400A0E3 		mov	r0, #4
 6695              	.LVL548:
 6696 3974 A0119FE5 		ldr	r1, .L547+184
 6697 3978 FEFFFFEB 		bl	CyU3PDebugPrint
 6698              	.LVL549:
 6699              	.L508:
 6700              	.LBB278:
 6701              	.LBB279:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6702              		.loc 1 1223 0
 6703 397c 4C119FE5 		ldr	r1, .L547+108
 6704 3980 0400A0E3 		mov	r0, #4
 6705 3984 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6706              		.loc 1 1224 0
 6707 3988 FA0FA0E3 		mov	r0, #1000
 6708 398c FEFFFFEB 		bl	_tx_thread_sleep
 6709 3990 F9FFFFEA 		b	.L508
 6710              	.LVL550:
 6711              	.L545:
 6712              	.LBE279:
 6713              	.LBE278:
 6714              	.LBB280:
 6715              	.LBB271:
2125:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6716              		.loc 1 2125 0
 6717 3994 84119FE5 		ldr	r1, .L547+188
 6718 3998 0100A0E3 		mov	r0, #1
 6719 399c FEFFFFEB 		bl	CyU3PDebugPrint
2126:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6720              		.loc 1 2126 0
 6721 39a0 7C019FE5 		ldr	r0, .L547+192
 6722 39a4 FEFFFFEB 		bl	CyU3PGpifLoad
 6723 39a8 0020A0E1 		mov	r2, r0
 6724              	.LVL551:
 6725              	.L511:
2128:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6726              		.loc 1 2128 0
 6727 39ac 000052E3 		cmp	r2, #0
 6728 39b0 2200001A 		bne	.L546
2136:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6729              		.loc 1 2136 0
 6730 39b4 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6731 39b8 030053E3 		cmp	r3, #3
 6732 39bc 0100000A 		beq	.L521
2140:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6733              		.loc 1 2140 0
 6734 39c0 020053E3 		cmp	r3, #2
 6735 39c4 E4FFFF1A 		bne	.L512
 6736              	.L521:
2142:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6737              		.loc 1 2142 0
 6738 39c8 0200A0E1 		mov	r0, r2
 6739              	.LVL552:
 6740 39cc 0210A0E1 		mov	r1, r2
 6741 39d0 FEFFFFEB 		bl	CyU3PGpifSMStart
 6742              	.LVL553:
2144:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6743              		.loc 1 2144 0
 6744 39d4 000050E3 		cmp	r0, #0
2142:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6745              		.loc 1 2142 0
 6746 39d8 0020A0E1 		mov	r2, r0
 6747              	.LVL554:
2144:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6748              		.loc 1 2144 0
 6749 39dc DEFFFF0A 		beq	.L512
2147:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6750              		.loc 1 2147 0
 6751 39e0 0400A0E3 		mov	r0, #4
 6752              	.LVL555:
 6753 39e4 3C119FE5 		ldr	r1, .L547+196
 6754 39e8 FEFFFFEB 		bl	CyU3PDebugPrint
 6755              	.LVL556:
 6756              	.L517:
 6757              	.LBB273:
 6758              	.LBB274:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6759              		.loc 1 1223 0
 6760 39ec DC109FE5 		ldr	r1, .L547+108
 6761 39f0 0400A0E3 		mov	r0, #4
 6762 39f4 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6763              		.loc 1 1224 0
 6764 39f8 FA0FA0E3 		mov	r0, #1000
 6765 39fc FEFFFFEB 		bl	_tx_thread_sleep
 6766 3a00 F9FFFFEA 		b	.L517
 6767              	.LVL557:
 6768              	.L544:
 6769              	.LBE274:
 6770              	.LBE273:
2120:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6771              		.loc 1 2120 0
 6772 3a04 20119FE5 		ldr	r1, .L547+200
 6773 3a08 0100A0E3 		mov	r0, #1
 6774 3a0c FEFFFFEB 		bl	CyU3PDebugPrint
2121:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6775              		.loc 1 2121 0
 6776 3a10 18019FE5 		ldr	r0, .L547+204
 6777 3a14 FEFFFFEB 		bl	CyU3PGpifLoad
 6778 3a18 0020A0E1 		mov	r2, r0
 6779              	.LVL558:
 6780 3a1c E2FFFFEA 		b	.L511
 6781              	.LVL559:
 6782              	.L509:
 6783              	.LBE271:
 6784              	.LBE280:
2379:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6785              		.loc 1 2379 0
 6786 3a20 94009FE5 		ldr	r0, .L547+88
 6787              	.LVL560:
 6788 3a24 02E0A0E3 		mov	lr, #2
 6789 3a28 0410A0E1 		mov	r1, r4
 6790 3a2c 0020A0E1 		mov	r2, r0
 6791              	.LVL561:
 6792 3a30 0430A0E1 		mov	r3, r4
 6793 3a34 00E08DE5 		str	lr, [sp, #0]
 6794 3a38 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6795 3a3c 8AFEFFEA 		b	.L496
 6796              	.LVL562:
 6797              	.L546:
 6798              	.LBB281:
 6799              	.LBB277:
2131:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6800              		.loc 1 2131 0
 6801 3a40 0400A0E3 		mov	r0, #4
 6802              	.LVL563:
 6803 3a44 E8109FE5 		ldr	r1, .L547+208
 6804 3a48 FEFFFFEB 		bl	CyU3PDebugPrint
 6805              	.LVL564:
 6806              	.L514:
 6807              	.LBB275:
 6808              	.LBB276:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6809              		.loc 1 1223 0
 6810 3a4c 7C109FE5 		ldr	r1, .L547+108
 6811 3a50 0400A0E3 		mov	r0, #4
 6812 3a54 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6813              		.loc 1 1224 0
 6814 3a58 FA0FA0E3 		mov	r0, #1000
 6815 3a5c FEFFFFEB 		bl	_tx_thread_sleep
 6816 3a60 F9FFFFEA 		b	.L514
 6817              	.L548:
 6818              		.align	2
 6819              	.L547:
 6820 3a64 18060000 		.word	.LC33
 6821 3a68 00C20100 		.word	115200
 6822 3a6c A0860100 		.word	100000
 6823 3a70 00000000 		.word	.LANCHOR0
 6824 3a74 00000000 		.word	CyFxGpifCB
 6825 3a78 00000000 		.word	CyFxUVCApplnUSBSetupCB
 6826 3a7c 00000000 		.word	CyFxUVCApplnUSBEventCB
 6827 3a80 00000000 		.word	CyFxUSBDeviceDscr
 6828 3a84 00000000 		.word	CyFxUSBDeviceDscrSS
 6829 3a88 00000000 		.word	CyFxUSBDeviceQualDscr
 6830 3a8c 00000000 		.word	CyFxUSBBOSDscr
 6831 3a90 00000000 		.word	CyFxUSBHSConfigDscr
 6832 3a94 00000000 		.word	CyFxUSBFSConfigDscr
 6833 3a98 00000000 		.word	CyFxUSBSSConfigDscr
 6834 3a9c 00000000 		.word	CyFxUSBStringLangIDDscr
 6835 3aa0 00000000 		.word	CyFxUSBManufactureDscr
 6836 3aa4 00000000 		.word	CyFxUSBProductDscr
 6837 3aa8 013F0000 		.word	16129
 6838 3aac 02030000 		.word	770
 6839 3ab0 00000000 		.word	glChHandleInterStat
 6840 3ab4 00000000 		.word	glInterStaBuffer
 6841 3ab8 03030000 		.word	771
 6842 3abc 01010000 		.word	257
 6843 3ac0 00000000 		.word	CyFxUvcApplnDmaCallback
 6844 3ac4 00000000 		.word	glChHandleUVCStream
 6845 3ac8 00000000 		.word	.LANCHOR1
 6846 3acc 38060000 		.word	.LC34
 6847 3ad0 D4010000 		.word	.LC12
 6848 3ad4 54060000 		.word	.LC35
 6849 3ad8 70060000 		.word	.LC36
 6850 3adc 40080000 		.word	.LC46
 6851 3ae0 1C090000 		.word	.LC50
 6852 3ae4 A8070000 		.word	.LC43
 6853 3ae8 74070000 		.word	.LC42
 6854 3aec 40070000 		.word	.LC41
 6855 3af0 14070000 		.word	.LC40
 6856 3af4 E8060000 		.word	.LC39
 6857 3af8 C0060000 		.word	.LC38
 6858 3afc 9C060000 		.word	.LC37
 6859 3b00 70090000 		.word	.LC52
 6860 3b04 44090000 		.word	.LC51
 6861 3b08 74080000 		.word	.LC47
 6862 3b0c 10080000 		.word	.LC45
 6863 3b10 E0070000 		.word	.LC44
 6864 3b14 EC080000 		.word	.LC49
 6865 3b18 B4080000 		.word	.LC48
 6866 3b1c A4090000 		.word	.LC53
 6867 3b20 E8090000 		.word	.LC55
 6868 3b24 2C000000 		.word	.LANCHOR2+44
 6869 3b28 300A0000 		.word	.LC57
 6870 3b2c D8090000 		.word	.LC54
 6871 3b30 10000000 		.word	.LANCHOR2+16
 6872 3b34 F8090000 		.word	.LC56
 6873              	.LBE276:
 6874              	.LBE275:
 6875              	.LBE277:
 6876              	.LBE281:
 6877              		.cfi_endproc
 6878              	.LFE18:
 6880              		.align	2
 6881              		.global	CyFxUVCApplnI2CInit
 6883              	CyFxUVCApplnI2CInit:
 6884              	.LFB14:
1670:../uvc.c      **** {
 6885              		.loc 1 1670 0
 6886              		.cfi_startproc
 6887              		@ args = 0, pretend = 0, frame = 16
 6888              		@ frame_needed = 0, uses_anonymous_args = 0
 6889 3b38 04E02DE5 		str	lr, [sp, #-4]!
 6890              	.LCFI25:
 6891              		.cfi_def_cfa_offset 4
 6892 3b3c 14D04DE2 		sub	sp, sp, #20
 6893              	.LCFI26:
 6894              		.cfi_def_cfa_offset 24
1674:../uvc.c      ****     status = CyU3PI2cInit ();
 6895              		.loc 1 1674 0
 6896              		.cfi_offset 14, -4
 6897 3b40 FEFFFFEB 		bl	CyU3PI2cInit
 6898              	.LVL565:
1675:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6899              		.loc 1 1675 0
 6900 3b44 002050E2 		subs	r2, r0, #0
 6901 3b48 0B00001A 		bne	.L554
1682:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6902              		.loc 1 1682 0
 6903 3b4c 70C09FE5 		ldr	ip, .L556
1684:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6904              		.loc 1 1684 0
 6905 3b50 0030E0E3 		mvn	r3, #0
1687:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6906              		.loc 1 1687 0
 6907 3b54 0D00A0E1 		mov	r0, sp
 6908              	.LVL566:
 6909 3b58 0210A0E1 		mov	r1, r2
1682:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6910              		.loc 1 1682 0
 6911 3b5c 00C08DE5 		str	ip, [sp, #0]
1683:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6912              		.loc 1 1683 0
 6913 3b60 0C008DE9 		stmib	sp, {r2, r3}	@ phole stm
1685:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6914              		.loc 1 1685 0
 6915 3b64 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1687:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6916              		.loc 1 1687 0
 6917 3b68 FEFFFFEB 		bl	CyU3PI2cSetConfig
 6918              	.LVL567:
1688:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6919              		.loc 1 1688 0
 6920 3b6c 000050E3 		cmp	r0, #0
 6921 3b70 0A00001A 		bne	.L555
1693:../uvc.c      **** }
 6922              		.loc 1 1693 0
 6923 3b74 14D08DE2 		add	sp, sp, #20
 6924 3b78 04F09DE4 		ldmfd	sp!, {pc}
 6925              	.L554:
1677:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6926              		.loc 1 1677 0
 6927 3b7c 0400A0E3 		mov	r0, #4
 6928              	.LVL568:
 6929 3b80 40109FE5 		ldr	r1, .L556+4
 6930 3b84 FEFFFFEB 		bl	CyU3PDebugPrint
 6931              	.LVL569:
 6932              	.L551:
 6933              	.LBB286:
 6934              	.LBB287:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6935              		.loc 1 1223 0
 6936 3b88 3C109FE5 		ldr	r1, .L556+8
 6937 3b8c 0400A0E3 		mov	r0, #4
 6938 3b90 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6939              		.loc 1 1224 0
 6940 3b94 FA0FA0E3 		mov	r0, #1000
 6941 3b98 FEFFFFEB 		bl	_tx_thread_sleep
 6942 3b9c F9FFFFEA 		b	.L551
 6943              	.LVL570:
 6944              	.L555:
 6945              	.LBE287:
 6946              	.LBE286:
1690:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6947              		.loc 1 1690 0
 6948 3ba0 0400A0E3 		mov	r0, #4
 6949              	.LVL571:
 6950 3ba4 24109FE5 		ldr	r1, .L556+12
 6951 3ba8 FEFFFFEB 		bl	CyU3PDebugPrint
 6952              	.L553:
 6953              	.LBB288:
 6954              	.LBB289:
1223:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6955              		.loc 1 1223 0
 6956 3bac 18109FE5 		ldr	r1, .L556+8
 6957 3bb0 0400A0E3 		mov	r0, #4
 6958 3bb4 FEFFFFEB 		bl	CyU3PDebugPrint
1224:../uvc.c      ****         CyU3PThreadSleep (1000);
 6959              		.loc 1 1224 0
 6960 3bb8 FA0FA0E3 		mov	r0, #1000
 6961 3bbc FEFFFFEB 		bl	_tx_thread_sleep
 6962 3bc0 F9FFFFEA 		b	.L553
 6963              	.L557:
 6964              		.align	2
 6965              	.L556:
 6966 3bc4 A0860100 		.word	100000
 6967 3bc8 38060000 		.word	.LC34
 6968 3bcc D4010000 		.word	.LC12
 6969 3bd0 54060000 		.word	.LC35
 6970              	.LBE289:
 6971              	.LBE288:
 6972              		.cfi_endproc
 6973              	.LFE14:
 6975              		.align	2
 6976              		.global	CyFxApplicationDefine
 6978              	CyFxApplicationDefine:
 6979              	.LFB26:
3606:../uvc.c      **** }
3607:../uvc.c      **** 
3608:../uvc.c      **** 
3609:../uvc.c      **** /*
3610:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3611:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3612:../uvc.c      ****  */
3613:../uvc.c      **** void
3614:../uvc.c      **** CyFxApplicationDefine (
3615:../uvc.c      ****         void)
3616:../uvc.c      **** {
 6980              		.loc 1 3616 0
 6981              		.cfi_startproc
 6982              		@ args = 0, pretend = 0, frame = 40
 6983              		@ frame_needed = 0, uses_anonymous_args = 0
 6984              	.LVL572:
 6985 3bd4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 6986              	.LCFI27:
 6987              		.cfi_def_cfa_offset 36
3617:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3618:../uvc.c      ****     uint32_t retThrdCreate;
3619:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3620:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3621:../uvc.c      **** 
3622:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3623:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 6988              		.loc 1 3623 0
 6989 3bd8 010AA0E3 		mov	r0, #4096
3616:../uvc.c      **** {
 6990              		.loc 1 3616 0
 6991 3bdc 4CD04DE2 		sub	sp, sp, #76
 6992              	.LCFI28:
 6993              		.cfi_def_cfa_offset 112
 6994              		.loc 1 3623 0
 6995              		.cfi_offset 14, -4
 6996              		.cfi_offset 11, -8
 6997              		.cfi_offset 10, -12
 6998              		.cfi_offset 9, -16
 6999              		.cfi_offset 8, -20
 7000              		.cfi_offset 7, -24
 7001              		.cfi_offset 6, -28
 7002              		.cfi_offset 5, -32
 7003              		.cfi_offset 4, -36
 7004 3be0 FEFFFFEB 		bl	CyU3PMemAlloc
 7005 3be4 00A0A0E1 		mov	sl, r0
 7006              	.LVL573:
3624:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7007              		.loc 1 3624 0
 7008 3be8 010AA0E3 		mov	r0, #4096
 7009              	.LVL574:
 7010 3bec FEFFFFEB 		bl	CyU3PMemAlloc
 7011 3bf0 00B0A0E1 		mov	fp, r0
 7012              	.LVL575:
3625:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7013              		.loc 1 3625 0
 7014 3bf4 010AA0E3 		mov	r0, #4096
 7015              	.LVL576:
 7016 3bf8 FEFFFFEB 		bl	CyU3PMemAlloc
3626:../uvc.c      **** 
3627:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7017              		.loc 1 3627 0
 7018 3bfc 00005AE3 		cmp	sl, #0
 7019 3c00 00005B13 		cmpne	fp, #0
 7020 3c04 0090A013 		movne	r9, #0
 7021 3c08 0190A003 		moveq	r9, #1
3625:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7022              		.loc 1 3625 0
 7023 3c0c 24008DE5 		str	r0, [sp, #36]
 7024              	.LVL577:
 7025              		.loc 1 3627 0
 7026 3c10 0000001A 		bne	.L562
 7027              	.LVL578:
 7028              	.L559:
 7029              	.L561:
 7030 3c14 FEFFFFEA 		b	.L561
 7031              	.L562:
 7032              		.loc 1 3627 0 is_stmt 0 discriminator 1
 7033 3c18 000050E3 		cmp	r0, #0
 7034 3c1c FCFFFF0A 		beq	.L559
3628:../uvc.c      ****         goto fatalErrorHandler;
3629:../uvc.c      **** 
3630:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3631:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7035              		.loc 1 3631 0 is_stmt 1
 7036 3c20 28408DE2 		add	r4, sp, #40
 7037 3c24 0400A0E1 		mov	r0, r4
 7038 3c28 4010A0E3 		mov	r1, #64
 7039 3c2c 18219FE5 		ldr	r2, .L563
 7040 3c30 FEFFFFEB 		bl	cmdbufCreate
 7041 3c34 0450A0E1 		mov	r5, r4
 7042 3c38 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7043 3c3c 0C719FE5 		ldr	r7, .L563+4
3632:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7044              		.loc 1 3632 0
 7045 3c40 0C819FE5 		ldr	r8, .L563+8
3631:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7046              		.loc 1 3631 0
 7047 3c44 07C0A0E1 		mov	ip, r7
 7048 3c48 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7049 3c4c 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3633:../uvc.c      **** 
3634:../uvc.c      **** 	/****** initialize command descriptor ***********/
3635:../uvc.c      **** 	cmdquInit(cmdQuptr);
3636:../uvc.c      **** 	cmdquInit(statQuptr);
3637:../uvc.c      **** 
3638:../uvc.c      ****     /* Create the UVC application thread. */
3639:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7050              		.loc 1 3639 0
 7051 3c50 0860A0E3 		mov	r6, #8
3631:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7052              		.loc 1 3631 0
 7053 3c54 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3632:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7054              		.loc 1 3632 0
 7055 3c58 F8209FE5 		ldr	r2, .L563+12
 7056 3c5c 0400A0E1 		mov	r0, r4
 7057 3c60 2010A0E3 		mov	r1, #32
 7058 3c64 FEFFFFEB 		bl	cmdbufCreate
 7059 3c68 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7060 3c6c 08C0A0E1 		mov	ip, r8
 7061 3c70 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7062 3c74 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7063              		.loc 1 3639 0
 7064 3c78 0140A0E3 		mov	r4, #1
3632:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7065              		.loc 1 3632 0
 7066 3c7c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3635:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7067              		.loc 1 3635 0
 7068 3c80 0700A0E1 		mov	r0, r7
 7069 3c84 FEFFFFEB 		bl	cmdquInit
3636:../uvc.c      **** 	cmdquInit(statQuptr);
 7070              		.loc 1 3636 0
 7071 3c88 0800A0E1 		mov	r0, r8
 7072 3c8c FEFFFFEB 		bl	cmdquInit
 7073              		.loc 1 3639 0
 7074 3c90 A850A0E3 		mov	r5, #168
 7075 3c94 01CAA0E3 		mov	ip, #4096
 7076 3c98 BC009FE5 		ldr	r0, .L563+16
 7077 3c9c BC109FE5 		ldr	r1, .L563+20
 7078 3ca0 BC209FE5 		ldr	r2, .L563+24
 7079 3ca4 0930A0E1 		mov	r3, r9
 7080 3ca8 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7081 3cac 08608DE5 		str	r6, [sp, #8]
 7082 3cb0 0C608DE5 		str	r6, [sp, #12]
 7083 3cb4 10908DE5 		str	r9, [sp, #16]
 7084 3cb8 14408DE5 		str	r4, [sp, #20]
 7085 3cbc 18508DE5 		str	r5, [sp, #24]
 7086 3cc0 FEFFFFEB 		bl	_txe_thread_create
 7087              	.LVL579:
3640:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3641:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3642:../uvc.c      ****             0,                                          /* No input parameter to thread */
3643:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3644:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3645:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3646:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3647:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3648:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3649:../uvc.c      ****             );
3650:../uvc.c      ****     if (retThrdCreate != 0)
 7088              		.loc 1 3650 0
 7089 3cc4 00C050E2 		subs	ip, r0, #0
 7090 3cc8 D1FFFF1A 		bne	.L559
3651:../uvc.c      ****     {
3652:../uvc.c      ****         goto fatalErrorHandler;
3653:../uvc.c      ****     }
3654:../uvc.c      **** 
3655:../uvc.c      ****     /* Create the control request handling thread. */
3656:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7091              		.loc 1 3656 0
 7092 3ccc 0C30A0E1 		mov	r3, ip
 7093 3cd0 027BA0E3 		mov	r7, #2048
 7094 3cd4 8C009FE5 		ldr	r0, .L563+28
 7095              	.LVL580:
 7096 3cd8 8C109FE5 		ldr	r1, .L563+32
 7097 3cdc 8C209FE5 		ldr	r2, .L563+36
 7098 3ce0 10C08DE5 		str	ip, [sp, #16]
 7099 3ce4 00B08DE5 		str	fp, [sp, #0]
 7100 3ce8 04708DE5 		str	r7, [sp, #4]
 7101 3cec 08608DE5 		str	r6, [sp, #8]
 7102 3cf0 0C608DE5 		str	r6, [sp, #12]
 7103 3cf4 14408DE5 		str	r4, [sp, #20]
 7104 3cf8 18508DE5 		str	r5, [sp, #24]
 7105 3cfc FEFFFFEB 		bl	_txe_thread_create
 7106              	.LVL581:
3657:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3658:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3659:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3660:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3661:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3662:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3663:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3664:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3665:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3666:../uvc.c      ****             );
3667:../uvc.c      ****     if (retThrdCreate != 0)
 7107              		.loc 1 3667 0
 7108 3d00 00C050E2 		subs	ip, r0, #0
 7109 3d04 C2FFFF1A 		bne	.L559
3668:../uvc.c      ****     {
3669:../uvc.c      ****         goto fatalErrorHandler;
3670:../uvc.c      ****     }
3671:../uvc.c      **** #if 1
3672:../uvc.c      ****     /* Create the I2C control command handling thread. */
3673:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7110              		.loc 1 3673 0
 7111 3d08 24E09DE5 		ldr	lr, [sp, #36]
 7112 3d0c 60009FE5 		ldr	r0, .L563+40
 7113              	.LVL582:
 7114 3d10 60109FE5 		ldr	r1, .L563+44
 7115 3d14 60209FE5 		ldr	r2, .L563+48
 7116 3d18 0C30A0E1 		mov	r3, ip
 7117 3d1c 00E08DE5 		str	lr, [sp, #0]
 7118 3d20 04708DE5 		str	r7, [sp, #4]
 7119 3d24 08608DE5 		str	r6, [sp, #8]
 7120 3d28 0C608DE5 		str	r6, [sp, #12]
 7121 3d2c 10C08DE5 		str	ip, [sp, #16]
 7122 3d30 14408DE5 		str	r4, [sp, #20]
 7123 3d34 18508DE5 		str	r5, [sp, #24]
 7124 3d38 FEFFFFEB 		bl	_txe_thread_create
 7125              	.LVL583:
3674:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3675:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3676:../uvc.c      ****             0,                                          /* No input parameter to thread */
3677:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3678:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3679:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3680:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3681:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3682:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3683:../uvc.c      ****             );
3684:../uvc.c      ****     if (retThrdCreate != 0)
 7126              		.loc 1 3684 0
 7127 3d3c 000050E3 		cmp	r0, #0
 7128 3d40 B3FFFF1A 		bne	.L559
3685:../uvc.c      ****     {
3686:../uvc.c      ****         goto fatalErrorHandler;
3687:../uvc.c      ****     }
3688:../uvc.c      **** #endif
3689:../uvc.c      **** 
3690:../uvc.c      ****     return;
3691:../uvc.c      **** 
3692:../uvc.c      **** fatalErrorHandler:
3693:../uvc.c      ****     /* Add custom recovery or debug actions here */
3694:../uvc.c      ****     /* Loop indefinitely */
3695:../uvc.c      ****     while (1);
3696:../uvc.c      **** }
 7129              		.loc 1 3696 0
 7130 3d44 4CD08DE2 		add	sp, sp, #76
 7131 3d48 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7132              	.L564:
 7133              		.align	2
 7134              	.L563:
 7135 3d4c 00000000 		.word	cmdQuMux
 7136 3d50 00000000 		.word	cmdQu
 7137 3d54 00000000 		.word	statQu
 7138 3d58 00000000 		.word	staQuMux
 7139 3d5c 9C000000 		.word	.LANCHOR0+156
 7140 3d60 680A0000 		.word	.LC58
 7141 3d64 00000000 		.word	UVCAppThread_Entry
 7142 3d68 44010000 		.word	.LANCHOR0+324
 7143 3d6c 7C0A0000 		.word	.LC59
 7144 3d70 00000000 		.word	UVCAppEP0Thread_Entry
 7145 3d74 EC010000 		.word	.LANCHOR0+492
 7146 3d78 940A0000 		.word	.LC60
 7147 3d7c 00000000 		.word	I2cAppThread_Entry
 7148              		.cfi_endproc
 7149              	.LFE26:
 7151              		.align	2
 7152              		.global	main
 7154              	main:
 7155              	.LFB27:
3697:../uvc.c      **** 
3698:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3699:../uvc.c      ****  * the ThreadX RTOS here.
3700:../uvc.c      ****  */
3701:../uvc.c      **** int
3702:../uvc.c      **** main (
3703:../uvc.c      ****         void)
3704:../uvc.c      **** {
 7156              		.loc 1 3704 0
 7157              		.cfi_startproc
 7158              		@ args = 0, pretend = 0, frame = 56
 7159              		@ frame_needed = 0, uses_anonymous_args = 0
 7160 3d80 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7161              	.LCFI29:
 7162              		.cfi_def_cfa_offset 12
3705:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3706:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3707:../uvc.c      **** 
3708:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3709:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3710:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3711:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3712:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3713:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7163              		.loc 1 3713 0
 7164 3d84 0010A0E3 		mov	r1, #0
3704:../uvc.c      **** {
 7165              		.loc 1 3704 0
 7166 3d88 3CD04DE2 		sub	sp, sp, #60
 7167              	.LCFI30:
 7168              		.cfi_def_cfa_offset 72
3710:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7169              		.loc 1 3710 0
 7170 3d8c 0220A0E3 		mov	r2, #2
3714:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7171              		.loc 1 3714 0
 7172 3d90 033081E2 		add	r3, r1, #3
3709:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7173              		.loc 1 3709 0
 7174 3d94 0150A0E3 		mov	r5, #1
 7175              		.cfi_offset 14, -4
 7176              		.cfi_offset 5, -8
 7177              		.cfi_offset 4, -12
3715:../uvc.c      **** 
3716:../uvc.c      ****     /* Initialize the device */
3717:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7178              		.loc 1 3717 0
 7179 3d98 28008DE2 		add	r0, sp, #40
3709:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7180              		.loc 1 3709 0
 7181 3d9c 28508DE5 		str	r5, [sp, #40]
3710:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7182              		.loc 1 3710 0
 7183 3da0 2C20CDE5 		strb	r2, [sp, #44]
3711:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7184              		.loc 1 3711 0
 7185 3da4 2D20CDE5 		strb	r2, [sp, #45]
3712:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7186              		.loc 1 3712 0
 7187 3da8 2E20CDE5 		strb	r2, [sp, #46]
3713:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7188              		.loc 1 3713 0
 7189 3dac 30108DE5 		str	r1, [sp, #48]
3714:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7190              		.loc 1 3714 0
 7191 3db0 3430CDE5 		strb	r3, [sp, #52]
 7192              		.loc 1 3717 0
 7193 3db4 FEFFFFEB 		bl	CyU3PDeviceInit
 7194              	.LVL584:
3718:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7195              		.loc 1 3718 0
 7196 3db8 004050E2 		subs	r4, r0, #0
 7197 3dbc 0000000A 		beq	.L568
 7198              	.L566:
 7199              	.L567:
 7200 3dc0 FEFFFFEA 		b	.L567
 7201              	.L568:
3719:../uvc.c      ****     {
3720:../uvc.c      ****         goto handle_fatal_error;
3721:../uvc.c      ****     }
3722:../uvc.c      **** 
3723:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3724:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7202              		.loc 1 3724 0
 7203 3dc4 0410A0E1 		mov	r1, r4
 7204 3dc8 0420A0E1 		mov	r2, r4
 7205 3dcc 0500A0E1 		mov	r0, r5
 7206              	.LVL585:
 7207 3dd0 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7208              	.LVL586:
3725:../uvc.c      **** 
3726:../uvc.c      ****     /* Configure the IO matrix for the device. */
3727:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3728:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3729:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3730:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3731:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3732:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3733:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3734:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3735:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3736:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3737:../uvc.c      **** 
3738:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7209              		.loc 1 3738 0
 7210 3dd4 0D00A0E1 		mov	r0, sp
3728:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7211              		.loc 1 3728 0
 7212 3dd8 1640CDE5 		strb	r4, [sp, #22]
3729:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7213              		.loc 1 3729 0
 7214 3ddc 18408DE5 		str	r4, [sp, #24]
3730:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7215              		.loc 1 3730 0
 7216 3de0 1C408DE5 		str	r4, [sp, #28]
3731:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7217              		.loc 1 3731 0
 7218 3de4 20408DE5 		str	r4, [sp, #32]
3732:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7219              		.loc 1 3732 0
 7220 3de8 24408DE5 		str	r4, [sp, #36]
3735:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7221              		.loc 1 3735 0
 7222 3dec 0C408DE5 		str	r4, [sp, #12]
3736:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7223              		.loc 1 3736 0
 7224 3df0 10408DE5 		str	r4, [sp, #16]
3727:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7225              		.loc 1 3727 0
 7226 3df4 00508DE5 		str	r5, [sp, #0]
3733:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7227              		.loc 1 3733 0
 7228 3df8 04508DE5 		str	r5, [sp, #4]
3734:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7229              		.loc 1 3734 0
 7230 3dfc 08508DE5 		str	r5, [sp, #8]
 7231              		.loc 1 3738 0
 7232 3e00 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7233              	.LVL587:
3739:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7234              		.loc 1 3739 0
 7235 3e04 004050E2 		subs	r4, r0, #0
 7236 3e08 ECFFFF1A 		bne	.L566
3740:../uvc.c      ****     {
3741:../uvc.c      ****         goto handle_fatal_error;
3742:../uvc.c      ****     }
3743:../uvc.c      **** 
3744:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3745:../uvc.c      ****     CyU3PKernelEntry ();
 7237              		.loc 1 3745 0
 7238 3e0c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7239              	.LVL588:
3746:../uvc.c      **** 
3747:../uvc.c      ****     /* Dummy return to make the compiler happy */
3748:../uvc.c      ****     return 0;
3749:../uvc.c      **** 
3750:../uvc.c      **** handle_fatal_error:
3751:../uvc.c      ****     /* Cannot recover from this error. */
3752:../uvc.c      ****     while (1);
3753:../uvc.c      **** }
 7240              		.loc 1 3753 0
 7241 3e10 0400A0E1 		mov	r0, r4
 7242 3e14 3CD08DE2 		add	sp, sp, #60
 7243 3e18 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7244              		.cfi_endproc
 7245              	.LFE27:
 7247              		.global	CyFxGpifTransition
 7248              		.global	CyFxGpifWavedata
 7249              		.global	CyFxGpifWavedataPosition
 7250              		.global	CyFxGpifRegValue
 7251              		.global	CyFxGpifConfig
 7252              		.global	CyFxGpifTransition_usb2
 7253              		.global	CyFxGpifWavedata_usb2
 7254              		.global	CyFxGpifWavedataPosition_usb2
 7255              		.global	CyFxGpifRegValue_usb2
 7256              		.global	CyFxGpifConfig_usb2
 7257              		.global	snapButFlag
 7258              		.global	testSnap
 7259              		.global	fb
 7260              		.global	pb
 7261              		.global	pbc
 7262              		.global	fbbak
 7263              		.global	pbbak
 7264              		.global	pbcbak
 7265              		.global	pbcpbak
 7266              		.global	isUsbConnected
 7267              		.global	usbSpeed
 7268              		.global	clearFeatureRqtReceived
 7269              		.global	streamingStarted
 7270              		.global	glProbeCtrl
 7271              		.global	glProbeStilCtrl
 7272              		.global	glProbeCtrl20
 7273              		.global	glProbeStilCtrl20
 7274              		.global	glUVCHeader
 7275              		.comm	glChHandleUVCStream,220,4
 7276              		.comm	glChHandleStillStream,220,4
 7277              		.comm	glChHandleInterStat,160,4
 7278              		.comm	glInterStaBuffer,4,4
 7279              		.comm	cmdQu,32,4
 7280              		.comm	statQu,32,4
 7281              		.comm	cmdQuMux,56,4
 7282              		.comm	staQuMux,56,4
 7283              		.comm	timMux,56,4
 7284              		.comm	bmReqType,1,1
 7285              		.comm	bRequest,1,1
 7286              		.comm	wValue,2,2
 7287              		.comm	wIndex,2,2
 7288              		.comm	wLength,2,2
 7289              		.comm	posTick,4,4
 7290              		.comm	I2CCmdTimer,44,4
 7291              		.section	.rodata
 7292              		.align	2
 7293              		.set	.LANCHOR2,. + 0
 7296              	ExTime:
 7297 0000 9C       		.byte	-100
 7298 0001 00       		.byte	0
 7299 0002 4E       		.byte	78
 7300 0003 00       		.byte	0
 7301 0004 27       		.byte	39
 7302 0005 00       		.byte	0
 7303 0006 14       		.byte	20
 7304 0007 00       		.byte	0
 7305 0008 0A       		.byte	10
 7306 0009 00       		.byte	0
 7307 000a 05       		.byte	5
 7308 000b 00       		.byte	0
 7309 000c 02       		.byte	2
 7310 000d 00       		.byte	0
 7311 000e 01       		.byte	1
 7312 000f 00       		.byte	0
 7315              	CyFxGpifConfig:
 7316 0010 0F00     		.short	15
 7317 0012 0000     		.space	2
 7318 0014 00000000 		.word	CyFxGpifWavedata
 7319 0018 00000000 		.word	CyFxGpifWavedataPosition
 7320 001c 0500     		.short	5
 7321 001e 0000     		.space	2
 7322 0020 00000000 		.word	CyFxGpifTransition
 7323 0024 4C00     		.short	76
 7324 0026 0000     		.space	2
 7325 0028 00000000 		.word	CyFxGpifRegValue
 7328              	CyFxGpifConfig_usb2:
 7329 002c 9300     		.short	147
 7330 002e 0000     		.space	2
 7331 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7332 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7333 0038 0800     		.short	8
 7334 003a 0000     		.space	2
 7335 003c 00000000 		.word	CyFxGpifTransition_usb2
 7336 0040 4C00     		.short	76
 7337 0042 0000     		.space	2
 7338 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7339              		.data
 7340              		.align	2
 7341              		.set	.LANCHOR1,. + 0
 7344              	ExUCtrlParArry:
 7345 0000 13       		.byte	19
 7346 0001 14       		.byte	20
 7347 0002 02       		.byte	2
 7348 0003 01       		.byte	1
 7349 0004 00       		.byte	0
 7350 0005 03       		.byte	3
 7351 0006 00       		.byte	0
 7352 0007 01       		.byte	1
 7353 0008 00       		.byte	0
 7354 0009 03       		.byte	3
 7355 000a 00       		.byte	0
 7356 000b 23       		.byte	35
 7357 000c 37       		.byte	55
 7358 000d 23       		.byte	35
 7359 000e 37       		.byte	55
 7360 000f 30       		.byte	48
 7361 0010 01       		.byte	1
 7362 0011 00       		.byte	0
 7363 0012 00       		.byte	0
 7364 0013 00000000 		.space	5
 7364      00
 7365 0018 11       		.byte	17
 7366 0019 00       		.byte	0
 7367 001a 02       		.byte	2
 7368 001b 01       		.byte	1
 7369 001c 00       		.byte	0
 7370 001d 03       		.byte	3
 7371 001e 00       		.byte	0
 7372 001f 01       		.byte	1
 7373 0020 00       		.byte	0
 7374 0021 03       		.byte	3
 7375 0022 00       		.byte	0
 7376 0023 01       		.byte	1
 7377 0024 00       		.byte	0
 7378 0025 01       		.byte	1
 7379 0026 00       		.byte	0
 7380 0027 30       		.byte	48
 7381 0028 01       		.byte	1
 7382 0029 01       		.byte	1
 7383 002a 00       		.byte	0
 7384 002b 00000000 		.space	5
 7384      00
 7385 0030 17       		.byte	23
 7386 0031 00       		.byte	0
 7387 0032 01       		.byte	1
 7388 0033 01       		.byte	1
 7389 0034 00       		.byte	0
 7390 0035 02       		.byte	2
 7391 0036 00       		.byte	0
 7392 0037 01       		.byte	1
 7393 0038 00       		.byte	0
 7394 0039 03       		.byte	3
 7395 003a 00       		.byte	0
 7396 003b 00       		.byte	0
 7397 003c 00       		.byte	0
 7398 003d 00       		.byte	0
 7399 003e 00       		.byte	0
 7400 003f 30       		.byte	48
 7401 0040 01       		.byte	1
 7402 0041 01       		.byte	1
 7403 0042 00       		.byte	0
 7404 0043 00000000 		.space	5
 7404      00
 7405 0048 00       		.byte	0
 7406 0049 00       		.byte	0
 7407 004a 04       		.byte	4
 7408 004b 01       		.byte	1
 7409 004c 00       		.byte	0
 7410 004d 38       		.byte	56
 7411 004e 01       		.byte	1
 7412 004f 01       		.byte	1
 7413 0050 00       		.byte	0
 7414 0051 03       		.byte	3
 7415 0052 00       		.byte	0
 7416 0053 4E       		.byte	78
 7417 0054 00       		.byte	0
 7418 0055 4E       		.byte	78
 7419 0056 00       		.byte	0
 7420 0057 30       		.byte	48
 7421 0058 01       		.byte	1
 7422 0059 00       		.byte	0
 7423 005a 00       		.byte	0
 7424 005b 00000000 		.space	5
 7424      00
 7425 0060 00       		.byte	0
 7426 0061 00       		.byte	0
 7427 0062 01       		.byte	1
 7428 0063 00       		.byte	0
 7429 0064 00       		.byte	0
 7430 0065 00       		.byte	0
 7431 0066 00       		.byte	0
 7432 0067 01       		.byte	1
 7433 0068 00       		.byte	0
 7434 0069 03       		.byte	3
 7435 006a 00       		.byte	0
 7436 006b 00       		.byte	0
 7437 006c 00       		.byte	0
 7438 006d 00       		.byte	0
 7439 006e 00       		.byte	0
 7440 006f 30       		.byte	48
 7441 0070 01       		.byte	1
 7442 0071 00       		.byte	0
 7443 0072 00       		.byte	0
 7444 0073 00000000 		.space	5
 7444      00
 7445 0078 00       		.byte	0
 7446 0079 00       		.byte	0
 7447 007a 02       		.byte	2
 7448 007b 00       		.byte	0
 7449 007c 00       		.byte	0
 7450 007d FF       		.byte	-1
 7451 007e 00       		.byte	0
 7452 007f 01       		.byte	1
 7453 0080 00       		.byte	0
 7454 0081 03       		.byte	3
 7455 0082 00       		.byte	0
 7456 0083 01       		.byte	1
 7457 0084 00       		.byte	0
 7458 0085 00       		.byte	0
 7459 0086 00       		.byte	0
 7460 0087 30       		.byte	48
 7461 0088 01       		.byte	1
 7462 0089 01       		.byte	1
 7463 008a 00       		.byte	0
 7464 008b 00000000 		.space	5
 7464      00
 7465 0090 00       		.byte	0
 7466 0091 00       		.byte	0
 7467 0092 02       		.byte	2
 7468 0093 00       		.byte	0
 7469 0094 00       		.byte	0
 7470 0095 00       		.byte	0
 7471 0096 00       		.byte	0
 7472 0097 00       		.byte	0
 7473 0098 00       		.byte	0
 7474 0099 03       		.byte	3
 7475 009a 00       		.byte	0
 7476 009b 00       		.byte	0
 7477 009c 00       		.byte	0
 7478 009d 00       		.byte	0
 7479 009e 00       		.byte	0
 7480 009f 30       		.byte	48
 7481 00a0 01       		.byte	1
 7482 00a1 01       		.byte	1
 7483 00a2 00       		.byte	0
 7484 00a3 00000000 		.space	5
 7484      00
 7485 00a8 00       		.byte	0
 7486 00a9 00       		.byte	0
 7487 00aa 02       		.byte	2
 7488 00ab 00       		.byte	0
 7489 00ac 00       		.byte	0
 7490 00ad 30       		.byte	48
 7491 00ae 00       		.byte	0
 7492 00af 01       		.byte	1
 7493 00b0 00       		.byte	0
 7494 00b1 03       		.byte	3
 7495 00b2 0A       		.byte	10
 7496 00b3 00       		.byte	0
 7497 00b4 00       		.byte	0
 7498 00b5 0A       		.byte	10
 7499 00b6 00       		.byte	0
 7500 00b7 30       		.byte	48
 7501 00b8 01       		.byte	1
 7502 00b9 01       		.byte	1
 7503 00ba 00       		.byte	0
 7504 00bb 00000000 		.space	5
 7504      00
 7505 00c0 00       		.byte	0
 7506 00c1 00       		.byte	0
 7507 00c2 01       		.byte	1
 7508 00c3 00       		.byte	0
 7509 00c4 00       		.byte	0
 7510 00c5 7F       		.byte	127
 7511 00c6 00       		.byte	0
 7512 00c7 01       		.byte	1
 7513 00c8 00       		.byte	0
 7514 00c9 03       		.byte	3
 7515 00ca 00       		.byte	0
 7516 00cb 00       		.byte	0
 7517 00cc 00       		.byte	0
 7518 00cd 00       		.byte	0
 7519 00ce 00       		.byte	0
 7520 00cf 30       		.byte	48
 7521 00d0 01       		.byte	1
 7522 00d1 00       		.byte	0
 7523 00d2 00       		.byte	0
 7524 00d3 00000000 		.space	5
 7524      00
 7525 00d8 00       		.byte	0
 7526 00d9 00       		.byte	0
 7527 00da 02       		.byte	2
 7528 00db 00       		.byte	0
 7529 00dc 00       		.byte	0
 7530 00dd 05       		.byte	5
 7531 00de 00       		.byte	0
 7532 00df 01       		.byte	1
 7533 00e0 00       		.byte	0
 7534 00e1 03       		.byte	3
 7535 00e2 00       		.byte	0
 7536 00e3 00       		.byte	0
 7537 00e4 00       		.byte	0
 7538 00e5 00       		.byte	0
 7539 00e6 00       		.byte	0
 7540 00e7 30       		.byte	48
 7541 00e8 01       		.byte	1
 7542 00e9 00       		.byte	0
 7543 00ea 00       		.byte	0
 7544 00eb 00000000 		.space	5
 7544      00
 7545 00f0 00       		.byte	0
 7546 00f1 00       		.byte	0
 7547 00f2 03       		.byte	3
 7548 00f3 00       		.byte	0
 7549 00f4 00       		.byte	0
 7550 00f5 0A       		.byte	10
 7551 00f6 00       		.byte	0
 7552 00f7 01       		.byte	1
 7553 00f8 00       		.byte	0
 7554 00f9 03       		.byte	3
 7555 00fa 00       		.byte	0
 7556 00fb 00       		.byte	0
 7557 00fc 00       		.byte	0
 7558 00fd 00       		.byte	0
 7559 00fe 00       		.byte	0
 7560 00ff 30       		.byte	48
 7561 0100 01       		.byte	1
 7562 0101 00       		.byte	0
 7563 0102 00       		.byte	0
 7564 0103 00000000 		.space	5
 7564      00
 7565 0108 00       		.byte	0
 7566 0109 00       		.byte	0
 7567 010a 02       		.byte	2
 7568 010b 00       		.byte	0
 7569 010c 00       		.byte	0
 7570 010d 40       		.byte	64
 7571 010e 00       		.byte	0
 7572 010f 01       		.byte	1
 7573 0110 00       		.byte	0
 7574 0111 03       		.byte	3
 7575 0112 00       		.byte	0
 7576 0113 0F       		.byte	15
 7577 0114 11       		.byte	17
 7578 0115 00       		.byte	0
 7579 0116 00       		.byte	0
 7580 0117 30       		.byte	48
 7581 0118 01       		.byte	1
 7582 0119 00       		.byte	0
 7583 011a 00       		.byte	0
 7584 011b 00000000 		.space	5
 7584      00
 7585 0120 00       		.byte	0
 7586 0121 00       		.byte	0
 7587 0122 02       		.byte	2
 7588 0123 00       		.byte	0
 7589 0124 00       		.byte	0
 7590 0125 64       		.byte	100
 7591 0126 00       		.byte	0
 7592 0127 01       		.byte	1
 7593 0128 00       		.byte	0
 7594 0129 03       		.byte	3
 7595 012a 00       		.byte	0
 7596 012b 00       		.byte	0
 7597 012c 00       		.byte	0
 7598 012d 00       		.byte	0
 7599 012e 00       		.byte	0
 7600 012f 30       		.byte	48
 7601 0130 01       		.byte	1
 7602 0131 00       		.byte	0
 7603 0132 00       		.byte	0
 7604 0133 00000000 		.space	5
 7604      00
 7605 0138 00       		.byte	0
 7606 0139 00       		.byte	0
 7607 013a 02       		.byte	2
 7608 013b 00       		.byte	0
 7609 013c 00       		.byte	0
 7610 013d 64       		.byte	100
 7611 013e 00       		.byte	0
 7612 013f 01       		.byte	1
 7613 0140 00       		.byte	0
 7614 0141 03       		.byte	3
 7615 0142 00       		.byte	0
 7616 0143 00       		.byte	0
 7617 0144 00       		.byte	0
 7618 0145 00       		.byte	0
 7619 0146 00       		.byte	0
 7620 0147 30       		.byte	48
 7621 0148 01       		.byte	1
 7622 0149 00       		.byte	0
 7623 014a 00       		.byte	0
 7624 014b 00000000 		.space	5
 7624      00
 7625 0150 00       		.byte	0
 7626 0151 00       		.byte	0
 7627 0152 02       		.byte	2
 7628 0153 00       		.byte	0
 7629 0154 00       		.byte	0
 7630 0155 64       		.byte	100
 7631 0156 00       		.byte	0
 7632 0157 01       		.byte	1
 7633 0158 00       		.byte	0
 7634 0159 03       		.byte	3
 7635 015a 00       		.byte	0
 7636 015b 00       		.byte	0
 7637 015c 00       		.byte	0
 7638 015d 00       		.byte	0
 7639 015e 00       		.byte	0
 7640 015f 30       		.byte	48
 7641 0160 01       		.byte	1
 7642 0161 00       		.byte	0
 7643 0162 00       		.byte	0
 7644 0163 00000000 		.space	5
 7644      00
 7645 0168 00       		.byte	0
 7646 0169 00       		.byte	0
 7647 016a 02       		.byte	2
 7648 016b 00       		.byte	0
 7649 016c 00       		.byte	0
 7650 016d 64       		.byte	100
 7651 016e 00       		.byte	0
 7652 016f 01       		.byte	1
 7653 0170 00       		.byte	0
 7654 0171 03       		.byte	3
 7655 0172 00       		.byte	0
 7656 0173 00       		.byte	0
 7657 0174 00       		.byte	0
 7658 0175 00       		.byte	0
 7659 0176 00       		.byte	0
 7660 0177 30       		.byte	48
 7661 0178 01       		.byte	1
 7662 0179 00       		.byte	0
 7663 017a 00       		.byte	0
 7664 017b 00000000 		.space	5
 7664      00
 7667              	CtrlParArry:
 7668 0180 10       		.byte	16
 7669 0181 10       		.byte	16
 7670 0182 02       		.byte	2
 7671 0183 00       		.byte	0
 7672 0184 00       		.byte	0
 7673 0185 03       		.byte	3
 7674 0186 00       		.byte	0
 7675 0187 01       		.byte	1
 7676 0188 00       		.byte	0
 7677 0189 03       		.byte	3
 7678 018a 00       		.byte	0
 7679 018b 00       		.byte	0
 7680 018c 00       		.byte	0
 7681 018d 03       		.byte	3
 7682 018e 00       		.byte	0
 7683 018f 30       		.byte	48
 7684 0190 01       		.byte	1
 7685 0191 00       		.byte	0
 7686 0192 00       		.byte	0
 7687 0193 00000000 		.space	5
 7687      00
 7688 0198 01       		.byte	1
 7689 0199 00       		.byte	0
 7690 019a 02       		.byte	2
 7691 019b 00       		.byte	0
 7692 019c 00       		.byte	0
 7693 019d FF       		.byte	-1
 7694 019e 00       		.byte	0
 7695 019f 01       		.byte	1
 7696 01a0 00       		.byte	0
 7697 01a1 03       		.byte	3
 7698 01a2 00       		.byte	0
 7699 01a3 76       		.byte	118
 7700 01a4 00       		.byte	0
 7701 01a5 76       		.byte	118
 7702 01a6 C7       		.byte	-57
 7703 01a7 C6       		.byte	-58
 7704 01a8 01       		.byte	1
 7705 01a9 01       		.byte	1
 7706 01aa 00       		.byte	0
 7707 01ab 00000000 		.space	5
 7707      00
 7708 01b0 02       		.byte	2
 7709 01b1 02       		.byte	2
 7710 01b2 02       		.byte	2
 7711 01b3 00       		.byte	0
 7712 01b4 00       		.byte	0
 7713 01b5 FF       		.byte	-1
 7714 01b6 00       		.byte	0
 7715 01b7 01       		.byte	1
 7716 01b8 00       		.byte	0
 7717 01b9 03       		.byte	3
 7718 01ba 00       		.byte	0
 7719 01bb 70       		.byte	112
 7720 01bc 00       		.byte	0
 7721 01bd 70       		.byte	112
 7722 01be 00       		.byte	0
 7723 01bf C6       		.byte	-58
 7724 01c0 01       		.byte	1
 7725 01c1 01       		.byte	1
 7726 01c2 00       		.byte	0
 7727 01c3 00000000 		.space	5
 7727      00
 7728 01c8 00       		.byte	0
 7729 01c9 00       		.byte	0
 7730 01ca 02       		.byte	2
 7731 01cb 00       		.byte	0
 7732 01cc 00       		.byte	0
 7733 01cd 64       		.byte	100
 7734 01ce 00       		.byte	0
 7735 01cf 01       		.byte	1
 7736 01d0 00       		.byte	0
 7737 01d1 03       		.byte	3
 7738 01d2 00       		.byte	0
 7739 01d3 00       		.byte	0
 7740 01d4 00       		.byte	0
 7741 01d5 00       		.byte	0
 7742 01d6 00       		.byte	0
 7743 01d7 30       		.byte	48
 7744 01d8 01       		.byte	1
 7745 01d9 00       		.byte	0
 7746 01da 00       		.byte	0
 7747 01db 00000000 		.space	5
 7747      00
 7748 01e0 07       		.byte	7
 7749 01e1 07       		.byte	7
 7750 01e2 02       		.byte	2
 7751 01e3 00       		.byte	0
 7752 01e4 00       		.byte	0
 7753 01e5 01       		.byte	1
 7754 01e6 00       		.byte	0
 7755 01e7 01       		.byte	1
 7756 01e8 00       		.byte	0
 7757 01e9 03       		.byte	3
 7758 01ea 00       		.byte	0
 7759 01eb 01       		.byte	1
 7760 01ec 00       		.byte	0
 7761 01ed 01       		.byte	1
 7762 01ee 00       		.byte	0
 7763 01ef 30       		.byte	48
 7764 01f0 01       		.byte	1
 7765 01f1 00       		.byte	0
 7766 01f2 00       		.byte	0
 7767 01f3 00000000 		.space	5
 7767      00
 7768 01f8 DF       		.byte	-33
 7769 01f9 E1       		.byte	-31
 7770 01fa 02       		.byte	2
 7771 01fb 00       		.byte	0
 7772 01fc 00       		.byte	0
 7773 01fd FF       		.byte	-1
 7774 01fe 00       		.byte	0
 7775 01ff 01       		.byte	1
 7776 0200 00       		.byte	0
 7777 0201 03       		.byte	3
 7778 0202 00       		.byte	0
 7779 0203 80       		.byte	-128
 7780 0204 00       		.byte	0
 7781 0205 00       		.byte	0
 7782 0206 00       		.byte	0
 7783 0207 C6       		.byte	-58
 7784 0208 01       		.byte	1
 7785 0209 01       		.byte	1
 7786 020a 00       		.byte	0
 7787 020b 00000000 		.space	5
 7787      00
 7788 0210 85       		.byte	-123
 7789 0211 86       		.byte	-122
 7790 0212 02       		.byte	2
 7791 0213 00       		.byte	0
 7792 0214 00       		.byte	0
 7793 0215 64       		.byte	100
 7794 0216 00       		.byte	0
 7795 0217 01       		.byte	1
 7796 0218 00       		.byte	0
 7797 0219 03       		.byte	3
 7798 021a 00       		.byte	0
 7799 021b 32       		.byte	50
 7800 021c 00       		.byte	0
 7801 021d 32       		.byte	50
 7802 021e 00       		.byte	0
 7803 021f F2       		.byte	-14
 7804 0220 01       		.byte	1
 7805 0221 01       		.byte	1
 7806 0222 00       		.byte	0
 7807 0223 00000000 		.space	5
 7807      00
 7808 0228 06       		.byte	6
 7809 0229 06       		.byte	6
 7810 022a 02       		.byte	2
 7811 022b 00       		.byte	0
 7812 022c 00       		.byte	0
 7813 022d 40       		.byte	64
 7814 022e 00       		.byte	0
 7815 022f 01       		.byte	1
 7816 0230 00       		.byte	0
 7817 0231 03       		.byte	3
 7818 0232 00       		.byte	0
 7819 0233 20       		.byte	32
 7820 0234 00       		.byte	0
 7821 0235 20       		.byte	32
 7822 0236 00       		.byte	0
 7823 0237 30       		.byte	48
 7824 0238 01       		.byte	1
 7825 0239 01       		.byte	1
 7826 023a 00       		.byte	0
 7827 023b 00000000 		.space	5
 7827      00
 7828 0240 00       		.byte	0
 7829 0241 00       		.byte	0
 7830 0242 02       		.byte	2
 7831 0243 00       		.byte	0
 7832 0244 00       		.byte	0
 7833 0245 64       		.byte	100
 7834 0246 00       		.byte	0
 7835 0247 01       		.byte	1
 7836 0248 00       		.byte	0
 7837 0249 03       		.byte	3
 7838 024a 00       		.byte	0
 7839 024b 00       		.byte	0
 7840 024c 00       		.byte	0
 7841 024d 00       		.byte	0
 7842 024e 00       		.byte	0
 7843 024f 30       		.byte	48
 7844 0250 01       		.byte	1
 7845 0251 00       		.byte	0
 7846 0252 00       		.byte	0
 7847 0253 00000000 		.space	5
 7847      00
 7848 0258 08       		.byte	8
 7849 0259 08       		.byte	8
 7850 025a 02       		.byte	2
 7851 025b 00       		.byte	0
 7852 025c 00       		.byte	0
 7853 025d 05       		.byte	5
 7854 025e 00       		.byte	0
 7855 025f 01       		.byte	1
 7856 0260 00       		.byte	0
 7857 0261 03       		.byte	3
 7858 0262 00       		.byte	0
 7859 0263 00       		.byte	0
 7860 0264 00       		.byte	0
 7861 0265 00       		.byte	0
 7862 0266 00       		.byte	0
 7863 0267 30       		.byte	48
 7864 0268 01       		.byte	1
 7865 0269 00       		.byte	0
 7866 026a 00       		.byte	0
 7867 026b 00000000 		.space	5
 7867      00
 7868 0270 00       		.byte	0
 7869 0271 00       		.byte	0
 7870 0272 02       		.byte	2
 7871 0273 00       		.byte	0
 7872 0274 00       		.byte	0
 7873 0275 40       		.byte	64
 7874 0276 00       		.byte	0
 7875 0277 01       		.byte	1
 7876 0278 00       		.byte	0
 7877 0279 03       		.byte	3
 7878 027a 00       		.byte	0
 7879 027b 00       		.byte	0
 7880 027c 00       		.byte	0
 7881 027d 00       		.byte	0
 7882 027e 00       		.byte	0
 7883 027f 30       		.byte	48
 7884 0280 01       		.byte	1
 7885 0281 00       		.byte	0
 7886 0282 00       		.byte	0
 7887 0283 00000000 		.space	5
 7887      00
 7888 0288 09       		.byte	9
 7889 0289 0A       		.byte	10
 7890 028a 04       		.byte	4
 7891 028b 00       		.byte	0
 7892 028c 00       		.byte	0
 7893 028d 40       		.byte	64
 7894 028e 00       		.byte	0
 7895 028f 01       		.byte	1
 7896 0290 00       		.byte	0
 7897 0291 03       		.byte	3
 7898 0292 00       		.byte	0
 7899 0293 20       		.byte	32
 7900 0294 38       		.byte	56
 7901 0295 20       		.byte	32
 7902 0296 38       		.byte	56
 7903 0297 30       		.byte	48
 7904 0298 01       		.byte	1
 7905 0299 00       		.byte	0
 7906 029a 00       		.byte	0
 7907 029b 00000000 		.space	5
 7907      00
 7908 02a0 00       		.byte	0
 7909 02a1 00       		.byte	0
 7910 02a2 02       		.byte	2
 7911 02a3 00       		.byte	0
 7912 02a4 00       		.byte	0
 7913 02a5 64       		.byte	100
 7914 02a6 00       		.byte	0
 7915 02a7 01       		.byte	1
 7916 02a8 00       		.byte	0
 7917 02a9 03       		.byte	3
 7918 02aa 00       		.byte	0
 7919 02ab 00       		.byte	0
 7920 02ac 00       		.byte	0
 7921 02ad 00       		.byte	0
 7922 02ae 00       		.byte	0
 7923 02af 30       		.byte	48
 7924 02b0 01       		.byte	1
 7925 02b1 00       		.byte	0
 7926 02b2 00       		.byte	0
 7927 02b3 00000000 		.space	5
 7927      00
 7928 02b8 00       		.byte	0
 7929 02b9 00       		.byte	0
 7930 02ba 02       		.byte	2
 7931 02bb 00       		.byte	0
 7932 02bc 00       		.byte	0
 7933 02bd 64       		.byte	100
 7934 02be 00       		.byte	0
 7935 02bf 01       		.byte	1
 7936 02c0 00       		.byte	0
 7937 02c1 03       		.byte	3
 7938 02c2 00       		.byte	0
 7939 02c3 00       		.byte	0
 7940 02c4 00       		.byte	0
 7941 02c5 00       		.byte	0
 7942 02c6 00       		.byte	0
 7943 02c7 30       		.byte	48
 7944 02c8 01       		.byte	1
 7945 02c9 00       		.byte	0
 7946 02ca 00       		.byte	0
 7947 02cb 00000000 		.space	5
 7947      00
 7948 02d0 2A       		.byte	42
 7949 02d1 2A       		.byte	42
 7950 02d2 02       		.byte	2
 7951 02d3 00       		.byte	0
 7952 02d4 00       		.byte	0
 7953 02d5 1B       		.byte	27
 7954 02d6 00       		.byte	0
 7955 02d7 01       		.byte	1
 7956 02d8 00       		.byte	0
 7957 02d9 03       		.byte	3
 7958 02da 00       		.byte	0
 7959 02db 00       		.byte	0
 7960 02dc 00       		.byte	0
 7961 02dd 00       		.byte	0
 7962 02de 00       		.byte	0
 7963 02df 30       		.byte	48
 7964 02e0 01       		.byte	1
 7965 02e1 00       		.byte	0
 7966 02e2 00       		.byte	0
 7967 02e3 00000000 		.space	5
 7967      00
 7968 02e8 00       		.byte	0
 7969 02e9 00       		.byte	0
 7970 02ea 02       		.byte	2
 7971 02eb 00       		.byte	0
 7972 02ec 00       		.byte	0
 7973 02ed 64       		.byte	100
 7974 02ee 00       		.byte	0
 7975 02ef 01       		.byte	1
 7976 02f0 00       		.byte	0
 7977 02f1 03       		.byte	3
 7978 02f2 00       		.byte	0
 7979 02f3 00       		.byte	0
 7980 02f4 00       		.byte	0
 7981 02f5 00       		.byte	0
 7982 02f6 00       		.byte	0
 7983 02f7 30       		.byte	48
 7984 02f8 01       		.byte	1
 7985 02f9 00       		.byte	0
 7986 02fa 00       		.byte	0
 7987 02fb 00000000 		.space	5
 7987      00
 7988 0300 00       		.byte	0
 7989 0301 00       		.byte	0
 7990 0302 02       		.byte	2
 7991 0303 00       		.byte	0
 7992 0304 00       		.byte	0
 7993 0305 12       		.byte	18
 7994 0306 00       		.byte	0
 7995 0307 01       		.byte	1
 7996 0308 00       		.byte	0
 7997 0309 03       		.byte	3
 7998 030a 00       		.byte	0
 7999 030b 00       		.byte	0
 8000 030c 00       		.byte	0
 8001 030d 00       		.byte	0
 8002 030e 00       		.byte	0
 8003 030f 30       		.byte	48
 8004 0310 01       		.byte	1
 8005 0311 00       		.byte	0
 8006 0312 00       		.byte	0
 8007 0313 00000000 		.space	5
 8007      00
 8008 0318 01       		.byte	1
 8009 0319 01       		.byte	1
 8010 031a 02       		.byte	2
 8011 031b 00       		.byte	0
 8012 031c 00       		.byte	0
 8013 031d 09       		.byte	9
 8014 031e 00       		.byte	0
 8015 031f 01       		.byte	1
 8016 0320 00       		.byte	0
 8017 0321 03       		.byte	3
 8018 0322 00       		.byte	0
 8019 0323 00       		.byte	0
 8020 0324 00       		.byte	0
 8021 0325 01       		.byte	1
 8022 0326 00       		.byte	0
 8023 0327 30       		.byte	48
 8024 0328 01       		.byte	1
 8025 0329 00       		.byte	0
 8026 032a 00       		.byte	0
 8027 032b 00000000 		.space	5
 8027      00
 8028 0330 05       		.byte	5
 8029 0331 05       		.byte	5
 8030 0332 02       		.byte	2
 8031 0333 00       		.byte	0
 8032 0334 00       		.byte	0
 8033 0335 03       		.byte	3
 8034 0336 00       		.byte	0
 8035 0337 01       		.byte	1
 8036 0338 00       		.byte	0
 8037 0339 03       		.byte	3
 8038 033a 00       		.byte	0
 8039 033b 00       		.byte	0
 8040 033c 00       		.byte	0
 8041 033d 03       		.byte	3
 8042 033e 00       		.byte	0
 8043 033f 30       		.byte	48
 8044 0340 01       		.byte	1
 8045 0341 00       		.byte	0
 8046 0342 00       		.byte	0
 8047 0343 00000000 		.space	5
 8047      00
 8048 0348 18       		.byte	24
 8049 0349 18       		.byte	24
 8050 034a 02       		.byte	2
 8051 034b 00       		.byte	0
 8052 034c 00       		.byte	0
 8053 034d 01       		.byte	1
 8054 034e 00       		.byte	0
 8055 034f 01       		.byte	1
 8056 0350 00       		.byte	0
 8057 0351 03       		.byte	3
 8058 0352 00       		.byte	0
 8059 0353 00       		.byte	0
 8060 0354 00       		.byte	0
 8061 0355 00       		.byte	0
 8062 0356 00       		.byte	0
 8063 0357 30       		.byte	48
 8064 0358 01       		.byte	1
 8065 0359 00       		.byte	0
 8066 035a 00       		.byte	0
 8067 035b 00000000 		.space	5
 8067      00
 8068 0360 19       		.byte	25
 8069 0361 19       		.byte	25
 8070 0362 01       		.byte	1
 8071 0363 00       		.byte	0
 8072 0364 00       		.byte	0
 8073 0365 40       		.byte	64
 8074 0366 00       		.byte	0
 8075 0367 01       		.byte	1
 8076 0368 00       		.byte	0
 8077 0369 03       		.byte	3
 8078 036a 00       		.byte	0
 8079 036b 20       		.byte	32
 8080 036c 00       		.byte	0
 8081 036d 20       		.byte	32
 8082 036e 00       		.byte	0
 8083 036f 30       		.byte	48
 8084 0370 01       		.byte	1
 8085 0371 00       		.byte	0
 8086 0372 00       		.byte	0
 8087 0373 00000000 		.space	5
 8087      00
 8088 0378 20       		.byte	32
 8089 0379 20       		.byte	32
 8090 037a 02       		.byte	2
 8091 037b 00       		.byte	0
 8092 037c 00       		.byte	0
 8093 037d 02       		.byte	2
 8094 037e 00       		.byte	0
 8095 037f 01       		.byte	1
 8096 0380 00       		.byte	0
 8097 0381 03       		.byte	3
 8098 0382 00       		.byte	0
 8099 0383 00       		.byte	0
 8100 0384 00       		.byte	0
 8101 0385 00       		.byte	0
 8102 0386 00       		.byte	0
 8103 0387 30       		.byte	48
 8104 0388 01       		.byte	1
 8105 0389 00       		.byte	0
 8106 038a 00       		.byte	0
 8107 038b 00000000 		.space	5
 8107      00
 8108 0390 22       		.byte	34
 8109 0391 22       		.byte	34
 8110 0392 02       		.byte	2
 8111 0393 00       		.byte	0
 8112 0394 00       		.byte	0
 8113 0395 3F       		.byte	63
 8114 0396 00       		.byte	0
 8115 0397 01       		.byte	1
 8116 0398 00       		.byte	0
 8117 0399 03       		.byte	3
 8118 039a 00       		.byte	0
 8119 039b 00       		.byte	0
 8120 039c 00       		.byte	0
 8121 039d 00       		.byte	0
 8122 039e 00       		.byte	0
 8123 039f 30       		.byte	48
 8124 03a0 01       		.byte	1
 8125 03a1 00       		.byte	0
 8126 03a2 00       		.byte	0
 8127 03a3 00000000 		.space	5
 8127      00
 8128 03a8 23       		.byte	35
 8129 03a9 23       		.byte	35
 8130 03aa 02       		.byte	2
 8131 03ab 00       		.byte	0
 8132 03ac 00       		.byte	0
 8133 03ad 64       		.byte	100
 8134 03ae 00       		.byte	0
 8135 03af 01       		.byte	1
 8136 03b0 00       		.byte	0
 8137 03b1 03       		.byte	3
 8138 03b2 00       		.byte	0
 8139 03b3 10       		.byte	16
 8140 03b4 00       		.byte	0
 8141 03b5 10       		.byte	16
 8142 03b6 00       		.byte	0
 8143 03b7 30       		.byte	48
 8144 03b8 01       		.byte	1
 8145 03b9 00       		.byte	0
 8146 03ba 00       		.byte	0
 8147 03bb 00000000 		.space	5
 8147      00
 8148 03c0 24       		.byte	36
 8149 03c1 24       		.byte	36
 8150 03c2 02       		.byte	2
 8151 03c3 00       		.byte	0
 8152 03c4 00       		.byte	0
 8153 03c5 64       		.byte	100
 8154 03c6 00       		.byte	0
 8155 03c7 01       		.byte	1
 8156 03c8 00       		.byte	0
 8157 03c9 03       		.byte	3
 8158 03ca 00       		.byte	0
 8159 03cb 10       		.byte	16
 8160 03cc 00       		.byte	0
 8161 03cd 10       		.byte	16
 8162 03ce 00       		.byte	0
 8163 03cf 30       		.byte	48
 8164 03d0 01       		.byte	1
 8165 03d1 00       		.byte	0
 8166 03d2 00       		.byte	0
 8167 03d3 00000000 		.space	5
 8167      00
 8168 03d8 02       		.byte	2
 8169 03d9 03       		.byte	3
 8170 03da 04       		.byte	4
 8171 03db 00       		.byte	0
 8172 03dc 00       		.byte	0
 8173 03dd 7F       		.byte	127
 8174 03de 00       		.byte	0
 8175 03df 01       		.byte	1
 8176 03e0 00       		.byte	0
 8177 03e1 03       		.byte	3
 8178 03e2 00       		.byte	0
 8179 03e3 00       		.byte	0
 8180 03e4 20       		.byte	32
 8181 03e5 00       		.byte	0
 8182 03e6 20       		.byte	32
 8183 03e7 30       		.byte	48
 8184 03e8 01       		.byte	1
 8185 03e9 00       		.byte	0
 8186 03ea 00       		.byte	0
 8187 03eb 00000000 		.space	5
 8187      00
 8188 03f0 04       		.byte	4
 8189 03f1 04       		.byte	4
 8190 03f2 02       		.byte	2
 8191 03f3 00       		.byte	0
 8192 03f4 00       		.byte	0
 8193 03f5 40       		.byte	64
 8194 03f6 00       		.byte	0
 8195 03f7 01       		.byte	1
 8196 03f8 00       		.byte	0
 8197 03f9 03       		.byte	3
 8198 03fa 00       		.byte	0
 8199 03fb 20       		.byte	32
 8200 03fc 00       		.byte	0
 8201 03fd 20       		.byte	32
 8202 03fe 00       		.byte	0
 8203 03ff 30       		.byte	48
 8204 0400 01       		.byte	1
 8205 0401 00       		.byte	0
 8206 0402 00       		.byte	0
 8207 0403 00000000 		.space	5
 8207      00
 8208 0408 00       		.byte	0
 8209 0409 00       		.byte	0
 8210 040a 02       		.byte	2
 8211 040b 00       		.byte	0
 8212 040c 00       		.byte	0
 8213 040d 19       		.byte	25
 8214 040e 00       		.byte	0
 8215 040f 01       		.byte	1
 8216 0410 00       		.byte	0
 8217 0411 03       		.byte	3
 8218 0412 00       		.byte	0
 8219 0413 00       		.byte	0
 8220 0414 00       		.byte	0
 8221 0415 00       		.byte	0
 8222 0416 00       		.byte	0
 8223 0417 30       		.byte	48
 8224 0418 01       		.byte	1
 8225 0419 00       		.byte	0
 8226 041a 00       		.byte	0
 8227 041b 00000000 		.space	5
 8227      00
 8228 0420 10       		.byte	16
 8229 0421 10       		.byte	16
 8230 0422 02       		.byte	2
 8231 0423 00       		.byte	0
 8232 0424 00       		.byte	0
 8233 0425 06       		.byte	6
 8234 0426 00       		.byte	0
 8235 0427 01       		.byte	1
 8236 0428 00       		.byte	0
 8237 0429 03       		.byte	3
 8238 042a 00       		.byte	0
 8239 042b 00       		.byte	0
 8240 042c 00       		.byte	0
 8241 042d 00       		.byte	0
 8242 042e 00       		.byte	0
 8243 042f 30       		.byte	48
 8244 0430 01       		.byte	1
 8245 0431 00       		.byte	0
 8246 0432 00       		.byte	0
 8247 0433 00000000 		.space	5
 8247      00
 8248 0438 00       		.byte	0
 8249 0439 00       		.byte	0
 8250 043a 02       		.byte	2
 8251 043b 00       		.byte	0
 8252 043c 00       		.byte	0
 8253 043d 03       		.byte	3
 8254 043e 00       		.byte	0
 8255 043f 01       		.byte	1
 8256 0440 00       		.byte	0
 8257 0441 03       		.byte	3
 8258 0442 00       		.byte	0
 8259 0443 00       		.byte	0
 8260 0444 00       		.byte	0
 8261 0445 00       		.byte	0
 8262 0446 00       		.byte	0
 8263 0447 30       		.byte	48
 8264 0448 01       		.byte	1
 8265 0449 00       		.byte	0
 8266 044a 00       		.byte	0
 8267 044b 00000000 		.space	5
 8267      00
 8268 0450 50       		.byte	80
 8269 0451 50       		.byte	80
 8270 0452 01       		.byte	1
 8271 0453 00       		.byte	0
 8272 0454 00       		.byte	0
 8273 0455 03       		.byte	3
 8274 0456 00       		.byte	0
 8275 0457 01       		.byte	1
 8276 0458 00       		.byte	0
 8277 0459 03       		.byte	3
 8278 045a 00       		.byte	0
 8279 045b 00       		.byte	0
 8280 045c 00       		.byte	0
 8281 045d 00       		.byte	0
 8282 045e 00       		.byte	0
 8283 045f 30       		.byte	48
 8284 0460 01       		.byte	1
 8285 0461 00       		.byte	0
 8286 0462 00       		.byte	0
 8287 0463 00000000 		.space	5
 8287      00
 8288 0468 00       		.byte	0
 8289 0469 00       		.byte	0
 8290 046a 0B       		.byte	11
 8291 046b 00       		.byte	0
 8292 046c 00       		.byte	0
 8293 046d FF       		.byte	-1
 8294 046e FF       		.byte	-1
 8295 046f 01       		.byte	1
 8296 0470 00       		.byte	0
 8297 0471 03       		.byte	3
 8298 0472 00       		.byte	0
 8299 0473 00       		.byte	0
 8300 0474 00       		.byte	0
 8301 0475 00       		.byte	0
 8302 0476 00       		.byte	0
 8303 0477 00       		.byte	0
 8304 0478 01       		.byte	1
 8305 0479 00       		.byte	0
 8306 047a 00       		.byte	0
 8307 047b 00000000 		.space	5
 8307      00
 8310              	glUVCHeader:
 8311 0480 0C       		.byte	12
 8312 0481 8C       		.byte	-116
 8313 0482 00       		.byte	0
 8314 0483 00       		.byte	0
 8315 0484 00       		.byte	0
 8316 0485 00       		.byte	0
 8317 0486 00       		.byte	0
 8318 0487 00       		.byte	0
 8319 0488 00       		.byte	0
 8320 0489 00       		.byte	0
 8321 048a 00       		.byte	0
 8322 048b 00       		.byte	0
 8325              	WBMenuCmpArry:
 8326 048c 20       		.byte	32
 8327 048d 0F       		.byte	15
 8328 048e 38       		.byte	56
 8329 048f F0       		.byte	-16
 8332              	CTCtrlParArry:
 8333 0490 00       		.byte	0
 8334 0491 00       		.byte	0
 8335 0492 01       		.byte	1
 8336 0493 00       		.byte	0
 8337 0494 00       		.byte	0
 8338 0495 03       		.byte	3
 8339 0496 00       		.byte	0
 8340 0497 01       		.byte	1
 8341 0498 00       		.byte	0
 8342 0499 03       		.byte	3
 8343 049a 00       		.byte	0
 8344 049b 03       		.byte	3
 8345 049c 00       		.byte	0
 8346 049d 03       		.byte	3
 8347 049e 00       		.byte	0
 8348 049f 30       		.byte	48
 8349 04a0 01       		.byte	1
 8350 04a1 00       		.byte	0
 8351 04a2 00       		.byte	0
 8352 04a3 00000000 		.space	5
 8352      00
 8353 04a8 00       		.byte	0
 8354 04a9 00       		.byte	0
 8355 04aa 01       		.byte	1
 8356 04ab 01       		.byte	1
 8357 04ac 00       		.byte	0
 8358 04ad 0F       		.byte	15
 8359 04ae 00       		.byte	0
 8360 04af 0F       		.byte	15
 8361 04b0 00       		.byte	0
 8362 04b1 03       		.byte	3
 8363 04b2 00       		.byte	0
 8364 04b3 02       		.byte	2
 8365 04b4 00       		.byte	0
 8366 04b5 02       		.byte	2
 8367 04b6 00       		.byte	0
 8368 04b7 30       		.byte	48
 8369 04b8 01       		.byte	1
 8370 04b9 01       		.byte	1
 8371 04ba 00       		.byte	0
 8372 04bb 00000000 		.space	5
 8372      00
 8373 04c0 02       		.byte	2
 8374 04c1 00       		.byte	0
 8375 04c2 01       		.byte	1
 8376 04c3 00       		.byte	0
 8377 04c4 00       		.byte	0
 8378 04c5 01       		.byte	1
 8379 04c6 00       		.byte	0
 8380 04c7 01       		.byte	1
 8381 04c8 00       		.byte	0
 8382 04c9 03       		.byte	3
 8383 04ca 00       		.byte	0
 8384 04cb 00       		.byte	0
 8385 04cc 00       		.byte	0
 8386 04cd 00       		.byte	0
 8387 04ce 00       		.byte	0
 8388 04cf 30       		.byte	48
 8389 04d0 01       		.byte	1
 8390 04d1 01       		.byte	1
 8391 04d2 00       		.byte	0
 8392 04d3 00000000 		.space	5
 8392      00
 8393 04d8 00       		.byte	0
 8394 04d9 00       		.byte	0
 8395 04da 04       		.byte	4
 8396 04db 01       		.byte	1
 8397 04dc 00       		.byte	0
 8398 04dd 38       		.byte	56
 8399 04de 01       		.byte	1
 8400 04df 01       		.byte	1
 8401 04e0 00       		.byte	0
 8402 04e1 03       		.byte	3
 8403 04e2 00       		.byte	0
 8404 04e3 4E       		.byte	78
 8405 04e4 00       		.byte	0
 8406 04e5 4E       		.byte	78
 8407 04e6 00       		.byte	0
 8408 04e7 30       		.byte	48
 8409 04e8 01       		.byte	1
 8410 04e9 00       		.byte	0
 8411 04ea 00       		.byte	0
 8412 04eb 00000000 		.space	5
 8412      00
 8413 04f0 04       		.byte	4
 8414 04f1 00       		.byte	0
 8415 04f2 01       		.byte	1
 8416 04f3 00       		.byte	0
 8417 04f4 00       		.byte	0
 8418 04f5 00       		.byte	0
 8419 04f6 00       		.byte	0
 8420 04f7 01       		.byte	1
 8421 04f8 00       		.byte	0
 8422 04f9 03       		.byte	3
 8423 04fa 00       		.byte	0
 8424 04fb 00       		.byte	0
 8425 04fc 00       		.byte	0
 8426 04fd 00       		.byte	0
 8427 04fe 00       		.byte	0
 8428 04ff 30       		.byte	48
 8429 0500 01       		.byte	1
 8430 0501 00       		.byte	0
 8431 0502 00       		.byte	0
 8432 0503 00000000 		.space	5
 8432      00
 8433 0508 05       		.byte	5
 8434 0509 00       		.byte	0
 8435 050a 02       		.byte	2
 8436 050b 00       		.byte	0
 8437 050c 00       		.byte	0
 8438 050d FF       		.byte	-1
 8439 050e 00       		.byte	0
 8440 050f 01       		.byte	1
 8441 0510 00       		.byte	0
 8442 0511 03       		.byte	3
 8443 0512 00       		.byte	0
 8444 0513 01       		.byte	1
 8445 0514 00       		.byte	0
 8446 0515 00       		.byte	0
 8447 0516 00       		.byte	0
 8448 0517 30       		.byte	48
 8449 0518 01       		.byte	1
 8450 0519 01       		.byte	1
 8451 051a 00       		.byte	0
 8452 051b 00000000 		.space	5
 8452      00
 8453 0520 06       		.byte	6
 8454 0521 00       		.byte	0
 8455 0522 02       		.byte	2
 8456 0523 00       		.byte	0
 8457 0524 00       		.byte	0
 8458 0525 00       		.byte	0
 8459 0526 00       		.byte	0
 8460 0527 00       		.byte	0
 8461 0528 00       		.byte	0
 8462 0529 03       		.byte	3
 8463 052a 00       		.byte	0
 8464 052b 00       		.byte	0
 8465 052c 00       		.byte	0
 8466 052d 00       		.byte	0
 8467 052e 00       		.byte	0
 8468 052f 30       		.byte	48
 8469 0530 01       		.byte	1
 8470 0531 01       		.byte	1
 8471 0532 00       		.byte	0
 8472 0533 00000000 		.space	5
 8472      00
 8473 0538 23       		.byte	35
 8474 0539 00       		.byte	0
 8475 053a 02       		.byte	2
 8476 053b 00       		.byte	0
 8477 053c 00       		.byte	0
 8478 053d 30       		.byte	48
 8479 053e 00       		.byte	0
 8480 053f 01       		.byte	1
 8481 0540 00       		.byte	0
 8482 0541 03       		.byte	3
 8483 0542 0A       		.byte	10
 8484 0543 00       		.byte	0
 8485 0544 00       		.byte	0
 8486 0545 0A       		.byte	10
 8487 0546 00       		.byte	0
 8488 0547 30       		.byte	48
 8489 0548 01       		.byte	1
 8490 0549 01       		.byte	1
 8491 054a 00       		.byte	0
 8492 054b 00000000 		.space	5
 8492      00
 8493 0550 08       		.byte	8
 8494 0551 00       		.byte	0
 8495 0552 01       		.byte	1
 8496 0553 00       		.byte	0
 8497 0554 00       		.byte	0
 8498 0555 7F       		.byte	127
 8499 0556 00       		.byte	0
 8500 0557 01       		.byte	1
 8501 0558 00       		.byte	0
 8502 0559 03       		.byte	3
 8503 055a 00       		.byte	0
 8504 055b 00       		.byte	0
 8505 055c 00       		.byte	0
 8506 055d 00       		.byte	0
 8507 055e 00       		.byte	0
 8508 055f 30       		.byte	48
 8509 0560 01       		.byte	1
 8510 0561 00       		.byte	0
 8511 0562 00       		.byte	0
 8512 0563 00000000 		.space	5
 8512      00
 8513 0568 09       		.byte	9
 8514 0569 00       		.byte	0
 8515 056a 02       		.byte	2
 8516 056b 00       		.byte	0
 8517 056c 00       		.byte	0
 8518 056d 05       		.byte	5
 8519 056e 00       		.byte	0
 8520 056f 01       		.byte	1
 8521 0570 00       		.byte	0
 8522 0571 03       		.byte	3
 8523 0572 00       		.byte	0
 8524 0573 00       		.byte	0
 8525 0574 00       		.byte	0
 8526 0575 00       		.byte	0
 8527 0576 00       		.byte	0
 8528 0577 30       		.byte	48
 8529 0578 01       		.byte	1
 8530 0579 00       		.byte	0
 8531 057a 00       		.byte	0
 8532 057b 00000000 		.space	5
 8532      00
 8533 0580 10       		.byte	16
 8534 0581 00       		.byte	0
 8535 0582 03       		.byte	3
 8536 0583 00       		.byte	0
 8537 0584 00       		.byte	0
 8538 0585 00       		.byte	0
 8539 0586 00       		.byte	0
 8540 0587 00       		.byte	0
 8541 0588 00       		.byte	0
 8542 0589 03       		.byte	3
 8543 058a 00       		.byte	0
 8544 058b 00       		.byte	0
 8545 058c 00       		.byte	0
 8546 058d 00       		.byte	0
 8547 058e 00       		.byte	0
 8548 058f 30       		.byte	48
 8549 0590 01       		.byte	1
 8550 0591 00       		.byte	0
 8551 0592 00       		.byte	0
 8552 0593 00000000 		.space	5
 8552      00
 8553 0598 00       		.byte	0
 8554 0599 00       		.byte	0
 8555 059a 02       		.byte	2
 8556 059b 00       		.byte	0
 8557 059c 00       		.byte	0
 8558 059d 40       		.byte	64
 8559 059e 00       		.byte	0
 8560 059f 01       		.byte	1
 8561 05a0 00       		.byte	0
 8562 05a1 03       		.byte	3
 8563 05a2 00       		.byte	0
 8564 05a3 0F       		.byte	15
 8565 05a4 11       		.byte	17
 8566 05a5 00       		.byte	0
 8567 05a6 00       		.byte	0
 8568 05a7 30       		.byte	48
 8569 05a8 01       		.byte	1
 8570 05a9 00       		.byte	0
 8571 05aa 00       		.byte	0
 8572 05ab 00000000 		.space	5
 8572      00
 8573 05b0 00       		.byte	0
 8574 05b1 00       		.byte	0
 8575 05b2 02       		.byte	2
 8576 05b3 00       		.byte	0
 8577 05b4 00       		.byte	0
 8578 05b5 64       		.byte	100
 8579 05b6 00       		.byte	0
 8580 05b7 01       		.byte	1
 8581 05b8 00       		.byte	0
 8582 05b9 03       		.byte	3
 8583 05ba 00       		.byte	0
 8584 05bb 00       		.byte	0
 8585 05bc 00       		.byte	0
 8586 05bd 00       		.byte	0
 8587 05be 00       		.byte	0
 8588 05bf 30       		.byte	48
 8589 05c0 01       		.byte	1
 8590 05c1 00       		.byte	0
 8591 05c2 00       		.byte	0
 8592 05c3 00000000 		.space	5
 8592      00
 8593 05c8 00       		.byte	0
 8594 05c9 00       		.byte	0
 8595 05ca 02       		.byte	2
 8596 05cb 00       		.byte	0
 8597 05cc 00       		.byte	0
 8598 05cd 64       		.byte	100
 8599 05ce 00       		.byte	0
 8600 05cf 01       		.byte	1
 8601 05d0 00       		.byte	0
 8602 05d1 03       		.byte	3
 8603 05d2 00       		.byte	0
 8604 05d3 00       		.byte	0
 8605 05d4 00       		.byte	0
 8606 05d5 00       		.byte	0
 8607 05d6 00       		.byte	0
 8608 05d7 30       		.byte	48
 8609 05d8 01       		.byte	1
 8610 05d9 00       		.byte	0
 8611 05da 00       		.byte	0
 8612 05db 00000000 		.space	5
 8612      00
 8613 05e0 00       		.byte	0
 8614 05e1 00       		.byte	0
 8615 05e2 02       		.byte	2
 8616 05e3 00       		.byte	0
 8617 05e4 00       		.byte	0
 8618 05e5 64       		.byte	100
 8619 05e6 00       		.byte	0
 8620 05e7 01       		.byte	1
 8621 05e8 00       		.byte	0
 8622 05e9 03       		.byte	3
 8623 05ea 00       		.byte	0
 8624 05eb 00       		.byte	0
 8625 05ec 00       		.byte	0
 8626 05ed 00       		.byte	0
 8627 05ee 00       		.byte	0
 8628 05ef 30       		.byte	48
 8629 05f0 01       		.byte	1
 8630 05f1 00       		.byte	0
 8631 05f2 00       		.byte	0
 8632 05f3 00000000 		.space	5
 8632      00
 8633 05f8 00       		.byte	0
 8634 05f9 00       		.byte	0
 8635 05fa 02       		.byte	2
 8636 05fb 00       		.byte	0
 8637 05fc 00       		.byte	0
 8638 05fd 64       		.byte	100
 8639 05fe 00       		.byte	0
 8640 05ff 01       		.byte	1
 8641 0600 00       		.byte	0
 8642 0601 03       		.byte	3
 8643 0602 00       		.byte	0
 8644 0603 00       		.byte	0
 8645 0604 00       		.byte	0
 8646 0605 00       		.byte	0
 8647 0606 00       		.byte	0
 8648 0607 30       		.byte	48
 8649 0608 01       		.byte	1
 8650 0609 00       		.byte	0
 8651 060a 00       		.byte	0
 8652 060b 00000000 		.space	5
 8652      00
 8655              	glProbeCtrl:
 8656 0610 00       		.byte	0
 8657 0611 00       		.byte	0
 8658 0612 01       		.byte	1
 8659 0613 01       		.byte	1
 8660 0614 15       		.byte	21
 8661 0615 16       		.byte	22
 8662 0616 05       		.byte	5
 8663 0617 00       		.byte	0
 8664 0618 00       		.byte	0
 8665 0619 00       		.byte	0
 8666 061a 00       		.byte	0
 8667 061b 00       		.byte	0
 8668 061c 00       		.byte	0
 8669 061d 00       		.byte	0
 8670 061e 00       		.byte	0
 8671 061f 00       		.byte	0
 8672 0620 00       		.byte	0
 8673 0621 00       		.byte	0
 8674 0622 00       		.byte	0
 8675 0623 48       		.byte	72
 8676 0624 3F       		.byte	63
 8677 0625 00       		.byte	0
 8678 0626 00       		.byte	0
 8679 0627 40       		.byte	64
 8680 0628 00       		.byte	0
 8681 0629 00       		.byte	0
 8682 062a 0000     		.space	2
 8685              	glProbeCtrl20:
 8686 062c 00       		.byte	0
 8687 062d 00       		.byte	0
 8688 062e 01       		.byte	1
 8689 062f 01       		.byte	1
 8690 0630 80       		.byte	-128
 8691 0631 1A       		.byte	26
 8692 0632 06       		.byte	6
 8693 0633 00       		.byte	0
 8694 0634 00       		.byte	0
 8695 0635 00       		.byte	0
 8696 0636 00       		.byte	0
 8697 0637 00       		.byte	0
 8698 0638 00       		.byte	0
 8699 0639 00       		.byte	0
 8700 063a 00       		.byte	0
 8701 063b 00       		.byte	0
 8702 063c 00       		.byte	0
 8703 063d 00       		.byte	0
 8704 063e 00       		.byte	0
 8705 063f D2       		.byte	-46
 8706 0640 0F       		.byte	15
 8707 0641 00       		.byte	0
 8708 0642 00       		.byte	0
 8709 0643 40       		.byte	64
 8710 0644 00       		.byte	0
 8711 0645 00       		.byte	0
 8712 0646 0000     		.space	2
 8715              	glProbeStilCtrl:
 8716 0648 01       		.byte	1
 8717 0649 01       		.byte	1
 8718 064a 00       		.byte	0
 8719 064b 00       		.byte	0
 8720 064c 48       		.byte	72
 8721 064d 3F       		.byte	63
 8722 064e 00       		.byte	0
 8723 064f 00       		.byte	0
 8724 0650 40       		.byte	64
 8725 0651 00       		.byte	0
 8726 0652 00       		.byte	0
 8727 0653 00       		.space	1
 8730              	glProbeStilCtrl20:
 8731 0654 01       		.byte	1
 8732 0655 01       		.byte	1
 8733 0656 00       		.byte	0
 8734 0657 00       		.byte	0
 8735 0658 D2       		.byte	-46
 8736 0659 0F       		.byte	15
 8737 065a 00       		.byte	0
 8738 065b 00       		.byte	0
 8739 065c 40       		.byte	64
 8740 065d 00       		.byte	0
 8741 065e 00       		.byte	0
 8744              	snapButFlag:
 8745 065f 01       		.byte	1
 8748              	CyFxGpifTransition:
 8749 0660 0000     		.short	0
 8750 0662 5555     		.short	21845
 8751 0664 8888     		.short	-30584
 8752 0666 AAAA     		.short	-21846
 8753 0668 3333     		.short	13107
 8754 066a 0000     		.space	2
 8757              	CyFxGpifWavedata:
 8758 066c 0181731E 		.word	510886145
 8759 0670 00000000 		.word	0
 8760 0674 00000080 		.word	-2147483648
 8761 0678 00000000 		.word	0
 8762 067c 00000000 		.word	0
 8763 0680 00000000 		.word	0
 8764 0684 0201702E 		.word	779092226
 8765 0688 00010000 		.word	256
 8766 068c A0000080 		.word	-2147483488
 8767 0690 00000000 		.word	0
 8768 0694 00000000 		.word	0
 8769 0698 00000000 		.word	0
 8770 069c 0380722E 		.word	779255811
 8771 06a0 02010020 		.word	536871170
 8772 06a4 60000080 		.word	-2147483552
 8773 06a8 00000000 		.word	0
 8774 06ac 00000000 		.word	0
 8775 06b0 00000000 		.word	0
 8776 06b4 0460722E 		.word	779247620
 8777 06b8 02010024 		.word	603980034
 8778 06bc 90000080 		.word	-2147483504
 8779 06c0 0594731E 		.word	510891013
 8780 06c4 06000000 		.word	6
 8781 06c8 00000080 		.word	-2147483648
 8782 06cc 0380722E 		.word	779255811
 8783 06d0 02010020 		.word	536871170
 8784 06d4 60000080 		.word	-2147483552
 8785 06d8 0693731E 		.word	510890758
 8786 06dc 06000000 		.word	6
 8787 06e0 00000080 		.word	-2147483648
 8788 06e4 0720703E 		.word	1047535623
 8789 06e8 08010000 		.word	264
 8790 06ec 00000080 		.word	-2147483648
 8791 06f0 0820703E 		.word	1047535624
 8792 06f4 08010000 		.word	264
 8793 06f8 00000080 		.word	-2147483648
 8794 06fc 0920703E 		.word	1047535625
 8795 0700 08010000 		.word	264
 8796 0704 00000080 		.word	-2147483648
 8797 0708 0A20703E 		.word	1047535626
 8798 070c 08010000 		.word	264
 8799 0710 00000080 		.word	-2147483648
 8800 0714 0380722E 		.word	779255811
 8801 0718 02010020 		.word	536871170
 8802 071c 60000080 		.word	-2147483552
 8803 0720 0B000000 		.word	11
 8804 0724 00000000 		.word	0
 8805 0728 00010080 		.word	-2147483392
 8806 072c 0460722E 		.word	779247620
 8807 0730 02010024 		.word	603980034
 8808 0734 90000080 		.word	-2147483504
 8809 0738 0D000000 		.word	13
 8810 073c 00000000 		.word	0
 8811 0740 00010080 		.word	-2147483392
 8812 0744 0460722E 		.word	779247620
 8813 0748 02010024 		.word	603980034
 8814 074c 90000080 		.word	-2147483504
 8815 0750 0C000000 		.word	12
 8816 0754 00000000 		.word	0
 8817 0758 00010080 		.word	-2147483392
 8818 075c 0380722E 		.word	779255811
 8819 0760 02010020 		.word	536871170
 8820 0764 60000080 		.word	-2147483552
 8821 0768 0E000000 		.word	14
 8822 076c 00000000 		.word	0
 8823 0770 00010080 		.word	-2147483392
 8824 0774 00000000 		.word	0
 8825 0778 00000000 		.word	0
 8826 077c 00000000 		.word	0
 8827 0780 00000000 		.word	0
 8828 0784 00000000 		.word	0
 8829 0788 00000000 		.word	0
 8832              	CyFxGpifWavedataPosition:
 8833 078c 00       		.byte	0
 8834 078d 01       		.byte	1
 8835 078e 02       		.byte	2
 8836 078f 03       		.byte	3
 8837 0790 04       		.byte	4
 8838 0791 05       		.byte	5
 8839 0792 06       		.byte	6
 8840 0793 07       		.byte	7
 8841 0794 08       		.byte	8
 8842 0795 09       		.byte	9
 8843 0796 0A       		.byte	10
 8844 0797 0B       		.byte	11
 8845 0798 0B       		.byte	11
 8846 0799 0B       		.byte	11
 8847 079a 0B       		.byte	11
 8848 079b 00       		.space	1
 8851              	CyFxGpifRegValue:
 8852 079c 08830080 		.word	-2147450104
 8853 07a0 67000000 		.word	103
 8854 07a4 00000000 		.word	0
 8855 07a8 46000000 		.word	70
 8856 07ac 00000000 		.word	0
 8857 07b0 00000000 		.word	0
 8858 07b4 02000000 		.word	2
 8859 07b8 82000000 		.word	130
 8860 07bc 82070000 		.word	1922
 8861 07c0 40040000 		.word	1088
 8862 07c4 FCFF0000 		.word	65532
 8863 07c8 28000000 		.word	40
 8864 07cc 00000000 		.word	0
 8865 07d0 00000000 		.word	0
 8866 07d4 00000000 		.word	0
 8867 07d8 00000000 		.word	0
 8868 07dc 01000000 		.word	1
 8869 07e0 00000000 		.word	0
 8870 07e4 00000000 		.word	0
 8871 07e8 00000000 		.word	0
 8872 07ec 00000000 		.word	0
 8873 07f0 00000000 		.word	0
 8874 07f4 00000000 		.word	0
 8875 07f8 00000000 		.word	0
 8876 07fc 00000000 		.word	0
 8877 0800 00000000 		.word	0
 8878 0804 00000000 		.word	0
 8879 0808 00000000 		.word	0
 8880 080c 00000000 		.word	0
 8881 0810 06000000 		.word	6
 8882 0814 00000000 		.word	0
 8883 0818 FFFF0000 		.word	65535
 8884 081c 09010000 		.word	265
 8885 0820 00000000 		.word	0
 8886 0824 F71F0000 		.word	8183
 8887 0828 00000000 		.word	0
 8888 082c FFFF0000 		.word	65535
 8889 0830 09010000 		.word	265
 8890 0834 00000000 		.word	0
 8891 0838 F71F0000 		.word	8183
 8892 083c 00000000 		.word	0
 8893 0840 00000000 		.word	0
 8894 0844 00000000 		.word	0
 8895 0848 00000000 		.word	0
 8896 084c 00000000 		.word	0
 8897 0850 00000000 		.word	0
 8898 0854 00000000 		.word	0
 8899 0858 00000000 		.word	0
 8900 085c 00000000 		.word	0
 8901 0860 00000000 		.word	0
 8902 0864 00000000 		.word	0
 8903 0868 00000000 		.word	0
 8904 086c 00000000 		.word	0
 8905 0870 00000000 		.word	0
 8906 0874 00000000 		.word	0
 8907 0878 00000000 		.word	0
 8908 087c 00000000 		.word	0
 8909 0880 00000000 		.word	0
 8910 0884 00000000 		.word	0
 8911 0888 00000000 		.word	0
 8912 088c 00000000 		.word	0
 8913 0890 00000000 		.word	0
 8914 0894 00000000 		.word	0
 8915 0898 00040180 		.word	-2147417088
 8916 089c 01040180 		.word	-2147417087
 8917 08a0 02040180 		.word	-2147417086
 8918 08a4 03040180 		.word	-2147417085
 8919 08a8 00000000 		.word	0
 8920 08ac 00000000 		.word	0
 8921 08b0 00000000 		.word	0
 8922 08b4 00000000 		.word	0
 8923 08b8 00000000 		.word	0
 8924 08bc 00000000 		.word	0
 8925 08c0 00000000 		.word	0
 8926 08c4 00000000 		.word	0
 8927 08c8 C1FFFFFF 		.word	-63
 8930              	CyFxGpifTransition_usb2:
 8931 08cc 0000     		.short	0
 8932 08ce 5555     		.short	21845
 8933 08d0 AAAA     		.short	-21846
 8934 08d2 8888     		.short	-30584
 8935 08d4 1111     		.short	4369
 8936 08d6 4444     		.short	17476
 8937 08d8 3333     		.short	13107
 8938 08da CCCC     		.short	-13108
 8941              	CyFxGpifWavedata_usb2:
 8942 08dc 0181731E 		.word	510886145
 8943 08e0 00000000 		.word	0
 8944 08e4 00000080 		.word	-2147483648
 8945 08e8 00000000 		.word	0
 8946 08ec 00000000 		.word	0
 8947 08f0 00000000 		.word	0
 8948 08f4 0201703E 		.word	1047527682
 8949 08f8 00010000 		.word	256
 8950 08fc A00000C0 		.word	-1073741664
 8951 0900 00000000 		.word	0
 8952 0904 00000000 		.word	0
 8953 0908 00000000 		.word	0
 8954 090c 0394731E 		.word	510891011
 8955 0910 04000020 		.word	536870916
 8956 0914 60004080 		.word	-2143289248
 8957 0918 00000000 		.word	0
 8958 091c 00000000 		.word	0
 8959 0920 00000000 		.word	0
 8960 0924 0620702E 		.word	779100166
 8961 0928 0C000000 		.word	12
 8962 092c 00000080 		.word	-2147483648
 8963 0930 0620702E 		.word	779100166
 8964 0934 0C000000 		.word	12
 8965 0938 00000080 		.word	-2147483648
 8966 093c 0394731E 		.word	510891011
 8967 0940 04000020 		.word	536870916
 8968 0944 60004080 		.word	-2143289248
 8969 0948 0620702E 		.word	779100166
 8970 094c 0C000000 		.word	12
 8971 0950 00000080 		.word	-2147483648
 8972 0954 0C93731E 		.word	510890764
 8973 0958 04000024 		.word	603979780
 8974 095c 90004080 		.word	-2143289200
 8975 0960 0D20702E 		.word	779100173
 8976 0964 0C000000 		.word	12
 8977 0968 00000080 		.word	-2147483648
 8978 096c 0780724E 		.word	1316126727
 8979 0970 0A000000 		.word	10
 8980 0974 00000080 		.word	-2147483648
 8981 0978 08000000 		.word	8
 8982 097c 00000000 		.word	0
 8983 0980 00010080 		.word	-2147483392
 8984 0984 0920702E 		.word	779100169
 8985 0988 0C010000 		.word	268
 8986 098c 00000080 		.word	-2147483648
 8987 0990 0A01701E 		.word	510656778
 8988 0994 0E000100 		.word	65550
 8989 0998 00000080 		.word	-2147483648
 8990 099c 00000000 		.word	0
 8991 09a0 00000000 		.word	0
 8992 09a4 00000000 		.word	0
 8993 09a8 00000000 		.word	0
 8994 09ac 00000000 		.word	0
 8995 09b0 00000000 		.word	0
 8996 09b4 0394731E 		.word	510891011
 8997 09b8 04000020 		.word	536870916
 8998 09bc 60004080 		.word	-2143289248
 8999 09c0 08000000 		.word	8
 9000 09c4 00000000 		.word	0
 9001 09c8 00010080 		.word	-2147483392
 9002 09cc 0B000000 		.word	11
 9003 09d0 00000000 		.word	0
 9004 09d4 00010080 		.word	-2147483392
 9005 09d8 0C93731E 		.word	510890764
 9006 09dc 04000024 		.word	603979780
 9007 09e0 90004080 		.word	-2143289200
 9008 09e4 0D20702E 		.word	779100173
 9009 09e8 0C000000 		.word	12
 9010 09ec 00000080 		.word	-2147483648
 9011 09f0 0D20702E 		.word	779100173
 9012 09f4 0C000000 		.word	12
 9013 09f8 00000080 		.word	-2147483648
 9014 09fc 0E60724E 		.word	1316118542
 9015 0a00 0A000000 		.word	10
 9016 0a04 00000080 		.word	-2147483648
 9017 0a08 0F000000 		.word	15
 9018 0a0c 00000000 		.word	0
 9019 0a10 00010080 		.word	-2147483392
 9020 0a14 1020702E 		.word	779100176
 9021 0a18 0C010000 		.word	268
 9022 0a1c 00000080 		.word	-2147483648
 9023 0a20 1101701E 		.word	510656785
 9024 0a24 0E000100 		.word	65550
 9025 0a28 00000080 		.word	-2147483648
 9026 0a2c 0C93731E 		.word	510890764
 9027 0a30 04000024 		.word	603979780
 9028 0a34 90004080 		.word	-2143289200
 9029 0a38 0F000000 		.word	15
 9030 0a3c 00000000 		.word	0
 9031 0a40 00010080 		.word	-2147483392
 9032 0a44 12000000 		.word	18
 9033 0a48 00000000 		.word	0
 9034 0a4c 00010080 		.word	-2147483392
 9035 0a50 0394731E 		.word	510891011
 9036 0a54 04000020 		.word	536870916
 9037 0a58 60004080 		.word	-2143289248
 9038 0a5c 0480732E 		.word	779321348
 9039 0a60 02010000 		.word	258
 9040 0a64 000040C0 		.word	-1069547520
 9041 0a68 0580732E 		.word	779321349
 9042 0a6c 02010000 		.word	258
 9043 0a70 000040C0 		.word	-1069547520
 9044 0a74 0580732E 		.word	779321349
 9045 0a78 02010000 		.word	258
 9046 0a7c 000040C0 		.word	-1069547520
 9047 0a80 0480732E 		.word	779321348
 9048 0a84 02010000 		.word	258
 9049 0a88 000040C0 		.word	-1069547520
 9052              	CyFxGpifWavedataPosition_usb2:
 9053 0a8c 00       		.byte	0
 9054 0a8d 01       		.byte	1
 9055 0a8e 02       		.byte	2
 9056 0a8f 03       		.byte	3
 9057 0a90 04       		.byte	4
 9058 0a91 05       		.byte	5
 9059 0a92 06       		.byte	6
 9060 0a93 07       		.byte	7
 9061 0a94 08       		.byte	8
 9062 0a95 09       		.byte	9
 9063 0a96 0A       		.byte	10
 9064 0a97 08       		.byte	8
 9065 0a98 0B       		.byte	11
 9066 0a99 0C       		.byte	12
 9067 0a9a 0D       		.byte	13
 9068 0a9b 08       		.byte	8
 9069 0a9c 0E       		.byte	14
 9070 0a9d 0F       		.byte	15
 9071 0a9e 08       		.byte	8
 9072 0a9f 08       		.byte	8
 9073 0aa0 08       		.byte	8
 9074 0aa1 08       		.byte	8
 9075 0aa2 08       		.byte	8
 9076 0aa3 08       		.byte	8
 9077 0aa4 08       		.byte	8
 9078 0aa5 08       		.byte	8
 9079 0aa6 08       		.byte	8
 9080 0aa7 08       		.byte	8
 9081 0aa8 08       		.byte	8
 9082 0aa9 08       		.byte	8
 9083 0aaa 08       		.byte	8
 9084 0aab 08       		.byte	8
 9085 0aac 08       		.byte	8
 9086 0aad 08       		.byte	8
 9087 0aae 08       		.byte	8
 9088 0aaf 08       		.byte	8
 9089 0ab0 08       		.byte	8
 9090 0ab1 08       		.byte	8
 9091 0ab2 08       		.byte	8
 9092 0ab3 08       		.byte	8
 9093 0ab4 08       		.byte	8
 9094 0ab5 08       		.byte	8
 9095 0ab6 08       		.byte	8
 9096 0ab7 08       		.byte	8
 9097 0ab8 08       		.byte	8
 9098 0ab9 08       		.byte	8
 9099 0aba 08       		.byte	8
 9100 0abb 08       		.byte	8
 9101 0abc 08       		.byte	8
 9102 0abd 08       		.byte	8
 9103 0abe 08       		.byte	8
 9104 0abf 08       		.byte	8
 9105 0ac0 08       		.byte	8
 9106 0ac1 08       		.byte	8
 9107 0ac2 08       		.byte	8
 9108 0ac3 08       		.byte	8
 9109 0ac4 08       		.byte	8
 9110 0ac5 08       		.byte	8
 9111 0ac6 08       		.byte	8
 9112 0ac7 08       		.byte	8
 9113 0ac8 08       		.byte	8
 9114 0ac9 08       		.byte	8
 9115 0aca 08       		.byte	8
 9116 0acb 08       		.byte	8
 9117 0acc 08       		.byte	8
 9118 0acd 08       		.byte	8
 9119 0ace 08       		.byte	8
 9120 0acf 08       		.byte	8
 9121 0ad0 08       		.byte	8
 9122 0ad1 08       		.byte	8
 9123 0ad2 08       		.byte	8
 9124 0ad3 08       		.byte	8
 9125 0ad4 08       		.byte	8
 9126 0ad5 08       		.byte	8
 9127 0ad6 08       		.byte	8
 9128 0ad7 08       		.byte	8
 9129 0ad8 08       		.byte	8
 9130 0ad9 08       		.byte	8
 9131 0ada 08       		.byte	8
 9132 0adb 08       		.byte	8
 9133 0adc 08       		.byte	8
 9134 0add 08       		.byte	8
 9135 0ade 08       		.byte	8
 9136 0adf 08       		.byte	8
 9137 0ae0 08       		.byte	8
 9138 0ae1 08       		.byte	8
 9139 0ae2 08       		.byte	8
 9140 0ae3 08       		.byte	8
 9141 0ae4 08       		.byte	8
 9142 0ae5 08       		.byte	8
 9143 0ae6 08       		.byte	8
 9144 0ae7 08       		.byte	8
 9145 0ae8 08       		.byte	8
 9146 0ae9 08       		.byte	8
 9147 0aea 08       		.byte	8
 9148 0aeb 08       		.byte	8
 9149 0aec 08       		.byte	8
 9150 0aed 08       		.byte	8
 9151 0aee 08       		.byte	8
 9152 0aef 08       		.byte	8
 9153 0af0 08       		.byte	8
 9154 0af1 08       		.byte	8
 9155 0af2 08       		.byte	8
 9156 0af3 08       		.byte	8
 9157 0af4 08       		.byte	8
 9158 0af5 08       		.byte	8
 9159 0af6 08       		.byte	8
 9160 0af7 08       		.byte	8
 9161 0af8 08       		.byte	8
 9162 0af9 08       		.byte	8
 9163 0afa 08       		.byte	8
 9164 0afb 08       		.byte	8
 9165 0afc 08       		.byte	8
 9166 0afd 08       		.byte	8
 9167 0afe 08       		.byte	8
 9168 0aff 08       		.byte	8
 9169 0b00 08       		.byte	8
 9170 0b01 08       		.byte	8
 9171 0b02 08       		.byte	8
 9172 0b03 08       		.byte	8
 9173 0b04 08       		.byte	8
 9174 0b05 08       		.byte	8
 9175 0b06 08       		.byte	8
 9176 0b07 08       		.byte	8
 9177 0b08 08       		.byte	8
 9178 0b09 08       		.byte	8
 9179 0b0a 08       		.byte	8
 9180 0b0b 08       		.byte	8
 9181 0b0c 00       		.byte	0
 9182 0b0d 01       		.byte	1
 9183 0b0e 02       		.byte	2
 9184 0b0f 10       		.byte	16
 9185 0b10 04       		.byte	4
 9186 0b11 05       		.byte	5
 9187 0b12 06       		.byte	6
 9188 0b13 07       		.byte	7
 9189 0b14 08       		.byte	8
 9190 0b15 09       		.byte	9
 9191 0b16 0A       		.byte	10
 9192 0b17 08       		.byte	8
 9193 0b18 11       		.byte	17
 9194 0b19 0C       		.byte	12
 9195 0b1a 0D       		.byte	13
 9196 0b1b 08       		.byte	8
 9197 0b1c 0E       		.byte	14
 9198 0b1d 0F       		.byte	15
 9199 0b1e 08       		.byte	8
 9200 0b1f 00       		.space	1
 9203              	CyFxGpifRegValue_usb2:
 9204 0b20 08830080 		.word	-2147450104
 9205 0b24 67000000 		.word	103
 9206 0b28 01000000 		.word	1
 9207 0b2c 46000000 		.word	70
 9208 0b30 00000000 		.word	0
 9209 0b34 00000000 		.word	0
 9210 0b38 02000000 		.word	2
 9211 0b3c 82000000 		.word	130
 9212 0b40 82070000 		.word	1922
 9213 0b44 40040000 		.word	1088
 9214 0b48 FCFF0000 		.word	65532
 9215 0b4c 28000000 		.word	40
 9216 0b50 00000000 		.word	0
 9217 0b54 00000000 		.word	0
 9218 0b58 00000000 		.word	0
 9219 0b5c 00000000 		.word	0
 9220 0b60 01000000 		.word	1
 9221 0b64 00000000 		.word	0
 9222 0b68 00000000 		.word	0
 9223 0b6c 00000000 		.word	0
 9224 0b70 00000000 		.word	0
 9225 0b74 00000000 		.word	0
 9226 0b78 00000000 		.word	0
 9227 0b7c 00000000 		.word	0
 9228 0b80 00000000 		.word	0
 9229 0b84 00000000 		.word	0
 9230 0b88 00000000 		.word	0
 9231 0b8c 00000000 		.word	0
 9232 0b90 00000000 		.word	0
 9233 0b94 06000000 		.word	6
 9234 0b98 00000000 		.word	0
 9235 0b9c FFFF0000 		.word	65535
 9236 0ba0 09010000 		.word	265
 9237 0ba4 00000000 		.word	0
 9238 0ba8 F71F0000 		.word	8183
 9239 0bac 00000000 		.word	0
 9240 0bb0 FFFF0000 		.word	65535
 9241 0bb4 09010000 		.word	265
 9242 0bb8 00000000 		.word	0
 9243 0bbc F71F0000 		.word	8183
 9244 0bc0 00000000 		.word	0
 9245 0bc4 00000000 		.word	0
 9246 0bc8 00000000 		.word	0
 9247 0bcc 00000000 		.word	0
 9248 0bd0 00000000 		.word	0
 9249 0bd4 00000000 		.word	0
 9250 0bd8 00000000 		.word	0
 9251 0bdc 00000000 		.word	0
 9252 0be0 00000000 		.word	0
 9253 0be4 00000000 		.word	0
 9254 0be8 00000000 		.word	0
 9255 0bec 00000000 		.word	0
 9256 0bf0 00000000 		.word	0
 9257 0bf4 00000000 		.word	0
 9258 0bf8 00000000 		.word	0
 9259 0bfc 00000000 		.word	0
 9260 0c00 00000000 		.word	0
 9261 0c04 00000000 		.word	0
 9262 0c08 00000000 		.word	0
 9263 0c0c 00000000 		.word	0
 9264 0c10 00000000 		.word	0
 9265 0c14 00000000 		.word	0
 9266 0c18 00000000 		.word	0
 9267 0c1c 00040180 		.word	-2147417088
 9268 0c20 01040180 		.word	-2147417087
 9269 0c24 02040180 		.word	-2147417086
 9270 0c28 03040180 		.word	-2147417085
 9271 0c2c 00000000 		.word	0
 9272 0c30 00000000 		.word	0
 9273 0c34 00000000 		.word	0
 9274 0c38 00000000 		.word	0
 9275 0c3c 00000000 		.word	0
 9276 0c40 00000000 		.word	0
 9277 0c44 00000000 		.word	0
 9278 0c48 00000000 		.word	0
 9279 0c4c C1FFFFFF 		.word	-63
 9280              		.section	.rodata.str1.4,"aMS",%progbits,1
 9281              		.align	2
 9282              	.LC0:
 9283 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9283      7065722D 
 9283      74696D65 
 9283      72202564 
 9283      0D0A00
 9284 0013 00       		.space	1
 9285              	.LC1:
 9286 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9286      636F6D6D 
 9286      616E6420 
 9286      71756575 
 9286      65206973 
 9287 0037 00       		.space	1
 9288              	.LC2:
 9289 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9289      7220696E 
 9289      206D756C 
 9289      74696368 
 9289      616E6E65 
 9290 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 9290      2C20646D 
 9290      61446F6E 
 9290      65202578 
 9290      0D0A00
 9291 007e 0000     		.space	2
 9292              	.LC3:
 9293 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9293      5420656E 
 9293      636F756E 
 9293      74657265 
 9293      642E2E2E 
 9294              	.LC4:
 9295 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9295      454E4420 
 9295      656E636F 
 9295      756E7465 
 9295      7265642E 
 9296 00c2 0000     		.space	2
 9297              	.LC5:
 9298 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9298      64697363 
 9298      6F6E6E65 
 9298      63746564 
 9298      2E2E2E30 
 9299 00e3 00       		.space	1
 9300              	.LC6:
 9301 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9301      43595F46 
 9301      585F5556 
 9301      435F5649 
 9301      44454F5F 
 9302 0117 0A00     		.ascii	"\012\000"
 9303 0119 000000   		.space	3
 9304              	.LC7:
 9305 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9305      43595F46 
 9305      585F5556 
 9305      435F5649 
 9305      44454F5F 
 9306 014f 00       		.ascii	"\000"
 9307              	.LC8:
 9308 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9308      726E6174 
 9308      65207365 
 9308      7474696E 
 9308      6720302E 
 9309              	.LC9:
 9310 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9310      72206665 
 9310      61747572 
 9310      65207265 
 9310      71756573 
 9311 018b 00       		.space	1
 9312              	.LC10:
 9313 018c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9313      6F6D6D69 
 9313      74656F66 
 9313      20737461 
 9313      7465203D 
 9314              	.LC11:
 9315 01a4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9315      6E656C20 
 9315      53657420 
 9315      57726170 
 9315      55702066 
 9316 01d1 000000   		.space	3
 9317              	.LC12:
 9318 01d4 4572726F 		.ascii	"Error handler...\015\012\000"
 9318      72206861 
 9318      6E646C65 
 9318      722E2E2E 
 9318      0D0A00
 9319 01e7 00       		.space	1
 9320              	.LC13:
 9321 01e8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9321      69742045 
 9321      4F462066 
 9321      61696C65 
 9321      64210A00 
 9322              	.LC14:
 9323 01fc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9323      49324320 
 9323      636F6D6D 
 9323      616E6420 
 9323      69732030 
 9324 022f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9324      78257820 
 9324      30782578 
 9324      20307825 
 9324      78203078 
 9325              	.LC15:
 9326 0248 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9326      49324320 
 9326      63757272 
 9326      656E7420 
 9326      64617461 
 9327 027b 64202564 		.ascii	"d %d\015\012\000"
 9327      0D0A00
 9328 0282 0000     		.space	2
 9329              	.LC16:
 9330 0284 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9330      26414743 
 9330      2073656E 
 9330      7420746F 
 9330      20686F73 
 9331 02aa 0000     		.space	2
 9332              	.LC17:
 9333 02ac 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9333      26414743 
 9333      20676F74 
 9333      74656E20 
 9333      66726F6D 
 9334 02d6 0000     		.space	2
 9335              	.LC18:
 9336 02d8 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9336      67657420 
 9336      64617461 
 9336      2066726F 
 9336      6D20686F 
 9337 0305 000000   		.space	3
 9338              	.LC19:
 9339 0308 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9339      52657175 
 9339      65737420 
 9339      30782578 
 9339      20706172 
 9340 033b 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9340      6E642074 
 9340      6F20686F 
 9340      73742030 
 9340      78257820 
 9341 0356 0000     		.space	2
 9342              	.LC20:
 9343 0358 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9343      204F7020 
 9343      72656365 
 9343      69766573 
 9343      20284354 
 9344 037f 00       		.space	1
 9345              	.LC21:
 9346 0380 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9346      756C7420 
 9346      73656C65 
 9346      63746F72 
 9346      20284354 
 9347 03a2 0000     		.space	2
 9348              	.LC22:
 9349 03a4 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9349      756C7420 
 9349      72657175 
 9349      65737420 
 9349      28435429 
 9350 03c5 000000   		.space	3
 9351              	.LC23:
 9352 03c8 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9352      52657175 
 9352      65737420 
 9352      30782578 
 9352      20706172 
 9353 03fb 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9353      20307825 
 9353      78202F20 
 9353      73656E64 
 9353      20746F20 
 9354 0428 00       		.ascii	"\000"
 9355 0429 000000   		.space	3
 9356              	.LC24:
 9357 042c 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9357      73706565 
 9357      64203D20 
 9357      25642065 
 9357      76656E66 
 9358 045c 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9358      71756573 
 9358      74203D20 
 9358      30782578 
 9358      20775661 
 9359 048c 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9359      203D2030 
 9359      78257820 
 9359      6973666C 
 9359      61672030 
 9360 04a6 0000     		.space	2
 9361              	.LC25:
 9362 04a8 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9362      64656661 
 9362      756C7420 
 9362      73657475 
 9362      70207265 
 9363              	.LC26:
 9364 04d4 54686520 		.ascii	"The host command is not correct for 1080p camera 0x"
 9364      686F7374 
 9364      20636F6D 
 9364      6D616E64 
 9364      20697320 
 9365 0507 25782030 		.ascii	"%x 0x%x %d\015\012\000"
 9365      78257820 
 9365      25640D0A 
 9365      00
 9366              	.LC27:
 9367 0514 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9367      43595F46 
 9367      585F5556 
 9367      435F5354 
 9367      5245414D 
 9368 053a 0000     		.space	2
 9369              	.LC28:
 9370 053c 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9370      55564320 
 9370      7374696C 
 9370      6C207472 
 9370      69676765 
 9371 0562 0000     		.space	2
 9372              	.LC29:
 9373 0564 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9373      7374696C 
 9373      6C207472 
 9373      69676765 
 9373      7220636F 
 9374 058b 00       		.space	1
 9375              	.LC30:
 9376 058c 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9376      65642074 
 9376      6F207365 
 9376      6E642069 
 9376      6E746572 
 9377 05bd 0A00     		.ascii	"\012\000"
 9378 05bf 00       		.space	1
 9379              	.LC31:
 9380 05c0 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9380      73657420 
 9380      64656620 
 9380      64617461 
 9380      20307825 
 9381 05df 00       		.space	1
 9382              	.LC32:
 9383 05e0 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9383      73657420 
 9383      64656620 
 9383      64617461 
 9383      20307825 
 9384 0613 2E0D0A00 		.ascii	".\015\012\000"
 9385 0617 00       		.space	1
 9386              	.LC33:
 9387 0618 55415254 		.ascii	"UART initialization failed!\012\000"
 9387      20696E69 
 9387      7469616C 
 9387      697A6174 
 9387      696F6E20 
 9388 0635 000000   		.space	3
 9389              	.LC34:
 9390 0638 49324320 		.ascii	"I2C initialization failed!\012\000"
 9390      696E6974 
 9390      69616C69 
 9390      7A617469 
 9390      6F6E2066 
 9391              	.LC35:
 9392 0654 49324320 		.ascii	"I2C configuration failed!\012\000"
 9392      636F6E66 
 9392      69677572 
 9392      6174696F 
 9392      6E206661 
 9393 066f 00       		.space	1
 9394              	.LC36:
 9395 0670 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9395      43726561 
 9395      74652045 
 9395      76656E74 
 9395      20666169 
 9396 069a 0000     		.space	2
 9397              	.LC37:
 9398 069c 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9398      20496E69 
 9398      74206661 
 9398      696C6564 
 9398      2C204572 
 9399 06bf 00       		.space	1
 9400              	.LC38:
 9401 06c0 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9401      204F7665 
 9401      72726964 
 9401      65206661 
 9401      696C6564 
 9402 06e7 00       		.space	1
 9403              	.LC39:
 9404 06e8 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9404      28323029 
 9404      204F7665 
 9404      72726964 
 9404      65206661 
 9405 0713 00       		.space	1
 9406              	.LC40:
 9407 0714 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9407      28323429 
 9407      204F7665 
 9407      72726964 
 9407      65206661 
 9408 073f 00       		.space	1
 9409              	.LC41:
 9410 0740 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9410      20536574 
 9410      20287265 
 9410      73657420 
 9410      32322920 
 9411 0772 00       		.ascii	"\000"
 9412 0773 00       		.space	1
 9413              	.LC42:
 9414 0774 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9414      20536574 
 9414      2028706F 
 9414      77657220 
 9414      32302920 
 9415 07a6 00       		.ascii	"\000"
 9416 07a7 00       		.space	1
 9417              	.LC43:
 9418 07a8 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9418      20536574 
 9418      2028736E 
 9418      61702073 
 9418      686F7420 
 9419 07db 25640A00 		.ascii	"%d\012\000"
 9420 07df 00       		.space	1
 9421              	.LC44:
 9422 07e0 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9422      46756E63 
 9422      74696F6E 
 9422      20466169 
 9422      6C656420 
 9423 080f 00       		.space	1
 9424              	.LC45:
 9425 0810 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9425      46756E63 
 9425      74696F6E 
 9425      20466169 
 9425      6C656420 
 9426 083f 00       		.space	1
 9427              	.LC46:
 9428 0840 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9428      53657420 
 9428      456E6470 
 9428      6F696E74 
 9428      20636F6E 
 9429 0870 00       		.ascii	"\000"
 9430 0871 000000   		.space	3
 9431              	.LC47:
 9432 0874 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9432      496E7465 
 9432      72727570 
 9432      74205374 
 9432      61747573 
 9433 08a7 20436F64 		.ascii	" Code = %d\012\000"
 9433      65203D20 
 9433      25640A00 
 9434 08b3 00       		.space	1
 9435              	.LC48:
 9436 08b4 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9436      65642074 
 9436      6F20616C 
 9436      6C6F6361 
 9436      7465206D 
 9437 08e7 65720D0A 		.ascii	"er\015\012\000"
 9437      00
 9438              	.LC49:
 9439 08ec 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9439      4368616E 
 9439      6E656C20 
 9439      43726561 
 9439      74696F6E 
 9440 091a 0000     		.space	2
 9441              	.LC50:
 9442 091c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9442      436F6E6E 
 9442      65637420 
 9442      6661696C 
 9442      65642C20 
 9443 0941 000000   		.space	3
 9444              	.LC51:
 9445 0944 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9445      4368616E 
 9445      6E656C20 
 9445      52657365 
 9445      74204661 
 9446 096f 00       		.space	1
 9447              	.LC52:
 9448 0970 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9448      4368616E 
 9448      6E656C20 
 9448      53657420 
 9448      5472616E 
 9449 09a1 00       		.ascii	"\000"
 9450 09a2 0000     		.space	2
 9451              	.LC53:
 9452 09a4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9452      4368616E 
 9452      6E656C20 
 9452      53657420 
 9452      5472616E 
 9453 09d5 0A00     		.ascii	"\012\000"
 9454 09d7 00       		.space	1
 9455              	.LC54:
 9456 09d8 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9456      75706572 
 9456      20677069 
 9456      6600
 9457 09e6 0000     		.space	2
 9458              	.LC55:
 9459 09e8 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9459      69676820 
 9459      67706966 
 9459      00
 9460 09f5 000000   		.space	3
 9461              	.LC56:
 9462 09f8 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9462      696E6720 
 9462      47504946 
 9462      20436F6E 
 9462      66696775 
 9463 0a2b 0A00     		.ascii	"\012\000"
 9464 0a2d 000000   		.space	3
 9465              	.LC57:
 9466 0a30 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9466      74696E67 
 9466      20475049 
 9466      46207374 
 9466      61746520 
 9467 0a63 0D0A00   		.ascii	"\015\012\000"
 9468 0a66 0000     		.space	2
 9469              	.LC58:
 9470 0a68 33303A55 		.ascii	"30:UVC App Thread\000"
 9470      56432041 
 9470      70702054 
 9470      68726561 
 9470      6400
 9471 0a7a 0000     		.space	2
 9472              	.LC59:
 9473 0a7c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9473      56432041 
 9473      70702045 
 9473      50302054 
 9473      68726561 
 9474 0a92 0000     		.space	2
 9475              	.LC60:
 9476 0a94 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9476      32432041 
 9476      70702043 
 9476      54524C20 
 9476      54687265 
 9477 0aab 00       		.bss
 9478              		.align	2
 9479              		.set	.LANCHOR0,. + 0
 9482              	glFxUVCEvent:
 9483 0000 00000000 		.space	40
 9483      00000000 
 9483      00000000 
 9483      00000000 
 9483      00000000 
 9486              	fb:
 9487 0028 0000     		.space	2
 9490              	pb:
 9491 002a 0000     		.space	2
 9494              	pbc:
 9495 002c 0000     		.space	2
 9498              	prodCount:
 9499 002e 0000     		.space	2
 9502              	consCount:
 9503 0030 0000     		.space	2
 9504 0032 0000     		.space	2
 9507              	streamingStarted:
 9508 0034 00000000 		.space	4
 9511              	gpif_initialized:
 9512 0038 00000000 		.space	4
 9515              	isUsbConnected:
 9516 003c 00000000 		.space	4
 9519              	clearFeatureRqtReceived:
 9520 0040 00000000 		.space	4
 9523              	hitFV:
 9524 0044 00000000 		.space	4
 9527              	usbSpeed:
 9528 0048 00       		.space	1
 9529 0049 000000   		.space	3
 9532              	I2CCMDArry:
 9533 004c 00000000 		.space	12
 9533      00000000 
 9533      00000000 
 9536              	glEp0Buffer:
 9537 0058 00000000 		.space	32
 9537      00000000 
 9537      00000000 
 9537      00000000 
 9537      00000000 
 9540              	glCommitCtrl:
 9541 0078 00000000 		.space	32
 9541      00000000 
 9541      00000000 
 9541      00000000 
 9541      00000000 
 9544              	stiflag:
 9545 0098 00000000 		.space	4
 9548              	uvcAppThread:
 9549 009c 00000000 		.space	168
 9549      00000000 
 9549      00000000 
 9549      00000000 
 9549      00000000 
 9552              	uvcAppEP0Thread:
 9553 0144 00000000 		.space	168
 9553      00000000 
 9553      00000000 
 9553      00000000 
 9553      00000000 
 9556              	i2cAppThread:
 9557 01ec 00000000 		.space	168
 9557      00000000 
 9557      00000000 
 9557      00000000 
 9557      00000000 
 9560              	testSnap:
 9561 0294 00       		.space	1
 9562 0295 00       		.space	1
 9565              	fbbak:
 9566 0296 0000     		.space	2
 9569              	pbbak:
 9570 0298 0000     		.space	2
 9573              	pbcbak:
 9574 029a 0000     		.space	2
 9577              	pbcpbak:
 9578 029c 0000     		.space	2
 9579 029e 0000     		.text
 9580              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:191    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:292    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:306    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:303    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:325    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:329    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:332    .text:00000250 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:490    .text:00000378 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:498    .text:0000038c $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:500    .text:0000038c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:679    .text:000004ec $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:688    .text:000004fc $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:690    .text:000004fc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1015   .text:000007c4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1031   .text:000007f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1034   .text:000007f0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1080   .text:0000082c $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1093   .text:00000858 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1156   .text:000008c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1163   .text:000008d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1174   .text:000008f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1177   .text:000008f0 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1288   .text:000009e4 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1293   .text:000009ec $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1296   .text:000009ec setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1359   .text:00000a6c ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1566   .text:00000c08 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1604   .text:00000c94 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1668   .text:00000d18 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:1704   .text:00000da0 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:2859   .text:00001878 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:2876   .text:000018b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:2879   .text:000018b0 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:3047   .text:00001a0c $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:3060   .text:00001a34 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:3555   .text:00001f44 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:3566   .text:00001f64 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:3821   .text:0000221c $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:3834   .text:00002244 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:3837   .text:00002244 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:3899   .text:000022c0 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:3907   .text:000022d0 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5034   .text:00002c2c $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5062   .text:00002c88 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5065   .text:00002c88 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5356   .text:00002f40 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5363   .text:00002f50 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5366   .text:00002f50 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5402   .text:00002f7c $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5406   .text:00002f80 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5409   .text:00002f80 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5434   .text:00002f9c $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5438   .text:00002fa0 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:5441   .text:00002fa0 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:6820   .text:00003a64 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:6880   .text:00003b38 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:6883   .text:00003b38 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:6966   .text:00003bc4 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:6975   .text:00003bd4 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:6978   .text:00003bd4 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7135   .text:00003d4c $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7151   .text:00003d80 $a
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7154   .text:00003d80 main
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8748   .data:00000660 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8757   .data:0000066c CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8832   .data:0000078c CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8851   .data:0000079c CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7315   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8930   .data:000008cc CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8941   .data:000008dc CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9052   .data:00000a8c CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9203   .data:00000b20 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7328   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8744   .data:0000065f snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9560   .bss:00000294 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9486   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9490   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9494   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9565   .bss:00000296 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9569   .bss:00000298 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9573   .bss:0000029a pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9577   .bss:0000029c pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9515   .bss:0000003c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9527   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9519   .bss:00000040 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9507   .bss:00000034 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8655   .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8715   .data:00000648 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8685   .data:0000062c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8730   .data:00000654 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8310   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7292   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7296   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7340   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7344   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:7667   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8325   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:8332   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9281   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9478   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9482   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9498   .bss:0000002e prodCount
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9502   .bss:00000030 consCount
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9511   .bss:00000038 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9523   .bss:00000044 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9532   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9536   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9540   .bss:00000078 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9544   .bss:00000098 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9548   .bss:0000009c uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9552   .bss:00000144 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccznKkMC.s:9556   .bss:000001ec i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
