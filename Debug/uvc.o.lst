   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB17:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 141:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 145:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 146:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 147:../uvc.c      **** };
 148:../uvc.c      **** 
 149:../uvc.c      **** 
 150:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 151:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 152:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 154:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 155:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 156:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 157:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 158:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 159:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 160:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 161:../uvc.c      ****                                    with adjustable compression parameters */
 162:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 163:../uvc.c      ****                                    streaming with adjustable compression parameters */
 164:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 165:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 170:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 171:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 173:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 174:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 175:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 176:../uvc.c      **** };
 177:../uvc.c      **** 
 178:../uvc.c      **** 
 179:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 180:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 181:../uvc.c      **** 
 182:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 183:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 184:../uvc.c      **** {
 185:../uvc.c      ****     0x0C,                               /* Header Length */
 186:../uvc.c      ****     0x8C,                               /* Bit field header field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 188:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 189:../uvc.c      **** };
 190:../uvc.c      **** 
 191:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 192:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 193:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 194:../uvc.c      ****                                                            the current video frame. */
 195:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 196:../uvc.c      **** #ifndef CAM720
 197:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 198:../uvc.c      **** #else
 199:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 200:../uvc.c      **** #endif
 201:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 202:../uvc.c      **** 
 203:../uvc.c      **** /************ control parameters array ***********
 204:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 205:../uvc.c      ****  *    e.g.
 206:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 207:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 208:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 209:../uvc.c      ****  **************************************************/
 210:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 211:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 212:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 213:../uvc.c      **** #ifndef CAM720
 214:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 215:../uvc.c      **** #else
 216:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 217:../uvc.c      **** #endif
 218:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  63,     0, 1, 0, 3, 0, 31, 0, 
 219:../uvc.c      **** 		{/*2*/0x7/*ContrastReg*/  , 0x7/*ContrastReg*/   , 2,    16,   0,  64,     0, 1, 0, 3, 0, 40, 0, 
 220:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 221:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 222:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 223:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 224:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   14,    0, 1, 0, 3, 0,   0, 0,
 225:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*9*/0xb/*WBModeReg*/    , 0xb/*WBModeReg*/     , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 228:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 229:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 233:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 235:../uvc.c      **** #ifndef CAM720
 236:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 237:../uvc.c      **** #else
 238:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 239:../uvc.c      **** #endif
 240:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 241:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 242:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 244:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 246:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  255,    0, 1, 0, 3, 0,   0,32
 247:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg0     , 2,    0,    0,   63,    0, 1, 0, 3, 0,  32, 0
 248:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		/**********************************
 253:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 254:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 255:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 256:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 257:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 258:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 259:../uvc.c      **** 		 *
 260:../uvc.c      **** 		 *********************************/
 261:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 262:../uvc.c      **** };
 263:../uvc.c      **** 
 264:../uvc.c      **** #ifndef CAM720
 265:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 266:../uvc.c      **** #else
 267:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 268:../uvc.c      **** #endif
 269:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 270:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 271:../uvc.c      **** 
 272:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 273:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 274:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 275:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 276:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 277:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 278:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 279:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 280:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 281:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 282:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 285:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 287:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 288:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 289:../uvc.c      **** };
 290:../uvc.c      **** 
 291:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 292:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 293:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 294:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 295:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 296:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 297:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 298:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 299:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 300:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 302:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 303:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 304:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 308:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 309:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 310:../uvc.c      **** };
 311:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 312:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 313:../uvc.c      **** 
 314:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 315:../uvc.c      **** 
 316:../uvc.c      **** /*
 317:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 318:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 319:../uvc.c      ****  */
 320:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 321:../uvc.c      **** 		0xa0, 0x0f, 0xf, 0xf0
 322:../uvc.c      **** };
 323:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 324:../uvc.c      **** 		0
 325:../uvc.c      **** };
 326:../uvc.c      **** 
 327:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 328:../uvc.c      **** 
 329:../uvc.c      **** void I2CCmdHandler(){
 330:../uvc.c      **** 	uint8_t buf[2];
 331:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 332:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 333:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 334:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 335:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 336:../uvc.c      **** 
 337:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 338:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 339:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 340:../uvc.c      **** 
 341:../uvc.c      **** 	if(CmdType == 0)//I2C read
 342:../uvc.c      **** 	{
 343:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 344:../uvc.c      **** #if 0 //for debugging
 345:../uvc.c      **** 		/* test still image operation */
 346:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 347:../uvc.c      **** 			snapButFlag = 0; //press
 348:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 349:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 350:../uvc.c      **** 			snapButFlag = 0xf; //release
 351:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 352:../uvc.c      **** 		}
 353:../uvc.c      **** 
 354:../uvc.c      **** 		/* end of the test */
 355:../uvc.c      **** #endif
 356:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 357:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 358:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 359:../uvc.c      **** 			if(CmdDataLen == 2){
 360:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 361:../uvc.c      **** 			}
 362:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 363:../uvc.c      **** 		}else{//not support currently
 364:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 365:../uvc.c      **** 		}
 366:../uvc.c      **** 	}else if(CmdType == 1){
 367:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 368:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 369:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 370:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 371:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 372:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 373:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 374:../uvc.c      **** 			}
 375:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 376:../uvc.c      **** 		}else{//not support currently
 377:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 378:../uvc.c      **** 		}
 379:../uvc.c      **** 
 380:../uvc.c      **** 	}
 381:../uvc.c      **** }
 382:../uvc.c      **** 
 383:../uvc.c      **** /************************************
 384:../uvc.c      ****  * set Iris mode
 385:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 386:../uvc.c      ****  */
 387:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 388:../uvc.c      **** 	uint8_t dataIdx;
 389:../uvc.c      **** 	  dataIdx = 0;
 390:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 392:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 393:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 394:../uvc.c      **** }
 395:../uvc.c      **** 
 396:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 397:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 398:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 399:../uvc.c      ****     uint16_t readCount;
 400:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 401:../uvc.c      ****     uint8_t devAdd;
 402:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 403:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 404:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 405:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 406:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 407:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 408:../uvc.c      ****     }else{
 409:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 410:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 411:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 412:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 413:../uvc.c      ****     }
 414:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 415:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 416:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 417:../uvc.c      **** #endif
 418:../uvc.c      ****     reqData = bRequest;
 419:../uvc.c      ****     /*
 420:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 421:../uvc.c      ****      */
 422:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 423:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 424:../uvc.c      ****     	goto EndofSet;
 425:../uvc.c      ****     }
 426:../uvc.c      ****     switch (bRequest)
 427:../uvc.c      **** 		 {
 428:../uvc.c      **** 
 429:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 430:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 431:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 432:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 433:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 434:../uvc.c      **** 			  break;
 435:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 436:../uvc.c      **** 
 437:../uvc.c      **** 			 switch(CtrlID)
 438:../uvc.c      **** 			 {
 439:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 440:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 441:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 442:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 443:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 444:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 445:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 446:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 447:../uvc.c      **** 			 	 		 break;
 448:../uvc.c      **** 			 	 }
 449:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 450:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 451:../uvc.c      **** 					 if(CamMode == 1){//720p
 452:../uvc.c      **** 						if(sendData >= 3){
 453:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 454:../uvc.c      **** 							sendData = 0; //set back to default
 455:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 456:../uvc.c      **** 						}
 457:../uvc.c      **** 						sendData += 4;
 458:../uvc.c      **** 					 }
 459:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 460:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 461:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 462:../uvc.c      **** 					 break;
 463:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 464:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 465:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 466:../uvc.c      **** 			 		 }
 467:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 468:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 469:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 470:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 471:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 472:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 473:../uvc.c      **** #endif
 474:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 475:../uvc.c      **** 			 		 {
 476:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 477:../uvc.c      **** 			 		 }
 478:../uvc.c      **** 			 		 break;
 479:../uvc.c      **** 				 case ExtAexModCtlID9:
 480:../uvc.c      **** 
 481:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 482:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 483:../uvc.c      **** 						 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 484:../uvc.c      **** 		 	 		 }else{
 485:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 486:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 487:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 488:../uvc.c      **** 
 489:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 490:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 491:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 492:../uvc.c      **** 		 	 		 }
 493:../uvc.c      **** 
 494:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 496:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 497:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 498:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 499:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 500:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 501:../uvc.c      **** 					 break;
 502:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 503:../uvc.c      **** 			 	 case BrgtCtlID1:
 504:../uvc.c      **** 
 505:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 506:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 507:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 508:../uvc.c      **** 		 	 		 }else{
 509:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 510:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 511:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 512:../uvc.c      **** 
 513:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 514:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 515:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 516:../uvc.c      **** 		 	 		 }
 517:../uvc.c      **** 
 518:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 519:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 520:../uvc.c      **** 					 }else{
 521:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 522:../uvc.c      **** 					 }
 523:../uvc.c      **** 
 524:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 525:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 526:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 527:../uvc.c      **** 					 break;
 528:../uvc.c      **** #endif
 529:../uvc.c      **** 				 case HueCtlID5://TODO check sensor register
 530:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 531:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 533:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 534:../uvc.c      **** 					 break;
 535:../uvc.c      **** 				 case WBTLevCtlID11:
 536:../uvc.c      **** 
 537:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 538:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 539:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 540:../uvc.c      **** 		 	 		 }else{
 541:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd1, devAdd);
 542:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 543:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 544:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 545:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 546:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 547:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 548:../uvc.c      **** 		 	 		 }
 549:../uvc.c      **** 
 550:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 551:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 552:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 553:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 554:../uvc.c      **** 					 break;
 555:../uvc.c      **** 				 case SaturCtlID6://TODO check sensor register
 556:../uvc.c      **** 				 default:
 557:../uvc.c      **** 
 558:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 560:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 561:../uvc.c      **** 		 	 		 }else{
 562:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 565:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 566:../uvc.c      **** 		 	 		 }
 567:../uvc.c      **** 
 568:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 571:../uvc.c      **** 					 break;
 572:../uvc.c      **** 			 }
 573:../uvc.c      **** 
 574:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 575:../uvc.c      **** 
 576:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 577:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 578:../uvc.c      **** #endif
 579:../uvc.c      **** 			  break;
 580:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 581:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 584:../uvc.c      **** 		 	 }
 585:../uvc.c      **** 
 586:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 587:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 588:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 589:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 590:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 591:../uvc.c      **** 			 }else
 592:../uvc.c      **** 			 {
 593:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 595:../uvc.c      **** 			 }
 596:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 598:../uvc.c      **** 			  break;
 599:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 600:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 601:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 603:../uvc.c      **** 		 	 }
 604:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 605:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 606:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 607:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 608:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 609:../uvc.c      **** 			 }else
 610:../uvc.c      **** 			 {
 611:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 613:../uvc.c      **** 			 }
 614:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 615:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 616:../uvc.c      **** 			  break;
 617:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 618:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 619:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 622:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 623:../uvc.c      **** 		 	 }
 624:../uvc.c      **** 		 	 else{
 625:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 629:../uvc.c      **** 		 	 }
 630:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 632:../uvc.c      **** 			  break;
 633:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 634:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 635:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 636:../uvc.c      **** 		 	 }
 637:../uvc.c      **** 		 	 else{
 638:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 639:../uvc.c      **** 		 	 }
 640:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 642:../uvc.c      **** 			  Len = 1;
 643:../uvc.c      **** 			  break;
 644:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 645:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 646:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 648:../uvc.c      **** 		 	 }
 649:../uvc.c      **** 
 650:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 651:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 652:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 653:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 654:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 655:../uvc.c      **** 			 }else{
 656:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 658:../uvc.c      **** 			 }
 659:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 660:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 661:../uvc.c      **** 			  break;
 662:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 663:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 665:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 666:../uvc.c      **** 			   {
 667:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 669:../uvc.c      **** 				  getData = glEp0Buffer[0];
 670:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 672:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 673:../uvc.c      **** #endif
 674:../uvc.c      **** 				  switch(CtrlID)
 675:../uvc.c      **** 					 {
 676:../uvc.c      **** 						 case ExtShutCtlID0:
 677:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 678:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 679:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 680:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 681:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 682:../uvc.c      **** 									 }else{
 683:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 684:../uvc.c      **** 									 }
 685:../uvc.c      **** 								 }
 686:../uvc.c      **** 							 }else{
 687:../uvc.c      **** 								 Data1 = Data0 - 1;
 688:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 689:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 690:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 691:../uvc.c      **** 									 }else{
 692:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 693:../uvc.c      **** 									 }
 694:../uvc.c      **** 								 }
 695:../uvc.c      **** 								 if(Data1 < 8){
 696:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 698:../uvc.c      **** 								 }else{
 699:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 701:../uvc.c      **** 								 }
 702:../uvc.c      **** 							 }
 703:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 704:../uvc.c      **** 							 dataIdx = 0;
 705:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 708:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 709:../uvc.c      **** 							 break;
 710:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 711:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 714:../uvc.c      **** 							 dataIdx = 0;
 715:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 717:../uvc.c      **** 							 if(1 || (getData != 0)){
 718:../uvc.c      **** 								 //dataIdx++;
 719:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 720:../uvc.c      **** 							 }
 721:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 722:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 723:../uvc.c      **** 							 break;
 724:../uvc.c      **** 						 case ExtExRefCtlID10:
 725:../uvc.c      **** 							 dataIdx = 0;
 726:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 727:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 728:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 729:../uvc.c      **** 							 if(WDRflag)
 730:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 731:../uvc.c      **** 							 else
 732:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 734:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 735:../uvc.c      **** 						 case ExtCamMCtlID12:
 736:../uvc.c      **** 							 /*
 737:../uvc.c      **** 							 dataIdx = 0;
 738:../uvc.c      **** 							 if(Data0 <= 3){
 739:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 740:../uvc.c      **** 								 Data1 = Data0;
 741:../uvc.c      **** 							 }else{
 742:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 743:../uvc.c      **** 								 Data1 = Data0-4;
 744:../uvc.c      **** 							 }
 745:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 746:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 747:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 748:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 749:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 750:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 751:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 752:../uvc.c      **** 							 */
 753:../uvc.c      **** 							 break;
 754:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 755:../uvc.c      **** 							 dataIdx = 0;
 756:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 757:../uvc.c      **** 								 Data0 = 1;
 758:../uvc.c      **** 							 }else{ //save current sensor parameters.
 759:../uvc.c      **** 								 Data0 = 0;
 760:../uvc.c      **** 							 }
 761:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 764:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 765:../uvc.c      **** 							 break;
 766:../uvc.c      **** 						 case ExtI2CCtlID15:
 767:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 769:../uvc.c      **** 					 		 }
 770:../uvc.c      **** 					 		I2CCmdHandler();
 771:../uvc.c      **** 							 break;
 772:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 773:../uvc.c      **** 							 dataIdx = 0;
 774:../uvc.c      **** #if 0 //seperate version
 775:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 776:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 777:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 778:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 779:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 780:../uvc.c      **** 							 }else{ //disable BLD window
 781:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 782:../uvc.c      **** 							 }
 783:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 784:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 785:../uvc.c      **** 							 dataIdx++;
 786:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 787:../uvc.c      **** 							 dataIdx++;
 788:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 789:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 790:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 791:../uvc.c      **** 							 dataIdx++;
 792:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 793:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 794:../uvc.c      **** #else //combination version
 795:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 797:../uvc.c      **** 						     /* end test */
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 799:../uvc.c      **** 							 dataIdx++;
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 801:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 802:../uvc.c      **** 							 getData1 = Data1;
 803:../uvc.c      **** #endif
 804:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 807:../uvc.c      **** 							 break;
 808:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 809:../uvc.c      **** 							 dataIdx = 0;
 810:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 812:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 815:../uvc.c      **** 							 break;
 816:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 817:../uvc.c      **** 							 dataIdx = 0;
 818:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 821:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 823:../uvc.c      **** 							 break;
 824:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 825:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 826:../uvc.c      **** 							 dataIdx = 0;
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 828:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 829:../uvc.c      **** 							  if(Data0&0x80){
 830:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 831:../uvc.c      **** 							  }else{
 832:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 833:../uvc.c      **** 							  }
 834:../uvc.c      **** 							 Data1 |= ~0x03;
 835:../uvc.c      **** 							 Data1 &= 0xC7;
 836:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 837:../uvc.c      **** 						  	 dataIdx++;
 838:../uvc.c      **** 
 839:../uvc.c      **** 							 Data0 = (Data0 << 2);
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 841:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 842:../uvc.c      **** 
 843:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 844:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 845:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 846:../uvc.c      **** 
 847:../uvc.c      **** 							 break;
 848:../uvc.c      **** #endif
 849:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 850:../uvc.c      **** 							 dataIdx = 0;
 851:../uvc.c      **** 
 852:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 853:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 854:../uvc.c      **** 							 dataIdx++;
 855:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 856:../uvc.c      **** 							 dataIdx++;
 857:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 858:../uvc.c      **** 							 dataIdx++;
 859:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 860:../uvc.c      **** 							 dataIdx++;
 861:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 862:../uvc.c      **** 							 dataIdx++;
 863:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 864:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 865:../uvc.c      **** 
 866:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 868:../uvc.c      **** 							 break;
 869:../uvc.c      **** 						 case SaturCtlID6:
 870:../uvc.c      **** 							 dataIdx = 0;
 871:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 872:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 873:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 874:../uvc.c      **** 							 dataIdx++;
 875:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 876:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 877:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 878:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 879:../uvc.c      **** 							 break;
 880:../uvc.c      **** 
 881:../uvc.c      **** 						 case WBTLevCtlID11:
 882:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue to 0x9 or low to 0xa
 883:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red to 0xa or high to 0x9
 884:../uvc.c      **** 							 dataIdx = 0;
 885:../uvc.c      **** 
 886:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 887:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 888:../uvc.c      **** 							 dataIdx++;
 889:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data1, dataIdx);  //Second
 890:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 891:../uvc.c      **** 
 892:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 893:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 894:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 895:../uvc.c      **** 							 break;
 896:../uvc.c      **** 						 case MFreqCtlID4:
 897:../uvc.c      **** 							 dataIdx = 0;
 898:../uvc.c      **** 							 Data0 = Data0 - 1;
 899:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 900:../uvc.c      **** 								 Data0 = 0;
 901:../uvc.c      **** 							 else if(Data0 >2)
 902:../uvc.c      **** 								 Data0 = 1;
 903:../uvc.c      **** 
 904:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 905:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 906:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 907:../uvc.c      **** 
 908:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 909:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 910:../uvc.c      **** 							 break;
 911:../uvc.c      **** 					 	 case BLCCtlID0:
 912:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 913:../uvc.c      **** 							 if(Data0 == 3)
 914:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 915:../uvc.c      **** 							 else
 916:../uvc.c      **** 								 WDRflag = CyFalse;
 917:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 918:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 919:../uvc.c      **** 							 {
 920:../uvc.c      **** 								 if(Data0 < 2){
 921:../uvc.c      **** 					 				 ;//Data0 += 4;
 922:../uvc.c      **** 					 			 }else{
 923:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 924:../uvc.c      **** 									Data0 = 0; //set to default.
 925:../uvc.c      **** 					 			 }
 926:../uvc.c      **** 					 		 }
 927:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 928:../uvc.c      **** 							 dataIdx = 0;
 929:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 930:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 931:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 932:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 933:../uvc.c      **** 
 934:../uvc.c      **** 					 		 break;
 935:../uvc.c      **** 						 default:
 936:../uvc.c      **** 							 dataIdx = 0;
 937:../uvc.c      **** 
 938:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 939:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 940:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 941:../uvc.c      **** 
 942:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 943:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 944:../uvc.c      **** 							 break;
 945:../uvc.c      **** 					 }
 946:../uvc.c      **** 			   }else{
 947:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 948:../uvc.c      **** 			   }
 949:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 950:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 951:../uvc.c      **** #endif
 952:../uvc.c      **** 
 953:../uvc.c      **** 			  break;
 954:../uvc.c      **** 		  default:
 955:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 956:../uvc.c      **** 			  break;
 957:../uvc.c      **** 		 }
 958:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 959:../uvc.c      **** }
 960:../uvc.c      **** /************** CT control requests handler *************************/
 961:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 962:../uvc.c      **** 
 963:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 964:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 965:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 966:../uvc.c      ****     uint16_t readCount;
 967:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 968:../uvc.c      ****     uint16_t diff, value, diffRd;
 969:../uvc.c      ****     uint8_t i, shutter, index;
 970:../uvc.c      ****     diff = 0xffff;
 971:../uvc.c      ****     shutter = 1;
 972:../uvc.c      ****     index = 1;
 973:../uvc.c      **** 
 974:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 975:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 976:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 977:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 978:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 979:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 980:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 981:../uvc.c      **** #endif
 982:../uvc.c      ****     reqData = bRequest;
 983:../uvc.c      **** 
 984:../uvc.c      ****     switch (bRequest)
 985:../uvc.c      **** 		 {
 986:../uvc.c      **** 
 987:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 988:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 989:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 990:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 991:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 992:../uvc.c      **** 			  break;
 993:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 994:../uvc.c      **** 
 995:../uvc.c      **** 			 switch(CtrlID)
 996:../uvc.c      **** 			 {
 997:../uvc.c      **** 				 default:
 998:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 999:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1000:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1001:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1002:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1003:../uvc.c      **** 					 break;
1004:../uvc.c      **** 			 }
1005:../uvc.c      **** 
1006:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1007:../uvc.c      **** 
1008:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1009:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1010:../uvc.c      **** #endif
1011:../uvc.c      **** 			  break;
1012:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1013:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1014:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1015:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1016:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1017:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1018:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1019:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1020:../uvc.c      **** 			  break;
1021:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1022:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1023:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1024:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1025:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1026:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1027:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1028:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1029:../uvc.c      **** 			  break;
1030:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1031:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1032:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1033:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1034:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1035:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1038:../uvc.c      **** 			  break;
1039:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1040:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1041:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1042:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1043:../uvc.c      **** 			  Len = 1;
1044:../uvc.c      **** 			  break;
1045:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1046:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1047:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1048:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1049:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1050:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1051:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1052:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1053:../uvc.c      **** 			  break;
1054:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1055:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1056:../uvc.c      **** 			  glEp0Buffer, &readCount);
1057:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1058:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1059:../uvc.c      **** 			  value = Data1;
1060:../uvc.c      **** 
1061:../uvc.c      **** 			  switch(CtrlID)
1062:../uvc.c      **** 			  {
1063:../uvc.c      **** 		  	      case AutoExMCtlID1:
1064:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1065:../uvc.c      **** 
1066:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1067:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1068:../uvc.c      **** 				    getData = glEp0Buffer[0];
1069:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1070:../uvc.c      **** 		  		    switch (getData){
1071:../uvc.c      **** 						case 1:
1072:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1073:../uvc.c      **** 							break;
1074:../uvc.c      **** 						case 2:
1075:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1076:../uvc.c      **** 							dataIdx = 0;
1077:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1078:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1079:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1080:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1081:../uvc.c      **** 
1082:../uvc.c      **** 							break;
1083:../uvc.c      **** 						case 4:
1084:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1085:../uvc.c      **** 							break;
1086:../uvc.c      **** 						case 8:
1087:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1088:../uvc.c      **** 			  		    	dataIdx = 0;
1089:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1090:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1091:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1092:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1093:../uvc.c      **** 							break;
1094:../uvc.c      **** 		  		    }
1095:../uvc.c      **** #if 0
1096:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1097:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1098:../uvc.c      **** 						  dataIdx = 0;
1099:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1100:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1101:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1102:../uvc.c      **** 		  		    }
1103:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1104:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1105:../uvc.c      **** 		  		    }
1106:../uvc.c      **** #endif
1107:../uvc.c      **** 				    break;
1108:../uvc.c      **** 
1109:../uvc.c      **** 			  	  case ExTmACtlID3:
1110:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1111:../uvc.c      **** 
1112:../uvc.c      **** 					  value = (value << 8)|Data0;
1113:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1114:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1115:../uvc.c      **** 					  {
1116:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1117:../uvc.c      **** 						  {
1118:../uvc.c      **** 							if(value > ShutValueArry[i]){
1119:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1120:../uvc.c      **** 							}else{
1121:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1122:../uvc.c      **** 							}
1123:../uvc.c      **** 							  if(diff > diffRd){
1124:../uvc.c      **** 								  diff = diffRd;
1125:../uvc.c      **** 								  index = i;
1126:../uvc.c      **** 							  }
1127:../uvc.c      **** 						  }
1128:../uvc.c      **** 						  shutter = shutter+index;
1129:../uvc.c      **** 
1130:../uvc.c      **** 						  dataIdx = 0;
1131:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1132:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1133:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1134:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1135:../uvc.c      **** 
1136:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1137:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1139:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1140:../uvc.c      **** 					  }else{
1141:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1142:../uvc.c      **** 					  }
1143:../uvc.c      **** 					  getData = glEp0Buffer[0];
1144:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1145:../uvc.c      **** 					  break;
1146:../uvc.c      **** 			  	  case IriACtlID7:
1147:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1148:../uvc.c      **** 					  {
1149:../uvc.c      **** 							 dataIdx = 0;
1150:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1151:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1152:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1153:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1154:../uvc.c      **** 
1155:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1156:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1158:../uvc.c      **** 					  }else{
1159:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1160:../uvc.c      **** 					  }
1161:../uvc.c      **** 					  getData = glEp0Buffer[0];
1162:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1163:../uvc.c      **** 
1164:../uvc.c      **** 					  break;
1165:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1166:../uvc.c      **** 					  getData = glEp0Buffer[0];
1167:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1168:../uvc.c      **** #if 1
1169:../uvc.c      **** 					  dataIdx = 0;
1170:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1171:../uvc.c      **** 					  if(getData == 1)
1172:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1173:../uvc.c      **** 					  else if(getData == 0xff)
1174:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1175:../uvc.c      **** 					  else
1176:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1177:../uvc.c      **** 					  //dataIdx++;
1178:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1179:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1180:../uvc.c      **** #endif
1181:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1182:../uvc.c      **** 					  break;
1183:../uvc.c      **** 
1184:../uvc.c      **** 			  	  default:
1185:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1186:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1187:../uvc.c      **** 			  		 break;
1188:../uvc.c      **** 			  }
1189:../uvc.c      **** 			  break;
1190:../uvc.c      **** 		  default:
1191:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1192:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1193:../uvc.c      **** 			  break;
1194:../uvc.c      **** 		 }
1195:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1196:../uvc.c      **** 
1197:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1198:../uvc.c      **** }
1199:../uvc.c      **** 
1200:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1201:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1202:../uvc.c      **** {
1203:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1204:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1205:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1206:../uvc.c      **** 
1207:../uvc.c      ****     CtrlID = BrgtCtlID1;
1208:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1209:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1210:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1211:../uvc.c      ****     Data1 = Data0;
1212:../uvc.c      **** 
1213:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1214:../uvc.c      ****     if(Data1&0x80){
1215:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1216:../uvc.c      ****     }else{
1217:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1218:../uvc.c      ****     }
1219:../uvc.c      ****     Data0 = (Data0 << 2);
1220:../uvc.c      **** 
1221:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1222:../uvc.c      **** 
1223:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1224:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1225:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1226:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1227:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1228:../uvc.c      **** 
1229:../uvc.c      ****     CtrlID = ConsCtlID2;
1230:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1231:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1232:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1233:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1234:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1235:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1236:../uvc.c      **** 
1237:../uvc.c      ****     CtrlID = HueCtlID5;
1238:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1239:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1240:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1241:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1242:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1247:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1248:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1249:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1250:../uvc.c      **** 
1251:../uvc.c      ****     CtrlID = SaturCtlID6;
1252:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1253:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1254:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1255:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1256:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1257:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1258:../uvc.c      **** 
1259:../uvc.c      ****     CtrlID = ShapCtlID7;
1260:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1261:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1262:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1263:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1264:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1265:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1266:../uvc.c      **** 
1267:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1268:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1269:../uvc.c      **** 	return;
1270:../uvc.c      **** }
1271:../uvc.c      **** 
1272:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1273:../uvc.c      **** void
1274:../uvc.c      **** CyFxUVCAddHeader (
1275:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1276:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1277:../uvc.c      ****         )
1278:../uvc.c      **** {
1279:../uvc.c      ****     /* Copy header to buffer */
1280:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1281:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1282:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1283:../uvc.c      **** 
1284:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1285:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1286:../uvc.c      ****     {
1287:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1288:../uvc.c      ****     }
1289:../uvc.c      **** }
1290:../uvc.c      **** 
1291:../uvc.c      **** 
1292:../uvc.c      **** /* Application Error Handler */
1293:../uvc.c      **** void
1294:../uvc.c      **** CyFxAppErrorHandler (
1295:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1296:../uvc.c      ****         )
1297:../uvc.c      **** {
1298:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1299:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1300:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1301:../uvc.c      **** 
1302:../uvc.c      ****        This function can be modified to take additional error handling actions such
1303:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1304:../uvc.c      ****      */
1305:../uvc.c      ****     for (;;)
1306:../uvc.c      ****     {
1307:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1308:../uvc.c      ****         CyU3PThreadSleep (1000);
1309:../uvc.c      ****     }
1310:../uvc.c      **** }
1311:../uvc.c      **** 
1312:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1313:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1314:../uvc.c      ****  */
1315:../uvc.c      **** static void
1316:../uvc.c      **** CyFxUVCApplnAbortHandler (
1317:../uvc.c      ****         void)
1318:../uvc.c      **** {
1319:../uvc.c      **** 	uint32_t flag;
1320:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1321:../uvc.c      **** 	{
1322:../uvc.c      ****         /* Clear the Video Stream Request Event */
1323:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1324:../uvc.c      **** 
1325:../uvc.c      ****         /* Set Video Stream Abort Event */
1326:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1327:../uvc.c      **** 	}
1328:../uvc.c      **** }
1329:../uvc.c      **** 
1330:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1331:../uvc.c      **** static void
1332:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1333:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1334:../uvc.c      ****         uint16_t             evdata  /* Event data */
1335:../uvc.c      ****         )
1336:../uvc.c      **** {
1337:../uvc.c      ****     switch (evtype)
1338:../uvc.c      ****     {
1339:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1340:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1341:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1342:../uvc.c      ****             gpif_initialized = 0;
1343:../uvc.c      ****             streamingStarted = CyFalse;
1344:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1345:../uvc.c      ****             break;
1346:../uvc.c      **** 
1347:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1348:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1349:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1350:../uvc.c      ****             gpif_initialized = 0;
1351:../uvc.c      ****             streamingStarted = CyFalse;
1352:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1353:../uvc.c      ****             break;
1354:../uvc.c      **** 
1355:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1356:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1357:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1358:../uvc.c      ****             gpif_initialized = 0;
1359:../uvc.c      ****             isUsbConnected = CyFalse;
1360:../uvc.c      ****             streamingStarted = CyFalse;
1361:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1362:../uvc.c      ****             break;
1363:../uvc.c      **** 
1364:../uvc.c      **** #ifdef BACKFLOW_DETECT
1365:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1366:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1367:../uvc.c      ****             break;
1368:../uvc.c      **** #endif
1369:../uvc.c      **** 
1370:../uvc.c      ****         default:
1371:../uvc.c      ****             break;
1372:../uvc.c      ****     }
1373:../uvc.c      **** }
1374:../uvc.c      **** 
1375:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1376:../uvc.c      **** static CyBool_t
1377:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1378:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1379:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1380:../uvc.c      ****         )
1381:../uvc.c      **** {
1382:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1383:../uvc.c      ****     uint32_t status;
1384:../uvc.c      **** 
1385:../uvc.c      ****     /* Obtain Request Type and Request */
1386:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1387:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1388:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1389:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1390:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1391:../uvc.c      **** 
1392:../uvc.c      ****     /* Check for UVC Class Requests */
1393:../uvc.c      ****     switch (bmReqType)
1394:../uvc.c      ****     {
1395:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1396:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1397:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1398:../uvc.c      ****             switch (wIndex & 0xFF)
1399:../uvc.c      ****             {
1400:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1401:../uvc.c      ****                     {
1402:../uvc.c      ****                         uvcHandleReq = CyTrue;
1403:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1404:../uvc.c      ****                                 CYU3P_EVENT_OR);
1405:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1406:../uvc.c      ****                         {
1407:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1408:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1409:../uvc.c      ****                         }
1410:../uvc.c      ****                     }
1411:../uvc.c      ****                     break;
1412:../uvc.c      **** 
1413:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1414:../uvc.c      ****                     {
1415:../uvc.c      ****                         uvcHandleReq = CyTrue;
1416:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1417:../uvc.c      ****                                 CYU3P_EVENT_OR);
1418:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1419:../uvc.c      ****                         {
1420:../uvc.c      ****                             /* Error handling */
1421:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1422:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1423:../uvc.c      ****                         }
1424:../uvc.c      ****                     }
1425:../uvc.c      ****                     break;
1426:../uvc.c      **** 
1427:../uvc.c      ****                 default:
1428:../uvc.c      ****                     break;
1429:../uvc.c      ****             }
1430:../uvc.c      ****             break;
1431:../uvc.c      **** 
1432:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1433:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1434:../uvc.c      ****             {
1435:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1436:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1437:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1438:../uvc.c      ****                 {
1439:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1440:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1441:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1442:../uvc.c      ****                     gpif_initialized = 0;
1443:../uvc.c      ****                     streamingStarted = CyFalse;
1444:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1445:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1446:../uvc.c      ****                     CyU3PBusyWait (100);
1447:../uvc.c      **** 
1448:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1449:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1450:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1451:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1452:../uvc.c      ****                     CyU3PBusyWait (100);
1453:../uvc.c      **** 
1454:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1455:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1456:../uvc.c      ****                     uvcHandleReq = CyTrue;
1457:../uvc.c      ****                     /* Complete Control request handshake */
1458:../uvc.c      ****                     CyU3PUsbAckSetup ();
1459:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1460:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1461:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1462:../uvc.c      **** 
1463:../uvc.c      ****                 }
1464:../uvc.c      ****             }
1465:../uvc.c      ****             break;
1466:../uvc.c      **** 
1467:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1468:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1469:../uvc.c      ****             {
1470:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1471:../uvc.c      ****                 {
1472:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1473:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1474:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1475:../uvc.c      ****                 	 * has started. */
1476:../uvc.c      ****                     if (streamingStarted == CyTrue)
1477:../uvc.c      ****                     {
1478:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1479:../uvc.c      **** 
1480:../uvc.c      ****                         /* Disable the GPIF state machine. */
1481:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1482:../uvc.c      ****                         gpif_initialized = 0;
1483:../uvc.c      ****                         streamingStarted = CyFalse;
1484:../uvc.c      **** 
1485:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1486:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1487:../uvc.c      ****                         CyU3PBusyWait (100);
1488:../uvc.c      **** 
1489:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1490:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1491:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1492:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1493:../uvc.c      ****                         CyU3PBusyWait (100);
1494:../uvc.c      **** 
1495:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1496:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1497:../uvc.c      **** 
1498:../uvc.c      ****                         uvcHandleReq = CyTrue;
1499:../uvc.c      ****                         /* Complete Control request handshake */
1500:../uvc.c      ****                         CyU3PUsbAckSetup ();
1501:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1502:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1503:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1504:../uvc.c      ****                     }
1505:../uvc.c      ****                     else
1506:../uvc.c      ****                     {
1507:../uvc.c      ****                         uvcHandleReq = CyTrue;
1508:../uvc.c      ****                         CyU3PUsbAckSetup ();
1509:../uvc.c      ****                     }
1510:../uvc.c      ****                 }
1511:../uvc.c      ****             }
1512:../uvc.c      ****             break;
1513:../uvc.c      **** 
1514:../uvc.c      ****         default:
1515:../uvc.c      ****             break;
1516:../uvc.c      ****     }
1517:../uvc.c      **** 
1518:../uvc.c      ****     /* Return status of request handling to the USB driver */
1519:../uvc.c      ****     return uvcHandleReq;
1520:../uvc.c      **** }
1521:../uvc.c      **** 
1522:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1523:../uvc.c      **** 
1524:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1525:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1526:../uvc.c      ****  */
1527:../uvc.c      **** void
1528:../uvc.c      **** CyFxUvcApplnDmaCallback (
1529:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1530:../uvc.c      ****         CyU3PDmaCbType_t      type,
1531:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1532:../uvc.c      ****         )
1533:../uvc.c      **** {
1534:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1535:../uvc.c      **** #if 1
1536:../uvc.c      ****     CyU3PReturnStatus_t status;
1537:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1538:../uvc.c      ****     {
1539:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1540:../uvc.c      ****             {
1541:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1542:../uvc.c      ****                 fb++;
1543:../uvc.c      ****             }
1544:../uvc.c      ****             else
1545:../uvc.c      ****             {
1546:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1547:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1548:../uvc.c      ****                 pb++;
1549:../uvc.c      ****                 pbc = input->buffer_p.count;
1550:../uvc.c      ****                // hitFV = CyTrue;
1551:../uvc.c      **** #if 1   //remove the still flag clearing here
1552:../uvc.c      ****                 if(stiflag == 0x0F){
1553:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1554:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1555:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1556:../uvc.c      ****                 	stiflag = 0xAA;
1557:../uvc.c      ****                 }
1558:../uvc.c      **** #endif
1559:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1560:../uvc.c      ****             }
1561:../uvc.c      **** 
1562:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1563:../uvc.c      ****             prodCount++;
1564:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1565:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1566:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1567:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1568:../uvc.c      ****             {
1569:../uvc.c      ****                 prodCount--;
1570:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1571:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1572:../uvc.c      ****             }
1573:../uvc.c      ****     }
1574:../uvc.c      **** #endif
1575:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1576:../uvc.c      ****     {
1577:../uvc.c      ****         consCount++;
1578:../uvc.c      ****         streamingStarted = CyTrue;
1579:../uvc.c      ****     }
1580:../uvc.c      **** }
1581:../uvc.c      **** 
1582:../uvc.c      **** /*
1583:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1584:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1585:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1586:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1587:../uvc.c      ****  * to commit the buffer.
1588:../uvc.c      ****  */
1589:../uvc.c      **** static uint8_t
1590:../uvc.c      **** CyFxUvcAppCommitEOF (
1591:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1592:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1593:../uvc.c      ****         )
1594:../uvc.c      **** {
1595:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1596:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1597:../uvc.c      **** 
1598:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1599:../uvc.c      **** 
1600:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1601:../uvc.c      ****     {
1602:../uvc.c      ****         switch (stateId)
1603:../uvc.c      ****         {
1604:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1605:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1606:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1607:../uvc.c      ****                 break;
1608:../uvc.c      **** 
1609:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1610:../uvc.c      ****                 socket = 0;
1611:../uvc.c      ****                 break;
1612:../uvc.c      **** 
1613:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1614:../uvc.c      ****                 socket = 1;
1615:../uvc.c      ****                 break;
1616:../uvc.c      **** 
1617:../uvc.c      ****             default:
1618:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1619:../uvc.c      ****                 /* Unexpected current state. Return error. */
1620:../uvc.c      ****                 return 1;
1621:../uvc.c      ****         }
1622:../uvc.c      ****     }
1623:../uvc.c      **** 
1624:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1625:../uvc.c      ****     {
1626:../uvc.c      ****         switch (stateId)
1627:../uvc.c      ****         {
1628:../uvc.c      **** #ifndef CAM720
1629:../uvc.c      **** #ifdef GPIFIIM
1630:../uvc.c      ****             case 13:
1631:../uvc.c      ****             case 24:
1632:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1633:../uvc.c      ****                 break;
1634:../uvc.c      **** 
1635:../uvc.c      ****             case 8:
1636:../uvc.c      ****                 socket = 0;
1637:../uvc.c      ****                 break;
1638:../uvc.c      **** 
1639:../uvc.c      ****             case 20:
1640:../uvc.c      ****                 socket = 1;
1641:../uvc.c      ****                 break;
1642:../uvc.c      **** #else
1643:../uvc.c      ****             case 11:
1644:../uvc.c      ****             case 18:
1645:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1646:../uvc.c      ****                 break;
1647:../uvc.c      **** 
1648:../uvc.c      ****             case 8:
1649:../uvc.c      ****                 socket = 0;
1650:../uvc.c      ****                 break;
1651:../uvc.c      **** 
1652:../uvc.c      ****             case 15:
1653:../uvc.c      ****                 socket = 1;
1654:../uvc.c      ****                 break;
1655:../uvc.c      **** #endif
1656:../uvc.c      **** #else
1657:../uvc.c      ****             case 11:
1658:../uvc.c      ****             case 18:
1659:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1660:../uvc.c      ****                 break;
1661:../uvc.c      **** 
1662:../uvc.c      ****             case 8:
1663:../uvc.c      ****                 socket = 0;
1664:../uvc.c      ****                 break;
1665:../uvc.c      **** 
1666:../uvc.c      ****             case 15:
1667:../uvc.c      ****                 socket = 1;
1668:../uvc.c      ****                 break;
1669:../uvc.c      **** 
1670:../uvc.c      **** #endif
1671:../uvc.c      ****              default:
1672:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1673:../uvc.c      ****                 /* Unexpected current state. Return error. */
1674:../uvc.c      ****                return 1;
1675:../uvc.c      ****         }
1676:../uvc.c      ****     }
1677:../uvc.c      **** 
1678:../uvc.c      ****     if (socket != 0xFF)
1679:../uvc.c      ****     {
1680:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1681:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1682:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1683:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1684:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1685:../uvc.c      ****         {
1686:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1687:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1688:../uvc.c      ****         }
1689:../uvc.c      ****     }
1690:../uvc.c      **** 
1691:../uvc.c      ****     return 0;
1692:../uvc.c      **** }
1693:../uvc.c      **** 
1694:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1695:../uvc.c      **** void
1696:../uvc.c      **** CyFxGpifCB (
1697:../uvc.c      ****         CyU3PGpifEventType event,
1698:../uvc.c      ****         uint8_t currentState
1699:../uvc.c      ****         )
1700:../uvc.c      **** {
1701:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1702:../uvc.c      ****     {
1703:../uvc.c      ****         //hitFV = CyTrue;
1704:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1705:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1706:../uvc.c      ****     }
1707:../uvc.c      **** }
1708:../uvc.c      **** 
1709:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1710:../uvc.c      **** static void
1711:../uvc.c      **** CyFxUVCApplnDebugInit (
1712:../uvc.c      ****         void)
1713:../uvc.c      **** {
1714:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1715:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1716:../uvc.c      **** 
1717:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1718:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1719:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1720:../uvc.c      ****     {
1721:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1722:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1723:../uvc.c      ****     }
1724:../uvc.c      **** 
1725:../uvc.c      ****     /* Set UART Configuration */
1726:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1727:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1728:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1729:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1730:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1731:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1732:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1733:../uvc.c      **** 
1734:../uvc.c      ****     /* Set the UART configuration */
1735:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1736:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1737:../uvc.c      ****     {
1738:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1739:../uvc.c      ****     }
1740:../uvc.c      **** 
1741:../uvc.c      ****     /* Set the UART transfer */
1742:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1743:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1744:../uvc.c      ****     {
1745:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1746:../uvc.c      ****     }
1747:../uvc.c      **** 
1748:../uvc.c      ****     /* Initialize the Debug logger module. */
1749:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1750:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1751:../uvc.c      ****     {
1752:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1753:../uvc.c      ****     }
1754:../uvc.c      **** 
1755:../uvc.c      ****     /* Disable log message headers. */
1756:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1757:../uvc.c      **** }
1758:../uvc.c      **** 
1759:../uvc.c      **** /* I2C initialization. */
1760:../uvc.c      **** //static void
1761:../uvc.c      **** void
1762:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1763:../uvc.c      **** {
1764:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1765:../uvc.c      ****     CyU3PReturnStatus_t status;
1766:../uvc.c      **** 
1767:../uvc.c      ****     status = CyU3PI2cInit ();
1768:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1769:../uvc.c      ****     {
1770:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1771:../uvc.c      ****         CyFxAppErrorHandler (status);
1772:../uvc.c      ****     }
1773:../uvc.c      **** 
1774:../uvc.c      ****     /*  Set I2C Configuration */
1775:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1776:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1777:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1778:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1779:../uvc.c      **** 
1780:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1781:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1782:../uvc.c      ****     {
1783:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1784:../uvc.c      ****         CyFxAppErrorHandler (status);
1785:../uvc.c      ****     }
1786:../uvc.c      **** }
1787:../uvc.c      **** 
1788:../uvc.c      **** #ifdef BACKFLOW_DETECT
1789:../uvc.c      **** static void CyFxUvcAppPibCallback (
1790:../uvc.c      ****         CyU3PPibIntrType cbType,
1791:../uvc.c      ****         uint16_t cbArg)
1792:../uvc.c      **** {
1793:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1794:../uvc.c      ****     {
1795:../uvc.c      ****         if (!back_flow_detected)
1796:../uvc.c      ****         {
1797:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1798:../uvc.c      ****             back_flow_detected = 1;
1799:../uvc.c      ****         }
1800:../uvc.c      ****     }
1801:../uvc.c      **** }
1802:../uvc.c      **** #endif
1803:../uvc.c      **** 
1804:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1805:../uvc.c      **** static void
1806:../uvc.c      **** CyFxUvcAppDebugCallback (
1807:../uvc.c      ****         CyU3PDmaChannel   *handle,
1808:../uvc.c      ****         CyU3PDmaCbType_t   type,
1809:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1810:../uvc.c      **** {
1811:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1812:../uvc.c      ****     {
1813:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1814:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1815:../uvc.c      ****     }
1816:../uvc.c      **** }
1817:../uvc.c      **** #endif
1818:../uvc.c      **** 
1819:../uvc.c      **** #if 0
1820:../uvc.c      **** static void CyFxAppIntEpCb(
1821:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1822:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1823:../uvc.c      **** 		uint8_t  ebNum)
1824:../uvc.c      **** 		{
1825:../uvc.c      **** 			//CyBool_t value;
1826:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1827:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1828:../uvc.c      **** 
1829:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1830:../uvc.c      **** 		}
1831:../uvc.c      **** #endif
1832:../uvc.c      **** 
1833:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1834:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1835:../uvc.c      ****    configures the DMA module for the UVC Application */
1836:../uvc.c      **** static void
1837:../uvc.c      **** CyFxUVCApplnInit (void)
1838:../uvc.c      **** {
1839:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1840:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1841:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1842:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1843:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1844:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1845:../uvc.c      **** 
1846:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1847:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1848:../uvc.c      **** 
1849:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1850:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1851:../uvc.c      **** #endif
1852:../uvc.c      **** 
1853:../uvc.c      ****     /* Create UVC event group */
1854:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1855:../uvc.c      ****     if (apiRetStatus != 0)
1856:../uvc.c      ****     {
1857:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1858:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1859:../uvc.c      ****     }
1860:../uvc.c      **** 
1861:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1862:../uvc.c      ****     CyFxUvcAppPTZInit ();
1863:../uvc.c      **** #endif
1864:../uvc.c      **** 
1865:../uvc.c      ****     isUsbConnected = CyFalse;
1866:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1867:../uvc.c      **** 
1868:../uvc.c      ****     /* Init the GPIO module */
1869:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1870:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1871:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1872:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1873:../uvc.c      ****     gpioClock.halfDiv    = 0;
1874:../uvc.c      **** 
1875:../uvc.c      ****     /* Initialize Gpio interface */
1876:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1877:../uvc.c      ****     if (apiRetStatus != 0)
1878:../uvc.c      ****     {
1879:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1880:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1881:../uvc.c      ****     }
1882:../uvc.c      **** 
1883:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1884:../uvc.c      ****      * must use GpioOverride to configure it */
1885:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1886:../uvc.c      ****     if (apiRetStatus != 0)
1887:../uvc.c      ****     {
1888:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1889:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1890:../uvc.c      ****     }
1891:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1892:../uvc.c      ****     if (apiRetStatus != 0)
1893:../uvc.c      ****     {
1894:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1895:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1896:../uvc.c      ****     }
1897:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1898:../uvc.c      ****     if (apiRetStatus != 0)
1899:../uvc.c      ****     {
1900:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1901:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1902:../uvc.c      ****     }
1903:../uvc.c      **** 
1904:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1905:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1906:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1907:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1908:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1909:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1910:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1911:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1912:../uvc.c      ****     {
1913:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1914:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1915:../uvc.c      ****     }
1916:../uvc.c      **** 
1917:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1918:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1919:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1920:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1921:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1922:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1923:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1924:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1925:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1926:../uvc.c      ****     {
1927:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1928:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1929:../uvc.c      ****     }
1930:../uvc.c      **** 
1931:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1932:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1933:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1934:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1935:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1936:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1937:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1938:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1939:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1940:../uvc.c      ****     {
1941:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1942:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1943:../uvc.c      ****     }
1944:../uvc.c      **** 
1945:../uvc.c      ****     /* Initialize the P-port. */
1946:../uvc.c      ****     pibclock.clkDiv      = 2;
1947:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1948:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1949:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1950:../uvc.c      **** 
1951:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1952:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1953:../uvc.c      ****     {
1954:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1955:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1956:../uvc.c      ****     }
1957:../uvc.c      **** 
1958:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1959:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1960:../uvc.c      **** 
1961:../uvc.c      **** #ifdef BACKFLOW_DETECT
1962:../uvc.c      ****     back_flow_detected = 0;
1963:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1964:../uvc.c      **** #endif
1965:../uvc.c      **** 
1966:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1967:../uvc.c      ****     SensorReset ();
1968:../uvc.c      ****     SensorInit ();
1969:../uvc.c      **** 
1970:../uvc.c      ****     /* USB initialization. */
1971:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1972:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1973:../uvc.c      ****     {
1974:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1975:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1976:../uvc.c      ****     }
1977:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1978:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1979:../uvc.c      **** 
1980:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1981:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1982:../uvc.c      **** 
1983:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1984:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1985:../uvc.c      **** 
1986:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1987:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1988:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1989:../uvc.c      **** 
1990:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1991:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1992:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1993:../uvc.c      **** 
1994:../uvc.c      ****     /* Configuration descriptors. */
1995:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1996:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1997:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1998:../uvc.c      **** 
1999:../uvc.c      ****     /* String Descriptors */
2000:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2001:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2002:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2003:../uvc.c      **** 
2004:../uvc.c      ****     /* Configure the status interrupt endpoint.
2005:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2006:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2007:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2008:../uvc.c      ****      */
2009:../uvc.c      ****     endPointConfig.enable   = 1;
2010:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2011:../uvc.c      ****     endPointConfig.pcktSize = 64;
2012:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2013:../uvc.c      ****     endPointConfig.streams  = 0;
2014:../uvc.c      ****     endPointConfig.burstLen = 1;
2015:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2016:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2017:../uvc.c      ****     {
2018:../uvc.c      ****         /* Error Handling */
2019:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2020:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2021:../uvc.c      ****     }
2022:../uvc.c      **** 
2023:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2024:../uvc.c      ****     dmaInterConfig.size           = 1024;
2025:../uvc.c      ****     dmaInterConfig.count          = 1;
2026:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2027:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2028:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2029:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2030:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2031:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2032:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2033:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2034:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2035:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2036:../uvc.c      ****             &dmaInterConfig);
2037:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2038:../uvc.c      ****     {
2039:../uvc.c      ****         /* Error handling */
2040:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2041:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2042:../uvc.c      ****     }
2043:../uvc.c      **** 
2044:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2045:../uvc.c      ****     if (glInterStaBuffer == 0)
2046:../uvc.c      ****     {
2047:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2048:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2049:../uvc.c      ****     }
2050:../uvc.c      **** 
2051:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2052:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2053:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2054:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2055:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2056:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2057:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2058:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2059:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2060:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2061:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2062:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2063:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2064:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2065:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2066:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2067:../uvc.c      ****             &dmaMultiConfig);
2068:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2069:../uvc.c      ****     {
2070:../uvc.c      ****         /* Error handling */
2071:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2072:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2073:../uvc.c      ****     }
2074:../uvc.c      **** 
2075:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2076:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2077:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2078:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2079:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2080:../uvc.c      ****      */
2081:../uvc.c      **** 
2082:../uvc.c      ****     endPointConfig.enable   = 1;
2083:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2084:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2085:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2086:../uvc.c      ****     endPointConfig.streams  = 0;
2087:../uvc.c      ****     endPointConfig.burstLen = 1;
2088:../uvc.c      **** 
2089:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2090:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2091:../uvc.c      ****     {
2092:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2093:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2094:../uvc.c      ****     }
2095:../uvc.c      **** 
2096:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2097:../uvc.c      **** 
2098:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2099:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2100:../uvc.c      ****     {
2101:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2102:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2103:../uvc.c      ****     }
2104:../uvc.c      **** 
2105:../uvc.c      ****     channelConfig.size           = 1024;
2106:../uvc.c      ****     channelConfig.count          = 1;
2107:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2108:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2109:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2110:../uvc.c      ****     channelConfig.prodHeader     = 0;
2111:../uvc.c      ****     channelConfig.prodFooter     = 0;
2112:../uvc.c      ****     channelConfig.consHeader     = 0;
2113:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2114:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2115:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2116:../uvc.c      **** 
2117:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2118:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2119:../uvc.c      ****     {
2120:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2121:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2122:../uvc.c      ****     }
2123:../uvc.c      **** 
2124:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2125:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2126:../uvc.c      ****     {
2127:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2128:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2129:../uvc.c      ****     }
2130:../uvc.c      **** 
2131:../uvc.c      ****     channelConfig.size           = 1024;
2132:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2133:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2134:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2135:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2136:../uvc.c      ****     channelConfig.prodHeader     = 0;
2137:../uvc.c      ****     channelConfig.prodFooter     = 0;
2138:../uvc.c      ****     channelConfig.consHeader     = 0;
2139:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2140:../uvc.c      ****     channelConfig.notification   = 0;
2141:../uvc.c      ****     channelConfig.cb             = 0;
2142:../uvc.c      **** 
2143:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2144:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2145:../uvc.c      ****     {
2146:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2147:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2148:../uvc.c      ****     }
2149:../uvc.c      **** 
2150:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2151:../uvc.c      ****     if (glDebugRspBuffer == 0)
2152:../uvc.c      ****     {
2153:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2154:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2155:../uvc.c      ****     }
2156:../uvc.c      **** #endif
2157:../uvc.c      **** 
2158:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2159:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2160:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2161:../uvc.c      ****     {
2162:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2163:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2164:../uvc.c      ****     }
2165:../uvc.c      **** 
2166:../uvc.c      ****     CyU3PBusyWait(100);
2167:../uvc.c      **** 
2168:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2169:../uvc.c      **** 
2170:../uvc.c      ****     endPointConfig.enable   = 1;
2171:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2172:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2173:../uvc.c      ****     {
2174:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2175:../uvc.c      ****     	endPointConfig.burstLen = 16;
2176:../uvc.c      ****     }
2177:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2178:../uvc.c      ****     {
2179:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2180:../uvc.c      ****     	endPointConfig.burstLen = 1;
2181:../uvc.c      ****     }
2182:../uvc.c      ****     endPointConfig.streams  = 0;
2183:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2184:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2185:../uvc.c      ****     {
2186:../uvc.c      ****         /* Error Handling */
2187:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2188:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2189:../uvc.c      ****     }
2190:../uvc.c      **** #if 0    //for still image method 3 using
2191:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2192:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2193:../uvc.c      ****     {
2194:../uvc.c      ****         /* Error Handling */
2195:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2196:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2197:../uvc.c      ****     }
2198:../uvc.c      **** #endif
2199:../uvc.c      **** 
2200:../uvc.c      **** }
2201:../uvc.c      **** 
2202:../uvc.c      **** /*
2203:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2204:../uvc.c      ****  * streaming session is started.
2205:../uvc.c      ****  */
2206:../uvc.c      **** static void
2207:../uvc.c      **** CyFxUvcAppGpifInit (
2208:../uvc.c      ****         void)
2209:../uvc.c      **** {
2210:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2211:../uvc.c      **** 
2212:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2213:../uvc.c      ****     {
2214:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2215:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2216:../uvc.c      ****     }
2217:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2218:../uvc.c      ****     {
2219:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2220:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2221:../uvc.c      ****     }
2222:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2223:../uvc.c      ****     {
2224:../uvc.c      ****         /* Error Handling */
2225:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2226:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2227:../uvc.c      ****     }
2228:../uvc.c      **** 
2229:../uvc.c      ****     /* Start the state machine from the designated start state. */
2230:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2231:../uvc.c      ****     {
2232:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2233:../uvc.c      ****     }
2234:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2235:../uvc.c      ****     {
2236:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2237:../uvc.c      ****     }
2238:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2239:../uvc.c      ****     {
2240:../uvc.c      ****         /* Error Handling */
2241:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2242:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2243:../uvc.c      ****     }
2244:../uvc.c      **** }
2245:../uvc.c      **** 
2246:../uvc.c      **** /*
2247:../uvc.c      ****  * Entry function for the UVC Application Thread
2248:../uvc.c      ****  */
2249:../uvc.c      **** 
2250:../uvc.c      **** uint32_t posTick;
2251:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2252:../uvc.c      **** 
2253:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 2253 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              		@ link register save eliminated.
  27              	.LVL0:
2254:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2255:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  28              		.loc 1 2255 0
  29 0000 08009FE5 		ldr	r0, .L2
  30              	.LVL1:
  31 0004 2010A0E3 		mov	r1, #32
  32 0008 0020A0E3 		mov	r2, #0
  33 000c FEFFFFEA 		b	_txe_event_flags_set
  34              	.LVL2:
  35              	.L3:
  36              		.align	2
  37              	.L2:
  38 0010 00000000 		.word	.LANCHOR0
  39              		.cfi_endproc
  40              	.LFE17:
  42              		.align	2
  43              		.global	I2cAppThread_Entry
  45              	I2cAppThread_Entry:
  46              	.LFB25:
2256:../uvc.c      **** }
2257:../uvc.c      **** 
2258:../uvc.c      **** 
2259:../uvc.c      **** void
2260:../uvc.c      **** UVCAppThread_Entry (
2261:../uvc.c      ****         uint32_t input)
2262:../uvc.c      **** {
2263:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2264:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2265:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2266:../uvc.c      ****     uint8_t i = 0;
2267:../uvc.c      ****     uint32_t flag;
2268:../uvc.c      ****     uint32_t prinflag = 0;
2269:../uvc.c      **** static uint8_t IMcount = 0;
2270:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2271:../uvc.c      ****     uint32_t frameCnt = 0;
2272:../uvc.c      **** #endif
2273:../uvc.c      ****     /* Initialize the Uart Debug Module */
2274:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2275:../uvc.c      **** 
2276:../uvc.c      ****     /* Initialize the I2C interface */
2277:../uvc.c      **** 	while (i++ < 6){
2278:../uvc.c      **** 		CyU3PThreadSleep(500);
2279:../uvc.c      **** 	}
2280:../uvc.c      **** 
2281:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2282:../uvc.c      **** 
2283:../uvc.c      ****     /* Initialize the UVC Application */
2284:../uvc.c      ****     CyFxUVCApplnInit ();
2285:../uvc.c      **** 
2286:../uvc.c      ****     /*
2287:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2288:../uvc.c      **** 
2289:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2290:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2291:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2292:../uvc.c      **** 
2293:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2294:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2295:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2296:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2297:../uvc.c      **** 
2298:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2299:../uvc.c      ****        of handling the abort request.
2300:../uvc.c      ****      */
2301:../uvc.c      **** 
2302:../uvc.c      ****     for (;;)
2303:../uvc.c      ****     {
2304:../uvc.c      ****         /* Waiting for the Video Stream Event */
2305:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2306:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2307:../uvc.c      ****         {
2308:../uvc.c      **** #if 0 //test for new firmware no video bring up
2309:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2310:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2311:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2312:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2313:../uvc.c      ****             {
2314:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2315:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2316:../uvc.c      ****                 {
2317:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2318:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2319:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2320:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2321:../uvc.c      **** #endif
2322:../uvc.c      **** #endif
2323:../uvc.c      ****                     }
2324:../uvc.c      ****                 else
2325:../uvc.c      ****                 {
2326:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2327:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2328:../uvc.c      **** #ifdef USB_LOWRES_IMG
2329:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2330:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2331:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2332:../uvc.c      **** #endif
2333:../uvc.c      **** #endif
2334:../uvc.c      ****                 }
2335:../uvc.c      **** 
2336:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2337:../uvc.c      ****                 prodCount++;
2338:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2339:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2340:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2341:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2342:../uvc.c      ****                 {
2343:../uvc.c      ****                     prodCount--;
2344:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2345:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2346:../uvc.c      ****                 }
2347:../uvc.c      ****             }
2348:../uvc.c      **** #endif
2349:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2350:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2351:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2352:../uvc.c      ****             {
2353:../uvc.c      ****             	if(0&&(prinflag == 0)){
2354:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2355:../uvc.c      ****             		prinflag = 1;
2356:../uvc.c      ****             	}
2357:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2358:../uvc.c      ****             	fb=0;
2359:../uvc.c      ****             	pb=0;
2360:../uvc.c      ****             	pbc=0;
2361:../uvc.c      ****                 prodCount = 0;
2362:../uvc.c      ****                 consCount = 0;
2363:../uvc.c      ****                 hitFV     = CyFalse;
2364:../uvc.c      **** 
2365:../uvc.c      **** #ifdef BACKFLOW_DETECT
2366:../uvc.c      ****                 back_flow_detected = 0;
2367:../uvc.c      **** #endif
2368:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2369:../uvc.c      ****                 frameCnt++;
2370:../uvc.c      **** #endif
2371:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2372:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2373:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2374:../uvc.c      ****                 //}
2375:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2376:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2377:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2378:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2379:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2380:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2381:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2382:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2383:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2384:../uvc.c      ****                 		stiflag = 0xFF;
2385:../uvc.c      ****                 		IMcount = 0;
2386:../uvc.c      ****                 	}
2387:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2388:../uvc.c      **** 
2389:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2390:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2391:../uvc.c      ****                 		stiflag = 0x0F;
2392:../uvc.c      ****                 		IMcount = 0;
2393:../uvc.c      ****                 		}
2394:../uvc.c      ****                  		/*if(IMcount > 0x4){
2395:../uvc.c      ****                 			stiflag = 0x0F;
2396:../uvc.c      ****                 			IMcount = 0;
2397:../uvc.c      ****                 		}*/
2398:../uvc.c      **** 
2399:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2400:../uvc.c      ****                     //CyU3PThreadSleep(400);
2401:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2402:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2403:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2404:../uvc.c      **** 
2405:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2406:../uvc.c      ****                 	{
2407:../uvc.c      ****                     switch (setRes)
2408:../uvc.c      ****                      {
2409:../uvc.c      ****                  	case 1: //960
2410:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2411:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2412:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0xb, 0x0);
2413:../uvc.c      ****                  		break;
2414:../uvc.c      ****                  	case 2: //720
2415:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2416:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2417:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0x0b, 0x1);
2418:../uvc.c      ****                  		break;
2419:../uvc.c      ****                  	default:
2420:../uvc.c      ****                  		break;
2421:../uvc.c      ****                      }
2422:../uvc.c      ****                     IMcount = 0;
2423:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2424:../uvc.c      ****                 	stiflag = 0x0;
2425:../uvc.c      ****                 	}
2426:../uvc.c      ****                 }
2427:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2428:../uvc.c      ****                 /* Reset the DMA channel. */
2429:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2430:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2431:../uvc.c      ****                 {
2432:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2433:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2434:../uvc.c      ****                 }
2435:../uvc.c      **** 
2436:../uvc.c      ****                 /* Start Channel Immediately */
2437:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2438:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2439:../uvc.c      ****                 {
2440:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2441:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2442:../uvc.c      ****                 }
2443:../uvc.c      **** 
2444:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2445:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2446:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2447:../uvc.c      ****                 }
2448:../uvc.c      ****         }
2449:../uvc.c      ****         else
2450:../uvc.c      ****         {
2451:../uvc.c      ****             /* If we have a stream abort request pending. */
2452:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2453:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2454:../uvc.c      ****             {
2455:../uvc.c      ****                 hitFV     = CyFalse;
2456:../uvc.c      ****                 prodCount = 0;
2457:../uvc.c      ****                 consCount = 0;
2458:../uvc.c      ****                 if(0&&(prinflag == 0)){
2459:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2460:../uvc.c      ****                 	prinflag = 1;
2461:../uvc.c      ****                 }
2462:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2463:../uvc.c      ****                 fb=0;
2464:../uvc.c      ****                 pb=0;
2465:../uvc.c      ****                 pbc=0;
2466:../uvc.c      **** 
2467:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2468:../uvc.c      ****                 {
2469:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2470:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2471:../uvc.c      ****                     {
2472:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2473:../uvc.c      ****                     }
2474:../uvc.c      **** 
2475:../uvc.c      ****                     /* Flush the Endpoint memory */
2476:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2477:../uvc.c      ****                 }
2478:../uvc.c      **** 
2479:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2480:../uvc.c      ****             }
2481:../uvc.c      ****             else
2482:../uvc.c      ****             {
2483:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2484:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2485:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2486:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2487:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2488:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2489:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2490:../uvc.c      ****                 {
2491:../uvc.c      ****                     /* Error handling */
2492:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2493:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2494:../uvc.c      ****                 }
2495:../uvc.c      **** 
2496:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2497:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2498:../uvc.c      ****                 {
2499:../uvc.c      **** #if 0
2500:../uvc.c      ****                 	//for start up of the AF Lens
2501:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2502:../uvc.c      ****                     CyU3PThreadSleep(500);
2503:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2504:../uvc.c      ****                     CyU3PThreadSleep(500);
2505:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2506:../uvc.c      ****                    	CyU3PThreadSleep(300);
2507:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2508:../uvc.c      ****                     CyU3PThreadSleep(500);
2509:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2510:../uvc.c      ****                     CyU3PThreadSleep(500);
2511:../uvc.c      **** #endif
2512:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2513:../uvc.c      ****                     gpif_initialized = CyTrue;
2514:../uvc.c      ****                     CyU3PThreadSleep(200);
2515:../uvc.c      ****                     
2516:../uvc.c      ****                 }
2517:../uvc.c      ****                 else
2518:../uvc.c      ****                 {
2519:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2520:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2521:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2522:../uvc.c      ****                 }
2523:../uvc.c      ****             }
2524:../uvc.c      ****         }
2525:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2526:../uvc.c      **** 
2527:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2528:../uvc.c      ****         CyU3PThreadRelinquish ();
2529:../uvc.c      ****     }
2530:../uvc.c      **** }
2531:../uvc.c      **** 
2532:../uvc.c      **** /*
2533:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2534:../uvc.c      ****  */
2535:../uvc.c      **** 
2536:../uvc.c      **** static void
2537:../uvc.c      **** UVCHandleProcessingUnitRqts (
2538:../uvc.c      ****         void)
2539:../uvc.c      **** {
2540:../uvc.c      ****     uint8_t CtrlAdd;
2541:../uvc.c      **** #ifdef DbgInfo
2542:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2543:../uvc.c      **** #endif
2544:../uvc.c      ****     switch (wValue)
2545:../uvc.c      ****     {
2546:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2547:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2548:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2549:../uvc.c      ****     		break;
2550:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2551:../uvc.c      ****         	CtrlAdd = CtrlParArry[ExtExRefCtlID10/*BrgtCtlID1*/][0]; //Exreference places brightness.
2552:../uvc.c      ****    			ControlHandle(ExtExRefCtlID10/*BrgtCtlID1*/);
2553:../uvc.c      ****     		break;
2554:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2555:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2556:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2557:../uvc.c      **** 			break;
2558:../uvc.c      **** 
2559:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2560:../uvc.c      **** 
2561:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2562:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2563:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2564:../uvc.c      ****       		break;
2565:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2566:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2567:../uvc.c      ****      		ControlHandle(HueCtlID5);
2568:../uvc.c      ****      		break;
2569:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2570:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2571:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2572:../uvc.c      ****           		break;
2573:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2574:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2575:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2576:../uvc.c      ****           		break;
2577:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2578:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2579:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2580:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2581:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2582:../uvc.c      ****     		break;
2583:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2584:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2585:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2586:../uvc.c      ****     		break;
2587:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2588:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2589:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2590:../uvc.c      ****     		break;
2591:../uvc.c      **** 
2592:../uvc.c      ****         default:
2593:../uvc.c      ****             /*
2594:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2595:../uvc.c      ****              * other controls.
2596:../uvc.c      ****              */
2597:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2598:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2599:../uvc.c      ****             break;
2600:../uvc.c      ****     }
2601:../uvc.c      **** }
2602:../uvc.c      **** 
2603:../uvc.c      **** /*
2604:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2605:../uvc.c      ****  */
2606:../uvc.c      **** static void
2607:../uvc.c      **** UVCHandleCameraTerminalRqts (
2608:../uvc.c      ****         void)
2609:../uvc.c      **** {
2610:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2611:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2612:../uvc.c      ****     uint16_t readCount;
2613:../uvc.c      ****     uint16_t zoomVal;
2614:../uvc.c      ****     int32_t  panVal, tiltVal;
2615:../uvc.c      ****     CyBool_t sendData = CyFalse;
2616:../uvc.c      **** #endif
2617:../uvc.c      ****     uint8_t CtrlAdd;
2618:../uvc.c      **** 
2619:../uvc.c      ****     switch (wValue)
2620:../uvc.c      ****     {
2621:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2622:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2623:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2624:../uvc.c      ****     		break;
2625:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2626:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2627:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2628:../uvc.c      ****     		break;
2629:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2630:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2631:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2632:../uvc.c      **** 			break;
2633:../uvc.c      **** 
2634:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2635:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2636:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2637:../uvc.c      **** 			break;
2638:../uvc.c      **** 
2639:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2640:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2641:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2642:../uvc.c      ****       		break;
2643:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2644:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2645:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2646:../uvc.c      ****      		break;
2647:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2648:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2649:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2650:../uvc.c      ****           		break;
2651:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2652:../uvc.c      ****           		break;
2653:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2654:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2655:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2656:../uvc.c      ****      		break;
2657:../uvc.c      **** 
2658:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2659:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2660:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2661:../uvc.c      ****     		break;
2662:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2663:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2664:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2665:../uvc.c      ****     		break;
2666:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2667:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2668:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2669:../uvc.c      ****     		break;
2670:../uvc.c      **** 
2671:../uvc.c      ****         default:
2672:../uvc.c      ****             /*
2673:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2674:../uvc.c      ****              * other controls.
2675:../uvc.c      ****              */
2676:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2677:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2678:../uvc.c      ****             break;
2679:../uvc.c      ****     }
2680:../uvc.c      **** 
2681:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2682:../uvc.c      ****     switch (wValue)
2683:../uvc.c      ****     {
2684:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2685:../uvc.c      ****             switch (bRequest)
2686:../uvc.c      ****             {
2687:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2688:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2689:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2690:../uvc.c      ****                     break;
2691:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2692:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2693:../uvc.c      ****                     sendData = CyTrue;
2694:../uvc.c      ****                     break;
2695:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2696:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2697:../uvc.c      ****                     sendData = CyTrue;
2698:../uvc.c      ****                     break;
2699:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2700:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2701:../uvc.c      ****                     sendData = CyTrue;
2702:../uvc.c      ****                     break;
2703:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2704:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2705:../uvc.c      ****                     sendData = CyTrue;
2706:../uvc.c      ****                     break;
2707:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2708:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2709:../uvc.c      ****                     sendData = CyTrue;
2710:../uvc.c      ****                     break;
2711:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2712:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2713:../uvc.c      ****                             glEp0Buffer, &readCount);
2714:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2715:../uvc.c      ****                     {
2716:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2717:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2718:../uvc.c      ****                     }
2719:../uvc.c      ****                     break;
2720:../uvc.c      ****                 default:
2721:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2722:../uvc.c      ****                     break;
2723:../uvc.c      ****             }
2724:../uvc.c      **** 
2725:../uvc.c      ****             if (sendData)
2726:../uvc.c      ****             {
2727:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2728:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2729:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2730:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2731:../uvc.c      ****             }
2732:../uvc.c      ****             break;
2733:../uvc.c      **** 
2734:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2735:../uvc.c      ****             switch (bRequest)
2736:../uvc.c      ****             {
2737:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2738:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2739:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2740:../uvc.c      ****                     break;
2741:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2742:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2743:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2744:../uvc.c      ****                     sendData = CyTrue;
2745:../uvc.c      ****                     break;
2746:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2747:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2748:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2749:../uvc.c      ****                     sendData = CyTrue;
2750:../uvc.c      ****                     break;
2751:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2752:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2753:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2754:../uvc.c      ****                     sendData = CyTrue;
2755:../uvc.c      ****                     break;
2756:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2757:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2758:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2759:../uvc.c      ****                     sendData = CyTrue;
2760:../uvc.c      ****                     break;
2761:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2762:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2763:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2764:../uvc.c      ****                     sendData = CyTrue;
2765:../uvc.c      ****                     break;
2766:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2767:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2768:../uvc.c      ****                             glEp0Buffer, &readCount);
2769:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2770:../uvc.c      ****                     {
2771:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2772:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2773:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2774:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2775:../uvc.c      **** 
2776:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2777:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2778:../uvc.c      ****                     }
2779:../uvc.c      ****                     break;
2780:../uvc.c      ****                 default:
2781:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2782:../uvc.c      ****                     break;
2783:../uvc.c      ****             }
2784:../uvc.c      **** 
2785:../uvc.c      ****             if (sendData)
2786:../uvc.c      ****             {
2787:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2788:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2789:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2790:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2791:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2792:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2793:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2794:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2795:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2796:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2797:../uvc.c      ****             }
2798:../uvc.c      ****             break;
2799:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2800:../uvc.c      ****         default:
2801:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2802:../uvc.c      ****             break;
2803:../uvc.c      ****     }
2804:../uvc.c      **** #endif
2805:../uvc.c      **** }
2806:../uvc.c      **** 
2807:../uvc.c      **** /*
2808:../uvc.c      ****  * Handler for UVC Interface control requests.
2809:../uvc.c      ****  */
2810:../uvc.c      **** static void
2811:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2812:../uvc.c      ****         void)
2813:../uvc.c      **** {
2814:../uvc.c      **** 
2815:../uvc.c      ****     switch (wValue)
2816:../uvc.c      ****     {
2817:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2818:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2819:../uvc.c      ****     		break;
2820:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2821:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2822:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2823:../uvc.c      ****     		break;
2824:../uvc.c      ****     	default:
2825:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2826:../uvc.c      ****      		break;
2827:../uvc.c      ****     }
2828:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2829:../uvc.c      **** 
2830:../uvc.c      **** }
2831:../uvc.c      **** 
2832:../uvc.c      **** /*
2833:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2834:../uvc.c      ****  */
2835:../uvc.c      **** static void
2836:../uvc.c      **** UVCHandleExtensionUnitRqts (
2837:../uvc.c      ****         void)
2838:../uvc.c      **** {
2839:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2840:../uvc.c      **** 
2841:../uvc.c      **** #ifdef DbgInfo
2842:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2843:../uvc.c      **** #endif
2844:../uvc.c      ****     switch (wValue)
2845:../uvc.c      ****     {
2846:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2847:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2848:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2849:../uvc.c      ****     		break;
2850:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2851:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2852:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2853:../uvc.c      ****     		break;
2854:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2855:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2856:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2857:../uvc.c      ****      		break;
2858:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2859:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2860:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2861:../uvc.c      ****     		break;
2862:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2863:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2864:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2865:../uvc.c      ****     		break;
2866:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2867:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2868:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2869:../uvc.c      ****      		break;
2870:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2871:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2872:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2873:../uvc.c      ****     		break;
2874:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2875:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2876:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2877:../uvc.c      ****     		break;
2878:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2879:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2880:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2881:../uvc.c      ****      		break;
2882:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2883:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2884:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2885:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2886:../uvc.c      ****     		}else/* no support for 1080p camera */
2887:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2888:../uvc.c      ****     		break;
2889:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2890:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2891:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2892:../uvc.c      ****     		break;
2893:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2894:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2895:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2896:../uvc.c      ****     		break;
2897:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2898:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2899:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2900:../uvc.c      ****     		//break;
2901:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2902:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2903:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2904:../uvc.c      ****     		break;
2905:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2906:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2907:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2908:../uvc.c      ****     		break;
2909:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2910:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2911:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2912:../uvc.c      ****     		break;
2913:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2914:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2915:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2916:../uvc.c      ****     		break;
2917:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2918:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2919:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2920:../uvc.c      ****     		break;
2921:../uvc.c      ****    	default:
2922:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2923:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2924:../uvc.c      ****     		break;
2925:../uvc.c      ****     }
2926:../uvc.c      **** 
2927:../uvc.c      **** }
2928:../uvc.c      **** 
2929:../uvc.c      **** /*
2930:../uvc.c      ****  * Handler for the video streaming control requests.
2931:../uvc.c      ****  */
2932:../uvc.c      **** static void
2933:../uvc.c      **** UVCHandleVideoStreamingRqts (
2934:../uvc.c      ****         void)
2935:../uvc.c      **** {
2936:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2937:../uvc.c      ****     uint16_t readCount;
2938:../uvc.c      **** 
2939:../uvc.c      ****     switch (wValue)
2940:../uvc.c      ****     {
2941:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2942:../uvc.c      ****             switch (bRequest)
2943:../uvc.c      ****             {
2944:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2945:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2946:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2947:../uvc.c      ****                     break;
2948:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2949:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2950:../uvc.c      ****                     glEp0Buffer[1] = 0;
2951:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2952:../uvc.c      ****                     break;
2953:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2954:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2955:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2956:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2957:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED)//supports both SS and HS
2958:../uvc.c      ****                     {
2959:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2960:../uvc.c      ****                     }
2961:../uvc.c      ****                     else
2962:../uvc.c      ****                     {
2963:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2964:../uvc.c      ****                     }
2965:../uvc.c      ****                     break;
2966:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2967:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2968:../uvc.c      ****                             glCommitCtrl, &readCount);
2969:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2970:../uvc.c      ****                     {
2971:../uvc.c      ****                         //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
2972:../uvc.c      ****                         {
2973:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2974:../uvc.c      ****                                active data structure. */
2975:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2976:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2977:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2978:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2979:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2980:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2981:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d\r\n", readCount
2982:../uvc.c      ****                         }
2983:../uvc.c      ****                     }
2984:../uvc.c      ****                     break;
2985:../uvc.c      ****                 default:
2986:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2987:../uvc.c      ****                     break;
2988:../uvc.c      ****             }
2989:../uvc.c      ****             break;
2990:../uvc.c      **** 
2991:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2992:../uvc.c      ****             switch (bRequest)
2993:../uvc.c      ****             {
2994:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2995:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2996:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2997:../uvc.c      ****                     break;
2998:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2999:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3000:../uvc.c      ****                     glEp0Buffer[1] = 0;
3001:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3002:../uvc.c      ****                     break;
3003:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3004:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED) //support both SS and HS
3005:../uvc.c      ****                     {
3006:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3007:../uvc.c      ****                     }
3008:../uvc.c      ****                     else
3009:../uvc.c      ****                     {
3010:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3011:../uvc.c      ****                     }
3012:../uvc.c      ****                     break;
3013:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3014:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3015:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3016:../uvc.c      ****                        */
3017:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3018:../uvc.c      ****                             glCommitCtrl, &readCount);
3019:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)//supports both SS and HS
3020:../uvc.c      ****                     {
3021:../uvc.c      ****                         switch (glCommitCtrl[3])
3022:../uvc.c      ****                          {
3023:../uvc.c      ****                          	case 1: //960 or 480
3024:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
3025:../uvc.c      ****                          		CyU3PThreadSleep(500);
3026:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
3027:../uvc.c      ****                          		break;
3028:../uvc.c      ****                          	case 2: //720 or 360
3029:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
3030:../uvc.c      ****                          		CyU3PThreadSleep(500);
3031:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
3032:../uvc.c      ****                          		break;
3033:../uvc.c      ****                          	default:
3034:../uvc.c      ****                          		break;
3035:../uvc.c      ****                          }
3036:../uvc.c      ****                         setRes = glCommitCtrl[3];
3037:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3038:../uvc.c      **** 
3039:../uvc.c      **** #if 0
3040:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3041:../uvc.c      ****                         {
3042:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3043:../uvc.c      ****                         }
3044:../uvc.c      ****                         else
3045:../uvc.c      ****                         {
3046:../uvc.c      ****                             SensorScaling_VGA ();
3047:../uvc.c      ****                         }
3048:../uvc.c      **** #endif
3049:../uvc.c      ****                         /* We can start streaming video now. */
3050:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3051:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3052:../uvc.c      ****                         {
3053:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3054:../uvc.c      ****                         }
3055:../uvc.c      ****                     }
3056:../uvc.c      ****                     break;
3057:../uvc.c      **** 
3058:../uvc.c      ****                 default:
3059:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3060:../uvc.c      ****                     break;
3061:../uvc.c      ****             }
3062:../uvc.c      ****             break;
3063:../uvc.c      **** 
3064:../uvc.c      **** /* still image streaming handler */
3065:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3066:../uvc.c      ****                 switch (bRequest)
3067:../uvc.c      ****                 {
3068:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3069:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3070:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3071:../uvc.c      ****                         break;
3072:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3073:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3074:../uvc.c      ****                         glEp0Buffer[1] = 0;
3075:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3076:../uvc.c      ****                         break;
3077:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3078:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3079:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3080:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3081:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3082:../uvc.c      ****                         {
3083:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3084:../uvc.c      ****                         }
3085:../uvc.c      ****                         else
3086:../uvc.c      ****                         {
3087:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3088:../uvc.c      ****                         }
3089:../uvc.c      ****                         break;
3090:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3091:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3092:../uvc.c      ****                                 glCommitCtrl, &readCount);
3093:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3094:../uvc.c      ****                         {
3095:../uvc.c      ****                             //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
3096:../uvc.c      ****                             {
3097:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3098:../uvc.c      ****                                    active data structure. */
3099:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3100:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3101:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3102:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3103:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3104:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3105:../uvc.c      ****                             }
3106:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3107:../uvc.c      ****                         }
3108:../uvc.c      ****                         break;
3109:../uvc.c      ****                     default:
3110:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3111:../uvc.c      ****                         break;
3112:../uvc.c      ****                 }
3113:../uvc.c      ****                 break;
3114:../uvc.c      **** 
3115:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3116:../uvc.c      ****                 switch (bRequest)
3117:../uvc.c      ****                 {
3118:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3119:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3120:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3121:../uvc.c      ****                         break;
3122:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3123:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3124:../uvc.c      ****                         glEp0Buffer[1] = 0;
3125:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3126:../uvc.c      ****                         break;
3127:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3128:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3129:../uvc.c      ****                         {
3130:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3131:../uvc.c      ****                         }
3132:../uvc.c      ****                         else
3133:../uvc.c      ****                         {
3134:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3135:../uvc.c      ****                         }
3136:../uvc.c      ****                         break;
3137:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3138:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3139:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3140:../uvc.c      ****                            */
3141:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3142:../uvc.c      ****                                 glCommitCtrl, &readCount);
3143:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3144:../uvc.c      ****                         {
3145:../uvc.c      ****     #if 0
3146:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3147:../uvc.c      ****                             {
3148:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3149:../uvc.c      ****                             }
3150:../uvc.c      ****                             else
3151:../uvc.c      ****                             {
3152:../uvc.c      ****                                 SensorScaling_VGA ();
3153:../uvc.c      ****                             }
3154:../uvc.c      ****                             /* We can start streaming video now. */
3155:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3156:../uvc.c      **** 
3157:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3158:../uvc.c      ****                             {
3159:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3160:../uvc.c      ****                             }
3161:../uvc.c      **** 	#endif
3162:../uvc.c      ****                            switch (glCommitCtrl[1])
3163:../uvc.c      ****                              {
3164:../uvc.c      ****                              	case 1: //720
3165:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*
3166:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3167:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3168:../uvc.c      ****                              		break;
3169:../uvc.c      ****                             	case 2: //960
3170:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*
3171:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3172:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3173:../uvc.c      ****                              		break;
3174:../uvc.c      ****                               	default:
3175:../uvc.c      ****                              		break;
3176:../uvc.c      ****                              }
3177:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3178:../uvc.c      **** 
3179:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3180:../uvc.c      **** 
3181:../uvc.c      ****                         }
3182:../uvc.c      ****                         break;
3183:../uvc.c      **** 
3184:../uvc.c      ****                     default:
3185:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3186:../uvc.c      ****                         break;
3187:../uvc.c      ****                 }
3188:../uvc.c      ****                 break;
3189:../uvc.c      **** 
3190:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3191:../uvc.c      ****                 switch (bRequest)
3192:../uvc.c      ****                 {
3193:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3194:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3195:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3196:../uvc.c      ****                         break;
3197:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3198:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3199:../uvc.c      ****                         glEp0Buffer[1] = 0;
3200:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3201:../uvc.c      ****                         break;
3202:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3203:../uvc.c      ****                         if (1 || usbSpeed == CY_U3P_SUPER_SPEED)// support both SS and HS
3204:../uvc.c      ****                         {
3205:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3206:../uvc.c      ****                         }
3207:../uvc.c      ****                         else
3208:../uvc.c      ****                         {
3209:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3210:../uvc.c      ****                         }
3211:../uvc.c      ****                         break;
3212:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3213:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3214:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3215:../uvc.c      ****                            */
3216:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3217:../uvc.c      ****                                 glCommitCtrl, &readCount);
3218:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3219:../uvc.c      ****                         {
3220:../uvc.c      ****     #if 1
3221:../uvc.c      ****                             /* We can start still streaming video now. */
3222:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3223:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3224:../uvc.c      ****                             {
3225:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3226:../uvc.c      ****                             }
3227:../uvc.c      ****     #endif
3228:../uvc.c      ****                             else{
3229:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3230:../uvc.c      ****                             //stillcont = 0;
3231:../uvc.c      ****                             }
3232:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3233:../uvc.c      ****                         }else{
3234:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3235:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3236:../uvc.c      ****                         }
3237:../uvc.c      ****                         break;
3238:../uvc.c      **** 
3239:../uvc.c      ****                     default:
3240:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3241:../uvc.c      ****                         break;
3242:../uvc.c      ****                 }
3243:../uvc.c      ****                 break;
3244:../uvc.c      **** 
3245:../uvc.c      ****         default:
3246:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3247:../uvc.c      ****             break;
3248:../uvc.c      ****     }
3249:../uvc.c      **** }
3250:../uvc.c      **** 
3251:../uvc.c      **** /*
3252:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3253:../uvc.c      ****  */
3254:../uvc.c      **** void
3255:../uvc.c      **** UVCAppEP0Thread_Entry (
3256:../uvc.c      ****         uint32_t input)
3257:../uvc.c      **** {
3258:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3259:../uvc.c      ****     uint32_t eventFlag;
3260:../uvc.c      **** 	CyBool_t value;
3261:../uvc.c      **** 	CyBool_t *valueptr = &value;
3262:../uvc.c      **** 
3263:../uvc.c      **** 
3264:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3265:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3266:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3267:../uvc.c      **** 
3268:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3269:../uvc.c      **** #endif
3270:../uvc.c      **** 
3271:../uvc.c      ****     /* for interrupt status test */
3272:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3273:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3274:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3275:../uvc.c      **** 
3276:../uvc.c      ****     for (;;)
3277:../uvc.c      ****     {
3278:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3279:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3280:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3281:../uvc.c      ****         {
3282:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3283:../uvc.c      ****             if (!isUsbConnected)
3284:../uvc.c      ****             {
3285:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3286:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3287:../uvc.c      ****                 {
3288:../uvc.c      ****                     isUsbConnected = CyTrue;
3289:../uvc.c      ****                 }
3290:../uvc.c      ****             }
3291:../uvc.c      **** //#ifdef DbgInfo
3292:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3293:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3294:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3295:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3296:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3297:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3298:../uvc.c      **** //#endif
3299:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3300:../uvc.c      ****             {
3301:../uvc.c      ****             	switch ((wIndex >> 8))
3302:../uvc.c      ****                 {
3303:../uvc.c      **** 
3304:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3305:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3306:../uvc.c      ****                         break;
3307:../uvc.c      **** 
3308:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3309:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3310:../uvc.c      ****                         break;
3311:../uvc.c      **** 
3312:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3313:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3314:../uvc.c      ****                         break;
3315:../uvc.c      **** 
3316:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3317:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3318:../uvc.c      ****                         break;
3319:../uvc.c      **** 
3320:../uvc.c      ****                     default:
3321:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3322:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3323:../uvc.c      ****                         break;
3324:../uvc.c      ****                 }
3325:../uvc.c      ****             }
3326:../uvc.c      **** 
3327:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3328:../uvc.c      ****             {
3329:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3330:../uvc.c      **** 
3331:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3332:../uvc.c      ****                 {
3333:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3334:../uvc.c      ****                 }
3335:../uvc.c      ****                 else
3336:../uvc.c      ****                 {
3337:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3338:../uvc.c      ****                 }
3339:../uvc.c      ****             }
3340:../uvc.c      **** 
3341:../uvc.c      ****             /* handle interrupt status event */
3342:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3343:../uvc.c      ****             {
3344:../uvc.c      **** 
3345:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3346:../uvc.c      ****             	/** preparing interrupt status data **/
3347:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3348:../uvc.c      **** 
3349:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3350:../uvc.c      **** 
3351:../uvc.c      **** #if 1 //for real button
3352:../uvc.c      **** 				if(value&&(!snapButFlag)){
3353:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3354:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3355:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3356:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3357:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3358:../uvc.c      **** 
3359:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3360:../uvc.c      **** 					interStabuf.size   = 1024;
3361:../uvc.c      **** 					interStabuf.status = 0;
3362:../uvc.c      **** 
3363:../uvc.c      **** 					interStabuf.count = 4;
3364:../uvc.c      **** 
3365:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3366:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3367:../uvc.c      **** 
3368:../uvc.c      **** 					/** send a interrupt status data **/
3369:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3370:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3371:../uvc.c      **** 					{
3372:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3373:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3374:../uvc.c      **** 					}
3375:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3376:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3377:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3378:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3379:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3380:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3381:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3382:../uvc.c      **** 
3383:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3384:../uvc.c      **** 					interStabuf.size   = 1024;
3385:../uvc.c      **** 					interStabuf.status = 0;
3386:../uvc.c      **** 
3387:../uvc.c      **** 					interStabuf.count = 4;
3388:../uvc.c      **** 
3389:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3390:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3391:../uvc.c      **** 
3392:../uvc.c      **** 					/** send a interrupt status data **/
3393:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3394:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3395:../uvc.c      **** 					{
3396:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3397:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3398:../uvc.c      **** 					}
3399:../uvc.c      **** 
3400:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3401:../uvc.c      **** 					stiflag = 0xFF;
3402:../uvc.c      **** 				}
3403:../uvc.c      **** #else			//for botton simulation
3404:../uvc.c      **** 				if(snapButFlag == 0x0f){
3405:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3406:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3407:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3408:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3409:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3410:../uvc.c      **** 
3411:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3412:../uvc.c      **** 					interStabuf.size   = 1024;
3413:../uvc.c      **** 					interStabuf.status = 0;
3414:../uvc.c      **** 
3415:../uvc.c      **** 					interStabuf.count = 4;
3416:../uvc.c      **** 
3417:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3418:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3419:../uvc.c      **** 
3420:../uvc.c      **** 					/** send a interrupt status data **/
3421:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3422:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3423:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3424:../uvc.c      **** 					{
3425:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3426:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3427:../uvc.c      **** 					}
3428:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3429:../uvc.c      **** 
3430:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3431:../uvc.c      **** 				}else if(!snapButFlag){
3432:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3433:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3434:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3435:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3436:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3437:../uvc.c      **** 
3438:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3439:../uvc.c      **** 					interStabuf.size   = 1024;
3440:../uvc.c      **** 					interStabuf.status = 0;
3441:../uvc.c      **** 
3442:../uvc.c      **** 					interStabuf.count = 4;
3443:../uvc.c      **** 
3444:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3445:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3446:../uvc.c      **** 
3447:../uvc.c      **** 					/** send a interrupt status data **/
3448:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3449:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3450:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3451:../uvc.c      **** 					{
3452:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3453:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3454:../uvc.c      **** 					}
3455:../uvc.c      **** 
3456:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3457:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3458:../uvc.c      **** 				}
3459:../uvc.c      **** #endif
3460:../uvc.c      **** 
3461:../uvc.c      ****             }
3462:../uvc.c      **** 
3463:../uvc.c      **** 
3464:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3465:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3466:../uvc.c      ****             {
3467:../uvc.c      ****                 /* Get the command buffer */
3468:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3469:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3470:../uvc.c      ****                 {
3471:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3472:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3473:../uvc.c      ****                 }
3474:../uvc.c      **** 
3475:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3476:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3477:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3478:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3479:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3480:../uvc.c      ****                  * register value high byte and register value low byte.
3481:../uvc.c      ****                  */
3482:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3483:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3484:../uvc.c      ****                 {
3485:../uvc.c      ****                     if (dmaInfo.count == 3)
3486:../uvc.c      ****                     {
3487:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3488:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3489:../uvc.c      ****                         dmaInfo.count = 3;
3490:../uvc.c      ****                     }
3491:../uvc.c      ****                     else if (dmaInfo.count == 4)
3492:../uvc.c      ****                     {
3493:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3494:../uvc.c      ****                         {
3495:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3496:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3497:../uvc.c      ****                         }
3498:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3499:../uvc.c      ****                     }
3500:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3501:../uvc.c      ****                 }
3502:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3503:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3504:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3505:../uvc.c      ****                  */
3506:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3507:../uvc.c      ****                 {
3508:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3509:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3510:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3511:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3512:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3513:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3514:../uvc.c      ****                         	break;
3515:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3516:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3517:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3518:../uvc.c      ****                         	break;*/
3519:../uvc.c      ****                     dmaInfo.count -= 2;
3520:../uvc.c      ****                 }
3521:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3522:../uvc.c      ****                 else
3523:../uvc.c      ****                 {
3524:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3525:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3526:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3527:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3528:../uvc.c      ****                 }
3529:../uvc.c      **** 
3530:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3531:../uvc.c      ****                 dmaInfo.size   = 1024;
3532:../uvc.c      ****                 dmaInfo.status = 0;
3533:../uvc.c      **** 
3534:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3535:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3536:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3537:../uvc.c      ****                 {
3538:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3539:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3540:../uvc.c      ****                 }
3541:../uvc.c      **** 
3542:../uvc.c      ****                 /* Wait until the response has gone out. */
3543:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3544:../uvc.c      **** 
3545:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3546:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3547:../uvc.c      ****                 {
3548:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3549:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3550:../uvc.c      ****                 }
3551:../uvc.c      ****             }
3552:../uvc.c      **** #endif
3553:../uvc.c      ****         }
3554:../uvc.c      ****         /* Allow other ready threads to run. */
3555:../uvc.c      ****         CyU3PThreadRelinquish ();
3556:../uvc.c      ****     }
3557:../uvc.c      **** }
3558:../uvc.c      **** 
3559:../uvc.c      **** /*
3560:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3561:../uvc.c      ****  * added 10/2013
3562:../uvc.c      ****  */
3563:../uvc.c      **** /*
3564:../uvc.c      **** static uint8_t timeDelay[64] = {
3565:../uvc.c      **** 
3566:../uvc.c      **** };
3567:../uvc.c      **** */
3568:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  47              		.loc 1 3568 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 8
  50              		@ frame_needed = 0, uses_anonymous_args = 0
  51              	.LVL3:
  52 0014 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
  53              	.LCFI0:
  54              		.cfi_def_cfa_offset 32
  55              		.cfi_offset 4, -32
  56              		.cfi_offset 5, -28
  57              		.cfi_offset 6, -24
  58              		.cfi_offset 7, -20
  59              		.cfi_offset 8, -16
  60              		.cfi_offset 9, -12
  61              		.cfi_offset 10, -8
  62              		.cfi_offset 14, -4
3569:../uvc.c      **** 
3570:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3571:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3572:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3573:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3574:../uvc.c      **** 	VdstateDes *lcStaDes;
3575:../uvc.c      **** 	uint32_t flag = 0;
3576:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3577:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3578:../uvc.c      **** 	uint8_t i;
3579:../uvc.c      **** 	uint16_t delaytime;
3580:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3581:../uvc.c      **** 
3582:../uvc.c      **** #if 0 //for test the command queue
3583:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3584:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3585:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3586:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3587:../uvc.c      **** 		lcCmdDes += 1;
3588:../uvc.c      **** 	}
3589:../uvc.c      **** #endif
3590:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3591:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  63              		.loc 1 3591 0
  64 0018 04029FE5 		ldr	r0, .L26
  65              	.LVL4:
3568:../uvc.c      **** 
  66              		.loc 1 3568 0
  67 001c 18D04DE2 		sub	sp, sp, #24
  68              	.LCFI1:
  69              		.cfi_def_cfa_offset 56
3575:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  70              		.loc 1 3575 0
  71 0020 00C0A0E3 		mov	ip, #0
  72              		.loc 1 3591 0
  73 0024 FA2FA0E3 		mov	r2, #1000
  74 0028 2C30A0E3 		mov	r3, #44
  75 002c 0C10A0E1 		mov	r1, ip
  76 0030 04C08DE5 		str	ip, [sp, #4]
  77 0034 08C08DE5 		str	ip, [sp, #8]
  78 0038 00208DE5 		str	r2, [sp]
  79 003c 0C308DE5 		str	r3, [sp, #12]
  80 0040 E0219FE5 		ldr	r2, .L26+4
  81 0044 0B30A0E3 		mov	r3, #11
3575:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  82              		.loc 1 3575 0
  83 0048 14C08DE5 		str	ip, [sp, #20]
  84              	.LVL5:
  85              		.loc 1 3591 0
  86 004c FEFFFFEB 		bl	_txe_timer_create
  87              	.LVL6:
3592:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  88              		.loc 1 3592 0
  89 0050 FEFFFFEB 		bl	_tx_time_get
  90              	.LVL7:
3593:../uvc.c      **** 	CyU3PThreadSleep(50);
3594:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
3595:../uvc.c      **** 
3596:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  91              		.loc 1 3596 0
  92 0054 D0519FE5 		ldr	r5, .L26+8
3592:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  93              		.loc 1 3592 0
  94 0058 D0119FE5 		ldr	r1, .L26+12
  95 005c 0020A0E1 		mov	r2, r0
  96 0060 0400A0E3 		mov	r0, #4
  97 0064 FEFFFFEB 		bl	CyU3PDebugPrint
  98              	.LVL8:
3593:../uvc.c      **** 	CyU3PThreadSleep(50);
  99              		.loc 1 3593 0
 100 0068 3200A0E3 		mov	r0, #50
 101 006c FEFFFFEB 		bl	_tx_thread_sleep
 102              	.LVL9:
3594:../uvc.c      **** 
 103              		.loc 1 3594 0
 104 0070 AC019FE5 		ldr	r0, .L26
 105 0074 FEFFFFEB 		bl	_txe_timer_activate
 106              	.LVL10:
 107              		.loc 1 3596 0
 108 0078 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 109 007c 000052E3 		cmp	r2, #0
 110 0080 0300001A 		bne	.L5
 111              	.L6:
3597:../uvc.c      ****         /* Allow other ready threads to run. */
3598:../uvc.c      **** 
3599:../uvc.c      ****         CyU3PThreadRelinquish ();
 112              		.loc 1 3599 0
 113 0084 FEFFFFEB 		bl	_txe_thread_relinquish
 114              	.LVL11:
3596:../uvc.c      ****         /* Allow other ready threads to run. */
 115              		.loc 1 3596 0
 116 0088 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 117 008c 000052E3 		cmp	r2, #0
 118 0090 FBFFFF0A 		beq	.L6
 119              	.L5:
3600:../uvc.c      **** 	}
3601:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 120              		.loc 1 3601 0
 121 0094 103095E5 		ldr	r3, [r5, #16]
 122 0098 0400A0E3 		mov	r0, #4
 123 009c 3C3093E5 		ldr	r3, [r3, #60]
 124 00a0 8C119FE5 		ldr	r1, .L26+16
 125 00a4 FEFFFFEB 		bl	CyU3PDebugPrint
 126              	.LVL12:
 127 00a8 88619FE5 		ldr	r6, .L26+20
 128 00ac 88919FE5 		ldr	r9, .L26+24
3602:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3603:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3604:../uvc.c      **** 	//CyU3PThreadSleep(100);
3605:../uvc.c      **** 	//SetCurCmd();
3606:../uvc.c      **** 	/*********** the loop of the thread ***********/
3607:../uvc.c      **** 	for(;;){
3608:../uvc.c      **** 
3609:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 129              		.loc 1 3609 0
 130 00b0 0070E0E3 		mvn	r7, #0
3610:../uvc.c      **** /*  // for test GPIO output
3611:../uvc.c      **** 		if(trigger)
3612:../uvc.c      **** 		{
3613:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3614:../uvc.c      **** 			{
3615:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3616:../uvc.c      **** 			}
3617:../uvc.c      **** 
3618:../uvc.c      **** 		}else{
3619:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3620:../uvc.c      **** 			{
3621:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3622:../uvc.c      **** 			}
3623:../uvc.c      **** 
3624:../uvc.c      **** 		}
3625:../uvc.c      **** */
3626:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3627:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3628:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3629:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3630:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3631:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3632:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3633:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3634:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3635:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3636:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3637:../uvc.c      **** #endif
3638:../uvc.c      **** 				}
3639:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3640:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3641:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3642:../uvc.c      **** 			}
3643:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3644:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3645:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3646:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3647:../uvc.c      **** 
3648:../uvc.c      **** 				/*
3649:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3650:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3651:../uvc.c      **** 				*/
3652:../uvc.c      **** 
3653:../uvc.c      **** 				/* find a available command */
3654:../uvc.c      **** 				i = 0;
3655:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
3656:../uvc.c      **** 					i++;
3657:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3658:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3659:../uvc.c      **** 				}
3660:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3661:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3662:../uvc.c      **** 					i = lcCmdDes->curNum;
3663:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3664:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3665:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3666:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3667:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3668:../uvc.c      **** 						case 0x20:
3669:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3670:../uvc.c      **** 							delaytime = 500;
3671:../uvc.c      **** 							break;
3672:../uvc.c      **** 						case 0x21:
3673:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3674:../uvc.c      **** 							delaytime = 500;
3675:../uvc.c      **** 							break;
3676:../uvc.c      **** 						case 0x22:
3677:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3678:../uvc.c      **** 							delaytime = 300;
3679:../uvc.c      **** 							break;
3680:../uvc.c      **** 						case 0x23:
3681:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3682:../uvc.c      **** 							delaytime = 300;
3683:../uvc.c      **** 							break;
3684:../uvc.c      **** 						default:
3685:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3686:../uvc.c      **** 							break;
3687:../uvc.c      **** 					}
3688:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3689:../uvc.c      **** 					/** timer's ticket modify **/
3690:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 131              		.loc 1 3690 0
 132 00b4 0080A0E3 		mov	r8, #0
 133              	.L21:
3609:../uvc.c      **** /*  // for test GPIO output
 134              		.loc 1 3609 0
 135 00b8 14308DE2 		add	r3, sp, #20
 136 00bc 0320A0E3 		mov	r2, #3
 137 00c0 2010A0E3 		mov	r1, #32
 138 00c4 00708DE5 		str	r7, [sp]
 139 00c8 70019FE5 		ldr	r0, .L26+28
 140 00cc FEFFFFEB 		bl	_txe_event_flags_get
 141              	.LVL13:
3626:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
 142              		.loc 1 3626 0
 143 00d0 0010E0E3 		mvn	r1, #0
 144 00d4 1C0096E5 		ldr	r0, [r6, #28]
 145 00d8 FEFFFFEB 		bl	_txe_mutex_get
 146              	.LVL14:
3643:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
 147              		.loc 1 3643 0
 148 00dc 1C0096E5 		ldr	r0, [r6, #28]
 149 00e0 FEFFFFEB 		bl	_txe_mutex_put
 150              	.LVL15:
3645:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 151              		.loc 1 3645 0
 152 00e4 1C0095E5 		ldr	r0, [r5, #28]
 153 00e8 0010E0E3 		mvn	r1, #0
 154 00ec FEFFFFEB 		bl	_txe_mutex_get
 155              	.LVL16:
3646:../uvc.c      **** 
 156              		.loc 1 3646 0
 157 00f0 104095E5 		ldr	r4, [r5, #16]
 158              	.LVL17:
3655:../uvc.c      **** 					i++;
 159              		.loc 1 3655 0
 160 00f4 3C3094E5 		ldr	r3, [r4, #60]
 161 00f8 000053E3 		cmp	r3, #0
 162 00fc 0900001A 		bne	.L7
 163 0100 4020A0E3 		mov	r2, #64
 164 0104 010000EA 		b	.L10
 165              	.LVL18:
 166              	.L8:
3655:../uvc.c      **** 					i++;
 167              		.loc 1 3655 0 is_stmt 0 discriminator 2
 168 0108 FF2012E2 		ands	r2, r2, #255
 169 010c 2D00000A 		beq	.L24
 170              	.L10:
3657:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
 171              		.loc 1 3657 0 is_stmt 1
 172 0110 344094E5 		ldr	r4, [r4, #52]
 173              	.LVL19:
 174 0114 012042E2 		sub	r2, r2, #1
3655:../uvc.c      **** 					i++;
 175              		.loc 1 3655 0
 176 0118 3C3094E5 		ldr	r3, [r4, #60]
 177 011c 000053E3 		cmp	r3, #0
 178 0120 F8FFFF0A 		beq	.L8
 179 0124 104085E5 		str	r4, [r5, #16]
 180              	.L7:
 181              	.LVL20:
 182 0128 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3667:../uvc.c      **** 						case 0x20:
 183              		.loc 1 3667 0
 184 012c 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 185 0130 833083E0 		add	r3, r3, r3, asl #1
 186 0134 833084E0 		add	r3, r4, r3, asl #1
 187 0138 20C04CE2 		sub	ip, ip, #32
3663:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 188              		.loc 1 3663 0
 189 013c 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 190              	.LVL21:
3664:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 191              		.loc 1 3664 0
 192 0140 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 193              	.LVL22:
3665:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 194              		.loc 1 3665 0
 195 0144 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 196              	.LVL23:
3666:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 197              		.loc 1 3666 0
 198 0148 B8A0D3E1 		ldrh	r10, [r3, #8]
 199              	.LVL24:
3667:../uvc.c      **** 						case 0x20:
 200              		.loc 1 3667 0
 201 014c 03005CE3 		cmp	ip, #3
 202 0150 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 203 0154 2F0000EA 		b	.L16
 204              	.L22:
 205 0158 68010000 		.word	.L13
 206 015c 68010000 		.word	.L13
 207 0160 B8010000 		.word	.L15
 208 0164 B8010000 		.word	.L15
 209              	.L13:
3673:../uvc.c      **** 							delaytime = 500;
 210              		.loc 1 3673 0
 211 0168 5230A0E3 		mov	r3, #82
 212              	.LVL25:
 213 016c FEFFFFEB 		bl	SensorSetIrisControl
 214              	.LVL26:
3675:../uvc.c      **** 						case 0x22:
 215              		.loc 1 3675 0
 216 0170 7D1FA0E3 		mov	r1, #500
 217              	.LVL27:
 218              	.L12:
 219              		.loc 1 3690 0
 220 0174 0020A0E3 		mov	r2, #0
 221 0178 A4009FE5 		ldr	r0, .L26
 222 017c FEFFFFEB 		bl	_txe_timer_change
 223              	.LVL28:
3691:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 224              		.loc 1 3691 0
 225 0180 9C009FE5 		ldr	r0, .L26
 226 0184 FEFFFFEB 		bl	_txe_timer_activate
 227              	.LVL29:
3692:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3693:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3694:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3695:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3696:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3697:../uvc.c      **** #endif
3698:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 228              		.loc 1 3698 0
 229 0188 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 230 018c 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 231 0190 030052E1 		cmp	r2, r3
 232 0194 1200000A 		beq	.L25
3699:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3700:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3701:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3702:../uvc.c      **** 						}else{
3703:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3704:../uvc.c      **** 						}
3705:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3706:../uvc.c      **** 					}else{
3707:../uvc.c      **** 						lcCmdDes->curNum ++;
 233              		.loc 1 3707 0
 234 0198 013083E2 		add	r3, r3, #1
3708:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 235              		.loc 1 3708 0
 236 019c 0F20A0E3 		mov	r2, #15
3707:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 237              		.loc 1 3707 0
 238 01a0 0130C4E5 		strb	r3, [r4, #1]
 239              		.loc 1 3708 0
 240 01a4 3C2084E5 		str	r2, [r4, #60]
 241              	.LVL30:
 242              	.L20:
3709:../uvc.c      **** 					}
3710:../uvc.c      **** 				}else{
3711:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3712:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3713:../uvc.c      **** 				}
3714:../uvc.c      **** 			}
3715:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 243              		.loc 1 3715 0
 244 01a8 1C0095E5 		ldr	r0, [r5, #28]
 245 01ac FEFFFFEB 		bl	_txe_mutex_put
 246              	.LVL31:
3716:../uvc.c      **** /*
3717:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3718:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3719:../uvc.c      **** */
3720:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3721:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3722:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3723:../uvc.c      **** #endif
3724:../uvc.c      **** 
3725:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3726:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3727:../uvc.c      **** #if 0
3728:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3729:../uvc.c      **** 
3730:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3731:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3732:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3733:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3734:../uvc.c      **** 			    i = 0;
3735:../uvc.c      **** 				 switch(cmdCopyIdx)
3736:../uvc.c      **** 				 {
3737:../uvc.c      **** 					 case BrgtCtlID1:
3738:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3739:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3740:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3741:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3742:../uvc.c      **** 							 i++;
3743:../uvc.c      **** 						 }
3744:../uvc.c      **** 						 else{
3745:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3746:../uvc.c      **** 						 }
3747:../uvc.c      **** 
3748:../uvc.c      **** 						 CyU3PBusyWait(500);
3749:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3750:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3751:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3752:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3753:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3754:../uvc.c      **** 						 }
3755:../uvc.c      **** 						 else{
3756:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3757:../uvc.c      **** 						 }
3758:../uvc.c      **** 						 break;
3759:../uvc.c      **** 					 case HueCtlID5:
3760:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3761:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3762:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3764:../uvc.c      **** 						 }
3765:../uvc.c      **** 						 else{
3766:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3767:../uvc.c      **** 						 }
3768:../uvc.c      **** 						 break;
3769:../uvc.c      **** 					 case SaturCtlID6:
3770:../uvc.c      **** 					 case WBTLevCtlID10:
3771:../uvc.c      **** 					 default:
3772:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3773:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3774:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3775:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3776:../uvc.c      **** 						 }
3777:../uvc.c      **** 						 else{
3778:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3779:../uvc.c      **** 						 }
3780:../uvc.c      **** 						 break;
3781:../uvc.c      **** 				 }
3782:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3783:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3784:../uvc.c      **** 			}
3785:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3786:../uvc.c      **** #endif
3787:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3788:../uvc.c      **** 		/* Allow other ready threads to run. */
3789:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3790:../uvc.c      **** 			CyU3PThreadRelinquish ();
 247              		.loc 1 3790 0
 248 01b0 FEFFFFEB 		bl	_txe_thread_relinquish
 249              	.LVL32:
3791:../uvc.c      **** 		}
 250              		.loc 1 3791 0
 251 01b4 BFFFFFEA 		b	.L21
 252              	.LVL33:
 253              	.L15:
3681:../uvc.c      **** 							delaytime = 300;
 254              		.loc 1 3681 0
 255 01b8 8230A0E3 		mov	r3, #130
 256              	.LVL34:
 257 01bc FEFFFFEB 		bl	SensorSetIrisControl
 258              	.LVL35:
3683:../uvc.c      **** 						default:
 259              		.loc 1 3683 0
 260 01c0 4B1FA0E3 		mov	r1, #300
 261 01c4 EAFFFFEA 		b	.L12
 262              	.LVL36:
 263              	.L24:
3711:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 264              		.loc 1 3711 0
 265 01c8 FA1FA0E3 		mov	r1, #1000
 266 01cc 50009FE5 		ldr	r0, .L26
 267 01d0 104085E5 		str	r4, [r5, #16]
 268 01d4 FEFFFFEB 		bl	_txe_timer_change
 269              	.LVL37:
3712:../uvc.c      **** 				}
 270              		.loc 1 3712 0
 271 01d8 44009FE5 		ldr	r0, .L26
 272 01dc FEFFFFEB 		bl	_txe_timer_activate
 273              	.LVL38:
 274 01e0 F0FFFFEA 		b	.L20
 275              	.LVL39:
 276              	.L25:
3700:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 277              		.loc 1 3700 0
 278 01e4 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
3699:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 279              		.loc 1 3699 0
 280 01e8 3C8084E5 		str	r8, [r4, #60]
3700:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 281              		.loc 1 3700 0
 282 01ec 230053E3 		cmp	r3, #35
3701:../uvc.c      **** 						}else{
 283              		.loc 1 3701 0
 284 01f0 20304382 		subhi	r3, r3, #32
 285 01f4 83308380 		addhi	r3, r3, r3, asl #1
3703:../uvc.c      **** 						}
 286              		.loc 1 3703 0
 287 01f8 83308390 		addls	r3, r3, r3, asl #1
3701:../uvc.c      **** 						}else{
 288              		.loc 1 3701 0
 289 01fc 83318980 		addhi	r3, r9, r3, asl #3
3703:../uvc.c      **** 						}
 290              		.loc 1 3703 0
 291 0200 83318990 		addls	r3, r9, r3, asl #3
3701:../uvc.c      **** 						}else{
 292              		.loc 1 3701 0
 293 0204 1080C385 		strhib	r8, [r3, #16]
3703:../uvc.c      **** 						}
 294              		.loc 1 3703 0
 295 0208 9081C395 		strlsb	r8, [r3, #400]
3705:../uvc.c      **** 					}else{
 296              		.loc 1 3705 0
 297 020c 343094E5 		ldr	r3, [r4, #52]
 298 0210 103085E5 		str	r3, [r5, #16]
 299 0214 E3FFFFEA 		b	.L20
 300              	.LVL40:
 301              	.L16:
3685:../uvc.c      **** 							break;
 302              		.loc 1 3685 0
 303 0218 FEFFFFEB 		bl	SensorSetControl
 304              	.LVL41:
 305 021c 0A10A0E1 		mov	r1, r10
3686:../uvc.c      **** 					}
 306              		.loc 1 3686 0
 307 0220 D3FFFFEA 		b	.L12
 308              	.L27:
 309              		.align	2
 310              	.L26:
 311 0224 00000000 		.word	I2CCmdTimer
 312 0228 00000000 		.word	I2CCmdCb
 313 022c 00000000 		.word	cmdQu
 314 0230 00000000 		.word	.LC0
 315 0234 14000000 		.word	.LC1
 316 0238 00000000 		.word	statQu
 317 023c 00000000 		.word	.LANCHOR1
 318 0240 00000000 		.word	.LANCHOR0
 319              		.cfi_endproc
 320              	.LFE25:
 322              		.align	2
 323              		.global	CyFxUvcApplnDmaCallback
 325              	CyFxUvcApplnDmaCallback:
 326              	.LFB10:
1533:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 327              		.loc 1 1533 0
 328              		.cfi_startproc
 329              		@ args = 0, pretend = 0, frame = 0
 330              		@ frame_needed = 0, uses_anonymous_args = 0
 331              	.LVL42:
1537:../uvc.c      ****     {
 332              		.loc 1 1537 0
 333 0244 080051E3 		cmp	r1, #8
1533:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 334              		.loc 1 1533 0
 335 0248 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 336              	.LCFI2:
 337              		.cfi_def_cfa_offset 20
 338              		.cfi_offset 4, -20
 339              		.cfi_offset 5, -16
 340              		.cfi_offset 6, -12
 341              		.cfi_offset 7, -8
 342              		.cfi_offset 14, -4
 343 024c 0250A0E1 		mov	r5, r2
 344 0250 0CD04DE2 		sub	sp, sp, #12
 345              	.LCFI3:
 346              		.cfi_def_cfa_offset 32
1537:../uvc.c      ****     {
 347              		.loc 1 1537 0
 348 0254 0B00000A 		beq	.L39
1575:../uvc.c      ****     {
 349              		.loc 1 1575 0
 350 0258 100051E3 		cmp	r1, #16
 351 025c 0700001A 		bne	.L28
1577:../uvc.c      ****         streamingStarted = CyTrue;
 352              		.loc 1 1577 0
 353 0260 74319FE5 		ldr	r3, .L42
1578:../uvc.c      ****     }
 354              		.loc 1 1578 0
 355 0264 0110A0E3 		mov	r1, #1
 356              	.LVL43:
1577:../uvc.c      ****         streamingStarted = CyTrue;
 357              		.loc 1 1577 0
 358 0268 BA23D3E1 		ldrh	r2, [r3, #58]
 359              	.LVL44:
1578:../uvc.c      ****     }
 360              		.loc 1 1578 0
 361 026c 3C1083E5 		str	r1, [r3, #60]
1577:../uvc.c      ****         streamingStarted = CyTrue;
 362              		.loc 1 1577 0
 363 0270 012082E0 		add	r2, r2, r1
 364 0274 0228A0E1 		mov	r2, r2, asl #16
 365 0278 2228A0E1 		mov	r2, r2, lsr #16
 366 027c BA23C3E1 		strh	r2, [r3, #58]	@ movhi
 367              	.LVL45:
 368              	.L28:
1580:../uvc.c      **** 
 369              		.loc 1 1580 0
 370 0280 0CD08DE2 		add	sp, sp, #12
 371              		@ sp needed
 372 0284 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 373              	.LVL46:
 374              	.L39:
1539:../uvc.c      ****             {
 375              		.loc 1 1539 0
 376 0288 50319FE5 		ldr	r3, .L42+4
 377 028c B420D2E1 		ldrh	r2, [r2, #4]
 378              	.LVL47:
1541:../uvc.c      ****                 fb++;
 379              		.loc 1 1541 0
 380 0290 006095E5 		ldr	r6, [r5]
1539:../uvc.c      ****             {
 381              		.loc 1 1539 0
 382 0294 030052E1 		cmp	r2, r3
 383 0298 3300000A 		beq	.L40
 384              	.LVL48:
 385              	.LBB6:
 386              	.LBB7:
1281:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 387              		.loc 1 1281 0
 388 029c 40719FE5 		ldr	r7, .L42+8
1280:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 389              		.loc 1 1280 0
 390 02a0 0010E0E3 		mvn	r1, #0
 391              	.LVL49:
 392 02a4 3C019FE5 		ldr	r0, .L42+12
 393              	.LVL50:
 394 02a8 FEFFFFEB 		bl	_txe_mutex_get
 395              	.LVL51:
1281:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 396              		.loc 1 1281 0
 397 02ac 121D87E2 		add	r1, r7, #1152
 398 02b0 0C20A0E3 		mov	r2, #12
 399 02b4 0C0046E2 		sub	r0, r6, #12
 400              	.LVL52:
 401 02b8 FEFFFFEB 		bl	CyU3PMemCopy
 402              	.LVL53:
1282:../uvc.c      **** 
 403              		.loc 1 1282 0
 404 02bc 24019FE5 		ldr	r0, .L42+12
 405 02c0 FEFFFFEB 		bl	_txe_mutex_put
 406              	.LVL54:
1287:../uvc.c      ****     }
 407              		.loc 1 1287 0
 408 02c4 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 409              	.LBE7:
 410              	.LBE6:
1548:../uvc.c      ****                 pbc = input->buffer_p.count;
 411              		.loc 1 1548 0
 412 02c8 0C419FE5 		ldr	r4, .L42
 413              	.LBB9:
 414              	.LBB8:
1287:../uvc.c      ****     }
 415              		.loc 1 1287 0
 416 02cc 023083E3 		orr	r3, r3, #2
 417 02d0 0B3046E5 		strb	r3, [r6, #-11]
 418              	.LBE8:
 419              	.LBE9:
1552:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 420              		.loc 1 1552 0
 421 02d4 301094E5 		ldr	r1, [r4, #48]
1548:../uvc.c      ****                 pbc = input->buffer_p.count;
 422              		.loc 1 1548 0
 423 02d8 BA22D4E1 		ldrh	r2, [r4, #42]
1549:../uvc.c      ****                // hitFV = CyTrue;
 424              		.loc 1 1549 0
 425 02dc B430D5E1 		ldrh	r3, [r5, #4]
1548:../uvc.c      ****                 pbc = input->buffer_p.count;
 426              		.loc 1 1548 0
 427 02e0 012082E2 		add	r2, r2, #1
1552:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 428              		.loc 1 1552 0
 429 02e4 0F0051E3 		cmp	r1, #15
1548:../uvc.c      ****                 pbc = input->buffer_p.count;
 430              		.loc 1 1548 0
 431 02e8 BA22C4E1 		strh	r2, [r4, #42]	@ movhi
1549:../uvc.c      ****                // hitFV = CyTrue;
 432              		.loc 1 1549 0
 433 02ec BC32C4E1 		strh	r3, [r4, #44]	@ movhi
1552:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 434              		.loc 1 1552 0
 435 02f0 2D00000A 		beq	.L41
 436              	.L32:
1559:../uvc.c      ****             }
 437              		.loc 1 1559 0
 438 02f4 0120A0E3 		mov	r2, #1
 439 02f8 342084E5 		str	r2, [r4, #52]
 440              	.LVL55:
 441              	.L31:
1563:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 442              		.loc 1 1563 0
 443 02fc B823D4E1 		ldrh	r2, [r4, #56]
1564:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 444              		.loc 1 1564 0
 445 0300 0C1083E2 		add	r1, r3, #12
1563:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 446              		.loc 1 1563 0
 447 0304 013082E2 		add	r3, r2, #1
1564:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 448              		.loc 1 1564 0
 449 0308 0118A0E1 		mov	r1, r1, asl #16
1563:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 450              		.loc 1 1563 0
 451 030c 0338A0E1 		mov	r3, r3, asl #16
1564:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 452              		.loc 1 1564 0
 453 0310 2118A0E1 		mov	r1, r1, lsr #16
1563:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 454              		.loc 1 1563 0
 455 0314 2338A0E1 		mov	r3, r3, lsr #16
1564:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 456              		.loc 1 1564 0
 457 0318 0020A0E3 		mov	r2, #0
 458 031c C8009FE5 		ldr	r0, .L42+16
1563:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 459              		.loc 1 1563 0
 460 0320 B833C4E1 		strh	r3, [r4, #56]	@ movhi
1564:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 461              		.loc 1 1564 0
 462 0324 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 463              	.LVL56:
1563:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 464              		.loc 1 1563 0
 465 0328 AC109FE5 		ldr	r1, .L42
1567:../uvc.c      ****             {
 466              		.loc 1 1567 0
 467 032c 002050E2 		subs	r2, r0, #0
 468 0330 D2FFFF0A 		beq	.L28
1569:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 469              		.loc 1 1569 0
 470 0334 B803D1E1 		ldrh	r0, [r1, #56]
 471              	.LVL57:
1570:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 472              		.loc 1 1570 0
 473 0338 B430D5E1 		ldrh	r3, [r5, #4]
1569:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 474              		.loc 1 1569 0
 475 033c 010040E2 		sub	r0, r0, #1
 476 0340 0008A0E1 		mov	r0, r0, asl #16
 477 0344 2008A0E1 		mov	r0, r0, lsr #16
 478 0348 B803C1E1 		strh	r0, [r1, #56]	@ movhi
1570:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 479              		.loc 1 1570 0
 480 034c B803D1E1 		ldrh	r0, [r1, #56]
 481 0350 BA13D1E1 		ldrh	r1, [r1, #58]
 482 0354 001061E0 		rsb	r1, r1, r0
 483 0358 00108DE5 		str	r1, [sp]
 484 035c 0400A0E3 		mov	r0, #4
 485 0360 88109FE5 		ldr	r1, .L42+20
 486 0364 FEFFFFEB 		bl	CyU3PDebugPrint
 487              	.LVL58:
 488 0368 C4FFFFEA 		b	.L28
 489              	.LVL59:
 490              	.L40:
 491              	.LBB10:
 492              	.LBB11:
1280:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 493              		.loc 1 1280 0
 494 036c 0010E0E3 		mvn	r1, #0
 495              	.LVL60:
 496              	.LBE11:
 497              	.LBE10:
1542:../uvc.c      ****             }
 498              		.loc 1 1542 0
 499 0370 64409FE5 		ldr	r4, .L42
 500              	.LBB14:
 501              	.LBB12:
1280:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 502              		.loc 1 1280 0
 503 0374 6C009FE5 		ldr	r0, .L42+12
 504              	.LVL61:
 505 0378 FEFFFFEB 		bl	_txe_mutex_get
 506              	.LVL62:
 507              	.LBE12:
 508              	.LBE14:
1541:../uvc.c      ****                 fb++;
 509              		.loc 1 1541 0
 510 037c 0C6046E2 		sub	r6, r6, #12
 511              	.LVL63:
 512              	.LBB15:
 513              	.LBB13:
1281:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 514              		.loc 1 1281 0
 515 0380 0C20A0E3 		mov	r2, #12
 516 0384 0600A0E1 		mov	r0, r6
 517 0388 64109FE5 		ldr	r1, .L42+24
 518 038c FEFFFFEB 		bl	CyU3PMemCopy
 519              	.LVL64:
1282:../uvc.c      **** 
 520              		.loc 1 1282 0
 521 0390 50009FE5 		ldr	r0, .L42+12
 522 0394 FEFFFFEB 		bl	_txe_mutex_put
 523              	.LVL65:
 524              	.LBE13:
 525              	.LBE15:
1542:../uvc.c      ****             }
 526              		.loc 1 1542 0
 527 0398 B822D4E1 		ldrh	r2, [r4, #40]
 528 039c B430D5E1 		ldrh	r3, [r5, #4]
 529 03a0 012082E2 		add	r2, r2, #1
 530 03a4 B822C4E1 		strh	r2, [r4, #40]	@ movhi
 531 03a8 D3FFFFEA 		b	.L31
 532              	.LVL66:
 533              	.L41:
1553:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 534              		.loc 1 1553 0
 535 03ac 0010E0E3 		mvn	r1, #0
 536 03b0 30009FE5 		ldr	r0, .L42+12
 537 03b4 FEFFFFEB 		bl	_txe_mutex_get
 538              	.LVL67:
1554:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 539              		.loc 1 1554 0
 540 03b8 8134D7E5 		ldrb	r3, [r7, #1153]	@ zero_extendqisi2
1555:../uvc.c      ****                 	stiflag = 0xAA;
 541              		.loc 1 1555 0
 542 03bc 24009FE5 		ldr	r0, .L42+12
1554:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 543              		.loc 1 1554 0
 544 03c0 DF3003E2 		and	r3, r3, #223
 545 03c4 8134C7E5 		strb	r3, [r7, #1153]
1555:../uvc.c      ****                 	stiflag = 0xAA;
 546              		.loc 1 1555 0
 547 03c8 FEFFFFEB 		bl	_txe_mutex_put
 548              	.LVL68:
1556:../uvc.c      ****                 }
 549              		.loc 1 1556 0
 550 03cc AA30A0E3 		mov	r3, #170
 551 03d0 303084E5 		str	r3, [r4, #48]
 552 03d4 B430D5E1 		ldrh	r3, [r5, #4]
 553 03d8 C5FFFFEA 		b	.L32
 554              	.L43:
 555              		.align	2
 556              	.L42:
 557 03dc 00000000 		.word	.LANCHOR0
 558 03e0 F03F0000 		.word	16368
 559 03e4 00000000 		.word	.LANCHOR1
 560 03e8 00000000 		.word	imgHdMux
 561 03ec 00000000 		.word	glChHandleUVCStream
 562 03f0 38000000 		.word	.LC2
 563 03f4 80040000 		.word	.LANCHOR1+1152
 564              		.cfi_endproc
 565              	.LFE10:
 567              		.align	2
 569              	CyFxUVCApplnUSBEventCB:
 570              	.LFB8:
1336:../uvc.c      ****     switch (evtype)
 571              		.loc 1 1336 0
 572              		.cfi_startproc
 573              		@ args = 0, pretend = 0, frame = 8
 574              		@ frame_needed = 0, uses_anonymous_args = 0
 575              	.LVL69:
1337:../uvc.c      ****     {
 576              		.loc 1 1337 0
 577 03f8 020050E3 		cmp	r0, #2
1336:../uvc.c      ****     switch (evtype)
 578              		.loc 1 1336 0
 579 03fc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 580              	.LCFI4:
 581              		.cfi_def_cfa_offset 16
 582              		.cfi_offset 4, -16
 583              		.cfi_offset 5, -12
 584              		.cfi_offset 6, -8
 585              		.cfi_offset 14, -4
 586 0400 0040A0E1 		mov	r4, r0
 587 0404 10D04DE2 		sub	sp, sp, #16
 588              	.LCFI5:
 589              		.cfi_def_cfa_offset 32
1337:../uvc.c      ****     {
 590              		.loc 1 1337 0
 591 0408 3D00000A 		beq	.L46
 592 040c 040050E3 		cmp	r0, #4
 593 0410 2000000A 		beq	.L47
 594 0414 010050E3 		cmp	r0, #1
 595 0418 0100000A 		beq	.L52
 596              	.LVL70:
 597              	.L44:
1373:../uvc.c      **** 
 598              		.loc 1 1373 0
 599 041c 10D08DE2 		add	sp, sp, #16
 600              		@ sp needed
 601 0420 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 602              	.LVL71:
 603              	.L52:
 604              	.LBB30:
 605              	.LBB31:
1356:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 606              		.loc 1 1356 0
 607 0424 0130A0E1 		mov	r3, r1
 608 0428 0420A0E1 		mov	r2, r4
1358:../uvc.c      ****             isUsbConnected = CyFalse;
 609              		.loc 1 1358 0
 610 042c 40519FE5 		ldr	r5, .L53
1356:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 611              		.loc 1 1356 0
 612 0430 40119FE5 		ldr	r1, .L53+4
 613              	.LVL72:
 614 0434 0400A0E3 		mov	r0, #4
 615              	.LVL73:
 616 0438 FEFFFFEB 		bl	CyU3PDebugPrint
 617              	.LVL74:
1357:../uvc.c      ****             gpif_initialized = 0;
 618              		.loc 1 1357 0
 619 043c 0400A0E1 		mov	r0, r4
 620 0440 FEFFFFEB 		bl	CyU3PGpifDisable
 621              	.LVL75:
1358:../uvc.c      ****             isUsbConnected = CyFalse;
 622              		.loc 1 1358 0
 623 0444 00C0A0E3 		mov	ip, #0
 624              	.LBB32:
 625              	.LBB33:
1320:../uvc.c      **** 	{
 626              		.loc 1 1320 0
 627 0448 00C08DE5 		str	ip, [sp]
 628 044c 0410A0E1 		mov	r1, r4
 629 0450 0500A0E1 		mov	r0, r5
 630 0454 0220A0E3 		mov	r2, #2
 631 0458 0C308DE2 		add	r3, sp, #12
 632              	.LBE33:
 633              	.LBE32:
1358:../uvc.c      ****             isUsbConnected = CyFalse;
 634              		.loc 1 1358 0
 635 045c 40C085E5 		str	ip, [r5, #64]
1359:../uvc.c      ****             streamingStarted = CyFalse;
 636              		.loc 1 1359 0
 637 0460 44C085E5 		str	ip, [r5, #68]
1360:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 638              		.loc 1 1360 0
 639 0464 3CC085E5 		str	ip, [r5, #60]
 640              	.LBB37:
 641              	.LBB36:
1320:../uvc.c      **** 	{
 642              		.loc 1 1320 0
 643 0468 FEFFFFEB 		bl	_txe_event_flags_get
 644              	.LVL76:
 645 046c 004050E2 		subs	r4, r0, #0
 646 0470 E9FFFF1A 		bne	.L44
 647              	.LBB34:
 648              	.LBB35:
1323:../uvc.c      **** 
 649              		.loc 1 1323 0
 650 0474 0500A0E1 		mov	r0, r5
 651 0478 0110E0E3 		mvn	r1, #1
 652 047c 0220A0E3 		mov	r2, #2
 653 0480 FEFFFFEB 		bl	_txe_event_flags_set
 654              	.LVL77:
1326:../uvc.c      **** 	}
 655              		.loc 1 1326 0
 656 0484 0500A0E1 		mov	r0, r5
 657 0488 0420A0E1 		mov	r2, r4
 658 048c 0210A0E3 		mov	r1, #2
 659 0490 FEFFFFEB 		bl	_txe_event_flags_set
 660              	.LVL78:
 661 0494 E0FFFFEA 		b	.L44
 662              	.LVL79:
 663              	.L47:
 664              	.LBE35:
 665              	.LBE34:
 666              	.LBE36:
 667              	.LBE37:
 668              	.LBE31:
 669              	.LBE30:
1340:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 670              		.loc 1 1340 0
 671 0498 0130A0E1 		mov	r3, r1
 672 049c 0020A0E1 		mov	r2, r0
 673 04a0 D4109FE5 		ldr	r1, .L53+8
 674              	.LVL80:
 675 04a4 FEFFFFEB 		bl	CyU3PDebugPrint
 676              	.LVL81:
1342:../uvc.c      ****             streamingStarted = CyFalse;
 677              		.loc 1 1342 0
 678 04a8 C4409FE5 		ldr	r4, .L53
1341:../uvc.c      ****             gpif_initialized = 0;
 679              		.loc 1 1341 0
 680 04ac 0100A0E3 		mov	r0, #1
 681 04b0 FEFFFFEB 		bl	CyU3PGpifDisable
 682              	.LVL82:
1342:../uvc.c      ****             streamingStarted = CyFalse;
 683              		.loc 1 1342 0
 684 04b4 00C0A0E3 		mov	ip, #0
 685              	.LBB38:
 686              	.LBB39:
1320:../uvc.c      **** 	{
 687              		.loc 1 1320 0
 688 04b8 00C08DE5 		str	ip, [sp]
 689 04bc 0400A0E1 		mov	r0, r4
 690 04c0 0110A0E3 		mov	r1, #1
 691 04c4 0220A0E3 		mov	r2, #2
 692 04c8 0C308DE2 		add	r3, sp, #12
 693              	.LBE39:
 694              	.LBE38:
1342:../uvc.c      ****             streamingStarted = CyFalse;
 695              		.loc 1 1342 0
 696 04cc 40C084E5 		str	ip, [r4, #64]
1343:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 697              		.loc 1 1343 0
 698 04d0 3CC084E5 		str	ip, [r4, #60]
 699              	.LBB43:
 700              	.LBB42:
1320:../uvc.c      **** 	{
 701              		.loc 1 1320 0
 702 04d4 FEFFFFEB 		bl	_txe_event_flags_get
 703              	.LVL83:
 704 04d8 005050E2 		subs	r5, r0, #0
 705 04dc CEFFFF1A 		bne	.L44
 706              	.LBB40:
 707              	.LBB41:
1323:../uvc.c      **** 
 708              		.loc 1 1323 0
 709 04e0 0400A0E1 		mov	r0, r4
 710 04e4 0110E0E3 		mvn	r1, #1
 711 04e8 0220A0E3 		mov	r2, #2
 712 04ec FEFFFFEB 		bl	_txe_event_flags_set
 713              	.LVL84:
1326:../uvc.c      **** 	}
 714              		.loc 1 1326 0
 715 04f0 0400A0E1 		mov	r0, r4
 716 04f4 0520A0E1 		mov	r2, r5
 717 04f8 0210A0E3 		mov	r1, #2
 718 04fc FEFFFFEB 		bl	_txe_event_flags_set
 719              	.LVL85:
 720 0500 C5FFFFEA 		b	.L44
 721              	.LVL86:
 722              	.L46:
 723              	.LBE41:
 724              	.LBE40:
 725              	.LBE42:
 726              	.LBE43:
1348:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 727              		.loc 1 1348 0
 728 0504 0130A0E1 		mov	r3, r1
 729 0508 0420A0E1 		mov	r2, r4
 730 050c 6C109FE5 		ldr	r1, .L53+12
 731              	.LVL87:
1350:../uvc.c      ****             streamingStarted = CyFalse;
 732              		.loc 1 1350 0
 733 0510 5C509FE5 		ldr	r5, .L53
1348:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 734              		.loc 1 1348 0
 735 0514 0400A0E3 		mov	r0, #4
 736              	.LVL88:
 737 0518 FEFFFFEB 		bl	CyU3PDebugPrint
 738              	.LVL89:
1349:../uvc.c      ****             gpif_initialized = 0;
 739              		.loc 1 1349 0
 740 051c 0100A0E3 		mov	r0, #1
 741 0520 FEFFFFEB 		bl	CyU3PGpifDisable
 742              	.LVL90:
1350:../uvc.c      ****             streamingStarted = CyFalse;
 743              		.loc 1 1350 0
 744 0524 00C0A0E3 		mov	ip, #0
 745              	.LBB44:
 746              	.LBB45:
1320:../uvc.c      **** 	{
 747              		.loc 1 1320 0
 748 0528 00C08DE5 		str	ip, [sp]
 749 052c 0500A0E1 		mov	r0, r5
 750 0530 0110A0E3 		mov	r1, #1
 751 0534 0420A0E1 		mov	r2, r4
 752 0538 0C308DE2 		add	r3, sp, #12
 753              	.LBE45:
 754              	.LBE44:
1350:../uvc.c      ****             streamingStarted = CyFalse;
 755              		.loc 1 1350 0
 756 053c 40C085E5 		str	ip, [r5, #64]
1351:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 757              		.loc 1 1351 0
 758 0540 3CC085E5 		str	ip, [r5, #60]
 759              	.LBB49:
 760              	.LBB48:
1320:../uvc.c      **** 	{
 761              		.loc 1 1320 0
 762 0544 FEFFFFEB 		bl	_txe_event_flags_get
 763              	.LVL91:
 764 0548 006050E2 		subs	r6, r0, #0
 765 054c B2FFFF1A 		bne	.L44
 766              	.LBB46:
 767              	.LBB47:
1323:../uvc.c      **** 
 768              		.loc 1 1323 0
 769 0550 0420A0E1 		mov	r2, r4
 770 0554 0500A0E1 		mov	r0, r5
 771 0558 0110E0E3 		mvn	r1, #1
 772 055c FEFFFFEB 		bl	_txe_event_flags_set
 773              	.LVL92:
1326:../uvc.c      **** 	}
 774              		.loc 1 1326 0
 775 0560 0500A0E1 		mov	r0, r5
 776 0564 0410A0E1 		mov	r1, r4
 777 0568 0620A0E1 		mov	r2, r6
 778 056c FEFFFFEB 		bl	_txe_event_flags_set
 779              	.LVL93:
 780 0570 A9FFFFEA 		b	.L44
 781              	.L54:
 782              		.align	2
 783              	.L53:
 784 0574 00000000 		.word	.LANCHOR0
 785 0578 C4000000 		.word	.LC5
 786 057c 80000000 		.word	.LC3
 787 0580 A0000000 		.word	.LC4
 788              	.LBE47:
 789              	.LBE46:
 790              	.LBE48:
 791              	.LBE49:
 792              		.cfi_endproc
 793              	.LFE8:
 795              		.align	2
 797              	CyFxUVCApplnUSBSetupCB:
 798              	.LFB9:
1381:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 799              		.loc 1 1381 0
 800              		.cfi_startproc
 801              		@ args = 0, pretend = 0, frame = 8
 802              		@ frame_needed = 0, uses_anonymous_args = 0
 803              	.LVL94:
 804 0584 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 805              	.LCFI6:
 806              		.cfi_def_cfa_offset 28
 807              		.cfi_offset 4, -28
 808              		.cfi_offset 5, -24
 809              		.cfi_offset 6, -20
 810              		.cfi_offset 7, -16
 811              		.cfi_offset 8, -12
 812              		.cfi_offset 9, -8
 813              		.cfi_offset 14, -4
1390:../uvc.c      **** 
 814              		.loc 1 1390 0
 815 0588 B0C29FE5 		ldr	ip, .L89
1387:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 816              		.loc 1 1387 0
 817 058c B0929FE5 		ldr	r9, .L89+4
1389:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 818              		.loc 1 1389 0
 819 0590 B0829FE5 		ldr	r8, .L89+8
1386:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 820              		.loc 1 1386 0
 821 0594 B0229FE5 		ldr	r2, .L89+12
1388:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 822              		.loc 1 1388 0
 823 0598 B0329FE5 		ldr	r3, .L89+16
1389:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 824              		.loc 1 1389 0
 825 059c 0168A0E1 		mov	r6, r1, asl #16
1386:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 826              		.loc 1 1386 0
 827 05a0 FF4000E2 		and	r4, r0, #255
1387:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 828              		.loc 1 1387 0
 829 05a4 FF5C00E2 		and	r5, r0, #65280
 830 05a8 2554A0E1 		mov	r5, r5, lsr #8
1389:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 831              		.loc 1 1389 0
 832 05ac 2668A0E1 		mov	r6, r6, lsr #16
1390:../uvc.c      **** 
 833              		.loc 1 1390 0
 834 05b0 2118A0E1 		mov	r1, r1, lsr #16
 835              	.LVL95:
1388:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 836              		.loc 1 1388 0
 837 05b4 2078A0E1 		mov	r7, r0, lsr #16
1393:../uvc.c      ****     {
 838              		.loc 1 1393 0
 839 05b8 020054E3 		cmp	r4, #2
1381:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 840              		.loc 1 1381 0
 841 05bc 14D04DE2 		sub	sp, sp, #20
 842              	.LCFI7:
 843              		.cfi_def_cfa_offset 48
1387:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 844              		.loc 1 1387 0
 845 05c0 0050C9E5 		strb	r5, [r9]
1389:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 846              		.loc 1 1389 0
 847 05c4 B060C8E1 		strh	r6, [r8]	@ movhi
1390:../uvc.c      **** 
 848              		.loc 1 1390 0
 849 05c8 B010CCE1 		strh	r1, [ip]	@ movhi
1386:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 850              		.loc 1 1386 0
 851 05cc 0040C2E5 		strb	r4, [r2]
1388:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 852              		.loc 1 1388 0
 853 05d0 B070C3E1 		strh	r7, [r3]	@ movhi
1393:../uvc.c      ****     {
 854              		.loc 1 1393 0
 855 05d4 4A00000A 		beq	.L57
 856 05d8 0600009A 		bls	.L86
 857 05dc 210054E3 		cmp	r4, #33
 858 05e0 3900000A 		beq	.L60
 859 05e4 A10054E3 		cmp	r4, #161
 860 05e8 3700000A 		beq	.L60
 861              	.L74:
1382:../uvc.c      ****     uint32_t status;
 862              		.loc 1 1382 0
 863 05ec 0000A0E3 		mov	r0, #0
 864              	.LVL96:
 865              	.L56:
1520:../uvc.c      **** 
 866              		.loc 1 1520 0
 867 05f0 14D08DE2 		add	sp, sp, #20
 868              		@ sp needed
 869 05f4 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 870              	.LVL97:
 871              	.L86:
1393:../uvc.c      ****     {
 872              		.loc 1 1393 0
 873 05f8 010054E3 		cmp	r4, #1
 874 05fc FAFFFF1A 		bne	.L74
1433:../uvc.c      ****             {
 875              		.loc 1 1433 0
 876 0600 0B0055E3 		cmp	r5, #11
 877 0604 F8FFFF1A 		bne	.L74
1437:../uvc.c      ****                 {
 878              		.loc 1 1437 0
 879 0608 010056E3 		cmp	r6, #1
 880 060c F6FFFF1A 		bne	.L74
1437:../uvc.c      ****                 {
 881              		.loc 1 1437 0 is_stmt 0 discriminator 1
 882 0610 000057E3 		cmp	r7, #0
 883 0614 F4FFFF1A 		bne	.L74
1442:../uvc.c      ****                     streamingStarted = CyFalse;
 884              		.loc 1 1442 0 is_stmt 1
 885 0618 34429FE5 		ldr	r4, .L89+20
1440:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 886              		.loc 1 1440 0
 887 061c 34129FE5 		ldr	r1, .L89+24
 888 0620 0400A0E3 		mov	r0, #4
 889              	.LVL98:
 890 0624 FEFFFFEB 		bl	CyU3PDebugPrint
 891              	.LVL99:
1441:../uvc.c      ****                     gpif_initialized = 0;
 892              		.loc 1 1441 0
 893 0628 0600A0E1 		mov	r0, r6
 894 062c FEFFFFEB 		bl	CyU3PGpifDisable
 895              	.LVL100:
1445:../uvc.c      ****                     CyU3PBusyWait (100);
 896              		.loc 1 1445 0
 897 0630 0610A0E1 		mov	r1, r6
 898 0634 8300A0E3 		mov	r0, #131
1442:../uvc.c      ****                     streamingStarted = CyFalse;
 899              		.loc 1 1442 0
 900 0638 407084E5 		str	r7, [r4, #64]
1443:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 901              		.loc 1 1443 0
 902 063c 3C7084E5 		str	r7, [r4, #60]
1445:../uvc.c      ****                     CyU3PBusyWait (100);
 903              		.loc 1 1445 0
 904 0640 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 905              	.LVL101:
1446:../uvc.c      **** 
 906              		.loc 1 1446 0
 907 0644 6400A0E3 		mov	r0, #100
 908 0648 FEFFFFEB 		bl	CyFx3BusyWait
 909              	.LVL102:
1449:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 910              		.loc 1 1449 0
 911 064c 08029FE5 		ldr	r0, .L89+28
 912 0650 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 913              	.LVL103:
1450:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 914              		.loc 1 1450 0
 915 0654 8300A0E3 		mov	r0, #131
 916 0658 FEFFFFEB 		bl	CyU3PUsbFlushEp
 917              	.LVL104:
1451:../uvc.c      ****                     CyU3PBusyWait (100);
 918              		.loc 1 1451 0
 919 065c 0710A0E1 		mov	r1, r7
 920 0660 8300A0E3 		mov	r0, #131
 921 0664 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 922              	.LVL105:
1452:../uvc.c      **** 
 923              		.loc 1 1452 0
 924 0668 6400A0E3 		mov	r0, #100
 925 066c FEFFFFEB 		bl	CyFx3BusyWait
 926              	.LVL106:
1455:../uvc.c      ****                     uvcHandleReq = CyTrue;
 927              		.loc 1 1455 0
 928 0670 0710A0E1 		mov	r1, r7
 929 0674 0620A0E1 		mov	r2, r6
 930 0678 8300A0E3 		mov	r0, #131
 931 067c FEFFFFEB 		bl	CyU3PUsbStall
 932              	.LVL107:
1458:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 933              		.loc 1 1458 0
 934 0680 FEFFFFEB 		bl	CyU3PUsbAckSetup
 935              	.LVL108:
 936              	.LBB58:
 937              	.LBB59:
1320:../uvc.c      **** 	{
 938              		.loc 1 1320 0
 939 0684 00708DE5 		str	r7, [sp]
 940 0688 0610A0E1 		mov	r1, r6
 941 068c 0400A0E1 		mov	r0, r4
 942 0690 0220A0E3 		mov	r2, #2
 943 0694 0C308DE2 		add	r3, sp, #12
 944              	.LBE59:
 945              	.LBE58:
1460:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 946              		.loc 1 1460 0
 947 0698 486084E5 		str	r6, [r4, #72]
 948              	.LBB63:
 949              	.LBB62:
1320:../uvc.c      **** 	{
 950              		.loc 1 1320 0
 951 069c FEFFFFEB 		bl	_txe_event_flags_get
 952              	.LVL109:
 953 06a0 005050E2 		subs	r5, r0, #0
 954 06a4 1300001A 		bne	.L85
 955              	.LBB60:
 956              	.LBB61:
1323:../uvc.c      **** 
 957              		.loc 1 1323 0
 958 06a8 0400A0E1 		mov	r0, r4
 959 06ac 0110E0E3 		mvn	r1, #1
 960 06b0 0220A0E3 		mov	r2, #2
 961 06b4 FEFFFFEB 		bl	_txe_event_flags_set
 962              	.LVL110:
1326:../uvc.c      **** 	}
 963              		.loc 1 1326 0
 964 06b8 0400A0E1 		mov	r0, r4
 965 06bc 0520A0E1 		mov	r2, r5
 966 06c0 0210A0E3 		mov	r1, #2
 967 06c4 FEFFFFEB 		bl	_txe_event_flags_set
 968              	.LVL111:
 969 06c8 0A0000EA 		b	.L85
 970              	.LVL112:
 971              	.L60:
 972              	.LBE61:
 973              	.LBE60:
 974              	.LBE62:
 975              	.LBE63:
1398:../uvc.c      ****             {
 976              		.loc 1 1398 0
 977 06cc FF6006E2 		and	r6, r6, #255
 978 06d0 000056E3 		cmp	r6, #0
 979 06d4 1500000A 		beq	.L61
 980 06d8 010056E3 		cmp	r6, #1
 981 06dc C2FFFF1A 		bne	.L74
 982              	.LVL113:
1416:../uvc.c      ****                                 CYU3P_EVENT_OR);
 983              		.loc 1 1416 0
 984 06e0 0020A0E3 		mov	r2, #0
 985 06e4 68019FE5 		ldr	r0, .L89+20
 986              	.LVL114:
 987 06e8 0810A0E3 		mov	r1, #8
 988 06ec FEFFFFEB 		bl	_txe_event_flags_set
 989              	.LVL115:
1418:../uvc.c      ****                         {
 990              		.loc 1 1418 0
 991 06f0 002050E2 		subs	r2, r0, #0
 992 06f4 1B00001A 		bne	.L87
 993              	.LVL116:
 994              	.L85:
1402:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 995              		.loc 1 1402 0
 996 06f8 0100A0E3 		mov	r0, #1
 997              	.LVL117:
1520:../uvc.c      **** 
 998              		.loc 1 1520 0
 999 06fc 14D08DE2 		add	sp, sp, #20
 1000              		@ sp needed
 1001 0700 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1002              	.LVL118:
 1003              	.L57:
1468:../uvc.c      ****             {
 1004              		.loc 1 1468 0
 1005 0704 010055E3 		cmp	r5, #1
 1006 0708 B7FFFF1A 		bne	.L74
1470:../uvc.c      ****                 {
 1007              		.loc 1 1470 0
 1008 070c 830056E3 		cmp	r6, #131
 1009 0710 B5FFFF1A 		bne	.L74
1476:../uvc.c      ****                     {
 1010              		.loc 1 1476 0
 1011 0714 38819FE5 		ldr	r8, .L89+20
 1012 0718 3C7098E5 		ldr	r7, [r8, #60]
 1013 071c 010057E3 		cmp	r7, #1
 1014 0720 1900000A 		beq	.L88
 1015              	.LVL119:
1508:../uvc.c      ****                     }
 1016              		.loc 1 1508 0
 1017 0724 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1018              	.LVL120:
1507:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1019              		.loc 1 1507 0
 1020 0728 0500A0E1 		mov	r0, r5
 1021 072c AFFFFFEA 		b	.L56
 1022              	.LVL121:
 1023              	.L61:
1403:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1024              		.loc 1 1403 0
 1025 0730 0620A0E1 		mov	r2, r6
 1026 0734 18019FE5 		ldr	r0, .L89+20
 1027              	.LVL122:
 1028 0738 0410A0E3 		mov	r1, #4
 1029 073c FEFFFFEB 		bl	_txe_event_flags_set
 1030              	.LVL123:
1405:../uvc.c      ****                         {
 1031              		.loc 1 1405 0
 1032 0740 002050E2 		subs	r2, r0, #0
 1033 0744 EBFFFF0A 		beq	.L85
1407:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1034              		.loc 1 1407 0
 1035 0748 10119FE5 		ldr	r1, .L89+32
 1036 074c 0400A0E3 		mov	r0, #4
 1037              	.LVL124:
 1038 0750 FEFFFFEB 		bl	CyU3PDebugPrint
 1039              	.LVL125:
1408:../uvc.c      ****                         }
 1040              		.loc 1 1408 0
 1041 0754 0600A0E1 		mov	r0, r6
 1042 0758 0620A0E1 		mov	r2, r6
 1043 075c 0110A0E3 		mov	r1, #1
 1044 0760 FEFFFFEB 		bl	CyU3PUsbStall
 1045              	.LVL126:
 1046 0764 E3FFFFEA 		b	.L85
 1047              	.LVL127:
 1048              	.L87:
1421:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1049              		.loc 1 1421 0
 1050 0768 F4109FE5 		ldr	r1, .L89+36
 1051 076c 0400A0E3 		mov	r0, #4
 1052              	.LVL128:
 1053 0770 FEFFFFEB 		bl	CyU3PDebugPrint
 1054              	.LVL129:
1422:../uvc.c      ****                         }
 1055              		.loc 1 1422 0
 1056 0774 0000A0E3 		mov	r0, #0
 1057 0778 0020A0E1 		mov	r2, r0
 1058 077c 0610A0E1 		mov	r1, r6
 1059 0780 FEFFFFEB 		bl	CyU3PUsbStall
 1060              	.LVL130:
1415:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1061              		.loc 1 1415 0
 1062 0784 0600A0E1 		mov	r0, r6
 1063 0788 98FFFFEA 		b	.L56
 1064              	.LVL131:
 1065              	.L88:
1478:../uvc.c      **** 
 1066              		.loc 1 1478 0
 1067 078c D4109FE5 		ldr	r1, .L89+40
 1068 0790 0400A0E3 		mov	r0, #4
 1069              	.LVL132:
 1070 0794 FEFFFFEB 		bl	CyU3PDebugPrint
 1071              	.LVL133:
1481:../uvc.c      ****                         gpif_initialized = 0;
 1072              		.loc 1 1481 0
 1073 0798 0700A0E1 		mov	r0, r7
 1074 079c FEFFFFEB 		bl	CyU3PGpifDisable
 1075              	.LVL134:
1482:../uvc.c      ****                         streamingStarted = CyFalse;
 1076              		.loc 1 1482 0
 1077 07a0 0050A0E3 		mov	r5, #0
1486:../uvc.c      ****                         CyU3PBusyWait (100);
 1078              		.loc 1 1486 0
 1079 07a4 0710A0E1 		mov	r1, r7
 1080 07a8 0600A0E1 		mov	r0, r6
1482:../uvc.c      ****                         streamingStarted = CyFalse;
 1081              		.loc 1 1482 0
 1082 07ac 405088E5 		str	r5, [r8, #64]
1483:../uvc.c      **** 
 1083              		.loc 1 1483 0
 1084 07b0 3C5088E5 		str	r5, [r8, #60]
1486:../uvc.c      ****                         CyU3PBusyWait (100);
 1085              		.loc 1 1486 0
 1086 07b4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1087              	.LVL135:
1487:../uvc.c      **** 
 1088              		.loc 1 1487 0
 1089 07b8 6400A0E3 		mov	r0, #100
 1090 07bc FEFFFFEB 		bl	CyFx3BusyWait
 1091              	.LVL136:
1490:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1092              		.loc 1 1490 0
 1093 07c0 94009FE5 		ldr	r0, .L89+28
 1094 07c4 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1095              	.LVL137:
1491:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1096              		.loc 1 1491 0
 1097 07c8 0600A0E1 		mov	r0, r6
 1098 07cc FEFFFFEB 		bl	CyU3PUsbFlushEp
 1099              	.LVL138:
1492:../uvc.c      ****                         CyU3PBusyWait (100);
 1100              		.loc 1 1492 0
 1101 07d0 0510A0E1 		mov	r1, r5
 1102 07d4 0600A0E1 		mov	r0, r6
 1103 07d8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1104              	.LVL139:
1493:../uvc.c      **** 
 1105              		.loc 1 1493 0
 1106 07dc 6400A0E3 		mov	r0, #100
 1107 07e0 FEFFFFEB 		bl	CyFx3BusyWait
 1108              	.LVL140:
1496:../uvc.c      **** 
 1109              		.loc 1 1496 0
 1110 07e4 0510A0E1 		mov	r1, r5
 1111 07e8 0720A0E1 		mov	r2, r7
 1112 07ec 0600A0E1 		mov	r0, r6
 1113 07f0 FEFFFFEB 		bl	CyU3PUsbStall
 1114              	.LVL141:
1500:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1115              		.loc 1 1500 0
 1116 07f4 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1117              	.LVL142:
 1118              	.LBB64:
 1119              	.LBB65:
1320:../uvc.c      **** 	{
 1120              		.loc 1 1320 0
 1121 07f8 00508DE5 		str	r5, [sp]
 1122 07fc 0710A0E1 		mov	r1, r7
 1123 0800 0800A0E1 		mov	r0, r8
 1124 0804 0420A0E1 		mov	r2, r4
 1125 0808 0C308DE2 		add	r3, sp, #12
 1126              	.LBE65:
 1127              	.LBE64:
1502:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1128              		.loc 1 1502 0
 1129 080c 487088E5 		str	r7, [r8, #72]
 1130              	.LBB69:
 1131              	.LBB68:
1320:../uvc.c      **** 	{
 1132              		.loc 1 1320 0
 1133 0810 FEFFFFEB 		bl	_txe_event_flags_get
 1134              	.LVL143:
 1135 0814 005050E2 		subs	r5, r0, #0
 1136 0818 B6FFFF1A 		bne	.L85
 1137              	.LBB66:
 1138              	.LBB67:
1323:../uvc.c      **** 
 1139              		.loc 1 1323 0
 1140 081c 0420A0E1 		mov	r2, r4
 1141 0820 0800A0E1 		mov	r0, r8
 1142 0824 0110E0E3 		mvn	r1, #1
 1143 0828 FEFFFFEB 		bl	_txe_event_flags_set
 1144              	.LVL144:
1326:../uvc.c      **** 	}
 1145              		.loc 1 1326 0
 1146 082c 0800A0E1 		mov	r0, r8
 1147 0830 0410A0E1 		mov	r1, r4
 1148 0834 0520A0E1 		mov	r2, r5
 1149 0838 FEFFFFEB 		bl	_txe_event_flags_set
 1150              	.LVL145:
 1151 083c ADFFFFEA 		b	.L85
 1152              	.L90:
 1153              		.align	2
 1154              	.L89:
 1155 0840 00000000 		.word	wLength
 1156 0844 00000000 		.word	bRequest
 1157 0848 00000000 		.word	wIndex
 1158 084c 00000000 		.word	bmReqType
 1159 0850 00000000 		.word	wValue
 1160 0854 00000000 		.word	.LANCHOR0
 1161 0858 50010000 		.word	.LC8
 1162 085c 00000000 		.word	glChHandleUVCStream
 1163 0860 E4000000 		.word	.LC6
 1164 0864 1C010000 		.word	.LC7
 1165 0868 68010000 		.word	.LC9
 1166              	.LBE67:
 1167              	.LBE66:
 1168              	.LBE68:
 1169              	.LBE69:
 1170              		.cfi_endproc
 1171              	.LFE9:
 1173              		.align	2
 1174              		.global	I2CCmdHandler
 1176              	I2CCmdHandler:
 1177              	.LFB0:
 329:../uvc.c      **** 	uint8_t buf[2];
 1178              		.loc 1 329 0
 1179              		.cfi_startproc
 1180              		@ args = 0, pretend = 0, frame = 8
 1181              		@ frame_needed = 0, uses_anonymous_args = 0
 1182 086c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1183              	.LCFI8:
 1184              		.cfi_def_cfa_offset 36
 1185              		.cfi_offset 4, -36
 1186              		.cfi_offset 5, -32
 1187              		.cfi_offset 6, -28
 1188              		.cfi_offset 7, -24
 1189              		.cfi_offset 8, -20
 1190              		.cfi_offset 9, -16
 1191              		.cfi_offset 10, -12
 1192              		.cfi_offset 11, -8
 1193              		.cfi_offset 14, -4
 332:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1194              		.loc 1 332 0
 1195 0870 14419FE5 		ldr	r4, .L97
 329:../uvc.c      **** 	uint8_t buf[2];
 1196              		.loc 1 329 0
 1197 0874 34D04DE2 		sub	sp, sp, #52
 1198              	.LCFI9:
 1199              		.cfi_def_cfa_offset 88
 332:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1200              		.loc 1 332 0
 1201 0878 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1202              	.LVL146:
 337:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1203              		.loc 1 337 0
 1204 087c 5610D4E5 		ldrb	r1, [r4, #86]	@ zero_extendqisi2
 334:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1205              		.loc 1 334 0
 1206 0880 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1207              	.LVL147:
 337:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1208              		.loc 1 337 0
 1209 0884 4EB0D4E5 		ldrb	fp, [r4, #78]	@ zero_extendqisi2
 1210 0888 4FA0D4E5 		ldrb	r10, [r4, #79]	@ zero_extendqisi2
 1211 088c 5090D4E5 		ldrb	r9, [r4, #80]	@ zero_extendqisi2
 1212 0890 5180D4E5 		ldrb	r8, [r4, #81]	@ zero_extendqisi2
 1213 0894 5270D4E5 		ldrb	r7, [r4, #82]	@ zero_extendqisi2
 1214 0898 53E0D4E5 		ldrb	lr, [r4, #83]	@ zero_extendqisi2
 1215 089c 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1216 08a0 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 1217 08a4 0400A0E3 		mov	r0, #4
 1218 08a8 20108DE5 		str	r1, [sp, #32]
 1219 08ac 0520A0E1 		mov	r2, r5
 1220 08b0 18608DE5 		str	r6, [sp, #24]
 1221 08b4 00B08DE5 		str	fp, [sp]
 1222 08b8 04A08DE5 		str	r10, [sp, #4]
 1223 08bc 08908DE5 		str	r9, [sp, #8]
 1224 08c0 0C808DE5 		str	r8, [sp, #12]
 1225 08c4 10708DE5 		str	r7, [sp, #16]
 1226 08c8 14E08DE5 		str	lr, [sp, #20]
 1227 08cc 1CC08DE5 		str	ip, [sp, #28]
 1228 08d0 B8109FE5 		ldr	r1, .L97+4
 1229 08d4 FEFFFFEB 		bl	CyU3PDebugPrint
 1230              	.LVL148:
 341:../uvc.c      **** 	{
 1231              		.loc 1 341 0
 1232 08d8 000055E3 		cmp	r5, #0
 1233 08dc 0300000A 		beq	.L95
 366:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1234              		.loc 1 366 0
 1235 08e0 010055E3 		cmp	r5, #1
 1236 08e4 1700000A 		beq	.L96
 381:../uvc.c      **** 
 1237              		.loc 1 381 0
 1238 08e8 34D08DE2 		add	sp, sp, #52
 1239              		@ sp needed
 1240 08ec F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1241              	.LVL149:
 1242              	.L95:
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1243              		.loc 1 357 0
 1244 08f0 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1245 08f4 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1246 08f8 54E0D4E5 		ldrb	lr, [r4, #84]	@ zero_extendqisi2
 1247 08fc 28C08DE2 		add	ip, sp, #40
 1248 0900 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1249 0904 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1250 0908 04C08DE5 		str	ip, [sp, #4]
 343:../uvc.c      **** #if 0 //for debugging
 1251              		.loc 1 343 0
 1252 090c 0FC0A0E3 		mov	ip, #15
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1253              		.loc 1 357 0
 1254 0910 00E08DE5 		str	lr, [sp]
 1255 0914 011081E3 		orr	r1, r1, #1
 343:../uvc.c      **** #if 0 //for debugging
 1256              		.loc 1 343 0
 1257 0918 57C0C4E5 		strb	ip, [r4, #87]
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1258              		.loc 1 357 0
 1259 091c 010080E3 		orr	r0, r0, #1
 1260 0920 FEFFFFEB 		bl	SensorRead2B
 1261              	.LVL150:
 358:../uvc.c      **** 			if(CmdDataLen == 2){
 1262              		.loc 1 358 0
 1263 0924 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
 359:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1264              		.loc 1 359 0
 1265 0928 020056E3 		cmp	r6, #2
 358:../uvc.c      **** 			if(CmdDataLen == 2){
 1266              		.loc 1 358 0
 1267 092c 5530C4E5 		strb	r3, [r4, #85]
 360:../uvc.c      **** 			}
 1268              		.loc 1 360 0
 1269 0930 2930DD05 		ldreqb	r3, [sp, #41]	@ zero_extendqisi2
 1270 0934 5630C405 		streqb	r3, [r4, #86]
 362:../uvc.c      **** 		}else{//not support currently
 1271              		.loc 1 362 0
 1272 0938 0030E0E3 		mvn	r3, #0
 1273 093c 5730C4E5 		strb	r3, [r4, #87]
 381:../uvc.c      **** 
 1274              		.loc 1 381 0
 1275 0940 34D08DE2 		add	sp, sp, #52
 1276              		@ sp needed
 1277 0944 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1278              	.LVL151:
 1279              	.L96:
 375:../uvc.c      **** 		}else{//not support currently
 1280              		.loc 1 375 0
 1281 0948 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1282 094c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1283 0950 5450D4E5 		ldrb	r5, [r4, #84]	@ zero_extendqisi2
 1284              	.LVL152:
 368:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1285              		.loc 1 368 0
 1286 0954 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 369:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1287              		.loc 1 369 0
 1288 0958 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 375:../uvc.c      **** 		}else{//not support currently
 1289              		.loc 1 375 0
 1290 095c 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1291 0960 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1292 0964 28408DE2 		add	r4, sp, #40
 1293 0968 FE1001E2 		and	r1, r1, #254
 1294 096c 00508DE5 		str	r5, [sp]
 1295 0970 04408DE5 		str	r4, [sp, #4]
 1296 0974 FE0000E2 		and	r0, r0, #254
 368:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1297              		.loc 1 368 0
 1298 0978 28E0CDE5 		strb	lr, [sp, #40]
 369:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1299              		.loc 1 369 0
 1300 097c 29C0CDE5 		strb	ip, [sp, #41]
 375:../uvc.c      **** 		}else{//not support currently
 1301              		.loc 1 375 0
 1302 0980 FEFFFFEB 		bl	SensorWrite2B
 1303              	.LVL153:
 381:../uvc.c      **** 
 1304              		.loc 1 381 0
 1305 0984 34D08DE2 		add	sp, sp, #52
 1306              		@ sp needed
 1307 0988 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1308              	.LVL154:
 1309              	.L98:
 1310              		.align	2
 1311              	.L97:
 1312 098c 00000000 		.word	.LANCHOR0
 1313 0990 8C010000 		.word	.LC10
 1314              		.cfi_endproc
 1315              	.LFE0:
 1317              		.align	2
 1318              		.global	setIrisauto
 1320              	setIrisauto:
 1321              	.LFB1:
 387:../uvc.c      **** 	uint8_t dataIdx;
 1322              		.loc 1 387 0
 1323              		.cfi_startproc
 1324              		@ args = 0, pretend = 0, frame = 0
 1325              		@ frame_needed = 0, uses_anonymous_args = 0
 1326              	.LVL155:
 1327 0994 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1328              	.LCFI10:
 1329              		.cfi_def_cfa_offset 16
 1330              		.cfi_offset 4, -16
 1331              		.cfi_offset 5, -12
 1332              		.cfi_offset 6, -8
 1333              		.cfi_offset 14, -4
 1334 0998 0150A0E1 		mov	r5, r1
 1335 099c 08D04DE2 		sub	sp, sp, #8
 1336              	.LCFI11:
 1337              		.cfi_def_cfa_offset 24
 387:../uvc.c      **** 	uint8_t dataIdx;
 1338              		.loc 1 387 0
 1339 09a0 0040A0E1 		mov	r4, r0
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1340              		.loc 1 391 0
 1341 09a4 0060A0E3 		mov	r6, #0
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1342              		.loc 1 390 0
 1343 09a8 0010E0E3 		mvn	r1, #0
 1344              	.LVL156:
 1345 09ac 1C0090E5 		ldr	r0, [r0, #28]
 1346              	.LVL157:
 1347 09b0 FEFFFFEB 		bl	_txe_mutex_get
 1348              	.LVL158:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1349              		.loc 1 391 0
 1350 09b4 062055E0 		subs	r2, r5, r6
 1351 09b8 003072E2 		rsbs	r3, r2, #0
 1352 09bc 0230B3E0 		adcs	r3, r3, r2
 1353 09c0 00308DE5 		str	r3, [sp]
 1354 09c4 0400A0E1 		mov	r0, r4
 1355 09c8 04608DE5 		str	r6, [sp, #4]
 1356 09cc 2010A0E3 		mov	r1, #32
 1357 09d0 2720A0E3 		mov	r2, #39
 1358 09d4 3030A0E3 		mov	r3, #48
 1359 09d8 FEFFFFEB 		bl	cmdSet
 1360              	.LVL159:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1361              		.loc 1 392 0
 1362 09dc 060055E1 		cmp	r5, r6
 1363 09e0 0250A003 		moveq	r5, #2
 1364 09e4 0150A013 		movne	r5, #1
 1365 09e8 60008DE8 		stmia	sp, {r5, r6}
 1366 09ec 0400A0E1 		mov	r0, r4
 1367 09f0 2110A0E3 		mov	r1, #33
 1368 09f4 2520A0E3 		mov	r2, #37
 1369 09f8 3030A0E3 		mov	r3, #48
 1370 09fc FEFFFFEB 		bl	cmdSet
 1371              	.LVL160:
 393:../uvc.c      **** }
 1372              		.loc 1 393 0
 1373 0a00 1C0094E5 		ldr	r0, [r4, #28]
 394:../uvc.c      **** 
 1374              		.loc 1 394 0
 1375 0a04 08D08DE2 		add	sp, sp, #8
 1376              		@ sp needed
 1377 0a08 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1378              	.LVL161:
 393:../uvc.c      **** }
 1379              		.loc 1 393 0
 1380 0a0c FEFFFFEA 		b	_txe_mutex_put
 1381              	.LVL162:
 1382              		.cfi_endproc
 1383              	.LFE1:
 1385              		.align	2
 1386              		.global	ControlHandle
 1388              	ControlHandle:
 1389              	.LFB2:
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1390              		.loc 1 396 0
 1391              		.cfi_startproc
 1392              		@ args = 0, pretend = 0, frame = 24
 1393              		@ frame_needed = 0, uses_anonymous_args = 0
 1394              	.LVL163:
 1395 0a10 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1396              	.LCFI12:
 1397              		.cfi_def_cfa_offset 36
 1398              		.cfi_offset 4, -36
 1399              		.cfi_offset 5, -32
 1400              		.cfi_offset 6, -28
 1401              		.cfi_offset 7, -24
 1402              		.cfi_offset 8, -20
 1403              		.cfi_offset 9, -16
 1404              		.cfi_offset 10, -12
 1405              		.cfi_offset 11, -8
 1406              		.cfi_offset 14, -4
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1407              		.loc 1 404 0
 1408 0a14 DC6E9FE5 		ldr	r6, .L194
 402:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1409              		.loc 1 402 0
 1410 0a18 208040E2 		sub	r8, r0, #32
 403:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1411              		.loc 1 403 0
 1412 0a1c 230050E3 		cmp	r0, #35
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1413              		.loc 1 396 0
 1414 0a20 2CD04DE2 		sub	sp, sp, #44
 1415              	.LCFI13:
 1416              		.cfi_def_cfa_offset 80
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1417              		.loc 1 396 0
 1418 0a24 0040A0E1 		mov	r4, r0
 402:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1419              		.loc 1 402 0
 1420 0a28 FF8008E2 		and	r8, r8, #255
 1421              	.LVL164:
 403:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1422              		.loc 1 403 0
 1423 0a2c 2A00009A 		bls	.L103
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1424              		.loc 1 404 0
 1425 0a30 882088E0 		add	r2, r8, r8, asl #1
 1426 0a34 8221A0E1 		mov	r2, r2, asl #3
 1427 0a38 023086E0 		add	r3, r6, r2
 405:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1428              		.loc 1 405 0
 1429 0a3c 01C0D3E5 		ldrb	ip, [r3, #1]	@ zero_extendqisi2
 406:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1430              		.loc 1 406 0
 1431 0a40 0FA0D3E5 		ldrb	r10, [r3, #15]	@ zero_extendqisi2
 407:../uvc.c      ****     }else{
 1432              		.loc 1 407 0
 1433 0a44 0290D3E5 		ldrb	r9, [r3, #2]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 1434              		.loc 1 418 0
 1435 0a48 AC3E9FE5 		ldr	r3, .L194+4
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1436              		.loc 1 404 0
 1437 0a4c 02B0D6E7 		ldrb	fp, [r6, r2]	@ zero_extendqisi2
 1438              	.LVL165:
 418:../uvc.c      ****     /*
 1439              		.loc 1 418 0
 1440 0a50 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 1441              	.LVL166:
 426:../uvc.c      **** 		 {
 1442              		.loc 1 426 0
 1443 0a54 830055E3 		cmp	r5, #131
 1444 0a58 2900000A 		beq	.L106
 1445              	.LVL167:
 1446              	.L192:
 1447 0a5c 3200009A 		bls	.L191
 1448 0a60 850055E3 		cmp	r5, #133
 1449 0a64 B800000A 		beq	.L111
 1450 0a68 C300003A 		bcc	.L112
 1451 0a6c 860055E3 		cmp	r5, #134
 1452 0a70 7500000A 		beq	.L113
 1453 0a74 870055E3 		cmp	r5, #135
 1454 0a78 AA00001A 		bne	.L105
 645:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1455              		.loc 1 645 0
 1456 0a7c 230054E3 		cmp	r4, #35
 1457 0a80 CD00009A 		bls	.L147
 646:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1458              		.loc 1 646 0
 1459 0a84 888088E0 		add	r8, r8, r8, asl #1
 1460              	.LVL168:
 1461 0a88 886186E0 		add	r6, r6, r8, asl #3
 1462 0a8c 6C7E9FE5 		ldr	r7, .L194+8
 1463 0a90 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 647:../uvc.c      **** 		 	 }
 1464              		.loc 1 647 0
 1465 0a94 0C30D6E5 		ldrb	r3, [r6, #12]	@ zero_extendqisi2
 646:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1466              		.loc 1 646 0
 1467 0a98 5820C7E5 		strb	r2, [r7, #88]
 647:../uvc.c      **** 		 	 }
 1468              		.loc 1 647 0
 1469 0a9c 5930C7E5 		strb	r3, [r7, #89]
 1470              	.L148:
 659:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1471              		.loc 1 659 0
 1472 0aa0 0900A0E1 		mov	r0, r9
 1473              	.LVL169:
 1474 0aa4 581E9FE5 		ldr	r1, .L194+12
 1475 0aa8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1476              	.LVL170:
 1477 0aac 5860D7E5 		ldrb	r6, [r7, #88]	@ zero_extendqisi2
 661:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 1478              		.loc 1 661 0
 1479 0ab0 FF80A0E3 		mov	r8, #255
 1480 0ab4 0830A0E1 		mov	r3, r8
 1481 0ab8 0840A0E1 		mov	r4, r8
 1482              	.LVL171:
 1483              	.L115:
 958:../uvc.c      **** }
 1484              		.loc 1 958 0
 1485 0abc 48018DE8 		stmia	sp, {r3, r6, r8}
 1486 0ac0 401E9FE5 		ldr	r1, .L194+16
 1487 0ac4 0520A0E1 		mov	r2, r5
 1488 0ac8 0430A0E1 		mov	r3, r4
 1489 0acc 0400A0E3 		mov	r0, #4
 1490 0ad0 FEFFFFEB 		bl	CyU3PDebugPrint
 1491              	.LVL172:
 959:../uvc.c      **** /************** CT control requests handler *************************/
 1492              		.loc 1 959 0
 1493 0ad4 2CD08DE2 		add	sp, sp, #44
 1494              		@ sp needed
 1495 0ad8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1496              	.LVL173:
 1497              	.L103:
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1498              		.loc 1 409 0
 1499 0adc 803080E0 		add	r3, r0, r0, asl #1
 1500 0ae0 833186E0 		add	r3, r6, r3, asl #3
 1501 0ae4 80B1D3E5 		ldrb	fp, [r3, #384]	@ zero_extendqisi2
 1502              	.LVL174:
 410:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1503              		.loc 1 410 0
 1504 0ae8 81C1D3E5 		ldrb	ip, [r3, #385]	@ zero_extendqisi2
 1505              	.LVL175:
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1506              		.loc 1 411 0
 1507 0aec 8FA1D3E5 		ldrb	r10, [r3, #399]	@ zero_extendqisi2
 1508              	.LVL176:
 412:../uvc.c      ****     }
 1509              		.loc 1 412 0
 1510 0af0 8291D3E5 		ldrb	r9, [r3, #386]	@ zero_extendqisi2
 1511              	.LVL177:
 418:../uvc.c      ****     /*
 1512              		.loc 1 418 0
 1513 0af4 003E9FE5 		ldr	r3, .L194+4
 1514              	.LVL178:
 1515 0af8 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 1516              	.LVL179:
 426:../uvc.c      **** 		 {
 1517              		.loc 1 426 0
 1518 0afc 830055E3 		cmp	r5, #131
 1519 0b00 D5FFFF1A 		bne	.L192
 1520              	.LVL180:
 1521              	.L106:
 600:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1522              		.loc 1 600 0
 1523 0b04 230054E3 		cmp	r4, #35
 1524 0b08 C100009A 		bls	.L140
 601:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1525              		.loc 1 601 0
 1526 0b0c 888088E0 		add	r8, r8, r8, asl #1
 1527              	.LVL181:
 1528 0b10 886186E0 		add	r6, r6, r8, asl #3
 1529 0b14 E47D9FE5 		ldr	r7, .L194+8
 1530 0b18 0520D6E5 		ldrb	r2, [r6, #5]	@ zero_extendqisi2
 602:../uvc.c      **** 		 	 }
 1531              		.loc 1 602 0
 1532 0b1c 0630D6E5 		ldrb	r3, [r6, #6]	@ zero_extendqisi2
 601:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1533              		.loc 1 601 0
 1534 0b20 5820C7E5 		strb	r2, [r7, #88]
 602:../uvc.c      **** 		 	 }
 1535              		.loc 1 602 0
 1536 0b24 5930C7E5 		strb	r3, [r7, #89]
 1537 0b28 DCFFFFEA 		b	.L148
 1538              	.LVL182:
 1539              	.L191:
 426:../uvc.c      **** 		 {
 1540              		.loc 1 426 0
 1541 0b2c 810055E3 		cmp	r5, #129
 1542 0b30 5600000A 		beq	.L108
 1543 0b34 3A00008A 		bhi	.L109
 1544 0b38 010055E3 		cmp	r5, #1
 1545 0b3c 7900001A 		bne	.L105
 663:../uvc.c      **** 				  glEp0Buffer, &readCount);
 1546              		.loc 1 663 0
 1547 0b40 B87D9FE5 		ldr	r7, .L194+8
 1548 0b44 26208DE2 		add	r2, sp, #38
 1549 0b48 2000A0E3 		mov	r0, #32
 1550              	.LVL183:
 1551 0b4c 581087E2 		add	r1, r7, #88
 1552 0b50 10C08DE5 		str	ip, [sp, #16]
 1553 0b54 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1554              	.LVL184:
 665:../uvc.c      **** 			   {
 1555              		.loc 1 665 0
 1556 0b58 10C09DE5 		ldr	ip, [sp, #16]
 1557 0b5c 002050E2 		subs	r2, r0, #0
 1558 0b60 1403001A 		bne	.L150
 667:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1559              		.loc 1 667 0
 1560 0b64 5800D7E5 		ldrb	r0, [r7, #88]	@ zero_extendqisi2
 1561              	.LVL185:
 668:../uvc.c      **** 				  getData = glEp0Buffer[0];
 1562              		.loc 1 668 0
 1563 0b68 5920D7E5 		ldrb	r2, [r7, #89]	@ zero_extendqisi2
 1564              	.LVL186:
 670:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1565              		.loc 1 670 0
 1566 0b6c 5A30D7E5 		ldrb	r3, [r7, #90]	@ zero_extendqisi2
 667:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1567              		.loc 1 667 0
 1568 0b70 14008DE5 		str	r0, [sp, #20]
 1569              	.LVL187:
 668:../uvc.c      **** 				  getData = glEp0Buffer[0];
 1570              		.loc 1 668 0
 1571 0b74 1C208DE5 		str	r2, [sp, #28]
 1572              	.LVL188:
 670:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1573              		.loc 1 670 0
 1574 0b78 18308DE5 		str	r3, [sp, #24]
 1575              	.LVL189:
 674:../uvc.c      **** 					 {
 1576              		.loc 1 674 0
 1577 0b7c 260054E3 		cmp	r4, #38
 1578 0b80 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1579 0b84 F10200EA 		b	.L151
 1580              	.L153:
 1581 0b88 B4130000 		.word	.L152
 1582 0b8c 50170000 		.word	.L151
 1583 0b90 50170000 		.word	.L151
 1584 0b94 50170000 		.word	.L151
 1585 0b98 4C130000 		.word	.L154
 1586 0b9c 04120000 		.word	.L155
 1587 0ba0 80110000 		.word	.L156
 1588 0ba4 50170000 		.word	.L151
 1589 0ba8 50170000 		.word	.L151
 1590 0bac 50170000 		.word	.L151
 1591 0bb0 50170000 		.word	.L151
 1592 0bb4 F4100000 		.word	.L157
 1593 0bb8 50170000 		.word	.L151
 1594 0bbc 50170000 		.word	.L151
 1595 0bc0 50170000 		.word	.L151
 1596 0bc4 50170000 		.word	.L151
 1597 0bc8 6C100000 		.word	.L158
 1598 0bcc 50170000 		.word	.L151
 1599 0bd0 50170000 		.word	.L151
 1600 0bd4 50170000 		.word	.L151
 1601 0bd8 50170000 		.word	.L151
 1602 0bdc 50170000 		.word	.L151
 1603 0be0 50170000 		.word	.L151
 1604 0be4 50170000 		.word	.L151
 1605 0be8 50170000 		.word	.L151
 1606 0bec 90150000 		.word	.L159
 1607 0bf0 F0140000 		.word	.L160
 1608 0bf4 50170000 		.word	.L151
 1609 0bf8 E0140000 		.word	.L161
 1610 0bfc 50170000 		.word	.L151
 1611 0c00 80140000 		.word	.L162
 1612 0c04 B8160000 		.word	.L163
 1613 0c08 50170000 		.word	.L151
 1614 0c0c 50170000 		.word	.L151
 1615 0c10 50170000 		.word	.L151
 1616 0c14 50170000 		.word	.L151
 1617 0c18 20160000 		.word	.L164
 1618 0c1c E8160000 		.word	.L165
 1619 0c20 04100000 		.word	.L166
 1620              	.LVL190:
 1621              	.L109:
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1622              		.loc 1 581 0
 1623 0c24 230054E3 		cmp	r4, #35
 1624 0c28 6D00009A 		bls	.L137
 582:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1625              		.loc 1 582 0
 1626 0c2c 888088E0 		add	r8, r8, r8, asl #1
 1627              	.LVL191:
 1628 0c30 886186E0 		add	r6, r6, r8, asl #3
 1629 0c34 C47C9FE5 		ldr	r7, .L194+8
 1630 0c38 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 583:../uvc.c      **** 		 	 }
 1631              		.loc 1 583 0
 1632 0c3c 0430D6E5 		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 582:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1633              		.loc 1 582 0
 1634 0c40 5820C7E5 		strb	r2, [r7, #88]
 583:../uvc.c      **** 		 	 }
 1635              		.loc 1 583 0
 1636 0c44 5930C7E5 		strb	r3, [r7, #89]
 1637 0c48 94FFFFEA 		b	.L148
 1638              	.LVL192:
 1639              	.L113:
 634:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1640              		.loc 1 634 0
 1641 0c4c 230054E3 		cmp	r4, #35
 635:../uvc.c      **** 		 	 }
 1642              		.loc 1 635 0
 1643 0c50 88808880 		addhi	r8, r8, r8, asl #1
 1644              	.LVL193:
 638:../uvc.c      **** 		 	 }
 1645              		.loc 1 638 0
 1646 0c54 84408490 		addls	r4, r4, r4, asl #1
 635:../uvc.c      **** 		 	 }
 1647              		.loc 1 635 0
 1648 0c58 88618680 		addhi	r6, r6, r8, asl #3
 638:../uvc.c      **** 		 	 }
 1649              		.loc 1 638 0
 1650 0c5c 84618690 		addls	r6, r6, r4, asl #3
 635:../uvc.c      **** 		 	 }
 1651              		.loc 1 635 0
 1652 0c60 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 638:../uvc.c      **** 		 	 }
 1653              		.loc 1 638 0
 1654 0c64 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 1655 0c68 906C9FE5 		ldr	r6, .L194+8
 643:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 1656              		.loc 1 643 0
 1657 0c6c FF80A0E3 		mov	r8, #255
 1658 0c70 0610A0E1 		mov	r1, r6
 1659 0c74 5830E1E5 		strb	r3, [r1, #88]!
 640:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1660              		.loc 1 640 0
 1661 0c78 0100A0E3 		mov	r0, #1
 1662              	.LVL194:
 1663 0c7c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1664              	.LVL195:
 643:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 1665              		.loc 1 643 0
 1666 0c80 0840A0E1 		mov	r4, r8
 1667 0c84 5860D6E5 		ldrb	r6, [r6, #88]	@ zero_extendqisi2
 1668 0c88 0830A0E1 		mov	r3, r8
 1669 0c8c 8AFFFFEA 		b	.L115
 1670              	.LVL196:
 1671              	.L108:
 437:../uvc.c      **** 			 {
 1672              		.loc 1 437 0
 1673 0c90 053044E2 		sub	r3, r4, #5
 1674 0c94 210053E3 		cmp	r3, #33
 1675 0c98 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1676 0c9c CA0000EA 		b	.L116
 1677              	.L118:
 1678 0ca0 4C0F0000 		.word	.L117
 1679 0ca4 CC0F0000 		.word	.L116
 1680 0ca8 CC0F0000 		.word	.L116
 1681 0cac CC0F0000 		.word	.L116
 1682 0cb0 CC0F0000 		.word	.L116
 1683 0cb4 CC0F0000 		.word	.L116
 1684 0cb8 700F0000 		.word	.L119
 1685 0cbc CC0F0000 		.word	.L116
 1686 0cc0 CC0F0000 		.word	.L116
 1687 0cc4 CC0F0000 		.word	.L116
 1688 0cc8 CC0F0000 		.word	.L116
 1689 0ccc CC0F0000 		.word	.L116
 1690 0cd0 CC0F0000 		.word	.L116
 1691 0cd4 CC0F0000 		.word	.L116
 1692 0cd8 CC0F0000 		.word	.L116
 1693 0cdc CC0F0000 		.word	.L116
 1694 0ce0 CC0F0000 		.word	.L116
 1695 0ce4 CC0F0000 		.word	.L116
 1696 0ce8 CC0F0000 		.word	.L116
 1697 0cec CC0F0000 		.word	.L116
 1698 0cf0 F80E0000 		.word	.L120
 1699 0cf4 CC0F0000 		.word	.L116
 1700 0cf8 CC0F0000 		.word	.L116
 1701 0cfc C40E0000 		.word	.L121
 1702 0d00 CC0F0000 		.word	.L116
 1703 0d04 CC0F0000 		.word	.L116
 1704 0d08 7C0E0000 		.word	.L122
 1705 0d0c CC0F0000 		.word	.L116
 1706 0d10 CC0F0000 		.word	.L116
 1707 0d14 CC0F0000 		.word	.L116
 1708 0d18 CC0F0000 		.word	.L116
 1709 0d1c 440E0000 		.word	.L123
 1710 0d20 440E0000 		.word	.L123
 1711 0d24 440E0000 		.word	.L123
 1712              	.L105:
 955:../uvc.c      **** 			  break;
 1713              		.loc 1 955 0
 1714 0d28 0000A0E3 		mov	r0, #0
 1715              	.LVL197:
 956:../uvc.c      **** 		 }
 1716              		.loc 1 956 0
 1717 0d2c FF80A0E3 		mov	r8, #255
 1718              	.LVL198:
 955:../uvc.c      **** 			  break;
 1719              		.loc 1 955 0
 1720 0d30 0020A0E1 		mov	r2, r0
 1721 0d34 0110A0E3 		mov	r1, #1
 1722 0d38 FEFFFFEB 		bl	CyU3PUsbStall
 1723              	.LVL199:
 956:../uvc.c      **** 		 }
 1724              		.loc 1 956 0
 1725 0d3c 0860A0E1 		mov	r6, r8
 1726 0d40 0830A0E1 		mov	r3, r8
 1727 0d44 0840A0E1 		mov	r4, r8
 1728              	.LVL200:
 1729 0d48 5BFFFFEA 		b	.L115
 1730              	.LVL201:
 1731              	.L111:
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1732              		.loc 1 430 0
 1733 0d4c AC6B9FE5 		ldr	r6, .L194+8
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1734              		.loc 1 431 0
 1735 0d50 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1736              		.loc 1 432 0
 1737 0d54 581086E2 		add	r1, r6, #88
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1738              		.loc 1 434 0
 1739 0d58 FF80A0E3 		mov	r8, #255
 1740              	.LVL202:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1741              		.loc 1 432 0
 1742 0d5c 0200A0E3 		mov	r0, #2
 1743              	.LVL203:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1744              		.loc 1 431 0
 1745 0d60 5930C6E5 		strb	r3, [r6, #89]
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1746              		.loc 1 430 0
 1747 0d64 5890C6E5 		strb	r9, [r6, #88]
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1748              		.loc 1 434 0
 1749 0d68 0840A0E1 		mov	r4, r8
 1750              	.LVL204:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1751              		.loc 1 432 0
 1752 0d6c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1753              	.LVL205:
 1754 0d70 5860D6E5 		ldrb	r6, [r6, #88]	@ zero_extendqisi2
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1755              		.loc 1 434 0
 1756 0d74 0830A0E1 		mov	r3, r8
 1757 0d78 4FFFFFEA 		b	.L115
 1758              	.LVL206:
 1759              	.L112:
 618:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1760              		.loc 1 618 0
 1761 0d7c 230054E3 		cmp	r4, #35
 619:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1762              		.loc 1 619 0
 1763 0d80 88808880 		addhi	r8, r8, r8, asl #1
 1764              	.LVL207:
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1765              		.loc 1 625 0
 1766 0d84 84408490 		addls	r4, r4, r4, asl #1
 619:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1767              		.loc 1 619 0
 1768 0d88 88618680 		addhi	r6, r6, r8, asl #3
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1769              		.loc 1 625 0
 1770 0d8c 84618690 		addls	r6, r6, r4, asl #3
 1771 0d90 687B9FE5 		ldr	r7, .L194+8
 619:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1772              		.loc 1 619 0
 1773 0d94 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 620:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 1774              		.loc 1 620 0
 1775 0d98 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1776              		.loc 1 625 0
 1777 0d9c 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 626:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1778              		.loc 1 626 0
 1779 0da0 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1780              		.loc 1 627 0
 1781 0da4 0030A0E3 		mov	r3, #0
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1782              		.loc 1 625 0
 1783 0da8 5810C7E5 		strb	r1, [r7, #88]
 626:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1784              		.loc 1 626 0
 1785 0dac 5920C7E5 		strb	r2, [r7, #89]
 627:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1786              		.loc 1 627 0
 1787 0db0 5A30C7E5 		strb	r3, [r7, #90]
 628:../uvc.c      **** 		 	 }
 1788              		.loc 1 628 0
 1789 0db4 5B30C7E5 		strb	r3, [r7, #91]
 1790 0db8 38FFFFEA 		b	.L148
 1791              	.LVL208:
 1792              	.L147:
 650:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1793              		.loc 1 650 0
 1794 0dbc 0B0054E3 		cmp	r4, #11
 1795 0dc0 7800000A 		beq	.L193
 656:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1796              		.loc 1 656 0
 1797 0dc4 844084E0 		add	r4, r4, r4, asl #1
 1798 0dc8 846186E0 		add	r6, r6, r4, asl #3
 1799 0dcc 2C7B9FE5 		ldr	r7, .L194+8
 1800 0dd0 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 657:../uvc.c      **** 			 }
 1801              		.loc 1 657 0
 1802 0dd4 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
 656:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1803              		.loc 1 656 0
 1804 0dd8 5820C7E5 		strb	r2, [r7, #88]
 657:../uvc.c      **** 			 }
 1805              		.loc 1 657 0
 1806 0ddc 5930C7E5 		strb	r3, [r7, #89]
 1807 0de0 2EFFFFEA 		b	.L148
 1808              	.L137:
 586:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1809              		.loc 1 586 0
 1810 0de4 0B0054E3 		cmp	r4, #11
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1811              		.loc 1 593 0
 1812 0de8 84408410 		addne	r4, r4, r4, asl #1
 1813 0dec 84618610 		addne	r6, r6, r4, asl #3
 1814 0df0 087B9F15 		ldrne	r7, .L194+8
 587:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1815              		.loc 1 587 0
 1816 0df4 047B9F05 		ldreq	r7, .L194+8
 1817 0df8 0C3B9F05 		ldreq	r3, .L194+20
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1818              		.loc 1 593 0
 1819 0dfc 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 594:../uvc.c      **** 			 }
 1820              		.loc 1 594 0
 1821 0e00 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 587:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1822              		.loc 1 587 0
 1823 0e04 58308705 		streq	r3, [r7, #88]
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1824              		.loc 1 593 0
 1825 0e08 5820C715 		strneb	r2, [r7, #88]
 594:../uvc.c      **** 			 }
 1826              		.loc 1 594 0
 1827 0e0c 5930C715 		strneb	r3, [r7, #89]
 1828 0e10 22FFFFEA 		b	.L148
 1829              	.L140:
 604:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1830              		.loc 1 604 0
 1831 0e14 0B0054E3 		cmp	r4, #11
 611:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1832              		.loc 1 611 0
 1833 0e18 84408410 		addne	r4, r4, r4, asl #1
 1834 0e1c 84618610 		addne	r6, r6, r4, asl #3
 1835 0e20 D87A9F15 		ldrne	r7, .L194+8
 605:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1836              		.loc 1 605 0
 1837 0e24 D47A9F05 		ldreq	r7, .L194+8
 1838 0e28 E03A9F05 		ldreq	r3, .L194+24
 611:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1839              		.loc 1 611 0
 1840 0e2c 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 612:../uvc.c      **** 			 }
 1841              		.loc 1 612 0
 1842 0e30 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 605:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1843              		.loc 1 605 0
 1844 0e34 58308705 		streq	r3, [r7, #88]
 611:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1845              		.loc 1 611 0
 1846 0e38 5820C715 		strneb	r2, [r7, #88]
 612:../uvc.c      **** 			 }
 1847              		.loc 1 612 0
 1848 0e3c 5930C715 		strneb	r3, [r7, #89]
 1849 0e40 16FFFFEA 		b	.L148
 1850              	.L123:
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1851              		.loc 1 443 0
 1852 0e44 888088E0 		add	r8, r8, r8, asl #1
 1853              	.LVL209:
 1854 0e48 886186E0 		add	r6, r6, r8, asl #3
 1855 0e4c 0D20D6E5 		ldrb	r2, [r6, #13]	@ zero_extendqisi2
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 1856              		.loc 1 444 0
 1857 0e50 0E80D6E5 		ldrb	r8, [r6, #14]	@ zero_extendqisi2
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1858              		.loc 1 443 0
 1859 0e54 A43A9FE5 		ldr	r3, .L194+8
 1860 0e58 0260A0E1 		mov	r6, r2
 1861 0e5c 5820C3E5 		strb	r2, [r3, #88]
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 1862              		.loc 1 444 0
 1863 0e60 5980C3E5 		strb	r8, [r3, #89]
 1864              	.LVL210:
 1865              	.L127:
 574:../uvc.c      **** 
 1866              		.loc 1 574 0
 1867 0e64 0900A0E1 		mov	r0, r9
 1868 0e68 941A9FE5 		ldr	r1, .L194+12
 1869 0e6c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1870              	.LVL211:
 579:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 1871              		.loc 1 579 0
 1872 0e70 FF30A0E3 		mov	r3, #255
 1873 0e74 0340A0E1 		mov	r4, r3
 1874 0e78 0FFFFFEA 		b	.L115
 1875              	.LVL212:
 1876              	.L122:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1877              		.loc 1 464 0 discriminator 1
 1878 0e7c 000059E3 		cmp	r9, #0
 1879 0e80 0300000A 		beq	.L130
 1880 0e84 780A9FE5 		ldr	r0, .L194+12
 1881              	.LVL213:
 1882 0e88 0920A0E1 		mov	r2, r9
 1883 0e8c 0C1040E2 		sub	r1, r0, #12
 1884 0e90 FEFFFFEB 		bl	memcpy
 1885              	.LVL214:
 1886              	.L130:
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1887              		.loc 1 467 0
 1888 0e94 643A9FE5 		ldr	r3, .L194+8
 474:../uvc.c      **** 			 		 {
 1889              		.loc 1 474 0
 1890 0e98 5720D3E5 		ldrb	r2, [r3, #87]	@ zero_extendqisi2
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1891              		.loc 1 467 0
 1892 0e9c 6160D3E5 		ldrb	r6, [r3, #97]	@ zero_extendqisi2
 1893              	.LVL215:
 474:../uvc.c      **** 			 		 {
 1894              		.loc 1 474 0
 1895 0ea0 FF0052E3 		cmp	r2, #255
 468:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1896              		.loc 1 468 0
 1897 0ea4 6280D3E5 		ldrb	r8, [r3, #98]	@ zero_extendqisi2
 1898              	.LVL216:
 474:../uvc.c      **** 			 		 {
 1899              		.loc 1 474 0
 1900 0ea8 EDFFFF0A 		beq	.L127
 476:../uvc.c      **** 			 		 }
 1901              		.loc 1 476 0
 1902 0eac 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1903 0eb0 5C1A9FE5 		ldr	r1, .L194+28
 1904 0eb4 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1905 0eb8 0400A0E3 		mov	r0, #4
 1906 0ebc FEFFFFEB 		bl	CyU3PDebugPrint
 1907              	.LVL217:
 1908 0ec0 E7FFFFEA 		b	.L127
 1909              	.LVL218:
 1910              	.L121:
 450:../uvc.c      **** 					 if(CamMode == 1){//720p
 1911              		.loc 1 450 0
 1912 0ec4 2D34D6E5 		ldrb	r3, [r6, #1069]	@ zero_extendqisi2
 1913              	.LVL219:
 1914 0ec8 284A9FE5 		ldr	r4, .L194
 452:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 1915              		.loc 1 452 0
 1916 0ecc 020053E3 		cmp	r3, #2
 1917 0ed0 7F02008A 		bhi	.L128
 1918 0ed4 043083E2 		add	r3, r3, #4
 1919 0ed8 FF3003E2 		and	r3, r3, #255
 1920 0edc 0360A0E1 		mov	r6, r3
 1921              	.LVL220:
 1922              	.L129:
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1923              		.loc 1 460 0
 1924 0ee0 182A9FE5 		ldr	r2, .L194+8
 461:../uvc.c      **** 					 break;
 1925              		.loc 1 461 0
 1926 0ee4 0010A0E3 		mov	r1, #0
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1927              		.loc 1 460 0
 1928 0ee8 5830C2E5 		strb	r3, [r2, #88]
 461:../uvc.c      **** 					 break;
 1929              		.loc 1 461 0
 1930 0eec 5910C2E5 		strb	r1, [r2, #89]
 462:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 1931              		.loc 1 462 0
 1932 0ef0 FF80A0E3 		mov	r8, #255
 1933              	.LVL221:
 1934 0ef4 DAFFFFEA 		b	.L127
 1935              	.LVL222:
 1936              	.L120:
 481:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1937              		.loc 1 481 0
 1938 0ef8 007A9FE5 		ldr	r7, .L194+8
 1939 0efc 9130D7E5 		ldrb	r3, [r7, #145]	@ zero_extendqisi2
 1940 0f00 000053E3 		cmp	r3, #0
 1941 0f04 4D02000A 		beq	.L131
 1942 0f08 E6E3D6E5 		ldrb	lr, [r6, #998]	@ zero_extendqisi2
 1943              	.LVL223:
 1944              	.L132:
 494:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1945              		.loc 1 494 0
 1946 0f0c E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 495:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1947              		.loc 1 495 0
 1948 0f10 00C0A0E3 		mov	ip, #0
 500:../uvc.c      **** 					 break;
 1949              		.loc 1 500 0
 1950 0f14 00E08DE5 		str	lr, [sp]
 1951 0f18 04C08DE5 		str	ip, [sp, #4]
 1952 0f1c 0420A0E1 		mov	r2, r4
 1953 0f20 0C30A0E1 		mov	r3, ip
 1954 0f24 EC199FE5 		ldr	r1, .L194+32
 494:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1955              		.loc 1 494 0
 1956 0f28 5840C7E5 		strb	r4, [r7, #88]
 496:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1957              		.loc 1 496 0
 1958 0f2c 5AE0C7E5 		strb	lr, [r7, #90]
 495:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1959              		.loc 1 495 0
 1960 0f30 59C0C7E5 		strb	ip, [r7, #89]
 497:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 1961              		.loc 1 497 0
 1962 0f34 5BC0C7E5 		strb	ip, [r7, #91]
 1963              	.LVL224:
 500:../uvc.c      **** 					 break;
 1964              		.loc 1 500 0
 1965 0f38 0400A0E3 		mov	r0, #4
 1966 0f3c 0E80A0E1 		mov	r8, lr
 1967              	.LVL225:
 1968 0f40 0460A0E1 		mov	r6, r4
 1969 0f44 FEFFFFEB 		bl	CyU3PDebugPrint
 1970              	.LVL226:
 501:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 1971              		.loc 1 501 0
 1972 0f48 C5FFFFEA 		b	.L127
 1973              	.LVL227:
 1974              	.L117:
 531:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1975              		.loc 1 531 0
 1976 0f4c 0562D6E5 		ldrb	r6, [r6, #517]	@ zero_extendqisi2
 1977 0f50 A8399FE5 		ldr	r3, .L194+8
 1978 0f54 806046E2 		sub	r6, r6, #128
 1979 0f58 FF6006E2 		and	r6, r6, #255
 532:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 1980              		.loc 1 532 0
 1981 0f5c 0020A0E3 		mov	r2, #0
 531:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1982              		.loc 1 531 0
 1983 0f60 5860C3E5 		strb	r6, [r3, #88]
 532:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 1984              		.loc 1 532 0
 1985 0f64 5920C3E5 		strb	r2, [r3, #89]
 1986              	.LVL228:
 534:../uvc.c      **** 				 case WBTLevCtlID11:
 1987              		.loc 1 534 0
 1988 0f68 FF80A0E3 		mov	r8, #255
 1989              	.LVL229:
 1990 0f6c BCFFFFEA 		b	.L127
 1991              	.LVL230:
 1992              	.L119:
 537:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 1993              		.loc 1 537 0
 1994 0f70 88799FE5 		ldr	r7, .L194+8
 1995 0f74 8330D7E5 		ldrb	r3, [r7, #131]	@ zero_extendqisi2
 1996 0f78 000053E3 		cmp	r3, #0
 1997 0f7c 1F02000A 		beq	.L133
 538:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 1998              		.loc 1 538 0
 1999 0f80 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 539:../uvc.c      **** 		 	 		 }else{
 2000              		.loc 1 539 0
 2001 0f84 8E84D6E5 		ldrb	r8, [r6, #1166]	@ zero_extendqisi2
 2002              	.LVL231:
 2003 0f88 0320A0E1 		mov	r2, r3
 538:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2004              		.loc 1 538 0
 2005 0f8c 5830C7E5 		strb	r3, [r7, #88]
 539:../uvc.c      **** 		 	 		 }else{
 2006              		.loc 1 539 0
 2007 0f90 5A80C7E5 		strb	r8, [r7, #90]
 2008              	.LVL232:
 2009              	.L134:
 550:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2010              		.loc 1 550 0
 2011 0f94 0030A0E3 		mov	r3, #0
 2012 0f98 0260A0E1 		mov	r6, r2
 2013 0f9c 5930C7E5 		strb	r3, [r7, #89]
 551:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2014              		.loc 1 551 0
 2015 0fa0 5B30C7E5 		strb	r3, [r7, #91]
 2016              	.LVL233:
 554:../uvc.c      **** 				 case SaturCtlID6://TODO check sensor register
 2017              		.loc 1 554 0
 2018 0fa4 AEFFFFEA 		b	.L127
 2019              	.LVL234:
 2020              	.L193:
 651:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2021              		.loc 1 651 0
 2022 0fa8 50799FE5 		ldr	r7, .L194+8
 2023 0fac 9312D6E5 		ldrb	r1, [r6, #659]	@ zero_extendqisi2
 653:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2024              		.loc 1 653 0
 2025 0fb0 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 652:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2026              		.loc 1 652 0
 2027 0fb4 0030A0E3 		mov	r3, #0
 651:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2028              		.loc 1 651 0
 2029 0fb8 5810C7E5 		strb	r1, [r7, #88]
 653:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2030              		.loc 1 653 0
 2031 0fbc 5A20C7E5 		strb	r2, [r7, #90]
 652:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2032              		.loc 1 652 0
 2033 0fc0 5930C7E5 		strb	r3, [r7, #89]
 654:../uvc.c      **** 			 }else{
 2034              		.loc 1 654 0
 2035 0fc4 5B30C7E5 		strb	r3, [r7, #91]
 2036 0fc8 B4FEFFEA 		b	.L148
 2037              	.L116:
 558:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2038              		.loc 1 558 0
 2039 0fcc 2C799FE5 		ldr	r7, .L194+8
 2040 0fd0 048087E0 		add	r8, r7, r4
 2041              	.LVL235:
 2042 0fd4 7830D8E5 		ldrb	r3, [r8, #120]	@ zero_extendqisi2
 2043 0fd8 000053E3 		cmp	r3, #0
 2044 0fdc FD01000A 		beq	.L135
 2045 0fe0 844084E0 		add	r4, r4, r4, asl #1
 2046 0fe4 846186E0 		add	r6, r6, r4, asl #3
 2047 0fe8 8D31D6E5 		ldrb	r3, [r6, #397]	@ zero_extendqisi2
 2048              	.LVL236:
 2049              	.L136:
 569:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2050              		.loc 1 569 0
 2051 0fec 0020A0E3 		mov	r2, #0
 2052 0ff0 0360A0E1 		mov	r6, r3
 571:../uvc.c      **** 			 }
 2053              		.loc 1 571 0
 2054 0ff4 FF80A0E3 		mov	r8, #255
 568:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2055              		.loc 1 568 0
 2056 0ff8 5830C7E5 		strb	r3, [r7, #88]
 569:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2057              		.loc 1 569 0
 2058 0ffc 5920C7E5 		strb	r2, [r7, #89]
 2059              	.LVL237:
 571:../uvc.c      **** 			 }
 2060              		.loc 1 571 0
 2061 1000 97FFFFEA 		b	.L127
 2062              	.LVL238:
 2063              	.L166:
 818:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2064              		.loc 1 818 0
 2065 1004 10499FE5 		ldr	r4, .L194+36
 2066 1008 0010E0E3 		mvn	r1, #0
 2067 100c 1C0094E5 		ldr	r0, [r4, #28]
 2068 1010 FEFFFFEB 		bl	_txe_mutex_get
 2069              	.LVL239:
 819:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2070              		.loc 1 819 0
 2071 1014 14209DE5 		ldr	r2, [sp, #20]
 2072 1018 0010A0E3 		mov	r1, #0
 2073 101c 0A30A0E1 		mov	r3, r10
 2074 1020 00208DE5 		str	r2, [sp]
 2075 1024 0400A0E1 		mov	r0, r4
 2076 1028 0B20A0E1 		mov	r2, fp
 2077 102c 04108DE5 		str	r1, [sp, #4]
 2078 1030 2610A0E3 		mov	r1, #38
 2079 1034 FEFFFFEB 		bl	cmdSet
 2080              	.LVL240:
 820:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2081              		.loc 1 820 0
 2082 1038 1C0094E5 		ldr	r0, [r4, #28]
 2083 103c FEFFFFEB 		bl	_txe_mutex_put
 2084              	.LVL241:
 821:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2085              		.loc 1 821 0
 2086 1040 14309DE5 		ldr	r3, [sp, #20]
 2087 1044 888088E0 		add	r8, r8, r8, asl #1
 2088              	.LVL242:
 2089 1048 886186E0 		add	r6, r6, r8, asl #3
 822:../uvc.c      **** 							 break;
 2090              		.loc 1 822 0
 2091 104c 0120A0E3 		mov	r2, #1
 823:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2092              		.loc 1 823 0
 2093 1050 FF80A0E3 		mov	r8, #255
 821:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2094              		.loc 1 821 0
 2095 1054 0D30C6E5 		strb	r3, [r6, #13]
 2096 1058 0340A0E1 		mov	r4, r3
 822:../uvc.c      **** 							 break;
 2097              		.loc 1 822 0
 2098 105c 1020C6E5 		strb	r2, [r6, #16]
 2099 1060 18309DE5 		ldr	r3, [sp, #24]
 823:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2100              		.loc 1 823 0
 2101 1064 0860A0E1 		mov	r6, r8
 2102 1068 93FEFFEA 		b	.L115
 2103              	.LVL243:
 2104              	.L158:
 677:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2105              		.loc 1 677 0
 2106 106c 84389FE5 		ldr	r3, .L194
 678:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2107              		.loc 1 678 0
 2108 1070 000050E3 		cmp	r0, #0
 677:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2109              		.loc 1 677 0
 2110 1074 0D03C6E5 		strb	r0, [r6, #781]
 679:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2111              		.loc 1 679 0
 2112 1078 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 678:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2113              		.loc 1 678 0
 2114 107c FF01001A 		bne	.L168
 679:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2115              		.loc 1 679 0
 2116 1080 020052E3 		cmp	r2, #2
 2117 1084 08005213 		cmpne	r2, #8
 2118 1088 0300000A 		beq	.L169
 680:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2119              		.loc 1 680 0
 2120 108c 010052E3 		cmp	r2, #1
 681:../uvc.c      **** 									 }else{
 2121              		.loc 1 681 0
 2122 1090 0820A003 		moveq	r2, #8
 683:../uvc.c      **** 									 }
 2123              		.loc 1 683 0
 2124 1094 0220A013 		movne	r2, #2
 2125 1098 B524C3E5 		strb	r2, [r3, #1205]
 2126              	.LVL244:
 2127              	.L169:
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2128              		.loc 1 705 0
 2129 109c 78489FE5 		ldr	r4, .L194+36
 703:../uvc.c      **** 							 dataIdx = 0;
 2130              		.loc 1 703 0
 2131 10a0 0130A0E3 		mov	r3, #1
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2132              		.loc 1 705 0
 2133 10a4 1C0094E5 		ldr	r0, [r4, #28]
 2134 10a8 0010E0E3 		mvn	r1, #0
 703:../uvc.c      **** 							 dataIdx = 0;
 2135              		.loc 1 703 0
 2136 10ac 1033C6E5 		strb	r3, [r6, #784]
 2137              	.LVL245:
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2138              		.loc 1 705 0
 2139 10b0 FEFFFFEB 		bl	_txe_mutex_get
 2140              	.LVL246:
 706:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2141              		.loc 1 706 0
 2142 10b4 14209DE5 		ldr	r2, [sp, #20]
 2143 10b8 0010A0E3 		mov	r1, #0
 2144 10bc 0A30A0E1 		mov	r3, r10
 2145 10c0 00208DE5 		str	r2, [sp]
 2146 10c4 0400A0E1 		mov	r0, r4
 2147 10c8 0B20A0E1 		mov	r2, fp
 2148 10cc 04108DE5 		str	r1, [sp, #4]
 2149 10d0 1010A0E3 		mov	r1, #16
 2150 10d4 FEFFFFEB 		bl	cmdSet
 2151              	.LVL247:
 709:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 2152              		.loc 1 709 0
 2153 10d8 FF80A0E3 		mov	r8, #255
 2154              	.LVL248:
 707:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 2155              		.loc 1 707 0
 2156 10dc 1C0094E5 		ldr	r0, [r4, #28]
 2157 10e0 FEFFFFEB 		bl	_txe_mutex_put
 2158              	.LVL249:
 709:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 2159              		.loc 1 709 0
 2160 10e4 0860A0E1 		mov	r6, r8
 2161 10e8 14409DE5 		ldr	r4, [sp, #20]
 2162 10ec 18309DE5 		ldr	r3, [sp, #24]
 2163 10f0 71FEFFEA 		b	.L115
 2164              	.LVL250:
 2165              	.L157:
 886:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2166              		.loc 1 886 0
 2167 10f4 20489FE5 		ldr	r4, .L194+36
 2168 10f8 0010E0E3 		mvn	r1, #0
 2169 10fc 1C0094E5 		ldr	r0, [r4, #28]
 2170 1100 10C08DE5 		str	ip, [sp, #16]
 2171 1104 FEFFFFEB 		bl	_txe_mutex_get
 2172              	.LVL251:
 887:../uvc.c      **** 							 dataIdx++;
 2173              		.loc 1 887 0
 2174 1108 10C09DE5 		ldr	ip, [sp, #16]
 2175 110c 14009DE5 		ldr	r0, [sp, #20]
 2176 1110 0030A0E3 		mov	r3, #0
 2177 1114 0C20A0E1 		mov	r2, ip
 2178 1118 00008DE5 		str	r0, [sp]
 2179 111c 04308DE5 		str	r3, [sp, #4]
 2180 1120 0400A0E1 		mov	r0, r4
 2181 1124 0B10A0E3 		mov	r1, #11
 2182 1128 0A30A0E1 		mov	r3, r10
 2183 112c FEFFFFEB 		bl	cmdSet
 2184              	.LVL252:
 889:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2185              		.loc 1 889 0
 2186 1130 18209DE5 		ldr	r2, [sp, #24]
 2187 1134 0170A0E3 		mov	r7, #1
 2188 1138 0A30A0E1 		mov	r3, r10
 2189 113c 00208DE5 		str	r2, [sp]
 2190 1140 0400A0E1 		mov	r0, r4
 2191 1144 0B20A0E1 		mov	r2, fp
 2192 1148 0B10A0E3 		mov	r1, #11
 2193 114c 04708DE5 		str	r7, [sp, #4]
 2194 1150 FEFFFFEB 		bl	cmdSet
 2195              	.LVL253:
 890:../uvc.c      **** 
 2196              		.loc 1 890 0
 2197 1154 1C0094E5 		ldr	r0, [r4, #28]
 2198 1158 FEFFFFEB 		bl	_txe_mutex_put
 2199              	.LVL254:
 893:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2200              		.loc 1 893 0
 2201 115c 18009DE5 		ldr	r0, [sp, #24]
 2202 1160 14409DE5 		ldr	r4, [sp, #20]
 895:../uvc.c      **** 						 case MFreqCtlID4:
 2203              		.loc 1 895 0
 2204 1164 FF80A0E3 		mov	r8, #255
 2205              	.LVL255:
 894:../uvc.c      **** 							 break;
 2206              		.loc 1 894 0
 2207 1168 9872C6E5 		strb	r7, [r6, #664]
 892:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2208              		.loc 1 892 0
 2209 116c 8C44C6E5 		strb	r4, [r6, #1164]
 893:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2210              		.loc 1 893 0
 2211 1170 8E04C6E5 		strb	r0, [r6, #1166]
 2212 1174 0030A0E1 		mov	r3, r0
 895:../uvc.c      **** 						 case MFreqCtlID4:
 2213              		.loc 1 895 0
 2214 1178 0860A0E1 		mov	r6, r8
 2215 117c 4EFEFFEA 		b	.L115
 2216              	.LVL256:
 2217              	.L156:
 872:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2218              		.loc 1 872 0
 2219 1180 94479FE5 		ldr	r4, .L194+36
 2220 1184 0010E0E3 		mvn	r1, #0
 2221 1188 1C0094E5 		ldr	r0, [r4, #28]
 2222 118c 10C08DE5 		str	ip, [sp, #16]
 2223 1190 FEFFFFEB 		bl	_txe_mutex_get
 2224              	.LVL257:
 873:../uvc.c      **** 							 dataIdx++;
 2225              		.loc 1 873 0
 2226 1194 14009DE5 		ldr	r0, [sp, #20]
 2227 1198 0030A0E3 		mov	r3, #0
 2228 119c 00008DE5 		str	r0, [sp]
 2229 11a0 0B20A0E1 		mov	r2, fp
 2230 11a4 0400A0E1 		mov	r0, r4
 2231 11a8 04308DE5 		str	r3, [sp, #4]
 2232 11ac 0610A0E3 		mov	r1, #6
 2233 11b0 0A30A0E1 		mov	r3, r10
 2234 11b4 FEFFFFEB 		bl	cmdSet
 2235              	.LVL258:
 875:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2236              		.loc 1 875 0
 2237 11b8 14209DE5 		ldr	r2, [sp, #20]
 2238 11bc 10C09DE5 		ldr	ip, [sp, #16]
 2239 11c0 0170A0E3 		mov	r7, #1
 2240 11c4 0A30A0E1 		mov	r3, r10
 2241 11c8 00208DE5 		str	r2, [sp]
 2242 11cc 0400A0E1 		mov	r0, r4
 2243 11d0 0C20A0E1 		mov	r2, ip
 2244 11d4 0610A0E3 		mov	r1, #6
 2245 11d8 04708DE5 		str	r7, [sp, #4]
 2246 11dc FEFFFFEB 		bl	cmdSet
 2247              	.LVL259:
 876:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2248              		.loc 1 876 0
 2249 11e0 1C0094E5 		ldr	r0, [r4, #28]
 2250 11e4 FEFFFFEB 		bl	_txe_mutex_put
 2251              	.LVL260:
 2252 11e8 14409DE5 		ldr	r4, [sp, #20]
 879:../uvc.c      **** 
 2253              		.loc 1 879 0
 2254 11ec FF80A0E3 		mov	r8, #255
 2255              	.LVL261:
 878:../uvc.c      **** 							 break;
 2256              		.loc 1 878 0
 2257 11f0 2072C6E5 		strb	r7, [r6, #544]
 877:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2258              		.loc 1 877 0
 2259 11f4 1D42C6E5 		strb	r4, [r6, #541]
 2260 11f8 18309DE5 		ldr	r3, [sp, #24]
 879:../uvc.c      **** 
 2261              		.loc 1 879 0
 2262 11fc 0860A0E1 		mov	r6, r8
 2263 1200 2DFEFFEA 		b	.L115
 2264              	.LVL262:
 2265              	.L155:
 852:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2266              		.loc 1 852 0
 2267 1204 10479FE5 		ldr	r4, .L194+36
 2268 1208 0010E0E3 		mvn	r1, #0
 2269 120c 1C0094E5 		ldr	r0, [r4, #28]
 2270 1210 10C08DE5 		str	ip, [sp, #16]
 2271 1214 FEFFFFEB 		bl	_txe_mutex_get
 2272              	.LVL263:
 853:../uvc.c      **** 							 dataIdx++;
 2273              		.loc 1 853 0
 2274 1218 14009DE5 		ldr	r0, [sp, #20]
 2275 121c 0030A0E3 		mov	r3, #0
 2276 1220 801040E2 		sub	r1, r0, #128
 2277 1224 FF1001E2 		and	r1, r1, #255
 2278 1228 0B20A0E1 		mov	r2, fp
 2279 122c 00108DE5 		str	r1, [sp]
 2280 1230 0400A0E1 		mov	r0, r4
 2281 1234 04308DE5 		str	r3, [sp, #4]
 2282 1238 0510A0E3 		mov	r1, #5
 2283 123c 0A30A0E1 		mov	r3, r10
 2284 1240 FEFFFFEB 		bl	cmdSet
 2285              	.LVL264:
 855:../uvc.c      **** 							 dataIdx++;
 2286              		.loc 1 855 0
 2287 1244 14209DE5 		ldr	r2, [sp, #20]
 2288 1248 0190A0E3 		mov	r9, #1
 2289 124c 763042E2 		sub	r3, r2, #118
 2290 1250 FF3003E2 		and	r3, r3, #255
 2291 1254 00308DE5 		str	r3, [sp]
 2292 1258 0400A0E1 		mov	r0, r4
 2293 125c 0510A0E3 		mov	r1, #5
 2294 1260 DC20A0E3 		mov	r2, #220
 2295 1264 0A30A0E1 		mov	r3, r10
 2296 1268 04908DE5 		str	r9, [sp, #4]
 2297 126c FEFFFFEB 		bl	cmdSet
 2298              	.LVL265:
 857:../uvc.c      **** 							 dataIdx++;
 2299              		.loc 1 857 0
 2300 1270 14309DE5 		ldr	r3, [sp, #20]
 2301 1274 0400A0E1 		mov	r0, r4
 2302 1278 7E2083E2 		add	r2, r3, #126
 2303 127c FF2002E2 		and	r2, r2, #255
 2304 1280 0230A0E3 		mov	r3, #2
 2305 1284 00208DE5 		str	r2, [sp]
 2306 1288 04308DE5 		str	r3, [sp, #4]
 2307 128c 0510A0E3 		mov	r1, #5
 2308 1290 DE20A0E3 		mov	r2, #222
 2309 1294 0A30A0E1 		mov	r3, r10
 2310 1298 FEFFFFEB 		bl	cmdSet
 2311              	.LVL266:
 859:../uvc.c      **** 							 dataIdx++;
 2312              		.loc 1 859 0
 2313 129c 14009DE5 		ldr	r0, [sp, #20]
 2314 12a0 0330A0E3 		mov	r3, #3
 2315 12a4 722080E2 		add	r2, r0, #114
 2316 12a8 FF2002E2 		and	r2, r2, #255
 2317 12ac 00208DE5 		str	r2, [sp]
 2318 12b0 0400A0E1 		mov	r0, r4
 2319 12b4 04308DE5 		str	r3, [sp, #4]
 2320 12b8 0510A0E3 		mov	r1, #5
 2321 12bc E020A0E3 		mov	r2, #224
 2322 12c0 0A30A0E1 		mov	r3, r10
 2323 12c4 FEFFFFEB 		bl	cmdSet
 2324              	.LVL267:
 861:../uvc.c      **** 							 dataIdx++;
 2325              		.loc 1 861 0
 2326 12c8 14309DE5 		ldr	r3, [sp, #20]
 2327 12cc 0400A0E1 		mov	r0, r4
 2328 12d0 6F2043E2 		sub	r2, r3, #111
 2329 12d4 FF2002E2 		and	r2, r2, #255
 2330 12d8 0430A0E3 		mov	r3, #4
 2331 12dc 00208DE5 		str	r2, [sp]
 2332 12e0 04308DE5 		str	r3, [sp, #4]
 2333 12e4 0510A0E3 		mov	r1, #5
 2334 12e8 DD20A0E3 		mov	r2, #221
 2335 12ec 0A30A0E1 		mov	r3, r10
 2336 12f0 FEFFFFEB 		bl	cmdSet
 2337              	.LVL268:
 863:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2338              		.loc 1 863 0
 2339 12f4 5800D7E5 		ldrb	r0, [r7, #88]	@ zero_extendqisi2
 2340 12f8 10C09DE5 		ldr	ip, [sp, #16]
 2341 12fc 7F0080E2 		add	r0, r0, #127
 2342 1300 0510A0E3 		mov	r1, #5
 2343 1304 FF0000E2 		and	r0, r0, #255
 2344 1308 0A30A0E1 		mov	r3, r10
 2345 130c 0C20A0E1 		mov	r2, ip
 2346 1310 00008DE5 		str	r0, [sp]
 2347 1314 04108DE5 		str	r1, [sp, #4]
 2348 1318 0400A0E1 		mov	r0, r4
 2349 131c FEFFFFEB 		bl	cmdSet
 2350              	.LVL269:
 864:../uvc.c      **** 
 2351              		.loc 1 864 0
 2352 1320 1C0094E5 		ldr	r0, [r4, #28]
 2353 1324 FEFFFFEB 		bl	_txe_mutex_put
 2354              	.LVL270:
 866:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2355              		.loc 1 866 0
 2356 1328 5830D7E5 		ldrb	r3, [r7, #88]	@ zero_extendqisi2
 868:../uvc.c      **** 						 case SaturCtlID6:
 2357              		.loc 1 868 0
 2358 132c FF80A0E3 		mov	r8, #255
 2359              	.LVL271:
 866:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2360              		.loc 1 866 0
 2361 1330 803043E2 		sub	r3, r3, #128
 2362 1334 0532C6E5 		strb	r3, [r6, #517]
 867:../uvc.c      **** 							 break;
 2363              		.loc 1 867 0
 2364 1338 0892C6E5 		strb	r9, [r6, #520]
 2365 133c 14409DE5 		ldr	r4, [sp, #20]
 2366 1340 18309DE5 		ldr	r3, [sp, #24]
 868:../uvc.c      **** 						 case SaturCtlID6:
 2367              		.loc 1 868 0
 2368 1344 0860A0E1 		mov	r6, r8
 2369 1348 DBFDFFEA 		b	.L115
 2370              	.LVL272:
 2371              	.L154:
 904:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2372              		.loc 1 904 0
 2373 134c C8459FE5 		ldr	r4, .L194+36
 898:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 2374              		.loc 1 898 0
 2375 1350 017040E2 		sub	r7, r0, #1
 2376 1354 FF7007E2 		and	r7, r7, #255
 2377              	.LVL273:
 902:../uvc.c      **** 
 2378              		.loc 1 902 0
 2379 1358 020057E3 		cmp	r7, #2
 904:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2380              		.loc 1 904 0
 2381 135c 1C0094E5 		ldr	r0, [r4, #28]
 2382 1360 0010E0E3 		mvn	r1, #0
 902:../uvc.c      **** 
 2383              		.loc 1 902 0
 2384 1364 0170A083 		movhi	r7, #1
 2385              	.LVL274:
 904:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2386              		.loc 1 904 0
 2387 1368 FEFFFFEB 		bl	_txe_mutex_get
 2388              	.LVL275:
 905:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2389              		.loc 1 905 0
 2390 136c 0010A0E3 		mov	r1, #0
 2391 1370 0B20A0E1 		mov	r2, fp
 2392 1374 0A30A0E1 		mov	r3, r10
 2393 1378 0400A0E1 		mov	r0, r4
 2394 137c 04108DE5 		str	r1, [sp, #4]
 2395 1380 00708DE5 		str	r7, [sp]
 2396 1384 0410A0E3 		mov	r1, #4
 2397 1388 FEFFFFEB 		bl	cmdSet
 2398              	.LVL276:
 906:../uvc.c      **** 
 2399              		.loc 1 906 0
 2400 138c 1C0094E5 		ldr	r0, [r4, #28]
 2401 1390 FEFFFFEB 		bl	_txe_mutex_put
 2402              	.LVL277:
 910:../uvc.c      **** 					 	 case BLCCtlID0:
 2403              		.loc 1 910 0
 2404 1394 FF80A0E3 		mov	r8, #255
 2405              	.LVL278:
 909:../uvc.c      **** 							 break;
 2406              		.loc 1 909 0
 2407 1398 0120A0E3 		mov	r2, #1
 908:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2408              		.loc 1 908 0
 2409 139c ED71C6E5 		strb	r7, [r6, #493]
 909:../uvc.c      **** 							 break;
 2410              		.loc 1 909 0
 2411 13a0 F021C6E5 		strb	r2, [r6, #496]
 2412 13a4 14409DE5 		ldr	r4, [sp, #20]
 2413 13a8 18309DE5 		ldr	r3, [sp, #24]
 910:../uvc.c      **** 					 	 case BLCCtlID0:
 2414              		.loc 1 910 0
 2415 13ac 0860A0E1 		mov	r6, r8
 2416 13b0 C1FDFFEA 		b	.L115
 2417              	.LVL279:
 2418              	.L152:
 912:../uvc.c      **** 							 if(Data0 == 3)
 2419              		.loc 1 912 0
 2420 13b4 3C359FE5 		ldr	r3, .L194
 913:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2421              		.loc 1 913 0
 2422 13b8 030050E3 		cmp	r0, #3
 914:../uvc.c      **** 							 else
 2423              		.loc 1 914 0
 2424 13bc 0120A003 		moveq	r2, #1
 912:../uvc.c      **** 							 if(Data0 == 3)
 2425              		.loc 1 912 0
 2426 13c0 8D01C6E5 		strb	r0, [r6, #397]
 914:../uvc.c      **** 							 else
 2427              		.loc 1 914 0
 2428 13c4 B8208705 		streq	r2, [r7, #184]
 917:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2429              		.loc 1 917 0
 2430 13c8 9021C305 		streqb	r2, [r3, #400]
 913:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2431              		.loc 1 913 0
 2432 13cc 0800000A 		beq	.L179
 920:../uvc.c      **** 					 				 ;//Data0 += 4;
 2433              		.loc 1 920 0
 2434 13d0 14009DE5 		ldr	r0, [sp, #20]
 916:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2435              		.loc 1 916 0
 2436 13d4 0010A0E3 		mov	r1, #0
 920:../uvc.c      **** 					 				 ;//Data0 += 4;
 2437              		.loc 1 920 0
 2438 13d8 010050E3 		cmp	r0, #1
 917:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2439              		.loc 1 917 0
 2440 13dc 0120A0E3 		mov	r2, #1
 2441 13e0 0060A091 		movls	r6, r0
 916:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2442              		.loc 1 916 0
 2443 13e4 B81087E5 		str	r1, [r7, #184]
 917:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2444              		.loc 1 917 0
 2445 13e8 9021C3E5 		strb	r2, [r3, #400]
 920:../uvc.c      **** 					 				 ;//Data0 += 4;
 2446              		.loc 1 920 0
 2447 13ec 0640A091 		movls	r4, r6
 2448 13f0 0800009A 		bls	.L180
 2449              	.L179:
 923:../uvc.c      **** 									Data0 = 0; //set to default.
 2450              		.loc 1 923 0
 2451 13f4 14409DE5 		ldr	r4, [sp, #20]
 2452 13f8 0120A0E3 		mov	r2, #1
 2453 13fc 0430A0E1 		mov	r3, r4
 2454 1400 0400A0E3 		mov	r0, #4
 2455 1404 14159FE5 		ldr	r1, .L194+40
 2456 1408 FEFFFFEB 		bl	CyU3PDebugPrint
 2457              	.LVL280:
 2458 140c 0020A0E3 		mov	r2, #0
 924:../uvc.c      **** 					 			 }
 2459              		.loc 1 924 0
 2460 1410 0260A0E1 		mov	r6, r2
 923:../uvc.c      **** 									Data0 = 0; //set to default.
 2461              		.loc 1 923 0
 2462 1414 14208DE5 		str	r2, [sp, #20]
 2463              	.LVL281:
 2464              	.L180:
 929:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2465              		.loc 1 929 0
 2466 1418 FC849FE5 		ldr	r8, .L194+36
 2467              	.LVL282:
 2468 141c 0010E0E3 		mvn	r1, #0
 2469 1420 1C0098E5 		ldr	r0, [r8, #28]
 2470 1424 FEFFFFEB 		bl	_txe_mutex_get
 2471              	.LVL283:
 930:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2472              		.loc 1 930 0
 2473 1428 14309DE5 		ldr	r3, [sp, #20]
 2474 142c 0010A0E3 		mov	r1, #0
 2475 1430 0B20A0E1 		mov	r2, fp
 2476 1434 04108DE5 		str	r1, [sp, #4]
 2477 1438 00308DE5 		str	r3, [sp]
 2478 143c 0800A0E1 		mov	r0, r8
 2479 1440 0A30A0E1 		mov	r3, r10
 2480 1444 FEFFFFEB 		bl	cmdSet
 2481              	.LVL284:
 931:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2482              		.loc 1 931 0
 2483 1448 1C0098E5 		ldr	r0, [r8, #28]
 2484 144c FEFFFFEB 		bl	_txe_mutex_put
 2485              	.LVL285:
 932:../uvc.c      **** 
 2486              		.loc 1 932 0
 2487 1450 5A00D7E5 		ldrb	r0, [r7, #90]	@ zero_extendqisi2
 2488 1454 5B10D7E5 		ldrb	r1, [r7, #91]	@ zero_extendqisi2
 2489 1458 B83097E5 		ldr	r3, [r7, #184]
 2490 145c 0620A0E1 		mov	r2, r6
 2491 1460 03008DE8 		stmia	sp, {r0, r1}
 2492 1464 B8149FE5 		ldr	r1, .L194+44
 2493 1468 0400A0E3 		mov	r0, #4
 934:../uvc.c      **** 						 default:
 2494              		.loc 1 934 0
 2495 146c FF80A0E3 		mov	r8, #255
 932:../uvc.c      **** 
 2496              		.loc 1 932 0
 2497 1470 FEFFFFEB 		bl	CyU3PDebugPrint
 2498              	.LVL286:
 934:../uvc.c      **** 						 default:
 2499              		.loc 1 934 0
 2500 1474 0860A0E1 		mov	r6, r8
 2501 1478 18309DE5 		ldr	r3, [sp, #24]
 2502 147c 8EFDFFEA 		b	.L115
 2503              	.LVL287:
 2504              	.L162:
 761:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2505              		.loc 1 761 0
 2506 1480 94449FE5 		ldr	r4, .L194+36
 2507 1484 0010E0E3 		mvn	r1, #0
 2508 1488 1C0094E5 		ldr	r0, [r4, #28]
 2509 148c FEFFFFEB 		bl	_txe_mutex_get
 2510              	.LVL288:
 762:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2511              		.loc 1 762 0
 2512 1490 14209DE5 		ldr	r2, [sp, #20]
 2513 1494 0010A0E3 		mov	r1, #0
 2514 1498 01C072E2 		rsbs	ip, r2, #1
 2515 149c 00C0A033 		movcc	ip, #0
 2516 14a0 0B20A0E1 		mov	r2, fp
 2517 14a4 0A30A0E1 		mov	r3, r10
 2518 14a8 0400A0E1 		mov	r0, r4
 2519 14ac 00C08DE5 		str	ip, [sp]
 2520 14b0 04108DE5 		str	r1, [sp, #4]
 2521 14b4 1E10A0E3 		mov	r1, #30
 2522 14b8 FEFFFFEB 		bl	cmdSet
 2523              	.LVL289:
 763:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2524              		.loc 1 763 0
 2525 14bc 1C0094E5 		ldr	r0, [r4, #28]
 2526 14c0 FEFFFFEB 		bl	_txe_mutex_put
 2527              	.LVL290:
 765:../uvc.c      **** 						 case ExtI2CCtlID15:
 2528              		.loc 1 765 0
 2529 14c4 FF80A0E3 		mov	r8, #255
 2530              	.LVL291:
 764:../uvc.c      **** 							 break;
 2531              		.loc 1 764 0
 2532 14c8 0120A0E3 		mov	r2, #1
 2533 14cc 6024C6E5 		strb	r2, [r6, #1120]
 2534 14d0 14409DE5 		ldr	r4, [sp, #20]
 2535 14d4 18309DE5 		ldr	r3, [sp, #24]
 765:../uvc.c      **** 						 case ExtI2CCtlID15:
 2536              		.loc 1 765 0
 2537 14d8 0860A0E1 		mov	r6, r8
 2538 14dc 76FDFFEA 		b	.L115
 2539              	.LVL292:
 2540              	.L161:
 674:../uvc.c      **** 					 {
 2541              		.loc 1 674 0
 2542 14e0 FF80A0E3 		mov	r8, #255
 2543              	.LVL293:
 2544 14e4 0040A0E1 		mov	r4, r0
 2545              	.LVL294:
 2546 14e8 0860A0E1 		mov	r6, r8
 2547 14ec 72FDFFEA 		b	.L115
 2548              	.LVL295:
 2549              	.L160:
 728:../uvc.c      **** 							 if(WDRflag)
 2550              		.loc 1 728 0
 2551 14f0 24449FE5 		ldr	r4, .L194+36
 2552 14f4 0020A0E1 		mov	r2, r0
 2553 14f8 0010E0E3 		mvn	r1, #0
 727:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2554              		.loc 1 727 0
 2555 14fc 0130A0E3 		mov	r3, #1
 728:../uvc.c      **** 							 if(WDRflag)
 2556              		.loc 1 728 0
 2557 1500 1C0094E5 		ldr	r0, [r4, #28]
 726:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2558              		.loc 1 726 0
 2559 1504 FD23C6E5 		strb	r2, [r6, #1021]
 727:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2560              		.loc 1 727 0
 2561 1508 0034C6E5 		strb	r3, [r6, #1024]
 728:../uvc.c      **** 							 if(WDRflag)
 2562              		.loc 1 728 0
 2563 150c 10C08DE5 		str	ip, [sp, #16]
 2564 1510 FEFFFFEB 		bl	_txe_mutex_get
 2565              	.LVL296:
 729:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2566              		.loc 1 729 0
 2567 1514 B83097E5 		ldr	r3, [r7, #184]
 2568 1518 10C09DE5 		ldr	ip, [sp, #16]
 2569 151c 000053E3 		cmp	r3, #0
 730:../uvc.c      **** 							 else
 2570              		.loc 1 730 0
 2571 1520 14309D15 		ldrne	r3, [sp, #20]
 732:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2572              		.loc 1 732 0
 2573 1524 14009D05 		ldreq	r0, [sp, #20]
 730:../uvc.c      **** 							 else
 2574              		.loc 1 730 0
 2575 1528 0010A013 		movne	r1, #0
 2576 152c 00308D15 		strne	r3, [sp]
 2577 1530 0C20A011 		movne	r2, ip
 2578 1534 0A30A011 		movne	r3, r10
 732:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2579              		.loc 1 732 0
 2580 1538 0B20A001 		moveq	r2, fp
 734:../uvc.c      **** 						 case ExtCamMCtlID12:
 2581              		.loc 1 734 0
 2582 153c FF80A0E3 		mov	r8, #255
 2583              	.LVL297:
 2584 1540 0860A0E1 		mov	r6, r8
 732:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2585              		.loc 1 732 0
 2586 1544 09008D08 		stmeqia	sp, {r0, r3}
 730:../uvc.c      **** 							 else
 2587              		.loc 1 730 0
 2588 1548 04108D15 		strne	r1, [sp, #4]
 732:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2589              		.loc 1 732 0
 2590 154c 0A30A001 		moveq	r3, r10
 2591 1550 1A10A0E3 		mov	r1, #26
 2592 1554 0400A0E1 		mov	r0, r4
 2593 1558 FEFFFFEB 		bl	cmdSet
 2594              	.LVL298:
 733:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2595              		.loc 1 733 0
 2596 155c 1C0094E5 		ldr	r0, [r4, #28]
 2597 1560 FEFFFFEB 		bl	_txe_mutex_put
 2598              	.LVL299:
 734:../uvc.c      **** 						 case ExtCamMCtlID12:
 2599              		.loc 1 734 0
 2600 1564 5A00D7E5 		ldrb	r0, [r7, #90]	@ zero_extendqisi2
 2601 1568 5B10D7E5 		ldrb	r1, [r7, #91]	@ zero_extendqisi2
 2602 156c 14409DE5 		ldr	r4, [sp, #20]
 2603 1570 B83097E5 		ldr	r3, [r7, #184]
 2604 1574 0420A0E1 		mov	r2, r4
 2605 1578 03008DE8 		stmia	sp, {r0, r1}
 2606 157c A4139FE5 		ldr	r1, .L194+48
 2607 1580 0400A0E3 		mov	r0, #4
 2608 1584 FEFFFFEB 		bl	CyU3PDebugPrint
 2609              	.LVL300:
 2610 1588 18309DE5 		ldr	r3, [sp, #24]
 2611 158c 4AFDFFEA 		b	.L115
 2612              	.LVL301:
 2613              	.L159:
 715:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2614              		.loc 1 715 0
 2615 1590 84439FE5 		ldr	r4, .L194+36
 2616 1594 0020A0E1 		mov	r2, r0
 711:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2617              		.loc 1 711 0
 2618 1598 E523C6E5 		strb	r2, [r6, #997]
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2619              		.loc 1 712 0
 2620 159c 18209DE5 		ldr	r2, [sp, #24]
 713:../uvc.c      **** 							 dataIdx = 0;
 2621              		.loc 1 713 0
 2622 15a0 0130A0E3 		mov	r3, #1
 715:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2623              		.loc 1 715 0
 2624 15a4 1C0094E5 		ldr	r0, [r4, #28]
 2625 15a8 0010E0E3 		mvn	r1, #0
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2626              		.loc 1 712 0
 2627 15ac E623C6E5 		strb	r2, [r6, #998]
 713:../uvc.c      **** 							 dataIdx = 0;
 2628              		.loc 1 713 0
 2629 15b0 E833C6E5 		strb	r3, [r6, #1000]
 2630              	.LVL302:
 715:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2631              		.loc 1 715 0
 2632 15b4 10C08DE5 		str	ip, [sp, #16]
 2633 15b8 FEFFFFEB 		bl	_txe_mutex_get
 2634              	.LVL303:
 719:../uvc.c      **** 							 }
 2635              		.loc 1 719 0
 2636 15bc 10C09DE5 		ldr	ip, [sp, #16]
 2637 15c0 18309DE5 		ldr	r3, [sp, #24]
 2638 15c4 0010A0E3 		mov	r1, #0
 2639 15c8 0C20A0E1 		mov	r2, ip
 2640 15cc 00308DE5 		str	r3, [sp]
 2641 15d0 0400A0E1 		mov	r0, r4
 2642 15d4 0A30A0E1 		mov	r3, r10
 2643 15d8 04108DE5 		str	r1, [sp, #4]
 2644 15dc 1910A0E3 		mov	r1, #25
 2645 15e0 FEFFFFEB 		bl	cmdSet
 2646              	.LVL304:
 721:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2647              		.loc 1 721 0
 2648 15e4 1C0094E5 		ldr	r0, [r4, #28]
 2649 15e8 FEFFFFEB 		bl	_txe_mutex_put
 2650              	.LVL305:
 722:../uvc.c      **** 							 break;
 2651              		.loc 1 722 0
 2652 15ec 5A00D7E5 		ldrb	r0, [r7, #90]	@ zero_extendqisi2
 2653 15f0 5B10D7E5 		ldrb	r1, [r7, #91]	@ zero_extendqisi2
 2654 15f4 5930D7E5 		ldrb	r3, [r7, #89]	@ zero_extendqisi2
 2655 15f8 5820D7E5 		ldrb	r2, [r7, #88]	@ zero_extendqisi2
 723:../uvc.c      **** 						 case ExtExRefCtlID10:
 2656              		.loc 1 723 0
 2657 15fc FF80A0E3 		mov	r8, #255
 2658              	.LVL306:
 722:../uvc.c      **** 							 break;
 2659              		.loc 1 722 0
 2660 1600 03008DE8 		stmia	sp, {r0, r1}
 2661 1604 20139FE5 		ldr	r1, .L194+52
 2662 1608 0400A0E3 		mov	r0, #4
 2663 160c FEFFFFEB 		bl	CyU3PDebugPrint
 2664              	.LVL307:
 723:../uvc.c      **** 						 case ExtExRefCtlID10:
 2665              		.loc 1 723 0
 2666 1610 0860A0E1 		mov	r6, r8
 2667 1614 14409DE5 		ldr	r4, [sp, #20]
 2668 1618 18309DE5 		ldr	r3, [sp, #24]
 2669 161c 26FDFFEA 		b	.L115
 2670              	.LVL308:
 2671              	.L164:
 796:../uvc.c      **** 						     /* end test */
 2672              		.loc 1 796 0
 2673 1620 F4429FE5 		ldr	r4, .L194+36
 2674 1624 0010E0E3 		mvn	r1, #0
 2675 1628 1C0094E5 		ldr	r0, [r4, #28]
 2676 162c 10C08DE5 		str	ip, [sp, #16]
 2677 1630 FEFFFFEB 		bl	_txe_mutex_get
 2678              	.LVL309:
 795:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2679              		.loc 1 795 0
 2680 1634 14309DE5 		ldr	r3, [sp, #20]
 798:../uvc.c      **** 							 dataIdx++;
 2681              		.loc 1 798 0
 2682 1638 0B20A0E1 		mov	r2, fp
 795:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2683              		.loc 1 795 0
 2684 163c 7F7003E2 		and	r7, r3, #127
 2685              	.LVL310:
 798:../uvc.c      **** 							 dataIdx++;
 2686              		.loc 1 798 0
 2687 1640 0030A0E3 		mov	r3, #0
 2688 1644 0400A0E1 		mov	r0, r4
 2689 1648 04308DE5 		str	r3, [sp, #4]
 2690 164c 2410A0E3 		mov	r1, #36
 2691 1650 0A30A0E1 		mov	r3, r10
 2692 1654 00708DE5 		str	r7, [sp]
 2693 1658 FEFFFFEB 		bl	cmdSet
 2694              	.LVL311:
 800:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2695              		.loc 1 800 0
 2696 165c 1C009DE5 		ldr	r0, [sp, #28]
 2697 1660 10C09DE5 		ldr	ip, [sp, #16]
 2698 1664 0190A0E3 		mov	r9, #1
 2699 1668 0C20A0E1 		mov	r2, ip
 2700 166c 0A30A0E1 		mov	r3, r10
 2701 1670 00008DE5 		str	r0, [sp]
 2702 1674 2410A0E3 		mov	r1, #36
 2703 1678 0400A0E1 		mov	r0, r4
 2704 167c 04908DE5 		str	r9, [sp, #4]
 2705 1680 FEFFFFEB 		bl	cmdSet
 2706              	.LVL312:
 801:../uvc.c      **** 							 getData1 = Data1;
 2707              		.loc 1 801 0
 2708 1684 1C0094E5 		ldr	r0, [r4, #28]
 2709 1688 FEFFFFEB 		bl	_txe_mutex_put
 2710              	.LVL313:
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2711              		.loc 1 805 0
 2712 168c 1C209DE5 		ldr	r2, [sp, #28]
 804:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2713              		.loc 1 804 0
 2714 1690 888088E0 		add	r8, r8, r8, asl #1
 2715              	.LVL314:
 2716 1694 886186E0 		add	r6, r6, r8, asl #3
 807:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 2717              		.loc 1 807 0
 2718 1698 FF80A0E3 		mov	r8, #255
 804:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2719              		.loc 1 804 0
 2720 169c 0D70C6E5 		strb	r7, [r6, #13]
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2721              		.loc 1 805 0
 2722 16a0 0E20C6E5 		strb	r2, [r6, #14]
 806:../uvc.c      **** 							 break;
 2723              		.loc 1 806 0
 2724 16a4 1090C6E5 		strb	r9, [r6, #16]
 2725 16a8 14409DE5 		ldr	r4, [sp, #20]
 2726 16ac 0230A0E1 		mov	r3, r2
 807:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 2727              		.loc 1 807 0
 2728 16b0 0860A0E1 		mov	r6, r8
 2729 16b4 00FDFFEA 		b	.L115
 2730              	.LVL315:
 2731              	.L163:
 767:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2732              		.loc 1 767 0 discriminator 1
 2733 16b8 000059E3 		cmp	r9, #0
 2734 16bc 0300000A 		beq	.L176
 2735 16c0 68029FE5 		ldr	r0, .L194+56
 2736 16c4 0920A0E1 		mov	r2, r9
 2737 16c8 0C1080E2 		add	r1, r0, #12
 2738 16cc FEFFFFEB 		bl	memcpy
 2739              	.LVL316:
 2740              	.L176:
 771:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 2741              		.loc 1 771 0
 2742 16d0 FF80A0E3 		mov	r8, #255
 2743              	.LVL317:
 770:../uvc.c      **** 							 break;
 2744              		.loc 1 770 0
 2745 16d4 FEFFFFEB 		bl	I2CCmdHandler
 2746              	.LVL318:
 771:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 2747              		.loc 1 771 0
 2748 16d8 0860A0E1 		mov	r6, r8
 2749 16dc 14409DE5 		ldr	r4, [sp, #20]
 2750              	.LVL319:
 2751 16e0 18309DE5 		ldr	r3, [sp, #24]
 2752 16e4 F4FCFFEA 		b	.L115
 2753              	.LVL320:
 2754              	.L165:
 810:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2755              		.loc 1 810 0
 2756 16e8 2C429FE5 		ldr	r4, .L194+36
 2757 16ec 0010E0E3 		mvn	r1, #0
 2758 16f0 1C0094E5 		ldr	r0, [r4, #28]
 2759 16f4 FEFFFFEB 		bl	_txe_mutex_get
 2760              	.LVL321:
 811:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2761              		.loc 1 811 0
 2762 16f8 14309DE5 		ldr	r3, [sp, #20]
 2763 16fc 0010A0E3 		mov	r1, #0
 2764 1700 0B20A0E1 		mov	r2, fp
 2765 1704 00308DE5 		str	r3, [sp]
 2766 1708 0400A0E1 		mov	r0, r4
 2767 170c 0A30A0E1 		mov	r3, r10
 2768 1710 04108DE5 		str	r1, [sp, #4]
 2769 1714 2510A0E3 		mov	r1, #37
 2770 1718 FEFFFFEB 		bl	cmdSet
 2771              	.LVL322:
 812:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2772              		.loc 1 812 0
 2773 171c 1C0094E5 		ldr	r0, [r4, #28]
 2774 1720 FEFFFFEB 		bl	_txe_mutex_put
 2775              	.LVL323:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2776              		.loc 1 813 0
 2777 1724 14009DE5 		ldr	r0, [sp, #20]
 2778 1728 888088E0 		add	r8, r8, r8, asl #1
 2779              	.LVL324:
 2780 172c 886186E0 		add	r6, r6, r8, asl #3
 814:../uvc.c      **** 							 break;
 2781              		.loc 1 814 0
 2782 1730 0120A0E3 		mov	r2, #1
 815:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 2783              		.loc 1 815 0
 2784 1734 FF80A0E3 		mov	r8, #255
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2785              		.loc 1 813 0
 2786 1738 0D00C6E5 		strb	r0, [r6, #13]
 814:../uvc.c      **** 							 break;
 2787              		.loc 1 814 0
 2788 173c 1020C6E5 		strb	r2, [r6, #16]
 2789 1740 0040A0E1 		mov	r4, r0
 2790 1744 18309DE5 		ldr	r3, [sp, #24]
 815:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 2791              		.loc 1 815 0
 2792 1748 0860A0E1 		mov	r6, r8
 2793 174c DAFCFFEA 		b	.L115
 2794              	.LVL325:
 2795              	.L151:
 938:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2796              		.loc 1 938 0
 2797 1750 C4719FE5 		ldr	r7, .L194+36
 2798 1754 0010E0E3 		mvn	r1, #0
 2799 1758 1C0097E5 		ldr	r0, [r7, #28]
 2800 175c FEFFFFEB 		bl	_txe_mutex_get
 2801              	.LVL326:
 939:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2802              		.loc 1 939 0
 2803 1760 14009DE5 		ldr	r0, [sp, #20]
 2804 1764 0010A0E3 		mov	r1, #0
 2805 1768 0B20A0E1 		mov	r2, fp
 2806 176c 0A30A0E1 		mov	r3, r10
 2807 1770 00008DE5 		str	r0, [sp]
 2808 1774 04108DE5 		str	r1, [sp, #4]
 2809 1778 0700A0E1 		mov	r0, r7
 2810 177c 0410A0E1 		mov	r1, r4
 2811 1780 FEFFFFEB 		bl	cmdSet
 2812              	.LVL327:
 940:../uvc.c      **** 
 2813              		.loc 1 940 0
 2814 1784 1C0097E5 		ldr	r0, [r7, #28]
 2815 1788 FEFFFFEB 		bl	_txe_mutex_put
 2816              	.LVL328:
 942:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2817              		.loc 1 942 0
 2818 178c 14309DE5 		ldr	r3, [sp, #20]
 2819 1790 844084E0 		add	r4, r4, r4, asl #1
 2820 1794 846186E0 		add	r6, r6, r4, asl #3
 943:../uvc.c      **** 							 break;
 2821              		.loc 1 943 0
 2822 1798 0120A0E3 		mov	r2, #1
 944:../uvc.c      **** 					 }
 2823              		.loc 1 944 0
 2824 179c FF80A0E3 		mov	r8, #255
 2825              	.LVL329:
 942:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2826              		.loc 1 942 0
 2827 17a0 8D31C6E5 		strb	r3, [r6, #397]
 2828 17a4 0340A0E1 		mov	r4, r3
 943:../uvc.c      **** 							 break;
 2829              		.loc 1 943 0
 2830 17a8 9021C6E5 		strb	r2, [r6, #400]
 2831 17ac 18309DE5 		ldr	r3, [sp, #24]
 944:../uvc.c      **** 					 }
 2832              		.loc 1 944 0
 2833 17b0 0860A0E1 		mov	r6, r8
 2834 17b4 C0FCFFEA 		b	.L115
 2835              	.LVL330:
 2836              	.L150:
 947:../uvc.c      **** 			   }
 2837              		.loc 1 947 0
 2838 17b8 FF80A0E3 		mov	r8, #255
 2839              	.LVL331:
 2840 17bc 0400A0E3 		mov	r0, #4
 2841              	.LVL332:
 2842 17c0 6C119FE5 		ldr	r1, .L194+60
 2843 17c4 FEFFFFEB 		bl	CyU3PDebugPrint
 2844              	.LVL333:
 2845 17c8 0860A0E1 		mov	r6, r8
 2846 17cc 0830A0E1 		mov	r3, r8
 2847 17d0 0840A0E1 		mov	r4, r8
 2848              	.LVL334:
 2849 17d4 B8FCFFEA 		b	.L115
 2850              	.LVL335:
 2851              	.L135:
 562:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 2852              		.loc 1 562 0
 2853 17d8 0B00A0E1 		mov	r0, fp
 2854              	.LVL336:
 2855 17dc 0A10A0E1 		mov	r1, r10
 2856 17e0 FEFFFFEB 		bl	SensorGetControl
 2857              	.LVL337:
 563:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2858              		.loc 1 563 0
 2859 17e4 844084E0 		add	r4, r4, r4, asl #1
 2860              	.LVL338:
 2861 17e8 846186E0 		add	r6, r6, r4, asl #3
 565:../uvc.c      **** 		 	 		 }
 2862              		.loc 1 565 0
 2863 17ec 0120A0E3 		mov	r2, #1
 2864 17f0 7820C8E5 		strb	r2, [r8, #120]
 2865 17f4 0030A0E1 		mov	r3, r0
 563:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2866              		.loc 1 563 0
 2867 17f8 8D01C6E5 		strb	r0, [r6, #397]
 2868 17fc FAFDFFEA 		b	.L136
 2869              	.LVL339:
 2870              	.L133:
 541:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 2871              		.loc 1 541 0
 2872 1800 0C00A0E1 		mov	r0, ip
 2873              	.LVL340:
 2874 1804 0A10A0E1 		mov	r1, r10
 2875 1808 FEFFFFEB 		bl	SensorGetControl
 2876              	.LVL341:
 542:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 2877              		.loc 1 542 0
 2878 180c 0A10A0E1 		mov	r1, r10
 541:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 2879              		.loc 1 541 0
 2880 1810 0040A0E1 		mov	r4, r0
 2881              	.LVL342:
 542:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 2882              		.loc 1 542 0
 2883 1814 0B00A0E1 		mov	r0, fp
 2884              	.LVL343:
 2885 1818 FEFFFFEB 		bl	SensorGetControl
 2886              	.LVL344:
 547:../uvc.c      **** 		 	 		 }
 2887              		.loc 1 547 0
 2888 181c 0130A0E3 		mov	r3, #1
 2889 1820 0420A0E1 		mov	r2, r4
 543:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2890              		.loc 1 543 0
 2891 1824 5840C7E5 		strb	r4, [r7, #88]
 544:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 2892              		.loc 1 544 0
 2893 1828 8C44C6E5 		strb	r4, [r6, #1164]
 547:../uvc.c      **** 		 	 		 }
 2894              		.loc 1 547 0
 2895 182c 8330C7E5 		strb	r3, [r7, #131]
 2896 1830 0080A0E1 		mov	r8, r0
 2897              	.LVL345:
 545:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 2898              		.loc 1 545 0
 2899 1834 5A00C7E5 		strb	r0, [r7, #90]
 546:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 2900              		.loc 1 546 0
 2901 1838 8E04C6E5 		strb	r0, [r6, #1166]
 2902 183c D4FDFFEA 		b	.L134
 2903              	.LVL346:
 2904              	.L131:
 485:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 2905              		.loc 1 485 0
 2906 1840 0A10A0E1 		mov	r1, r10
 2907 1844 0B00A0E1 		mov	r0, fp
 2908              	.LVL347:
 2909 1848 10C08DE5 		str	ip, [sp, #16]
 2910 184c FEFFFFEB 		bl	SensorGetControl
 2911              	.LVL348:
 489:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 2912              		.loc 1 489 0
 2913 1850 10C09DE5 		ldr	ip, [sp, #16]
 2914 1854 0A10A0E1 		mov	r1, r10
 486:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 2915              		.loc 1 486 0
 2916 1858 033000E2 		and	r3, r0, #3
 489:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 2917              		.loc 1 489 0
 2918 185c 0C00A0E1 		mov	r0, ip
 486:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 2919              		.loc 1 486 0
 2920 1860 5830C7E5 		strb	r3, [r7, #88]
 487:../uvc.c      **** 
 2921              		.loc 1 487 0
 2922 1864 E533C6E5 		strb	r3, [r6, #997]
 489:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 2923              		.loc 1 489 0
 2924 1868 FEFFFFEB 		bl	SensorGetControl
 2925              	.LVL349:
 491:../uvc.c      **** 		 	 		 }
 2926              		.loc 1 491 0
 2927 186c 0130A0E3 		mov	r3, #1
 2928 1870 9130C7E5 		strb	r3, [r7, #145]
 2929 1874 00E0A0E1 		mov	lr, r0
 490:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 2930              		.loc 1 490 0
 2931 1878 E603C6E5 		strb	r0, [r6, #998]
 2932 187c A2FDFFEA 		b	.L132
 2933              	.LVL350:
 2934              	.L168:
 687:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2935              		.loc 1 687 0
 2936 1880 011040E2 		sub	r1, r0, #1
 688:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2937              		.loc 1 688 0
 2938 1884 040052E3 		cmp	r2, #4
 2939 1888 01005213 		cmpne	r2, #1
 687:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2940              		.loc 1 687 0
 2941 188c FF1001E2 		and	r1, r1, #255
 2942              	.LVL351:
 688:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2943              		.loc 1 688 0
 2944 1890 0300000A 		beq	.L171
 689:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2945              		.loc 1 689 0
 2946 1894 080052E3 		cmp	r2, #8
 690:../uvc.c      **** 									 }else{
 2947              		.loc 1 690 0
 2948 1898 0120A003 		moveq	r2, #1
 692:../uvc.c      **** 									 }
 2949              		.loc 1 692 0
 2950 189c 0420A013 		movne	r2, #4
 2951 18a0 B524C3E5 		strb	r2, [r3, #1205]
 2952              	.L171:
 695:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2953              		.loc 1 695 0
 2954 18a4 070051E3 		cmp	r1, #7
 696:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2955              		.loc 1 696 0
 2956 18a8 88309F95 		ldrls	r3, .L194+64
 699:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2957              		.loc 1 699 0
 2958 18ac 0120A083 		movhi	r2, #1
 697:../uvc.c      **** 								 }else{
 2959              		.loc 1 697 0
 2960 18b0 81208390 		addls	r2, r3, r1, asl #1
 2961 18b4 0120D295 		ldrlsb	r2, [r2, #1]	@ zero_extendqisi2
 696:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2962              		.loc 1 696 0
 2963 18b8 8130D397 		ldrlsb	r3, [r3, r1, asl #1]	@ zero_extendqisi2
 700:../uvc.c      **** 								 }
 2964              		.loc 1 700 0
 2965 18bc 0030A083 		movhi	r3, #0
 697:../uvc.c      **** 								 }else{
 2966              		.loc 1 697 0
 2967 18c0 E624C695 		strlsb	r2, [r6, #1254]
 696:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2968              		.loc 1 696 0
 2969 18c4 E534C695 		strlsb	r3, [r6, #1253]
 699:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2970              		.loc 1 699 0
 2971 18c8 E524C685 		strhib	r2, [r6, #1253]
 700:../uvc.c      **** 								 }
 2972              		.loc 1 700 0
 2973 18cc E634C685 		strhib	r3, [r6, #1254]
 2974 18d0 F1FDFFEA 		b	.L169
 2975              	.LVL352:
 2976              	.L128:
 453:../uvc.c      **** 							sendData = 0; //set back to default
 2977              		.loc 1 453 0
 2978 18d4 0400A0E3 		mov	r0, #4
 2979              	.LVL353:
 2980 18d8 0120A0E3 		mov	r2, #1
 2981 18dc 3C109FE5 		ldr	r1, .L194+40
 455:../uvc.c      **** 						}
 2982              		.loc 1 455 0
 2983 18e0 0060A0E1 		mov	r6, r0
 453:../uvc.c      **** 							sendData = 0; //set back to default
 2984              		.loc 1 453 0
 2985 18e4 FEFFFFEB 		bl	CyU3PDebugPrint
 2986              	.LVL354:
 455:../uvc.c      **** 						}
 2987              		.loc 1 455 0
 2988 18e8 0020A0E3 		mov	r2, #0
 2989 18ec 0630A0E1 		mov	r3, r6
 2990 18f0 2D24C4E5 		strb	r2, [r4, #1069]
 2991 18f4 79FDFFEA 		b	.L129
 2992              	.L195:
 2993              		.align	2
 2994              	.L194:
 2995 18f8 00000000 		.word	.LANCHOR1
 2996 18fc 00000000 		.word	bRequest
 2997 1900 00000000 		.word	.LANCHOR0
 2998 1904 58000000 		.word	.LANCHOR0+88
 2999 1908 04030000 		.word	.LC18
 3000 190c 01000100 		.word	65537
 3001 1910 FF00FF00 		.word	16711935
 3002 1914 10020000 		.word	.LC12
 3003 1918 4C020000 		.word	.LC13
 3004 191c 00000000 		.word	cmdQu
 3005 1920 D8010000 		.word	.LC11
 3006 1924 BC020000 		.word	.LC16
 3007 1928 A0020000 		.word	.LC15
 3008 192c 74020000 		.word	.LC14
 3009 1930 4C000000 		.word	.LANCHOR0+76
 3010 1934 D4020000 		.word	.LC17
 3011 1938 00000000 		.word	.LANCHOR2
 3012              		.cfi_endproc
 3013              	.LFE2:
 3015              		.align	2
 3016              		.global	CTControlHandle
 3018              	CTControlHandle:
 3019              	.LFB3:
 963:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3020              		.loc 1 963 0
 3021              		.cfi_startproc
 3022              		@ args = 0, pretend = 0, frame = 24
 3023              		@ frame_needed = 0, uses_anonymous_args = 0
 3024              	.LVL355:
 3025 193c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3026              	.LCFI14:
 3027              		.cfi_def_cfa_offset 36
 3028              		.cfi_offset 4, -36
 3029              		.cfi_offset 5, -32
 3030              		.cfi_offset 6, -28
 3031              		.cfi_offset 7, -24
 3032              		.cfi_offset 8, -20
 3033              		.cfi_offset 9, -16
 3034              		.cfi_offset 10, -12
 3035              		.cfi_offset 11, -8
 3036              		.cfi_offset 14, -4
 982:../uvc.c      **** 
 3037              		.loc 1 982 0
 3038 1940 28B89FE5 		ldr	fp, .L234
 974:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3039              		.loc 1 974 0
 3040 1944 28389FE5 		ldr	r3, .L234+4
 982:../uvc.c      **** 
 3041              		.loc 1 982 0
 3042 1948 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
 974:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3043              		.loc 1 974 0
 3044 194c 8080A0E1 		mov	r8, r0, asl #1
 3045 1950 002088E0 		add	r2, r8, r0
 3046 1954 822183E0 		add	r2, r3, r2, asl #3
 984:../uvc.c      **** 		 {
 3047              		.loc 1 984 0
 3048 1958 830055E3 		cmp	r5, #131
 963:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3049              		.loc 1 963 0
 3050 195c 34D04DE2 		sub	sp, sp, #52
 3051              	.LCFI15:
 3052              		.cfi_def_cfa_offset 88
 963:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3053              		.loc 1 963 0
 3054 1960 0060A0E1 		mov	r6, r0
 974:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3055              		.loc 1 974 0
 3056 1964 9F94D2E5 		ldrb	r9, [r2, #1183]	@ zero_extendqisi2
 3057              	.LVL356:
 975:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 3058              		.loc 1 975 0
 3059 1968 90A4D2E5 		ldrb	r10, [r2, #1168]	@ zero_extendqisi2
 3060              	.LVL357:
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 3061              		.loc 1 977 0
 3062 196c 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3063              	.LVL358:
 984:../uvc.c      **** 		 {
 3064              		.loc 1 984 0
 3065 1970 8000000A 		beq	.L198
 3066 1974 2600009A 		bls	.L232
 3067 1978 850055E3 		cmp	r5, #133
 3068 197c 7200000A 		beq	.L203
 3069 1980 5000003A 		bcc	.L204
 3070 1984 860055E3 		cmp	r5, #134
 3071 1988 4300000A 		beq	.L205
 3072 198c 870055E3 		cmp	r5, #135
 3073 1990 5F00001A 		bne	.L197
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3074              		.loc 1 1046 0
 3075 1994 9BC4D2E5 		ldrb	ip, [r2, #1179]	@ zero_extendqisi2
 3076 1998 D8479FE5 		ldr	r4, .L234+8
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3077              		.loc 1 1047 0
 3078 199c 9C24D2E5 		ldrb	r2, [r2, #1180]	@ zero_extendqisi2
 3079              	.LVL359:
 3080              	.L231:
1024:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3081              		.loc 1 1024 0
 3082 19a0 0A1056E2 		subs	r1, r6, #10
 3083 19a4 006071E2 		rsbs	r6, r1, #0
 3084 19a8 0160B6E0 		adcs	r6, r6, r1
1026:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3085              		.loc 1 1026 0
 3086 19ac 0030A0E3 		mov	r3, #0
 3087              	.LVL360:
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3088              		.loc 1 1027 0
 3089 19b0 581084E2 		add	r1, r4, #88
 3090 19b4 0700A0E1 		mov	r0, r7
 3091              	.LVL361:
1024:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3092              		.loc 1 1024 0
 3093 19b8 5A60C4E5 		strb	r6, [r4, #90]
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3094              		.loc 1 1022 0
 3095 19bc 58C0C4E5 		strb	ip, [r4, #88]
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3096              		.loc 1 1023 0
 3097 19c0 5920C4E5 		strb	r2, [r4, #89]
1026:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3098              		.loc 1 1026 0
 3099 19c4 5B30C4E5 		strb	r3, [r4, #91]
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3100              		.loc 1 1027 0
 3101 19c8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3102              	.LVL362:
 3103 19cc 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
1029:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 3104              		.loc 1 1029 0
 3105 19d0 FF80A0E3 		mov	r8, #255
 3106 19d4 0860A0E1 		mov	r6, r8
 3107              	.LVL363:
 3108              	.L207:
1197:../uvc.c      **** }
 3109              		.loc 1 1197 0
 3110 19d8 5A10D4E5 		ldrb	r1, [r4, #90]	@ zero_extendqisi2
 3111 19dc FFC0A0E3 		mov	ip, #255
 3112 19e0 04108DE5 		str	r1, [sp, #4]
 3113 19e4 10108DE5 		str	r1, [sp, #16]
 3114 19e8 08008DE5 		str	r0, [sp, #8]
 3115 19ec 00808DE5 		str	r8, [sp]
 3116 19f0 14708DE5 		str	r7, [sp, #20]
 3117 19f4 0520A0E1 		mov	r2, r5
 3118 19f8 0630A0E1 		mov	r3, r6
 3119 19fc 0CC08DE5 		str	ip, [sp, #12]
 3120 1a00 74179FE5 		ldr	r1, .L234+12
 3121 1a04 0400A0E3 		mov	r0, #4
 3122 1a08 FEFFFFEB 		bl	CyU3PDebugPrint
 3123              	.LVL364:
1198:../uvc.c      **** 
 3124              		.loc 1 1198 0
 3125 1a0c 34D08DE2 		add	sp, sp, #52
 3126              		@ sp needed
 3127 1a10 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 3128              	.LVL365:
 3129              	.L232:
 984:../uvc.c      **** 		 {
 3130              		.loc 1 984 0
 3131 1a14 810055E3 		cmp	r5, #129
 3132 1a18 2E00000A 		beq	.L200
 3133 1a1c 1A00008A 		bhi	.L201
 3134 1a20 010055E3 		cmp	r5, #1
 3135 1a24 3A00001A 		bne	.L197
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 3136              		.loc 1 1055 0
 3137 1a28 48479FE5 		ldr	r4, .L234+8
 3138 1a2c 2E208DE2 		add	r2, sp, #46
 3139              	.LVL366:
 3140 1a30 2000A0E3 		mov	r0, #32
 3141              	.LVL367:
 3142 1a34 581084E2 		add	r1, r4, #88
 3143 1a38 18308DE5 		str	r3, [sp, #24]
 3144 1a3c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3145              	.LVL368:
1057:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3146              		.loc 1 1057 0
 3147 1a40 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
1061:../uvc.c      **** 			  {
 3148              		.loc 1 1061 0
 3149 1a44 012046E2 		sub	r2, r6, #1
1057:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3150              		.loc 1 1057 0
 3151 1a48 1CC08DE5 		str	ip, [sp, #28]
 3152              	.LVL369:
1058:../uvc.c      **** 			  value = Data1;
 3153              		.loc 1 1058 0
 3154 1a4c 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
1061:../uvc.c      **** 			  {
 3155              		.loc 1 1061 0
 3156 1a50 18309DE5 		ldr	r3, [sp, #24]
1058:../uvc.c      **** 			  value = Data1;
 3157              		.loc 1 1058 0
 3158 1a54 20C08DE5 		str	ip, [sp, #32]
 3159              	.LVL370:
1061:../uvc.c      **** 			  {
 3160              		.loc 1 1061 0
 3161 1a58 090052E3 		cmp	r2, #9
 3162 1a5c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3163 1a60 1D0100EA 		b	.L208
 3164              	.L210:
 3165 1a64 941E0000 		.word	.L209
 3166 1a68 DC1E0000 		.word	.L208
 3167 1a6c 941C0000 		.word	.L211
 3168 1a70 DC1E0000 		.word	.L208
 3169 1a74 DC1E0000 		.word	.L208
 3170 1a78 DC1E0000 		.word	.L208
 3171 1a7c 041C0000 		.word	.L212
 3172 1a80 DC1E0000 		.word	.L208
 3173 1a84 DC1E0000 		.word	.L208
 3174 1a88 881B0000 		.word	.L213
 3175              	.LVL371:
 3176              	.L201:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3177              		.loc 1 1013 0
 3178 1a8c 93C4D2E5 		ldrb	ip, [r2, #1171]	@ zero_extendqisi2
 3179 1a90 E0469FE5 		ldr	r4, .L234+8
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3180              		.loc 1 1014 0
 3181 1a94 9424D2E5 		ldrb	r2, [r2, #1172]	@ zero_extendqisi2
 3182              	.LVL372:
 3183 1a98 C0FFFFEA 		b	.L231
 3184              	.LVL373:
 3185              	.L205:
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3186              		.loc 1 1040 0
 3187 1a9c D4469FE5 		ldr	r4, .L234+8
 3188 1aa0 9934D2E5 		ldrb	r3, [r2, #1177]	@ zero_extendqisi2
 3189 1aa4 0410A0E1 		mov	r1, r4
 3190 1aa8 5830E1E5 		strb	r3, [r1, #88]!
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3191              		.loc 1 1041 0
 3192 1aac 0100A0E3 		mov	r0, #1
 3193              	.LVL374:
1044:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3194              		.loc 1 1044 0
 3195 1ab0 FF80A0E3 		mov	r8, #255
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3196              		.loc 1 1041 0
 3197 1ab4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3198              	.LVL375:
1044:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3199              		.loc 1 1044 0
 3200 1ab8 0860A0E1 		mov	r6, r8
 3201 1abc 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 3202 1ac0 0170A0E3 		mov	r7, #1
 3203 1ac4 C3FFFFEA 		b	.L207
 3204              	.LVL376:
 3205              	.L204:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3206              		.loc 1 1031 0
 3207 1ac8 97C4D2E5 		ldrb	ip, [r2, #1175]	@ zero_extendqisi2
 3208 1acc A4469FE5 		ldr	r4, .L234+8
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3209              		.loc 1 1032 0
 3210 1ad0 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 3211              	.LVL377:
 3212 1ad4 B1FFFFEA 		b	.L231
 3213              	.LVL378:
 3214              	.L200:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3215              		.loc 1 998 0
 3216 1ad8 98469FE5 		ldr	r4, .L234+8
 3217 1adc 9D94D2E5 		ldrb	r9, [r2, #1181]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3218              		.loc 1 999 0
 3219 1ae0 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3220              		.loc 1 1000 0
 3221 1ae4 0030A0E3 		mov	r3, #0
1006:../uvc.c      **** 
 3222              		.loc 1 1006 0
 3223 1ae8 581084E2 		add	r1, r4, #88
 3224 1aec 0700A0E1 		mov	r0, r7
 3225              	.LVL379:
1011:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3226              		.loc 1 1011 0
 3227 1af0 FF80A0E3 		mov	r8, #255
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3228              		.loc 1 999 0
 3229 1af4 59C0C4E5 		strb	ip, [r4, #89]
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3230              		.loc 1 998 0
 3231 1af8 5890C4E5 		strb	r9, [r4, #88]
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3232              		.loc 1 1000 0
 3233 1afc 5A30C4E5 		strb	r3, [r4, #90]
1001:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3234              		.loc 1 1001 0
 3235 1b00 5B30C4E5 		strb	r3, [r4, #91]
 3236              	.LVL380:
1011:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3237              		.loc 1 1011 0
 3238 1b04 0860A0E1 		mov	r6, r8
 3239              	.LVL381:
1006:../uvc.c      **** 
 3240              		.loc 1 1006 0
 3241 1b08 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3242              	.LVL382:
 3243 1b0c 0900A0E1 		mov	r0, r9
1011:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3244              		.loc 1 1011 0
 3245 1b10 B0FFFFEA 		b	.L207
 3246              	.LVL383:
 3247              	.L197:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3248              		.loc 1 1191 0
 3249 1b14 0000A0E3 		mov	r0, #0
 3250              	.LVL384:
 3251 1b18 0020A0E1 		mov	r2, r0
 3252              	.LVL385:
 3253 1b1c 0110A0E3 		mov	r1, #1
 3254 1b20 FEFFFFEB 		bl	CyU3PUsbStall
 3255              	.LVL386:
1192:../uvc.c      **** 			  break;
 3256              		.loc 1 1192 0
 3257 1b24 0620A0E1 		mov	r2, r6
 3258 1b28 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 3259 1b2c 0400A0E3 		mov	r0, #4
 3260 1b30 48169FE5 		ldr	r1, .L234+16
 3261 1b34 FEFFFFEB 		bl	CyU3PDebugPrint
 3262              	.LVL387:
1193:../uvc.c      **** 		 }
 3263              		.loc 1 1193 0
 3264 1b38 FF00A0E3 		mov	r0, #255
 3265 1b3c 34469FE5 		ldr	r4, .L234+8
 3266 1b40 0080A0E1 		mov	r8, r0
 3267 1b44 0060A0E1 		mov	r6, r0
 3268 1b48 A2FFFFEA 		b	.L207
 3269              	.LVL388:
 3270              	.L203:
 988:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3271              		.loc 1 988 0
 3272 1b4c 24469FE5 		ldr	r4, .L234+8
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3273              		.loc 1 989 0
 3274 1b50 0030A0E3 		mov	r3, #0
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3275              		.loc 1 990 0
 3276 1b54 581084E2 		add	r1, r4, #88
 3277 1b58 0200A0E3 		mov	r0, #2
 3278              	.LVL389:
 992:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3279              		.loc 1 992 0
 3280 1b5c FF80A0E3 		mov	r8, #255
 988:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3281              		.loc 1 988 0
 3282 1b60 5870C4E5 		strb	r7, [r4, #88]
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3283              		.loc 1 989 0
 3284 1b64 5930C4E5 		strb	r3, [r4, #89]
 992:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3285              		.loc 1 992 0
 3286 1b68 0860A0E1 		mov	r6, r8
 3287              	.LVL390:
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3288              		.loc 1 990 0
 3289 1b6c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3290              	.LVL391:
 3291 1b70 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 992:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3292              		.loc 1 992 0
 3293 1b74 97FFFFEA 		b	.L207
 3294              	.LVL392:
 3295              	.L198:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3296              		.loc 1 1022 0
 3297 1b78 95C4D2E5 		ldrb	ip, [r2, #1173]	@ zero_extendqisi2
 3298 1b7c F4459FE5 		ldr	r4, .L234+8
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3299              		.loc 1 1023 0
 3300 1b80 9624D2E5 		ldrb	r2, [r2, #1174]	@ zero_extendqisi2
 3301              	.LVL393:
 3302 1b84 85FFFFEA 		b	.L231
 3303              	.LVL394:
 3304              	.L213:
1170:../uvc.c      **** 					  if(getData == 1)
 3305              		.loc 1 1170 0
 3306 1b88 F4659FE5 		ldr	r6, .L234+20
 3307 1b8c 0010E0E3 		mvn	r1, #0
 3308 1b90 1C0096E5 		ldr	r0, [r6, #28]
 3309 1b94 FEFFFFEB 		bl	_txe_mutex_get
 3310              	.LVL395:
1171:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3311              		.loc 1 1171 0
 3312 1b98 1CC09DE5 		ldr	ip, [sp, #28]
 3313 1b9c 01005CE3 		cmp	ip, #1
1172:../uvc.c      **** 					  else if(getData == 0xff)
 3314              		.loc 1 1172 0
 3315 1ba0 0400A003 		moveq	r0, #4
1171:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3316              		.loc 1 1171 0
 3317 1ba4 6901000A 		beq	.L230
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3318              		.loc 1 1173 0
 3319 1ba8 FF005CE3 		cmp	ip, #255
 3320 1bac 6601000A 		beq	.L233
1176:../uvc.c      **** 					  //dataIdx++;
 3321              		.loc 1 1176 0
 3322 1bb0 0010A0E3 		mov	r1, #0
 3323 1bb4 00108DE5 		str	r1, [sp]
 3324 1bb8 04108DE5 		str	r1, [sp, #4]
 3325 1bbc 0A20A0E1 		mov	r2, r10
 3326 1bc0 0930A0E1 		mov	r3, r9
 3327 1bc4 0600A0E1 		mov	r0, r6
 3328 1bc8 2310A0E3 		mov	r1, #35
 3329 1bcc FEFFFFEB 		bl	cmdSet
 3330              	.LVL396:
 3331              	.L225:
1179:../uvc.c      **** #endif
 3332              		.loc 1 1179 0
 3333 1bd0 1C0096E5 		ldr	r0, [r6, #28]
 3334 1bd4 FEFFFFEB 		bl	_txe_mutex_put
 3335              	.LVL397:
1181:../uvc.c      **** 					  break;
 3336              		.loc 1 1181 0
 3337 1bd8 5A10D4E5 		ldrb	r1, [r4, #90]	@ zero_extendqisi2
 3338 1bdc 1C609DE5 		ldr	r6, [sp, #28]
 3339 1be0 20809DE5 		ldr	r8, [sp, #32]
 3340 1be4 00108DE5 		str	r1, [sp]
 3341 1be8 0620A0E1 		mov	r2, r6
 3342 1bec 0830A0E1 		mov	r3, r8
 3343 1bf0 0400A0E3 		mov	r0, #4
 3344 1bf4 8C159FE5 		ldr	r1, .L234+24
 3345 1bf8 FEFFFFEB 		bl	CyU3PDebugPrint
 3346              	.LVL398:
1182:../uvc.c      **** 
 3347              		.loc 1 1182 0
 3348 1bfc FF00A0E3 		mov	r0, #255
 3349 1c00 74FFFFEA 		b	.L207
 3350              	.LVL399:
 3351              	.L212:
1147:../uvc.c      **** 					  {
 3352              		.loc 1 1147 0
 3353 1c04 B504D3E5 		ldrb	r0, [r3, #1205]	@ zero_extendqisi2
 3354 1c08 64C59FE5 		ldr	ip, .L234+4
 3355 1c0c 010050E3 		cmp	r0, #1
 3356 1c10 08005013 		cmpne	r0, #8
 3357 1c14 0000A013 		movne	r0, #0
 3358 1c18 0100A003 		moveq	r0, #1
 3359 1c1c 4601001A 		bne	.L222
 3360              	.LVL400:
1150:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3361              		.loc 1 1150 0
 3362 1c20 5CB59FE5 		ldr	fp, .L234+20
 3363 1c24 0010E0E3 		mvn	r1, #0
 3364 1c28 1C009BE5 		ldr	r0, [fp, #28]
 3365 1c2c 18C08DE5 		str	ip, [sp, #24]
 3366 1c30 FEFFFFEB 		bl	_txe_mutex_get
 3367              	.LVL401:
1151:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3368              		.loc 1 1151 0
 3369 1c34 1C009DE5 		ldr	r0, [sp, #28]
 3370 1c38 0010A0E3 		mov	r1, #0
 3371 1c3c 0A20A0E1 		mov	r2, r10
 3372 1c40 0930A0E1 		mov	r3, r9
 3373 1c44 00008DE5 		str	r0, [sp]
 3374 1c48 04108DE5 		str	r1, [sp, #4]
 3375 1c4c 0B00A0E1 		mov	r0, fp
 3376 1c50 2210A0E3 		mov	r1, #34
 3377 1c54 FEFFFFEB 		bl	cmdSet
 3378              	.LVL402:
1152:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 3379              		.loc 1 1152 0
 3380 1c58 1C009BE5 		ldr	r0, [fp, #28]
 3381 1c5c FEFFFFEB 		bl	_txe_mutex_put
 3382              	.LVL403:
1155:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3383              		.loc 1 1155 0
 3384 1c60 18C09DE5 		ldr	ip, [sp, #24]
 3385 1c64 1C109DE5 		ldr	r1, [sp, #28]
1156:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3386              		.loc 1 1156 0
 3387 1c68 20209DE5 		ldr	r2, [sp, #32]
1155:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3388              		.loc 1 1155 0
 3389 1c6c 066088E0 		add	r6, r8, r6
 3390 1c70 86C18CE0 		add	ip, ip, r6, asl #3
1157:../uvc.c      **** 					  }else{
 3391              		.loc 1 1157 0
 3392 1c74 0130A0E3 		mov	r3, #1
1155:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3393              		.loc 1 1155 0
 3394 1c78 9D14CCE5 		strb	r1, [ip, #1181]
1156:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3395              		.loc 1 1156 0
 3396 1c7c 9E24CCE5 		strb	r2, [ip, #1182]
1157:../uvc.c      **** 					  }else{
 3397              		.loc 1 1157 0
 3398 1c80 A034CCE5 		strb	r3, [ip, #1184]
 3399              	.LVL404:
 3400              	.L223:
 3401 1c84 5860D4E5 		ldrb	r6, [r4, #88]	@ zero_extendqisi2
 3402 1c88 5980D4E5 		ldrb	r8, [r4, #89]	@ zero_extendqisi2
1164:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 3403              		.loc 1 1164 0
 3404 1c8c FF00A0E3 		mov	r0, #255
 3405 1c90 50FFFFEA 		b	.L207
 3406              	.LVL405:
 3407              	.L211:
1113:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3408              		.loc 1 1113 0
 3409 1c94 B534D3E5 		ldrb	r3, [r3, #1205]	@ zero_extendqisi2
 3410 1c98 010053E3 		cmp	r3, #1
 3411 1c9c 04005313 		cmpne	r3, #4
 3412 1ca0 2001001A 		bne	.L220
1112:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3413              		.loc 1 1112 0
 3414 1ca4 1CC09DE5 		ldr	ip, [sp, #28]
 3415 1ca8 20009DE5 		ldr	r0, [sp, #32]
 3416 1cac 00348CE1 		orr	r3, ip, r0, asl #8
1114:../uvc.c      **** 					  {
 3417              		.loc 1 1114 0
 3418 1cb0 F90053E3 		cmp	r3, #249
 3419 1cb4 1B01008A 		bhi	.L220
 3420              	.LVL406:
1119:../uvc.c      **** 							}else{
 3421              		.loc 1 1119 0
 3422 1cb8 C80043E2 		sub	r0, r3, #200
 3423 1cbc C80053E3 		cmp	r3, #200
1121:../uvc.c      **** 							}
 3424              		.loc 1 1121 0
 3425 1cc0 C82063E2 		rsb	r2, r3, #200
 3426 1cc4 C0149FE5 		ldr	r1, .L234+28
 3427 1cc8 0208A091 		movls	r0, r2, asl #16
 3428 1ccc 0008A081 		movhi	r0, r0, asl #16
 3429 1cd0 642063E2 		rsb	r2, r3, #100
 3430 1cd4 640053E3 		cmp	r3, #100
1119:../uvc.c      **** 							}else{
 3431              		.loc 1 1119 0
 3432 1cd8 64C043E2 		sub	ip, r3, #100
 3433 1cdc 2008A0E1 		mov	r0, r0, lsr #16
 3434 1ce0 0C28A081 		movhi	r2, ip, asl #16
 3435 1ce4 0228A091 		movls	r2, r2, asl #16
 3436 1ce8 010050E1 		cmp	r0, r1
 3437 1cec 00E0A031 		movcc	lr, r0
 3438 1cf0 01E0A021 		movcs	lr, r1
 3439 1cf4 010050E1 		cmp	r0, r1
 3440 1cf8 27C043E2 		sub	ip, r3, #39
1121:../uvc.c      **** 							}
 3441              		.loc 1 1121 0
 3442 1cfc 271063E2 		rsb	r1, r3, #39
 3443 1d00 00B0A033 		movcc	fp, #0
 3444 1d04 01B0A023 		movcs	fp, #1
 3445 1d08 270053E3 		cmp	r3, #39
1119:../uvc.c      **** 							}else{
 3446              		.loc 1 1119 0
 3447 1d0c 140043E2 		sub	r0, r3, #20
 3448 1d10 01C8A091 		movls	ip, r1, asl #16
 3449 1d14 2228A0E1 		mov	r2, r2, lsr #16
1121:../uvc.c      **** 							}
 3450              		.loc 1 1121 0
 3451 1d18 141063E2 		rsb	r1, r3, #20
 3452 1d1c 0CC8A081 		movhi	ip, ip, asl #16
 3453 1d20 140053E3 		cmp	r3, #20
 3454 1d24 0018A081 		movhi	r1, r0, asl #16
 3455 1d28 0118A091 		movls	r1, r1, asl #16
 3456 1d2c 0E0052E1 		cmp	r2, lr
1119:../uvc.c      **** 							}else{
 3457              		.loc 1 1119 0
 3458 1d30 0A0043E2 		sub	r0, r3, #10
 3459 1d34 01B0A033 		movcc	fp, #1
 3460 1d38 2CC8A0E1 		mov	ip, ip, lsr #16
 3461 1d3c 02005EE1 		cmp	lr, r2
 3462 1d40 0E20A031 		movcc	r2, lr
 3463 1d44 0A0053E3 		cmp	r3, #10
 3464 1d48 21E8A0E1 		mov	lr, r1, lsr #16
1121:../uvc.c      **** 							}
 3465              		.loc 1 1121 0
 3466 1d4c 0A1063E2 		rsb	r1, r3, #10
 3467 1d50 0118A091 		movls	r1, r1, asl #16
 3468 1d54 0018A081 		movhi	r1, r0, asl #16
 3469 1d58 0C0052E1 		cmp	r2, ip
 3470 1d5c 02B0A083 		movhi	fp, #2
 3471 1d60 24B08DE5 		str	fp, [sp, #36]
1119:../uvc.c      **** 							}else{
 3472              		.loc 1 1119 0
 3473 1d64 050043E2 		sub	r0, r3, #5
 3474 1d68 02005CE1 		cmp	ip, r2
 3475 1d6c 0C20A031 		movcc	r2, ip
 3476 1d70 21B8A0E1 		mov	fp, r1, lsr #16
1121:../uvc.c      **** 							}
 3477              		.loc 1 1121 0
 3478 1d74 05C063E2 		rsb	ip, r3, #5
 3479 1d78 050053E3 		cmp	r3, #5
 3480 1d7c 24109DE5 		ldr	r1, [sp, #36]
 3481 1d80 00C8A081 		movhi	ip, r0, asl #16
 3482 1d84 0CC8A091 		movls	ip, ip, asl #16
 3483 1d88 0E0052E1 		cmp	r2, lr
 3484 1d8c 0310A083 		movhi	r1, #3
 3485 1d90 24108DE5 		str	r1, [sp, #36]
 3486 1d94 02005EE1 		cmp	lr, r2
 3487 1d98 0E00A031 		movcc	r0, lr
 3488 1d9c 0200A021 		movcs	r0, r2
 3489 1da0 021063E2 		rsb	r1, r3, #2
1119:../uvc.c      **** 							}else{
 3490              		.loc 1 1119 0
 3491 1da4 022043E2 		sub	r2, r3, #2
 3492 1da8 020053E3 		cmp	r3, #2
 3493 1dac 0128A091 		movls	r2, r1, asl #16
 3494 1db0 0228A081 		movhi	r2, r2, asl #16
 3495 1db4 0B0050E1 		cmp	r0, fp
 3496 1db8 24E09DE5 		ldr	lr, [sp, #36]
 3497 1dbc 2CC8A0E1 		mov	ip, ip, lsr #16
 3498 1dc0 04E0A083 		movhi	lr, #4
 3499 1dc4 00005BE1 		cmp	fp, r0
 3500 1dc8 0B00A031 		movcc	r0, fp
 3501 1dcc 00005CE1 		cmp	ip, r0
 3502 1dd0 0C10A031 		movcc	r1, ip
 3503 1dd4 0010A021 		movcs	r1, r0
 3504 1dd8 0C0050E1 		cmp	r0, ip
 3505 1ddc 05E0A083 		movhi	lr, #5
 3506 1de0 01C043E2 		sub	ip, r3, #1
 3507 1de4 010053E3 		cmp	r3, #1
1121:../uvc.c      **** 							}
 3508              		.loc 1 1121 0
 3509 1de8 010063E2 		rsb	r0, r3, #1
 3510 1dec 0C38A081 		movhi	r3, ip, asl #16
1131:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3511              		.loc 1 1131 0
 3512 1df0 8CC39FE5 		ldr	ip, .L234+20
 3513 1df4 2228A0E1 		mov	r2, r2, lsr #16
 3514 1df8 0038A091 		movls	r3, r0, asl #16
 3515 1dfc 010052E1 		cmp	r2, r1
 3516 1e00 0200A031 		movcc	r0, r2
 3517 1e04 0100A021 		movcs	r0, r1
 3518 1e08 020051E1 		cmp	r1, r2
 3519 1e0c 0E20A091 		movls	r2, lr
 3520 1e10 0620A083 		movhi	r2, #6
 3521              	.LVL407:
 3522 1e14 0010E0E3 		mvn	r1, #0
 3523              	.LVL408:
 3524 1e18 230850E1 		cmp	r0, r3, lsr #16
 3525 1e1c 1C009CE5 		ldr	r0, [ip, #28]
 3526 1e20 02B0A091 		movls	fp, r2
 3527 1e24 07B0A083 		movhi	fp, #7
 3528              	.LVL409:
 3529 1e28 18C08DE5 		str	ip, [sp, #24]
 3530 1e2c FEFFFFEB 		bl	_txe_mutex_get
 3531              	.LVL410:
1132:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3532              		.loc 1 1132 0
 3533 1e30 18C09DE5 		ldr	ip, [sp, #24]
1128:../uvc.c      **** 
 3534              		.loc 1 1128 0
 3535 1e34 01B08BE2 		add	fp, fp, #1
 3536              	.LVL411:
1132:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3537              		.loc 1 1132 0
 3538 1e38 0010A0E3 		mov	r1, #0
 3539 1e3c 0A20A0E1 		mov	r2, r10
 3540 1e40 0930A0E1 		mov	r3, r9
 3541 1e44 0C00A0E1 		mov	r0, ip
 3542 1e48 04108DE5 		str	r1, [sp, #4]
 3543 1e4c 00B08DE5 		str	fp, [sp]
 3544 1e50 0310A0E3 		mov	r1, #3
 3545 1e54 FEFFFFEB 		bl	cmdSet
 3546              	.LVL412:
1133:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 3547              		.loc 1 1133 0
 3548 1e58 18C09DE5 		ldr	ip, [sp, #24]
 3549 1e5c 1C009CE5 		ldr	r0, [ip, #28]
 3550 1e60 FEFFFFEB 		bl	_txe_mutex_put
 3551              	.LVL413:
1139:../uvc.c      **** 					  }else{
 3552              		.loc 1 1139 0
 3553 1e64 08C39FE5 		ldr	ip, .L234+4
1136:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3554              		.loc 1 1136 0
 3555 1e68 04239FE5 		ldr	r2, .L234+4
1139:../uvc.c      **** 					  }else{
 3556              		.loc 1 1139 0
 3557 1e6c 0DB3CCE5 		strb	fp, [ip, #781]
1136:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3558              		.loc 1 1136 0
 3559 1e70 1CC09DE5 		ldr	ip, [sp, #28]
 3560 1e74 063088E0 		add	r3, r8, r6
 3561 1e78 833182E0 		add	r3, r2, r3, asl #3
 3562 1e7c 9DC4C3E5 		strb	ip, [r3, #1181]
1137:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3563              		.loc 1 1137 0
 3564 1e80 20C09DE5 		ldr	ip, [sp, #32]
1138:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3565              		.loc 1 1138 0
 3566 1e84 0120A0E3 		mov	r2, #1
1137:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3567              		.loc 1 1137 0
 3568 1e88 9EC4C3E5 		strb	ip, [r3, #1182]
1138:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3569              		.loc 1 1138 0
 3570 1e8c A024C3E5 		strb	r2, [r3, #1184]
1139:../uvc.c      **** 					  }else{
 3571              		.loc 1 1139 0
 3572 1e90 7BFFFFEA 		b	.L223
 3573              	.LVL414:
 3574              	.L209:
1070:../uvc.c      **** 						case 1:
 3575              		.loc 1 1070 0
 3576 1e94 1CC09DE5 		ldr	ip, [sp, #28]
1066:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3577              		.loc 1 1066 0
 3578 1e98 066088E0 		add	r6, r8, r6
 3579 1e9c 866183E0 		add	r6, r3, r6, asl #3
1067:../uvc.c      **** 				    getData = glEp0Buffer[0];
 3580              		.loc 1 1067 0
 3581 1ea0 0110A0E3 		mov	r1, #1
1070:../uvc.c      **** 						case 1:
 3582              		.loc 1 1070 0
 3583 1ea4 01204CE2 		sub	r2, ip, #1
1066:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3584              		.loc 1 1066 0
 3585 1ea8 9DC4C6E5 		strb	ip, [r6, #1181]
1067:../uvc.c      **** 				    getData = glEp0Buffer[0];
 3586              		.loc 1 1067 0
 3587 1eac A014C6E5 		strb	r1, [r6, #1184]
 3588              	.LVL415:
1070:../uvc.c      **** 						case 1:
 3589              		.loc 1 1070 0
 3590 1eb0 070052E3 		cmp	r2, #7
 3591 1eb4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3592 1eb8 960000EA 		b	.L214
 3593              	.L216:
 3594 1ebc B4200000 		.word	.L215
 3595 1ec0 18200000 		.word	.L217
 3596 1ec4 18210000 		.word	.L214
 3597 1ec8 B01F0000 		.word	.L218
 3598 1ecc 18210000 		.word	.L214
 3599 1ed0 18210000 		.word	.L214
 3600 1ed4 18210000 		.word	.L214
 3601 1ed8 101F0000 		.word	.L219
 3602              	.LVL416:
 3603              	.L208:
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3604              		.loc 1 1185 0
 3605 1edc 1CC09DE5 		ldr	ip, [sp, #28]
 3606 1ee0 068088E0 		add	r8, r8, r6
 3607 1ee4 888183E0 		add	r8, r3, r8, asl #3
1186:../uvc.c      **** 			  		 break;
 3608              		.loc 1 1186 0
 3609 1ee8 0620A0E1 		mov	r2, r6
 3610 1eec 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 3611 1ef0 0400A0E3 		mov	r0, #4
 3612 1ef4 94129FE5 		ldr	r1, .L234+32
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3613              		.loc 1 1185 0
 3614 1ef8 9DC4C8E5 		strb	ip, [r8, #1181]
1186:../uvc.c      **** 			  		 break;
 3615              		.loc 1 1186 0
 3616 1efc FEFFFFEB 		bl	CyU3PDebugPrint
 3617              	.LVL417:
1187:../uvc.c      **** 			  }
 3618              		.loc 1 1187 0
 3619 1f00 FF00A0E3 		mov	r0, #255
 3620 1f04 0080A0E1 		mov	r8, r0
 3621 1f08 0060A0E1 		mov	r6, r0
 3622 1f0c B1FEFFEA 		b	.L207
 3623              	.LVL418:
 3624              	.L219:
1089:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3625              		.loc 1 1089 0
 3626 1f10 6C629FE5 		ldr	r6, .L234+20
1087:../uvc.c      **** 			  		    	dataIdx = 0;
 3627              		.loc 1 1087 0
 3628 1f14 0080A0E3 		mov	r8, #0
1089:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3629              		.loc 1 1089 0
 3630 1f18 1C0096E5 		ldr	r0, [r6, #28]
 3631 1f1c 0010E0E3 		mvn	r1, #0
1087:../uvc.c      **** 			  		    	dataIdx = 0;
 3632              		.loc 1 1087 0
 3633 1f20 0D83C3E5 		strb	r8, [r3, #781]
 3634              	.LVL419:
1089:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3635              		.loc 1 1089 0
 3636 1f24 FEFFFFEB 		bl	_txe_mutex_get
 3637              	.LVL420:
1090:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3638              		.loc 1 1090 0
 3639 1f28 0A20A0E1 		mov	r2, r10
 3640 1f2c 0930A0E1 		mov	r3, r9
 3641 1f30 1010A0E3 		mov	r1, #16
 3642 1f34 00808DE5 		str	r8, [sp]
 3643 1f38 04808DE5 		str	r8, [sp, #4]
 3644 1f3c 0600A0E1 		mov	r0, r6
 3645 1f40 FEFFFFEB 		bl	cmdSet
 3646              	.LVL421:
1091:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 3647              		.loc 1 1091 0
 3648 1f44 1C0096E5 		ldr	r0, [r6, #28]
 3649 1f48 FEFFFFEB 		bl	_txe_mutex_put
 3650              	.LVL422:
 3651              	.LBB78:
 3652              	.LBB79:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3653              		.loc 1 390 0
 3654 1f4c 1C0096E5 		ldr	r0, [r6, #28]
 3655 1f50 0010E0E3 		mvn	r1, #0
 3656 1f54 FEFFFFEB 		bl	_txe_mutex_get
 3657              	.LVL423:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3658              		.loc 1 391 0
 3659 1f58 0130A0E3 		mov	r3, #1
 3660 1f5c 04808DE5 		str	r8, [sp, #4]
 3661 1f60 0600A0E1 		mov	r0, r6
 3662 1f64 00308DE5 		str	r3, [sp]
 3663 1f68 2010A0E3 		mov	r1, #32
 3664 1f6c 2720A0E3 		mov	r2, #39
 3665 1f70 3030A0E3 		mov	r3, #48
 3666 1f74 FEFFFFEB 		bl	cmdSet
 3667              	.LVL424:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3668              		.loc 1 392 0
 3669 1f78 0230A0E3 		mov	r3, #2
 3670 1f7c 04808DE5 		str	r8, [sp, #4]
 3671 1f80 0600A0E1 		mov	r0, r6
 3672 1f84 00308DE5 		str	r3, [sp]
 3673 1f88 2110A0E3 		mov	r1, #33
 3674 1f8c 2520A0E3 		mov	r2, #37
 3675 1f90 3030A0E3 		mov	r3, #48
 3676 1f94 FEFFFFEB 		bl	cmdSet
 3677              	.LVL425:
 393:../uvc.c      **** }
 3678              		.loc 1 393 0
 3679 1f98 1C0096E5 		ldr	r0, [r6, #28]
 3680 1f9c FEFFFFEB 		bl	_txe_mutex_put
 3681              	.LVL426:
 3682 1fa0 FF00A0E3 		mov	r0, #255
 3683 1fa4 0080A0E1 		mov	r8, r0
 3684 1fa8 0860A0E3 		mov	r6, #8
 3685 1fac 89FEFFEA 		b	.L207
 3686              	.LVL427:
 3687              	.L218:
 3688              	.LBE79:
 3689              	.LBE78:
 3690              	.LBB80:
 3691              	.LBB81:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3692              		.loc 1 390 0
 3693 1fb0 CC619FE5 		ldr	r6, .L234+20
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3694              		.loc 1 391 0
 3695 1fb4 0080A0E3 		mov	r8, #0
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3696              		.loc 1 390 0
 3697 1fb8 0010E0E3 		mvn	r1, #0
 3698 1fbc 1C0096E5 		ldr	r0, [r6, #28]
 3699 1fc0 FEFFFFEB 		bl	_txe_mutex_get
 3700              	.LVL428:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3701              		.loc 1 391 0
 3702 1fc4 0600A0E1 		mov	r0, r6
 3703 1fc8 00808DE5 		str	r8, [sp]
 3704 1fcc 04808DE5 		str	r8, [sp, #4]
 3705 1fd0 2010A0E3 		mov	r1, #32
 3706 1fd4 2720A0E3 		mov	r2, #39
 3707 1fd8 3030A0E3 		mov	r3, #48
 3708 1fdc FEFFFFEB 		bl	cmdSet
 3709              	.LVL429:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3710              		.loc 1 392 0
 3711 1fe0 0130A0E3 		mov	r3, #1
 3712 1fe4 04808DE5 		str	r8, [sp, #4]
 3713 1fe8 0600A0E1 		mov	r0, r6
 3714 1fec 00308DE5 		str	r3, [sp]
 3715 1ff0 2110A0E3 		mov	r1, #33
 3716 1ff4 2520A0E3 		mov	r2, #37
 3717 1ff8 3030A0E3 		mov	r3, #48
 3718 1ffc FEFFFFEB 		bl	cmdSet
 3719              	.LVL430:
 393:../uvc.c      **** }
 3720              		.loc 1 393 0
 3721 2000 1C0096E5 		ldr	r0, [r6, #28]
 3722 2004 FEFFFFEB 		bl	_txe_mutex_put
 3723              	.LVL431:
 3724 2008 FF00A0E3 		mov	r0, #255
 3725 200c 0080A0E1 		mov	r8, r0
 3726 2010 0460A0E3 		mov	r6, #4
 3727 2014 6FFEFFEA 		b	.L207
 3728              	.LVL432:
 3729              	.L217:
 3730              	.LBE81:
 3731              	.LBE80:
1077:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3732              		.loc 1 1077 0
 3733 2018 64619FE5 		ldr	r6, .L234+20
1075:../uvc.c      **** 							dataIdx = 0;
 3734              		.loc 1 1075 0
 3735 201c 0080A0E3 		mov	r8, #0
1077:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3736              		.loc 1 1077 0
 3737 2020 1C0096E5 		ldr	r0, [r6, #28]
 3738 2024 0010E0E3 		mvn	r1, #0
1075:../uvc.c      **** 							dataIdx = 0;
 3739              		.loc 1 1075 0
 3740 2028 0D83C3E5 		strb	r8, [r3, #781]
 3741              	.LVL433:
1077:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3742              		.loc 1 1077 0
 3743 202c FEFFFFEB 		bl	_txe_mutex_get
 3744              	.LVL434:
1078:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3745              		.loc 1 1078 0
 3746 2030 0A20A0E1 		mov	r2, r10
 3747 2034 0930A0E1 		mov	r3, r9
 3748 2038 1010A0E3 		mov	r1, #16
 3749 203c 00808DE5 		str	r8, [sp]
 3750 2040 04808DE5 		str	r8, [sp, #4]
 3751 2044 0600A0E1 		mov	r0, r6
 3752 2048 FEFFFFEB 		bl	cmdSet
 3753              	.LVL435:
1079:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 3754              		.loc 1 1079 0
 3755 204c 1C0096E5 		ldr	r0, [r6, #28]
 3756 2050 FEFFFFEB 		bl	_txe_mutex_put
 3757              	.LVL436:
 3758              	.LBB82:
 3759              	.LBB83:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3760              		.loc 1 390 0
 3761 2054 1C0096E5 		ldr	r0, [r6, #28]
 3762 2058 0010E0E3 		mvn	r1, #0
 3763 205c FEFFFFEB 		bl	_txe_mutex_get
 3764              	.LVL437:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3765              		.loc 1 391 0
 3766 2060 00808DE5 		str	r8, [sp]
 3767 2064 04808DE5 		str	r8, [sp, #4]
 3768 2068 0600A0E1 		mov	r0, r6
 3769 206c 2010A0E3 		mov	r1, #32
 3770 2070 2720A0E3 		mov	r2, #39
 3771 2074 3030A0E3 		mov	r3, #48
 3772 2078 FEFFFFEB 		bl	cmdSet
 3773              	.LVL438:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3774              		.loc 1 392 0
 3775 207c 0130A0E3 		mov	r3, #1
 3776 2080 04808DE5 		str	r8, [sp, #4]
 3777 2084 0600A0E1 		mov	r0, r6
 3778 2088 00308DE5 		str	r3, [sp]
 3779 208c 2110A0E3 		mov	r1, #33
 3780 2090 2520A0E3 		mov	r2, #37
 3781 2094 3030A0E3 		mov	r3, #48
 3782 2098 FEFFFFEB 		bl	cmdSet
 3783              	.LVL439:
 393:../uvc.c      **** }
 3784              		.loc 1 393 0
 3785 209c 1C0096E5 		ldr	r0, [r6, #28]
 3786 20a0 FEFFFFEB 		bl	_txe_mutex_put
 3787              	.LVL440:
 3788 20a4 FF00A0E3 		mov	r0, #255
 3789 20a8 0080A0E1 		mov	r8, r0
 3790 20ac 0260A0E3 		mov	r6, #2
 3791 20b0 48FEFFEA 		b	.L207
 3792              	.LVL441:
 3793              	.L215:
 3794              	.LBE83:
 3795              	.LBE82:
 3796              	.LBB84:
 3797              	.LBB85:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3798              		.loc 1 390 0
 3799 20b4 C8809FE5 		ldr	r8, .L234+20
 3800 20b8 0010E0E3 		mvn	r1, #0
 3801 20bc 1C0098E5 		ldr	r0, [r8, #28]
 3802 20c0 FEFFFFEB 		bl	_txe_mutex_get
 3803              	.LVL442:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3804              		.loc 1 391 0
 3805 20c4 0090A0E3 		mov	r9, #0
 3806              	.LVL443:
 3807 20c8 0160A0E3 		mov	r6, #1
 3808 20cc 0800A0E1 		mov	r0, r8
 3809 20d0 2010A0E3 		mov	r1, #32
 3810 20d4 2720A0E3 		mov	r2, #39
 3811 20d8 3030A0E3 		mov	r3, #48
 3812 20dc 40028DE8 		stmia	sp, {r6, r9}
 3813 20e0 FEFFFFEB 		bl	cmdSet
 3814              	.LVL444:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3815              		.loc 1 392 0
 3816 20e4 0230A0E3 		mov	r3, #2
 3817 20e8 0800A0E1 		mov	r0, r8
 3818 20ec 00308DE5 		str	r3, [sp]
 3819 20f0 2110A0E3 		mov	r1, #33
 3820 20f4 2520A0E3 		mov	r2, #37
 3821 20f8 3030A0E3 		mov	r3, #48
 3822 20fc 04908DE5 		str	r9, [sp, #4]
 3823 2100 FEFFFFEB 		bl	cmdSet
 3824              	.LVL445:
 393:../uvc.c      **** }
 3825              		.loc 1 393 0
 3826 2104 1C0098E5 		ldr	r0, [r8, #28]
 3827 2108 FEFFFFEB 		bl	_txe_mutex_put
 3828              	.LVL446:
 3829 210c FF00A0E3 		mov	r0, #255
 3830 2110 0080A0E1 		mov	r8, r0
 3831 2114 2FFEFFEA 		b	.L207
 3832              	.LVL447:
 3833              	.L214:
 3834              	.LBE85:
 3835              	.LBE84:
1070:../uvc.c      **** 						case 1:
 3836              		.loc 1 1070 0
 3837 2118 FF00A0E3 		mov	r0, #255
 3838 211c 0C60A0E1 		mov	r6, ip
 3839 2120 0080A0E1 		mov	r8, r0
 3840 2124 2BFEFFEA 		b	.L207
 3841              	.LVL448:
 3842              	.L220:
1141:../uvc.c      **** 					  }
 3843              		.loc 1 1141 0
 3844 2128 0000A0E3 		mov	r0, #0
 3845 212c 0020A0E1 		mov	r2, r0
 3846 2130 0110A0E3 		mov	r1, #1
 3847 2134 FEFFFFEB 		bl	CyU3PUsbStall
 3848              	.LVL449:
 3849 2138 D1FEFFEA 		b	.L223
 3850              	.LVL450:
 3851              	.L222:
1159:../uvc.c      **** 					  }
 3852              		.loc 1 1159 0
 3853 213c 0020A0E1 		mov	r2, r0
 3854 2140 0110A0E3 		mov	r1, #1
 3855 2144 FEFFFFEB 		bl	CyU3PUsbStall
 3856              	.LVL451:
 3857 2148 CDFEFFEA 		b	.L223
 3858              	.LVL452:
 3859              	.L233:
1174:../uvc.c      **** 					  else
 3860              		.loc 1 1174 0
 3861 214c 0800A0E3 		mov	r0, #8
 3862              	.L230:
 3863 2150 0010A0E3 		mov	r1, #0
 3864 2154 03008DE8 		stmia	sp, {r0, r1}
 3865 2158 0A20A0E1 		mov	r2, r10
 3866 215c 0930A0E1 		mov	r3, r9
 3867 2160 0600A0E1 		mov	r0, r6
 3868 2164 2310A0E3 		mov	r1, #35
 3869 2168 FEFFFFEB 		bl	cmdSet
 3870              	.LVL453:
 3871 216c 97FEFFEA 		b	.L225
 3872              	.L235:
 3873              		.align	2
 3874              	.L234:
 3875 2170 00000000 		.word	bRequest
 3876 2174 00000000 		.word	.LANCHOR1
 3877 2178 00000000 		.word	.LANCHOR0
 3878 217c C4030000 		.word	.LC22
 3879 2180 A0030000 		.word	.LC21
 3880 2184 00000000 		.word	cmdQu
 3881 2188 54030000 		.word	.LC19
 3882 218c FFFF0000 		.word	65535
 3883 2190 7C030000 		.word	.LC20
 3884              		.cfi_endproc
 3885              	.LFE3:
 3887              		.align	2
 3888              		.global	CamDefSet
 3890              	CamDefSet:
 3891              	.LFB4:
1202:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 3892              		.loc 1 1202 0
 3893              		.cfi_startproc
 3894              		@ args = 0, pretend = 0, frame = 24
 3895              		@ frame_needed = 0, uses_anonymous_args = 0
 3896              	.LVL454:
 3897 2194 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3898              	.LCFI16:
 3899              		.cfi_def_cfa_offset 36
 3900              		.cfi_offset 4, -36
 3901              		.cfi_offset 5, -32
 3902              		.cfi_offset 6, -28
 3903              		.cfi_offset 7, -24
 3904              		.cfi_offset 8, -20
 3905              		.cfi_offset 9, -16
 3906              		.cfi_offset 10, -12
 3907              		.cfi_offset 11, -8
 3908              		.cfi_offset 14, -4
1208:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 3909              		.loc 1 1208 0
 3910 2198 AC429FE5 		ldr	r4, .L239
1213:../uvc.c      ****     if(Data1&0x80){
 3911              		.loc 1 1213 0
 3912 219c AC229FE5 		ldr	r2, .L239+4
1210:../uvc.c      ****     Data1 = Data0;
 3913              		.loc 1 1210 0
 3914 21a0 A351D4E5 		ldrb	r5, [r4, #419]	@ zero_extendqisi2
1202:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 3915              		.loc 1 1202 0
 3916 21a4 2CD04DE2 		sub	sp, sp, #44
 3917              	.LCFI17:
 3918              		.cfi_def_cfa_offset 80
1213:../uvc.c      ****     if(Data1&0x80){
 3919              		.loc 1 1213 0
 3920 21a8 1C0092E5 		ldr	r0, [r2, #28]
 3921 21ac 0010E0E3 		mvn	r1, #0
1215:../uvc.c      ****     }else{
 3922              		.loc 1 1215 0
 3923 21b0 2563A0E1 		mov	r6, r5, lsr #6
1209:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 3924              		.loc 1 1209 0
 3925 21b4 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1208:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 3926              		.loc 1 1208 0
 3927 21b8 9991D4E5 		ldrb	r9, [r4, #409]	@ zero_extendqisi2
 3928              	.LVL455:
1213:../uvc.c      ****     if(Data1&0x80){
 3929              		.loc 1 1213 0
 3930 21bc FEFFFFEB 		bl	_txe_mutex_get
 3931              	.LVL456:
1214:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 3932              		.loc 1 1214 0
 3933 21c0 800015E3 		tst	r5, #128
1215:../uvc.c      ****     }else{
 3934              		.loc 1 1215 0
 3935 21c4 01600612 		andne	r6, r6, #1
 3936 21c8 0660E011 		mvnne	r6, r6
 3937 21cc 3B600612 		andne	r6, r6, #59
 3938 21d0 0660E011 		mvnne	r6, r6
 3939 21d4 FF600612 		andne	r6, r6, #255
 3940              	.LVL457:
1217:../uvc.c      ****     }
 3941              		.loc 1 1217 0
 3942 21d8 C6608603 		orreq	r6, r6, #198
 3943              	.LVL458:
1221:../uvc.c      **** 
 3944              		.loc 1 1221 0
 3945 21dc 0080A0E3 		mov	r8, #0
1219:../uvc.c      **** 
 3946              		.loc 1 1219 0
 3947 21e0 0551A0E1 		mov	r5, r5, asl #2
 3948              	.LVL459:
 3949 21e4 FF5005E2 		and	r5, r5, #255
 3950              	.LVL460:
1224:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3951              		.loc 1 1224 0
 3952 21e8 01A0A0E3 		mov	r10, #1
1221:../uvc.c      **** 
 3953              		.loc 1 1221 0
 3954 21ec 00608DE5 		str	r6, [sp]
 3955 21f0 0920A0E1 		mov	r2, r9
 3956 21f4 0730A0E1 		mov	r3, r7
 3957 21f8 04808DE5 		str	r8, [sp, #4]
 3958 21fc 0110A0E3 		mov	r1, #1
 3959 2200 48029FE5 		ldr	r0, .L239+4
 3960 2204 FEFFFFEB 		bl	cmdSet
 3961              	.LVL461:
1224:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3962              		.loc 1 1224 0
 3963 2208 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 3964 220c 0730A0E1 		mov	r3, r7
 3965 2210 0A10A0E1 		mov	r1, r10
 3966 2214 00508DE5 		str	r5, [sp]
 3967 2218 04A08DE5 		str	r10, [sp, #4]
 3968 221c 2C029FE5 		ldr	r0, .L239+4
 3969 2220 FEFFFFEB 		bl	cmdSet
 3970              	.LVL462:
1227:../uvc.c      **** 
 3971              		.loc 1 1227 0
 3972 2224 0620A0E1 		mov	r2, r6
 3973 2228 0530A0E1 		mov	r3, r5
 3974 222c 20129FE5 		ldr	r1, .L239+8
 3975 2230 0400A0E3 		mov	r0, #4
1226:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 3976              		.loc 1 1226 0
 3977 2234 A661C4E5 		strb	r6, [r4, #422]
1225:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 3978              		.loc 1 1225 0
 3979 2238 A551C4E5 		strb	r5, [r4, #421]
1227:../uvc.c      **** 
 3980              		.loc 1 1227 0
 3981 223c FEFFFFEB 		bl	CyU3PDebugPrint
 3982              	.LVL463:
1232:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 3983              		.loc 1 1232 0
 3984 2240 BB61D4E5 		ldrb	r6, [r4, #443]	@ zero_extendqisi2
 3985              	.LVL464:
1233:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3986              		.loc 1 1233 0
 3987 2244 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 3988 2248 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 3989 224c 40018DE8 		stmia	sp, {r6, r8}
 3990 2250 F8019FE5 		ldr	r0, .L239+4
 3991 2254 0210A0E3 		mov	r1, #2
 3992 2258 FEFFFFEB 		bl	cmdSet
 3993              	.LVL465:
1235:../uvc.c      **** 
 3994              		.loc 1 1235 0
 3995 225c 0620A0E1 		mov	r2, r6
 3996 2260 0530A0E1 		mov	r3, r5
 3997 2264 E8119FE5 		ldr	r1, .L239+8
 3998 2268 0400A0E3 		mov	r0, #4
1234:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 3999              		.loc 1 1234 0
 4000 226c BD51C4E5 		strb	r5, [r4, #445]
1235:../uvc.c      **** 
 4001              		.loc 1 1235 0
 4002 2270 FEFFFFEB 		bl	CyU3PDebugPrint
 4003              	.LVL466:
1240:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 4004              		.loc 1 1240 0
 4005 2274 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1239:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 4006              		.loc 1 1239 0
 4007 2278 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 4008              	.LVL467:
1241:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4009              		.loc 1 1241 0
 4010 227c 80C047E2 		sub	ip, r7, #128
 4011 2280 FF300CE2 		and	r3, ip, #255
1242:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4012              		.loc 1 1242 0
 4013 2284 76E047E2 		sub	lr, r7, #118
1241:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4014              		.loc 1 1241 0
 4015 2288 18308DE5 		str	r3, [sp, #24]
 4016 228c 08018DE8 		stmia	sp, {r3, r8}
 4017 2290 B8019FE5 		ldr	r0, .L239+4
 4018 2294 0630A0E1 		mov	r3, r6
 4019 2298 0510A0E3 		mov	r1, #5
 4020 229c DF20A0E3 		mov	r2, #223
 4021 22a0 14C08DE5 		str	ip, [sp, #20]
1242:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4022              		.loc 1 1242 0
 4023 22a4 1CE08DE5 		str	lr, [sp, #28]
1241:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4024              		.loc 1 1241 0
 4025 22a8 FEFFFFEB 		bl	cmdSet
 4026              	.LVL468:
1242:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4027              		.loc 1 1242 0
 4028 22ac 1C209DE5 		ldr	r2, [sp, #28]
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4029              		.loc 1 1243 0
 4030 22b0 7EE087E2 		add	lr, r7, #126
1242:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4031              		.loc 1 1242 0
 4032 22b4 FF3002E2 		and	r3, r2, #255
 4033 22b8 08048DE8 		stmia	sp, {r3, r10}
 4034 22bc 8C019FE5 		ldr	r0, .L239+4
 4035 22c0 0630A0E1 		mov	r3, r6
 4036 22c4 0510A0E3 		mov	r1, #5
 4037 22c8 DC20A0E3 		mov	r2, #220
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4038              		.loc 1 1243 0
 4039 22cc 20E08DE5 		str	lr, [sp, #32]
1242:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4040              		.loc 1 1242 0
 4041 22d0 FEFFFFEB 		bl	cmdSet
 4042              	.LVL469:
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4043              		.loc 1 1243 0
 4044 22d4 20209DE5 		ldr	r2, [sp, #32]
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4045              		.loc 1 1244 0
 4046 22d8 72E087E2 		add	lr, r7, #114
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4047              		.loc 1 1243 0
 4048 22dc FF3002E2 		and	r3, r2, #255
 4049 22e0 0220A0E3 		mov	r2, #2
 4050 22e4 00308DE5 		str	r3, [sp]
 4051 22e8 04208DE5 		str	r2, [sp, #4]
 4052 22ec 0630A0E1 		mov	r3, r6
 4053 22f0 0510A0E3 		mov	r1, #5
 4054 22f4 DE20A0E3 		mov	r2, #222
 4055 22f8 50019FE5 		ldr	r0, .L239+4
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4056              		.loc 1 1244 0
 4057 22fc 24E08DE5 		str	lr, [sp, #36]
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4058              		.loc 1 1243 0
 4059 2300 FEFFFFEB 		bl	cmdSet
 4060              	.LVL470:
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4061              		.loc 1 1244 0
 4062 2304 24209DE5 		ldr	r2, [sp, #36]
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4063              		.loc 1 1245 0
 4064 2308 6FB047E2 		sub	fp, r7, #111
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4065              		.loc 1 1244 0
 4066 230c FF3002E2 		and	r3, r2, #255
 4067 2310 0320A0E3 		mov	r2, #3
 4068 2314 00308DE5 		str	r3, [sp]
 4069 2318 04208DE5 		str	r2, [sp, #4]
 4070 231c 0630A0E1 		mov	r3, r6
 4071 2320 0510A0E3 		mov	r1, #5
 4072 2324 E020A0E3 		mov	r2, #224
 4073 2328 20019FE5 		ldr	r0, .L239+4
 4074 232c FEFFFFEB 		bl	cmdSet
 4075              	.LVL471:
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4076              		.loc 1 1245 0
 4077 2330 0490A0E3 		mov	r9, #4
 4078 2334 FF300BE2 		and	r3, fp, #255
1246:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 4079              		.loc 1 1246 0
 4080 2338 7F7087E2 		add	r7, r7, #127
 4081              	.LVL472:
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4082              		.loc 1 1245 0
 4083 233c 00308DE5 		str	r3, [sp]
 4084 2340 04908DE5 		str	r9, [sp, #4]
 4085 2344 0630A0E1 		mov	r3, r6
 4086 2348 0510A0E3 		mov	r1, #5
 4087 234c DD20A0E3 		mov	r2, #221
 4088 2350 F8009FE5 		ldr	r0, .L239+4
 4089 2354 FEFFFFEB 		bl	cmdSet
 4090              	.LVL473:
1246:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 4091              		.loc 1 1246 0
 4092 2358 FF2007E2 		and	r2, r7, #255
 4093 235c 0510A0E3 		mov	r1, #5
 4094 2360 0630A0E1 		mov	r3, r6
 4095 2364 00208DE5 		str	r2, [sp]
 4096 2368 04108DE5 		str	r1, [sp, #4]
 4097 236c E120A0E3 		mov	r2, #225
 4098 2370 D8009FE5 		ldr	r0, .L239+4
 4099 2374 FEFFFFEB 		bl	cmdSet
 4100              	.LVL474:
1248:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4101              		.loc 1 1248 0
 4102 2378 14C09DE5 		ldr	ip, [sp, #20]
 4103 237c 24E09DE5 		ldr	lr, [sp, #36]
 4104 2380 20309DE5 		ldr	r3, [sp, #32]
 4105 2384 0C20A0E1 		mov	r2, ip
1247:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 4106              		.loc 1 1247 0
 4107 2388 18C09DE5 		ldr	ip, [sp, #24]
1248:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4108              		.loc 1 1248 0
 4109 238c 04E08DE5 		str	lr, [sp, #4]
 4110 2390 00308DE5 		str	r3, [sp]
 4111 2394 0C708DE5 		str	r7, [sp, #12]
 4112 2398 1C309DE5 		ldr	r3, [sp, #28]
 4113 239c 08B08DE5 		str	fp, [sp, #8]
 4114 23a0 0900A0E1 		mov	r0, r9
 4115 23a4 AC109FE5 		ldr	r1, .L239+12
1247:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 4116              		.loc 1 1247 0
 4117 23a8 05C2C4E5 		strb	ip, [r4, #517]
1248:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4118              		.loc 1 1248 0
 4119 23ac FEFFFFEB 		bl	CyU3PDebugPrint
 4120              	.LVL475:
1253:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 4121              		.loc 1 1253 0
 4122 23b0 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 4123              	.LVL476:
1252:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 4124              		.loc 1 1252 0
 4125 23b4 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 4126              	.LVL477:
1254:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 4127              		.loc 1 1254 0
 4128 23b8 00608DE5 		str	r6, [sp]
 4129 23bc 0730A0E1 		mov	r3, r7
 4130 23c0 04808DE5 		str	r8, [sp, #4]
 4131 23c4 0610A0E3 		mov	r1, #6
 4132 23c8 8520A0E3 		mov	r2, #133
 4133 23cc 7C009FE5 		ldr	r0, .L239+4
 4134 23d0 FEFFFFEB 		bl	cmdSet
 4135              	.LVL478:
1255:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 4136              		.loc 1 1255 0
 4137 23d4 40048DE8 		stmia	sp, {r6, r10}
 4138 23d8 70009FE5 		ldr	r0, .L239+4
 4139 23dc 0730A0E1 		mov	r3, r7
 4140 23e0 0610A0E3 		mov	r1, #6
 4141 23e4 8620A0E3 		mov	r2, #134
 4142 23e8 FEFFFFEB 		bl	cmdSet
 4143              	.LVL479:
1257:../uvc.c      **** 
 4144              		.loc 1 1257 0
 4145 23ec 0620A0E1 		mov	r2, r6
 4146 23f0 0530A0E1 		mov	r3, r5
 4147 23f4 0900A0E1 		mov	r0, r9
 4148 23f8 54109FE5 		ldr	r1, .L239+8
1256:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4149              		.loc 1 1256 0
 4150 23fc 1D62C4E5 		strb	r6, [r4, #541]
1257:../uvc.c      **** 
 4151              		.loc 1 1257 0
 4152 2400 FEFFFFEB 		bl	CyU3PDebugPrint
 4153              	.LVL480:
1262:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 4154              		.loc 1 1262 0
 4155 2404 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 4156              	.LVL481:
1263:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 4157              		.loc 1 1263 0
 4158 2408 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 4159 240c 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 4160 2410 40018DE8 		stmia	sp, {r6, r8}
 4161 2414 34009FE5 		ldr	r0, .L239+4
 4162 2418 0710A0E3 		mov	r1, #7
 4163 241c FEFFFFEB 		bl	cmdSet
 4164              	.LVL482:
1265:../uvc.c      **** 
 4165              		.loc 1 1265 0
 4166 2420 0620A0E1 		mov	r2, r6
 4167 2424 0530A0E1 		mov	r3, r5
 4168 2428 0900A0E1 		mov	r0, r9
 4169 242c 20109FE5 		ldr	r1, .L239+8
1264:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4170              		.loc 1 1264 0
 4171 2430 3552C4E5 		strb	r5, [r4, #565]
1265:../uvc.c      **** 
 4172              		.loc 1 1265 0
 4173 2434 FEFFFFEB 		bl	CyU3PDebugPrint
 4174              	.LVL483:
1267:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 4175              		.loc 1 1267 0
 4176 2438 10209FE5 		ldr	r2, .L239+4
 4177 243c 1C0092E5 		ldr	r0, [r2, #28]
1270:../uvc.c      **** 
 4178              		.loc 1 1270 0
 4179 2440 2CD08DE2 		add	sp, sp, #44
 4180              		@ sp needed
 4181 2444 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4182              	.LVL484:
1267:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 4183              		.loc 1 1267 0
 4184 2448 FEFFFFEA 		b	_txe_mutex_put
 4185              	.LVL485:
 4186              	.L240:
 4187              		.align	2
 4188              	.L239:
 4189 244c 00000000 		.word	.LANCHOR1
 4190 2450 00000000 		.word	cmdQu
 4191 2454 28040000 		.word	.LC23
 4192 2458 48040000 		.word	.LC24
 4193              		.cfi_endproc
 4194              	.LFE4:
 4196              		.align	2
 4197              		.global	CyFxUVCAddHeader
 4199              	CyFxUVCAddHeader:
 4200              	.LFB5:
1278:../uvc.c      ****     /* Copy header to buffer */
 4201              		.loc 1 1278 0
 4202              		.cfi_startproc
 4203              		@ args = 0, pretend = 0, frame = 0
 4204              		@ frame_needed = 0, uses_anonymous_args = 0
 4205              	.LVL486:
 4206 245c 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 4207              	.LCFI18:
 4208              		.cfi_def_cfa_offset 16
 4209              		.cfi_offset 3, -16
 4210              		.cfi_offset 4, -12
 4211              		.cfi_offset 5, -8
 4212              		.cfi_offset 14, -4
1278:../uvc.c      ****     /* Copy header to buffer */
 4213              		.loc 1 1278 0
 4214 2460 0040A0E1 		mov	r4, r0
 4215 2464 0150A0E1 		mov	r5, r1
1280:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 4216              		.loc 1 1280 0
 4217 2468 30009FE5 		ldr	r0, .L246
 4218              	.LVL487:
 4219 246c 0010E0E3 		mvn	r1, #0
 4220              	.LVL488:
 4221 2470 FEFFFFEB 		bl	_txe_mutex_get
 4222              	.LVL489:
1281:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 4223              		.loc 1 1281 0
 4224 2474 0400A0E1 		mov	r0, r4
 4225 2478 24109FE5 		ldr	r1, .L246+4
 4226 247c 0C20A0E3 		mov	r2, #12
 4227 2480 FEFFFFEB 		bl	CyU3PMemCopy
 4228              	.LVL490:
1282:../uvc.c      **** 
 4229              		.loc 1 1282 0
 4230 2484 14009FE5 		ldr	r0, .L246
 4231 2488 FEFFFFEB 		bl	_txe_mutex_put
 4232              	.LVL491:
1285:../uvc.c      ****     {
 4233              		.loc 1 1285 0
 4234 248c 020015E3 		tst	r5, #2
1287:../uvc.c      ****     }
 4235              		.loc 1 1287 0
 4236 2490 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 4237 2494 02308313 		orrne	r3, r3, #2
 4238 2498 0130C415 		strneb	r3, [r4, #1]
 4239 249c 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 4240              	.L247:
 4241              		.align	2
 4242              	.L246:
 4243 24a0 00000000 		.word	imgHdMux
 4244 24a4 80040000 		.word	.LANCHOR1+1152
 4245              		.cfi_endproc
 4246              	.LFE5:
 4248              		.align	2
 4249              		.global	CyFxAppErrorHandler
 4251              	CyFxAppErrorHandler:
 4252              	.LFB6:
1297:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 4253              		.loc 1 1297 0
 4254              		.cfi_startproc
 4255              		@ Volatile: function does not return.
 4256              		@ args = 0, pretend = 0, frame = 0
 4257              		@ frame_needed = 0, uses_anonymous_args = 0
 4258              	.LVL492:
 4259 24a8 08402DE9 		stmfd	sp!, {r3, lr}
 4260              	.LCFI19:
 4261              		.cfi_def_cfa_offset 8
 4262              		.cfi_offset 3, -8
 4263              		.cfi_offset 14, -4
 4264              	.LVL493:
 4265              	.L249:
1307:../uvc.c      ****         CyU3PThreadSleep (1000);
 4266              		.loc 1 1307 0 discriminator 1
 4267 24ac 10109FE5 		ldr	r1, .L250
 4268 24b0 0400A0E3 		mov	r0, #4
 4269 24b4 FEFFFFEB 		bl	CyU3PDebugPrint
 4270              	.LVL494:
1308:../uvc.c      ****     }
 4271              		.loc 1 1308 0 discriminator 1
 4272 24b8 FA0FA0E3 		mov	r0, #1000
 4273 24bc FEFFFFEB 		bl	_tx_thread_sleep
 4274              	.LVL495:
 4275 24c0 F9FFFFEA 		b	.L249
 4276              	.L251:
 4277              		.align	2
 4278              	.L250:
 4279 24c4 80040000 		.word	.LC25
 4280              		.cfi_endproc
 4281              	.LFE6:
 4283              		.align	2
 4284              		.global	UVCAppEP0Thread_Entry
 4286              	UVCAppEP0Thread_Entry:
 4287              	.LFB24:
3257:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 4288              		.loc 1 3257 0
 4289              		.cfi_startproc
 4290              		@ args = 0, pretend = 0, frame = 80
 4291              		@ frame_needed = 0, uses_anonymous_args = 0
 4292              	.LVL496:
 4293 24c8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4294              	.LCFI20:
 4295              		.cfi_def_cfa_offset 36
 4296              		.cfi_offset 4, -36
 4297              		.cfi_offset 5, -32
 4298              		.cfi_offset 6, -28
 4299              		.cfi_offset 7, -24
 4300              		.cfi_offset 8, -20
 4301              		.cfi_offset 9, -16
 4302              		.cfi_offset 10, -12
 4303              		.cfi_offset 11, -8
 4304              		.cfi_offset 14, -4
 4305 24cc F4BF9FE5 		ldr	fp, .L658
 4306 24d0 F4AF9FE5 		ldr	r10, .L658+4
 4307 24d4 F46F9FE5 		ldr	r6, .L658+8
3331:../uvc.c      ****                 {
 4308              		.loc 1 3331 0
 4309 24d8 F45F9FE5 		ldr	r5, .L658+12
 4310              	.LBB132:
 4311              	.LBB133:
2939:../uvc.c      ****     {
 4312              		.loc 1 2939 0
 4313 24dc F49F9FE5 		ldr	r9, .L658+16
 4314              	.LBE133:
 4315              	.LBE132:
3257:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 4316              		.loc 1 3257 0
 4317 24e0 6CD04DE2 		sub	sp, sp, #108
 4318              	.LCFI21:
 4319              		.cfi_def_cfa_offset 144
 4320              	.LVL497:
3279:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 4321              		.loc 1 3279 0
 4322 24e4 0B40A0E1 		mov	r4, fp
 4323              	.LVL498:
 4324              	.L548:
 4325 24e8 0030E0E3 		mvn	r3, #0
 4326 24ec 00308DE5 		str	r3, [sp]
 4327 24f0 D00F9FE5 		ldr	r0, .L658
 4328 24f4 4C10A0E3 		mov	r1, #76
 4329 24f8 0120A0E3 		mov	r2, #1
 4330 24fc 50308DE2 		add	r3, sp, #80
 4331              	.LVL499:
 4332 2500 FEFFFFEB 		bl	_txe_event_flags_get
 4333              	.LVL500:
 4334 2504 000050E3 		cmp	r0, #0
 4335 2508 5900001A 		bne	.L254
3283:../uvc.c      ****             {
 4336              		.loc 1 3283 0
 4337 250c 443094E5 		ldr	r3, [r4, #68]
 4338 2510 000053E3 		cmp	r3, #0
 4339 2514 8E00000A 		beq	.L621
 4340              	.L256:
3292:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4341              		.loc 1 3292 0
 4342 2518 50309DE5 		ldr	r3, [sp, #80]
 4343 251c 0C0013E3 		tst	r3, #12
 4344 2520 7600001A 		bne	.L622
 4345              	.L258:
3299:../uvc.c      ****             {
 4346              		.loc 1 3299 0
 4347 2524 040013E3 		tst	r3, #4
 4348 2528 1F00000A 		beq	.L259
3301:../uvc.c      ****                 {
 4349              		.loc 1 3301 0
 4350 252c B020D5E1 		ldrh	r2, [r5]
 4351 2530 2224A0E1 		mov	r2, r2, lsr #8
 4352 2534 030052E3 		cmp	r2, #3
 4353 2538 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4354 253c 150000EA 		b	.L260
 4355              	.L262:
 4356 2540 98250000 		.word	.L260
 4357 2544 50250000 		.word	.L263
 4358 2548 7C260000 		.word	.L264
 4359 254c B8260000 		.word	.L265
 4360              	.L263:
 4361              	.LBB144:
 4362              	.LBB145:
2619:../uvc.c      ****     {
 4363              		.loc 1 2619 0
 4364 2550 B020D9E1 		ldrh	r2, [r9]
 4365 2554 060C52E3 		cmp	r2, #1536
 4366 2558 DB01000A 		beq	.L294
 4367 255c E200009A 		bls	.L623
 4368 2560 090C52E3 		cmp	r2, #2304
 4369 2564 A102000A 		beq	.L302
 4370 2568 3B01009A 		bls	.L624
 4371 256c 0B0C52E3 		cmp	r2, #2816
 4372 2570 C302000A 		beq	.L305
 4373 2574 030B52E3 		cmp	r2, #3072
 4374 2578 7402000A 		beq	.L306
 4375 257c 0A0C52E3 		cmp	r2, #2560
 4376 2580 E201000A 		beq	.L625
 4377              	.L293:
2676:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4378              		.loc 1 2676 0
 4379 2584 503F9FE5 		ldr	r3, .L658+20
 4380 2588 0400A0E3 		mov	r0, #4
 4381 258c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 4382 2590 481F9FE5 		ldr	r1, .L658+24
 4383 2594 FEFFFFEB 		bl	CyU3PDebugPrint
 4384              	.LVL501:
 4385              	.L260:
 4386              	.LBE145:
 4387              	.LBE144:
3322:../uvc.c      ****                         break;
 4388              		.loc 1 3322 0
 4389 2598 0000A0E3 		mov	r0, #0
 4390 259c 0020A0E1 		mov	r2, r0
 4391 25a0 0110A0E3 		mov	r1, #1
 4392 25a4 FEFFFFEB 		bl	CyU3PUsbStall
 4393              	.LVL502:
 4394 25a8 50309DE5 		ldr	r3, [sp, #80]
 4395              	.L259:
3327:../uvc.c      ****             {
 4396              		.loc 1 3327 0
 4397 25ac 080013E3 		tst	r3, #8
 4398 25b0 0700000A 		beq	.L491
3331:../uvc.c      ****                 {
 4399              		.loc 1 3331 0
 4400 25b4 B030D5E1 		ldrh	r3, [r5]
 4401 25b8 010053E3 		cmp	r3, #1
 4402 25bc 8A00000A 		beq	.L492
 4403              	.L493:
 4404              	.LBB321:
 4405              	.LBB134:
3246:../uvc.c      ****             break;
 4406              		.loc 1 3246 0
 4407 25c0 0000A0E3 		mov	r0, #0
 4408 25c4 0020A0E1 		mov	r2, r0
 4409 25c8 0110A0E3 		mov	r1, #1
 4410 25cc FEFFFFEB 		bl	CyU3PUsbStall
 4411              	.LVL503:
 4412              	.L506:
 4413 25d0 50309DE5 		ldr	r3, [sp, #80]
 4414              	.L491:
 4415              	.LBE134:
 4416              	.LBE321:
3342:../uvc.c      ****             {
 4417              		.loc 1 3342 0
 4418 25d4 400013E3 		tst	r3, #64
 4419 25d8 2500000A 		beq	.L254
3347:../uvc.c      **** 
 4420              		.loc 1 3347 0
 4421 25dc 1800A0E3 		mov	r0, #24
 4422 25e0 58108DE2 		add	r1, sp, #88
 4423 25e4 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 4424              	.LVL504:
3352:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4425              		.loc 1 3352 0
 4426 25e8 58309DE5 		ldr	r3, [sp, #88]
 4427 25ec 000053E3 		cmp	r3, #0
 4428 25f0 5D00001A 		bne	.L626
3376:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4429              		.loc 1 3376 0
 4430 25f4 4326DAE5 		ldrb	r2, [r10, #1603]	@ zero_extendqisi2
 4431 25f8 000052E3 		cmp	r2, #0
 4432 25fc 1C00000A 		beq	.L254
3378:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4433              		.loc 1 3378 0
 4434 2600 002096E5 		ldr	r2, [r6]
 4435 2604 0210A0E3 		mov	r1, #2
 4436 2608 0010C2E5 		strb	r1, [r2]
3379:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4437              		.loc 1 3379 0
 4438 260c 001096E5 		ldr	r1, [r6]
 4439 2610 0120A0E3 		mov	r2, #1
 4440 2614 0120C1E5 		strb	r2, [r1, #1]
3380:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4441              		.loc 1 3380 0
 4442 2618 001096E5 		ldr	r1, [r6]
3384:../uvc.c      **** 					interStabuf.status = 0;
 4443              		.loc 1 3384 0
 4444 261c 01CBA0E3 		mov	ip, #1024
3380:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4445              		.loc 1 3380 0
 4446 2620 0230C1E5 		strb	r3, [r1, #2]
3381:../uvc.c      **** 
 4447              		.loc 1 3381 0
 4448 2624 001096E5 		ldr	r1, [r6]
3387:../uvc.c      **** 
 4449              		.loc 1 3387 0
 4450 2628 0480A0E3 		mov	r8, #4
3381:../uvc.c      **** 
 4451              		.loc 1 3381 0
 4452 262c 0320C1E5 		strb	r2, [r1, #3]
3383:../uvc.c      **** 					interStabuf.size   = 1024;
 4453              		.loc 1 3383 0
 4454 2630 002096E5 		ldr	r2, [r6]
3390:../uvc.c      **** 
 4455              		.loc 1 3390 0
 4456 2634 0010E0E3 		mvn	r1, #0
 4457 2638 A40E9FE5 		ldr	r0, .L658+28
3385:../uvc.c      **** 
 4458              		.loc 1 3385 0
 4459 263c B436CDE1 		strh	r3, [sp, #100]	@ movhi
3383:../uvc.c      **** 					interStabuf.size   = 1024;
 4460              		.loc 1 3383 0
 4461 2640 5C208DE5 		str	r2, [sp, #92]
3384:../uvc.c      **** 					interStabuf.status = 0;
 4462              		.loc 1 3384 0
 4463 2644 B2C6CDE1 		strh	ip, [sp, #98]	@ movhi
3387:../uvc.c      **** 
 4464              		.loc 1 3387 0
 4465 2648 B086CDE1 		strh	r8, [sp, #96]	@ movhi
3390:../uvc.c      **** 
 4466              		.loc 1 3390 0
 4467 264c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 4468              	.LVL505:
3393:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4469              		.loc 1 3393 0
 4470 2650 8C0E9FE5 		ldr	r0, .L658+28
 4471 2654 5C108DE2 		add	r1, sp, #92
 4472 2658 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4473              	.LVL506:
3394:../uvc.c      **** 					{
 4474              		.loc 1 3394 0
 4475 265c 000050E3 		cmp	r0, #0
 4476 2660 AD05001A 		bne	.L627
3400:../uvc.c      **** 					stiflag = 0xFF;
 4477              		.loc 1 3400 0
 4478 2664 60EE9FE5 		ldr	lr, .L658+4
3401:../uvc.c      **** 				}
 4479              		.loc 1 3401 0
 4480 2668 FF30A0E3 		mov	r3, #255
3400:../uvc.c      **** 					stiflag = 0xFF;
 4481              		.loc 1 3400 0
 4482 266c 4306CEE5 		strb	r0, [lr, #1603]
3401:../uvc.c      **** 				}
 4483              		.loc 1 3401 0
 4484 2670 30308BE5 		str	r3, [fp, #48]
 4485              	.LVL507:
 4486              	.L254:
3555:../uvc.c      ****     }
 4487              		.loc 1 3555 0
 4488 2674 FEFFFFEB 		bl	_txe_thread_relinquish
 4489              	.LVL508:
3556:../uvc.c      **** }
 4490              		.loc 1 3556 0
 4491 2678 9AFFFFEA 		b	.L548
 4492              	.L264:
 4493              	.LBB322:
 4494              	.LBB323:
2544:../uvc.c      ****     {
 4495              		.loc 1 2544 0
 4496 267c B020D9E1 		ldrh	r2, [r9]
 4497 2680 060C52E3 		cmp	r2, #1536
 4498 2684 8C01000A 		beq	.L267
 4499 2688 8A00008A 		bhi	.L268
 4500 268c 030C52E3 		cmp	r2, #768
 4501 2690 8501000A 		beq	.L269
 4502 2694 CC00008A 		bhi	.L270
 4503 2698 010C52E3 		cmp	r2, #256
 4504 269c 7A01000A 		beq	.L271
 4505 26a0 020C52E3 		cmp	r2, #512
 4506 26a4 B6FFFF1A 		bne	.L293
 4507              	.L445:
 4508              	.LVL509:
 4509              	.LBE323:
 4510              	.LBE322:
 4511              	.LBB351:
 4512              	.LBB352:
2891:../uvc.c      ****     		break;
 4513              		.loc 1 2891 0
 4514 26a8 1A00A0E3 		mov	r0, #26
 4515 26ac FEFFFFEB 		bl	ControlHandle
 4516              	.LVL510:
 4517 26b0 50309DE5 		ldr	r3, [sp, #80]
 4518 26b4 BCFFFFEA 		b	.L259
 4519              	.L265:
2844:../uvc.c      ****     {
 4520              		.loc 1 2844 0
 4521 26b8 B030D9E1 		ldrh	r3, [r9]
 4522 26bc 090C53E3 		cmp	r3, #2304
 4523 26c0 4103000A 		beq	.L431
 4524 26c4 6D00008A 		bhi	.L432
 4525 26c8 010B53E3 		cmp	r3, #1024
 4526 26cc 3A03000A 		beq	.L433
 4527 26d0 CD00009A 		bls	.L628
 4528 26d4 060C53E3 		cmp	r3, #1536
 4529 26d8 0B03000A 		beq	.L438
 4530 26dc EB02009A 		bls	.L629
 4531 26e0 070C53E3 		cmp	r3, #1792
 4532 26e4 0C03000A 		beq	.L441
 4533 26e8 020B53E3 		cmp	r3, #2048
 4534 26ec A9FFFF1A 		bne	.L260
 4535              	.LVL511:
2876:../uvc.c      ****     		break;
 4536              		.loc 1 2876 0
 4537 26f0 1700A0E3 		mov	r0, #23
 4538 26f4 FEFFFFEB 		bl	ControlHandle
 4539              	.LVL512:
 4540 26f8 50309DE5 		ldr	r3, [sp, #80]
 4541 26fc AAFFFFEA 		b	.L259
 4542              	.L622:
 4543              	.LBE352:
 4544              	.LBE351:
3293:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 4545              		.loc 1 3293 0
 4546 2700 E00D9FE5 		ldr	r0, .L658+32
 4547 2704 D01D9FE5 		ldr	r1, .L658+20
 4548 2708 DC2D9FE5 		ldr	r2, .L658+36
 4549 270c 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 4550 2710 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 4551 2714 B010D2E1 		ldrh	r1, [r2]
 4552 2718 B0C0D9E1 		ldrh	ip, [r9]
 4553 271c BC20DBE5 		ldrb	r2, [fp, #188]	@ zero_extendqisi2
 4554 2720 00008DE5 		str	r0, [sp]
 4555 2724 B000D5E1 		ldrh	r0, [r5]
 4556 2728 10108DE5 		str	r1, [sp, #16]
 4557 272c 0010A0E3 		mov	r1, #0
 4558 2730 0C008DE5 		str	r0, [sp, #12]
 4559 2734 14108DE5 		str	r1, [sp, #20]
 4560 2738 04E08DE5 		str	lr, [sp, #4]
 4561 273c 08C08DE5 		str	ip, [sp, #8]
 4562 2740 0400A0E3 		mov	r0, #4
 4563 2744 A41D9FE5 		ldr	r1, .L658+40
 4564 2748 FEFFFFEB 		bl	CyU3PDebugPrint
 4565              	.LVL513:
 4566 274c 50309DE5 		ldr	r3, [sp, #80]
 4567 2750 73FFFFEA 		b	.L258
 4568              	.L621:
3285:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4569              		.loc 1 3285 0
 4570 2754 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 4571              	.LVL514:
3286:../uvc.c      ****                 {
 4572              		.loc 1 3286 0
 4573 2758 000050E3 		cmp	r0, #0
3288:../uvc.c      ****                 }
 4574              		.loc 1 3288 0
 4575 275c 0130A013 		movne	r3, #1
3285:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4576              		.loc 1 3285 0
 4577 2760 BC00C4E5 		strb	r0, [r4, #188]
3288:../uvc.c      ****                 }
 4578              		.loc 1 3288 0
 4579 2764 44308415 		strne	r3, [r4, #68]
 4580 2768 6AFFFFEA 		b	.L256
 4581              	.L626:
3352:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4582              		.loc 1 3352 0 discriminator 1
 4583 276c 4336DAE5 		ldrb	r3, [r10, #1603]	@ zero_extendqisi2
 4584 2770 000053E3 		cmp	r3, #0
 4585 2774 BEFFFF1A 		bne	.L254
3354:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4586              		.loc 1 3354 0
 4587 2778 002096E5 		ldr	r2, [r6]
 4588 277c 0210A0E3 		mov	r1, #2
 4589 2780 0010C2E5 		strb	r1, [r2]
3355:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4590              		.loc 1 3355 0
 4591 2784 002096E5 		ldr	r2, [r6]
 4592 2788 0170A0E3 		mov	r7, #1
 4593 278c 0170C2E5 		strb	r7, [r2, #1]
3356:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4594              		.loc 1 3356 0
 4595 2790 001096E5 		ldr	r1, [r6]
3360:../uvc.c      **** 					interStabuf.status = 0;
 4596              		.loc 1 3360 0
 4597 2794 012BA0E3 		mov	r2, #1024
3356:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4598              		.loc 1 3356 0
 4599 2798 0230C1E5 		strb	r3, [r1, #2]
3357:../uvc.c      **** 
 4600              		.loc 1 3357 0
 4601 279c 001096E5 		ldr	r1, [r6]
3363:../uvc.c      **** 
 4602              		.loc 1 3363 0
 4603 27a0 0480A0E3 		mov	r8, #4
3357:../uvc.c      **** 
 4604              		.loc 1 3357 0
 4605 27a4 0330C1E5 		strb	r3, [r1, #3]
3359:../uvc.c      **** 					interStabuf.size   = 1024;
 4606              		.loc 1 3359 0
 4607 27a8 001096E5 		ldr	r1, [r6]
3366:../uvc.c      **** 
 4608              		.loc 1 3366 0
 4609 27ac 300D9FE5 		ldr	r0, .L658+28
3359:../uvc.c      **** 					interStabuf.size   = 1024;
 4610              		.loc 1 3359 0
 4611 27b0 5C108DE5 		str	r1, [sp, #92]
3366:../uvc.c      **** 
 4612              		.loc 1 3366 0
 4613 27b4 0010E0E3 		mvn	r1, #0
3361:../uvc.c      **** 
 4614              		.loc 1 3361 0
 4615 27b8 B436CDE1 		strh	r3, [sp, #100]	@ movhi
3360:../uvc.c      **** 					interStabuf.status = 0;
 4616              		.loc 1 3360 0
 4617 27bc B226CDE1 		strh	r2, [sp, #98]	@ movhi
3363:../uvc.c      **** 
 4618              		.loc 1 3363 0
 4619 27c0 B086CDE1 		strh	r8, [sp, #96]	@ movhi
3366:../uvc.c      **** 
 4620              		.loc 1 3366 0
 4621 27c4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 4622              	.LVL515:
3369:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4623              		.loc 1 3369 0
 4624 27c8 140D9FE5 		ldr	r0, .L658+28
 4625 27cc 5C108DE2 		add	r1, sp, #92
 4626 27d0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4627              	.LVL516:
3370:../uvc.c      **** 					{
 4628              		.loc 1 3370 0
 4629 27d4 000050E3 		cmp	r0, #0
 4630 27d8 8303001A 		bne	.L630
3375:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4631              		.loc 1 3375 0
 4632 27dc E8CC9FE5 		ldr	ip, .L658+4
 4633 27e0 4376CCE5 		strb	r7, [ip, #1603]
3555:../uvc.c      ****     }
 4634              		.loc 1 3555 0
 4635 27e4 FEFFFFEB 		bl	_txe_thread_relinquish
 4636              	.LVL517:
 4637 27e8 3EFFFFEA 		b	.L548
 4638              	.L492:
 4639              	.LVL518:
 4640              	.LBB417:
 4641              	.LBB135:
2939:../uvc.c      ****     {
 4642              		.loc 1 2939 0
 4643 27ec B020D9E1 		ldrh	r2, [r9]
 4644 27f0 030C52E3 		cmp	r2, #768
 4645 27f4 4700000A 		beq	.L494
 4646 27f8 1200008A 		bhi	.L495
 4647 27fc 010C52E3 		cmp	r2, #256
 4648 2800 5600000A 		beq	.L496
 4649 2804 020C52E3 		cmp	r2, #512
 4650 2808 6CFFFF1A 		bne	.L493
2992:../uvc.c      ****             {
 4651              		.loc 1 2992 0
 4652 280c C83C9FE5 		ldr	r3, .L658+20
 4653 2810 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 4654 2814 810053E3 		cmp	r3, #129
 4655 2818 5800000A 		beq	.L536
 4656 281c 5402009A 		bls	.L631
 4657 2820 850053E3 		cmp	r3, #133
 4658 2824 4500000A 		beq	.L529
 4659 2828 860053E3 		cmp	r3, #134
 4660 282c 63FFFF1A 		bne	.L493
 4661              	.L616:
3194:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4662              		.loc 1 3194 0
 4663 2830 0330A0E3 		mov	r3, #3
3195:../uvc.c      ****                         break;
 4664              		.loc 1 3195 0
 4665 2834 181D9FE5 		ldr	r1, .L658+140
 4666 2838 0100A0E3 		mov	r0, #1
3194:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4667              		.loc 1 3194 0
 4668 283c 5830CBE5 		strb	r3, [fp, #88]
3195:../uvc.c      ****                         break;
 4669              		.loc 1 3195 0
 4670 2840 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4671              	.LVL519:
 4672 2844 61FFFFEA 		b	.L506
 4673              	.L495:
2939:../uvc.c      ****     {
 4674              		.loc 1 2939 0
 4675 2848 010B52E3 		cmp	r2, #1024
 4676 284c 4F00000A 		beq	.L498
 4677 2850 050C52E3 		cmp	r2, #1280
 4678 2854 59FFFF1A 		bne	.L493
3191:../uvc.c      ****                 {
 4679              		.loc 1 3191 0
 4680 2858 7C2C9FE5 		ldr	r2, .L658+20
 4681 285c 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4682 2860 810052E3 		cmp	r2, #129
 4683 2864 4500000A 		beq	.L536
 4684 2868 6A02009A 		bls	.L632
 4685 286c 850052E3 		cmp	r2, #133
 4686 2870 0D03000A 		beq	.L539
 4687 2874 860052E3 		cmp	r2, #134
 4688 2878 ECFFFF0A 		beq	.L616
 4689 287c 4FFFFFEA 		b	.L493
 4690              	.LVL520:
 4691              	.L432:
 4692              	.LBE135:
 4693              	.LBE417:
 4694              	.LBB418:
 4695              	.LBB407:
2844:../uvc.c      ****     {
 4696              		.loc 1 2844 0
 4697 2880 0F0C53E3 		cmp	r3, #3840
 4698 2884 D402000A 		beq	.L443
 4699 2888 6900009A 		bls	.L633
 4700 288c 110C53E3 		cmp	r3, #4352
 4701 2890 9902000A 		beq	.L448
 4702 2894 7702009A 		bls	.L634
 4703 2898 120C53E3 		cmp	r3, #4608
 4704 289c AA02000A 		beq	.L451
 4705 28a0 130C53E3 		cmp	r3, #4864
 4706 28a4 3BFFFF1A 		bne	.L260
 4707              	.LVL521:
2919:../uvc.c      ****     		break;
 4708              		.loc 1 2919 0
 4709 28a8 2600A0E3 		mov	r0, #38
 4710 28ac FEFFFFEB 		bl	ControlHandle
 4711              	.LVL522:
 4712 28b0 50309DE5 		ldr	r3, [sp, #80]
 4713 28b4 3CFFFFEA 		b	.L259
 4714              	.L268:
 4715              	.LBE407:
 4716              	.LBE418:
 4717              	.LBB419:
 4718              	.LBB340:
2544:../uvc.c      ****     {
 4719              		.loc 1 2544 0
 4720 28b8 0A0C52E3 		cmp	r2, #2560
 4721 28bc EE00000A 		beq	.L274
 4722 28c0 4900009A 		bls	.L635
 4723 28c4 0D0C52E3 		cmp	r2, #3328
 4724 28c8 EB00000A 		beq	.L274
 4725 28cc 0E0C52E3 		cmp	r2, #3584
 4726 28d0 C400000A 		beq	.L278
 4727 28d4 030B52E3 		cmp	r2, #3072
 4728 28d8 29FFFF1A 		bne	.L293
 4729              	.LVL523:
2585:../uvc.c      ****     		break;
 4730              		.loc 1 2585 0
 4731 28dc 0B00A0E3 		mov	r0, #11
 4732 28e0 FEFFFFEB 		bl	ControlHandle
 4733              	.LVL524:
 4734 28e4 50309DE5 		ldr	r3, [sp, #80]
 4735 28e8 2FFFFFEA 		b	.L259
 4736              	.L623:
 4737              	.LBE340:
 4738              	.LBE419:
 4739              	.LBB420:
 4740              	.LBB310:
2619:../uvc.c      ****     {
 4741              		.loc 1 2619 0
 4742 28ec 030C52E3 		cmp	r2, #768
 4743 28f0 3E01000A 		beq	.L296
 4744 28f4 5D00008A 		bhi	.L297
 4745 28f8 010C52E3 		cmp	r2, #256
 4746 28fc 1F01000A 		beq	.L298
 4747 2900 020C52E3 		cmp	r2, #512
 4748 2904 1EFFFF1A 		bne	.L293
 4749              	.LVL525:
2627:../uvc.c      ****     		break;
 4750              		.loc 1 2627 0
 4751 2908 0100A0E3 		mov	r0, #1
 4752 290c FEFFFFEB 		bl	CTControlHandle
 4753              	.LVL526:
 4754 2910 50309DE5 		ldr	r3, [sp, #80]
 4755 2914 24FFFFEA 		b	.L259
 4756              	.LVL527:
 4757              	.L494:
 4758              	.LBE310:
 4759              	.LBE420:
 4760              	.LBB421:
 4761              	.LBB136:
3066:../uvc.c      ****                 {
 4762              		.loc 1 3066 0
 4763 2918 BC2B9FE5 		ldr	r2, .L658+20
 4764 291c 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4765 2920 830052E3 		cmp	r2, #131
 4766 2924 8B00009A 		bls	.L636
 4767 2928 860052E3 		cmp	r2, #134
 4768 292c 2000000A 		beq	.L617
 4769 2930 870052E3 		cmp	r2, #135
 4770 2934 A400000A 		beq	.L520
 4771              	.L620:
 4772 2938 850052E3 		cmp	r2, #133
 4773 293c 1FFFFF1A 		bne	.L493
 4774              	.L529:
3123:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4775              		.loc 1 3123 0
 4776 2940 1A20A0E3 		mov	r2, #26
3124:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4777              		.loc 1 3124 0
 4778 2944 0030A0E3 		mov	r3, #0
3125:../uvc.c      ****                         break;
 4779              		.loc 1 3125 0
 4780 2948 041C9FE5 		ldr	r1, .L658+140
 4781 294c 0200A0E3 		mov	r0, #2
3123:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4782              		.loc 1 3123 0
 4783 2950 5820CBE5 		strb	r2, [fp, #88]
3124:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4784              		.loc 1 3124 0
 4785 2954 5930CBE5 		strb	r3, [fp, #89]
3125:../uvc.c      ****                         break;
 4786              		.loc 1 3125 0
 4787 2958 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4788              	.LVL528:
 4789 295c 1BFFFFEA 		b	.L506
 4790              	.L496:
2942:../uvc.c      ****             {
 4791              		.loc 1 2942 0
 4792 2960 742B9FE5 		ldr	r2, .L658+20
 4793 2964 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4794 2968 830052E3 		cmp	r2, #131
 4795 296c 5C00009A 		bls	.L637
 4796 2970 860052E3 		cmp	r2, #134
 4797 2974 0E00000A 		beq	.L617
 4798 2978 870052E3 		cmp	r2, #135
 4799 297c EDFFFF1A 		bne	.L620
 4800              	.L536:
3205:../uvc.c      ****                         }
 4801              		.loc 1 3205 0
 4802 2980 6C1B9FE5 		ldr	r1, .L658+44
 4803 2984 1A00A0E3 		mov	r0, #26
 4804 2988 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4805              	.LVL529:
 4806 298c 0FFFFFEA 		b	.L506
 4807              	.L498:
3116:../uvc.c      ****                 {
 4808              		.loc 1 3116 0
 4809 2990 442B9FE5 		ldr	r2, .L658+20
 4810 2994 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4811 2998 810052E3 		cmp	r2, #129
 4812 299c 8A00000A 		beq	.L520
 4813 29a0 D301009A 		bls	.L638
 4814 29a4 850052E3 		cmp	r2, #133
 4815 29a8 E4FFFF0A 		beq	.L529
 4816 29ac 860052E3 		cmp	r2, #134
 4817 29b0 02FFFF1A 		bne	.L493
 4818              	.L617:
3120:../uvc.c      ****                         break;
 4819              		.loc 1 3120 0
 4820 29b4 0300A0E1 		mov	r0, r3
 4821 29b8 941B9FE5 		ldr	r1, .L658+140
3119:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4822              		.loc 1 3119 0
 4823 29bc 0330A0E3 		mov	r3, #3
 4824 29c0 5830CBE5 		strb	r3, [fp, #88]
3120:../uvc.c      ****                         break;
 4825              		.loc 1 3120 0
 4826 29c4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4827              	.LVL530:
 4828 29c8 00FFFFEA 		b	.L506
 4829              	.LVL531:
 4830              	.L270:
 4831              	.LBE136:
 4832              	.LBE421:
 4833              	.LBB422:
 4834              	.LBB341:
2544:../uvc.c      ****     {
 4835              		.loc 1 2544 0
 4836 29cc 010B52E3 		cmp	r2, #1024
 4837 29d0 F5FEFF0A 		beq	.L259
 4838 29d4 050C52E3 		cmp	r2, #1280
 4839 29d8 E9FEFF1A 		bne	.L293
 4840              	.LVL532:
2563:../uvc.c      ****       		break;
 4841              		.loc 1 2563 0
 4842 29dc 0400A0E3 		mov	r0, #4
 4843 29e0 FEFFFFEB 		bl	ControlHandle
 4844              	.LVL533:
 4845 29e4 50309DE5 		ldr	r3, [sp, #80]
 4846 29e8 EFFEFFEA 		b	.L259
 4847              	.L635:
2544:../uvc.c      ****     {
 4848              		.loc 1 2544 0
 4849 29ec 070C52E3 		cmp	r2, #1792
 4850 29f0 A900000A 		beq	.L276
 4851 29f4 020B52E3 		cmp	r2, #2048
 4852 29f8 E1FEFF1A 		bne	.L293
 4853              	.LVL534:
2575:../uvc.c      ****           		break;
 4854              		.loc 1 2575 0
 4855 29fc 0700A0E3 		mov	r0, #7
 4856 2a00 FEFFFFEB 		bl	ControlHandle
 4857              	.LVL535:
 4858 2a04 50309DE5 		ldr	r3, [sp, #80]
 4859 2a08 E7FEFFEA 		b	.L259
 4860              	.L628:
 4861              	.LBE341:
 4862              	.LBE422:
 4863              	.LBB423:
 4864              	.LBB408:
2844:../uvc.c      ****     {
 4865              		.loc 1 2844 0
 4866 2a0c 020C53E3 		cmp	r3, #512
 4867 2a10 4902000A 		beq	.L435
 4868 2a14 030C53E3 		cmp	r3, #768
 4869 2a18 4302000A 		beq	.L436
 4870 2a1c 010C53E3 		cmp	r3, #256
 4871 2a20 DCFEFF1A 		bne	.L260
 4872              	.LVL536:
2848:../uvc.c      ****     		break;
 4873              		.loc 1 2848 0
 4874 2a24 1000A0E3 		mov	r0, #16
 4875 2a28 FEFFFFEB 		bl	ControlHandle
 4876              	.LVL537:
 4877 2a2c 50309DE5 		ldr	r3, [sp, #80]
 4878 2a30 DDFEFFEA 		b	.L259
 4879              	.L633:
2844:../uvc.c      ****     {
 4880              		.loc 1 2844 0
 4881 2a34 0B0C53E3 		cmp	r3, #2816
 4882 2a38 1AFFFF0A 		beq	.L445
 4883 2a3c 0D0C53E3 		cmp	r3, #3328
 4884 2a40 8102000A 		beq	.L446
 4885 2a44 0A0C53E3 		cmp	r3, #2560
 4886 2a48 D2FEFF1A 		bne	.L260
 4887              	.LVL538:
2885:../uvc.c      ****     		}else/* no support for 1080p camera */
 4888              		.loc 1 2885 0
 4889 2a4c 1900A0E3 		mov	r0, #25
 4890 2a50 FEFFFFEB 		bl	ControlHandle
 4891              	.LVL539:
 4892 2a54 50309DE5 		ldr	r3, [sp, #80]
 4893 2a58 D3FEFFEA 		b	.L259
 4894              	.L624:
 4895              	.LBE408:
 4896              	.LBE423:
 4897              	.LBB424:
 4898              	.LBB311:
2619:../uvc.c      ****     {
 4899              		.loc 1 2619 0
 4900 2a5c 070C52E3 		cmp	r2, #1792
 4901 2a60 F300000A 		beq	.L304
 4902 2a64 020B52E3 		cmp	r2, #2048
 4903 2a68 CFFEFF0A 		beq	.L259
 4904 2a6c C4FEFFEA 		b	.L293
 4905              	.L297:
 4906 2a70 010B52E3 		cmp	r2, #1024
 4907 2a74 0A01000A 		beq	.L300
 4908 2a78 050C52E3 		cmp	r2, #1280
 4909 2a7c C0FEFF1A 		bne	.L293
 4910              	.LVL540:
 4911              	.LBB146:
 4912              	.LBB147:
 982:../uvc.c      **** 
 4913              		.loc 1 982 0
 4914 2a80 54CA9FE5 		ldr	ip, .L658+20
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4915              		.loc 1 977 0
 4916 2a84 F284DAE5 		ldrb	r8, [r10, #1266]	@ zero_extendqisi2
 4917              	.LVL541:
 982:../uvc.c      **** 
 4918              		.loc 1 982 0
 4919 2a88 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 4920              	.LVL542:
 984:../uvc.c      **** 		 {
 4921              		.loc 1 984 0
 4922 2a8c 830057E3 		cmp	r7, #131
 4923 2a90 4006000A 		beq	.L346
 4924 2a94 A903009A 		bls	.L639
 4925 2a98 850057E3 		cmp	r7, #133
 4926 2a9c 0102000A 		beq	.L408
 4927 2aa0 0E05003A 		bcc	.L352
 4928 2aa4 860057E3 		cmp	r7, #134
 4929 2aa8 F305000A 		beq	.L353
 4930 2aac 870057E3 		cmp	r7, #135
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4931              		.loc 1 1046 0
 4932 2ab0 FB14DA05 		ldreqb	r1, [r10, #1275]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4933              		.loc 1 1047 0
 4934 2ab4 FC24DA05 		ldreqb	r2, [r10, #1276]	@ zero_extendqisi2
 984:../uvc.c      **** 		 {
 4935              		.loc 1 984 0
 4936 2ab8 7105001A 		bne	.L345
 4937              	.LVL543:
 4938              	.L602:
 4939              	.LBE147:
 4940              	.LBE146:
 4941              	.LBB155:
 4942              	.LBB156:
1025:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4943              		.loc 1 1025 0
 4944 2abc 0030A0E3 		mov	r3, #0
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4945              		.loc 1 1022 0
 4946 2ac0 5810CBE5 		strb	r1, [fp, #88]
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4947              		.loc 1 1027 0
 4948 2ac4 0800A0E1 		mov	r0, r8
 4949 2ac8 841A9FE5 		ldr	r1, .L658+140
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4950              		.loc 1 1023 0
 4951 2acc 5920CBE5 		strb	r2, [fp, #89]
1025:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4952              		.loc 1 1025 0
 4953 2ad0 5A30CBE5 		strb	r3, [fp, #90]
1026:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4954              		.loc 1 1026 0
 4955 2ad4 5B30CBE5 		strb	r3, [fp, #91]
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4956              		.loc 1 1027 0
 4957 2ad8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4958              	.LVL544:
1028:../uvc.c      **** 			  break;
 4959              		.loc 1 1028 0
 4960 2adc 5820DBE5 		ldrb	r2, [fp, #88]	@ zero_extendqisi2
 4961              	.LVL545:
 4962 2ae0 F70100EA 		b	.L412
 4963              	.LVL546:
 4964              	.L637:
 4965              	.LBE156:
 4966              	.LBE155:
 4967              	.LBE311:
 4968              	.LBE424:
 4969              	.LBB425:
 4970              	.LBB137:
2942:../uvc.c      ****             {
 4971              		.loc 1 2942 0
 4972 2ae4 810052E3 		cmp	r2, #129
 4973 2ae8 A4FFFF2A 		bcs	.L536
 4974 2aec 010052E3 		cmp	r2, #1
 4975 2af0 B2FEFF1A 		bne	.L493
2967:../uvc.c      ****                             glCommitCtrl, &readCount);
 4976              		.loc 1 2967 0
 4977 2af4 2000A0E3 		mov	r0, #32
 4978 2af8 F8199FE5 		ldr	r1, .L658+48
 4979 2afc 48208DE2 		add	r2, sp, #72
 4980 2b00 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4981              	.LVL547:
2969:../uvc.c      ****                     {
 4982              		.loc 1 2969 0
 4983 2b04 000050E3 		cmp	r0, #0
 4984 2b08 B0FEFF1A 		bne	.L506
2976:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4985              		.loc 1 2976 0
 4986 2b0c C310D4E5 		ldrb	r1, [r4, #195]	@ zero_extendqisi2
2975:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4987              		.loc 1 2975 0
 4988 2b10 C2C0D4E5 		ldrb	ip, [r4, #194]	@ zero_extendqisi2
2978:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4989              		.loc 1 2978 0
 4990 2b14 C500D4E5 		ldrb	r0, [r4, #197]	@ zero_extendqisi2
 4991              	.LVL548:
2977:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4992              		.loc 1 2977 0
 4993 2b18 C4E0D4E5 		ldrb	lr, [r4, #196]	@ zero_extendqisi2
2981:../uvc.c      ****                         }
 4994              		.loc 1 2981 0
 4995 2b1c C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
2976:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4996              		.loc 1 2976 0
 4997 2b20 1316CAE5 		strb	r1, [r10, #1555]
2981:../uvc.c      ****                         }
 4998              		.loc 1 2981 0
 4999 2b24 00108DE5 		str	r1, [sp]
2979:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 5000              		.loc 1 2979 0
 5001 2b28 C610D4E5 		ldrb	r1, [r4, #198]	@ zero_extendqisi2
2975:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 5002              		.loc 1 2975 0
 5003 2b2c 12C6CAE5 		strb	ip, [r10, #1554]
2980:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d\r\n", readCount
 5004              		.loc 1 2980 0
 5005 2b30 C7C0D4E5 		ldrb	ip, [r4, #199]	@ zero_extendqisi2
2978:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 5006              		.loc 1 2978 0
 5007 2b34 1506CAE5 		strb	r0, [r10, #1557]
2979:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 5008              		.loc 1 2979 0
 5009 2b38 1616CAE5 		strb	r1, [r10, #1558]
2981:../uvc.c      ****                         }
 5010              		.loc 1 2981 0
 5011 2b3c B824DDE1 		ldrh	r2, [sp, #72]
 5012 2b40 B4199FE5 		ldr	r1, .L658+52
 5013 2b44 0400A0E3 		mov	r0, #4
2977:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 5014              		.loc 1 2977 0
 5015 2b48 14E6CAE5 		strb	lr, [r10, #1556]
2980:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d\r\n", readCount
 5016              		.loc 1 2980 0
 5017 2b4c 17C6CAE5 		strb	ip, [r10, #1559]
2981:../uvc.c      ****                         }
 5018              		.loc 1 2981 0
 5019 2b50 FEFFFFEB 		bl	CyU3PDebugPrint
 5020              	.LVL549:
 5021 2b54 9DFEFFEA 		b	.L506
 5022              	.LVL550:
 5023              	.L636:
3066:../uvc.c      ****                 {
 5024              		.loc 1 3066 0
 5025 2b58 810052E3 		cmp	r2, #129
 5026 2b5c 1A00002A 		bcs	.L520
 5027 2b60 010052E3 		cmp	r2, #1
 5028 2b64 95FEFF1A 		bne	.L493
3091:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5029              		.loc 1 3091 0
 5030 2b68 2000A0E3 		mov	r0, #32
 5031 2b6c 84199FE5 		ldr	r1, .L658+48
 5032 2b70 48208DE2 		add	r2, sp, #72
 5033 2b74 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5034              	.LVL551:
3093:../uvc.c      ****                         {
 5035              		.loc 1 3093 0
 5036 2b78 000050E3 		cmp	r0, #0
 5037 2b7c 93FEFF1A 		bne	.L506
3099:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5038              		.loc 1 3099 0
 5039 2b80 C110D4E5 		ldrb	r1, [r4, #193]	@ zero_extendqisi2
3100:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5040              		.loc 1 3100 0
 5041 2b84 C2C0D4E5 		ldrb	ip, [r4, #194]	@ zero_extendqisi2
3102:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5042              		.loc 1 3102 0
 5043 2b88 C400D4E5 		ldrb	r0, [r4, #196]	@ zero_extendqisi2
 5044              	.LVL552:
3101:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5045              		.loc 1 3101 0
 5046 2b8c C3E0D4E5 		ldrb	lr, [r4, #195]	@ zero_extendqisi2
3106:../uvc.c      ****                         }
 5047              		.loc 1 3106 0
 5048 2b90 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
3099:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5049              		.loc 1 3099 0
 5050 2b94 2D16CAE5 		strb	r1, [r10, #1581]
3106:../uvc.c      ****                         }
 5051              		.loc 1 3106 0
 5052 2b98 00108DE5 		str	r1, [sp]
3103:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5053              		.loc 1 3103 0
 5054 2b9c C510D4E5 		ldrb	r1, [r4, #197]	@ zero_extendqisi2
3100:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5055              		.loc 1 3100 0
 5056 2ba0 2EC6CAE5 		strb	ip, [r10, #1582]
3104:../uvc.c      ****                             }
 5057              		.loc 1 3104 0
 5058 2ba4 C6C0D4E5 		ldrb	ip, [r4, #198]	@ zero_extendqisi2
3102:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5059              		.loc 1 3102 0
 5060 2ba8 3006CAE5 		strb	r0, [r10, #1584]
3103:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5061              		.loc 1 3103 0
 5062 2bac 3116CAE5 		strb	r1, [r10, #1585]
3106:../uvc.c      ****                         }
 5063              		.loc 1 3106 0
 5064 2bb0 B824DDE1 		ldrh	r2, [sp, #72]
 5065 2bb4 44199FE5 		ldr	r1, .L658+56
 5066 2bb8 0400A0E3 		mov	r0, #4
3101:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5067              		.loc 1 3101 0
 5068 2bbc 2FE6CAE5 		strb	lr, [r10, #1583]
3104:../uvc.c      ****                             }
 5069              		.loc 1 3104 0
 5070 2bc0 32C6CAE5 		strb	ip, [r10, #1586]
3106:../uvc.c      ****                         }
 5071              		.loc 1 3106 0
 5072 2bc4 FEFFFFEB 		bl	CyU3PDebugPrint
 5073              	.LVL553:
 5074 2bc8 80FEFFEA 		b	.L506
 5075              	.LVL554:
 5076              	.L520:
3081:../uvc.c      ****                         {
 5077              		.loc 1 3081 0
 5078 2bcc BC30DBE5 		ldrb	r3, [fp, #188]	@ zero_extendqisi2
3083:../uvc.c      ****                         }
 5079              		.loc 1 3083 0
 5080 2bd0 0B00A0E3 		mov	r0, #11
3081:../uvc.c      ****                         {
 5081              		.loc 1 3081 0
 5082 2bd4 030053E3 		cmp	r3, #3
3083:../uvc.c      ****                         }
 5083              		.loc 1 3083 0
 5084 2bd8 24199F05 		ldreq	r1, .L658+60
3087:../uvc.c      ****                         }
 5085              		.loc 1 3087 0
 5086 2bdc 24199F15 		ldrne	r1, .L658+64
 5087 2be0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5088              	.LVL555:
 5089 2be4 79FEFFEA 		b	.L506
 5090              	.LVL556:
 5091              	.L278:
 5092              	.LBE137:
 5093              	.LBE425:
 5094              	.LBB426:
 5095              	.LBB342:
 5096              	.LBB324:
 5097              	.LBB325:
 418:../uvc.c      ****     /*
 5098              		.loc 1 418 0
 5099 2be8 EC289FE5 		ldr	r2, .L658+20
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 5100              		.loc 1 409 0
 5101 2bec D032DAE5 		ldrb	r3, [r10, #720]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 5102              		.loc 1 418 0
 5103 2bf0 0070D2E5 		ldrb	r7, [r2]	@ zero_extendqisi2
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 5104              		.loc 1 409 0
 5105 2bf4 30308DE5 		str	r3, [sp, #48]
 5106              	.LVL557:
 426:../uvc.c      **** 		 {
 5107              		.loc 1 426 0
 5108 2bf8 830057E3 		cmp	r7, #131
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 5109              		.loc 1 411 0
 5110 2bfc DF32DAE5 		ldrb	r3, [r10, #735]	@ zero_extendqisi2
 5111              	.LVL558:
 412:../uvc.c      ****     }
 5112              		.loc 1 412 0
 5113 2c00 D282DAE5 		ldrb	r8, [r10, #722]	@ zero_extendqisi2
 5114              	.LVL559:
 426:../uvc.c      **** 		 {
 5115              		.loc 1 426 0
 5116 2c04 6705000A 		beq	.L281
 5117 2c08 5202009A 		bls	.L640
 5118 2c0c 850057E3 		cmp	r7, #133
 5119 2c10 6805000A 		beq	.L286
 5120 2c14 4704003A 		bcc	.L287
 5121 2c18 860057E3 		cmp	r7, #134
 5122 2c1c 7705000A 		beq	.L288
 5123 2c20 870057E3 		cmp	r7, #135
 656:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 5124              		.loc 1 656 0
 5125 2c24 DB22DA05 		ldreqb	r2, [r10, #731]	@ zero_extendqisi2
 657:../uvc.c      **** 			 }
 5126              		.loc 1 657 0
 5127 2c28 DC32DA05 		ldreqb	r3, [r10, #732]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 5128              		.loc 1 426 0
 5129 2c2c FC04001A 		bne	.L280
 5130              	.L593:
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5131              		.loc 1 596 0
 5132 2c30 1C199FE5 		ldr	r1, .L658+140
 5133 2c34 0800A0E1 		mov	r0, r8
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 5134              		.loc 1 593 0
 5135 2c38 5820CBE5 		strb	r2, [fp, #88]
 5136              	.L592:
 594:../uvc.c      **** 			 }
 5137              		.loc 1 594 0
 5138 2c3c 5930CBE5 		strb	r3, [fp, #89]
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5139              		.loc 1 596 0
 5140 2c40 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5141              	.LVL560:
 597:../uvc.c      **** 			  break;
 5142              		.loc 1 597 0
 5143 2c44 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 5144              	.LVL561:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5145              		.loc 1 414 0
 5146 2c48 FF80A0E3 		mov	r8, #255
 5147              	.LVL562:
 5148 2c4c 08C0A0E1 		mov	ip, r8
 5149              	.LVL563:
 5150              	.L290:
 958:../uvc.c      **** }
 5151              		.loc 1 958 0
 5152 2c50 FF10A0E3 		mov	r1, #255
 5153 2c54 0720A0E1 		mov	r2, r7
 5154 2c58 00808DE5 		str	r8, [sp]
 5155 2c5c 04308DE5 		str	r3, [sp, #4]
 5156              	.LVL564:
 5157              	.L613:
 5158              	.LBE325:
 5159              	.LBE324:
 5160              	.LBE342:
 5161              	.LBE426:
 5162              	.LBB427:
 5163              	.LBB409:
 5164              	.LBB353:
 5165              	.LBB354:
 5166 2c60 0C30A0E1 		mov	r3, ip
 5167 2c64 08108DE5 		str	r1, [sp, #8]
 5168 2c68 0400A0E3 		mov	r0, #4
 5169 2c6c C0189FE5 		ldr	r1, .L658+108
 5170 2c70 FEFFFFEB 		bl	CyU3PDebugPrint
 5171              	.LVL565:
 5172 2c74 50309DE5 		ldr	r3, [sp, #80]
 5173 2c78 4BFEFFEA 		b	.L259
 5174              	.L274:
 5175              	.LVL566:
 5176              	.LBE354:
 5177              	.LBE353:
 5178              	.LBE409:
 5179              	.LBE427:
 5180              	.LBB428:
 5181              	.LBB343:
2581:../uvc.c      ****     		break;
 5182              		.loc 1 2581 0
 5183 2c7c 0900A0E3 		mov	r0, #9
 5184 2c80 FEFFFFEB 		bl	ControlHandle
 5185              	.LVL567:
 5186 2c84 50309DE5 		ldr	r3, [sp, #80]
 5187 2c88 47FEFFEA 		b	.L259
 5188              	.L271:
 5189              	.LVL568:
2548:../uvc.c      ****     		break;
 5190              		.loc 1 2548 0
 5191 2c8c 0000A0E3 		mov	r0, #0
 5192 2c90 FEFFFFEB 		bl	ControlHandle
 5193              	.LVL569:
 5194 2c94 50309DE5 		ldr	r3, [sp, #80]
 5195 2c98 43FEFFEA 		b	.L259
 5196              	.L276:
 5197              	.LVL570:
2571:../uvc.c      ****           		break;
 5198              		.loc 1 2571 0
 5199 2c9c 0600A0E3 		mov	r0, #6
 5200 2ca0 FEFFFFEB 		bl	ControlHandle
 5201              	.LVL571:
 5202 2ca4 50309DE5 		ldr	r3, [sp, #80]
 5203 2ca8 3FFEFFEA 		b	.L259
 5204              	.L269:
 5205              	.LVL572:
2556:../uvc.c      **** 			break;
 5206              		.loc 1 2556 0
 5207 2cac 0200A0E3 		mov	r0, #2
 5208 2cb0 FEFFFFEB 		bl	ControlHandle
 5209              	.LVL573:
 5210 2cb4 50309DE5 		ldr	r3, [sp, #80]
 5211 2cb8 3BFEFFEA 		b	.L259
 5212              	.L267:
 5213              	.LVL574:
2567:../uvc.c      ****      		break;
 5214              		.loc 1 2567 0
 5215 2cbc 0500A0E3 		mov	r0, #5
 5216 2cc0 FEFFFFEB 		bl	ControlHandle
 5217              	.LVL575:
 5218 2cc4 50309DE5 		ldr	r3, [sp, #80]
 5219 2cc8 37FEFFEA 		b	.L259
 5220              	.L294:
 5221              	.LVL576:
 5222              	.LBE343:
 5223              	.LBE428:
 5224              	.LBB429:
 5225              	.LBB312:
 5226              	.LBB167:
 5227              	.LBB168:
 982:../uvc.c      **** 
 5228              		.loc 1 982 0
 5229 2ccc 08C89FE5 		ldr	ip, .L658+20
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5230              		.loc 1 977 0
 5231 2cd0 0A85DAE5 		ldrb	r8, [r10, #1290]	@ zero_extendqisi2
 5232              	.LVL577:
 982:../uvc.c      **** 
 5233              		.loc 1 982 0
 5234 2cd4 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5235              	.LVL578:
 984:../uvc.c      **** 		 {
 5236              		.loc 1 984 0
 5237 2cd8 830057E3 		cmp	r7, #131
 5238 2cdc B505000A 		beq	.L357
 5239 2ce0 3E03009A 		bls	.L641
 5240 2ce4 850057E3 		cmp	r7, #133
 5241 2ce8 6E01000A 		beq	.L408
 5242 2cec A504003A 		bcc	.L363
 5243 2cf0 860057E3 		cmp	r7, #134
 5244 2cf4 F505000A 		beq	.L364
 5245 2cf8 870057E3 		cmp	r7, #135
 5246 2cfc 0B05001A 		bne	.L356
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5247              		.loc 1 1046 0
 5248 2d00 C4E79FE5 		ldr	lr, .L658+4
 5249 2d04 1315DEE5 		ldrb	r1, [lr, #1299]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5250              		.loc 1 1047 0
 5251 2d08 1425DEE5 		ldrb	r2, [lr, #1300]	@ zero_extendqisi2
 5252 2d0c 6AFFFFEA 		b	.L602
 5253              	.LVL579:
 5254              	.L625:
 5255              	.LBE168:
 5256              	.LBE167:
 5257              	.LBB175:
 5258              	.LBB176:
 982:../uvc.c      **** 
 5259              		.loc 1 982 0
 5260 2d10 C4C79FE5 		ldr	ip, .L658+20
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5261              		.loc 1 977 0
 5262 2d14 5285DAE5 		ldrb	r8, [r10, #1362]	@ zero_extendqisi2
 5263              	.LVL580:
 982:../uvc.c      **** 
 5264              		.loc 1 982 0
 5265 2d18 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5266              	.LVL581:
 984:../uvc.c      **** 		 {
 5267              		.loc 1 984 0
 5268 2d1c 830057E3 		cmp	r7, #131
 5269 2d20 9805000A 		beq	.L392
 5270 2d24 F102009A 		bls	.L642
 5271 2d28 850057E3 		cmp	r7, #133
 5272 2d2c 5D01000A 		beq	.L408
 5273 2d30 6704003A 		bcc	.L398
 5274 2d34 860057E3 		cmp	r7, #134
 5275 2d38 DB05000A 		beq	.L399
 5276 2d3c 870057E3 		cmp	r7, #135
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5277              		.loc 1 1046 0
 5278 2d40 5B15DA05 		ldreqb	r1, [r10, #1371]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5279              		.loc 1 1047 0
 5280 2d44 5C25DA05 		ldreqb	r2, [r10, #1372]	@ zero_extendqisi2
 984:../uvc.c      **** 		 {
 5281              		.loc 1 984 0
 5282 2d48 5BFFFF0A 		beq	.L602
 5283              	.L391:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5284              		.loc 1 1191 0
 5285 2d4c 0000A0E3 		mov	r0, #0
 5286 2d50 0020A0E1 		mov	r2, r0
 5287 2d54 0110A0E3 		mov	r1, #1
 5288 2d58 24C08DE5 		str	ip, [sp, #36]
 5289 2d5c FEFFFFEB 		bl	CyU3PUsbStall
 5290              	.LVL582:
1192:../uvc.c      **** 			  break;
 5291              		.loc 1 1192 0
 5292 2d60 24C09DE5 		ldr	ip, [sp, #36]
 5293 2d64 0820A0E3 		mov	r2, #8
 5294 2d68 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5295 2d6c 0400A0E3 		mov	r0, #4
 5296 2d70 C8179FE5 		ldr	r1, .L658+120
 5297 2d74 FEFFFFEB 		bl	CyU3PDebugPrint
 5298              	.LVL583:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5299              		.loc 1 978 0
 5300 2d78 FF20A0E3 		mov	r2, #255
 5301              	.LVL584:
 5302 2d7c 500100EA 		b	.L412
 5303              	.LVL585:
 5304              	.L298:
 5305              	.LBE176:
 5306              	.LBE175:
 5307              	.LBB183:
 5308              	.LBB184:
 982:../uvc.c      **** 
 5309              		.loc 1 982 0
 5310 2d80 54C79FE5 		ldr	ip, .L658+20
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5311              		.loc 1 977 0
 5312 2d84 9284DAE5 		ldrb	r8, [r10, #1170]	@ zero_extendqisi2
 5313              	.LVL586:
 982:../uvc.c      **** 
 5314              		.loc 1 982 0
 5315 2d88 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5316              	.LVL587:
 984:../uvc.c      **** 		 {
 5317              		.loc 1 984 0
 5318 2d8c 830057E3 		cmp	r7, #131
 5319 2d90 8C05000A 		beq	.L309
 5320 2d94 3A03009A 		bls	.L643
 5321 2d98 850057E3 		cmp	r7, #133
 5322 2d9c 4101000A 		beq	.L408
 5323 2da0 7404003A 		bcc	.L315
 5324 2da4 860057E3 		cmp	r7, #134
 5325 2da8 AF05000A 		beq	.L316
 5326 2dac 870057E3 		cmp	r7, #135
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5327              		.loc 1 1046 0
 5328 2db0 9B14DA05 		ldreqb	r1, [r10, #1179]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5329              		.loc 1 1047 0
 5330 2db4 9C24DA05 		ldreqb	r2, [r10, #1180]	@ zero_extendqisi2
 984:../uvc.c      **** 		 {
 5331              		.loc 1 984 0
 5332 2db8 3FFFFF0A 		beq	.L602
 5333              	.L308:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5334              		.loc 1 1191 0
 5335 2dbc 0000A0E3 		mov	r0, #0
 5336 2dc0 0020A0E1 		mov	r2, r0
 5337 2dc4 0110A0E3 		mov	r1, #1
 5338 2dc8 24C08DE5 		str	ip, [sp, #36]
 5339 2dcc FEFFFFEB 		bl	CyU3PUsbStall
 5340              	.LVL588:
1192:../uvc.c      **** 			  break;
 5341              		.loc 1 1192 0
 5342 2dd0 24C09DE5 		ldr	ip, [sp, #36]
 5343 2dd4 0020A0E3 		mov	r2, #0
 5344 2dd8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5345 2ddc 0400A0E3 		mov	r0, #4
 5346 2de0 58179FE5 		ldr	r1, .L658+120
 5347 2de4 FEFFFFEB 		bl	CyU3PDebugPrint
 5348              	.LVL589:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5349              		.loc 1 978 0
 5350 2de8 FF20A0E3 		mov	r2, #255
 5351              	.LVL590:
 5352 2dec 340100EA 		b	.L412
 5353              	.LVL591:
 5354              	.L296:
 5355              	.LBE184:
 5356              	.LBE183:
 5357              	.LBB191:
 5358              	.LBB192:
 982:../uvc.c      **** 
 5359              		.loc 1 982 0
 5360 2df0 E4C69FE5 		ldr	ip, .L658+20
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5361              		.loc 1 977 0
 5362 2df4 C284DAE5 		ldrb	r8, [r10, #1218]	@ zero_extendqisi2
 5363              	.LVL592:
 982:../uvc.c      **** 
 5364              		.loc 1 982 0
 5365 2df8 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5366              	.LVL593:
 984:../uvc.c      **** 		 {
 5367              		.loc 1 984 0
 5368 2dfc 830057E3 		cmp	r7, #131
 5369 2e00 4305000A 		beq	.L320
 5370 2e04 3203009A 		bls	.L644
 5371 2e08 850057E3 		cmp	r7, #133
 5372 2e0c 2501000A 		beq	.L408
 5373 2e10 2B04003A 		bcc	.L326
 5374 2e14 860057E3 		cmp	r7, #134
 5375 2e18 9005000A 		beq	.L327
 5376 2e1c 870057E3 		cmp	r7, #135
 5377 2e20 B504001A 		bne	.L319
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5378              		.loc 1 1046 0
 5379 2e24 A0E69FE5 		ldr	lr, .L658+4
 5380 2e28 CB14DEE5 		ldrb	r1, [lr, #1227]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5381              		.loc 1 1047 0
 5382 2e2c CC24DEE5 		ldrb	r2, [lr, #1228]	@ zero_extendqisi2
 5383 2e30 21FFFFEA 		b	.L602
 5384              	.LVL594:
 5385              	.L304:
 5386              	.LBE192:
 5387              	.LBE191:
 5388              	.LBB200:
 5389              	.LBB201:
 982:../uvc.c      **** 
 5390              		.loc 1 982 0
 5391 2e34 A0C69FE5 		ldr	ip, .L658+20
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5392              		.loc 1 977 0
 5393 2e38 2285DAE5 		ldrb	r8, [r10, #1314]	@ zero_extendqisi2
 5394              	.LVL595:
 982:../uvc.c      **** 
 5395              		.loc 1 982 0
 5396 2e3c 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5397              	.LVL596:
 984:../uvc.c      **** 		 {
 5398              		.loc 1 984 0
 5399 2e40 830057E3 		cmp	r7, #131
 5400 2e44 5705000A 		beq	.L368
 5401 2e48 D002009A 		bls	.L645
 5402 2e4c 850057E3 		cmp	r7, #133
 5403 2e50 1401000A 		beq	.L408
 5404 2e54 2C04003A 		bcc	.L374
 5405 2e58 860057E3 		cmp	r7, #134
 5406 2e5c FE04000A 		beq	.L375
 5407 2e60 870057E3 		cmp	r7, #135
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5408              		.loc 1 1046 0
 5409 2e64 2B15DA05 		ldreqb	r1, [r10, #1323]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5410              		.loc 1 1047 0
 5411 2e68 2C25DA05 		ldreqb	r2, [r10, #1324]	@ zero_extendqisi2
 984:../uvc.c      **** 		 {
 5412              		.loc 1 984 0
 5413 2e6c 12FFFF0A 		beq	.L602
 5414              	.L367:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5415              		.loc 1 1191 0
 5416 2e70 0000A0E3 		mov	r0, #0
 5417 2e74 0020A0E1 		mov	r2, r0
 5418 2e78 0110A0E3 		mov	r1, #1
 5419 2e7c 24C08DE5 		str	ip, [sp, #36]
 5420 2e80 FEFFFFEB 		bl	CyU3PUsbStall
 5421              	.LVL597:
1192:../uvc.c      **** 			  break;
 5422              		.loc 1 1192 0
 5423 2e84 24C09DE5 		ldr	ip, [sp, #36]
 5424 2e88 0620A0E3 		mov	r2, #6
 5425 2e8c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5426 2e90 0400A0E3 		mov	r0, #4
 5427 2e94 A4169FE5 		ldr	r1, .L658+120
 5428 2e98 FEFFFFEB 		bl	CyU3PDebugPrint
 5429              	.LVL598:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5430              		.loc 1 978 0
 5431 2e9c FF20A0E3 		mov	r2, #255
 5432              	.LVL599:
 5433 2ea0 070100EA 		b	.L412
 5434              	.LVL600:
 5435              	.L300:
 5436              	.LBE201:
 5437              	.LBE200:
 5438              	.LBB208:
 5439              	.LBB209:
 982:../uvc.c      **** 
 5440              		.loc 1 982 0
 5441 2ea4 30C69FE5 		ldr	ip, .L658+20
 975:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5442              		.loc 1 975 0
 5443 2ea8 D874DAE5 		ldrb	r7, [r10, #1240]	@ zero_extendqisi2
 982:../uvc.c      **** 
 5444              		.loc 1 982 0
 5445 2eac 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
 975:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5446              		.loc 1 975 0
 5447 2eb0 30708DE5 		str	r7, [sp, #48]
 984:../uvc.c      **** 		 {
 5448              		.loc 1 984 0
 5449 2eb4 830058E3 		cmp	r8, #131
 974:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5450              		.loc 1 974 0
 5451 2eb8 E734DAE5 		ldrb	r3, [r10, #1255]	@ zero_extendqisi2
 5452              	.LVL601:
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5453              		.loc 1 977 0
 5454 2ebc DA74DAE5 		ldrb	r7, [r10, #1242]	@ zero_extendqisi2
 5455              	.LVL602:
 984:../uvc.c      **** 		 {
 5456              		.loc 1 984 0
 5457 2ec0 5405000A 		beq	.L331
 5458 2ec4 D101009A 		bls	.L646
 5459 2ec8 850058E3 		cmp	r8, #133
 5460 2ecc 5505000A 		beq	.L336
 5461 2ed0 2404003A 		bcc	.L337
 5462 2ed4 860058E3 		cmp	r8, #134
 5463 2ed8 F904000A 		beq	.L338
 5464 2edc 870058E3 		cmp	r8, #135
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5465              		.loc 1 1046 0
 5466 2ee0 E314DA05 		ldreqb	r1, [r10, #1251]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5467              		.loc 1 1047 0
 5468 2ee4 E424DA05 		ldreqb	r2, [r10, #1252]	@ zero_extendqisi2
 984:../uvc.c      **** 		 {
 5469              		.loc 1 984 0
 5470 2ee8 9D04001A 		bne	.L330
 5471              	.L596:
1025:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5472              		.loc 1 1025 0
 5473 2eec 0030A0E3 		mov	r3, #0
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5474              		.loc 1 1022 0
 5475 2ef0 5810CBE5 		strb	r1, [fp, #88]
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5476              		.loc 1 1027 0
 5477 2ef4 0700A0E1 		mov	r0, r7
 5478 2ef8 54169FE5 		ldr	r1, .L658+140
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5479              		.loc 1 1023 0
 5480 2efc 5920CBE5 		strb	r2, [fp, #89]
1025:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5481              		.loc 1 1025 0
 5482 2f00 5A30CBE5 		strb	r3, [fp, #90]
1026:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5483              		.loc 1 1026 0
 5484 2f04 5B30CBE5 		strb	r3, [fp, #91]
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5485              		.loc 1 1027 0
 5486 2f08 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5487              	.LVL603:
1028:../uvc.c      **** 			  break;
 5488              		.loc 1 1028 0
 5489 2f0c 58C0DBE5 		ldrb	ip, [fp, #88]	@ zero_extendqisi2
 5490              	.LVL604:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5491              		.loc 1 978 0
 5492 2f10 FF20A0E3 		mov	r2, #255
 5493 2f14 0230A0E1 		mov	r3, r2
 5494              	.LVL605:
 5495              	.L340:
1197:../uvc.c      **** }
 5496              		.loc 1 1197 0
 5497 2f18 5A10DBE5 		ldrb	r1, [fp, #90]	@ zero_extendqisi2
 5498 2f1c FF00A0E3 		mov	r0, #255
 5499 2f20 00208DE5 		str	r2, [sp]
 5500 2f24 0820A0E1 		mov	r2, r8
 5501              	.LVL606:
 5502 2f28 08C08DE5 		str	ip, [sp, #8]
 5503 2f2c 14708DE5 		str	r7, [sp, #20]
 5504              	.LVL607:
 5505              	.L614:
 5506              	.LBE209:
 5507              	.LBE208:
 5508              	.LBB217:
 5509              	.LBB218:
 5510 2f30 04108DE5 		str	r1, [sp, #4]
 5511 2f34 10108DE5 		str	r1, [sp, #16]
 5512 2f38 0C008DE5 		str	r0, [sp, #12]
 5513 2f3c C8159FE5 		ldr	r1, .L658+68
 5514 2f40 0400A0E3 		mov	r0, #4
 5515 2f44 FEFFFFEB 		bl	CyU3PDebugPrint
 5516              	.LVL608:
 5517 2f48 50309DE5 		ldr	r3, [sp, #80]
 5518 2f4c 96FDFFEA 		b	.L259
 5519              	.L306:
 5520              	.LVL609:
 982:../uvc.c      **** 
 5521              		.loc 1 982 0
 5522 2f50 84C59FE5 		ldr	ip, .L658+20
 975:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5523              		.loc 1 975 0
 5524 2f54 80E5DAE5 		ldrb	lr, [r10, #1408]	@ zero_extendqisi2
 982:../uvc.c      **** 
 5525              		.loc 1 982 0
 5526 2f58 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5527              		.loc 1 977 0
 5528 2f5c 8215DAE5 		ldrb	r1, [r10, #1410]	@ zero_extendqisi2
 984:../uvc.c      **** 		 {
 5529              		.loc 1 984 0
 5530 2f60 830057E3 		cmp	r7, #131
 974:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5531              		.loc 1 974 0
 5532 2f64 8F35DAE5 		ldrb	r3, [r10, #1423]	@ zero_extendqisi2
 5533              	.LVL610:
 975:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5534              		.loc 1 975 0
 5535 2f68 34E08DE5 		str	lr, [sp, #52]
 5536              	.LVL611:
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5537              		.loc 1 977 0
 5538 2f6c 30108DE5 		str	r1, [sp, #48]
 5539              	.LVL612:
 984:../uvc.c      **** 		 {
 5540              		.loc 1 984 0
 5541 2f70 1805000A 		beq	.L414
 5542 2f74 2902009A 		bls	.L647
 5543 2f78 850057E3 		cmp	r7, #133
 5544 2f7c 1905000A 		beq	.L419
 5545 2f80 E503003A 		bcc	.L420
 5546 2f84 860057E3 		cmp	r7, #134
 5547 2f88 C104000A 		beq	.L421
 5548 2f8c 870057E3 		cmp	r7, #135
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5549              		.loc 1 1046 0
 5550 2f90 8B05DA05 		ldreqb	r0, [r10, #1419]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5551              		.loc 1 1047 0
 5552 2f94 8C15DA05 		ldreqb	r1, [r10, #1420]	@ zero_extendqisi2
 984:../uvc.c      **** 		 {
 5553              		.loc 1 984 0
 5554 2f98 2904001A 		bne	.L413
 5555              	.L604:
1024:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5556              		.loc 1 1024 0
 5557 2f9c 0120A0E3 		mov	r2, #1
1026:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5558              		.loc 1 1026 0
 5559 2fa0 0030A0E3 		mov	r3, #0
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5560              		.loc 1 1022 0
 5561 2fa4 5800CBE5 		strb	r0, [fp, #88]
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5562              		.loc 1 1023 0
 5563 2fa8 5910CBE5 		strb	r1, [fp, #89]
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5564              		.loc 1 1027 0
 5565 2fac 30009DE5 		ldr	r0, [sp, #48]
 5566 2fb0 9C159FE5 		ldr	r1, .L658+140
1024:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5567              		.loc 1 1024 0
 5568 2fb4 5A20CBE5 		strb	r2, [fp, #90]
1026:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5569              		.loc 1 1026 0
 5570 2fb8 5B30CBE5 		strb	r3, [fp, #91]
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5571              		.loc 1 1027 0
 5572 2fbc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5573              	.LVL613:
1028:../uvc.c      **** 			  break;
 5574              		.loc 1 1028 0
 5575 2fc0 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 5576              	.LVL614:
 5577 2fc4 30209DE5 		ldr	r2, [sp, #48]
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5578              		.loc 1 978 0
 5579 2fc8 FF80A0E3 		mov	r8, #255
 5580 2fcc 08C0A0E1 		mov	ip, r8
 5581              	.LVL615:
 5582              	.L423:
1197:../uvc.c      **** }
 5583              		.loc 1 1197 0
 5584 2fd0 5A10DBE5 		ldrb	r1, [fp, #90]	@ zero_extendqisi2
 5585 2fd4 FF00A0E3 		mov	r0, #255
 5586 2fd8 08308DE5 		str	r3, [sp, #8]
 5587 2fdc 14208DE5 		str	r2, [sp, #20]
 5588 2fe0 00808DE5 		str	r8, [sp]
 5589 2fe4 0720A0E1 		mov	r2, r7
 5590 2fe8 0C30A0E1 		mov	r3, ip
 5591              	.LVL616:
 5592 2fec CFFFFFEA 		b	.L614
 5593              	.LVL617:
 5594              	.L302:
 5595              	.LBE218:
 5596              	.LBE217:
 5597              	.LBB227:
 5598              	.LBB228:
 982:../uvc.c      **** 
 5599              		.loc 1 982 0
 5600 2ff0 E4C49FE5 		ldr	ip, .L658+20
 975:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5601              		.loc 1 975 0
 5602 2ff4 38E5DAE5 		ldrb	lr, [r10, #1336]	@ zero_extendqisi2
 982:../uvc.c      **** 
 5603              		.loc 1 982 0
 5604 2ff8 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 974:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5605              		.loc 1 974 0
 5606 2ffc 4735DAE5 		ldrb	r3, [r10, #1351]	@ zero_extendqisi2
 5607              	.LVL618:
 984:../uvc.c      **** 		 {
 5608              		.loc 1 984 0
 5609 3000 830057E3 		cmp	r7, #131
 975:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5610              		.loc 1 975 0
 5611 3004 30E08DE5 		str	lr, [sp, #48]
 5612              	.LVL619:
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5613              		.loc 1 977 0
 5614 3008 3A85DAE5 		ldrb	r8, [r10, #1338]	@ zero_extendqisi2
 5615              	.LVL620:
 984:../uvc.c      **** 		 {
 5616              		.loc 1 984 0
 5617 300c C404000A 		beq	.L379
 5618 3010 D101009A 		bls	.L648
 5619 3014 850057E3 		cmp	r7, #133
 5620 3018 B304000A 		beq	.L384
 5621 301c 6203003A 		bcc	.L385
 5622 3020 860057E3 		cmp	r7, #134
 5623 3024 C404000A 		beq	.L386
 5624 3028 870057E3 		cmp	r7, #135
 5625 302c 2104001A 		bne	.L378
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5626              		.loc 1 1046 0
 5627 3030 94249FE5 		ldr	r2, .L658+4
 5628 3034 4315D2E5 		ldrb	r1, [r2, #1347]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5629              		.loc 1 1047 0
 5630 3038 4425D2E5 		ldrb	r2, [r2, #1348]	@ zero_extendqisi2
 5631              	.L600:
1025:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5632              		.loc 1 1025 0
 5633 303c 0030A0E3 		mov	r3, #0
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5634              		.loc 1 1022 0
 5635 3040 5810CBE5 		strb	r1, [fp, #88]
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5636              		.loc 1 1027 0
 5637 3044 0800A0E1 		mov	r0, r8
 5638 3048 04159FE5 		ldr	r1, .L658+140
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5639              		.loc 1 1023 0
 5640 304c 5920CBE5 		strb	r2, [fp, #89]
1025:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5641              		.loc 1 1025 0
 5642 3050 5A30CBE5 		strb	r3, [fp, #90]
1026:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5643              		.loc 1 1026 0
 5644 3054 5B30CBE5 		strb	r3, [fp, #91]
1027:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5645              		.loc 1 1027 0
 5646 3058 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5647              	.LVL621:
1028:../uvc.c      **** 			  break;
 5648              		.loc 1 1028 0
 5649 305c 58C0DBE5 		ldrb	ip, [fp, #88]	@ zero_extendqisi2
 5650              	.LVL622:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5651              		.loc 1 978 0
 5652 3060 FF20A0E3 		mov	r2, #255
 5653 3064 0230A0E1 		mov	r3, r2
 5654              	.LVL623:
 5655              	.L388:
1197:../uvc.c      **** }
 5656              		.loc 1 1197 0
 5657 3068 5A10DBE5 		ldrb	r1, [fp, #90]	@ zero_extendqisi2
 5658 306c FF00A0E3 		mov	r0, #255
 5659 3070 00208DE5 		str	r2, [sp]
 5660 3074 08C08DE5 		str	ip, [sp, #8]
 5661 3078 14808DE5 		str	r8, [sp, #20]
 5662 307c 0720A0E1 		mov	r2, r7
 5663              	.LVL624:
 5664 3080 AAFFFFEA 		b	.L614
 5665              	.LVL625:
 5666              	.L305:
 5667              	.LBE228:
 5668              	.LBE227:
 5669              	.LBB238:
 5670              	.LBB157:
 982:../uvc.c      **** 
 5671              		.loc 1 982 0
 5672 3084 50C49FE5 		ldr	ip, .L658+20
 977:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5673              		.loc 1 977 0
 5674 3088 6A85DAE5 		ldrb	r8, [r10, #1386]	@ zero_extendqisi2
 5675              	.LVL626:
 982:../uvc.c      **** 
 5676              		.loc 1 982 0
 5677 308c 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 5678              	.LVL627:
 984:../uvc.c      **** 		 {
 5679              		.loc 1 984 0
 5680 3090 830057E3 		cmp	r7, #131
 5681 3094 ED04000A 		beq	.L403
 5682 3098 6502009A 		bls	.L649
 5683 309c 850057E3 		cmp	r7, #133
 5684 30a0 8000000A 		beq	.L408
 5685 30a4 8203003A 		bcc	.L409
 5686 30a8 860057E3 		cmp	r7, #134
 5687 30ac A004000A 		beq	.L410
 5688 30b0 870057E3 		cmp	r7, #135
1046:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5689              		.loc 1 1046 0
 5690 30b4 7315DA05 		ldreqb	r1, [r10, #1395]	@ zero_extendqisi2
1047:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5691              		.loc 1 1047 0
 5692 30b8 7425DA05 		ldreqb	r2, [r10, #1396]	@ zero_extendqisi2
 984:../uvc.c      **** 		 {
 5693              		.loc 1 984 0
 5694 30bc 7EFEFF0A 		beq	.L602
 5695              	.L402:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5696              		.loc 1 1191 0
 5697 30c0 0000A0E3 		mov	r0, #0
 5698 30c4 0020A0E1 		mov	r2, r0
 5699 30c8 0110A0E3 		mov	r1, #1
 5700 30cc 24C08DE5 		str	ip, [sp, #36]
 5701 30d0 FEFFFFEB 		bl	CyU3PUsbStall
 5702              	.LVL628:
1192:../uvc.c      **** 			  break;
 5703              		.loc 1 1192 0
 5704 30d4 24C09DE5 		ldr	ip, [sp, #36]
 5705 30d8 0920A0E3 		mov	r2, #9
 5706 30dc 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5707 30e0 0400A0E3 		mov	r0, #4
 5708 30e4 54149FE5 		ldr	r1, .L658+120
 5709 30e8 FEFFFFEB 		bl	CyU3PDebugPrint
 5710              	.LVL629:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5711              		.loc 1 978 0
 5712 30ec FF20A0E3 		mov	r2, #255
 5713 30f0 730000EA 		b	.L412
 5714              	.LVL630:
 5715              	.L638:
 5716              	.LBE157:
 5717              	.LBE238:
 5718              	.LBE312:
 5719              	.LBE429:
 5720              	.LBB430:
 5721              	.LBB138:
3116:../uvc.c      ****                 {
 5722              		.loc 1 3116 0
 5723 30f4 010052E3 		cmp	r2, #1
 5724 30f8 30FDFF1A 		bne	.L493
3141:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5725              		.loc 1 3141 0
 5726 30fc 2000A0E3 		mov	r0, #32
 5727 3100 F0139FE5 		ldr	r1, .L658+48
 5728 3104 48208DE2 		add	r2, sp, #72
 5729 3108 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5730              	.LVL631:
3143:../uvc.c      ****                         {
 5731              		.loc 1 3143 0
 5732 310c 000050E3 		cmp	r0, #0
 5733 3110 2EFDFF1A 		bne	.L506
3162:../uvc.c      ****                              {
 5734              		.loc 1 3162 0
 5735 3114 C130D4E5 		ldrb	r3, [r4, #193]	@ zero_extendqisi2
 5736 3118 010053E3 		cmp	r3, #1
 5737 311c 4304000A 		beq	.L533
 5738 3120 020053E3 		cmp	r3, #2
 5739 3124 0900001A 		bne	.L532
3170:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 5740              		.loc 1 3170 0
 5741 3128 3010A0E3 		mov	r1, #48
 5742 312c 0020A0E3 		mov	r2, #0
 5743 3130 5230A0E3 		mov	r3, #82
 5744 3134 0B00A0E3 		mov	r0, #11
 5745              	.LVL632:
 5746 3138 FEFFFFEB 		bl	SensorSetIrisControl
 5747              	.LVL633:
3172:../uvc.c      ****                              		break;
 5748              		.loc 1 3172 0
 5749 313c 0400A0E3 		mov	r0, #4
 5750 3140 00149FE5 		ldr	r1, .L658+128
 5751 3144 0B20A0E3 		mov	r2, #11
 5752 3148 0030A0E3 		mov	r3, #0
 5753 314c FEFFFFEB 		bl	CyU3PDebugPrint
 5754              	.LVL634:
 5755              	.L532:
3177:../uvc.c      **** 
 5756              		.loc 1 3177 0
 5757 3150 C1C0DBE5 		ldrb	ip, [fp, #193]	@ zero_extendqisi2
3179:../uvc.c      **** 
 5758              		.loc 1 3179 0
 5759 3154 C030DBE5 		ldrb	r3, [fp, #192]	@ zero_extendqisi2
 5760 3158 B824DDE1 		ldrh	r2, [sp, #72]
 5761 315c 00C08DE5 		str	ip, [sp]
 5762 3160 A8139FE5 		ldr	r1, .L658+72
3177:../uvc.c      **** 
 5763              		.loc 1 3177 0
 5764 3164 E1C0CBE5 		strb	ip, [fp, #225]
3179:../uvc.c      **** 
 5765              		.loc 1 3179 0
 5766 3168 0400A0E3 		mov	r0, #4
 5767 316c FEFFFFEB 		bl	CyU3PDebugPrint
 5768              	.LVL635:
 5769 3170 16FDFFEA 		b	.L506
 5770              	.LVL636:
 5771              	.L631:
2992:../uvc.c      ****             {
 5772              		.loc 1 2992 0
 5773 3174 010053E3 		cmp	r3, #1
 5774 3178 10FDFF1A 		bne	.L493
3017:../uvc.c      ****                             glCommitCtrl, &readCount);
 5775              		.loc 1 3017 0
 5776 317c 2000A0E3 		mov	r0, #32
 5777 3180 70139FE5 		ldr	r1, .L658+48
 5778 3184 48208DE2 		add	r2, sp, #72
 5779 3188 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5780              	.LVL637:
3019:../uvc.c      ****                     {
 5781              		.loc 1 3019 0
 5782 318c 000050E3 		cmp	r0, #0
 5783 3190 0EFDFF1A 		bne	.L506
3021:../uvc.c      ****                          {
 5784              		.loc 1 3021 0
 5785 3194 C330DBE5 		ldrb	r3, [fp, #195]	@ zero_extendqisi2
 5786 3198 010053E3 		cmp	r3, #1
 5787 319c 0A04000A 		beq	.L516
 5788 31a0 020053E3 		cmp	r3, #2
 5789 31a4 0B00001A 		bne	.L515
3029:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5790              		.loc 1 3029 0
 5791 31a8 3010A0E3 		mov	r1, #48
 5792 31ac 0120A0E3 		mov	r2, #1
 5793 31b0 5230A0E3 		mov	r3, #82
 5794 31b4 0B00A0E3 		mov	r0, #11
 5795              	.LVL638:
 5796 31b8 FEFFFFEB 		bl	SensorSetIrisControl
 5797              	.LVL639:
3030:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
 5798              		.loc 1 3030 0
 5799 31bc 7D0FA0E3 		mov	r0, #500
 5800 31c0 FEFFFFEB 		bl	_tx_thread_sleep
 5801              	.LVL640:
3031:../uvc.c      ****                          		break;
 5802              		.loc 1 3031 0
 5803 31c4 0400A0E3 		mov	r0, #4
 5804 31c8 74139FE5 		ldr	r1, .L658+124
 5805 31cc 0120A0E3 		mov	r2, #1
 5806 31d0 0B30A0E3 		mov	r3, #11
 5807 31d4 FEFFFFEB 		bl	CyU3PDebugPrint
 5808              	.LVL641:
 5809              	.L515:
3036:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5810              		.loc 1 3036 0
 5811 31d8 C330DBE5 		ldrb	r3, [fp, #195]	@ zero_extendqisi2
3037:../uvc.c      **** 
 5812              		.loc 1 3037 0
 5813 31dc 30139FE5 		ldr	r1, .L658+76
 5814 31e0 0320A0E1 		mov	r2, r3
 5815 31e4 0400A0E3 		mov	r0, #4
3036:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5816              		.loc 1 3036 0
 5817 31e8 E030CBE5 		strb	r3, [fp, #224]
3037:../uvc.c      **** 
 5818              		.loc 1 3037 0
 5819 31ec FEFFFFEB 		bl	CyU3PDebugPrint
 5820              	.LVL642:
3050:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5821              		.loc 1 3050 0
 5822 31f0 0020A0E3 		mov	r2, #0
 5823 31f4 CC029FE5 		ldr	r0, .L658
 5824 31f8 0110A0E3 		mov	r1, #1
 5825 31fc FEFFFFEB 		bl	_txe_event_flags_set
 5826              	.LVL643:
3051:../uvc.c      ****                         {
 5827              		.loc 1 3051 0
 5828 3200 002050E2 		subs	r2, r0, #0
 5829 3204 F1FCFF0A 		beq	.L506
3053:../uvc.c      ****                         }
 5830              		.loc 1 3053 0
 5831 3208 08139FE5 		ldr	r1, .L658+80
 5832 320c 0400A0E3 		mov	r0, #4
 5833              	.LVL644:
 5834 3210 FEFFFFEB 		bl	CyU3PDebugPrint
 5835              	.LVL645:
 5836 3214 EDFCFFEA 		b	.L506
 5837              	.LVL646:
 5838              	.L632:
3191:../uvc.c      ****                 {
 5839              		.loc 1 3191 0
 5840 3218 010052E3 		cmp	r2, #1
 5841 321c E7FCFF1A 		bne	.L493
3216:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5842              		.loc 1 3216 0
 5843 3220 2000A0E3 		mov	r0, #32
 5844 3224 CC129FE5 		ldr	r1, .L658+48
 5845 3228 48208DE2 		add	r2, sp, #72
 5846 322c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5847              	.LVL647:
3218:../uvc.c      ****                         {
 5848              		.loc 1 3218 0
 5849 3230 000050E3 		cmp	r0, #0
 5850 3234 AE02001A 		bne	.L541
3222:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5851              		.loc 1 3222 0
 5852 3238 0020A0E3 		mov	r2, #0
 5853 323c 84029FE5 		ldr	r0, .L658
 5854              	.LVL648:
 5855 3240 8010A0E3 		mov	r1, #128
 5856 3244 FEFFFFEB 		bl	_txe_event_flags_set
 5857              	.LVL649:
3223:../uvc.c      ****                             {
 5858              		.loc 1 3223 0
 5859 3248 002050E2 		subs	r2, r0, #0
3229:../uvc.c      ****                             //stillcont = 0;
 5860              		.loc 1 3229 0
 5861 324c F030A003 		moveq	r3, #240
 5862 3250 30308405 		streq	r3, [r4, #48]
3223:../uvc.c      ****                             {
 5863              		.loc 1 3223 0
 5864 3254 0A04001A 		bne	.L650
 5865              	.LVL650:
 5866              	.L543:
3232:../uvc.c      ****                         }else{
 5867              		.loc 1 3232 0
 5868 3258 C110DBE5 		ldrb	r1, [fp, #193]	@ zero_extendqisi2
 5869 325c C030DBE5 		ldrb	r3, [fp, #192]	@ zero_extendqisi2
 5870 3260 B824DDE1 		ldrh	r2, [sp, #72]
 5871 3264 00108DE5 		str	r1, [sp]
 5872 3268 0400A0E3 		mov	r0, #4
 5873 326c A8129FE5 		ldr	r1, .L658+84
 5874 3270 FEFFFFEB 		bl	CyU3PDebugPrint
 5875              	.LVL651:
 5876 3274 D5FCFFEA 		b	.L506
 5877              	.L634:
 5878              	.LBE138:
 5879              	.LBE430:
 5880              	.LBB431:
 5881              	.LBB410:
2844:../uvc.c      ****     {
 5882              		.loc 1 2844 0
 5883 3278 010A53E3 		cmp	r3, #4096
 5884 327c C5FCFF1A 		bne	.L260
 5885              	.LVL652:
2907:../uvc.c      ****     		break;
 5886              		.loc 1 2907 0
 5887 3280 1F00A0E3 		mov	r0, #31
 5888 3284 FEFFFFEB 		bl	ControlHandle
 5889              	.LVL653:
 5890 3288 50309DE5 		ldr	r3, [sp, #80]
 5891 328c C6FCFFEA 		b	.L259
 5892              	.L629:
2844:../uvc.c      ****     {
 5893              		.loc 1 2844 0
 5894 3290 050C53E3 		cmp	r3, #1280
 5895 3294 BFFCFF1A 		bne	.L260
 5896              	.LVL654:
2864:../uvc.c      ****     		break;
 5897              		.loc 1 2864 0
 5898 3298 1400A0E3 		mov	r0, #20
 5899 329c FEFFFFEB 		bl	ControlHandle
 5900              	.LVL655:
 5901 32a0 50309DE5 		ldr	r3, [sp, #80]
 5902 32a4 C0FCFFEA 		b	.L259
 5903              	.L408:
 5904              	.LBE410:
 5905              	.LBE431:
 5906              	.LBB432:
 5907              	.LBB313:
 5908              	.LBB239:
 5909              	.LBB158:
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5910              		.loc 1 989 0
 5911 32a8 0030A0E3 		mov	r3, #0
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5912              		.loc 1 990 0
 5913 32ac 0200A0E3 		mov	r0, #2
 5914 32b0 9C129FE5 		ldr	r1, .L658+140
 988:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5915              		.loc 1 988 0
 5916 32b4 5880CBE5 		strb	r8, [fp, #88]
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5917              		.loc 1 989 0
 5918 32b8 5930CBE5 		strb	r3, [fp, #89]
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5919              		.loc 1 990 0
 5920 32bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5921              	.LVL656:
 991:../uvc.c      **** 			  break;
 5922              		.loc 1 991 0
 5923 32c0 5820DBE5 		ldrb	r2, [fp, #88]	@ zero_extendqisi2
 5924              	.LVL657:
 5925              	.L412:
1197:../uvc.c      **** }
 5926              		.loc 1 1197 0
 5927 32c4 5A10DBE5 		ldrb	r1, [fp, #90]	@ zero_extendqisi2
 5928 32c8 FF30A0E3 		mov	r3, #255
 5929 32cc 08208DE5 		str	r2, [sp, #8]
 5930 32d0 04108DE5 		str	r1, [sp, #4]
 5931 32d4 10108DE5 		str	r1, [sp, #16]
 5932 32d8 00308DE5 		str	r3, [sp]
 5933 32dc 0C308DE5 		str	r3, [sp, #12]
 5934 32e0 14808DE5 		str	r8, [sp, #20]
 5935 32e4 0720A0E1 		mov	r2, r7
 5936              	.LVL658:
 5937 32e8 0400A0E3 		mov	r0, #4
 5938 32ec 18129FE5 		ldr	r1, .L658+68
 5939 32f0 FEFFFFEB 		bl	CyU3PDebugPrint
 5940              	.LVL659:
 5941 32f4 50309DE5 		ldr	r3, [sp, #80]
 5942 32f8 ABFCFFEA 		b	.L259
 5943              	.LVL660:
 5944              	.L448:
 5945              	.LBE158:
 5946              	.LBE239:
 5947              	.LBE313:
 5948              	.LBE432:
 5949              	.LBB433:
 5950              	.LBB411:
2911:../uvc.c      ****     		break;
 5951              		.loc 1 2911 0
 5952 32fc 2400A0E3 		mov	r0, #36
 5953 3300 FEFFFFEB 		bl	ControlHandle
 5954              	.LVL661:
 5955 3304 50309DE5 		ldr	r3, [sp, #80]
 5956 3308 A7FCFFEA 		b	.L259
 5957              	.L438:
 5958              	.LVL662:
2868:../uvc.c      ****      		break;
 5959              		.loc 1 2868 0
 5960 330c 1500A0E3 		mov	r0, #21
 5961 3310 FEFFFFEB 		bl	ControlHandle
 5962              	.LVL663:
 5963 3314 50309DE5 		ldr	r3, [sp, #80]
 5964 3318 A3FCFFEA 		b	.L259
 5965              	.L441:
 5966              	.LVL664:
2872:../uvc.c      ****     		break;
 5967              		.loc 1 2872 0
 5968 331c 1600A0E3 		mov	r0, #22
 5969 3320 FEFFFFEB 		bl	ControlHandle
 5970              	.LVL665:
 5971 3324 50309DE5 		ldr	r3, [sp, #80]
 5972 3328 9FFCFFEA 		b	.L259
 5973              	.L436:
 5974              	.LVL666:
2856:../uvc.c      ****      		break;
 5975              		.loc 1 2856 0
 5976 332c 1200A0E3 		mov	r0, #18
 5977 3330 FEFFFFEB 		bl	ControlHandle
 5978              	.LVL667:
 5979 3334 50309DE5 		ldr	r3, [sp, #80]
 5980 3338 9BFCFFEA 		b	.L259
 5981              	.L435:
 5982              	.LVL668:
2852:../uvc.c      ****     		break;
 5983              		.loc 1 2852 0
 5984 333c 1100A0E3 		mov	r0, #17
 5985 3340 FEFFFFEB 		bl	ControlHandle
 5986              	.LVL669:
 5987 3344 50309DE5 		ldr	r3, [sp, #80]
 5988 3348 97FCFFEA 		b	.L259
 5989              	.L451:
 5990              	.LVL670:
 5991              	.LBB364:
 5992              	.LBB365:
 418:../uvc.c      ****     /*
 5993              		.loc 1 418 0
 5994 334c 88219FE5 		ldr	r2, .L658+20
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 5995              		.loc 1 404 0
 5996 3350 7830DAE5 		ldrb	r3, [r10, #120]	@ zero_extendqisi2
 5997              	.LVL671:
 418:../uvc.c      ****     /*
 5998              		.loc 1 418 0
 5999 3354 0070D2E5 		ldrb	r7, [r2]	@ zero_extendqisi2
 406:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 6000              		.loc 1 406 0
 6001 3358 8780DAE5 		ldrb	r8, [r10, #135]	@ zero_extendqisi2
 6002              	.LVL672:
 426:../uvc.c      **** 		 {
 6003              		.loc 1 426 0
 6004 335c 830057E3 		cmp	r7, #131
 407:../uvc.c      ****     }else{
 6005              		.loc 1 407 0
 6006 3360 7AC0DAE5 		ldrb	ip, [r10, #122]	@ zero_extendqisi2
 6007              	.LVL673:
 426:../uvc.c      **** 		 {
 6008              		.loc 1 426 0
 6009 3364 D104000A 		beq	.L480
 6010 3368 EE01009A 		bls	.L651
 6011 336c 850057E3 		cmp	r7, #133
 6012 3370 6604000A 		beq	.L485
 6013 3374 E404003A 		bcc	.L486
 6014 3378 860057E3 		cmp	r7, #134
 6015 337c 1B03000A 		beq	.L487
 6016 3380 870057E3 		cmp	r7, #135
 646:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 6017              		.loc 1 646 0
 6018 3384 83E0DA05 		ldreqb	lr, [r10, #131]	@ zero_extendqisi2
 647:../uvc.c      **** 		 	 }
 6019              		.loc 1 647 0
 6020 3388 8420DA05 		ldreqb	r2, [r10, #132]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 6021              		.loc 1 426 0
 6022 338c A604001A 		bne	.L479
 6023              	.L611:
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6024              		.loc 1 596 0
 6025 3390 BC119FE5 		ldr	r1, .L658+140
 6026 3394 0C00A0E1 		mov	r0, ip
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6027              		.loc 1 414 0
 6028 3398 FF80A0E3 		mov	r8, #255
 582:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 6029              		.loc 1 582 0
 6030 339c 58E0CBE5 		strb	lr, [fp, #88]
 6031              	.L609:
 583:../uvc.c      **** 		 	 }
 6032              		.loc 1 583 0
 6033 33a0 5920CBE5 		strb	r2, [fp, #89]
 6034              	.L612:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6035              		.loc 1 414 0
 6036 33a4 30808DE5 		str	r8, [sp, #48]
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6037              		.loc 1 596 0
 6038 33a8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6039              	.LVL674:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6040              		.loc 1 414 0
 6041 33ac 08C0A0E1 		mov	ip, r8
 597:../uvc.c      **** 			  break;
 6042              		.loc 1 597 0
 6043 33b0 5820DBE5 		ldrb	r2, [fp, #88]	@ zero_extendqisi2
 6044              	.LVL675:
 6045 33b4 30309DE5 		ldr	r3, [sp, #48]
 6046 33b8 020200EA 		b	.L489
 6047              	.LVL676:
 6048              	.L433:
 6049              	.LBE365:
 6050              	.LBE364:
2860:../uvc.c      ****     		break;
 6051              		.loc 1 2860 0
 6052 33bc 1300A0E3 		mov	r0, #19
 6053 33c0 FEFFFFEB 		bl	ControlHandle
 6054              	.LVL677:
 6055 33c4 50309DE5 		ldr	r3, [sp, #80]
 6056 33c8 77FCFFEA 		b	.L259
 6057              	.L431:
 6058              	.LVL678:
2880:../uvc.c      ****      		break;
 6059              		.loc 1 2880 0
 6060 33cc 1800A0E3 		mov	r0, #24
 6061 33d0 FEFFFFEB 		bl	ControlHandle
 6062              	.LVL679:
 6063 33d4 50309DE5 		ldr	r3, [sp, #80]
 6064 33d8 73FCFFEA 		b	.L259
 6065              	.L443:
 6066              	.LVL680:
 6067              	.LBB374:
 6068              	.LBB355:
 418:../uvc.c      ****     /*
 6069              		.loc 1 418 0
 6070 33dc F8209FE5 		ldr	r2, .L658+20
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6071              		.loc 1 409 0
 6072 33e0 5034DAE5 		ldrb	r3, [r10, #1104]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 6073              		.loc 1 418 0
 6074 33e4 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6075              		.loc 1 409 0
 6076 33e8 30308DE5 		str	r3, [sp, #48]
 6077              	.LVL681:
 426:../uvc.c      **** 		 {
 6078              		.loc 1 426 0
 6079 33ec 830058E3 		cmp	r8, #131
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 6080              		.loc 1 411 0
 6081 33f0 5F34DAE5 		ldrb	r3, [r10, #1119]	@ zero_extendqisi2
 6082              	.LVL682:
 412:../uvc.c      ****     }
 6083              		.loc 1 412 0
 6084 33f4 5274DAE5 		ldrb	r7, [r10, #1106]	@ zero_extendqisi2
 6085              	.LVL683:
 426:../uvc.c      **** 		 {
 6086              		.loc 1 426 0
 6087 33f8 A804000A 		beq	.L467
 6088 33fc FA01009A 		bls	.L652
 6089 3400 850058E3 		cmp	r8, #133
 6090 3404 4704000A 		beq	.L472
 6091 3408 B004003A 		bcc	.L473
 6092 340c 860058E3 		cmp	r8, #134
 6093 3410 EC02000A 		beq	.L474
 6094 3414 870058E3 		cmp	r8, #135
 6095 3418 5604001A 		bne	.L466
 656:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 6096              		.loc 1 656 0
 6097 341c A8C09FE5 		ldr	ip, .L658+4
 6098 3420 5B24DCE5 		ldrb	r2, [ip, #1115]	@ zero_extendqisi2
 657:../uvc.c      **** 			 }
 6099              		.loc 1 657 0
 6100 3424 5C34DCE5 		ldrb	r3, [ip, #1116]	@ zero_extendqisi2
 6101              	.L608:
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6102              		.loc 1 596 0
 6103 3428 24119FE5 		ldr	r1, .L658+140
 6104 342c 0700A0E1 		mov	r0, r7
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 6105              		.loc 1 593 0
 6106 3430 5820CBE5 		strb	r2, [fp, #88]
 6107              	.L607:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6108              		.loc 1 414 0
 6109 3434 FF70A0E3 		mov	r7, #255
 594:../uvc.c      **** 			 }
 6110              		.loc 1 594 0
 6111 3438 5930CBE5 		strb	r3, [fp, #89]
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6112              		.loc 1 596 0
 6113 343c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6114              	.LVL684:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6115              		.loc 1 414 0
 6116 3440 07C0A0E1 		mov	ip, r7
 597:../uvc.c      **** 			  break;
 6117              		.loc 1 597 0
 6118 3444 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 6119              	.LVL685:
 6120 3448 0D0200EA 		b	.L476
 6121              	.LVL686:
 6122              	.L446:
 6123              	.LBE355:
 6124              	.LBE374:
 6125              	.LBB375:
 6126              	.LBB376:
 418:../uvc.c      ****     /*
 6127              		.loc 1 418 0
 6128 344c 88309FE5 		ldr	r3, .L658+20
 412:../uvc.c      ****     }
 6129              		.loc 1 412 0
 6130 3450 22C4DAE5 		ldrb	ip, [r10, #1058]	@ zero_extendqisi2
 6131              	.LVL687:
 418:../uvc.c      ****     /*
 6132              		.loc 1 418 0
 6133 3454 0070D3E5 		ldrb	r7, [r3]	@ zero_extendqisi2
 6134              	.LVL688:
 426:../uvc.c      **** 		 {
 6135              		.loc 1 426 0
 6136 3458 830057E3 		cmp	r7, #131
 6137 345c 9704000A 		beq	.L454
 6138 3460 0C02009A 		bls	.L653
 6139 3464 850057E3 		cmp	r7, #133
 6140 3468 8704000A 		beq	.L459
 6141 346c 7804003A 		bcc	.L460
 6142 3470 860057E3 		cmp	r7, #134
 6143 3474 CA02000A 		beq	.L461
 6144 3478 870057E3 		cmp	r7, #135
 656:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 6145              		.loc 1 656 0
 6146 347c 2B24DA05 		ldreqb	r2, [r10, #1067]	@ zero_extendqisi2
 657:../uvc.c      **** 			 }
 6147              		.loc 1 657 0
 6148 3480 2C34DA05 		ldreqb	r3, [r10, #1068]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 6149              		.loc 1 426 0
 6150 3484 5204001A 		bne	.L453
 6151              	.L606:
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6152              		.loc 1 596 0
 6153 3488 C4109FE5 		ldr	r1, .L658+140
 6154 348c 0C00A0E1 		mov	r0, ip
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 6155              		.loc 1 593 0
 6156 3490 5820CBE5 		strb	r2, [fp, #88]
 6157              	.L605:
 594:../uvc.c      **** 			 }
 6158              		.loc 1 594 0
 6159 3494 5930CBE5 		strb	r3, [fp, #89]
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6160              		.loc 1 596 0
 6161 3498 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6162              	.LVL689:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6163              		.loc 1 414 0
 6164 349c FF10A0E3 		mov	r1, #255
 6165 34a0 0130A0E1 		mov	r3, r1
 597:../uvc.c      **** 			  break;
 6166              		.loc 1 597 0
 6167 34a4 5880DBE5 		ldrb	r8, [fp, #88]	@ zero_extendqisi2
 6168              	.LVL690:
 6169 34a8 080200EA 		b	.L463
 6170              	.LVL691:
 6171              	.L539:
 6172              	.LBE376:
 6173              	.LBE375:
 6174              	.LBE411:
 6175              	.LBE433:
 6176              	.LBB434:
 6177              	.LBB139:
3199:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6178              		.loc 1 3199 0
 6179 34ac 0020A0E3 		mov	r2, #0
3200:../uvc.c      ****                         break;
 6180              		.loc 1 3200 0
 6181 34b0 9C109FE5 		ldr	r1, .L658+140
 6182 34b4 0200A0E3 		mov	r0, #2
3198:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6183              		.loc 1 3198 0
 6184 34b8 5830CBE5 		strb	r3, [fp, #88]
3199:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6185              		.loc 1 3199 0
 6186 34bc 5920CBE5 		strb	r2, [fp, #89]
3200:../uvc.c      ****                         break;
 6187              		.loc 1 3200 0
 6188 34c0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6189              	.LVL692:
 6190 34c4 41FCFFEA 		b	.L506
 6191              	.L659:
 6192              		.align	2
 6193              	.L658:
 6194 34c8 00000000 		.word	.LANCHOR0
 6195 34cc 00000000 		.word	.LANCHOR1
 6196 34d0 00000000 		.word	glInterStaBuffer
 6197 34d4 00000000 		.word	wIndex
 6198 34d8 00000000 		.word	wValue
 6199 34dc 00000000 		.word	bRequest
 6200 34e0 10050000 		.word	.LC27
 6201 34e4 00000000 		.word	glChHandleInterStat
 6202 34e8 00000000 		.word	bmReqType
 6203 34ec 00000000 		.word	wLength
 6204 34f0 94040000 		.word	.LC26
 6205 34f4 10060000 		.word	.LANCHOR1+1552
 6206 34f8 C0000000 		.word	.LANCHOR0+192
 6207 34fc 3C050000 		.word	.LC28
 6208 3500 D8050000 		.word	.LC32
 6209 3504 2C060000 		.word	.LANCHOR1+1580
 6210 3508 38060000 		.word	.LANCHOR1+1592
 6211 350c C4030000 		.word	.LC22
 6212 3510 28060000 		.word	.LC34
 6213 3514 88050000 		.word	.LC30
 6214 3518 B0050000 		.word	.LC31
 6215 351c 74060000 		.word	.LC36
 6216 3520 FFFF0000 		.word	65535
 6217 3524 10000000 		.word	.LANCHOR2+16
 6218 3528 54030000 		.word	.LC19
 6219 352c 7C030000 		.word	.LC20
 6220 3530 00000000 		.word	cmdQu
 6221 3534 04030000 		.word	.LC18
 6222 3538 A0060000 		.word	.LC37
 6223 353c C8060000 		.word	.LC38
 6224 3540 A0030000 		.word	.LC21
 6225 3544 64050000 		.word	.LC29
 6226 3548 04060000 		.word	.LC33
 6227 354c 50060000 		.word	.LC35
 6228 3550 00000000 		.word	.LANCHOR1
 6229 3554 58000000 		.word	.LANCHOR0+88
 6230              	.LVL693:
 6231              	.L640:
 6232              	.LBE139:
 6233              	.LBE434:
 6234              	.LBB435:
 6235              	.LBB344:
 6236              	.LBB333:
 6237              	.LBB326:
 426:../uvc.c      **** 		 {
 6238              		.loc 1 426 0
 6239 3558 810057E3 		cmp	r7, #129
 6240 355c 0302000A 		beq	.L283
 6241 3560 2F03008A 		bhi	.L284
 6242 3564 010057E3 		cmp	r7, #1
 6243 3568 AD02001A 		bne	.L280
 663:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6244              		.loc 1 663 0
 6245 356c 48208DE2 		add	r2, sp, #72
 6246 3570 2000A0E3 		mov	r0, #32
 6247 3574 28101FE5 		ldr	r1, .L658+140
 6248 3578 28308DE5 		str	r3, [sp, #40]
 6249 357c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6250              	.LVL694:
 665:../uvc.c      **** 			   {
 6251              		.loc 1 665 0
 6252 3580 002050E2 		subs	r2, r0, #0
 6253 3584 8F04001A 		bne	.L292
 938:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 6254              		.loc 1 938 0
 6255 3588 60E01FE5 		ldr	lr, .L658+104
 667:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6256              		.loc 1 667 0
 6257 358c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 6258              	.LVL695:
 938:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 6259              		.loc 1 938 0
 6260 3590 1C009EE5 		ldr	r0, [lr, #28]
 6261              	.LVL696:
 6262 3594 0010E0E3 		mvn	r1, #0
 670:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6263              		.loc 1 670 0
 6264 3598 5A80D4E5 		ldrb	r8, [r4, #90]	@ zero_extendqisi2
 6265              	.LVL697:
 938:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 6266              		.loc 1 938 0
 6267 359c 2C208DE5 		str	r2, [sp, #44]
 6268 35a0 24C08DE5 		str	ip, [sp, #36]
 6269 35a4 FEFFFFEB 		bl	_txe_mutex_get
 6270              	.LVL698:
 939:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6271              		.loc 1 939 0
 6272 35a8 24C09DE5 		ldr	ip, [sp, #36]
 6273 35ac 2C209DE5 		ldr	r2, [sp, #44]
 6274 35b0 00C08DE5 		str	ip, [sp]
 6275 35b4 28309DE5 		ldr	r3, [sp, #40]
 6276 35b8 04208DE5 		str	r2, [sp, #4]
 6277 35bc 0E10A0E3 		mov	r1, #14
 6278 35c0 30209DE5 		ldr	r2, [sp, #48]
 6279 35c4 9C001FE5 		ldr	r0, .L658+104
 6280 35c8 FEFFFFEB 		bl	cmdSet
 6281              	.LVL699:
 940:../uvc.c      **** 
 6282              		.loc 1 940 0
 6283 35cc A4101FE5 		ldr	r1, .L658+104
 6284 35d0 1C0091E5 		ldr	r0, [r1, #28]
 6285 35d4 FEFFFFEB 		bl	_txe_mutex_put
 6286              	.LVL700:
 942:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 6287              		.loc 1 942 0
 6288 35d8 24C09DE5 		ldr	ip, [sp, #36]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6289              		.loc 1 414 0
 6290 35dc FF30A0E3 		mov	r3, #255
 942:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 6291              		.loc 1 942 0
 6292 35e0 DDC2CAE5 		strb	ip, [r10, #733]
 943:../uvc.c      **** 							 break;
 6293              		.loc 1 943 0
 6294 35e4 E072CAE5 		strb	r7, [r10, #736]
 6295 35e8 98FDFFEA 		b	.L290
 6296              	.LVL701:
 6297              	.L630:
 6298 35ec 0030A0E1 		mov	r3, r0
 6299              	.LBE326:
 6300              	.LBE333:
 6301              	.LBE344:
 6302              	.LBE435:
3372:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 6303              		.loc 1 3372 0
 6304 35f0 0320A0E1 		mov	r2, r3
 6305 35f4 0800A0E1 		mov	r0, r8
 6306              	.LVL702:
 6307 35f8 C4101FE5 		ldr	r1, .L658+116
 6308 35fc 28308DE5 		str	r3, [sp, #40]
 6309 3600 FEFFFFEB 		bl	CyU3PDebugPrint
 6310              	.LVL703:
3373:../uvc.c      **** 					}
 6311              		.loc 1 3373 0
 6312 3604 28309DE5 		ldr	r3, [sp, #40]
 6313 3608 0300A0E1 		mov	r0, r3
 6314 360c FEFFFFEB 		bl	CyFxAppErrorHandler
 6315              	.LVL704:
 6316              	.L646:
 6317              	.LBB436:
 6318              	.LBB314:
 6319              	.LBB240:
 6320              	.LBB210:
 984:../uvc.c      **** 		 {
 6321              		.loc 1 984 0
 6322 3610 810058E3 		cmp	r8, #129
 6323 3614 4302000A 		beq	.L333
 6324 3618 5203008A 		bhi	.L334
 6325 361c 010058E3 		cmp	r8, #1
 6326 3620 CF02001A 		bne	.L330
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6327              		.loc 1 1055 0
 6328 3624 48208DE2 		add	r2, sp, #72
 6329 3628 2000A0E3 		mov	r0, #32
 6330 362c E0101FE5 		ldr	r1, .L658+140
 6331 3630 28308DE5 		str	r3, [sp, #40]
 6332 3634 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6333              	.LVL705:
1057:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6334              		.loc 1 1057 0
 6335 3638 58C0DBE5 		ldrb	ip, [fp, #88]	@ zero_extendqisi2
1113:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6336              		.loc 1 1113 0
 6337 363c B524DAE5 		ldrb	r2, [r10, #1205]	@ zero_extendqisi2
1057:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6338              		.loc 1 1057 0
 6339 3640 34C08DE5 		str	ip, [sp, #52]
 6340              	.LVL706:
1058:../uvc.c      **** 			  value = Data1;
 6341              		.loc 1 1058 0
 6342 3644 59C0DBE5 		ldrb	ip, [fp, #89]	@ zero_extendqisi2
1113:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6343              		.loc 1 1113 0
 6344 3648 010052E3 		cmp	r2, #1
 6345 364c 04005213 		cmpne	r2, #4
1058:../uvc.c      **** 			  value = Data1;
 6346              		.loc 1 1058 0
 6347 3650 38C08DE5 		str	ip, [sp, #56]
 6348              	.LVL707:
1113:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6349              		.loc 1 1113 0
 6350 3654 28309DE5 		ldr	r3, [sp, #40]
 6351 3658 A703001A 		bne	.L341
1112:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 6352              		.loc 1 1112 0
 6353 365c 34109DE5 		ldr	r1, [sp, #52]
 6354 3660 0CE481E1 		orr	lr, r1, ip, asl #8
1114:../uvc.c      **** 					  {
 6355              		.loc 1 1114 0
 6356 3664 F9005EE3 		cmp	lr, #249
 6357 3668 A303008A 		bhi	.L341
 6358 366c 54C11FE5 		ldr	ip, .L658+88
 6359 3670 0020A0E3 		mov	r2, #0
 6360 3674 0100A0E3 		mov	r0, #1
 6361 3678 20308DE5 		str	r3, [sp, #32]
 6362 367c 1C708DE5 		str	r7, [sp, #28]
 6363              	.LVL708:
 6364              	.L343:
1118:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 6365              		.loc 1 1118 0
 6366 3680 64711FE5 		ldr	r7, .L658+92
 6367 3684 8230A0E1 		mov	r3, r2, asl #1
 6368 3688 B33097E1 		ldrh	r3, [r7, r3]
 6369 368c FF1002E2 		and	r1, r2, #255
1119:../uvc.c      **** 							}else{
 6370              		.loc 1 1119 0
 6371 3690 0E7063E0 		rsb	r7, r3, lr
 6372 3694 03005EE1 		cmp	lr, r3
 6373 3698 3C108DE5 		str	r1, [sp, #60]
1121:../uvc.c      **** 							}
 6374              		.loc 1 1121 0
 6375 369c 03106EE0 		rsb	r1, lr, r3
 6376 36a0 0138A091 		movls	r3, r1, asl #16
 6377 36a4 0738A081 		movhi	r3, r7, asl #16
 6378 36a8 3C709DE5 		ldr	r7, [sp, #60]
 6379 36ac 2338A0E1 		mov	r3, r3, lsr #16
 6380 36b0 0C0053E1 		cmp	r3, ip
 6381 36b4 012082E2 		add	r2, r2, #1
 6382 36b8 0700A031 		movcc	r0, r7
 6383              	.LVL709:
 6384 36bc 0C0053E1 		cmp	r3, ip
 6385 36c0 03C0A031 		movcc	ip, r3
 6386              	.LVL710:
1116:../uvc.c      **** 						  {
 6387              		.loc 1 1116 0
 6388 36c4 080052E3 		cmp	r2, #8
 6389 36c8 ECFFFF1A 		bne	.L343
1131:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6390              		.loc 1 1131 0
 6391 36cc A4C11FE5 		ldr	ip, .L658+104
 6392              	.LVL711:
 6393 36d0 20309DE5 		ldr	r3, [sp, #32]
1128:../uvc.c      **** 
 6394              		.loc 1 1128 0
 6395 36d4 012080E2 		add	r2, r0, #1
 6396 36d8 FF2002E2 		and	r2, r2, #255
1131:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6397              		.loc 1 1131 0
 6398 36dc 1C009CE5 		ldr	r0, [ip, #28]
 6399              	.LVL712:
 6400 36e0 0010E0E3 		mvn	r1, #0
1128:../uvc.c      **** 
 6401              		.loc 1 1128 0
 6402 36e4 3C208DE5 		str	r2, [sp, #60]
 6403              	.LVL713:
1131:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6404              		.loc 1 1131 0
 6405 36e8 28308DE5 		str	r3, [sp, #40]
 6406 36ec 24C08DE5 		str	ip, [sp, #36]
 6407 36f0 1C709DE5 		ldr	r7, [sp, #28]
 6408 36f4 FEFFFFEB 		bl	_txe_mutex_get
 6409              	.LVL714:
1132:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6410              		.loc 1 1132 0
 6411 36f8 3CE09DE5 		ldr	lr, [sp, #60]
 6412 36fc 24C09DE5 		ldr	ip, [sp, #36]
 6413 3700 0010A0E3 		mov	r1, #0
 6414 3704 28309DE5 		ldr	r3, [sp, #40]
 6415 3708 00E08DE5 		str	lr, [sp]
 6416 370c 30209DE5 		ldr	r2, [sp, #48]
 6417 3710 0C00A0E1 		mov	r0, ip
 6418 3714 04108DE5 		str	r1, [sp, #4]
 6419 3718 0310A0E3 		mov	r1, #3
 6420 371c FEFFFFEB 		bl	cmdSet
 6421              	.LVL715:
1133:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 6422              		.loc 1 1133 0
 6423 3720 24C09DE5 		ldr	ip, [sp, #36]
 6424 3724 1C009CE5 		ldr	r0, [ip, #28]
 6425 3728 FEFFFFEB 		bl	_txe_mutex_put
 6426              	.LVL716:
1139:../uvc.c      **** 					  }else{
 6427              		.loc 1 1139 0
 6428 372c 3CC09DE5 		ldr	ip, [sp, #60]
1138:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6429              		.loc 1 1138 0
 6430 3730 0130A0E3 		mov	r3, #1
1139:../uvc.c      **** 					  }else{
 6431              		.loc 1 1139 0
 6432 3734 0DC3CAE5 		strb	ip, [r10, #781]
1136:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6433              		.loc 1 1136 0
 6434 3738 34C09DE5 		ldr	ip, [sp, #52]
1138:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6435              		.loc 1 1138 0
 6436 373c E834CAE5 		strb	r3, [r10, #1256]
1136:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6437              		.loc 1 1136 0
 6438 3740 E5C4CAE5 		strb	ip, [r10, #1253]
1137:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 6439              		.loc 1 1137 0
 6440 3744 38C09DE5 		ldr	ip, [sp, #56]
 6441 3748 E6C4CAE5 		strb	ip, [r10, #1254]
 6442              	.LVL717:
 6443              	.L344:
1143:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 6444              		.loc 1 1143 0
 6445 374c 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 6446              	.LVL718:
1144:../uvc.c      **** 					  break;
 6447              		.loc 1 1144 0
 6448 3750 5920DBE5 		ldrb	r2, [fp, #89]	@ zero_extendqisi2
 6449              	.LVL719:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6450              		.loc 1 978 0
 6451 3754 FFC0A0E3 		mov	ip, #255
 6452 3758 EEFDFFEA 		b	.L340
 6453              	.LVL720:
 6454              	.L648:
 6455              	.LBE210:
 6456              	.LBE240:
 6457              	.LBB241:
 6458              	.LBB229:
 984:../uvc.c      **** 		 {
 6459              		.loc 1 984 0
 6460 375c 810057E3 		cmp	r7, #129
 6461 3760 AA01000A 		beq	.L381
 6462 3764 0303008A 		bhi	.L382
 6463 3768 010057E3 		cmp	r7, #1
 6464 376c 5102001A 		bne	.L378
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6465              		.loc 1 1055 0
 6466 3770 2000A0E3 		mov	r0, #32
 6467 3774 28121FE5 		ldr	r1, .L658+140
 6468 3778 48208DE2 		add	r2, sp, #72
 6469 377c 28308DE5 		str	r3, [sp, #40]
 6470 3780 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6471              	.LVL721:
1147:../uvc.c      **** 					  {
 6472              		.loc 1 1147 0
 6473 3784 3CC21FE5 		ldr	ip, .L658+136
 6474 3788 B504DCE5 		ldrb	r0, [ip, #1205]	@ zero_extendqisi2
1057:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6475              		.loc 1 1057 0
 6476 378c 58C0DBE5 		ldrb	ip, [fp, #88]	@ zero_extendqisi2
1147:../uvc.c      **** 					  {
 6477              		.loc 1 1147 0
 6478 3790 010050E3 		cmp	r0, #1
 6479 3794 08005013 		cmpne	r0, #8
1057:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6480              		.loc 1 1057 0
 6481 3798 34C08DE5 		str	ip, [sp, #52]
 6482              	.LVL722:
1058:../uvc.c      **** 			  value = Data1;
 6483              		.loc 1 1058 0
 6484 379c 59C0DBE5 		ldrb	ip, [fp, #89]	@ zero_extendqisi2
1147:../uvc.c      **** 					  {
 6485              		.loc 1 1147 0
 6486 37a0 0000A013 		movne	r0, #0
 6487 37a4 0100A003 		moveq	r0, #1
1058:../uvc.c      **** 			  value = Data1;
 6488              		.loc 1 1058 0
 6489 37a8 38C08DE5 		str	ip, [sp, #56]
 6490              	.LVL723:
1147:../uvc.c      **** 					  {
 6491              		.loc 1 1147 0
 6492 37ac E103001A 		bne	.L389
 6493              	.LVL724:
1150:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 6494              		.loc 1 1150 0
 6495 37b0 88C21FE5 		ldr	ip, .L658+104
 6496 37b4 0010E0E3 		mvn	r1, #0
 6497 37b8 1C009CE5 		ldr	r0, [ip, #28]
 6498 37bc 24C08DE5 		str	ip, [sp, #36]
 6499 37c0 FEFFFFEB 		bl	_txe_mutex_get
 6500              	.LVL725:
1151:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6501              		.loc 1 1151 0
 6502 37c4 34E09DE5 		ldr	lr, [sp, #52]
 6503 37c8 24C09DE5 		ldr	ip, [sp, #36]
 6504 37cc 0010A0E3 		mov	r1, #0
 6505 37d0 00E08DE5 		str	lr, [sp]
 6506 37d4 30209DE5 		ldr	r2, [sp, #48]
 6507 37d8 28309DE5 		ldr	r3, [sp, #40]
 6508 37dc 0C00A0E1 		mov	r0, ip
 6509 37e0 04108DE5 		str	r1, [sp, #4]
 6510 37e4 2210A0E3 		mov	r1, #34
 6511 37e8 FEFFFFEB 		bl	cmdSet
 6512              	.LVL726:
1152:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 6513              		.loc 1 1152 0
 6514 37ec 24C09DE5 		ldr	ip, [sp, #36]
 6515 37f0 1C009CE5 		ldr	r0, [ip, #28]
 6516 37f4 FEFFFFEB 		bl	_txe_mutex_put
 6517              	.LVL727:
1155:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6518              		.loc 1 1155 0
 6519 37f8 B0E21FE5 		ldr	lr, .L658+136
 6520 37fc 34C09DE5 		ldr	ip, [sp, #52]
1157:../uvc.c      **** 					  }else{
 6521              		.loc 1 1157 0
 6522 3800 4875CEE5 		strb	r7, [lr, #1352]
1155:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6523              		.loc 1 1155 0
 6524 3804 45C5CEE5 		strb	ip, [lr, #1349]
1156:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 6525              		.loc 1 1156 0
 6526 3808 38C09DE5 		ldr	ip, [sp, #56]
 6527 380c 46C5CEE5 		strb	ip, [lr, #1350]
 6528              	.LVL728:
 6529              	.L390:
1161:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 6530              		.loc 1 1161 0
 6531 3810 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 6532              	.LVL729:
1162:../uvc.c      **** 
 6533              		.loc 1 1162 0
 6534 3814 5920DBE5 		ldrb	r2, [fp, #89]	@ zero_extendqisi2
 6535              	.LVL730:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6536              		.loc 1 978 0
 6537 3818 FFC0A0E3 		mov	ip, #255
 6538 381c 11FEFFEA 		b	.L388
 6539              	.LVL731:
 6540              	.L647:
 6541              	.LBE229:
 6542              	.LBE241:
 6543              	.LBB242:
 6544              	.LBB219:
 984:../uvc.c      **** 		 {
 6545              		.loc 1 984 0
 6546 3820 810057E3 		cmp	r7, #129
 6547 3824 8901000A 		beq	.L416
 6548 3828 1103008A 		bhi	.L417
 6549 382c 010057E3 		cmp	r7, #1
 6550 3830 0302001A 		bne	.L413
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6551              		.loc 1 1055 0
 6552 3834 E8121FE5 		ldr	r1, .L658+140
 6553 3838 48208DE2 		add	r2, sp, #72
 6554 383c 2000A0E3 		mov	r0, #32
 6555 3840 28308DE5 		str	r3, [sp, #40]
 6556 3844 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6557              	.LVL732:
1170:../uvc.c      **** 					  if(getData == 1)
 6558              		.loc 1 1170 0
 6559 3848 20E31FE5 		ldr	lr, .L658+104
1057:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6560              		.loc 1 1057 0
 6561 384c 58C0DBE5 		ldrb	ip, [fp, #88]	@ zero_extendqisi2
 6562              	.LVL733:
1170:../uvc.c      **** 					  if(getData == 1)
 6563              		.loc 1 1170 0
 6564 3850 1C009EE5 		ldr	r0, [lr, #28]
 6565 3854 0010E0E3 		mvn	r1, #0
1058:../uvc.c      **** 			  value = Data1;
 6566              		.loc 1 1058 0
 6567 3858 5980DBE5 		ldrb	r8, [fp, #89]	@ zero_extendqisi2
 6568              	.LVL734:
1170:../uvc.c      **** 					  if(getData == 1)
 6569              		.loc 1 1170 0
 6570 385c 24C08DE5 		str	ip, [sp, #36]
 6571 3860 FEFFFFEB 		bl	_txe_mutex_get
 6572              	.LVL735:
1171:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 6573              		.loc 1 1171 0
 6574 3864 24C09DE5 		ldr	ip, [sp, #36]
 6575 3868 28309DE5 		ldr	r3, [sp, #40]
 6576 386c 01005CE3 		cmp	ip, #1
 6577 3870 CA03000A 		beq	.L654
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 6578              		.loc 1 1173 0
 6579 3874 FF005CE3 		cmp	ip, #255
1176:../uvc.c      **** 					  //dataIdx++;
 6580              		.loc 1 1176 0
 6581 3878 0010A013 		movne	r1, #0
1174:../uvc.c      **** 					  else
 6582              		.loc 1 1174 0
 6583 387c 0810A003 		moveq	r1, #8
 6584 3880 0000A003 		moveq	r0, #0
 6585 3884 00108D05 		streq	r1, [sp]
 6586 3888 04008D05 		streq	r0, [sp, #4]
1176:../uvc.c      **** 					  //dataIdx++;
 6587              		.loc 1 1176 0
 6588 388c 00108D15 		strne	r1, [sp]
 6589 3890 04108D15 		strne	r1, [sp, #4]
1174:../uvc.c      **** 					  else
 6590              		.loc 1 1174 0
 6591 3894 34209D05 		ldreq	r2, [sp, #52]
1176:../uvc.c      **** 					  //dataIdx++;
 6592              		.loc 1 1176 0
 6593 3898 34209D15 		ldrne	r2, [sp, #52]
 6594 389c 74031FE5 		ldr	r0, .L658+104
 6595 38a0 2310A0E3 		mov	r1, #35
 6596 38a4 24C08DE5 		str	ip, [sp, #36]
 6597 38a8 FEFFFFEB 		bl	cmdSet
 6598              	.LVL736:
 6599 38ac 24C09DE5 		ldr	ip, [sp, #36]
 6600              	.L425:
1179:../uvc.c      **** #endif
 6601              		.loc 1 1179 0
 6602 38b0 88131FE5 		ldr	r1, .L658+104
 6603 38b4 1C0091E5 		ldr	r0, [r1, #28]
 6604 38b8 24C08DE5 		str	ip, [sp, #36]
 6605 38bc FEFFFFEB 		bl	_txe_mutex_put
 6606              	.LVL737:
1181:../uvc.c      **** 					  break;
 6607              		.loc 1 1181 0
 6608 38c0 5A30DBE5 		ldrb	r3, [fp, #90]	@ zero_extendqisi2
 6609 38c4 24C09DE5 		ldr	ip, [sp, #36]
 6610 38c8 00308DE5 		str	r3, [sp]
 6611 38cc 0C20A0E1 		mov	r2, ip
 6612 38d0 0830A0E1 		mov	r3, r8
 6613 38d4 0400A0E3 		mov	r0, #4
 6614 38d8 B8131FE5 		ldr	r1, .L658+96
 6615 38dc FEFFFFEB 		bl	CyU3PDebugPrint
 6616              	.LVL738:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6617              		.loc 1 978 0
 6618 38e0 FF30A0E3 		mov	r3, #255
 6619 38e4 24C09DE5 		ldr	ip, [sp, #36]
 6620 38e8 30209DE5 		ldr	r2, [sp, #48]
 6621 38ec B7FDFFEA 		b	.L423
 6622              	.LVL739:
 6623              	.L642:
 6624              	.LBE219:
 6625              	.LBE242:
 6626              	.LBB243:
 6627              	.LBB177:
 984:../uvc.c      **** 		 {
 6628              		.loc 1 984 0
 6629 38f0 810057E3 		cmp	r7, #129
 6630 38f4 3001000A 		beq	.L394
 6631 38f8 E002008A 		bhi	.L395
 6632 38fc 010057E3 		cmp	r7, #1
 6633 3900 11FDFF1A 		bne	.L391
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6634              		.loc 1 1055 0
 6635 3904 B8131FE5 		ldr	r1, .L658+140
 6636 3908 48208DE2 		add	r2, sp, #72
 6637 390c 2000A0E3 		mov	r0, #32
 6638 3910 24C08DE5 		str	ip, [sp, #36]
 6639 3914 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6640              	.LVL740:
1186:../uvc.c      **** 			  		 break;
 6641              		.loc 1 1186 0
 6642 3918 24C09DE5 		ldr	ip, [sp, #36]
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6643              		.loc 1 1185 0
 6644 391c 58E0DBE5 		ldrb	lr, [fp, #88]	@ zero_extendqisi2
1186:../uvc.c      **** 			  		 break;
 6645              		.loc 1 1186 0
 6646 3920 0820A0E3 		mov	r2, #8
 6647 3924 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6648 3928 0400A0E3 		mov	r0, #4
 6649 392c 08141FE5 		ldr	r1, .L658+100
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6650              		.loc 1 1185 0
 6651 3930 5DE5CAE5 		strb	lr, [r10, #1373]
1186:../uvc.c      **** 			  		 break;
 6652              		.loc 1 1186 0
 6653 3934 FEFFFFEB 		bl	CyU3PDebugPrint
 6654              	.LVL741:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6655              		.loc 1 978 0
 6656 3938 FF20A0E3 		mov	r2, #255
 6657 393c 60FEFFEA 		b	.L412
 6658              	.LVL742:
 6659              	.L639:
 6660              	.LBE177:
 6661              	.LBE243:
 6662              	.LBB244:
 6663              	.LBB148:
 984:../uvc.c      **** 		 {
 6664              		.loc 1 984 0
 6665 3940 810057E3 		cmp	r7, #129
 6666 3944 2901000A 		beq	.L348
 6667 3948 D902008A 		bhi	.L349
 6668 394c 010057E3 		cmp	r7, #1
 6669 3950 CB01001A 		bne	.L345
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6670              		.loc 1 1055 0
 6671 3954 08141FE5 		ldr	r1, .L658+140
 6672 3958 48208DE2 		add	r2, sp, #72
 6673 395c 2000A0E3 		mov	r0, #32
 6674 3960 24C08DE5 		str	ip, [sp, #36]
 6675 3964 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6676              	.LVL743:
1186:../uvc.c      **** 			  		 break;
 6677              		.loc 1 1186 0
 6678 3968 24C09DE5 		ldr	ip, [sp, #36]
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6679              		.loc 1 1185 0
 6680 396c 58E0DBE5 		ldrb	lr, [fp, #88]	@ zero_extendqisi2
1186:../uvc.c      **** 			  		 break;
 6681              		.loc 1 1186 0
 6682 3970 0400A0E3 		mov	r0, #4
 6683 3974 0020A0E1 		mov	r2, r0
 6684 3978 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6685 397c 58141FE5 		ldr	r1, .L658+100
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6686              		.loc 1 1185 0
 6687 3980 FDE4CAE5 		strb	lr, [r10, #1277]
1186:../uvc.c      **** 			  		 break;
 6688              		.loc 1 1186 0
 6689 3984 FEFFFFEB 		bl	CyU3PDebugPrint
 6690              	.LVL744:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6691              		.loc 1 978 0
 6692 3988 FF20A0E3 		mov	r2, #255
 6693 398c 4CFEFFEA 		b	.L412
 6694              	.LVL745:
 6695              	.L645:
 6696              	.LBE148:
 6697              	.LBE244:
 6698              	.LBB245:
 6699              	.LBB202:
 984:../uvc.c      **** 		 {
 6700              		.loc 1 984 0
 6701 3990 810057E3 		cmp	r7, #129
 6702 3994 3E01000A 		beq	.L370
 6703 3998 C802008A 		bhi	.L371
 6704 399c 010057E3 		cmp	r7, #1
 6705 39a0 32FDFF1A 		bne	.L367
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6706              		.loc 1 1055 0
 6707 39a4 58141FE5 		ldr	r1, .L658+140
 6708 39a8 48208DE2 		add	r2, sp, #72
 6709 39ac 2000A0E3 		mov	r0, #32
 6710 39b0 24C08DE5 		str	ip, [sp, #36]
 6711 39b4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6712              	.LVL746:
1186:../uvc.c      **** 			  		 break;
 6713              		.loc 1 1186 0
 6714 39b8 24C09DE5 		ldr	ip, [sp, #36]
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6715              		.loc 1 1185 0
 6716 39bc 58E0DBE5 		ldrb	lr, [fp, #88]	@ zero_extendqisi2
1186:../uvc.c      **** 			  		 break;
 6717              		.loc 1 1186 0
 6718 39c0 0620A0E3 		mov	r2, #6
 6719 39c4 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6720 39c8 0400A0E3 		mov	r0, #4
 6721 39cc A8141FE5 		ldr	r1, .L658+100
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6722              		.loc 1 1185 0
 6723 39d0 2DE5CAE5 		strb	lr, [r10, #1325]
1186:../uvc.c      **** 			  		 break;
 6724              		.loc 1 1186 0
 6725 39d4 FEFFFFEB 		bl	CyU3PDebugPrint
 6726              	.LVL747:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6727              		.loc 1 978 0
 6728 39d8 FF20A0E3 		mov	r2, #255
 6729 39dc 38FEFFEA 		b	.L412
 6730              	.LVL748:
 6731              	.L641:
 6732              	.LBE202:
 6733              	.LBE245:
 6734              	.LBB246:
 6735              	.LBB169:
 984:../uvc.c      **** 		 {
 6736              		.loc 1 984 0
 6737 39e0 810057E3 		cmp	r7, #129
 6738 39e4 2E01000A 		beq	.L359
 6739 39e8 BB02008A 		bhi	.L360
 6740 39ec 010057E3 		cmp	r7, #1
 6741 39f0 CE01001A 		bne	.L356
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6742              		.loc 1 1055 0
 6743 39f4 A8141FE5 		ldr	r1, .L658+140
 6744 39f8 48208DE2 		add	r2, sp, #72
 6745 39fc 2000A0E3 		mov	r0, #32
 6746 3a00 24C08DE5 		str	ip, [sp, #36]
 6747 3a04 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6748              	.LVL749:
1186:../uvc.c      **** 			  		 break;
 6749              		.loc 1 1186 0
 6750 3a08 24C09DE5 		ldr	ip, [sp, #36]
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6751              		.loc 1 1185 0
 6752 3a0c 58E0DBE5 		ldrb	lr, [fp, #88]	@ zero_extendqisi2
1186:../uvc.c      **** 			  		 break;
 6753              		.loc 1 1186 0
 6754 3a10 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6755              		.loc 1 1185 0
 6756 3a14 CCC41FE5 		ldr	ip, .L658+136
1186:../uvc.c      **** 			  		 break;
 6757              		.loc 1 1186 0
 6758 3a18 0520A0E3 		mov	r2, #5
 6759 3a1c 0400A0E3 		mov	r0, #4
 6760 3a20 FC141FE5 		ldr	r1, .L658+100
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6761              		.loc 1 1185 0
 6762 3a24 15E5CCE5 		strb	lr, [ip, #1301]
1186:../uvc.c      **** 			  		 break;
 6763              		.loc 1 1186 0
 6764 3a28 FEFFFFEB 		bl	CyU3PDebugPrint
 6765              	.LVL750:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6766              		.loc 1 978 0
 6767 3a2c FF20A0E3 		mov	r2, #255
 6768 3a30 23FEFFEA 		b	.L412
 6769              	.LVL751:
 6770              	.L649:
 6771              	.LBE169:
 6772              	.LBE246:
 6773              	.LBB247:
 6774              	.LBB159:
 984:../uvc.c      **** 		 {
 6775              		.loc 1 984 0
 6776 3a34 810057E3 		cmp	r7, #129
 6777 3a38 2B01000A 		beq	.L405
 6778 3a3c AA02008A 		bhi	.L406
 6779 3a40 010057E3 		cmp	r7, #1
 6780 3a44 9DFDFF1A 		bne	.L402
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6781              		.loc 1 1055 0
 6782 3a48 FC141FE5 		ldr	r1, .L658+140
 6783 3a4c 48208DE2 		add	r2, sp, #72
 6784 3a50 2000A0E3 		mov	r0, #32
 6785 3a54 24C08DE5 		str	ip, [sp, #36]
 6786 3a58 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6787              	.LVL752:
1186:../uvc.c      **** 			  		 break;
 6788              		.loc 1 1186 0
 6789 3a5c 24C09DE5 		ldr	ip, [sp, #36]
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6790              		.loc 1 1185 0
 6791 3a60 58E0DBE5 		ldrb	lr, [fp, #88]	@ zero_extendqisi2
1186:../uvc.c      **** 			  		 break;
 6792              		.loc 1 1186 0
 6793 3a64 0920A0E3 		mov	r2, #9
 6794 3a68 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6795 3a6c 0400A0E3 		mov	r0, #4
 6796 3a70 4C151FE5 		ldr	r1, .L658+100
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6797              		.loc 1 1185 0
 6798 3a74 75E5CAE5 		strb	lr, [r10, #1397]
1186:../uvc.c      **** 			  		 break;
 6799              		.loc 1 1186 0
 6800 3a78 FEFFFFEB 		bl	CyU3PDebugPrint
 6801              	.LVL753:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6802              		.loc 1 978 0
 6803 3a7c FF20A0E3 		mov	r2, #255
 6804 3a80 0FFEFFEA 		b	.L412
 6805              	.LVL754:
 6806              	.L643:
 6807              	.LBE159:
 6808              	.LBE247:
 6809              	.LBB248:
 6810              	.LBB185:
 984:../uvc.c      **** 		 {
 6811              		.loc 1 984 0
 6812 3a84 810057E3 		cmp	r7, #129
 6813 3a88 1B01000A 		beq	.L311
 6814 3a8c 7E02008A 		bhi	.L312
 6815 3a90 010057E3 		cmp	r7, #1
 6816 3a94 C8FCFF1A 		bne	.L308
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6817              		.loc 1 1055 0
 6818 3a98 4C151FE5 		ldr	r1, .L658+140
 6819 3a9c 48208DE2 		add	r2, sp, #72
 6820 3aa0 2000A0E3 		mov	r0, #32
 6821 3aa4 24C08DE5 		str	ip, [sp, #36]
 6822 3aa8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6823              	.LVL755:
1186:../uvc.c      **** 			  		 break;
 6824              		.loc 1 1186 0
 6825 3aac 24C09DE5 		ldr	ip, [sp, #36]
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6826              		.loc 1 1185 0
 6827 3ab0 58E0DBE5 		ldrb	lr, [fp, #88]	@ zero_extendqisi2
1186:../uvc.c      **** 			  		 break;
 6828              		.loc 1 1186 0
 6829 3ab4 0020A0E3 		mov	r2, #0
 6830 3ab8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6831 3abc 0400A0E3 		mov	r0, #4
 6832 3ac0 9C151FE5 		ldr	r1, .L658+100
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6833              		.loc 1 1185 0
 6834 3ac4 9DE4CAE5 		strb	lr, [r10, #1181]
1186:../uvc.c      **** 			  		 break;
 6835              		.loc 1 1186 0
 6836 3ac8 FEFFFFEB 		bl	CyU3PDebugPrint
 6837              	.LVL756:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6838              		.loc 1 978 0
 6839 3acc FF20A0E3 		mov	r2, #255
 6840 3ad0 FBFDFFEA 		b	.L412
 6841              	.LVL757:
 6842              	.L644:
 6843              	.LBE185:
 6844              	.LBE248:
 6845              	.LBB249:
 6846              	.LBB193:
 984:../uvc.c      **** 		 {
 6847              		.loc 1 984 0
 6848 3ad4 810057E3 		cmp	r7, #129
 6849 3ad8 C800000A 		beq	.L322
 6850 3adc 6E02008A 		bhi	.L323
 6851 3ae0 010057E3 		cmp	r7, #1
 6852 3ae4 8401001A 		bne	.L319
1055:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6853              		.loc 1 1055 0
 6854 3ae8 9C151FE5 		ldr	r1, .L658+140
 6855 3aec 48208DE2 		add	r2, sp, #72
 6856 3af0 2000A0E3 		mov	r0, #32
 6857 3af4 24C08DE5 		str	ip, [sp, #36]
 6858 3af8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6859              	.LVL758:
1186:../uvc.c      **** 			  		 break;
 6860              		.loc 1 1186 0
 6861 3afc 24C09DE5 		ldr	ip, [sp, #36]
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6862              		.loc 1 1185 0
 6863 3b00 58E0DBE5 		ldrb	lr, [fp, #88]	@ zero_extendqisi2
1186:../uvc.c      **** 			  		 break;
 6864              		.loc 1 1186 0
 6865 3b04 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6866              		.loc 1 1185 0
 6867 3b08 C0C51FE5 		ldr	ip, .L658+136
1186:../uvc.c      **** 			  		 break;
 6868              		.loc 1 1186 0
 6869 3b0c 0220A0E3 		mov	r2, #2
 6870 3b10 0400A0E3 		mov	r0, #4
 6871 3b14 F0151FE5 		ldr	r1, .L658+100
1185:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6872              		.loc 1 1185 0
 6873 3b18 CDE4CCE5 		strb	lr, [ip, #1229]
1186:../uvc.c      **** 			  		 break;
 6874              		.loc 1 1186 0
 6875 3b1c FEFFFFEB 		bl	CyU3PDebugPrint
 6876              	.LVL759:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6877              		.loc 1 978 0
 6878 3b20 FF20A0E3 		mov	r2, #255
 6879 3b24 E6FDFFEA 		b	.L412
 6880              	.LVL760:
 6881              	.L651:
 6882              	.LBE193:
 6883              	.LBE249:
 6884              	.LBE314:
 6885              	.LBE436:
 6886              	.LBB437:
 6887              	.LBB412:
 6888              	.LBB384:
 6889              	.LBB366:
 426:../uvc.c      **** 		 {
 6890              		.loc 1 426 0
 6891 3b28 810057E3 		cmp	r7, #129
 6892 3b2c B002000A 		beq	.L482
 6893 3b30 3801008A 		bhi	.L483
 6894 3b34 010057E3 		cmp	r7, #1
 6895 3b38 BB02001A 		bne	.L479
 663:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6896              		.loc 1 663 0
 6897 3b3c 48208DE2 		add	r2, sp, #72
 6898 3b40 2000A0E3 		mov	r0, #32
 6899 3b44 F8151FE5 		ldr	r1, .L658+140
 6900 3b48 28308DE5 		str	r3, [sp, #40]
 6901 3b4c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6902              	.LVL761:
 665:../uvc.c      **** 			   {
 6903              		.loc 1 665 0
 6904 3b50 002050E2 		subs	r2, r0, #0
 6905 3b54 2203001A 		bne	.L490
 810:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6906              		.loc 1 810 0
 6907 3b58 30E61FE5 		ldr	lr, .L658+104
 667:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6908              		.loc 1 667 0
 6909 3b5c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 6910              	.LVL762:
 810:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6911              		.loc 1 810 0
 6912 3b60 1C009EE5 		ldr	r0, [lr, #28]
 6913              	.LVL763:
 670:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6914              		.loc 1 670 0
 6915 3b64 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 810:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6916              		.loc 1 810 0
 6917 3b68 0010E0E3 		mvn	r1, #0
 670:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6918              		.loc 1 670 0
 6919 3b6c 30E08DE5 		str	lr, [sp, #48]
 6920              	.LVL764:
 810:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6921              		.loc 1 810 0
 6922 3b70 2C208DE5 		str	r2, [sp, #44]
 6923 3b74 24C08DE5 		str	ip, [sp, #36]
 6924 3b78 FEFFFFEB 		bl	_txe_mutex_get
 6925              	.LVL765:
 811:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6926              		.loc 1 811 0
 6927 3b7c 24C09DE5 		ldr	ip, [sp, #36]
 6928 3b80 2C209DE5 		ldr	r2, [sp, #44]
 6929 3b84 28309DE5 		ldr	r3, [sp, #40]
 6930 3b88 00C08DE5 		str	ip, [sp]
 6931 3b8c 04208DE5 		str	r2, [sp, #4]
 6932 3b90 2510A0E3 		mov	r1, #37
 6933 3b94 0320A0E1 		mov	r2, r3
 6934 3b98 70061FE5 		ldr	r0, .L658+104
 6935 3b9c 0830A0E1 		mov	r3, r8
 6936 3ba0 FEFFFFEB 		bl	cmdSet
 6937              	.LVL766:
 812:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 6938              		.loc 1 812 0
 6939 3ba4 7C161FE5 		ldr	r1, .L658+104
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6940              		.loc 1 414 0
 6941 3ba8 FF80A0E3 		mov	r8, #255
 6942              	.LVL767:
 812:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 6943              		.loc 1 812 0
 6944 3bac 1C0091E5 		ldr	r0, [r1, #28]
 6945 3bb0 FEFFFFEB 		bl	_txe_mutex_put
 6946              	.LVL768:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 6947              		.loc 1 813 0
 6948 3bb4 24C09DE5 		ldr	ip, [sp, #36]
 6949 3bb8 30309DE5 		ldr	r3, [sp, #48]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6950              		.loc 1 414 0
 6951 3bbc 0820A0E1 		mov	r2, r8
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 6952              		.loc 1 813 0
 6953 3bc0 85C0CAE5 		strb	ip, [r10, #133]
 814:../uvc.c      **** 							 break;
 6954              		.loc 1 814 0
 6955 3bc4 8870CAE5 		strb	r7, [r10, #136]
 6956              	.LVL769:
 6957              	.L489:
 958:../uvc.c      **** }
 6958              		.loc 1 958 0
 6959 3bc8 00308DE5 		str	r3, [sp]
 6960 3bcc 04018DE9 		stmib	sp, {r2, r8}
 6961 3bd0 A4161FE5 		ldr	r1, .L658+108
 6962 3bd4 0C30A0E1 		mov	r3, ip
 6963 3bd8 0720A0E1 		mov	r2, r7
 6964              	.LVL770:
 6965 3bdc 0400A0E3 		mov	r0, #4
 6966 3be0 FEFFFFEB 		bl	CyU3PDebugPrint
 6967              	.LVL771:
 6968 3be4 50309DE5 		ldr	r3, [sp, #80]
 6969 3be8 6FFAFFEA 		b	.L259
 6970              	.LVL772:
 6971              	.L652:
 6972              	.LBE366:
 6973              	.LBE384:
 6974              	.LBB385:
 6975              	.LBB356:
 426:../uvc.c      **** 		 {
 6976              		.loc 1 426 0
 6977 3bec 810058E3 		cmp	r8, #129
 6978 3bf0 5102000A 		beq	.L469
 6979 3bf4 0301008A 		bhi	.L470
 6980 3bf8 010058E3 		cmp	r8, #1
 6981 3bfc 5D02001A 		bne	.L466
 663:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6982              		.loc 1 663 0
 6983 3c00 48208DE2 		add	r2, sp, #72
 6984 3c04 2000A0E3 		mov	r0, #32
 6985 3c08 BC161FE5 		ldr	r1, .L658+140
 6986 3c0c 28308DE5 		str	r3, [sp, #40]
 6987 3c10 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6988              	.LVL773:
 665:../uvc.c      **** 			   {
 6989              		.loc 1 665 0
 6990 3c14 002050E2 		subs	r2, r0, #0
 6991 3c18 F502001A 		bne	.L478
 761:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 6992              		.loc 1 761 0
 6993 3c1c F4E61FE5 		ldr	lr, .L658+104
 667:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6994              		.loc 1 667 0
 6995 3c20 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 6996              	.LVL774:
 761:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 6997              		.loc 1 761 0
 6998 3c24 1C009EE5 		ldr	r0, [lr, #28]
 6999              	.LVL775:
 7000 3c28 0010E0E3 		mvn	r1, #0
 670:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7001              		.loc 1 670 0
 7002 3c2c 5A70D4E5 		ldrb	r7, [r4, #90]	@ zero_extendqisi2
 7003              	.LVL776:
 761:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7004              		.loc 1 761 0
 7005 3c30 2C208DE5 		str	r2, [sp, #44]
 7006 3c34 24C08DE5 		str	ip, [sp, #36]
 7007 3c38 FEFFFFEB 		bl	_txe_mutex_get
 7008              	.LVL777:
 762:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 7009              		.loc 1 762 0
 7010 3c3c 24C09DE5 		ldr	ip, [sp, #36]
 7011 3c40 2C209DE5 		ldr	r2, [sp, #44]
 7012 3c44 01107CE2 		rsbs	r1, ip, #1
 7013 3c48 0010A033 		movcc	r1, #0
 7014 3c4c 28309DE5 		ldr	r3, [sp, #40]
 7015 3c50 04208DE5 		str	r2, [sp, #4]
 7016 3c54 00108DE5 		str	r1, [sp]
 7017 3c58 30209DE5 		ldr	r2, [sp, #48]
 7018 3c5c 1E10A0E3 		mov	r1, #30
 7019 3c60 38071FE5 		ldr	r0, .L658+104
 7020 3c64 FEFFFFEB 		bl	cmdSet
 7021              	.LVL778:
 763:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 7022              		.loc 1 763 0
 7023 3c68 40171FE5 		ldr	r1, .L658+104
 7024 3c6c 1C0091E5 		ldr	r0, [r1, #28]
 7025 3c70 FEFFFFEB 		bl	_txe_mutex_put
 7026              	.LVL779:
 764:../uvc.c      **** 							 break;
 7027              		.loc 1 764 0
 7028 3c74 2C271FE5 		ldr	r2, .L658+136
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7029              		.loc 1 414 0
 7030 3c78 FF30A0E3 		mov	r3, #255
 764:../uvc.c      **** 							 break;
 7031              		.loc 1 764 0
 7032 3c7c 6084C2E5 		strb	r8, [r2, #1120]
 7033 3c80 24C09DE5 		ldr	ip, [sp, #36]
 7034              	.LVL780:
 7035              	.L476:
 958:../uvc.c      **** }
 7036              		.loc 1 958 0
 7037 3c84 FF10A0E3 		mov	r1, #255
 7038 3c88 00708DE5 		str	r7, [sp]
 7039 3c8c 04308DE5 		str	r3, [sp, #4]
 7040 3c90 0820A0E1 		mov	r2, r8
 7041 3c94 F1FBFFEA 		b	.L613
 7042              	.LVL781:
 7043              	.L653:
 7044              	.LBE356:
 7045              	.LBE385:
 7046              	.LBB386:
 7047              	.LBB377:
 426:../uvc.c      **** 		 {
 7048              		.loc 1 426 0
 7049 3c98 810057E3 		cmp	r7, #129
 7050 3c9c 3D02000A 		beq	.L456
 7051 3ca0 BC00008A 		bhi	.L457
 7052 3ca4 010057E3 		cmp	r7, #1
 7053 3ca8 4902001A 		bne	.L453
 663:../uvc.c      **** 				  glEp0Buffer, &readCount);
 7054              		.loc 1 663 0
 7055 3cac 48208DE2 		add	r2, sp, #72
 7056 3cb0 2000A0E3 		mov	r0, #32
 7057 3cb4 68171FE5 		ldr	r1, .L658+140
 7058 3cb8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 7059              	.LVL782:
 665:../uvc.c      **** 			   {
 7060              		.loc 1 665 0
 7061 3cbc 002050E2 		subs	r2, r0, #0
 7062 3cc0 A702001A 		bne	.L465
 667:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 7063              		.loc 1 667 0
 7064 3cc4 5830D4E5 		ldrb	r3, [r4, #88]	@ zero_extendqisi2
 7065              	.LVL783:
 670:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7066              		.loc 1 670 0
 7067 3cc8 5A10D4E5 		ldrb	r1, [r4, #90]	@ zero_extendqisi2
 7068              	.LVL784:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7069              		.loc 1 414 0
 7070 3ccc FF80A0E3 		mov	r8, #255
 7071              	.LVL785:
 7072              	.L463:
 958:../uvc.c      **** }
 7073              		.loc 1 958 0
 7074 3cd0 FF00A0E3 		mov	r0, #255
 7075 3cd4 02018DE8 		stmia	sp, {r1, r8}
 7076 3cd8 AC171FE5 		ldr	r1, .L658+108
 7077              	.LVL786:
 7078 3cdc 08008DE5 		str	r0, [sp, #8]
 7079 3ce0 0720A0E1 		mov	r2, r7
 7080 3ce4 0400A0E3 		mov	r0, #4
 7081 3ce8 FEFFFFEB 		bl	CyU3PDebugPrint
 7082              	.LVL787:
 7083 3cec 50309DE5 		ldr	r3, [sp, #80]
 7084 3cf0 2DFAFFEA 		b	.L259
 7085              	.LVL788:
 7086              	.L541:
 7087              	.LBE377:
 7088              	.LBE386:
 7089              	.LBE412:
 7090              	.LBE437:
 7091              	.LBB438:
 7092              	.LBB140:
3234:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 7093              		.loc 1 3234 0
 7094 3cf4 B824DDE1 		ldrh	r2, [sp, #72]
 7095 3cf8 C8171FE5 		ldr	r1, .L658+112
 7096 3cfc C030DBE5 		ldrb	r3, [fp, #192]	@ zero_extendqisi2
 7097 3d00 0400A0E3 		mov	r0, #4
 7098              	.LVL789:
 7099 3d04 FEFFFFEB 		bl	CyU3PDebugPrint
 7100              	.LVL790:
3235:../uvc.c      ****                         }
 7101              		.loc 1 3235 0
 7102 3d08 0000A0E3 		mov	r0, #0
 7103 3d0c 0020A0E1 		mov	r2, r0
 7104 3d10 0110A0E3 		mov	r1, #1
 7105 3d14 FEFFFFEB 		bl	CyU3PUsbStall
 7106              	.LVL791:
 7107 3d18 2CFAFFEA 		b	.L506
 7108              	.LVL792:
 7109              	.L627:
 7110 3d1c 0070A0E1 		mov	r7, r0
 7111              	.LBE140:
 7112              	.LBE438:
3396:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 7113              		.loc 1 3396 0
 7114 3d20 EC171FE5 		ldr	r1, .L658+116
 7115 3d24 0800A0E1 		mov	r0, r8
 7116              	.LVL793:
 7117 3d28 0720A0E1 		mov	r2, r7
 7118 3d2c FEFFFFEB 		bl	CyU3PDebugPrint
 7119              	.LVL794:
3397:../uvc.c      **** 					}
 7120              		.loc 1 3397 0
 7121 3d30 0700A0E1 		mov	r0, r7
 7122 3d34 FEFFFFEB 		bl	CyFxAppErrorHandler
 7123              	.LVL795:
 7124              	.L287:
 7125              	.LBB439:
 7126              	.LBB345:
 7127              	.LBB334:
 7128              	.LBB327:
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 7129              		.loc 1 625 0
 7130 3d38 D712DAE5 		ldrb	r1, [r10, #727]	@ zero_extendqisi2
 626:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 7131              		.loc 1 626 0
 7132 3d3c D822DAE5 		ldrb	r2, [r10, #728]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 7133              		.loc 1 627 0
 7134 3d40 0030A0E3 		mov	r3, #0
 630:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7135              		.loc 1 630 0
 7136 3d44 0800A0E1 		mov	r0, r8
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 7137              		.loc 1 625 0
 7138 3d48 5810CBE5 		strb	r1, [fp, #88]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7139              		.loc 1 414 0
 7140 3d4c FF80A0E3 		mov	r8, #255
 630:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7141              		.loc 1 630 0
 7142 3d50 04181FE5 		ldr	r1, .L658+140
 627:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 7143              		.loc 1 627 0
 7144 3d54 5A30CBE5 		strb	r3, [fp, #90]
 628:../uvc.c      **** 		 	 }
 7145              		.loc 1 628 0
 7146 3d58 5B30CBE5 		strb	r3, [fp, #91]
 626:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 7147              		.loc 1 626 0
 7148 3d5c 5920CBE5 		strb	r2, [fp, #89]
 630:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7149              		.loc 1 630 0
 7150 3d60 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7151              	.LVL796:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7152              		.loc 1 414 0
 7153 3d64 08C0A0E1 		mov	ip, r8
 631:../uvc.c      **** 			  break;
 7154              		.loc 1 631 0
 7155 3d68 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 7156              	.LVL797:
 7157 3d6c B7FBFFEA 		b	.L290
 7158              	.LVL798:
 7159              	.L283:
 558:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 7160              		.loc 1 558 0
 7161 3d70 8620DBE5 		ldrb	r2, [fp, #134]	@ zero_extendqisi2
 7162 3d74 000052E3 		cmp	r2, #0
 7163 3d78 7202000A 		beq	.L655
 7164              	.LVL799:
 7165              	.L291:
 568:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7166              		.loc 1 568 0
 7167 3d7c DD32DAE5 		ldrb	r3, [r10, #733]	@ zero_extendqisi2
 574:../uvc.c      **** 
 7168              		.loc 1 574 0
 7169 3d80 0800A0E1 		mov	r0, r8
 569:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7170              		.loc 1 569 0
 7171 3d84 0020A0E3 		mov	r2, #0
 574:../uvc.c      **** 
 7172              		.loc 1 574 0
 7173 3d88 3C181FE5 		ldr	r1, .L658+140
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7174              		.loc 1 414 0
 7175 3d8c FF80A0E3 		mov	r8, #255
 7176              	.LVL800:
 568:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7177              		.loc 1 568 0
 7178 3d90 5830CBE5 		strb	r3, [fp, #88]
 569:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7179              		.loc 1 569 0
 7180 3d94 5920CBE5 		strb	r2, [fp, #89]
 7181              	.LVL801:
 574:../uvc.c      **** 
 7182              		.loc 1 574 0
 7183 3d98 28308DE5 		str	r3, [sp, #40]
 7184 3d9c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7185              	.LVL802:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7186              		.loc 1 414 0
 7187 3da0 08C0A0E1 		mov	ip, r8
 7188 3da4 28309DE5 		ldr	r3, [sp, #40]
 7189 3da8 A8FBFFEA 		b	.L290
 7190              	.LVL803:
 7191              	.L385:
 7192              	.LBE327:
 7193              	.LBE334:
 7194              	.LBE345:
 7195              	.LBE439:
 7196              	.LBB440:
 7197              	.LBB315:
 7198              	.LBB250:
 7199              	.LBB230:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7200              		.loc 1 1031 0
 7201 3dac 64C81FE5 		ldr	ip, .L658+136
 7202 3db0 3F15DCE5 		ldrb	r1, [ip, #1343]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7203              		.loc 1 1032 0
 7204 3db4 4025DCE5 		ldrb	r2, [ip, #1344]	@ zero_extendqisi2
 7205 3db8 9FFCFFEA 		b	.L600
 7206              	.LVL804:
 7207              	.L394:
 7208              	.LBE230:
 7209              	.LBE250:
 7210              	.LBB251:
 7211              	.LBB178:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7212              		.loc 1 998 0
 7213 3dbc 5D25DAE5 		ldrb	r2, [r10, #1373]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7214              		.loc 1 999 0
 7215 3dc0 5E15DAE5 		ldrb	r1, [r10, #1374]	@ zero_extendqisi2
 7216              	.LVL805:
 7217              	.L618:
 7218              	.LBE178:
 7219              	.LBE251:
 7220              	.LBB252:
 7221              	.LBB160:
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7222              		.loc 1 1000 0
 7223 3dc4 0030A0E3 		mov	r3, #0
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7224              		.loc 1 999 0
 7225 3dc8 5910CBE5 		strb	r1, [fp, #89]
1006:../uvc.c      **** 
 7226              		.loc 1 1006 0
 7227 3dcc 0800A0E1 		mov	r0, r8
 7228 3dd0 84181FE5 		ldr	r1, .L658+140
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7229              		.loc 1 998 0
 7230 3dd4 5820CBE5 		strb	r2, [fp, #88]
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7231              		.loc 1 1000 0
 7232 3dd8 5A30CBE5 		strb	r3, [fp, #90]
1001:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7233              		.loc 1 1001 0
 7234 3ddc 5B30CBE5 		strb	r3, [fp, #91]
 7235              	.LVL806:
1006:../uvc.c      **** 
 7236              		.loc 1 1006 0
 7237 3de0 2C208DE5 		str	r2, [sp, #44]
 7238 3de4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7239              	.LVL807:
 7240 3de8 2C209DE5 		ldr	r2, [sp, #44]
 7241 3dec 34FDFFEA 		b	.L412
 7242              	.LVL808:
 7243              	.L348:
 7244              	.LBE160:
 7245              	.LBE252:
 7246              	.LBB253:
 7247              	.LBB149:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7248              		.loc 1 998 0
 7249 3df0 A8E81FE5 		ldr	lr, .L658+136
 7250 3df4 FD24DEE5 		ldrb	r2, [lr, #1277]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7251              		.loc 1 999 0
 7252 3df8 FE14DEE5 		ldrb	r1, [lr, #1278]	@ zero_extendqisi2
 7253 3dfc F0FFFFEA 		b	.L618
 7254              	.LVL809:
 7255              	.L322:
 7256              	.LBE149:
 7257              	.LBE253:
 7258              	.LBB254:
 7259              	.LBB194:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7260              		.loc 1 998 0
 7261 3e00 B8381FE5 		ldr	r3, .L658+136
 7262 3e04 CD24D3E5 		ldrb	r2, [r3, #1229]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7263              		.loc 1 999 0
 7264 3e08 CE14D3E5 		ldrb	r1, [r3, #1230]	@ zero_extendqisi2
 7265 3e0c ECFFFFEA 		b	.L618
 7266              	.LVL810:
 7267              	.L381:
 7268              	.LBE194:
 7269              	.LBE254:
 7270              	.LBB255:
 7271              	.LBB231:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7272              		.loc 1 998 0
 7273 3e10 C8181FE5 		ldr	r1, .L658+136
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7274              		.loc 1 1000 0
 7275 3e14 0030A0E3 		mov	r3, #0
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7276              		.loc 1 998 0
 7277 3e18 45C5D1E5 		ldrb	ip, [r1, #1349]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7278              		.loc 1 999 0
 7279 3e1c 4625D1E5 		ldrb	r2, [r1, #1350]	@ zero_extendqisi2
1006:../uvc.c      **** 
 7280              		.loc 1 1006 0
 7281 3e20 0800A0E1 		mov	r0, r8
 7282 3e24 D8181FE5 		ldr	r1, .L658+140
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7283              		.loc 1 998 0
 7284 3e28 58C0CBE5 		strb	ip, [fp, #88]
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7285              		.loc 1 999 0
 7286 3e2c 5920CBE5 		strb	r2, [fp, #89]
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7287              		.loc 1 1000 0
 7288 3e30 5A30CBE5 		strb	r3, [fp, #90]
1001:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7289              		.loc 1 1001 0
 7290 3e34 5B30CBE5 		strb	r3, [fp, #91]
 7291              	.LVL811:
1006:../uvc.c      **** 
 7292              		.loc 1 1006 0
 7293 3e38 24C08DE5 		str	ip, [sp, #36]
 7294 3e3c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7295              	.LVL812:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7296              		.loc 1 978 0
 7297 3e40 FF20A0E3 		mov	r2, #255
 7298 3e44 0230A0E1 		mov	r3, r2
 7299 3e48 24C09DE5 		ldr	ip, [sp, #36]
 7300 3e4c 85FCFFEA 		b	.L388
 7301              	.LVL813:
 7302              	.L416:
 7303              	.LBE231:
 7304              	.LBE255:
 7305              	.LBB256:
 7306              	.LBB220:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7307              		.loc 1 998 0
 7308 3e50 08E91FE5 		ldr	lr, .L658+136
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7309              		.loc 1 1000 0
 7310 3e54 0020A0E3 		mov	r2, #0
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7311              		.loc 1 999 0
 7312 3e58 8E15DEE5 		ldrb	r1, [lr, #1422]	@ zero_extendqisi2
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7313              		.loc 1 998 0
 7314 3e5c 8D35DEE5 		ldrb	r3, [lr, #1421]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7315              		.loc 1 999 0
 7316 3e60 5910CBE5 		strb	r1, [fp, #89]
1006:../uvc.c      **** 
 7317              		.loc 1 1006 0
 7318 3e64 30009DE5 		ldr	r0, [sp, #48]
 7319 3e68 1C191FE5 		ldr	r1, .L658+140
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7320              		.loc 1 978 0
 7321 3e6c FF80A0E3 		mov	r8, #255
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7322              		.loc 1 998 0
 7323 3e70 5830CBE5 		strb	r3, [fp, #88]
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7324              		.loc 1 1000 0
 7325 3e74 5A20CBE5 		strb	r2, [fp, #90]
1001:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7326              		.loc 1 1001 0
 7327 3e78 5B20CBE5 		strb	r2, [fp, #91]
 7328              	.LVL814:
1006:../uvc.c      **** 
 7329              		.loc 1 1006 0
 7330 3e7c 28308DE5 		str	r3, [sp, #40]
 7331 3e80 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7332              	.LVL815:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7333              		.loc 1 978 0
 7334 3e84 08C0A0E1 		mov	ip, r8
 7335 3e88 28309DE5 		ldr	r3, [sp, #40]
 7336 3e8c 30209DE5 		ldr	r2, [sp, #48]
 7337 3e90 4EFCFFEA 		b	.L423
 7338              	.LVL816:
 7339              	.L370:
 7340              	.LBE220:
 7341              	.LBE256:
 7342              	.LBB257:
 7343              	.LBB203:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7344              		.loc 1 998 0
 7345 3e94 4CE91FE5 		ldr	lr, .L658+136
 7346 3e98 2D25DEE5 		ldrb	r2, [lr, #1325]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7347              		.loc 1 999 0
 7348 3e9c 2E15DEE5 		ldrb	r1, [lr, #1326]	@ zero_extendqisi2
 7349 3ea0 C7FFFFEA 		b	.L618
 7350              	.LVL817:
 7351              	.L359:
 7352              	.LBE203:
 7353              	.LBE257:
 7354              	.LBB258:
 7355              	.LBB170:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7356              		.loc 1 998 0
 7357 3ea4 5C391FE5 		ldr	r3, .L658+136
 7358 3ea8 1525D3E5 		ldrb	r2, [r3, #1301]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7359              		.loc 1 999 0
 7360 3eac 1615D3E5 		ldrb	r1, [r3, #1302]	@ zero_extendqisi2
 7361 3eb0 C3FFFFEA 		b	.L618
 7362              	.LVL818:
 7363              	.L409:
 7364              	.LBE170:
 7365              	.LBE258:
 7366              	.LBB259:
 7367              	.LBB161:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7368              		.loc 1 1031 0
 7369 3eb4 6CC91FE5 		ldr	ip, .L658+136
 7370 3eb8 6F15DCE5 		ldrb	r1, [ip, #1391]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7371              		.loc 1 1032 0
 7372 3ebc 7025DCE5 		ldrb	r2, [ip, #1392]	@ zero_extendqisi2
 7373 3ec0 FDFAFFEA 		b	.L602
 7374              	.LVL819:
 7375              	.L326:
 7376              	.LBE161:
 7377              	.LBE259:
 7378              	.LBB260:
 7379              	.LBB195:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7380              		.loc 1 1031 0
 7381 3ec4 7C291FE5 		ldr	r2, .L658+136
 7382 3ec8 C714D2E5 		ldrb	r1, [r2, #1223]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7383              		.loc 1 1032 0
 7384 3ecc C824D2E5 		ldrb	r2, [r2, #1224]	@ zero_extendqisi2
 7385 3ed0 F9FAFFEA 		b	.L602
 7386              	.LVL820:
 7387              	.L398:
 7388              	.LBE195:
 7389              	.LBE260:
 7390              	.LBB261:
 7391              	.LBB179:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7392              		.loc 1 1031 0
 7393 3ed4 5715DAE5 		ldrb	r1, [r10, #1367]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7394              		.loc 1 1032 0
 7395 3ed8 5825DAE5 		ldrb	r2, [r10, #1368]	@ zero_extendqisi2
 7396 3edc F6FAFFEA 		b	.L602
 7397              	.LVL821:
 7398              	.L352:
 7399              	.LBE179:
 7400              	.LBE261:
 7401              	.LBB262:
 7402              	.LBB150:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7403              		.loc 1 1031 0
 7404 3ee0 F714DAE5 		ldrb	r1, [r10, #1271]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7405              		.loc 1 1032 0
 7406 3ee4 F824DAE5 		ldrb	r2, [r10, #1272]	@ zero_extendqisi2
 7407 3ee8 F3FAFFEA 		b	.L602
 7408              	.LVL822:
 7409              	.L405:
 7410              	.LBE150:
 7411              	.LBE262:
 7412              	.LBB263:
 7413              	.LBB162:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7414              		.loc 1 998 0
 7415 3eec A4191FE5 		ldr	r1, .L658+136
 7416 3ef0 7525D1E5 		ldrb	r2, [r1, #1397]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7417              		.loc 1 999 0
 7418 3ef4 7615D1E5 		ldrb	r1, [r1, #1398]	@ zero_extendqisi2
 7419 3ef8 B1FFFFEA 		b	.L618
 7420              	.LVL823:
 7421              	.L311:
 7422              	.LBE162:
 7423              	.LBE263:
 7424              	.LBB264:
 7425              	.LBB186:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7426              		.loc 1 998 0
 7427 3efc B4391FE5 		ldr	r3, .L658+136
 7428 3f00 9D24D3E5 		ldrb	r2, [r3, #1181]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7429              		.loc 1 999 0
 7430 3f04 9E14D3E5 		ldrb	r1, [r3, #1182]	@ zero_extendqisi2
 7431 3f08 ADFFFFEA 		b	.L618
 7432              	.LVL824:
 7433              	.L374:
 7434              	.LBE186:
 7435              	.LBE264:
 7436              	.LBB265:
 7437              	.LBB204:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7438              		.loc 1 1031 0
 7439 3f0c C4C91FE5 		ldr	ip, .L658+136
 7440 3f10 2715DCE5 		ldrb	r1, [ip, #1319]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7441              		.loc 1 1032 0
 7442 3f14 2825DCE5 		ldrb	r2, [ip, #1320]	@ zero_extendqisi2
 7443 3f18 E7FAFFEA 		b	.L602
 7444              	.LVL825:
 7445              	.L420:
 7446              	.LBE204:
 7447              	.LBE265:
 7448              	.LBB266:
 7449              	.LBB221:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7450              		.loc 1 1031 0
 7451 3f1c 8705DAE5 		ldrb	r0, [r10, #1415]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7452              		.loc 1 1032 0
 7453 3f20 8815DAE5 		ldrb	r1, [r10, #1416]	@ zero_extendqisi2
 7454 3f24 1CFCFFEA 		b	.L604
 7455              	.LVL826:
 7456              	.L333:
 7457              	.LBE221:
 7458              	.LBE266:
 7459              	.LBB267:
 7460              	.LBB211:
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7461              		.loc 1 998 0
 7462 3f28 E0E91FE5 		ldr	lr, .L658+136
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7463              		.loc 1 1000 0
 7464 3f2c 0030A0E3 		mov	r3, #0
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7465              		.loc 1 998 0
 7466 3f30 E5C4DEE5 		ldrb	ip, [lr, #1253]	@ zero_extendqisi2
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7467              		.loc 1 999 0
 7468 3f34 E624DEE5 		ldrb	r2, [lr, #1254]	@ zero_extendqisi2
1006:../uvc.c      **** 
 7469              		.loc 1 1006 0
 7470 3f38 0700A0E1 		mov	r0, r7
 7471 3f3c F0191FE5 		ldr	r1, .L658+140
 998:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7472              		.loc 1 998 0
 7473 3f40 58C0CBE5 		strb	ip, [fp, #88]
 999:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7474              		.loc 1 999 0
 7475 3f44 5920CBE5 		strb	r2, [fp, #89]
1000:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7476              		.loc 1 1000 0
 7477 3f48 5A30CBE5 		strb	r3, [fp, #90]
1001:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7478              		.loc 1 1001 0
 7479 3f4c 5B30CBE5 		strb	r3, [fp, #91]
 7480              	.LVL827:
1006:../uvc.c      **** 
 7481              		.loc 1 1006 0
 7482 3f50 24C08DE5 		str	ip, [sp, #36]
 7483 3f54 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7484              	.LVL828:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7485              		.loc 1 978 0
 7486 3f58 FF20A0E3 		mov	r2, #255
 7487 3f5c 0230A0E1 		mov	r3, r2
 7488 3f60 24C09DE5 		ldr	ip, [sp, #36]
 7489 3f64 EBFBFFEA 		b	.L340
 7490              	.LVL829:
 7491              	.L337:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7492              		.loc 1 1031 0
 7493 3f68 20CA1FE5 		ldr	ip, .L658+136
 7494 3f6c DF14DCE5 		ldrb	r1, [ip, #1247]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7495              		.loc 1 1032 0
 7496 3f70 E024DCE5 		ldrb	r2, [ip, #1248]	@ zero_extendqisi2
 7497 3f74 DCFBFFEA 		b	.L596
 7498              	.LVL830:
 7499              	.L315:
 7500              	.LBE211:
 7501              	.LBE267:
 7502              	.LBB268:
 7503              	.LBB187:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7504              		.loc 1 1031 0
 7505 3f78 302A1FE5 		ldr	r2, .L658+136
 7506 3f7c 9714D2E5 		ldrb	r1, [r2, #1175]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7507              		.loc 1 1032 0
 7508 3f80 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 7509 3f84 CCFAFFEA 		b	.L602
 7510              	.LVL831:
 7511              	.L363:
 7512              	.LBE187:
 7513              	.LBE268:
 7514              	.LBB269:
 7515              	.LBB171:
1031:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7516              		.loc 1 1031 0
 7517 3f88 402A1FE5 		ldr	r2, .L658+136
 7518 3f8c 0F15D2E5 		ldrb	r1, [r2, #1295]	@ zero_extendqisi2
1032:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7519              		.loc 1 1032 0
 7520 3f90 1025D2E5 		ldrb	r2, [r2, #1296]	@ zero_extendqisi2
 7521 3f94 C8FAFFEA 		b	.L602
 7522              	.LVL832:
 7523              	.L457:
 7524              	.LBE171:
 7525              	.LBE269:
 7526              	.LBE315:
 7527              	.LBE440:
 7528              	.LBB441:
 7529              	.LBB413:
 7530              	.LBB387:
 7531              	.LBB378:
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7532              		.loc 1 593 0
 7533 3f98 2324DAE5 		ldrb	r2, [r10, #1059]	@ zero_extendqisi2
 594:../uvc.c      **** 			 }
 7534              		.loc 1 594 0
 7535 3f9c 2434DAE5 		ldrb	r3, [r10, #1060]	@ zero_extendqisi2
 7536 3fa0 38FDFFEA 		b	.L606
 7537              	.L461:
 638:../uvc.c      **** 		 	 }
 7538              		.loc 1 638 0
 7539 3fa4 2934DAE5 		ldrb	r3, [r10, #1065]	@ zero_extendqisi2
 640:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7540              		.loc 1 640 0
 7541 3fa8 5C1A1FE5 		ldr	r1, .L658+140
 7542 3fac 0100A0E3 		mov	r0, #1
 638:../uvc.c      **** 		 	 }
 7543              		.loc 1 638 0
 7544 3fb0 5830CBE5 		strb	r3, [fp, #88]
 640:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7545              		.loc 1 640 0
 7546 3fb4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7547              	.LVL833:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7548              		.loc 1 414 0
 7549 3fb8 FF10A0E3 		mov	r1, #255
 7550 3fbc 0130A0E1 		mov	r3, r1
 641:../uvc.c      **** 			  Len = 1;
 7551              		.loc 1 641 0
 7552 3fc0 5880DBE5 		ldrb	r8, [fp, #88]	@ zero_extendqisi2
 7553              	.LVL834:
 7554 3fc4 41FFFFEA 		b	.L463
 7555              	.LVL835:
 7556              	.L474:
 7557              	.LBE378:
 7558              	.LBE387:
 7559              	.LBB388:
 7560              	.LBB357:
 638:../uvc.c      **** 		 	 }
 7561              		.loc 1 638 0
 7562 3fc8 807A1FE5 		ldr	r7, .L658+136
 640:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7563              		.loc 1 640 0
 7564 3fcc 0100A0E3 		mov	r0, #1
 638:../uvc.c      **** 		 	 }
 7565              		.loc 1 638 0
 7566 3fd0 5934D7E5 		ldrb	r3, [r7, #1113]	@ zero_extendqisi2
 640:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7567              		.loc 1 640 0
 7568 3fd4 881A1FE5 		ldr	r1, .L658+140
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7569              		.loc 1 414 0
 7570 3fd8 FF70A0E3 		mov	r7, #255
 638:../uvc.c      **** 		 	 }
 7571              		.loc 1 638 0
 7572 3fdc 5830CBE5 		strb	r3, [fp, #88]
 640:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7573              		.loc 1 640 0
 7574 3fe0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7575              	.LVL836:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7576              		.loc 1 414 0
 7577 3fe4 07C0A0E1 		mov	ip, r7
 641:../uvc.c      **** 			  Len = 1;
 7578              		.loc 1 641 0
 7579 3fe8 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 7580              	.LVL837:
 7581 3fec 24FFFFEA 		b	.L476
 7582              	.LVL838:
 7583              	.L487:
 7584              	.LBE357:
 7585              	.LBE388:
 7586              	.LBB389:
 7587              	.LBB367:
 635:../uvc.c      **** 		 	 }
 7588              		.loc 1 635 0
 7589 3ff0 8120DAE5 		ldrb	r2, [r10, #129]	@ zero_extendqisi2
 640:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7590              		.loc 1 640 0
 7591 3ff4 0100A0E3 		mov	r0, #1
 7592 3ff8 AC1A1FE5 		ldr	r1, .L658+140
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7593              		.loc 1 414 0
 7594 3ffc FF80A0E3 		mov	r8, #255
 635:../uvc.c      **** 		 	 }
 7595              		.loc 1 635 0
 7596 4000 5820CBE5 		strb	r2, [fp, #88]
 7597 4004 E6FCFFEA 		b	.L612
 7598              	.LVL839:
 7599              	.L470:
 7600              	.LBE367:
 7601              	.LBE389:
 7602              	.LBB390:
 7603              	.LBB358:
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7604              		.loc 1 593 0
 7605 4008 C0EA1FE5 		ldr	lr, .L658+136
 7606 400c 5324DEE5 		ldrb	r2, [lr, #1107]	@ zero_extendqisi2
 594:../uvc.c      **** 			 }
 7607              		.loc 1 594 0
 7608 4010 5434DEE5 		ldrb	r3, [lr, #1108]	@ zero_extendqisi2
 7609 4014 03FDFFEA 		b	.L608
 7610              	.LVL840:
 7611              	.L483:
 7612              	.LBE358:
 7613              	.LBE390:
 7614              	.LBB391:
 7615              	.LBB368:
 582:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 7616              		.loc 1 582 0
 7617 4018 7BE0DAE5 		ldrb	lr, [r10, #123]	@ zero_extendqisi2
 583:../uvc.c      **** 		 	 }
 7618              		.loc 1 583 0
 7619 401c 7C20DAE5 		ldrb	r2, [r10, #124]	@ zero_extendqisi2
 7620 4020 DAFCFFEA 		b	.L611
 7621              	.LVL841:
 7622              	.L280:
 7623              	.LBE368:
 7624              	.LBE391:
 7625              	.LBE413:
 7626              	.LBE441:
 7627              	.LBB442:
 7628              	.LBB346:
 7629              	.LBB335:
 7630              	.LBB328:
 955:../uvc.c      **** 			  break;
 7631              		.loc 1 955 0
 7632 4024 0000A0E3 		mov	r0, #0
 7633 4028 0020A0E1 		mov	r2, r0
 7634 402c 0110A0E3 		mov	r1, #1
 7635 4030 FEFFFFEB 		bl	CyU3PUsbStall
 7636              	.LVL842:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7637              		.loc 1 414 0
 7638 4034 FF30A0E3 		mov	r3, #255
 7639 4038 0380A0E1 		mov	r8, r3
 7640              	.LVL843:
 7641 403c 03C0A0E1 		mov	ip, r3
 7642 4040 02FBFFEA 		b	.L290
 7643              	.LVL844:
 7644              	.L413:
 7645              	.LBE328:
 7646              	.LBE335:
 7647              	.LBE346:
 7648              	.LBE442:
 7649              	.LBB443:
 7650              	.LBB316:
 7651              	.LBB270:
 7652              	.LBB222:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7653              		.loc 1 1191 0
 7654 4044 0000A0E3 		mov	r0, #0
 7655 4048 0020A0E1 		mov	r2, r0
 7656 404c 0110A0E3 		mov	r1, #1
 7657 4050 24C08DE5 		str	ip, [sp, #36]
 7658 4054 FEFFFFEB 		bl	CyU3PUsbStall
 7659              	.LVL845:
1192:../uvc.c      **** 			  break;
 7660              		.loc 1 1192 0
 7661 4058 24C09DE5 		ldr	ip, [sp, #36]
 7662 405c 0A20A0E3 		mov	r2, #10
 7663 4060 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7664 4064 0400A0E3 		mov	r0, #4
 7665 4068 301B1FE5 		ldr	r1, .L658+120
 7666 406c FEFFFFEB 		bl	CyU3PDebugPrint
 7667              	.LVL846:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7668              		.loc 1 978 0
 7669 4070 FF30A0E3 		mov	r3, #255
 7670 4074 0380A0E1 		mov	r8, r3
 7671 4078 03C0A0E1 		mov	ip, r3
 7672 407c 30209DE5 		ldr	r2, [sp, #48]
 7673 4080 D2FBFFEA 		b	.L423
 7674              	.LVL847:
 7675              	.L345:
 7676              	.LBE222:
 7677              	.LBE270:
 7678              	.LBB271:
 7679              	.LBB151:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7680              		.loc 1 1191 0
 7681 4084 0000A0E3 		mov	r0, #0
 7682 4088 0020A0E1 		mov	r2, r0
 7683 408c 0110A0E3 		mov	r1, #1
 7684 4090 24C08DE5 		str	ip, [sp, #36]
 7685 4094 FEFFFFEB 		bl	CyU3PUsbStall
 7686              	.LVL848:
1192:../uvc.c      **** 			  break;
 7687              		.loc 1 1192 0
 7688 4098 24C09DE5 		ldr	ip, [sp, #36]
 7689 409c 0400A0E3 		mov	r0, #4
 7690 40a0 0020A0E1 		mov	r2, r0
 7691 40a4 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7692 40a8 701B1FE5 		ldr	r1, .L658+120
 7693 40ac FEFFFFEB 		bl	CyU3PDebugPrint
 7694              	.LVL849:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7695              		.loc 1 978 0
 7696 40b0 FF20A0E3 		mov	r2, #255
 7697              	.LVL850:
 7698 40b4 82FCFFEA 		b	.L412
 7699              	.LVL851:
 7700              	.L378:
 7701              	.LBE151:
 7702              	.LBE271:
 7703              	.LBB272:
 7704              	.LBB232:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7705              		.loc 1 1191 0
 7706 40b8 0000A0E3 		mov	r0, #0
 7707 40bc 0020A0E1 		mov	r2, r0
 7708 40c0 0110A0E3 		mov	r1, #1
 7709 40c4 24C08DE5 		str	ip, [sp, #36]
 7710 40c8 FEFFFFEB 		bl	CyU3PUsbStall
 7711              	.LVL852:
1192:../uvc.c      **** 			  break;
 7712              		.loc 1 1192 0
 7713 40cc 24C09DE5 		ldr	ip, [sp, #36]
 7714 40d0 0720A0E3 		mov	r2, #7
 7715 40d4 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7716 40d8 0400A0E3 		mov	r0, #4
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7717              		.loc 1 978 0
 7718 40dc FFC0A0E3 		mov	ip, #255
1192:../uvc.c      **** 			  break;
 7719              		.loc 1 1192 0
 7720 40e0 A81B1FE5 		ldr	r1, .L658+120
 7721 40e4 24C08DE5 		str	ip, [sp, #36]
 7722 40e8 FEFFFFEB 		bl	CyU3PDebugPrint
 7723              	.LVL853:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7724              		.loc 1 978 0
 7725 40ec 24C09DE5 		ldr	ip, [sp, #36]
 7726 40f0 0C20A0E1 		mov	r2, ip
 7727 40f4 0C30A0E1 		mov	r3, ip
 7728 40f8 DAFBFFEA 		b	.L388
 7729              	.LVL854:
 7730              	.L319:
 7731              	.LBE232:
 7732              	.LBE272:
 7733              	.LBB273:
 7734              	.LBB196:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7735              		.loc 1 1191 0
 7736 40fc 0000A0E3 		mov	r0, #0
 7737 4100 0020A0E1 		mov	r2, r0
 7738 4104 0110A0E3 		mov	r1, #1
 7739 4108 24C08DE5 		str	ip, [sp, #36]
 7740 410c FEFFFFEB 		bl	CyU3PUsbStall
 7741              	.LVL855:
1192:../uvc.c      **** 			  break;
 7742              		.loc 1 1192 0
 7743 4110 24C09DE5 		ldr	ip, [sp, #36]
 7744 4114 0220A0E3 		mov	r2, #2
 7745 4118 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7746 411c 0400A0E3 		mov	r0, #4
 7747 4120 E81B1FE5 		ldr	r1, .L658+120
 7748 4124 FEFFFFEB 		bl	CyU3PDebugPrint
 7749              	.LVL856:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7750              		.loc 1 978 0
 7751 4128 FF20A0E3 		mov	r2, #255
 7752              	.LVL857:
 7753 412c 64FCFFEA 		b	.L412
 7754              	.LVL858:
 7755              	.L356:
 7756              	.LBE196:
 7757              	.LBE273:
 7758              	.LBB274:
 7759              	.LBB172:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7760              		.loc 1 1191 0
 7761 4130 0000A0E3 		mov	r0, #0
 7762 4134 0020A0E1 		mov	r2, r0
 7763 4138 0110A0E3 		mov	r1, #1
 7764 413c 24C08DE5 		str	ip, [sp, #36]
 7765 4140 FEFFFFEB 		bl	CyU3PUsbStall
 7766              	.LVL859:
1192:../uvc.c      **** 			  break;
 7767              		.loc 1 1192 0
 7768 4144 24C09DE5 		ldr	ip, [sp, #36]
 7769 4148 0520A0E3 		mov	r2, #5
 7770 414c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7771 4150 0400A0E3 		mov	r0, #4
 7772 4154 1C1C1FE5 		ldr	r1, .L658+120
 7773 4158 FEFFFFEB 		bl	CyU3PDebugPrint
 7774              	.LVL860:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7775              		.loc 1 978 0
 7776 415c FF20A0E3 		mov	r2, #255
 7777              	.LVL861:
 7778 4160 57FCFFEA 		b	.L412
 7779              	.LVL862:
 7780              	.L330:
 7781              	.LBE172:
 7782              	.LBE274:
 7783              	.LBB275:
 7784              	.LBB212:
1191:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7785              		.loc 1 1191 0
 7786 4164 0000A0E3 		mov	r0, #0
 7787 4168 0020A0E1 		mov	r2, r0
 7788 416c 0110A0E3 		mov	r1, #1
 7789 4170 24C08DE5 		str	ip, [sp, #36]
 7790 4174 FEFFFFEB 		bl	CyU3PUsbStall
 7791              	.LVL863:
1192:../uvc.c      **** 			  break;
 7792              		.loc 1 1192 0
 7793 4178 24C09DE5 		ldr	ip, [sp, #36]
 7794 417c 0320A0E3 		mov	r2, #3
 7795 4180 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7796 4184 0400A0E3 		mov	r0, #4
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7797              		.loc 1 978 0
 7798 4188 FFC0A0E3 		mov	ip, #255
1192:../uvc.c      **** 			  break;
 7799              		.loc 1 1192 0
 7800 418c 541C1FE5 		ldr	r1, .L658+120
 7801 4190 24C08DE5 		str	ip, [sp, #36]
 7802 4194 FEFFFFEB 		bl	CyU3PDebugPrint
 7803              	.LVL864:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7804              		.loc 1 978 0
 7805 4198 24C09DE5 		ldr	ip, [sp, #36]
 7806 419c 0C20A0E1 		mov	r2, ip
 7807 41a0 0C30A0E1 		mov	r3, ip
 7808 41a4 5BFBFFEA 		b	.L340
 7809              	.LVL865:
 7810              	.L281:
 7811              	.LBE212:
 7812              	.LBE275:
 7813              	.LBE316:
 7814              	.LBE443:
 7815              	.LBB444:
 7816              	.LBB347:
 7817              	.LBB336:
 7818              	.LBB329:
 611:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 7819              		.loc 1 611 0
 7820 41a8 60CC1FE5 		ldr	ip, .L658+136
 7821 41ac D522DCE5 		ldrb	r2, [ip, #725]	@ zero_extendqisi2
 612:../uvc.c      **** 			 }
 7822              		.loc 1 612 0
 7823 41b0 D632DCE5 		ldrb	r3, [ip, #726]	@ zero_extendqisi2
 7824 41b4 9DFAFFEA 		b	.L593
 7825              	.L286:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 7826              		.loc 1 431 0
 7827 41b8 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7828              		.loc 1 432 0
 7829 41bc 0200A0E3 		mov	r0, #2
 7830 41c0 741C1FE5 		ldr	r1, .L658+140
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 7831              		.loc 1 430 0
 7832 41c4 5880CBE5 		strb	r8, [fp, #88]
 7833 41c8 9BFAFFEA 		b	.L592
 7834              	.LVL866:
 7835              	.L516:
 7836              	.LBE329:
 7837              	.LBE336:
 7838              	.LBE347:
 7839              	.LBE444:
 7840              	.LBB445:
 7841              	.LBB141:
3024:../uvc.c      ****                          		CyU3PThreadSleep(500);
 7842              		.loc 1 3024 0
 7843 41cc 3010A0E3 		mov	r1, #48
 7844 41d0 0020A0E3 		mov	r2, #0
 7845 41d4 5230A0E3 		mov	r3, #82
 7846 41d8 0B00A0E3 		mov	r0, #11
 7847              	.LVL867:
 7848 41dc FEFFFFEB 		bl	SensorSetIrisControl
 7849              	.LVL868:
3025:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
 7850              		.loc 1 3025 0
 7851 41e0 7D0FA0E3 		mov	r0, #500
 7852 41e4 FEFFFFEB 		bl	_tx_thread_sleep
 7853              	.LVL869:
3026:../uvc.c      ****                          		break;
 7854              		.loc 1 3026 0
 7855 41e8 AC1C1FE5 		ldr	r1, .L658+124
 7856 41ec 0020A0E3 		mov	r2, #0
 7857 41f0 0B30A0E3 		mov	r3, #11
 7858 41f4 0400A0E3 		mov	r0, #4
 7859 41f8 FEFFFFEB 		bl	CyU3PDebugPrint
 7860              	.LVL870:
 7861 41fc F5FBFFEA 		b	.L515
 7862              	.LVL871:
 7863              	.L288:
 7864              	.LBE141:
 7865              	.LBE445:
 7866              	.LBB446:
 7867              	.LBB348:
 7868              	.LBB337:
 7869              	.LBB330:
 638:../uvc.c      **** 		 	 }
 7870              		.loc 1 638 0
 7871 4200 D932DAE5 		ldrb	r3, [r10, #729]	@ zero_extendqisi2
 640:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7872              		.loc 1 640 0
 7873 4204 0100A0E3 		mov	r0, #1
 7874 4208 BC1C1FE5 		ldr	r1, .L658+140
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7875              		.loc 1 414 0
 7876 420c FF80A0E3 		mov	r8, #255
 638:../uvc.c      **** 		 	 }
 7877              		.loc 1 638 0
 7878 4210 5830CBE5 		strb	r3, [fp, #88]
 640:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7879              		.loc 1 640 0
 7880 4214 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7881              	.LVL872:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7882              		.loc 1 414 0
 7883 4218 08C0A0E1 		mov	ip, r8
 641:../uvc.c      **** 			  Len = 1;
 7884              		.loc 1 641 0
 7885 421c 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 7886              	.LVL873:
 7887 4220 8AFAFFEA 		b	.L290
 7888              	.LVL874:
 7889              	.L284:
 593:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7890              		.loc 1 593 0
 7891 4224 D322DAE5 		ldrb	r2, [r10, #723]	@ zero_extendqisi2
 594:../uvc.c      **** 			 }
 7892              		.loc 1 594 0
 7893 4228 D432DAE5 		ldrb	r3, [r10, #724]	@ zero_extendqisi2
 7894 422c 7FFAFFEA 		b	.L593
 7895              	.LVL875:
 7896              	.L533:
 7897              	.LBE330:
 7898              	.LBE337:
 7899              	.LBE348:
 7900              	.LBE446:
 7901              	.LBB447:
 7902              	.LBB142:
3165:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 7903              		.loc 1 3165 0
 7904 4230 3010A0E3 		mov	r1, #48
 7905 4234 0120A0E3 		mov	r2, #1
 7906 4238 5230A0E3 		mov	r3, #82
 7907 423c 0B00A0E3 		mov	r0, #11
 7908              	.LVL876:
 7909 4240 FEFFFFEB 		bl	SensorSetIrisControl
 7910              	.LVL877:
3167:../uvc.c      ****                              		break;
 7911              		.loc 1 3167 0
 7912 4244 041D1FE5 		ldr	r1, .L658+128
 7913 4248 0B20A0E3 		mov	r2, #11
 7914 424c 0130A0E3 		mov	r3, #1
 7915 4250 0400A0E3 		mov	r0, #4
 7916 4254 FEFFFFEB 		bl	CyU3PDebugPrint
 7917              	.LVL878:
 7918 4258 BCFBFFEA 		b	.L532
 7919              	.LVL879:
 7920              	.L375:
 7921              	.LBE142:
 7922              	.LBE447:
 7923              	.LBB448:
 7924              	.LBB317:
 7925              	.LBB276:
 7926              	.LBB205:
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7927              		.loc 1 1040 0
 7928 425c 2935DAE5 		ldrb	r3, [r10, #1321]	@ zero_extendqisi2
 7929              	.LVL880:
 7930              	.L619:
 7931              	.LBE205:
 7932              	.LBE276:
 7933              	.LBB277:
 7934              	.LBB163:
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7935              		.loc 1 1041 0
 7936 4260 0100A0E3 		mov	r0, #1
 7937 4264 181D1FE5 		ldr	r1, .L658+140
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7938              		.loc 1 1040 0
 7939 4268 5830CBE5 		strb	r3, [fp, #88]
1043:../uvc.c      **** 			  break;
 7940              		.loc 1 1043 0
 7941 426c 0180A0E3 		mov	r8, #1
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7942              		.loc 1 1041 0
 7943 4270 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7944              	.LVL881:
1042:../uvc.c      **** 			  Len = 1;
 7945              		.loc 1 1042 0
 7946 4274 5820DBE5 		ldrb	r2, [fp, #88]	@ zero_extendqisi2
 7947              	.LVL882:
 7948 4278 11FCFFEA 		b	.L412
 7949              	.LVL883:
 7950              	.L353:
 7951              	.LBE163:
 7952              	.LBE277:
 7953              	.LBB278:
 7954              	.LBB152:
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7955              		.loc 1 1040 0
 7956 427c F934DAE5 		ldrb	r3, [r10, #1273]	@ zero_extendqisi2
 7957 4280 F6FFFFEA 		b	.L619
 7958              	.LVL884:
 7959              	.L650:
 7960              	.LBE152:
 7961              	.LBE278:
 7962              	.LBE317:
 7963              	.LBE448:
 7964              	.LBB449:
 7965              	.LBB143:
3225:../uvc.c      ****                             }
 7966              		.loc 1 3225 0
 7967 4284 401D1FE5 		ldr	r1, .L658+132
 7968 4288 0400A0E3 		mov	r0, #4
 7969              	.LVL885:
 7970 428c FEFFFFEB 		bl	CyU3PDebugPrint
 7971              	.LVL886:
 7972 4290 F0FBFFEA 		b	.L543
 7973              	.LVL887:
 7974              	.L421:
 7975              	.LBE143:
 7976              	.LBE449:
 7977              	.LBB450:
 7978              	.LBB318:
 7979              	.LBB279:
 7980              	.LBB223:
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7981              		.loc 1 1040 0
 7982 4294 8935DAE5 		ldrb	r3, [r10, #1417]	@ zero_extendqisi2
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7983              		.loc 1 1041 0
 7984 4298 0100A0E3 		mov	r0, #1
 7985 429c 501D1FE5 		ldr	r1, .L658+140
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7986              		.loc 1 978 0
 7987 42a0 FF80A0E3 		mov	r8, #255
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7988              		.loc 1 1040 0
 7989 42a4 5830CBE5 		strb	r3, [fp, #88]
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7990              		.loc 1 1041 0
 7991 42a8 24808DE5 		str	r8, [sp, #36]
 7992 42ac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7993              	.LVL888:
1043:../uvc.c      **** 			  break;
 7994              		.loc 1 1043 0
 7995 42b0 0120A0E3 		mov	r2, #1
 7996 42b4 30208DE5 		str	r2, [sp, #48]
 7997              	.LVL889:
1042:../uvc.c      **** 			  Len = 1;
 7998              		.loc 1 1042 0
 7999 42b8 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 8000              	.LVL890:
 8001 42bc 24C09DE5 		ldr	ip, [sp, #36]
 8002 42c0 42FBFFEA 		b	.L423
 8003              	.LVL891:
 8004              	.L338:
 8005              	.LBE223:
 8006              	.LBE279:
 8007              	.LBB280:
 8008              	.LBB213:
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8009              		.loc 1 1040 0
 8010 42c4 E134DAE5 		ldrb	r3, [r10, #1249]	@ zero_extendqisi2
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8011              		.loc 1 1041 0
 8012 42c8 0100A0E3 		mov	r0, #1
 8013 42cc 801D1FE5 		ldr	r1, .L658+140
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8014              		.loc 1 1040 0
 8015 42d0 5830CBE5 		strb	r3, [fp, #88]
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8016              		.loc 1 1041 0
 8017 42d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8018              	.LVL892:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8019              		.loc 1 978 0
 8020 42d8 FF20A0E3 		mov	r2, #255
 8021 42dc 0230A0E1 		mov	r3, r2
1042:../uvc.c      **** 			  Len = 1;
 8022              		.loc 1 1042 0
 8023 42e0 58C0DBE5 		ldrb	ip, [fp, #88]	@ zero_extendqisi2
 8024              	.LVL893:
1043:../uvc.c      **** 			  break;
 8025              		.loc 1 1043 0
 8026 42e4 0170A0E3 		mov	r7, #1
 8027 42e8 0AFBFFEA 		b	.L340
 8028              	.LVL894:
 8029              	.L384:
 8030              	.LBE213:
 8031              	.LBE280:
 8032              	.LBB281:
 8033              	.LBB233:
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8034              		.loc 1 989 0
 8035 42ec 0030A0E3 		mov	r3, #0
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8036              		.loc 1 990 0
 8037 42f0 0200A0E3 		mov	r0, #2
 8038 42f4 A81D1FE5 		ldr	r1, .L658+140
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8039              		.loc 1 989 0
 8040 42f8 5930CBE5 		strb	r3, [fp, #89]
 988:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8041              		.loc 1 988 0
 8042 42fc 5880CBE5 		strb	r8, [fp, #88]
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8043              		.loc 1 990 0
 8044 4300 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8045              	.LVL895:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8046              		.loc 1 978 0
 8047 4304 FF20A0E3 		mov	r2, #255
 8048 4308 0230A0E1 		mov	r3, r2
 991:../uvc.c      **** 			  break;
 8049              		.loc 1 991 0
 8050 430c 58C0DBE5 		ldrb	ip, [fp, #88]	@ zero_extendqisi2
 8051              	.LVL896:
 8052 4310 54FBFFEA 		b	.L388
 8053              	.LVL897:
 8054              	.L320:
 8055              	.LBE233:
 8056              	.LBE281:
 8057              	.LBB282:
 8058              	.LBB197:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8059              		.loc 1 1022 0
 8060 4314 CCED1FE5 		ldr	lr, .L658+136
 8061 4318 C514DEE5 		ldrb	r1, [lr, #1221]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8062              		.loc 1 1023 0
 8063 431c C624DEE5 		ldrb	r2, [lr, #1222]	@ zero_extendqisi2
 8064 4320 E5F9FFEA 		b	.L602
 8065              	.LVL898:
 8066              	.L379:
 8067              	.LBE197:
 8068              	.LBE282:
 8069              	.LBB283:
 8070              	.LBB234:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8071              		.loc 1 1022 0
 8072 4324 DC3D1FE5 		ldr	r3, .L658+136
 8073 4328 3D15D3E5 		ldrb	r1, [r3, #1341]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8074              		.loc 1 1023 0
 8075 432c 3E25D3E5 		ldrb	r2, [r3, #1342]	@ zero_extendqisi2
 8076 4330 41FBFFEA 		b	.L600
 8077              	.LVL899:
 8078              	.L410:
 8079              	.LBE234:
 8080              	.LBE283:
 8081              	.LBB284:
 8082              	.LBB164:
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8083              		.loc 1 1040 0
 8084 4334 7135DAE5 		ldrb	r3, [r10, #1393]	@ zero_extendqisi2
 8085 4338 C8FFFFEA 		b	.L619
 8086              	.LVL900:
 8087              	.L386:
 8088              	.LBE164:
 8089              	.LBE284:
 8090              	.LBB285:
 8091              	.LBB235:
 8092 433c F4ED1FE5 		ldr	lr, .L658+136
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8093              		.loc 1 1041 0
 8094 4340 0100A0E3 		mov	r0, #1
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8095              		.loc 1 1040 0
 8096 4344 4135DEE5 		ldrb	r3, [lr, #1345]	@ zero_extendqisi2
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8097              		.loc 1 1041 0
 8098 4348 FC1D1FE5 		ldr	r1, .L658+140
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8099              		.loc 1 1040 0
 8100 434c 5830CBE5 		strb	r3, [fp, #88]
1041:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8101              		.loc 1 1041 0
 8102 4350 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8103              	.LVL901:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8104              		.loc 1 978 0
 8105 4354 FF20A0E3 		mov	r2, #255
 8106 4358 0230A0E1 		mov	r3, r2
1042:../uvc.c      **** 			  Len = 1;
 8107              		.loc 1 1042 0
 8108 435c 58C0DBE5 		ldrb	ip, [fp, #88]	@ zero_extendqisi2
 8109              	.LVL902:
1043:../uvc.c      **** 			  break;
 8110              		.loc 1 1043 0
 8111 4360 0180A0E3 		mov	r8, #1
 8112 4364 3FFBFFEA 		b	.L388
 8113              	.LVL903:
 8114              	.L334:
 8115              	.LBE235:
 8116              	.LBE285:
 8117              	.LBB286:
 8118              	.LBB214:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8119              		.loc 1 1013 0
 8120 4368 202E1FE5 		ldr	r2, .L658+136
 8121 436c DB14D2E5 		ldrb	r1, [r2, #1243]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8122              		.loc 1 1014 0
 8123 4370 DC24D2E5 		ldrb	r2, [r2, #1244]	@ zero_extendqisi2
 8124 4374 DCFAFFEA 		b	.L596
 8125              	.LVL904:
 8126              	.L382:
 8127              	.LBE214:
 8128              	.LBE286:
 8129              	.LBB287:
 8130              	.LBB236:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8131              		.loc 1 1013 0
 8132 4378 302E1FE5 		ldr	r2, .L658+136
 8133 437c 3B15D2E5 		ldrb	r1, [r2, #1339]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8134              		.loc 1 1014 0
 8135 4380 3C25D2E5 		ldrb	r2, [r2, #1340]	@ zero_extendqisi2
 8136 4384 2CFBFFEA 		b	.L600
 8137              	.LVL905:
 8138              	.L392:
 8139              	.LBE236:
 8140              	.LBE287:
 8141              	.LBB288:
 8142              	.LBB180:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8143              		.loc 1 1022 0
 8144 4388 40EE1FE5 		ldr	lr, .L658+136
 8145 438c 5515DEE5 		ldrb	r1, [lr, #1365]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8146              		.loc 1 1023 0
 8147 4390 5625DEE5 		ldrb	r2, [lr, #1366]	@ zero_extendqisi2
 8148 4394 C8F9FFEA 		b	.L602
 8149              	.LVL906:
 8150              	.L346:
 8151              	.LBE180:
 8152              	.LBE288:
 8153              	.LBB289:
 8154              	.LBB153:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8155              		.loc 1 1022 0
 8156 4398 502E1FE5 		ldr	r2, .L658+136
 8157 439c F514D2E5 		ldrb	r1, [r2, #1269]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8158              		.loc 1 1023 0
 8159 43a0 F624D2E5 		ldrb	r2, [r2, #1270]	@ zero_extendqisi2
 8160 43a4 C4F9FFEA 		b	.L602
 8161              	.LVL907:
 8162              	.L368:
 8163              	.LBE153:
 8164              	.LBE289:
 8165              	.LBB290:
 8166              	.LBB206:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8167              		.loc 1 1022 0
 8168 43a8 603E1FE5 		ldr	r3, .L658+136
 8169 43ac 2515D3E5 		ldrb	r1, [r3, #1317]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8170              		.loc 1 1023 0
 8171 43b0 2625D3E5 		ldrb	r2, [r3, #1318]	@ zero_extendqisi2
 8172 43b4 C0F9FFEA 		b	.L602
 8173              	.LVL908:
 8174              	.L357:
 8175              	.LBE206:
 8176              	.LBE290:
 8177              	.LBB291:
 8178              	.LBB173:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8179              		.loc 1 1022 0
 8180 43b8 70EE1FE5 		ldr	lr, .L658+136
 8181 43bc 0D15DEE5 		ldrb	r1, [lr, #1293]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8182              		.loc 1 1023 0
 8183 43c0 0E25DEE5 		ldrb	r2, [lr, #1294]	@ zero_extendqisi2
 8184 43c4 BCF9FFEA 		b	.L602
 8185              	.LVL909:
 8186              	.L309:
 8187              	.LBE173:
 8188              	.LBE291:
 8189              	.LBB292:
 8190              	.LBB188:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8191              		.loc 1 1022 0
 8192 43c8 80EE1FE5 		ldr	lr, .L658+136
 8193 43cc 9514DEE5 		ldrb	r1, [lr, #1173]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8194              		.loc 1 1023 0
 8195 43d0 9624DEE5 		ldrb	r2, [lr, #1174]	@ zero_extendqisi2
 8196 43d4 B8F9FFEA 		b	.L602
 8197              	.LVL910:
 8198              	.L414:
 8199              	.LBE188:
 8200              	.LBE292:
 8201              	.LBB293:
 8202              	.LBB224:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8203              		.loc 1 1022 0
 8204 43d8 901E1FE5 		ldr	r1, .L658+136
 8205 43dc 8505D1E5 		ldrb	r0, [r1, #1413]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8206              		.loc 1 1023 0
 8207 43e0 8615D1E5 		ldrb	r1, [r1, #1414]	@ zero_extendqisi2
 8208 43e4 ECFAFFEA 		b	.L604
 8209              	.L419:
 988:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8210              		.loc 1 988 0
 8211 43e8 30C09DE5 		ldr	ip, [sp, #48]
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8212              		.loc 1 989 0
 8213 43ec 0030A0E3 		mov	r3, #0
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8214              		.loc 1 990 0
 8215 43f0 0200A0E3 		mov	r0, #2
 8216 43f4 A81E1FE5 		ldr	r1, .L658+140
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8217              		.loc 1 978 0
 8218 43f8 FF80A0E3 		mov	r8, #255
 988:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8219              		.loc 1 988 0
 8220 43fc 58C0CBE5 		strb	ip, [fp, #88]
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8221              		.loc 1 989 0
 8222 4400 5930CBE5 		strb	r3, [fp, #89]
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8223              		.loc 1 990 0
 8224 4404 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8225              	.LVL911:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8226              		.loc 1 978 0
 8227 4408 08C0A0E1 		mov	ip, r8
 991:../uvc.c      **** 			  break;
 8228              		.loc 1 991 0
 8229 440c 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 8230              	.LVL912:
 8231 4410 30209DE5 		ldr	r2, [sp, #48]
 8232 4414 EDFAFFEA 		b	.L423
 8233              	.LVL913:
 8234              	.L331:
 8235              	.LBE224:
 8236              	.LBE293:
 8237              	.LBB294:
 8238              	.LBB215:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8239              		.loc 1 1022 0
 8240 4418 D03E1FE5 		ldr	r3, .L658+136
 8241 441c DD14D3E5 		ldrb	r1, [r3, #1245]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8242              		.loc 1 1023 0
 8243 4420 DE24D3E5 		ldrb	r2, [r3, #1246]	@ zero_extendqisi2
 8244 4424 B0FAFFEA 		b	.L596
 8245              	.L336:
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8246              		.loc 1 989 0
 8247 4428 0030A0E3 		mov	r3, #0
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8248              		.loc 1 990 0
 8249 442c 0200A0E3 		mov	r0, #2
 8250 4430 E41E1FE5 		ldr	r1, .L658+140
 989:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8251              		.loc 1 989 0
 8252 4434 5930CBE5 		strb	r3, [fp, #89]
 988:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8253              		.loc 1 988 0
 8254 4438 5870CBE5 		strb	r7, [fp, #88]
 990:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8255              		.loc 1 990 0
 8256 443c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8257              	.LVL914:
 978:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8258              		.loc 1 978 0
 8259 4440 FF20A0E3 		mov	r2, #255
 8260 4444 0230A0E1 		mov	r3, r2
 991:../uvc.c      **** 			  break;
 8261              		.loc 1 991 0
 8262 4448 58C0DBE5 		ldrb	ip, [fp, #88]	@ zero_extendqisi2
 8263              	.LVL915:
 8264 444c B1FAFFEA 		b	.L340
 8265              	.LVL916:
 8266              	.L403:
 8267              	.LBE215:
 8268              	.LBE294:
 8269              	.LBB295:
 8270              	.LBB165:
1022:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8271              		.loc 1 1022 0
 8272 4450 083F1FE5 		ldr	r3, .L658+136
 8273 4454 6D15D3E5 		ldrb	r1, [r3, #1389]	@ zero_extendqisi2
1023:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8274              		.loc 1 1023 0
 8275 4458 6E25D3E5 		ldrb	r2, [r3, #1390]	@ zero_extendqisi2
 8276 445c 96F9FFEA 		b	.L602
 8277              	.LVL917:
 8278              	.L327:
 8279              	.LBE165:
 8280              	.LBE295:
 8281              	.LBB296:
 8282              	.LBB198:
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8283              		.loc 1 1040 0
 8284 4460 18CF1FE5 		ldr	ip, .L658+136
 8285 4464 C934DCE5 		ldrb	r3, [ip, #1225]	@ zero_extendqisi2
 8286 4468 7CFFFFEA 		b	.L619
 8287              	.LVL918:
 8288              	.L316:
 8289              	.LBE198:
 8290              	.LBE296:
 8291              	.LBB297:
 8292              	.LBB189:
 8293 446c 9934DAE5 		ldrb	r3, [r10, #1177]	@ zero_extendqisi2
 8294 4470 7AFFFFEA 		b	.L619
 8295              	.LVL919:
 8296              	.L417:
 8297              	.LBE189:
 8298              	.LBE297:
 8299              	.LBB298:
 8300              	.LBB225:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8301              		.loc 1 1013 0
 8302 4474 8305DAE5 		ldrb	r0, [r10, #1411]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8303              		.loc 1 1014 0
 8304 4478 8415DAE5 		ldrb	r1, [r10, #1412]	@ zero_extendqisi2
 8305 447c C6FAFFEA 		b	.L604
 8306              	.LVL920:
 8307              	.L395:
 8308              	.LBE225:
 8309              	.LBE298:
 8310              	.LBB299:
 8311              	.LBB181:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8312              		.loc 1 1013 0
 8313 4480 5315DAE5 		ldrb	r1, [r10, #1363]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8314              		.loc 1 1014 0
 8315 4484 5425DAE5 		ldrb	r2, [r10, #1364]	@ zero_extendqisi2
 8316 4488 8BF9FFEA 		b	.L602
 8317              	.LVL921:
 8318              	.L312:
 8319              	.LBE181:
 8320              	.LBE299:
 8321              	.LBB300:
 8322              	.LBB190:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8323              		.loc 1 1013 0
 8324 448c 44CF1FE5 		ldr	ip, .L658+136
 8325 4490 9314DCE5 		ldrb	r1, [ip, #1171]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8326              		.loc 1 1014 0
 8327 4494 9424DCE5 		ldrb	r2, [ip, #1172]	@ zero_extendqisi2
 8328 4498 87F9FFEA 		b	.L602
 8329              	.LVL922:
 8330              	.L323:
 8331              	.LBE190:
 8332              	.LBE300:
 8333              	.LBB301:
 8334              	.LBB199:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8335              		.loc 1 1013 0
 8336 449c 54CF1FE5 		ldr	ip, .L658+136
 8337 44a0 C314DCE5 		ldrb	r1, [ip, #1219]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8338              		.loc 1 1014 0
 8339 44a4 C424DCE5 		ldrb	r2, [ip, #1220]	@ zero_extendqisi2
 8340 44a8 83F9FFEA 		b	.L602
 8341              	.LVL923:
 8342              	.L399:
 8343              	.LBE199:
 8344              	.LBE301:
 8345              	.LBB302:
 8346              	.LBB182:
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8347              		.loc 1 1040 0
 8348 44ac 5935DAE5 		ldrb	r3, [r10, #1369]	@ zero_extendqisi2
 8349 44b0 6AFFFFEA 		b	.L619
 8350              	.LVL924:
 8351              	.L349:
 8352              	.LBE182:
 8353              	.LBE302:
 8354              	.LBB303:
 8355              	.LBB154:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8356              		.loc 1 1013 0
 8357 44b4 F314DAE5 		ldrb	r1, [r10, #1267]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8358              		.loc 1 1014 0
 8359 44b8 F424DAE5 		ldrb	r2, [r10, #1268]	@ zero_extendqisi2
 8360 44bc 7EF9FFEA 		b	.L602
 8361              	.LVL925:
 8362              	.L371:
 8363              	.LBE154:
 8364              	.LBE303:
 8365              	.LBB304:
 8366              	.LBB207:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8367              		.loc 1 1013 0
 8368 44c0 782F1FE5 		ldr	r2, .L658+136
 8369 44c4 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8370              		.loc 1 1014 0
 8371 44c8 2425D2E5 		ldrb	r2, [r2, #1316]	@ zero_extendqisi2
 8372 44cc 7AF9FFEA 		b	.L602
 8373              	.LVL926:
 8374              	.L364:
 8375              	.LBE207:
 8376              	.LBE304:
 8377              	.LBB305:
 8378              	.LBB174:
1040:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8379              		.loc 1 1040 0
 8380 44d0 88CF1FE5 		ldr	ip, .L658+136
 8381 44d4 1135DCE5 		ldrb	r3, [ip, #1297]	@ zero_extendqisi2
 8382 44d8 60FFFFEA 		b	.L619
 8383              	.L360:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8384              		.loc 1 1013 0
 8385 44dc 94CF1FE5 		ldr	ip, .L658+136
 8386 44e0 0B15DCE5 		ldrb	r1, [ip, #1291]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8387              		.loc 1 1014 0
 8388 44e4 0C25DCE5 		ldrb	r2, [ip, #1292]	@ zero_extendqisi2
 8389 44e8 73F9FFEA 		b	.L602
 8390              	.LVL927:
 8391              	.L406:
 8392              	.LBE174:
 8393              	.LBE305:
 8394              	.LBB306:
 8395              	.LBB166:
1013:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8396              		.loc 1 1013 0
 8397 44ec A42F1FE5 		ldr	r2, .L658+136
 8398 44f0 6B15D2E5 		ldrb	r1, [r2, #1387]	@ zero_extendqisi2
1014:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8399              		.loc 1 1014 0
 8400 44f4 6C25D2E5 		ldrb	r2, [r2, #1388]	@ zero_extendqisi2
 8401 44f8 6FF9FFEA 		b	.L602
 8402              	.LVL928:
 8403              	.L341:
 8404              	.LBE166:
 8405              	.LBE306:
 8406              	.LBB307:
 8407              	.LBB216:
1141:../uvc.c      **** 					  }
 8408              		.loc 1 1141 0
 8409 44fc 0000A0E3 		mov	r0, #0
 8410 4500 0020A0E1 		mov	r2, r0
 8411 4504 0110A0E3 		mov	r1, #1
 8412 4508 FEFFFFEB 		bl	CyU3PUsbStall
 8413              	.LVL929:
 8414 450c 8EFCFFEA 		b	.L344
 8415              	.LVL930:
 8416              	.L485:
 8417              	.LBE216:
 8418              	.LBE307:
 8419              	.LBE318:
 8420              	.LBE450:
 8421              	.LBB451:
 8422              	.LBB414:
 8423              	.LBB392:
 8424              	.LBB369:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8425              		.loc 1 431 0
 8426 4510 0020A0E3 		mov	r2, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8427              		.loc 1 432 0
 8428 4514 0200A0E3 		mov	r0, #2
 8429 4518 CC1F1FE5 		ldr	r1, .L658+140
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8430              		.loc 1 414 0
 8431 451c FF80A0E3 		mov	r8, #255
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8432              		.loc 1 430 0
 8433 4520 58C0CBE5 		strb	ip, [fp, #88]
 8434 4524 9DFBFFEA 		b	.L609
 8435              	.LVL931:
 8436              	.L472:
 8437              	.LBE369:
 8438              	.LBE392:
 8439              	.LBB393:
 8440              	.LBB359:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8441              		.loc 1 431 0
 8442 4528 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8443              		.loc 1 432 0
 8444 452c 0200A0E3 		mov	r0, #2
 8445 4530 E41F1FE5 		ldr	r1, .L658+140
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8446              		.loc 1 430 0
 8447 4534 5870CBE5 		strb	r7, [fp, #88]
 8448 4538 BDFBFFEA 		b	.L607
 8449              	.L469:
 558:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 8450              		.loc 1 558 0
 8451 453c 9620DBE5 		ldrb	r2, [fp, #150]	@ zero_extendqisi2
 8452 4540 000052E3 		cmp	r2, #0
 8453 4544 8D00000A 		beq	.L656
 8454              	.LVL932:
 8455              	.L477:
 568:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8456              		.loc 1 568 0
 8457 4548 5D34DAE5 		ldrb	r3, [r10, #1117]	@ zero_extendqisi2
 574:../uvc.c      **** 
 8458              		.loc 1 574 0
 8459 454c 0700A0E1 		mov	r0, r7
 569:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 8460              		.loc 1 569 0
 8461 4550 0020A0E3 		mov	r2, #0
 574:../uvc.c      **** 
 8462              		.loc 1 574 0
 8463 4554 DC129FE5 		ldr	r1, .L660
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8464              		.loc 1 414 0
 8465 4558 FF70A0E3 		mov	r7, #255
 8466              	.LVL933:
 568:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8467              		.loc 1 568 0
 8468 455c 5830CBE5 		strb	r3, [fp, #88]
 569:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 8469              		.loc 1 569 0
 8470 4560 5920CBE5 		strb	r2, [fp, #89]
 8471              	.LVL934:
 574:../uvc.c      **** 
 8472              		.loc 1 574 0
 8473 4564 28308DE5 		str	r3, [sp, #40]
 8474 4568 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8475              	.LVL935:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8476              		.loc 1 414 0
 8477 456c 07C0A0E1 		mov	ip, r7
 8478 4570 28309DE5 		ldr	r3, [sp, #40]
 8479 4574 C2FDFFEA 		b	.L476
 8480              	.LVL936:
 8481              	.L466:
 955:../uvc.c      **** 			  break;
 8482              		.loc 1 955 0
 8483 4578 0000A0E3 		mov	r0, #0
 8484 457c 0020A0E1 		mov	r2, r0
 8485 4580 0110A0E3 		mov	r1, #1
 8486 4584 FEFFFFEB 		bl	CyU3PUsbStall
 8487              	.LVL937:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8488              		.loc 1 414 0
 8489 4588 FF30A0E3 		mov	r3, #255
 8490 458c 0370A0E1 		mov	r7, r3
 8491              	.LVL938:
 8492 4590 03C0A0E1 		mov	ip, r3
 8493 4594 BAFDFFEA 		b	.L476
 8494              	.LVL939:
 8495              	.L456:
 8496              	.LBE359:
 8497              	.LBE393:
 8498              	.LBB394:
 8499              	.LBB379:
 450:../uvc.c      **** 					 if(CamMode == 1){//720p
 8500              		.loc 1 450 0
 8501 4598 9CE29FE5 		ldr	lr, .L660+4
 8502 459c 2D34DEE5 		ldrb	r3, [lr, #1069]	@ zero_extendqisi2
 8503              	.LVL940:
 452:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 8504              		.loc 1 452 0
 8505 45a0 020053E3 		cmp	r3, #2
 8506 45a4 9900008A 		bhi	.L657
 8507              	.LVL941:
 8508              	.L464:
 457:../uvc.c      **** 					 }
 8509              		.loc 1 457 0
 8510 45a8 043083E2 		add	r3, r3, #4
 8511              	.LVL942:
 8512 45ac FF8003E2 		and	r8, r3, #255
 8513              	.LVL943:
 574:../uvc.c      **** 
 8514              		.loc 1 574 0
 8515 45b0 80129FE5 		ldr	r1, .L660
 461:../uvc.c      **** 					 break;
 8516              		.loc 1 461 0
 8517 45b4 0030A0E3 		mov	r3, #0
 574:../uvc.c      **** 
 8518              		.loc 1 574 0
 8519 45b8 0C00A0E1 		mov	r0, ip
 461:../uvc.c      **** 					 break;
 8520              		.loc 1 461 0
 8521 45bc 5930CBE5 		strb	r3, [fp, #89]
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8522              		.loc 1 460 0
 8523 45c0 5880CBE5 		strb	r8, [fp, #88]
 574:../uvc.c      **** 
 8524              		.loc 1 574 0
 8525 45c4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8526              	.LVL944:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8527              		.loc 1 414 0
 8528 45c8 FF10A0E3 		mov	r1, #255
 8529 45cc 0130A0E1 		mov	r3, r1
 8530 45d0 BEFDFFEA 		b	.L463
 8531              	.LVL945:
 8532              	.L453:
 955:../uvc.c      **** 			  break;
 8533              		.loc 1 955 0
 8534 45d4 0000A0E3 		mov	r0, #0
 8535 45d8 0110A0E3 		mov	r1, #1
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8536              		.loc 1 414 0
 8537 45dc FF80A0E3 		mov	r8, #255
 955:../uvc.c      **** 			  break;
 8538              		.loc 1 955 0
 8539 45e0 0020A0E1 		mov	r2, r0
 8540 45e4 FEFFFFEB 		bl	CyU3PUsbStall
 8541              	.LVL946:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8542              		.loc 1 414 0
 8543 45e8 0810A0E1 		mov	r1, r8
 8544 45ec 0830A0E1 		mov	r3, r8
 8545 45f0 B6FDFFEA 		b	.L463
 8546              	.LVL947:
 8547              	.L482:
 8548              	.LBE379:
 8549              	.LBE394:
 8550              	.LBB395:
 8551              	.LBB370:
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 8552              		.loc 1 443 0
 8553 45f4 8520DAE5 		ldrb	r2, [r10, #133]	@ zero_extendqisi2
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 8554              		.loc 1 444 0
 8555 45f8 8680DAE5 		ldrb	r8, [r10, #134]	@ zero_extendqisi2
 574:../uvc.c      **** 
 8556              		.loc 1 574 0
 8557 45fc 0C00A0E1 		mov	r0, ip
 8558 4600 30129FE5 		ldr	r1, .L660
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8559              		.loc 1 414 0
 8560 4604 FFC0A0E3 		mov	ip, #255
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 8561              		.loc 1 443 0
 8562 4608 5820CBE5 		strb	r2, [fp, #88]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8563              		.loc 1 414 0
 8564 460c 30C08DE5 		str	ip, [sp, #48]
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 8565              		.loc 1 444 0
 8566 4610 5980CBE5 		strb	r8, [fp, #89]
 8567              	.LVL948:
 574:../uvc.c      **** 
 8568              		.loc 1 574 0
 8569 4614 2C208DE5 		str	r2, [sp, #44]
 8570 4618 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8571              	.LVL949:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8572              		.loc 1 414 0
 8573 461c 30C09DE5 		ldr	ip, [sp, #48]
 8574 4620 2C209DE5 		ldr	r2, [sp, #44]
 8575 4624 0C30A0E1 		mov	r3, ip
 8576 4628 66FDFFEA 		b	.L489
 8577              	.LVL950:
 8578              	.L479:
 955:../uvc.c      **** 			  break;
 8579              		.loc 1 955 0
 8580 462c 0000A0E3 		mov	r0, #0
 8581 4630 0020A0E1 		mov	r2, r0
 8582 4634 0110A0E3 		mov	r1, #1
 8583 4638 FEFFFFEB 		bl	CyU3PUsbStall
 8584              	.LVL951:
 8585              	.L610:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8586              		.loc 1 414 0
 8587 463c FF80A0E3 		mov	r8, #255
 8588              	.LVL952:
 8589 4640 0820A0E1 		mov	r2, r8
 8590 4644 30808DE5 		str	r8, [sp, #48]
 8591 4648 08C0A0E1 		mov	ip, r8
 8592 464c 0830A0E1 		mov	r3, r8
 8593 4650 5CFDFFEA 		b	.L489
 8594              	.LVL953:
 8595              	.L460:
 8596              	.LBE370:
 8597              	.LBE395:
 8598              	.LBB396:
 8599              	.LBB380:
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8600              		.loc 1 625 0
 8601 4654 2714DAE5 		ldrb	r1, [r10, #1063]	@ zero_extendqisi2
 626:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8602              		.loc 1 626 0
 8603 4658 2824DAE5 		ldrb	r2, [r10, #1064]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8604              		.loc 1 627 0
 8605 465c 0030A0E3 		mov	r3, #0
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8606              		.loc 1 625 0
 8607 4660 5810CBE5 		strb	r1, [fp, #88]
 630:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8608              		.loc 1 630 0
 8609 4664 0C00A0E1 		mov	r0, ip
 8610 4668 C8119FE5 		ldr	r1, .L660
 627:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8611              		.loc 1 627 0
 8612 466c 5A30CBE5 		strb	r3, [fp, #90]
 628:../uvc.c      **** 		 	 }
 8613              		.loc 1 628 0
 8614 4670 5B30CBE5 		strb	r3, [fp, #91]
 626:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8615              		.loc 1 626 0
 8616 4674 5920CBE5 		strb	r2, [fp, #89]
 630:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8617              		.loc 1 630 0
 8618 4678 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8619              	.LVL954:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8620              		.loc 1 414 0
 8621 467c FF10A0E3 		mov	r1, #255
 8622 4680 0130A0E1 		mov	r3, r1
 631:../uvc.c      **** 			  break;
 8623              		.loc 1 631 0
 8624 4684 5880DBE5 		ldrb	r8, [fp, #88]	@ zero_extendqisi2
 8625              	.LVL955:
 8626 4688 90FDFFEA 		b	.L463
 8627              	.LVL956:
 8628              	.L459:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8629              		.loc 1 431 0
 8630 468c 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8631              		.loc 1 432 0
 8632 4690 0200A0E3 		mov	r0, #2
 8633 4694 9C119FE5 		ldr	r1, .L660
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8634              		.loc 1 430 0
 8635 4698 58C0CBE5 		strb	ip, [fp, #88]
 8636 469c 7CFBFFEA 		b	.L605
 8637              	.LVL957:
 8638              	.L467:
 8639              	.LBE380:
 8640              	.LBE396:
 8641              	.LBB397:
 8642              	.LBB360:
 611:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8643              		.loc 1 611 0
 8644 46a0 94119FE5 		ldr	r1, .L660+4
 8645 46a4 5524D1E5 		ldrb	r2, [r1, #1109]	@ zero_extendqisi2
 612:../uvc.c      **** 			 }
 8646              		.loc 1 612 0
 8647 46a8 5634D1E5 		ldrb	r3, [r1, #1110]	@ zero_extendqisi2
 8648 46ac 5DFBFFEA 		b	.L608
 8649              	.LVL958:
 8650              	.L480:
 8651              	.LBE360:
 8652              	.LBE397:
 8653              	.LBB398:
 8654              	.LBB371:
 601:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 8655              		.loc 1 601 0
 8656 46b0 84119FE5 		ldr	r1, .L660+4
 8657 46b4 7DE0D1E5 		ldrb	lr, [r1, #125]	@ zero_extendqisi2
 602:../uvc.c      **** 		 	 }
 8658              		.loc 1 602 0
 8659 46b8 7E20D1E5 		ldrb	r2, [r1, #126]	@ zero_extendqisi2
 8660 46bc 33FBFFEA 		b	.L611
 8661              	.LVL959:
 8662              	.L454:
 8663              	.LBE371:
 8664              	.LBE398:
 8665              	.LBB399:
 8666              	.LBB381:
 611:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8667              		.loc 1 611 0
 8668 46c0 74119FE5 		ldr	r1, .L660+4
 8669 46c4 2524D1E5 		ldrb	r2, [r1, #1061]	@ zero_extendqisi2
 612:../uvc.c      **** 			 }
 8670              		.loc 1 612 0
 8671 46c8 2634D1E5 		ldrb	r3, [r1, #1062]	@ zero_extendqisi2
 8672 46cc 6DFBFFEA 		b	.L606
 8673              	.LVL960:
 8674              	.L473:
 8675              	.LBE381:
 8676              	.LBE399:
 8677              	.LBB400:
 8678              	.LBB361:
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8679              		.loc 1 625 0
 8680 46d0 64219FE5 		ldr	r2, .L660+4
 627:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8681              		.loc 1 627 0
 8682 46d4 0030A0E3 		mov	r3, #0
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8683              		.loc 1 625 0
 8684 46d8 5714D2E5 		ldrb	r1, [r2, #1111]	@ zero_extendqisi2
 626:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8685              		.loc 1 626 0
 8686 46dc 5824D2E5 		ldrb	r2, [r2, #1112]	@ zero_extendqisi2
 630:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8687              		.loc 1 630 0
 8688 46e0 0700A0E1 		mov	r0, r7
 625:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8689              		.loc 1 625 0
 8690 46e4 5810CBE5 		strb	r1, [fp, #88]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8691              		.loc 1 414 0
 8692 46e8 FF70A0E3 		mov	r7, #255
 630:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8693              		.loc 1 630 0
 8694 46ec 44119FE5 		ldr	r1, .L660
 627:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8695              		.loc 1 627 0
 8696 46f0 5A30CBE5 		strb	r3, [fp, #90]
 628:../uvc.c      **** 		 	 }
 8697              		.loc 1 628 0
 8698 46f4 5B30CBE5 		strb	r3, [fp, #91]
 626:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8699              		.loc 1 626 0
 8700 46f8 5920CBE5 		strb	r2, [fp, #89]
 630:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8701              		.loc 1 630 0
 8702 46fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8703              	.LVL961:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8704              		.loc 1 414 0
 8705 4700 07C0A0E1 		mov	ip, r7
 631:../uvc.c      **** 			  break;
 8706              		.loc 1 631 0
 8707 4704 5830DBE5 		ldrb	r3, [fp, #88]	@ zero_extendqisi2
 8708              	.LVL962:
 8709 4708 5DFDFFEA 		b	.L476
 8710              	.LVL963:
 8711              	.L486:
 8712              	.LBE361:
 8713              	.LBE400:
 8714              	.LBB401:
 8715              	.LBB372:
 619:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 8716              		.loc 1 619 0
 8717 470c 7F30DAE5 		ldrb	r3, [r10, #127]	@ zero_extendqisi2
 620:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 8718              		.loc 1 620 0
 8719 4710 80E0DAE5 		ldrb	lr, [r10, #128]	@ zero_extendqisi2
 621:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 8720              		.loc 1 621 0
 8721 4714 0020A0E3 		mov	r2, #0
 630:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8722              		.loc 1 630 0
 8723 4718 0C00A0E1 		mov	r0, ip
 8724 471c 14119FE5 		ldr	r1, .L660
 619:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 8725              		.loc 1 619 0
 8726 4720 5830CBE5 		strb	r3, [fp, #88]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8727              		.loc 1 414 0
 8728 4724 FF80A0E3 		mov	r8, #255
 620:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 8729              		.loc 1 620 0
 8730 4728 59E0CBE5 		strb	lr, [fp, #89]
 621:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 8731              		.loc 1 621 0
 8732 472c 5A20CBE5 		strb	r2, [fp, #90]
 622:../uvc.c      **** 		 	 }
 8733              		.loc 1 622 0
 8734 4730 5B20CBE5 		strb	r2, [fp, #91]
 8735 4734 1AFBFFEA 		b	.L612
 8736              	.LVL964:
 8737              	.L389:
 8738              	.LBE372:
 8739              	.LBE401:
 8740              	.LBE414:
 8741              	.LBE451:
 8742              	.LBB452:
 8743              	.LBB319:
 8744              	.LBB308:
 8745              	.LBB237:
1159:../uvc.c      **** 					  }
 8746              		.loc 1 1159 0
 8747 4738 0020A0E1 		mov	r2, r0
 8748 473c 0710A0E1 		mov	r1, r7
 8749 4740 FEFFFFEB 		bl	CyU3PUsbStall
 8750              	.LVL965:
 8751 4744 31FCFFEA 		b	.L390
 8752              	.LVL966:
 8753              	.L655:
 8754              	.LBE237:
 8755              	.LBE308:
 8756              	.LBE319:
 8757              	.LBE452:
 8758              	.LBB453:
 8759              	.LBB349:
 8760              	.LBB338:
 8761              	.LBB331:
 562:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 8762              		.loc 1 562 0
 8763 4748 0310A0E1 		mov	r1, r3
 8764 474c 30009DE5 		ldr	r0, [sp, #48]
 8765 4750 FEFFFFEB 		bl	SensorGetControl
 8766              	.LVL967:
 565:../uvc.c      **** 		 	 		 }
 8767              		.loc 1 565 0
 8768 4754 0130A0E3 		mov	r3, #1
 8769 4758 8630CBE5 		strb	r3, [fp, #134]
 563:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 8770              		.loc 1 563 0
 8771 475c DD02CAE5 		strb	r0, [r10, #733]
 8772 4760 85FDFFEA 		b	.L291
 8773              	.LVL968:
 8774              	.L465:
 8775              	.LBE331:
 8776              	.LBE338:
 8777              	.LBE349:
 8778              	.LBE453:
 8779              	.LBB454:
 8780              	.LBB415:
 8781              	.LBB402:
 8782              	.LBB382:
 947:../uvc.c      **** 			   }
 8783              		.loc 1 947 0
 8784 4764 D4109FE5 		ldr	r1, .L660+8
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8785              		.loc 1 414 0
 8786 4768 FF80A0E3 		mov	r8, #255
 947:../uvc.c      **** 			   }
 8787              		.loc 1 947 0
 8788 476c 0400A0E3 		mov	r0, #4
 8789              	.LVL969:
 8790 4770 FEFFFFEB 		bl	CyU3PDebugPrint
 8791              	.LVL970:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8792              		.loc 1 414 0
 8793 4774 0810A0E1 		mov	r1, r8
 8794 4778 0830A0E1 		mov	r3, r8
 8795 477c 53FDFFEA 		b	.L463
 8796              	.LVL971:
 8797              	.L656:
 8798              	.LBE382:
 8799              	.LBE402:
 8800              	.LBB403:
 8801              	.LBB362:
 562:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 8802              		.loc 1 562 0
 8803 4780 0310A0E1 		mov	r1, r3
 8804 4784 30009DE5 		ldr	r0, [sp, #48]
 8805 4788 FEFFFFEB 		bl	SensorGetControl
 8806              	.LVL972:
 563:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 8807              		.loc 1 563 0
 8808 478c A8C09FE5 		ldr	ip, .L660+4
 565:../uvc.c      **** 		 	 		 }
 8809              		.loc 1 565 0
 8810 4790 0130A0E3 		mov	r3, #1
 8811 4794 9630C4E5 		strb	r3, [r4, #150]
 563:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 8812              		.loc 1 563 0
 8813 4798 5D04CCE5 		strb	r0, [ip, #1117]
 8814 479c 69FFFFEA 		b	.L477
 8815              	.LVL973:
 8816              	.L654:
 8817              	.LBE362:
 8818              	.LBE403:
 8819              	.LBE415:
 8820              	.LBE454:
 8821              	.LBB455:
 8822              	.LBB320:
 8823              	.LBB309:
 8824              	.LBB226:
1172:../uvc.c      **** 					  else if(getData == 0xff)
 8825              		.loc 1 1172 0
 8826 47a0 0410A0E3 		mov	r1, #4
 8827 47a4 0000A0E3 		mov	r0, #0
 8828 47a8 00108DE5 		str	r1, [sp]
 8829 47ac 04008DE5 		str	r0, [sp, #4]
 8830 47b0 34209DE5 		ldr	r2, [sp, #52]
 8831 47b4 88009FE5 		ldr	r0, .L660+12
 8832 47b8 2310A0E3 		mov	r1, #35
 8833 47bc FEFFFFEB 		bl	cmdSet
 8834              	.LVL974:
 8835 47c0 24C09DE5 		ldr	ip, [sp, #36]
 8836 47c4 39FCFFEA 		b	.L425
 8837              	.LVL975:
 8838              	.L292:
 8839              	.LBE226:
 8840              	.LBE309:
 8841              	.LBE320:
 8842              	.LBE455:
 8843              	.LBB456:
 8844              	.LBB350:
 8845              	.LBB339:
 8846              	.LBB332:
 947:../uvc.c      **** 			   }
 8847              		.loc 1 947 0
 8848 47c8 0400A0E3 		mov	r0, #4
 8849              	.LVL976:
 8850 47cc 6C109FE5 		ldr	r1, .L660+8
 8851 47d0 FEFFFFEB 		bl	CyU3PDebugPrint
 8852              	.LVL977:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8853              		.loc 1 414 0
 8854 47d4 FF30A0E3 		mov	r3, #255
 8855 47d8 0380A0E1 		mov	r8, r3
 8856              	.LVL978:
 8857 47dc 03C0A0E1 		mov	ip, r3
 8858 47e0 1AF9FFEA 		b	.L290
 8859              	.LVL979:
 8860              	.L490:
 8861              	.LBE332:
 8862              	.LBE339:
 8863              	.LBE350:
 8864              	.LBE456:
 8865              	.LBB457:
 8866              	.LBB416:
 8867              	.LBB404:
 8868              	.LBB373:
 947:../uvc.c      **** 			   }
 8869              		.loc 1 947 0
 8870 47e4 54109FE5 		ldr	r1, .L660+8
 8871 47e8 0400A0E3 		mov	r0, #4
 8872              	.LVL980:
 8873 47ec FEFFFFEB 		bl	CyU3PDebugPrint
 8874              	.LVL981:
 8875 47f0 91FFFFEA 		b	.L610
 8876              	.LVL982:
 8877              	.L478:
 8878              	.LBE373:
 8879              	.LBE404:
 8880              	.LBB405:
 8881              	.LBB363:
 8882 47f4 0400A0E3 		mov	r0, #4
 8883              	.LVL983:
 8884 47f8 40109FE5 		ldr	r1, .L660+8
 8885 47fc FEFFFFEB 		bl	CyU3PDebugPrint
 8886              	.LVL984:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8887              		.loc 1 414 0
 8888 4800 FF30A0E3 		mov	r3, #255
 8889 4804 0370A0E1 		mov	r7, r3
 8890              	.LVL985:
 8891 4808 03C0A0E1 		mov	ip, r3
 8892 480c 1CFDFFEA 		b	.L476
 8893              	.LVL986:
 8894              	.L657:
 8895              	.LBE363:
 8896              	.LBE405:
 8897              	.LBB406:
 8898              	.LBB383:
 453:../uvc.c      **** 							sendData = 0; //set back to default
 8899              		.loc 1 453 0
 8900 4810 0120A0E3 		mov	r2, #1
 8901 4814 0400A0E3 		mov	r0, #4
 8902 4818 28109FE5 		ldr	r1, .L660+16
 8903 481c 24C08DE5 		str	ip, [sp, #36]
 8904 4820 FEFFFFEB 		bl	CyU3PDebugPrint
 8905              	.LVL987:
 455:../uvc.c      **** 						}
 8906              		.loc 1 455 0
 8907 4824 0020A0E3 		mov	r2, #0
 454:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 8908              		.loc 1 454 0
 8909 4828 0230A0E1 		mov	r3, r2
 455:../uvc.c      **** 						}
 8910              		.loc 1 455 0
 8911 482c 2D24CAE5 		strb	r2, [r10, #1069]
 8912 4830 24C09DE5 		ldr	ip, [sp, #36]
 8913 4834 5BFFFFEA 		b	.L464
 8914              	.L661:
 8915              		.align	2
 8916              	.L660:
 8917 4838 58000000 		.word	.LANCHOR0+88
 8918 483c 00000000 		.word	.LANCHOR1
 8919 4840 D4020000 		.word	.LC17
 8920 4844 00000000 		.word	cmdQu
 8921 4848 D8010000 		.word	.LC11
 8922              	.LBE383:
 8923              	.LBE406:
 8924              	.LBE416:
 8925              	.LBE457:
 8926              		.cfi_endproc
 8927              	.LFE24:
 8929              		.align	2
 8930              		.global	CyFxGpifCB
 8932              	CyFxGpifCB:
 8933              	.LFB12:
1700:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 8934              		.loc 1 1700 0
 8935              		.cfi_startproc
 8936              		@ args = 0, pretend = 0, frame = 0
 8937              		@ frame_needed = 0, uses_anonymous_args = 0
1701:../uvc.c      ****     {
 8938              		.loc 1 1701 0
 8939 484c 010050E3 		cmp	r0, #1
1700:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 8940              		.loc 1 1700 0
 8941 4850 10402DE9 		stmfd	sp!, {r4, lr}
 8942              	.LCFI22:
 8943              		.cfi_def_cfa_offset 8
 8944              		.cfi_offset 4, -8
 8945              		.cfi_offset 14, -4
1701:../uvc.c      ****     {
 8946              		.loc 1 1701 0
 8947 4854 1080BD18 		ldmnefd	sp!, {r4, pc}
 8948              	.LBB462:
 8949              	.LBB463:
1600:../uvc.c      ****     {
 8950              		.loc 1 1600 0
 8951 4858 C4309FE5 		ldr	r3, .L680
 8952 485c BC30D3E5 		ldrb	r3, [r3, #188]	@ zero_extendqisi2
 8953 4860 030053E3 		cmp	r3, #3
 8954 4864 1000000A 		beq	.L679
1624:../uvc.c      ****     {
 8955              		.loc 1 1624 0
 8956 4868 020053E3 		cmp	r3, #2
 8957 486c 1080BD18 		ldmnefd	sp!, {r4, pc}
1626:../uvc.c      ****         {
 8958              		.loc 1 1626 0
 8959 4870 083041E2 		sub	r3, r1, #8
 8960 4874 0A0053E3 		cmp	r3, #10
 8961 4878 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 8962 487c 200000EA 		b	.L672
 8963              	.L674:
 8964 4880 FC480000 		.word	.L666
 8965 4884 04490000 		.word	.L672
 8966 4888 04490000 		.word	.L672
 8967 488c CC480000 		.word	.L662
 8968 4890 04490000 		.word	.L672
 8969 4894 04490000 		.word	.L672
 8970 4898 04490000 		.word	.L672
 8971 489c D0480000 		.word	.L678
 8972 48a0 04490000 		.word	.L672
 8973 48a4 04490000 		.word	.L672
 8974 48a8 CC480000 		.word	.L662
 8975              	.L679:
1602:../uvc.c      ****         {
 8976              		.loc 1 1602 0
 8977 48ac 0B3041E2 		sub	r3, r1, #11
 8978 48b0 030053E3 		cmp	r3, #3
 8979 48b4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 8980 48b8 110000EA 		b	.L672
 8981              	.L667:
 8982 48bc FC480000 		.word	.L666
 8983 48c0 D0480000 		.word	.L678
 8984 48c4 CC480000 		.word	.L662
 8985 48c8 CC480000 		.word	.L662
 8986              	.L662:
 8987 48cc 1080BDE8 		ldmfd	sp!, {r4, pc}
 8988              	.L678:
1626:../uvc.c      ****         {
 8989              		.loc 1 1626 0
 8990 48d0 0110A0E3 		mov	r1, #1
 8991              	.L668:
1683:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 8992              		.loc 1 1683 0
 8993 48d4 4C009FE5 		ldr	r0, .L680+4
 8994 48d8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
1684:../uvc.c      ****         {
 8995              		.loc 1 1684 0
 8996 48dc 004050E2 		subs	r4, r0, #0
 8997 48e0 1080BD08 		ldmeqfd	sp!, {r4, pc}
1686:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 8998              		.loc 1 1686 0
 8999 48e4 0400A0E3 		mov	r0, #4
 9000 48e8 3C109FE5 		ldr	r1, .L680+8
 9001 48ec 0420A0E1 		mov	r2, r4
 9002 48f0 FEFFFFEB 		bl	CyU3PDebugPrint
1687:../uvc.c      ****         }
 9003              		.loc 1 1687 0
 9004 48f4 0400A0E1 		mov	r0, r4
 9005 48f8 FEFFFFEB 		bl	CyFxAppErrorHandler
 9006              	.L666:
1602:../uvc.c      ****         {
 9007              		.loc 1 1602 0
 9008 48fc 0010A0E3 		mov	r1, #0
 9009 4900 F3FFFFEA 		b	.L668
 9010              	.L672:
1672:../uvc.c      ****                 /* Unexpected current state. Return error. */
 9011              		.loc 1 1672 0
 9012 4904 0120A0E1 		mov	r2, r1
 9013 4908 0100A0E3 		mov	r0, #1
 9014 490c 1C109FE5 		ldr	r1, .L680+12
 9015 4910 FEFFFFEB 		bl	CyU3PDebugPrint
 9016              	.LBE463:
 9017              	.LBE462:
 9018              	.LBB464:
 9019              	.LBB465:
1705:../uvc.c      ****     }
 9020              		.loc 1 1705 0
 9021 4914 0400A0E3 		mov	r0, #4
 9022 4918 14109FE5 		ldr	r1, .L680+16
 9023              	.LBE465:
 9024              	.LBE464:
1707:../uvc.c      **** 
 9025              		.loc 1 1707 0
 9026 491c 1040BDE8 		ldmfd	sp!, {r4, lr}
 9027              	.LBB467:
 9028              	.LBB466:
1705:../uvc.c      ****     }
 9029              		.loc 1 1705 0
 9030 4920 FEFFFFEA 		b	CyU3PDebugPrint
 9031              	.L681:
 9032              		.align	2
 9033              	.L680:
 9034 4924 00000000 		.word	.LANCHOR0
 9035 4928 00000000 		.word	glChHandleUVCStream
 9036 492c 14070000 		.word	.LC40
 9037 4930 FC060000 		.word	.LC39
 9038 4934 44070000 		.word	.LC41
 9039              	.LBE466:
 9040              	.LBE467:
 9041              		.cfi_endproc
 9042              	.LFE12:
 9044              		.align	2
 9045              		.global	CyFxUVCApplnI2CInit
 9047              	CyFxUVCApplnI2CInit:
 9048              	.LFB14:
1763:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
 9049              		.loc 1 1763 0
 9050              		.cfi_startproc
 9051              		@ args = 0, pretend = 0, frame = 16
 9052              		@ frame_needed = 0, uses_anonymous_args = 0
 9053 4938 10402DE9 		stmfd	sp!, {r4, lr}
 9054              	.LCFI23:
 9055              		.cfi_def_cfa_offset 8
 9056              		.cfi_offset 4, -8
 9057              		.cfi_offset 14, -4
 9058 493c 10D04DE2 		sub	sp, sp, #16
 9059              	.LCFI24:
 9060              		.cfi_def_cfa_offset 24
1767:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 9061              		.loc 1 1767 0
 9062 4940 FEFFFFEB 		bl	CyU3PI2cInit
 9063              	.LVL988:
1768:../uvc.c      ****     {
 9064              		.loc 1 1768 0
 9065 4944 004050E2 		subs	r4, r0, #0
 9066 4948 0B00001A 		bne	.L685
1775:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 9067              		.loc 1 1775 0
 9068 494c 50209FE5 		ldr	r2, .L687
1777:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 9069              		.loc 1 1777 0
 9070 4950 0030E0E3 		mvn	r3, #0
1780:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 9071              		.loc 1 1780 0
 9072 4954 0410A0E1 		mov	r1, r4
 9073 4958 0D00A0E1 		mov	r0, sp
 9074              	.LVL989:
1775:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 9075              		.loc 1 1775 0
 9076 495c 14008DE8 		stmia	sp, {r2, r4}
1777:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 9077              		.loc 1 1777 0
 9078 4960 08308DE5 		str	r3, [sp, #8]
1778:../uvc.c      **** 
 9079              		.loc 1 1778 0
 9080 4964 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1780:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 9081              		.loc 1 1780 0
 9082 4968 FEFFFFEB 		bl	CyU3PI2cSetConfig
 9083              	.LVL990:
1781:../uvc.c      ****     {
 9084              		.loc 1 1781 0
 9085 496c 004050E2 		subs	r4, r0, #0
 9086 4970 0600001A 		bne	.L686
1786:../uvc.c      **** 
 9087              		.loc 1 1786 0
 9088 4974 10D08DE2 		add	sp, sp, #16
 9089              		@ sp needed
 9090 4978 1080BDE8 		ldmfd	sp!, {r4, pc}
 9091              	.L685:
1770:../uvc.c      ****         CyFxAppErrorHandler (status);
 9092              		.loc 1 1770 0
 9093 497c 0400A0E3 		mov	r0, #4
 9094              	.LVL991:
 9095 4980 20109FE5 		ldr	r1, .L687+4
 9096 4984 FEFFFFEB 		bl	CyU3PDebugPrint
 9097              	.LVL992:
1771:../uvc.c      ****     }
 9098              		.loc 1 1771 0
 9099 4988 0400A0E1 		mov	r0, r4
 9100 498c FEFFFFEB 		bl	CyFxAppErrorHandler
 9101              	.LVL993:
 9102              	.L686:
1783:../uvc.c      ****         CyFxAppErrorHandler (status);
 9103              		.loc 1 1783 0
 9104 4990 0400A0E3 		mov	r0, #4
 9105              	.LVL994:
 9106 4994 10109FE5 		ldr	r1, .L687+8
 9107 4998 FEFFFFEB 		bl	CyU3PDebugPrint
 9108              	.LVL995:
1784:../uvc.c      ****     }
 9109              		.loc 1 1784 0
 9110 499c 0400A0E1 		mov	r0, r4
 9111 49a0 FEFFFFEB 		bl	CyFxAppErrorHandler
 9112              	.LVL996:
 9113              	.L688:
 9114              		.align	2
 9115              	.L687:
 9116 49a4 A0860100 		.word	100000
 9117 49a8 58070000 		.word	.LC42
 9118 49ac 74070000 		.word	.LC43
 9119              		.cfi_endproc
 9120              	.LFE14:
 9122              		.align	2
 9123              		.global	UVCAppThread_Entry
 9125              	UVCAppThread_Entry:
 9126              	.LFB18:
2262:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 9127              		.loc 1 2262 0
 9128              		.cfi_startproc
 9129              		@ args = 0, pretend = 0, frame = 128
 9130              		@ frame_needed = 0, uses_anonymous_args = 0
 9131              	.LVL997:
 9132 49b0 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 9133              	.LCFI25:
 9134              		.cfi_def_cfa_offset 32
 9135              		.cfi_offset 4, -32
 9136              		.cfi_offset 5, -28
 9137              		.cfi_offset 6, -24
 9138              		.cfi_offset 7, -20
 9139              		.cfi_offset 8, -16
 9140              		.cfi_offset 9, -12
 9141              		.cfi_offset 10, -8
 9142              		.cfi_offset 14, -4
 9143 49b4 88D04DE2 		sub	sp, sp, #136
 9144              	.LCFI26:
 9145              		.cfi_def_cfa_offset 168
 9146              	.LBB474:
 9147              	.LBB475:
1718:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9148              		.loc 1 1718 0
 9149 49b8 FEFFFFEB 		bl	CyU3PUartInit
 9150              	.LVL998:
1719:../uvc.c      ****     {
 9151              		.loc 1 1719 0
 9152 49bc 004050E2 		subs	r4, r0, #0
 9153 49c0 E001001A 		bne	.L749
1726:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 9154              		.loc 1 1726 0
 9155 49c4 0C299FE5 		ldr	r2, .L778
1727:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 9156              		.loc 1 1727 0
 9157 49c8 0130A0E3 		mov	r3, #1
1735:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9158              		.loc 1 1735 0
 9159 49cc 0410A0E1 		mov	r1, r4
 9160 49d0 60008DE2 		add	r0, sp, #96
 9161              	.LVL999:
1728:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 9162              		.loc 1 1728 0
 9163 49d4 7540CDE5 		strb	r4, [sp, #117]
1730:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 9164              		.loc 1 1730 0
 9165 49d8 64408DE5 		str	r4, [sp, #100]
1731:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 9166              		.loc 1 1731 0
 9167 49dc 68408DE5 		str	r4, [sp, #104]
1726:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 9168              		.loc 1 1726 0
 9169 49e0 70208DE5 		str	r2, [sp, #112]
1727:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 9170              		.loc 1 1727 0
 9171 49e4 7430CDE5 		strb	r3, [sp, #116]
1729:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 9172              		.loc 1 1729 0
 9173 49e8 60308DE5 		str	r3, [sp, #96]
1732:../uvc.c      **** 
 9174              		.loc 1 1732 0
 9175 49ec 6C308DE5 		str	r3, [sp, #108]
1735:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9176              		.loc 1 1735 0
 9177 49f0 FEFFFFEB 		bl	CyU3PUartSetConfig
 9178              	.LVL1000:
1736:../uvc.c      ****     {
 9179              		.loc 1 1736 0
 9180 49f4 000050E3 		cmp	r0, #0
 9181 49f8 AD01001A 		bne	.L748
1742:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9182              		.loc 1 1742 0
 9183 49fc 0000E0E3 		mvn	r0, #0
 9184              	.LVL1001:
 9185 4a00 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 9186              	.LVL1002:
1743:../uvc.c      ****     {
 9187              		.loc 1 1743 0
 9188 4a04 000050E3 		cmp	r0, #0
 9189 4a08 A901001A 		bne	.L748
1749:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9190              		.loc 1 1749 0
 9191 4a0c 0300A0E3 		mov	r0, #3
 9192              	.LVL1003:
 9193 4a10 0410A0E3 		mov	r1, #4
 9194 4a14 FEFFFFEB 		bl	CyU3PDebugInit
 9195              	.LVL1004:
1750:../uvc.c      ****     {
 9196              		.loc 1 1750 0
 9197 4a18 000050E3 		cmp	r0, #0
 9198 4a1c A401001A 		bne	.L748
1756:../uvc.c      **** }
 9199              		.loc 1 1756 0
 9200 4a20 FEFFFFEB 		bl	CyU3PDebugPreamble
 9201              	.LVL1005:
 9202 4a24 0640A0E3 		mov	r4, #6
 9203              	.LVL1006:
 9204              	.L695:
 9205              	.LBE475:
 9206              	.LBE474:
2278:../uvc.c      **** 	}
 9207              		.loc 1 2278 0
 9208 4a28 7D0FA0E3 		mov	r0, #500
 9209 4a2c 014044E2 		sub	r4, r4, #1
 9210 4a30 FEFFFFEB 		bl	_tx_thread_sleep
 9211              	.LVL1007:
2277:../uvc.c      **** 		CyU3PThreadSleep(500);
 9212              		.loc 1 2277 0
 9213 4a34 FF4014E2 		ands	r4, r4, #255
 9214 4a38 FAFFFF1A 		bne	.L695
 9215              	.LBB477:
 9216              	.LBB478:
1854:../uvc.c      ****     if (apiRetStatus != 0)
 9217              		.loc 1 1854 0
 9218 4a3c 98789FE5 		ldr	r7, .L778+4
 9219              	.LBE478:
 9220              	.LBE477:
2281:../uvc.c      **** 
 9221              		.loc 1 2281 0
 9222 4a40 FEFFFFEB 		bl	CyFxUVCApplnI2CInit
 9223              	.LVL1008:
 9224              	.LBB482:
 9225              	.LBB479:
1854:../uvc.c      ****     if (apiRetStatus != 0)
 9226              		.loc 1 1854 0
 9227 4a44 0410A0E1 		mov	r1, r4
 9228 4a48 0700A0E1 		mov	r0, r7
 9229 4a4c 2820A0E3 		mov	r2, #40
 9230 4a50 FEFFFFEB 		bl	_txe_event_flags_create
 9231              	.LVL1009:
1855:../uvc.c      ****     {
 9232              		.loc 1 1855 0
 9233 4a54 005050E2 		subs	r5, r0, #0
 9234 4a58 0002001A 		bne	.L750
1869:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 9235              		.loc 1 1869 0
 9236 4a5c 0260A0E3 		mov	r6, #2
1872:../uvc.c      ****     gpioClock.halfDiv    = 0;
 9237              		.loc 1 1872 0
 9238 4a60 0380A0E3 		mov	r8, #3
1876:../uvc.c      ****     if (apiRetStatus != 0)
 9239              		.loc 1 1876 0
 9240 4a64 14008DE2 		add	r0, sp, #20
 9241              	.LVL1010:
 9242 4a68 0410A0E1 		mov	r1, r4
1865:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 9243              		.loc 1 1865 0
 9244 4a6c 444087E5 		str	r4, [r7, #68]
1866:../uvc.c      **** 
 9245              		.loc 1 1866 0
 9246 4a70 484087E5 		str	r4, [r7, #72]
1871:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 9247              		.loc 1 1871 0
 9248 4a74 1C40CDE5 		strb	r4, [sp, #28]
1873:../uvc.c      **** 
 9249              		.loc 1 1873 0
 9250 4a78 18408DE5 		str	r4, [sp, #24]
1869:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 9251              		.loc 1 1869 0
 9252 4a7c 1460CDE5 		strb	r6, [sp, #20]
1870:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 9253              		.loc 1 1870 0
 9254 4a80 1560CDE5 		strb	r6, [sp, #21]
1872:../uvc.c      ****     gpioClock.halfDiv    = 0;
 9255              		.loc 1 1872 0
 9256 4a84 1D80CDE5 		strb	r8, [sp, #29]
1876:../uvc.c      ****     if (apiRetStatus != 0)
 9257              		.loc 1 1876 0
 9258 4a88 FEFFFFEB 		bl	CyU3PGpioInit
 9259              	.LVL1011:
1877:../uvc.c      ****     {
 9260              		.loc 1 1877 0
 9261 4a8c 005050E2 		subs	r5, r0, #0
 9262 4a90 EC01001A 		bne	.L751
1885:../uvc.c      ****     if (apiRetStatus != 0)
 9263              		.loc 1 1885 0
 9264 4a94 1600A0E3 		mov	r0, #22
 9265              	.LVL1012:
 9266 4a98 0110A0E3 		mov	r1, #1
 9267 4a9c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9268              	.LVL1013:
1886:../uvc.c      ****     {
 9269              		.loc 1 1886 0
 9270 4aa0 005050E2 		subs	r5, r0, #0
 9271 4aa4 E101001A 		bne	.L752
1891:../uvc.c      ****     if (apiRetStatus != 0)
 9272              		.loc 1 1891 0
 9273 4aa8 1400A0E3 		mov	r0, #20
 9274              	.LVL1014:
 9275 4aac 0110A0E3 		mov	r1, #1
 9276 4ab0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9277              	.LVL1015:
1892:../uvc.c      ****     {
 9278              		.loc 1 1892 0
 9279 4ab4 005050E2 		subs	r5, r0, #0
 9280 4ab8 D601001A 		bne	.L753
1897:../uvc.c      ****     if (apiRetStatus != 0)
 9281              		.loc 1 1897 0
 9282 4abc 1800A0E3 		mov	r0, #24
 9283              	.LVL1016:
 9284 4ac0 0110A0E3 		mov	r1, #1
 9285 4ac4 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9286              	.LVL1017:
1898:../uvc.c      ****     {
 9287              		.loc 1 1898 0
 9288 4ac8 005050E2 		subs	r5, r0, #0
 9289 4acc FB01001A 		bne	.L754
1905:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9290              		.loc 1 1905 0
 9291 4ad0 0150A0E3 		mov	r5, #1
1910:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9292              		.loc 1 1910 0
 9293 4ad4 30108DE2 		add	r1, sp, #48
 9294 4ad8 1600A0E3 		mov	r0, #22
 9295              	.LVL1018:
1908:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9296              		.loc 1 1908 0
 9297 4adc 3C408DE5 		str	r4, [sp, #60]
1909:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 9298              		.loc 1 1909 0
 9299 4ae0 4040CDE5 		strb	r4, [sp, #64]
1905:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9300              		.loc 1 1905 0
 9301 4ae4 30508DE5 		str	r5, [sp, #48]
1906:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 9302              		.loc 1 1906 0
 9303 4ae8 34508DE5 		str	r5, [sp, #52]
1907:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 9304              		.loc 1 1907 0
 9305 4aec 38508DE5 		str	r5, [sp, #56]
1910:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9306              		.loc 1 1910 0
 9307 4af0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9308              	.LVL1019:
1911:../uvc.c      ****     {
 9309              		.loc 1 1911 0
 9310 4af4 009050E2 		subs	r9, r0, #0
 9311 4af8 EA01001A 		bne	.L755
1924:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9312              		.loc 1 1924 0
 9313 4afc 1400A0E3 		mov	r0, #20
 9314              	.LVL1020:
 9315 4b00 30108DE2 		add	r1, sp, #48
1919:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9316              		.loc 1 1919 0
 9317 4b04 30508DE5 		str	r5, [sp, #48]
1920:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 9318              		.loc 1 1920 0
 9319 4b08 34508DE5 		str	r5, [sp, #52]
1921:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 9320              		.loc 1 1921 0
 9321 4b0c 38508DE5 		str	r5, [sp, #56]
1922:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9322              		.loc 1 1922 0
 9323 4b10 3C408DE5 		str	r4, [sp, #60]
1923:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 9324              		.loc 1 1923 0
 9325 4b14 4040CDE5 		strb	r4, [sp, #64]
1924:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9326              		.loc 1 1924 0
 9327 4b18 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9328              	.LVL1021:
1925:../uvc.c      ****     {
 9329              		.loc 1 1925 0
 9330 4b1c 009050E2 		subs	r9, r0, #0
 9331 4b20 DA01001A 		bne	.L756
1938:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9332              		.loc 1 1938 0
 9333 4b24 30108DE2 		add	r1, sp, #48
 9334 4b28 1800A0E3 		mov	r0, #24
 9335              	.LVL1022:
1933:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 9336              		.loc 1 1933 0
 9337 4b2c 30408DE5 		str	r4, [sp, #48]
1934:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 9338              		.loc 1 1934 0
 9339 4b30 34408DE5 		str	r4, [sp, #52]
1935:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 9340              		.loc 1 1935 0
 9341 4b34 38408DE5 		str	r4, [sp, #56]
1936:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9342              		.loc 1 1936 0
 9343 4b38 3C508DE5 		str	r5, [sp, #60]
1937:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 9344              		.loc 1 1937 0
 9345 4b3c 4040CDE5 		strb	r4, [sp, #64]
1938:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9346              		.loc 1 1938 0
 9347 4b40 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9348              	.LVL1023:
1939:../uvc.c      ****     {
 9349              		.loc 1 1939 0
 9350 4b44 009050E2 		subs	r9, r0, #0
 9351 4b48 CA01001A 		bne	.L757
1951:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9352              		.loc 1 1951 0
 9353 4b4c 0500A0E1 		mov	r0, r5
 9354              	.LVL1024:
 9355 4b50 20108DE2 		add	r1, sp, #32
1948:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 9356              		.loc 1 1948 0
 9357 4b54 28408DE5 		str	r4, [sp, #40]
1949:../uvc.c      **** 
 9358              		.loc 1 1949 0
 9359 4b58 24408DE5 		str	r4, [sp, #36]
1946:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 9360              		.loc 1 1946 0
 9361 4b5c B062CDE1 		strh	r6, [sp, #32]	@ movhi
1947:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 9362              		.loc 1 1947 0
 9363 4b60 2C80CDE5 		strb	r8, [sp, #44]
1951:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9364              		.loc 1 1951 0
 9365 4b64 FEFFFFEB 		bl	CyU3PPibInit
 9366              	.LVL1025:
1952:../uvc.c      ****     {
 9367              		.loc 1 1952 0
 9368 4b68 004050E2 		subs	r4, r0, #0
 9369 4b6c A301001A 		bne	.L758
1959:../uvc.c      **** 
 9370              		.loc 1 1959 0
 9371 4b70 68079FE5 		ldr	r0, .L778+8
 9372              	.LVL1026:
 9373 4b74 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 9374              	.LVL1027:
1967:../uvc.c      ****     SensorInit ();
 9375              		.loc 1 1967 0
 9376 4b78 FEFFFFEB 		bl	SensorReset
 9377              	.LVL1028:
1968:../uvc.c      **** 
 9378              		.loc 1 1968 0
 9379 4b7c FEFFFFEB 		bl	SensorInit
 9380              	.LVL1029:
1971:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9381              		.loc 1 1971 0
 9382 4b80 FEFFFFEB 		bl	CyU3PUsbStart
 9383              	.LVL1030:
1972:../uvc.c      ****     {
 9384              		.loc 1 1972 0
 9385 4b84 004050E2 		subs	r4, r0, #0
 9386 4b88 9601001A 		bne	.L759
1978:../uvc.c      **** 
 9387              		.loc 1 1978 0
 9388 4b8c 0410A0E1 		mov	r1, r4
 9389 4b90 4C079FE5 		ldr	r0, .L778+12
 9390              	.LVL1031:
 9391 4b94 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 9392              	.LVL1032:
1981:../uvc.c      **** 
 9393              		.loc 1 1981 0
 9394 4b98 48079FE5 		ldr	r0, .L778+16
 9395 4b9c FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 9396              	.LVL1033:
1987:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 9397              		.loc 1 1987 0
 9398 4ba0 0410A0E1 		mov	r1, r4
 9399 4ba4 40279FE5 		ldr	r2, .L778+20
 9400 4ba8 0100A0E3 		mov	r0, #1
 9401 4bac FEFFFFEB 		bl	CyU3PUsbSetDesc
 9402              	.LVL1034:
1988:../uvc.c      **** 
 9403              		.loc 1 1988 0
 9404 4bb0 0410A0E1 		mov	r1, r4
 9405 4bb4 0400A0E1 		mov	r0, r4
 9406 4bb8 30279FE5 		ldr	r2, .L778+24
 9407 4bbc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9408              	.LVL1035:
1991:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 9409              		.loc 1 1991 0
 9410 4bc0 0410A0E1 		mov	r1, r4
 9411 4bc4 28279FE5 		ldr	r2, .L778+28
 9412 4bc8 0200A0E3 		mov	r0, #2
 9413 4bcc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9414              	.LVL1036:
1992:../uvc.c      **** 
 9415              		.loc 1 1992 0
 9416 4bd0 0410A0E1 		mov	r1, r4
 9417 4bd4 1C279FE5 		ldr	r2, .L778+32
 9418 4bd8 0700A0E3 		mov	r0, #7
 9419 4bdc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9420              	.LVL1037:
1995:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 9421              		.loc 1 1995 0
 9422 4be0 0410A0E1 		mov	r1, r4
 9423 4be4 10279FE5 		ldr	r2, .L778+36
 9424 4be8 0400A0E3 		mov	r0, #4
 9425 4bec FEFFFFEB 		bl	CyU3PUsbSetDesc
 9426              	.LVL1038:
1996:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 9427              		.loc 1 1996 0
 9428 4bf0 0410A0E1 		mov	r1, r4
 9429 4bf4 04279FE5 		ldr	r2, .L778+40
 9430 4bf8 0300A0E3 		mov	r0, #3
 9431 4bfc FEFFFFEB 		bl	CyU3PUsbSetDesc
 9432              	.LVL1039:
1997:../uvc.c      **** 
 9433              		.loc 1 1997 0
 9434 4c00 0410A0E1 		mov	r1, r4
 9435 4c04 F8269FE5 		ldr	r2, .L778+44
 9436 4c08 0600A0E3 		mov	r0, #6
 9437 4c0c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9438              	.LVL1040:
2000:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 9439              		.loc 1 2000 0
 9440 4c10 0410A0E1 		mov	r1, r4
 9441 4c14 EC269FE5 		ldr	r2, .L778+48
 9442 4c18 0500A0E3 		mov	r0, #5
 9443 4c1c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9444              	.LVL1041:
2001:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 9445              		.loc 1 2001 0
 9446 4c20 0110A0E3 		mov	r1, #1
 9447 4c24 E0269FE5 		ldr	r2, .L778+52
 9448 4c28 0500A0E3 		mov	r0, #5
 9449 4c2c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9450              	.LVL1042:
2002:../uvc.c      **** 
 9451              		.loc 1 2002 0
 9452 4c30 0210A0E3 		mov	r1, #2
 9453 4c34 D4269FE5 		ldr	r2, .L778+56
 9454 4c38 0500A0E3 		mov	r0, #5
 9455 4c3c FEFFFFEB 		bl	CyU3PUsbSetDesc
 9456              	.LVL1043:
2009:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 9457              		.loc 1 2009 0
 9458 4c40 0150A0E3 		mov	r5, #1
2010:../uvc.c      ****     endPointConfig.pcktSize = 64;
 9459              		.loc 1 2010 0
 9460 4c44 0320A0E3 		mov	r2, #3
2011:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 9461              		.loc 1 2011 0
 9462 4c48 4030A0E3 		mov	r3, #64
2015:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9463              		.loc 1 2015 0
 9464 4c4c 08108DE2 		add	r1, sp, #8
 9465 4c50 8200A0E3 		mov	r0, #130
2012:../uvc.c      ****     endPointConfig.streams  = 0;
 9466              		.loc 1 2012 0
 9467 4c54 1340CDE5 		strb	r4, [sp, #19]
2013:../uvc.c      ****     endPointConfig.burstLen = 1;
 9468              		.loc 1 2013 0
 9469 4c58 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2009:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 9470              		.loc 1 2009 0
 9471 4c5c 08508DE5 		str	r5, [sp, #8]
2014:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 9472              		.loc 1 2014 0
 9473 4c60 1250CDE5 		strb	r5, [sp, #18]
2010:../uvc.c      ****     endPointConfig.pcktSize = 64;
 9474              		.loc 1 2010 0
 9475 4c64 0C20CDE5 		strb	r2, [sp, #12]
2011:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 9476              		.loc 1 2011 0
 9477 4c68 B031CDE1 		strh	r3, [sp, #16]	@ movhi
2015:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9478              		.loc 1 2015 0
 9479 4c6c FEFFFFEB 		bl	CyU3PSetEpConfig
 9480              	.LVL1044:
2016:../uvc.c      ****     {
 9481              		.loc 1 2016 0
 9482 4c70 004050E2 		subs	r4, r0, #0
2019:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 9483              		.loc 1 2019 0
 9484 4c74 0400A013 		movne	r0, #4
 9485              	.LVL1045:
2016:../uvc.c      ****     {
 9486              		.loc 1 2016 0
 9487 4c78 3E01001A 		bne	.L746
2024:../uvc.c      ****     dmaInterConfig.count          = 1;
 9488              		.loc 1 2024 0
 9489 4c7c 90C69FE5 		ldr	ip, .L778+60
 9490 4c80 413BA0E3 		mov	r3, #66560
2033:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 9491              		.loc 1 2033 0
 9492 4c84 1060A0E3 		mov	r6, #16
2035:../uvc.c      ****             &dmaInterConfig);
 9493              		.loc 1 2035 0
 9494 4c88 88069FE5 		ldr	r0, .L778+64
 9495 4c8c 0410A0E3 		mov	r1, #4
 9496 4c90 44208DE2 		add	r2, sp, #68
2024:../uvc.c      ****     dmaInterConfig.count          = 1;
 9497              		.loc 1 2024 0
 9498 4c94 4C408DE5 		str	r4, [sp, #76]
 9499 4c98 50408DE5 		str	r4, [sp, #80]
2032:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 9500              		.loc 1 2032 0
 9501 4c9c 5440CDE5 		strb	r4, [sp, #84]
2034:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 9502              		.loc 1 2034 0
 9503 4ca0 5C408DE5 		str	r4, [sp, #92]
2024:../uvc.c      ****     dmaInterConfig.count          = 1;
 9504              		.loc 1 2024 0
 9505 4ca4 48C08DE5 		str	ip, [sp, #72]
 9506 4ca8 44308DE5 		str	r3, [sp, #68]
2033:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 9507              		.loc 1 2033 0
 9508 4cac 58608DE5 		str	r6, [sp, #88]
2035:../uvc.c      ****             &dmaInterConfig);
 9509              		.loc 1 2035 0
 9510 4cb0 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 9511              	.LVL1046:
2037:../uvc.c      ****     {
 9512              		.loc 1 2037 0
 9513 4cb4 004050E2 		subs	r4, r0, #0
 9514 4cb8 4401001A 		bne	.L760
2044:../uvc.c      ****     if (glInterStaBuffer == 0)
 9515              		.loc 1 2044 0
 9516 4cbc 010BA0E3 		mov	r0, #1024
 9517              	.LVL1047:
 9518 4cc0 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 9519              	.LVL1048:
 9520 4cc4 50369FE5 		ldr	r3, .L778+68
2045:../uvc.c      ****     {
 9521              		.loc 1 2045 0
 9522 4cc8 000050E3 		cmp	r0, #0
2044:../uvc.c      ****     if (glInterStaBuffer == 0)
 9523              		.loc 1 2044 0
 9524 4ccc 000083E5 		str	r0, [r3]
2045:../uvc.c      ****     {
 9525              		.loc 1 2045 0
 9526 4cd0 3901000A 		beq	.L761
2052:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 9527              		.loc 1 2052 0
 9528 4cd4 0410A0E1 		mov	r1, r4
 9529 4cd8 0420A0E1 		mov	r2, r4
 9530 4cdc 3830A0E3 		mov	r3, #56
 9531 4ce0 38069FE5 		ldr	r0, .L778+72
 9532 4ce4 FEFFFFEB 		bl	_txe_mutex_create
 9533              	.LVL1049:
2057:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 9534              		.loc 1 2057 0
 9535 4ce8 34169FE5 		ldr	r1, .L778+76
2058:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 9536              		.loc 1 2058 0
 9537 4cec 34269FE5 		ldr	r2, .L778+80
2065:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 9538              		.loc 1 2065 0
 9539 4cf0 34A69FE5 		ldr	r10, .L778+84
2054:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 9540              		.loc 1 2054 0
 9541 4cf4 0460A0E3 		mov	r6, #4
2056:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 9542              		.loc 1 2056 0
 9543 4cf8 01ECA0E3 		mov	lr, #256
2060:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 9544              		.loc 1 2060 0
 9545 4cfc 0CC0A0E3 		mov	ip, #12
2064:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 9546              		.loc 1 2064 0
 9547 4d00 1830A0E3 		mov	r3, #24
2057:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 9548              		.loc 1 2057 0
 9549 4d04 B816CDE1 		strh	r1, [sp, #104]	@ movhi
2058:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 9550              		.loc 1 2058 0
 9551 4d08 BE26CDE1 		strh	r2, [sp, #110]	@ movhi
2053:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 9552              		.loc 1 2053 0
 9553 4d0c 0199A0E3 		mov	r9, #16384
2055:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 9554              		.loc 1 2055 0
 9555 4d10 0280A0E3 		mov	r8, #2
2066:../uvc.c      ****             &dmaMultiConfig);
 9556              		.loc 1 2066 0
 9557 4d14 14069FE5 		ldr	r0, .L778+88
 9558 4d18 0710A0E3 		mov	r1, #7
 9559 4d1c 60208DE2 		add	r2, sp, #96
2059:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 9560              		.loc 1 2059 0
 9561 4d20 B647CDE1 		strh	r4, [sp, #118]	@ movhi
2062:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 9562              		.loc 1 2062 0
 9563 4d24 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
2063:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 9564              		.loc 1 2063 0
 9565 4d28 7E40CDE5 		strb	r4, [sp, #126]
2065:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 9566              		.loc 1 2065 0
 9567 4d2c 84A08DE5 		str	r10, [sp, #132]
2053:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 9568              		.loc 1 2053 0
 9569 4d30 B096CDE1 		strh	r9, [sp, #96]	@ movhi
2054:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 9570              		.loc 1 2054 0
 9571 4d34 B266CDE1 		strh	r6, [sp, #98]	@ movhi
2061:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 9572              		.loc 1 2061 0
 9573 4d38 BA67CDE1 		strh	r6, [sp, #122]	@ movhi
2055:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 9574              		.loc 1 2055 0
 9575 4d3c B486CDE1 		strh	r8, [sp, #100]	@ movhi
2056:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 9576              		.loc 1 2056 0
 9577 4d40 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
2060:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 9578              		.loc 1 2060 0
 9579 4d44 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
2064:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 9580              		.loc 1 2064 0
 9581 4d48 80308DE5 		str	r3, [sp, #128]
2066:../uvc.c      ****             &dmaMultiConfig);
 9582              		.loc 1 2066 0
 9583 4d4c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 9584              	.LVL1050:
2068:../uvc.c      ****     {
 9585              		.loc 1 2068 0
 9586 4d50 004050E2 		subs	r4, r0, #0
 9587 4d54 1201001A 		bne	.L762
2159:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9588              		.loc 1 2159 0
 9589 4d58 0500A0E1 		mov	r0, r5
 9590              	.LVL1051:
 9591 4d5c 0510A0E1 		mov	r1, r5
 9592 4d60 FEFFFFEB 		bl	CyU3PConnectState
 9593              	.LVL1052:
2160:../uvc.c      ****     {
 9594              		.loc 1 2160 0
 9595 4d64 004050E2 		subs	r4, r0, #0
 9596 4d68 0701001A 		bne	.L763
2166:../uvc.c      **** 
 9597              		.loc 1 2166 0
 9598 4d6c 6400A0E3 		mov	r0, #100
 9599              	.LVL1053:
 9600 4d70 FEFFFFEB 		bl	CyFx3BusyWait
 9601              	.LVL1054:
2168:../uvc.c      **** 
 9602              		.loc 1 2168 0
 9603 4d74 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 9604              	.LVL1055:
2183:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9605              		.loc 1 2183 0
 9606 4d78 08108DE2 		add	r1, sp, #8
2182:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 9607              		.loc 1 2182 0
 9608 4d7c BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2170:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 9609              		.loc 1 2170 0
 9610 4d80 08508DE5 		str	r5, [sp, #8]
2171:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 9611              		.loc 1 2171 0
 9612 4d84 0C80CDE5 		strb	r8, [sp, #12]
2175:../uvc.c      ****     }
 9613              		.loc 1 2175 0
 9614 4d88 030050E3 		cmp	r0, #3
2168:../uvc.c      **** 
 9615              		.loc 1 2168 0
 9616 4d8c 0030A0E1 		mov	r3, r0
2175:../uvc.c      ****     }
 9617              		.loc 1 2175 0
 9618 4d90 01C0A013 		movne	ip, #1
 9619 4d94 10C0A003 		moveq	ip, #16
 9620 4d98 022CA013 		movne	r2, #512
 9621 4d9c 012BA003 		moveq	r2, #1024
2183:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9622              		.loc 1 2183 0
 9623 4da0 8300A0E3 		mov	r0, #131
2168:../uvc.c      **** 
 9624              		.loc 1 2168 0
 9625 4da4 BC30C7E5 		strb	r3, [r7, #188]
 9626 4da8 12C0CDE5 		strb	ip, [sp, #18]
 9627 4dac B021CDE1 		strh	r2, [sp, #16]	@ movhi
2183:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9628              		.loc 1 2183 0
 9629 4db0 FEFFFFEB 		bl	CyU3PSetEpConfig
 9630              	.LVL1056:
2184:../uvc.c      ****     {
 9631              		.loc 1 2184 0
 9632 4db4 004050E2 		subs	r4, r0, #0
 9633              	.LBE479:
 9634              	.LBE482:
2305:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9635              		.loc 1 2305 0
 9636 4db8 1C459F05 		ldreq	r4, .L778+4
 9637              	.LBB483:
 9638              	.LBB480:
2184:../uvc.c      ****     {
 9639              		.loc 1 2184 0
 9640 4dbc 0C00000A 		beq	.L733
 9641 4dc0 EB0000EA 		b	.L777
 9642              	.LVL1057:
 9643              	.L766:
 9644              	.LBE480:
 9645              	.LBE483:
2351:../uvc.c      ****             {
 9646              		.loc 1 2351 0
 9647 4dc4 343094E5 		ldr	r3, [r4, #52]
 9648 4dc8 050053E1 		cmp	r3, r5
 9649 4dcc 0300000A 		beq	.L714
2351:../uvc.c      ****             {
 9650              		.loc 1 2351 0 is_stmt 0 discriminator 1
 9651 4dd0 B823D4E1 		ldrh	r2, [r4, #56]
 9652 4dd4 BA33D4E1 		ldrh	r3, [r4, #58]
 9653 4dd8 030052E1 		cmp	r2, r3
 9654 4ddc 3B00000A 		beq	.L765
 9655              	.L714:
2525:../uvc.c      **** 
 9656              		.loc 1 2525 0 is_stmt 1
 9657 4de0 4010A0E3 		mov	r1, #64
 9658 4de4 0020A0E3 		mov	r2, #0
 9659 4de8 EC049FE5 		ldr	r0, .L778+4
 9660 4dec FEFFFFEB 		bl	_txe_event_flags_set
 9661              	.LVL1058:
2528:../uvc.c      ****     }
 9662              		.loc 1 2528 0
 9663 4df0 FEFFFFEB 		bl	_txe_thread_relinquish
 9664              	.LVL1059:
 9665              	.L733:
2305:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9666              		.loc 1 2305 0
 9667 4df4 0050A0E3 		mov	r5, #0
 9668 4df8 00508DE5 		str	r5, [sp]
 9669 4dfc D8049FE5 		ldr	r0, .L778+4
 9670 4e00 0110A0E3 		mov	r1, #1
 9671 4e04 0220A0E3 		mov	r2, #2
 9672 4e08 60308DE2 		add	r3, sp, #96
 9673 4e0c FEFFFFEB 		bl	_txe_event_flags_get
 9674              	.LVL1060:
 9675 4e10 006050E2 		subs	r6, r0, #0
 9676 4e14 EAFFFF0A 		beq	.L766
2452:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9677              		.loc 1 2452 0
 9678 4e18 00508DE5 		str	r5, [sp]
 9679 4e1c B8049FE5 		ldr	r0, .L778+4
 9680 4e20 0210A0E3 		mov	r1, #2
 9681 4e24 0320A0E3 		mov	r2, #3
 9682 4e28 60308DE2 		add	r3, sp, #96
 9683 4e2c FEFFFFEB 		bl	_txe_event_flags_get
 9684              	.LVL1061:
 9685 4e30 000050E3 		cmp	r0, #0
 9686 4e34 0B00001A 		bne	.L725
2467:../uvc.c      ****                 {
 9687              		.loc 1 2467 0
 9688 4e38 483094E5 		ldr	r3, [r4, #72]
2455:../uvc.c      ****                 prodCount = 0;
 9689              		.loc 1 2455 0
 9690 4e3c 340084E5 		str	r0, [r4, #52]
2467:../uvc.c      ****                 {
 9691              		.loc 1 2467 0
 9692 4e40 000053E3 		cmp	r3, #0
2456:../uvc.c      ****                 consCount = 0;
 9693              		.loc 1 2456 0
 9694 4e44 B803C4E1 		strh	r0, [r4, #56]	@ movhi
2463:../uvc.c      ****                 pb=0;
 9695              		.loc 1 2463 0
 9696 4e48 B802C4E1 		strh	r0, [r4, #40]	@ movhi
2457:../uvc.c      ****                 if(0&&(prinflag == 0)){
 9697              		.loc 1 2457 0
 9698 4e4c BA03C4E1 		strh	r0, [r4, #58]	@ movhi
2464:../uvc.c      ****                 pbc=0;
 9699              		.loc 1 2464 0
 9700 4e50 BA02C4E1 		strh	r0, [r4, #42]	@ movhi
2465:../uvc.c      **** 
 9701              		.loc 1 2465 0
 9702 4e54 BC02C4E1 		strh	r0, [r4, #44]	@ movhi
2467:../uvc.c      ****                 {
 9703              		.loc 1 2467 0
 9704 4e58 4600000A 		beq	.L767
 9705              	.L726:
2479:../uvc.c      ****             }
 9706              		.loc 1 2479 0
 9707 4e5c 0030A0E3 		mov	r3, #0
 9708 4e60 483087E5 		str	r3, [r7, #72]
 9709 4e64 DDFFFFEA 		b	.L714
 9710              	.L725:
2484:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 9711              		.loc 1 2484 0
 9712 4e68 0030E0E3 		mvn	r3, #0
 9713 4e6c 00308DE5 		str	r3, [sp]
 9714 4e70 0110A0E3 		mov	r1, #1
 9715 4e74 0220A0E3 		mov	r2, #2
 9716 4e78 60308DE2 		add	r3, sp, #96
 9717 4e7c 58049FE5 		ldr	r0, .L778+4
 9718 4e80 FEFFFFEB 		bl	_txe_event_flags_get
 9719              	.LVL1062:
2488:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 9720              		.loc 1 2488 0
 9721 4e84 0510A0E1 		mov	r1, r5
 9722 4e88 0520A0E1 		mov	r2, r5
 9723 4e8c 9C049FE5 		ldr	r0, .L778+88
 9724 4e90 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 9725              	.LVL1063:
2489:../uvc.c      ****                 {
 9726              		.loc 1 2489 0
 9727 4e94 005050E2 		subs	r5, r0, #0
 9728 4e98 9300001A 		bne	.L768
2497:../uvc.c      ****                 {
 9729              		.loc 1 2497 0
 9730 4e9c 403094E5 		ldr	r3, [r4, #64]
 9731 4ea0 000053E3 		cmp	r3, #0
 9732 4ea4 2B00001A 		bne	.L724
 9733              	.LVL1064:
 9734              	.LBB484:
 9735              	.LBB485:
2212:../uvc.c      ****     {
 9736              		.loc 1 2212 0
 9737 4ea8 BC30D4E5 		ldrb	r3, [r4, #188]	@ zero_extendqisi2
 9738 4eac 030053E3 		cmp	r3, #3
 9739 4eb0 6800000A 		beq	.L769
2217:../uvc.c      ****     {
 9740              		.loc 1 2217 0
 9741 4eb4 020053E3 		cmp	r3, #2
 9742 4eb8 7E00000A 		beq	.L770
 9743              	.LVL1065:
 9744              	.L731:
 9745              	.LBE485:
 9746              	.LBE484:
2513:../uvc.c      ****                     CyU3PThreadSleep(200);
 9747              		.loc 1 2513 0
 9748 4ebc 0130A0E3 		mov	r3, #1
2514:../uvc.c      ****                     
 9749              		.loc 1 2514 0
 9750 4ec0 C800A0E3 		mov	r0, #200
2513:../uvc.c      ****                     CyU3PThreadSleep(200);
 9751              		.loc 1 2513 0
 9752 4ec4 403087E5 		str	r3, [r7, #64]
2514:../uvc.c      ****                     
 9753              		.loc 1 2514 0
 9754 4ec8 FEFFFFEB 		bl	_tx_thread_sleep
 9755              	.LVL1066:
 9756 4ecc C3FFFFEA 		b	.L714
 9757              	.L765:
2377:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 9758              		.loc 1 2377 0
 9759 4ed0 5C549FE5 		ldr	r5, .L778+92
2376:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 9760              		.loc 1 2376 0
 9761 4ed4 44049FE5 		ldr	r0, .L778+72
 9762 4ed8 0010E0E3 		mvn	r1, #0
2361:../uvc.c      ****                 consCount = 0;
 9763              		.loc 1 2361 0
 9764 4edc B863C4E1 		strh	r6, [r4, #56]	@ movhi
2358:../uvc.c      ****             	pb=0;
 9765              		.loc 1 2358 0
 9766 4ee0 B862C4E1 		strh	r6, [r4, #40]	@ movhi
2362:../uvc.c      ****                 hitFV     = CyFalse;
 9767              		.loc 1 2362 0
 9768 4ee4 BA63C4E1 		strh	r6, [r4, #58]	@ movhi
2359:../uvc.c      ****             	pbc=0;
 9769              		.loc 1 2359 0
 9770 4ee8 BA62C4E1 		strh	r6, [r4, #42]	@ movhi
2360:../uvc.c      ****                 prodCount = 0;
 9771              		.loc 1 2360 0
 9772 4eec BC62C4E1 		strh	r6, [r4, #44]	@ movhi
2363:../uvc.c      **** 
 9773              		.loc 1 2363 0
 9774 4ef0 346084E5 		str	r6, [r4, #52]
2376:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 9775              		.loc 1 2376 0
 9776 4ef4 FEFFFFEB 		bl	_txe_mutex_get
 9777              	.LVL1067:
2377:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 9778              		.loc 1 2377 0
 9779 4ef8 8134D5E5 		ldrb	r3, [r5, #1153]	@ zero_extendqisi2
 9780 4efc 013023E2 		eor	r3, r3, #1
 9781 4f00 8134C5E5 		strb	r3, [r5, #1153]
2379:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 9782              		.loc 1 2379 0
 9783 4f04 303094E5 		ldr	r3, [r4, #48]
 9784 4f08 F00053E3 		cmp	r3, #240
 9785 4f0c 4500000A 		beq	.L771
 9786              	.L715:
2387:../uvc.c      **** 
 9787              		.loc 1 2387 0
 9788 4f10 303097E5 		ldr	r3, [r7, #48]
 9789 4f14 FF0053E3 		cmp	r3, #255
 9790 4f18 1D00000A 		beq	.L772
2399:../uvc.c      ****                     //CyU3PThreadSleep(400);
 9791              		.loc 1 2399 0
 9792 4f1c 303094E5 		ldr	r3, [r4, #48]
 9793 4f20 AA0053E3 		cmp	r3, #170
 9794 4f24 2700000A 		beq	.L773
 9795              	.L716:
2427:../uvc.c      ****                 /* Reset the DMA channel. */
 9796              		.loc 1 2427 0
 9797 4f28 F0039FE5 		ldr	r0, .L778+72
 9798 4f2c FEFFFFEB 		bl	_txe_mutex_put
 9799              	.LVL1068:
2429:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 9800              		.loc 1 2429 0
 9801 4f30 F8039FE5 		ldr	r0, .L778+88
 9802 4f34 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 9803              	.LVL1069:
2430:../uvc.c      ****                 {
 9804              		.loc 1 2430 0
 9805 4f38 005050E2 		subs	r5, r0, #0
 9806 4f3c 7B00001A 		bne	.L774
2437:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 9807              		.loc 1 2437 0
 9808 4f40 0510A0E1 		mov	r1, r5
 9809 4f44 0520A0E1 		mov	r2, r5
 9810 4f48 E0039FE5 		ldr	r0, .L778+88
 9811              	.LVL1070:
 9812 4f4c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 9813              	.LVL1071:
2438:../uvc.c      ****                 {
 9814              		.loc 1 2438 0
 9815 4f50 005050E2 		subs	r5, r0, #0
 9816 4f54 5E00001A 		bne	.L775
 9817              	.L724:
2446:../uvc.c      ****                 }
 9818              		.loc 1 2446 0
 9819 4f58 C4039FE5 		ldr	r0, .L778+76
 9820              	.LVL1072:
 9821 4f5c 0230A0E3 		mov	r3, #2
 9822 4f60 0010A0E3 		mov	r1, #0
 9823 4f64 00308DE5 		str	r3, [sp]
 9824 4f68 0020A0E1 		mov	r2, r0
 9825 4f6c 0130A0E1 		mov	r3, r1
 9826 4f70 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 9827              	.LVL1073:
 9828 4f74 99FFFFEA 		b	.L714
 9829              	.LVL1074:
 9830              	.L767:
2469:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 9831              		.loc 1 2469 0
 9832 4f78 B0039FE5 		ldr	r0, .L778+88
 9833 4f7c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 9834              	.LVL1075:
2470:../uvc.c      ****                     {
 9835              		.loc 1 2470 0
 9836 4f80 000050E3 		cmp	r0, #0
 9837 4f84 4A00001A 		bne	.L748
2476:../uvc.c      ****                 }
 9838              		.loc 1 2476 0
 9839 4f88 8300A0E3 		mov	r0, #131
 9840              	.LVL1076:
 9841 4f8c FEFFFFEB 		bl	CyU3PUsbFlushEp
 9842              	.LVL1077:
 9843 4f90 B1FFFFEA 		b	.L726
 9844              	.L772:
2389:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 9845              		.loc 1 2389 0
 9846 4f94 E230D4E5 		ldrb	r3, [r4, #226]	@ zero_extendqisi2
 9847 4f98 020053E3 		cmp	r3, #2
 9848 4f9c 013083E2 		add	r3, r3, #1
 9849 4fa0 E230C4E5 		strb	r3, [r4, #226]
 9850 4fa4 DFFFFF9A 		bls	.L716
2390:../uvc.c      ****                 		stiflag = 0x0F;
 9851              		.loc 1 2390 0
 9852 4fa8 8114D5E5 		ldrb	r1, [r5, #1153]	@ zero_extendqisi2
2391:../uvc.c      ****                 		IMcount = 0;
 9853              		.loc 1 2391 0
 9854 4fac 0F30A0E3 		mov	r3, #15
2390:../uvc.c      ****                 		stiflag = 0x0F;
 9855              		.loc 1 2390 0
 9856 4fb0 201081E3 		orr	r1, r1, #32
2392:../uvc.c      ****                 		}
 9857              		.loc 1 2392 0
 9858 4fb4 0020A0E3 		mov	r2, #0
2390:../uvc.c      ****                 		stiflag = 0x0F;
 9859              		.loc 1 2390 0
 9860 4fb8 8114C5E5 		strb	r1, [r5, #1153]
2392:../uvc.c      ****                 		}
 9861              		.loc 1 2392 0
 9862 4fbc E220C4E5 		strb	r2, [r4, #226]
2391:../uvc.c      ****                 		IMcount = 0;
 9863              		.loc 1 2391 0
 9864 4fc0 303084E5 		str	r3, [r4, #48]
 9865 4fc4 D7FFFFEA 		b	.L716
 9866              	.L773:
2405:../uvc.c      ****                 	{
 9867              		.loc 1 2405 0
 9868 4fc8 E230D4E5 		ldrb	r3, [r4, #226]	@ zero_extendqisi2
 9869 4fcc 020053E3 		cmp	r3, #2
 9870 4fd0 013083E2 		add	r3, r3, #1
 9871 4fd4 E230C4E5 		strb	r3, [r4, #226]
 9872 4fd8 D2FFFF9A 		bls	.L716
2407:../uvc.c      ****                      {
 9873              		.loc 1 2407 0
 9874 4fdc E030D4E5 		ldrb	r3, [r4, #224]	@ zero_extendqisi2
 9875 4fe0 010053E3 		cmp	r3, #1
 9876 4fe4 4600000A 		beq	.L721
 9877 4fe8 020053E3 		cmp	r3, #2
 9878 4fec 0900001A 		bne	.L720
2415:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 9879              		.loc 1 2415 0
 9880 4ff0 3010A0E3 		mov	r1, #48
 9881 4ff4 0120A0E3 		mov	r2, #1
 9882 4ff8 5230A0E3 		mov	r3, #82
 9883 4ffc 0B00A0E3 		mov	r0, #11
 9884 5000 FEFFFFEB 		bl	SensorSetIrisControl
 9885              	.LVL1078:
2417:../uvc.c      ****                  		break;
 9886              		.loc 1 2417 0
 9887 5004 0400A0E3 		mov	r0, #4
 9888 5008 28139FE5 		ldr	r1, .L778+96
 9889 500c 0B20A0E3 		mov	r2, #11
 9890 5010 0130A0E3 		mov	r3, #1
 9891 5014 FEFFFFEB 		bl	CyU3PDebugPrint
 9892              	.LVL1079:
 9893              	.L720:
2422:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 9894              		.loc 1 2422 0
 9895 5018 0030A0E3 		mov	r3, #0
 9896 501c E230C7E5 		strb	r3, [r7, #226]
2424:../uvc.c      ****                 	}
 9897              		.loc 1 2424 0
 9898 5020 303087E5 		str	r3, [r7, #48]
 9899 5024 BFFFFFEA 		b	.L716
 9900              	.L771:
2379:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 9901              		.loc 1 2379 0 discriminator 1
 9902 5028 00608DE5 		str	r6, [sp]
 9903 502c A8029FE5 		ldr	r0, .L778+4
 9904 5030 8010A0E3 		mov	r1, #128
 9905 5034 0320A0E3 		mov	r2, #3
 9906 5038 60308DE2 		add	r3, sp, #96
 9907 503c FEFFFFEB 		bl	_txe_event_flags_get
 9908              	.LVL1080:
 9909 5040 000050E3 		cmp	r0, #0
 9910 5044 B1FFFF1A 		bne	.L715
2384:../uvc.c      ****                 		IMcount = 0;
 9911              		.loc 1 2384 0
 9912 5048 FF30A0E3 		mov	r3, #255
2385:../uvc.c      ****                 	}
 9913              		.loc 1 2385 0
 9914 504c E200C4E5 		strb	r0, [r4, #226]
2384:../uvc.c      ****                 		IMcount = 0;
 9915              		.loc 1 2384 0
 9916 5050 303084E5 		str	r3, [r4, #48]
2385:../uvc.c      ****                 	}
 9917              		.loc 1 2385 0
 9918 5054 B3FFFFEA 		b	.L716
 9919              	.LVL1081:
 9920              	.L769:
 9921              	.LBB488:
 9922              	.LBB486:
2214:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 9923              		.loc 1 2214 0
 9924 5058 DC129FE5 		ldr	r1, .L778+100
 9925 505c 0100A0E3 		mov	r0, #1
 9926              	.LVL1082:
 9927 5060 FEFFFFEB 		bl	CyU3PDebugPrint
 9928              	.LVL1083:
2215:../uvc.c      ****     }
 9929              		.loc 1 2215 0
 9930 5064 D4029FE5 		ldr	r0, .L778+104
 9931 5068 FEFFFFEB 		bl	CyU3PGpifLoad
 9932              	.LVL1084:
 9933 506c 0050A0E1 		mov	r5, r0
 9934              	.LVL1085:
 9935              	.L730:
2222:../uvc.c      ****     {
 9936              		.loc 1 2222 0
 9937 5070 000055E3 		cmp	r5, #0
 9938 5074 3800001A 		bne	.L776
 9939              	.LVL1086:
2234:../uvc.c      ****     {
 9940              		.loc 1 2234 0
 9941 5078 BC30D7E5 		ldrb	r3, [r7, #188]	@ zero_extendqisi2
 9942 507c 023043E2 		sub	r3, r3, #2
 9943 5080 FF3003E2 		and	r3, r3, #255
 9944 5084 010053E3 		cmp	r3, #1
 9945 5088 8BFFFF8A 		bhi	.L731
2232:../uvc.c      ****     }
 9946              		.loc 1 2232 0
 9947 508c 0500A0E1 		mov	r0, r5
 9948 5090 0510A0E1 		mov	r1, r5
 9949 5094 FEFFFFEB 		bl	CyU3PGpifSMStart
 9950              	.LVL1087:
2238:../uvc.c      ****     {
 9951              		.loc 1 2238 0
 9952 5098 005050E2 		subs	r5, r0, #0
 9953 509c 86FFFF0A 		beq	.L731
2241:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 9954              		.loc 1 2241 0
 9955 50a0 0400A0E3 		mov	r0, #4
 9956              	.LVL1088:
 9957 50a4 98129FE5 		ldr	r1, .L778+108
 9958 50a8 0520A0E1 		mov	r2, r5
 9959 50ac FEFFFFEB 		bl	CyU3PDebugPrint
 9960              	.LVL1089:
2242:../uvc.c      ****     }
 9961              		.loc 1 2242 0
 9962 50b0 0500A0E1 		mov	r0, r5
 9963              	.LVL1090:
 9964              	.L748:
2226:../uvc.c      ****     }
 9965              		.loc 1 2226 0
 9966 50b4 FEFFFFEB 		bl	CyFxAppErrorHandler
 9967              	.LVL1091:
 9968              	.L770:
2219:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 9969              		.loc 1 2219 0
 9970 50b8 88129FE5 		ldr	r1, .L778+112
 9971 50bc 0100A0E3 		mov	r0, #1
 9972              	.LVL1092:
 9973 50c0 FEFFFFEB 		bl	CyU3PDebugPrint
 9974              	.LVL1093:
2220:../uvc.c      ****     }
 9975              		.loc 1 2220 0
 9976 50c4 80029FE5 		ldr	r0, .L778+116
 9977 50c8 FEFFFFEB 		bl	CyU3PGpifLoad
 9978              	.LVL1094:
 9979 50cc 0050A0E1 		mov	r5, r0
 9980              	.LVL1095:
 9981 50d0 E6FFFFEA 		b	.L730
 9982              	.LVL1096:
 9983              	.L775:
 9984              	.LBE486:
 9985              	.LBE488:
2440:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 9986              		.loc 1 2440 0
 9987 50d4 0400A0E3 		mov	r0, #4
 9988              	.LVL1097:
 9989 50d8 70129FE5 		ldr	r1, .L778+120
 9990 50dc 0520A0E1 		mov	r2, r5
 9991 50e0 FEFFFFEB 		bl	CyU3PDebugPrint
 9992              	.LVL1098:
2441:../uvc.c      ****                 }
 9993              		.loc 1 2441 0
 9994 50e4 0500A0E1 		mov	r0, r5
 9995 50e8 FEFFFFEB 		bl	CyFxAppErrorHandler
 9996              	.LVL1099:
 9997              	.L768:
2492:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 9998              		.loc 1 2492 0
 9999 50ec 0400A0E3 		mov	r0, #4
 10000              	.LVL1100:
 10001 50f0 5C129FE5 		ldr	r1, .L778+124
 10002 50f4 0520A0E1 		mov	r2, r5
 10003 50f8 FEFFFFEB 		bl	CyU3PDebugPrint
 10004              	.LVL1101:
2493:../uvc.c      ****                 }
 10005              		.loc 1 2493 0
 10006 50fc 0500A0E1 		mov	r0, r5
 10007 5100 FEFFFFEB 		bl	CyFxAppErrorHandler
 10008              	.LVL1102:
 10009              	.L721:
2410:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 10010              		.loc 1 2410 0
 10011 5104 3010A0E3 		mov	r1, #48
 10012 5108 0020A0E3 		mov	r2, #0
 10013 510c 5230A0E3 		mov	r3, #82
 10014 5110 0B00A0E3 		mov	r0, #11
 10015 5114 FEFFFFEB 		bl	SensorSetIrisControl
 10016              	.LVL1103:
2412:../uvc.c      ****                  		break;
 10017              		.loc 1 2412 0
 10018 5118 18129FE5 		ldr	r1, .L778+96
 10019 511c 0B20A0E3 		mov	r2, #11
 10020 5120 0030A0E3 		mov	r3, #0
 10021 5124 0400A0E3 		mov	r0, #4
 10022 5128 FEFFFFEB 		bl	CyU3PDebugPrint
 10023              	.LVL1104:
2413:../uvc.c      ****                  	case 2: //720
 10024              		.loc 1 2413 0
 10025 512c B9FFFFEA 		b	.L720
 10026              	.LVL1105:
 10027              	.L774:
2432:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10028              		.loc 1 2432 0
 10029 5130 0400A0E3 		mov	r0, #4
 10030              	.LVL1106:
 10031 5134 1C129FE5 		ldr	r1, .L778+128
 10032 5138 0520A0E1 		mov	r2, r5
 10033 513c FEFFFFEB 		bl	CyU3PDebugPrint
 10034              	.LVL1107:
2433:../uvc.c      ****                 }
 10035              		.loc 1 2433 0
 10036 5140 0500A0E1 		mov	r0, r5
 10037 5144 FEFFFFEB 		bl	CyFxAppErrorHandler
 10038              	.LVL1108:
 10039              	.L749:
 10040              	.LBB489:
 10041              	.LBB476:
1721:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10042              		.loc 1 1721 0
 10043 5148 0400A0E3 		mov	r0, #4
 10044              	.LVL1109:
 10045 514c 08129FE5 		ldr	r1, .L778+132
 10046 5150 FEFFFFEB 		bl	CyU3PDebugPrint
 10047              	.LVL1110:
1722:../uvc.c      ****     }
 10048              		.loc 1 1722 0
 10049 5154 0400A0E1 		mov	r0, r4
 10050 5158 FEFFFFEB 		bl	CyFxAppErrorHandler
 10051              	.LVL1111:
 10052              	.L776:
 10053              	.LBE476:
 10054              	.LBE489:
 10055              	.LBB490:
 10056              	.LBB487:
2225:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10057              		.loc 1 2225 0
 10058 515c 0400A0E3 		mov	r0, #4
 10059              	.LVL1112:
 10060 5160 F8119FE5 		ldr	r1, .L778+136
 10061 5164 0520A0E1 		mov	r2, r5
 10062 5168 FEFFFFEB 		bl	CyU3PDebugPrint
 10063              	.LVL1113:
2226:../uvc.c      ****     }
 10064              		.loc 1 2226 0
 10065 516c 0500A0E1 		mov	r0, r5
 10066 5170 CFFFFFEA 		b	.L748
 10067              	.LVL1114:
 10068              	.L777:
 10069              	.LBE487:
 10070              	.LBE490:
 10071              	.LBB491:
 10072              	.LBB481:
2187:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10073              		.loc 1 2187 0
 10074 5174 0600A0E1 		mov	r0, r6
 10075              	.LVL1115:
 10076              	.L746:
 10077 5178 E4119FE5 		ldr	r1, .L778+140
 10078 517c 0420A0E1 		mov	r2, r4
 10079 5180 FEFFFFEB 		bl	CyU3PDebugPrint
 10080              	.LVL1116:
2188:../uvc.c      ****     }
 10081              		.loc 1 2188 0
 10082 5184 0400A0E1 		mov	r0, r4
 10083 5188 C9FFFFEA 		b	.L748
 10084              	.LVL1117:
 10085              	.L763:
2162:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10086              		.loc 1 2162 0
 10087 518c 0600A0E1 		mov	r0, r6
 10088              	.LVL1118:
 10089 5190 D0119FE5 		ldr	r1, .L778+144
 10090 5194 0420A0E1 		mov	r2, r4
 10091 5198 FEFFFFEB 		bl	CyU3PDebugPrint
 10092              	.LVL1119:
2163:../uvc.c      ****     }
 10093              		.loc 1 2163 0
 10094 519c 0400A0E1 		mov	r0, r4
 10095 51a0 FEFFFFEB 		bl	CyFxAppErrorHandler
 10096              	.LVL1120:
 10097              	.L762:
2071:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10098              		.loc 1 2071 0
 10099 51a4 0600A0E1 		mov	r0, r6
 10100              	.LVL1121:
 10101 51a8 BC119FE5 		ldr	r1, .L778+148
 10102 51ac 0420A0E1 		mov	r2, r4
 10103 51b0 FEFFFFEB 		bl	CyU3PDebugPrint
 10104              	.LVL1122:
2072:../uvc.c      ****     }
 10105              		.loc 1 2072 0
 10106 51b4 0400A0E1 		mov	r0, r4
 10107 51b8 FEFFFFEB 		bl	CyFxAppErrorHandler
 10108              	.LVL1123:
 10109              	.L761:
2047:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 10110              		.loc 1 2047 0
 10111 51bc 0400A0E3 		mov	r0, #4
 10112 51c0 A8119FE5 		ldr	r1, .L778+152
 10113 51c4 FEFFFFEB 		bl	CyU3PDebugPrint
 10114              	.LVL1124:
2048:../uvc.c      ****     }
 10115              		.loc 1 2048 0
 10116 51c8 0600A0E1 		mov	r0, r6
 10117 51cc FEFFFFEB 		bl	CyFxAppErrorHandler
 10118              	.LVL1125:
 10119              	.L760:
2040:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10120              		.loc 1 2040 0
 10121 51d0 0400A0E3 		mov	r0, #4
 10122              	.LVL1126:
 10123 51d4 98119FE5 		ldr	r1, .L778+156
 10124 51d8 0420A0E1 		mov	r2, r4
 10125 51dc FEFFFFEB 		bl	CyU3PDebugPrint
 10126              	.LVL1127:
2041:../uvc.c      ****     }
 10127              		.loc 1 2041 0
 10128 51e0 0400A0E1 		mov	r0, r4
 10129 51e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 10130              	.LVL1128:
 10131              	.L759:
1974:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10132              		.loc 1 1974 0
 10133 51e8 0400A0E3 		mov	r0, #4
 10134              	.LVL1129:
 10135 51ec 84119FE5 		ldr	r1, .L778+160
 10136 51f0 0420A0E1 		mov	r2, r4
 10137 51f4 FEFFFFEB 		bl	CyU3PDebugPrint
 10138              	.LVL1130:
1975:../uvc.c      ****     }
 10139              		.loc 1 1975 0
 10140 51f8 0400A0E1 		mov	r0, r4
 10141 51fc FEFFFFEB 		bl	CyFxAppErrorHandler
 10142              	.LVL1131:
 10143              	.L758:
1954:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10144              		.loc 1 1954 0
 10145 5200 0400A0E3 		mov	r0, #4
 10146              	.LVL1132:
 10147 5204 70119FE5 		ldr	r1, .L778+164
 10148 5208 0420A0E1 		mov	r2, r4
 10149 520c FEFFFFEB 		bl	CyU3PDebugPrint
 10150              	.LVL1133:
1955:../uvc.c      ****     }
 10151              		.loc 1 1955 0
 10152 5210 0400A0E1 		mov	r0, r4
 10153 5214 FEFFFFEB 		bl	CyFxAppErrorHandler
 10154              	.LVL1134:
 10155              	.L753:
1894:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10156              		.loc 1 1894 0
 10157 5218 0400A0E3 		mov	r0, #4
 10158              	.LVL1135:
 10159 521c 5C119FE5 		ldr	r1, .L778+168
 10160 5220 0520A0E1 		mov	r2, r5
 10161 5224 FEFFFFEB 		bl	CyU3PDebugPrint
 10162              	.LVL1136:
1895:../uvc.c      ****     }
 10163              		.loc 1 1895 0
 10164 5228 0500A0E1 		mov	r0, r5
 10165 522c FEFFFFEB 		bl	CyFxAppErrorHandler
 10166              	.LVL1137:
 10167              	.L752:
1888:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10168              		.loc 1 1888 0
 10169 5230 0400A0E3 		mov	r0, #4
 10170              	.LVL1138:
 10171 5234 48119FE5 		ldr	r1, .L778+172
 10172 5238 0520A0E1 		mov	r2, r5
 10173 523c FEFFFFEB 		bl	CyU3PDebugPrint
 10174              	.LVL1139:
1889:../uvc.c      ****     }
 10175              		.loc 1 1889 0
 10176 5240 0500A0E1 		mov	r0, r5
 10177 5244 FEFFFFEB 		bl	CyFxAppErrorHandler
 10178              	.LVL1140:
 10179              	.L751:
1879:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10180              		.loc 1 1879 0
 10181 5248 0400A0E3 		mov	r0, #4
 10182              	.LVL1141:
 10183 524c 34119FE5 		ldr	r1, .L778+176
 10184 5250 0520A0E1 		mov	r2, r5
 10185 5254 FEFFFFEB 		bl	CyU3PDebugPrint
 10186              	.LVL1142:
1880:../uvc.c      ****     }
 10187              		.loc 1 1880 0
 10188 5258 0500A0E1 		mov	r0, r5
 10189 525c FEFFFFEB 		bl	CyFxAppErrorHandler
 10190              	.LVL1143:
 10191              	.L750:
1857:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10192              		.loc 1 1857 0
 10193 5260 0400A0E3 		mov	r0, #4
 10194              	.LVL1144:
 10195 5264 20119FE5 		ldr	r1, .L778+180
 10196 5268 0520A0E1 		mov	r2, r5
 10197 526c FEFFFFEB 		bl	CyU3PDebugPrint
 10198              	.LVL1145:
1858:../uvc.c      ****     }
 10199              		.loc 1 1858 0
 10200 5270 0500A0E1 		mov	r0, r5
 10201 5274 FEFFFFEB 		bl	CyFxAppErrorHandler
 10202              	.LVL1146:
 10203              	.L757:
1941:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10204              		.loc 1 1941 0
 10205 5278 0400A0E3 		mov	r0, #4
 10206              	.LVL1147:
 10207 527c 0C119FE5 		ldr	r1, .L778+184
 10208 5280 0920A0E1 		mov	r2, r9
 10209 5284 FEFFFFEB 		bl	CyU3PDebugPrint
 10210              	.LVL1148:
1942:../uvc.c      ****     }
 10211              		.loc 1 1942 0
 10212 5288 0900A0E1 		mov	r0, r9
 10213 528c FEFFFFEB 		bl	CyFxAppErrorHandler
 10214              	.LVL1149:
 10215              	.L756:
1927:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10216              		.loc 1 1927 0
 10217 5290 0400A0E3 		mov	r0, #4
 10218              	.LVL1150:
 10219 5294 F8109FE5 		ldr	r1, .L778+188
 10220 5298 0920A0E1 		mov	r2, r9
 10221 529c FEFFFFEB 		bl	CyU3PDebugPrint
 10222              	.LVL1151:
1928:../uvc.c      ****     }
 10223              		.loc 1 1928 0
 10224 52a0 0900A0E1 		mov	r0, r9
 10225 52a4 FEFFFFEB 		bl	CyFxAppErrorHandler
 10226              	.LVL1152:
 10227              	.L755:
1913:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10228              		.loc 1 1913 0
 10229 52a8 0400A0E3 		mov	r0, #4
 10230              	.LVL1153:
 10231 52ac E4109FE5 		ldr	r1, .L778+192
 10232 52b0 0920A0E1 		mov	r2, r9
 10233 52b4 FEFFFFEB 		bl	CyU3PDebugPrint
 10234              	.LVL1154:
1914:../uvc.c      ****     }
 10235              		.loc 1 1914 0
 10236 52b8 0900A0E1 		mov	r0, r9
 10237 52bc FEFFFFEB 		bl	CyFxAppErrorHandler
 10238              	.LVL1155:
 10239              	.L754:
1900:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10240              		.loc 1 1900 0
 10241 52c0 0400A0E3 		mov	r0, #4
 10242              	.LVL1156:
 10243 52c4 D0109FE5 		ldr	r1, .L778+196
 10244 52c8 0520A0E1 		mov	r2, r5
 10245 52cc FEFFFFEB 		bl	CyU3PDebugPrint
 10246              	.LVL1157:
1901:../uvc.c      ****     }
 10247              		.loc 1 1901 0
 10248 52d0 0500A0E1 		mov	r0, r5
 10249 52d4 FEFFFFEB 		bl	CyFxAppErrorHandler
 10250              	.LVL1158:
 10251              	.L779:
 10252              		.align	2
 10253              	.L778:
 10254 52d8 00C20100 		.word	115200
 10255 52dc 00000000 		.word	.LANCHOR0
 10256 52e0 00000000 		.word	CyFxGpifCB
 10257 52e4 00000000 		.word	CyFxUVCApplnUSBSetupCB
 10258 52e8 00000000 		.word	CyFxUVCApplnUSBEventCB
 10259 52ec 00000000 		.word	CyFxUSBDeviceDscr
 10260 52f0 00000000 		.word	CyFxUSBDeviceDscrSS
 10261 52f4 00000000 		.word	CyFxUSBDeviceQualDscr
 10262 52f8 00000000 		.word	CyFxUSBBOSDscr
 10263 52fc 00000000 		.word	CyFxUSBHSConfigDscr
 10264 5300 00000000 		.word	CyFxUSBFSConfigDscr
 10265 5304 00000000 		.word	CyFxUSBSSConfigDscr
 10266 5308 00000000 		.word	CyFxUSBStringLangIDDscr
 10267 530c 00000000 		.word	CyFxUSBManufactureDscr
 10268 5310 00000000 		.word	CyFxUSBProductDscr
 10269 5314 013F0203 		.word	50478849
 10270 5318 00000000 		.word	glChHandleInterStat
 10271 531c 00000000 		.word	glInterStaBuffer
 10272 5320 00000000 		.word	imgHdMux
 10273 5324 01010000 		.word	257
 10274 5328 03030000 		.word	771
 10275 532c 00000000 		.word	CyFxUvcApplnDmaCallback
 10276 5330 00000000 		.word	glChHandleUVCStream
 10277 5334 00000000 		.word	.LANCHOR1
 10278 5338 840A0000 		.word	.LC60
 10279 533c 3C0B0000 		.word	.LC64
 10280 5340 20000000 		.word	.LANCHOR2+32
 10281 5344 940B0000 		.word	.LC67
 10282 5348 4C0B0000 		.word	.LC65
 10283 534c 3C000000 		.word	.LANCHOR2+60
 10284 5350 D40A0000 		.word	.LC62
 10285 5354 080B0000 		.word	.LC63
 10286 5358 A80A0000 		.word	.LC61
 10287 535c 90070000 		.word	.LC44
 10288 5360 5C0B0000 		.word	.LC66
 10289 5364 80090000 		.word	.LC55
 10290 5368 5C0A0000 		.word	.LC59
 10291 536c 2C0A0000 		.word	.LC58
 10292 5370 F4090000 		.word	.LC57
 10293 5374 B4090000 		.word	.LC56
 10294 5378 50090000 		.word	.LC54
 10295 537c 20090000 		.word	.LC53
 10296 5380 28080000 		.word	.LC48
 10297 5384 00080000 		.word	.LC47
 10298 5388 DC070000 		.word	.LC46
 10299 538c B0070000 		.word	.LC45
 10300 5390 E8080000 		.word	.LC52
 10301 5394 B4080000 		.word	.LC51
 10302 5398 80080000 		.word	.LC50
 10303 539c 54080000 		.word	.LC49
 10304              	.LBE481:
 10305              	.LBE491:
 10306              		.cfi_endproc
 10307              	.LFE18:
 10309              		.align	2
 10310              		.global	CyFxApplicationDefine
 10312              	CyFxApplicationDefine:
 10313              	.LFB26:
3792:../uvc.c      **** }
3793:../uvc.c      **** 
3794:../uvc.c      **** 
3795:../uvc.c      **** /*
3796:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3797:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3798:../uvc.c      ****  */
3799:../uvc.c      **** void
3800:../uvc.c      **** CyFxApplicationDefine (
3801:../uvc.c      ****         void)
3802:../uvc.c      **** {
 10314              		.loc 1 3802 0
 10315              		.cfi_startproc
 10316              		@ args = 0, pretend = 0, frame = 40
 10317              		@ frame_needed = 0, uses_anonymous_args = 0
 10318              	.LVL1159:
 10319 53a0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 10320              	.LCFI27:
 10321              		.cfi_def_cfa_offset 36
 10322              		.cfi_offset 4, -36
 10323              		.cfi_offset 5, -32
 10324              		.cfi_offset 6, -28
 10325              		.cfi_offset 7, -24
 10326              		.cfi_offset 8, -20
 10327              		.cfi_offset 9, -16
 10328              		.cfi_offset 10, -12
 10329              		.cfi_offset 11, -8
 10330              		.cfi_offset 14, -4
3803:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3804:../uvc.c      ****     uint32_t retThrdCreate;
3805:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3806:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3807:../uvc.c      **** 
3808:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3809:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10331              		.loc 1 3809 0
 10332 53a4 010AA0E3 		mov	r0, #4096
3802:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 10333              		.loc 1 3802 0
 10334 53a8 4CD04DE2 		sub	sp, sp, #76
 10335              	.LCFI28:
 10336              		.cfi_def_cfa_offset 112
 10337              		.loc 1 3809 0
 10338 53ac FEFFFFEB 		bl	CyU3PMemAlloc
 10339              	.LVL1160:
 10340 53b0 00A0A0E1 		mov	r10, r0
 10341              	.LVL1161:
3810:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10342              		.loc 1 3810 0
 10343 53b4 010AA0E3 		mov	r0, #4096
 10344              	.LVL1162:
 10345 53b8 FEFFFFEB 		bl	CyU3PMemAlloc
 10346              	.LVL1163:
 10347 53bc 0090A0E1 		mov	r9, r0
 10348              	.LVL1164:
3811:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10349              		.loc 1 3811 0
 10350 53c0 010AA0E3 		mov	r0, #4096
 10351              	.LVL1165:
 10352 53c4 FEFFFFEB 		bl	CyU3PMemAlloc
 10353              	.LVL1166:
3812:../uvc.c      **** 
3813:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 10354              		.loc 1 3813 0
 10355 53c8 000059E3 		cmp	r9, #0
 10356 53cc 00005A13 		cmpne	r10, #0
 10357 53d0 00C0A013 		movne	ip, #0
 10358 53d4 01C0A003 		moveq	ip, #1
3811:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10359              		.loc 1 3811 0
 10360 53d8 00B0A0E1 		mov	fp, r0
 10361              	.LVL1167:
 10362              		.loc 1 3813 0
 10363 53dc 0000001A 		bne	.L791
 10364              	.LVL1168:
 10365              	.L781:
 10366              	.L783:
 10367 53e0 FEFFFFEA 		b	.L783
 10368              	.LVL1169:
 10369              	.L791:
 10370              		.loc 1 3813 0 is_stmt 0 discriminator 1
 10371 53e4 000050E3 		cmp	r0, #0
 10372 53e8 FCFFFF0A 		beq	.L781
3814:../uvc.c      ****         goto fatalErrorHandler;
3815:../uvc.c      **** 
3816:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3817:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 10373              		.loc 1 3817 0 is_stmt 1
 10374 53ec 28008DE2 		add	r0, sp, #40
 10375              	.LVL1170:
 10376 53f0 4010A0E3 		mov	r1, #64
 10377 53f4 0C219FE5 		ldr	r2, .L792
 10378 53f8 28708DE2 		add	r7, sp, #40
 10379 53fc 24C08DE5 		str	ip, [sp, #36]
 10380 5400 FEFFFFEB 		bl	cmdbufCreate
 10381              	.LVL1171:
 10382 5404 0F00B7E8 		ldmia	r7!, {r0, r1, r2, r3}
 10383 5408 FC509FE5 		ldr	r5, .L792+4
3818:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10384              		.loc 1 3818 0
 10385 540c FC409FE5 		ldr	r4, .L792+8
3817:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10386              		.loc 1 3817 0
 10387 5410 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 10388 5414 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
3819:../uvc.c      **** 
3820:../uvc.c      **** 	/****** initialize command descriptor ***********/
3821:../uvc.c      **** 	cmdquInit(cmdQuptr);
3822:../uvc.c      **** 	cmdquInit(statQuptr);
3823:../uvc.c      **** 
3824:../uvc.c      ****     /* Create the UVC application thread. */
3825:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 10389              		.loc 1 3825 0
 10390 5418 0860A0E3 		mov	r6, #8
3817:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10391              		.loc 1 3817 0
 10392 541c 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
3818:../uvc.c      **** 
 10393              		.loc 1 3818 0
 10394 5420 EC209FE5 		ldr	r2, .L792+12
 10395 5424 28008DE2 		add	r0, sp, #40
 10396 5428 2010A0E3 		mov	r1, #32
 10397 542c FEFFFFEB 		bl	cmdbufCreate
 10398              	.LVL1172:
 10399 5430 28E08DE2 		add	lr, sp, #40
 10400 5434 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 10401              		.loc 1 3825 0
 10402 5438 0180A0E3 		mov	r8, #1
3818:../uvc.c      **** 
 10403              		.loc 1 3818 0
 10404 543c 0F00A4E8 		stmia	r4!, {r0, r1, r2, r3}
 10405 5440 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
 10406              		.loc 1 3825 0
 10407 5444 A870A0E3 		mov	r7, #168
3818:../uvc.c      **** 
 10408              		.loc 1 3818 0
 10409 5448 0F0084E8 		stmia	r4, {r0, r1, r2, r3}
3821:../uvc.c      **** 	cmdquInit(statQuptr);
 10410              		.loc 1 3821 0
 10411 544c 100045E2 		sub	r0, r5, #16
 10412 5450 FEFFFFEB 		bl	cmdquInit
 10413              	.LVL1173:
3822:../uvc.c      **** 
 10414              		.loc 1 3822 0
 10415 5454 100044E2 		sub	r0, r4, #16
 10416 5458 FEFFFFEB 		bl	cmdquInit
 10417              	.LVL1174:
 10418              		.loc 1 3825 0
 10419 545c 24C09DE5 		ldr	ip, [sp, #36]
 10420 5460 012AA0E3 		mov	r2, #4096
 10421 5464 0C30A0E1 		mov	r3, ip
 10422 5468 44008DE9 		stmib	sp, {r2, r6}
 10423 546c A4009FE5 		ldr	r0, .L792+16
 10424 5470 00A08DE5 		str	r10, [sp]
 10425 5474 10C08DE5 		str	ip, [sp, #16]
 10426 5478 0C608DE5 		str	r6, [sp, #12]
 10427 547c 14808DE5 		str	r8, [sp, #20]
 10428 5480 18708DE5 		str	r7, [sp, #24]
 10429 5484 90109FE5 		ldr	r1, .L792+20
 10430 5488 90209FE5 		ldr	r2, .L792+24
 10431 548c FEFFFFEB 		bl	_txe_thread_create
 10432              	.LVL1175:
3826:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3827:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3828:../uvc.c      ****             0,                                          /* No input parameter to thread */
3829:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3830:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3831:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3832:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3833:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3834:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3835:../uvc.c      ****             );
3836:../uvc.c      ****     if (retThrdCreate != 0)
 10433              		.loc 1 3836 0
 10434 5490 003050E2 		subs	r3, r0, #0
 10435 5494 D1FFFF1A 		bne	.L781
3837:../uvc.c      ****     {
3838:../uvc.c      ****         goto fatalErrorHandler;
3839:../uvc.c      ****     }
3840:../uvc.c      **** 
3841:../uvc.c      ****     /* Create the control request handling thread. */
3842:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 10436              		.loc 1 3842 0
 10437 5498 024BA0E3 		mov	r4, #2048
 10438 549c 10308DE5 		str	r3, [sp, #16]
 10439 54a0 00908DE5 		str	r9, [sp]
 10440 54a4 08608DE5 		str	r6, [sp, #8]
 10441 54a8 0C608DE5 		str	r6, [sp, #12]
 10442 54ac 14808DE5 		str	r8, [sp, #20]
 10443 54b0 18708DE5 		str	r7, [sp, #24]
 10444 54b4 04408DE5 		str	r4, [sp, #4]
 10445 54b8 64009FE5 		ldr	r0, .L792+28
 10446              	.LVL1176:
 10447 54bc 64109FE5 		ldr	r1, .L792+32
 10448 54c0 64209FE5 		ldr	r2, .L792+36
 10449 54c4 FEFFFFEB 		bl	_txe_thread_create
 10450              	.LVL1177:
3843:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3844:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3845:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3846:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3847:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3848:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3849:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3850:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3851:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3852:../uvc.c      ****             );
3853:../uvc.c      ****     if (retThrdCreate != 0)
 10451              		.loc 1 3853 0
 10452 54c8 003050E2 		subs	r3, r0, #0
 10453 54cc C3FFFF1A 		bne	.L781
3854:../uvc.c      ****     {
3855:../uvc.c      ****         goto fatalErrorHandler;
3856:../uvc.c      ****     }
3857:../uvc.c      **** #if 1
3858:../uvc.c      ****     /* Create the I2C control command handling thread. */
3859:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 10454              		.loc 1 3859 0
 10455 54d0 00B08DE5 		str	fp, [sp]
 10456 54d4 50008DE9 		stmib	sp, {r4, r6}
 10457 54d8 50009FE5 		ldr	r0, .L792+40
 10458              	.LVL1178:
 10459 54dc 0C608DE5 		str	r6, [sp, #12]
 10460 54e0 10308DE5 		str	r3, [sp, #16]
 10461 54e4 14808DE5 		str	r8, [sp, #20]
 10462 54e8 18708DE5 		str	r7, [sp, #24]
 10463 54ec 40109FE5 		ldr	r1, .L792+44
 10464 54f0 40209FE5 		ldr	r2, .L792+48
 10465 54f4 FEFFFFEB 		bl	_txe_thread_create
 10466              	.LVL1179:
3860:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3861:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3862:../uvc.c      ****             0,                                          /* No input parameter to thread */
3863:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3864:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3865:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3866:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3867:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3868:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3869:../uvc.c      ****             );
3870:../uvc.c      ****     if (retThrdCreate != 0)
 10467              		.loc 1 3870 0
 10468 54f8 000050E3 		cmp	r0, #0
 10469 54fc B7FFFF1A 		bne	.L781
3871:../uvc.c      ****     {
3872:../uvc.c      ****         goto fatalErrorHandler;
3873:../uvc.c      ****     }
3874:../uvc.c      **** #endif
3875:../uvc.c      **** 
3876:../uvc.c      ****     return;
3877:../uvc.c      **** 
3878:../uvc.c      **** fatalErrorHandler:
3879:../uvc.c      ****     /* Add custom recovery or debug actions here */
3880:../uvc.c      ****     /* Loop indefinitely */
3881:../uvc.c      ****     while (1);
3882:../uvc.c      **** }
 10470              		.loc 1 3882 0
 10471 5500 4CD08DE2 		add	sp, sp, #76
 10472              		@ sp needed
 10473 5504 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 10474              	.LVL1180:
 10475              	.L793:
 10476              		.align	2
 10477              	.L792:
 10478 5508 00000000 		.word	cmdQuMux
 10479 550c 00000000 		.word	cmdQu
 10480 5510 00000000 		.word	statQu
 10481 5514 00000000 		.word	staQuMux
 10482 5518 E4000000 		.word	.LANCHOR0+228
 10483 551c CC0B0000 		.word	.LC68
 10484 5520 00000000 		.word	UVCAppThread_Entry
 10485 5524 8C010000 		.word	.LANCHOR0+396
 10486 5528 E00B0000 		.word	.LC69
 10487 552c 00000000 		.word	UVCAppEP0Thread_Entry
 10488 5530 34020000 		.word	.LANCHOR0+564
 10489 5534 F80B0000 		.word	.LC70
 10490 5538 00000000 		.word	I2cAppThread_Entry
 10491              		.cfi_endproc
 10492              	.LFE26:
 10494              		.section	.text.startup,"ax",%progbits
 10495              		.align	2
 10496              		.global	main
 10498              	main:
 10499              	.LFB27:
3883:../uvc.c      **** 
3884:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3885:../uvc.c      ****  * the ThreadX RTOS here.
3886:../uvc.c      ****  */
3887:../uvc.c      **** int
3888:../uvc.c      **** main (
3889:../uvc.c      ****         void)
3890:../uvc.c      **** {
 10500              		.loc 1 3890 0
 10501              		.cfi_startproc
 10502              		@ args = 0, pretend = 0, frame = 56
 10503              		@ frame_needed = 0, uses_anonymous_args = 0
 10504 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 10505              	.LCFI29:
 10506              		.cfi_def_cfa_offset 12
 10507              		.cfi_offset 4, -12
 10508              		.cfi_offset 5, -8
 10509              		.cfi_offset 14, -4
 10510 0004 3CD04DE2 		sub	sp, sp, #60
 10511              	.LCFI30:
 10512              		.cfi_def_cfa_offset 72
3891:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3892:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3893:../uvc.c      **** 
3894:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3895:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3896:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10513              		.loc 1 3896 0
 10514 0008 0230A0E3 		mov	r3, #2
3897:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3898:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3899:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 10515              		.loc 1 3899 0
 10516 000c 0010A0E3 		mov	r1, #0
3900:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 10517              		.loc 1 3900 0
 10518 0010 0320A0E3 		mov	r2, #3
3895:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10519              		.loc 1 3895 0
 10520 0014 0150A0E3 		mov	r5, #1
3901:../uvc.c      **** 
3902:../uvc.c      ****     /* Initialize the device */
3903:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 10521              		.loc 1 3903 0
 10522 0018 0D00A0E1 		mov	r0, sp
3895:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10523              		.loc 1 3895 0
 10524 001c 00508DE5 		str	r5, [sp]
3896:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 10525              		.loc 1 3896 0
 10526 0020 0430CDE5 		strb	r3, [sp, #4]
3897:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 10527              		.loc 1 3897 0
 10528 0024 0530CDE5 		strb	r3, [sp, #5]
3898:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 10529              		.loc 1 3898 0
 10530 0028 0630CDE5 		strb	r3, [sp, #6]
3899:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 10531              		.loc 1 3899 0
 10532 002c 08108DE5 		str	r1, [sp, #8]
3900:../uvc.c      **** 
 10533              		.loc 1 3900 0
 10534 0030 0C20CDE5 		strb	r2, [sp, #12]
 10535              		.loc 1 3903 0
 10536 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 10537              	.LVL1181:
3904:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10538              		.loc 1 3904 0
 10539 0038 004050E2 		subs	r4, r0, #0
 10540 003c 0000000A 		beq	.L799
 10541              	.L795:
 10542              	.L796:
 10543 0040 FEFFFFEA 		b	.L796
 10544              	.L799:
3905:../uvc.c      ****     {
3906:../uvc.c      ****         goto handle_fatal_error;
3907:../uvc.c      ****     }
3908:../uvc.c      **** 
3909:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3910:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 10545              		.loc 1 3910 0
 10546 0044 0410A0E1 		mov	r1, r4
 10547 0048 0420A0E1 		mov	r2, r4
 10548 004c 0500A0E1 		mov	r0, r5
 10549              	.LVL1182:
 10550 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 10551              	.LVL1183:
3911:../uvc.c      **** 
3912:../uvc.c      ****     /* Configure the IO matrix for the device. */
3913:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3914:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3915:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3916:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3917:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3918:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3919:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3920:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3921:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3922:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3923:../uvc.c      **** 
3924:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 10552              		.loc 1 3924 0
 10553 0054 10008DE2 		add	r0, sp, #16
3914:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 10554              		.loc 1 3914 0
 10555 0058 2640CDE5 		strb	r4, [sp, #38]
3915:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 10556              		.loc 1 3915 0
 10557 005c 28408DE5 		str	r4, [sp, #40]
3916:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 10558              		.loc 1 3916 0
 10559 0060 2C408DE5 		str	r4, [sp, #44]
3917:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 10560              		.loc 1 3917 0
 10561 0064 30408DE5 		str	r4, [sp, #48]
3918:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 10562              		.loc 1 3918 0
 10563 0068 34408DE5 		str	r4, [sp, #52]
3921:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 10564              		.loc 1 3921 0
 10565 006c 1C408DE5 		str	r4, [sp, #28]
3922:../uvc.c      **** 
 10566              		.loc 1 3922 0
 10567 0070 20408DE5 		str	r4, [sp, #32]
3913:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 10568              		.loc 1 3913 0
 10569 0074 10508DE5 		str	r5, [sp, #16]
3919:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 10570              		.loc 1 3919 0
 10571 0078 14508DE5 		str	r5, [sp, #20]
3920:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 10572              		.loc 1 3920 0
 10573 007c 18508DE5 		str	r5, [sp, #24]
 10574              		.loc 1 3924 0
 10575 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 10576              	.LVL1184:
3925:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10577              		.loc 1 3925 0
 10578 0084 004050E2 		subs	r4, r0, #0
 10579 0088 ECFFFF1A 		bne	.L795
3926:../uvc.c      ****     {
3927:../uvc.c      ****         goto handle_fatal_error;
3928:../uvc.c      ****     }
3929:../uvc.c      **** 
3930:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3931:../uvc.c      ****     CyU3PKernelEntry ();
 10580              		.loc 1 3931 0
 10581 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 10582              	.LVL1185:
3932:../uvc.c      **** 
3933:../uvc.c      ****     /* Dummy return to make the compiler happy */
3934:../uvc.c      ****     return 0;
3935:../uvc.c      **** 
3936:../uvc.c      **** handle_fatal_error:
3937:../uvc.c      ****     /* Cannot recover from this error. */
3938:../uvc.c      ****     while (1);
3939:../uvc.c      **** }
 10583              		.loc 1 3939 0
 10584 0090 0400A0E1 		mov	r0, r4
 10585 0094 3CD08DE2 		add	sp, sp, #60
 10586              		@ sp needed
 10587 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 10588              		.cfi_endproc
 10589              	.LFE27:
 10591              		.comm	I2CCmdTimer,44,4
 10592              		.comm	posTick,4,4
 10593              		.global	glUVCHeader
 10594              		.global	glProbeStilCtrl20
 10595              		.global	glProbeCtrl20
 10596              		.global	glProbeStilCtrl
 10597              		.global	glProbeCtrl
 10598              		.global	streamingStarted
 10599              		.global	clearFeatureRqtReceived
 10600              		.global	usbSpeed
 10601              		.global	isUsbConnected
 10602              		.global	pbcpbak
 10603              		.global	pbcbak
 10604              		.global	pbbak
 10605              		.global	fbbak
 10606              		.global	pbc
 10607              		.global	pb
 10608              		.global	fb
 10609              		.comm	wLength,2,2
 10610              		.comm	wIndex,2,2
 10611              		.comm	wValue,2,2
 10612              		.comm	bRequest,1,1
 10613              		.comm	bmReqType,1,1
 10614              		.comm	imgHdMux,56,4
 10615              		.comm	timMux,56,4
 10616              		.comm	staQuMux,56,4
 10617              		.comm	cmdQuMux,56,4
 10618              		.comm	statQu,32,4
 10619              		.comm	cmdQu,32,4
 10620              		.global	testSnap
 10621              		.global	snapButFlag
 10622              		.comm	glInterStaBuffer,4,4
 10623              		.comm	glChHandleInterStat,172,4
 10624              		.comm	glChHandleStillStream,232,4
 10625              		.comm	glChHandleUVCStream,232,4
 10626              		.global	CyFxGpifConfig_usb2
 10627              		.global	CyFxGpifRegValue_usb2
 10628              		.global	CyFxGpifWavedataPosition_usb2
 10629              		.global	CyFxGpifWavedata_usb2
 10630              		.global	CyFxGpifTransition_usb2
 10631              		.global	CyFxGpifConfig
 10632              		.global	CyFxGpifRegValue
 10633              		.global	CyFxGpifWavedataPosition
 10634              		.global	CyFxGpifWavedata
 10635              		.global	CyFxGpifTransition
 10636              		.section	.rodata
 10637              		.align	2
 10638              		.set	.LANCHOR2,. + 0
 10641              	ExTime:
 10642 0000 9C       		.byte	-100
 10643 0001 00       		.byte	0
 10644 0002 4E       		.byte	78
 10645 0003 00       		.byte	0
 10646 0004 27       		.byte	39
 10647 0005 00       		.byte	0
 10648 0006 14       		.byte	20
 10649 0007 00       		.byte	0
 10650 0008 0A       		.byte	10
 10651 0009 00       		.byte	0
 10652 000a 05       		.byte	5
 10653 000b 00       		.byte	0
 10654 000c 02       		.byte	2
 10655 000d 00       		.byte	0
 10656 000e 01       		.byte	1
 10657 000f 00       		.byte	0
 10660              	ShutValueArry:
 10661 0010 C800     		.short	200
 10662 0012 6400     		.short	100
 10663 0014 2700     		.short	39
 10664 0016 1400     		.short	20
 10665 0018 0A00     		.short	10
 10666 001a 0500     		.short	5
 10667 001c 0200     		.short	2
 10668 001e 0100     		.short	1
 10671              	CyFxGpifConfig:
 10672 0020 0F00     		.short	15
 10673 0022 0000     		.space	2
 10674 0024 00000000 		.word	CyFxGpifWavedata
 10675 0028 00000000 		.word	CyFxGpifWavedataPosition
 10676 002c 0500     		.short	5
 10677 002e 0000     		.space	2
 10678 0030 00000000 		.word	CyFxGpifTransition
 10679 0034 4C00     		.short	76
 10680 0036 0000     		.space	2
 10681 0038 00000000 		.word	CyFxGpifRegValue
 10684              	CyFxGpifConfig_usb2:
 10685 003c 9300     		.short	147
 10686 003e 0000     		.space	2
 10687 0040 00000000 		.word	CyFxGpifWavedata_usb2
 10688 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 10689 0048 0800     		.short	8
 10690 004a 0000     		.space	2
 10691 004c 00000000 		.word	CyFxGpifTransition_usb2
 10692 0050 4C00     		.short	76
 10693 0052 0000     		.space	2
 10694 0054 00000000 		.word	CyFxGpifRegValue_usb2
 10695              		.data
 10696              		.align	2
 10697              		.set	.LANCHOR1,. + 0
 10700              	ExUCtrlParArry:
 10701 0000 00       		.byte	0
 10702 0001 00       		.byte	0
 10703 0002 04       		.byte	4
 10704 0003 01       		.byte	1
 10705 0004 00       		.byte	0
 10706 0005 38       		.byte	56
 10707 0006 01       		.byte	1
 10708 0007 01       		.byte	1
 10709 0008 00       		.byte	0
 10710 0009 03       		.byte	3
 10711 000a 00       		.byte	0
 10712 000b 4E       		.byte	78
 10713 000c 00       		.byte	0
 10714 000d 4E       		.byte	78
 10715 000e 00       		.byte	0
 10716 000f 30       		.byte	48
 10717 0010 01       		.byte	1
 10718 0011 00       		.byte	0
 10719 0012 00       		.byte	0
 10720 0013 00000000 		.space	5
 10720      00
 10721 0018 00       		.byte	0
 10722 0019 00       		.byte	0
 10723 001a 01       		.byte	1
 10724 001b 00       		.byte	0
 10725 001c 00       		.byte	0
 10726 001d 00       		.byte	0
 10727 001e 00       		.byte	0
 10728 001f 01       		.byte	1
 10729 0020 00       		.byte	0
 10730 0021 03       		.byte	3
 10731 0022 00       		.byte	0
 10732 0023 00       		.byte	0
 10733 0024 00       		.byte	0
 10734 0025 00       		.byte	0
 10735 0026 00       		.byte	0
 10736 0027 30       		.byte	48
 10737 0028 01       		.byte	1
 10738 0029 00       		.byte	0
 10739 002a 00       		.byte	0
 10740 002b 00000000 		.space	5
 10740      00
 10741 0030 00       		.byte	0
 10742 0031 00       		.byte	0
 10743 0032 02       		.byte	2
 10744 0033 00       		.byte	0
 10745 0034 00       		.byte	0
 10746 0035 FF       		.byte	-1
 10747 0036 00       		.byte	0
 10748 0037 01       		.byte	1
 10749 0038 00       		.byte	0
 10750 0039 03       		.byte	3
 10751 003a 00       		.byte	0
 10752 003b 01       		.byte	1
 10753 003c 00       		.byte	0
 10754 003d 00       		.byte	0
 10755 003e 00       		.byte	0
 10756 003f 30       		.byte	48
 10757 0040 01       		.byte	1
 10758 0041 01       		.byte	1
 10759 0042 00       		.byte	0
 10760 0043 00000000 		.space	5
 10760      00
 10761 0048 00       		.byte	0
 10762 0049 00       		.byte	0
 10763 004a 02       		.byte	2
 10764 004b 00       		.byte	0
 10765 004c 00       		.byte	0
 10766 004d 00       		.byte	0
 10767 004e 00       		.byte	0
 10768 004f 00       		.byte	0
 10769 0050 00       		.byte	0
 10770 0051 03       		.byte	3
 10771 0052 00       		.byte	0
 10772 0053 00       		.byte	0
 10773 0054 00       		.byte	0
 10774 0055 00       		.byte	0
 10775 0056 00       		.byte	0
 10776 0057 30       		.byte	48
 10777 0058 01       		.byte	1
 10778 0059 01       		.byte	1
 10779 005a 00       		.byte	0
 10780 005b 00000000 		.space	5
 10780      00
 10781 0060 13       		.byte	19
 10782 0061 14       		.byte	20
 10783 0062 02       		.byte	2
 10784 0063 01       		.byte	1
 10785 0064 00       		.byte	0
 10786 0065 03       		.byte	3
 10787 0066 00       		.byte	0
 10788 0067 01       		.byte	1
 10789 0068 00       		.byte	0
 10790 0069 03       		.byte	3
 10791 006a 00       		.byte	0
 10792 006b 23       		.byte	35
 10793 006c 37       		.byte	55
 10794 006d 23       		.byte	35
 10795 006e 37       		.byte	55
 10796 006f 30       		.byte	48
 10797 0070 01       		.byte	1
 10798 0071 00       		.byte	0
 10799 0072 00       		.byte	0
 10800 0073 00000000 		.space	5
 10800      00
 10801 0078 11       		.byte	17
 10802 0079 00       		.byte	0
 10803 007a 02       		.byte	2
 10804 007b 01       		.byte	1
 10805 007c 00       		.byte	0
 10806 007d 03       		.byte	3
 10807 007e 00       		.byte	0
 10808 007f 01       		.byte	1
 10809 0080 00       		.byte	0
 10810 0081 03       		.byte	3
 10811 0082 00       		.byte	0
 10812 0083 01       		.byte	1
 10813 0084 00       		.byte	0
 10814 0085 01       		.byte	1
 10815 0086 00       		.byte	0
 10816 0087 30       		.byte	48
 10817 0088 01       		.byte	1
 10818 0089 01       		.byte	1
 10819 008a 00       		.byte	0
 10820 008b 00000000 		.space	5
 10820      00
 10821 0090 17       		.byte	23
 10822 0091 00       		.byte	0
 10823 0092 01       		.byte	1
 10824 0093 01       		.byte	1
 10825 0094 00       		.byte	0
 10826 0095 02       		.byte	2
 10827 0096 00       		.byte	0
 10828 0097 01       		.byte	1
 10829 0098 00       		.byte	0
 10830 0099 03       		.byte	3
 10831 009a 00       		.byte	0
 10832 009b 00       		.byte	0
 10833 009c 00       		.byte	0
 10834 009d 00       		.byte	0
 10835 009e 00       		.byte	0
 10836 009f 30       		.byte	48
 10837 00a0 01       		.byte	1
 10838 00a1 01       		.byte	1
 10839 00a2 00       		.byte	0
 10840 00a3 00000000 		.space	5
 10840      00
 10841 00a8 00       		.byte	0
 10842 00a9 00       		.byte	0
 10843 00aa 04       		.byte	4
 10844 00ab 01       		.byte	1
 10845 00ac 00       		.byte	0
 10846 00ad 38       		.byte	56
 10847 00ae 01       		.byte	1
 10848 00af 01       		.byte	1
 10849 00b0 00       		.byte	0
 10850 00b1 03       		.byte	3
 10851 00b2 00       		.byte	0
 10852 00b3 4E       		.byte	78
 10853 00b4 00       		.byte	0
 10854 00b5 4E       		.byte	78
 10855 00b6 00       		.byte	0
 10856 00b7 30       		.byte	48
 10857 00b8 01       		.byte	1
 10858 00b9 00       		.byte	0
 10859 00ba 00       		.byte	0
 10860 00bb 00000000 		.space	5
 10860      00
 10861 00c0 00       		.byte	0
 10862 00c1 00       		.byte	0
 10863 00c2 01       		.byte	1
 10864 00c3 00       		.byte	0
 10865 00c4 00       		.byte	0
 10866 00c5 00       		.byte	0
 10867 00c6 00       		.byte	0
 10868 00c7 01       		.byte	1
 10869 00c8 00       		.byte	0
 10870 00c9 03       		.byte	3
 10871 00ca 00       		.byte	0
 10872 00cb 00       		.byte	0
 10873 00cc 00       		.byte	0
 10874 00cd 00       		.byte	0
 10875 00ce 00       		.byte	0
 10876 00cf 30       		.byte	48
 10877 00d0 01       		.byte	1
 10878 00d1 00       		.byte	0
 10879 00d2 00       		.byte	0
 10880 00d3 00000000 		.space	5
 10880      00
 10881 00d8 00       		.byte	0
 10882 00d9 00       		.byte	0
 10883 00da 02       		.byte	2
 10884 00db 00       		.byte	0
 10885 00dc 00       		.byte	0
 10886 00dd 05       		.byte	5
 10887 00de 00       		.byte	0
 10888 00df 01       		.byte	1
 10889 00e0 00       		.byte	0
 10890 00e1 03       		.byte	3
 10891 00e2 00       		.byte	0
 10892 00e3 00       		.byte	0
 10893 00e4 00       		.byte	0
 10894 00e5 00       		.byte	0
 10895 00e6 00       		.byte	0
 10896 00e7 30       		.byte	48
 10897 00e8 01       		.byte	1
 10898 00e9 00       		.byte	0
 10899 00ea 00       		.byte	0
 10900 00eb 00000000 		.space	5
 10900      00
 10901 00f0 00       		.byte	0
 10902 00f1 00       		.byte	0
 10903 00f2 03       		.byte	3
 10904 00f3 00       		.byte	0
 10905 00f4 00       		.byte	0
 10906 00f5 0A       		.byte	10
 10907 00f6 00       		.byte	0
 10908 00f7 01       		.byte	1
 10909 00f8 00       		.byte	0
 10910 00f9 03       		.byte	3
 10911 00fa 00       		.byte	0
 10912 00fb 00       		.byte	0
 10913 00fc 00       		.byte	0
 10914 00fd 00       		.byte	0
 10915 00fe 00       		.byte	0
 10916 00ff 30       		.byte	48
 10917 0100 01       		.byte	1
 10918 0101 00       		.byte	0
 10919 0102 00       		.byte	0
 10920 0103 00000000 		.space	5
 10920      00
 10921 0108 00       		.byte	0
 10922 0109 00       		.byte	0
 10923 010a 02       		.byte	2
 10924 010b 00       		.byte	0
 10925 010c 00       		.byte	0
 10926 010d 40       		.byte	64
 10927 010e 00       		.byte	0
 10928 010f 01       		.byte	1
 10929 0110 00       		.byte	0
 10930 0111 03       		.byte	3
 10931 0112 00       		.byte	0
 10932 0113 0F       		.byte	15
 10933 0114 11       		.byte	17
 10934 0115 00       		.byte	0
 10935 0116 00       		.byte	0
 10936 0117 30       		.byte	48
 10937 0118 01       		.byte	1
 10938 0119 00       		.byte	0
 10939 011a 00       		.byte	0
 10940 011b 00000000 		.space	5
 10940      00
 10941 0120 00       		.byte	0
 10942 0121 00       		.byte	0
 10943 0122 02       		.byte	2
 10944 0123 00       		.byte	0
 10945 0124 00       		.byte	0
 10946 0125 64       		.byte	100
 10947 0126 00       		.byte	0
 10948 0127 01       		.byte	1
 10949 0128 00       		.byte	0
 10950 0129 03       		.byte	3
 10951 012a 00       		.byte	0
 10952 012b 00       		.byte	0
 10953 012c 00       		.byte	0
 10954 012d 00       		.byte	0
 10955 012e 00       		.byte	0
 10956 012f 30       		.byte	48
 10957 0130 01       		.byte	1
 10958 0131 00       		.byte	0
 10959 0132 00       		.byte	0
 10960 0133 00000000 		.space	5
 10960      00
 10961 0138 00       		.byte	0
 10962 0139 00       		.byte	0
 10963 013a 02       		.byte	2
 10964 013b 00       		.byte	0
 10965 013c 00       		.byte	0
 10966 013d 64       		.byte	100
 10967 013e 00       		.byte	0
 10968 013f 01       		.byte	1
 10969 0140 00       		.byte	0
 10970 0141 03       		.byte	3
 10971 0142 00       		.byte	0
 10972 0143 00       		.byte	0
 10973 0144 00       		.byte	0
 10974 0145 00       		.byte	0
 10975 0146 00       		.byte	0
 10976 0147 30       		.byte	48
 10977 0148 01       		.byte	1
 10978 0149 00       		.byte	0
 10979 014a 00       		.byte	0
 10980 014b 00000000 		.space	5
 10980      00
 10981 0150 00       		.byte	0
 10982 0151 00       		.byte	0
 10983 0152 02       		.byte	2
 10984 0153 00       		.byte	0
 10985 0154 00       		.byte	0
 10986 0155 64       		.byte	100
 10987 0156 00       		.byte	0
 10988 0157 01       		.byte	1
 10989 0158 00       		.byte	0
 10990 0159 03       		.byte	3
 10991 015a 00       		.byte	0
 10992 015b 00       		.byte	0
 10993 015c 00       		.byte	0
 10994 015d 00       		.byte	0
 10995 015e 00       		.byte	0
 10996 015f 30       		.byte	48
 10997 0160 01       		.byte	1
 10998 0161 00       		.byte	0
 10999 0162 00       		.byte	0
 11000 0163 00000000 		.space	5
 11000      00
 11001 0168 00       		.byte	0
 11002 0169 00       		.byte	0
 11003 016a 02       		.byte	2
 11004 016b 00       		.byte	0
 11005 016c 00       		.byte	0
 11006 016d 64       		.byte	100
 11007 016e 00       		.byte	0
 11008 016f 01       		.byte	1
 11009 0170 00       		.byte	0
 11010 0171 03       		.byte	3
 11011 0172 00       		.byte	0
 11012 0173 00       		.byte	0
 11013 0174 00       		.byte	0
 11014 0175 00       		.byte	0
 11015 0176 00       		.byte	0
 11016 0177 30       		.byte	48
 11017 0178 01       		.byte	1
 11018 0179 00       		.byte	0
 11019 017a 00       		.byte	0
 11020 017b 00000000 		.space	5
 11020      00
 11023              	CtrlParArry:
 11024 0180 10       		.byte	16
 11025 0181 10       		.byte	16
 11026 0182 02       		.byte	2
 11027 0183 00       		.byte	0
 11028 0184 00       		.byte	0
 11029 0185 03       		.byte	3
 11030 0186 00       		.byte	0
 11031 0187 01       		.byte	1
 11032 0188 00       		.byte	0
 11033 0189 03       		.byte	3
 11034 018a 00       		.byte	0
 11035 018b 00       		.byte	0
 11036 018c 00       		.byte	0
 11037 018d 00       		.byte	0
 11038 018e 00       		.byte	0
 11039 018f 30       		.byte	48
 11040 0190 01       		.byte	1
 11041 0191 00       		.byte	0
 11042 0192 00       		.byte	0
 11043 0193 00000000 		.space	5
 11043      00
 11044 0198 01       		.byte	1
 11045 0199 00       		.byte	0
 11046 019a 02       		.byte	2
 11047 019b 00       		.byte	0
 11048 019c 00       		.byte	0
 11049 019d 3F       		.byte	63
 11050 019e 00       		.byte	0
 11051 019f 01       		.byte	1
 11052 01a0 00       		.byte	0
 11053 01a1 03       		.byte	3
 11054 01a2 00       		.byte	0
 11055 01a3 1F       		.byte	31
 11056 01a4 00       		.byte	0
 11057 01a5 1F       		.byte	31
 11058 01a6 C7       		.byte	-57
 11059 01a7 30       		.byte	48
 11060 01a8 01       		.byte	1
 11061 01a9 01       		.byte	1
 11062 01aa 00       		.byte	0
 11063 01ab 00000000 		.space	5
 11063      00
 11064 01b0 07       		.byte	7
 11065 01b1 07       		.byte	7
 11066 01b2 02       		.byte	2
 11067 01b3 10       		.byte	16
 11068 01b4 00       		.byte	0
 11069 01b5 40       		.byte	64
 11070 01b6 00       		.byte	0
 11071 01b7 01       		.byte	1
 11072 01b8 00       		.byte	0
 11073 01b9 03       		.byte	3
 11074 01ba 00       		.byte	0
 11075 01bb 28       		.byte	40
 11076 01bc 00       		.byte	0
 11077 01bd 28       		.byte	40
 11078 01be 00       		.byte	0
 11079 01bf 30       		.byte	48
 11080 01c0 01       		.byte	1
 11081 01c1 01       		.byte	1
 11082 01c2 00       		.byte	0
 11083 01c3 00000000 		.space	5
 11083      00
 11084 01c8 00       		.byte	0
 11085 01c9 00       		.byte	0
 11086 01ca 02       		.byte	2
 11087 01cb 00       		.byte	0
 11088 01cc 00       		.byte	0
 11089 01cd 64       		.byte	100
 11090 01ce 00       		.byte	0
 11091 01cf 01       		.byte	1
 11092 01d0 00       		.byte	0
 11093 01d1 03       		.byte	3
 11094 01d2 00       		.byte	0
 11095 01d3 00       		.byte	0
 11096 01d4 00       		.byte	0
 11097 01d5 00       		.byte	0
 11098 01d6 00       		.byte	0
 11099 01d7 30       		.byte	48
 11100 01d8 01       		.byte	1
 11101 01d9 00       		.byte	0
 11102 01da 00       		.byte	0
 11103 01db 00000000 		.space	5
 11103      00
 11104 01e0 07       		.byte	7
 11105 01e1 07       		.byte	7
 11106 01e2 02       		.byte	2
 11107 01e3 00       		.byte	0
 11108 01e4 00       		.byte	0
 11109 01e5 01       		.byte	1
 11110 01e6 00       		.byte	0
 11111 01e7 01       		.byte	1
 11112 01e8 00       		.byte	0
 11113 01e9 03       		.byte	3
 11114 01ea 00       		.byte	0
 11115 01eb 01       		.byte	1
 11116 01ec 00       		.byte	0
 11117 01ed 01       		.byte	1
 11118 01ee 00       		.byte	0
 11119 01ef 30       		.byte	48
 11120 01f0 01       		.byte	1
 11121 01f1 00       		.byte	0
 11122 01f2 00       		.byte	0
 11123 01f3 00000000 		.space	5
 11123      00
 11124 01f8 DF       		.byte	-33
 11125 01f9 E1       		.byte	-31
 11126 01fa 02       		.byte	2
 11127 01fb 00       		.byte	0
 11128 01fc 00       		.byte	0
 11129 01fd FF       		.byte	-1
 11130 01fe 00       		.byte	0
 11131 01ff 01       		.byte	1
 11132 0200 00       		.byte	0
 11133 0201 03       		.byte	3
 11134 0202 00       		.byte	0
 11135 0203 80       		.byte	-128
 11136 0204 00       		.byte	0
 11137 0205 00       		.byte	0
 11138 0206 00       		.byte	0
 11139 0207 C6       		.byte	-58
 11140 0208 01       		.byte	1
 11141 0209 01       		.byte	1
 11142 020a 00       		.byte	0
 11143 020b 00000000 		.space	5
 11143      00
 11144 0210 85       		.byte	-123
 11145 0211 86       		.byte	-122
 11146 0212 02       		.byte	2
 11147 0213 00       		.byte	0
 11148 0214 00       		.byte	0
 11149 0215 64       		.byte	100
 11150 0216 00       		.byte	0
 11151 0217 01       		.byte	1
 11152 0218 00       		.byte	0
 11153 0219 03       		.byte	3
 11154 021a 00       		.byte	0
 11155 021b 32       		.byte	50
 11156 021c 00       		.byte	0
 11157 021d 32       		.byte	50
 11158 021e 00       		.byte	0
 11159 021f F2       		.byte	-14
 11160 0220 01       		.byte	1
 11161 0221 01       		.byte	1
 11162 0222 00       		.byte	0
 11163 0223 00000000 		.space	5
 11163      00
 11164 0228 06       		.byte	6
 11165 0229 06       		.byte	6
 11166 022a 02       		.byte	2
 11167 022b 00       		.byte	0
 11168 022c 00       		.byte	0
 11169 022d 0E       		.byte	14
 11170 022e 00       		.byte	0
 11171 022f 01       		.byte	1
 11172 0230 00       		.byte	0
 11173 0231 03       		.byte	3
 11174 0232 00       		.byte	0
 11175 0233 00       		.byte	0
 11176 0234 00       		.byte	0
 11177 0235 00       		.byte	0
 11178 0236 00       		.byte	0
 11179 0237 30       		.byte	48
 11180 0238 01       		.byte	1
 11181 0239 01       		.byte	1
 11182 023a 00       		.byte	0
 11183 023b 00000000 		.space	5
 11183      00
 11184 0240 00       		.byte	0
 11185 0241 00       		.byte	0
 11186 0242 02       		.byte	2
 11187 0243 00       		.byte	0
 11188 0244 00       		.byte	0
 11189 0245 64       		.byte	100
 11190 0246 00       		.byte	0
 11191 0247 01       		.byte	1
 11192 0248 00       		.byte	0
 11193 0249 03       		.byte	3
 11194 024a 00       		.byte	0
 11195 024b 00       		.byte	0
 11196 024c 00       		.byte	0
 11197 024d 00       		.byte	0
 11198 024e 00       		.byte	0
 11199 024f 30       		.byte	48
 11200 0250 01       		.byte	1
 11201 0251 00       		.byte	0
 11202 0252 00       		.byte	0
 11203 0253 00000000 		.space	5
 11203      00
 11204 0258 0B       		.byte	11
 11205 0259 0B       		.byte	11
 11206 025a 02       		.byte	2
 11207 025b 00       		.byte	0
 11208 025c 00       		.byte	0
 11209 025d 05       		.byte	5
 11210 025e 00       		.byte	0
 11211 025f 01       		.byte	1
 11212 0260 00       		.byte	0
 11213 0261 03       		.byte	3
 11214 0262 00       		.byte	0
 11215 0263 00       		.byte	0
 11216 0264 00       		.byte	0
 11217 0265 00       		.byte	0
 11218 0266 00       		.byte	0
 11219 0267 30       		.byte	48
 11220 0268 01       		.byte	1
 11221 0269 00       		.byte	0
 11222 026a 00       		.byte	0
 11223 026b 00000000 		.space	5
 11223      00
 11224 0270 00       		.byte	0
 11225 0271 00       		.byte	0
 11226 0272 02       		.byte	2
 11227 0273 00       		.byte	0
 11228 0274 00       		.byte	0
 11229 0275 40       		.byte	64
 11230 0276 00       		.byte	0
 11231 0277 01       		.byte	1
 11232 0278 00       		.byte	0
 11233 0279 03       		.byte	3
 11234 027a 00       		.byte	0
 11235 027b 00       		.byte	0
 11236 027c 00       		.byte	0
 11237 027d 00       		.byte	0
 11238 027e 00       		.byte	0
 11239 027f 30       		.byte	48
 11240 0280 01       		.byte	1
 11241 0281 00       		.byte	0
 11242 0282 00       		.byte	0
 11243 0283 00000000 		.space	5
 11243      00
 11244 0288 09       		.byte	9
 11245 0289 0A       		.byte	10
 11246 028a 04       		.byte	4
 11247 028b 00       		.byte	0
 11248 028c 00       		.byte	0
 11249 028d 40       		.byte	64
 11250 028e 00       		.byte	0
 11251 028f 01       		.byte	1
 11252 0290 00       		.byte	0
 11253 0291 03       		.byte	3
 11254 0292 00       		.byte	0
 11255 0293 20       		.byte	32
 11256 0294 38       		.byte	56
 11257 0295 20       		.byte	32
 11258 0296 38       		.byte	56
 11259 0297 30       		.byte	48
 11260 0298 01       		.byte	1
 11261 0299 00       		.byte	0
 11262 029a 00       		.byte	0
 11263 029b 00000000 		.space	5
 11263      00
 11264 02a0 00       		.byte	0
 11265 02a1 00       		.byte	0
 11266 02a2 02       		.byte	2
 11267 02a3 00       		.byte	0
 11268 02a4 00       		.byte	0
 11269 02a5 64       		.byte	100
 11270 02a6 00       		.byte	0
 11271 02a7 01       		.byte	1
 11272 02a8 00       		.byte	0
 11273 02a9 03       		.byte	3
 11274 02aa 00       		.byte	0
 11275 02ab 00       		.byte	0
 11276 02ac 00       		.byte	0
 11277 02ad 00       		.byte	0
 11278 02ae 00       		.byte	0
 11279 02af 30       		.byte	48
 11280 02b0 01       		.byte	1
 11281 02b1 00       		.byte	0
 11282 02b2 00       		.byte	0
 11283 02b3 00000000 		.space	5
 11283      00
 11284 02b8 00       		.byte	0
 11285 02b9 00       		.byte	0
 11286 02ba 02       		.byte	2
 11287 02bb 00       		.byte	0
 11288 02bc 00       		.byte	0
 11289 02bd 64       		.byte	100
 11290 02be 00       		.byte	0
 11291 02bf 01       		.byte	1
 11292 02c0 00       		.byte	0
 11293 02c1 03       		.byte	3
 11294 02c2 00       		.byte	0
 11295 02c3 00       		.byte	0
 11296 02c4 00       		.byte	0
 11297 02c5 00       		.byte	0
 11298 02c6 00       		.byte	0
 11299 02c7 30       		.byte	48
 11300 02c8 01       		.byte	1
 11301 02c9 00       		.byte	0
 11302 02ca 00       		.byte	0
 11303 02cb 00000000 		.space	5
 11303      00
 11304 02d0 2A       		.byte	42
 11305 02d1 2A       		.byte	42
 11306 02d2 02       		.byte	2
 11307 02d3 00       		.byte	0
 11308 02d4 00       		.byte	0
 11309 02d5 1B       		.byte	27
 11310 02d6 00       		.byte	0
 11311 02d7 01       		.byte	1
 11312 02d8 00       		.byte	0
 11313 02d9 03       		.byte	3
 11314 02da 00       		.byte	0
 11315 02db 00       		.byte	0
 11316 02dc 00       		.byte	0
 11317 02dd 00       		.byte	0
 11318 02de 00       		.byte	0
 11319 02df 30       		.byte	48
 11320 02e0 01       		.byte	1
 11321 02e1 00       		.byte	0
 11322 02e2 00       		.byte	0
 11323 02e3 00000000 		.space	5
 11323      00
 11324 02e8 00       		.byte	0
 11325 02e9 00       		.byte	0
 11326 02ea 02       		.byte	2
 11327 02eb 00       		.byte	0
 11328 02ec 00       		.byte	0
 11329 02ed 64       		.byte	100
 11330 02ee 00       		.byte	0
 11331 02ef 01       		.byte	1
 11332 02f0 00       		.byte	0
 11333 02f1 03       		.byte	3
 11334 02f2 00       		.byte	0
 11335 02f3 00       		.byte	0
 11336 02f4 00       		.byte	0
 11337 02f5 00       		.byte	0
 11338 02f6 00       		.byte	0
 11339 02f7 30       		.byte	48
 11340 02f8 01       		.byte	1
 11341 02f9 00       		.byte	0
 11342 02fa 00       		.byte	0
 11343 02fb 00000000 		.space	5
 11343      00
 11344 0300 00       		.byte	0
 11345 0301 00       		.byte	0
 11346 0302 02       		.byte	2
 11347 0303 00       		.byte	0
 11348 0304 00       		.byte	0
 11349 0305 12       		.byte	18
 11350 0306 00       		.byte	0
 11351 0307 01       		.byte	1
 11352 0308 00       		.byte	0
 11353 0309 03       		.byte	3
 11354 030a 00       		.byte	0
 11355 030b 00       		.byte	0
 11356 030c 00       		.byte	0
 11357 030d 00       		.byte	0
 11358 030e 00       		.byte	0
 11359 030f 30       		.byte	48
 11360 0310 01       		.byte	1
 11361 0311 00       		.byte	0
 11362 0312 00       		.byte	0
 11363 0313 00000000 		.space	5
 11363      00
 11364 0318 01       		.byte	1
 11365 0319 01       		.byte	1
 11366 031a 02       		.byte	2
 11367 031b 00       		.byte	0
 11368 031c 00       		.byte	0
 11369 031d 09       		.byte	9
 11370 031e 00       		.byte	0
 11371 031f 01       		.byte	1
 11372 0320 00       		.byte	0
 11373 0321 03       		.byte	3
 11374 0322 00       		.byte	0
 11375 0323 00       		.byte	0
 11376 0324 00       		.byte	0
 11377 0325 01       		.byte	1
 11378 0326 00       		.byte	0
 11379 0327 30       		.byte	48
 11380 0328 01       		.byte	1
 11381 0329 00       		.byte	0
 11382 032a 00       		.byte	0
 11383 032b 00000000 		.space	5
 11383      00
 11384 0330 05       		.byte	5
 11385 0331 05       		.byte	5
 11386 0332 02       		.byte	2
 11387 0333 00       		.byte	0
 11388 0334 00       		.byte	0
 11389 0335 03       		.byte	3
 11390 0336 00       		.byte	0
 11391 0337 01       		.byte	1
 11392 0338 00       		.byte	0
 11393 0339 03       		.byte	3
 11394 033a 00       		.byte	0
 11395 033b 00       		.byte	0
 11396 033c 00       		.byte	0
 11397 033d 00       		.byte	0
 11398 033e 00       		.byte	0
 11399 033f 30       		.byte	48
 11400 0340 01       		.byte	1
 11401 0341 00       		.byte	0
 11402 0342 00       		.byte	0
 11403 0343 00000000 		.space	5
 11403      00
 11404 0348 18       		.byte	24
 11405 0349 18       		.byte	24
 11406 034a 02       		.byte	2
 11407 034b 00       		.byte	0
 11408 034c 00       		.byte	0
 11409 034d 01       		.byte	1
 11410 034e 00       		.byte	0
 11411 034f 01       		.byte	1
 11412 0350 00       		.byte	0
 11413 0351 03       		.byte	3
 11414 0352 00       		.byte	0
 11415 0353 00       		.byte	0
 11416 0354 00       		.byte	0
 11417 0355 00       		.byte	0
 11418 0356 00       		.byte	0
 11419 0357 30       		.byte	48
 11420 0358 01       		.byte	1
 11421 0359 00       		.byte	0
 11422 035a 00       		.byte	0
 11423 035b 00000000 		.space	5
 11423      00
 11424 0360 19       		.byte	25
 11425 0361 19       		.byte	25
 11426 0362 01       		.byte	1
 11427 0363 00       		.byte	0
 11428 0364 00       		.byte	0
 11429 0365 40       		.byte	64
 11430 0366 00       		.byte	0
 11431 0367 01       		.byte	1
 11432 0368 00       		.byte	0
 11433 0369 03       		.byte	3
 11434 036a 00       		.byte	0
 11435 036b 20       		.byte	32
 11436 036c 00       		.byte	0
 11437 036d 20       		.byte	32
 11438 036e 00       		.byte	0
 11439 036f 30       		.byte	48
 11440 0370 01       		.byte	1
 11441 0371 00       		.byte	0
 11442 0372 00       		.byte	0
 11443 0373 00000000 		.space	5
 11443      00
 11444 0378 20       		.byte	32
 11445 0379 20       		.byte	32
 11446 037a 02       		.byte	2
 11447 037b 00       		.byte	0
 11448 037c 00       		.byte	0
 11449 037d 02       		.byte	2
 11450 037e 00       		.byte	0
 11451 037f 01       		.byte	1
 11452 0380 00       		.byte	0
 11453 0381 03       		.byte	3
 11454 0382 00       		.byte	0
 11455 0383 00       		.byte	0
 11456 0384 00       		.byte	0
 11457 0385 00       		.byte	0
 11458 0386 00       		.byte	0
 11459 0387 30       		.byte	48
 11460 0388 01       		.byte	1
 11461 0389 00       		.byte	0
 11462 038a 00       		.byte	0
 11463 038b 00000000 		.space	5
 11463      00
 11464 0390 22       		.byte	34
 11465 0391 22       		.byte	34
 11466 0392 02       		.byte	2
 11467 0393 00       		.byte	0
 11468 0394 00       		.byte	0
 11469 0395 3F       		.byte	63
 11470 0396 00       		.byte	0
 11471 0397 01       		.byte	1
 11472 0398 00       		.byte	0
 11473 0399 03       		.byte	3
 11474 039a 00       		.byte	0
 11475 039b 00       		.byte	0
 11476 039c 00       		.byte	0
 11477 039d 00       		.byte	0
 11478 039e 00       		.byte	0
 11479 039f 30       		.byte	48
 11480 03a0 01       		.byte	1
 11481 03a1 00       		.byte	0
 11482 03a2 00       		.byte	0
 11483 03a3 00000000 		.space	5
 11483      00
 11484 03a8 23       		.byte	35
 11485 03a9 23       		.byte	35
 11486 03aa 02       		.byte	2
 11487 03ab 00       		.byte	0
 11488 03ac 00       		.byte	0
 11489 03ad 64       		.byte	100
 11490 03ae 00       		.byte	0
 11491 03af 01       		.byte	1
 11492 03b0 00       		.byte	0
 11493 03b1 03       		.byte	3
 11494 03b2 00       		.byte	0
 11495 03b3 10       		.byte	16
 11496 03b4 00       		.byte	0
 11497 03b5 10       		.byte	16
 11498 03b6 00       		.byte	0
 11499 03b7 30       		.byte	48
 11500 03b8 01       		.byte	1
 11501 03b9 00       		.byte	0
 11502 03ba 00       		.byte	0
 11503 03bb 00000000 		.space	5
 11503      00
 11504 03c0 24       		.byte	36
 11505 03c1 24       		.byte	36
 11506 03c2 02       		.byte	2
 11507 03c3 00       		.byte	0
 11508 03c4 00       		.byte	0
 11509 03c5 64       		.byte	100
 11510 03c6 00       		.byte	0
 11511 03c7 01       		.byte	1
 11512 03c8 00       		.byte	0
 11513 03c9 03       		.byte	3
 11514 03ca 00       		.byte	0
 11515 03cb 10       		.byte	16
 11516 03cc 00       		.byte	0
 11517 03cd 10       		.byte	16
 11518 03ce 00       		.byte	0
 11519 03cf 30       		.byte	48
 11520 03d0 01       		.byte	1
 11521 03d1 00       		.byte	0
 11522 03d2 00       		.byte	0
 11523 03d3 00000000 		.space	5
 11523      00
 11524 03d8 02       		.byte	2
 11525 03d9 03       		.byte	3
 11526 03da 04       		.byte	4
 11527 03db 00       		.byte	0
 11528 03dc 00       		.byte	0
 11529 03dd FF       		.byte	-1
 11530 03de 00       		.byte	0
 11531 03df 01       		.byte	1
 11532 03e0 00       		.byte	0
 11533 03e1 03       		.byte	3
 11534 03e2 00       		.byte	0
 11535 03e3 00       		.byte	0
 11536 03e4 20       		.byte	32
 11537 03e5 00       		.byte	0
 11538 03e6 20       		.byte	32
 11539 03e7 30       		.byte	48
 11540 03e8 01       		.byte	1
 11541 03e9 00       		.byte	0
 11542 03ea 00       		.byte	0
 11543 03eb 00000000 		.space	5
 11543      00
 11544 03f0 04       		.byte	4
 11545 03f1 04       		.byte	4
 11546 03f2 02       		.byte	2
 11547 03f3 00       		.byte	0
 11548 03f4 00       		.byte	0
 11549 03f5 3F       		.byte	63
 11550 03f6 00       		.byte	0
 11551 03f7 01       		.byte	1
 11552 03f8 00       		.byte	0
 11553 03f9 03       		.byte	3
 11554 03fa 00       		.byte	0
 11555 03fb 20       		.byte	32
 11556 03fc 00       		.byte	0
 11557 03fd 20       		.byte	32
 11558 03fe 00       		.byte	0
 11559 03ff 30       		.byte	48
 11560 0400 01       		.byte	1
 11561 0401 00       		.byte	0
 11562 0402 00       		.byte	0
 11563 0403 00000000 		.space	5
 11563      00
 11564 0408 00       		.byte	0
 11565 0409 00       		.byte	0
 11566 040a 02       		.byte	2
 11567 040b 00       		.byte	0
 11568 040c 00       		.byte	0
 11569 040d 19       		.byte	25
 11570 040e 00       		.byte	0
 11571 040f 01       		.byte	1
 11572 0410 00       		.byte	0
 11573 0411 03       		.byte	3
 11574 0412 00       		.byte	0
 11575 0413 00       		.byte	0
 11576 0414 00       		.byte	0
 11577 0415 00       		.byte	0
 11578 0416 00       		.byte	0
 11579 0417 30       		.byte	48
 11580 0418 01       		.byte	1
 11581 0419 00       		.byte	0
 11582 041a 00       		.byte	0
 11583 041b 00000000 		.space	5
 11583      00
 11584 0420 10       		.byte	16
 11585 0421 10       		.byte	16
 11586 0422 02       		.byte	2
 11587 0423 00       		.byte	0
 11588 0424 00       		.byte	0
 11589 0425 06       		.byte	6
 11590 0426 00       		.byte	0
 11591 0427 01       		.byte	1
 11592 0428 00       		.byte	0
 11593 0429 03       		.byte	3
 11594 042a 00       		.byte	0
 11595 042b 00       		.byte	0
 11596 042c 00       		.byte	0
 11597 042d 00       		.byte	0
 11598 042e 00       		.byte	0
 11599 042f 30       		.byte	48
 11600 0430 01       		.byte	1
 11601 0431 00       		.byte	0
 11602 0432 00       		.byte	0
 11603 0433 00000000 		.space	5
 11603      00
 11604 0438 00       		.byte	0
 11605 0439 00       		.byte	0
 11606 043a 02       		.byte	2
 11607 043b 00       		.byte	0
 11608 043c 00       		.byte	0
 11609 043d 03       		.byte	3
 11610 043e 00       		.byte	0
 11611 043f 01       		.byte	1
 11612 0440 00       		.byte	0
 11613 0441 03       		.byte	3
 11614 0442 00       		.byte	0
 11615 0443 00       		.byte	0
 11616 0444 00       		.byte	0
 11617 0445 00       		.byte	0
 11618 0446 00       		.byte	0
 11619 0447 30       		.byte	48
 11620 0448 01       		.byte	1
 11621 0449 00       		.byte	0
 11622 044a 00       		.byte	0
 11623 044b 00000000 		.space	5
 11623      00
 11624 0450 50       		.byte	80
 11625 0451 50       		.byte	80
 11626 0452 01       		.byte	1
 11627 0453 00       		.byte	0
 11628 0454 00       		.byte	0
 11629 0455 03       		.byte	3
 11630 0456 00       		.byte	0
 11631 0457 01       		.byte	1
 11632 0458 00       		.byte	0
 11633 0459 03       		.byte	3
 11634 045a 00       		.byte	0
 11635 045b 00       		.byte	0
 11636 045c 00       		.byte	0
 11637 045d 00       		.byte	0
 11638 045e 00       		.byte	0
 11639 045f 30       		.byte	48
 11640 0460 01       		.byte	1
 11641 0461 00       		.byte	0
 11642 0462 00       		.byte	0
 11643 0463 00000000 		.space	5
 11643      00
 11644 0468 00       		.byte	0
 11645 0469 00       		.byte	0
 11646 046a 0B       		.byte	11
 11647 046b 00       		.byte	0
 11648 046c 00       		.byte	0
 11649 046d FF       		.byte	-1
 11650 046e FF       		.byte	-1
 11651 046f 01       		.byte	1
 11652 0470 00       		.byte	0
 11653 0471 03       		.byte	3
 11654 0472 00       		.byte	0
 11655 0473 00       		.byte	0
 11656 0474 00       		.byte	0
 11657 0475 00       		.byte	0
 11658 0476 00       		.byte	0
 11659 0477 00       		.byte	0
 11660 0478 01       		.byte	1
 11661 0479 00       		.byte	0
 11662 047a 00       		.byte	0
 11663 047b 00000000 		.space	5
 11663      00
 11666              	glUVCHeader:
 11667 0480 0C       		.byte	12
 11668 0481 8C       		.byte	-116
 11669 0482 00       		.byte	0
 11670 0483 00       		.byte	0
 11671 0484 00       		.byte	0
 11672 0485 00       		.byte	0
 11673 0486 00       		.byte	0
 11674 0487 00       		.byte	0
 11675 0488 00       		.byte	0
 11676 0489 00       		.byte	0
 11677 048a 00       		.byte	0
 11678 048b 00       		.byte	0
 11681              	WBMenuCmpArry:
 11682 048c A0       		.byte	-96
 11683 048d 0F       		.byte	15
 11684 048e 0F       		.byte	15
 11685 048f F0       		.byte	-16
 11688              	CTCtrlParArry:
 11689 0490 00       		.byte	0
 11690 0491 00       		.byte	0
 11691 0492 01       		.byte	1
 11692 0493 00       		.byte	0
 11693 0494 00       		.byte	0
 11694 0495 03       		.byte	3
 11695 0496 00       		.byte	0
 11696 0497 01       		.byte	1
 11697 0498 00       		.byte	0
 11698 0499 03       		.byte	3
 11699 049a 00       		.byte	0
 11700 049b 03       		.byte	3
 11701 049c 00       		.byte	0
 11702 049d 03       		.byte	3
 11703 049e 00       		.byte	0
 11704 049f 30       		.byte	48
 11705 04a0 01       		.byte	1
 11706 04a1 00       		.byte	0
 11707 04a2 00       		.byte	0
 11708 04a3 00000000 		.space	5
 11708      00
 11709 04a8 00       		.byte	0
 11710 04a9 00       		.byte	0
 11711 04aa 01       		.byte	1
 11712 04ab 01       		.byte	1
 11713 04ac 00       		.byte	0
 11714 04ad 0F       		.byte	15
 11715 04ae 00       		.byte	0
 11716 04af 0F       		.byte	15
 11717 04b0 00       		.byte	0
 11718 04b1 03       		.byte	3
 11719 04b2 00       		.byte	0
 11720 04b3 02       		.byte	2
 11721 04b4 00       		.byte	0
 11722 04b5 02       		.byte	2
 11723 04b6 00       		.byte	0
 11724 04b7 30       		.byte	48
 11725 04b8 01       		.byte	1
 11726 04b9 01       		.byte	1
 11727 04ba 00       		.byte	0
 11728 04bb 00000000 		.space	5
 11728      00
 11729 04c0 02       		.byte	2
 11730 04c1 00       		.byte	0
 11731 04c2 01       		.byte	1
 11732 04c3 00       		.byte	0
 11733 04c4 00       		.byte	0
 11734 04c5 01       		.byte	1
 11735 04c6 00       		.byte	0
 11736 04c7 01       		.byte	1
 11737 04c8 00       		.byte	0
 11738 04c9 03       		.byte	3
 11739 04ca 00       		.byte	0
 11740 04cb 00       		.byte	0
 11741 04cc 00       		.byte	0
 11742 04cd 00       		.byte	0
 11743 04ce 00       		.byte	0
 11744 04cf 30       		.byte	48
 11745 04d0 01       		.byte	1
 11746 04d1 01       		.byte	1
 11747 04d2 00       		.byte	0
 11748 04d3 00000000 		.space	5
 11748      00
 11749 04d8 00       		.byte	0
 11750 04d9 00       		.byte	0
 11751 04da 04       		.byte	4
 11752 04db 01       		.byte	1
 11753 04dc 00       		.byte	0
 11754 04dd 38       		.byte	56
 11755 04de 01       		.byte	1
 11756 04df 01       		.byte	1
 11757 04e0 00       		.byte	0
 11758 04e1 03       		.byte	3
 11759 04e2 00       		.byte	0
 11760 04e3 4E       		.byte	78
 11761 04e4 00       		.byte	0
 11762 04e5 4E       		.byte	78
 11763 04e6 00       		.byte	0
 11764 04e7 30       		.byte	48
 11765 04e8 01       		.byte	1
 11766 04e9 00       		.byte	0
 11767 04ea 00       		.byte	0
 11768 04eb 00000000 		.space	5
 11768      00
 11769 04f0 04       		.byte	4
 11770 04f1 00       		.byte	0
 11771 04f2 01       		.byte	1
 11772 04f3 00       		.byte	0
 11773 04f4 00       		.byte	0
 11774 04f5 00       		.byte	0
 11775 04f6 00       		.byte	0
 11776 04f7 01       		.byte	1
 11777 04f8 00       		.byte	0
 11778 04f9 03       		.byte	3
 11779 04fa 00       		.byte	0
 11780 04fb 00       		.byte	0
 11781 04fc 00       		.byte	0
 11782 04fd 00       		.byte	0
 11783 04fe 00       		.byte	0
 11784 04ff 30       		.byte	48
 11785 0500 01       		.byte	1
 11786 0501 00       		.byte	0
 11787 0502 00       		.byte	0
 11788 0503 00000000 		.space	5
 11788      00
 11789 0508 05       		.byte	5
 11790 0509 00       		.byte	0
 11791 050a 02       		.byte	2
 11792 050b 00       		.byte	0
 11793 050c 00       		.byte	0
 11794 050d FF       		.byte	-1
 11795 050e 00       		.byte	0
 11796 050f 01       		.byte	1
 11797 0510 00       		.byte	0
 11798 0511 03       		.byte	3
 11799 0512 00       		.byte	0
 11800 0513 01       		.byte	1
 11801 0514 00       		.byte	0
 11802 0515 00       		.byte	0
 11803 0516 00       		.byte	0
 11804 0517 30       		.byte	48
 11805 0518 01       		.byte	1
 11806 0519 01       		.byte	1
 11807 051a 00       		.byte	0
 11808 051b 00000000 		.space	5
 11808      00
 11809 0520 06       		.byte	6
 11810 0521 00       		.byte	0
 11811 0522 02       		.byte	2
 11812 0523 00       		.byte	0
 11813 0524 00       		.byte	0
 11814 0525 00       		.byte	0
 11815 0526 00       		.byte	0
 11816 0527 00       		.byte	0
 11817 0528 00       		.byte	0
 11818 0529 03       		.byte	3
 11819 052a 00       		.byte	0
 11820 052b 00       		.byte	0
 11821 052c 00       		.byte	0
 11822 052d 00       		.byte	0
 11823 052e 00       		.byte	0
 11824 052f 30       		.byte	48
 11825 0530 01       		.byte	1
 11826 0531 01       		.byte	1
 11827 0532 00       		.byte	0
 11828 0533 00000000 		.space	5
 11828      00
 11829 0538 23       		.byte	35
 11830 0539 00       		.byte	0
 11831 053a 02       		.byte	2
 11832 053b 00       		.byte	0
 11833 053c 00       		.byte	0
 11834 053d 30       		.byte	48
 11835 053e 00       		.byte	0
 11836 053f 01       		.byte	1
 11837 0540 00       		.byte	0
 11838 0541 03       		.byte	3
 11839 0542 0A       		.byte	10
 11840 0543 00       		.byte	0
 11841 0544 00       		.byte	0
 11842 0545 0A       		.byte	10
 11843 0546 00       		.byte	0
 11844 0547 30       		.byte	48
 11845 0548 01       		.byte	1
 11846 0549 01       		.byte	1
 11847 054a 00       		.byte	0
 11848 054b 00000000 		.space	5
 11848      00
 11849 0550 08       		.byte	8
 11850 0551 00       		.byte	0
 11851 0552 01       		.byte	1
 11852 0553 00       		.byte	0
 11853 0554 00       		.byte	0
 11854 0555 7F       		.byte	127
 11855 0556 00       		.byte	0
 11856 0557 01       		.byte	1
 11857 0558 00       		.byte	0
 11858 0559 03       		.byte	3
 11859 055a 00       		.byte	0
 11860 055b 00       		.byte	0
 11861 055c 00       		.byte	0
 11862 055d 00       		.byte	0
 11863 055e 00       		.byte	0
 11864 055f 30       		.byte	48
 11865 0560 01       		.byte	1
 11866 0561 00       		.byte	0
 11867 0562 00       		.byte	0
 11868 0563 00000000 		.space	5
 11868      00
 11869 0568 09       		.byte	9
 11870 0569 00       		.byte	0
 11871 056a 02       		.byte	2
 11872 056b 00       		.byte	0
 11873 056c 00       		.byte	0
 11874 056d 05       		.byte	5
 11875 056e 00       		.byte	0
 11876 056f 01       		.byte	1
 11877 0570 00       		.byte	0
 11878 0571 03       		.byte	3
 11879 0572 00       		.byte	0
 11880 0573 00       		.byte	0
 11881 0574 00       		.byte	0
 11882 0575 00       		.byte	0
 11883 0576 00       		.byte	0
 11884 0577 30       		.byte	48
 11885 0578 01       		.byte	1
 11886 0579 00       		.byte	0
 11887 057a 00       		.byte	0
 11888 057b 00000000 		.space	5
 11888      00
 11889 0580 10       		.byte	16
 11890 0581 00       		.byte	0
 11891 0582 03       		.byte	3
 11892 0583 00       		.byte	0
 11893 0584 00       		.byte	0
 11894 0585 00       		.byte	0
 11895 0586 00       		.byte	0
 11896 0587 00       		.byte	0
 11897 0588 00       		.byte	0
 11898 0589 03       		.byte	3
 11899 058a 00       		.byte	0
 11900 058b 00       		.byte	0
 11901 058c 00       		.byte	0
 11902 058d 00       		.byte	0
 11903 058e 00       		.byte	0
 11904 058f 30       		.byte	48
 11905 0590 01       		.byte	1
 11906 0591 00       		.byte	0
 11907 0592 00       		.byte	0
 11908 0593 00000000 		.space	5
 11908      00
 11909 0598 00       		.byte	0
 11910 0599 00       		.byte	0
 11911 059a 02       		.byte	2
 11912 059b 00       		.byte	0
 11913 059c 00       		.byte	0
 11914 059d 40       		.byte	64
 11915 059e 00       		.byte	0
 11916 059f 01       		.byte	1
 11917 05a0 00       		.byte	0
 11918 05a1 03       		.byte	3
 11919 05a2 00       		.byte	0
 11920 05a3 0F       		.byte	15
 11921 05a4 11       		.byte	17
 11922 05a5 00       		.byte	0
 11923 05a6 00       		.byte	0
 11924 05a7 30       		.byte	48
 11925 05a8 01       		.byte	1
 11926 05a9 00       		.byte	0
 11927 05aa 00       		.byte	0
 11928 05ab 00000000 		.space	5
 11928      00
 11929 05b0 00       		.byte	0
 11930 05b1 00       		.byte	0
 11931 05b2 02       		.byte	2
 11932 05b3 00       		.byte	0
 11933 05b4 00       		.byte	0
 11934 05b5 64       		.byte	100
 11935 05b6 00       		.byte	0
 11936 05b7 01       		.byte	1
 11937 05b8 00       		.byte	0
 11938 05b9 03       		.byte	3
 11939 05ba 00       		.byte	0
 11940 05bb 00       		.byte	0
 11941 05bc 00       		.byte	0
 11942 05bd 00       		.byte	0
 11943 05be 00       		.byte	0
 11944 05bf 30       		.byte	48
 11945 05c0 01       		.byte	1
 11946 05c1 00       		.byte	0
 11947 05c2 00       		.byte	0
 11948 05c3 00000000 		.space	5
 11948      00
 11949 05c8 00       		.byte	0
 11950 05c9 00       		.byte	0
 11951 05ca 02       		.byte	2
 11952 05cb 00       		.byte	0
 11953 05cc 00       		.byte	0
 11954 05cd 64       		.byte	100
 11955 05ce 00       		.byte	0
 11956 05cf 01       		.byte	1
 11957 05d0 00       		.byte	0
 11958 05d1 03       		.byte	3
 11959 05d2 00       		.byte	0
 11960 05d3 00       		.byte	0
 11961 05d4 00       		.byte	0
 11962 05d5 00       		.byte	0
 11963 05d6 00       		.byte	0
 11964 05d7 30       		.byte	48
 11965 05d8 01       		.byte	1
 11966 05d9 00       		.byte	0
 11967 05da 00       		.byte	0
 11968 05db 00000000 		.space	5
 11968      00
 11969 05e0 00       		.byte	0
 11970 05e1 00       		.byte	0
 11971 05e2 02       		.byte	2
 11972 05e3 00       		.byte	0
 11973 05e4 00       		.byte	0
 11974 05e5 64       		.byte	100
 11975 05e6 00       		.byte	0
 11976 05e7 01       		.byte	1
 11977 05e8 00       		.byte	0
 11978 05e9 03       		.byte	3
 11979 05ea 00       		.byte	0
 11980 05eb 00       		.byte	0
 11981 05ec 00       		.byte	0
 11982 05ed 00       		.byte	0
 11983 05ee 00       		.byte	0
 11984 05ef 30       		.byte	48
 11985 05f0 01       		.byte	1
 11986 05f1 00       		.byte	0
 11987 05f2 00       		.byte	0
 11988 05f3 00000000 		.space	5
 11988      00
 11989 05f8 00       		.byte	0
 11990 05f9 00       		.byte	0
 11991 05fa 02       		.byte	2
 11992 05fb 00       		.byte	0
 11993 05fc 00       		.byte	0
 11994 05fd 64       		.byte	100
 11995 05fe 00       		.byte	0
 11996 05ff 01       		.byte	1
 11997 0600 00       		.byte	0
 11998 0601 03       		.byte	3
 11999 0602 00       		.byte	0
 12000 0603 00       		.byte	0
 12001 0604 00       		.byte	0
 12002 0605 00       		.byte	0
 12003 0606 00       		.byte	0
 12004 0607 30       		.byte	48
 12005 0608 01       		.byte	1
 12006 0609 00       		.byte	0
 12007 060a 00       		.byte	0
 12008 060b 00000000 		.space	5
 12008      00
 12011              	glProbeCtrl:
 12012 0610 00       		.byte	0
 12013 0611 00       		.byte	0
 12014 0612 01       		.byte	1
 12015 0613 01       		.byte	1
 12016 0614 15       		.byte	21
 12017 0615 16       		.byte	22
 12018 0616 05       		.byte	5
 12019 0617 00       		.byte	0
 12020 0618 00       		.byte	0
 12021 0619 00       		.byte	0
 12022 061a 00       		.byte	0
 12023 061b 00       		.byte	0
 12024 061c 00       		.byte	0
 12025 061d 00       		.byte	0
 12026 061e 00       		.byte	0
 12027 061f 00       		.byte	0
 12028 0620 00       		.byte	0
 12029 0621 00       		.byte	0
 12030 0622 00       		.byte	0
 12031 0623 48       		.byte	72
 12032 0624 3F       		.byte	63
 12033 0625 00       		.byte	0
 12034 0626 00       		.byte	0
 12035 0627 40       		.byte	64
 12036 0628 00       		.byte	0
 12037 0629 00       		.byte	0
 12038 062a 0000     		.space	2
 12041              	glProbeStilCtrl:
 12042 062c 01       		.byte	1
 12043 062d 01       		.byte	1
 12044 062e 00       		.byte	0
 12045 062f 00       		.byte	0
 12046 0630 48       		.byte	72
 12047 0631 3F       		.byte	63
 12048 0632 00       		.byte	0
 12049 0633 00       		.byte	0
 12050 0634 40       		.byte	64
 12051 0635 00       		.byte	0
 12052 0636 00       		.byte	0
 12053 0637 00       		.space	1
 12056              	glProbeStilCtrl20:
 12057 0638 01       		.byte	1
 12058 0639 01       		.byte	1
 12059 063a 00       		.byte	0
 12060 063b 00       		.byte	0
 12061 063c D2       		.byte	-46
 12062 063d 0F       		.byte	15
 12063 063e 00       		.byte	0
 12064 063f 00       		.byte	0
 12065 0640 40       		.byte	64
 12066 0641 00       		.byte	0
 12067 0642 00       		.byte	0
 12070              	snapButFlag:
 12071 0643 01       		.byte	1
 12074              	glProbeCtrl20:
 12075 0644 00       		.byte	0
 12076 0645 00       		.byte	0
 12077 0646 01       		.byte	1
 12078 0647 01       		.byte	1
 12079 0648 80       		.byte	-128
 12080 0649 1A       		.byte	26
 12081 064a 06       		.byte	6
 12082 064b 00       		.byte	0
 12083 064c 00       		.byte	0
 12084 064d 00       		.byte	0
 12085 064e 00       		.byte	0
 12086 064f 00       		.byte	0
 12087 0650 00       		.byte	0
 12088 0651 00       		.byte	0
 12089 0652 00       		.byte	0
 12090 0653 00       		.byte	0
 12091 0654 00       		.byte	0
 12092 0655 00       		.byte	0
 12093 0656 00       		.byte	0
 12094 0657 D2       		.byte	-46
 12095 0658 0F       		.byte	15
 12096 0659 00       		.byte	0
 12097 065a 00       		.byte	0
 12098 065b 40       		.byte	64
 12099 065c 00       		.byte	0
 12100 065d 00       		.byte	0
 12101 065e 0000     		.space	2
 12104              	CyFxGpifRegValue_usb2:
 12105 0660 08830080 		.word	-2147450104
 12106 0664 67000000 		.word	103
 12107 0668 01000000 		.word	1
 12108 066c 46000000 		.word	70
 12109 0670 00000000 		.word	0
 12110 0674 00000000 		.word	0
 12111 0678 02000000 		.word	2
 12112 067c 82000000 		.word	130
 12113 0680 82070000 		.word	1922
 12114 0684 40040000 		.word	1088
 12115 0688 FCFF0000 		.word	65532
 12116 068c 28000000 		.word	40
 12117 0690 00000000 		.word	0
 12118 0694 00000000 		.word	0
 12119 0698 00000000 		.word	0
 12120 069c 00000000 		.word	0
 12121 06a0 01000000 		.word	1
 12122 06a4 00000000 		.word	0
 12123 06a8 00000000 		.word	0
 12124 06ac 00000000 		.word	0
 12125 06b0 00000000 		.word	0
 12126 06b4 00000000 		.word	0
 12127 06b8 00000000 		.word	0
 12128 06bc 00000000 		.word	0
 12129 06c0 00000000 		.word	0
 12130 06c4 00000000 		.word	0
 12131 06c8 00000000 		.word	0
 12132 06cc 00000000 		.word	0
 12133 06d0 00000000 		.word	0
 12134 06d4 06000000 		.word	6
 12135 06d8 00000000 		.word	0
 12136 06dc FFFF0000 		.word	65535
 12137 06e0 09010000 		.word	265
 12138 06e4 00000000 		.word	0
 12139 06e8 F71F0000 		.word	8183
 12140 06ec 00000000 		.word	0
 12141 06f0 FFFF0000 		.word	65535
 12142 06f4 09010000 		.word	265
 12143 06f8 00000000 		.word	0
 12144 06fc F71F0000 		.word	8183
 12145 0700 00000000 		.word	0
 12146 0704 00000000 		.word	0
 12147 0708 00000000 		.word	0
 12148 070c 00000000 		.word	0
 12149 0710 00000000 		.word	0
 12150 0714 00000000 		.word	0
 12151 0718 00000000 		.word	0
 12152 071c 00000000 		.word	0
 12153 0720 00000000 		.word	0
 12154 0724 00000000 		.word	0
 12155 0728 00000000 		.word	0
 12156 072c 00000000 		.word	0
 12157 0730 00000000 		.word	0
 12158 0734 00000000 		.word	0
 12159 0738 00000000 		.word	0
 12160 073c 00000000 		.word	0
 12161 0740 00000000 		.word	0
 12162 0744 00000000 		.word	0
 12163 0748 00000000 		.word	0
 12164 074c 00000000 		.word	0
 12165 0750 00000000 		.word	0
 12166 0754 00000000 		.word	0
 12167 0758 00000000 		.word	0
 12168 075c 00040180 		.word	-2147417088
 12169 0760 01040180 		.word	-2147417087
 12170 0764 02040180 		.word	-2147417086
 12171 0768 03040180 		.word	-2147417085
 12172 076c 00000000 		.word	0
 12173 0770 00000000 		.word	0
 12174 0774 00000000 		.word	0
 12175 0778 00000000 		.word	0
 12176 077c 00000000 		.word	0
 12177 0780 00000000 		.word	0
 12178 0784 00000000 		.word	0
 12179 0788 00000000 		.word	0
 12180 078c C1FFFFFF 		.word	-63
 12183              	CyFxGpifWavedataPosition_usb2:
 12184 0790 00       		.byte	0
 12185 0791 01       		.byte	1
 12186 0792 02       		.byte	2
 12187 0793 03       		.byte	3
 12188 0794 04       		.byte	4
 12189 0795 05       		.byte	5
 12190 0796 06       		.byte	6
 12191 0797 07       		.byte	7
 12192 0798 08       		.byte	8
 12193 0799 09       		.byte	9
 12194 079a 0A       		.byte	10
 12195 079b 08       		.byte	8
 12196 079c 0B       		.byte	11
 12197 079d 0C       		.byte	12
 12198 079e 0D       		.byte	13
 12199 079f 08       		.byte	8
 12200 07a0 0E       		.byte	14
 12201 07a1 0F       		.byte	15
 12202 07a2 08       		.byte	8
 12203 07a3 08       		.byte	8
 12204 07a4 08       		.byte	8
 12205 07a5 08       		.byte	8
 12206 07a6 08       		.byte	8
 12207 07a7 08       		.byte	8
 12208 07a8 08       		.byte	8
 12209 07a9 08       		.byte	8
 12210 07aa 08       		.byte	8
 12211 07ab 08       		.byte	8
 12212 07ac 08       		.byte	8
 12213 07ad 08       		.byte	8
 12214 07ae 08       		.byte	8
 12215 07af 08       		.byte	8
 12216 07b0 08       		.byte	8
 12217 07b1 08       		.byte	8
 12218 07b2 08       		.byte	8
 12219 07b3 08       		.byte	8
 12220 07b4 08       		.byte	8
 12221 07b5 08       		.byte	8
 12222 07b6 08       		.byte	8
 12223 07b7 08       		.byte	8
 12224 07b8 08       		.byte	8
 12225 07b9 08       		.byte	8
 12226 07ba 08       		.byte	8
 12227 07bb 08       		.byte	8
 12228 07bc 08       		.byte	8
 12229 07bd 08       		.byte	8
 12230 07be 08       		.byte	8
 12231 07bf 08       		.byte	8
 12232 07c0 08       		.byte	8
 12233 07c1 08       		.byte	8
 12234 07c2 08       		.byte	8
 12235 07c3 08       		.byte	8
 12236 07c4 08       		.byte	8
 12237 07c5 08       		.byte	8
 12238 07c6 08       		.byte	8
 12239 07c7 08       		.byte	8
 12240 07c8 08       		.byte	8
 12241 07c9 08       		.byte	8
 12242 07ca 08       		.byte	8
 12243 07cb 08       		.byte	8
 12244 07cc 08       		.byte	8
 12245 07cd 08       		.byte	8
 12246 07ce 08       		.byte	8
 12247 07cf 08       		.byte	8
 12248 07d0 08       		.byte	8
 12249 07d1 08       		.byte	8
 12250 07d2 08       		.byte	8
 12251 07d3 08       		.byte	8
 12252 07d4 08       		.byte	8
 12253 07d5 08       		.byte	8
 12254 07d6 08       		.byte	8
 12255 07d7 08       		.byte	8
 12256 07d8 08       		.byte	8
 12257 07d9 08       		.byte	8
 12258 07da 08       		.byte	8
 12259 07db 08       		.byte	8
 12260 07dc 08       		.byte	8
 12261 07dd 08       		.byte	8
 12262 07de 08       		.byte	8
 12263 07df 08       		.byte	8
 12264 07e0 08       		.byte	8
 12265 07e1 08       		.byte	8
 12266 07e2 08       		.byte	8
 12267 07e3 08       		.byte	8
 12268 07e4 08       		.byte	8
 12269 07e5 08       		.byte	8
 12270 07e6 08       		.byte	8
 12271 07e7 08       		.byte	8
 12272 07e8 08       		.byte	8
 12273 07e9 08       		.byte	8
 12274 07ea 08       		.byte	8
 12275 07eb 08       		.byte	8
 12276 07ec 08       		.byte	8
 12277 07ed 08       		.byte	8
 12278 07ee 08       		.byte	8
 12279 07ef 08       		.byte	8
 12280 07f0 08       		.byte	8
 12281 07f1 08       		.byte	8
 12282 07f2 08       		.byte	8
 12283 07f3 08       		.byte	8
 12284 07f4 08       		.byte	8
 12285 07f5 08       		.byte	8
 12286 07f6 08       		.byte	8
 12287 07f7 08       		.byte	8
 12288 07f8 08       		.byte	8
 12289 07f9 08       		.byte	8
 12290 07fa 08       		.byte	8
 12291 07fb 08       		.byte	8
 12292 07fc 08       		.byte	8
 12293 07fd 08       		.byte	8
 12294 07fe 08       		.byte	8
 12295 07ff 08       		.byte	8
 12296 0800 08       		.byte	8
 12297 0801 08       		.byte	8
 12298 0802 08       		.byte	8
 12299 0803 08       		.byte	8
 12300 0804 08       		.byte	8
 12301 0805 08       		.byte	8
 12302 0806 08       		.byte	8
 12303 0807 08       		.byte	8
 12304 0808 08       		.byte	8
 12305 0809 08       		.byte	8
 12306 080a 08       		.byte	8
 12307 080b 08       		.byte	8
 12308 080c 08       		.byte	8
 12309 080d 08       		.byte	8
 12310 080e 08       		.byte	8
 12311 080f 08       		.byte	8
 12312 0810 00       		.byte	0
 12313 0811 01       		.byte	1
 12314 0812 02       		.byte	2
 12315 0813 10       		.byte	16
 12316 0814 04       		.byte	4
 12317 0815 05       		.byte	5
 12318 0816 06       		.byte	6
 12319 0817 07       		.byte	7
 12320 0818 08       		.byte	8
 12321 0819 09       		.byte	9
 12322 081a 0A       		.byte	10
 12323 081b 08       		.byte	8
 12324 081c 11       		.byte	17
 12325 081d 0C       		.byte	12
 12326 081e 0D       		.byte	13
 12327 081f 08       		.byte	8
 12328 0820 0E       		.byte	14
 12329 0821 0F       		.byte	15
 12330 0822 08       		.byte	8
 12331 0823 00       		.space	1
 12334              	CyFxGpifWavedata_usb2:
 12335 0824 0181731E 		.word	510886145
 12336 0828 00000000 		.word	0
 12337 082c 00000080 		.word	-2147483648
 12338 0830 00000000 		.word	0
 12339 0834 00000000 		.word	0
 12340 0838 00000000 		.word	0
 12341 083c 0201703E 		.word	1047527682
 12342 0840 00010000 		.word	256
 12343 0844 A00000C0 		.word	-1073741664
 12344 0848 00000000 		.word	0
 12345 084c 00000000 		.word	0
 12346 0850 00000000 		.word	0
 12347 0854 0394731E 		.word	510891011
 12348 0858 04000020 		.word	536870916
 12349 085c 60004080 		.word	-2143289248
 12350 0860 00000000 		.word	0
 12351 0864 00000000 		.word	0
 12352 0868 00000000 		.word	0
 12353 086c 0620702E 		.word	779100166
 12354 0870 0C000000 		.word	12
 12355 0874 00000080 		.word	-2147483648
 12356 0878 0620702E 		.word	779100166
 12357 087c 0C000000 		.word	12
 12358 0880 00000080 		.word	-2147483648
 12359 0884 0394731E 		.word	510891011
 12360 0888 04000020 		.word	536870916
 12361 088c 60004080 		.word	-2143289248
 12362 0890 0620702E 		.word	779100166
 12363 0894 0C000000 		.word	12
 12364 0898 00000080 		.word	-2147483648
 12365 089c 0C93731E 		.word	510890764
 12366 08a0 04000024 		.word	603979780
 12367 08a4 90004080 		.word	-2143289200
 12368 08a8 0D20702E 		.word	779100173
 12369 08ac 0C000000 		.word	12
 12370 08b0 00000080 		.word	-2147483648
 12371 08b4 0780724E 		.word	1316126727
 12372 08b8 0A000000 		.word	10
 12373 08bc 00000080 		.word	-2147483648
 12374 08c0 08000000 		.word	8
 12375 08c4 00000000 		.word	0
 12376 08c8 00010080 		.word	-2147483392
 12377 08cc 0920702E 		.word	779100169
 12378 08d0 0C010000 		.word	268
 12379 08d4 00000080 		.word	-2147483648
 12380 08d8 0A01701E 		.word	510656778
 12381 08dc 0E000100 		.word	65550
 12382 08e0 00000080 		.word	-2147483648
 12383 08e4 00000000 		.word	0
 12384 08e8 00000000 		.word	0
 12385 08ec 00000000 		.word	0
 12386 08f0 00000000 		.word	0
 12387 08f4 00000000 		.word	0
 12388 08f8 00000000 		.word	0
 12389 08fc 0394731E 		.word	510891011
 12390 0900 04000020 		.word	536870916
 12391 0904 60004080 		.word	-2143289248
 12392 0908 08000000 		.word	8
 12393 090c 00000000 		.word	0
 12394 0910 00010080 		.word	-2147483392
 12395 0914 0B000000 		.word	11
 12396 0918 00000000 		.word	0
 12397 091c 00010080 		.word	-2147483392
 12398 0920 0C93731E 		.word	510890764
 12399 0924 04000024 		.word	603979780
 12400 0928 90004080 		.word	-2143289200
 12401 092c 0D20702E 		.word	779100173
 12402 0930 0C000000 		.word	12
 12403 0934 00000080 		.word	-2147483648
 12404 0938 0D20702E 		.word	779100173
 12405 093c 0C000000 		.word	12
 12406 0940 00000080 		.word	-2147483648
 12407 0944 0E60724E 		.word	1316118542
 12408 0948 0A000000 		.word	10
 12409 094c 00000080 		.word	-2147483648
 12410 0950 0F000000 		.word	15
 12411 0954 00000000 		.word	0
 12412 0958 00010080 		.word	-2147483392
 12413 095c 1020702E 		.word	779100176
 12414 0960 0C010000 		.word	268
 12415 0964 00000080 		.word	-2147483648
 12416 0968 1101701E 		.word	510656785
 12417 096c 0E000100 		.word	65550
 12418 0970 00000080 		.word	-2147483648
 12419 0974 0C93731E 		.word	510890764
 12420 0978 04000024 		.word	603979780
 12421 097c 90004080 		.word	-2143289200
 12422 0980 0F000000 		.word	15
 12423 0984 00000000 		.word	0
 12424 0988 00010080 		.word	-2147483392
 12425 098c 12000000 		.word	18
 12426 0990 00000000 		.word	0
 12427 0994 00010080 		.word	-2147483392
 12428 0998 0394731E 		.word	510891011
 12429 099c 04000020 		.word	536870916
 12430 09a0 60004080 		.word	-2143289248
 12431 09a4 0480732E 		.word	779321348
 12432 09a8 02010000 		.word	258
 12433 09ac 000040C0 		.word	-1069547520
 12434 09b0 0580732E 		.word	779321349
 12435 09b4 02010000 		.word	258
 12436 09b8 000040C0 		.word	-1069547520
 12437 09bc 0580732E 		.word	779321349
 12438 09c0 02010000 		.word	258
 12439 09c4 000040C0 		.word	-1069547520
 12440 09c8 0480732E 		.word	779321348
 12441 09cc 02010000 		.word	258
 12442 09d0 000040C0 		.word	-1069547520
 12445              	CyFxGpifTransition_usb2:
 12446 09d4 0000     		.short	0
 12447 09d6 5555     		.short	21845
 12448 09d8 AAAA     		.short	-21846
 12449 09da 8888     		.short	-30584
 12450 09dc 1111     		.short	4369
 12451 09de 4444     		.short	17476
 12452 09e0 3333     		.short	13107
 12453 09e2 CCCC     		.short	-13108
 12456              	CyFxGpifRegValue:
 12457 09e4 08830080 		.word	-2147450104
 12458 09e8 67000000 		.word	103
 12459 09ec 00000000 		.word	0
 12460 09f0 46000000 		.word	70
 12461 09f4 00000000 		.word	0
 12462 09f8 00000000 		.word	0
 12463 09fc 02000000 		.word	2
 12464 0a00 82000000 		.word	130
 12465 0a04 82070000 		.word	1922
 12466 0a08 40040000 		.word	1088
 12467 0a0c FCFF0000 		.word	65532
 12468 0a10 28000000 		.word	40
 12469 0a14 00000000 		.word	0
 12470 0a18 00000000 		.word	0
 12471 0a1c 00000000 		.word	0
 12472 0a20 00000000 		.word	0
 12473 0a24 01000000 		.word	1
 12474 0a28 00000000 		.word	0
 12475 0a2c 00000000 		.word	0
 12476 0a30 00000000 		.word	0
 12477 0a34 00000000 		.word	0
 12478 0a38 00000000 		.word	0
 12479 0a3c 00000000 		.word	0
 12480 0a40 00000000 		.word	0
 12481 0a44 00000000 		.word	0
 12482 0a48 00000000 		.word	0
 12483 0a4c 00000000 		.word	0
 12484 0a50 00000000 		.word	0
 12485 0a54 00000000 		.word	0
 12486 0a58 06000000 		.word	6
 12487 0a5c 00000000 		.word	0
 12488 0a60 FFFF0000 		.word	65535
 12489 0a64 09010000 		.word	265
 12490 0a68 00000000 		.word	0
 12491 0a6c F71F0000 		.word	8183
 12492 0a70 00000000 		.word	0
 12493 0a74 FFFF0000 		.word	65535
 12494 0a78 09010000 		.word	265
 12495 0a7c 00000000 		.word	0
 12496 0a80 F71F0000 		.word	8183
 12497 0a84 00000000 		.word	0
 12498 0a88 00000000 		.word	0
 12499 0a8c 00000000 		.word	0
 12500 0a90 00000000 		.word	0
 12501 0a94 00000000 		.word	0
 12502 0a98 00000000 		.word	0
 12503 0a9c 00000000 		.word	0
 12504 0aa0 00000000 		.word	0
 12505 0aa4 00000000 		.word	0
 12506 0aa8 00000000 		.word	0
 12507 0aac 00000000 		.word	0
 12508 0ab0 00000000 		.word	0
 12509 0ab4 00000000 		.word	0
 12510 0ab8 00000000 		.word	0
 12511 0abc 00000000 		.word	0
 12512 0ac0 00000000 		.word	0
 12513 0ac4 00000000 		.word	0
 12514 0ac8 00000000 		.word	0
 12515 0acc 00000000 		.word	0
 12516 0ad0 00000000 		.word	0
 12517 0ad4 00000000 		.word	0
 12518 0ad8 00000000 		.word	0
 12519 0adc 00000000 		.word	0
 12520 0ae0 00040180 		.word	-2147417088
 12521 0ae4 01040180 		.word	-2147417087
 12522 0ae8 02040180 		.word	-2147417086
 12523 0aec 03040180 		.word	-2147417085
 12524 0af0 00000000 		.word	0
 12525 0af4 00000000 		.word	0
 12526 0af8 00000000 		.word	0
 12527 0afc 00000000 		.word	0
 12528 0b00 00000000 		.word	0
 12529 0b04 00000000 		.word	0
 12530 0b08 00000000 		.word	0
 12531 0b0c 00000000 		.word	0
 12532 0b10 C1FFFFFF 		.word	-63
 12535              	CyFxGpifWavedataPosition:
 12536 0b14 00       		.byte	0
 12537 0b15 01       		.byte	1
 12538 0b16 02       		.byte	2
 12539 0b17 03       		.byte	3
 12540 0b18 04       		.byte	4
 12541 0b19 05       		.byte	5
 12542 0b1a 06       		.byte	6
 12543 0b1b 07       		.byte	7
 12544 0b1c 08       		.byte	8
 12545 0b1d 09       		.byte	9
 12546 0b1e 0A       		.byte	10
 12547 0b1f 0B       		.byte	11
 12548 0b20 0B       		.byte	11
 12549 0b21 0B       		.byte	11
 12550 0b22 0B       		.byte	11
 12551 0b23 00       		.space	1
 12554              	CyFxGpifWavedata:
 12555 0b24 0181731E 		.word	510886145
 12556 0b28 00000000 		.word	0
 12557 0b2c 00000080 		.word	-2147483648
 12558 0b30 00000000 		.word	0
 12559 0b34 00000000 		.word	0
 12560 0b38 00000000 		.word	0
 12561 0b3c 0201702E 		.word	779092226
 12562 0b40 00010000 		.word	256
 12563 0b44 A0000080 		.word	-2147483488
 12564 0b48 00000000 		.word	0
 12565 0b4c 00000000 		.word	0
 12566 0b50 00000000 		.word	0
 12567 0b54 0380722E 		.word	779255811
 12568 0b58 02010020 		.word	536871170
 12569 0b5c 60000080 		.word	-2147483552
 12570 0b60 00000000 		.word	0
 12571 0b64 00000000 		.word	0
 12572 0b68 00000000 		.word	0
 12573 0b6c 0460722E 		.word	779247620
 12574 0b70 02010024 		.word	603980034
 12575 0b74 90000080 		.word	-2147483504
 12576 0b78 0594731E 		.word	510891013
 12577 0b7c 06000000 		.word	6
 12578 0b80 00000080 		.word	-2147483648
 12579 0b84 0380722E 		.word	779255811
 12580 0b88 02010020 		.word	536871170
 12581 0b8c 60000080 		.word	-2147483552
 12582 0b90 0693731E 		.word	510890758
 12583 0b94 06000000 		.word	6
 12584 0b98 00000080 		.word	-2147483648
 12585 0b9c 0720703E 		.word	1047535623
 12586 0ba0 08010000 		.word	264
 12587 0ba4 00000080 		.word	-2147483648
 12588 0ba8 0820703E 		.word	1047535624
 12589 0bac 08010000 		.word	264
 12590 0bb0 00000080 		.word	-2147483648
 12591 0bb4 0920703E 		.word	1047535625
 12592 0bb8 08010000 		.word	264
 12593 0bbc 00000080 		.word	-2147483648
 12594 0bc0 0A20703E 		.word	1047535626
 12595 0bc4 08010000 		.word	264
 12596 0bc8 00000080 		.word	-2147483648
 12597 0bcc 0380722E 		.word	779255811
 12598 0bd0 02010020 		.word	536871170
 12599 0bd4 60000080 		.word	-2147483552
 12600 0bd8 0B000000 		.word	11
 12601 0bdc 00000000 		.word	0
 12602 0be0 00010080 		.word	-2147483392
 12603 0be4 0460722E 		.word	779247620
 12604 0be8 02010024 		.word	603980034
 12605 0bec 90000080 		.word	-2147483504
 12606 0bf0 0D000000 		.word	13
 12607 0bf4 00000000 		.word	0
 12608 0bf8 00010080 		.word	-2147483392
 12609 0bfc 0460722E 		.word	779247620
 12610 0c00 02010024 		.word	603980034
 12611 0c04 90000080 		.word	-2147483504
 12612 0c08 0C000000 		.word	12
 12613 0c0c 00000000 		.word	0
 12614 0c10 00010080 		.word	-2147483392
 12615 0c14 0380722E 		.word	779255811
 12616 0c18 02010020 		.word	536871170
 12617 0c1c 60000080 		.word	-2147483552
 12618 0c20 0E000000 		.word	14
 12619 0c24 00000000 		.word	0
 12620 0c28 00010080 		.word	-2147483392
 12621 0c2c 00000000 		.word	0
 12622 0c30 00000000 		.word	0
 12623 0c34 00000000 		.word	0
 12624 0c38 00000000 		.word	0
 12625 0c3c 00000000 		.word	0
 12626 0c40 00000000 		.word	0
 12629              	CyFxGpifTransition:
 12630 0c44 0000     		.short	0
 12631 0c46 5555     		.short	21845
 12632 0c48 8888     		.short	-30584
 12633 0c4a AAAA     		.short	-21846
 12634 0c4c 3333     		.short	13107
 12635 0c4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 12636              		.align	2
 12637              	.LC0:
 12638 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 12638      7065722D 
 12638      74696D65 
 12638      72202564 
 12638      0D0A00
 12639 0013 00       		.space	1
 12640              	.LC1:
 12641 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 12641      636F6D6D 
 12641      616E6420 
 12641      71756575 
 12641      65206973 
 12642 0037 00       		.space	1
 12643              	.LC2:
 12644 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 12644      7220696E 
 12644      206D756C 
 12644      74696368 
 12644      616E6E65 
 12645 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 12645      2C20646D 
 12645      61446F6E 
 12645      65202578 
 12645      0D0A00
 12646 007e 0000     		.space	2
 12647              	.LC3:
 12648 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 12648      5420656E 
 12648      636F756E 
 12648      74657265 
 12648      642E2E2E 
 12649              	.LC4:
 12650 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 12650      454E4420 
 12650      656E636F 
 12650      756E7465 
 12650      7265642E 
 12651 00c2 0000     		.space	2
 12652              	.LC5:
 12653 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 12653      64697363 
 12653      6F6E6E65 
 12653      63746564 
 12653      2E2E2E30 
 12654 00e3 00       		.space	1
 12655              	.LC6:
 12656 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 12656      43595F46 
 12656      585F5556 
 12656      435F5649 
 12656      44454F5F 
 12657 0117 0A00     		.ascii	"\012\000"
 12658 0119 000000   		.space	3
 12659              	.LC7:
 12660 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 12660      43595F46 
 12660      585F5556 
 12660      435F5649 
 12660      44454F5F 
 12661 014f 00       		.ascii	"\000"
 12662              	.LC8:
 12663 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 12663      726E6174 
 12663      65207365 
 12663      7474696E 
 12663      6720302E 
 12664              	.LC9:
 12665 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 12665      72206665 
 12665      61747572 
 12665      65207265 
 12665      71756573 
 12666 018b 00       		.space	1
 12667              	.LC10:
 12668 018c 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 12668      49324320 
 12668      636F6D6D 
 12668      616E6420 
 12668      69732030 
 12669 01bf 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 12669      78257820 
 12669      30782578 
 12669      20307825 
 12669      78203078 
 12670              	.LC11:
 12671 01d8 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 12671      206C6967 
 12671      68742063 
 12671      6F6D7065 
 12671      6E736174 
 12672 020b 25640D0A 		.ascii	"%d\015\012\000"
 12672      00
 12673              	.LC12:
 12674 0210 54686520 		.ascii	"The I2C current data is not available. try again. %"
 12674      49324320 
 12674      63757272 
 12674      656E7420 
 12674      64617461 
 12675 0243 64202564 		.ascii	"d %d\015\012\000"
 12675      0D0A00
 12676 024a 0000     		.space	2
 12677              	.LC13:
 12678 024c 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 12678      26414743 
 12678      2073656E 
 12678      7420746F 
 12678      20686F73 
 12679 0272 0000     		.space	2
 12680              	.LC14:
 12681 0274 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 12681      26414743 
 12681      20676F74 
 12681      74656E20 
 12681      66726F6D 
 12682 029e 0000     		.space	2
 12683              	.LC15:
 12684 02a0 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 12684      6C657665 
 12684      6C2E2025 
 12684      64202564 
 12684      3B202564 
 12685 02ba 0000     		.space	2
 12686              	.LC16:
 12687 02bc 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 12687      7365742E 
 12687      20256420 
 12687      25643B20 
 12687      25642025 
 12688              	.LC17:
 12689 02d4 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 12689      67657420 
 12689      64617461 
 12689      2066726F 
 12689      6D20686F 
 12690 0301 000000   		.space	3
 12691              	.LC18:
 12692 0304 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 12692      52657175 
 12692      65737420 
 12692      30782578 
 12692      20706172 
 12693 0337 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 12693      6E642074 
 12693      6F20686F 
 12693      73742030 
 12693      78257820 
 12694 0352 0000     		.space	2
 12695              	.LC19:
 12696 0354 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 12696      204F7020 
 12696      72656365 
 12696      69766573 
 12696      20284354 
 12697 037b 00       		.space	1
 12698              	.LC20:
 12699 037c 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 12699      756C7420 
 12699      73656C65 
 12699      63746F72 
 12699      20284354 
 12700 039e 0000     		.space	2
 12701              	.LC21:
 12702 03a0 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 12702      756C7420 
 12702      72657175 
 12702      65737420 
 12702      28435429 
 12703 03c1 000000   		.space	3
 12704              	.LC22:
 12705 03c4 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 12705      52657175 
 12705      65737420 
 12705      30782578 
 12705      20706172 
 12706 03f7 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 12706      20307825 
 12706      78202F20 
 12706      73656E64 
 12706      20746F20 
 12707 0424 00       		.ascii	"\000"
 12708 0425 000000   		.space	3
 12709              	.LC23:
 12710 0428 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 12710      73657420 
 12710      64656620 
 12710      64617461 
 12710      20307825 
 12711 0447 00       		.space	1
 12712              	.LC24:
 12713 0448 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 12713      73657420 
 12713      64656620 
 12713      64617461 
 12713      20307825 
 12714 047b 2E0D0A00 		.ascii	".\015\012\000"
 12715 047f 00       		.space	1
 12716              	.LC25:
 12717 0480 4572726F 		.ascii	"Error handler...\015\012\000"
 12717      72206861 
 12717      6E646C65 
 12717      722E2E2E 
 12717      0D0A00
 12718 0493 00       		.space	1
 12719              	.LC26:
 12720 0494 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 12720      73706565 
 12720      64203D20 
 12720      25642065 
 12720      76656E66 
 12721 04c4 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 12721      71756573 
 12721      74203D20 
 12721      30782578 
 12721      20775661 
 12722 04f4 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 12722      203D2030 
 12722      78257820 
 12722      6973666C 
 12722      61672030 
 12723 050e 0000     		.space	2
 12724              	.LC27:
 12725 0510 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 12725      64656661 
 12725      756C7420 
 12725      73657475 
 12725      70207265 
 12726              	.LC28:
 12727 053c 47657420 		.ascii	"Get UVC Prob(set) control %d %d %d\015\012\000"
 12727      55564320 
 12727      50726F62 
 12727      28736574 
 12727      2920636F 
 12728 0561 000000   		.space	3
 12729              	.LC29:
 12730 0564 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 12730      74686520 
 12730      76696465 
 12730      6F206D6F 
 12730      64652066 
 12731 0585 000000   		.space	3
 12732              	.LC30:
 12733 0588 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 12733      74686520 
 12733      76696465 
 12733      6F206D6F 
 12733      64652066 
 12734 05ad 000000   		.space	3
 12735              	.LC31:
 12736 05b0 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 12736      43595F46 
 12736      585F5556 
 12736      435F5354 
 12736      5245414D 
 12737 05d6 0000     		.space	2
 12738              	.LC32:
 12739 05d8 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 12739      55564320 
 12739      7374696C 
 12739      6C205072 
 12739      6F622873 
 12740 0603 00       		.space	1
 12741              	.LC33:
 12742 0604 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 12742      74686520 
 12742      7374696C 
 12742      6C206D6F 
 12742      64652066 
 12743 0625 000000   		.space	3
 12744              	.LC34:
 12745 0628 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 12745      7374696C 
 12745      6C20636F 
 12745      6D6D6974 
 12745      20636F6E 
 12746              	.LC35:
 12747 0650 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 12747      43595F46 
 12747      585F5556 
 12747      435F5354 
 12747      494C5F45 
 12748              	.LC36:
 12749 0674 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 12749      55564320 
 12749      7374696C 
 12749      6C207472 
 12749      69676765 
 12750 069d 000000   		.space	3
 12751              	.LC37:
 12752 06a0 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 12752      7374696C 
 12752      6C207472 
 12752      69676765 
 12752      7220636F 
 12753 06c7 00       		.space	1
 12754              	.LC38:
 12755 06c8 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 12755      65642074 
 12755      6F207365 
 12755      6E642069 
 12755      6E746572 
 12756 06f9 0A00     		.ascii	"\012\000"
 12757 06fb 00       		.space	1
 12758              	.LC39:
 12759 06fc 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 12759      6F6D6D69 
 12759      74656F66 
 12759      20737461 
 12759      7465203D 
 12760              	.LC40:
 12761 0714 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 12761      6E656C20 
 12761      53657420 
 12761      57726170 
 12761      55702066 
 12762 0741 000000   		.space	3
 12763              	.LC41:
 12764 0744 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 12764      69742045 
 12764      4F462066 
 12764      61696C65 
 12764      64210A00 
 12765              	.LC42:
 12766 0758 49324320 		.ascii	"I2C initialization failed!\012\000"
 12766      696E6974 
 12766      69616C69 
 12766      7A617469 
 12766      6F6E2066 
 12767              	.LC43:
 12768 0774 49324320 		.ascii	"I2C configuration failed!\012\000"
 12768      636F6E66 
 12768      69677572 
 12768      6174696F 
 12768      6E206661 
 12769 078f 00       		.space	1
 12770              	.LC44:
 12771 0790 55415254 		.ascii	"UART initialization failed!\012\000"
 12771      20696E69 
 12771      7469616C 
 12771      697A6174 
 12771      696F6E20 
 12772 07ad 000000   		.space	3
 12773              	.LC45:
 12774 07b0 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 12774      43726561 
 12774      74652045 
 12774      76656E74 
 12774      20666169 
 12775 07da 0000     		.space	2
 12776              	.LC46:
 12777 07dc 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 12777      20496E69 
 12777      74206661 
 12777      696C6564 
 12777      2C204572 
 12778 07ff 00       		.space	1
 12779              	.LC47:
 12780 0800 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 12780      204F7665 
 12780      72726964 
 12780      65206661 
 12780      696C6564 
 12781 0827 00       		.space	1
 12782              	.LC48:
 12783 0828 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 12783      28323029 
 12783      204F7665 
 12783      72726964 
 12783      65206661 
 12784 0853 00       		.space	1
 12785              	.LC49:
 12786 0854 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 12786      28323429 
 12786      204F7665 
 12786      72726964 
 12786      65206661 
 12787 087f 00       		.space	1
 12788              	.LC50:
 12789 0880 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 12789      20536574 
 12789      20287265 
 12789      73657420 
 12789      32322920 
 12790 08b2 00       		.ascii	"\000"
 12791 08b3 00       		.space	1
 12792              	.LC51:
 12793 08b4 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 12793      20536574 
 12793      2028706F 
 12793      77657220 
 12793      32302920 
 12794 08e6 00       		.ascii	"\000"
 12795 08e7 00       		.space	1
 12796              	.LC52:
 12797 08e8 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 12797      20536574 
 12797      2028736E 
 12797      61702073 
 12797      686F7420 
 12798 091b 25640A00 		.ascii	"%d\012\000"
 12799 091f 00       		.space	1
 12800              	.LC53:
 12801 0920 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 12801      46756E63 
 12801      74696F6E 
 12801      20466169 
 12801      6C656420 
 12802 094f 00       		.space	1
 12803              	.LC54:
 12804 0950 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 12804      46756E63 
 12804      74696F6E 
 12804      20466169 
 12804      6C656420 
 12805 097f 00       		.space	1
 12806              	.LC55:
 12807 0980 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 12807      53657420 
 12807      456E6470 
 12807      6F696E74 
 12807      20636F6E 
 12808 09b0 00       		.ascii	"\000"
 12809 09b1 000000   		.space	3
 12810              	.LC56:
 12811 09b4 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 12811      496E7465 
 12811      72727570 
 12811      74205374 
 12811      61747573 
 12812 09e7 20436F64 		.ascii	" Code = %d\012\000"
 12812      65203D20 
 12812      25640A00 
 12813 09f3 00       		.space	1
 12814              	.LC57:
 12815 09f4 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 12815      65642074 
 12815      6F20616C 
 12815      6C6F6361 
 12815      7465206D 
 12816 0a27 65720D0A 		.ascii	"er\015\012\000"
 12816      00
 12817              	.LC58:
 12818 0a2c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 12818      4368616E 
 12818      6E656C20 
 12818      43726561 
 12818      74696F6E 
 12819 0a5a 0000     		.space	2
 12820              	.LC59:
 12821 0a5c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 12821      436F6E6E 
 12821      65637420 
 12821      6661696C 
 12821      65642C20 
 12822 0a81 000000   		.space	3
 12823              	.LC60:
 12824 0a84 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 12824      74686520 
 12824      76696465 
 12824      6F206D6F 
 12824      64652066 
 12825 0aa6 0000     		.space	2
 12826              	.LC61:
 12827 0aa8 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 12827      4368616E 
 12827      6E656C20 
 12827      52657365 
 12827      74204661 
 12828 0ad3 00       		.space	1
 12829              	.LC62:
 12830 0ad4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 12830      4368616E 
 12830      6E656C20 
 12830      53657420 
 12830      5472616E 
 12831 0b05 00       		.ascii	"\000"
 12832 0b06 0000     		.space	2
 12833              	.LC63:
 12834 0b08 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 12834      4368616E 
 12834      6E656C20 
 12834      53657420 
 12834      5472616E 
 12835 0b39 0A00     		.ascii	"\012\000"
 12836 0b3b 00       		.space	1
 12837              	.LC64:
 12838 0b3c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 12838      75706572 
 12838      20677069 
 12838      6600
 12839 0b4a 0000     		.space	2
 12840              	.LC65:
 12841 0b4c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 12841      69676820 
 12841      67706966 
 12841      00
 12842 0b59 000000   		.space	3
 12843              	.LC66:
 12844 0b5c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 12844      696E6720 
 12844      47504946 
 12844      20436F6E 
 12844      66696775 
 12845 0b8f 0A00     		.ascii	"\012\000"
 12846 0b91 000000   		.space	3
 12847              	.LC67:
 12848 0b94 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 12848      74696E67 
 12848      20475049 
 12848      46207374 
 12848      61746520 
 12849 0bc7 0D0A00   		.ascii	"\015\012\000"
 12850 0bca 0000     		.space	2
 12851              	.LC68:
 12852 0bcc 33303A55 		.ascii	"30:UVC App Thread\000"
 12852      56432041 
 12852      70702054 
 12852      68726561 
 12852      6400
 12853 0bde 0000     		.space	2
 12854              	.LC69:
 12855 0be0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 12855      56432041 
 12855      70702045 
 12855      50302054 
 12855      68726561 
 12856 0bf6 0000     		.space	2
 12857              	.LC70:
 12858 0bf8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 12858      32432041 
 12858      70702043 
 12858      54524C20 
 12858      54687265 
 12859 0c0f 00       		.bss
 12860              		.align	2
 12861              		.set	.LANCHOR0,. + 0
 12864              	glFxUVCEvent:
 12865 0000 00000000 		.space	40
 12865      00000000 
 12865      00000000 
 12865      00000000 
 12865      00000000 
 12868              	fb:
 12869 0028 0000     		.space	2
 12872              	pb:
 12873 002a 0000     		.space	2
 12876              	pbc:
 12877 002c 0000     		.space	2
 12878 002e 0000     		.space	2
 12881              	stiflag:
 12882 0030 00000000 		.space	4
 12885              	hitFV:
 12886 0034 00000000 		.space	4
 12889              	prodCount:
 12890 0038 0000     		.space	2
 12893              	consCount:
 12894 003a 0000     		.space	2
 12897              	streamingStarted:
 12898 003c 00000000 		.space	4
 12901              	gpif_initialized:
 12902 0040 00000000 		.space	4
 12905              	isUsbConnected:
 12906 0044 00000000 		.space	4
 12909              	clearFeatureRqtReceived:
 12910 0048 00000000 		.space	4
 12913              	I2CCMDArry:
 12914 004c 00000000 		.space	12
 12914      00000000 
 12914      00000000 
 12917              	glEp0Buffer:
 12918 0058 00000000 		.space	32
 12918      00000000 
 12918      00000000 
 12918      00000000 
 12918      00000000 
 12921              	curFlag:
 12922 0078 00000000 		.space	64
 12922      00000000 
 12922      00000000 
 12922      00000000 
 12922      00000000 
 12925              	WDRflag:
 12926 00b8 00000000 		.space	4
 12929              	usbSpeed:
 12930 00bc 00       		.space	1
 12931 00bd 000000   		.space	3
 12934              	glCommitCtrl:
 12935 00c0 00000000 		.space	32
 12935      00000000 
 12935      00000000 
 12935      00000000 
 12935      00000000 
 12938              	setRes:
 12939 00e0 00       		.space	1
 12942              	setstilRes:
 12943 00e1 00       		.space	1
 12946              	IMcount.8108:
 12947 00e2 00       		.space	1
 12948 00e3 00       		.space	1
 12951              	uvcAppThread:
 12952 00e4 00000000 		.space	168
 12952      00000000 
 12952      00000000 
 12952      00000000 
 12952      00000000 
 12955              	uvcAppEP0Thread:
 12956 018c 00000000 		.space	168
 12956      00000000 
 12956      00000000 
 12956      00000000 
 12956      00000000 
 12959              	i2cAppThread:
 12960 0234 00000000 		.space	168
 12960      00000000 
 12960      00000000 
 12960      00000000 
 12960      00000000 
 12963              	pbcpbak:
 12964 02dc 0000     		.space	2
 12967              	pbcbak:
 12968 02de 0000     		.space	2
 12971              	pbbak:
 12972 02e0 0000     		.space	2
 12975              	fbbak:
 12976 02e2 0000     		.space	2
 12979              	testSnap:
 12980 02e4 00       		.space	1
 12981 02e5 000000   		.text
 12982              	.Letext0:
 12983              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 12984              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 12985              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 12986              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 12987              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 12988              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 12989              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 12990              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 12991              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 12992              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 12993              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 12994              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 12995              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 12996              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 12997              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 12998              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 12999              		.file 18 "../cmdqu.h"
 13000              		.file 19 "../uvc.h"
 13001              		.file 20 "../cyfxgpif2config.h"
 13002              		.file 21 "../cyfxgpif2config_usb2_720.h"
 13003              		.file 22 "../sensor.h"
 13004              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:38     .text:00000010 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:42     .text:00000014 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:45     .text:00000014 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:205    .text:00000158 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:211    .text:00000168 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:311    .text:00000224 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:322    .text:00000244 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:325    .text:00000244 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:557    .text:000003dc $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:567    .text:000003f8 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:569    .text:000003f8 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:784    .text:00000574 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:795    .text:00000584 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:797    .text:00000584 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1155   .text:00000840 $d
                            *COM*:00000002 wLength
                            *COM*:00000001 bRequest
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
                            *COM*:00000002 wValue
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1173   .text:0000086c $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1176   .text:0000086c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1312   .text:0000098c $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1317   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1320   .text:00000994 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1388   .text:00000a10 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1581   .text:00000b88 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1623   .text:00000c24 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1678   .text:00000ca0 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:1714   .text:00000d28 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:2995   .text:000018f8 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:3015   .text:0000193c $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:3018   .text:0000193c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:3165   .text:00001a64 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:3178   .text:00001a8c $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:3594   .text:00001ebc $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:3605   .text:00001edc $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:3875   .text:00002170 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:3887   .text:00002194 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:3890   .text:00002194 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4189   .text:0000244c $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4196   .text:0000245c $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4199   .text:0000245c CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4243   .text:000024a0 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4248   .text:000024a8 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4251   .text:000024a8 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4279   .text:000024c4 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4283   .text:000024c8 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4286   .text:000024c8 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4356   .text:00002540 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:4364   .text:00002550 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:6194   .text:000034c8 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000ac glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:6239   .text:00003558 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:8917   .text:00004838 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:8929   .text:0000484c $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:8932   .text:0000484c CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:8964   .text:00004880 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:8977   .text:000048ac $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:8982   .text:000048bc $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:8987   .text:000048cc $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:9034   .text:00004924 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:9044   .text:00004938 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:9047   .text:00004938 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:9116   .text:000049a4 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:9122   .text:000049b0 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:9125   .text:000049b0 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10254  .text:000052d8 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10309  .text:000053a0 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10312  .text:000053a0 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10478  .text:00005508 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10495  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10498  .text.startup:00000000 main
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:11666  .data:00000480 glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12056  .data:00000638 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12074  .data:00000644 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12041  .data:0000062c glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12011  .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12897  .bss:0000003c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12909  .bss:00000048 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12929  .bss:000000bc usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12905  .bss:00000044 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12963  .bss:000002dc pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12967  .bss:000002de pbcbak
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12971  .bss:000002e0 pbbak
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12975  .bss:000002e2 fbbak
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12876  .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12872  .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12868  .bss:00000028 fb
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12979  .bss:000002e4 testSnap
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12070  .data:00000643 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10684  .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12104  .data:00000660 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12183  .data:00000790 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12334  .data:00000824 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12445  .data:000009d4 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10671  .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12456  .data:000009e4 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12535  .data:00000b14 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12554  .data:00000b24 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12629  .data:00000c44 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10637  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10641  .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10660  .rodata:00000010 ShutValueArry
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10696  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:10700  .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:11023  .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:11681  .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:11688  .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12636  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12860  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12864  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12881  .bss:00000030 stiflag
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12885  .bss:00000034 hitFV
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12889  .bss:00000038 prodCount
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12893  .bss:0000003a consCount
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12901  .bss:00000040 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12913  .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12917  .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12921  .bss:00000078 curFlag
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12925  .bss:000000b8 WDRflag
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12934  .bss:000000c0 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12938  .bss:000000e0 setRes
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12942  .bss:000000e1 setstilRes
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12946  .bss:000000e2 IMcount.8108
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12951  .bss:000000e4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12955  .bss:0000018c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cc22rxQm.s:12959  .bss:00000234 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_event_flags_set
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
memcpy
SensorGetControl
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetWrapUp
CyU3PI2cInit
CyU3PI2cSetConfig
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
