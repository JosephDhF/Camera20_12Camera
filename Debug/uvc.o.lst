   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 141:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 145:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 146:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 147:../uvc.c      **** };
 148:../uvc.c      **** 
 149:../uvc.c      **** 
 150:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 151:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 152:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 154:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 155:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 156:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 157:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 158:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 159:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 160:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 161:../uvc.c      ****                                    with adjustable compression parameters */
 162:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 163:../uvc.c      ****                                    streaming with adjustable compression parameters */
 164:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 165:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 170:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 171:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 173:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 174:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 175:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 176:../uvc.c      **** };
 177:../uvc.c      **** 
 178:../uvc.c      **** 
 179:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 180:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 181:../uvc.c      **** 
 182:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 183:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 184:../uvc.c      **** {
 185:../uvc.c      ****     0x0C,                               /* Header Length */
 186:../uvc.c      ****     0x8C,                               /* Bit field header field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 188:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 189:../uvc.c      **** };
 190:../uvc.c      **** 
 191:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 192:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 193:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 194:../uvc.c      ****                                                            the current video frame. */
 195:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 196:../uvc.c      **** #ifndef CAM720
 197:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 198:../uvc.c      **** #else
 199:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 200:../uvc.c      **** #endif
 201:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 202:../uvc.c      **** 
 203:../uvc.c      **** /************ control parameters array ***********
 204:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 205:../uvc.c      ****  *    e.g.
 206:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 207:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 208:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 209:../uvc.c      ****  **************************************************/
 210:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 211:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 212:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 213:../uvc.c      **** #ifndef CAM720
 214:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 215:../uvc.c      **** #else
 216:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 217:../uvc.c      **** #endif
 218:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0,
 219:../uvc.c      **** 		{/*2*/ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0,
 220:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 221:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 222:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 223:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 224:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,
 225:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 228:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 229:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 233:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 235:../uvc.c      **** #ifndef CAM720
 236:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 237:../uvc.c      **** #else
 238:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 239:../uvc.c      **** #endif
 240:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 241:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 242:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 244:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 246:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 247:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg1     , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 248:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		/**********************************
 253:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 254:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 255:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 256:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 257:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 258:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 259:../uvc.c      **** 		 *
 260:../uvc.c      **** 		 *********************************/
 261:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 262:../uvc.c      **** };
 263:../uvc.c      **** 
 264:../uvc.c      **** #ifndef CAM720
 265:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 266:../uvc.c      **** #else
 267:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 268:../uvc.c      **** #endif
 269:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 270:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 271:../uvc.c      **** 
 272:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 273:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 274:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 275:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 276:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 277:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 278:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 279:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 280:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 281:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 282:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 285:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 287:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 288:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 289:../uvc.c      **** };
 290:../uvc.c      **** 
 291:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 292:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 293:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 294:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 295:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 296:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 297:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 298:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 299:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 300:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 302:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 303:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 304:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 308:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 309:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 310:../uvc.c      **** };
 311:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 312:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 313:../uvc.c      **** /*
 314:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 315:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 316:../uvc.c      ****  */
 317:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 318:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 319:../uvc.c      **** };
 320:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 321:../uvc.c      **** 		0
 322:../uvc.c      **** };
 323:../uvc.c      **** 
 324:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 325:../uvc.c      **** 
 326:../uvc.c      **** void I2CCmdHandler(){
 327:../uvc.c      **** 	uint8_t buf[2];
 328:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 329:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 330:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 331:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 332:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 333:../uvc.c      **** 
 334:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 335:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 336:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 337:../uvc.c      **** 
 338:../uvc.c      **** 	if(CmdType == 0)//I2C read
 339:../uvc.c      **** 	{
 340:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 341:../uvc.c      **** #if 0 //for debugging
 342:../uvc.c      **** 		/* test still image operation */
 343:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 344:../uvc.c      **** 			snapButFlag = 0; //press
 345:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 346:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 347:../uvc.c      **** 			snapButFlag = 0xf; //release
 348:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 349:../uvc.c      **** 		}
 350:../uvc.c      **** 
 351:../uvc.c      **** 		/* end of the test */
 352:../uvc.c      **** #endif
 353:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 354:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 355:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 356:../uvc.c      **** 			if(CmdDataLen == 2){
 357:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 358:../uvc.c      **** 			}
 359:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 360:../uvc.c      **** 		}else{//not support currently
 361:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 362:../uvc.c      **** 		}
 363:../uvc.c      **** 	}else if(CmdType == 1){
 364:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 365:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 366:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 367:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 368:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 369:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 370:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 371:../uvc.c      **** 			}
 372:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 373:../uvc.c      **** 		}else{//not support currently
 374:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 375:../uvc.c      **** 		}
 376:../uvc.c      **** 
 377:../uvc.c      **** 	}
 378:../uvc.c      **** }
 379:../uvc.c      **** 
 380:../uvc.c      **** /************************************
 381:../uvc.c      ****  * set Iris mode
 382:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 383:../uvc.c      ****  */
 384:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 385:../uvc.c      **** 	uint8_t dataIdx;
 386:../uvc.c      **** 	  dataIdx = 0;
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 391:../uvc.c      **** }
 392:../uvc.c      **** 
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 394:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 395:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 396:../uvc.c      ****     uint16_t readCount;
 397:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 398:../uvc.c      ****     uint8_t devAdd;
 399:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 400:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 401:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 402:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 403:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 404:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 405:../uvc.c      ****     }else{
 406:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 407:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 408:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 409:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 410:../uvc.c      ****     }
 411:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 412:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 413:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 414:../uvc.c      **** #endif
 415:../uvc.c      ****     reqData = bRequest;
 416:../uvc.c      ****     /*
 417:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 418:../uvc.c      ****      */
 419:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 420:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 421:../uvc.c      ****     	goto EndofSet;
 422:../uvc.c      ****     }
 423:../uvc.c      ****     switch (bRequest)
 424:../uvc.c      **** 		 {
 425:../uvc.c      **** 
 426:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 427:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 428:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 429:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 430:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 431:../uvc.c      **** 			  break;
 432:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 433:../uvc.c      **** 
 434:../uvc.c      **** 			 switch(CtrlID)
 435:../uvc.c      **** 			 {
 436:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 437:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 438:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 439:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 440:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 441:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 442:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 443:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 444:../uvc.c      **** 			 	 		 break;
 445:../uvc.c      **** 			 	 }
 446:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 447:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 448:../uvc.c      **** 					 if(CamMode == 1){//720p
 449:../uvc.c      **** 						if(sendData >= 3){
 450:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 451:../uvc.c      **** 							sendData = 0; //set back to default
 452:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 453:../uvc.c      **** 						}
 454:../uvc.c      **** 						sendData += 4;
 455:../uvc.c      **** 					 }
 456:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 457:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 458:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 459:../uvc.c      **** 					 break;
 460:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 461:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 462:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 463:../uvc.c      **** 			 		 }
 464:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 465:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 466:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 467:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 468:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 469:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 470:../uvc.c      **** #endif
 471:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 472:../uvc.c      **** 			 		 {
 473:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 474:../uvc.c      **** 			 		 }
 475:../uvc.c      **** 			 		 break;
 476:../uvc.c      **** 				 case ExtAexModCtlID9:
 477:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 478:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 479:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 480:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 481:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 482:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 483:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 484:../uvc.c      **** 					 break;
 485:../uvc.c      **** 
 486:../uvc.c      **** 			 	 case BrgtCtlID1:
 487:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 488:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 489:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 490:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 491:../uvc.c      **** 					 }else{
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 493:../uvc.c      **** 					 }
 494:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 496:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 497:../uvc.c      **** 					 break;
 498:../uvc.c      **** 				 case HueCtlID5:
 499:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 500:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 502:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 503:../uvc.c      **** 					 break;
 504:../uvc.c      **** 				 case WBTLevCtlID11:
 505:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 506:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 507:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 508:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 509:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 510:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 511:../uvc.c      **** 					 break;
 512:../uvc.c      **** 				 case SaturCtlID6:
 513:../uvc.c      **** 				 default:
 514:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 515:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 516:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 517:../uvc.c      **** 					 break;
 518:../uvc.c      **** 			 }
 519:../uvc.c      **** 
 520:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 521:../uvc.c      **** 
 522:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 523:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 524:../uvc.c      **** #endif
 525:../uvc.c      **** 			  break;
 526:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 527:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 528:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 529:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 530:../uvc.c      **** 		 	 }
 531:../uvc.c      **** 
 532:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 533:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 534:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 535:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 536:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 537:../uvc.c      **** 			 }else
 538:../uvc.c      **** 			 {
 539:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 540:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 541:../uvc.c      **** 			 }
 542:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 543:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 544:../uvc.c      **** 			  break;
 545:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 546:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 548:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 549:../uvc.c      **** 		 	 }
 550:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 551:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 552:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 553:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 554:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 555:../uvc.c      **** 			 }else
 556:../uvc.c      **** 			 {
 557:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 558:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 559:../uvc.c      **** 			 }
 560:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 561:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 562:../uvc.c      **** 			  break;
 563:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 564:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 566:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 567:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 568:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 569:../uvc.c      **** 		 	 }
 570:../uvc.c      **** 		 	 else{
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 572:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 573:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 574:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 575:../uvc.c      **** 		 	 }
 576:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 577:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 578:../uvc.c      **** 			  break;
 579:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 580:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 582:../uvc.c      **** 		 	 }
 583:../uvc.c      **** 		 	 else{
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 585:../uvc.c      **** 		 	 }
 586:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 587:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 588:../uvc.c      **** 			  Len = 1;
 589:../uvc.c      **** 			  break;
 590:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 591:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 592:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 593:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 594:../uvc.c      **** 		 	 }
 595:../uvc.c      **** 
 596:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 598:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 599:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 600:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 601:../uvc.c      **** 			 }else{
 602:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 603:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 604:../uvc.c      **** 			 }
 605:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 606:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 607:../uvc.c      **** 			  break;
 608:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 609:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 610:../uvc.c      **** 				  glEp0Buffer, &readCount);
 611:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 612:../uvc.c      **** 			   {
 613:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 614:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 615:../uvc.c      **** 				  getData = glEp0Buffer[0];
 616:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 617:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 618:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 619:../uvc.c      **** #endif
 620:../uvc.c      **** 				  switch(CtrlID)
 621:../uvc.c      **** 					 {
 622:../uvc.c      **** 						 case ExtShutCtlID0:
 623:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 624:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 625:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 626:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 627:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 628:../uvc.c      **** 									 }else{
 629:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 630:../uvc.c      **** 									 }
 631:../uvc.c      **** 								 }
 632:../uvc.c      **** 							 }else{
 633:../uvc.c      **** 								 Data1 = Data0 - 1;
 634:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 635:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 636:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 637:../uvc.c      **** 									 }else{
 638:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 639:../uvc.c      **** 									 }
 640:../uvc.c      **** 								 }
 641:../uvc.c      **** 								 if(Data1 < 8){
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 644:../uvc.c      **** 								 }else{
 645:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 646:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 647:../uvc.c      **** 								 }
 648:../uvc.c      **** 							 }
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 650:../uvc.c      **** 							 dataIdx = 0;
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 652:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 653:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 654:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 655:../uvc.c      **** 							 break;
 656:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 657:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 658:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 659:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 660:../uvc.c      **** 							 dataIdx = 0;
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 662:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 663:../uvc.c      **** 							 if(getData != 0){
 664:../uvc.c      **** 								 dataIdx++;
 665:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 666:../uvc.c      **** 							 }
 667:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 668:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 669:../uvc.c      **** 							 break;
 670:../uvc.c      **** 						 case ExtExRefCtlID10:
 671:../uvc.c      **** 							 dataIdx = 0;
 672:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 673:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 674:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 675:../uvc.c      **** 							 if(WDRflag)
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 677:../uvc.c      **** 							 else
 678:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 680:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 681:../uvc.c      **** 						 case ExtCamMCtlID12:
 682:../uvc.c      **** 							 /*
 683:../uvc.c      **** 							 dataIdx = 0;
 684:../uvc.c      **** 							 if(Data0 <= 3){
 685:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 686:../uvc.c      **** 								 Data1 = Data0;
 687:../uvc.c      **** 							 }else{
 688:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 689:../uvc.c      **** 								 Data1 = Data0-4;
 690:../uvc.c      **** 							 }
 691:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 692:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 693:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 694:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 695:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 696:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 697:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 698:../uvc.c      **** 							 */
 699:../uvc.c      **** 							 break;
 700:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 701:../uvc.c      **** 							 dataIdx = 0;
 702:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 703:../uvc.c      **** 								 Data0 = 1;
 704:../uvc.c      **** 							 }else{ //save current sensor parameters.
 705:../uvc.c      **** 								 Data0 = 0;
 706:../uvc.c      **** 							 }
 707:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 708:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 709:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 710:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 711:../uvc.c      **** 							 break;
 712:../uvc.c      **** 						 case ExtI2CCtlID15:
 713:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 714:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 715:../uvc.c      **** 					 		 }
 716:../uvc.c      **** 					 		I2CCmdHandler();
 717:../uvc.c      **** 							 break;
 718:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 719:../uvc.c      **** 							 dataIdx = 0;
 720:../uvc.c      **** #if 0 //seperate version
 721:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 722:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 723:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 724:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 725:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 726:../uvc.c      **** 							 }else{ //disable BLD window
 727:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 728:../uvc.c      **** 							 }
 729:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 730:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 731:../uvc.c      **** 							 dataIdx++;
 732:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 733:../uvc.c      **** 							 dataIdx++;
 734:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 735:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 736:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 737:../uvc.c      **** 							 dataIdx++;
 738:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 739:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 740:../uvc.c      **** #else //combination version
 741:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 742:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 743:../uvc.c      **** 						     /* end test */
 744:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 745:../uvc.c      **** 							 dataIdx++;
 746:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 747:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 748:../uvc.c      **** 							 getData1 = Data1;
 749:../uvc.c      **** #endif
 750:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 751:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 752:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 753:../uvc.c      **** 							 break;
 754:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 755:../uvc.c      **** 							 dataIdx = 0;
 756:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 758:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 759:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 760:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 761:../uvc.c      **** 							 break;
 762:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 763:../uvc.c      **** 							 dataIdx = 0;
 764:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 765:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 766:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 767:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 768:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 769:../uvc.c      **** 							 break;
 770:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 771:../uvc.c      **** 							 dataIdx = 0;
 772:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 773:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 774:../uvc.c      **** 							  if(Data0&0x80){
 775:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 776:../uvc.c      **** 							  }else{
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 778:../uvc.c      **** 							  }
 779:../uvc.c      **** 							 Data1 |= ~0x03;
 780:../uvc.c      **** 							 Data1 &= 0xC7;
 781:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 782:../uvc.c      **** 						  	 dataIdx++;
 783:../uvc.c      **** 
 784:../uvc.c      **** 							 Data0 = (Data0 << 2);
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 786:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 787:../uvc.c      **** 
 788:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 791:../uvc.c      **** 
 792:../uvc.c      **** 							 break;
 793:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 794:../uvc.c      **** 							 dataIdx = 0;
 795:../uvc.c      **** 
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 797:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 798:../uvc.c      **** 							 dataIdx++;
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 800:../uvc.c      **** 							 dataIdx++;
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 802:../uvc.c      **** 							 dataIdx++;
 803:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 804:../uvc.c      **** 							 dataIdx++;
 805:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 806:../uvc.c      **** 							 dataIdx++;
 807:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 808:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 809:../uvc.c      **** 
 810:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 811:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 812:../uvc.c      **** 							 break;
 813:../uvc.c      **** 						 case SaturCtlID6:
 814:../uvc.c      **** 							 dataIdx = 0;
 815:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 816:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 817:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 818:../uvc.c      **** 							 dataIdx++;
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 821:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 823:../uvc.c      **** 							 break;
 824:../uvc.c      **** 
 825:../uvc.c      **** 						 case WBTLevCtlID11:
 826:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 827:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 828:../uvc.c      **** 							 dataIdx = 0;
 829:../uvc.c      **** 
 830:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 831:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 832:../uvc.c      **** 							 dataIdx++;
 833:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 834:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 835:../uvc.c      **** 
 836:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 837:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 838:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 839:../uvc.c      **** 							 break;
 840:../uvc.c      **** 						 case MFreqCtlID4:
 841:../uvc.c      **** 							 dataIdx = 0;
 842:../uvc.c      **** 							 Data0 = Data0 - 1;
 843:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 844:../uvc.c      **** 								 Data0 = 0;
 845:../uvc.c      **** 							 else if(Data0 >2)
 846:../uvc.c      **** 								 Data0 = 1;
 847:../uvc.c      **** 
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 851:../uvc.c      **** 
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 854:../uvc.c      **** 							 break;
 855:../uvc.c      **** 					 	 case BLCCtlID0:
 856:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 857:../uvc.c      **** 							 if(Data0 == 3)
 858:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 859:../uvc.c      **** 							 else
 860:../uvc.c      **** 								 WDRflag = CyFalse;
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 862:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 863:../uvc.c      **** 							 {
 864:../uvc.c      **** 								 if(Data0 < 2){
 865:../uvc.c      **** 					 				 ;//Data0 += 4;
 866:../uvc.c      **** 					 			 }else{
 867:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 868:../uvc.c      **** 									Data0 = 0; //set to default.
 869:../uvc.c      **** 					 			 }
 870:../uvc.c      **** 					 		 }
 871:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 872:../uvc.c      **** 							 dataIdx = 0;
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 875:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 876:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 877:../uvc.c      **** 
 878:../uvc.c      **** 					 		 break;
 879:../uvc.c      **** 						 default:
 880:../uvc.c      **** 							 dataIdx = 0;
 881:../uvc.c      **** 
 882:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 883:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 884:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 885:../uvc.c      **** 
 886:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 887:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 888:../uvc.c      **** 							 break;
 889:../uvc.c      **** 					 }
 890:../uvc.c      **** 			   }else{
 891:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 892:../uvc.c      **** 			   }
 893:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 894:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 895:../uvc.c      **** #endif
 896:../uvc.c      **** 
 897:../uvc.c      **** 			  break;
 898:../uvc.c      **** 		  default:
 899:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 900:../uvc.c      **** 			  break;
 901:../uvc.c      **** 		 }
 902:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 903:../uvc.c      **** }
 904:../uvc.c      **** /************** CT control requests handler *************************/
 905:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 906:../uvc.c      **** 
 907:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 908:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 909:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 910:../uvc.c      ****     uint16_t readCount;
 911:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 912:../uvc.c      ****     uint16_t diff, value, diffRd;
 913:../uvc.c      ****     uint8_t i, shutter, index;
 914:../uvc.c      ****     diff = 0xffff;
 915:../uvc.c      ****     shutter = 1;
 916:../uvc.c      ****     index = 1;
 917:../uvc.c      **** 
 918:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 919:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 920:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 921:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 922:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 923:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 924:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 925:../uvc.c      **** #endif
 926:../uvc.c      ****     reqData = bRequest;
 927:../uvc.c      **** 
 928:../uvc.c      ****     switch (bRequest)
 929:../uvc.c      **** 		 {
 930:../uvc.c      **** 
 931:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 932:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 933:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 934:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 935:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 936:../uvc.c      **** 			  break;
 937:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 938:../uvc.c      **** 
 939:../uvc.c      **** 			 switch(CtrlID)
 940:../uvc.c      **** 			 {
 941:../uvc.c      **** 				 default:
 942:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 943:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 944:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 945:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 946:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 947:../uvc.c      **** 					 break;
 948:../uvc.c      **** 			 }
 949:../uvc.c      **** 
 950:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 951:../uvc.c      **** 
 952:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 953:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 954:../uvc.c      **** #endif
 955:../uvc.c      **** 			  break;
 956:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 957:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 958:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 959:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 960:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 961:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 962:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 963:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 964:../uvc.c      **** 			  break;
 965:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 966:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 967:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 968:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 969:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 970:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 971:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 972:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 973:../uvc.c      **** 			  break;
 974:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 975:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 976:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 977:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 978:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 979:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 981:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 982:../uvc.c      **** 			  break;
 983:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 984:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 985:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 986:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 987:../uvc.c      **** 			  Len = 1;
 988:../uvc.c      **** 			  break;
 989:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 990:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 991:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 993:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 994:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 995:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 996:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 997:../uvc.c      **** 			  break;
 998:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 999:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1000:../uvc.c      **** 			  glEp0Buffer, &readCount);
1001:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1002:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1003:../uvc.c      **** 			  value = Data1;
1004:../uvc.c      **** 
1005:../uvc.c      **** 			  switch(CtrlID)
1006:../uvc.c      **** 			  {
1007:../uvc.c      **** 		  	      case AutoExMCtlID1:
1008:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1009:../uvc.c      **** 
1010:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1011:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1012:../uvc.c      **** 				    getData = glEp0Buffer[0];
1013:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1014:../uvc.c      **** 		  		    switch (getData){
1015:../uvc.c      **** 						case 1:
1016:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1017:../uvc.c      **** 							break;
1018:../uvc.c      **** 						case 2:
1019:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1020:../uvc.c      **** 							dataIdx = 0;
1021:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1022:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1023:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1024:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1025:../uvc.c      **** 
1026:../uvc.c      **** 							break;
1027:../uvc.c      **** 						case 4:
1028:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1029:../uvc.c      **** 							break;
1030:../uvc.c      **** 						case 8:
1031:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1032:../uvc.c      **** 			  		    	dataIdx = 0;
1033:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1034:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1035:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1036:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1037:../uvc.c      **** 							break;
1038:../uvc.c      **** 		  		    }
1039:../uvc.c      **** #if 0
1040:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1041:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1042:../uvc.c      **** 						  dataIdx = 0;
1043:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1044:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1045:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1046:../uvc.c      **** 		  		    }
1047:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1048:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1049:../uvc.c      **** 		  		    }
1050:../uvc.c      **** #endif
1051:../uvc.c      **** 				    break;
1052:../uvc.c      **** 
1053:../uvc.c      **** 			  	  case ExTmACtlID3:
1054:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1055:../uvc.c      **** 
1056:../uvc.c      **** 					  value = (value << 8)|Data0;
1057:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1058:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1059:../uvc.c      **** 					  {
1060:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1061:../uvc.c      **** 						  {
1062:../uvc.c      **** 							if(value > ShutValueArry[i]){
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1064:../uvc.c      **** 							}else{
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1066:../uvc.c      **** 							}
1067:../uvc.c      **** 							  if(diff > diffRd){
1068:../uvc.c      **** 								  diff = diffRd;
1069:../uvc.c      **** 								  index = i;
1070:../uvc.c      **** 							  }
1071:../uvc.c      **** 						  }
1072:../uvc.c      **** 						  shutter = shutter+index;
1073:../uvc.c      **** 
1074:../uvc.c      **** 						  dataIdx = 0;
1075:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1076:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1077:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1078:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1079:../uvc.c      **** 
1080:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1081:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1082:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1083:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1084:../uvc.c      **** 					  }else{
1085:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1086:../uvc.c      **** 					  }
1087:../uvc.c      **** 					  getData = glEp0Buffer[0];
1088:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1089:../uvc.c      **** 					  break;
1090:../uvc.c      **** 			  	  case IriACtlID7:
1091:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1092:../uvc.c      **** 					  {
1093:../uvc.c      **** 							 dataIdx = 0;
1094:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1095:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1096:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1097:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1098:../uvc.c      **** 
1099:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1100:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1101:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1102:../uvc.c      **** 					  }else{
1103:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1104:../uvc.c      **** 					  }
1105:../uvc.c      **** 					  getData = glEp0Buffer[0];
1106:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1107:../uvc.c      **** 
1108:../uvc.c      **** 					  break;
1109:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1110:../uvc.c      **** 					  getData = glEp0Buffer[0];
1111:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1112:../uvc.c      **** #if 1
1113:../uvc.c      **** 					  dataIdx = 0;
1114:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1115:../uvc.c      **** 					  if(getData == 1)
1116:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1117:../uvc.c      **** 					  else if(getData == 0xff)
1118:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1119:../uvc.c      **** 					  else
1120:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1121:../uvc.c      **** 					  //dataIdx++;
1122:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1123:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1124:../uvc.c      **** #endif
1125:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1126:../uvc.c      **** 					  break;
1127:../uvc.c      **** 
1128:../uvc.c      **** 			  	  default:
1129:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1130:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1131:../uvc.c      **** 			  		 break;
1132:../uvc.c      **** 			  }
1133:../uvc.c      **** 			  break;
1134:../uvc.c      **** 		  default:
1135:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1136:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1137:../uvc.c      **** 			  break;
1138:../uvc.c      **** 		 }
1139:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1140:../uvc.c      **** 
1141:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1142:../uvc.c      **** }
1143:../uvc.c      **** 
1144:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1145:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1146:../uvc.c      **** {
1147:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1148:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1149:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1150:../uvc.c      **** 
1151:../uvc.c      ****     CtrlID = BrgtCtlID1;
1152:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1153:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1154:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1155:../uvc.c      ****     Data1 = Data0;
1156:../uvc.c      **** 
1157:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1158:../uvc.c      ****     if(Data1&0x80){
1159:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1160:../uvc.c      ****     }else{
1161:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1162:../uvc.c      ****     }
1163:../uvc.c      ****     Data0 = (Data0 << 2);
1164:../uvc.c      **** 
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1166:../uvc.c      **** 
1167:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1168:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1169:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1170:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1171:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1172:../uvc.c      **** 
1173:../uvc.c      ****     CtrlID = ConsCtlID2;
1174:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1175:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1176:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1177:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1178:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1179:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1180:../uvc.c      **** 
1181:../uvc.c      ****     CtrlID = HueCtlID5;
1182:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1183:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1184:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1188:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1190:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1191:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1192:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1193:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1194:../uvc.c      **** 
1195:../uvc.c      ****     CtrlID = SaturCtlID6;
1196:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1197:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1198:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1199:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1200:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1201:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1202:../uvc.c      **** 
1203:../uvc.c      ****     CtrlID = ShapCtlID7;
1204:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1205:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1206:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1207:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1208:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1209:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1210:../uvc.c      **** 
1211:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1212:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1213:../uvc.c      **** 	return;
1214:../uvc.c      **** }
1215:../uvc.c      **** 
1216:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1217:../uvc.c      **** void
1218:../uvc.c      **** CyFxUVCAddHeader (
1219:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1220:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1221:../uvc.c      ****         )
1222:../uvc.c      **** {
1223:../uvc.c      ****     /* Copy header to buffer */
1224:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1225:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1226:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1227:../uvc.c      **** 
1228:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1229:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1230:../uvc.c      ****     {
1231:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1232:../uvc.c      ****     }
1233:../uvc.c      **** }
1234:../uvc.c      **** 
1235:../uvc.c      **** 
1236:../uvc.c      **** /* Application Error Handler */
1237:../uvc.c      **** void
1238:../uvc.c      **** CyFxAppErrorHandler (
1239:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1240:../uvc.c      ****         )
1241:../uvc.c      **** {
1242:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1243:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1244:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1245:../uvc.c      **** 
1246:../uvc.c      ****        This function can be modified to take additional error handling actions such
1247:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1248:../uvc.c      ****      */
1249:../uvc.c      ****     for (;;)
1250:../uvc.c      ****     {
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
1253:../uvc.c      ****     }
1254:../uvc.c      **** }
1255:../uvc.c      **** 
1256:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1257:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1258:../uvc.c      ****  */
1259:../uvc.c      **** static void
1260:../uvc.c      **** CyFxUVCApplnAbortHandler (
1261:../uvc.c      ****         void)
1262:../uvc.c      **** {
1263:../uvc.c      **** 	uint32_t flag;
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1265:../uvc.c      **** 	{
1266:../uvc.c      ****         /* Clear the Video Stream Request Event */
1267:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1268:../uvc.c      **** 
1269:../uvc.c      ****         /* Set Video Stream Abort Event */
1270:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1271:../uvc.c      **** 	}
1272:../uvc.c      **** }
1273:../uvc.c      **** 
1274:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1275:../uvc.c      **** static void
1276:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1277:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1278:../uvc.c      ****         uint16_t             evdata  /* Event data */
1279:../uvc.c      ****         )
1280:../uvc.c      **** {
1281:../uvc.c      ****     switch (evtype)
1282:../uvc.c      ****     {
1283:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1284:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1285:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1286:../uvc.c      ****             gpif_initialized = 0;
1287:../uvc.c      ****             streamingStarted = CyFalse;
1288:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1289:../uvc.c      ****             break;
1290:../uvc.c      **** 
1291:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1292:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1293:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1294:../uvc.c      ****             gpif_initialized = 0;
1295:../uvc.c      ****             streamingStarted = CyFalse;
1296:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1297:../uvc.c      ****             break;
1298:../uvc.c      **** 
1299:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1300:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1301:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1302:../uvc.c      ****             gpif_initialized = 0;
1303:../uvc.c      ****             isUsbConnected = CyFalse;
1304:../uvc.c      ****             streamingStarted = CyFalse;
1305:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1306:../uvc.c      ****             break;
1307:../uvc.c      **** 
1308:../uvc.c      **** #ifdef BACKFLOW_DETECT
1309:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1310:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1311:../uvc.c      ****             break;
1312:../uvc.c      **** #endif
1313:../uvc.c      **** 
1314:../uvc.c      ****         default:
1315:../uvc.c      ****             break;
1316:../uvc.c      ****     }
1317:../uvc.c      **** }
1318:../uvc.c      **** 
1319:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1320:../uvc.c      **** static CyBool_t
1321:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1322:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1323:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1324:../uvc.c      ****         )
1325:../uvc.c      **** {
1326:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1327:../uvc.c      ****     uint32_t status;
1328:../uvc.c      **** 
1329:../uvc.c      ****     /* Obtain Request Type and Request */
1330:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1331:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1332:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1333:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1334:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1335:../uvc.c      **** 
1336:../uvc.c      ****     /* Check for UVC Class Requests */
1337:../uvc.c      ****     switch (bmReqType)
1338:../uvc.c      ****     {
1339:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1340:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1341:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1342:../uvc.c      ****             switch (wIndex & 0xFF)
1343:../uvc.c      ****             {
1344:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1345:../uvc.c      ****                     {
1346:../uvc.c      ****                         uvcHandleReq = CyTrue;
1347:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1348:../uvc.c      ****                                 CYU3P_EVENT_OR);
1349:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1350:../uvc.c      ****                         {
1351:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1352:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1353:../uvc.c      ****                         }
1354:../uvc.c      ****                     }
1355:../uvc.c      ****                     break;
1356:../uvc.c      **** 
1357:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1358:../uvc.c      ****                     {
1359:../uvc.c      ****                         uvcHandleReq = CyTrue;
1360:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1361:../uvc.c      ****                                 CYU3P_EVENT_OR);
1362:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1363:../uvc.c      ****                         {
1364:../uvc.c      ****                             /* Error handling */
1365:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1366:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1367:../uvc.c      ****                         }
1368:../uvc.c      ****                     }
1369:../uvc.c      ****                     break;
1370:../uvc.c      **** 
1371:../uvc.c      ****                 default:
1372:../uvc.c      ****                     break;
1373:../uvc.c      ****             }
1374:../uvc.c      ****             break;
1375:../uvc.c      **** 
1376:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1377:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1378:../uvc.c      ****             {
1379:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1380:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1381:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1382:../uvc.c      ****                 {
1383:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1384:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1385:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1386:../uvc.c      ****                     gpif_initialized = 0;
1387:../uvc.c      ****                     streamingStarted = CyFalse;
1388:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1389:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1390:../uvc.c      ****                     CyU3PBusyWait (100);
1391:../uvc.c      **** 
1392:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1393:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1394:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1395:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1396:../uvc.c      ****                     CyU3PBusyWait (100);
1397:../uvc.c      **** 
1398:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1399:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1400:../uvc.c      ****                     uvcHandleReq = CyTrue;
1401:../uvc.c      ****                     /* Complete Control request handshake */
1402:../uvc.c      ****                     CyU3PUsbAckSetup ();
1403:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1404:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1405:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1406:../uvc.c      **** 
1407:../uvc.c      ****                 }
1408:../uvc.c      ****             }
1409:../uvc.c      ****             break;
1410:../uvc.c      **** 
1411:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1412:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1413:../uvc.c      ****             {
1414:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1415:../uvc.c      ****                 {
1416:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1417:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1418:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1419:../uvc.c      ****                 	 * has started. */
1420:../uvc.c      ****                     if (streamingStarted == CyTrue)
1421:../uvc.c      ****                     {
1422:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1423:../uvc.c      **** 
1424:../uvc.c      ****                         /* Disable the GPIF state machine. */
1425:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1426:../uvc.c      ****                         gpif_initialized = 0;
1427:../uvc.c      ****                         streamingStarted = CyFalse;
1428:../uvc.c      **** 
1429:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1430:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1431:../uvc.c      ****                         CyU3PBusyWait (100);
1432:../uvc.c      **** 
1433:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1434:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1435:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1436:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1437:../uvc.c      ****                         CyU3PBusyWait (100);
1438:../uvc.c      **** 
1439:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1440:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1441:../uvc.c      **** 
1442:../uvc.c      ****                         uvcHandleReq = CyTrue;
1443:../uvc.c      ****                         /* Complete Control request handshake */
1444:../uvc.c      ****                         CyU3PUsbAckSetup ();
1445:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1446:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1447:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1448:../uvc.c      ****                     }
1449:../uvc.c      ****                     else
1450:../uvc.c      ****                     {
1451:../uvc.c      ****                         uvcHandleReq = CyTrue;
1452:../uvc.c      ****                         CyU3PUsbAckSetup ();
1453:../uvc.c      ****                     }
1454:../uvc.c      ****                 }
1455:../uvc.c      ****             }
1456:../uvc.c      ****             break;
1457:../uvc.c      **** 
1458:../uvc.c      ****         default:
1459:../uvc.c      ****             break;
1460:../uvc.c      ****     }
1461:../uvc.c      **** 
1462:../uvc.c      ****     /* Return status of request handling to the USB driver */
1463:../uvc.c      ****     return uvcHandleReq;
1464:../uvc.c      **** }
1465:../uvc.c      **** 
1466:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1467:../uvc.c      **** 
1468:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1469:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1470:../uvc.c      ****  */
1471:../uvc.c      **** void
1472:../uvc.c      **** CyFxUvcApplnDmaCallback (
1473:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1474:../uvc.c      ****         CyU3PDmaCbType_t      type,
1475:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1476:../uvc.c      ****         )
1477:../uvc.c      **** {
1478:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1479:../uvc.c      **** #if 1
1480:../uvc.c      ****     CyU3PReturnStatus_t status;
1481:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1482:../uvc.c      ****     {
1483:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1484:../uvc.c      ****             {
1485:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1486:../uvc.c      ****                 fb++;
1487:../uvc.c      ****             }
1488:../uvc.c      ****             else
1489:../uvc.c      ****             {
1490:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1491:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1492:../uvc.c      ****                 pb++;
1493:../uvc.c      ****                 pbc = input->buffer_p.count;
1494:../uvc.c      ****                // hitFV = CyTrue;
1495:../uvc.c      **** #if 1   //remove the still flag clearing here
1496:../uvc.c      ****                 if(stiflag == 0x0F){
1497:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1498:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1499:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1500:../uvc.c      ****                 	stiflag = 0xAA;
1501:../uvc.c      ****                 }
1502:../uvc.c      **** #endif
1503:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1504:../uvc.c      ****             }
1505:../uvc.c      **** 
1506:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1507:../uvc.c      ****             prodCount++;
1508:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1509:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1510:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1511:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1512:../uvc.c      ****             {
1513:../uvc.c      ****                 prodCount--;
1514:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1515:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1516:../uvc.c      ****             }
1517:../uvc.c      ****     }
1518:../uvc.c      **** #endif
1519:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1520:../uvc.c      ****     {
1521:../uvc.c      ****         consCount++;
1522:../uvc.c      ****         streamingStarted = CyTrue;
1523:../uvc.c      ****     }
1524:../uvc.c      **** }
1525:../uvc.c      **** 
1526:../uvc.c      **** /*
1527:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1528:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1529:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1530:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1531:../uvc.c      ****  * to commit the buffer.
1532:../uvc.c      ****  */
1533:../uvc.c      **** static uint8_t
1534:../uvc.c      **** CyFxUvcAppCommitEOF (
1535:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1536:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1537:../uvc.c      ****         )
1538:../uvc.c      **** {
1539:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1540:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1541:../uvc.c      **** 
1542:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1543:../uvc.c      **** 
1544:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1545:../uvc.c      ****     {
1546:../uvc.c      ****         switch (stateId)
1547:../uvc.c      ****         {
1548:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1549:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1550:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1551:../uvc.c      ****                 break;
1552:../uvc.c      **** 
1553:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1554:../uvc.c      ****                 socket = 0;
1555:../uvc.c      ****                 break;
1556:../uvc.c      **** 
1557:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1558:../uvc.c      ****                 socket = 1;
1559:../uvc.c      ****                 break;
1560:../uvc.c      **** 
1561:../uvc.c      ****             default:
1562:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1563:../uvc.c      ****                 /* Unexpected current state. Return error. */
1564:../uvc.c      ****                 return 1;
1565:../uvc.c      ****         }
1566:../uvc.c      ****     }
1567:../uvc.c      **** 
1568:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1569:../uvc.c      ****     {
1570:../uvc.c      ****         switch (stateId)
1571:../uvc.c      ****         {
1572:../uvc.c      **** #ifndef CAM720
1573:../uvc.c      **** #ifdef GPIFIIM
1574:../uvc.c      ****             case 13:
1575:../uvc.c      ****             case 24:
1576:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1577:../uvc.c      ****                 break;
1578:../uvc.c      **** 
1579:../uvc.c      ****             case 8:
1580:../uvc.c      ****                 socket = 0;
1581:../uvc.c      ****                 break;
1582:../uvc.c      **** 
1583:../uvc.c      ****             case 20:
1584:../uvc.c      ****                 socket = 1;
1585:../uvc.c      ****                 break;
1586:../uvc.c      **** #else
1587:../uvc.c      ****             case 11:
1588:../uvc.c      ****             case 18:
1589:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1590:../uvc.c      ****                 break;
1591:../uvc.c      **** 
1592:../uvc.c      ****             case 8:
1593:../uvc.c      ****                 socket = 0;
1594:../uvc.c      ****                 break;
1595:../uvc.c      **** 
1596:../uvc.c      ****             case 15:
1597:../uvc.c      ****                 socket = 1;
1598:../uvc.c      ****                 break;
1599:../uvc.c      **** #endif
1600:../uvc.c      **** #else
1601:../uvc.c      ****             case 11:
1602:../uvc.c      ****             case 18:
1603:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1604:../uvc.c      ****                 break;
1605:../uvc.c      **** 
1606:../uvc.c      ****             case 8:
1607:../uvc.c      ****                 socket = 0;
1608:../uvc.c      ****                 break;
1609:../uvc.c      **** 
1610:../uvc.c      ****             case 15:
1611:../uvc.c      ****                 socket = 1;
1612:../uvc.c      ****                 break;
1613:../uvc.c      **** 
1614:../uvc.c      **** #endif
1615:../uvc.c      ****              default:
1616:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1617:../uvc.c      ****                 /* Unexpected current state. Return error. */
1618:../uvc.c      ****                return 1;
1619:../uvc.c      ****         }
1620:../uvc.c      ****     }
1621:../uvc.c      **** 
1622:../uvc.c      ****     if (socket != 0xFF)
1623:../uvc.c      ****     {
1624:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1625:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1626:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1627:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1628:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1629:../uvc.c      ****         {
1630:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1631:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1632:../uvc.c      ****         }
1633:../uvc.c      ****     }
1634:../uvc.c      **** 
1635:../uvc.c      ****     return 0;
1636:../uvc.c      **** }
1637:../uvc.c      **** 
1638:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1639:../uvc.c      **** void
1640:../uvc.c      **** CyFxGpifCB (
1641:../uvc.c      ****         CyU3PGpifEventType event,
1642:../uvc.c      ****         uint8_t currentState
1643:../uvc.c      ****         )
1644:../uvc.c      **** {
1645:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1646:../uvc.c      ****     {
1647:../uvc.c      ****         //hitFV = CyTrue;
1648:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1649:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1650:../uvc.c      ****     }
1651:../uvc.c      **** }
1652:../uvc.c      **** 
1653:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1654:../uvc.c      **** static void
1655:../uvc.c      **** CyFxUVCApplnDebugInit (
1656:../uvc.c      ****         void)
1657:../uvc.c      **** {
1658:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1659:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1660:../uvc.c      **** 
1661:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1662:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1663:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1664:../uvc.c      ****     {
1665:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1666:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1667:../uvc.c      ****     }
1668:../uvc.c      **** 
1669:../uvc.c      ****     /* Set UART Configuration */
1670:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1671:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1672:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1673:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1674:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1675:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1676:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1677:../uvc.c      **** 
1678:../uvc.c      ****     /* Set the UART configuration */
1679:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1680:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1681:../uvc.c      ****     {
1682:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1683:../uvc.c      ****     }
1684:../uvc.c      **** 
1685:../uvc.c      ****     /* Set the UART transfer */
1686:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1687:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1688:../uvc.c      ****     {
1689:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1690:../uvc.c      ****     }
1691:../uvc.c      **** 
1692:../uvc.c      ****     /* Initialize the Debug logger module. */
1693:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1694:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1695:../uvc.c      ****     {
1696:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1697:../uvc.c      ****     }
1698:../uvc.c      **** 
1699:../uvc.c      ****     /* Disable log message headers. */
1700:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1701:../uvc.c      **** }
1702:../uvc.c      **** 
1703:../uvc.c      **** /* I2C initialization. */
1704:../uvc.c      **** //static void
1705:../uvc.c      **** void
1706:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1707:../uvc.c      **** {
1708:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1709:../uvc.c      ****     CyU3PReturnStatus_t status;
1710:../uvc.c      **** 
1711:../uvc.c      ****     status = CyU3PI2cInit ();
1712:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1713:../uvc.c      ****     {
1714:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1715:../uvc.c      ****         CyFxAppErrorHandler (status);
1716:../uvc.c      ****     }
1717:../uvc.c      **** 
1718:../uvc.c      ****     /*  Set I2C Configuration */
1719:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1720:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1721:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1722:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1723:../uvc.c      **** 
1724:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1725:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1726:../uvc.c      ****     {
1727:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1728:../uvc.c      ****         CyFxAppErrorHandler (status);
1729:../uvc.c      ****     }
1730:../uvc.c      **** }
1731:../uvc.c      **** 
1732:../uvc.c      **** #ifdef BACKFLOW_DETECT
1733:../uvc.c      **** static void CyFxUvcAppPibCallback (
1734:../uvc.c      ****         CyU3PPibIntrType cbType,
1735:../uvc.c      ****         uint16_t cbArg)
1736:../uvc.c      **** {
1737:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1738:../uvc.c      ****     {
1739:../uvc.c      ****         if (!back_flow_detected)
1740:../uvc.c      ****         {
1741:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1742:../uvc.c      ****             back_flow_detected = 1;
1743:../uvc.c      ****         }
1744:../uvc.c      ****     }
1745:../uvc.c      **** }
1746:../uvc.c      **** #endif
1747:../uvc.c      **** 
1748:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1749:../uvc.c      **** static void
1750:../uvc.c      **** CyFxUvcAppDebugCallback (
1751:../uvc.c      ****         CyU3PDmaChannel   *handle,
1752:../uvc.c      ****         CyU3PDmaCbType_t   type,
1753:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1754:../uvc.c      **** {
1755:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1756:../uvc.c      ****     {
1757:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1758:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1759:../uvc.c      ****     }
1760:../uvc.c      **** }
1761:../uvc.c      **** #endif
1762:../uvc.c      **** 
1763:../uvc.c      **** #if 0
1764:../uvc.c      **** static void CyFxAppIntEpCb(
1765:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1766:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1767:../uvc.c      **** 		uint8_t  ebNum)
1768:../uvc.c      **** 		{
1769:../uvc.c      **** 			//CyBool_t value;
1770:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1771:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1772:../uvc.c      **** 
1773:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1774:../uvc.c      **** 		}
1775:../uvc.c      **** #endif
1776:../uvc.c      **** 
1777:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1778:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1779:../uvc.c      ****    configures the DMA module for the UVC Application */
1780:../uvc.c      **** static void
1781:../uvc.c      **** CyFxUVCApplnInit (void)
1782:../uvc.c      **** {
1783:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1784:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1785:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1786:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1787:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1788:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1789:../uvc.c      **** 
1790:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1791:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1792:../uvc.c      **** 
1793:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1794:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1795:../uvc.c      **** #endif
1796:../uvc.c      **** 
1797:../uvc.c      ****     /* Create UVC event group */
1798:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1799:../uvc.c      ****     if (apiRetStatus != 0)
1800:../uvc.c      ****     {
1801:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1802:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1803:../uvc.c      ****     }
1804:../uvc.c      **** 
1805:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1806:../uvc.c      ****     CyFxUvcAppPTZInit ();
1807:../uvc.c      **** #endif
1808:../uvc.c      **** 
1809:../uvc.c      ****     isUsbConnected = CyFalse;
1810:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1811:../uvc.c      **** 
1812:../uvc.c      ****     /* Init the GPIO module */
1813:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1814:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1815:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1816:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1817:../uvc.c      ****     gpioClock.halfDiv    = 0;
1818:../uvc.c      **** 
1819:../uvc.c      ****     /* Initialize Gpio interface */
1820:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1821:../uvc.c      ****     if (apiRetStatus != 0)
1822:../uvc.c      ****     {
1823:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1824:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1825:../uvc.c      ****     }
1826:../uvc.c      **** 
1827:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1828:../uvc.c      ****      * must use GpioOverride to configure it */
1829:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1830:../uvc.c      ****     if (apiRetStatus != 0)
1831:../uvc.c      ****     {
1832:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1833:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1834:../uvc.c      ****     }
1835:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1836:../uvc.c      ****     if (apiRetStatus != 0)
1837:../uvc.c      ****     {
1838:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1839:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1840:../uvc.c      ****     }
1841:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1842:../uvc.c      ****     if (apiRetStatus != 0)
1843:../uvc.c      ****     {
1844:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1845:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1846:../uvc.c      ****     }
1847:../uvc.c      **** 
1848:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1849:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1852:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1856:../uvc.c      ****     {
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1858:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1859:../uvc.c      ****     }
1860:../uvc.c      **** 
1861:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1862:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1863:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1864:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1865:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1866:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1867:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1870:../uvc.c      ****     {
1871:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1872:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1873:../uvc.c      ****     }
1874:../uvc.c      **** 
1875:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1876:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1877:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1878:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1879:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1880:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1881:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1882:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1883:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1884:../uvc.c      ****     {
1885:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1886:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1887:../uvc.c      ****     }
1888:../uvc.c      **** 
1889:../uvc.c      ****     /* Initialize the P-port. */
1890:../uvc.c      ****     pibclock.clkDiv      = 2;
1891:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1892:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1893:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1894:../uvc.c      **** 
1895:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1896:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1897:../uvc.c      ****     {
1898:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1899:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1900:../uvc.c      ****     }
1901:../uvc.c      **** 
1902:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1903:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1904:../uvc.c      **** 
1905:../uvc.c      **** #ifdef BACKFLOW_DETECT
1906:../uvc.c      ****     back_flow_detected = 0;
1907:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1908:../uvc.c      **** #endif
1909:../uvc.c      **** 
1910:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1911:../uvc.c      ****     SensorReset ();
1912:../uvc.c      ****     SensorInit ();
1913:../uvc.c      **** 
1914:../uvc.c      ****     /* USB initialization. */
1915:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1916:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1917:../uvc.c      ****     {
1918:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1919:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1920:../uvc.c      ****     }
1921:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1922:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1923:../uvc.c      **** 
1924:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1925:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1926:../uvc.c      **** 
1927:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1928:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1929:../uvc.c      **** 
1930:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1931:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1933:../uvc.c      **** 
1934:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1935:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1936:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1937:../uvc.c      **** 
1938:../uvc.c      ****     /* Configuration descriptors. */
1939:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1940:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1941:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1942:../uvc.c      **** 
1943:../uvc.c      ****     /* String Descriptors */
1944:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1945:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1946:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1947:../uvc.c      **** 
1948:../uvc.c      ****     /* Configure the status interrupt endpoint.
1949:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1950:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1951:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1952:../uvc.c      ****      */
1953:../uvc.c      ****     endPointConfig.enable   = 1;
1954:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1955:../uvc.c      ****     endPointConfig.pcktSize = 64;
1956:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1957:../uvc.c      ****     endPointConfig.streams  = 0;
1958:../uvc.c      ****     endPointConfig.burstLen = 1;
1959:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1960:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1961:../uvc.c      ****     {
1962:../uvc.c      ****         /* Error Handling */
1963:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1964:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1965:../uvc.c      ****     }
1966:../uvc.c      **** 
1967:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1968:../uvc.c      ****     dmaInterConfig.size           = 1024;
1969:../uvc.c      ****     dmaInterConfig.count          = 1;
1970:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1971:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1972:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1973:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1974:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1975:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1976:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1977:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1978:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1979:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1980:../uvc.c      ****             &dmaInterConfig);
1981:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1982:../uvc.c      ****     {
1983:../uvc.c      ****         /* Error handling */
1984:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1985:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1986:../uvc.c      ****     }
1987:../uvc.c      **** 
1988:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1989:../uvc.c      ****     if (glInterStaBuffer == 0)
1990:../uvc.c      ****     {
1991:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1992:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1993:../uvc.c      ****     }
1994:../uvc.c      **** 
1995:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1996:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
1997:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1998:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1999:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2000:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2001:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2002:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2003:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2004:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2005:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2006:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2007:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2008:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2009:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2010:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2011:../uvc.c      ****             &dmaMultiConfig);
2012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2013:../uvc.c      ****     {
2014:../uvc.c      ****         /* Error handling */
2015:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2016:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2017:../uvc.c      ****     }
2018:../uvc.c      **** 
2019:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2020:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2021:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2022:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2023:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2024:../uvc.c      ****      */
2025:../uvc.c      **** 
2026:../uvc.c      ****     endPointConfig.enable   = 1;
2027:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2028:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2029:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2030:../uvc.c      ****     endPointConfig.streams  = 0;
2031:../uvc.c      ****     endPointConfig.burstLen = 1;
2032:../uvc.c      **** 
2033:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2034:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2035:../uvc.c      ****     {
2036:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2037:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2038:../uvc.c      ****     }
2039:../uvc.c      **** 
2040:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2041:../uvc.c      **** 
2042:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2043:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2044:../uvc.c      ****     {
2045:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2046:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2047:../uvc.c      ****     }
2048:../uvc.c      **** 
2049:../uvc.c      ****     channelConfig.size           = 1024;
2050:../uvc.c      ****     channelConfig.count          = 1;
2051:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2052:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2053:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2054:../uvc.c      ****     channelConfig.prodHeader     = 0;
2055:../uvc.c      ****     channelConfig.prodFooter     = 0;
2056:../uvc.c      ****     channelConfig.consHeader     = 0;
2057:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2058:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2059:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2060:../uvc.c      **** 
2061:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2062:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2063:../uvc.c      ****     {
2064:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2065:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2066:../uvc.c      ****     }
2067:../uvc.c      **** 
2068:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2069:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2070:../uvc.c      ****     {
2071:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2072:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2073:../uvc.c      ****     }
2074:../uvc.c      **** 
2075:../uvc.c      ****     channelConfig.size           = 1024;
2076:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2077:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2078:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2079:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2080:../uvc.c      ****     channelConfig.prodHeader     = 0;
2081:../uvc.c      ****     channelConfig.prodFooter     = 0;
2082:../uvc.c      ****     channelConfig.consHeader     = 0;
2083:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2084:../uvc.c      ****     channelConfig.notification   = 0;
2085:../uvc.c      ****     channelConfig.cb             = 0;
2086:../uvc.c      **** 
2087:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2088:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2089:../uvc.c      ****     {
2090:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2091:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2092:../uvc.c      ****     }
2093:../uvc.c      **** 
2094:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2095:../uvc.c      ****     if (glDebugRspBuffer == 0)
2096:../uvc.c      ****     {
2097:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2098:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2099:../uvc.c      ****     }
2100:../uvc.c      **** #endif
2101:../uvc.c      **** 
2102:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2103:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2104:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2105:../uvc.c      ****     {
2106:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2107:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2108:../uvc.c      ****     }
2109:../uvc.c      **** 
2110:../uvc.c      ****     CyU3PBusyWait(100);
2111:../uvc.c      **** 
2112:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2113:../uvc.c      **** 
2114:../uvc.c      ****     endPointConfig.enable   = 1;
2115:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2116:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2117:../uvc.c      ****     {
2118:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2119:../uvc.c      ****     	endPointConfig.burstLen = 16;
2120:../uvc.c      ****     }
2121:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2122:../uvc.c      ****     {
2123:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2124:../uvc.c      ****     	endPointConfig.burstLen = 1;
2125:../uvc.c      ****     }
2126:../uvc.c      ****     endPointConfig.streams  = 0;
2127:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2128:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2129:../uvc.c      ****     {
2130:../uvc.c      ****         /* Error Handling */
2131:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2132:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2133:../uvc.c      ****     }
2134:../uvc.c      **** #if 0    //for still image method 3 using
2135:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2136:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2137:../uvc.c      ****     {
2138:../uvc.c      ****         /* Error Handling */
2139:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2140:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2141:../uvc.c      ****     }
2142:../uvc.c      **** #endif
2143:../uvc.c      **** 
2144:../uvc.c      **** }
2145:../uvc.c      **** 
2146:../uvc.c      **** /*
2147:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2148:../uvc.c      ****  * streaming session is started.
2149:../uvc.c      ****  */
2150:../uvc.c      **** static void
2151:../uvc.c      **** CyFxUvcAppGpifInit (
2152:../uvc.c      ****         void)
2153:../uvc.c      **** {
2154:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2155:../uvc.c      **** 
2156:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2157:../uvc.c      ****     {
2158:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2159:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2160:../uvc.c      ****     }
2161:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2162:../uvc.c      ****     {
2163:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2164:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2165:../uvc.c      ****     }
2166:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2167:../uvc.c      ****     {
2168:../uvc.c      ****         /* Error Handling */
2169:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2170:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2171:../uvc.c      ****     }
2172:../uvc.c      **** 
2173:../uvc.c      ****     /* Start the state machine from the designated start state. */
2174:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2175:../uvc.c      ****     {
2176:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2177:../uvc.c      ****     }
2178:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2179:../uvc.c      ****     {
2180:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2181:../uvc.c      ****     }
2182:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2183:../uvc.c      ****     {
2184:../uvc.c      ****         /* Error Handling */
2185:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2186:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2187:../uvc.c      ****     }
2188:../uvc.c      **** }
2189:../uvc.c      **** 
2190:../uvc.c      **** /*
2191:../uvc.c      ****  * Entry function for the UVC Application Thread
2192:../uvc.c      ****  */
2193:../uvc.c      **** 
2194:../uvc.c      **** uint32_t posTick;
2195:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2196:../uvc.c      **** 
2197:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2198:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2199:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2200:../uvc.c      **** }
2201:../uvc.c      **** 
2202:../uvc.c      **** 
2203:../uvc.c      **** void
2204:../uvc.c      **** UVCAppThread_Entry (
2205:../uvc.c      ****         uint32_t input)
2206:../uvc.c      **** {
2207:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2208:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2209:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2210:../uvc.c      ****     uint8_t i = 0;
2211:../uvc.c      ****     uint32_t flag;
2212:../uvc.c      ****     uint32_t prinflag = 0;
2213:../uvc.c      **** static uint8_t IMcount = 0;
2214:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2215:../uvc.c      ****     uint32_t frameCnt = 0;
2216:../uvc.c      **** #endif
2217:../uvc.c      ****     /* Initialize the Uart Debug Module */
2218:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2219:../uvc.c      **** 
2220:../uvc.c      ****     /* Initialize the I2C interface */
2221:../uvc.c      **** 	while (i++ < 6){
2222:../uvc.c      **** 		CyU3PThreadSleep(500);
2223:../uvc.c      **** 	}
2224:../uvc.c      **** 
2225:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2226:../uvc.c      **** 
2227:../uvc.c      ****     /* Initialize the UVC Application */
2228:../uvc.c      ****     CyFxUVCApplnInit ();
2229:../uvc.c      **** 
2230:../uvc.c      ****     /*
2231:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2232:../uvc.c      **** 
2233:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2234:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2235:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2236:../uvc.c      **** 
2237:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2238:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2239:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2240:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2241:../uvc.c      **** 
2242:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2243:../uvc.c      ****        of handling the abort request.
2244:../uvc.c      ****      */
2245:../uvc.c      **** 
2246:../uvc.c      ****     for (;;)
2247:../uvc.c      ****     {
2248:../uvc.c      ****         /* Waiting for the Video Stream Event */
2249:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2250:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2251:../uvc.c      ****         {
2252:../uvc.c      **** #if 0 //test for new firmware no video bring up
2253:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2254:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2255:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2256:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2257:../uvc.c      ****             {
2258:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2259:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2260:../uvc.c      ****                 {
2261:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2262:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2263:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2264:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2265:../uvc.c      **** #endif
2266:../uvc.c      **** #endif
2267:../uvc.c      ****                     }
2268:../uvc.c      ****                 else
2269:../uvc.c      ****                 {
2270:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2271:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2272:../uvc.c      **** #ifdef USB_LOWRES_IMG
2273:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2274:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2275:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2276:../uvc.c      **** #endif
2277:../uvc.c      **** #endif
2278:../uvc.c      ****                 }
2279:../uvc.c      **** 
2280:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2281:../uvc.c      ****                 prodCount++;
2282:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2283:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2284:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2285:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2286:../uvc.c      ****                 {
2287:../uvc.c      ****                     prodCount--;
2288:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2289:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2290:../uvc.c      ****                 }
2291:../uvc.c      ****             }
2292:../uvc.c      **** #endif
2293:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2294:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2295:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2296:../uvc.c      ****             {
2297:../uvc.c      ****             	if(0&&(prinflag == 0)){
2298:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2299:../uvc.c      ****             		prinflag = 1;
2300:../uvc.c      ****             	}
2301:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2302:../uvc.c      ****             	fb=0;
2303:../uvc.c      ****             	pb=0;
2304:../uvc.c      ****             	pbc=0;
2305:../uvc.c      ****                 prodCount = 0;
2306:../uvc.c      ****                 consCount = 0;
2307:../uvc.c      ****                 hitFV     = CyFalse;
2308:../uvc.c      **** 
2309:../uvc.c      **** #ifdef BACKFLOW_DETECT
2310:../uvc.c      ****                 back_flow_detected = 0;
2311:../uvc.c      **** #endif
2312:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2313:../uvc.c      ****                 frameCnt++;
2314:../uvc.c      **** #endif
2315:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2316:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2317:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2318:../uvc.c      ****                 //}
2319:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2320:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2321:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2322:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2323:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2324:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2325:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2326:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2327:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2328:../uvc.c      ****                 		stiflag = 0xFF;
2329:../uvc.c      ****                 		IMcount = 0;
2330:../uvc.c      ****                 	}
2331:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2332:../uvc.c      **** 
2333:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2334:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2335:../uvc.c      ****                 		stiflag = 0x0F;
2336:../uvc.c      ****                 		IMcount = 0;
2337:../uvc.c      ****                 		}
2338:../uvc.c      ****                  		/*if(IMcount > 0x4){
2339:../uvc.c      ****                 			stiflag = 0x0F;
2340:../uvc.c      ****                 			IMcount = 0;
2341:../uvc.c      ****                 		}*/
2342:../uvc.c      **** 
2343:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2344:../uvc.c      ****                     //CyU3PThreadSleep(400);
2345:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2346:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2347:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2348:../uvc.c      **** 
2349:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2350:../uvc.c      ****                 	{
2351:../uvc.c      ****                     switch (setRes)
2352:../uvc.c      ****                      {
2353:../uvc.c      ****                  	case 1: //960
2354:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2355:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2356:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0xb, 0x0);
2357:../uvc.c      ****                  		break;
2358:../uvc.c      ****                  	case 2: //720
2359:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2360:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2361:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0x0b, 0x1);
2362:../uvc.c      ****                  		break;
2363:../uvc.c      ****                  	default:
2364:../uvc.c      ****                  		break;
2365:../uvc.c      ****                      }
2366:../uvc.c      ****                     IMcount = 0;
2367:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2368:../uvc.c      ****                 	stiflag = 0x0;
2369:../uvc.c      ****                 	}
2370:../uvc.c      ****                 }
2371:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2372:../uvc.c      ****                 /* Reset the DMA channel. */
2373:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2374:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2375:../uvc.c      ****                 {
2376:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2377:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2378:../uvc.c      ****                 }
2379:../uvc.c      **** 
2380:../uvc.c      ****                 /* Start Channel Immediately */
2381:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2382:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2383:../uvc.c      ****                 {
2384:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2385:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2386:../uvc.c      ****                 }
2387:../uvc.c      **** 
2388:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2389:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2390:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2391:../uvc.c      ****                 }
2392:../uvc.c      ****         }
2393:../uvc.c      ****         else
2394:../uvc.c      ****         {
2395:../uvc.c      ****             /* If we have a stream abort request pending. */
2396:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2397:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2398:../uvc.c      ****             {
2399:../uvc.c      ****                 hitFV     = CyFalse;
2400:../uvc.c      ****                 prodCount = 0;
2401:../uvc.c      ****                 consCount = 0;
2402:../uvc.c      ****                 if(0&&(prinflag == 0)){
2403:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2404:../uvc.c      ****                 	prinflag = 1;
2405:../uvc.c      ****                 }
2406:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2407:../uvc.c      ****                 fb=0;
2408:../uvc.c      ****                 pb=0;
2409:../uvc.c      ****                 pbc=0;
2410:../uvc.c      **** 
2411:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2412:../uvc.c      ****                 {
2413:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2414:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2415:../uvc.c      ****                     {
2416:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2417:../uvc.c      ****                     }
2418:../uvc.c      **** 
2419:../uvc.c      ****                     /* Flush the Endpoint memory */
2420:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2421:../uvc.c      ****                 }
2422:../uvc.c      **** 
2423:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2424:../uvc.c      ****             }
2425:../uvc.c      ****             else
2426:../uvc.c      ****             {
2427:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2428:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2429:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2430:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2431:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2432:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2433:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2434:../uvc.c      ****                 {
2435:../uvc.c      ****                     /* Error handling */
2436:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2437:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2438:../uvc.c      ****                 }
2439:../uvc.c      **** 
2440:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2441:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2442:../uvc.c      ****                 {
2443:../uvc.c      **** #if 0
2444:../uvc.c      ****                 	//for start up of the AF Lens
2445:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2446:../uvc.c      ****                     CyU3PThreadSleep(500);
2447:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2448:../uvc.c      ****                     CyU3PThreadSleep(500);
2449:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2450:../uvc.c      ****                    	CyU3PThreadSleep(300);
2451:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2452:../uvc.c      ****                     CyU3PThreadSleep(500);
2453:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2454:../uvc.c      ****                     CyU3PThreadSleep(500);
2455:../uvc.c      **** #endif
2456:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2457:../uvc.c      ****                     gpif_initialized = CyTrue;
2458:../uvc.c      ****                     CyU3PThreadSleep(200);
2459:../uvc.c      ****                     
2460:../uvc.c      ****                 }
2461:../uvc.c      ****                 else
2462:../uvc.c      ****                 {
2463:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2464:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2465:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2466:../uvc.c      ****                 }
2467:../uvc.c      ****             }
2468:../uvc.c      ****         }
2469:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2470:../uvc.c      **** 
2471:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2472:../uvc.c      ****         CyU3PThreadRelinquish ();
2473:../uvc.c      ****     }
2474:../uvc.c      **** }
2475:../uvc.c      **** 
2476:../uvc.c      **** /*
2477:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2478:../uvc.c      ****  */
2479:../uvc.c      **** 
2480:../uvc.c      **** static void
2481:../uvc.c      **** UVCHandleProcessingUnitRqts (
2482:../uvc.c      ****         void)
2483:../uvc.c      **** {
2484:../uvc.c      ****     uint8_t CtrlAdd;
2485:../uvc.c      **** #ifdef DbgInfo
2486:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2487:../uvc.c      **** #endif
2488:../uvc.c      ****     switch (wValue)
2489:../uvc.c      ****     {
2490:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2491:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2492:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2493:../uvc.c      ****     		break;
2494:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2495:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2496:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2497:../uvc.c      ****     		break;
2498:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2499:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2500:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2501:../uvc.c      **** 			break;
2502:../uvc.c      **** 
2503:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2504:../uvc.c      **** 
2505:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2506:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2507:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2508:../uvc.c      ****       		break;
2509:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2510:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2511:../uvc.c      ****      		ControlHandle(HueCtlID5);
2512:../uvc.c      ****      		break;
2513:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2514:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2515:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2516:../uvc.c      ****           		break;
2517:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2518:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2519:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2520:../uvc.c      ****           		break;
2521:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2522:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2523:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2524:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2525:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2526:../uvc.c      ****     		break;
2527:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2528:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2529:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2530:../uvc.c      ****     		break;
2531:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2532:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2533:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2534:../uvc.c      ****     		break;
2535:../uvc.c      **** 
2536:../uvc.c      ****         default:
2537:../uvc.c      ****             /*
2538:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2539:../uvc.c      ****              * other controls.
2540:../uvc.c      ****              */
2541:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2542:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2543:../uvc.c      ****             break;
2544:../uvc.c      ****     }
2545:../uvc.c      **** }
2546:../uvc.c      **** 
2547:../uvc.c      **** /*
2548:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2549:../uvc.c      ****  */
2550:../uvc.c      **** static void
2551:../uvc.c      **** UVCHandleCameraTerminalRqts (
2552:../uvc.c      ****         void)
2553:../uvc.c      **** {
2554:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2555:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2556:../uvc.c      ****     uint16_t readCount;
2557:../uvc.c      ****     uint16_t zoomVal;
2558:../uvc.c      ****     int32_t  panVal, tiltVal;
2559:../uvc.c      ****     CyBool_t sendData = CyFalse;
2560:../uvc.c      **** #endif
2561:../uvc.c      ****     uint8_t CtrlAdd;
2562:../uvc.c      **** 
2563:../uvc.c      ****     switch (wValue)
2564:../uvc.c      ****     {
2565:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2566:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2567:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2568:../uvc.c      ****     		break;
2569:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2570:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2571:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2572:../uvc.c      ****     		break;
2573:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2574:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2575:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2576:../uvc.c      **** 			break;
2577:../uvc.c      **** 
2578:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2579:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2580:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2581:../uvc.c      **** 			break;
2582:../uvc.c      **** 
2583:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2584:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2585:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2586:../uvc.c      ****       		break;
2587:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2588:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2589:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2590:../uvc.c      ****      		break;
2591:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2592:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2593:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2594:../uvc.c      ****           		break;
2595:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2596:../uvc.c      ****           		break;
2597:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2598:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2599:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2600:../uvc.c      ****      		break;
2601:../uvc.c      **** 
2602:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2603:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2604:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2605:../uvc.c      ****     		break;
2606:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2607:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2608:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2609:../uvc.c      ****     		break;
2610:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2611:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2612:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2613:../uvc.c      ****     		break;
2614:../uvc.c      **** 
2615:../uvc.c      ****         default:
2616:../uvc.c      ****             /*
2617:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2618:../uvc.c      ****              * other controls.
2619:../uvc.c      ****              */
2620:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2621:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2622:../uvc.c      ****             break;
2623:../uvc.c      ****     }
2624:../uvc.c      **** 
2625:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2626:../uvc.c      ****     switch (wValue)
2627:../uvc.c      ****     {
2628:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2629:../uvc.c      ****             switch (bRequest)
2630:../uvc.c      ****             {
2631:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2632:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2633:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2634:../uvc.c      ****                     break;
2635:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2636:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2637:../uvc.c      ****                     sendData = CyTrue;
2638:../uvc.c      ****                     break;
2639:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2640:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2641:../uvc.c      ****                     sendData = CyTrue;
2642:../uvc.c      ****                     break;
2643:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2644:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2645:../uvc.c      ****                     sendData = CyTrue;
2646:../uvc.c      ****                     break;
2647:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2648:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2649:../uvc.c      ****                     sendData = CyTrue;
2650:../uvc.c      ****                     break;
2651:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2652:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2653:../uvc.c      ****                     sendData = CyTrue;
2654:../uvc.c      ****                     break;
2655:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2656:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2657:../uvc.c      ****                             glEp0Buffer, &readCount);
2658:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2659:../uvc.c      ****                     {
2660:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2661:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2662:../uvc.c      ****                     }
2663:../uvc.c      ****                     break;
2664:../uvc.c      ****                 default:
2665:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2666:../uvc.c      ****                     break;
2667:../uvc.c      ****             }
2668:../uvc.c      **** 
2669:../uvc.c      ****             if (sendData)
2670:../uvc.c      ****             {
2671:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2672:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2673:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2674:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2675:../uvc.c      ****             }
2676:../uvc.c      ****             break;
2677:../uvc.c      **** 
2678:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2679:../uvc.c      ****             switch (bRequest)
2680:../uvc.c      ****             {
2681:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2682:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2683:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2684:../uvc.c      ****                     break;
2685:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2686:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2687:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2688:../uvc.c      ****                     sendData = CyTrue;
2689:../uvc.c      ****                     break;
2690:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2691:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2692:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2693:../uvc.c      ****                     sendData = CyTrue;
2694:../uvc.c      ****                     break;
2695:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2696:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2697:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2698:../uvc.c      ****                     sendData = CyTrue;
2699:../uvc.c      ****                     break;
2700:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2701:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2702:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2703:../uvc.c      ****                     sendData = CyTrue;
2704:../uvc.c      ****                     break;
2705:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2706:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2707:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2708:../uvc.c      ****                     sendData = CyTrue;
2709:../uvc.c      ****                     break;
2710:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2711:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2712:../uvc.c      ****                             glEp0Buffer, &readCount);
2713:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2714:../uvc.c      ****                     {
2715:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2716:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2717:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2718:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2719:../uvc.c      **** 
2720:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2721:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2722:../uvc.c      ****                     }
2723:../uvc.c      ****                     break;
2724:../uvc.c      ****                 default:
2725:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2726:../uvc.c      ****                     break;
2727:../uvc.c      ****             }
2728:../uvc.c      **** 
2729:../uvc.c      ****             if (sendData)
2730:../uvc.c      ****             {
2731:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2732:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2733:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2734:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2735:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2736:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2737:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2738:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2739:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2740:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2741:../uvc.c      ****             }
2742:../uvc.c      ****             break;
2743:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2744:../uvc.c      ****         default:
2745:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2746:../uvc.c      ****             break;
2747:../uvc.c      ****     }
2748:../uvc.c      **** #endif
2749:../uvc.c      **** }
2750:../uvc.c      **** 
2751:../uvc.c      **** /*
2752:../uvc.c      ****  * Handler for UVC Interface control requests.
2753:../uvc.c      ****  */
2754:../uvc.c      **** static void
2755:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2756:../uvc.c      ****         void)
2757:../uvc.c      **** {
2758:../uvc.c      **** 
2759:../uvc.c      ****     switch (wValue)
2760:../uvc.c      ****     {
2761:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2762:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2763:../uvc.c      ****     		break;
2764:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2765:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2766:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2767:../uvc.c      ****     		break;
2768:../uvc.c      ****     	default:
2769:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2770:../uvc.c      ****      		break;
2771:../uvc.c      ****     }
2772:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2773:../uvc.c      **** 
2774:../uvc.c      **** }
2775:../uvc.c      **** 
2776:../uvc.c      **** /*
2777:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2778:../uvc.c      ****  */
2779:../uvc.c      **** static void
2780:../uvc.c      **** UVCHandleExtensionUnitRqts (
2781:../uvc.c      ****         void)
2782:../uvc.c      **** {
2783:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2784:../uvc.c      **** 
2785:../uvc.c      **** #ifdef DbgInfo
2786:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2787:../uvc.c      **** #endif
2788:../uvc.c      ****     switch (wValue)
2789:../uvc.c      ****     {
2790:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2791:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2792:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2793:../uvc.c      ****     		break;
2794:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2795:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2796:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2797:../uvc.c      ****     		break;
2798:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2799:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2800:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2801:../uvc.c      ****      		break;
2802:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2803:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2804:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2805:../uvc.c      ****     		break;
2806:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2807:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2808:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2809:../uvc.c      ****     		break;
2810:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2811:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2812:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2813:../uvc.c      ****      		break;
2814:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2815:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2816:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2817:../uvc.c      ****     		break;
2818:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2819:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2820:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2821:../uvc.c      ****     		break;
2822:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2823:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2824:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2825:../uvc.c      ****      		break;
2826:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2827:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2828:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2829:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2830:../uvc.c      ****     		}else/* no support for 1080p camera */
2831:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2832:../uvc.c      ****     		break;
2833:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2834:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2835:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2836:../uvc.c      ****     		break;
2837:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2838:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2839:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2840:../uvc.c      ****     		break;
2841:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2842:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2843:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2844:../uvc.c      ****     		//break;
2845:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2846:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2847:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2848:../uvc.c      ****     		break;
2849:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2850:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2851:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2852:../uvc.c      ****     		break;
2853:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2854:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2855:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2856:../uvc.c      ****     		break;
2857:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2858:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2859:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2860:../uvc.c      ****     		break;
2861:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2862:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2863:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2864:../uvc.c      ****     		break;
2865:../uvc.c      ****    	default:
2866:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2867:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2868:../uvc.c      ****     		break;
2869:../uvc.c      ****     }
2870:../uvc.c      **** 
2871:../uvc.c      **** }
2872:../uvc.c      **** 
2873:../uvc.c      **** /*
2874:../uvc.c      ****  * Handler for the video streaming control requests.
2875:../uvc.c      ****  */
2876:../uvc.c      **** static void
2877:../uvc.c      **** UVCHandleVideoStreamingRqts (
2878:../uvc.c      ****         void)
2879:../uvc.c      **** {
2880:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2881:../uvc.c      ****     uint16_t readCount;
2882:../uvc.c      **** 
2883:../uvc.c      ****     switch (wValue)
2884:../uvc.c      ****     {
2885:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2886:../uvc.c      ****             switch (bRequest)
2887:../uvc.c      ****             {
2888:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2889:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2890:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2891:../uvc.c      ****                     break;
2892:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2893:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2894:../uvc.c      ****                     glEp0Buffer[1] = 0;
2895:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2896:../uvc.c      ****                     break;
2897:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2898:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2899:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2900:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2901:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED)//supports both SS and HS
2902:../uvc.c      ****                     {
2903:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2904:../uvc.c      ****                     }
2905:../uvc.c      ****                     else
2906:../uvc.c      ****                     {
2907:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2908:../uvc.c      ****                     }
2909:../uvc.c      ****                     break;
2910:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2911:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2912:../uvc.c      ****                             glCommitCtrl, &readCount);
2913:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2914:../uvc.c      ****                     {
2915:../uvc.c      ****                         //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
2916:../uvc.c      ****                         {
2917:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2918:../uvc.c      ****                                active data structure. */
2919:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2920:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2921:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2922:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2923:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2924:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2925:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d\r\n", readCount
2926:../uvc.c      ****                         }
2927:../uvc.c      ****                     }
2928:../uvc.c      ****                     break;
2929:../uvc.c      ****                 default:
2930:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2931:../uvc.c      ****                     break;
2932:../uvc.c      ****             }
2933:../uvc.c      ****             break;
2934:../uvc.c      **** 
2935:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2936:../uvc.c      ****             switch (bRequest)
2937:../uvc.c      ****             {
2938:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2939:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2940:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2941:../uvc.c      ****                     break;
2942:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2943:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2944:../uvc.c      ****                     glEp0Buffer[1] = 0;
2945:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2946:../uvc.c      ****                     break;
2947:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2948:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED) //support both SS and HS
2949:../uvc.c      ****                     {
2950:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2951:../uvc.c      ****                     }
2952:../uvc.c      ****                     else
2953:../uvc.c      ****                     {
2954:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2955:../uvc.c      ****                     }
2956:../uvc.c      ****                     break;
2957:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2958:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2959:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2960:../uvc.c      ****                        */
2961:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2962:../uvc.c      ****                             glCommitCtrl, &readCount);
2963:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)//supports both SS and HS
2964:../uvc.c      ****                     {
2965:../uvc.c      ****                         switch (glCommitCtrl[3])
2966:../uvc.c      ****                          {
2967:../uvc.c      ****                          	case 1: //960 or 480
2968:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
2969:../uvc.c      ****                          		CyU3PThreadSleep(500);
2970:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
2971:../uvc.c      ****                          		break;
2972:../uvc.c      ****                          	case 2: //720 or 360
2973:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
2974:../uvc.c      ****                          		CyU3PThreadSleep(500);
2975:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
2976:../uvc.c      ****                          		break;
2977:../uvc.c      ****                          	default:
2978:../uvc.c      ****                          		break;
2979:../uvc.c      ****                          }
2980:../uvc.c      ****                         setRes = glCommitCtrl[3];
2981:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
2982:../uvc.c      **** 
2983:../uvc.c      **** #if 0
2984:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2985:../uvc.c      ****                         {
2986:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2987:../uvc.c      ****                         }
2988:../uvc.c      ****                         else
2989:../uvc.c      ****                         {
2990:../uvc.c      ****                             SensorScaling_VGA ();
2991:../uvc.c      ****                         }
2992:../uvc.c      **** #endif
2993:../uvc.c      ****                         /* We can start streaming video now. */
2994:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2995:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2996:../uvc.c      ****                         {
2997:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2998:../uvc.c      ****                         }
2999:../uvc.c      ****                     }
3000:../uvc.c      ****                     break;
3001:../uvc.c      **** 
3002:../uvc.c      ****                 default:
3003:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3004:../uvc.c      ****                     break;
3005:../uvc.c      ****             }
3006:../uvc.c      ****             break;
3007:../uvc.c      **** 
3008:../uvc.c      **** /* still image streaming handler */
3009:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3010:../uvc.c      ****                 switch (bRequest)
3011:../uvc.c      ****                 {
3012:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3013:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3014:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3015:../uvc.c      ****                         break;
3016:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3017:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3018:../uvc.c      ****                         glEp0Buffer[1] = 0;
3019:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3020:../uvc.c      ****                         break;
3021:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3022:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3023:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3024:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3025:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3026:../uvc.c      ****                         {
3027:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3028:../uvc.c      ****                         }
3029:../uvc.c      ****                         else
3030:../uvc.c      ****                         {
3031:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3032:../uvc.c      ****                         }
3033:../uvc.c      ****                         break;
3034:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3035:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3036:../uvc.c      ****                                 glCommitCtrl, &readCount);
3037:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3038:../uvc.c      ****                         {
3039:../uvc.c      ****                             //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
3040:../uvc.c      ****                             {
3041:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3042:../uvc.c      ****                                    active data structure. */
3043:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3044:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3045:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3046:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3047:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3048:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3049:../uvc.c      ****                             }
3050:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3051:../uvc.c      ****                         }
3052:../uvc.c      ****                         break;
3053:../uvc.c      ****                     default:
3054:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3055:../uvc.c      ****                         break;
3056:../uvc.c      ****                 }
3057:../uvc.c      ****                 break;
3058:../uvc.c      **** 
3059:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3060:../uvc.c      ****                 switch (bRequest)
3061:../uvc.c      ****                 {
3062:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3063:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3064:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3065:../uvc.c      ****                         break;
3066:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3067:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3068:../uvc.c      ****                         glEp0Buffer[1] = 0;
3069:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3070:../uvc.c      ****                         break;
3071:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3072:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3073:../uvc.c      ****                         {
3074:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3075:../uvc.c      ****                         }
3076:../uvc.c      ****                         else
3077:../uvc.c      ****                         {
3078:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3079:../uvc.c      ****                         }
3080:../uvc.c      ****                         break;
3081:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3082:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3083:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3084:../uvc.c      ****                            */
3085:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3086:../uvc.c      ****                                 glCommitCtrl, &readCount);
3087:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3088:../uvc.c      ****                         {
3089:../uvc.c      ****     #if 0
3090:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3091:../uvc.c      ****                             {
3092:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3093:../uvc.c      ****                             }
3094:../uvc.c      ****                             else
3095:../uvc.c      ****                             {
3096:../uvc.c      ****                                 SensorScaling_VGA ();
3097:../uvc.c      ****                             }
3098:../uvc.c      ****                             /* We can start streaming video now. */
3099:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3100:../uvc.c      **** 
3101:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3102:../uvc.c      ****                             {
3103:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3104:../uvc.c      ****                             }
3105:../uvc.c      **** 	#endif
3106:../uvc.c      ****                            switch (glCommitCtrl[1])
3107:../uvc.c      ****                              {
3108:../uvc.c      ****                              	case 1: //720
3109:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*
3110:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3111:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3112:../uvc.c      ****                              		break;
3113:../uvc.c      ****                             	case 2: //960
3114:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*
3115:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3116:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3117:../uvc.c      ****                              		break;
3118:../uvc.c      ****                               	default:
3119:../uvc.c      ****                              		break;
3120:../uvc.c      ****                              }
3121:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3122:../uvc.c      **** 
3123:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3124:../uvc.c      **** 
3125:../uvc.c      ****                         }
3126:../uvc.c      ****                         break;
3127:../uvc.c      **** 
3128:../uvc.c      ****                     default:
3129:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3130:../uvc.c      ****                         break;
3131:../uvc.c      ****                 }
3132:../uvc.c      ****                 break;
3133:../uvc.c      **** 
3134:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3135:../uvc.c      ****                 switch (bRequest)
3136:../uvc.c      ****                 {
3137:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3138:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3139:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3140:../uvc.c      ****                         break;
3141:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3142:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3143:../uvc.c      ****                         glEp0Buffer[1] = 0;
3144:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3145:../uvc.c      ****                         break;
3146:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3147:../uvc.c      ****                         if (1 || usbSpeed == CY_U3P_SUPER_SPEED)// support both SS and HS
3148:../uvc.c      ****                         {
3149:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3150:../uvc.c      ****                         }
3151:../uvc.c      ****                         else
3152:../uvc.c      ****                         {
3153:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3154:../uvc.c      ****                         }
3155:../uvc.c      ****                         break;
3156:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3157:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3158:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3159:../uvc.c      ****                            */
3160:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3161:../uvc.c      ****                                 glCommitCtrl, &readCount);
3162:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3163:../uvc.c      ****                         {
3164:../uvc.c      ****     #if 1
3165:../uvc.c      ****                             /* We can start still streaming video now. */
3166:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3167:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3168:../uvc.c      ****                             {
3169:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3170:../uvc.c      ****                             }
3171:../uvc.c      ****     #endif
3172:../uvc.c      ****                             else{
3173:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3174:../uvc.c      ****                             //stillcont = 0;
3175:../uvc.c      ****                             }
3176:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3177:../uvc.c      ****                         }else{
3178:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3179:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3180:../uvc.c      ****                         }
3181:../uvc.c      ****                         break;
3182:../uvc.c      **** 
3183:../uvc.c      ****                     default:
3184:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3185:../uvc.c      ****                         break;
3186:../uvc.c      ****                 }
3187:../uvc.c      ****                 break;
3188:../uvc.c      **** 
3189:../uvc.c      ****         default:
3190:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3191:../uvc.c      ****             break;
3192:../uvc.c      ****     }
3193:../uvc.c      **** }
3194:../uvc.c      **** 
3195:../uvc.c      **** /*
3196:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3197:../uvc.c      ****  */
3198:../uvc.c      **** void
3199:../uvc.c      **** UVCAppEP0Thread_Entry (
3200:../uvc.c      ****         uint32_t input)
3201:../uvc.c      **** {
3202:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3203:../uvc.c      ****     uint32_t eventFlag;
3204:../uvc.c      **** 	CyBool_t value;
3205:../uvc.c      **** 	CyBool_t *valueptr = &value;
3206:../uvc.c      **** 
3207:../uvc.c      **** 
3208:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3209:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3210:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3211:../uvc.c      **** 
3212:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3213:../uvc.c      **** #endif
3214:../uvc.c      **** 
3215:../uvc.c      ****     /* for interrupt status test */
3216:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3217:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3218:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3219:../uvc.c      **** 
3220:../uvc.c      ****     for (;;)
3221:../uvc.c      ****     {
3222:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3223:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3224:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3225:../uvc.c      ****         {
3226:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3227:../uvc.c      ****             if (!isUsbConnected)
3228:../uvc.c      ****             {
3229:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3230:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3231:../uvc.c      ****                 {
3232:../uvc.c      ****                     isUsbConnected = CyTrue;
3233:../uvc.c      ****                 }
3234:../uvc.c      ****             }
3235:../uvc.c      **** //#ifdef DbgInfo
3236:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3237:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3238:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3239:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3240:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3241:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3242:../uvc.c      **** //#endif
3243:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3244:../uvc.c      ****             {
3245:../uvc.c      ****             	switch ((wIndex >> 8))
3246:../uvc.c      ****                 {
3247:../uvc.c      **** 
3248:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3249:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3250:../uvc.c      ****                         break;
3251:../uvc.c      **** 
3252:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3253:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3254:../uvc.c      ****                         break;
3255:../uvc.c      **** 
3256:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3257:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3258:../uvc.c      ****                         break;
3259:../uvc.c      **** 
3260:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3261:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3262:../uvc.c      ****                         break;
3263:../uvc.c      **** 
3264:../uvc.c      ****                     default:
3265:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3266:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3267:../uvc.c      ****                         break;
3268:../uvc.c      ****                 }
3269:../uvc.c      ****             }
3270:../uvc.c      **** 
3271:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3272:../uvc.c      ****             {
3273:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3274:../uvc.c      **** 
3275:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3276:../uvc.c      ****                 {
3277:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3278:../uvc.c      ****                 }
3279:../uvc.c      ****                 else
3280:../uvc.c      ****                 {
3281:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3282:../uvc.c      ****                 }
3283:../uvc.c      ****             }
3284:../uvc.c      **** 
3285:../uvc.c      ****             /* handle interrupt status event */
3286:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3287:../uvc.c      ****             {
3288:../uvc.c      **** 
3289:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3290:../uvc.c      ****             	/** preparing interrupt status data **/
3291:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3292:../uvc.c      **** 
3293:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3294:../uvc.c      **** 
3295:../uvc.c      **** #if 1 //for real button
3296:../uvc.c      **** 				if(value&&(!snapButFlag)){
3297:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3298:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3299:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3300:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3301:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3302:../uvc.c      **** 
3303:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3304:../uvc.c      **** 					interStabuf.size   = 1024;
3305:../uvc.c      **** 					interStabuf.status = 0;
3306:../uvc.c      **** 
3307:../uvc.c      **** 					interStabuf.count = 4;
3308:../uvc.c      **** 
3309:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3310:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3311:../uvc.c      **** 
3312:../uvc.c      **** 					/** send a interrupt status data **/
3313:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3314:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3315:../uvc.c      **** 					{
3316:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3317:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3318:../uvc.c      **** 					}
3319:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3320:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3321:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3322:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3323:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3324:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3325:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3326:../uvc.c      **** 
3327:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3328:../uvc.c      **** 					interStabuf.size   = 1024;
3329:../uvc.c      **** 					interStabuf.status = 0;
3330:../uvc.c      **** 
3331:../uvc.c      **** 					interStabuf.count = 4;
3332:../uvc.c      **** 
3333:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3334:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3335:../uvc.c      **** 
3336:../uvc.c      **** 					/** send a interrupt status data **/
3337:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3338:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3339:../uvc.c      **** 					{
3340:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3341:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3342:../uvc.c      **** 					}
3343:../uvc.c      **** 
3344:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3345:../uvc.c      **** 					stiflag = 0xFF;
3346:../uvc.c      **** 				}
3347:../uvc.c      **** #else			//for botton simulation
3348:../uvc.c      **** 				if(snapButFlag == 0x0f){
3349:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3350:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3351:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3352:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3353:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3354:../uvc.c      **** 
3355:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3356:../uvc.c      **** 					interStabuf.size   = 1024;
3357:../uvc.c      **** 					interStabuf.status = 0;
3358:../uvc.c      **** 
3359:../uvc.c      **** 					interStabuf.count = 4;
3360:../uvc.c      **** 
3361:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3362:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3363:../uvc.c      **** 
3364:../uvc.c      **** 					/** send a interrupt status data **/
3365:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3366:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3367:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3368:../uvc.c      **** 					{
3369:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3370:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3371:../uvc.c      **** 					}
3372:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3373:../uvc.c      **** 
3374:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3375:../uvc.c      **** 				}else if(!snapButFlag){
3376:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3377:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3378:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3379:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3380:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3381:../uvc.c      **** 
3382:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3383:../uvc.c      **** 					interStabuf.size   = 1024;
3384:../uvc.c      **** 					interStabuf.status = 0;
3385:../uvc.c      **** 
3386:../uvc.c      **** 					interStabuf.count = 4;
3387:../uvc.c      **** 
3388:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3389:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3390:../uvc.c      **** 
3391:../uvc.c      **** 					/** send a interrupt status data **/
3392:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3393:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3394:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3395:../uvc.c      **** 					{
3396:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3397:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3398:../uvc.c      **** 					}
3399:../uvc.c      **** 
3400:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3401:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3402:../uvc.c      **** 				}
3403:../uvc.c      **** #endif
3404:../uvc.c      **** 
3405:../uvc.c      ****             }
3406:../uvc.c      **** 
3407:../uvc.c      **** 
3408:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3409:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3410:../uvc.c      ****             {
3411:../uvc.c      ****                 /* Get the command buffer */
3412:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3413:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3414:../uvc.c      ****                 {
3415:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3416:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3417:../uvc.c      ****                 }
3418:../uvc.c      **** 
3419:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3420:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3421:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3422:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3423:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3424:../uvc.c      ****                  * register value high byte and register value low byte.
3425:../uvc.c      ****                  */
3426:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3427:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3428:../uvc.c      ****                 {
3429:../uvc.c      ****                     if (dmaInfo.count == 3)
3430:../uvc.c      ****                     {
3431:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3432:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3433:../uvc.c      ****                         dmaInfo.count = 3;
3434:../uvc.c      ****                     }
3435:../uvc.c      ****                     else if (dmaInfo.count == 4)
3436:../uvc.c      ****                     {
3437:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3438:../uvc.c      ****                         {
3439:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3440:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3441:../uvc.c      ****                         }
3442:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3443:../uvc.c      ****                     }
3444:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3445:../uvc.c      ****                 }
3446:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3447:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3448:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3449:../uvc.c      ****                  */
3450:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3451:../uvc.c      ****                 {
3452:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3453:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3454:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3455:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3456:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3457:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3458:../uvc.c      ****                         	break;
3459:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3460:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3461:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3462:../uvc.c      ****                         	break;*/
3463:../uvc.c      ****                     dmaInfo.count -= 2;
3464:../uvc.c      ****                 }
3465:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3466:../uvc.c      ****                 else
3467:../uvc.c      ****                 {
3468:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3469:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3470:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3471:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3472:../uvc.c      ****                 }
3473:../uvc.c      **** 
3474:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3475:../uvc.c      ****                 dmaInfo.size   = 1024;
3476:../uvc.c      ****                 dmaInfo.status = 0;
3477:../uvc.c      **** 
3478:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3479:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3480:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3481:../uvc.c      ****                 {
3482:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3483:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3484:../uvc.c      ****                 }
3485:../uvc.c      **** 
3486:../uvc.c      ****                 /* Wait until the response has gone out. */
3487:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3488:../uvc.c      **** 
3489:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3490:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3491:../uvc.c      ****                 {
3492:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3493:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3494:../uvc.c      ****                 }
3495:../uvc.c      ****             }
3496:../uvc.c      **** #endif
3497:../uvc.c      ****         }
3498:../uvc.c      ****         /* Allow other ready threads to run. */
3499:../uvc.c      ****         CyU3PThreadRelinquish ();
3500:../uvc.c      ****     }
3501:../uvc.c      **** }
3502:../uvc.c      **** 
3503:../uvc.c      **** /*
3504:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3505:../uvc.c      ****  * added 10/2013
3506:../uvc.c      ****  */
3507:../uvc.c      **** /*
3508:../uvc.c      **** static uint8_t timeDelay[64] = {
3509:../uvc.c      **** 
3510:../uvc.c      **** };
3511:../uvc.c      **** */
3512:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3512 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3513:../uvc.c      **** 
3514:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3515:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3516:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3517:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3518:../uvc.c      **** 	VdstateDes *lcStaDes;
3519:../uvc.c      **** 	uint32_t flag = 0;
3520:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3521:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3522:../uvc.c      **** 	uint8_t i;
3523:../uvc.c      **** 	uint16_t delaytime;
3524:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3525:../uvc.c      **** 
3526:../uvc.c      **** #if 0 //for test the command queue
3527:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3528:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3529:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3530:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3531:../uvc.c      **** 		lcCmdDes += 1;
3532:../uvc.c      **** 	}
3533:../uvc.c      **** #endif
3534:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3535:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3535 0
  36 0004 00229FE5 		ldr	r2, .L22
3519:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3519 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3512:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3512 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3535 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 E8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3519:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3519 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3535 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3536:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3536 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 CC119FE5 		ldr	r1, .L22+8
  71 0044 CC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3537:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3537 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3538:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3538 0
  79 005c AC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3539:../uvc.c      **** 
3540:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3540 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3541:../uvc.c      ****         /* Allow other ready threads to run. */
3542:../uvc.c      **** 
3543:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3543 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3540:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3540 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3544:../uvc.c      **** 	}
3545:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3545 0
  92 0078 98019FE5 		ldr	r0, .L22+12
  93 007c 98119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 88719FE5 		ldr	r7, .L22+20
  99 0094 88B19FE5 		ldr	fp, .L22+24
3546:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3547:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3548:../uvc.c      **** 	//CyU3PThreadSleep(100);
3549:../uvc.c      **** 	//SetCurCmd();
3550:../uvc.c      **** 	/*********** the loop of the thread ***********/
3551:../uvc.c      **** 	for(;;){
3552:../uvc.c      **** 
3553:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3553 0
 101 0098 0060E0E3 		mvn	r6, #0
3554:../uvc.c      **** /*  // for test GPIO output
3555:../uvc.c      **** 		if(trigger)
3556:../uvc.c      **** 		{
3557:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3558:../uvc.c      **** 			{
3559:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3560:../uvc.c      **** 			}
3561:../uvc.c      **** 
3562:../uvc.c      **** 		}else{
3563:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3564:../uvc.c      **** 			{
3565:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3566:../uvc.c      **** 			}
3567:../uvc.c      **** 
3568:../uvc.c      **** 		}
3569:../uvc.c      **** */
3570:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3571:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3572:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3573:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3574:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3575:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3576:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3577:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3578:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3579:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3580:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3581:../uvc.c      **** #endif
3582:../uvc.c      **** 				}
3583:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3584:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3585:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3586:../uvc.c      **** 			}
3587:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3588:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3589:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3590:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3591:../uvc.c      **** 
3592:../uvc.c      **** 				/*
3593:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3594:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3595:../uvc.c      **** 				*/
3596:../uvc.c      **** 
3597:../uvc.c      **** 				/* find a available command */
3598:../uvc.c      **** 				i = 0;
3599:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3599 0
 103 009c 0090A0E3 		mov	r9, #0
3600:../uvc.c      **** 					i++;
3601:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3602:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3603:../uvc.c      **** 				}
3604:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3605:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3606:../uvc.c      **** 					i = lcCmdDes->curNum;
3607:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3608:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3609:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3610:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3611:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3612:../uvc.c      **** 						case 0x20:
3613:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3614:../uvc.c      **** 							delaytime = 500;
3615:../uvc.c      **** 							break;
3616:../uvc.c      **** 						case 0x21:
3617:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3618:../uvc.c      **** 							delaytime = 500;
3619:../uvc.c      **** 							break;
3620:../uvc.c      **** 						case 0x22:
3621:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3622:../uvc.c      **** 							delaytime = 300;
3623:../uvc.c      **** 							break;
3624:../uvc.c      **** 						case 0x23:
3625:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3626:../uvc.c      **** 							delaytime = 300;
3627:../uvc.c      **** 							break;
3628:../uvc.c      **** 						default:
3629:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3630:../uvc.c      **** 							break;
3631:../uvc.c      **** 					}
3632:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3633:../uvc.c      **** 					/** timer's ticket modify **/
3634:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3635:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3636:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3637:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3638:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3639:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3640:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3641:../uvc.c      **** #endif
3642:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3643:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3644:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3645:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3646:../uvc.c      **** 						}else{
3647:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3648:../uvc.c      **** 						}
3649:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3650:../uvc.c      **** 					}else{
3651:../uvc.c      **** 						lcCmdDes->curNum ++;
3652:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3652 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3553:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3553 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 70019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3570:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3570 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3587:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3587 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3589:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3589 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3590:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3590 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3599:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3599 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3601:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3601 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3600:../uvc.c      **** 					i++;
 140              		.loc 1 3600 0
 141 00f4 011083E2 		add	r1, r3, #1
3599:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3599 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3600:../uvc.c      **** 					i++;
 144              		.loc 1 3600 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3599:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3599 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3605:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3605 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2900000A 		beq	.L6
 157              	.LVL10:
3607:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3607 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3611:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3611 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3607:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3607 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3611:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3611 0
 166 0128 20C042E2 		sub	ip, r2, #32
3607:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3607 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3608:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3608 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3609:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3609 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3610:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3610 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3611:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3611 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 58010000 		.word	.L9
 185 014c 58010000 		.word	.L9
 186 0150 A4010000 		.word	.L11
 187 0154 A4010000 		.word	.L11
 188              	.LVL15:
 189              	.L9:
3617:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 190              		.loc 1 3617 0
 191 0158 5230A0E3 		mov	r3, #82
 192 015c FEFFFFEB 		bl	SensorSetIrisControl
 193              	.LVL16:
3619:../uvc.c      **** 							break;
 194              		.loc 1 3619 0
 195 0160 7D1FA0E3 		mov	r1, #500
 196              	.LVL17:
 197              	.L13:
3634:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 198              		.loc 1 3634 0
 199 0164 0020A0E3 		mov	r2, #0
 200 0168 A0009FE5 		ldr	r0, .L22+4
 201 016c FEFFFFEB 		bl	_txe_timer_change
3635:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 202              		.loc 1 3635 0
 203 0170 98009FE5 		ldr	r0, .L22+4
 204 0174 FEFFFFEB 		bl	_txe_timer_activate
 205              	.LVL18:
3642:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 206              		.loc 1 3642 0
 207 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 208 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 209 0180 000051E1 		cmp	r1, r0
3651:../uvc.c      **** 						lcCmdDes->curNum ++;
 210              		.loc 1 3651 0
 211 0184 01008012 		addne	r0, r0, #1
 212 0188 0100C415 		strneb	r0, [r4, #1]
 213              		.loc 1 3652 0
 214 018c 3C808415 		strne	r8, [r4, #60]
3642:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 215              		.loc 1 3642 0
 216 0190 1000000A 		beq	.L21
 217              	.LVL19:
 218              	.L17:
3653:../uvc.c      **** 					}
3654:../uvc.c      **** 				}else{
3655:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3656:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3657:../uvc.c      **** 				}
3658:../uvc.c      **** 			}
3659:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 219              		.loc 1 3659 0
 220 0194 1C0095E5 		ldr	r0, [r5, #28]
 221 0198 FEFFFFEB 		bl	_txe_mutex_put
 222              	.LVL20:
3660:../uvc.c      **** /*
3661:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3662:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3663:../uvc.c      **** */
3664:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3665:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3666:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3667:../uvc.c      **** #endif
3668:../uvc.c      **** 
3669:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3670:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3671:../uvc.c      **** #if 0
3672:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3673:../uvc.c      **** 
3674:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3675:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3676:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3677:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3678:../uvc.c      **** 			    i = 0;
3679:../uvc.c      **** 				 switch(cmdCopyIdx)
3680:../uvc.c      **** 				 {
3681:../uvc.c      **** 					 case BrgtCtlID1:
3682:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3683:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3684:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3685:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3686:../uvc.c      **** 							 i++;
3687:../uvc.c      **** 						 }
3688:../uvc.c      **** 						 else{
3689:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3690:../uvc.c      **** 						 }
3691:../uvc.c      **** 
3692:../uvc.c      **** 						 CyU3PBusyWait(500);
3693:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3694:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3695:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3696:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3697:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3698:../uvc.c      **** 						 }
3699:../uvc.c      **** 						 else{
3700:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3701:../uvc.c      **** 						 }
3702:../uvc.c      **** 						 break;
3703:../uvc.c      **** 					 case HueCtlID5:
3704:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3705:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3706:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3708:../uvc.c      **** 						 }
3709:../uvc.c      **** 						 else{
3710:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3711:../uvc.c      **** 						 }
3712:../uvc.c      **** 						 break;
3713:../uvc.c      **** 					 case SaturCtlID6:
3714:../uvc.c      **** 					 case WBTLevCtlID10:
3715:../uvc.c      **** 					 default:
3716:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3717:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3718:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3719:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3720:../uvc.c      **** 						 }
3721:../uvc.c      **** 						 else{
3722:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3723:../uvc.c      **** 						 }
3724:../uvc.c      **** 						 break;
3725:../uvc.c      **** 				 }
3726:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3727:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3728:../uvc.c      **** 			}
3729:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3730:../uvc.c      **** #endif
3731:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3732:../uvc.c      **** 		/* Allow other ready threads to run. */
3733:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3734:../uvc.c      **** 			CyU3PThreadRelinquish ();
 223              		.loc 1 3734 0
 224 019c FEFFFFEB 		bl	_txe_thread_relinquish
3735:../uvc.c      **** 		}
 225              		.loc 1 3735 0
 226 01a0 BFFFFFEA 		b	.L18
 227              	.LVL21:
 228              	.L11:
3625:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
 229              		.loc 1 3625 0
 230 01a4 8230A0E3 		mov	r3, #130
 231 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 232              	.LVL22:
3627:../uvc.c      **** 							break;
 233              		.loc 1 3627 0
 234 01ac 4B1FA0E3 		mov	r1, #300
 235 01b0 EBFFFFEA 		b	.L13
 236              	.LVL23:
 237              	.L7:
3629:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 238              		.loc 1 3629 0
 239 01b4 FEFFFFEB 		bl	SensorSetControl
 240              	.LVL24:
 241 01b8 0A10A0E1 		mov	r1, sl
3630:../uvc.c      **** 							break;
 242              		.loc 1 3630 0
 243 01bc E8FFFFEA 		b	.L13
 244              	.LVL25:
 245              	.L6:
3655:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 246              		.loc 1 3655 0
 247 01c0 FA1FA0E3 		mov	r1, #1000
 248 01c4 44009FE5 		ldr	r0, .L22+4
 249 01c8 FEFFFFEB 		bl	_txe_timer_change
3656:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 250              		.loc 1 3656 0
 251 01cc 3C009FE5 		ldr	r0, .L22+4
 252 01d0 FEFFFFEB 		bl	_txe_timer_activate
 253 01d4 EEFFFFEA 		b	.L17
 254              	.LVL26:
 255              	.L21:
3644:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 256              		.loc 1 3644 0
 257 01d8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3643:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 258              		.loc 1 3643 0
 259 01dc 3C9084E5 		str	r9, [r4, #60]
3644:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 260              		.loc 1 3644 0
 261 01e0 23005CE3 		cmp	ip, #35
3645:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 262              		.loc 1 3645 0
 263 01e4 20C04C82 		subhi	ip, ip, #32
 264 01e8 8CC08C80 		addhi	ip, ip, ip, asl #1
3647:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 265              		.loc 1 3647 0
 266 01ec 8CC08C90 		addls	ip, ip, ip, asl #1
3645:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 267              		.loc 1 3645 0
 268 01f0 8CC18B80 		addhi	ip, fp, ip, asl #3
3647:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 269              		.loc 1 3647 0
 270 01f4 8CC18B90 		addls	ip, fp, ip, asl #3
3645:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 271              		.loc 1 3645 0
 272 01f8 1090CC85 		strhib	r9, [ip, #16]
3647:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3647 0
 274 01fc 9091CC95 		strlsb	r9, [ip, #400]
3649:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 275              		.loc 1 3649 0
 276 0200 344094E5 		ldr	r4, [r4, #52]
 277              	.LVL27:
 278 0204 104085E5 		str	r4, [r5, #16]
 279 0208 E1FFFFEA 		b	.L17
 280              	.L23:
 281              		.align	2
 282              	.L22:
 283 020c 00000000 		.word	I2CCmdCb
 284 0210 00000000 		.word	I2CCmdTimer
 285 0214 00000000 		.word	.LC0
 286 0218 00000000 		.word	cmdQu
 287 021c 14000000 		.word	.LC1
 288 0220 00000000 		.word	statQu
 289 0224 00000000 		.word	.LANCHOR1
 290 0228 00000000 		.word	.LANCHOR0
 291              		.cfi_endproc
 292              	.LFE25:
 294              		.align	2
 295              		.global	I2CCmdCb
 297              	I2CCmdCb:
 298              	.LFB17:
2197:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 299              		.loc 1 2197 0
 300              		.cfi_startproc
 301              		@ args = 0, pretend = 0, frame = 0
 302              		@ frame_needed = 0, uses_anonymous_args = 0
 303              		@ link register save eliminated.
 304              	.LVL28:
2199:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 305              		.loc 1 2199 0
 306 022c 08009FE5 		ldr	r0, .L25
 307              	.LVL29:
 308 0230 2010A0E3 		mov	r1, #32
 309 0234 0020A0E3 		mov	r2, #0
2200:../uvc.c      **** }
 310              		.loc 1 2200 0
2199:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 311              		.loc 1 2199 0
 312 0238 FEFFFFEA 		b	_txe_event_flags_set
 313              	.L26:
 314              		.align	2
 315              	.L25:
 316 023c 00000000 		.word	.LANCHOR0
 317              		.cfi_endproc
 318              	.LFE17:
 320              		.align	2
 322              	CyFxUVCApplnUSBEventCB:
 323              	.LFB8:
1280:../uvc.c      **** {
 324              		.loc 1 1280 0
 325              		.cfi_startproc
 326              		@ args = 0, pretend = 0, frame = 8
 327              		@ frame_needed = 0, uses_anonymous_args = 0
 328              	.LVL30:
1281:../uvc.c      ****     switch (evtype)
 329              		.loc 1 1281 0
 330 0240 020050E3 		cmp	r0, #2
1280:../uvc.c      **** {
 331              		.loc 1 1280 0
 332 0244 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 333              	.LCFI2:
 334              		.cfi_def_cfa_offset 16
 335 0248 0130A0E1 		mov	r3, r1
 336 024c 10D04DE2 		sub	sp, sp, #16
 337              	.LCFI3:
 338              		.cfi_def_cfa_offset 32
1280:../uvc.c      **** {
 339              		.loc 1 1280 0
 340 0250 0040A0E1 		mov	r4, r0
 341              		.cfi_offset 14, -4
 342              		.cfi_offset 6, -8
 343              		.cfi_offset 5, -12
 344              		.cfi_offset 4, -16
1281:../uvc.c      ****     switch (evtype)
 345              		.loc 1 1281 0
 346 0254 3600000A 		beq	.L30
 347 0258 040050E3 		cmp	r0, #4
 348 025c 1F00000A 		beq	.L31
 349 0260 010050E3 		cmp	r0, #1
 350 0264 0100000A 		beq	.L33
 351              	.LVL31:
 352              	.L27:
1317:../uvc.c      **** }
 353              		.loc 1 1317 0
 354 0268 10D08DE2 		add	sp, sp, #16
 355 026c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 356              	.LVL32:
 357              	.L33:
1302:../uvc.c      ****             gpif_initialized = 0;
 358              		.loc 1 1302 0
 359 0270 28519FE5 		ldr	r5, .L34
1300:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 360              		.loc 1 1300 0
 361 0274 0020A0E1 		mov	r2, r0
 362 0278 24119FE5 		ldr	r1, .L34+4
 363              	.LVL33:
 364 027c 0400A0E3 		mov	r0, #4
 365              	.LVL34:
 366 0280 FEFFFFEB 		bl	CyU3PDebugPrint
1301:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 367              		.loc 1 1301 0
 368 0284 0400A0E1 		mov	r0, r4
 369 0288 FEFFFFEB 		bl	CyU3PGpifDisable
1302:../uvc.c      ****             gpif_initialized = 0;
 370              		.loc 1 1302 0
 371 028c 00C0A0E3 		mov	ip, #0
 372              	.LBB14:
 373              	.LBB15:
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 374              		.loc 1 1264 0
 375 0290 0410A0E1 		mov	r1, r4
 376 0294 0500A0E1 		mov	r0, r5
 377 0298 0220A0E3 		mov	r2, #2
 378 029c 0C308DE2 		add	r3, sp, #12
 379              	.LBE15:
 380              	.LBE14:
1302:../uvc.c      ****             gpif_initialized = 0;
 381              		.loc 1 1302 0
 382 02a0 28C085E5 		str	ip, [r5, #40]
1303:../uvc.c      ****             isUsbConnected = CyFalse;
 383              		.loc 1 1303 0
 384 02a4 30C085E5 		str	ip, [r5, #48]
1304:../uvc.c      ****             streamingStarted = CyFalse;
 385              		.loc 1 1304 0
 386 02a8 2CC085E5 		str	ip, [r5, #44]
 387              	.LBB17:
 388              	.LBB16:
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 389              		.loc 1 1264 0
 390 02ac 00C08DE5 		str	ip, [sp, #0]
 391 02b0 FEFFFFEB 		bl	_txe_event_flags_get
 392 02b4 004050E2 		subs	r4, r0, #0
 393 02b8 EAFFFF1A 		bne	.L27
1267:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 394              		.loc 1 1267 0
 395 02bc 0110E0E3 		mvn	r1, #1
 396 02c0 0220A0E3 		mov	r2, #2
 397 02c4 0500A0E1 		mov	r0, r5
 398              	.L32:
 399 02c8 FEFFFFEB 		bl	_txe_event_flags_set
1270:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 400              		.loc 1 1270 0
 401 02cc 0500A0E1 		mov	r0, r5
 402 02d0 0210A0E3 		mov	r1, #2
 403 02d4 0420A0E1 		mov	r2, r4
 404 02d8 FEFFFFEB 		bl	_txe_event_flags_set
 405 02dc E1FFFFEA 		b	.L27
 406              	.LVL35:
 407              	.L31:
 408              	.LBE16:
 409              	.LBE17:
1286:../uvc.c      ****             gpif_initialized = 0;
 410              		.loc 1 1286 0
 411 02e0 B8509FE5 		ldr	r5, .L34
1284:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 412              		.loc 1 1284 0
 413 02e4 BC109FE5 		ldr	r1, .L34+8
 414              	.LVL36:
 415 02e8 0020A0E1 		mov	r2, r0
 416 02ec FEFFFFEB 		bl	CyU3PDebugPrint
 417              	.LVL37:
1285:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 418              		.loc 1 1285 0
 419 02f0 0100A0E3 		mov	r0, #1
 420 02f4 FEFFFFEB 		bl	CyU3PGpifDisable
1286:../uvc.c      ****             gpif_initialized = 0;
 421              		.loc 1 1286 0
 422 02f8 00C0A0E3 		mov	ip, #0
 423              	.LBB18:
 424              	.LBB19:
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 425              		.loc 1 1264 0
 426 02fc 0110A0E3 		mov	r1, #1
 427 0300 0220A0E3 		mov	r2, #2
 428 0304 0500A0E1 		mov	r0, r5
 429 0308 0C308DE2 		add	r3, sp, #12
 430              	.LBE19:
 431              	.LBE18:
1286:../uvc.c      ****             gpif_initialized = 0;
 432              		.loc 1 1286 0
 433 030c 28C085E5 		str	ip, [r5, #40]
1287:../uvc.c      ****             streamingStarted = CyFalse;
 434              		.loc 1 1287 0
 435 0310 2CC085E5 		str	ip, [r5, #44]
 436              	.LBB21:
 437              	.LBB20:
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 438              		.loc 1 1264 0
 439 0314 00C08DE5 		str	ip, [sp, #0]
 440 0318 FEFFFFEB 		bl	_txe_event_flags_get
 441 031c 004050E2 		subs	r4, r0, #0
1267:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 442              		.loc 1 1267 0
 443 0320 0500A001 		moveq	r0, r5
 444 0324 0110E003 		mvneq	r1, #1
 445 0328 0220A003 		moveq	r2, #2
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 446              		.loc 1 1264 0
 447 032c CDFFFF1A 		bne	.L27
 448 0330 E4FFFFEA 		b	.L32
 449              	.LVL38:
 450              	.L30:
 451              	.LBE20:
 452              	.LBE21:
1294:../uvc.c      ****             gpif_initialized = 0;
 453              		.loc 1 1294 0
 454 0334 64509FE5 		ldr	r5, .L34
1292:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 455              		.loc 1 1292 0
 456 0338 0020A0E1 		mov	r2, r0
 457 033c 68109FE5 		ldr	r1, .L34+12
 458              	.LVL39:
 459 0340 0400A0E3 		mov	r0, #4
 460              	.LVL40:
 461 0344 FEFFFFEB 		bl	CyU3PDebugPrint
1293:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 462              		.loc 1 1293 0
 463 0348 0100A0E3 		mov	r0, #1
 464 034c FEFFFFEB 		bl	CyU3PGpifDisable
1294:../uvc.c      ****             gpif_initialized = 0;
 465              		.loc 1 1294 0
 466 0350 0060A0E3 		mov	r6, #0
 467              	.LBB22:
 468              	.LBB23:
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 469              		.loc 1 1264 0
 470 0354 0500A0E1 		mov	r0, r5
 471 0358 0110A0E3 		mov	r1, #1
 472 035c 0420A0E1 		mov	r2, r4
 473 0360 0C308DE2 		add	r3, sp, #12
 474              	.LBE23:
 475              	.LBE22:
1294:../uvc.c      ****             gpif_initialized = 0;
 476              		.loc 1 1294 0
 477 0364 286085E5 		str	r6, [r5, #40]
1295:../uvc.c      ****             streamingStarted = CyFalse;
 478              		.loc 1 1295 0
 479 0368 2C6085E5 		str	r6, [r5, #44]
 480              	.LBB25:
 481              	.LBB24:
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 482              		.loc 1 1264 0
 483 036c 00608DE5 		str	r6, [sp, #0]
 484 0370 FEFFFFEB 		bl	_txe_event_flags_get
 485 0374 006050E2 		subs	r6, r0, #0
 486 0378 BAFFFF1A 		bne	.L27
1267:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 487              		.loc 1 1267 0
 488 037c 0420A0E1 		mov	r2, r4
 489 0380 0500A0E1 		mov	r0, r5
 490 0384 0110E0E3 		mvn	r1, #1
 491 0388 FEFFFFEB 		bl	_txe_event_flags_set
1270:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 492              		.loc 1 1270 0
 493 038c 0500A0E1 		mov	r0, r5
 494 0390 0410A0E1 		mov	r1, r4
 495 0394 0620A0E1 		mov	r2, r6
 496 0398 FEFFFFEB 		bl	_txe_event_flags_set
 497 039c B1FFFFEA 		b	.L27
 498              	.L35:
 499              		.align	2
 500              	.L34:
 501 03a0 00000000 		.word	.LANCHOR0
 502 03a4 7C000000 		.word	.LC4
 503 03a8 38000000 		.word	.LC2
 504 03ac 58000000 		.word	.LC3
 505              	.LBE24:
 506              	.LBE25:
 507              		.cfi_endproc
 508              	.LFE8:
 510              		.align	2
 511              		.global	CyFxUvcApplnDmaCallback
 513              	CyFxUvcApplnDmaCallback:
 514              	.LFB10:
1477:../uvc.c      **** {
 515              		.loc 1 1477 0
 516              		.cfi_startproc
 517              		@ args = 0, pretend = 0, frame = 0
 518              		@ frame_needed = 0, uses_anonymous_args = 0
 519              	.LVL41:
1481:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 520              		.loc 1 1481 0
 521 03b0 080051E3 		cmp	r1, #8
1477:../uvc.c      **** {
 522              		.loc 1 1477 0
 523 03b4 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 524              	.LCFI4:
 525              		.cfi_def_cfa_offset 20
 526 03b8 0250A0E1 		mov	r5, r2
 527              		.cfi_offset 14, -4
 528              		.cfi_offset 7, -8
 529              		.cfi_offset 6, -12
 530              		.cfi_offset 5, -16
 531              		.cfi_offset 4, -20
 532 03bc 0CD04DE2 		sub	sp, sp, #12
 533              	.LCFI5:
 534              		.cfi_def_cfa_offset 32
1481:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 535              		.loc 1 1481 0
 536 03c0 0B00000A 		beq	.L42
1519:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 537              		.loc 1 1519 0
 538 03c4 100051E3 		cmp	r1, #16
 539 03c8 0700001A 		bne	.L36
1521:../uvc.c      ****         consCount++;
 540              		.loc 1 1521 0
 541 03cc 7C319FE5 		ldr	r3, .L45
1522:../uvc.c      ****         streamingStarted = CyTrue;
 542              		.loc 1 1522 0
 543 03d0 0120A0E3 		mov	r2, #1
 544              	.LVL42:
1521:../uvc.c      ****         consCount++;
 545              		.loc 1 1521 0
 546 03d4 B6C4D3E1 		ldrh	ip, [r3, #70]
1522:../uvc.c      ****         streamingStarted = CyTrue;
 547              		.loc 1 1522 0
 548 03d8 2C2083E5 		str	r2, [r3, #44]
1521:../uvc.c      ****         consCount++;
 549              		.loc 1 1521 0
 550 03dc 02008CE0 		add	r0, ip, r2
 551              	.LVL43:
 552 03e0 0018A0E1 		mov	r1, r0, asl #16
 553              	.LVL44:
 554 03e4 2128A0E1 		mov	r2, r1, lsr #16
 555 03e8 B624C3E1 		strh	r2, [r3, #70]	@ movhi
 556              	.L36:
1524:../uvc.c      **** }
 557              		.loc 1 1524 0
 558 03ec 0CD08DE2 		add	sp, sp, #12
 559 03f0 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 560              	.LVL45:
 561              	.L42:
1483:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 562              		.loc 1 1483 0
 563 03f4 B420D2E1 		ldrh	r2, [r2, #4]
 564 03f8 54319FE5 		ldr	r3, .L45+4
 565 03fc 030052E1 		cmp	r2, r3
 566 0400 3500000A 		beq	.L43
1491:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 567              		.loc 1 1491 0
 568 0404 006095E5 		ldr	r6, [r5, #0]
 569              	.LBB30:
 570              	.LBB32:
1225:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 571              		.loc 1 1225 0
 572 0408 48719FE5 		ldr	r7, .L45+8
1224:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 573              		.loc 1 1224 0
 574 040c 0010E0E3 		mvn	r1, #0
 575              	.LVL46:
 576              	.LBE32:
 577              	.LBE30:
1491:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 578              		.loc 1 1491 0
 579 0410 0C4046E2 		sub	r4, r6, #12
 580              	.LVL47:
 581              	.LBB34:
 582              	.LBB31:
1224:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 583              		.loc 1 1224 0
 584 0414 40019FE5 		ldr	r0, .L45+12
 585              	.LVL48:
 586 0418 FEFFFFEB 		bl	_txe_mutex_get
1225:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 587              		.loc 1 1225 0
 588 041c 0400A0E1 		mov	r0, r4
 589 0420 121D87E2 		add	r1, r7, #1152
 590 0424 0C20A0E3 		mov	r2, #12
 591 0428 FEFFFFEB 		bl	CyU3PMemCopy
1226:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 592              		.loc 1 1226 0
 593 042c 28019FE5 		ldr	r0, .L45+12
 594 0430 FEFFFFEB 		bl	_txe_mutex_put
1231:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 595              		.loc 1 1231 0
 596 0434 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 597              	.LBE31:
 598              	.LBE34:
1492:../uvc.c      ****                 pb++;
 599              		.loc 1 1492 0
 600 0438 10419FE5 		ldr	r4, .L45
 601              	.LVL49:
 602              	.LBB35:
 603              	.LBB33:
1231:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 604              		.loc 1 1231 0
 605 043c 02108CE3 		orr	r1, ip, #2
 606 0440 0B1046E5 		strb	r1, [r6, #-11]
 607              	.LBE33:
 608              	.LBE35:
1492:../uvc.c      ****                 pb++;
 609              		.loc 1 1492 0
 610 0444 B603D4E1 		ldrh	r0, [r4, #54]
1496:../uvc.c      ****                 if(stiflag == 0x0F){
 611              		.loc 1 1496 0
 612 0448 3C2094E5 		ldr	r2, [r4, #60]
1493:../uvc.c      ****                 pbc = input->buffer_p.count;
 613              		.loc 1 1493 0
 614 044c B410D5E1 		ldrh	r1, [r5, #4]
1492:../uvc.c      ****                 pb++;
 615              		.loc 1 1492 0
 616 0450 013080E2 		add	r3, r0, #1
1496:../uvc.c      ****                 if(stiflag == 0x0F){
 617              		.loc 1 1496 0
 618 0454 0F0052E3 		cmp	r2, #15
1492:../uvc.c      ****                 pb++;
 619              		.loc 1 1492 0
 620 0458 B633C4E1 		strh	r3, [r4, #54]	@ movhi
1493:../uvc.c      ****                 pbc = input->buffer_p.count;
 621              		.loc 1 1493 0
 622 045c B813C4E1 		strh	r1, [r4, #56]	@ movhi
1496:../uvc.c      ****                 if(stiflag == 0x0F){
 623              		.loc 1 1496 0
 624 0460 2E00000A 		beq	.L44
 625              	.L40:
1503:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 626              		.loc 1 1503 0
 627 0464 01E0A0E3 		mov	lr, #1
 628 0468 40E084E5 		str	lr, [r4, #64]
 629              	.LVL50:
 630              	.L39:
1507:../uvc.c      ****             prodCount++;
 631              		.loc 1 1507 0
 632 046c B4E4D4E1 		ldrh	lr, [r4, #68]
1508:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 633              		.loc 1 1508 0
 634 0470 0C1081E2 		add	r1, r1, #12
1507:../uvc.c      ****             prodCount++;
 635              		.loc 1 1507 0
 636 0474 01308EE2 		add	r3, lr, #1
 637 0478 0308A0E1 		mov	r0, r3, asl #16
 638 047c 20C8A0E1 		mov	ip, r0, lsr #16
1508:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 639              		.loc 1 1508 0
 640 0480 0128A0E1 		mov	r2, r1, asl #16
 641 0484 2218A0E1 		mov	r1, r2, lsr #16
 642 0488 D0009FE5 		ldr	r0, .L45+16
 643 048c 0020A0E3 		mov	r2, #0
1507:../uvc.c      ****             prodCount++;
 644              		.loc 1 1507 0
 645 0490 B4C4C4E1 		strh	ip, [r4, #68]	@ movhi
1508:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 646              		.loc 1 1508 0
 647 0494 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 648              	.LVL51:
1507:../uvc.c      ****             prodCount++;
 649              		.loc 1 1507 0
 650 0498 B0109FE5 		ldr	r1, .L45
1511:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 651              		.loc 1 1511 0
 652 049c 002050E2 		subs	r2, r0, #0
 653 04a0 D1FFFF0A 		beq	.L36
1513:../uvc.c      ****                 prodCount--;
 654              		.loc 1 1513 0
 655 04a4 B4C4D1E1 		ldrh	ip, [r1, #68]
1514:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 656              		.loc 1 1514 0
 657 04a8 B430D5E1 		ldrh	r3, [r5, #4]
1513:../uvc.c      ****                 prodCount--;
 658              		.loc 1 1513 0
 659 04ac 01004CE2 		sub	r0, ip, #1
 660              	.LVL52:
 661 04b0 00E8A0E1 		mov	lr, r0, asl #16
 662 04b4 2EC8A0E1 		mov	ip, lr, lsr #16
 663 04b8 B4C4C1E1 		strh	ip, [r1, #68]	@ movhi
1514:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 664              		.loc 1 1514 0
 665 04bc B4E4D1E1 		ldrh	lr, [r1, #68]
 666 04c0 B604D1E1 		ldrh	r0, [r1, #70]
 667 04c4 98109FE5 		ldr	r1, .L45+20
 668 04c8 0EC060E0 		rsb	ip, r0, lr
 669 04cc 0400A0E3 		mov	r0, #4
 670 04d0 00C08DE5 		str	ip, [sp, #0]
 671 04d4 FEFFFFEB 		bl	CyU3PDebugPrint
 672              	.LVL53:
 673 04d8 C3FFFFEA 		b	.L36
 674              	.LVL54:
 675              	.L43:
1485:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 676              		.loc 1 1485 0
 677 04dc 006095E5 		ldr	r6, [r5, #0]
 678              	.LBB36:
 679              	.LBB37:
1224:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 680              		.loc 1 1224 0
 681 04e0 0010E0E3 		mvn	r1, #0
 682              	.LVL55:
 683              	.LBE37:
 684              	.LBE36:
1486:../uvc.c      ****                 fb++;
 685              		.loc 1 1486 0
 686 04e4 64409FE5 		ldr	r4, .L45
1485:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 687              		.loc 1 1485 0
 688 04e8 0C6046E2 		sub	r6, r6, #12
 689              	.LVL56:
 690              	.LBB39:
 691              	.LBB38:
1224:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 692              		.loc 1 1224 0
 693 04ec 68009FE5 		ldr	r0, .L45+12
 694              	.LVL57:
 695 04f0 FEFFFFEB 		bl	_txe_mutex_get
1225:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 696              		.loc 1 1225 0
 697 04f4 6C109FE5 		ldr	r1, .L45+24
 698 04f8 0600A0E1 		mov	r0, r6
 699 04fc 0C20A0E3 		mov	r2, #12
 700 0500 FEFFFFEB 		bl	CyU3PMemCopy
1226:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 701              		.loc 1 1226 0
 702 0504 50009FE5 		ldr	r0, .L45+12
 703 0508 FEFFFFEB 		bl	_txe_mutex_put
 704              	.LBE38:
 705              	.LBE39:
1486:../uvc.c      ****                 fb++;
 706              		.loc 1 1486 0
 707 050c B4C3D4E1 		ldrh	ip, [r4, #52]
 708 0510 B410D5E1 		ldrh	r1, [r5, #4]
 709 0514 01008CE2 		add	r0, ip, #1
 710 0518 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 711 051c D2FFFFEA 		b	.L39
 712              	.LVL58:
 713              	.L44:
1497:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 714              		.loc 1 1497 0
 715 0520 0010E0E3 		mvn	r1, #0
 716 0524 30009FE5 		ldr	r0, .L45+12
 717 0528 FEFFFFEB 		bl	_txe_mutex_get
1498:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 718              		.loc 1 1498 0
 719 052c 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
1499:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 720              		.loc 1 1499 0
 721 0530 24009FE5 		ldr	r0, .L45+12
1498:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 722              		.loc 1 1498 0
 723 0534 DF2001E2 		and	r2, r1, #223
 724 0538 8124C7E5 		strb	r2, [r7, #1153]
1499:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 725              		.loc 1 1499 0
 726 053c FEFFFFEB 		bl	_txe_mutex_put
1500:../uvc.c      ****                 	stiflag = 0xAA;
 727              		.loc 1 1500 0
 728 0540 AA30A0E3 		mov	r3, #170
 729 0544 B410D5E1 		ldrh	r1, [r5, #4]
 730 0548 3C3084E5 		str	r3, [r4, #60]
 731 054c C4FFFFEA 		b	.L40
 732              	.L46:
 733              		.align	2
 734              	.L45:
 735 0550 00000000 		.word	.LANCHOR0
 736 0554 F03F0000 		.word	16368
 737 0558 00000000 		.word	.LANCHOR1
 738 055c 00000000 		.word	imgHdMux
 739 0560 00000000 		.word	glChHandleUVCStream
 740 0564 9C000000 		.word	.LC5
 741 0568 80040000 		.word	.LANCHOR1+1152
 742              		.cfi_endproc
 743              	.LFE10:
 745              		.align	2
 747              	CyFxUVCApplnUSBSetupCB:
 748              	.LFB9:
1325:../uvc.c      **** {
 749              		.loc 1 1325 0
 750              		.cfi_startproc
 751              		@ args = 0, pretend = 0, frame = 8
 752              		@ frame_needed = 0, uses_anonymous_args = 0
 753              	.LVL59:
1330:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 754              		.loc 1 1330 0
 755 056c C0329FE5 		ldr	r3, .L72
1325:../uvc.c      **** {
 756              		.loc 1 1325 0
 757 0570 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 758              	.LCFI6:
 759              		.cfi_def_cfa_offset 24
1331:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 760              		.loc 1 1331 0
 761 0574 BCC29FE5 		ldr	ip, .L72+4
1330:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 762              		.loc 1 1330 0
 763 0578 FF4000E2 		and	r4, r0, #255
 764              		.cfi_offset 14, -4
 765              		.cfi_offset 8, -8
 766              		.cfi_offset 7, -12
 767              		.cfi_offset 6, -16
 768              		.cfi_offset 5, -20
 769              		.cfi_offset 4, -24
1331:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 770              		.loc 1 1331 0
 771 057c FF8C00E2 		and	r8, r0, #65280
1332:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 772              		.loc 1 1332 0
 773 0580 2078A0E1 		mov	r7, r0, lsr #16
1330:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 774              		.loc 1 1330 0
 775 0584 0040C3E5 		strb	r4, [r3, #0]
1332:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 776              		.loc 1 1332 0
 777 0588 AC229FE5 		ldr	r2, .L72+8
1333:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 778              		.loc 1 1333 0
 779 058c AC029FE5 		ldr	r0, .L72+12
 780              	.LVL60:
1334:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 781              		.loc 1 1334 0
 782 0590 AC329FE5 		ldr	r3, .L72+16
1333:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 783              		.loc 1 1333 0
 784 0594 0158A0E1 		mov	r5, r1, asl #16
1331:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 785              		.loc 1 1331 0
 786 0598 2884A0E1 		mov	r8, r8, lsr #8
1333:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 787              		.loc 1 1333 0
 788 059c 2558A0E1 		mov	r5, r5, lsr #16
1334:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 789              		.loc 1 1334 0
 790 05a0 2118A0E1 		mov	r1, r1, lsr #16
 791              	.LVL61:
1337:../uvc.c      ****     switch (bmReqType)
 792              		.loc 1 1337 0
 793 05a4 020054E3 		cmp	r4, #2
1325:../uvc.c      **** {
 794              		.loc 1 1325 0
 795 05a8 10D04DE2 		sub	sp, sp, #16
 796              	.LCFI7:
 797              		.cfi_def_cfa_offset 40
1331:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 798              		.loc 1 1331 0
 799 05ac 0080CCE5 		strb	r8, [ip, #0]
1332:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 800              		.loc 1 1332 0
 801 05b0 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1333:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 802              		.loc 1 1333 0
 803 05b4 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1334:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 804              		.loc 1 1334 0
 805 05b8 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1337:../uvc.c      ****     switch (bmReqType)
 806              		.loc 1 1337 0
 807 05bc 4F00000A 		beq	.L50
 808 05c0 0600009A 		bls	.L68
 809 05c4 210054E3 		cmp	r4, #33
 810 05c8 3A00000A 		beq	.L51
 811 05cc A10054E3 		cmp	r4, #161
 812 05d0 3800000A 		beq	.L51
 813              	.L65:
1326:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 814              		.loc 1 1326 0
 815 05d4 0000A0E3 		mov	r0, #0
 816              	.LVL62:
 817              	.L48:
1464:../uvc.c      **** }
 818              		.loc 1 1464 0
 819 05d8 10D08DE2 		add	sp, sp, #16
 820 05dc F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 821              	.LVL63:
 822              	.L68:
1337:../uvc.c      ****     switch (bmReqType)
 823              		.loc 1 1337 0
 824 05e0 010054E3 		cmp	r4, #1
 825 05e4 FAFFFF1A 		bne	.L65
1377:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 826              		.loc 1 1377 0
 827 05e8 0B0058E3 		cmp	r8, #11
 828 05ec F8FFFF1A 		bne	.L65
1381:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 829              		.loc 1 1381 0
 830 05f0 010055E3 		cmp	r5, #1
 831 05f4 F6FFFF1A 		bne	.L65
1381:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 832              		.loc 1 1381 0 is_stmt 0 discriminator 1
 833 05f8 000057E3 		cmp	r7, #0
 834 05fc F4FFFF1A 		bne	.L65
1386:../uvc.c      ****                     gpif_initialized = 0;
 835              		.loc 1 1386 0 is_stmt 1
 836 0600 40429FE5 		ldr	r4, .L72+20
1384:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 837              		.loc 1 1384 0
 838 0604 40129FE5 		ldr	r1, .L72+24
 839 0608 0400A0E3 		mov	r0, #4
 840 060c FEFFFFEB 		bl	CyU3PDebugPrint
1385:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 841              		.loc 1 1385 0
 842 0610 0500A0E1 		mov	r0, r5
 843 0614 FEFFFFEB 		bl	CyU3PGpifDisable
1389:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 844              		.loc 1 1389 0
 845 0618 0510A0E1 		mov	r1, r5
 846 061c 8300A0E3 		mov	r0, #131
1386:../uvc.c      ****                     gpif_initialized = 0;
 847              		.loc 1 1386 0
 848 0620 287084E5 		str	r7, [r4, #40]
1387:../uvc.c      ****                     streamingStarted = CyFalse;
 849              		.loc 1 1387 0
 850 0624 2C7084E5 		str	r7, [r4, #44]
1389:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 851              		.loc 1 1389 0
 852 0628 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1390:../uvc.c      ****                     CyU3PBusyWait (100);
 853              		.loc 1 1390 0
 854 062c 6400A0E3 		mov	r0, #100
 855 0630 FEFFFFEB 		bl	CyU3PBusyWait
1393:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 856              		.loc 1 1393 0
 857 0634 14029FE5 		ldr	r0, .L72+28
 858 0638 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1394:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 859              		.loc 1 1394 0
 860 063c 8300A0E3 		mov	r0, #131
 861 0640 FEFFFFEB 		bl	CyU3PUsbFlushEp
1395:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 862              		.loc 1 1395 0
 863 0644 0710A0E1 		mov	r1, r7
 864 0648 8300A0E3 		mov	r0, #131
 865 064c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1396:../uvc.c      ****                     CyU3PBusyWait (100);
 866              		.loc 1 1396 0
 867 0650 6400A0E3 		mov	r0, #100
 868 0654 FEFFFFEB 		bl	CyU3PBusyWait
1399:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 869              		.loc 1 1399 0
 870 0658 0710A0E1 		mov	r1, r7
 871 065c 0520A0E1 		mov	r2, r5
 872 0660 8300A0E3 		mov	r0, #131
 873 0664 FEFFFFEB 		bl	CyU3PUsbStall
 874              	.LVL64:
1402:../uvc.c      ****                     CyU3PUsbAckSetup ();
 875              		.loc 1 1402 0
 876 0668 FEFFFFEB 		bl	CyU3PUsbAckSetup
1404:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 877              		.loc 1 1404 0
 878 066c 485084E5 		str	r5, [r4, #72]
 879              	.LBB44:
 880              	.LBB45:
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 881              		.loc 1 1264 0
 882 0670 0400A0E1 		mov	r0, r4
 883 0674 0510A0E1 		mov	r1, r5
 884 0678 0220A0E3 		mov	r2, #2
 885 067c 0C308DE2 		add	r3, sp, #12
 886 0680 00708DE5 		str	r7, [sp, #0]
 887 0684 FEFFFFEB 		bl	_txe_event_flags_get
 888 0688 006050E2 		subs	r6, r0, #0
 889 068c 2E00001A 		bne	.L63
1267:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 890              		.loc 1 1267 0
 891 0690 0110E0E3 		mvn	r1, #1
 892 0694 0220A0E3 		mov	r2, #2
 893 0698 0400A0E1 		mov	r0, r4
 894 069c FEFFFFEB 		bl	_txe_event_flags_set
1270:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 895              		.loc 1 1270 0
 896 06a0 0400A0E1 		mov	r0, r4
 897 06a4 0210A0E3 		mov	r1, #2
 898 06a8 0620A0E1 		mov	r2, r6
 899 06ac FEFFFFEB 		bl	_txe_event_flags_set
1400:../uvc.c      ****                     uvcHandleReq = CyTrue;
 900              		.loc 1 1400 0
 901 06b0 0500A0E1 		mov	r0, r5
 902 06b4 C7FFFFEA 		b	.L48
 903              	.LVL65:
 904              	.L51:
 905              	.LBE45:
 906              	.LBE44:
1342:../uvc.c      ****             switch (wIndex & 0xFF)
 907              		.loc 1 1342 0
 908 06b8 FF5015E2 		ands	r5, r5, #255
 909 06bc 1A00001A 		bne	.L69
 910              	.LVL66:
1347:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 911              		.loc 1 1347 0
 912 06c0 0520A0E1 		mov	r2, r5
 913 06c4 7C019FE5 		ldr	r0, .L72+20
 914 06c8 0410A0E3 		mov	r1, #4
 915 06cc FEFFFFEB 		bl	_txe_event_flags_set
 916              	.LVL67:
1349:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 917              		.loc 1 1349 0
 918 06d0 002050E2 		subs	r2, r0, #0
1346:../uvc.c      ****                         uvcHandleReq = CyTrue;
 919              		.loc 1 1346 0
 920 06d4 0100A003 		moveq	r0, #1
 921              	.LVL68:
1349:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 922              		.loc 1 1349 0
 923 06d8 BEFFFF0A 		beq	.L48
1351:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 924              		.loc 1 1351 0
 925 06dc 70119FE5 		ldr	r1, .L72+32
 926 06e0 0400A0E3 		mov	r0, #4
 927 06e4 FEFFFFEB 		bl	CyU3PDebugPrint
 928              	.LVL69:
1352:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 929              		.loc 1 1352 0
 930 06e8 0500A0E1 		mov	r0, r5
 931 06ec 0110A0E3 		mov	r1, #1
 932 06f0 0520A0E1 		mov	r2, r5
 933 06f4 FEFFFFEB 		bl	CyU3PUsbStall
1346:../uvc.c      ****                         uvcHandleReq = CyTrue;
 934              		.loc 1 1346 0
 935 06f8 0100A0E3 		mov	r0, #1
 936 06fc B5FFFFEA 		b	.L48
 937              	.LVL70:
 938              	.L50:
1412:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 939              		.loc 1 1412 0
 940 0700 010058E3 		cmp	r8, #1
 941 0704 B2FFFF1A 		bne	.L65
1414:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 942              		.loc 1 1414 0
 943 0708 830055E3 		cmp	r5, #131
 944 070c B0FFFF1A 		bne	.L65
1420:../uvc.c      ****                     if (streamingStarted == CyTrue)
 945              		.loc 1 1420 0
 946 0710 30719FE5 		ldr	r7, .L72+20
 947 0714 2C6097E5 		ldr	r6, [r7, #44]
 948 0718 010056E3 		cmp	r6, #1
 949 071c 1500000A 		beq	.L70
 950              	.LVL71:
1452:../uvc.c      ****                         CyU3PUsbAckSetup ();
 951              		.loc 1 1452 0
 952 0720 FEFFFFEB 		bl	CyU3PUsbAckSetup
1451:../uvc.c      ****                         uvcHandleReq = CyTrue;
 953              		.loc 1 1451 0
 954 0724 0800A0E1 		mov	r0, r8
 955 0728 AAFFFFEA 		b	.L48
 956              	.LVL72:
 957              	.L69:
1342:../uvc.c      ****             switch (wIndex & 0xFF)
 958              		.loc 1 1342 0
 959 072c 010055E3 		cmp	r5, #1
 960 0730 A7FFFF1A 		bne	.L65
 961              	.LVL73:
1360:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 962              		.loc 1 1360 0
 963 0734 0020A0E3 		mov	r2, #0
 964 0738 08019FE5 		ldr	r0, .L72+20
 965 073c 0810A0E3 		mov	r1, #8
 966 0740 FEFFFFEB 		bl	_txe_event_flags_set
 967              	.LVL74:
1362:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 968              		.loc 1 1362 0
 969 0744 002050E2 		subs	r2, r0, #0
 970 0748 0100001A 		bne	.L71
 971              	.LVL75:
 972              	.L63:
 973              	.LBB47:
 974              	.LBB46:
1400:../uvc.c      ****                     uvcHandleReq = CyTrue;
 975              		.loc 1 1400 0
 976 074c 0500A0E1 		mov	r0, r5
 977 0750 A0FFFFEA 		b	.L48
 978              	.LVL76:
 979              	.L71:
 980              	.LBE46:
 981              	.LBE47:
1365:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 982              		.loc 1 1365 0
 983 0754 FC109FE5 		ldr	r1, .L72+36
 984 0758 0400A0E3 		mov	r0, #4
 985              	.LVL77:
 986 075c FEFFFFEB 		bl	CyU3PDebugPrint
 987              	.LVL78:
1366:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 988              		.loc 1 1366 0
 989 0760 0000A0E3 		mov	r0, #0
 990 0764 0510A0E1 		mov	r1, r5
 991 0768 0020A0E1 		mov	r2, r0
 992 076c FEFFFFEB 		bl	CyU3PUsbStall
1359:../uvc.c      ****                         uvcHandleReq = CyTrue;
 993              		.loc 1 1359 0
 994 0770 0500A0E1 		mov	r0, r5
 995 0774 97FFFFEA 		b	.L48
 996              	.LVL79:
 997              	.L70:
1422:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 998              		.loc 1 1422 0
 999 0778 DC109FE5 		ldr	r1, .L72+40
 1000 077c 0400A0E3 		mov	r0, #4
 1001 0780 FEFFFFEB 		bl	CyU3PDebugPrint
1426:../uvc.c      ****                         gpif_initialized = 0;
 1002              		.loc 1 1426 0
 1003 0784 0080A0E3 		mov	r8, #0
1425:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1004              		.loc 1 1425 0
 1005 0788 0600A0E1 		mov	r0, r6
 1006 078c FEFFFFEB 		bl	CyU3PGpifDisable
1430:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1007              		.loc 1 1430 0
 1008 0790 0610A0E1 		mov	r1, r6
 1009 0794 0500A0E1 		mov	r0, r5
1426:../uvc.c      ****                         gpif_initialized = 0;
 1010              		.loc 1 1426 0
 1011 0798 288087E5 		str	r8, [r7, #40]
1427:../uvc.c      ****                         streamingStarted = CyFalse;
 1012              		.loc 1 1427 0
 1013 079c 2C8087E5 		str	r8, [r7, #44]
1430:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1014              		.loc 1 1430 0
 1015 07a0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1431:../uvc.c      ****                         CyU3PBusyWait (100);
 1016              		.loc 1 1431 0
 1017 07a4 6400A0E3 		mov	r0, #100
 1018 07a8 FEFFFFEB 		bl	CyU3PBusyWait
1434:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1019              		.loc 1 1434 0
 1020 07ac 9C009FE5 		ldr	r0, .L72+28
 1021 07b0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1435:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1022              		.loc 1 1435 0
 1023 07b4 0500A0E1 		mov	r0, r5
 1024 07b8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1436:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1025              		.loc 1 1436 0
 1026 07bc 0810A0E1 		mov	r1, r8
 1027 07c0 0500A0E1 		mov	r0, r5
 1028 07c4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1437:../uvc.c      ****                         CyU3PBusyWait (100);
 1029              		.loc 1 1437 0
 1030 07c8 6400A0E3 		mov	r0, #100
 1031 07cc FEFFFFEB 		bl	CyU3PBusyWait
1440:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1032              		.loc 1 1440 0
 1033 07d0 0810A0E1 		mov	r1, r8
 1034 07d4 0620A0E1 		mov	r2, r6
 1035 07d8 0500A0E1 		mov	r0, r5
 1036 07dc FEFFFFEB 		bl	CyU3PUsbStall
 1037              	.LVL80:
1444:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1038              		.loc 1 1444 0
 1039 07e0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1446:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1040              		.loc 1 1446 0
 1041 07e4 486087E5 		str	r6, [r7, #72]
 1042              	.LBB48:
 1043              	.LBB49:
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1044              		.loc 1 1264 0
 1045 07e8 0700A0E1 		mov	r0, r7
 1046 07ec 0610A0E1 		mov	r1, r6
 1047 07f0 0420A0E1 		mov	r2, r4
 1048 07f4 0C308DE2 		add	r3, sp, #12
 1049 07f8 00808DE5 		str	r8, [sp, #0]
 1050 07fc FEFFFFEB 		bl	_txe_event_flags_get
 1051 0800 005050E2 		subs	r5, r0, #0
1442:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1052              		.loc 1 1442 0
 1053 0804 0600A011 		movne	r0, r6
1264:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1054              		.loc 1 1264 0
 1055 0808 72FFFF1A 		bne	.L48
1267:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1056              		.loc 1 1267 0
 1057 080c 0110E0E3 		mvn	r1, #1
 1058 0810 0420A0E1 		mov	r2, r4
 1059 0814 0700A0E1 		mov	r0, r7
 1060 0818 FEFFFFEB 		bl	_txe_event_flags_set
1270:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1061              		.loc 1 1270 0
 1062 081c 0700A0E1 		mov	r0, r7
 1063 0820 0410A0E1 		mov	r1, r4
 1064 0824 0520A0E1 		mov	r2, r5
 1065 0828 FEFFFFEB 		bl	_txe_event_flags_set
1442:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1066              		.loc 1 1442 0
 1067 082c 0600A0E1 		mov	r0, r6
 1068 0830 68FFFFEA 		b	.L48
 1069              	.L73:
 1070              		.align	2
 1071              	.L72:
 1072 0834 00000000 		.word	bmReqType
 1073 0838 00000000 		.word	bRequest
 1074 083c 00000000 		.word	wValue
 1075 0840 00000000 		.word	wIndex
 1076 0844 00000000 		.word	wLength
 1077 0848 00000000 		.word	.LANCHOR0
 1078 084c 50010000 		.word	.LC8
 1079 0850 00000000 		.word	glChHandleUVCStream
 1080 0854 E4000000 		.word	.LC6
 1081 0858 1C010000 		.word	.LC7
 1082 085c 68010000 		.word	.LC9
 1083              	.LBE49:
 1084              	.LBE48:
 1085              		.cfi_endproc
 1086              	.LFE9:
 1088              		.align	2
 1089              		.global	CyFxGpifCB
 1091              	CyFxGpifCB:
 1092              	.LFB12:
1644:../uvc.c      **** {
 1093              		.loc 1 1644 0
 1094              		.cfi_startproc
 1095              		@ args = 0, pretend = 0, frame = 0
 1096              		@ frame_needed = 0, uses_anonymous_args = 0
 1097              	.LVL81:
1645:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1098              		.loc 1 1645 0
 1099 0860 010050E3 		cmp	r0, #1
1644:../uvc.c      **** {
 1100              		.loc 1 1644 0
 1101 0864 10402DE9 		stmfd	sp!, {r4, lr}
 1102              	.LCFI8:
 1103              		.cfi_def_cfa_offset 8
1644:../uvc.c      **** {
 1104              		.loc 1 1644 0
 1105 0868 0120A0E1 		mov	r2, r1
1645:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1106              		.loc 1 1645 0
 1107 086c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1108              		.cfi_offset 14, -4
 1109              		.cfi_offset 4, -8
 1110              	.LVL82:
 1111              	.LBB54:
 1112              	.LBB55:
1544:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1113              		.loc 1 1544 0
 1114 0870 CC309FE5 		ldr	r3, .L90
 1115 0874 4C30D3E5 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
 1116 0878 030053E3 		cmp	r3, #3
 1117 087c 2800000A 		beq	.L89
1568:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1118              		.loc 1 1568 0
 1119 0880 020053E3 		cmp	r3, #2
 1120 0884 1080BD18 		ldmnefd	sp!, {r4, pc}
1570:../uvc.c      ****         switch (stateId)
 1121              		.loc 1 1570 0
 1122 0888 081041E2 		sub	r1, r1, #8
 1123              	.LVL83:
 1124 088c 0A0051E3 		cmp	r1, #10
 1125 0890 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1126 0894 1B0000EA 		b	.L82
 1127              	.L84:
 1128 0898 C8080000 		.word	.L78
 1129 089c 08090000 		.word	.L82
 1130 08a0 08090000 		.word	.L82
 1131 08a4 C4080000 		.word	.L74
 1132 08a8 08090000 		.word	.L82
 1133 08ac 08090000 		.word	.L82
 1134 08b0 08090000 		.word	.L82
 1135 08b4 00090000 		.word	.L88
 1136 08b8 08090000 		.word	.L82
 1137 08bc 08090000 		.word	.L82
 1138 08c0 C4080000 		.word	.L74
 1139              	.LVL84:
 1140              	.L74:
 1141 08c4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1142              	.LVL85:
 1143              	.L78:
1554:../uvc.c      ****                 socket = 0;
 1144              		.loc 1 1554 0
 1145 08c8 0010A0E3 		mov	r1, #0
 1146              	.L79:
 1147              	.LVL86:
1627:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1148              		.loc 1 1627 0
 1149 08cc 74009FE5 		ldr	r0, .L90+4
 1150 08d0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1151              	.LVL87:
1628:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1152              		.loc 1 1628 0
 1153 08d4 002050E2 		subs	r2, r0, #0
 1154 08d8 F9FFFF0A 		beq	.L74
1630:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1155              		.loc 1 1630 0
 1156 08dc 0400A0E3 		mov	r0, #4
 1157              	.LVL88:
 1158 08e0 64109FE5 		ldr	r1, .L90+8
 1159 08e4 FEFFFFEB 		bl	CyU3PDebugPrint
 1160              	.LVL89:
 1161              	.L85:
 1162              	.LBB56:
 1163              	.LBB57:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1164              		.loc 1 1251 0
 1165 08e8 60109FE5 		ldr	r1, .L90+12
 1166 08ec 0400A0E3 		mov	r0, #4
 1167 08f0 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 1168              		.loc 1 1252 0
 1169 08f4 FA0FA0E3 		mov	r0, #1000
 1170 08f8 FEFFFFEB 		bl	_tx_thread_sleep
 1171 08fc F9FFFFEA 		b	.L85
 1172              	.LVL90:
 1173              	.L88:
 1174              	.LBE57:
 1175              	.LBE56:
1611:../uvc.c      ****                 socket = 1;
 1176              		.loc 1 1611 0
 1177 0900 0110A0E3 		mov	r1, #1
 1178 0904 F0FFFFEA 		b	.L79
 1179              	.L82:
1616:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1180              		.loc 1 1616 0
 1181 0908 44109FE5 		ldr	r1, .L90+16
 1182 090c 0100A0E3 		mov	r0, #1
 1183 0910 FEFFFFEB 		bl	CyU3PDebugPrint
 1184              	.LVL91:
 1185              	.LBE55:
 1186              	.LBE54:
1649:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1187              		.loc 1 1649 0
 1188 0914 3C109FE5 		ldr	r1, .L90+20
 1189 0918 0400A0E3 		mov	r0, #4
1651:../uvc.c      **** }
 1190              		.loc 1 1651 0
 1191 091c 1040BDE8 		ldmfd	sp!, {r4, lr}
1649:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1192              		.loc 1 1649 0
 1193 0920 FEFFFFEA 		b	CyU3PDebugPrint
 1194              	.LVL92:
 1195              	.L89:
 1196              	.LBB59:
 1197              	.LBB58:
1546:../uvc.c      ****         switch (stateId)
 1198              		.loc 1 1546 0
 1199 0924 0B0041E2 		sub	r0, r1, #11
 1200              	.LVL93:
 1201 0928 030050E3 		cmp	r0, #3
 1202 092c 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1203 0930 F4FFFFEA 		b	.L82
 1204              	.L80:
 1205 0934 C8080000 		.word	.L78
 1206 0938 00090000 		.word	.L88
 1207 093c C4080000 		.word	.L74
 1208 0940 C4080000 		.word	.L74
 1209              	.L91:
 1210              		.align	2
 1211              	.L90:
 1212 0944 00000000 		.word	.LANCHOR0
 1213 0948 00000000 		.word	glChHandleUVCStream
 1214 094c A4010000 		.word	.LC11
 1215 0950 D4010000 		.word	.LC12
 1216 0954 8C010000 		.word	.LC10
 1217 0958 E8010000 		.word	.LC13
 1218              	.LBE58:
 1219              	.LBE59:
 1220              		.cfi_endproc
 1221              	.LFE12:
 1223              		.align	2
 1224              		.global	I2CCmdHandler
 1226              	I2CCmdHandler:
 1227              	.LFB0:
 326:../uvc.c      **** void I2CCmdHandler(){
 1228              		.loc 1 326 0
 1229              		.cfi_startproc
 1230              		@ args = 0, pretend = 0, frame = 8
 1231              		@ frame_needed = 0, uses_anonymous_args = 0
 1232 095c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1233              	.LCFI9:
 1234              		.cfi_def_cfa_offset 36
 329:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1235              		.loc 1 329 0
 1236 0960 08419FE5 		ldr	r4, .L98
 1237              		.cfi_offset 14, -4
 1238              		.cfi_offset 11, -8
 1239              		.cfi_offset 10, -12
 1240              		.cfi_offset 9, -16
 1241              		.cfi_offset 8, -20
 1242              		.cfi_offset 7, -24
 1243              		.cfi_offset 6, -28
 1244              		.cfi_offset 5, -32
 1245              		.cfi_offset 4, -36
 326:../uvc.c      **** void I2CCmdHandler(){
 1246              		.loc 1 326 0
 1247 0964 34D04DE2 		sub	sp, sp, #52
 1248              	.LCFI10:
 1249              		.cfi_def_cfa_offset 88
 329:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1250              		.loc 1 329 0
 1251 0968 5050D4E5 		ldrb	r5, [r4, #80]	@ zero_extendqisi2
 1252              	.LVL94:
 334:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1253              		.loc 1 334 0
 1254 096c 5920D4E5 		ldrb	r2, [r4, #89]	@ zero_extendqisi2
 331:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1255              		.loc 1 331 0
 1256 0970 5860D4E5 		ldrb	r6, [r4, #88]	@ zero_extendqisi2
 1257              	.LVL95:
 334:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1258              		.loc 1 334 0
 1259 0974 5270D4E5 		ldrb	r7, [r4, #82]	@ zero_extendqisi2
 1260 0978 53E0D4E5 		ldrb	lr, [r4, #83]	@ zero_extendqisi2
 1261 097c 5480D4E5 		ldrb	r8, [r4, #84]	@ zero_extendqisi2
 1262 0980 55A0D4E5 		ldrb	sl, [r4, #85]	@ zero_extendqisi2
 1263 0984 5690D4E5 		ldrb	r9, [r4, #86]	@ zero_extendqisi2
 1264 0988 57B0D4E5 		ldrb	fp, [r4, #87]	@ zero_extendqisi2
 1265 098c 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 1266 0990 1C208DE5 		str	r2, [sp, #28]
 1267 0994 0400A0E3 		mov	r0, #4
 1268 0998 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1269 099c D0109FE5 		ldr	r1, .L98+4
 1270 09a0 0520A0E1 		mov	r2, r5
 1271 09a4 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1272 09a8 08808DE5 		str	r8, [sp, #8]
 1273 09ac 0CA08DE5 		str	sl, [sp, #12]
 1274 09b0 10908DE5 		str	r9, [sp, #16]
 1275 09b4 14B08DE5 		str	fp, [sp, #20]
 1276 09b8 18608DE5 		str	r6, [sp, #24]
 1277 09bc 20C08DE5 		str	ip, [sp, #32]
 1278 09c0 FEFFFFEB 		bl	CyU3PDebugPrint
 1279              	.LVL96:
 338:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1280              		.loc 1 338 0
 1281 09c4 000055E3 		cmp	r5, #0
 1282 09c8 0300000A 		beq	.L96
 363:../uvc.c      **** 	}else if(CmdType == 1){
 1283              		.loc 1 363 0
 1284 09cc 010055E3 		cmp	r5, #1
 1285 09d0 1600000A 		beq	.L97
 1286              	.LVL97:
 1287              	.L92:
 378:../uvc.c      **** }
 1288              		.loc 1 378 0
 1289 09d4 34D08DE2 		add	sp, sp, #52
 1290 09d8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1291              	.LVL98:
 1292              	.L96:
 354:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1293              		.loc 1 354 0
 1294 09dc 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 1295 09e0 5200D4E5 		ldrb	r0, [r4, #82]	@ zero_extendqisi2
 1296 09e4 5310D4E5 		ldrb	r1, [r4, #83]	@ zero_extendqisi2
 1297 09e8 5530D4E5 		ldrb	r3, [r4, #85]	@ zero_extendqisi2
 340:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1298              		.loc 1 340 0
 1299 09ec 0FE0A0E3 		mov	lr, #15
 354:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1300              		.loc 1 354 0
 1301 09f0 00C08DE5 		str	ip, [sp, #0]
 1302 09f4 5420D4E5 		ldrb	r2, [r4, #84]	@ zero_extendqisi2
 1303 09f8 2CC08DE2 		add	ip, sp, #44
 1304 09fc 010080E3 		orr	r0, r0, #1
 1305 0a00 011081E3 		orr	r1, r1, #1
 340:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1306              		.loc 1 340 0
 1307 0a04 5BE0C4E5 		strb	lr, [r4, #91]
 354:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1308              		.loc 1 354 0
 1309 0a08 04C08DE5 		str	ip, [sp, #4]
 1310 0a0c FEFFFFEB 		bl	SensorRead2B
 355:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1311              		.loc 1 355 0
 1312 0a10 2C00DDE5 		ldrb	r0, [sp, #44]	@ zero_extendqisi2
 356:../uvc.c      **** 			if(CmdDataLen == 2){
 1313              		.loc 1 356 0
 1314 0a14 020056E3 		cmp	r6, #2
 355:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1315              		.loc 1 355 0
 1316 0a18 5900C4E5 		strb	r0, [r4, #89]
 357:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1317              		.loc 1 357 0
 1318 0a1c 2D00DD05 		ldreqb	r0, [sp, #45]	@ zero_extendqisi2
 359:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1319              		.loc 1 359 0
 1320 0a20 0030E0E3 		mvn	r3, #0
 357:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1321              		.loc 1 357 0
 1322 0a24 5A00C405 		streqb	r0, [r4, #90]
 359:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1323              		.loc 1 359 0
 1324 0a28 5B30C4E5 		strb	r3, [r4, #91]
 1325 0a2c E8FFFFEA 		b	.L92
 1326              	.L97:
 372:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1327              		.loc 1 372 0
 1328 0a30 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 1329 0a34 5200D4E5 		ldrb	r0, [r4, #82]	@ zero_extendqisi2
 1330 0a38 5310D4E5 		ldrb	r1, [r4, #83]	@ zero_extendqisi2
 365:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1331              		.loc 1 365 0
 1332 0a3c 5950D4E5 		ldrb	r5, [r4, #89]	@ zero_extendqisi2
 1333              	.LVL99:
 366:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1334              		.loc 1 366 0
 1335 0a40 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 372:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1336              		.loc 1 372 0
 1337 0a44 00C08DE5 		str	ip, [sp, #0]
 1338 0a48 5420D4E5 		ldrb	r2, [r4, #84]	@ zero_extendqisi2
 1339 0a4c 2CC08DE2 		add	ip, sp, #44
 1340 0a50 5530D4E5 		ldrb	r3, [r4, #85]	@ zero_extendqisi2
 1341 0a54 FE1001E2 		and	r1, r1, #254
 1342 0a58 FE0000E2 		and	r0, r0, #254
 365:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1343              		.loc 1 365 0
 1344 0a5c 2C50CDE5 		strb	r5, [sp, #44]
 366:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1345              		.loc 1 366 0
 1346 0a60 2DE0CDE5 		strb	lr, [sp, #45]
 372:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1347              		.loc 1 372 0
 1348 0a64 04C08DE5 		str	ip, [sp, #4]
 1349 0a68 FEFFFFEB 		bl	SensorWrite2B
 1350 0a6c D8FFFFEA 		b	.L92
 1351              	.L99:
 1352              		.align	2
 1353              	.L98:
 1354 0a70 00000000 		.word	.LANCHOR0
 1355 0a74 FC010000 		.word	.LC14
 1356              		.cfi_endproc
 1357              	.LFE0:
 1359              		.align	2
 1360              		.global	setIrisauto
 1362              	setIrisauto:
 1363              	.LFB1:
 384:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1364              		.loc 1 384 0
 1365              		.cfi_startproc
 1366              		@ args = 0, pretend = 0, frame = 0
 1367              		@ frame_needed = 0, uses_anonymous_args = 0
 1368              	.LVL100:
 1369 0a78 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1370              	.LCFI11:
 1371              		.cfi_def_cfa_offset 16
 1372 0a7c 0160A0E1 		mov	r6, r1
 1373              		.cfi_offset 14, -4
 1374              		.cfi_offset 6, -8
 1375              		.cfi_offset 5, -12
 1376              		.cfi_offset 4, -16
 1377 0a80 08D04DE2 		sub	sp, sp, #8
 1378              	.LCFI12:
 1379              		.cfi_def_cfa_offset 24
 384:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1380              		.loc 1 384 0
 1381 0a84 0040A0E1 		mov	r4, r0
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1382              		.loc 1 388 0
 1383 0a88 0050A0E3 		mov	r5, #0
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1384              		.loc 1 387 0
 1385 0a8c 0010E0E3 		mvn	r1, #0
 1386              	.LVL101:
 1387 0a90 1C0090E5 		ldr	r0, [r0, #28]
 1388              	.LVL102:
 1389 0a94 FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1390              		.loc 1 388 0
 1391 0a98 060065E0 		rsb	r0, r5, r6
 1392 0a9c 00C070E2 		rsbs	ip, r0, #0
 1393 0aa0 00C0ACE0 		adc	ip, ip, r0
 1394 0aa4 2010A0E3 		mov	r1, #32
 1395 0aa8 2720A0E3 		mov	r2, #39
 1396 0aac 3030A0E3 		mov	r3, #48
 1397 0ab0 0400A0E1 		mov	r0, r4
 1398 0ab4 00C08DE5 		str	ip, [sp, #0]
 1399 0ab8 04508DE5 		str	r5, [sp, #4]
 1400 0abc FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1401              		.loc 1 389 0
 1402 0ac0 050056E1 		cmp	r6, r5
 1403 0ac4 0260A003 		moveq	r6, #2
 1404 0ac8 0160A013 		movne	r6, #1
 1405 0acc 0400A0E1 		mov	r0, r4
 1406 0ad0 2110A0E3 		mov	r1, #33
 1407 0ad4 2520A0E3 		mov	r2, #37
 1408 0ad8 3030A0E3 		mov	r3, #48
 1409 0adc 00608DE5 		str	r6, [sp, #0]
 1410 0ae0 04508DE5 		str	r5, [sp, #4]
 1411 0ae4 FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1412              		.loc 1 390 0
 1413 0ae8 1C0094E5 		ldr	r0, [r4, #28]
 391:../uvc.c      **** }
 1414              		.loc 1 391 0
 1415 0aec 08D08DE2 		add	sp, sp, #8
 1416 0af0 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1417              		.loc 1 390 0
 1418 0af4 FEFFFFEA 		b	_txe_mutex_put
 1419              		.cfi_endproc
 1420              	.LFE1:
 1422              		.align	2
 1423              		.global	ControlHandle
 1425              	ControlHandle:
 1426              	.LFB2:
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1427              		.loc 1 393 0
 1428              		.cfi_startproc
 1429              		@ args = 0, pretend = 0, frame = 24
 1430              		@ frame_needed = 0, uses_anonymous_args = 0
 1431              	.LVL103:
 1432 0af8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1433              	.LCFI13:
 1434              		.cfi_def_cfa_offset 36
 400:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1435              		.loc 1 400 0
 1436 0afc 230050E3 		cmp	r0, #35
 399:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1437              		.loc 1 399 0
 1438 0b00 207040E2 		sub	r7, r0, #32
 1439              		.cfi_offset 14, -4
 1440              		.cfi_offset 11, -8
 1441              		.cfi_offset 10, -12
 1442              		.cfi_offset 9, -16
 1443              		.cfi_offset 8, -20
 1444              		.cfi_offset 7, -24
 1445              		.cfi_offset 6, -28
 1446              		.cfi_offset 5, -32
 1447              		.cfi_offset 4, -36
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1448              		.loc 1 393 0
 1449 0b04 2CD04DE2 		sub	sp, sp, #44
 1450              	.LCFI14:
 1451              		.cfi_def_cfa_offset 80
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1452              		.loc 1 393 0
 1453 0b08 0040A0E1 		mov	r4, r0
 399:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1454              		.loc 1 399 0
 1455 0b0c FF7007E2 		and	r7, r7, #255
 1456              	.LVL104:
 400:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1457              		.loc 1 400 0
 1458 0b10 2400009A 		bls	.L104
 401:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1459              		.loc 1 401 0
 1460 0b14 586F9FE5 		ldr	r6, .L213
 1461 0b18 872087E0 		add	r2, r7, r7, asl #1
 1462 0b1c 8221A0E1 		mov	r2, r2, asl #3
 1463 0b20 023086E0 		add	r3, r6, r2
 402:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1464              		.loc 1 402 0
 1465 0b24 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 403:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1466              		.loc 1 403 0
 1467 0b28 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 404:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1468              		.loc 1 404 0
 1469 0b2c 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 415:../uvc.c      ****     reqData = bRequest;
 1470              		.loc 1 415 0
 1471 0b30 403F9FE5 		ldr	r3, .L213+4
 401:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1472              		.loc 1 401 0
 1473 0b34 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1474              	.LVL105:
 415:../uvc.c      ****     reqData = bRequest;
 1475              		.loc 1 415 0
 1476 0b38 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1477              	.LVL106:
 423:../uvc.c      ****     switch (bRequest)
 1478              		.loc 1 423 0
 1479 0b3c 830055E3 		cmp	r5, #131
 1480 0b40 2300000A 		beq	.L110
 1481              	.LVL107:
 1482              	.L208:
 1483 0b44 2C00009A 		bls	.L206
 1484 0b48 850055E3 		cmp	r5, #133
 1485 0b4c 8B00000A 		beq	.L112
 1486 0b50 7900003A 		bcc	.L111
 1487 0b54 860055E3 		cmp	r5, #134
 1488 0b58 C800000A 		beq	.L113
 1489 0b5c 870055E3 		cmp	r5, #135
 1490 0b60 BC00000A 		beq	.L207
 1491              	.L106:
 899:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1492              		.loc 1 899 0
 1493 0b64 0000A0E3 		mov	r0, #0
 1494 0b68 0110A0E3 		mov	r1, #1
 1495 0b6c 0020A0E1 		mov	r2, r0
 1496 0b70 FEFFFFEB 		bl	CyU3PUsbStall
 900:../uvc.c      **** 			  break;
 1497              		.loc 1 900 0
 1498 0b74 FFC0A0E3 		mov	ip, #255
 1499 0b78 0C70A0E1 		mov	r7, ip
 1500              	.LVL108:
 1501 0b7c 0CE0A0E1 		mov	lr, ip
 1502 0b80 0C40A0E1 		mov	r4, ip
 1503              	.LVL109:
 1504              	.L116:
 902:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1505              		.loc 1 902 0
 1506 0b84 F01E9FE5 		ldr	r1, .L213+8
 1507 0b88 0520A0E1 		mov	r2, r5
 1508 0b8c 0430A0E1 		mov	r3, r4
 1509 0b90 0400A0E3 		mov	r0, #4
 1510 0b94 00E08DE5 		str	lr, [sp, #0]
 1511 0b98 80108DE9 		stmib	sp, {r7, ip}	@ phole stm
 1512 0b9c FEFFFFEB 		bl	CyU3PDebugPrint
 903:../uvc.c      **** }
 1513              		.loc 1 903 0
 1514 0ba0 2CD08DE2 		add	sp, sp, #44
 1515 0ba4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1516              	.LVL110:
 1517              	.L104:
 406:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1518              		.loc 1 406 0
 1519 0ba8 C46E9FE5 		ldr	r6, .L213
 415:../uvc.c      ****     reqData = bRequest;
 1520              		.loc 1 415 0
 1521 0bac C43E9FE5 		ldr	r3, .L213+4
 406:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1522              		.loc 1 406 0
 1523 0bb0 805080E0 		add	r5, r0, r0, asl #1
 1524 0bb4 850186E0 		add	r0, r6, r5, asl #3
 1525              	.LVL111:
 415:../uvc.c      ****     reqData = bRequest;
 1526              		.loc 1 415 0
 1527 0bb8 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 406:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1528              		.loc 1 406 0
 1529 0bbc 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1530              	.LVL112:
 423:../uvc.c      ****     switch (bRequest)
 1531              		.loc 1 423 0
 1532 0bc0 830055E3 		cmp	r5, #131
 407:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1533              		.loc 1 407 0
 1534 0bc4 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1535              	.LVL113:
 408:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1536              		.loc 1 408 0
 1537 0bc8 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1538              	.LVL114:
 409:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1539              		.loc 1 409 0
 1540 0bcc 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1541              	.LVL115:
 423:../uvc.c      ****     switch (bRequest)
 1542              		.loc 1 423 0
 1543 0bd0 DBFFFF1A 		bne	.L208
 1544              	.LVL116:
 1545              	.L110:
 546:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1546              		.loc 1 546 0
 1547 0bd4 230054E3 		cmp	r4, #35
 1548 0bd8 C600009A 		bls	.L140
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1549              		.loc 1 547 0
 1550 0bdc 870087E0 		add	r0, r7, r7, asl #1
 1551 0be0 806186E0 		add	r6, r6, r0, asl #3
 1552 0be4 94AE9FE5 		ldr	sl, .L213+12
 1553 0be8 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
 548:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1554              		.loc 1 548 0
 1555 0bec 06E0D6E5 		ldrb	lr, [r6, #6]	@ zero_extendqisi2
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1556              		.loc 1 547 0
 1557 0bf0 5CC0CAE5 		strb	ip, [sl, #92]
 548:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1558              		.loc 1 548 0
 1559 0bf4 5DE0CAE5 		strb	lr, [sl, #93]
 1560 0bf8 0B0000EA 		b	.L148
 1561              	.L206:
 423:../uvc.c      ****     switch (bRequest)
 1562              		.loc 1 423 0
 1563 0bfc 810055E3 		cmp	r5, #129
 1564 0c00 6A00000A 		beq	.L108
 1565 0c04 1000009A 		bls	.L209
 527:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1566              		.loc 1 527 0
 1567 0c08 230054E3 		cmp	r4, #35
 1568 0c0c AD00009A 		bls	.L137
 528:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1569              		.loc 1 528 0
 1570 0c10 87A087E0 		add	sl, r7, r7, asl #1
 1571 0c14 8A6186E0 		add	r6, r6, sl, asl #3
 1572 0c18 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 1573 0c1c 5CAE9FE5 		ldr	sl, .L213+12
 529:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1574              		.loc 1 529 0
 1575 0c20 0470D6E5 		ldrb	r7, [r6, #4]	@ zero_extendqisi2
 1576              	.LVL117:
 528:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1577              		.loc 1 528 0
 1578 0c24 5C40CAE5 		strb	r4, [sl, #92]
 529:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1579              		.loc 1 529 0
 1580 0c28 5D70CAE5 		strb	r7, [sl, #93]
 1581              	.L148:
 605:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1582              		.loc 1 605 0
 1583 0c2c 0800A0E1 		mov	r0, r8
 1584 0c30 4C1E9FE5 		ldr	r1, .L213+16
 1585 0c34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1586              	.LVL118:
 607:../uvc.c      **** 			  break;
 1587              		.loc 1 607 0
 1588 0c38 FFC0A0E3 		mov	ip, #255
 605:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1589              		.loc 1 605 0
 1590 0c3c 5C70DAE5 		ldrb	r7, [sl, #92]	@ zero_extendqisi2
 607:../uvc.c      **** 			  break;
 1591              		.loc 1 607 0
 1592 0c40 0CE0A0E1 		mov	lr, ip
 1593 0c44 0C40A0E1 		mov	r4, ip
 1594 0c48 CDFFFFEA 		b	.L116
 1595              	.LVL119:
 1596              	.L209:
 423:../uvc.c      ****     switch (bRequest)
 1597              		.loc 1 423 0
 1598 0c4c 010055E3 		cmp	r5, #1
 1599 0c50 C3FFFF1A 		bne	.L106
 609:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1600              		.loc 1 609 0
 1601 0c54 241E9FE5 		ldr	r1, .L213+12
 1602 0c58 26208DE2 		add	r2, sp, #38
 1603 0c5c 2000A0E3 		mov	r0, #32
 1604 0c60 5C1081E2 		add	r1, r1, #92
 1605 0c64 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1606              	.LVL120:
 611:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1607              		.loc 1 611 0
 1608 0c68 002050E2 		subs	r2, r0, #0
 1609 0c6c 4E03001A 		bne	.L150
 614:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1610              		.loc 1 614 0
 1611 0c70 08CE9FE5 		ldr	ip, .L213+12
 613:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1612              		.loc 1 613 0
 1613 0c74 040E9FE5 		ldr	r0, .L213+12
 1614              	.LVL121:
 614:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1615              		.loc 1 614 0
 1616 0c78 5DE0DCE5 		ldrb	lr, [ip, #93]	@ zero_extendqisi2
 616:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1617              		.loc 1 616 0
 1618 0c7c FC2D9FE5 		ldr	r2, .L213+12
 1619              	.LVL122:
 613:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1620              		.loc 1 613 0
 1621 0c80 5C30D0E5 		ldrb	r3, [r0, #92]	@ zero_extendqisi2
 614:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1622              		.loc 1 614 0
 1623 0c84 1CE08DE5 		str	lr, [sp, #28]
 616:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1624              		.loc 1 616 0
 1625 0c88 5EE0D2E5 		ldrb	lr, [r2, #94]	@ zero_extendqisi2
 613:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1626              		.loc 1 613 0
 1627 0c8c 14308DE5 		str	r3, [sp, #20]
 1628              	.LVL123:
 616:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1629              		.loc 1 616 0
 1630 0c90 18E08DE5 		str	lr, [sp, #24]
 1631              	.LVL124:
 620:../uvc.c      **** 				  switch(CtrlID)
 1632              		.loc 1 620 0
 1633 0c94 260054E3 		cmp	r4, #38
 1634 0c98 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1635 0c9c B30200EA 		b	.L151
 1636              	.L167:
 1637 0ca0 B0160000 		.word	.L152
 1638 0ca4 EC150000 		.word	.L153
 1639 0ca8 70170000 		.word	.L151
 1640 0cac 70170000 		.word	.L151
 1641 0cb0 88150000 		.word	.L154
 1642 0cb4 48140000 		.word	.L155
 1643 0cb8 CC130000 		.word	.L156
 1644 0cbc 70170000 		.word	.L151
 1645 0cc0 70170000 		.word	.L151
 1646 0cc4 70170000 		.word	.L151
 1647 0cc8 70170000 		.word	.L151
 1648 0ccc 44130000 		.word	.L157
 1649 0cd0 70170000 		.word	.L151
 1650 0cd4 70170000 		.word	.L151
 1651 0cd8 70170000 		.word	.L151
 1652 0cdc 70170000 		.word	.L151
 1653 0ce0 28190000 		.word	.L158
 1654 0ce4 70170000 		.word	.L151
 1655 0ce8 70170000 		.word	.L151
 1656 0cec 70170000 		.word	.L151
 1657 0cf0 70170000 		.word	.L151
 1658 0cf4 70170000 		.word	.L151
 1659 0cf8 70170000 		.word	.L151
 1660 0cfc 70170000 		.word	.L151
 1661 0d00 70170000 		.word	.L151
 1662 0d04 84180000 		.word	.L159
 1663 0d08 E8170000 		.word	.L160
 1664 0d0c 70170000 		.word	.L151
 1665 0d10 D8170000 		.word	.L161
 1666 0d14 70170000 		.word	.L151
 1667 0d18 E8120000 		.word	.L162
 1668 0d1c 64120000 		.word	.L163
 1669 0d20 70170000 		.word	.L151
 1670 0d24 70170000 		.word	.L151
 1671 0d28 70170000 		.word	.L151
 1672 0d2c 70170000 		.word	.L151
 1673 0d30 C8110000 		.word	.L164
 1674 0d34 B0110000 		.word	.L165
 1675 0d38 4C110000 		.word	.L166
 1676              	.LVL125:
 1677              	.L111:
 564:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1678              		.loc 1 564 0
 1679 0d3c 230054E3 		cmp	r4, #35
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1680              		.loc 1 565 0
 1681 0d40 87708780 		addhi	r7, r7, r7, asl #1
 1682              	.LVL126:
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1683              		.loc 1 571 0
 1684 0d44 84408490 		addls	r4, r4, r4, asl #1
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1685              		.loc 1 565 0
 1686 0d48 87618680 		addhi	r6, r6, r7, asl #3
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1687              		.loc 1 571 0
 1688 0d4c 84618690 		addls	r6, r6, r4, asl #3
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1689              		.loc 1 565 0
 1690 0d50 28AD9F85 		ldrhi	sl, .L213+12
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1691              		.loc 1 571 0
 1692 0d54 24AD9F95 		ldrls	sl, .L213+12
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1693              		.loc 1 565 0
 1694 0d58 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 566:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1695              		.loc 1 566 0
 1696 0d5c 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1697              		.loc 1 571 0
 1698 0d60 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 572:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1699              		.loc 1 572 0
 1700 0d64 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 573:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1701              		.loc 1 573 0
 1702 0d68 0030A0E3 		mov	r3, #0
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1703              		.loc 1 571 0
 1704 0d6c 5C10CAE5 		strb	r1, [sl, #92]
 572:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1705              		.loc 1 572 0
 1706 0d70 5D20CAE5 		strb	r2, [sl, #93]
 573:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1707              		.loc 1 573 0
 1708 0d74 5E30CAE5 		strb	r3, [sl, #94]
 574:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1709              		.loc 1 574 0
 1710 0d78 5F30CAE5 		strb	r3, [sl, #95]
 1711 0d7c AAFFFFEA 		b	.L148
 1712              	.LVL127:
 1713              	.L112:
 427:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1714              		.loc 1 427 0
 1715 0d80 F84C9FE5 		ldr	r4, .L213+12
 428:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1716              		.loc 1 428 0
 1717 0d84 00C0A0E3 		mov	ip, #0
 1718 0d88 5DC0C4E5 		strb	ip, [r4, #93]
 429:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1719              		.loc 1 429 0
 1720 0d8c 5C1084E2 		add	r1, r4, #92
 427:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1721              		.loc 1 427 0
 1722 0d90 5C80C4E5 		strb	r8, [r4, #92]
 429:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1723              		.loc 1 429 0
 1724 0d94 0200A0E3 		mov	r0, #2
 1725 0d98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1726              	.LVL128:
 431:../uvc.c      **** 			  break;
 1727              		.loc 1 431 0
 1728 0d9c FFC0A0E3 		mov	ip, #255
 429:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1729              		.loc 1 429 0
 1730 0da0 5C70D4E5 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 1731              	.LVL129:
 431:../uvc.c      **** 			  break;
 1732              		.loc 1 431 0
 1733 0da4 0CE0A0E1 		mov	lr, ip
 1734 0da8 0C40A0E1 		mov	r4, ip
 1735 0dac 74FFFFEA 		b	.L116
 1736              	.LVL130:
 1737              	.L108:
 434:../uvc.c      **** 			 switch(CtrlID)
 1738              		.loc 1 434 0
 1739 0db0 011044E2 		sub	r1, r4, #1
 1740 0db4 250051E3 		cmp	r1, #37
 1741 0db8 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1742 0dbc D00000EA 		b	.L117
 1743              	.L125:
 1744 0dc0 D4100000 		.word	.L118
 1745 0dc4 04110000 		.word	.L117
 1746 0dc8 04110000 		.word	.L117
 1747 0dcc 04110000 		.word	.L117
 1748 0dd0 B4100000 		.word	.L119
 1749 0dd4 04110000 		.word	.L117
 1750 0dd8 04110000 		.word	.L117
 1751 0ddc 04110000 		.word	.L117
 1752 0de0 04110000 		.word	.L117
 1753 0de4 04110000 		.word	.L117
 1754 0de8 28110000 		.word	.L120
 1755 0dec 04110000 		.word	.L117
 1756 0df0 04110000 		.word	.L117
 1757 0df4 04110000 		.word	.L117
 1758 0df8 04110000 		.word	.L117
 1759 0dfc 04110000 		.word	.L117
 1760 0e00 04110000 		.word	.L117
 1761 0e04 04110000 		.word	.L117
 1762 0e08 04110000 		.word	.L117
 1763 0e0c 04110000 		.word	.L117
 1764 0e10 04110000 		.word	.L117
 1765 0e14 04110000 		.word	.L117
 1766 0e18 04110000 		.word	.L117
 1767 0e1c 04110000 		.word	.L117
 1768 0e20 78100000 		.word	.L121
 1769 0e24 04110000 		.word	.L117
 1770 0e28 04110000 		.word	.L117
 1771 0e2c 4C100000 		.word	.L122
 1772 0e30 04110000 		.word	.L117
 1773 0e34 04110000 		.word	.L117
 1774 0e38 B00F0000 		.word	.L123
 1775 0e3c 04110000 		.word	.L117
 1776 0e40 04110000 		.word	.L117
 1777 0e44 04110000 		.word	.L117
 1778 0e48 04110000 		.word	.L117
 1779 0e4c 740F0000 		.word	.L124
 1780 0e50 740F0000 		.word	.L124
 1781 0e54 740F0000 		.word	.L124
 1782              	.L207:
 591:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1783              		.loc 1 591 0
 1784 0e58 230054E3 		cmp	r4, #35
 1785 0e5c 3100009A 		bls	.L147
 592:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1786              		.loc 1 592 0
 1787 0e60 877087E0 		add	r7, r7, r7, asl #1
 1788              	.LVL131:
 1789 0e64 876186E0 		add	r6, r6, r7, asl #3
 1790 0e68 10AC9FE5 		ldr	sl, .L213+12
 1791 0e6c 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 593:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1792              		.loc 1 593 0
 1793 0e70 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 592:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1794              		.loc 1 592 0
 1795 0e74 5C20CAE5 		strb	r2, [sl, #92]
 593:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1796              		.loc 1 593 0
 1797 0e78 5D10CAE5 		strb	r1, [sl, #93]
 1798 0e7c 6AFFFFEA 		b	.L148
 1799              	.LVL132:
 1800              	.L113:
 580:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1801              		.loc 1 580 0
 1802 0e80 230054E3 		cmp	r4, #35
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1803              		.loc 1 581 0
 1804 0e84 87708780 		addhi	r7, r7, r7, asl #1
 1805              	.LVL133:
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1806              		.loc 1 584 0
 1807 0e88 84408490 		addls	r4, r4, r4, asl #1
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1808              		.loc 1 581 0
 1809 0e8c 87618680 		addhi	r6, r6, r7, asl #3
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1810              		.loc 1 584 0
 1811 0e90 84618690 		addls	r6, r6, r4, asl #3
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1812              		.loc 1 581 0
 1813 0e94 E48B9F85 		ldrhi	r8, .L213+12
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1814              		.loc 1 584 0
 1815 0e98 E08B9F95 		ldrls	r8, .L213+12
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1816              		.loc 1 581 0
 1817 0e9c 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1818              		.loc 1 584 0
 1819 0ea0 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 586:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1820              		.loc 1 586 0
 1821 0ea4 0100A0E3 		mov	r0, #1
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1822              		.loc 1 584 0
 1823 0ea8 5C30C8E5 		strb	r3, [r8, #92]
 586:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1824              		.loc 1 586 0
 1825 0eac D01B9FE5 		ldr	r1, .L213+16
 1826 0eb0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1827              	.LVL134:
 589:../uvc.c      **** 			  break;
 1828              		.loc 1 589 0
 1829 0eb4 FFC0A0E3 		mov	ip, #255
 586:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1830              		.loc 1 586 0
 1831 0eb8 5C70D8E5 		ldrb	r7, [r8, #92]	@ zero_extendqisi2
 589:../uvc.c      **** 			  break;
 1832              		.loc 1 589 0
 1833 0ebc 0CE0A0E1 		mov	lr, ip
 1834 0ec0 0C40A0E1 		mov	r4, ip
 1835 0ec4 2EFFFFEA 		b	.L116
 1836              	.LVL135:
 1837              	.L137:
 532:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1838              		.loc 1 532 0
 1839 0ec8 0B0054E3 		cmp	r4, #11
 539:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1840              		.loc 1 539 0
 1841 0ecc 84408410 		addne	r4, r4, r4, asl #1
 1842 0ed0 84618610 		addne	r6, r6, r4, asl #3
 1843 0ed4 A4AB9F15 		ldrne	sl, .L213+12
 533:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1844              		.loc 1 533 0
 1845 0ed8 A0AB9F05 		ldreq	sl, .L213+12
 1846 0edc A43B9F05 		ldreq	r3, .L213+20
 539:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1847              		.loc 1 539 0
 1848 0ee0 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 540:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1849              		.loc 1 540 0
 1850 0ee4 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 533:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1851              		.loc 1 533 0
 1852 0ee8 5C308A05 		streq	r3, [sl, #92]
 539:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1853              		.loc 1 539 0
 1854 0eec 5C20CA15 		strneb	r2, [sl, #92]
 540:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1855              		.loc 1 540 0
 1856 0ef0 5D30CA15 		strneb	r3, [sl, #93]
 1857 0ef4 4CFFFFEA 		b	.L148
 1858              	.L140:
 550:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1859              		.loc 1 550 0
 1860 0ef8 0B0054E3 		cmp	r4, #11
 557:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1861              		.loc 1 557 0
 1862 0efc 84408410 		addne	r4, r4, r4, asl #1
 1863 0f00 84618610 		addne	r6, r6, r4, asl #3
 1864 0f04 74AB9F15 		ldrne	sl, .L213+12
 551:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1865              		.loc 1 551 0
 1866 0f08 70AB9F05 		ldreq	sl, .L213+12
 1867 0f0c 783B9F05 		ldreq	r3, .L213+24
 557:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1868              		.loc 1 557 0
 1869 0f10 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 558:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1870              		.loc 1 558 0
 1871 0f14 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 551:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1872              		.loc 1 551 0
 1873 0f18 5C308A05 		streq	r3, [sl, #92]
 557:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1874              		.loc 1 557 0
 1875 0f1c 5C20CA15 		strneb	r2, [sl, #92]
 558:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1876              		.loc 1 558 0
 1877 0f20 5D30CA15 		strneb	r3, [sl, #93]
 1878 0f24 40FFFFEA 		b	.L148
 1879              	.L147:
 596:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1880              		.loc 1 596 0
 1881 0f28 0B0054E3 		cmp	r4, #11
 1882 0f2c 0700000A 		beq	.L210
 602:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1883              		.loc 1 602 0
 1884 0f30 84A084E0 		add	sl, r4, r4, asl #1
 1885 0f34 8A6186E0 		add	r6, r6, sl, asl #3
 1886 0f38 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1887 0f3c 3CAB9FE5 		ldr	sl, .L213+12
 603:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1888              		.loc 1 603 0
 1889 0f40 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 602:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1890              		.loc 1 602 0
 1891 0f44 5C30CAE5 		strb	r3, [sl, #92]
 603:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1892              		.loc 1 603 0
 1893 0f48 5D00CAE5 		strb	r0, [sl, #93]
 1894 0f4c 36FFFFEA 		b	.L148
 1895              	.L210:
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1896              		.loc 1 597 0
 1897 0f50 28AB9FE5 		ldr	sl, .L213+12
 1898 0f54 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 599:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1899              		.loc 1 599 0
 1900 0f58 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 598:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1901              		.loc 1 598 0
 1902 0f5c 0040A0E3 		mov	r4, #0
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1903              		.loc 1 597 0
 1904 0f60 5CC0CAE5 		strb	ip, [sl, #92]
 598:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1905              		.loc 1 598 0
 1906 0f64 5D40CAE5 		strb	r4, [sl, #93]
 599:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1907              		.loc 1 599 0
 1908 0f68 5EE0CAE5 		strb	lr, [sl, #94]
 600:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1909              		.loc 1 600 0
 1910 0f6c 5F40CAE5 		strb	r4, [sl, #95]
 1911 0f70 2DFFFFEA 		b	.L148
 1912              	.L124:
 440:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1913              		.loc 1 440 0
 1914 0f74 877087E0 		add	r7, r7, r7, asl #1
 1915              	.LVL136:
 1916 0f78 876186E0 		add	r6, r6, r7, asl #3
 1917 0f7c FCEA9FE5 		ldr	lr, .L213+12
 1918 0f80 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 441:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1919              		.loc 1 441 0
 1920 0f84 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 440:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1921              		.loc 1 440 0
 1922 0f88 5C40CEE5 		strb	r4, [lr, #92]
 441:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1923              		.loc 1 441 0
 1924 0f8c 5D60CEE5 		strb	r6, [lr, #93]
 1925              	.LVL137:
 1926              	.L128:
 520:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1927              		.loc 1 520 0
 1928 0f90 0800A0E1 		mov	r0, r8
 1929 0f94 E81A9FE5 		ldr	r1, .L213+16
 1930 0f98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 525:../uvc.c      **** 			  break;
 1931              		.loc 1 525 0
 1932 0f9c FFE0A0E3 		mov	lr, #255
 520:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1933              		.loc 1 520 0
 1934 0fa0 0470A0E1 		mov	r7, r4
 1935 0fa4 06C0A0E1 		mov	ip, r6
 525:../uvc.c      **** 			  break;
 1936              		.loc 1 525 0
 1937 0fa8 0E40A0E1 		mov	r4, lr
 1938              	.LVL138:
 1939 0fac F4FEFFEA 		b	.L116
 1940              	.LVL139:
 1941              	.L123:
 461:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1942              		.loc 1 461 0 discriminator 1
 1943 0fb0 000058E3 		cmp	r8, #0
 1944 0fb4 A702000A 		beq	.L201
 459:../uvc.c      **** 					 break;
 1945              		.loc 1 459 0
 1946 0fb8 28E1A0E1 		mov	lr, r8, lsr #2
 1947 0fbc 00005EE3 		cmp	lr, #0
 1948 0fc0 03005813 		cmpne	r8, #3
 1949 0fc4 0020A083 		movhi	r2, #0
 1950 0fc8 0120A093 		movls	r2, #1
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1951              		.loc 1 393 0
 1952 0fcc 0E31A0E1 		mov	r3, lr, asl #2
 459:../uvc.c      **** 					 break;
 1953              		.loc 1 459 0
 1954 0fd0 A402009A 		bls	.L189
 1955 0fd4 A81A9FE5 		ldr	r1, .L213+16
 1956 0fd8 0C0041E2 		sub	r0, r1, #12
 1957              	.LVL140:
 1958              	.L132:
 462:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1959              		.loc 1 462 0 discriminator 2
 1960 0fdc 044090E4 		ldr	r4, [r0], #4
 1961 0fe0 01C082E2 		add	ip, r2, #1
 1962 0fe4 FF200CE2 		and	r2, ip, #255
 1963 0fe8 02005EE1 		cmp	lr, r2
 1964 0fec 044081E4 		str	r4, [r1], #4
 1965 0ff0 F9FFFF8A 		bhi	.L132
 462:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1966              		.loc 1 462 0 is_stmt 0
 1967 0ff4 030058E1 		cmp	r8, r3
 1968 0ff8 800A9F15 		ldrne	r0, .L213+12
 1969 0ffc 9502000A 		beq	.L201
 1970              	.L193:
 1971 1000 03E080E0 		add	lr, r0, r3
 1972 1004 5010DEE5 		ldrb	r1, [lr, #80]	@ zero_extendqisi2
 461:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1973              		.loc 1 461 0 is_stmt 1
 1974 1008 016083E2 		add	r6, r3, #1
 1975 100c FF3006E2 		and	r3, r6, #255
 1976              	.LVL141:
 1977 1010 030058E1 		cmp	r8, r3
 462:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1978              		.loc 1 462 0
 1979 1014 5C10CEE5 		strb	r1, [lr, #92]
 461:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1980              		.loc 1 461 0
 1981 1018 F8FFFF8A 		bhi	.L193
 1982              	.LVL142:
 1983              	.L127:
 471:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1984              		.loc 1 471 0
 1985 101c 5B70D0E5 		ldrb	r7, [r0, #91]	@ zero_extendqisi2
 1986              	.LVL143:
 464:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1987              		.loc 1 464 0
 1988 1020 583A9FE5 		ldr	r3, .L213+12
 471:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1989              		.loc 1 471 0
 1990 1024 FF0057E3 		cmp	r7, #255
 464:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1991              		.loc 1 464 0
 1992 1028 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 1993              	.LVL144:
 465:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1994              		.loc 1 465 0
 1995 102c 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 1996              	.LVL145:
 471:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1997              		.loc 1 471 0
 1998 1030 D6FFFF0A 		beq	.L128
 473:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1999              		.loc 1 473 0
 2000 1034 5920D3E5 		ldrb	r2, [r3, #89]	@ zero_extendqisi2
 2001 1038 501A9FE5 		ldr	r1, .L213+28
 2002 103c 5A30D3E5 		ldrb	r3, [r3, #90]	@ zero_extendqisi2
 2003 1040 0400A0E3 		mov	r0, #4
 2004 1044 FEFFFFEB 		bl	CyU3PDebugPrint
 2005 1048 D0FFFFEA 		b	.L128
 2006              	.LVL146:
 2007              	.L122:
 447:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2008              		.loc 1 447 0
 2009 104c 2D34D6E5 		ldrb	r3, [r6, #1069]	@ zero_extendqisi2
 2010              	.LVL147:
 449:../uvc.c      **** 						if(sendData >= 3){
 2011              		.loc 1 449 0
 2012 1050 020053E3 		cmp	r3, #2
 2013 1054 04308392 		addls	r3, r3, #4
 2014              	.LVL148:
 2015 1058 FF400392 		andls	r4, r3, #255
 2016 105c 7402008A 		bhi	.L211
 2017              	.L136:
 2018              	.LVL149:
 494:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2019              		.loc 1 494 0
 2020 1060 183A9FE5 		ldr	r3, .L213+12
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2021              		.loc 1 495 0
 2022 1064 0010A0E3 		mov	r1, #0
 494:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2023              		.loc 1 494 0
 2024 1068 5C40C3E5 		strb	r4, [r3, #92]
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2025              		.loc 1 495 0
 2026 106c 5D10C3E5 		strb	r1, [r3, #93]
 2027              	.LVL150:
 411:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2028              		.loc 1 411 0
 2029 1070 FF60A0E3 		mov	r6, #255
 497:../uvc.c      **** 					 break;
 2030              		.loc 1 497 0
 2031 1074 C5FFFFEA 		b	.L128
 2032              	.LVL151:
 2033              	.L121:
 477:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2034              		.loc 1 477 0
 2035 1078 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 2036 107c FCC99FE5 		ldr	ip, .L213+12
 479:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2037              		.loc 1 479 0
 2038 1080 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 478:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2039              		.loc 1 478 0
 2040 1084 00E0A0E3 		mov	lr, #0
 477:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2041              		.loc 1 477 0
 2042 1088 5C40CCE5 		strb	r4, [ip, #92]
 478:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2043              		.loc 1 478 0
 2044 108c 5DE0CCE5 		strb	lr, [ip, #93]
 479:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2045              		.loc 1 479 0
 2046 1090 5E60CCE5 		strb	r6, [ip, #94]
 480:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2047              		.loc 1 480 0
 2048 1094 5FE0CCE5 		strb	lr, [ip, #95]
 2049              	.LVL152:
 483:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2050              		.loc 1 483 0
 2051 1098 F4199FE5 		ldr	r1, .L213+32
 2052 109c 0420A0E1 		mov	r2, r4
 2053 10a0 0E30A0E1 		mov	r3, lr
 2054 10a4 0400A0E3 		mov	r0, #4
 2055 10a8 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2056 10ac FEFFFFEB 		bl	CyU3PDebugPrint
 484:../uvc.c      **** 					 break;
 2057              		.loc 1 484 0
 2058 10b0 B6FFFFEA 		b	.L128
 2059              	.LVL153:
 2060              	.L119:
 500:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2061              		.loc 1 500 0
 2062 10b4 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 2063 10b8 C0799FE5 		ldr	r7, .L213+12
 2064              	.LVL154:
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2065              		.loc 1 501 0
 2066 10bc 0060A0E3 		mov	r6, #0
 500:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2067              		.loc 1 500 0
 2068 10c0 804024E2 		eor	r4, r4, #128
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2069              		.loc 1 501 0
 2070 10c4 5D60C7E5 		strb	r6, [r7, #93]
 2071              	.LVL155:
 500:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2072              		.loc 1 500 0
 2073 10c8 5C40C7E5 		strb	r4, [r7, #92]
 411:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2074              		.loc 1 411 0
 2075 10cc FF60A0E3 		mov	r6, #255
 503:../uvc.c      **** 					 break;
 2076              		.loc 1 503 0
 2077 10d0 AEFFFFEA 		b	.L128
 2078              	.LVL156:
 2079              	.L118:
 489:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2080              		.loc 1 489 0
 2081 10d4 A601D6E5 		ldrb	r0, [r6, #422]	@ zero_extendqisi2
 487:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2082              		.loc 1 487 0
 2083 10d8 A521D6E5 		ldrb	r2, [r6, #421]	@ zero_extendqisi2
 2084              	.LVL157:
 489:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2085              		.loc 1 489 0
 2086 10dc 020010E3 		tst	r0, #2
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2087              		.loc 1 492 0
 2088 10e0 2221A001 		moveq	r2, r2, lsr #2
 2089              	.LVL158:
 2090 10e4 822CE001 		mvneq	r2, r2, asl #25
 490:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2091              		.loc 1 490 0
 2092 10e8 0003A011 		movne	r0, r0, asl #6
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2093              		.loc 1 492 0
 2094 10ec A22CE001 		mvneq	r2, r2, lsr #25
 490:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2095              		.loc 1 490 0
 2096 10f0 40400012 		andne	r4, r0, #64
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2097              		.loc 1 492 0
 2098 10f4 00038201 		orreq	r0, r2, r0, asl #6
 490:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2099              		.loc 1 490 0
 2100 10f8 22418411 		orrne	r4, r4, r2, lsr #2
 2101              	.LVL159:
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2102              		.loc 1 492 0
 2103 10fc FF400002 		andeq	r4, r0, #255
 2104              	.LVL160:
 2105 1100 D6FFFFEA 		b	.L136
 2106              	.LVL161:
 2107              	.L117:
 514:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2108              		.loc 1 514 0
 2109 1104 843084E0 		add	r3, r4, r4, asl #1
 2110 1108 831186E0 		add	r1, r6, r3, asl #3
 2111 110c 6C299FE5 		ldr	r2, .L213+12
 2112 1110 8D41D1E5 		ldrb	r4, [r1, #397]	@ zero_extendqisi2
 515:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2113              		.loc 1 515 0
 2114 1114 0000A0E3 		mov	r0, #0
 411:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2115              		.loc 1 411 0
 2116 1118 FF60A0E3 		mov	r6, #255
 514:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2117              		.loc 1 514 0
 2118 111c 5C40C2E5 		strb	r4, [r2, #92]
 515:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2119              		.loc 1 515 0
 2120 1120 5D00C2E5 		strb	r0, [r2, #93]
 2121              	.LVL162:
 517:../uvc.c      **** 					 break;
 2122              		.loc 1 517 0
 2123 1124 99FFFFEA 		b	.L128
 2124              	.LVL163:
 2125              	.L120:
 505:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2126              		.loc 1 505 0
 2127 1128 50C99FE5 		ldr	ip, .L213+12
 2128 112c 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 507:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2129              		.loc 1 507 0
 2130 1130 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 506:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2131              		.loc 1 506 0
 2132 1134 00E0A0E3 		mov	lr, #0
 505:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2133              		.loc 1 505 0
 2134 1138 5C40CCE5 		strb	r4, [ip, #92]
 506:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2135              		.loc 1 506 0
 2136 113c 5DE0CCE5 		strb	lr, [ip, #93]
 507:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2137              		.loc 1 507 0
 2138 1140 5E60CCE5 		strb	r6, [ip, #94]
 508:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2139              		.loc 1 508 0
 2140 1144 5FE0CCE5 		strb	lr, [ip, #95]
 2141              	.LVL164:
 511:../uvc.c      **** 					 break;
 2142              		.loc 1 511 0
 2143 1148 90FFFFEA 		b	.L128
 2144              	.LVL165:
 2145              	.L166:
 764:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2146              		.loc 1 764 0
 2147 114c 44499FE5 		ldr	r4, .L213+36
 2148 1150 0010E0E3 		mvn	r1, #0
 2149 1154 1C0094E5 		ldr	r0, [r4, #28]
 2150 1158 FEFFFFEB 		bl	_txe_mutex_get
 765:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2151              		.loc 1 765 0
 2152 115c 2610A0E3 		mov	r1, #38
 2153              	.L205:
 2154 1160 14C09DE5 		ldr	ip, [sp, #20]
 2155 1164 00E0A0E3 		mov	lr, #0
 2156 1168 0A30A0E1 		mov	r3, sl
 2157 116c 0920A0E1 		mov	r2, r9
 2158 1170 0400A0E1 		mov	r0, r4
 2159 1174 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2160 1178 FEFFFFEB 		bl	cmdSet
 766:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2161              		.loc 1 766 0
 2162 117c 1C0094E5 		ldr	r0, [r4, #28]
 2163 1180 FEFFFFEB 		bl	_txe_mutex_put
 767:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2164              		.loc 1 767 0
 2165 1184 14109DE5 		ldr	r1, [sp, #20]
 2166 1188 873087E0 		add	r3, r7, r7, asl #1
 2167 118c 836186E0 		add	r6, r6, r3, asl #3
 769:../uvc.c      **** 							 break;
 2168              		.loc 1 769 0
 2169 1190 FFC0A0E3 		mov	ip, #255
 768:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2170              		.loc 1 768 0
 2171 1194 0100A0E3 		mov	r0, #1
 767:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2172              		.loc 1 767 0
 2173 1198 0D10C6E5 		strb	r1, [r6, #13]
 768:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2174              		.loc 1 768 0
 2175 119c 1000C6E5 		strb	r0, [r6, #16]
 2176 11a0 0140A0E1 		mov	r4, r1
 2177 11a4 18E09DE5 		ldr	lr, [sp, #24]
 769:../uvc.c      **** 							 break;
 2178              		.loc 1 769 0
 2179 11a8 0C70A0E1 		mov	r7, ip
 2180              	.LVL166:
 2181 11ac 74FEFFEA 		b	.L116
 2182              	.LVL167:
 2183              	.L165:
 756:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2184              		.loc 1 756 0
 2185 11b0 E0489FE5 		ldr	r4, .L213+36
 2186 11b4 0010E0E3 		mvn	r1, #0
 2187 11b8 1C0094E5 		ldr	r0, [r4, #28]
 2188 11bc FEFFFFEB 		bl	_txe_mutex_get
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2189              		.loc 1 757 0
 2190 11c0 2510A0E3 		mov	r1, #37
 2191 11c4 E5FFFFEA 		b	.L205
 2192              	.LVL168:
 2193              	.L164:
 742:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2194              		.loc 1 742 0
 2195 11c8 C8489FE5 		ldr	r4, .L213+36
 2196 11cc 0010E0E3 		mvn	r1, #0
 2197 11d0 1C0094E5 		ldr	r0, [r4, #28]
 2198 11d4 FEFFFFEB 		bl	_txe_mutex_get
 741:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2199              		.loc 1 741 0
 2200 11d8 14209DE5 		ldr	r2, [sp, #20]
 744:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2201              		.loc 1 744 0
 2202 11dc 2410A0E3 		mov	r1, #36
 741:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2203              		.loc 1 741 0
 2204 11e0 7F8002E2 		and	r8, r2, #127
 2205 11e4 18808DE5 		str	r8, [sp, #24]
 2206              	.LVL169:
 744:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2207              		.loc 1 744 0
 2208 11e8 18C09DE5 		ldr	ip, [sp, #24]
 2209 11ec 0920A0E1 		mov	r2, r9
 2210 11f0 0A30A0E1 		mov	r3, sl
 2211 11f4 0400A0E1 		mov	r0, r4
 2212 11f8 00C08DE5 		str	ip, [sp, #0]
 2213 11fc 00C0A0E3 		mov	ip, #0
 2214 1200 04C08DE5 		str	ip, [sp, #4]
 2215 1204 FEFFFFEB 		bl	cmdSet
 2216              	.LVL170:
 746:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2217              		.loc 1 746 0
 2218 1208 1CE09DE5 		ldr	lr, [sp, #28]
 2219 120c 0180A0E3 		mov	r8, #1
 2220 1210 2410A0E3 		mov	r1, #36
 2221 1214 0B20A0E1 		mov	r2, fp
 2222 1218 0A30A0E1 		mov	r3, sl
 2223 121c 0400A0E1 		mov	r0, r4
 2224 1220 00E08DE5 		str	lr, [sp, #0]
 2225 1224 04808DE5 		str	r8, [sp, #4]
 2226 1228 FEFFFFEB 		bl	cmdSet
 747:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2227              		.loc 1 747 0
 2228 122c 1C0094E5 		ldr	r0, [r4, #28]
 2229 1230 FEFFFFEB 		bl	_txe_mutex_put
 2230              	.LVL171:
 750:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2231              		.loc 1 750 0
 2232 1234 87C087E0 		add	ip, r7, r7, asl #1
 2233 1238 18409DE5 		ldr	r4, [sp, #24]
 751:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2234              		.loc 1 751 0
 2235 123c 1C709DE5 		ldr	r7, [sp, #28]
 2236              	.LVL172:
 750:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2237              		.loc 1 750 0
 2238 1240 8C6186E0 		add	r6, r6, ip, asl #3
 753:../uvc.c      **** 							 break;
 2239              		.loc 1 753 0
 2240 1244 FFC0A0E3 		mov	ip, #255
 750:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2241              		.loc 1 750 0
 2242 1248 0D40C6E5 		strb	r4, [r6, #13]
 751:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2243              		.loc 1 751 0
 2244 124c 0E70C6E5 		strb	r7, [r6, #14]
 752:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2245              		.loc 1 752 0
 2246 1250 07E0A0E1 		mov	lr, r7
 2247 1254 1080C6E5 		strb	r8, [r6, #16]
 2248 1258 14409DE5 		ldr	r4, [sp, #20]
 753:../uvc.c      **** 							 break;
 2249              		.loc 1 753 0
 2250 125c 0C70A0E1 		mov	r7, ip
 2251 1260 47FEFFEA 		b	.L116
 2252              	.LVL173:
 2253              	.L163:
 713:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2254              		.loc 1 713 0 discriminator 1
 2255 1264 000058E3 		cmp	r8, #0
 2256 1268 1800000A 		beq	.L169
 711:../uvc.c      **** 							 break;
 2257              		.loc 1 711 0
 2258 126c 28E1A0E1 		mov	lr, r8, lsr #2
 2259 1270 00005EE3 		cmp	lr, #0
 2260 1274 03005813 		cmpne	r8, #3
 2261 1278 0020A083 		movhi	r2, #0
 2262 127c 0120A093 		movls	r2, #1
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2263              		.loc 1 393 0
 2264 1280 0E31A0E1 		mov	r3, lr, asl #2
 711:../uvc.c      **** 							 break;
 2265              		.loc 1 711 0
 2266 1284 F501009A 		bls	.L190
 2267 1288 0C189FE5 		ldr	r1, .L213+40
 2268 128c 0C0081E2 		add	r0, r1, #12
 2269              	.LVL174:
 2270              	.L180:
 714:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2271              		.loc 1 714 0 discriminator 2
 2272 1290 047090E4 		ldr	r7, [r0], #4
 2273 1294 012082E2 		add	r2, r2, #1
 2274 1298 FF2002E2 		and	r2, r2, #255
 2275 129c 02005EE1 		cmp	lr, r2
 2276 12a0 047081E4 		str	r7, [r1], #4
 2277 12a4 F9FFFF8A 		bhi	.L180
 714:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2278              		.loc 1 714 0 is_stmt 0
 2279 12a8 030058E1 		cmp	r8, r3
 2280 12ac 0700000A 		beq	.L169
 2281              	.L194:
 2282 12b0 C8E79FE5 		ldr	lr, .L213+12
 2283 12b4 03008EE0 		add	r0, lr, r3
 2284 12b8 5C10D0E5 		ldrb	r1, [r0, #92]	@ zero_extendqisi2
 713:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2285              		.loc 1 713 0 is_stmt 1
 2286 12bc 013083E2 		add	r3, r3, #1
 2287 12c0 FF3003E2 		and	r3, r3, #255
 2288              	.LVL175:
 2289 12c4 030058E1 		cmp	r8, r3
 714:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2290              		.loc 1 714 0
 2291 12c8 5010C0E5 		strb	r1, [r0, #80]
 713:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2292              		.loc 1 713 0
 2293 12cc F7FFFF8A 		bhi	.L194
 2294              	.LVL176:
 2295              	.L169:
 716:../uvc.c      **** 					 		I2CCmdHandler();
 2296              		.loc 1 716 0
 2297 12d0 FEFFFFEB 		bl	I2CCmdHandler
 717:../uvc.c      **** 							 break;
 2298              		.loc 1 717 0
 2299 12d4 FFC0A0E3 		mov	ip, #255
 716:../uvc.c      **** 					 		I2CCmdHandler();
 2300              		.loc 1 716 0
 2301 12d8 14409DE5 		ldr	r4, [sp, #20]
 2302 12dc 18E09DE5 		ldr	lr, [sp, #24]
 717:../uvc.c      **** 							 break;
 2303              		.loc 1 717 0
 2304 12e0 0C70A0E1 		mov	r7, ip
 2305 12e4 26FEFFEA 		b	.L116
 2306              	.LVL177:
 2307              	.L162:
 707:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2308              		.loc 1 707 0
 2309 12e8 A8779FE5 		ldr	r7, .L213+36
 2310              	.LVL178:
 2311 12ec 0010E0E3 		mvn	r1, #0
 2312 12f0 1C0097E5 		ldr	r0, [r7, #28]
 2313 12f4 FEFFFFEB 		bl	_txe_mutex_get
 708:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2314              		.loc 1 708 0
 2315 12f8 14409DE5 		ldr	r4, [sp, #20]
 2316 12fc 00E0A0E3 		mov	lr, #0
 2317 1300 01C074E2 		rsbs	ip, r4, #1
 2318 1304 00C0A033 		movcc	ip, #0
 2319 1308 1E10A0E3 		mov	r1, #30
 2320 130c 0920A0E1 		mov	r2, r9
 2321 1310 0A30A0E1 		mov	r3, sl
 2322 1314 0700A0E1 		mov	r0, r7
 2323 1318 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2324 131c FEFFFFEB 		bl	cmdSet
 709:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2325              		.loc 1 709 0
 2326 1320 1C0097E5 		ldr	r0, [r7, #28]
 2327 1324 FEFFFFEB 		bl	_txe_mutex_put
 711:../uvc.c      **** 							 break;
 2328              		.loc 1 711 0
 2329 1328 FFC0A0E3 		mov	ip, #255
 710:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2330              		.loc 1 710 0
 2331 132c 0100A0E3 		mov	r0, #1
 2332 1330 6004C6E5 		strb	r0, [r6, #1120]
 2333 1334 14409DE5 		ldr	r4, [sp, #20]
 2334 1338 18E09DE5 		ldr	lr, [sp, #24]
 711:../uvc.c      **** 							 break;
 2335              		.loc 1 711 0
 2336 133c 0C70A0E1 		mov	r7, ip
 2337 1340 0FFEFFEA 		b	.L116
 2338              	.LVL179:
 2339              	.L157:
 830:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2340              		.loc 1 830 0
 2341 1344 4C479FE5 		ldr	r4, .L213+36
 2342 1348 0010E0E3 		mvn	r1, #0
 2343 134c 1C0094E5 		ldr	r0, [r4, #28]
 2344 1350 FEFFFFEB 		bl	_txe_mutex_get
 831:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2345              		.loc 1 831 0
 2346 1354 14C09DE5 		ldr	ip, [sp, #20]
 2347 1358 0B10A0E3 		mov	r1, #11
 2348 135c 0920A0E1 		mov	r2, r9
 2349 1360 0A30A0E1 		mov	r3, sl
 2350 1364 0400A0E1 		mov	r0, r4
 2351 1368 00C08DE5 		str	ip, [sp, #0]
 2352 136c 00C0A0E3 		mov	ip, #0
 2353 1370 04C08DE5 		str	ip, [sp, #4]
 2354 1374 FEFFFFEB 		bl	cmdSet
 2355              	.LVL180:
 833:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2356              		.loc 1 833 0
 2357 1378 18E09DE5 		ldr	lr, [sp, #24]
 2358 137c 0170A0E3 		mov	r7, #1
 2359              	.LVL181:
 2360 1380 0B10A0E3 		mov	r1, #11
 2361 1384 0B20A0E1 		mov	r2, fp
 2362 1388 0A30A0E1 		mov	r3, sl
 2363 138c 0400A0E1 		mov	r0, r4
 2364 1390 00E08DE5 		str	lr, [sp, #0]
 2365 1394 04708DE5 		str	r7, [sp, #4]
 2366 1398 FEFFFFEB 		bl	cmdSet
 834:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2367              		.loc 1 834 0
 2368 139c 1C0094E5 		ldr	r0, [r4, #28]
 2369 13a0 FEFFFFEB 		bl	_txe_mutex_put
 836:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2370              		.loc 1 836 0
 2371 13a4 14109DE5 		ldr	r1, [sp, #20]
 837:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2372              		.loc 1 837 0
 2373 13a8 18209DE5 		ldr	r2, [sp, #24]
 839:../uvc.c      **** 							 break;
 2374              		.loc 1 839 0
 2375 13ac FFC0A0E3 		mov	ip, #255
 838:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2376              		.loc 1 838 0
 2377 13b0 9872C6E5 		strb	r7, [r6, #664]
 836:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2378              		.loc 1 836 0
 2379 13b4 8C14C6E5 		strb	r1, [r6, #1164]
 837:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2380              		.loc 1 837 0
 2381 13b8 8E24C6E5 		strb	r2, [r6, #1166]
 838:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2382              		.loc 1 838 0
 2383 13bc 0140A0E1 		mov	r4, r1
 2384 13c0 02E0A0E1 		mov	lr, r2
 839:../uvc.c      **** 							 break;
 2385              		.loc 1 839 0
 2386 13c4 0C70A0E1 		mov	r7, ip
 2387 13c8 EDFDFFEA 		b	.L116
 2388              	.LVL182:
 2389              	.L156:
 816:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2390              		.loc 1 816 0
 2391 13cc C4469FE5 		ldr	r4, .L213+36
 2392 13d0 0010E0E3 		mvn	r1, #0
 2393 13d4 1C0094E5 		ldr	r0, [r4, #28]
 2394 13d8 FEFFFFEB 		bl	_txe_mutex_get
 817:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2395              		.loc 1 817 0
 2396 13dc 14C09DE5 		ldr	ip, [sp, #20]
 2397 13e0 0610A0E3 		mov	r1, #6
 2398 13e4 0920A0E1 		mov	r2, r9
 2399 13e8 0A30A0E1 		mov	r3, sl
 2400 13ec 0400A0E1 		mov	r0, r4
 2401 13f0 00C08DE5 		str	ip, [sp, #0]
 2402 13f4 00C0A0E3 		mov	ip, #0
 2403 13f8 04C08DE5 		str	ip, [sp, #4]
 2404 13fc FEFFFFEB 		bl	cmdSet
 2405              	.LVL183:
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2406              		.loc 1 819 0
 2407 1400 14E09DE5 		ldr	lr, [sp, #20]
 2408 1404 0170A0E3 		mov	r7, #1
 2409              	.LVL184:
 2410 1408 0610A0E3 		mov	r1, #6
 2411 140c 0B20A0E1 		mov	r2, fp
 2412 1410 0A30A0E1 		mov	r3, sl
 2413 1414 0400A0E1 		mov	r0, r4
 2414 1418 00E08DE5 		str	lr, [sp, #0]
 2415 141c 04708DE5 		str	r7, [sp, #4]
 2416 1420 FEFFFFEB 		bl	cmdSet
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2417              		.loc 1 820 0
 2418 1424 1C0094E5 		ldr	r0, [r4, #28]
 2419 1428 FEFFFFEB 		bl	_txe_mutex_put
 821:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2420              		.loc 1 821 0
 2421 142c 14409DE5 		ldr	r4, [sp, #20]
 823:../uvc.c      **** 							 break;
 2422              		.loc 1 823 0
 2423 1430 FFC0A0E3 		mov	ip, #255
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2424              		.loc 1 822 0
 2425 1434 2072C6E5 		strb	r7, [r6, #544]
 821:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2426              		.loc 1 821 0
 2427 1438 1D42C6E5 		strb	r4, [r6, #541]
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2428              		.loc 1 822 0
 2429 143c 18E09DE5 		ldr	lr, [sp, #24]
 823:../uvc.c      **** 							 break;
 2430              		.loc 1 823 0
 2431 1440 0C70A0E1 		mov	r7, ip
 2432 1444 CEFDFFEA 		b	.L116
 2433              	.LVL185:
 2434              	.L155:
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2435              		.loc 1 796 0
 2436 1448 48469FE5 		ldr	r4, .L213+36
 2437 144c 0010E0E3 		mvn	r1, #0
 2438 1450 1C0094E5 		ldr	r0, [r4, #28]
 2439 1454 FEFFFFEB 		bl	_txe_mutex_get
 797:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2440              		.loc 1 797 0
 2441 1458 14309DE5 		ldr	r3, [sp, #20]
 2442 145c 00C0A0E3 		mov	ip, #0
 2443 1460 800043E2 		sub	r0, r3, #128
 2444 1464 FF7000E2 		and	r7, r0, #255
 2445              	.LVL186:
 2446 1468 0510A0E3 		mov	r1, #5
 2447 146c 0920A0E1 		mov	r2, r9
 2448 1470 0A30A0E1 		mov	r3, sl
 2449 1474 0400A0E1 		mov	r0, r4
 2450 1478 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2451 147c FEFFFFEB 		bl	cmdSet
 2452              	.LVL187:
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2453              		.loc 1 799 0
 2454 1480 14109DE5 		ldr	r1, [sp, #20]
 2455 1484 DC20A0E3 		mov	r2, #220
 2456 1488 767041E2 		sub	r7, r1, #118
 2457 148c FFC007E2 		and	ip, r7, #255
 2458 1490 0510A0E3 		mov	r1, #5
 2459 1494 0170A0E3 		mov	r7, #1
 2460 1498 0A30A0E1 		mov	r3, sl
 2461 149c 0400A0E1 		mov	r0, r4
 2462 14a0 00C08DE5 		str	ip, [sp, #0]
 2463 14a4 04708DE5 		str	r7, [sp, #4]
 2464 14a8 FEFFFFEB 		bl	cmdSet
 2465              	.LVL188:
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2466              		.loc 1 801 0
 2467 14ac 14209DE5 		ldr	r2, [sp, #20]
 2468 14b0 0510A0E3 		mov	r1, #5
 2469 14b4 7E3082E2 		add	r3, r2, #126
 2470 14b8 FFC003E2 		and	ip, r3, #255
 2471 14bc DE20A0E3 		mov	r2, #222
 2472 14c0 0A30A0E1 		mov	r3, sl
 2473 14c4 0400A0E1 		mov	r0, r4
 2474 14c8 00C08DE5 		str	ip, [sp, #0]
 2475 14cc 02C0A0E3 		mov	ip, #2
 2476 14d0 04C08DE5 		str	ip, [sp, #4]
 2477 14d4 FEFFFFEB 		bl	cmdSet
 2478              	.LVL189:
 803:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2479              		.loc 1 803 0
 2480 14d8 14009DE5 		ldr	r0, [sp, #20]
 2481 14dc 03E0A0E3 		mov	lr, #3
 2482 14e0 721080E2 		add	r1, r0, #114
 2483 14e4 FFC001E2 		and	ip, r1, #255
 2484 14e8 E020A0E3 		mov	r2, #224
 2485 14ec 0510A0E3 		mov	r1, #5
 2486 14f0 0A30A0E1 		mov	r3, sl
 2487 14f4 0400A0E1 		mov	r0, r4
 2488 14f8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2489 14fc FEFFFFEB 		bl	cmdSet
 2490              	.LVL190:
 805:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2491              		.loc 1 805 0
 2492 1500 14209DE5 		ldr	r2, [sp, #20]
 2493 1504 0510A0E3 		mov	r1, #5
 2494 1508 6F3042E2 		sub	r3, r2, #111
 2495 150c FFC003E2 		and	ip, r3, #255
 2496 1510 DD20A0E3 		mov	r2, #221
 2497 1514 0A30A0E1 		mov	r3, sl
 2498 1518 0400A0E1 		mov	r0, r4
 2499 151c 00C08DE5 		str	ip, [sp, #0]
 2500 1520 04C0A0E3 		mov	ip, #4
 2501 1524 04C08DE5 		str	ip, [sp, #4]
 2502 1528 FEFFFFEB 		bl	cmdSet
 2503              	.LVL191:
 807:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2504              		.loc 1 807 0
 2505 152c 4C059FE5 		ldr	r0, .L213+12
 2506 1530 05E0A0E3 		mov	lr, #5
 2507 1534 5C10D0E5 		ldrb	r1, [r0, #92]	@ zero_extendqisi2
 2508 1538 0A30A0E1 		mov	r3, sl
 2509 153c 7F2081E2 		add	r2, r1, #127
 2510 1540 FFC002E2 		and	ip, r2, #255
 2511 1544 0E10A0E1 		mov	r1, lr
 2512 1548 0B20A0E1 		mov	r2, fp
 2513 154c 0400A0E1 		mov	r0, r4
 2514 1550 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2515 1554 FEFFFFEB 		bl	cmdSet
 808:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2516              		.loc 1 808 0
 2517 1558 1C0094E5 		ldr	r0, [r4, #28]
 2518 155c FEFFFFEB 		bl	_txe_mutex_put
 810:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2519              		.loc 1 810 0
 2520 1560 18359FE5 		ldr	r3, .L213+12
 812:../uvc.c      **** 							 break;
 2521              		.loc 1 812 0
 2522 1564 FFC0A0E3 		mov	ip, #255
 810:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2523              		.loc 1 810 0
 2524 1568 5C00D3E5 		ldrb	r0, [r3, #92]	@ zero_extendqisi2
 811:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2525              		.loc 1 811 0
 2526 156c 0872C6E5 		strb	r7, [r6, #520]
 810:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2527              		.loc 1 810 0
 2528 1570 801040E2 		sub	r1, r0, #128
 2529 1574 0512C6E5 		strb	r1, [r6, #517]
 811:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2530              		.loc 1 811 0
 2531 1578 14409DE5 		ldr	r4, [sp, #20]
 2532 157c 18E09DE5 		ldr	lr, [sp, #24]
 812:../uvc.c      **** 							 break;
 2533              		.loc 1 812 0
 2534 1580 0C70A0E1 		mov	r7, ip
 2535 1584 7EFDFFEA 		b	.L116
 2536              	.LVL192:
 2537              	.L154:
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2538              		.loc 1 848 0
 2539 1588 08459FE5 		ldr	r4, .L213+36
 842:../uvc.c      **** 							 Data0 = Data0 - 1;
 2540              		.loc 1 842 0
 2541 158c 013043E2 		sub	r3, r3, #1
 2542 1590 FF7003E2 		and	r7, r3, #255
 2543              	.LVL193:
 846:../uvc.c      **** 								 Data0 = 1;
 2544              		.loc 1 846 0
 2545 1594 020057E3 		cmp	r7, #2
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2546              		.loc 1 848 0
 2547 1598 0010E0E3 		mvn	r1, #0
 2548 159c 1C0094E5 		ldr	r0, [r4, #28]
 846:../uvc.c      **** 								 Data0 = 1;
 2549              		.loc 1 846 0
 2550 15a0 0170A083 		movhi	r7, #1
 2551              	.LVL194:
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2552              		.loc 1 848 0
 2553 15a4 FEFFFFEB 		bl	_txe_mutex_get
 849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2554              		.loc 1 849 0
 2555 15a8 00C0A0E3 		mov	ip, #0
 2556 15ac 0410A0E3 		mov	r1, #4
 2557 15b0 0920A0E1 		mov	r2, r9
 2558 15b4 0A30A0E1 		mov	r3, sl
 2559 15b8 0400A0E1 		mov	r0, r4
 2560 15bc 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2561 15c0 FEFFFFEB 		bl	cmdSet
 850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2562              		.loc 1 850 0
 2563 15c4 1C0094E5 		ldr	r0, [r4, #28]
 2564 15c8 FEFFFFEB 		bl	_txe_mutex_put
 854:../uvc.c      **** 							 break;
 2565              		.loc 1 854 0
 2566 15cc FFC0A0E3 		mov	ip, #255
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2567              		.loc 1 853 0
 2568 15d0 0100A0E3 		mov	r0, #1
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2569              		.loc 1 852 0
 2570 15d4 ED71C6E5 		strb	r7, [r6, #493]
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2571              		.loc 1 853 0
 2572 15d8 F001C6E5 		strb	r0, [r6, #496]
 2573 15dc 14409DE5 		ldr	r4, [sp, #20]
 2574 15e0 18E09DE5 		ldr	lr, [sp, #24]
 854:../uvc.c      **** 							 break;
 2575              		.loc 1 854 0
 2576 15e4 0C70A0E1 		mov	r7, ip
 2577 15e8 65FDFFEA 		b	.L116
 2578              	.LVL195:
 2579              	.L153:
 772:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2580              		.loc 1 772 0
 2581 15ec A4749FE5 		ldr	r7, .L213+36
 2582              	.LVL196:
 2583 15f0 0010E0E3 		mvn	r1, #0
 2584 15f4 1C0097E5 		ldr	r0, [r7, #28]
 2585 15f8 FEFFFFEB 		bl	_txe_mutex_get
 774:../uvc.c      **** 							  if(Data0&0x80){
 2586              		.loc 1 774 0
 2587 15fc 14C09DE5 		ldr	ip, [sp, #20]
 775:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2588              		.loc 1 775 0
 2589 1600 A641D6E5 		ldrb	r4, [r6, #422]	@ zero_extendqisi2
 774:../uvc.c      **** 							  if(Data0&0x80){
 2590              		.loc 1 774 0
 2591 1604 80001CE3 		tst	ip, #128
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2592              		.loc 1 777 0
 2593 1608 2C23A001 		moveq	r2, ip, lsr #6
 775:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2594              		.loc 1 775 0
 2595 160c 8C2CA011 		movne	r2, ip, asl #25
 2596 1610 0340C413 		bicne	r4, r4, #3
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2597              		.loc 1 777 0
 2598 1614 0340C403 		biceq	r4, r4, #3
 781:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2599              		.loc 1 781 0
 2600 1618 00C0A0E3 		mov	ip, #0
 2601 161c 04C08DE5 		str	ip, [sp, #4]
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2602              		.loc 1 777 0
 2603 1620 02208203 		orreq	r2, r2, #2
 775:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2604              		.loc 1 775 0
 2605 1624 A24F8411 		orrne	r4, r4, r2, lsr #31
 2606              	.LVL197:
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2607              		.loc 1 777 0
 2608 1628 04408201 		orreq	r4, r2, r4
 2609              	.LVL198:
 779:../uvc.c      **** 							 Data1 |= ~0x03;
 2610              		.loc 1 779 0
 2611 162c 043FE0E1 		mvn	r3, r4, asl #30
 2612 1630 230FE0E1 		mvn	r0, r3, lsr #30
 2613              	.LVL199:
 780:../uvc.c      **** 							 Data1 &= 0xC7;
 2614              		.loc 1 780 0
 2615 1634 C71000E2 		and	r1, r0, #199
 2616 1638 1C108DE5 		str	r1, [sp, #28]
 2617              	.LVL200:
 781:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2618              		.loc 1 781 0
 2619 163c 1C809DE5 		ldr	r8, [sp, #28]
 2620 1640 0110A0E3 		mov	r1, #1
 2621 1644 0B20A0E1 		mov	r2, fp
 2622 1648 0A30A0E1 		mov	r3, sl
 2623 164c 44049FE5 		ldr	r0, .L213+36
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2624              		.loc 1 785 0
 2625 1650 0140A0E1 		mov	r4, r1
 781:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2626              		.loc 1 781 0
 2627 1654 00808DE5 		str	r8, [sp, #0]
 2628 1658 FEFFFFEB 		bl	cmdSet
 2629              	.LVL201:
 784:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2630              		.loc 1 784 0
 2631 165c 14209DE5 		ldr	r2, [sp, #20]
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2632              		.loc 1 785 0
 2633 1660 0410A0E1 		mov	r1, r4
 784:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2634              		.loc 1 784 0
 2635 1664 0281A0E1 		mov	r8, r2, asl #2
 2636 1668 FF8008E2 		and	r8, r8, #255
 2637              	.LVL202:
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2638              		.loc 1 785 0
 2639 166c 0920A0E1 		mov	r2, r9
 2640 1670 0A30A0E1 		mov	r3, sl
 2641 1674 1C049FE5 		ldr	r0, .L213+36
 2642 1678 04408DE5 		str	r4, [sp, #4]
 2643 167c 00808DE5 		str	r8, [sp, #0]
 2644 1680 FEFFFFEB 		bl	cmdSet
 786:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2645              		.loc 1 786 0
 2646 1684 1C0097E5 		ldr	r0, [r7, #28]
 2647 1688 FEFFFFEB 		bl	_txe_mutex_put
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2648              		.loc 1 789 0
 2649 168c 1C709DE5 		ldr	r7, [sp, #28]
 792:../uvc.c      **** 							 break;
 2650              		.loc 1 792 0
 2651 1690 FFC0A0E3 		mov	ip, #255
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2652              		.loc 1 789 0
 2653 1694 A671C6E5 		strb	r7, [r6, #422]
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2654              		.loc 1 790 0
 2655 1698 A841C6E5 		strb	r4, [r6, #424]
 788:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2656              		.loc 1 788 0
 2657 169c A581C6E5 		strb	r8, [r6, #421]
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2658              		.loc 1 790 0
 2659 16a0 14409DE5 		ldr	r4, [sp, #20]
 2660 16a4 18E09DE5 		ldr	lr, [sp, #24]
 792:../uvc.c      **** 							 break;
 2661              		.loc 1 792 0
 2662 16a8 0C70A0E1 		mov	r7, ip
 2663 16ac 34FDFFEA 		b	.L116
 2664              	.LVL203:
 2665              	.L152:
 2666 16b0 03C0A0E1 		mov	ip, r3
 857:../uvc.c      **** 							 if(Data0 == 3)
 2667              		.loc 1 857 0
 2668 16b4 030053E3 		cmp	r3, #3
 856:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2669              		.loc 1 856 0
 2670 16b8 8DC1C6E5 		strb	ip, [r6, #397]
 2671 16bc B0339FE5 		ldr	r3, .L213
 857:../uvc.c      **** 							 if(Data0 == 3)
 2672              		.loc 1 857 0
 2673 16c0 D600000A 		beq	.L212
 860:../uvc.c      **** 								 WDRflag = CyFalse;
 2674              		.loc 1 860 0
 2675 16c4 B4E39FE5 		ldr	lr, .L213+12
 864:../uvc.c      **** 								 if(Data0 < 2){
 2676              		.loc 1 864 0
 2677 16c8 01005CE3 		cmp	ip, #1
 860:../uvc.c      **** 								 WDRflag = CyFalse;
 2678              		.loc 1 860 0
 2679 16cc 0000A0E3 		mov	r0, #0
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2680              		.loc 1 861 0
 2681 16d0 0110A0E3 		mov	r1, #1
 860:../uvc.c      **** 								 WDRflag = CyFalse;
 2682              		.loc 1 860 0
 2683 16d4 7C008EE5 		str	r0, [lr, #124]
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2684              		.loc 1 861 0
 2685 16d8 9011C3E5 		strb	r1, [r3, #400]
 864:../uvc.c      **** 								 if(Data0 < 2){
 2686              		.loc 1 864 0
 2687 16dc 0C60A091 		movls	r6, ip
 2688 16e0 0C70A091 		movls	r7, ip
 2689              	.LVL204:
 2690 16e4 0600009A 		bls	.L188
 2691              	.L187:
 867:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 2692              		.loc 1 867 0
 2693 16e8 0400A0E3 		mov	r0, #4
 2694 16ec AC139FE5 		ldr	r1, .L213+44
 2695 16f0 0120A0E3 		mov	r2, #1
 2696 16f4 14309DE5 		ldr	r3, [sp, #20]
 2697 16f8 FEFFFFEB 		bl	CyU3PDebugPrint
 2698              	.LVL205:
 2699 16fc 0060A0E3 		mov	r6, #0
 868:../uvc.c      **** 									Data0 = 0; //set to default.
 2700              		.loc 1 868 0
 2701 1700 0670A0E1 		mov	r7, r6
 2702              	.LVL206:
 2703              	.L188:
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2704              		.loc 1 873 0
 2705 1704 8C439FE5 		ldr	r4, .L213+36
 2706 1708 0010E0E3 		mvn	r1, #0
 2707 170c 1C0094E5 		ldr	r0, [r4, #28]
 2708 1710 FEFFFFEB 		bl	_txe_mutex_get
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2709              		.loc 1 874 0
 2710 1714 00C0A0E3 		mov	ip, #0
 2711 1718 0C10A0E1 		mov	r1, ip
 2712 171c 0920A0E1 		mov	r2, r9
 2713 1720 0A30A0E1 		mov	r3, sl
 2714 1724 0400A0E1 		mov	r0, r4
 2715 1728 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2716 172c FEFFFFEB 		bl	cmdSet
 875:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2717              		.loc 1 875 0
 2718 1730 1C0094E5 		ldr	r0, [r4, #28]
 2719 1734 FEFFFFEB 		bl	_txe_mutex_put
 876:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2720              		.loc 1 876 0
 2721 1738 40C39FE5 		ldr	ip, .L213+12
 2722 173c 60139FE5 		ldr	r1, .L213+48
 2723 1740 5E40DCE5 		ldrb	r4, [ip, #94]	@ zero_extendqisi2
 2724 1744 5F70DCE5 		ldrb	r7, [ip, #95]	@ zero_extendqisi2
 2725              	.LVL207:
 2726 1748 0400A0E3 		mov	r0, #4
 2727 174c 0620A0E1 		mov	r2, r6
 2728 1750 7C309CE5 		ldr	r3, [ip, #124]
 2729 1754 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2730              	.LVL208:
 2731              	.L204:
 2732 1758 FEFFFFEB 		bl	CyU3PDebugPrint
 878:../uvc.c      **** 					 		 break;
 2733              		.loc 1 878 0
 2734 175c FFC0A0E3 		mov	ip, #255
 876:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2735              		.loc 1 876 0
 2736 1760 14409DE5 		ldr	r4, [sp, #20]
 2737 1764 18E09DE5 		ldr	lr, [sp, #24]
 878:../uvc.c      **** 					 		 break;
 2738              		.loc 1 878 0
 2739 1768 0C70A0E1 		mov	r7, ip
 2740 176c 04FDFFEA 		b	.L116
 2741              	.LVL209:
 2742              	.L151:
 882:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2743              		.loc 1 882 0
 2744 1770 20739FE5 		ldr	r7, .L213+36
 2745              	.LVL210:
 2746 1774 0010E0E3 		mvn	r1, #0
 2747 1778 1C0097E5 		ldr	r0, [r7, #28]
 2748 177c FEFFFFEB 		bl	_txe_mutex_get
 883:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2749              		.loc 1 883 0
 2750 1780 14C09DE5 		ldr	ip, [sp, #20]
 2751 1784 0410A0E1 		mov	r1, r4
 2752 1788 0920A0E1 		mov	r2, r9
 2753 178c 0A30A0E1 		mov	r3, sl
 2754 1790 0700A0E1 		mov	r0, r7
 2755 1794 00C08DE5 		str	ip, [sp, #0]
 2756 1798 00C0A0E3 		mov	ip, #0
 2757 179c 04C08DE5 		str	ip, [sp, #4]
 2758 17a0 FEFFFFEB 		bl	cmdSet
 884:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2759              		.loc 1 884 0
 2760 17a4 1C0097E5 		ldr	r0, [r7, #28]
 2761 17a8 FEFFFFEB 		bl	_txe_mutex_put
 886:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2762              		.loc 1 886 0
 2763 17ac 14209DE5 		ldr	r2, [sp, #20]
 2764 17b0 841084E0 		add	r1, r4, r4, asl #1
 2765 17b4 816186E0 		add	r6, r6, r1, asl #3
 888:../uvc.c      **** 							 break;
 2766              		.loc 1 888 0
 2767 17b8 FFC0A0E3 		mov	ip, #255
 887:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2768              		.loc 1 887 0
 2769 17bc 0130A0E3 		mov	r3, #1
 886:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2770              		.loc 1 886 0
 2771 17c0 8D21C6E5 		strb	r2, [r6, #397]
 887:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2772              		.loc 1 887 0
 2773 17c4 9031C6E5 		strb	r3, [r6, #400]
 2774 17c8 0240A0E1 		mov	r4, r2
 2775 17cc 18E09DE5 		ldr	lr, [sp, #24]
 888:../uvc.c      **** 							 break;
 2776              		.loc 1 888 0
 2777 17d0 0C70A0E1 		mov	r7, ip
 2778 17d4 EAFCFFEA 		b	.L116
 2779              	.LVL211:
 2780              	.L161:
 620:../uvc.c      **** 				  switch(CtrlID)
 2781              		.loc 1 620 0
 2782 17d8 FFC0A0E3 		mov	ip, #255
 2783 17dc 0340A0E1 		mov	r4, r3
 2784 17e0 0C70A0E1 		mov	r7, ip
 2785              	.LVL212:
 2786 17e4 E6FCFFEA 		b	.L116
 2787              	.LVL213:
 2788              	.L160:
 674:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2789              		.loc 1 674 0
 2790 17e8 A8729FE5 		ldr	r7, .L213+36
 2791              	.LVL214:
 672:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2792              		.loc 1 672 0
 2793 17ec FD33C6E5 		strb	r3, [r6, #1021]
 673:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2794              		.loc 1 673 0
 2795 17f0 0130A0E3 		mov	r3, #1
 674:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2796              		.loc 1 674 0
 2797 17f4 1C0097E5 		ldr	r0, [r7, #28]
 2798 17f8 0010E0E3 		mvn	r1, #0
 673:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2799              		.loc 1 673 0
 2800 17fc 0034C6E5 		strb	r3, [r6, #1024]
 674:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2801              		.loc 1 674 0
 2802 1800 FEFFFFEB 		bl	_txe_mutex_get
 675:../uvc.c      **** 							 if(WDRflag)
 2803              		.loc 1 675 0
 2804 1804 74329FE5 		ldr	r3, .L213+12
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2805              		.loc 1 676 0
 2806 1808 1A10A0E3 		mov	r1, #26
 675:../uvc.c      **** 							 if(WDRflag)
 2807              		.loc 1 675 0
 2808 180c 7C4093E5 		ldr	r4, [r3, #124]
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2809              		.loc 1 676 0
 2810 1810 0700A0E1 		mov	r0, r7
 675:../uvc.c      **** 							 if(WDRflag)
 2811              		.loc 1 675 0
 2812 1814 000054E3 		cmp	r4, #0
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2813              		.loc 1 676 0
 2814 1818 14409D15 		ldrne	r4, [sp, #20]
 678:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2815              		.loc 1 678 0
 2816 181c 14E09D05 		ldreq	lr, [sp, #20]
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2817              		.loc 1 676 0
 2818 1820 00408D15 		strne	r4, [sp, #0]
 2819 1824 0B20A011 		movne	r2, fp
 2820 1828 0040A013 		movne	r4, #0
 2821 182c 0A30A011 		movne	r3, sl
 678:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2822              		.loc 1 678 0
 2823 1830 0920A001 		moveq	r2, r9
 2824 1834 0A30A001 		moveq	r3, sl
 2825 1838 04408DE5 		str	r4, [sp, #4]
 2826 183c 00E08D05 		streq	lr, [sp, #0]
 2827 1840 FEFFFFEB 		bl	cmdSet
 679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2828              		.loc 1 679 0
 2829 1844 1C0097E5 		ldr	r0, [r7, #28]
 2830 1848 FEFFFFEB 		bl	_txe_mutex_put
 680:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2831              		.loc 1 680 0
 2832 184c 2C229FE5 		ldr	r2, .L213+12
 2833 1850 14409DE5 		ldr	r4, [sp, #20]
 2834 1854 5EC0D2E5 		ldrb	ip, [r2, #94]	@ zero_extendqisi2
 2835 1858 5FE0D2E5 		ldrb	lr, [r2, #95]	@ zero_extendqisi2
 2836 185c 7C3092E5 		ldr	r3, [r2, #124]
 2837 1860 0400A0E3 		mov	r0, #4
 2838 1864 3C129FE5 		ldr	r1, .L213+52
 2839 1868 0420A0E1 		mov	r2, r4
 2840 186c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2841 1870 FEFFFFEB 		bl	CyU3PDebugPrint
 2842 1874 FFC0A0E3 		mov	ip, #255
 2843 1878 18E09DE5 		ldr	lr, [sp, #24]
 2844 187c 0C70A0E1 		mov	r7, ip
 2845 1880 BFFCFFEA 		b	.L116
 2846              	.LVL215:
 2847              	.L159:
 658:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2848              		.loc 1 658 0
 2849 1884 18209DE5 		ldr	r2, [sp, #24]
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2850              		.loc 1 661 0
 2851 1888 08429FE5 		ldr	r4, .L213+36
 659:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2852              		.loc 1 659 0
 2853 188c 0170A0E3 		mov	r7, #1
 2854              	.LVL216:
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2855              		.loc 1 661 0
 2856 1890 0010E0E3 		mvn	r1, #0
 657:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2857              		.loc 1 657 0
 2858 1894 E533C6E5 		strb	r3, [r6, #997]
 658:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2859              		.loc 1 658 0
 2860 1898 E623C6E5 		strb	r2, [r6, #998]
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2861              		.loc 1 661 0
 2862 189c 1C0094E5 		ldr	r0, [r4, #28]
 659:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2863              		.loc 1 659 0
 2864 18a0 E873C6E5 		strb	r7, [r6, #1000]
 2865              	.LVL217:
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2866              		.loc 1 661 0
 2867 18a4 FEFFFFEB 		bl	_txe_mutex_get
 662:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2868              		.loc 1 662 0
 2869 18a8 14C09DE5 		ldr	ip, [sp, #20]
 2870 18ac 1910A0E3 		mov	r1, #25
 2871 18b0 00C08DE5 		str	ip, [sp, #0]
 2872 18b4 0400A0E1 		mov	r0, r4
 2873 18b8 00C0A0E3 		mov	ip, #0
 2874 18bc 0920A0E1 		mov	r2, r9
 2875 18c0 0A30A0E1 		mov	r3, sl
 2876 18c4 04C08DE5 		str	ip, [sp, #4]
 2877 18c8 FEFFFFEB 		bl	cmdSet
 663:../uvc.c      **** 							 if(getData != 0){
 2878              		.loc 1 663 0
 2879 18cc 14109DE5 		ldr	r1, [sp, #20]
 2880 18d0 000051E3 		cmp	r1, #0
 2881 18d4 0700000A 		beq	.L176
 2882              	.LVL218:
 665:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2883              		.loc 1 665 0
 2884 18d8 18E09DE5 		ldr	lr, [sp, #24]
 2885 18dc 0400A0E1 		mov	r0, r4
 2886 18e0 1910A0E3 		mov	r1, #25
 2887 18e4 0B20A0E1 		mov	r2, fp
 2888 18e8 0A30A0E1 		mov	r3, sl
 2889 18ec 00E08DE5 		str	lr, [sp, #0]
 2890 18f0 04708DE5 		str	r7, [sp, #4]
 2891 18f4 FEFFFFEB 		bl	cmdSet
 2892              	.LVL219:
 2893              	.L176:
 667:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2894              		.loc 1 667 0
 2895 18f8 1C0094E5 		ldr	r0, [r4, #28]
 2896 18fc FEFFFFEB 		bl	_txe_mutex_put
 668:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2897              		.loc 1 668 0
 2898 1900 78119FE5 		ldr	r1, .L213+12
 2899 1904 74019FE5 		ldr	r0, .L213+12
 2900 1908 5E40D1E5 		ldrb	r4, [r1, #94]	@ zero_extendqisi2
 2901 190c 5F70D0E5 		ldrb	r7, [r0, #95]	@ zero_extendqisi2
 2902 1910 5C20D1E5 		ldrb	r2, [r1, #92]	@ zero_extendqisi2
 2903 1914 5D30D1E5 		ldrb	r3, [r1, #93]	@ zero_extendqisi2
 2904 1918 0400A0E3 		mov	r0, #4
 2905 191c 88119FE5 		ldr	r1, .L213+56
 2906 1920 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2907 1924 8BFFFFEA 		b	.L204
 2908              	.LVL220:
 2909              	.L158:
 624:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2910              		.loc 1 624 0
 2911 1928 000053E2 		subs	r0, r3, #0
 623:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2912              		.loc 1 623 0
 2913 192c 0D03C6E5 		strb	r0, [r6, #781]
 2914 1930 3C319FE5 		ldr	r3, .L213
 624:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2915              		.loc 1 624 0
 2916 1934 2400001A 		bne	.L170
 625:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2917              		.loc 1 625 0
 2918 1938 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2919 193c 020052E3 		cmp	r2, #2
 2920 1940 08005213 		cmpne	r2, #8
 2921 1944 0300000A 		beq	.L171
 626:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2922              		.loc 1 626 0
 2923 1948 010052E3 		cmp	r2, #1
 627:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2924              		.loc 1 627 0
 2925 194c 07208202 		addeq	r2, r2, #7
 629:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2926              		.loc 1 629 0
 2927 1950 0220A013 		movne	r2, #2
 2928 1954 B524C3E5 		strb	r2, [r3, #1205]
 2929              	.LVL221:
 2930              	.L171:
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2931              		.loc 1 651 0
 2932 1958 38419FE5 		ldr	r4, .L213+36
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2933              		.loc 1 649 0
 2934 195c 0130A0E3 		mov	r3, #1
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2935              		.loc 1 651 0
 2936 1960 0010E0E3 		mvn	r1, #0
 2937 1964 1C0094E5 		ldr	r0, [r4, #28]
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2938              		.loc 1 649 0
 2939 1968 1033C6E5 		strb	r3, [r6, #784]
 2940              	.LVL222:
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2941              		.loc 1 651 0
 2942 196c FEFFFFEB 		bl	_txe_mutex_get
 652:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2943              		.loc 1 652 0
 2944 1970 14C09DE5 		ldr	ip, [sp, #20]
 2945 1974 00E0A0E3 		mov	lr, #0
 2946 1978 1010A0E3 		mov	r1, #16
 2947 197c 0920A0E1 		mov	r2, r9
 2948 1980 0A30A0E1 		mov	r3, sl
 2949 1984 0400A0E1 		mov	r0, r4
 2950 1988 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2951 198c FEFFFFEB 		bl	cmdSet
 653:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2952              		.loc 1 653 0
 2953 1990 1C0094E5 		ldr	r0, [r4, #28]
 2954 1994 FEFFFFEB 		bl	_txe_mutex_put
 655:../uvc.c      **** 							 break;
 2955              		.loc 1 655 0
 2956 1998 FFC0A0E3 		mov	ip, #255
 653:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2957              		.loc 1 653 0
 2958 199c 14409DE5 		ldr	r4, [sp, #20]
 2959 19a0 18E09DE5 		ldr	lr, [sp, #24]
 655:../uvc.c      **** 							 break;
 2960              		.loc 1 655 0
 2961 19a4 0C70A0E1 		mov	r7, ip
 2962 19a8 75FCFFEA 		b	.L116
 2963              	.LVL223:
 2964              	.L150:
 891:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2965              		.loc 1 891 0
 2966 19ac 0400A0E3 		mov	r0, #4
 2967              	.LVL224:
 2968 19b0 F8109FE5 		ldr	r1, .L213+60
 2969 19b4 FEFFFFEB 		bl	CyU3PDebugPrint
 2970              	.LVL225:
 2971 19b8 FFC0A0E3 		mov	ip, #255
 2972 19bc 0C70A0E1 		mov	r7, ip
 2973              	.LVL226:
 2974 19c0 0CE0A0E1 		mov	lr, ip
 2975 19c4 0C40A0E1 		mov	r4, ip
 2976 19c8 6DFCFFEA 		b	.L116
 2977              	.LVL227:
 2978              	.L170:
 634:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2979              		.loc 1 634 0
 2980 19cc B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 633:../uvc.c      **** 								 Data1 = Data0 - 1;
 2981              		.loc 1 633 0
 2982 19d0 017040E2 		sub	r7, r0, #1
 2983              	.LVL228:
 634:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2984              		.loc 1 634 0
 2985 19d4 040052E3 		cmp	r2, #4
 2986 19d8 01005213 		cmpne	r2, #1
 633:../uvc.c      **** 								 Data1 = Data0 - 1;
 2987              		.loc 1 633 0
 2988 19dc FF1007E2 		and	r1, r7, #255
 2989              	.LVL229:
 634:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2990              		.loc 1 634 0
 2991 19e0 0300000A 		beq	.L173
 635:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2992              		.loc 1 635 0
 2993 19e4 080052E3 		cmp	r2, #8
 636:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2994              		.loc 1 636 0
 2995 19e8 0120A003 		moveq	r2, #1
 638:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2996              		.loc 1 638 0
 2997 19ec 0420A013 		movne	r2, #4
 2998 19f0 B524C3E5 		strb	r2, [r3, #1205]
 2999              	.L173:
 641:../uvc.c      **** 								 if(Data1 < 8){
 3000              		.loc 1 641 0
 3001 19f4 070051E3 		cmp	r1, #7
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3002              		.loc 1 642 0
 3003 19f8 B4309F95 		ldrls	r3, .L213+64
 645:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3004              		.loc 1 645 0
 3005 19fc 0130A083 		movhi	r3, #1
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3006              		.loc 1 643 0
 3007 1a00 81008390 		addls	r0, r3, r1, asl #1
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3008              		.loc 1 642 0
 3009 1a04 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3010              		.loc 1 643 0
 3011 1a08 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 645:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3012              		.loc 1 645 0
 3013 1a0c E534C685 		strhib	r3, [r6, #1253]
 646:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3014              		.loc 1 646 0
 3015 1a10 0030A083 		movhi	r3, #0
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3016              		.loc 1 642 0
 3017 1a14 E524C695 		strlsb	r2, [r6, #1253]
 646:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3018              		.loc 1 646 0
 3019 1a18 E634C6E5 		strb	r3, [r6, #1254]
 3020 1a1c CDFFFFEA 		b	.L171
 3021              	.LVL230:
 3022              	.L212:
 858:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 3023              		.loc 1 858 0
 3024 1a20 58209FE5 		ldr	r2, .L213+12
 3025 1a24 0160A0E3 		mov	r6, #1
 3026 1a28 7C6082E5 		str	r6, [r2, #124]
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3027              		.loc 1 861 0
 3028 1a2c 9061C3E5 		strb	r6, [r3, #400]
 3029 1a30 2CFFFFEA 		b	.L187
 3030              	.LVL231:
 3031              	.L211:
 450:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 3032              		.loc 1 450 0
 3033 1a34 0120A0E3 		mov	r2, #1
 3034 1a38 0400A0E3 		mov	r0, #4
 3035 1a3c 5C109FE5 		ldr	r1, .L213+44
 3036 1a40 FEFFFFEB 		bl	CyU3PDebugPrint
 3037              	.LVL232:
 452:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3038              		.loc 1 452 0
 3039 1a44 28309FE5 		ldr	r3, .L213
 3040 1a48 0020A0E3 		mov	r2, #0
 3041 1a4c 0440A0E3 		mov	r4, #4
 3042 1a50 2D24C3E5 		strb	r2, [r3, #1069]
 3043              	.LVL233:
 3044 1a54 81FDFFEA 		b	.L136
 3045              	.LVL234:
 3046              	.L201:
 3047 1a58 20009FE5 		ldr	r0, .L213+12
 3048 1a5c 6EFDFFEA 		b	.L127
 3049              	.LVL235:
 3050              	.L190:
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3051              		.loc 1 393 0
 3052 1a60 0030A0E3 		mov	r3, #0
 3053 1a64 11FEFFEA 		b	.L194
 3054              	.LVL236:
 3055              	.L189:
 3056 1a68 10009FE5 		ldr	r0, .L213+12
 3057 1a6c 0030A0E3 		mov	r3, #0
 3058 1a70 62FDFFEA 		b	.L193
 3059              	.L214:
 3060              		.align	2
 3061              	.L213:
 3062 1a74 00000000 		.word	.LANCHOR1
 3063 1a78 00000000 		.word	bRequest
 3064 1a7c 74030000 		.word	.LC22
 3065 1a80 00000000 		.word	.LANCHOR0
 3066 1a84 5C000000 		.word	.LANCHOR0+92
 3067 1a88 01000100 		.word	65537
 3068 1a8c FF00FF00 		.word	16711935
 3069 1a90 80020000 		.word	.LC16
 3070 1a94 BC020000 		.word	.LC17
 3071 1a98 00000000 		.word	cmdQu
 3072 1a9c 50000000 		.word	.LANCHOR0+80
 3073 1aa0 48020000 		.word	.LC15
 3074 1aa4 2C030000 		.word	.LC20
 3075 1aa8 10030000 		.word	.LC19
 3076 1aac E4020000 		.word	.LC18
 3077 1ab0 44030000 		.word	.LC21
 3078 1ab4 00000000 		.word	.LANCHOR2
 3079              		.cfi_endproc
 3080              	.LFE2:
 3082              		.align	2
 3083              		.global	CTControlHandle
 3085              	CTControlHandle:
 3086              	.LFB3:
 907:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3087              		.loc 1 907 0
 3088              		.cfi_startproc
 3089              		@ args = 0, pretend = 0, frame = 64
 3090              		@ frame_needed = 0, uses_anonymous_args = 0
 3091              	.LVL237:
 3092 1ab8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3093              	.LCFI15:
 3094              		.cfi_def_cfa_offset 36
 926:../uvc.c      ****     reqData = bRequest;
 3095              		.loc 1 926 0
 3096 1abc 64A99FE5 		ldr	sl, .L300
 3097              		.cfi_offset 14, -4
 3098              		.cfi_offset 11, -8
 3099              		.cfi_offset 10, -12
 3100              		.cfi_offset 9, -16
 3101              		.cfi_offset 8, -20
 3102              		.cfi_offset 7, -24
 3103              		.cfi_offset 6, -28
 3104              		.cfi_offset 5, -32
 3105              		.cfi_offset 4, -36
 918:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3106              		.loc 1 918 0
 3107 1ac0 64899FE5 		ldr	r8, .L300+4
 926:../uvc.c      ****     reqData = bRequest;
 3108              		.loc 1 926 0
 3109 1ac4 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 918:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3110              		.loc 1 918 0
 3111 1ac8 8090A0E1 		mov	r9, r0, asl #1
 3112 1acc 002089E0 		add	r2, r9, r0
 3113 1ad0 822188E0 		add	r2, r8, r2, asl #3
 928:../uvc.c      ****     switch (bRequest)
 3114              		.loc 1 928 0
 3115 1ad4 830055E3 		cmp	r5, #131
 907:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3116              		.loc 1 907 0
 3117 1ad8 5CD04DE2 		sub	sp, sp, #92
 3118              	.LCFI16:
 3119              		.cfi_def_cfa_offset 128
 907:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3120              		.loc 1 907 0
 3121 1adc 0060A0E1 		mov	r6, r0
 918:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3122              		.loc 1 918 0
 3123 1ae0 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3124              	.LVL238:
 919:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3125              		.loc 1 919 0
 3126 1ae4 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3127              	.LVL239:
 921:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3128              		.loc 1 921 0
 3129 1ae8 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3130              	.LVL240:
 928:../uvc.c      ****     switch (bRequest)
 3131              		.loc 1 928 0
 3132 1aec 7600000A 		beq	.L220
 3133 1af0 2100009A 		bls	.L295
 3134 1af4 850055E3 		cmp	r5, #133
 3135 1af8 5900000A 		beq	.L222
 3136 1afc 4E00003A 		bcc	.L221
 3137 1b00 860055E3 		cmp	r5, #134
 3138 1b04 8000000A 		beq	.L223
 3139 1b08 870055E3 		cmp	r5, #135
 3140 1b0c 7600000A 		beq	.L296
 3141              	.L216:
1135:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3142              		.loc 1 1135 0
 3143 1b10 0000A0E3 		mov	r0, #0
 3144              	.LVL241:
 3145 1b14 0110A0E3 		mov	r1, #1
 3146 1b18 0020A0E1 		mov	r2, r0
 3147 1b1c FEFFFFEB 		bl	CyU3PUsbStall
 3148              	.LVL242:
 3149 1b20 08499FE5 		ldr	r4, .L300+8
1136:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3150              		.loc 1 1136 0
 3151 1b24 0620A0E1 		mov	r2, r6
 3152 1b28 0400A0E3 		mov	r0, #4
 3153 1b2c 00199FE5 		ldr	r1, .L300+12
 3154 1b30 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3155 1b34 FEFFFFEB 		bl	CyU3PDebugPrint
1137:../uvc.c      **** 			  break;
 3156              		.loc 1 1137 0
 3157 1b38 FFC0A0E3 		mov	ip, #255
 3158 1b3c 0C60A0E1 		mov	r6, ip
 3159 1b40 0C80A0E1 		mov	r8, ip
 3160              	.LVL243:
 3161              	.L226:
1141:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3162              		.loc 1 1141 0
 3163 1b44 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 3164 1b48 08C08DE5 		str	ip, [sp, #8]
 3165 1b4c E4189FE5 		ldr	r1, .L300+16
 3166 1b50 FFC0A0E3 		mov	ip, #255
 3167 1b54 0520A0E1 		mov	r2, r5
 3168 1b58 0830A0E1 		mov	r3, r8
 3169 1b5c 0400A0E3 		mov	r0, #4
 3170 1b60 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3171 1b64 0CC08DE5 		str	ip, [sp, #12]
 3172 1b68 10E08DE5 		str	lr, [sp, #16]
 3173 1b6c 14708DE5 		str	r7, [sp, #20]
 3174 1b70 FEFFFFEB 		bl	CyU3PDebugPrint
1142:../uvc.c      **** }
 3175              		.loc 1 1142 0
 3176 1b74 5CD08DE2 		add	sp, sp, #92
 3177 1b78 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3178              	.LVL244:
 3179              	.L295:
 928:../uvc.c      ****     switch (bRequest)
 3180              		.loc 1 928 0
 3181 1b7c 810055E3 		cmp	r5, #129
 3182 1b80 4200000A 		beq	.L218
 3183 1b84 1100009A 		bls	.L297
 957:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3184              		.loc 1 957 0
 3185 1b88 A0489FE5 		ldr	r4, .L300+8
 3186 1b8c 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 958:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3187              		.loc 1 958 0
 3188 1b90 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 959:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3189              		.loc 1 959 0
 3190 1b94 0A0050E3 		cmp	r0, #10
 957:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3191              		.loc 1 957 0
 3192 1b98 5C10C4E5 		strb	r1, [r4, #92]
 958:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3193              		.loc 1 958 0
 3194 1b9c 5D60C4E5 		strb	r6, [r4, #93]
 959:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3195              		.loc 1 959 0
 3196 1ba0 2C00000A 		beq	.L294
 3197              	.LVL245:
 3198              	.L233:
 993:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3199              		.loc 1 993 0
 3200 1ba4 00E0A0E3 		mov	lr, #0
 3201 1ba8 5EE0C4E5 		strb	lr, [r4, #94]
 3202              	.L234:
 994:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3203              		.loc 1 994 0
 3204 1bac 0030A0E3 		mov	r3, #0
 995:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3205              		.loc 1 995 0
 3206 1bb0 0700A0E1 		mov	r0, r7
 3207              	.LVL246:
 3208 1bb4 80189FE5 		ldr	r1, .L300+20
 997:../uvc.c      **** 			  break;
 3209              		.loc 1 997 0
 3210 1bb8 FF60A0E3 		mov	r6, #255
 994:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3211              		.loc 1 994 0
 3212 1bbc 5F30C4E5 		strb	r3, [r4, #95]
 997:../uvc.c      **** 			  break;
 3213              		.loc 1 997 0
 3214 1bc0 0680A0E1 		mov	r8, r6
 995:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3215              		.loc 1 995 0
 3216 1bc4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3217              	.LVL247:
 3218 1bc8 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
 997:../uvc.c      **** 			  break;
 3219              		.loc 1 997 0
 3220 1bcc DCFFFFEA 		b	.L226
 3221              	.LVL248:
 3222              	.L297:
 928:../uvc.c      ****     switch (bRequest)
 3223              		.loc 1 928 0
 3224 1bd0 010055E3 		cmp	r5, #1
 3225 1bd4 CDFFFF1A 		bne	.L216
 999:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3226              		.loc 1 999 0
 3227 1bd8 50489FE5 		ldr	r4, .L300+8
 3228 1bdc 56208DE2 		add	r2, sp, #86
 3229 1be0 2000A0E3 		mov	r0, #32
 3230              	.LVL249:
 3231 1be4 5C1084E2 		add	r1, r4, #92
 3232 1be8 2C308DE5 		str	r3, [sp, #44]
 3233 1bec FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3234              	.LVL250:
1001:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3235              		.loc 1 1001 0
 3236 1bf0 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1002:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3237              		.loc 1 1002 0
 3238 1bf4 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1005:../uvc.c      **** 			  switch(CtrlID)
 3239              		.loc 1 1005 0
 3240 1bf8 012046E2 		sub	r2, r6, #1
1001:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3241              		.loc 1 1001 0
 3242 1bfc 30008DE5 		str	r0, [sp, #48]
 3243              	.LVL251:
1002:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3244              		.loc 1 1002 0
 3245 1c00 34C08DE5 		str	ip, [sp, #52]
 3246              	.LVL252:
1005:../uvc.c      **** 			  switch(CtrlID)
 3247              		.loc 1 1005 0
 3248 1c04 2C309DE5 		ldr	r3, [sp, #44]
 3249 1c08 090052E3 		cmp	r2, #9
 3250 1c0c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3251 1c10 550100EA 		b	.L235
 3252              	.L240:
 3253 1c14 28210000 		.word	.L236
 3254 1c18 6C210000 		.word	.L235
 3255 1c1c 381E0000 		.word	.L237
 3256 1c20 6C210000 		.word	.L235
 3257 1c24 6C210000 		.word	.L235
 3258 1c28 6C210000 		.word	.L235
 3259 1c2c B41D0000 		.word	.L238
 3260 1c30 6C210000 		.word	.L235
 3261 1c34 6C210000 		.word	.L235
 3262 1c38 381D0000 		.word	.L239
 3263              	.LVL253:
 3264              	.L221:
 975:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3265              		.loc 1 975 0
 3266 1c3c EC479FE5 		ldr	r4, .L300+8
 3267 1c40 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 976:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3268              		.loc 1 976 0
 3269 1c44 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 977:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3270              		.loc 1 977 0
 3271 1c48 0A0050E3 		cmp	r0, #10
 975:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3272              		.loc 1 975 0
 3273 1c4c 5C80C4E5 		strb	r8, [r4, #92]
 976:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3274              		.loc 1 976 0
 3275 1c50 5D20C4E5 		strb	r2, [r4, #93]
 977:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3276              		.loc 1 977 0
 3277 1c54 D2FFFF1A 		bne	.L233
 3278              	.LVL254:
 3279              	.L294:
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3280              		.loc 1 992 0 discriminator 1
 3281 1c58 0110A0E3 		mov	r1, #1
 3282 1c5c 5E10C4E5 		strb	r1, [r4, #94]
 3283 1c60 D1FFFFEA 		b	.L234
 3284              	.LVL255:
 3285              	.L222:
 932:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3286              		.loc 1 932 0
 3287 1c64 C4479FE5 		ldr	r4, .L300+8
 933:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3288              		.loc 1 933 0
 3289 1c68 0030A0E3 		mov	r3, #0
 3290              	.LVL256:
 934:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3291              		.loc 1 934 0
 3292 1c6c 0200A0E3 		mov	r0, #2
 3293              	.LVL257:
 3294 1c70 5C1084E2 		add	r1, r4, #92
 936:../uvc.c      **** 			  break;
 3295              		.loc 1 936 0
 3296 1c74 FF60A0E3 		mov	r6, #255
 932:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3297              		.loc 1 932 0
 3298 1c78 5C70C4E5 		strb	r7, [r4, #92]
 933:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3299              		.loc 1 933 0
 3300 1c7c 5D30C4E5 		strb	r3, [r4, #93]
 936:../uvc.c      **** 			  break;
 3301              		.loc 1 936 0
 3302 1c80 0680A0E1 		mov	r8, r6
 934:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3303              		.loc 1 934 0
 3304 1c84 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3305              	.LVL258:
 3306 1c88 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
 936:../uvc.c      **** 			  break;
 3307              		.loc 1 936 0
 3308 1c8c ACFFFFEA 		b	.L226
 3309              	.LVL259:
 3310              	.L218:
 942:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3311              		.loc 1 942 0
 3312 1c90 98479FE5 		ldr	r4, .L300+8
 3313 1c94 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 943:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3314              		.loc 1 943 0
 3315 1c98 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 944:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3316              		.loc 1 944 0
 3317 1c9c 0080A0E3 		mov	r8, #0
 950:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3318              		.loc 1 950 0
 3319 1ca0 0700A0E1 		mov	r0, r7
 3320              	.LVL260:
 3321 1ca4 5C1084E2 		add	r1, r4, #92
 955:../uvc.c      **** 			  break;
 3322              		.loc 1 955 0
 3323 1ca8 FF60A0E3 		mov	r6, #255
 943:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3324              		.loc 1 943 0
 3325 1cac 5DC0C4E5 		strb	ip, [r4, #93]
 944:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3326              		.loc 1 944 0
 3327 1cb0 5E80C4E5 		strb	r8, [r4, #94]
 945:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3328              		.loc 1 945 0
 3329 1cb4 5F80C4E5 		strb	r8, [r4, #95]
 3330              	.LVL261:
 942:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3331              		.loc 1 942 0
 3332 1cb8 5CA0C4E5 		strb	sl, [r4, #92]
 955:../uvc.c      **** 			  break;
 3333              		.loc 1 955 0
 3334 1cbc 0680A0E1 		mov	r8, r6
 950:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3335              		.loc 1 950 0
 3336 1cc0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3337              	.LVL262:
 3338 1cc4 0AC0A0E1 		mov	ip, sl
 955:../uvc.c      **** 			  break;
 3339              		.loc 1 955 0
 3340 1cc8 9DFFFFEA 		b	.L226
 3341              	.LVL263:
 3342              	.L220:
 966:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3343              		.loc 1 966 0
 3344 1ccc 5C479FE5 		ldr	r4, .L300+8
 3345 1cd0 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3346              	.LVL264:
 967:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3347              		.loc 1 967 0
 3348 1cd4 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 968:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3349              		.loc 1 968 0
 3350 1cd8 0A0050E3 		cmp	r0, #10
 966:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3351              		.loc 1 966 0
 3352 1cdc 5C30C4E5 		strb	r3, [r4, #92]
 967:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3353              		.loc 1 967 0
 3354 1ce0 5DE0C4E5 		strb	lr, [r4, #93]
 968:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3355              		.loc 1 968 0
 3356 1ce4 AEFFFF1A 		bne	.L233
 3357 1ce8 DAFFFFEA 		b	.L294
 3358              	.LVL265:
 3359              	.L296:
 990:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3360              		.loc 1 990 0
 3361 1cec 3C479FE5 		ldr	r4, .L300+8
 3362 1cf0 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 991:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3363              		.loc 1 991 0
 3364 1cf4 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3365              		.loc 1 992 0
 3366 1cf8 0A0050E3 		cmp	r0, #10
 990:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3367              		.loc 1 990 0
 3368 1cfc 5C60C4E5 		strb	r6, [r4, #92]
 991:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3369              		.loc 1 991 0
 3370 1d00 5DC0C4E5 		strb	ip, [r4, #93]
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3371              		.loc 1 992 0
 3372 1d04 A6FFFF1A 		bne	.L233
 3373 1d08 D2FFFFEA 		b	.L294
 3374              	.L223:
 984:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3375              		.loc 1 984 0
 3376 1d0c 1C479FE5 		ldr	r4, .L300+8
 3377 1d10 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3378              	.LVL266:
 3379 1d14 0410A0E1 		mov	r1, r4
 3380 1d18 5C00E1E5 		strb	r0, [r1, #92]!
 988:../uvc.c      **** 			  break;
 3381              		.loc 1 988 0
 3382 1d1c FF60A0E3 		mov	r6, #255
 985:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3383              		.loc 1 985 0
 3384 1d20 0100A0E3 		mov	r0, #1
 3385 1d24 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3386              	.LVL267:
 988:../uvc.c      **** 			  break;
 3387              		.loc 1 988 0
 3388 1d28 0680A0E1 		mov	r8, r6
 985:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3389              		.loc 1 985 0
 3390 1d2c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
 988:../uvc.c      **** 			  break;
 3391              		.loc 1 988 0
 3392 1d30 0170A0E3 		mov	r7, #1
 3393 1d34 82FFFFEA 		b	.L226
 3394              	.LVL268:
 3395              	.L239:
1114:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3396              		.loc 1 1114 0
 3397 1d38 00679FE5 		ldr	r6, .L300+24
 3398 1d3c 0010E0E3 		mvn	r1, #0
 3399 1d40 1C0096E5 		ldr	r0, [r6, #28]
 3400 1d44 2C308DE5 		str	r3, [sp, #44]
 3401 1d48 FEFFFFEB 		bl	_txe_mutex_get
1115:../uvc.c      **** 					  if(getData == 1)
 3402              		.loc 1 1115 0
 3403 1d4c 30E09DE5 		ldr	lr, [sp, #48]
 3404 1d50 2C309DE5 		ldr	r3, [sp, #44]
 3405 1d54 01005EE3 		cmp	lr, #1
 3406 1d58 AA01000A 		beq	.L298
1117:../uvc.c      **** 					  else if(getData == 0xff)
 3407              		.loc 1 1117 0
 3408 1d5c FF005EE3 		cmp	lr, #255
 3409 1d60 9F01000A 		beq	.L299
1120:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 3410              		.loc 1 1120 0
 3411 1d64 0080A0E3 		mov	r8, #0
 3412 1d68 0600A0E1 		mov	r0, r6
 3413 1d6c 2310A0E3 		mov	r1, #35
 3414 1d70 0B20A0E1 		mov	r2, fp
 3415 1d74 00808DE5 		str	r8, [sp, #0]
 3416 1d78 04808DE5 		str	r8, [sp, #4]
 3417 1d7c FEFFFFEB 		bl	cmdSet
 3418              	.L292:
1123:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3419              		.loc 1 1123 0
 3420 1d80 1C0096E5 		ldr	r0, [r6, #28]
 3421 1d84 FEFFFFEB 		bl	_txe_mutex_put
1125:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3422              		.loc 1 1125 0
 3423 1d88 30809DE5 		ldr	r8, [sp, #48]
 3424 1d8c 34609DE5 		ldr	r6, [sp, #52]
 3425 1d90 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 3426 1d94 0400A0E3 		mov	r0, #4
 3427 1d98 A4169FE5 		ldr	r1, .L300+28
 3428 1d9c 0820A0E1 		mov	r2, r8
 3429 1da0 0630A0E1 		mov	r3, r6
 3430 1da4 00C08DE5 		str	ip, [sp, #0]
 3431 1da8 FEFFFFEB 		bl	CyU3PDebugPrint
1126:../uvc.c      **** 					  break;
 3432              		.loc 1 1126 0
 3433 1dac FFC0A0E3 		mov	ip, #255
 3434 1db0 63FFFFEA 		b	.L226
 3435              	.LVL269:
 3436              	.L238:
1091:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3437              		.loc 1 1091 0
 3438 1db4 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3439 1db8 010058E3 		cmp	r8, #1
 3440 1dbc 08005813 		cmpne	r8, #8
 3441 1dc0 0000A013 		movne	r0, #0
 3442 1dc4 0100A003 		moveq	r0, #1
 3443 1dc8 8101001A 		bne	.L289
 3444              	.LVL270:
1094:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3445              		.loc 1 1094 0
 3446 1dcc 6C869FE5 		ldr	r8, .L300+24
 3447 1dd0 0010E0E3 		mvn	r1, #0
 3448 1dd4 1C0098E5 		ldr	r0, [r8, #28]
 3449 1dd8 2C308DE5 		str	r3, [sp, #44]
 3450 1ddc FEFFFFEB 		bl	_txe_mutex_get
1095:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3451              		.loc 1 1095 0
 3452 1de0 30A09DE5 		ldr	sl, [sp, #48]
 3453 1de4 2210A0E3 		mov	r1, #34
 3454 1de8 0B20A0E1 		mov	r2, fp
 3455 1dec 2C309DE5 		ldr	r3, [sp, #44]
 3456 1df0 00C0A0E3 		mov	ip, #0
 3457 1df4 0800A0E1 		mov	r0, r8
 3458 1df8 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3459 1dfc FEFFFFEB 		bl	cmdSet
1096:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3460              		.loc 1 1096 0
 3461 1e00 1C0098E5 		ldr	r0, [r8, #28]
 3462 1e04 FEFFFFEB 		bl	_txe_mutex_put
1099:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3463              		.loc 1 1099 0
 3464 1e08 1C069FE5 		ldr	r0, .L300+4
1100:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3465              		.loc 1 1100 0
 3466 1e0c 34209DE5 		ldr	r2, [sp, #52]
1099:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3467              		.loc 1 1099 0
 3468 1e10 061089E0 		add	r1, r9, r6
 3469 1e14 813180E0 		add	r3, r0, r1, asl #3
1101:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3470              		.loc 1 1101 0
 3471 1e18 0160A0E3 		mov	r6, #1
1099:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3472              		.loc 1 1099 0
 3473 1e1c 9DA4C3E5 		strb	sl, [r3, #1181]
1100:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3474              		.loc 1 1100 0
 3475 1e20 9E24C3E5 		strb	r2, [r3, #1182]
1101:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3476              		.loc 1 1101 0
 3477 1e24 A064C3E5 		strb	r6, [r3, #1184]
 3478              	.LVL271:
 3479              	.L290:
1103:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3480              		.loc 1 1103 0
 3481 1e28 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 3482 1e2c 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1108:../uvc.c      **** 					  break;
 3483              		.loc 1 1108 0
 3484 1e30 FFC0A0E3 		mov	ip, #255
 3485 1e34 42FFFFEA 		b	.L226
 3486              	.LVL272:
 3487              	.L237:
1057:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3488              		.loc 1 1057 0
 3489 1e38 B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3490 1e3c 010050E3 		cmp	r0, #1
 3491 1e40 04005013 		cmpne	r0, #4
 3492 1e44 5D01001A 		bne	.L247
1056:../uvc.c      **** 					  value = (value << 8)|Data0;
 3493              		.loc 1 1056 0
 3494 1e48 30109DE5 		ldr	r1, [sp, #48]
 3495 1e4c 34E09DE5 		ldr	lr, [sp, #52]
 3496 1e50 0E2481E1 		orr	r2, r1, lr, asl #8
1058:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3497              		.loc 1 1058 0
 3498 1e54 F90052E3 		cmp	r2, #249
 3499 1e58 5801008A 		bhi	.L247
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3500              		.loc 1 1063 0
 3501 1e5c C8A042E2 		sub	sl, r2, #200
 3502 1e60 0AC8A0E1 		mov	ip, sl, asl #16
 3503 1e64 3CC08DE5 		str	ip, [sp, #60]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3504              		.loc 1 1065 0
 3505 1e68 27A062E2 		rsb	sl, r2, #39
 3506 1e6c 38A08DE5 		str	sl, [sp, #56]
 3507 1e70 3CA09DE5 		ldr	sl, [sp, #60]
 3508 1e74 C81062E2 		rsb	r1, r2, #200
 3509 1e78 C80052E3 		cmp	r2, #200
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3510              		.loc 1 1063 0
 3511 1e7c 640042E2 		sub	r0, r2, #100
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3512              		.loc 1 1065 0
 3513 1e80 0118A0E1 		mov	r1, r1, asl #16
 3514 1e84 64E062E2 		rsb	lr, r2, #100
 3515 1e88 2A18A081 		movhi	r1, sl, lsr #16
 3516 1e8c 2118A091 		movls	r1, r1, lsr #16
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3517              		.loc 1 1063 0
 3518 1e90 00C8A0E1 		mov	ip, r0, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3519              		.loc 1 1065 0
 3520 1e94 640052E3 		cmp	r2, #100
 3521 1e98 0E08A0E1 		mov	r0, lr, asl #16
 3522 1e9c 2C08A081 		movhi	r0, ip, lsr #16
 3523 1ea0 38C09DE5 		ldr	ip, [sp, #56]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3524              		.loc 1 1063 0
 3525 1ea4 14A042E2 		sub	sl, r2, #20
 3526 1ea8 38A08DE5 		str	sl, [sp, #56]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3527              		.loc 1 1065 0
 3528 1eac 2008A091 		movls	r0, r0, lsr #16
 3529 1eb0 14A062E2 		rsb	sl, r2, #20
 3530 1eb4 3CA08DE5 		str	sl, [sp, #60]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3531              		.loc 1 1063 0
 3532 1eb8 27E042E2 		sub	lr, r2, #39
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3533              		.loc 1 1065 0
 3534 1ebc 000051E1 		cmp	r1, r0
 3535 1ec0 01A0A031 		movcc	sl, r1
 3536 1ec4 00A0A021 		movcs	sl, r0
 3537 1ec8 0CC8A0E1 		mov	ip, ip, asl #16
 3538 1ecc 270052E3 		cmp	r2, #39
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3539              		.loc 1 1063 0
 3540 1ed0 0EE8A0E1 		mov	lr, lr, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3541              		.loc 1 1065 0
 3542 1ed4 2CE8A091 		movls	lr, ip, lsr #16
 3543 1ed8 68C59FE5 		ldr	ip, .L300+32
 3544 1edc 20A08DE5 		str	sl, [sp, #32]
 3545 1ee0 01A06CE0 		rsb	sl, ip, r1
 3546 1ee4 2EE8A081 		movhi	lr, lr, lsr #16
 3547 1ee8 00C07AE2 		rsbs	ip, sl, #0
 3548 1eec 0AC0ACE0 		adc	ip, ip, sl
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3549              		.loc 1 1063 0
 3550 1ef0 38A09DE5 		ldr	sl, [sp, #56]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3551              		.loc 1 1065 0
 3552 1ef4 44C08DE5 		str	ip, [sp, #68]
 3553              	.LVL273:
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3554              		.loc 1 1063 0
 3555 1ef8 0AC8A0E1 		mov	ip, sl, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3556              		.loc 1 1065 0
 3557 1efc 3CA09DE5 		ldr	sl, [sp, #60]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3558              		.loc 1 1063 0
 3559 1f00 4CC08DE5 		str	ip, [sp, #76]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3560              		.loc 1 1065 0
 3561 1f04 0AC8A0E1 		mov	ip, sl, asl #16
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3562              		.loc 1 1063 0
 3563 1f08 0AA042E2 		sub	sl, r2, #10
 3564 1f0c 48A08DE5 		str	sl, [sp, #72]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3565              		.loc 1 1065 0
 3566 1f10 20A09DE5 		ldr	sl, [sp, #32]
 3567 1f14 3CC08DE5 		str	ip, [sp, #60]
 3568 1f18 0A005EE1 		cmp	lr, sl
 3569 1f1c 0EA0A031 		movcc	sl, lr
 3570 1f20 0AC062E2 		rsb	ip, r2, #10
 3571 1f24 40C08DE5 		str	ip, [sp, #64]
 3572 1f28 38A08DE5 		str	sl, [sp, #56]
 3573 1f2c 3CC09DE5 		ldr	ip, [sp, #60]
 3574 1f30 4CA09DE5 		ldr	sl, [sp, #76]
 3575 1f34 140052E3 		cmp	r2, #20
 3576 1f38 2CA8A091 		movls	sl, ip, lsr #16
 3577 1f3c 2AA8A081 		movhi	sl, sl, lsr #16
 3578 1f40 44C09DE5 		ldr	ip, [sp, #68]
 3579 1f44 010050E1 		cmp	r0, r1
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3580              		.loc 1 1063 0
 3581 1f48 48109DE5 		ldr	r1, [sp, #72]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3582              		.loc 1 1065 0
 3583 1f4c 01C0A033 		movcc	ip, #1
 3584 1f50 3CA08DE5 		str	sl, [sp, #60]
 3585 1f54 24C08DE5 		str	ip, [sp, #36]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3586              		.loc 1 1063 0
 3587 1f58 01A8A0E1 		mov	sl, r1, asl #16
 3588 1f5c 05C042E2 		sub	ip, r2, #5
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3589              		.loc 1 1065 0
 3590 1f60 051062E2 		rsb	r1, r2, #5
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3591              		.loc 1 1063 0
 3592 1f64 48A08DE5 		str	sl, [sp, #72]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3593              		.loc 1 1065 0
 3594 1f68 40009DE5 		ldr	r0, [sp, #64]
 3595 1f6c 38A09DE5 		ldr	sl, [sp, #56]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3596              		.loc 1 1063 0
 3597 1f70 40C08DE5 		str	ip, [sp, #64]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3598              		.loc 1 1065 0
 3599 1f74 3CC09DE5 		ldr	ip, [sp, #60]
 3600 1f78 4C108DE5 		str	r1, [sp, #76]
 3601 1f7c 48109DE5 		ldr	r1, [sp, #72]
 3602 1f80 0008A0E1 		mov	r0, r0, asl #16
 3603 1f84 0A005CE1 		cmp	ip, sl
 3604 1f88 0AC0A021 		movcs	ip, sl
 3605 1f8c 0A0052E3 		cmp	r2, #10
 3606 1f90 20A09DE5 		ldr	sl, [sp, #32]
 3607 1f94 2108A081 		movhi	r0, r1, lsr #16
 3608 1f98 2008A091 		movls	r0, r0, lsr #16
 3609 1f9c 48008DE5 		str	r0, [sp, #72]
 3610 1fa0 24009DE5 		ldr	r0, [sp, #36]
 3611 1fa4 0A005EE1 		cmp	lr, sl
 3612 1fa8 0200A033 		movcc	r0, #2
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3613              		.loc 1 1063 0
 3614 1fac 02E042E2 		sub	lr, r2, #2
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3615              		.loc 1 1065 0
 3616 1fb0 44C08DE5 		str	ip, [sp, #68]
 3617 1fb4 24008DE5 		str	r0, [sp, #36]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3618              		.loc 1 1063 0
 3619 1fb8 40C09DE5 		ldr	ip, [sp, #64]
 3620 1fbc 1CE08DE5 		str	lr, [sp, #28]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3621              		.loc 1 1065 0
 3622 1fc0 44009DE5 		ldr	r0, [sp, #68]
 3623 1fc4 48E09DE5 		ldr	lr, [sp, #72]
 3624 1fc8 4C109DE5 		ldr	r1, [sp, #76]
 3625 1fcc 02A062E2 		rsb	sl, r2, #2
 3626 1fd0 00005EE1 		cmp	lr, r0
 3627 1fd4 00E0A021 		movcs	lr, r0
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3628              		.loc 1 1063 0
 3629 1fd8 0CC8A0E1 		mov	ip, ip, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3630              		.loc 1 1065 0
 3631 1fdc 050052E3 		cmp	r2, #5
 3632 1fe0 40A08DE5 		str	sl, [sp, #64]
 3633 1fe4 0118A0E1 		mov	r1, r1, asl #16
 3634 1fe8 3CA09DE5 		ldr	sl, [sp, #60]
 3635 1fec 2C18A081 		movhi	r1, ip, lsr #16
 3636 1ff0 38C09DE5 		ldr	ip, [sp, #56]
 3637 1ff4 4CE08DE5 		str	lr, [sp, #76]
 3638 1ff8 24009DE5 		ldr	r0, [sp, #36]
 3639 1ffc 40E09DE5 		ldr	lr, [sp, #64]
 3640 2000 2118A091 		movls	r1, r1, lsr #16
 3641 2004 0C005AE1 		cmp	sl, ip
 3642 2008 20108DE5 		str	r1, [sp, #32]
 3643 200c 0300A033 		movcc	r0, #3
 3644 2010 38008DE5 		str	r0, [sp, #56]
 3645 2014 4CA09DE5 		ldr	sl, [sp, #76]
 3646 2018 0E08A0E1 		mov	r0, lr, asl #16
 3647 201c 20E09DE5 		ldr	lr, [sp, #32]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3648              		.loc 1 1063 0
 3649 2020 1C109DE5 		ldr	r1, [sp, #28]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3650              		.loc 1 1065 0
 3651 2024 0A005EE1 		cmp	lr, sl
 3652 2028 0AE0A021 		movcs	lr, sl
 3653 202c 44C09DE5 		ldr	ip, [sp, #68]
 3654 2030 48A09DE5 		ldr	sl, [sp, #72]
 3655 2034 020052E3 		cmp	r2, #2
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3656              		.loc 1 1063 0
 3657 2038 0118A0E1 		mov	r1, r1, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3658              		.loc 1 1065 0
 3659 203c 2018A091 		movls	r1, r0, lsr #16
 3660 2040 38009DE5 		ldr	r0, [sp, #56]
 3661 2044 2118A081 		movhi	r1, r1, lsr #16
 3662 2048 0C005AE1 		cmp	sl, ip
 3663 204c 0400A033 		movcc	r0, #4
 3664 2050 40008DE5 		str	r0, [sp, #64]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3665              		.loc 1 1063 0
 3666 2054 010042E2 		sub	r0, r2, #1
 3667 2058 38008DE5 		str	r0, [sp, #56]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3668              		.loc 1 1065 0
 3669 205c 4CA09DE5 		ldr	sl, [sp, #76]
 3670 2060 20009DE5 		ldr	r0, [sp, #32]
 3671 2064 01C062E2 		rsb	ip, r2, #1
 3672 2068 3CC08DE5 		str	ip, [sp, #60]
 3673 206c 0A0050E1 		cmp	r0, sl
1072:../uvc.c      **** 						  shutter = shutter+index;
 3674              		.loc 1 1072 0
 3675 2070 38A09DE5 		ldr	sl, [sp, #56]
 3676 2074 3C009DE5 		ldr	r0, [sp, #60]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3677              		.loc 1 1065 0
 3678 2078 40C09DE5 		ldr	ip, [sp, #64]
 3679 207c 05C0A033 		movcc	ip, #5
1072:../uvc.c      **** 						  shutter = shutter+index;
 3680              		.loc 1 1072 0
 3681 2080 010052E3 		cmp	r2, #1
 3682 2084 0028A091 		movls	r2, r0, asl #16
 3683 2088 0A28A081 		movhi	r2, sl, asl #16
 3684 208c 0E0051E1 		cmp	r1, lr
 3685 2090 01A0A031 		movcc	sl, r1
 3686 2094 0EA0A021 		movcs	sl, lr
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3687              		.loc 1 1065 0
 3688 2098 0E0051E1 		cmp	r1, lr
 3689 209c 0C10A021 		movcs	r1, ip
 3690 20a0 0610A033 		movcc	r1, #6
1072:../uvc.c      **** 						  shutter = shutter+index;
 3691              		.loc 1 1072 0
 3692 20a4 22085AE1 		cmp	sl, r2, lsr #16
1075:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3693              		.loc 1 1075 0
 3694 20a8 90A39FE5 		ldr	sl, .L300+24
1072:../uvc.c      **** 						  shutter = shutter+index;
 3695              		.loc 1 1072 0
 3696 20ac 0120A091 		movls	r2, r1
 3697 20b0 0720A083 		movhi	r2, #7
 3698 20b4 012082E2 		add	r2, r2, #1
 3699 20b8 FFE002E2 		and	lr, r2, #255
1075:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3700              		.loc 1 1075 0
 3701 20bc 0010E0E3 		mvn	r1, #0
 3702 20c0 1C009AE5 		ldr	r0, [sl, #28]
1072:../uvc.c      **** 						  shutter = shutter+index;
 3703              		.loc 1 1072 0
 3704 20c4 38E08DE5 		str	lr, [sp, #56]
 3705              	.LVL274:
1075:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3706              		.loc 1 1075 0
 3707 20c8 2C308DE5 		str	r3, [sp, #44]
 3708 20cc FEFFFFEB 		bl	_txe_mutex_get
1076:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3709              		.loc 1 1076 0
 3710 20d0 38C09DE5 		ldr	ip, [sp, #56]
 3711 20d4 0310A0E3 		mov	r1, #3
 3712 20d8 0B20A0E1 		mov	r2, fp
 3713 20dc 2C309DE5 		ldr	r3, [sp, #44]
 3714 20e0 00C08DE5 		str	ip, [sp, #0]
 3715 20e4 0A00A0E1 		mov	r0, sl
 3716 20e8 00C0A0E3 		mov	ip, #0
 3717 20ec 04C08DE5 		str	ip, [sp, #4]
 3718 20f0 FEFFFFEB 		bl	cmdSet
1077:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3719              		.loc 1 1077 0
 3720 20f4 1C009AE5 		ldr	r0, [sl, #28]
 3721 20f8 FEFFFFEB 		bl	_txe_mutex_put
1080:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3722              		.loc 1 1080 0
 3723 20fc 30009DE5 		ldr	r0, [sp, #48]
1081:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3724              		.loc 1 1081 0
 3725 2100 34C09DE5 		ldr	ip, [sp, #52]
1083:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3726              		.loc 1 1083 0
 3727 2104 38309DE5 		ldr	r3, [sp, #56]
1080:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3728              		.loc 1 1080 0
 3729 2108 061089E0 		add	r1, r9, r6
 3730 210c 816188E0 		add	r6, r8, r1, asl #3
1082:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3731              		.loc 1 1082 0
 3732 2110 0120A0E3 		mov	r2, #1
1080:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3733              		.loc 1 1080 0
 3734 2114 9D04C6E5 		strb	r0, [r6, #1181]
1081:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3735              		.loc 1 1081 0
 3736 2118 9EC4C6E5 		strb	ip, [r6, #1182]
1082:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3737              		.loc 1 1082 0
 3738 211c A024C6E5 		strb	r2, [r6, #1184]
1083:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3739              		.loc 1 1083 0
 3740 2120 0D33C8E5 		strb	r3, [r8, #781]
 3741 2124 3FFFFFEA 		b	.L290
 3742              	.LVL275:
 3743              	.L236:
1010:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3744              		.loc 1 1010 0
 3745 2128 062089E0 		add	r2, r9, r6
 3746 212c 826188E0 		add	r6, r8, r2, asl #3
1011:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3747              		.loc 1 1011 0
 3748 2130 0110A0E3 		mov	r1, #1
1014:../uvc.c      **** 		  		    switch (getData){
 3749              		.loc 1 1014 0
 3750 2134 01E040E2 		sub	lr, r0, #1
1010:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3751              		.loc 1 1010 0
 3752 2138 9D04C6E5 		strb	r0, [r6, #1181]
1011:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3753              		.loc 1 1011 0
 3754 213c A014C6E5 		strb	r1, [r6, #1184]
 3755              	.LVL276:
1014:../uvc.c      **** 		  		    switch (getData){
 3756              		.loc 1 1014 0
 3757 2140 07005EE3 		cmp	lr, #7
 3758 2144 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3759 2148 980000EA 		b	.L241
 3760              	.L246:
 3761 214c 44230000 		.word	.L242
 3762 2150 A8220000 		.word	.L243
 3763 2154 B0230000 		.word	.L241
 3764 2158 40220000 		.word	.L244
 3765 215c B0230000 		.word	.L241
 3766 2160 B0230000 		.word	.L241
 3767 2164 B0230000 		.word	.L241
 3768 2168 A0210000 		.word	.L245
 3769              	.LVL277:
 3770              	.L235:
1130:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3771              		.loc 1 1130 0
 3772 216c 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1129:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3773              		.loc 1 1129 0
 3774 2170 30A09DE5 		ldr	sl, [sp, #48]
 3775 2174 069089E0 		add	r9, r9, r6
 3776 2178 89E188E0 		add	lr, r8, r9, asl #3
1130:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3777              		.loc 1 1130 0
 3778 217c 0620A0E1 		mov	r2, r6
 3779 2180 0400A0E3 		mov	r0, #4
 3780 2184 C0129FE5 		ldr	r1, .L300+36
1129:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3781              		.loc 1 1129 0
 3782 2188 9DA4CEE5 		strb	sl, [lr, #1181]
1130:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3783              		.loc 1 1130 0
 3784 218c FEFFFFEB 		bl	CyU3PDebugPrint
1131:../uvc.c      **** 			  		 break;
 3785              		.loc 1 1131 0
 3786 2190 FFC0A0E3 		mov	ip, #255
 3787 2194 0C60A0E1 		mov	r6, ip
 3788 2198 0C80A0E1 		mov	r8, ip
 3789 219c 68FEFFEA 		b	.L226
 3790              	.LVL278:
 3791              	.L245:
1033:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3792              		.loc 1 1033 0
 3793 21a0 98629FE5 		ldr	r6, .L300+24
1031:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3794              		.loc 1 1031 0
 3795 21a4 00A0A0E3 		mov	sl, #0
1033:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3796              		.loc 1 1033 0
 3797 21a8 1C0096E5 		ldr	r0, [r6, #28]
1031:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3798              		.loc 1 1031 0
 3799 21ac 0DA3C8E5 		strb	sl, [r8, #781]
 3800              	.LVL279:
1033:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3801              		.loc 1 1033 0
 3802 21b0 0010E0E3 		mvn	r1, #0
 3803 21b4 2C308DE5 		str	r3, [sp, #44]
 3804 21b8 FEFFFFEB 		bl	_txe_mutex_get
1034:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3805              		.loc 1 1034 0
 3806 21bc 0B20A0E1 		mov	r2, fp
 3807 21c0 2C309DE5 		ldr	r3, [sp, #44]
 3808 21c4 1010A0E3 		mov	r1, #16
 3809 21c8 0600A0E1 		mov	r0, r6
 3810 21cc 00A08DE5 		str	sl, [sp, #0]
 3811 21d0 04A08DE5 		str	sl, [sp, #4]
 3812 21d4 FEFFFFEB 		bl	cmdSet
1035:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3813              		.loc 1 1035 0
 3814 21d8 1C0096E5 		ldr	r0, [r6, #28]
 3815 21dc FEFFFFEB 		bl	_txe_mutex_put
 3816              	.LVL280:
 3817              	.LBB68:
 3818              	.LBB69:
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3819              		.loc 1 387 0
 3820 21e0 0010E0E3 		mvn	r1, #0
 3821 21e4 1C0096E5 		ldr	r0, [r6, #28]
 3822 21e8 FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3823              		.loc 1 388 0
 3824 21ec 01C0A0E3 		mov	ip, #1
 3825 21f0 2010A0E3 		mov	r1, #32
 3826 21f4 2720A0E3 		mov	r2, #39
 3827 21f8 3030A0E3 		mov	r3, #48
 3828 21fc 0600A0E1 		mov	r0, r6
 3829 2200 00C08DE5 		str	ip, [sp, #0]
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3830              		.loc 1 389 0
 3831 2204 0280A0E3 		mov	r8, #2
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3832              		.loc 1 388 0
 3833 2208 04A08DE5 		str	sl, [sp, #4]
 3834 220c FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3835              		.loc 1 389 0
 3836 2210 2110A0E3 		mov	r1, #33
 3837 2214 2520A0E3 		mov	r2, #37
 3838 2218 3030A0E3 		mov	r3, #48
 3839 221c 0600A0E1 		mov	r0, r6
 3840 2220 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3841 2224 FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3842              		.loc 1 390 0
 3843 2228 1C0096E5 		ldr	r0, [r6, #28]
 3844 222c FEFFFFEB 		bl	_txe_mutex_put
 3845              	.LBE69:
 3846              	.LBE68:
1037:../uvc.c      **** 							break;
 3847              		.loc 1 1037 0
 3848 2230 FFC0A0E3 		mov	ip, #255
 3849 2234 0C60A0E1 		mov	r6, ip
 3850 2238 0880A0E3 		mov	r8, #8
 3851 223c 40FEFFEA 		b	.L226
 3852              	.LVL281:
 3853              	.L244:
 3854              	.LBB70:
 3855              	.LBB71:
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3856              		.loc 1 387 0
 3857 2240 F8619FE5 		ldr	r6, .L300+24
 3858 2244 0010E0E3 		mvn	r1, #0
 3859 2248 1C0096E5 		ldr	r0, [r6, #28]
 3860 224c FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3861              		.loc 1 388 0
 3862 2250 0080A0E3 		mov	r8, #0
 3863 2254 2010A0E3 		mov	r1, #32
 3864 2258 2720A0E3 		mov	r2, #39
 3865 225c 3030A0E3 		mov	r3, #48
 3866 2260 0600A0E1 		mov	r0, r6
 3867 2264 00808DE5 		str	r8, [sp, #0]
 3868 2268 04808DE5 		str	r8, [sp, #4]
 3869 226c FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3870              		.loc 1 389 0
 3871 2270 01C0A0E3 		mov	ip, #1
 3872 2274 2110A0E3 		mov	r1, #33
 3873 2278 2520A0E3 		mov	r2, #37
 3874 227c 3030A0E3 		mov	r3, #48
 3875 2280 0600A0E1 		mov	r0, r6
 3876 2284 00C08DE5 		str	ip, [sp, #0]
 3877 2288 04808DE5 		str	r8, [sp, #4]
 3878 228c FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3879              		.loc 1 390 0
 3880 2290 1C0096E5 		ldr	r0, [r6, #28]
 3881 2294 FEFFFFEB 		bl	_txe_mutex_put
 3882 2298 FFC0A0E3 		mov	ip, #255
 3883 229c 0C60A0E1 		mov	r6, ip
 3884 22a0 0480A0E3 		mov	r8, #4
 3885 22a4 26FEFFEA 		b	.L226
 3886              	.LVL282:
 3887              	.L243:
 3888              	.LBE71:
 3889              	.LBE70:
1021:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3890              		.loc 1 1021 0
 3891 22a8 90619FE5 		ldr	r6, .L300+24
1019:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3892              		.loc 1 1019 0
 3893 22ac 00A0A0E3 		mov	sl, #0
1021:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3894              		.loc 1 1021 0
 3895 22b0 1C0096E5 		ldr	r0, [r6, #28]
1019:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3896              		.loc 1 1019 0
 3897 22b4 0DA3C8E5 		strb	sl, [r8, #781]
 3898              	.LVL283:
1021:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3899              		.loc 1 1021 0
 3900 22b8 0010E0E3 		mvn	r1, #0
 3901 22bc 2C308DE5 		str	r3, [sp, #44]
 3902 22c0 FEFFFFEB 		bl	_txe_mutex_get
1022:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3903              		.loc 1 1022 0
 3904 22c4 0B20A0E1 		mov	r2, fp
 3905 22c8 2C309DE5 		ldr	r3, [sp, #44]
 3906 22cc 1010A0E3 		mov	r1, #16
 3907 22d0 0600A0E1 		mov	r0, r6
 3908 22d4 00A08DE5 		str	sl, [sp, #0]
 3909 22d8 04A08DE5 		str	sl, [sp, #4]
 3910 22dc FEFFFFEB 		bl	cmdSet
1023:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3911              		.loc 1 1023 0
 3912 22e0 1C0096E5 		ldr	r0, [r6, #28]
 3913 22e4 FEFFFFEB 		bl	_txe_mutex_put
 3914              	.LVL284:
 3915              	.LBB72:
 3916              	.LBB73:
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3917              		.loc 1 387 0
 3918 22e8 0010E0E3 		mvn	r1, #0
 3919 22ec 1C0096E5 		ldr	r0, [r6, #28]
 3920 22f0 FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3921              		.loc 1 388 0
 3922 22f4 2010A0E3 		mov	r1, #32
 3923 22f8 2720A0E3 		mov	r2, #39
 3924 22fc 3030A0E3 		mov	r3, #48
 3925 2300 0600A0E1 		mov	r0, r6
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3926              		.loc 1 389 0
 3927 2304 0180A0E3 		mov	r8, #1
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3928              		.loc 1 388 0
 3929 2308 00A08DE5 		str	sl, [sp, #0]
 3930 230c 04A08DE5 		str	sl, [sp, #4]
 3931 2310 FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3932              		.loc 1 389 0
 3933 2314 2110A0E3 		mov	r1, #33
 3934 2318 2520A0E3 		mov	r2, #37
 3935 231c 3030A0E3 		mov	r3, #48
 3936 2320 0600A0E1 		mov	r0, r6
 3937 2324 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3938 2328 FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3939              		.loc 1 390 0
 3940 232c 1C0096E5 		ldr	r0, [r6, #28]
 3941 2330 FEFFFFEB 		bl	_txe_mutex_put
 3942 2334 FFC0A0E3 		mov	ip, #255
 3943 2338 0C60A0E1 		mov	r6, ip
 3944 233c 0280A0E3 		mov	r8, #2
 3945 2340 FFFDFFEA 		b	.L226
 3946              	.LVL285:
 3947              	.L242:
 3948              	.LBE73:
 3949              	.LBE72:
 3950              	.LBB74:
 3951              	.LBB75:
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3952              		.loc 1 387 0
 3953 2344 F4609FE5 		ldr	r6, .L300+24
 3954 2348 0010E0E3 		mvn	r1, #0
 3955 234c 1C0096E5 		ldr	r0, [r6, #28]
 3956 2350 FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3957              		.loc 1 388 0
 3958 2354 0080A0E3 		mov	r8, #0
 3959 2358 01A0A0E3 		mov	sl, #1
 3960 235c 2010A0E3 		mov	r1, #32
 3961 2360 2720A0E3 		mov	r2, #39
 3962 2364 3030A0E3 		mov	r3, #48
 3963 2368 0600A0E1 		mov	r0, r6
 3964 236c 04808DE5 		str	r8, [sp, #4]
 3965 2370 00A08DE5 		str	sl, [sp, #0]
 3966 2374 FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3967              		.loc 1 389 0
 3968 2378 02C0A0E3 		mov	ip, #2
 3969 237c 2110A0E3 		mov	r1, #33
 3970 2380 2520A0E3 		mov	r2, #37
 3971 2384 3030A0E3 		mov	r3, #48
 3972 2388 0600A0E1 		mov	r0, r6
 3973 238c 00C08DE5 		str	ip, [sp, #0]
 3974 2390 04808DE5 		str	r8, [sp, #4]
 3975 2394 FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3976              		.loc 1 390 0
 3977 2398 1C0096E5 		ldr	r0, [r6, #28]
 3978 239c FEFFFFEB 		bl	_txe_mutex_put
 3979              	.LBE75:
 3980              	.LBE74:
1017:../uvc.c      **** 							break;
 3981              		.loc 1 1017 0
 3982 23a0 FFC0A0E3 		mov	ip, #255
 3983 23a4 0C60A0E1 		mov	r6, ip
 3984 23a8 0A80A0E1 		mov	r8, sl
 3985 23ac E4FDFFEA 		b	.L226
 3986              	.LVL286:
 3987              	.L241:
1014:../uvc.c      **** 		  		    switch (getData){
 3988              		.loc 1 1014 0
 3989 23b0 FFC0A0E3 		mov	ip, #255
 3990 23b4 0080A0E1 		mov	r8, r0
 3991 23b8 0C60A0E1 		mov	r6, ip
 3992 23bc E0FDFFEA 		b	.L226
 3993              	.LVL287:
 3994              	.L247:
1085:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3995              		.loc 1 1085 0
 3996 23c0 0000A0E3 		mov	r0, #0
 3997 23c4 0110A0E3 		mov	r1, #1
 3998 23c8 0020A0E1 		mov	r2, r0
 3999 23cc FEFFFFEB 		bl	CyU3PUsbStall
 4000              	.LVL288:
 4001 23d0 94FEFFEA 		b	.L290
 4002              	.LVL289:
 4003              	.L289:
1103:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4004              		.loc 1 1103 0
 4005 23d4 0110A0E3 		mov	r1, #1
 4006 23d8 0020A0E1 		mov	r2, r0
 4007 23dc FEFFFFEB 		bl	CyU3PUsbStall
 4008 23e0 90FEFFEA 		b	.L290
 4009              	.LVL290:
 4010              	.L299:
1118:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4011              		.loc 1 1118 0
 4012 23e4 08E0A0E3 		mov	lr, #8
 4013 23e8 00C0A0E3 		mov	ip, #0
 4014 23ec 0600A0E1 		mov	r0, r6
 4015 23f0 2310A0E3 		mov	r1, #35
 4016 23f4 0B20A0E1 		mov	r2, fp
 4017 23f8 00E08DE5 		str	lr, [sp, #0]
 4018 23fc 04C08DE5 		str	ip, [sp, #4]
 4019 2400 FEFFFFEB 		bl	cmdSet
 4020 2404 5DFEFFEA 		b	.L292
 4021              	.L298:
1116:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4022              		.loc 1 1116 0
 4023 2408 0480A0E3 		mov	r8, #4
 4024 240c 00E0A0E3 		mov	lr, #0
 4025 2410 0600A0E1 		mov	r0, r6
 4026 2414 2310A0E3 		mov	r1, #35
 4027 2418 0B20A0E1 		mov	r2, fp
 4028 241c 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4029 2420 FEFFFFEB 		bl	cmdSet
 4030 2424 55FEFFEA 		b	.L292
 4031              	.L301:
 4032              		.align	2
 4033              	.L300:
 4034 2428 00000000 		.word	bRequest
 4035 242c 00000000 		.word	.LANCHOR1
 4036 2430 00000000 		.word	.LANCHOR0
 4037 2434 10040000 		.word	.LC25
 4038 2438 34040000 		.word	.LC26
 4039 243c 5C000000 		.word	.LANCHOR0+92
 4040 2440 00000000 		.word	cmdQu
 4041 2444 C4030000 		.word	.LC23
 4042 2448 FFFF0000 		.word	65535
 4043 244c EC030000 		.word	.LC24
 4044              		.cfi_endproc
 4045              	.LFE3:
 4047              		.align	2
 4048              		.global	UVCAppEP0Thread_Entry
 4050              	UVCAppEP0Thread_Entry:
 4051              	.LFB24:
3201:../uvc.c      **** {
 4052              		.loc 1 3201 0
 4053              		.cfi_startproc
 4054              		@ args = 0, pretend = 0, frame = 40
 4055              		@ frame_needed = 0, uses_anonymous_args = 0
 4056              	.LVL291:
 4057 2450 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4058              	.LCFI17:
 4059              		.cfi_def_cfa_offset 36
 4060 2454 404B9FE5 		ldr	r4, .L448
 4061              		.cfi_offset 14, -4
 4062              		.cfi_offset 11, -8
 4063              		.cfi_offset 10, -12
 4064              		.cfi_offset 9, -16
 4065              		.cfi_offset 8, -20
 4066              		.cfi_offset 7, -24
 4067              		.cfi_offset 6, -28
 4068              		.cfi_offset 5, -32
 4069              		.cfi_offset 4, -36
 4070 2458 406B9FE5 		ldr	r6, .L448+4
 4071 245c 40AB9FE5 		ldr	sl, .L448+8
 4072 2460 409B9FE5 		ldr	r9, .L448+12
 4073 2464 408B9FE5 		ldr	r8, .L448+16
 4074 2468 407B9FE5 		ldr	r7, .L448+20
 4075 246c 44D04DE2 		sub	sp, sp, #68
 4076              	.LCFI18:
 4077              		.cfi_def_cfa_offset 104
 4078              	.LVL292:
3223:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4079              		.loc 1 3223 0
 4080 2470 0450A0E1 		mov	r5, r4
 4081              	.LVL293:
 4082              	.L428:
 4083 2474 00C0E0E3 		mvn	ip, #0
 4084 2478 1C0B9FE5 		ldr	r0, .L448
 4085 247c 4C10A0E3 		mov	r1, #76
 4086 2480 0120A0E3 		mov	r2, #1
 4087 2484 38308DE2 		add	r3, sp, #56
 4088 2488 00C08DE5 		str	ip, [sp, #0]
 4089 248c FEFFFFEB 		bl	_txe_event_flags_get
 4090 2490 000050E3 		cmp	r0, #0
 4091 2494 3000001A 		bne	.L303
3227:../uvc.c      ****             if (!isUsbConnected)
 4092              		.loc 1 3227 0
 4093 2498 303095E5 		ldr	r3, [r5, #48]
 4094 249c 000053E3 		cmp	r3, #0
 4095 24a0 8900000A 		beq	.L439
 4096              	.L304:
3236:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4097              		.loc 1 3236 0
 4098 24a4 38309DE5 		ldr	r3, [sp, #56]
 4099 24a8 0C0013E3 		tst	r3, #12
 4100 24ac 7200001A 		bne	.L440
 4101              	.L305:
3243:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4102              		.loc 1 3243 0
 4103 24b0 040013E3 		tst	r3, #4
 4104 24b4 1C00000A 		beq	.L306
3245:../uvc.c      ****             	switch ((wIndex >> 8))
 4105              		.loc 1 3245 0
 4106 24b8 B0E0D8E1 		ldrh	lr, [r8, #0]
 4107 24bc 2E24A0E1 		mov	r2, lr, lsr #8
 4108 24c0 030052E3 		cmp	r2, #3
 4109 24c4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4110 24c8 120000EA 		b	.L307
 4111              	.L312:
 4112 24cc 18250000 		.word	.L307
 4113 24d0 FC250000 		.word	.L309
 4114 24d4 DC240000 		.word	.L310
 4115 24d8 38260000 		.word	.L311
 4116              	.L310:
 4117              	.LBB90:
 4118              	.LBB92:
2488:../uvc.c      ****     switch (wValue)
 4119              		.loc 1 2488 0
 4120 24dc B020D9E1 		ldrh	r2, [r9, #0]
 4121 24e0 060C52E3 		cmp	r2, #1536
 4122 24e4 0302000A 		beq	.L318
 4123 24e8 D800008A 		bhi	.L324
 4124 24ec 030C52E3 		cmp	r2, #768
 4125 24f0 FC01000A 		beq	.L316
 4126 24f4 F301008A 		bhi	.L325
 4127 24f8 010C52E3 		cmp	r2, #256
 4128 24fc 8901000A 		beq	.L314
 4129 2500 020C52E3 		cmp	r2, #512
 4130 2504 8301000A 		beq	.L441
 4131              	.L327:
 4132              	.LBE92:
 4133              	.LBE90:
 4134              	.LBB95:
 4135              	.LBB99:
2620:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4136              		.loc 1 2620 0
 4137 2508 A41A9FE5 		ldr	r1, .L448+24
 4138 250c 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4139 2510 0400A0E3 		mov	r0, #4
 4140 2514 FEFFFFEB 		bl	CyU3PDebugPrint
 4141              	.L307:
 4142              	.LBE99:
 4143              	.LBE95:
3266:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4144              		.loc 1 3266 0
 4145 2518 0000A0E3 		mov	r0, #0
 4146 251c 0110A0E3 		mov	r1, #1
 4147 2520 0020A0E1 		mov	r2, r0
 4148 2524 FEFFFFEB 		bl	CyU3PUsbStall
 4149 2528 38309DE5 		ldr	r3, [sp, #56]
 4150              	.L306:
3271:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4151              		.loc 1 3271 0
 4152 252c 080013E3 		tst	r3, #8
 4153 2530 0700000A 		beq	.L368
3275:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4154              		.loc 1 3275 0
 4155 2534 B030D8E1 		ldrh	r3, [r8, #0]
 4156 2538 010053E3 		cmp	r3, #1
 4157 253c 6800000A 		beq	.L369
 4158              	.L370:
 4159              	.LBB104:
 4160              	.LBB110:
3190:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4161              		.loc 1 3190 0
 4162 2540 0000A0E3 		mov	r0, #0
 4163 2544 0110A0E3 		mov	r1, #1
 4164 2548 0020A0E1 		mov	r2, r0
 4165 254c FEFFFFEB 		bl	CyU3PUsbStall
 4166              	.L431:
 4167 2550 38309DE5 		ldr	r3, [sp, #56]
 4168              	.L368:
 4169              	.LBE110:
 4170              	.LBE104:
3286:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4171              		.loc 1 3286 0
 4172 2554 400013E3 		tst	r3, #64
 4173 2558 0100001A 		bne	.L442
 4174              	.L303:
3499:../uvc.c      ****         CyU3PThreadRelinquish ();
 4175              		.loc 1 3499 0
 4176 255c FEFFFFEB 		bl	_txe_thread_relinquish
3500:../uvc.c      ****     }
 4177              		.loc 1 3500 0
 4178 2560 C3FFFFEA 		b	.L428
 4179              	.L442:
3291:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4180              		.loc 1 3291 0
 4181 2564 1800A0E3 		mov	r0, #24
 4182 2568 34108DE2 		add	r1, sp, #52
 4183 256c FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3296:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4184              		.loc 1 3296 0
 4185 2570 34309DE5 		ldr	r3, [sp, #52]
 4186 2574 000053E3 		cmp	r3, #0
 4187 2578 6D00000A 		beq	.L423
3296:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4188              		.loc 1 3296 0 is_stmt 0 discriminator 1
 4189 257c 4336D6E5 		ldrb	r3, [r6, #1603]	@ zero_extendqisi2
 4190 2580 000053E3 		cmp	r3, #0
 4191 2584 F4FFFF1A 		bne	.L303
3298:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4192              		.loc 1 3298 0 is_stmt 1
 4193 2588 00C097E5 		ldr	ip, [r7, #0]
 4194 258c 02B0A0E3 		mov	fp, #2
 4195 2590 00B0CCE5 		strb	fp, [ip, #0]
3299:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4196              		.loc 1 3299 0
 4197 2594 001097E5 		ldr	r1, [r7, #0]
 4198 2598 01B0A0E3 		mov	fp, #1
 4199 259c 01B0C1E5 		strb	fp, [r1, #1]
3300:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4200              		.loc 1 3300 0
 4201 25a0 000097E5 		ldr	r0, [r7, #0]
3304:../uvc.c      **** 					interStabuf.size   = 1024;
 4202              		.loc 1 3304 0
 4203 25a4 01EBA0E3 		mov	lr, #1024	@ movhi
3300:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4204              		.loc 1 3300 0
 4205 25a8 0230C0E5 		strb	r3, [r0, #2]
3301:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4206              		.loc 1 3301 0
 4207 25ac 002097E5 		ldr	r2, [r7, #0]
3310:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4208              		.loc 1 3310 0
 4209 25b0 0010E0E3 		mvn	r1, #0
3301:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4210              		.loc 1 3301 0
 4211 25b4 0330C2E5 		strb	r3, [r2, #3]
3303:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4212              		.loc 1 3303 0
 4213 25b8 00C097E5 		ldr	ip, [r7, #0]
3307:../uvc.c      **** 					interStabuf.count = 4;
 4214              		.loc 1 3307 0
 4215 25bc 0420A0E3 		mov	r2, #4	@ movhi
3310:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4216              		.loc 1 3310 0
 4217 25c0 F0099FE5 		ldr	r0, .L448+28
3307:../uvc.c      **** 					interStabuf.count = 4;
 4218              		.loc 1 3307 0
 4219 25c4 BC22CDE1 		strh	r2, [sp, #44]	@ movhi
3304:../uvc.c      **** 					interStabuf.size   = 1024;
 4220              		.loc 1 3304 0
 4221 25c8 BEE2CDE1 		strh	lr, [sp, #46]	@ movhi
3303:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4222              		.loc 1 3303 0
 4223 25cc 28C08DE5 		str	ip, [sp, #40]
3305:../uvc.c      **** 					interStabuf.status = 0;
 4224              		.loc 1 3305 0
 4225 25d0 B033CDE1 		strh	r3, [sp, #48]	@ movhi
3310:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4226              		.loc 1 3310 0
 4227 25d4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3313:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4228              		.loc 1 3313 0
 4229 25d8 D8099FE5 		ldr	r0, .L448+28
 4230 25dc 28108DE2 		add	r1, sp, #40
 4231 25e0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4232              	.LVL294:
3314:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4233              		.loc 1 3314 0
 4234 25e4 002050E2 		subs	r2, r0, #0
 4235 25e8 9101001A 		bne	.L443
3319:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4236              		.loc 1 3319 0
 4237 25ec AC399FE5 		ldr	r3, .L448+4
 4238 25f0 43B6C3E5 		strb	fp, [r3, #1603]
3499:../uvc.c      ****         CyU3PThreadRelinquish ();
 4239              		.loc 1 3499 0
 4240 25f4 FEFFFFEB 		bl	_txe_thread_relinquish
 4241              	.LVL295:
 4242 25f8 9DFFFFEA 		b	.L428
 4243              	.L309:
 4244              	.LBB117:
 4245              	.LBB100:
2563:../uvc.c      ****     switch (wValue)
 4246              		.loc 1 2563 0
 4247 25fc B020D9E1 		ldrh	r2, [r9, #0]
 4248 2600 060C52E3 		cmp	r2, #1536
 4249 2604 ED00000A 		beq	.L333
 4250 2608 9B00008A 		bhi	.L339
 4251 260c 030C52E3 		cmp	r2, #768
 4252 2610 3801000A 		beq	.L330
 4253 2614 2F01008A 		bhi	.L340
 4254 2618 010C52E3 		cmp	r2, #256
 4255 261c 8001000A 		beq	.L328
 4256 2620 020C52E3 		cmp	r2, #512
 4257 2624 B7FFFF1A 		bne	.L327
 4258              	.LVL296:
2571:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4259              		.loc 1 2571 0
 4260 2628 0100A0E3 		mov	r0, #1
 4261 262c FEFFFFEB 		bl	CTControlHandle
 4262              	.LVL297:
 4263 2630 38309DE5 		ldr	r3, [sp, #56]
 4264 2634 BCFFFFEA 		b	.L306
 4265              	.L311:
 4266              	.LBE100:
 4267              	.LBE117:
 4268              	.LBB118:
 4269              	.LBB123:
2788:../uvc.c      ****     switch (wValue)
 4270              		.loc 1 2788 0
 4271 2638 B030D9E1 		ldrh	r3, [r9, #0]
 4272 263c 090C53E3 		cmp	r3, #2304
 4273 2640 4602000A 		beq	.L354
 4274 2644 9400008A 		bhi	.L363
 4275 2648 010B53E3 		cmp	r3, #1024
 4276 264c 3F02000A 		beq	.L349
 4277 2650 B101008A 		bhi	.L364
 4278 2654 020C53E3 		cmp	r3, #512
 4279 2658 3802000A 		beq	.L347
 4280 265c 030C53E3 		cmp	r3, #768
 4281 2660 1102000A 		beq	.L348
 4282 2664 010C53E3 		cmp	r3, #256
 4283 2668 AAFFFF1A 		bne	.L307
 4284              	.LVL298:
2792:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4285              		.loc 1 2792 0
 4286 266c 1000A0E3 		mov	r0, #16
 4287 2670 FEFFFFEB 		bl	ControlHandle
 4288              	.LVL299:
 4289 2674 38309DE5 		ldr	r3, [sp, #56]
 4290 2678 ABFFFFEA 		b	.L306
 4291              	.L440:
 4292              	.LBE123:
 4293              	.LBE118:
3237:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4294              		.loc 1 3237 0
 4295 267c 38B99FE5 		ldr	fp, .L448+32
 4296 2680 B0C0D9E1 		ldrh	ip, [r9, #0]
 4297 2684 B000D8E1 		ldrh	r0, [r8, #0]
 4298 2688 30199FE5 		ldr	r1, .L448+36
 4299 268c 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4300 2690 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4301 2694 0C008DE5 		str	r0, [sp, #12]
 4302 2698 08C08DE5 		str	ip, [sp, #8]
 4303 269c B0C0D1E1 		ldrh	ip, [r1, #0]
 4304 26a0 4C20D4E5 		ldrb	r2, [r4, #76]	@ zero_extendqisi2
 4305 26a4 04B08DE5 		str	fp, [sp, #4]
 4306 26a8 0400A0E3 		mov	r0, #4
 4307 26ac 10199FE5 		ldr	r1, .L448+40
 4308 26b0 00B0A0E3 		mov	fp, #0
 4309 26b4 00E08DE5 		str	lr, [sp, #0]
 4310 26b8 10C08DE5 		str	ip, [sp, #16]
 4311 26bc 14B08DE5 		str	fp, [sp, #20]
 4312 26c0 FEFFFFEB 		bl	CyU3PDebugPrint
 4313 26c4 38309DE5 		ldr	r3, [sp, #56]
 4314 26c8 78FFFFEA 		b	.L305
 4315              	.L439:
3229:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4316              		.loc 1 3229 0
 4317 26cc FEFFFFEB 		bl	CyU3PUsbGetSpeed
3230:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4318              		.loc 1 3230 0
 4319 26d0 000050E3 		cmp	r0, #0
3229:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4320              		.loc 1 3229 0
 4321 26d4 4C00C5E5 		strb	r0, [r5, #76]
3232:../uvc.c      ****                     isUsbConnected = CyTrue;
 4322              		.loc 1 3232 0
 4323 26d8 0100A013 		movne	r0, #1
 4324 26dc 30008515 		strne	r0, [r5, #48]
 4325 26e0 6FFFFFEA 		b	.L304
 4326              	.L369:
 4327              	.LVL300:
 4328              	.LBB129:
 4329              	.LBB111:
2883:../uvc.c      ****     switch (wValue)
 4330              		.loc 1 2883 0
 4331 26e4 B020D9E1 		ldrh	r2, [r9, #0]
 4332 26e8 030C52E3 		cmp	r2, #768
 4333 26ec 9C00000A 		beq	.L373
 4334 26f0 3200008A 		bhi	.L376
 4335 26f4 010C52E3 		cmp	r2, #256
 4336 26f8 A600000A 		beq	.L371
 4337 26fc 020C52E3 		cmp	r2, #512
 4338 2700 8EFFFF1A 		bne	.L370
2936:../uvc.c      ****             switch (bRequest)
 4339              		.loc 1 2936 0
 4340 2704 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4341 2708 810053E3 		cmp	r3, #129
 4342 270c A600000A 		beq	.L416
 4343 2710 5001008A 		bhi	.L389
 4344 2714 010053E3 		cmp	r3, #1
 4345 2718 AE01000A 		beq	.L444
 4346              	.L395:
3054:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4347              		.loc 1 3054 0
 4348 271c 0000A0E3 		mov	r0, #0
 4349 2720 0110A0E3 		mov	r1, #1
 4350 2724 0020A0E1 		mov	r2, r0
 4351 2728 FEFFFFEB 		bl	CyU3PUsbStall
 4352 272c 38309DE5 		ldr	r3, [sp, #56]
 4353 2730 87FFFFEA 		b	.L368
 4354              	.LVL301:
 4355              	.L423:
 4356              	.LBE111:
 4357              	.LBE129:
3320:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4358              		.loc 1 3320 0
 4359 2734 43E6D6E5 		ldrb	lr, [r6, #1603]	@ zero_extendqisi2
 4360 2738 00005EE3 		cmp	lr, #0
 4361 273c 86FFFF0A 		beq	.L303
3322:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4362              		.loc 1 3322 0
 4363 2740 00C097E5 		ldr	ip, [r7, #0]
 4364 2744 02B0A0E3 		mov	fp, #2
 4365 2748 00B0CCE5 		strb	fp, [ip, #0]
3323:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4366              		.loc 1 3323 0
 4367 274c 001097E5 		ldr	r1, [r7, #0]
 4368 2750 01E0A0E3 		mov	lr, #1
 4369 2754 01E0C1E5 		strb	lr, [r1, #1]
3324:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4370              		.loc 1 3324 0
 4371 2758 000097E5 		ldr	r0, [r7, #0]
3328:../uvc.c      **** 					interStabuf.size   = 1024;
 4372              		.loc 1 3328 0
 4373 275c 01CBA0E3 		mov	ip, #1024	@ movhi
3324:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4374              		.loc 1 3324 0
 4375 2760 0230C0E5 		strb	r3, [r0, #2]
3325:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4376              		.loc 1 3325 0
 4377 2764 002097E5 		ldr	r2, [r7, #0]
3334:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4378              		.loc 1 3334 0
 4379 2768 0010E0E3 		mvn	r1, #0
3325:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4380              		.loc 1 3325 0
 4381 276c 03E0C2E5 		strb	lr, [r2, #3]
3327:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4382              		.loc 1 3327 0
 4383 2770 00B097E5 		ldr	fp, [r7, #0]
3331:../uvc.c      **** 					interStabuf.count = 4;
 4384              		.loc 1 3331 0
 4385 2774 0420A0E3 		mov	r2, #4	@ movhi
3334:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4386              		.loc 1 3334 0
 4387 2778 38089FE5 		ldr	r0, .L448+28
3331:../uvc.c      **** 					interStabuf.count = 4;
 4388              		.loc 1 3331 0
 4389 277c BC22CDE1 		strh	r2, [sp, #44]	@ movhi
3328:../uvc.c      **** 					interStabuf.size   = 1024;
 4390              		.loc 1 3328 0
 4391 2780 BEC2CDE1 		strh	ip, [sp, #46]	@ movhi
3327:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4392              		.loc 1 3327 0
 4393 2784 28B08DE5 		str	fp, [sp, #40]
3329:../uvc.c      **** 					interStabuf.status = 0;
 4394              		.loc 1 3329 0
 4395 2788 B033CDE1 		strh	r3, [sp, #48]	@ movhi
 4396 278c 03B0A0E1 		mov	fp, r3	@ movhi
3334:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4397              		.loc 1 3334 0
 4398 2790 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3337:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4399              		.loc 1 3337 0
 4400 2794 1C089FE5 		ldr	r0, .L448+28
 4401 2798 28108DE2 		add	r1, sp, #40
 4402 279c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4403              	.LVL302:
3338:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4404              		.loc 1 3338 0
 4405 27a0 002050E2 		subs	r2, r0, #0
 4406 27a4 E300001A 		bne	.L445
3344:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4407              		.loc 1 3344 0
 4408 27a8 F0E79FE5 		ldr	lr, .L448+4
3345:../uvc.c      **** 					stiflag = 0xFF;
 4409              		.loc 1 3345 0
 4410 27ac FF30A0E3 		mov	r3, #255
3344:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4411              		.loc 1 3344 0
 4412 27b0 43B6CEE5 		strb	fp, [lr, #1603]
3345:../uvc.c      **** 					stiflag = 0xFF;
 4413              		.loc 1 3345 0
 4414 27b4 3C3084E5 		str	r3, [r4, #60]
3499:../uvc.c      ****         CyU3PThreadRelinquish ();
 4415              		.loc 1 3499 0
 4416 27b8 FEFFFFEB 		bl	_txe_thread_relinquish
 4417              	.LVL303:
 4418 27bc 2CFFFFEA 		b	.L428
 4419              	.LVL304:
 4420              	.L376:
 4421              	.LBB130:
 4422              	.LBB109:
2883:../uvc.c      ****     switch (wValue)
 4423              		.loc 1 2883 0
 4424 27c0 010B52E3 		cmp	r2, #1024
 4425 27c4 4100000A 		beq	.L374
 4426 27c8 050C52E3 		cmp	r2, #1280
 4427 27cc 5BFFFF1A 		bne	.L370
3135:../uvc.c      ****                 switch (bRequest)
 4428              		.loc 1 3135 0
 4429 27d0 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4430 27d4 810052E3 		cmp	r2, #129
 4431 27d8 7300000A 		beq	.L416
 4432 27dc 4901008A 		bhi	.L419
 4433 27e0 010052E3 		cmp	r2, #1
 4434 27e4 55FFFF1A 		bne	.L370
3160:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4435              		.loc 1 3160 0
 4436 27e8 2000A0E3 		mov	r0, #32
 4437 27ec D4179FE5 		ldr	r1, .L448+44
 4438 27f0 3E208DE2 		add	r2, sp, #62
 4439 27f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4440              	.LVL305:
3162:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4441              		.loc 1 3162 0
 4442 27f8 000050E3 		cmp	r0, #0
 4443 27fc C901001A 		bne	.L420
3166:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4444              		.loc 1 3166 0
 4445 2800 0020A0E3 		mov	r2, #0
 4446 2804 90079FE5 		ldr	r0, .L448
 4447              	.LVL306:
 4448 2808 8010A0E3 		mov	r1, #128
 4449 280c FEFFFFEB 		bl	_txe_event_flags_set
 4450              	.LVL307:
3167:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4451              		.loc 1 3167 0
 4452 2810 002050E2 		subs	r2, r0, #0
3173:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 4453              		.loc 1 3173 0
 4454 2814 F0B0A003 		moveq	fp, #240
 4455 2818 3CB08505 		streq	fp, [r5, #60]
3167:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4456              		.loc 1 3167 0
 4457 281c 0200000A 		beq	.L422
3169:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 4458              		.loc 1 3169 0
 4459 2820 A4179FE5 		ldr	r1, .L448+48
 4460 2824 0400A0E3 		mov	r0, #4
 4461              	.LVL308:
 4462 2828 FEFFFFEB 		bl	CyU3PDebugPrint
 4463              	.LVL309:
 4464              	.L422:
3176:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 4465              		.loc 1 3176 0
 4466 282c 81C0D4E5 		ldrb	ip, [r4, #129]	@ zero_extendqisi2
 4467 2830 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4468 2834 BE23DDE1 		ldrh	r2, [sp, #62]
 4469              	.LVL310:
 4470 2838 0400A0E3 		mov	r0, #4
 4471 283c 8C179FE5 		ldr	r1, .L448+52
 4472 2840 00C08DE5 		str	ip, [sp, #0]
 4473 2844 FEFFFFEB 		bl	CyU3PDebugPrint
 4474 2848 38309DE5 		ldr	r3, [sp, #56]
 4475 284c 40FFFFEA 		b	.L368
 4476              	.LVL311:
 4477              	.L324:
 4478              	.LBE109:
 4479              	.LBE130:
 4480              	.LBB131:
 4481              	.LBB93:
2488:../uvc.c      ****     switch (wValue)
 4482              		.loc 1 2488 0
 4483 2850 0A0C52E3 		cmp	r2, #2560
 4484 2854 1301000A 		beq	.L321
 4485 2858 0801008A 		bhi	.L326
 4486 285c 070C52E3 		cmp	r2, #1792
 4487 2860 0201000A 		beq	.L319
 4488 2864 020B52E3 		cmp	r2, #2048
 4489 2868 26FFFF1A 		bne	.L327
 4490              	.LVL312:
2519:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4491              		.loc 1 2519 0
 4492 286c 0700A0E3 		mov	r0, #7
 4493 2870 FEFFFFEB 		bl	ControlHandle
 4494              	.LVL313:
 4495 2874 38309DE5 		ldr	r3, [sp, #56]
 4496 2878 2BFFFFEA 		b	.L306
 4497              	.L339:
 4498              	.LBE93:
 4499              	.LBE131:
 4500              	.LBB132:
 4501              	.LBB98:
2563:../uvc.c      ****     switch (wValue)
 4502              		.loc 1 2563 0
 4503 287c 090C52E3 		cmp	r2, #2304
 4504 2880 4401000A 		beq	.L335
 4505 2884 3901008A 		bhi	.L341
 4506 2888 070C52E3 		cmp	r2, #1792
 4507 288c 2B01000A 		beq	.L334
 4508 2890 020B52E3 		cmp	r2, #2048
 4509 2894 1BFFFF1A 		bne	.L327
 4510 2898 23FFFFEA 		b	.L306
 4511              	.L363:
 4512              	.LBE98:
 4513              	.LBE132:
 4514              	.LBB133:
 4515              	.LBB124:
2788:../uvc.c      ****     switch (wValue)
 4516              		.loc 1 2788 0
 4517 289c 0F0C53E3 		cmp	r3, #3840
 4518 28a0 9C01000A 		beq	.L358
 4519 28a4 4900008A 		bhi	.L366
 4520 28a8 0B0C53E3 		cmp	r3, #2816
 4521 28ac 9501000A 		beq	.L356
 4522 28b0 0D0C53E3 		cmp	r3, #3328
 4523 28b4 8F01000A 		beq	.L357
 4524 28b8 0A0C53E3 		cmp	r3, #2560
 4525 28bc 15FFFF1A 		bne	.L307
 4526              	.LVL314:
2829:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4527              		.loc 1 2829 0
 4528 28c0 1900A0E3 		mov	r0, #25
 4529 28c4 FEFFFFEB 		bl	ControlHandle
 4530              	.LVL315:
 4531 28c8 38309DE5 		ldr	r3, [sp, #56]
 4532 28cc 16FFFFEA 		b	.L306
 4533              	.LVL316:
 4534              	.L374:
 4535              	.LBE124:
 4536              	.LBE133:
 4537              	.LBB134:
 4538              	.LBB112:
3060:../uvc.c      ****                 switch (bRequest)
 4539              		.loc 1 3060 0
 4540 28d0 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4541 28d4 810052E3 		cmp	r2, #129
 4542 28d8 2600000A 		beq	.L405
 4543 28dc 9E00008A 		bhi	.L408
 4544 28e0 010052E3 		cmp	r2, #1
 4545 28e4 15FFFF1A 		bne	.L370
3085:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4546              		.loc 1 3085 0
 4547 28e8 2000A0E3 		mov	r0, #32
 4548 28ec D4169FE5 		ldr	r1, .L448+44
 4549 28f0 3E208DE2 		add	r2, sp, #62
 4550 28f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4551              	.LVL317:
3087:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4552              		.loc 1 3087 0
 4553 28f8 000050E3 		cmp	r0, #0
 4554 28fc 13FFFF1A 		bne	.L431
3106:../uvc.c      ****                            switch (glCommitCtrl[1])
 4555              		.loc 1 3106 0
 4556 2900 8130D5E5 		ldrb	r3, [r5, #129]	@ zero_extendqisi2
 4557 2904 010053E3 		cmp	r3, #1
 4558 2908 9801000A 		beq	.L412
 4559 290c 020053E3 		cmp	r3, #2
 4560 2910 0900001A 		bne	.L411
3114:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*
 4561              		.loc 1 3114 0
 4562 2914 3010A0E3 		mov	r1, #48
 4563 2918 0020A0E3 		mov	r2, #0
 4564 291c 5230A0E3 		mov	r3, #82
 4565 2920 0B00A0E3 		mov	r0, #11
 4566              	.LVL318:
 4567 2924 FEFFFFEB 		bl	SensorSetIrisControl
3116:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
 4568              		.loc 1 3116 0
 4569 2928 0400A0E3 		mov	r0, #4
 4570 292c A0169FE5 		ldr	r1, .L448+56
 4571 2930 0B20A0E3 		mov	r2, #11
 4572 2934 0030A0E3 		mov	r3, #0
 4573 2938 FEFFFFEB 		bl	CyU3PDebugPrint
 4574              	.L411:
3121:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 4575              		.loc 1 3121 0
 4576 293c 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
3123:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 4577              		.loc 1 3123 0
 4578 2940 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4579 2944 BE23DDE1 		ldrh	r2, [sp, #62]
 4580              	.LVL319:
 4581 2948 0400A0E3 		mov	r0, #4
 4582 294c 84169FE5 		ldr	r1, .L448+60
3121:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 4583              		.loc 1 3121 0
 4584 2950 A1E0C4E5 		strb	lr, [r4, #161]
3123:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 4585              		.loc 1 3123 0
 4586 2954 00E08DE5 		str	lr, [sp, #0]
 4587 2958 FEFFFFEB 		bl	CyU3PDebugPrint
 4588 295c 38309DE5 		ldr	r3, [sp, #56]
 4589 2960 FBFEFFEA 		b	.L368
 4590              	.LVL320:
 4591              	.L373:
3010:../uvc.c      ****                 switch (bRequest)
 4592              		.loc 1 3010 0
 4593 2964 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4594 2968 830052E3 		cmp	r2, #131
 4595 296c A700008A 		bhi	.L400
 4596 2970 810052E3 		cmp	r2, #129
 4597 2974 8300003A 		bcc	.L446
 4598              	.L405:
3072:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4599              		.loc 1 3072 0
 4600 2978 4C20D4E5 		ldrb	r2, [r4, #76]	@ zero_extendqisi2
3074:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4601              		.loc 1 3074 0
 4602 297c 0B00A0E3 		mov	r0, #11
3072:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4603              		.loc 1 3072 0
 4604 2980 030052E3 		cmp	r2, #3
3074:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4605              		.loc 1 3074 0
 4606 2984 50169F05 		ldreq	r1, .L448+64
3078:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4607              		.loc 1 3078 0
 4608 2988 50169F15 		ldrne	r1, .L448+68
 4609 298c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4610 2990 38309DE5 		ldr	r3, [sp, #56]
 4611 2994 EEFEFFEA 		b	.L368
 4612              	.L371:
2886:../uvc.c      ****             switch (bRequest)
 4613              		.loc 1 2886 0
 4614 2998 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4615 299c 830052E3 		cmp	r2, #131
 4616 29a0 3500008A 		bhi	.L382
 4617 29a4 810052E3 		cmp	r2, #129
 4618 29a8 1100003A 		bcc	.L447
 4619              	.L416:
3149:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4620              		.loc 1 3149 0
 4621 29ac 1A00A0E3 		mov	r0, #26
 4622 29b0 2C169FE5 		ldr	r1, .L448+72
 4623 29b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4624 29b8 38309DE5 		ldr	r3, [sp, #56]
 4625 29bc E4FEFFEA 		b	.L368
 4626              	.LVL321:
 4627              	.L333:
 4628              	.LBE112:
 4629              	.LBE134:
 4630              	.LBB135:
 4631              	.LBB101:
2589:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4632              		.loc 1 2589 0
 4633 29c0 0500A0E3 		mov	r0, #5
 4634 29c4 FEFFFFEB 		bl	CTControlHandle
 4635              	.LVL322:
 4636 29c8 38309DE5 		ldr	r3, [sp, #56]
 4637 29cc D6FEFFEA 		b	.L306
 4638              	.L366:
 4639              	.LBE101:
 4640              	.LBE135:
 4641              	.LBB136:
 4642              	.LBB122:
2788:../uvc.c      ****     switch (wValue)
 4643              		.loc 1 2788 0
 4644 29d0 110C53E3 		cmp	r3, #4352
 4645 29d4 FB00000A 		beq	.L360
 4646 29d8 3600008A 		bhi	.L367
 4647 29dc 010A53E3 		cmp	r3, #4096
 4648 29e0 CCFEFF1A 		bne	.L307
 4649              	.LVL323:
2851:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4650              		.loc 1 2851 0
 4651 29e4 1F00A0E3 		mov	r0, #31
 4652 29e8 FEFFFFEB 		bl	ControlHandle
 4653              	.LVL324:
 4654 29ec 38309DE5 		ldr	r3, [sp, #56]
 4655 29f0 CDFEFFEA 		b	.L306
 4656              	.LVL325:
 4657              	.L447:
 4658              	.LBE122:
 4659              	.LBE136:
 4660              	.LBB137:
 4661              	.LBB108:
2886:../uvc.c      ****             switch (bRequest)
 4662              		.loc 1 2886 0
 4663 29f4 010052E3 		cmp	r2, #1
 4664 29f8 47FFFF1A 		bne	.L395
2911:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4665              		.loc 1 2911 0
 4666 29fc 2000A0E3 		mov	r0, #32
 4667 2a00 C0159FE5 		ldr	r1, .L448+44
 4668 2a04 3E208DE2 		add	r2, sp, #62
 4669 2a08 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4670              	.LVL326:
2913:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4671              		.loc 1 2913 0
 4672 2a0c 000050E3 		cmp	r0, #0
 4673 2a10 CEFEFF1A 		bne	.L431
2921:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4674              		.loc 1 2921 0
 4675 2a14 84C0D5E5 		ldrb	ip, [r5, #132]	@ zero_extendqisi2
2919:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4676              		.loc 1 2919 0
 4677 2a18 82B0D5E5 		ldrb	fp, [r5, #130]	@ zero_extendqisi2
2922:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4678              		.loc 1 2922 0
 4679 2a1c 8500D5E5 		ldrb	r0, [r5, #133]	@ zero_extendqisi2
 4680              	.LVL327:
2921:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4681              		.loc 1 2921 0
 4682 2a20 1CC08DE5 		str	ip, [sp, #28]
2919:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4683              		.loc 1 2919 0
 4684 2a24 12B6C6E5 		strb	fp, [r6, #1554]
2921:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4685              		.loc 1 2921 0
 4686 2a28 1CB09DE5 		ldr	fp, [sp, #28]
2923:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4687              		.loc 1 2923 0
 4688 2a2c 8610D5E5 		ldrb	r1, [r5, #134]	@ zero_extendqisi2
2922:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4689              		.loc 1 2922 0
 4690 2a30 20008DE5 		str	r0, [sp, #32]
2921:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4691              		.loc 1 2921 0
 4692 2a34 14B6C6E5 		strb	fp, [r6, #1556]
2922:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4693              		.loc 1 2922 0
 4694 2a38 20B09DE5 		ldr	fp, [sp, #32]
2923:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4695              		.loc 1 2923 0
 4696 2a3c 24108DE5 		str	r1, [sp, #36]
2920:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4697              		.loc 1 2920 0
 4698 2a40 83E0D5E5 		ldrb	lr, [r5, #131]	@ zero_extendqisi2
2924:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4699              		.loc 1 2924 0
 4700 2a44 87C0D5E5 		ldrb	ip, [r5, #135]	@ zero_extendqisi2
2922:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4701              		.loc 1 2922 0
 4702 2a48 15B6C6E5 		strb	fp, [r6, #1557]
2923:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4703              		.loc 1 2923 0
 4704 2a4c 24B09DE5 		ldr	fp, [sp, #36]
2925:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d\r\n", readCount
 4705              		.loc 1 2925 0
 4706 2a50 8030D5E5 		ldrb	r3, [r5, #128]	@ zero_extendqisi2
 4707 2a54 BE23DDE1 		ldrh	r2, [sp, #62]
 4708              	.LVL328:
 4709 2a58 0400A0E3 		mov	r0, #4
 4710 2a5c 84159FE5 		ldr	r1, .L448+76
2920:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4711              		.loc 1 2920 0
 4712 2a60 13E6C6E5 		strb	lr, [r6, #1555]
2923:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4713              		.loc 1 2923 0
 4714 2a64 16B6C6E5 		strb	fp, [r6, #1558]
2924:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4715              		.loc 1 2924 0
 4716 2a68 17C6C6E5 		strb	ip, [r6, #1559]
2925:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d\r\n", readCount
 4717              		.loc 1 2925 0
 4718 2a6c 00E08DE5 		str	lr, [sp, #0]
 4719 2a70 FEFFFFEB 		bl	CyU3PDebugPrint
 4720 2a74 38309DE5 		ldr	r3, [sp, #56]
 4721 2a78 B5FEFFEA 		b	.L368
 4722              	.LVL329:
 4723              	.L382:
2886:../uvc.c      ****             switch (bRequest)
 4724              		.loc 1 2886 0
 4725 2a7c 860052E3 		cmp	r2, #134
 4726 2a80 3900000A 		beq	.L434
 4727 2a84 870052E3 		cmp	r2, #135
 4728 2a88 C7FFFF0A 		beq	.L416
 4729              	.L438:
3010:../uvc.c      ****                 switch (bRequest)
 4730              		.loc 1 3010 0
 4731 2a8c 850052E3 		cmp	r2, #133
 4732 2a90 21FFFF1A 		bne	.L395
 4733              	.L406:
3069:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4734              		.loc 1 3069 0
 4735 2a94 50159FE5 		ldr	r1, .L448+80
 4736 2a98 0200A0E3 		mov	r0, #2
3067:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4737              		.loc 1 3067 0
 4738 2a9c 1A30A0E3 		mov	r3, #26
 4739              	.L432:
3142:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4740              		.loc 1 3142 0
 4741 2aa0 5C30C4E5 		strb	r3, [r4, #92]
3143:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4742              		.loc 1 3143 0
 4743 2aa4 0030A0E3 		mov	r3, #0
 4744 2aa8 5D30C4E5 		strb	r3, [r4, #93]
3144:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4745              		.loc 1 3144 0
 4746 2aac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4747 2ab0 38309DE5 		ldr	r3, [sp, #56]
 4748 2ab4 A6FEFFEA 		b	.L368
 4749              	.LVL330:
 4750              	.L367:
 4751              	.LBE108:
 4752              	.LBE137:
 4753              	.LBB138:
 4754              	.LBB125:
2788:../uvc.c      ****     switch (wValue)
 4755              		.loc 1 2788 0
 4756 2ab8 120C53E3 		cmp	r3, #4608
 4757 2abc 0901000A 		beq	.L361
 4758 2ac0 130C53E3 		cmp	r3, #4864
 4759 2ac4 93FEFF1A 		bne	.L307
 4760              	.LVL331:
2863:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 4761              		.loc 1 2863 0
 4762 2ac8 2600A0E3 		mov	r0, #38
 4763 2acc FEFFFFEB 		bl	ControlHandle
 4764              	.LVL332:
 4765 2ad0 38309DE5 		ldr	r3, [sp, #56]
 4766 2ad4 94FEFFEA 		b	.L306
 4767              	.L340:
 4768              	.LBE125:
 4769              	.LBE138:
 4770              	.LBB139:
 4771              	.LBB97:
2563:../uvc.c      ****     switch (wValue)
 4772              		.loc 1 2563 0
 4773 2ad8 010B52E3 		cmp	r2, #1024
 4774 2adc 0900000A 		beq	.L331
 4775 2ae0 050C52E3 		cmp	r2, #1280
 4776 2ae4 87FEFF1A 		bne	.L327
 4777              	.LVL333:
2585:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4778              		.loc 1 2585 0
 4779 2ae8 0400A0E3 		mov	r0, #4
 4780 2aec FEFFFFEB 		bl	CTControlHandle
 4781              	.LVL334:
 4782 2af0 38309DE5 		ldr	r3, [sp, #56]
 4783 2af4 8CFEFFEA 		b	.L306
 4784              	.L330:
 4785              	.LVL335:
2575:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4786              		.loc 1 2575 0
 4787 2af8 0200A0E3 		mov	r0, #2
 4788 2afc FEFFFFEB 		bl	CTControlHandle
 4789              	.LVL336:
 4790 2b00 38309DE5 		ldr	r3, [sp, #56]
 4791 2b04 88FEFFEA 		b	.L306
 4792              	.L331:
 4793              	.LVL337:
2580:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4794              		.loc 1 2580 0
 4795 2b08 0300A0E3 		mov	r0, #3
 4796 2b0c FEFFFFEB 		bl	CTControlHandle
 4797              	.LVL338:
 4798 2b10 38309DE5 		ldr	r3, [sp, #56]
 4799 2b14 84FEFFEA 		b	.L306
 4800              	.L441:
 4801              	.LVL339:
 4802              	.LBE97:
 4803              	.LBE139:
 4804              	.LBB140:
 4805              	.LBB91:
2496:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4806              		.loc 1 2496 0
 4807 2b18 0100A0E3 		mov	r0, #1
 4808 2b1c FEFFFFEB 		bl	ControlHandle
 4809              	.LVL340:
 4810 2b20 38309DE5 		ldr	r3, [sp, #56]
 4811 2b24 80FEFFEA 		b	.L306
 4812              	.L314:
 4813              	.LVL341:
2492:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4814              		.loc 1 2492 0
 4815 2b28 0000A0E3 		mov	r0, #0
 4816 2b2c FEFFFFEB 		bl	ControlHandle
 4817              	.LVL342:
 4818 2b30 38309DE5 		ldr	r3, [sp, #56]
 4819 2b34 7CFEFFEA 		b	.L306
 4820              	.LVL343:
 4821              	.L445:
 4822              	.LBE91:
 4823              	.LBE140:
3340:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4824              		.loc 1 3340 0
 4825 2b38 0400A0E3 		mov	r0, #4
 4826              	.LVL344:
 4827 2b3c AC149FE5 		ldr	r1, .L448+84
 4828 2b40 FEFFFFEB 		bl	CyU3PDebugPrint
 4829              	.LVL345:
 4830              	.L427:
 4831              	.LBB141:
 4832              	.LBB142:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4833              		.loc 1 1251 0
 4834 2b44 A8149FE5 		ldr	r1, .L448+88
 4835 2b48 0400A0E3 		mov	r0, #4
 4836 2b4c FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 4837              		.loc 1 1252 0
 4838 2b50 FA0FA0E3 		mov	r0, #1000
 4839 2b54 FEFFFFEB 		bl	_tx_thread_sleep
 4840 2b58 F9FFFFEA 		b	.L427
 4841              	.LVL346:
 4842              	.L408:
 4843              	.LBE142:
 4844              	.LBE141:
 4845              	.LBB143:
 4846              	.LBB113:
3060:../uvc.c      ****                 switch (bRequest)
 4847              		.loc 1 3060 0
 4848 2b5c 850052E3 		cmp	r2, #133
 4849 2b60 CBFFFF0A 		beq	.L406
 4850 2b64 860052E3 		cmp	r2, #134
 4851 2b68 74FEFF1A 		bne	.L370
 4852              	.L434:
3064:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4853              		.loc 1 3064 0
 4854 2b6c 0300A0E1 		mov	r0, r3
 4855              	.L430:
2939:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4856              		.loc 1 2939 0
 4857 2b70 0330A0E3 		mov	r3, #3
2940:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4858              		.loc 1 2940 0
 4859 2b74 70149FE5 		ldr	r1, .L448+80
2939:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4860              		.loc 1 2939 0
 4861 2b78 5C30C4E5 		strb	r3, [r4, #92]
2940:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4862              		.loc 1 2940 0
 4863 2b7c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4864 2b80 38309DE5 		ldr	r3, [sp, #56]
 4865 2b84 72FEFFEA 		b	.L368
 4866              	.L446:
3010:../uvc.c      ****                 switch (bRequest)
 4867              		.loc 1 3010 0
 4868 2b88 010052E3 		cmp	r2, #1
 4869 2b8c E2FEFF1A 		bne	.L395
3035:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4870              		.loc 1 3035 0
 4871 2b90 2000A0E3 		mov	r0, #32
 4872 2b94 2C149FE5 		ldr	r1, .L448+44
 4873 2b98 3E208DE2 		add	r2, sp, #62
 4874 2b9c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4875              	.LVL347:
3037:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4876              		.loc 1 3037 0
 4877 2ba0 000050E3 		cmp	r0, #0
 4878 2ba4 69FEFF1A 		bne	.L431
3045:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4879              		.loc 1 3045 0
 4880 2ba8 83C0D5E5 		ldrb	ip, [r5, #131]	@ zero_extendqisi2
3044:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4881              		.loc 1 3044 0
 4882 2bac 82B0D5E5 		ldrb	fp, [r5, #130]	@ zero_extendqisi2
3046:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4883              		.loc 1 3046 0
 4884 2bb0 8400D5E5 		ldrb	r0, [r5, #132]	@ zero_extendqisi2
 4885              	.LVL348:
3045:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4886              		.loc 1 3045 0
 4887 2bb4 1CC08DE5 		str	ip, [sp, #28]
3044:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4888              		.loc 1 3044 0
 4889 2bb8 2EB6C6E5 		strb	fp, [r6, #1582]
3045:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4890              		.loc 1 3045 0
 4891 2bbc 1CB09DE5 		ldr	fp, [sp, #28]
3047:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4892              		.loc 1 3047 0
 4893 2bc0 8510D5E5 		ldrb	r1, [r5, #133]	@ zero_extendqisi2
3046:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4894              		.loc 1 3046 0
 4895 2bc4 20008DE5 		str	r0, [sp, #32]
3045:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4896              		.loc 1 3045 0
 4897 2bc8 2FB6C6E5 		strb	fp, [r6, #1583]
3046:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4898              		.loc 1 3046 0
 4899 2bcc 20B09DE5 		ldr	fp, [sp, #32]
3047:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4900              		.loc 1 3047 0
 4901 2bd0 24108DE5 		str	r1, [sp, #36]
3043:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4902              		.loc 1 3043 0
 4903 2bd4 81E0D5E5 		ldrb	lr, [r5, #129]	@ zero_extendqisi2
3048:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4904              		.loc 1 3048 0
 4905 2bd8 86C0D5E5 		ldrb	ip, [r5, #134]	@ zero_extendqisi2
3046:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4906              		.loc 1 3046 0
 4907 2bdc 30B6C6E5 		strb	fp, [r6, #1584]
3047:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4908              		.loc 1 3047 0
 4909 2be0 24B09DE5 		ldr	fp, [sp, #36]
3050:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 4910              		.loc 1 3050 0
 4911 2be4 8030D5E5 		ldrb	r3, [r5, #128]	@ zero_extendqisi2
 4912 2be8 BE23DDE1 		ldrh	r2, [sp, #62]
 4913              	.LVL349:
 4914 2bec 0400A0E3 		mov	r0, #4
 4915 2bf0 00149FE5 		ldr	r1, .L448+92
3043:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4916              		.loc 1 3043 0
 4917 2bf4 2DE6C6E5 		strb	lr, [r6, #1581]
3047:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4918              		.loc 1 3047 0
 4919 2bf8 31B6C6E5 		strb	fp, [r6, #1585]
3048:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4920              		.loc 1 3048 0
 4921 2bfc 32C6C6E5 		strb	ip, [r6, #1586]
3050:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 4922              		.loc 1 3050 0
 4923 2c00 00E08DE5 		str	lr, [sp, #0]
 4924 2c04 FEFFFFEB 		bl	CyU3PDebugPrint
 4925 2c08 38309DE5 		ldr	r3, [sp, #56]
 4926 2c0c 50FEFFEA 		b	.L368
 4927              	.LVL350:
 4928              	.L400:
3010:../uvc.c      ****                 switch (bRequest)
 4929              		.loc 1 3010 0
 4930 2c10 860052E3 		cmp	r2, #134
 4931 2c14 D4FFFF0A 		beq	.L434
 4932 2c18 870052E3 		cmp	r2, #135
 4933 2c1c 9AFFFF1A 		bne	.L438
 4934 2c20 54FFFFEA 		b	.L405
 4935              	.LVL351:
 4936              	.L328:
 4937              	.LBE113:
 4938              	.LBE143:
 4939              	.LBB144:
 4940              	.LBB102:
2567:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4941              		.loc 1 2567 0
 4942 2c24 0000A0E3 		mov	r0, #0
 4943 2c28 FEFFFFEB 		bl	CTControlHandle
 4944              	.LVL352:
 4945 2c2c 38309DE5 		ldr	r3, [sp, #56]
 4946 2c30 3DFEFFEA 		b	.L306
 4947              	.LVL353:
 4948              	.L443:
 4949              	.LBE102:
 4950              	.LBE144:
3316:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4951              		.loc 1 3316 0
 4952 2c34 0400A0E3 		mov	r0, #4
 4953              	.LVL354:
 4954 2c38 B0139FE5 		ldr	r1, .L448+84
 4955 2c3c FEFFFFEB 		bl	CyU3PDebugPrint
 4956              	.LVL355:
 4957              	.L425:
 4958              	.LBB145:
 4959              	.LBB146:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4960              		.loc 1 1251 0
 4961 2c40 AC139FE5 		ldr	r1, .L448+88
 4962 2c44 0400A0E3 		mov	r0, #4
 4963 2c48 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 4964              		.loc 1 1252 0
 4965 2c4c FA0FA0E3 		mov	r0, #1000
 4966 2c50 FEFFFFEB 		bl	_tx_thread_sleep
 4967 2c54 F9FFFFEA 		b	.L425
 4968              	.LVL356:
 4969              	.L389:
 4970              	.LBE146:
 4971              	.LBE145:
 4972              	.LBB147:
 4973              	.LBB107:
2936:../uvc.c      ****             switch (bRequest)
 4974              		.loc 1 2936 0
 4975 2c58 850053E3 		cmp	r3, #133
 4976 2c5c 8CFFFF0A 		beq	.L406
 4977 2c60 860053E3 		cmp	r3, #134
 4978 2c64 ACFEFF1A 		bne	.L395
 4979              	.L435:
2940:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4980              		.loc 1 2940 0
 4981 2c68 0100A0E3 		mov	r0, #1
 4982 2c6c BFFFFFEA 		b	.L430
 4983              	.LVL357:
 4984              	.L319:
 4985              	.LBE107:
 4986              	.LBE147:
 4987              	.LBB148:
 4988              	.LBB94:
2515:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4989              		.loc 1 2515 0
 4990 2c70 0600A0E3 		mov	r0, #6
 4991 2c74 FEFFFFEB 		bl	ControlHandle
 4992              	.LVL358:
 4993 2c78 38309DE5 		ldr	r3, [sp, #56]
 4994 2c7c 2AFEFFEA 		b	.L306
 4995              	.L326:
2488:../uvc.c      ****     switch (wValue)
 4996              		.loc 1 2488 0
 4997 2c80 0D0C52E3 		cmp	r2, #3328
 4998 2c84 0700000A 		beq	.L321
 4999 2c88 0E0C52E3 		cmp	r2, #3584
 5000 2c8c 0900000A 		beq	.L323
 5001 2c90 030B52E3 		cmp	r2, #3072
 5002 2c94 1BFEFF1A 		bne	.L327
 5003              	.LVL359:
2529:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 5004              		.loc 1 2529 0
 5005 2c98 0B00A0E3 		mov	r0, #11
 5006 2c9c FEFFFFEB 		bl	ControlHandle
 5007              	.LVL360:
 5008 2ca0 38309DE5 		ldr	r3, [sp, #56]
 5009 2ca4 20FEFFEA 		b	.L306
 5010              	.L321:
 5011              	.LVL361:
2525:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 5012              		.loc 1 2525 0
 5013 2ca8 0900A0E3 		mov	r0, #9
 5014 2cac FEFFFFEB 		bl	ControlHandle
 5015              	.LVL362:
 5016 2cb0 38309DE5 		ldr	r3, [sp, #56]
 5017 2cb4 1CFEFFEA 		b	.L306
 5018              	.L323:
 5019              	.LVL363:
2533:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 5020              		.loc 1 2533 0
 5021 2cb8 0E00A0E3 		mov	r0, #14
 5022 2cbc FEFFFFEB 		bl	ControlHandle
 5023              	.LVL364:
 5024 2cc0 38309DE5 		ldr	r3, [sp, #56]
 5025 2cc4 18FEFFEA 		b	.L306
 5026              	.L325:
2488:../uvc.c      ****     switch (wValue)
 5027              		.loc 1 2488 0
 5028 2cc8 010B52E3 		cmp	r2, #1024
 5029 2ccc 16FEFF0A 		beq	.L306
 5030 2cd0 050C52E3 		cmp	r2, #1280
 5031 2cd4 0BFEFF1A 		bne	.L327
 5032              	.LVL365:
2507:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 5033              		.loc 1 2507 0
 5034 2cd8 0400A0E3 		mov	r0, #4
 5035 2cdc FEFFFFEB 		bl	ControlHandle
 5036              	.LVL366:
 5037 2ce0 38309DE5 		ldr	r3, [sp, #56]
 5038 2ce4 10FEFFEA 		b	.L306
 5039              	.L316:
 5040              	.LVL367:
2500:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 5041              		.loc 1 2500 0
 5042 2ce8 0200A0E3 		mov	r0, #2
 5043 2cec FEFFFFEB 		bl	ControlHandle
 5044              	.LVL368:
 5045 2cf0 38309DE5 		ldr	r3, [sp, #56]
 5046 2cf4 0CFEFFEA 		b	.L306
 5047              	.L318:
 5048              	.LVL369:
2511:../uvc.c      ****      		ControlHandle(HueCtlID5);
 5049              		.loc 1 2511 0
 5050 2cf8 0500A0E3 		mov	r0, #5
 5051 2cfc FEFFFFEB 		bl	ControlHandle
 5052              	.LVL370:
 5053 2d00 38309DE5 		ldr	r3, [sp, #56]
 5054 2d04 08FEFFEA 		b	.L306
 5055              	.LVL371:
 5056              	.L419:
 5057              	.LBE94:
 5058              	.LBE148:
 5059              	.LBB149:
 5060              	.LBB114:
3135:../uvc.c      ****                 switch (bRequest)
 5061              		.loc 1 3135 0
 5062 2d08 850052E3 		cmp	r2, #133
 5063 2d0c 7200000A 		beq	.L417
 5064 2d10 860052E3 		cmp	r2, #134
 5065 2d14 09FEFF1A 		bne	.L370
 5066 2d18 D2FFFFEA 		b	.L435
 5067              	.LVL372:
 5068              	.L364:
 5069              	.LBE114:
 5070              	.LBE149:
 5071              	.LBB150:
 5072              	.LBB121:
2788:../uvc.c      ****     switch (wValue)
 5073              		.loc 1 2788 0
 5074 2d1c 060C53E3 		cmp	r3, #1536
 5075 2d20 6900000A 		beq	.L351
 5076 2d24 0900008A 		bhi	.L365
 5077 2d28 050C53E3 		cmp	r3, #1280
 5078 2d2c F9FDFF1A 		bne	.L307
 5079              	.LVL373:
2808:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5080              		.loc 1 2808 0
 5081 2d30 1400A0E3 		mov	r0, #20
 5082 2d34 FEFFFFEB 		bl	ControlHandle
 5083              	.LVL374:
 5084 2d38 38309DE5 		ldr	r3, [sp, #56]
 5085 2d3c FAFDFFEA 		b	.L306
 5086              	.L334:
 5087              	.LVL375:
 5088              	.LBE121:
 5089              	.LBE150:
 5090              	.LBB151:
 5091              	.LBB96:
2593:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5092              		.loc 1 2593 0
 5093 2d40 0600A0E3 		mov	r0, #6
 5094 2d44 FEFFFFEB 		bl	CTControlHandle
 5095              	.LVL376:
 5096 2d48 38309DE5 		ldr	r3, [sp, #56]
 5097 2d4c F6FDFFEA 		b	.L306
 5098              	.L365:
 5099              	.LBE96:
 5100              	.LBE151:
 5101              	.LBB152:
 5102              	.LBB126:
2788:../uvc.c      ****     switch (wValue)
 5103              		.loc 1 2788 0
 5104 2d50 070C53E3 		cmp	r3, #1792
 5105 2d54 5800000A 		beq	.L352
 5106 2d58 020B53E3 		cmp	r3, #2048
 5107 2d5c EDFDFF1A 		bne	.L307
 5108              	.LVL377:
2820:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5109              		.loc 1 2820 0
 5110 2d60 1700A0E3 		mov	r0, #23
 5111 2d64 FEFFFFEB 		bl	ControlHandle
 5112              	.LVL378:
 5113 2d68 38309DE5 		ldr	r3, [sp, #56]
 5114 2d6c EEFDFFEA 		b	.L306
 5115              	.L341:
 5116              	.LBE126:
 5117              	.LBE152:
 5118              	.LBB153:
 5119              	.LBB103:
2563:../uvc.c      ****     switch (wValue)
 5120              		.loc 1 2563 0
 5121 2d70 0B0C52E3 		cmp	r2, #2816
 5122 2d74 0F00000A 		beq	.L337
 5123 2d78 030B52E3 		cmp	r2, #3072
 5124 2d7c 0900000A 		beq	.L338
 5125 2d80 0A0C52E3 		cmp	r2, #2560
 5126 2d84 DFFDFF1A 		bne	.L327
 5127              	.LVL379:
2604:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5128              		.loc 1 2604 0
 5129 2d88 0800A0E3 		mov	r0, #8
 5130 2d8c FEFFFFEB 		bl	CTControlHandle
 5131              	.LVL380:
 5132 2d90 38309DE5 		ldr	r3, [sp, #56]
 5133 2d94 E4FDFFEA 		b	.L306
 5134              	.L335:
 5135              	.LVL381:
2599:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5136              		.loc 1 2599 0
 5137 2d98 0700A0E3 		mov	r0, #7
 5138 2d9c FEFFFFEB 		bl	CTControlHandle
 5139              	.LVL382:
 5140 2da0 38309DE5 		ldr	r3, [sp, #56]
 5141 2da4 E0FDFFEA 		b	.L306
 5142              	.L338:
 5143              	.LVL383:
2612:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5144              		.loc 1 2612 0
 5145 2da8 0A00A0E3 		mov	r0, #10
 5146 2dac FEFFFFEB 		bl	CTControlHandle
 5147              	.LVL384:
 5148 2db0 38309DE5 		ldr	r3, [sp, #56]
 5149 2db4 DCFDFFEA 		b	.L306
 5150              	.L337:
 5151              	.LVL385:
2608:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5152              		.loc 1 2608 0
 5153 2db8 0900A0E3 		mov	r0, #9
 5154 2dbc FEFFFFEB 		bl	CTControlHandle
 5155              	.LVL386:
 5156 2dc0 38309DE5 		ldr	r3, [sp, #56]
 5157 2dc4 D8FDFFEA 		b	.L306
 5158              	.L360:
 5159              	.LVL387:
 5160              	.LBE103:
 5161              	.LBE153:
 5162              	.LBB154:
 5163              	.LBB120:
2855:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 5164              		.loc 1 2855 0
 5165 2dc8 2400A0E3 		mov	r0, #36
 5166 2dcc FEFFFFEB 		bl	ControlHandle
 5167              	.LVL388:
 5168 2dd0 38309DE5 		ldr	r3, [sp, #56]
 5169 2dd4 D4FDFFEA 		b	.L306
 5170              	.LVL389:
 5171              	.L444:
 5172              	.LBE120:
 5173              	.LBE154:
 5174              	.LBB155:
 5175              	.LBB106:
2961:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5176              		.loc 1 2961 0
 5177 2dd8 2000A0E3 		mov	r0, #32
 5178 2ddc E4119FE5 		ldr	r1, .L448+44
 5179 2de0 3E208DE2 		add	r2, sp, #62
 5180 2de4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5181              	.LVL390:
2963:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)//supports both SS and HS
 5182              		.loc 1 2963 0
 5183 2de8 000050E3 		cmp	r0, #0
 5184 2dec D7FDFF1A 		bne	.L431
2965:../uvc.c      ****                         switch (glCommitCtrl[3])
 5185              		.loc 1 2965 0
 5186 2df0 8330D4E5 		ldrb	r3, [r4, #131]	@ zero_extendqisi2
 5187 2df4 010053E3 		cmp	r3, #1
 5188 2df8 1E00000A 		beq	.L392
 5189 2dfc 020053E3 		cmp	r3, #2
 5190 2e00 0B00001A 		bne	.L391
2973:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
 5191              		.loc 1 2973 0
 5192 2e04 3010A0E3 		mov	r1, #48
 5193 2e08 0120A0E3 		mov	r2, #1
 5194 2e0c 5230A0E3 		mov	r3, #82
 5195 2e10 0B00A0E3 		mov	r0, #11
 5196              	.LVL391:
 5197 2e14 FEFFFFEB 		bl	SensorSetIrisControl
2974:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5198              		.loc 1 2974 0
 5199 2e18 7D0FA0E3 		mov	r0, #500
 5200 2e1c FEFFFFEB 		bl	_tx_thread_sleep
2975:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
 5201              		.loc 1 2975 0
 5202 2e20 0400A0E3 		mov	r0, #4
 5203 2e24 D0119FE5 		ldr	r1, .L448+96
 5204 2e28 0120A0E3 		mov	r2, #1
 5205 2e2c 0B30A0E3 		mov	r3, #11
 5206 2e30 FEFFFFEB 		bl	CyU3PDebugPrint
 5207              	.L391:
2980:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5208              		.loc 1 2980 0
 5209 2e34 83E0D4E5 		ldrb	lr, [r4, #131]	@ zero_extendqisi2
2981:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5210              		.loc 1 2981 0
 5211 2e38 C0119FE5 		ldr	r1, .L448+100
 5212 2e3c 0E20A0E1 		mov	r2, lr
 5213 2e40 0400A0E3 		mov	r0, #4
2980:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5214              		.loc 1 2980 0
 5215 2e44 A0E0C4E5 		strb	lr, [r4, #160]
2981:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5216              		.loc 1 2981 0
 5217 2e48 FEFFFFEB 		bl	CyU3PDebugPrint
2994:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5218              		.loc 1 2994 0
 5219 2e4c 0020A0E3 		mov	r2, #0
 5220 2e50 44019FE5 		ldr	r0, .L448
 5221 2e54 0110A0E3 		mov	r1, #1
 5222 2e58 FEFFFFEB 		bl	_txe_event_flags_set
 5223              	.LVL392:
2995:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5224              		.loc 1 2995 0
 5225 2e5c 002050E2 		subs	r2, r0, #0
 5226 2e60 BAFDFF0A 		beq	.L431
2997:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 5227              		.loc 1 2997 0
 5228 2e64 0400A0E3 		mov	r0, #4
 5229              	.LVL393:
 5230 2e68 94119FE5 		ldr	r1, .L448+104
 5231 2e6c FEFFFFEB 		bl	CyU3PDebugPrint
 5232              	.LVL394:
 5233 2e70 38309DE5 		ldr	r3, [sp, #56]
 5234 2e74 B6FDFFEA 		b	.L368
 5235              	.LVL395:
 5236              	.L392:
2968:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
 5237              		.loc 1 2968 0
 5238 2e78 3010A0E3 		mov	r1, #48
 5239 2e7c 0020A0E3 		mov	r2, #0
 5240 2e80 5230A0E3 		mov	r3, #82
 5241 2e84 0B00A0E3 		mov	r0, #11
 5242              	.LVL396:
 5243 2e88 FEFFFFEB 		bl	SensorSetIrisControl
2969:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5244              		.loc 1 2969 0
 5245 2e8c 7D0FA0E3 		mov	r0, #500
 5246 2e90 FEFFFFEB 		bl	_tx_thread_sleep
2970:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
 5247              		.loc 1 2970 0
 5248 2e94 60119FE5 		ldr	r1, .L448+96
 5249 2e98 0020A0E3 		mov	r2, #0
 5250 2e9c 0B30A0E3 		mov	r3, #11
 5251 2ea0 0400A0E3 		mov	r0, #4
 5252 2ea4 FEFFFFEB 		bl	CyU3PDebugPrint
 5253 2ea8 E1FFFFEA 		b	.L391
 5254              	.L348:
 5255              	.LVL397:
 5256              	.LBE106:
 5257              	.LBE155:
 5258              	.LBB156:
 5259              	.LBB127:
2800:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5260              		.loc 1 2800 0
 5261 2eac 1200A0E3 		mov	r0, #18
 5262 2eb0 FEFFFFEB 		bl	ControlHandle
 5263              	.LVL398:
 5264 2eb4 38309DE5 		ldr	r3, [sp, #56]
 5265 2eb8 9BFDFFEA 		b	.L306
 5266              	.L352:
 5267              	.LVL399:
2816:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5268              		.loc 1 2816 0
 5269 2ebc 1600A0E3 		mov	r0, #22
 5270 2ec0 FEFFFFEB 		bl	ControlHandle
 5271              	.LVL400:
 5272 2ec4 38309DE5 		ldr	r3, [sp, #56]
 5273 2ec8 97FDFFEA 		b	.L306
 5274              	.L351:
 5275              	.LVL401:
2812:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5276              		.loc 1 2812 0
 5277 2ecc 1500A0E3 		mov	r0, #21
 5278 2ed0 FEFFFFEB 		bl	ControlHandle
 5279              	.LVL402:
 5280 2ed4 38309DE5 		ldr	r3, [sp, #56]
 5281 2ed8 93FDFFEA 		b	.L306
 5282              	.LVL403:
 5283              	.L417:
 5284              	.LBE127:
 5285              	.LBE156:
 5286              	.LBB157:
 5287              	.LBB115:
3144:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5288              		.loc 1 3144 0
 5289 2edc 0200A0E3 		mov	r0, #2
 5290 2ee0 04119FE5 		ldr	r1, .L448+80
 5291 2ee4 EDFEFFEA 		b	.L432
 5292              	.LVL404:
 5293              	.L361:
 5294              	.LBE115:
 5295              	.LBE157:
 5296              	.LBB158:
 5297              	.LBB119:
2859:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 5298              		.loc 1 2859 0
 5299 2ee8 2500A0E3 		mov	r0, #37
 5300 2eec FEFFFFEB 		bl	ControlHandle
 5301              	.LVL405:
 5302 2ef0 38309DE5 		ldr	r3, [sp, #56]
 5303 2ef4 8CFDFFEA 		b	.L306
 5304              	.L357:
 5305              	.LVL406:
2839:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5306              		.loc 1 2839 0
 5307 2ef8 1C00A0E3 		mov	r0, #28
 5308 2efc FEFFFFEB 		bl	ControlHandle
 5309              	.LVL407:
 5310 2f00 38309DE5 		ldr	r3, [sp, #56]
 5311 2f04 88FDFFEA 		b	.L306
 5312              	.L356:
 5313              	.LVL408:
2835:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5314              		.loc 1 2835 0
 5315 2f08 1A00A0E3 		mov	r0, #26
 5316 2f0c FEFFFFEB 		bl	ControlHandle
 5317              	.LVL409:
 5318 2f10 38309DE5 		ldr	r3, [sp, #56]
 5319 2f14 84FDFFEA 		b	.L306
 5320              	.L358:
 5321              	.LVL410:
2847:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5322              		.loc 1 2847 0
 5323 2f18 1E00A0E3 		mov	r0, #30
 5324 2f1c FEFFFFEB 		bl	ControlHandle
 5325              	.LVL411:
 5326 2f20 38309DE5 		ldr	r3, [sp, #56]
 5327 2f24 80FDFFEA 		b	.L306
 5328              	.LVL412:
 5329              	.L420:
 5330              	.LBE119:
 5331              	.LBE158:
 5332              	.LBB159:
 5333              	.LBB105:
3178:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5334              		.loc 1 3178 0
 5335 2f28 D8109FE5 		ldr	r1, .L448+108
 5336 2f2c BE23DDE1 		ldrh	r2, [sp, #62]
 5337 2f30 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5338 2f34 0400A0E3 		mov	r0, #4
 5339              	.LVL413:
 5340 2f38 FEFFFFEB 		bl	CyU3PDebugPrint
 5341 2f3c 7FFDFFEA 		b	.L370
 5342              	.L347:
 5343              	.LVL414:
 5344              	.LBE105:
 5345              	.LBE159:
 5346              	.LBB160:
 5347              	.LBB128:
2796:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5348              		.loc 1 2796 0
 5349 2f40 1100A0E3 		mov	r0, #17
 5350 2f44 FEFFFFEB 		bl	ControlHandle
 5351              	.LVL415:
 5352 2f48 38309DE5 		ldr	r3, [sp, #56]
 5353 2f4c 76FDFFEA 		b	.L306
 5354              	.L349:
 5355              	.LVL416:
2804:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5356              		.loc 1 2804 0
 5357 2f50 1300A0E3 		mov	r0, #19
 5358 2f54 FEFFFFEB 		bl	ControlHandle
 5359              	.LVL417:
 5360 2f58 38309DE5 		ldr	r3, [sp, #56]
 5361 2f5c 72FDFFEA 		b	.L306
 5362              	.L354:
 5363              	.LVL418:
2824:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5364              		.loc 1 2824 0
 5365 2f60 1800A0E3 		mov	r0, #24
 5366 2f64 FEFFFFEB 		bl	ControlHandle
 5367              	.LVL419:
 5368 2f68 38309DE5 		ldr	r3, [sp, #56]
 5369 2f6c 6EFDFFEA 		b	.L306
 5370              	.LVL420:
 5371              	.L412:
 5372              	.LBE128:
 5373              	.LBE160:
 5374              	.LBB161:
 5375              	.LBB116:
3109:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*
 5376              		.loc 1 3109 0
 5377 2f70 3010A0E3 		mov	r1, #48
 5378 2f74 0120A0E3 		mov	r2, #1
 5379 2f78 5230A0E3 		mov	r3, #82
 5380 2f7c 0B00A0E3 		mov	r0, #11
 5381              	.LVL421:
 5382 2f80 FEFFFFEB 		bl	SensorSetIrisControl
3111:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
 5383              		.loc 1 3111 0
 5384 2f84 48109FE5 		ldr	r1, .L448+56
 5385 2f88 0B20A0E3 		mov	r2, #11
 5386 2f8c 0130A0E3 		mov	r3, #1
 5387 2f90 0400A0E3 		mov	r0, #4
 5388 2f94 FEFFFFEB 		bl	CyU3PDebugPrint
 5389 2f98 67FEFFEA 		b	.L411
 5390              	.L449:
 5391              		.align	2
 5392              	.L448:
 5393 2f9c 00000000 		.word	.LANCHOR0
 5394 2fa0 00000000 		.word	.LANCHOR1
 5395 2fa4 00000000 		.word	bRequest
 5396 2fa8 00000000 		.word	wValue
 5397 2fac 00000000 		.word	wIndex
 5398 2fb0 00000000 		.word	glInterStaBuffer
 5399 2fb4 14050000 		.word	.LC28
 5400 2fb8 00000000 		.word	glChHandleInterStat
 5401 2fbc 00000000 		.word	bmReqType
 5402 2fc0 00000000 		.word	wLength
 5403 2fc4 98040000 		.word	.LC27
 5404 2fc8 80000000 		.word	.LANCHOR0+128
 5405 2fcc 54060000 		.word	.LC36
 5406 2fd0 78060000 		.word	.LC37
 5407 2fd4 08060000 		.word	.LC34
 5408 2fd8 2C060000 		.word	.LC35
 5409 2fdc 2C060000 		.word	.LANCHOR1+1580
 5410 2fe0 38060000 		.word	.LANCHOR1+1592
 5411 2fe4 10060000 		.word	.LANCHOR1+1552
 5412 2fe8 40050000 		.word	.LC29
 5413 2fec 5C000000 		.word	.LANCHOR0+92
 5414 2ff0 CC060000 		.word	.LC39
 5415 2ff4 D4010000 		.word	.LC12
 5416 2ff8 DC050000 		.word	.LC33
 5417 2ffc 68050000 		.word	.LC30
 5418 3000 8C050000 		.word	.LC31
 5419 3004 B4050000 		.word	.LC32
 5420 3008 A4060000 		.word	.LC38
 5421              	.LBE116:
 5422              	.LBE161:
 5423              		.cfi_endproc
 5424              	.LFE24:
 5426              		.align	2
 5427              		.global	CamDefSet
 5429              	CamDefSet:
 5430              	.LFB4:
1146:../uvc.c      **** {
 5431              		.loc 1 1146 0
 5432              		.cfi_startproc
 5433              		@ args = 0, pretend = 0, frame = 24
 5434              		@ frame_needed = 0, uses_anonymous_args = 0
 5435              	.LVL422:
 5436 300c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5437              	.LCFI19:
 5438              		.cfi_def_cfa_offset 36
1152:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5439              		.loc 1 1152 0
 5440 3010 AC429FE5 		ldr	r4, .L453
 5441              		.cfi_offset 14, -4
 5442              		.cfi_offset 11, -8
 5443              		.cfi_offset 10, -12
 5444              		.cfi_offset 9, -16
 5445              		.cfi_offset 8, -20
 5446              		.cfi_offset 7, -24
 5447              		.cfi_offset 6, -28
 5448              		.cfi_offset 5, -32
 5449              		.cfi_offset 4, -36
1157:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5450              		.loc 1 1157 0
 5451 3014 AC229FE5 		ldr	r2, .L453+4
1154:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5452              		.loc 1 1154 0
 5453 3018 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1146:../uvc.c      **** {
 5454              		.loc 1 1146 0
 5455 301c 2CD04DE2 		sub	sp, sp, #44
 5456              	.LCFI20:
 5457              		.cfi_def_cfa_offset 80
1157:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5458              		.loc 1 1157 0
 5459 3020 1C0092E5 		ldr	r0, [r2, #28]
 5460 3024 0010E0E3 		mvn	r1, #0
1159:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5461              		.loc 1 1159 0
 5462 3028 2963A0E1 		mov	r6, r9, lsr #6
1153:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5463              		.loc 1 1153 0
 5464 302c A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1152:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5465              		.loc 1 1152 0
 5466 3030 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5467              	.LVL423:
1157:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5468              		.loc 1 1157 0
 5469 3034 FEFFFFEB 		bl	_txe_mutex_get
1158:../uvc.c      ****     if(Data1&0x80){
 5470              		.loc 1 1158 0
 5471 3038 800019E3 		tst	r9, #128
1159:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5472              		.loc 1 1159 0
 5473 303c 01600612 		andne	r6, r6, #1
 5474 3040 0660E011 		mvnne	r6, r6
 5475 3044 3B600612 		andne	r6, r6, #59
 5476 3048 0660E011 		mvnne	r6, r6
 5477 304c FF600612 		andne	r6, r6, #255
 5478              	.LVL424:
1161:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5479              		.loc 1 1161 0
 5480 3050 C6608603 		orreq	r6, r6, #198
 5481              	.LVL425:
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5482              		.loc 1 1165 0
 5483 3054 0080A0E3 		mov	r8, #0
 5484 3058 0A20A0E1 		mov	r2, sl
 5485 305c 0730A0E1 		mov	r3, r7
 5486 3060 0110A0E3 		mov	r1, #1
1163:../uvc.c      ****     Data0 = (Data0 << 2);
 5487              		.loc 1 1163 0
 5488 3064 0951A0E1 		mov	r5, r9, asl #2
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5489              		.loc 1 1165 0
 5490 3068 58029FE5 		ldr	r0, .L453+4
1168:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5491              		.loc 1 1168 0
 5492 306c 0190A0E3 		mov	r9, #1
 5493              	.LVL426:
1163:../uvc.c      ****     Data0 = (Data0 << 2);
 5494              		.loc 1 1163 0
 5495 3070 FF5005E2 		and	r5, r5, #255
 5496              	.LVL427:
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5497              		.loc 1 1165 0
 5498 3074 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5499 3078 FEFFFFEB 		bl	cmdSet
 5500              	.LVL428:
1168:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5501              		.loc 1 1168 0
 5502 307c 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5503 3080 0910A0E1 		mov	r1, r9
 5504 3084 0730A0E1 		mov	r3, r7
 5505 3088 38029FE5 		ldr	r0, .L453+4
 5506 308c 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5507 3090 FEFFFFEB 		bl	cmdSet
 5508              	.LVL429:
1171:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5509              		.loc 1 1171 0
 5510 3094 0620A0E1 		mov	r2, r6
 5511 3098 0530A0E1 		mov	r3, r5
 5512 309c 28129FE5 		ldr	r1, .L453+8
 5513 30a0 0400A0E3 		mov	r0, #4
1170:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5514              		.loc 1 1170 0
 5515 30a4 A661C4E5 		strb	r6, [r4, #422]
1169:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5516              		.loc 1 1169 0
 5517 30a8 A551C4E5 		strb	r5, [r4, #421]
1171:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5518              		.loc 1 1171 0
 5519 30ac FEFFFFEB 		bl	CyU3PDebugPrint
 5520              	.LVL430:
1176:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5521              		.loc 1 1176 0
 5522 30b0 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5523              	.LVL431:
1177:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5524              		.loc 1 1177 0
 5525 30b4 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5526 30b8 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5527 30bc 0210A0E3 		mov	r1, #2
 5528 30c0 00029FE5 		ldr	r0, .L453+4
 5529 30c4 00B08DE5 		str	fp, [sp, #0]
 5530 30c8 04808DE5 		str	r8, [sp, #4]
 5531 30cc FEFFFFEB 		bl	cmdSet
 5532              	.LVL432:
1179:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5533              		.loc 1 1179 0
 5534 30d0 0B20A0E1 		mov	r2, fp
 5535 30d4 0530A0E1 		mov	r3, r5
 5536 30d8 EC119FE5 		ldr	r1, .L453+8
 5537 30dc 0400A0E3 		mov	r0, #4
1178:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5538              		.loc 1 1178 0
 5539 30e0 BD51C4E5 		strb	r5, [r4, #445]
1179:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5540              		.loc 1 1179 0
 5541 30e4 FEFFFFEB 		bl	CyU3PDebugPrint
 5542              	.LVL433:
1184:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5543              		.loc 1 1184 0
 5544 30e8 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1183:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5545              		.loc 1 1183 0
 5546 30ec 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5547              	.LVL434:
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5548              		.loc 1 1185 0
 5549 30f0 80B047E2 		sub	fp, r7, #128
 5550 30f4 FF100BE2 		and	r1, fp, #255
 5551 30f8 14108DE5 		str	r1, [sp, #20]
 5552 30fc 14C09DE5 		ldr	ip, [sp, #20]
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5553              		.loc 1 1186 0
 5554 3100 760047E2 		sub	r0, r7, #118
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5555              		.loc 1 1187 0
 5556 3104 7EE087E2 		add	lr, r7, #126
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5557              		.loc 1 1185 0
 5558 3108 0630A0E1 		mov	r3, r6
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5559              		.loc 1 1186 0
 5560 310c 18008DE5 		str	r0, [sp, #24]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5561              		.loc 1 1185 0
 5562 3110 0510A0E3 		mov	r1, #5
 5563 3114 DF20A0E3 		mov	r2, #223
 5564 3118 A8019FE5 		ldr	r0, .L453+4
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5565              		.loc 1 1187 0
 5566 311c 1CE08DE5 		str	lr, [sp, #28]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5567              		.loc 1 1185 0
 5568 3120 00C08DE5 		str	ip, [sp, #0]
 5569 3124 04808DE5 		str	r8, [sp, #4]
 5570 3128 FEFFFFEB 		bl	cmdSet
 5571              	.LVL435:
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5572              		.loc 1 1186 0
 5573 312c 18A09DE5 		ldr	sl, [sp, #24]
1188:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5574              		.loc 1 1188 0
 5575 3130 72E087E2 		add	lr, r7, #114
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5576              		.loc 1 1186 0
 5577 3134 FFC00AE2 		and	ip, sl, #255
 5578 3138 0630A0E1 		mov	r3, r6
 5579 313c 0510A0E3 		mov	r1, #5
 5580 3140 DC20A0E3 		mov	r2, #220
 5581 3144 7C019FE5 		ldr	r0, .L453+4
1188:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5582              		.loc 1 1188 0
 5583 3148 20E08DE5 		str	lr, [sp, #32]
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5584              		.loc 1 1186 0
 5585 314c 00C08DE5 		str	ip, [sp, #0]
 5586 3150 04908DE5 		str	r9, [sp, #4]
 5587 3154 FEFFFFEB 		bl	cmdSet
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5588              		.loc 1 1187 0
 5589 3158 1C009DE5 		ldr	r0, [sp, #28]
 5590 315c 02E0A0E3 		mov	lr, #2
 5591 3160 FFC000E2 		and	ip, r0, #255
 5592 3164 0630A0E1 		mov	r3, r6
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5593              		.loc 1 1189 0
 5594 3168 6FA047E2 		sub	sl, r7, #111
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5595              		.loc 1 1187 0
 5596 316c 0510A0E3 		mov	r1, #5
 5597 3170 DE20A0E3 		mov	r2, #222
 5598 3174 4C019FE5 		ldr	r0, .L453+4
 5599 3178 04E08DE5 		str	lr, [sp, #4]
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5600              		.loc 1 1189 0
 5601 317c 24A08DE5 		str	sl, [sp, #36]
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5602              		.loc 1 1187 0
 5603 3180 00C08DE5 		str	ip, [sp, #0]
 5604 3184 FEFFFFEB 		bl	cmdSet
1188:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5605              		.loc 1 1188 0
 5606 3188 20A09DE5 		ldr	sl, [sp, #32]
 5607 318c 0630A0E1 		mov	r3, r6
 5608 3190 FFC00AE2 		and	ip, sl, #255
 5609 3194 00C08DE5 		str	ip, [sp, #0]
 5610 3198 0510A0E3 		mov	r1, #5
 5611 319c 03C0A0E3 		mov	ip, #3
 5612 31a0 E020A0E3 		mov	r2, #224
 5613 31a4 1C019FE5 		ldr	r0, .L453+4
 5614 31a8 04C08DE5 		str	ip, [sp, #4]
 5615 31ac FEFFFFEB 		bl	cmdSet
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5616              		.loc 1 1189 0
 5617 31b0 24009DE5 		ldr	r0, [sp, #36]
 5618 31b4 04A0A0E3 		mov	sl, #4
 5619 31b8 FFC000E2 		and	ip, r0, #255
 5620 31bc 0630A0E1 		mov	r3, r6
 5621 31c0 0510A0E3 		mov	r1, #5
 5622 31c4 DD20A0E3 		mov	r2, #221
 5623 31c8 F8009FE5 		ldr	r0, .L453+4
 5624 31cc 00C08DE5 		str	ip, [sp, #0]
1190:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5625              		.loc 1 1190 0
 5626 31d0 7F7087E2 		add	r7, r7, #127
 5627              	.LVL436:
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5628              		.loc 1 1189 0
 5629 31d4 04A08DE5 		str	sl, [sp, #4]
 5630 31d8 FEFFFFEB 		bl	cmdSet
1190:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5631              		.loc 1 1190 0
 5632 31dc 05E0A0E3 		mov	lr, #5
 5633 31e0 0E10A0E1 		mov	r1, lr
 5634 31e4 0630A0E1 		mov	r3, r6
 5635 31e8 E120A0E3 		mov	r2, #225
 5636 31ec FF6007E2 		and	r6, r7, #255
 5637              	.LVL437:
 5638 31f0 D0009FE5 		ldr	r0, .L453+4
 5639 31f4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5640 31f8 FEFFFFEB 		bl	cmdSet
 5641              	.LVL438:
1191:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5642              		.loc 1 1191 0
 5643 31fc 14C09DE5 		ldr	ip, [sp, #20]
1192:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5644              		.loc 1 1192 0
 5645 3200 24E09DE5 		ldr	lr, [sp, #36]
 5646 3204 1C609DE5 		ldr	r6, [sp, #28]
1191:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5647              		.loc 1 1191 0
 5648 3208 05C2C4E5 		strb	ip, [r4, #517]
1192:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5649              		.loc 1 1192 0
 5650 320c 20C09DE5 		ldr	ip, [sp, #32]
 5651 3210 0B20A0E1 		mov	r2, fp
 5652 3214 18309DE5 		ldr	r3, [sp, #24]
 5653 3218 B0109FE5 		ldr	r1, .L453+12
 5654 321c 0A00A0E1 		mov	r0, sl
 5655 3220 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5656 3224 0C708DE5 		str	r7, [sp, #12]
 5657 3228 FEFFFFEB 		bl	CyU3PDebugPrint
 5658              	.LVL439:
1196:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5659              		.loc 1 1196 0
 5660 322c 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5661              	.LVL440:
1197:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5662              		.loc 1 1197 0
 5663 3230 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5664              	.LVL441:
1198:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5665              		.loc 1 1198 0
 5666 3234 0730A0E1 		mov	r3, r7
 5667 3238 0610A0E3 		mov	r1, #6
 5668 323c 8520A0E3 		mov	r2, #133
 5669 3240 80009FE5 		ldr	r0, .L453+4
 5670 3244 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5671 3248 FEFFFFEB 		bl	cmdSet
1199:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5672              		.loc 1 1199 0
 5673 324c 0730A0E1 		mov	r3, r7
 5674 3250 0610A0E3 		mov	r1, #6
 5675 3254 8620A0E3 		mov	r2, #134
 5676 3258 68009FE5 		ldr	r0, .L453+4
 5677 325c 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5678 3260 FEFFFFEB 		bl	cmdSet
1201:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5679              		.loc 1 1201 0
 5680 3264 0620A0E1 		mov	r2, r6
 5681 3268 0530A0E1 		mov	r3, r5
 5682 326c 58109FE5 		ldr	r1, .L453+8
 5683 3270 0A00A0E1 		mov	r0, sl
1200:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5684              		.loc 1 1200 0
 5685 3274 1D62C4E5 		strb	r6, [r4, #541]
1201:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5686              		.loc 1 1201 0
 5687 3278 FEFFFFEB 		bl	CyU3PDebugPrint
 5688              	.LVL442:
1206:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5689              		.loc 1 1206 0
 5690 327c 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5691              	.LVL443:
1207:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5692              		.loc 1 1207 0
 5693 3280 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5694 3284 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5695 3288 0710A0E3 		mov	r1, #7
 5696 328c 34009FE5 		ldr	r0, .L453+4
 5697 3290 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5698 3294 FEFFFFEB 		bl	cmdSet
 5699              	.LVL444:
1209:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5700              		.loc 1 1209 0
 5701 3298 0530A0E1 		mov	r3, r5
 5702 329c 0A00A0E1 		mov	r0, sl
 5703 32a0 24109FE5 		ldr	r1, .L453+8
 5704 32a4 0620A0E1 		mov	r2, r6
1208:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5705              		.loc 1 1208 0
 5706 32a8 3552C4E5 		strb	r5, [r4, #565]
1209:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5707              		.loc 1 1209 0
 5708 32ac FEFFFFEB 		bl	CyU3PDebugPrint
1211:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5709              		.loc 1 1211 0
 5710 32b0 10309FE5 		ldr	r3, .L453+4
 5711 32b4 1C0093E5 		ldr	r0, [r3, #28]
1214:../uvc.c      **** }
 5712              		.loc 1 1214 0
 5713 32b8 2CD08DE2 		add	sp, sp, #44
 5714 32bc F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1211:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5715              		.loc 1 1211 0
 5716 32c0 FEFFFFEA 		b	_txe_mutex_put
 5717              	.L454:
 5718              		.align	2
 5719              	.L453:
 5720 32c4 00000000 		.word	.LANCHOR1
 5721 32c8 00000000 		.word	cmdQu
 5722 32cc 00070000 		.word	.LC40
 5723 32d0 20070000 		.word	.LC41
 5724              		.cfi_endproc
 5725              	.LFE4:
 5727              		.align	2
 5728              		.global	CyFxUVCAddHeader
 5730              	CyFxUVCAddHeader:
 5731              	.LFB5:
1222:../uvc.c      **** {
 5732              		.loc 1 1222 0
 5733              		.cfi_startproc
 5734              		@ args = 0, pretend = 0, frame = 0
 5735              		@ frame_needed = 0, uses_anonymous_args = 0
 5736              	.LVL445:
 5737 32d4 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5738              	.LCFI21:
 5739              		.cfi_def_cfa_offset 16
1222:../uvc.c      **** {
 5740              		.loc 1 1222 0
 5741 32d8 0040A0E1 		mov	r4, r0
 5742              		.cfi_offset 14, -4
 5743              		.cfi_offset 5, -8
 5744              		.cfi_offset 4, -12
 5745              		.cfi_offset 3, -16
 5746 32dc 0150A0E1 		mov	r5, r1
1224:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 5747              		.loc 1 1224 0
 5748 32e0 30009FE5 		ldr	r0, .L457
 5749              	.LVL446:
 5750 32e4 0010E0E3 		mvn	r1, #0
 5751              	.LVL447:
 5752 32e8 FEFFFFEB 		bl	_txe_mutex_get
1225:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5753              		.loc 1 1225 0
 5754 32ec 0400A0E1 		mov	r0, r4
 5755 32f0 24109FE5 		ldr	r1, .L457+4
 5756 32f4 0C20A0E3 		mov	r2, #12
 5757 32f8 FEFFFFEB 		bl	CyU3PMemCopy
1226:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5758              		.loc 1 1226 0
 5759 32fc 14009FE5 		ldr	r0, .L457
 5760 3300 FEFFFFEB 		bl	_txe_mutex_put
1229:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5761              		.loc 1 1229 0
 5762 3304 020015E3 		tst	r5, #2
1231:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5763              		.loc 1 1231 0
 5764 3308 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5765 330c 02308313 		orrne	r3, r3, #2
 5766 3310 0130C415 		strneb	r3, [r4, #1]
 5767 3314 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5768              	.L458:
 5769              		.align	2
 5770              	.L457:
 5771 3318 00000000 		.word	imgHdMux
 5772 331c 80040000 		.word	.LANCHOR1+1152
 5773              		.cfi_endproc
 5774              	.LFE5:
 5776              		.align	2
 5777              		.global	CyFxAppErrorHandler
 5779              	CyFxAppErrorHandler:
 5780              	.LFB6:
1241:../uvc.c      **** {
 5781              		.loc 1 1241 0
 5782              		.cfi_startproc
 5783              		@ args = 0, pretend = 0, frame = 0
 5784              		@ frame_needed = 0, uses_anonymous_args = 0
 5785              	.LVL448:
 5786 3320 08402DE9 		stmfd	sp!, {r3, lr}
 5787              	.LCFI22:
 5788              		.cfi_def_cfa_offset 8
 5789              	.LVL449:
 5790              	.L460:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5791              		.loc 1 1251 0 discriminator 1
 5792 3324 10109FE5 		ldr	r1, .L461
 5793 3328 0400A0E3 		mov	r0, #4
 5794              		.cfi_offset 14, -4
 5795              		.cfi_offset 3, -8
 5796 332c FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 5797              		.loc 1 1252 0 discriminator 1
 5798 3330 FA0FA0E3 		mov	r0, #1000
 5799 3334 FEFFFFEB 		bl	_tx_thread_sleep
 5800 3338 F9FFFFEA 		b	.L460
 5801              	.L462:
 5802              		.align	2
 5803              	.L461:
 5804 333c D4010000 		.word	.LC12
 5805              		.cfi_endproc
 5806              	.LFE6:
 5808              		.align	2
 5809              		.global	UVCAppThread_Entry
 5811              	UVCAppThread_Entry:
 5812              	.LFB18:
2206:../uvc.c      **** {
 5813              		.loc 1 2206 0
 5814              		.cfi_startproc
 5815              		@ args = 0, pretend = 0, frame = 176
 5816              		@ frame_needed = 0, uses_anonymous_args = 0
 5817              	.LVL450:
 5818 3340 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5819              	.LCFI23:
 5820              		.cfi_def_cfa_offset 28
 5821 3344 BCD04DE2 		sub	sp, sp, #188
 5822              	.LCFI24:
 5823              		.cfi_def_cfa_offset 216
 5824              	.LBB218:
 5825              	.LBB219:
1662:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5826              		.loc 1 1662 0
 5827              		.cfi_offset 14, -4
 5828              		.cfi_offset 10, -8
 5829              		.cfi_offset 8, -12
 5830              		.cfi_offset 7, -16
 5831              		.cfi_offset 6, -20
 5832              		.cfi_offset 5, -24
 5833              		.cfi_offset 4, -28
 5834 3348 FEFFFFEB 		bl	CyU3PUartInit
 5835              	.LVL451:
1663:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5836              		.loc 1 1663 0
 5837 334c 004050E2 		subs	r4, r0, #0
 5838 3350 0400000A 		beq	.L464
1665:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5839              		.loc 1 1665 0
 5840 3354 0400A0E3 		mov	r0, #4
 5841              	.LVL452:
 5842 3358 281B9FE5 		ldr	r1, .L565
 5843 335c FEFFFFEB 		bl	CyU3PDebugPrint
1666:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5844              		.loc 1 1666 0
 5845 3360 0400A0E1 		mov	r0, r4
 5846 3364 FEFFFFEB 		bl	CyFxAppErrorHandler
 5847              	.L464:
1670:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5848              		.loc 1 1670 0
 5849 3368 1CCB9FE5 		ldr	ip, .L565+4
1672:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5850              		.loc 1 1672 0
 5851 336c 0030A0E3 		mov	r3, #0
1671:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5852              		.loc 1 1671 0
 5853 3370 0120A0E3 		mov	r2, #1
1679:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5854              		.loc 1 1679 0
 5855 3374 50008DE2 		add	r0, sp, #80
 5856 3378 0310A0E1 		mov	r1, r3
1670:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5857              		.loc 1 1670 0
 5858 337c 60C08DE5 		str	ip, [sp, #96]
1671:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5859              		.loc 1 1671 0
 5860 3380 6420CDE5 		strb	r2, [sp, #100]
1672:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5861              		.loc 1 1672 0
 5862 3384 6530CDE5 		strb	r3, [sp, #101]
1673:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5863              		.loc 1 1673 0
 5864 3388 50208DE5 		str	r2, [sp, #80]
1674:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5865              		.loc 1 1674 0
 5866 338c 54308DE5 		str	r3, [sp, #84]
1675:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5867              		.loc 1 1675 0
 5868 3390 58308DE5 		str	r3, [sp, #88]
1676:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5869              		.loc 1 1676 0
 5870 3394 5C208DE5 		str	r2, [sp, #92]
1679:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5871              		.loc 1 1679 0
 5872 3398 FEFFFFEB 		bl	CyU3PUartSetConfig
 5873              	.LVL453:
1680:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5874              		.loc 1 1680 0
 5875 339c 000050E3 		cmp	r0, #0
 5876 33a0 0000000A 		beq	.L465
1682:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5877              		.loc 1 1682 0
 5878 33a4 FEFFFFEB 		bl	CyFxAppErrorHandler
 5879              	.LVL454:
 5880              	.L465:
1686:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5881              		.loc 1 1686 0
 5882 33a8 0000E0E3 		mvn	r0, #0
 5883 33ac FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5884              	.LVL455:
1687:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5885              		.loc 1 1687 0
 5886 33b0 000050E3 		cmp	r0, #0
 5887 33b4 0000000A 		beq	.L466
1689:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5888              		.loc 1 1689 0
 5889 33b8 FEFFFFEB 		bl	CyFxAppErrorHandler
 5890              	.LVL456:
 5891              	.L466:
1693:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5892              		.loc 1 1693 0
 5893 33bc 0300A0E3 		mov	r0, #3
 5894 33c0 0410A0E3 		mov	r1, #4
 5895 33c4 FEFFFFEB 		bl	CyU3PDebugInit
 5896              	.LVL457:
1694:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5897              		.loc 1 1694 0
 5898 33c8 000050E3 		cmp	r0, #0
 5899 33cc 0000000A 		beq	.L467
1696:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5900              		.loc 1 1696 0
 5901 33d0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5902              	.LVL458:
 5903              	.L467:
1700:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5904              		.loc 1 1700 0
 5905 33d4 0000A0E3 		mov	r0, #0
 5906 33d8 FEFFFFEB 		bl	CyU3PDebugPreamble
 5907              	.LVL459:
 5908              	.LBE219:
 5909              	.LBE218:
2222:../uvc.c      **** 		CyU3PThreadSleep(500);
 5910              		.loc 1 2222 0
 5911 33dc 7D0FA0E3 		mov	r0, #500
 5912 33e0 FEFFFFEB 		bl	_tx_thread_sleep
 5913              	.LVL460:
 5914 33e4 7D0FA0E3 		mov	r0, #500
 5915 33e8 FEFFFFEB 		bl	_tx_thread_sleep
 5916 33ec 7D0FA0E3 		mov	r0, #500
 5917 33f0 FEFFFFEB 		bl	_tx_thread_sleep
 5918 33f4 7D0FA0E3 		mov	r0, #500
 5919 33f8 FEFFFFEB 		bl	_tx_thread_sleep
 5920 33fc 7D0FA0E3 		mov	r0, #500
 5921 3400 FEFFFFEB 		bl	_tx_thread_sleep
 5922 3404 7D0FA0E3 		mov	r0, #500
 5923 3408 FEFFFFEB 		bl	_tx_thread_sleep
 5924              	.LBB220:
 5925              	.LBB221:
1711:../uvc.c      ****     status = CyU3PI2cInit ();
 5926              		.loc 1 1711 0
 5927 340c FEFFFFEB 		bl	CyU3PI2cInit
 5928              	.LVL461:
1712:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5929              		.loc 1 1712 0
 5930 3410 002050E2 		subs	r2, r0, #0
 5931 3414 0701001A 		bne	.L537
1719:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5932              		.loc 1 1719 0
 5933 3418 705A9FE5 		ldr	r5, .L565+8
1721:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5934              		.loc 1 1721 0
 5935 341c 0040E0E3 		mvn	r4, #0
1724:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5936              		.loc 1 1724 0
 5937 3420 0210A0E1 		mov	r1, r2
 5938 3424 8C008DE2 		add	r0, sp, #140
 5939              	.LVL462:
1719:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5940              		.loc 1 1719 0
 5941 3428 8C508DE5 		str	r5, [sp, #140]
1720:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5942              		.loc 1 1720 0
 5943 342c 90208DE5 		str	r2, [sp, #144]
1721:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5944              		.loc 1 1721 0
 5945 3430 94408DE5 		str	r4, [sp, #148]
1722:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5946              		.loc 1 1722 0
 5947 3434 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1724:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5948              		.loc 1 1724 0
 5949 3438 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5950              	.LVL463:
1725:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5951              		.loc 1 1725 0
 5952 343c 001050E2 		subs	r1, r0, #0
 5953 3440 0501001A 		bne	.L538
 5954              	.LBE221:
 5955              	.LBE220:
 5956              	.LBB227:
 5957              	.LBB230:
1798:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5958              		.loc 1 1798 0
 5959 3444 484A9FE5 		ldr	r4, .L565+12
 5960 3448 2820A0E3 		mov	r2, #40
 5961 344c 0400A0E1 		mov	r0, r4
 5962              	.LVL464:
 5963 3450 FEFFFFEB 		bl	_txe_event_flags_create
 5964              	.LVL465:
1799:../uvc.c      ****     if (apiRetStatus != 0)
 5965              		.loc 1 1799 0
 5966 3454 002050E2 		subs	r2, r0, #0
 5967 3458 0801001A 		bne	.L539
1813:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5968              		.loc 1 1813 0
 5969 345c 0270A0E3 		mov	r7, #2
1820:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5970              		.loc 1 1820 0
 5971 3460 0210A0E1 		mov	r1, r2
1809:../uvc.c      ****     isUsbConnected = CyFalse;
 5972              		.loc 1 1809 0
 5973 3464 302084E5 		str	r2, [r4, #48]
1810:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5974              		.loc 1 1810 0
 5975 3468 482084E5 		str	r2, [r4, #72]
1820:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5976              		.loc 1 1820 0
 5977 346c 9C008DE2 		add	r0, sp, #156
 5978              	.LVL466:
1816:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5979              		.loc 1 1816 0
 5980 3470 016087E2 		add	r6, r7, #1
1815:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5981              		.loc 1 1815 0
 5982 3474 A420CDE5 		strb	r2, [sp, #164]
1817:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5983              		.loc 1 1817 0
 5984 3478 A0208DE5 		str	r2, [sp, #160]
1813:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5985              		.loc 1 1813 0
 5986 347c 9C70CDE5 		strb	r7, [sp, #156]
1814:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5987              		.loc 1 1814 0
 5988 3480 9D70CDE5 		strb	r7, [sp, #157]
1816:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5989              		.loc 1 1816 0
 5990 3484 A560CDE5 		strb	r6, [sp, #165]
1820:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5991              		.loc 1 1820 0
 5992 3488 FEFFFFEB 		bl	CyU3PGpioInit
 5993              	.LVL467:
1821:../uvc.c      ****     if (apiRetStatus != 0)
 5994              		.loc 1 1821 0
 5995 348c 002050E2 		subs	r2, r0, #0
 5996 3490 7D01001A 		bne	.L540
1829:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5997              		.loc 1 1829 0
 5998 3494 1600A0E3 		mov	r0, #22
 5999              	.LVL468:
 6000 3498 0110A0E3 		mov	r1, #1
 6001 349c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6002              	.LVL469:
1830:../uvc.c      ****     if (apiRetStatus != 0)
 6003              		.loc 1 1830 0
 6004 34a0 002050E2 		subs	r2, r0, #0
 6005 34a4 6F01001A 		bne	.L541
1835:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 6006              		.loc 1 1835 0
 6007 34a8 1400A0E3 		mov	r0, #20
 6008              	.LVL470:
 6009 34ac 0110A0E3 		mov	r1, #1
 6010 34b0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6011              	.LVL471:
1836:../uvc.c      ****     if (apiRetStatus != 0)
 6012              		.loc 1 1836 0
 6013 34b4 002050E2 		subs	r2, r0, #0
 6014 34b8 7C01001A 		bne	.L542
1841:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 6015              		.loc 1 1841 0
 6016 34bc 1800A0E3 		mov	r0, #24
 6017              	.LVL472:
 6018 34c0 0110A0E3 		mov	r1, #1
 6019 34c4 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6020              	.LVL473:
1842:../uvc.c      ****     if (apiRetStatus != 0)
 6021              		.loc 1 1842 0
 6022 34c8 002050E2 		subs	r2, r0, #0
 6023 34cc 5C01001A 		bne	.L543
1849:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6024              		.loc 1 1849 0
 6025 34d0 0150A0E3 		mov	r5, #1
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6026              		.loc 1 1854 0
 6027 34d4 1600A0E3 		mov	r0, #22
 6028              	.LVL474:
 6029 34d8 68108DE2 		add	r1, sp, #104
1852:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6030              		.loc 1 1852 0
 6031 34dc 74208DE5 		str	r2, [sp, #116]
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6032              		.loc 1 1853 0
 6033 34e0 7820CDE5 		strb	r2, [sp, #120]
1849:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6034              		.loc 1 1849 0
 6035 34e4 68508DE5 		str	r5, [sp, #104]
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6036              		.loc 1 1850 0
 6037 34e8 6C508DE5 		str	r5, [sp, #108]
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6038              		.loc 1 1851 0
 6039 34ec 70508DE5 		str	r5, [sp, #112]
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6040              		.loc 1 1854 0
 6041 34f0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6042              	.LVL475:
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6043              		.loc 1 1855 0
 6044 34f4 002050E2 		subs	r2, r0, #0
 6045 34f8 2001001A 		bne	.L544
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6046              		.loc 1 1868 0
 6047 34fc 1400A0E3 		mov	r0, #20
 6048              	.LVL476:
 6049 3500 68108DE2 		add	r1, sp, #104
1866:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6050              		.loc 1 1866 0
 6051 3504 74208DE5 		str	r2, [sp, #116]
1867:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6052              		.loc 1 1867 0
 6053 3508 7820CDE5 		strb	r2, [sp, #120]
1863:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6054              		.loc 1 1863 0
 6055 350c 68508DE5 		str	r5, [sp, #104]
1864:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6056              		.loc 1 1864 0
 6057 3510 6C508DE5 		str	r5, [sp, #108]
1865:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6058              		.loc 1 1865 0
 6059 3514 70508DE5 		str	r5, [sp, #112]
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6060              		.loc 1 1868 0
 6061 3518 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6062              	.LVL477:
1869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6063              		.loc 1 1869 0
 6064 351c 002050E2 		subs	r2, r0, #0
 6065 3520 0D01001A 		bne	.L545
1882:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6066              		.loc 1 1882 0
 6067 3524 1800A0E3 		mov	r0, #24
 6068              	.LVL478:
 6069 3528 68108DE2 		add	r1, sp, #104
1877:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6070              		.loc 1 1877 0
 6071 352c 68208DE5 		str	r2, [sp, #104]
1878:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6072              		.loc 1 1878 0
 6073 3530 6C208DE5 		str	r2, [sp, #108]
1879:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6074              		.loc 1 1879 0
 6075 3534 70208DE5 		str	r2, [sp, #112]
1881:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6076              		.loc 1 1881 0
 6077 3538 7820CDE5 		strb	r2, [sp, #120]
1880:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6078              		.loc 1 1880 0
 6079 353c 74508DE5 		str	r5, [sp, #116]
1882:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6080              		.loc 1 1882 0
 6081 3540 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6082              	.LVL479:
1883:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6083              		.loc 1 1883 0
 6084 3544 002050E2 		subs	r2, r0, #0
 6085 3548 FA00001A 		bne	.L546
1892:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6086              		.loc 1 1892 0
 6087 354c 0080A0E3 		mov	r8, #0
1890:../uvc.c      ****     pibclock.clkDiv      = 2;
 6088              		.loc 1 1890 0
 6089 3550 0270A0E3 		mov	r7, #2	@ movhi
1891:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6090              		.loc 1 1891 0
 6091 3554 0360A0E3 		mov	r6, #3
1895:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6092              		.loc 1 1895 0
 6093 3558 0100A0E3 		mov	r0, #1
 6094              	.LVL480:
 6095 355c 7C108DE2 		add	r1, sp, #124
1890:../uvc.c      ****     pibclock.clkDiv      = 2;
 6096              		.loc 1 1890 0
 6097 3560 BC77CDE1 		strh	r7, [sp, #124]	@ movhi
1891:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6098              		.loc 1 1891 0
 6099 3564 8860CDE5 		strb	r6, [sp, #136]
1892:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6100              		.loc 1 1892 0
 6101 3568 84808DE5 		str	r8, [sp, #132]
1893:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6102              		.loc 1 1893 0
 6103 356c 80808DE5 		str	r8, [sp, #128]
1895:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6104              		.loc 1 1895 0
 6105 3570 FEFFFFEB 		bl	CyU3PPibInit
 6106              	.LVL481:
1896:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6107              		.loc 1 1896 0
 6108 3574 002050E2 		subs	r2, r0, #0
 6109 3578 BF01001A 		bne	.L547
1903:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 6110              		.loc 1 1903 0
 6111 357c 14099FE5 		ldr	r0, .L565+16
 6112              	.LVL482:
 6113 3580 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6114              	.LVL483:
1911:../uvc.c      ****     SensorReset ();
 6115              		.loc 1 1911 0
 6116 3584 FEFFFFEB 		bl	SensorReset
1912:../uvc.c      ****     SensorInit ();
 6117              		.loc 1 1912 0
 6118 3588 FEFFFFEB 		bl	SensorInit
1915:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 6119              		.loc 1 1915 0
 6120 358c FEFFFFEB 		bl	CyU3PUsbStart
 6121              	.LVL484:
1916:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6122              		.loc 1 1916 0
 6123 3590 008050E2 		subs	r8, r0, #0
 6124 3594 AE01001A 		bne	.L548
1922:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6125              		.loc 1 1922 0
 6126 3598 0810A0E1 		mov	r1, r8
 6127 359c F8089FE5 		ldr	r0, .L565+20
 6128              	.LVL485:
 6129 35a0 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6130              	.LVL486:
1925:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6131              		.loc 1 1925 0
 6132 35a4 F4089FE5 		ldr	r0, .L565+24
 6133 35a8 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1931:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6134              		.loc 1 1931 0
 6135 35ac F0289FE5 		ldr	r2, .L565+28
 6136 35b0 0810A0E1 		mov	r1, r8
 6137 35b4 0100A0E3 		mov	r0, #1
 6138 35b8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6139              		.loc 1 1932 0
 6140 35bc 0810A0E1 		mov	r1, r8
 6141 35c0 E0289FE5 		ldr	r2, .L565+32
 6142 35c4 0800A0E1 		mov	r0, r8
 6143 35c8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1935:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 6144              		.loc 1 1935 0
 6145 35cc 0810A0E1 		mov	r1, r8
 6146 35d0 D4289FE5 		ldr	r2, .L565+36
 6147 35d4 0200A0E3 		mov	r0, #2
 6148 35d8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1936:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6149              		.loc 1 1936 0
 6150 35dc 0810A0E1 		mov	r1, r8
 6151 35e0 C8289FE5 		ldr	r2, .L565+40
 6152 35e4 0700A0E3 		mov	r0, #7
 6153 35e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1939:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 6154              		.loc 1 1939 0
 6155 35ec C0289FE5 		ldr	r2, .L565+44
 6156 35f0 0810A0E1 		mov	r1, r8
 6157 35f4 0400A0E3 		mov	r0, #4
 6158 35f8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1940:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6159              		.loc 1 1940 0
 6160 35fc 0810A0E1 		mov	r1, r8
 6161 3600 B0289FE5 		ldr	r2, .L565+48
 6162 3604 0600A0E1 		mov	r0, r6
 6163 3608 FEFFFFEB 		bl	CyU3PUsbSetDesc
1941:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6164              		.loc 1 1941 0
 6165 360c 0810A0E1 		mov	r1, r8
 6166 3610 A4289FE5 		ldr	r2, .L565+52
 6167 3614 0600A0E3 		mov	r0, #6
 6168 3618 FEFFFFEB 		bl	CyU3PUsbSetDesc
1944:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 6169              		.loc 1 1944 0
 6170 361c 0810A0E1 		mov	r1, r8
 6171 3620 98289FE5 		ldr	r2, .L565+56
 6172 3624 0500A0E3 		mov	r0, #5
 6173 3628 FEFFFFEB 		bl	CyU3PUsbSetDesc
1945:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6174              		.loc 1 1945 0
 6175 362c 0110A0E3 		mov	r1, #1
 6176 3630 8C289FE5 		ldr	r2, .L565+60
 6177 3634 0500A0E3 		mov	r0, #5
 6178 3638 FEFFFFEB 		bl	CyU3PUsbSetDesc
1946:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6179              		.loc 1 1946 0
 6180 363c 0210A0E3 		mov	r1, #2
 6181 3640 80289FE5 		ldr	r2, .L565+64
 6182 3644 0500A0E3 		mov	r0, #5
 6183 3648 FEFFFFEB 		bl	CyU3PUsbSetDesc
1953:../uvc.c      ****     endPointConfig.enable   = 1;
 6184              		.loc 1 1953 0
 6185 364c 0150A0E3 		mov	r5, #1
1959:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6186              		.loc 1 1959 0
 6187 3650 8200A0E3 		mov	r0, #130
 6188 3654 A8108DE2 		add	r1, sp, #168
1955:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6189              		.loc 1 1955 0
 6190 3658 40A0A0E3 		mov	sl, #64	@ movhi
1953:../uvc.c      ****     endPointConfig.enable   = 1;
 6191              		.loc 1 1953 0
 6192 365c A8508DE5 		str	r5, [sp, #168]
1954:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6193              		.loc 1 1954 0
 6194 3660 AC60CDE5 		strb	r6, [sp, #172]
1955:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6195              		.loc 1 1955 0
 6196 3664 B0ABCDE1 		strh	sl, [sp, #176]	@ movhi
1956:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6197              		.loc 1 1956 0
 6198 3668 B380CDE5 		strb	r8, [sp, #179]
1957:../uvc.c      ****     endPointConfig.streams  = 0;
 6199              		.loc 1 1957 0
 6200 366c BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
1958:../uvc.c      ****     endPointConfig.burstLen = 1;
 6201              		.loc 1 1958 0
 6202 3670 B250CDE5 		strb	r5, [sp, #178]
1959:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6203              		.loc 1 1959 0
 6204 3674 FEFFFFEB 		bl	CyU3PSetEpConfig
 6205              	.LVL487:
1960:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6206              		.loc 1 1960 0
 6207 3678 003050E2 		subs	r3, r0, #0
 6208 367c 6A01001A 		bne	.L549
1970:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6209              		.loc 1 1970 0
 6210 3680 44C89FE5 		ldr	ip, .L565+68
1971:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6211              		.loc 1 1971 0
 6212 3684 44E89FE5 		ldr	lr, .L565+72
1968:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6213              		.loc 1 1968 0
 6214 3688 016BA0E3 		mov	r6, #1024	@ movhi
1977:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6215              		.loc 1 1977 0
 6216 368c 10A0A0E3 		mov	sl, #16
1979:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6217              		.loc 1 1979 0
 6218 3690 3C089FE5 		ldr	r0, .L565+76
 6219              	.LVL488:
 6220 3694 0410A0E3 		mov	r1, #4
 6221 3698 34208DE2 		add	r2, sp, #52
1968:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6222              		.loc 1 1968 0
 6223 369c B463CDE1 		strh	r6, [sp, #52]	@ movhi
1969:../uvc.c      ****     dmaInterConfig.count          = 1;
 6224              		.loc 1 1969 0
 6225 36a0 B653CDE1 		strh	r5, [sp, #54]	@ movhi
1970:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6226              		.loc 1 1970 0
 6227 36a4 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1971:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6228              		.loc 1 1971 0
 6229 36a8 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1972:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6230              		.loc 1 1972 0
 6231 36ac BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1973:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6232              		.loc 1 1973 0
 6233 36b0 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1974:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6234              		.loc 1 1974 0
 6235 36b4 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1975:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6236              		.loc 1 1975 0
 6237 36b8 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1976:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6238              		.loc 1 1976 0
 6239 36bc 4480CDE5 		strb	r8, [sp, #68]
1977:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6240              		.loc 1 1977 0
 6241 36c0 48A08DE5 		str	sl, [sp, #72]
1978:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6242              		.loc 1 1978 0
 6243 36c4 4C308DE5 		str	r3, [sp, #76]
1979:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6244              		.loc 1 1979 0
 6245 36c8 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6246              	.LVL489:
1981:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6247              		.loc 1 1981 0
 6248 36cc 006050E2 		subs	r6, r0, #0
 6249 36d0 4B01001A 		bne	.L550
1988:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6250              		.loc 1 1988 0
 6251 36d4 010BA0E3 		mov	r0, #1024
 6252              	.LVL490:
 6253 36d8 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6254 36dc F4179FE5 		ldr	r1, .L565+80
1989:../uvc.c      ****     if (glInterStaBuffer == 0)
 6255              		.loc 1 1989 0
 6256 36e0 000050E3 		cmp	r0, #0
1988:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6257              		.loc 1 1988 0
 6258 36e4 000081E5 		str	r0, [r1, #0]
1989:../uvc.c      ****     if (glInterStaBuffer == 0)
 6259              		.loc 1 1989 0
 6260 36e8 7501000A 		beq	.L551
1996:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 6261              		.loc 1 1996 0
 6262 36ec 0610A0E1 		mov	r1, r6
 6263 36f0 0620A0E1 		mov	r2, r6
 6264 36f4 3830A0E3 		mov	r3, #56
 6265 36f8 DC079FE5 		ldr	r0, .L565+84
 6266 36fc FEFFFFEB 		bl	_txe_mutex_create
1998:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6267              		.loc 1 1998 0
 6268 3700 0430A0E3 		mov	r3, #4	@ movhi
 6269 3704 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2001:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6270              		.loc 1 2001 0
 6271 3708 D0379FE5 		ldr	r3, .L565+88
1997:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6272              		.loc 1 1997 0
 6273 370c 01C9A0E3 		mov	ip, #16384	@ movhi
 6274 3710 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2000:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6275              		.loc 1 2000 0
 6276 3714 01CCA0E3 		mov	ip, #256	@ movhi
 6277 3718 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2001:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6278              		.loc 1 2001 0
 6279 371c B431CDE1 		strh	r3, [sp, #20]	@ movhi
2002:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6280              		.loc 1 2002 0
 6281 3720 BCC79FE5 		ldr	ip, .L565+92
2004:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6282              		.loc 1 2004 0
 6283 3724 0C30A0E3 		mov	r3, #12	@ movhi
 6284 3728 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2009:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6285              		.loc 1 2009 0
 6286 372c B4379FE5 		ldr	r3, .L565+96
2010:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6287              		.loc 1 2010 0
 6288 3730 0C208DE2 		add	r2, sp, #12
2002:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6289              		.loc 1 2002 0
 6290 3734 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2007:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6291              		.loc 1 2007 0
 6292 3738 2A80CDE5 		strb	r8, [sp, #42]
2005:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6293              		.loc 1 2005 0
 6294 373c 04C0A0E3 		mov	ip, #4	@ movhi
2010:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6295              		.loc 1 2010 0
 6296 3740 A4079FE5 		ldr	r0, .L565+100
 6297 3744 0710A0E3 		mov	r1, #7
2008:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6298              		.loc 1 2008 0
 6299 3748 1880A0E3 		mov	r8, #24
1999:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6300              		.loc 1 1999 0
 6301 374c B071CDE1 		strh	r7, [sp, #16]	@ movhi
2003:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6302              		.loc 1 2003 0
 6303 3750 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2005:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6304              		.loc 1 2005 0
 6305 3754 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2006:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6306              		.loc 1 2006 0
 6307 3758 B862CDE1 		strh	r6, [sp, #40]	@ movhi
2008:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6308              		.loc 1 2008 0
 6309 375c 2C808DE5 		str	r8, [sp, #44]
2009:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6310              		.loc 1 2009 0
 6311 3760 30308DE5 		str	r3, [sp, #48]
2010:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6312              		.loc 1 2010 0
 6313 3764 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6314              	.LVL491:
2012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6315              		.loc 1 2012 0
 6316 3768 002050E2 		subs	r2, r0, #0
 6317 376c 4B01001A 		bne	.L552
2103:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6318              		.loc 1 2103 0
 6319 3770 0500A0E1 		mov	r0, r5
 6320              	.LVL492:
 6321 3774 0510A0E1 		mov	r1, r5
 6322 3778 FEFFFFEB 		bl	CyU3PConnectState
 6323              	.LVL493:
2104:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6324              		.loc 1 2104 0
 6325 377c 002050E2 		subs	r2, r0, #0
 6326 3780 6300001A 		bne	.L553
2110:../uvc.c      ****     CyU3PBusyWait(100);
 6327              		.loc 1 2110 0
 6328 3784 6400A0E3 		mov	r0, #100
 6329              	.LVL494:
 6330 3788 FEFFFFEB 		bl	CyU3PBusyWait
 6331              	.LVL495:
2112:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6332              		.loc 1 2112 0
 6333 378c FEFFFFEB 		bl	CyU3PUsbGetSpeed
2126:../uvc.c      ****     endPointConfig.streams  = 0;
 6334              		.loc 1 2126 0
 6335 3790 0020A0E3 		mov	r2, #0	@ movhi
2115:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6336              		.loc 1 2115 0
 6337 3794 AC70CDE5 		strb	r7, [sp, #172]
2127:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6338              		.loc 1 2127 0
 6339 3798 A8108DE2 		add	r1, sp, #168
2126:../uvc.c      ****     endPointConfig.streams  = 0;
 6340              		.loc 1 2126 0
 6341 379c BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2114:../uvc.c      ****     endPointConfig.enable   = 1;
 6342              		.loc 1 2114 0
 6343 37a0 A8508DE5 		str	r5, [sp, #168]
2116:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6344              		.loc 1 2116 0
 6345 37a4 030050E3 		cmp	r0, #3
2112:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6346              		.loc 1 2112 0
 6347 37a8 4C00C4E5 		strb	r0, [r4, #76]
2123:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6348              		.loc 1 2123 0
 6349 37ac 020CA013 		movne	r0, #512	@ movhi
2118:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6350              		.loc 1 2118 0
 6351 37b0 017BA003 		moveq	r7, #1024	@ movhi
2123:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6352              		.loc 1 2123 0
 6353 37b4 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2127:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6354              		.loc 1 2127 0
 6355 37b8 8300A0E3 		mov	r0, #131
2118:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6356              		.loc 1 2118 0
 6357 37bc B07BCD01 		streqh	r7, [sp, #176]	@ movhi
2119:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6358              		.loc 1 2119 0
 6359 37c0 B2A0CD05 		streqb	sl, [sp, #178]
2124:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6360              		.loc 1 2124 0
 6361 37c4 B250CD15 		strneb	r5, [sp, #178]
2127:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6362              		.loc 1 2127 0
 6363 37c8 FEFFFFEB 		bl	CyU3PSetEpConfig
 6364              	.LVL496:
2128:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6365              		.loc 1 2128 0
 6366 37cc 002050E2 		subs	r2, r0, #0
 6367 37d0 4600001A 		bne	.L534
 6368 37d4 14779FE5 		ldr	r7, .L565+104
 6369              	.LBE230:
 6370              	.LBE227:
2249:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6371              		.loc 1 2249 0
 6372 37d8 B4569FE5 		ldr	r5, .L565+12
 6373 37dc 0260A0E1 		mov	r6, r2
2428:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6374              		.loc 1 2428 0
 6375 37e0 00A0E0E3 		mvn	sl, #0
 6376              	.LVL497:
 6377              	.L504:
2249:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6378              		.loc 1 2249 0
 6379 37e4 A8069FE5 		ldr	r0, .L565+12
 6380 37e8 0110A0E3 		mov	r1, #1
 6381 37ec 0220A0E3 		mov	r2, #2
 6382 37f0 B4308DE2 		add	r3, sp, #180
 6383 37f4 00608DE5 		str	r6, [sp, #0]
 6384 37f8 FEFFFFEB 		bl	_txe_event_flags_get
 6385 37fc 000050E3 		cmp	r0, #0
 6386 3800 2700001A 		bne	.L506
2295:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6387              		.loc 1 2295 0
 6388 3804 40E095E5 		ldr	lr, [r5, #64]
 6389 3808 00005EE3 		cmp	lr, #0
 6390 380c 0300000A 		beq	.L507
2295:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6391              		.loc 1 2295 0 is_stmt 0 discriminator 1
 6392 3810 B414D5E1 		ldrh	r1, [r5, #68]
 6393 3814 B684D5E1 		ldrh	r8, [r5, #70]
 6394 3818 080051E1 		cmp	r1, r8
 6395 381c 6000000A 		beq	.L554
 6396              	.L507:
2469:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6397              		.loc 1 2469 0 is_stmt 1
 6398 3820 4010A0E3 		mov	r1, #64
 6399 3824 0020A0E3 		mov	r2, #0
 6400 3828 64069FE5 		ldr	r0, .L565+12
 6401 382c FEFFFFEB 		bl	_txe_event_flags_set
2472:../uvc.c      ****         CyU3PThreadRelinquish ();
 6402              		.loc 1 2472 0
 6403 3830 FEFFFFEB 		bl	_txe_thread_relinquish
2473:../uvc.c      ****     }
 6404              		.loc 1 2473 0
 6405 3834 EAFFFFEA 		b	.L504
 6406              	.LVL498:
 6407              	.L537:
 6408              	.LBB265:
 6409              	.LBB226:
1714:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6410              		.loc 1 1714 0
 6411 3838 0400A0E3 		mov	r0, #4
 6412              	.LVL499:
 6413 383c B0169FE5 		ldr	r1, .L565+108
 6414 3840 FEFFFFEB 		bl	CyU3PDebugPrint
 6415              	.LVL500:
 6416              	.L469:
 6417              	.LBB222:
 6418              	.LBB223:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6419              		.loc 1 1251 0
 6420 3844 AC169FE5 		ldr	r1, .L565+112
 6421 3848 0400A0E3 		mov	r0, #4
 6422 384c FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6423              		.loc 1 1252 0
 6424 3850 FA0FA0E3 		mov	r0, #1000
 6425 3854 FEFFFFEB 		bl	_tx_thread_sleep
 6426 3858 F9FFFFEA 		b	.L469
 6427              	.LVL501:
 6428              	.L538:
 6429              	.LBE223:
 6430              	.LBE222:
1727:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6431              		.loc 1 1727 0
 6432 385c 0400A0E3 		mov	r0, #4
 6433              	.LVL502:
 6434 3860 94169FE5 		ldr	r1, .L565+116
 6435              	.LVL503:
 6436 3864 FEFFFFEB 		bl	CyU3PDebugPrint
 6437              	.L471:
 6438              	.LBB224:
 6439              	.LBB225:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6440              		.loc 1 1251 0
 6441 3868 88169FE5 		ldr	r1, .L565+112
 6442 386c 0400A0E3 		mov	r0, #4
 6443 3870 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6444              		.loc 1 1252 0
 6445 3874 FA0FA0E3 		mov	r0, #1000
 6446 3878 FEFFFFEB 		bl	_tx_thread_sleep
 6447 387c F9FFFFEA 		b	.L471
 6448              	.LVL504:
 6449              	.L539:
 6450              	.LBE225:
 6451              	.LBE224:
 6452              	.LBE226:
 6453              	.LBE265:
 6454              	.LBB266:
 6455              	.LBB229:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6456              		.loc 1 1801 0
 6457 3880 0400A0E3 		mov	r0, #4
 6458              	.LVL505:
 6459 3884 74169FE5 		ldr	r1, .L565+120
 6460 3888 FEFFFFEB 		bl	CyU3PDebugPrint
 6461              	.LVL506:
 6462              	.L473:
 6463              	.LBB239:
 6464              	.LBB240:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6465              		.loc 1 1251 0
 6466 388c 64169FE5 		ldr	r1, .L565+112
 6467 3890 0400A0E3 		mov	r0, #4
 6468 3894 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6469              		.loc 1 1252 0
 6470 3898 FA0FA0E3 		mov	r0, #1000
 6471 389c FEFFFFEB 		bl	_tx_thread_sleep
 6472 38a0 F9FFFFEA 		b	.L473
 6473              	.LVL507:
 6474              	.L506:
 6475              	.LBE240:
 6476              	.LBE239:
 6477              	.LBE229:
 6478              	.LBE266:
2396:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6479              		.loc 1 2396 0
 6480 38a4 E8059FE5 		ldr	r0, .L565+12
 6481 38a8 0210A0E3 		mov	r1, #2
 6482 38ac 0320A0E3 		mov	r2, #3
 6483 38b0 B4308DE2 		add	r3, sp, #180
 6484 38b4 00608DE5 		str	r6, [sp, #0]
 6485 38b8 FEFFFFEB 		bl	_txe_event_flags_get
 6486 38bc 000050E3 		cmp	r0, #0
 6487 38c0 1A01001A 		bne	.L518
2411:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6488              		.loc 1 2411 0
 6489 38c4 483095E5 		ldr	r3, [r5, #72]
2399:../uvc.c      ****                 hitFV     = CyFalse;
 6490              		.loc 1 2399 0
 6491 38c8 406085E5 		str	r6, [r5, #64]
2411:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6492              		.loc 1 2411 0
 6493 38cc 000053E3 		cmp	r3, #0
2400:../uvc.c      ****                 prodCount = 0;
 6494              		.loc 1 2400 0
 6495 38d0 B464C5E1 		strh	r6, [r5, #68]	@ movhi
2407:../uvc.c      ****                 fb=0;
 6496              		.loc 1 2407 0
 6497 38d4 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2401:../uvc.c      ****                 consCount = 0;
 6498              		.loc 1 2401 0
 6499 38d8 B664C5E1 		strh	r6, [r5, #70]	@ movhi
2408:../uvc.c      ****                 pb=0;
 6500              		.loc 1 2408 0
 6501 38dc B663C5E1 		strh	r6, [r5, #54]	@ movhi
2409:../uvc.c      ****                 pbc=0;
 6502              		.loc 1 2409 0
 6503 38e0 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2411:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6504              		.loc 1 2411 0
 6505 38e4 FF00000A 		beq	.L555
 6506              	.L519:
2423:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6507              		.loc 1 2423 0
 6508 38e8 486084E5 		str	r6, [r4, #72]
 6509 38ec CBFFFFEA 		b	.L507
 6510              	.LVL508:
 6511              	.L534:
 6512              	.LBB267:
 6513              	.LBB263:
2131:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6514              		.loc 1 2131 0
 6515 38f0 0400A0E3 		mov	r0, #4
 6516              	.LVL509:
 6517 38f4 08169FE5 		ldr	r1, .L565+124
 6518 38f8 FEFFFFEB 		bl	CyU3PDebugPrint
 6519              	.LVL510:
 6520              	.L505:
 6521              	.LBB241:
 6522              	.LBB242:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6523              		.loc 1 1251 0
 6524 38fc F4159FE5 		ldr	r1, .L565+112
 6525 3900 0400A0E3 		mov	r0, #4
 6526 3904 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6527              		.loc 1 1252 0
 6528 3908 FA0FA0E3 		mov	r0, #1000
 6529 390c FEFFFFEB 		bl	_tx_thread_sleep
 6530 3910 F9FFFFEA 		b	.L505
 6531              	.LVL511:
 6532              	.L553:
 6533              	.LBE242:
 6534              	.LBE241:
2106:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6535              		.loc 1 2106 0
 6536 3914 0400A0E3 		mov	r0, #4
 6537              	.LVL512:
 6538 3918 E8159FE5 		ldr	r1, .L565+128
 6539 391c FEFFFFEB 		bl	CyU3PDebugPrint
 6540              	.LVL513:
 6541              	.L501:
 6542              	.LBB243:
 6543              	.LBB244:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6544              		.loc 1 1251 0
 6545 3920 D0159FE5 		ldr	r1, .L565+112
 6546 3924 0400A0E3 		mov	r0, #4
 6547 3928 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6548              		.loc 1 1252 0
 6549 392c FA0FA0E3 		mov	r0, #1000
 6550 3930 FEFFFFEB 		bl	_tx_thread_sleep
 6551 3934 F9FFFFEA 		b	.L501
 6552              	.LVL514:
 6553              	.L546:
 6554              	.LBE244:
 6555              	.LBE243:
1885:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6556              		.loc 1 1885 0
 6557 3938 0400A0E3 		mov	r0, #4
 6558              	.LVL515:
 6559 393c C8159FE5 		ldr	r1, .L565+132
 6560 3940 FEFFFFEB 		bl	CyU3PDebugPrint
 6561              	.LVL516:
 6562              	.L487:
 6563              	.LBB245:
 6564              	.LBB246:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6565              		.loc 1 1251 0
 6566 3944 AC159FE5 		ldr	r1, .L565+112
 6567 3948 0400A0E3 		mov	r0, #4
 6568 394c FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6569              		.loc 1 1252 0
 6570 3950 FA0FA0E3 		mov	r0, #1000
 6571 3954 FEFFFFEB 		bl	_tx_thread_sleep
 6572 3958 F9FFFFEA 		b	.L487
 6573              	.LVL517:
 6574              	.L545:
 6575              	.LBE246:
 6576              	.LBE245:
1871:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6577              		.loc 1 1871 0
 6578 395c 0400A0E3 		mov	r0, #4
 6579              	.LVL518:
 6580 3960 A8159FE5 		ldr	r1, .L565+136
 6581 3964 FEFFFFEB 		bl	CyU3PDebugPrint
 6582              	.LVL519:
 6583              	.L485:
 6584              	.LBB247:
 6585              	.LBB248:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6586              		.loc 1 1251 0
 6587 3968 88159FE5 		ldr	r1, .L565+112
 6588 396c 0400A0E3 		mov	r0, #4
 6589 3970 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6590              		.loc 1 1252 0
 6591 3974 FA0FA0E3 		mov	r0, #1000
 6592 3978 FEFFFFEB 		bl	_tx_thread_sleep
 6593 397c F9FFFFEA 		b	.L485
 6594              	.LVL520:
 6595              	.L544:
 6596              	.LBE248:
 6597              	.LBE247:
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6598              		.loc 1 1857 0
 6599 3980 0400A0E3 		mov	r0, #4
 6600              	.LVL521:
 6601 3984 88159FE5 		ldr	r1, .L565+140
 6602 3988 FEFFFFEB 		bl	CyU3PDebugPrint
 6603              	.LVL522:
 6604              	.L483:
 6605              	.LBB249:
 6606              	.LBB250:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6607              		.loc 1 1251 0
 6608 398c 64159FE5 		ldr	r1, .L565+112
 6609 3990 0400A0E3 		mov	r0, #4
 6610 3994 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6611              		.loc 1 1252 0
 6612 3998 FA0FA0E3 		mov	r0, #1000
 6613 399c FEFFFFEB 		bl	_tx_thread_sleep
 6614 39a0 F9FFFFEA 		b	.L483
 6615              	.LVL523:
 6616              	.L554:
 6617              	.LBE250:
 6618              	.LBE249:
 6619              	.LBE263:
 6620              	.LBE267:
2305:../uvc.c      ****                 prodCount = 0;
 6621              		.loc 1 2305 0
 6622 39a4 B464C5E1 		strh	r6, [r5, #68]	@ movhi
2320:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6623              		.loc 1 2320 0
 6624 39a8 2C059FE5 		ldr	r0, .L565+84
2306:../uvc.c      ****                 consCount = 0;
 6625              		.loc 1 2306 0
 6626 39ac B664C5E1 		strh	r6, [r5, #70]	@ movhi
2320:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6627              		.loc 1 2320 0
 6628 39b0 0010E0E3 		mvn	r1, #0
2302:../uvc.c      ****             	fb=0;
 6629              		.loc 1 2302 0
 6630 39b4 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2303:../uvc.c      ****             	pb=0;
 6631              		.loc 1 2303 0
 6632 39b8 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2304:../uvc.c      ****             	pbc=0;
 6633              		.loc 1 2304 0
 6634 39bc B863C5E1 		strh	r6, [r5, #56]	@ movhi
2307:../uvc.c      ****                 hitFV     = CyFalse;
 6635              		.loc 1 2307 0
 6636 39c0 406085E5 		str	r6, [r5, #64]
2320:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6637              		.loc 1 2320 0
 6638 39c4 FEFFFFEB 		bl	_txe_mutex_get
2321:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6639              		.loc 1 2321 0
 6640 39c8 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
 6641 39cc 01C022E2 		eor	ip, r2, #1
 6642 39d0 81C4C7E5 		strb	ip, [r7, #1153]
2323:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 6643              		.loc 1 2323 0
 6644 39d4 3C3095E5 		ldr	r3, [r5, #60]
 6645 39d8 F00053E3 		cmp	r3, #240
 6646 39dc 7C00000A 		beq	.L556
 6647              	.L508:
2331:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 6648              		.loc 1 2331 0
 6649 39e0 3CE094E5 		ldr	lr, [r4, #60]
 6650 39e4 FF005EE3 		cmp	lr, #255
 6651 39e8 6D00000A 		beq	.L557
2343:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 6652              		.loc 1 2343 0
 6653 39ec 3C0095E5 		ldr	r0, [r5, #60]
 6654 39f0 AA0050E3 		cmp	r0, #170
 6655 39f4 4800000A 		beq	.L558
 6656              	.L509:
2371:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 6657              		.loc 1 2371 0
 6658 39f8 DC049FE5 		ldr	r0, .L565+84
 6659 39fc FEFFFFEB 		bl	_txe_mutex_put
2373:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6660              		.loc 1 2373 0
 6661 3a00 E4049FE5 		ldr	r0, .L565+100
 6662 3a04 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6663              	.LVL524:
2374:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6664              		.loc 1 2374 0
 6665 3a08 002050E2 		subs	r2, r0, #0
 6666 3a0c 3900001A 		bne	.L559
2381:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6667              		.loc 1 2381 0
 6668 3a10 0210A0E1 		mov	r1, r2
 6669 3a14 D0049FE5 		ldr	r0, .L565+100
 6670              	.LVL525:
 6671 3a18 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6672              	.LVL526:
2382:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6673              		.loc 1 2382 0
 6674 3a1c 002050E2 		subs	r2, r0, #0
 6675 3a20 2B00001A 		bne	.L560
2390:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6676              		.loc 1 2390 0
 6677 3a24 B4049FE5 		ldr	r0, .L565+88
 6678              	.LVL527:
 6679 3a28 0210A0E1 		mov	r1, r2
 6680 3a2c 0280A0E3 		mov	r8, #2
 6681 3a30 0020A0E1 		mov	r2, r0
 6682              	.LVL528:
 6683 3a34 0130A0E1 		mov	r3, r1
 6684 3a38 00808DE5 		str	r8, [sp, #0]
 6685 3a3c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6686              	.LVL529:
 6687 3a40 76FFFFEA 		b	.L507
 6688              	.LVL530:
 6689              	.L543:
 6690              	.LBB268:
 6691              	.LBB228:
1844:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6692              		.loc 1 1844 0
 6693 3a44 0400A0E3 		mov	r0, #4
 6694              	.LVL531:
 6695 3a48 C8149FE5 		ldr	r1, .L565+144
 6696 3a4c FEFFFFEB 		bl	CyU3PDebugPrint
 6697              	.LVL532:
 6698              	.L481:
 6699              	.LBB237:
 6700              	.LBB238:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6701              		.loc 1 1251 0
 6702 3a50 A0149FE5 		ldr	r1, .L565+112
 6703 3a54 0400A0E3 		mov	r0, #4
 6704 3a58 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6705              		.loc 1 1252 0
 6706 3a5c FA0FA0E3 		mov	r0, #1000
 6707 3a60 FEFFFFEB 		bl	_tx_thread_sleep
 6708 3a64 F9FFFFEA 		b	.L481
 6709              	.LVL533:
 6710              	.L541:
 6711              	.LBE238:
 6712              	.LBE237:
1832:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6713              		.loc 1 1832 0
 6714 3a68 0400A0E3 		mov	r0, #4
 6715              	.LVL534:
 6716 3a6c A8149FE5 		ldr	r1, .L565+148
 6717 3a70 FEFFFFEB 		bl	CyU3PDebugPrint
 6718              	.LVL535:
 6719              	.L477:
 6720              	.LBB235:
 6721              	.LBB236:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6722              		.loc 1 1251 0
 6723 3a74 7C149FE5 		ldr	r1, .L565+112
 6724 3a78 0400A0E3 		mov	r0, #4
 6725 3a7c FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6726              		.loc 1 1252 0
 6727 3a80 FA0FA0E3 		mov	r0, #1000
 6728 3a84 FEFFFFEB 		bl	_tx_thread_sleep
 6729 3a88 F9FFFFEA 		b	.L477
 6730              	.LVL536:
 6731              	.L540:
 6732              	.LBE236:
 6733              	.LBE235:
1823:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6734              		.loc 1 1823 0
 6735 3a8c 0400A0E3 		mov	r0, #4
 6736              	.LVL537:
 6737 3a90 88149FE5 		ldr	r1, .L565+152
 6738 3a94 FEFFFFEB 		bl	CyU3PDebugPrint
 6739              	.LVL538:
 6740              	.L475:
 6741              	.LBB233:
 6742              	.LBB234:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6743              		.loc 1 1251 0
 6744 3a98 58149FE5 		ldr	r1, .L565+112
 6745 3a9c 0400A0E3 		mov	r0, #4
 6746 3aa0 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6747              		.loc 1 1252 0
 6748 3aa4 FA0FA0E3 		mov	r0, #1000
 6749 3aa8 FEFFFFEB 		bl	_tx_thread_sleep
 6750 3aac F9FFFFEA 		b	.L475
 6751              	.LVL539:
 6752              	.L542:
 6753              	.LBE234:
 6754              	.LBE233:
1838:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6755              		.loc 1 1838 0
 6756 3ab0 0400A0E3 		mov	r0, #4
 6757              	.LVL540:
 6758 3ab4 68149FE5 		ldr	r1, .L565+156
 6759 3ab8 FEFFFFEB 		bl	CyU3PDebugPrint
 6760              	.LVL541:
 6761              	.L479:
 6762              	.LBB231:
 6763              	.LBB232:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6764              		.loc 1 1251 0
 6765 3abc 34149FE5 		ldr	r1, .L565+112
 6766 3ac0 0400A0E3 		mov	r0, #4
 6767 3ac4 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6768              		.loc 1 1252 0
 6769 3ac8 FA0FA0E3 		mov	r0, #1000
 6770 3acc FEFFFFEB 		bl	_tx_thread_sleep
 6771 3ad0 F9FFFFEA 		b	.L479
 6772              	.LVL542:
 6773              	.L560:
 6774              	.LBE232:
 6775              	.LBE231:
 6776              	.LBE228:
 6777              	.LBE268:
2384:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6778              		.loc 1 2384 0
 6779 3ad4 0400A0E3 		mov	r0, #4
 6780              	.LVL543:
 6781 3ad8 48149FE5 		ldr	r1, .L565+160
 6782 3adc FEFFFFEB 		bl	CyU3PDebugPrint
 6783              	.LVL544:
 6784              	.L517:
 6785              	.LBB269:
 6786              	.LBB270:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6787              		.loc 1 1251 0
 6788 3ae0 10149FE5 		ldr	r1, .L565+112
 6789 3ae4 0400A0E3 		mov	r0, #4
 6790 3ae8 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6791              		.loc 1 1252 0
 6792 3aec FA0FA0E3 		mov	r0, #1000
 6793 3af0 FEFFFFEB 		bl	_tx_thread_sleep
 6794 3af4 F9FFFFEA 		b	.L517
 6795              	.LVL545:
 6796              	.L559:
 6797              	.LBE270:
 6798              	.LBE269:
2376:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6799              		.loc 1 2376 0
 6800 3af8 0400A0E3 		mov	r0, #4
 6801              	.LVL546:
 6802 3afc 28149FE5 		ldr	r1, .L565+164
 6803 3b00 FEFFFFEB 		bl	CyU3PDebugPrint
 6804              	.LVL547:
 6805              	.L515:
 6806              	.LBB271:
 6807              	.LBB272:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6808              		.loc 1 1251 0
 6809 3b04 EC139FE5 		ldr	r1, .L565+112
 6810 3b08 0400A0E3 		mov	r0, #4
 6811 3b0c FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6812              		.loc 1 1252 0
 6813 3b10 FA0FA0E3 		mov	r0, #1000
 6814 3b14 FEFFFFEB 		bl	_tx_thread_sleep
 6815 3b18 F9FFFFEA 		b	.L515
 6816              	.L558:
 6817              	.LBE272:
 6818              	.LBE271:
2349:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 6819              		.loc 1 2349 0
 6820 3b1c A210D5E5 		ldrb	r1, [r5, #162]	@ zero_extendqisi2
 6821 3b20 01E081E2 		add	lr, r1, #1
 6822 3b24 020051E3 		cmp	r1, #2
 6823 3b28 A2E0C5E5 		strb	lr, [r5, #162]
 6824 3b2c B1FFFF9A 		bls	.L509
2351:../uvc.c      ****                     switch (setRes)
 6825              		.loc 1 2351 0
 6826 3b30 A030D5E5 		ldrb	r3, [r5, #160]	@ zero_extendqisi2
 6827 3b34 010053E3 		cmp	r3, #1
 6828 3b38 0E00000A 		beq	.L512
 6829 3b3c 020053E3 		cmp	r3, #2
 6830 3b40 0900001A 		bne	.L511
2359:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
 6831              		.loc 1 2359 0
 6832 3b44 3010A0E3 		mov	r1, #48
 6833 3b48 0120A0E3 		mov	r2, #1
 6834 3b4c 5230A0E3 		mov	r3, #82
 6835 3b50 0B00A0E3 		mov	r0, #11
 6836 3b54 FEFFFFEB 		bl	SensorSetIrisControl
2361:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0x0b, 0x1);
 6837              		.loc 1 2361 0
 6838 3b58 0400A0E3 		mov	r0, #4
 6839 3b5c CC139FE5 		ldr	r1, .L565+168
 6840 3b60 0B20A0E3 		mov	r2, #11
 6841 3b64 0130A0E3 		mov	r3, #1
 6842 3b68 FEFFFFEB 		bl	CyU3PDebugPrint
 6843              	.L511:
2366:../uvc.c      ****                     IMcount = 0;
 6844              		.loc 1 2366 0
 6845 3b6c A260C4E5 		strb	r6, [r4, #162]
2368:../uvc.c      ****                 	stiflag = 0x0;
 6846              		.loc 1 2368 0
 6847 3b70 3C6084E5 		str	r6, [r4, #60]
 6848 3b74 9FFFFFEA 		b	.L509
 6849              	.L512:
2354:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
 6850              		.loc 1 2354 0
 6851 3b78 3010A0E3 		mov	r1, #48
 6852 3b7c 0020A0E3 		mov	r2, #0
 6853 3b80 5230A0E3 		mov	r3, #82
 6854 3b84 0B00A0E3 		mov	r0, #11
 6855 3b88 FEFFFFEB 		bl	SensorSetIrisControl
2356:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0xb, 0x0);
 6856              		.loc 1 2356 0
 6857 3b8c 9C139FE5 		ldr	r1, .L565+168
 6858 3b90 0B20A0E3 		mov	r2, #11
 6859 3b94 0030A0E3 		mov	r3, #0
 6860 3b98 0400A0E3 		mov	r0, #4
 6861 3b9c FEFFFFEB 		bl	CyU3PDebugPrint
2357:../uvc.c      ****                  		break;
 6862              		.loc 1 2357 0
 6863 3ba0 F1FFFFEA 		b	.L511
 6864              	.L557:
2333:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 6865              		.loc 1 2333 0
 6866 3ba4 A280D5E5 		ldrb	r8, [r5, #162]	@ zero_extendqisi2
 6867 3ba8 011088E2 		add	r1, r8, #1
 6868 3bac 020058E3 		cmp	r8, #2
 6869 3bb0 A210C5E5 		strb	r1, [r5, #162]
 6870 3bb4 8FFFFF9A 		bls	.L509
2334:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6871              		.loc 1 2334 0
 6872 3bb8 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2335:../uvc.c      ****                 		stiflag = 0x0F;
 6873              		.loc 1 2335 0
 6874 3bbc 0F30A0E3 		mov	r3, #15
2334:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6875              		.loc 1 2334 0
 6876 3bc0 20C082E3 		orr	ip, r2, #32
 6877 3bc4 81C4C7E5 		strb	ip, [r7, #1153]
2336:../uvc.c      ****                 		IMcount = 0;
 6878              		.loc 1 2336 0
 6879 3bc8 A260C5E5 		strb	r6, [r5, #162]
2335:../uvc.c      ****                 		stiflag = 0x0F;
 6880              		.loc 1 2335 0
 6881 3bcc 3C3085E5 		str	r3, [r5, #60]
 6882 3bd0 88FFFFEA 		b	.L509
 6883              	.L556:
2323:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 6884              		.loc 1 2323 0 discriminator 1
 6885 3bd4 B8029FE5 		ldr	r0, .L565+12
 6886 3bd8 8010A0E3 		mov	r1, #128
 6887 3bdc 0320A0E3 		mov	r2, #3
 6888 3be0 B4308DE2 		add	r3, sp, #180
 6889 3be4 00608DE5 		str	r6, [sp, #0]
 6890 3be8 FEFFFFEB 		bl	_txe_event_flags_get
 6891 3bec 000050E3 		cmp	r0, #0
2328:../uvc.c      ****                 		stiflag = 0xFF;
 6892              		.loc 1 2328 0 discriminator 1
 6893 3bf0 FF00A003 		moveq	r0, #255
 6894 3bf4 3C008505 		streq	r0, [r5, #60]
2329:../uvc.c      ****                 		IMcount = 0;
 6895              		.loc 1 2329 0 discriminator 1
 6896 3bf8 A260C505 		streqb	r6, [r5, #162]
2323:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 6897              		.loc 1 2323 0 discriminator 1
 6898 3bfc 7DFFFF0A 		beq	.L509
 6899 3c00 76FFFFEA 		b	.L508
 6900              	.LVL548:
 6901              	.L550:
 6902              	.LBB273:
 6903              	.LBB264:
1984:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6904              		.loc 1 1984 0
 6905 3c04 0400A0E3 		mov	r0, #4
 6906              	.LVL549:
 6907 3c08 24139FE5 		ldr	r1, .L565+172
 6908 3c0c 0620A0E1 		mov	r2, r6
 6909 3c10 FEFFFFEB 		bl	CyU3PDebugPrint
 6910              	.L495:
 6911              	.LBB251:
 6912              	.LBB252:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6913              		.loc 1 1251 0
 6914 3c14 DC129FE5 		ldr	r1, .L565+112
 6915 3c18 0400A0E3 		mov	r0, #4
 6916 3c1c FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6917              		.loc 1 1252 0
 6918 3c20 FA0FA0E3 		mov	r0, #1000
 6919 3c24 FEFFFFEB 		bl	_tx_thread_sleep
 6920 3c28 F9FFFFEA 		b	.L495
 6921              	.LVL550:
 6922              	.L549:
 6923              	.LBE252:
 6924              	.LBE251:
1963:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6925              		.loc 1 1963 0
 6926 3c2c 0400A0E3 		mov	r0, #4
 6927              	.LVL551:
 6928 3c30 CC129FE5 		ldr	r1, .L565+124
 6929 3c34 0320A0E1 		mov	r2, r3
 6930 3c38 FEFFFFEB 		bl	CyU3PDebugPrint
 6931              	.LVL552:
 6932              	.L493:
 6933              	.LBB253:
 6934              	.LBB254:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6935              		.loc 1 1251 0
 6936 3c3c B4129FE5 		ldr	r1, .L565+112
 6937 3c40 0400A0E3 		mov	r0, #4
 6938 3c44 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6939              		.loc 1 1252 0
 6940 3c48 FA0FA0E3 		mov	r0, #1000
 6941 3c4c FEFFFFEB 		bl	_tx_thread_sleep
 6942 3c50 F9FFFFEA 		b	.L493
 6943              	.LVL553:
 6944              	.L548:
 6945              	.LBE254:
 6946              	.LBE253:
1918:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6947              		.loc 1 1918 0
 6948 3c54 0400A0E3 		mov	r0, #4
 6949 3c58 D8129FE5 		ldr	r1, .L565+176
 6950 3c5c 0820A0E1 		mov	r2, r8
 6951 3c60 FEFFFFEB 		bl	CyU3PDebugPrint
 6952              	.L491:
 6953              	.LBB255:
 6954              	.LBB256:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6955              		.loc 1 1251 0
 6956 3c64 8C129FE5 		ldr	r1, .L565+112
 6957 3c68 0400A0E3 		mov	r0, #4
 6958 3c6c FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6959              		.loc 1 1252 0
 6960 3c70 FA0FA0E3 		mov	r0, #1000
 6961 3c74 FEFFFFEB 		bl	_tx_thread_sleep
 6962 3c78 F9FFFFEA 		b	.L491
 6963              	.LVL554:
 6964              	.L547:
 6965              	.LBE256:
 6966              	.LBE255:
1898:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6967              		.loc 1 1898 0
 6968 3c7c 0400A0E3 		mov	r0, #4
 6969              	.LVL555:
 6970 3c80 B4129FE5 		ldr	r1, .L565+180
 6971 3c84 FEFFFFEB 		bl	CyU3PDebugPrint
 6972              	.LVL556:
 6973              	.L489:
 6974              	.LBB257:
 6975              	.LBB258:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6976              		.loc 1 1251 0
 6977 3c88 68129FE5 		ldr	r1, .L565+112
 6978 3c8c 0400A0E3 		mov	r0, #4
 6979 3c90 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 6980              		.loc 1 1252 0
 6981 3c94 FA0FA0E3 		mov	r0, #1000
 6982 3c98 FEFFFFEB 		bl	_tx_thread_sleep
 6983 3c9c F9FFFFEA 		b	.L489
 6984              	.LVL557:
 6985              	.L552:
 6986              	.LBE258:
 6987              	.LBE257:
2015:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6988              		.loc 1 2015 0
 6989 3ca0 0400A0E3 		mov	r0, #4
 6990              	.LVL558:
 6991 3ca4 94129FE5 		ldr	r1, .L565+184
 6992 3ca8 FEFFFFEB 		bl	CyU3PDebugPrint
 6993              	.LVL559:
 6994              	.L499:
 6995              	.LBB259:
 6996              	.LBB260:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6997              		.loc 1 1251 0
 6998 3cac 44129FE5 		ldr	r1, .L565+112
 6999 3cb0 0400A0E3 		mov	r0, #4
 7000 3cb4 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 7001              		.loc 1 1252 0
 7002 3cb8 FA0FA0E3 		mov	r0, #1000
 7003 3cbc FEFFFFEB 		bl	_tx_thread_sleep
 7004 3cc0 F9FFFFEA 		b	.L499
 7005              	.LVL560:
 7006              	.L551:
 7007              	.LBE260:
 7008              	.LBE259:
1991:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 7009              		.loc 1 1991 0
 7010 3cc4 040080E2 		add	r0, r0, #4
 7011 3cc8 74129FE5 		ldr	r1, .L565+188
 7012 3ccc FEFFFFEB 		bl	CyU3PDebugPrint
 7013              	.LVL561:
 7014              	.L497:
 7015              	.LBB261:
 7016              	.LBB262:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7017              		.loc 1 1251 0
 7018 3cd0 20129FE5 		ldr	r1, .L565+112
 7019 3cd4 0400A0E3 		mov	r0, #4
 7020 3cd8 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 7021              		.loc 1 1252 0
 7022 3cdc FA0FA0E3 		mov	r0, #1000
 7023 3ce0 FEFFFFEB 		bl	_tx_thread_sleep
 7024 3ce4 F9FFFFEA 		b	.L497
 7025              	.LVL562:
 7026              	.L555:
 7027              	.LBE262:
 7028              	.LBE261:
 7029              	.LBE264:
 7030              	.LBE273:
2413:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7031              		.loc 1 2413 0
 7032 3ce8 FC019FE5 		ldr	r0, .L565+100
 7033 3cec FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7034              	.LVL563:
2414:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 7035              		.loc 1 2414 0
 7036 3cf0 000050E3 		cmp	r0, #0
 7037 3cf4 0200001A 		bne	.L535
2420:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 7038              		.loc 1 2420 0
 7039 3cf8 8300A0E3 		mov	r0, #131
 7040              	.LVL564:
 7041 3cfc FEFFFFEB 		bl	CyU3PUsbFlushEp
 7042 3d00 F8FEFFEA 		b	.L519
 7043              	.L535:
 7044              	.LBB274:
 7045              	.LBB275:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7046              		.loc 1 1251 0
 7047 3d04 EC119FE5 		ldr	r1, .L565+112
 7048 3d08 0400A0E3 		mov	r0, #4
 7049 3d0c FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 7050              		.loc 1 1252 0
 7051 3d10 FA0FA0E3 		mov	r0, #1000
 7052 3d14 FEFFFFEB 		bl	_tx_thread_sleep
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7053              		.loc 1 1251 0
 7054 3d18 D8119FE5 		ldr	r1, .L565+112
 7055 3d1c 0400A0E3 		mov	r0, #4
 7056 3d20 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 7057              		.loc 1 1252 0
 7058 3d24 FA0FA0E3 		mov	r0, #1000
 7059 3d28 FEFFFFEB 		bl	_tx_thread_sleep
 7060 3d2c F4FFFFEA 		b	.L535
 7061              	.L518:
 7062              	.LBE275:
 7063              	.LBE274:
2428:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7064              		.loc 1 2428 0
 7065 3d30 0110A0E3 		mov	r1, #1
 7066 3d34 0220A0E3 		mov	r2, #2
 7067 3d38 B4308DE2 		add	r3, sp, #180
 7068 3d3c 50019FE5 		ldr	r0, .L565+12
 7069 3d40 00A08DE5 		str	sl, [sp, #0]
 7070 3d44 FEFFFFEB 		bl	_txe_event_flags_get
2432:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7071              		.loc 1 2432 0
 7072 3d48 0620A0E1 		mov	r2, r6
 7073 3d4c 98019FE5 		ldr	r0, .L565+100
 7074 3d50 0610A0E1 		mov	r1, r6
 7075 3d54 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7076              	.LVL565:
2433:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7077              		.loc 1 2433 0
 7078 3d58 002050E2 		subs	r2, r0, #0
 7079 3d5c 0C00001A 		bne	.L561
2441:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 7080              		.loc 1 2441 0
 7081 3d60 28C095E5 		ldr	ip, [r5, #40]
 7082 3d64 00005CE3 		cmp	ip, #0
 7083 3d68 3500001A 		bne	.L524
 7084              	.LVL566:
 7085              	.LBB276:
 7086              	.LBB278:
2156:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7087              		.loc 1 2156 0
 7088 3d6c 4C30D5E5 		ldrb	r3, [r5, #76]	@ zero_extendqisi2
 7089 3d70 030053E3 		cmp	r3, #3
 7090 3d74 2B00000A 		beq	.L562
2161:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 7091              		.loc 1 2161 0
 7092 3d78 020053E3 		cmp	r3, #2
 7093 3d7c 0D00000A 		beq	.L563
 7094              	.LVL567:
 7095              	.L527:
 7096              	.LBE278:
 7097              	.LBE276:
2457:../uvc.c      ****                     gpif_initialized = CyTrue;
 7098              		.loc 1 2457 0
 7099 3d80 0120A0E3 		mov	r2, #1
 7100 3d84 282084E5 		str	r2, [r4, #40]
2458:../uvc.c      ****                     CyU3PThreadSleep(200);
 7101              		.loc 1 2458 0
 7102 3d88 C800A0E3 		mov	r0, #200
 7103 3d8c FEFFFFEB 		bl	_tx_thread_sleep
 7104 3d90 A2FEFFEA 		b	.L507
 7105              	.LVL568:
 7106              	.L561:
2436:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 7107              		.loc 1 2436 0
 7108 3d94 0400A0E3 		mov	r0, #4
 7109              	.LVL569:
 7110 3d98 A8119FE5 		ldr	r1, .L565+192
 7111 3d9c FEFFFFEB 		bl	CyU3PDebugPrint
 7112              	.LVL570:
 7113              	.L523:
 7114              	.LBB284:
 7115              	.LBB285:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7116              		.loc 1 1251 0
 7117 3da0 50119FE5 		ldr	r1, .L565+112
 7118 3da4 0400A0E3 		mov	r0, #4
 7119 3da8 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 7120              		.loc 1 1252 0
 7121 3dac FA0FA0E3 		mov	r0, #1000
 7122 3db0 FEFFFFEB 		bl	_tx_thread_sleep
 7123 3db4 F9FFFFEA 		b	.L523
 7124              	.LVL571:
 7125              	.L563:
 7126              	.LBE285:
 7127              	.LBE284:
 7128              	.LBB286:
 7129              	.LBB277:
2163:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 7130              		.loc 1 2163 0
 7131 3db8 8C119FE5 		ldr	r1, .L565+196
 7132 3dbc 0100A0E3 		mov	r0, #1
 7133              	.LVL572:
 7134 3dc0 FEFFFFEB 		bl	CyU3PDebugPrint
 7135              	.LVL573:
2164:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7136              		.loc 1 2164 0
 7137 3dc4 84019FE5 		ldr	r0, .L565+200
 7138 3dc8 FEFFFFEB 		bl	CyU3PGpifLoad
 7139 3dcc 0020A0E1 		mov	r2, r0
 7140              	.LVL574:
 7141              	.L526:
2166:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7142              		.loc 1 2166 0
 7143 3dd0 000052E3 		cmp	r2, #0
 7144 3dd4 2200001A 		bne	.L564
2174:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7145              		.loc 1 2174 0
 7146 3dd8 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 7147 3ddc 030053E3 		cmp	r3, #3
 7148 3de0 0100000A 		beq	.L536
2178:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 7149              		.loc 1 2178 0
 7150 3de4 020053E3 		cmp	r3, #2
 7151 3de8 E4FFFF1A 		bne	.L527
 7152              	.L536:
2180:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7153              		.loc 1 2180 0
 7154 3dec 0200A0E1 		mov	r0, r2
 7155              	.LVL575:
 7156 3df0 0210A0E1 		mov	r1, r2
 7157 3df4 FEFFFFEB 		bl	CyU3PGpifSMStart
 7158              	.LVL576:
2182:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7159              		.loc 1 2182 0
 7160 3df8 000050E3 		cmp	r0, #0
2180:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7161              		.loc 1 2180 0
 7162 3dfc 0020A0E1 		mov	r2, r0
 7163              	.LVL577:
2182:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7164              		.loc 1 2182 0
 7165 3e00 DEFFFF0A 		beq	.L527
2185:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 7166              		.loc 1 2185 0
 7167 3e04 0400A0E3 		mov	r0, #4
 7168              	.LVL578:
 7169 3e08 44119FE5 		ldr	r1, .L565+204
 7170 3e0c FEFFFFEB 		bl	CyU3PDebugPrint
 7171              	.LVL579:
 7172              	.L532:
 7173              	.LBB279:
 7174              	.LBB280:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7175              		.loc 1 1251 0
 7176 3e10 E0109FE5 		ldr	r1, .L565+112
 7177 3e14 0400A0E3 		mov	r0, #4
 7178 3e18 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 7179              		.loc 1 1252 0
 7180 3e1c FA0FA0E3 		mov	r0, #1000
 7181 3e20 FEFFFFEB 		bl	_tx_thread_sleep
 7182 3e24 F9FFFFEA 		b	.L532
 7183              	.LVL580:
 7184              	.L562:
 7185              	.LBE280:
 7186              	.LBE279:
2158:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 7187              		.loc 1 2158 0
 7188 3e28 28119FE5 		ldr	r1, .L565+208
 7189 3e2c 0100A0E3 		mov	r0, #1
 7190              	.LVL581:
 7191 3e30 FEFFFFEB 		bl	CyU3PDebugPrint
 7192              	.LVL582:
2159:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7193              		.loc 1 2159 0
 7194 3e34 20019FE5 		ldr	r0, .L565+212
 7195 3e38 FEFFFFEB 		bl	CyU3PGpifLoad
 7196 3e3c 0020A0E1 		mov	r2, r0
 7197              	.LVL583:
 7198 3e40 E2FFFFEA 		b	.L526
 7199              	.LVL584:
 7200              	.L524:
 7201              	.LBE277:
 7202              	.LBE286:
2465:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7203              		.loc 1 2465 0
 7204 3e44 94009FE5 		ldr	r0, .L565+88
 7205              	.LVL585:
 7206 3e48 02E0A0E3 		mov	lr, #2
 7207 3e4c 0610A0E1 		mov	r1, r6
 7208 3e50 0020A0E1 		mov	r2, r0
 7209              	.LVL586:
 7210 3e54 0630A0E1 		mov	r3, r6
 7211 3e58 00E08DE5 		str	lr, [sp, #0]
 7212 3e5c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7213 3e60 6EFEFFEA 		b	.L507
 7214              	.LVL587:
 7215              	.L564:
 7216              	.LBB287:
 7217              	.LBB283:
2169:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 7218              		.loc 1 2169 0
 7219 3e64 0400A0E3 		mov	r0, #4
 7220              	.LVL588:
 7221 3e68 F0109FE5 		ldr	r1, .L565+216
 7222 3e6c FEFFFFEB 		bl	CyU3PDebugPrint
 7223              	.LVL589:
 7224              	.L529:
 7225              	.LBB281:
 7226              	.LBB282:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7227              		.loc 1 1251 0
 7228 3e70 80109FE5 		ldr	r1, .L565+112
 7229 3e74 0400A0E3 		mov	r0, #4
 7230 3e78 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 7231              		.loc 1 1252 0
 7232 3e7c FA0FA0E3 		mov	r0, #1000
 7233 3e80 FEFFFFEB 		bl	_tx_thread_sleep
 7234 3e84 F9FFFFEA 		b	.L529
 7235              	.L566:
 7236              		.align	2
 7237              	.L565:
 7238 3e88 58070000 		.word	.LC42
 7239 3e8c 00C20100 		.word	115200
 7240 3e90 A0860100 		.word	100000
 7241 3e94 00000000 		.word	.LANCHOR0
 7242 3e98 00000000 		.word	CyFxGpifCB
 7243 3e9c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7244 3ea0 00000000 		.word	CyFxUVCApplnUSBEventCB
 7245 3ea4 00000000 		.word	CyFxUSBDeviceDscr
 7246 3ea8 00000000 		.word	CyFxUSBDeviceDscrSS
 7247 3eac 00000000 		.word	CyFxUSBDeviceQualDscr
 7248 3eb0 00000000 		.word	CyFxUSBBOSDscr
 7249 3eb4 00000000 		.word	CyFxUSBHSConfigDscr
 7250 3eb8 00000000 		.word	CyFxUSBFSConfigDscr
 7251 3ebc 00000000 		.word	CyFxUSBSSConfigDscr
 7252 3ec0 00000000 		.word	CyFxUSBStringLangIDDscr
 7253 3ec4 00000000 		.word	CyFxUSBManufactureDscr
 7254 3ec8 00000000 		.word	CyFxUSBProductDscr
 7255 3ecc 013F0000 		.word	16129
 7256 3ed0 02030000 		.word	770
 7257 3ed4 00000000 		.word	glChHandleInterStat
 7258 3ed8 00000000 		.word	glInterStaBuffer
 7259 3edc 00000000 		.word	imgHdMux
 7260 3ee0 01010000 		.word	257
 7261 3ee4 03030000 		.word	771
 7262 3ee8 00000000 		.word	CyFxUvcApplnDmaCallback
 7263 3eec 00000000 		.word	glChHandleUVCStream
 7264 3ef0 00000000 		.word	.LANCHOR1
 7265 3ef4 78070000 		.word	.LC43
 7266 3ef8 D4010000 		.word	.LC12
 7267 3efc 94070000 		.word	.LC44
 7268 3f00 B0070000 		.word	.LC45
 7269 3f04 80090000 		.word	.LC55
 7270 3f08 5C0A0000 		.word	.LC59
 7271 3f0c E8080000 		.word	.LC52
 7272 3f10 B4080000 		.word	.LC51
 7273 3f14 80080000 		.word	.LC50
 7274 3f18 54080000 		.word	.LC49
 7275 3f1c 00080000 		.word	.LC47
 7276 3f20 DC070000 		.word	.LC46
 7277 3f24 28080000 		.word	.LC48
 7278 3f28 D40A0000 		.word	.LC62
 7279 3f2c A80A0000 		.word	.LC61
 7280 3f30 840A0000 		.word	.LC60
 7281 3f34 B4090000 		.word	.LC56
 7282 3f38 50090000 		.word	.LC54
 7283 3f3c 20090000 		.word	.LC53
 7284 3f40 2C0A0000 		.word	.LC58
 7285 3f44 F4090000 		.word	.LC57
 7286 3f48 080B0000 		.word	.LC63
 7287 3f4c 4C0B0000 		.word	.LC65
 7288 3f50 2C000000 		.word	.LANCHOR2+44
 7289 3f54 940B0000 		.word	.LC67
 7290 3f58 3C0B0000 		.word	.LC64
 7291 3f5c 10000000 		.word	.LANCHOR2+16
 7292 3f60 5C0B0000 		.word	.LC66
 7293              	.LBE282:
 7294              	.LBE281:
 7295              	.LBE283:
 7296              	.LBE287:
 7297              		.cfi_endproc
 7298              	.LFE18:
 7300              		.align	2
 7301              		.global	CyFxUVCApplnI2CInit
 7303              	CyFxUVCApplnI2CInit:
 7304              	.LFB14:
1707:../uvc.c      **** {
 7305              		.loc 1 1707 0
 7306              		.cfi_startproc
 7307              		@ args = 0, pretend = 0, frame = 16
 7308              		@ frame_needed = 0, uses_anonymous_args = 0
 7309 3f64 04E02DE5 		str	lr, [sp, #-4]!
 7310              	.LCFI25:
 7311              		.cfi_def_cfa_offset 4
 7312 3f68 14D04DE2 		sub	sp, sp, #20
 7313              	.LCFI26:
 7314              		.cfi_def_cfa_offset 24
1711:../uvc.c      ****     status = CyU3PI2cInit ();
 7315              		.loc 1 1711 0
 7316              		.cfi_offset 14, -4
 7317 3f6c FEFFFFEB 		bl	CyU3PI2cInit
 7318              	.LVL590:
1712:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7319              		.loc 1 1712 0
 7320 3f70 002050E2 		subs	r2, r0, #0
 7321 3f74 0B00001A 		bne	.L572
1719:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7322              		.loc 1 1719 0
 7323 3f78 70C09FE5 		ldr	ip, .L574
1721:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7324              		.loc 1 1721 0
 7325 3f7c 0030E0E3 		mvn	r3, #0
1724:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7326              		.loc 1 1724 0
 7327 3f80 0D00A0E1 		mov	r0, sp
 7328              	.LVL591:
 7329 3f84 0210A0E1 		mov	r1, r2
1719:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7330              		.loc 1 1719 0
 7331 3f88 00C08DE5 		str	ip, [sp, #0]
1720:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7332              		.loc 1 1720 0
 7333 3f8c 0C008DE9 		stmib	sp, {r2, r3}	@ phole stm
1722:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7334              		.loc 1 1722 0
 7335 3f90 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1724:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7336              		.loc 1 1724 0
 7337 3f94 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7338              	.LVL592:
1725:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7339              		.loc 1 1725 0
 7340 3f98 000050E3 		cmp	r0, #0
 7341 3f9c 0A00001A 		bne	.L573
1730:../uvc.c      **** }
 7342              		.loc 1 1730 0
 7343 3fa0 14D08DE2 		add	sp, sp, #20
 7344 3fa4 04F09DE4 		ldmfd	sp!, {pc}
 7345              	.L572:
1714:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7346              		.loc 1 1714 0
 7347 3fa8 0400A0E3 		mov	r0, #4
 7348              	.LVL593:
 7349 3fac 40109FE5 		ldr	r1, .L574+4
 7350 3fb0 FEFFFFEB 		bl	CyU3PDebugPrint
 7351              	.LVL594:
 7352              	.L569:
 7353              	.LBB292:
 7354              	.LBB293:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7355              		.loc 1 1251 0
 7356 3fb4 3C109FE5 		ldr	r1, .L574+8
 7357 3fb8 0400A0E3 		mov	r0, #4
 7358 3fbc FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 7359              		.loc 1 1252 0
 7360 3fc0 FA0FA0E3 		mov	r0, #1000
 7361 3fc4 FEFFFFEB 		bl	_tx_thread_sleep
 7362 3fc8 F9FFFFEA 		b	.L569
 7363              	.LVL595:
 7364              	.L573:
 7365              	.LBE293:
 7366              	.LBE292:
1727:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7367              		.loc 1 1727 0
 7368 3fcc 0400A0E3 		mov	r0, #4
 7369              	.LVL596:
 7370 3fd0 24109FE5 		ldr	r1, .L574+12
 7371 3fd4 FEFFFFEB 		bl	CyU3PDebugPrint
 7372              	.L571:
 7373              	.LBB294:
 7374              	.LBB295:
1251:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7375              		.loc 1 1251 0
 7376 3fd8 18109FE5 		ldr	r1, .L574+8
 7377 3fdc 0400A0E3 		mov	r0, #4
 7378 3fe0 FEFFFFEB 		bl	CyU3PDebugPrint
1252:../uvc.c      ****         CyU3PThreadSleep (1000);
 7379              		.loc 1 1252 0
 7380 3fe4 FA0FA0E3 		mov	r0, #1000
 7381 3fe8 FEFFFFEB 		bl	_tx_thread_sleep
 7382 3fec F9FFFFEA 		b	.L571
 7383              	.L575:
 7384              		.align	2
 7385              	.L574:
 7386 3ff0 A0860100 		.word	100000
 7387 3ff4 78070000 		.word	.LC43
 7388 3ff8 D4010000 		.word	.LC12
 7389 3ffc 94070000 		.word	.LC44
 7390              	.LBE295:
 7391              	.LBE294:
 7392              		.cfi_endproc
 7393              	.LFE14:
 7395              		.align	2
 7396              		.global	CyFxApplicationDefine
 7398              	CyFxApplicationDefine:
 7399              	.LFB26:
3736:../uvc.c      **** }
3737:../uvc.c      **** 
3738:../uvc.c      **** 
3739:../uvc.c      **** /*
3740:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3741:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3742:../uvc.c      ****  */
3743:../uvc.c      **** void
3744:../uvc.c      **** CyFxApplicationDefine (
3745:../uvc.c      ****         void)
3746:../uvc.c      **** {
 7400              		.loc 1 3746 0
 7401              		.cfi_startproc
 7402              		@ args = 0, pretend = 0, frame = 40
 7403              		@ frame_needed = 0, uses_anonymous_args = 0
 7404              	.LVL597:
 7405 4000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7406              	.LCFI27:
 7407              		.cfi_def_cfa_offset 36
3747:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3748:../uvc.c      ****     uint32_t retThrdCreate;
3749:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3750:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3751:../uvc.c      **** 
3752:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3753:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7408              		.loc 1 3753 0
 7409 4004 010AA0E3 		mov	r0, #4096
3746:../uvc.c      **** {
 7410              		.loc 1 3746 0
 7411 4008 4CD04DE2 		sub	sp, sp, #76
 7412              	.LCFI28:
 7413              		.cfi_def_cfa_offset 112
 7414              		.loc 1 3753 0
 7415              		.cfi_offset 14, -4
 7416              		.cfi_offset 11, -8
 7417              		.cfi_offset 10, -12
 7418              		.cfi_offset 9, -16
 7419              		.cfi_offset 8, -20
 7420              		.cfi_offset 7, -24
 7421              		.cfi_offset 6, -28
 7422              		.cfi_offset 5, -32
 7423              		.cfi_offset 4, -36
 7424 400c FEFFFFEB 		bl	CyU3PMemAlloc
 7425 4010 00A0A0E1 		mov	sl, r0
 7426              	.LVL598:
3754:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7427              		.loc 1 3754 0
 7428 4014 010AA0E3 		mov	r0, #4096
 7429              	.LVL599:
 7430 4018 FEFFFFEB 		bl	CyU3PMemAlloc
 7431 401c 00B0A0E1 		mov	fp, r0
 7432              	.LVL600:
3755:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7433              		.loc 1 3755 0
 7434 4020 010AA0E3 		mov	r0, #4096
 7435              	.LVL601:
 7436 4024 FEFFFFEB 		bl	CyU3PMemAlloc
3756:../uvc.c      **** 
3757:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7437              		.loc 1 3757 0
 7438 4028 00005AE3 		cmp	sl, #0
 7439 402c 00005B13 		cmpne	fp, #0
 7440 4030 0090A013 		movne	r9, #0
 7441 4034 0190A003 		moveq	r9, #1
3755:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7442              		.loc 1 3755 0
 7443 4038 24008DE5 		str	r0, [sp, #36]
 7444              	.LVL602:
 7445              		.loc 1 3757 0
 7446 403c 0000001A 		bne	.L580
 7447              	.LVL603:
 7448              	.L577:
 7449              	.L579:
 7450 4040 FEFFFFEA 		b	.L579
 7451              	.L580:
 7452              		.loc 1 3757 0 is_stmt 0 discriminator 1
 7453 4044 000050E3 		cmp	r0, #0
 7454 4048 FCFFFF0A 		beq	.L577
3758:../uvc.c      ****         goto fatalErrorHandler;
3759:../uvc.c      **** 
3760:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3761:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7455              		.loc 1 3761 0 is_stmt 1
 7456 404c 28408DE2 		add	r4, sp, #40
 7457 4050 0400A0E1 		mov	r0, r4
 7458 4054 4010A0E3 		mov	r1, #64
 7459 4058 18219FE5 		ldr	r2, .L581
 7460 405c FEFFFFEB 		bl	cmdbufCreate
 7461 4060 0450A0E1 		mov	r5, r4
 7462 4064 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7463 4068 0C719FE5 		ldr	r7, .L581+4
3762:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7464              		.loc 1 3762 0
 7465 406c 0C819FE5 		ldr	r8, .L581+8
3761:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7466              		.loc 1 3761 0
 7467 4070 07C0A0E1 		mov	ip, r7
 7468 4074 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7469 4078 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3763:../uvc.c      **** 
3764:../uvc.c      **** 	/****** initialize command descriptor ***********/
3765:../uvc.c      **** 	cmdquInit(cmdQuptr);
3766:../uvc.c      **** 	cmdquInit(statQuptr);
3767:../uvc.c      **** 
3768:../uvc.c      ****     /* Create the UVC application thread. */
3769:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7470              		.loc 1 3769 0
 7471 407c 0860A0E3 		mov	r6, #8
3761:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7472              		.loc 1 3761 0
 7473 4080 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3762:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7474              		.loc 1 3762 0
 7475 4084 F8209FE5 		ldr	r2, .L581+12
 7476 4088 0400A0E1 		mov	r0, r4
 7477 408c 2010A0E3 		mov	r1, #32
 7478 4090 FEFFFFEB 		bl	cmdbufCreate
 7479 4094 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7480 4098 08C0A0E1 		mov	ip, r8
 7481 409c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7482 40a0 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7483              		.loc 1 3769 0
 7484 40a4 0140A0E3 		mov	r4, #1
3762:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7485              		.loc 1 3762 0
 7486 40a8 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3765:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7487              		.loc 1 3765 0
 7488 40ac 0700A0E1 		mov	r0, r7
 7489 40b0 FEFFFFEB 		bl	cmdquInit
3766:../uvc.c      **** 	cmdquInit(statQuptr);
 7490              		.loc 1 3766 0
 7491 40b4 0800A0E1 		mov	r0, r8
 7492 40b8 FEFFFFEB 		bl	cmdquInit
 7493              		.loc 1 3769 0
 7494 40bc A850A0E3 		mov	r5, #168
 7495 40c0 01CAA0E3 		mov	ip, #4096
 7496 40c4 BC009FE5 		ldr	r0, .L581+16
 7497 40c8 BC109FE5 		ldr	r1, .L581+20
 7498 40cc BC209FE5 		ldr	r2, .L581+24
 7499 40d0 0930A0E1 		mov	r3, r9
 7500 40d4 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7501 40d8 08608DE5 		str	r6, [sp, #8]
 7502 40dc 0C608DE5 		str	r6, [sp, #12]
 7503 40e0 10908DE5 		str	r9, [sp, #16]
 7504 40e4 14408DE5 		str	r4, [sp, #20]
 7505 40e8 18508DE5 		str	r5, [sp, #24]
 7506 40ec FEFFFFEB 		bl	_txe_thread_create
 7507              	.LVL604:
3770:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3771:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3772:../uvc.c      ****             0,                                          /* No input parameter to thread */
3773:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3774:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3775:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3776:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3777:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3778:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3779:../uvc.c      ****             );
3780:../uvc.c      ****     if (retThrdCreate != 0)
 7508              		.loc 1 3780 0
 7509 40f0 00C050E2 		subs	ip, r0, #0
 7510 40f4 D1FFFF1A 		bne	.L577
3781:../uvc.c      ****     {
3782:../uvc.c      ****         goto fatalErrorHandler;
3783:../uvc.c      ****     }
3784:../uvc.c      **** 
3785:../uvc.c      ****     /* Create the control request handling thread. */
3786:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7511              		.loc 1 3786 0
 7512 40f8 0C30A0E1 		mov	r3, ip
 7513 40fc 027BA0E3 		mov	r7, #2048
 7514 4100 8C009FE5 		ldr	r0, .L581+28
 7515              	.LVL605:
 7516 4104 8C109FE5 		ldr	r1, .L581+32
 7517 4108 8C209FE5 		ldr	r2, .L581+36
 7518 410c 10C08DE5 		str	ip, [sp, #16]
 7519 4110 00B08DE5 		str	fp, [sp, #0]
 7520 4114 04708DE5 		str	r7, [sp, #4]
 7521 4118 08608DE5 		str	r6, [sp, #8]
 7522 411c 0C608DE5 		str	r6, [sp, #12]
 7523 4120 14408DE5 		str	r4, [sp, #20]
 7524 4124 18508DE5 		str	r5, [sp, #24]
 7525 4128 FEFFFFEB 		bl	_txe_thread_create
 7526              	.LVL606:
3787:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3788:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3789:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3790:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3791:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3792:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3793:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3794:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3795:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3796:../uvc.c      ****             );
3797:../uvc.c      ****     if (retThrdCreate != 0)
 7527              		.loc 1 3797 0
 7528 412c 00C050E2 		subs	ip, r0, #0
 7529 4130 C2FFFF1A 		bne	.L577
3798:../uvc.c      ****     {
3799:../uvc.c      ****         goto fatalErrorHandler;
3800:../uvc.c      ****     }
3801:../uvc.c      **** #if 1
3802:../uvc.c      ****     /* Create the I2C control command handling thread. */
3803:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7530              		.loc 1 3803 0
 7531 4134 24E09DE5 		ldr	lr, [sp, #36]
 7532 4138 60009FE5 		ldr	r0, .L581+40
 7533              	.LVL607:
 7534 413c 60109FE5 		ldr	r1, .L581+44
 7535 4140 60209FE5 		ldr	r2, .L581+48
 7536 4144 0C30A0E1 		mov	r3, ip
 7537 4148 00E08DE5 		str	lr, [sp, #0]
 7538 414c 04708DE5 		str	r7, [sp, #4]
 7539 4150 08608DE5 		str	r6, [sp, #8]
 7540 4154 0C608DE5 		str	r6, [sp, #12]
 7541 4158 10C08DE5 		str	ip, [sp, #16]
 7542 415c 14408DE5 		str	r4, [sp, #20]
 7543 4160 18508DE5 		str	r5, [sp, #24]
 7544 4164 FEFFFFEB 		bl	_txe_thread_create
 7545              	.LVL608:
3804:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3805:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3806:../uvc.c      ****             0,                                          /* No input parameter to thread */
3807:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3808:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3809:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3810:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3811:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3812:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3813:../uvc.c      ****             );
3814:../uvc.c      ****     if (retThrdCreate != 0)
 7546              		.loc 1 3814 0
 7547 4168 000050E3 		cmp	r0, #0
 7548 416c B3FFFF1A 		bne	.L577
3815:../uvc.c      ****     {
3816:../uvc.c      ****         goto fatalErrorHandler;
3817:../uvc.c      ****     }
3818:../uvc.c      **** #endif
3819:../uvc.c      **** 
3820:../uvc.c      ****     return;
3821:../uvc.c      **** 
3822:../uvc.c      **** fatalErrorHandler:
3823:../uvc.c      ****     /* Add custom recovery or debug actions here */
3824:../uvc.c      ****     /* Loop indefinitely */
3825:../uvc.c      ****     while (1);
3826:../uvc.c      **** }
 7549              		.loc 1 3826 0
 7550 4170 4CD08DE2 		add	sp, sp, #76
 7551 4174 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7552              	.L582:
 7553              		.align	2
 7554              	.L581:
 7555 4178 00000000 		.word	cmdQuMux
 7556 417c 00000000 		.word	cmdQu
 7557 4180 00000000 		.word	statQu
 7558 4184 00000000 		.word	staQuMux
 7559 4188 A4000000 		.word	.LANCHOR0+164
 7560 418c CC0B0000 		.word	.LC68
 7561 4190 00000000 		.word	UVCAppThread_Entry
 7562 4194 4C010000 		.word	.LANCHOR0+332
 7563 4198 E00B0000 		.word	.LC69
 7564 419c 00000000 		.word	UVCAppEP0Thread_Entry
 7565 41a0 F4010000 		.word	.LANCHOR0+500
 7566 41a4 F80B0000 		.word	.LC70
 7567 41a8 00000000 		.word	I2cAppThread_Entry
 7568              		.cfi_endproc
 7569              	.LFE26:
 7571              		.align	2
 7572              		.global	main
 7574              	main:
 7575              	.LFB27:
3827:../uvc.c      **** 
3828:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3829:../uvc.c      ****  * the ThreadX RTOS here.
3830:../uvc.c      ****  */
3831:../uvc.c      **** int
3832:../uvc.c      **** main (
3833:../uvc.c      ****         void)
3834:../uvc.c      **** {
 7576              		.loc 1 3834 0
 7577              		.cfi_startproc
 7578              		@ args = 0, pretend = 0, frame = 56
 7579              		@ frame_needed = 0, uses_anonymous_args = 0
 7580 41ac 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7581              	.LCFI29:
 7582              		.cfi_def_cfa_offset 12
3835:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3836:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3837:../uvc.c      **** 
3838:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3839:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3840:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3841:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3842:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3843:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7583              		.loc 1 3843 0
 7584 41b0 0010A0E3 		mov	r1, #0
3834:../uvc.c      **** {
 7585              		.loc 1 3834 0
 7586 41b4 3CD04DE2 		sub	sp, sp, #60
 7587              	.LCFI30:
 7588              		.cfi_def_cfa_offset 72
3840:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7589              		.loc 1 3840 0
 7590 41b8 0220A0E3 		mov	r2, #2
3844:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7591              		.loc 1 3844 0
 7592 41bc 033081E2 		add	r3, r1, #3
3839:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7593              		.loc 1 3839 0
 7594 41c0 0150A0E3 		mov	r5, #1
 7595              		.cfi_offset 14, -4
 7596              		.cfi_offset 5, -8
 7597              		.cfi_offset 4, -12
3845:../uvc.c      **** 
3846:../uvc.c      ****     /* Initialize the device */
3847:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7598              		.loc 1 3847 0
 7599 41c4 28008DE2 		add	r0, sp, #40
3839:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7600              		.loc 1 3839 0
 7601 41c8 28508DE5 		str	r5, [sp, #40]
3840:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7602              		.loc 1 3840 0
 7603 41cc 2C20CDE5 		strb	r2, [sp, #44]
3841:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7604              		.loc 1 3841 0
 7605 41d0 2D20CDE5 		strb	r2, [sp, #45]
3842:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7606              		.loc 1 3842 0
 7607 41d4 2E20CDE5 		strb	r2, [sp, #46]
3843:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7608              		.loc 1 3843 0
 7609 41d8 30108DE5 		str	r1, [sp, #48]
3844:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7610              		.loc 1 3844 0
 7611 41dc 3430CDE5 		strb	r3, [sp, #52]
 7612              		.loc 1 3847 0
 7613 41e0 FEFFFFEB 		bl	CyU3PDeviceInit
 7614              	.LVL609:
3848:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7615              		.loc 1 3848 0
 7616 41e4 004050E2 		subs	r4, r0, #0
 7617 41e8 0000000A 		beq	.L586
 7618              	.L584:
 7619              	.L585:
 7620 41ec FEFFFFEA 		b	.L585
 7621              	.L586:
3849:../uvc.c      ****     {
3850:../uvc.c      ****         goto handle_fatal_error;
3851:../uvc.c      ****     }
3852:../uvc.c      **** 
3853:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3854:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7622              		.loc 1 3854 0
 7623 41f0 0410A0E1 		mov	r1, r4
 7624 41f4 0420A0E1 		mov	r2, r4
 7625 41f8 0500A0E1 		mov	r0, r5
 7626              	.LVL610:
 7627 41fc FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7628              	.LVL611:
3855:../uvc.c      **** 
3856:../uvc.c      ****     /* Configure the IO matrix for the device. */
3857:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3858:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3859:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3860:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3861:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3862:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3863:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3864:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3865:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3866:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3867:../uvc.c      **** 
3868:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7629              		.loc 1 3868 0
 7630 4200 0D00A0E1 		mov	r0, sp
3858:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7631              		.loc 1 3858 0
 7632 4204 1640CDE5 		strb	r4, [sp, #22]
3859:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7633              		.loc 1 3859 0
 7634 4208 18408DE5 		str	r4, [sp, #24]
3860:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7635              		.loc 1 3860 0
 7636 420c 1C408DE5 		str	r4, [sp, #28]
3861:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7637              		.loc 1 3861 0
 7638 4210 20408DE5 		str	r4, [sp, #32]
3862:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7639              		.loc 1 3862 0
 7640 4214 24408DE5 		str	r4, [sp, #36]
3865:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7641              		.loc 1 3865 0
 7642 4218 0C408DE5 		str	r4, [sp, #12]
3866:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7643              		.loc 1 3866 0
 7644 421c 10408DE5 		str	r4, [sp, #16]
3857:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7645              		.loc 1 3857 0
 7646 4220 00508DE5 		str	r5, [sp, #0]
3863:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7647              		.loc 1 3863 0
 7648 4224 04508DE5 		str	r5, [sp, #4]
3864:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7649              		.loc 1 3864 0
 7650 4228 08508DE5 		str	r5, [sp, #8]
 7651              		.loc 1 3868 0
 7652 422c FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7653              	.LVL612:
3869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7654              		.loc 1 3869 0
 7655 4230 004050E2 		subs	r4, r0, #0
 7656 4234 ECFFFF1A 		bne	.L584
3870:../uvc.c      ****     {
3871:../uvc.c      ****         goto handle_fatal_error;
3872:../uvc.c      ****     }
3873:../uvc.c      **** 
3874:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3875:../uvc.c      ****     CyU3PKernelEntry ();
 7657              		.loc 1 3875 0
 7658 4238 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7659              	.LVL613:
3876:../uvc.c      **** 
3877:../uvc.c      ****     /* Dummy return to make the compiler happy */
3878:../uvc.c      ****     return 0;
3879:../uvc.c      **** 
3880:../uvc.c      **** handle_fatal_error:
3881:../uvc.c      ****     /* Cannot recover from this error. */
3882:../uvc.c      ****     while (1);
3883:../uvc.c      **** }
 7660              		.loc 1 3883 0
 7661 423c 0400A0E1 		mov	r0, r4
 7662 4240 3CD08DE2 		add	sp, sp, #60
 7663 4244 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7664              		.cfi_endproc
 7665              	.LFE27:
 7667              		.global	CyFxGpifTransition
 7668              		.global	CyFxGpifWavedata
 7669              		.global	CyFxGpifWavedataPosition
 7670              		.global	CyFxGpifRegValue
 7671              		.global	CyFxGpifConfig
 7672              		.global	CyFxGpifTransition_usb2
 7673              		.global	CyFxGpifWavedata_usb2
 7674              		.global	CyFxGpifWavedataPosition_usb2
 7675              		.global	CyFxGpifRegValue_usb2
 7676              		.global	CyFxGpifConfig_usb2
 7677              		.global	snapButFlag
 7678              		.global	testSnap
 7679              		.global	fb
 7680              		.global	pb
 7681              		.global	pbc
 7682              		.global	fbbak
 7683              		.global	pbbak
 7684              		.global	pbcbak
 7685              		.global	pbcpbak
 7686              		.global	isUsbConnected
 7687              		.global	usbSpeed
 7688              		.global	clearFeatureRqtReceived
 7689              		.global	streamingStarted
 7690              		.global	glProbeCtrl
 7691              		.global	glProbeStilCtrl
 7692              		.global	glProbeCtrl20
 7693              		.global	glProbeStilCtrl20
 7694              		.global	glUVCHeader
 7695              		.comm	glChHandleUVCStream,220,4
 7696              		.comm	glChHandleStillStream,220,4
 7697              		.comm	glChHandleInterStat,160,4
 7698              		.comm	glInterStaBuffer,4,4
 7699              		.comm	cmdQu,32,4
 7700              		.comm	statQu,32,4
 7701              		.comm	cmdQuMux,56,4
 7702              		.comm	staQuMux,56,4
 7703              		.comm	timMux,56,4
 7704              		.comm	imgHdMux,56,4
 7705              		.comm	bmReqType,1,1
 7706              		.comm	bRequest,1,1
 7707              		.comm	wValue,2,2
 7708              		.comm	wIndex,2,2
 7709              		.comm	wLength,2,2
 7710              		.comm	posTick,4,4
 7711              		.comm	I2CCmdTimer,44,4
 7712              		.section	.rodata
 7713              		.align	2
 7714              		.set	.LANCHOR2,. + 0
 7717              	ExTime:
 7718 0000 9C       		.byte	-100
 7719 0001 00       		.byte	0
 7720 0002 4E       		.byte	78
 7721 0003 00       		.byte	0
 7722 0004 27       		.byte	39
 7723 0005 00       		.byte	0
 7724 0006 14       		.byte	20
 7725 0007 00       		.byte	0
 7726 0008 0A       		.byte	10
 7727 0009 00       		.byte	0
 7728 000a 05       		.byte	5
 7729 000b 00       		.byte	0
 7730 000c 02       		.byte	2
 7731 000d 00       		.byte	0
 7732 000e 01       		.byte	1
 7733 000f 00       		.byte	0
 7736              	CyFxGpifConfig:
 7737 0010 0F00     		.short	15
 7738 0012 0000     		.space	2
 7739 0014 00000000 		.word	CyFxGpifWavedata
 7740 0018 00000000 		.word	CyFxGpifWavedataPosition
 7741 001c 0500     		.short	5
 7742 001e 0000     		.space	2
 7743 0020 00000000 		.word	CyFxGpifTransition
 7744 0024 4C00     		.short	76
 7745 0026 0000     		.space	2
 7746 0028 00000000 		.word	CyFxGpifRegValue
 7749              	CyFxGpifConfig_usb2:
 7750 002c 9300     		.short	147
 7751 002e 0000     		.space	2
 7752 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7753 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7754 0038 0800     		.short	8
 7755 003a 0000     		.space	2
 7756 003c 00000000 		.word	CyFxGpifTransition_usb2
 7757 0040 4C00     		.short	76
 7758 0042 0000     		.space	2
 7759 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7760              		.data
 7761              		.align	2
 7762              		.set	.LANCHOR1,. + 0
 7765              	ExUCtrlParArry:
 7766 0000 00       		.byte	0
 7767 0001 00       		.byte	0
 7768 0002 04       		.byte	4
 7769 0003 01       		.byte	1
 7770 0004 00       		.byte	0
 7771 0005 38       		.byte	56
 7772 0006 01       		.byte	1
 7773 0007 01       		.byte	1
 7774 0008 00       		.byte	0
 7775 0009 03       		.byte	3
 7776 000a 00       		.byte	0
 7777 000b 4E       		.byte	78
 7778 000c 00       		.byte	0
 7779 000d 4E       		.byte	78
 7780 000e 00       		.byte	0
 7781 000f 30       		.byte	48
 7782 0010 01       		.byte	1
 7783 0011 00       		.byte	0
 7784 0012 00       		.byte	0
 7785 0013 00000000 		.space	5
 7785      00
 7786 0018 00       		.byte	0
 7787 0019 00       		.byte	0
 7788 001a 01       		.byte	1
 7789 001b 00       		.byte	0
 7790 001c 00       		.byte	0
 7791 001d 00       		.byte	0
 7792 001e 00       		.byte	0
 7793 001f 01       		.byte	1
 7794 0020 00       		.byte	0
 7795 0021 03       		.byte	3
 7796 0022 00       		.byte	0
 7797 0023 00       		.byte	0
 7798 0024 00       		.byte	0
 7799 0025 00       		.byte	0
 7800 0026 00       		.byte	0
 7801 0027 30       		.byte	48
 7802 0028 01       		.byte	1
 7803 0029 00       		.byte	0
 7804 002a 00       		.byte	0
 7805 002b 00000000 		.space	5
 7805      00
 7806 0030 00       		.byte	0
 7807 0031 00       		.byte	0
 7808 0032 02       		.byte	2
 7809 0033 00       		.byte	0
 7810 0034 00       		.byte	0
 7811 0035 FF       		.byte	-1
 7812 0036 00       		.byte	0
 7813 0037 01       		.byte	1
 7814 0038 00       		.byte	0
 7815 0039 03       		.byte	3
 7816 003a 00       		.byte	0
 7817 003b 01       		.byte	1
 7818 003c 00       		.byte	0
 7819 003d 00       		.byte	0
 7820 003e 00       		.byte	0
 7821 003f 30       		.byte	48
 7822 0040 01       		.byte	1
 7823 0041 01       		.byte	1
 7824 0042 00       		.byte	0
 7825 0043 00000000 		.space	5
 7825      00
 7826 0048 00       		.byte	0
 7827 0049 00       		.byte	0
 7828 004a 02       		.byte	2
 7829 004b 00       		.byte	0
 7830 004c 00       		.byte	0
 7831 004d 00       		.byte	0
 7832 004e 00       		.byte	0
 7833 004f 00       		.byte	0
 7834 0050 00       		.byte	0
 7835 0051 03       		.byte	3
 7836 0052 00       		.byte	0
 7837 0053 00       		.byte	0
 7838 0054 00       		.byte	0
 7839 0055 00       		.byte	0
 7840 0056 00       		.byte	0
 7841 0057 30       		.byte	48
 7842 0058 01       		.byte	1
 7843 0059 01       		.byte	1
 7844 005a 00       		.byte	0
 7845 005b 00000000 		.space	5
 7845      00
 7846 0060 13       		.byte	19
 7847 0061 14       		.byte	20
 7848 0062 02       		.byte	2
 7849 0063 01       		.byte	1
 7850 0064 00       		.byte	0
 7851 0065 03       		.byte	3
 7852 0066 00       		.byte	0
 7853 0067 01       		.byte	1
 7854 0068 00       		.byte	0
 7855 0069 03       		.byte	3
 7856 006a 00       		.byte	0
 7857 006b 23       		.byte	35
 7858 006c 37       		.byte	55
 7859 006d 23       		.byte	35
 7860 006e 37       		.byte	55
 7861 006f 30       		.byte	48
 7862 0070 01       		.byte	1
 7863 0071 00       		.byte	0
 7864 0072 00       		.byte	0
 7865 0073 00000000 		.space	5
 7865      00
 7866 0078 11       		.byte	17
 7867 0079 00       		.byte	0
 7868 007a 02       		.byte	2
 7869 007b 01       		.byte	1
 7870 007c 00       		.byte	0
 7871 007d 03       		.byte	3
 7872 007e 00       		.byte	0
 7873 007f 01       		.byte	1
 7874 0080 00       		.byte	0
 7875 0081 03       		.byte	3
 7876 0082 00       		.byte	0
 7877 0083 01       		.byte	1
 7878 0084 00       		.byte	0
 7879 0085 01       		.byte	1
 7880 0086 00       		.byte	0
 7881 0087 30       		.byte	48
 7882 0088 01       		.byte	1
 7883 0089 01       		.byte	1
 7884 008a 00       		.byte	0
 7885 008b 00000000 		.space	5
 7885      00
 7886 0090 17       		.byte	23
 7887 0091 00       		.byte	0
 7888 0092 01       		.byte	1
 7889 0093 01       		.byte	1
 7890 0094 00       		.byte	0
 7891 0095 02       		.byte	2
 7892 0096 00       		.byte	0
 7893 0097 01       		.byte	1
 7894 0098 00       		.byte	0
 7895 0099 03       		.byte	3
 7896 009a 00       		.byte	0
 7897 009b 00       		.byte	0
 7898 009c 00       		.byte	0
 7899 009d 00       		.byte	0
 7900 009e 00       		.byte	0
 7901 009f 30       		.byte	48
 7902 00a0 01       		.byte	1
 7903 00a1 01       		.byte	1
 7904 00a2 00       		.byte	0
 7905 00a3 00000000 		.space	5
 7905      00
 7906 00a8 00       		.byte	0
 7907 00a9 00       		.byte	0
 7908 00aa 04       		.byte	4
 7909 00ab 01       		.byte	1
 7910 00ac 00       		.byte	0
 7911 00ad 38       		.byte	56
 7912 00ae 01       		.byte	1
 7913 00af 01       		.byte	1
 7914 00b0 00       		.byte	0
 7915 00b1 03       		.byte	3
 7916 00b2 00       		.byte	0
 7917 00b3 4E       		.byte	78
 7918 00b4 00       		.byte	0
 7919 00b5 4E       		.byte	78
 7920 00b6 00       		.byte	0
 7921 00b7 30       		.byte	48
 7922 00b8 01       		.byte	1
 7923 00b9 00       		.byte	0
 7924 00ba 00       		.byte	0
 7925 00bb 00000000 		.space	5
 7925      00
 7926 00c0 00       		.byte	0
 7927 00c1 00       		.byte	0
 7928 00c2 01       		.byte	1
 7929 00c3 00       		.byte	0
 7930 00c4 00       		.byte	0
 7931 00c5 00       		.byte	0
 7932 00c6 00       		.byte	0
 7933 00c7 01       		.byte	1
 7934 00c8 00       		.byte	0
 7935 00c9 03       		.byte	3
 7936 00ca 00       		.byte	0
 7937 00cb 00       		.byte	0
 7938 00cc 00       		.byte	0
 7939 00cd 00       		.byte	0
 7940 00ce 00       		.byte	0
 7941 00cf 30       		.byte	48
 7942 00d0 01       		.byte	1
 7943 00d1 00       		.byte	0
 7944 00d2 00       		.byte	0
 7945 00d3 00000000 		.space	5
 7945      00
 7946 00d8 00       		.byte	0
 7947 00d9 00       		.byte	0
 7948 00da 02       		.byte	2
 7949 00db 00       		.byte	0
 7950 00dc 00       		.byte	0
 7951 00dd 05       		.byte	5
 7952 00de 00       		.byte	0
 7953 00df 01       		.byte	1
 7954 00e0 00       		.byte	0
 7955 00e1 03       		.byte	3
 7956 00e2 00       		.byte	0
 7957 00e3 00       		.byte	0
 7958 00e4 00       		.byte	0
 7959 00e5 00       		.byte	0
 7960 00e6 00       		.byte	0
 7961 00e7 30       		.byte	48
 7962 00e8 01       		.byte	1
 7963 00e9 00       		.byte	0
 7964 00ea 00       		.byte	0
 7965 00eb 00000000 		.space	5
 7965      00
 7966 00f0 00       		.byte	0
 7967 00f1 00       		.byte	0
 7968 00f2 03       		.byte	3
 7969 00f3 00       		.byte	0
 7970 00f4 00       		.byte	0
 7971 00f5 0A       		.byte	10
 7972 00f6 00       		.byte	0
 7973 00f7 01       		.byte	1
 7974 00f8 00       		.byte	0
 7975 00f9 03       		.byte	3
 7976 00fa 00       		.byte	0
 7977 00fb 00       		.byte	0
 7978 00fc 00       		.byte	0
 7979 00fd 00       		.byte	0
 7980 00fe 00       		.byte	0
 7981 00ff 30       		.byte	48
 7982 0100 01       		.byte	1
 7983 0101 00       		.byte	0
 7984 0102 00       		.byte	0
 7985 0103 00000000 		.space	5
 7985      00
 7986 0108 00       		.byte	0
 7987 0109 00       		.byte	0
 7988 010a 02       		.byte	2
 7989 010b 00       		.byte	0
 7990 010c 00       		.byte	0
 7991 010d 40       		.byte	64
 7992 010e 00       		.byte	0
 7993 010f 01       		.byte	1
 7994 0110 00       		.byte	0
 7995 0111 03       		.byte	3
 7996 0112 00       		.byte	0
 7997 0113 0F       		.byte	15
 7998 0114 11       		.byte	17
 7999 0115 00       		.byte	0
 8000 0116 00       		.byte	0
 8001 0117 30       		.byte	48
 8002 0118 01       		.byte	1
 8003 0119 00       		.byte	0
 8004 011a 00       		.byte	0
 8005 011b 00000000 		.space	5
 8005      00
 8006 0120 00       		.byte	0
 8007 0121 00       		.byte	0
 8008 0122 02       		.byte	2
 8009 0123 00       		.byte	0
 8010 0124 00       		.byte	0
 8011 0125 64       		.byte	100
 8012 0126 00       		.byte	0
 8013 0127 01       		.byte	1
 8014 0128 00       		.byte	0
 8015 0129 03       		.byte	3
 8016 012a 00       		.byte	0
 8017 012b 00       		.byte	0
 8018 012c 00       		.byte	0
 8019 012d 00       		.byte	0
 8020 012e 00       		.byte	0
 8021 012f 30       		.byte	48
 8022 0130 01       		.byte	1
 8023 0131 00       		.byte	0
 8024 0132 00       		.byte	0
 8025 0133 00000000 		.space	5
 8025      00
 8026 0138 00       		.byte	0
 8027 0139 00       		.byte	0
 8028 013a 02       		.byte	2
 8029 013b 00       		.byte	0
 8030 013c 00       		.byte	0
 8031 013d 64       		.byte	100
 8032 013e 00       		.byte	0
 8033 013f 01       		.byte	1
 8034 0140 00       		.byte	0
 8035 0141 03       		.byte	3
 8036 0142 00       		.byte	0
 8037 0143 00       		.byte	0
 8038 0144 00       		.byte	0
 8039 0145 00       		.byte	0
 8040 0146 00       		.byte	0
 8041 0147 30       		.byte	48
 8042 0148 01       		.byte	1
 8043 0149 00       		.byte	0
 8044 014a 00       		.byte	0
 8045 014b 00000000 		.space	5
 8045      00
 8046 0150 00       		.byte	0
 8047 0151 00       		.byte	0
 8048 0152 02       		.byte	2
 8049 0153 00       		.byte	0
 8050 0154 00       		.byte	0
 8051 0155 64       		.byte	100
 8052 0156 00       		.byte	0
 8053 0157 01       		.byte	1
 8054 0158 00       		.byte	0
 8055 0159 03       		.byte	3
 8056 015a 00       		.byte	0
 8057 015b 00       		.byte	0
 8058 015c 00       		.byte	0
 8059 015d 00       		.byte	0
 8060 015e 00       		.byte	0
 8061 015f 30       		.byte	48
 8062 0160 01       		.byte	1
 8063 0161 00       		.byte	0
 8064 0162 00       		.byte	0
 8065 0163 00000000 		.space	5
 8065      00
 8066 0168 00       		.byte	0
 8067 0169 00       		.byte	0
 8068 016a 02       		.byte	2
 8069 016b 00       		.byte	0
 8070 016c 00       		.byte	0
 8071 016d 64       		.byte	100
 8072 016e 00       		.byte	0
 8073 016f 01       		.byte	1
 8074 0170 00       		.byte	0
 8075 0171 03       		.byte	3
 8076 0172 00       		.byte	0
 8077 0173 00       		.byte	0
 8078 0174 00       		.byte	0
 8079 0175 00       		.byte	0
 8080 0176 00       		.byte	0
 8081 0177 30       		.byte	48
 8082 0178 01       		.byte	1
 8083 0179 00       		.byte	0
 8084 017a 00       		.byte	0
 8085 017b 00000000 		.space	5
 8085      00
 8088              	CtrlParArry:
 8089 0180 10       		.byte	16
 8090 0181 10       		.byte	16
 8091 0182 02       		.byte	2
 8092 0183 00       		.byte	0
 8093 0184 00       		.byte	0
 8094 0185 03       		.byte	3
 8095 0186 00       		.byte	0
 8096 0187 01       		.byte	1
 8097 0188 00       		.byte	0
 8098 0189 03       		.byte	3
 8099 018a 00       		.byte	0
 8100 018b 00       		.byte	0
 8101 018c 00       		.byte	0
 8102 018d 00       		.byte	0
 8103 018e 00       		.byte	0
 8104 018f 30       		.byte	48
 8105 0190 01       		.byte	1
 8106 0191 00       		.byte	0
 8107 0192 00       		.byte	0
 8108 0193 00000000 		.space	5
 8108      00
 8109 0198 01       		.byte	1
 8110 0199 00       		.byte	0
 8111 019a 02       		.byte	2
 8112 019b 00       		.byte	0
 8113 019c 00       		.byte	0
 8114 019d FF       		.byte	-1
 8115 019e 00       		.byte	0
 8116 019f 01       		.byte	1
 8117 01a0 00       		.byte	0
 8118 01a1 03       		.byte	3
 8119 01a2 00       		.byte	0
 8120 01a3 76       		.byte	118
 8121 01a4 00       		.byte	0
 8122 01a5 76       		.byte	118
 8123 01a6 C7       		.byte	-57
 8124 01a7 C6       		.byte	-58
 8125 01a8 01       		.byte	1
 8126 01a9 01       		.byte	1
 8127 01aa 00       		.byte	0
 8128 01ab 00000000 		.space	5
 8128      00
 8129 01b0 02       		.byte	2
 8130 01b1 02       		.byte	2
 8131 01b2 02       		.byte	2
 8132 01b3 00       		.byte	0
 8133 01b4 00       		.byte	0
 8134 01b5 FF       		.byte	-1
 8135 01b6 00       		.byte	0
 8136 01b7 01       		.byte	1
 8137 01b8 00       		.byte	0
 8138 01b9 03       		.byte	3
 8139 01ba 00       		.byte	0
 8140 01bb 70       		.byte	112
 8141 01bc 00       		.byte	0
 8142 01bd 70       		.byte	112
 8143 01be 00       		.byte	0
 8144 01bf C6       		.byte	-58
 8145 01c0 01       		.byte	1
 8146 01c1 01       		.byte	1
 8147 01c2 00       		.byte	0
 8148 01c3 00000000 		.space	5
 8148      00
 8149 01c8 00       		.byte	0
 8150 01c9 00       		.byte	0
 8151 01ca 02       		.byte	2
 8152 01cb 00       		.byte	0
 8153 01cc 00       		.byte	0
 8154 01cd 64       		.byte	100
 8155 01ce 00       		.byte	0
 8156 01cf 01       		.byte	1
 8157 01d0 00       		.byte	0
 8158 01d1 03       		.byte	3
 8159 01d2 00       		.byte	0
 8160 01d3 00       		.byte	0
 8161 01d4 00       		.byte	0
 8162 01d5 00       		.byte	0
 8163 01d6 00       		.byte	0
 8164 01d7 30       		.byte	48
 8165 01d8 01       		.byte	1
 8166 01d9 00       		.byte	0
 8167 01da 00       		.byte	0
 8168 01db 00000000 		.space	5
 8168      00
 8169 01e0 07       		.byte	7
 8170 01e1 07       		.byte	7
 8171 01e2 02       		.byte	2
 8172 01e3 00       		.byte	0
 8173 01e4 00       		.byte	0
 8174 01e5 01       		.byte	1
 8175 01e6 00       		.byte	0
 8176 01e7 01       		.byte	1
 8177 01e8 00       		.byte	0
 8178 01e9 03       		.byte	3
 8179 01ea 00       		.byte	0
 8180 01eb 01       		.byte	1
 8181 01ec 00       		.byte	0
 8182 01ed 01       		.byte	1
 8183 01ee 00       		.byte	0
 8184 01ef 30       		.byte	48
 8185 01f0 01       		.byte	1
 8186 01f1 00       		.byte	0
 8187 01f2 00       		.byte	0
 8188 01f3 00000000 		.space	5
 8188      00
 8189 01f8 DF       		.byte	-33
 8190 01f9 E1       		.byte	-31
 8191 01fa 02       		.byte	2
 8192 01fb 00       		.byte	0
 8193 01fc 00       		.byte	0
 8194 01fd FF       		.byte	-1
 8195 01fe 00       		.byte	0
 8196 01ff 01       		.byte	1
 8197 0200 00       		.byte	0
 8198 0201 03       		.byte	3
 8199 0202 00       		.byte	0
 8200 0203 80       		.byte	-128
 8201 0204 00       		.byte	0
 8202 0205 00       		.byte	0
 8203 0206 00       		.byte	0
 8204 0207 C6       		.byte	-58
 8205 0208 01       		.byte	1
 8206 0209 01       		.byte	1
 8207 020a 00       		.byte	0
 8208 020b 00000000 		.space	5
 8208      00
 8209 0210 85       		.byte	-123
 8210 0211 86       		.byte	-122
 8211 0212 02       		.byte	2
 8212 0213 00       		.byte	0
 8213 0214 00       		.byte	0
 8214 0215 64       		.byte	100
 8215 0216 00       		.byte	0
 8216 0217 01       		.byte	1
 8217 0218 00       		.byte	0
 8218 0219 03       		.byte	3
 8219 021a 00       		.byte	0
 8220 021b 32       		.byte	50
 8221 021c 00       		.byte	0
 8222 021d 32       		.byte	50
 8223 021e 00       		.byte	0
 8224 021f F2       		.byte	-14
 8225 0220 01       		.byte	1
 8226 0221 01       		.byte	1
 8227 0222 00       		.byte	0
 8228 0223 00000000 		.space	5
 8228      00
 8229 0228 06       		.byte	6
 8230 0229 06       		.byte	6
 8231 022a 02       		.byte	2
 8232 022b 00       		.byte	0
 8233 022c 00       		.byte	0
 8234 022d 40       		.byte	64
 8235 022e 00       		.byte	0
 8236 022f 01       		.byte	1
 8237 0230 00       		.byte	0
 8238 0231 03       		.byte	3
 8239 0232 00       		.byte	0
 8240 0233 20       		.byte	32
 8241 0234 00       		.byte	0
 8242 0235 20       		.byte	32
 8243 0236 00       		.byte	0
 8244 0237 30       		.byte	48
 8245 0238 01       		.byte	1
 8246 0239 01       		.byte	1
 8247 023a 00       		.byte	0
 8248 023b 00000000 		.space	5
 8248      00
 8249 0240 00       		.byte	0
 8250 0241 00       		.byte	0
 8251 0242 02       		.byte	2
 8252 0243 00       		.byte	0
 8253 0244 00       		.byte	0
 8254 0245 64       		.byte	100
 8255 0246 00       		.byte	0
 8256 0247 01       		.byte	1
 8257 0248 00       		.byte	0
 8258 0249 03       		.byte	3
 8259 024a 00       		.byte	0
 8260 024b 00       		.byte	0
 8261 024c 00       		.byte	0
 8262 024d 00       		.byte	0
 8263 024e 00       		.byte	0
 8264 024f 30       		.byte	48
 8265 0250 01       		.byte	1
 8266 0251 00       		.byte	0
 8267 0252 00       		.byte	0
 8268 0253 00000000 		.space	5
 8268      00
 8269 0258 08       		.byte	8
 8270 0259 08       		.byte	8
 8271 025a 02       		.byte	2
 8272 025b 00       		.byte	0
 8273 025c 00       		.byte	0
 8274 025d 05       		.byte	5
 8275 025e 00       		.byte	0
 8276 025f 01       		.byte	1
 8277 0260 00       		.byte	0
 8278 0261 03       		.byte	3
 8279 0262 00       		.byte	0
 8280 0263 00       		.byte	0
 8281 0264 00       		.byte	0
 8282 0265 00       		.byte	0
 8283 0266 00       		.byte	0
 8284 0267 30       		.byte	48
 8285 0268 01       		.byte	1
 8286 0269 00       		.byte	0
 8287 026a 00       		.byte	0
 8288 026b 00000000 		.space	5
 8288      00
 8289 0270 00       		.byte	0
 8290 0271 00       		.byte	0
 8291 0272 02       		.byte	2
 8292 0273 00       		.byte	0
 8293 0274 00       		.byte	0
 8294 0275 40       		.byte	64
 8295 0276 00       		.byte	0
 8296 0277 01       		.byte	1
 8297 0278 00       		.byte	0
 8298 0279 03       		.byte	3
 8299 027a 00       		.byte	0
 8300 027b 00       		.byte	0
 8301 027c 00       		.byte	0
 8302 027d 00       		.byte	0
 8303 027e 00       		.byte	0
 8304 027f 30       		.byte	48
 8305 0280 01       		.byte	1
 8306 0281 00       		.byte	0
 8307 0282 00       		.byte	0
 8308 0283 00000000 		.space	5
 8308      00
 8309 0288 09       		.byte	9
 8310 0289 0A       		.byte	10
 8311 028a 04       		.byte	4
 8312 028b 00       		.byte	0
 8313 028c 00       		.byte	0
 8314 028d 40       		.byte	64
 8315 028e 00       		.byte	0
 8316 028f 01       		.byte	1
 8317 0290 00       		.byte	0
 8318 0291 03       		.byte	3
 8319 0292 00       		.byte	0
 8320 0293 20       		.byte	32
 8321 0294 38       		.byte	56
 8322 0295 20       		.byte	32
 8323 0296 38       		.byte	56
 8324 0297 30       		.byte	48
 8325 0298 01       		.byte	1
 8326 0299 00       		.byte	0
 8327 029a 00       		.byte	0
 8328 029b 00000000 		.space	5
 8328      00
 8329 02a0 00       		.byte	0
 8330 02a1 00       		.byte	0
 8331 02a2 02       		.byte	2
 8332 02a3 00       		.byte	0
 8333 02a4 00       		.byte	0
 8334 02a5 64       		.byte	100
 8335 02a6 00       		.byte	0
 8336 02a7 01       		.byte	1
 8337 02a8 00       		.byte	0
 8338 02a9 03       		.byte	3
 8339 02aa 00       		.byte	0
 8340 02ab 00       		.byte	0
 8341 02ac 00       		.byte	0
 8342 02ad 00       		.byte	0
 8343 02ae 00       		.byte	0
 8344 02af 30       		.byte	48
 8345 02b0 01       		.byte	1
 8346 02b1 00       		.byte	0
 8347 02b2 00       		.byte	0
 8348 02b3 00000000 		.space	5
 8348      00
 8349 02b8 00       		.byte	0
 8350 02b9 00       		.byte	0
 8351 02ba 02       		.byte	2
 8352 02bb 00       		.byte	0
 8353 02bc 00       		.byte	0
 8354 02bd 64       		.byte	100
 8355 02be 00       		.byte	0
 8356 02bf 01       		.byte	1
 8357 02c0 00       		.byte	0
 8358 02c1 03       		.byte	3
 8359 02c2 00       		.byte	0
 8360 02c3 00       		.byte	0
 8361 02c4 00       		.byte	0
 8362 02c5 00       		.byte	0
 8363 02c6 00       		.byte	0
 8364 02c7 30       		.byte	48
 8365 02c8 01       		.byte	1
 8366 02c9 00       		.byte	0
 8367 02ca 00       		.byte	0
 8368 02cb 00000000 		.space	5
 8368      00
 8369 02d0 2A       		.byte	42
 8370 02d1 2A       		.byte	42
 8371 02d2 02       		.byte	2
 8372 02d3 00       		.byte	0
 8373 02d4 00       		.byte	0
 8374 02d5 1B       		.byte	27
 8375 02d6 00       		.byte	0
 8376 02d7 01       		.byte	1
 8377 02d8 00       		.byte	0
 8378 02d9 03       		.byte	3
 8379 02da 00       		.byte	0
 8380 02db 00       		.byte	0
 8381 02dc 00       		.byte	0
 8382 02dd 00       		.byte	0
 8383 02de 00       		.byte	0
 8384 02df 30       		.byte	48
 8385 02e0 01       		.byte	1
 8386 02e1 00       		.byte	0
 8387 02e2 00       		.byte	0
 8388 02e3 00000000 		.space	5
 8388      00
 8389 02e8 00       		.byte	0
 8390 02e9 00       		.byte	0
 8391 02ea 02       		.byte	2
 8392 02eb 00       		.byte	0
 8393 02ec 00       		.byte	0
 8394 02ed 64       		.byte	100
 8395 02ee 00       		.byte	0
 8396 02ef 01       		.byte	1
 8397 02f0 00       		.byte	0
 8398 02f1 03       		.byte	3
 8399 02f2 00       		.byte	0
 8400 02f3 00       		.byte	0
 8401 02f4 00       		.byte	0
 8402 02f5 00       		.byte	0
 8403 02f6 00       		.byte	0
 8404 02f7 30       		.byte	48
 8405 02f8 01       		.byte	1
 8406 02f9 00       		.byte	0
 8407 02fa 00       		.byte	0
 8408 02fb 00000000 		.space	5
 8408      00
 8409 0300 00       		.byte	0
 8410 0301 00       		.byte	0
 8411 0302 02       		.byte	2
 8412 0303 00       		.byte	0
 8413 0304 00       		.byte	0
 8414 0305 12       		.byte	18
 8415 0306 00       		.byte	0
 8416 0307 01       		.byte	1
 8417 0308 00       		.byte	0
 8418 0309 03       		.byte	3
 8419 030a 00       		.byte	0
 8420 030b 00       		.byte	0
 8421 030c 00       		.byte	0
 8422 030d 00       		.byte	0
 8423 030e 00       		.byte	0
 8424 030f 30       		.byte	48
 8425 0310 01       		.byte	1
 8426 0311 00       		.byte	0
 8427 0312 00       		.byte	0
 8428 0313 00000000 		.space	5
 8428      00
 8429 0318 01       		.byte	1
 8430 0319 01       		.byte	1
 8431 031a 02       		.byte	2
 8432 031b 00       		.byte	0
 8433 031c 00       		.byte	0
 8434 031d 09       		.byte	9
 8435 031e 00       		.byte	0
 8436 031f 01       		.byte	1
 8437 0320 00       		.byte	0
 8438 0321 03       		.byte	3
 8439 0322 00       		.byte	0
 8440 0323 00       		.byte	0
 8441 0324 00       		.byte	0
 8442 0325 01       		.byte	1
 8443 0326 00       		.byte	0
 8444 0327 30       		.byte	48
 8445 0328 01       		.byte	1
 8446 0329 00       		.byte	0
 8447 032a 00       		.byte	0
 8448 032b 00000000 		.space	5
 8448      00
 8449 0330 05       		.byte	5
 8450 0331 05       		.byte	5
 8451 0332 02       		.byte	2
 8452 0333 00       		.byte	0
 8453 0334 00       		.byte	0
 8454 0335 03       		.byte	3
 8455 0336 00       		.byte	0
 8456 0337 01       		.byte	1
 8457 0338 00       		.byte	0
 8458 0339 03       		.byte	3
 8459 033a 00       		.byte	0
 8460 033b 00       		.byte	0
 8461 033c 00       		.byte	0
 8462 033d 00       		.byte	0
 8463 033e 00       		.byte	0
 8464 033f 30       		.byte	48
 8465 0340 01       		.byte	1
 8466 0341 00       		.byte	0
 8467 0342 00       		.byte	0
 8468 0343 00000000 		.space	5
 8468      00
 8469 0348 18       		.byte	24
 8470 0349 18       		.byte	24
 8471 034a 02       		.byte	2
 8472 034b 00       		.byte	0
 8473 034c 00       		.byte	0
 8474 034d 01       		.byte	1
 8475 034e 00       		.byte	0
 8476 034f 01       		.byte	1
 8477 0350 00       		.byte	0
 8478 0351 03       		.byte	3
 8479 0352 00       		.byte	0
 8480 0353 00       		.byte	0
 8481 0354 00       		.byte	0
 8482 0355 00       		.byte	0
 8483 0356 00       		.byte	0
 8484 0357 30       		.byte	48
 8485 0358 01       		.byte	1
 8486 0359 00       		.byte	0
 8487 035a 00       		.byte	0
 8488 035b 00000000 		.space	5
 8488      00
 8489 0360 19       		.byte	25
 8490 0361 19       		.byte	25
 8491 0362 01       		.byte	1
 8492 0363 00       		.byte	0
 8493 0364 00       		.byte	0
 8494 0365 40       		.byte	64
 8495 0366 00       		.byte	0
 8496 0367 01       		.byte	1
 8497 0368 00       		.byte	0
 8498 0369 03       		.byte	3
 8499 036a 00       		.byte	0
 8500 036b 20       		.byte	32
 8501 036c 00       		.byte	0
 8502 036d 20       		.byte	32
 8503 036e 00       		.byte	0
 8504 036f 30       		.byte	48
 8505 0370 01       		.byte	1
 8506 0371 00       		.byte	0
 8507 0372 00       		.byte	0
 8508 0373 00000000 		.space	5
 8508      00
 8509 0378 20       		.byte	32
 8510 0379 20       		.byte	32
 8511 037a 02       		.byte	2
 8512 037b 00       		.byte	0
 8513 037c 00       		.byte	0
 8514 037d 02       		.byte	2
 8515 037e 00       		.byte	0
 8516 037f 01       		.byte	1
 8517 0380 00       		.byte	0
 8518 0381 03       		.byte	3
 8519 0382 00       		.byte	0
 8520 0383 00       		.byte	0
 8521 0384 00       		.byte	0
 8522 0385 00       		.byte	0
 8523 0386 00       		.byte	0
 8524 0387 30       		.byte	48
 8525 0388 01       		.byte	1
 8526 0389 00       		.byte	0
 8527 038a 00       		.byte	0
 8528 038b 00000000 		.space	5
 8528      00
 8529 0390 22       		.byte	34
 8530 0391 22       		.byte	34
 8531 0392 02       		.byte	2
 8532 0393 00       		.byte	0
 8533 0394 00       		.byte	0
 8534 0395 3F       		.byte	63
 8535 0396 00       		.byte	0
 8536 0397 01       		.byte	1
 8537 0398 00       		.byte	0
 8538 0399 03       		.byte	3
 8539 039a 00       		.byte	0
 8540 039b 00       		.byte	0
 8541 039c 00       		.byte	0
 8542 039d 00       		.byte	0
 8543 039e 00       		.byte	0
 8544 039f 30       		.byte	48
 8545 03a0 01       		.byte	1
 8546 03a1 00       		.byte	0
 8547 03a2 00       		.byte	0
 8548 03a3 00000000 		.space	5
 8548      00
 8549 03a8 23       		.byte	35
 8550 03a9 23       		.byte	35
 8551 03aa 02       		.byte	2
 8552 03ab 00       		.byte	0
 8553 03ac 00       		.byte	0
 8554 03ad 64       		.byte	100
 8555 03ae 00       		.byte	0
 8556 03af 01       		.byte	1
 8557 03b0 00       		.byte	0
 8558 03b1 03       		.byte	3
 8559 03b2 00       		.byte	0
 8560 03b3 10       		.byte	16
 8561 03b4 00       		.byte	0
 8562 03b5 10       		.byte	16
 8563 03b6 00       		.byte	0
 8564 03b7 30       		.byte	48
 8565 03b8 01       		.byte	1
 8566 03b9 00       		.byte	0
 8567 03ba 00       		.byte	0
 8568 03bb 00000000 		.space	5
 8568      00
 8569 03c0 24       		.byte	36
 8570 03c1 24       		.byte	36
 8571 03c2 02       		.byte	2
 8572 03c3 00       		.byte	0
 8573 03c4 00       		.byte	0
 8574 03c5 64       		.byte	100
 8575 03c6 00       		.byte	0
 8576 03c7 01       		.byte	1
 8577 03c8 00       		.byte	0
 8578 03c9 03       		.byte	3
 8579 03ca 00       		.byte	0
 8580 03cb 10       		.byte	16
 8581 03cc 00       		.byte	0
 8582 03cd 10       		.byte	16
 8583 03ce 00       		.byte	0
 8584 03cf 30       		.byte	48
 8585 03d0 01       		.byte	1
 8586 03d1 00       		.byte	0
 8587 03d2 00       		.byte	0
 8588 03d3 00000000 		.space	5
 8588      00
 8589 03d8 02       		.byte	2
 8590 03d9 03       		.byte	3
 8591 03da 04       		.byte	4
 8592 03db 00       		.byte	0
 8593 03dc 00       		.byte	0
 8594 03dd 7F       		.byte	127
 8595 03de 00       		.byte	0
 8596 03df 01       		.byte	1
 8597 03e0 00       		.byte	0
 8598 03e1 03       		.byte	3
 8599 03e2 00       		.byte	0
 8600 03e3 00       		.byte	0
 8601 03e4 20       		.byte	32
 8602 03e5 00       		.byte	0
 8603 03e6 20       		.byte	32
 8604 03e7 30       		.byte	48
 8605 03e8 01       		.byte	1
 8606 03e9 00       		.byte	0
 8607 03ea 00       		.byte	0
 8608 03eb 00000000 		.space	5
 8608      00
 8609 03f0 04       		.byte	4
 8610 03f1 0C       		.byte	12
 8611 03f2 02       		.byte	2
 8612 03f3 00       		.byte	0
 8613 03f4 00       		.byte	0
 8614 03f5 40       		.byte	64
 8615 03f6 00       		.byte	0
 8616 03f7 01       		.byte	1
 8617 03f8 00       		.byte	0
 8618 03f9 03       		.byte	3
 8619 03fa 00       		.byte	0
 8620 03fb 20       		.byte	32
 8621 03fc 00       		.byte	0
 8622 03fd 20       		.byte	32
 8623 03fe 00       		.byte	0
 8624 03ff 30       		.byte	48
 8625 0400 01       		.byte	1
 8626 0401 00       		.byte	0
 8627 0402 00       		.byte	0
 8628 0403 00000000 		.space	5
 8628      00
 8629 0408 00       		.byte	0
 8630 0409 00       		.byte	0
 8631 040a 02       		.byte	2
 8632 040b 00       		.byte	0
 8633 040c 00       		.byte	0
 8634 040d 19       		.byte	25
 8635 040e 00       		.byte	0
 8636 040f 01       		.byte	1
 8637 0410 00       		.byte	0
 8638 0411 03       		.byte	3
 8639 0412 00       		.byte	0
 8640 0413 00       		.byte	0
 8641 0414 00       		.byte	0
 8642 0415 00       		.byte	0
 8643 0416 00       		.byte	0
 8644 0417 30       		.byte	48
 8645 0418 01       		.byte	1
 8646 0419 00       		.byte	0
 8647 041a 00       		.byte	0
 8648 041b 00000000 		.space	5
 8648      00
 8649 0420 10       		.byte	16
 8650 0421 10       		.byte	16
 8651 0422 02       		.byte	2
 8652 0423 00       		.byte	0
 8653 0424 00       		.byte	0
 8654 0425 06       		.byte	6
 8655 0426 00       		.byte	0
 8656 0427 01       		.byte	1
 8657 0428 00       		.byte	0
 8658 0429 03       		.byte	3
 8659 042a 00       		.byte	0
 8660 042b 00       		.byte	0
 8661 042c 00       		.byte	0
 8662 042d 00       		.byte	0
 8663 042e 00       		.byte	0
 8664 042f 30       		.byte	48
 8665 0430 01       		.byte	1
 8666 0431 00       		.byte	0
 8667 0432 00       		.byte	0
 8668 0433 00000000 		.space	5
 8668      00
 8669 0438 00       		.byte	0
 8670 0439 00       		.byte	0
 8671 043a 02       		.byte	2
 8672 043b 00       		.byte	0
 8673 043c 00       		.byte	0
 8674 043d 03       		.byte	3
 8675 043e 00       		.byte	0
 8676 043f 01       		.byte	1
 8677 0440 00       		.byte	0
 8678 0441 03       		.byte	3
 8679 0442 00       		.byte	0
 8680 0443 00       		.byte	0
 8681 0444 00       		.byte	0
 8682 0445 00       		.byte	0
 8683 0446 00       		.byte	0
 8684 0447 30       		.byte	48
 8685 0448 01       		.byte	1
 8686 0449 00       		.byte	0
 8687 044a 00       		.byte	0
 8688 044b 00000000 		.space	5
 8688      00
 8689 0450 50       		.byte	80
 8690 0451 50       		.byte	80
 8691 0452 01       		.byte	1
 8692 0453 00       		.byte	0
 8693 0454 00       		.byte	0
 8694 0455 03       		.byte	3
 8695 0456 00       		.byte	0
 8696 0457 01       		.byte	1
 8697 0458 00       		.byte	0
 8698 0459 03       		.byte	3
 8699 045a 00       		.byte	0
 8700 045b 00       		.byte	0
 8701 045c 00       		.byte	0
 8702 045d 00       		.byte	0
 8703 045e 00       		.byte	0
 8704 045f 30       		.byte	48
 8705 0460 01       		.byte	1
 8706 0461 00       		.byte	0
 8707 0462 00       		.byte	0
 8708 0463 00000000 		.space	5
 8708      00
 8709 0468 00       		.byte	0
 8710 0469 00       		.byte	0
 8711 046a 0B       		.byte	11
 8712 046b 00       		.byte	0
 8713 046c 00       		.byte	0
 8714 046d FF       		.byte	-1
 8715 046e FF       		.byte	-1
 8716 046f 01       		.byte	1
 8717 0470 00       		.byte	0
 8718 0471 03       		.byte	3
 8719 0472 00       		.byte	0
 8720 0473 00       		.byte	0
 8721 0474 00       		.byte	0
 8722 0475 00       		.byte	0
 8723 0476 00       		.byte	0
 8724 0477 00       		.byte	0
 8725 0478 01       		.byte	1
 8726 0479 00       		.byte	0
 8727 047a 00       		.byte	0
 8728 047b 00000000 		.space	5
 8728      00
 8731              	glUVCHeader:
 8732 0480 0C       		.byte	12
 8733 0481 8C       		.byte	-116
 8734 0482 00       		.byte	0
 8735 0483 00       		.byte	0
 8736 0484 00       		.byte	0
 8737 0485 00       		.byte	0
 8738 0486 00       		.byte	0
 8739 0487 00       		.byte	0
 8740 0488 00       		.byte	0
 8741 0489 00       		.byte	0
 8742 048a 00       		.byte	0
 8743 048b 00       		.byte	0
 8746              	WBMenuCmpArry:
 8747 048c 20       		.byte	32
 8748 048d 0F       		.byte	15
 8749 048e 38       		.byte	56
 8750 048f F0       		.byte	-16
 8753              	CTCtrlParArry:
 8754 0490 00       		.byte	0
 8755 0491 00       		.byte	0
 8756 0492 01       		.byte	1
 8757 0493 00       		.byte	0
 8758 0494 00       		.byte	0
 8759 0495 03       		.byte	3
 8760 0496 00       		.byte	0
 8761 0497 01       		.byte	1
 8762 0498 00       		.byte	0
 8763 0499 03       		.byte	3
 8764 049a 00       		.byte	0
 8765 049b 03       		.byte	3
 8766 049c 00       		.byte	0
 8767 049d 03       		.byte	3
 8768 049e 00       		.byte	0
 8769 049f 30       		.byte	48
 8770 04a0 01       		.byte	1
 8771 04a1 00       		.byte	0
 8772 04a2 00       		.byte	0
 8773 04a3 00000000 		.space	5
 8773      00
 8774 04a8 00       		.byte	0
 8775 04a9 00       		.byte	0
 8776 04aa 01       		.byte	1
 8777 04ab 01       		.byte	1
 8778 04ac 00       		.byte	0
 8779 04ad 0F       		.byte	15
 8780 04ae 00       		.byte	0
 8781 04af 0F       		.byte	15
 8782 04b0 00       		.byte	0
 8783 04b1 03       		.byte	3
 8784 04b2 00       		.byte	0
 8785 04b3 02       		.byte	2
 8786 04b4 00       		.byte	0
 8787 04b5 02       		.byte	2
 8788 04b6 00       		.byte	0
 8789 04b7 30       		.byte	48
 8790 04b8 01       		.byte	1
 8791 04b9 01       		.byte	1
 8792 04ba 00       		.byte	0
 8793 04bb 00000000 		.space	5
 8793      00
 8794 04c0 02       		.byte	2
 8795 04c1 00       		.byte	0
 8796 04c2 01       		.byte	1
 8797 04c3 00       		.byte	0
 8798 04c4 00       		.byte	0
 8799 04c5 01       		.byte	1
 8800 04c6 00       		.byte	0
 8801 04c7 01       		.byte	1
 8802 04c8 00       		.byte	0
 8803 04c9 03       		.byte	3
 8804 04ca 00       		.byte	0
 8805 04cb 00       		.byte	0
 8806 04cc 00       		.byte	0
 8807 04cd 00       		.byte	0
 8808 04ce 00       		.byte	0
 8809 04cf 30       		.byte	48
 8810 04d0 01       		.byte	1
 8811 04d1 01       		.byte	1
 8812 04d2 00       		.byte	0
 8813 04d3 00000000 		.space	5
 8813      00
 8814 04d8 00       		.byte	0
 8815 04d9 00       		.byte	0
 8816 04da 04       		.byte	4
 8817 04db 01       		.byte	1
 8818 04dc 00       		.byte	0
 8819 04dd 38       		.byte	56
 8820 04de 01       		.byte	1
 8821 04df 01       		.byte	1
 8822 04e0 00       		.byte	0
 8823 04e1 03       		.byte	3
 8824 04e2 00       		.byte	0
 8825 04e3 4E       		.byte	78
 8826 04e4 00       		.byte	0
 8827 04e5 4E       		.byte	78
 8828 04e6 00       		.byte	0
 8829 04e7 30       		.byte	48
 8830 04e8 01       		.byte	1
 8831 04e9 00       		.byte	0
 8832 04ea 00       		.byte	0
 8833 04eb 00000000 		.space	5
 8833      00
 8834 04f0 04       		.byte	4
 8835 04f1 00       		.byte	0
 8836 04f2 01       		.byte	1
 8837 04f3 00       		.byte	0
 8838 04f4 00       		.byte	0
 8839 04f5 00       		.byte	0
 8840 04f6 00       		.byte	0
 8841 04f7 01       		.byte	1
 8842 04f8 00       		.byte	0
 8843 04f9 03       		.byte	3
 8844 04fa 00       		.byte	0
 8845 04fb 00       		.byte	0
 8846 04fc 00       		.byte	0
 8847 04fd 00       		.byte	0
 8848 04fe 00       		.byte	0
 8849 04ff 30       		.byte	48
 8850 0500 01       		.byte	1
 8851 0501 00       		.byte	0
 8852 0502 00       		.byte	0
 8853 0503 00000000 		.space	5
 8853      00
 8854 0508 05       		.byte	5
 8855 0509 00       		.byte	0
 8856 050a 02       		.byte	2
 8857 050b 00       		.byte	0
 8858 050c 00       		.byte	0
 8859 050d FF       		.byte	-1
 8860 050e 00       		.byte	0
 8861 050f 01       		.byte	1
 8862 0510 00       		.byte	0
 8863 0511 03       		.byte	3
 8864 0512 00       		.byte	0
 8865 0513 01       		.byte	1
 8866 0514 00       		.byte	0
 8867 0515 00       		.byte	0
 8868 0516 00       		.byte	0
 8869 0517 30       		.byte	48
 8870 0518 01       		.byte	1
 8871 0519 01       		.byte	1
 8872 051a 00       		.byte	0
 8873 051b 00000000 		.space	5
 8873      00
 8874 0520 06       		.byte	6
 8875 0521 00       		.byte	0
 8876 0522 02       		.byte	2
 8877 0523 00       		.byte	0
 8878 0524 00       		.byte	0
 8879 0525 00       		.byte	0
 8880 0526 00       		.byte	0
 8881 0527 00       		.byte	0
 8882 0528 00       		.byte	0
 8883 0529 03       		.byte	3
 8884 052a 00       		.byte	0
 8885 052b 00       		.byte	0
 8886 052c 00       		.byte	0
 8887 052d 00       		.byte	0
 8888 052e 00       		.byte	0
 8889 052f 30       		.byte	48
 8890 0530 01       		.byte	1
 8891 0531 01       		.byte	1
 8892 0532 00       		.byte	0
 8893 0533 00000000 		.space	5
 8893      00
 8894 0538 23       		.byte	35
 8895 0539 00       		.byte	0
 8896 053a 02       		.byte	2
 8897 053b 00       		.byte	0
 8898 053c 00       		.byte	0
 8899 053d 30       		.byte	48
 8900 053e 00       		.byte	0
 8901 053f 01       		.byte	1
 8902 0540 00       		.byte	0
 8903 0541 03       		.byte	3
 8904 0542 0A       		.byte	10
 8905 0543 00       		.byte	0
 8906 0544 00       		.byte	0
 8907 0545 0A       		.byte	10
 8908 0546 00       		.byte	0
 8909 0547 30       		.byte	48
 8910 0548 01       		.byte	1
 8911 0549 01       		.byte	1
 8912 054a 00       		.byte	0
 8913 054b 00000000 		.space	5
 8913      00
 8914 0550 08       		.byte	8
 8915 0551 00       		.byte	0
 8916 0552 01       		.byte	1
 8917 0553 00       		.byte	0
 8918 0554 00       		.byte	0
 8919 0555 7F       		.byte	127
 8920 0556 00       		.byte	0
 8921 0557 01       		.byte	1
 8922 0558 00       		.byte	0
 8923 0559 03       		.byte	3
 8924 055a 00       		.byte	0
 8925 055b 00       		.byte	0
 8926 055c 00       		.byte	0
 8927 055d 00       		.byte	0
 8928 055e 00       		.byte	0
 8929 055f 30       		.byte	48
 8930 0560 01       		.byte	1
 8931 0561 00       		.byte	0
 8932 0562 00       		.byte	0
 8933 0563 00000000 		.space	5
 8933      00
 8934 0568 09       		.byte	9
 8935 0569 00       		.byte	0
 8936 056a 02       		.byte	2
 8937 056b 00       		.byte	0
 8938 056c 00       		.byte	0
 8939 056d 05       		.byte	5
 8940 056e 00       		.byte	0
 8941 056f 01       		.byte	1
 8942 0570 00       		.byte	0
 8943 0571 03       		.byte	3
 8944 0572 00       		.byte	0
 8945 0573 00       		.byte	0
 8946 0574 00       		.byte	0
 8947 0575 00       		.byte	0
 8948 0576 00       		.byte	0
 8949 0577 30       		.byte	48
 8950 0578 01       		.byte	1
 8951 0579 00       		.byte	0
 8952 057a 00       		.byte	0
 8953 057b 00000000 		.space	5
 8953      00
 8954 0580 10       		.byte	16
 8955 0581 00       		.byte	0
 8956 0582 03       		.byte	3
 8957 0583 00       		.byte	0
 8958 0584 00       		.byte	0
 8959 0585 00       		.byte	0
 8960 0586 00       		.byte	0
 8961 0587 00       		.byte	0
 8962 0588 00       		.byte	0
 8963 0589 03       		.byte	3
 8964 058a 00       		.byte	0
 8965 058b 00       		.byte	0
 8966 058c 00       		.byte	0
 8967 058d 00       		.byte	0
 8968 058e 00       		.byte	0
 8969 058f 30       		.byte	48
 8970 0590 01       		.byte	1
 8971 0591 00       		.byte	0
 8972 0592 00       		.byte	0
 8973 0593 00000000 		.space	5
 8973      00
 8974 0598 00       		.byte	0
 8975 0599 00       		.byte	0
 8976 059a 02       		.byte	2
 8977 059b 00       		.byte	0
 8978 059c 00       		.byte	0
 8979 059d 40       		.byte	64
 8980 059e 00       		.byte	0
 8981 059f 01       		.byte	1
 8982 05a0 00       		.byte	0
 8983 05a1 03       		.byte	3
 8984 05a2 00       		.byte	0
 8985 05a3 0F       		.byte	15
 8986 05a4 11       		.byte	17
 8987 05a5 00       		.byte	0
 8988 05a6 00       		.byte	0
 8989 05a7 30       		.byte	48
 8990 05a8 01       		.byte	1
 8991 05a9 00       		.byte	0
 8992 05aa 00       		.byte	0
 8993 05ab 00000000 		.space	5
 8993      00
 8994 05b0 00       		.byte	0
 8995 05b1 00       		.byte	0
 8996 05b2 02       		.byte	2
 8997 05b3 00       		.byte	0
 8998 05b4 00       		.byte	0
 8999 05b5 64       		.byte	100
 9000 05b6 00       		.byte	0
 9001 05b7 01       		.byte	1
 9002 05b8 00       		.byte	0
 9003 05b9 03       		.byte	3
 9004 05ba 00       		.byte	0
 9005 05bb 00       		.byte	0
 9006 05bc 00       		.byte	0
 9007 05bd 00       		.byte	0
 9008 05be 00       		.byte	0
 9009 05bf 30       		.byte	48
 9010 05c0 01       		.byte	1
 9011 05c1 00       		.byte	0
 9012 05c2 00       		.byte	0
 9013 05c3 00000000 		.space	5
 9013      00
 9014 05c8 00       		.byte	0
 9015 05c9 00       		.byte	0
 9016 05ca 02       		.byte	2
 9017 05cb 00       		.byte	0
 9018 05cc 00       		.byte	0
 9019 05cd 64       		.byte	100
 9020 05ce 00       		.byte	0
 9021 05cf 01       		.byte	1
 9022 05d0 00       		.byte	0
 9023 05d1 03       		.byte	3
 9024 05d2 00       		.byte	0
 9025 05d3 00       		.byte	0
 9026 05d4 00       		.byte	0
 9027 05d5 00       		.byte	0
 9028 05d6 00       		.byte	0
 9029 05d7 30       		.byte	48
 9030 05d8 01       		.byte	1
 9031 05d9 00       		.byte	0
 9032 05da 00       		.byte	0
 9033 05db 00000000 		.space	5
 9033      00
 9034 05e0 00       		.byte	0
 9035 05e1 00       		.byte	0
 9036 05e2 02       		.byte	2
 9037 05e3 00       		.byte	0
 9038 05e4 00       		.byte	0
 9039 05e5 64       		.byte	100
 9040 05e6 00       		.byte	0
 9041 05e7 01       		.byte	1
 9042 05e8 00       		.byte	0
 9043 05e9 03       		.byte	3
 9044 05ea 00       		.byte	0
 9045 05eb 00       		.byte	0
 9046 05ec 00       		.byte	0
 9047 05ed 00       		.byte	0
 9048 05ee 00       		.byte	0
 9049 05ef 30       		.byte	48
 9050 05f0 01       		.byte	1
 9051 05f1 00       		.byte	0
 9052 05f2 00       		.byte	0
 9053 05f3 00000000 		.space	5
 9053      00
 9054 05f8 00       		.byte	0
 9055 05f9 00       		.byte	0
 9056 05fa 02       		.byte	2
 9057 05fb 00       		.byte	0
 9058 05fc 00       		.byte	0
 9059 05fd 64       		.byte	100
 9060 05fe 00       		.byte	0
 9061 05ff 01       		.byte	1
 9062 0600 00       		.byte	0
 9063 0601 03       		.byte	3
 9064 0602 00       		.byte	0
 9065 0603 00       		.byte	0
 9066 0604 00       		.byte	0
 9067 0605 00       		.byte	0
 9068 0606 00       		.byte	0
 9069 0607 30       		.byte	48
 9070 0608 01       		.byte	1
 9071 0609 00       		.byte	0
 9072 060a 00       		.byte	0
 9073 060b 00000000 		.space	5
 9073      00
 9076              	glProbeCtrl:
 9077 0610 00       		.byte	0
 9078 0611 00       		.byte	0
 9079 0612 01       		.byte	1
 9080 0613 01       		.byte	1
 9081 0614 15       		.byte	21
 9082 0615 16       		.byte	22
 9083 0616 05       		.byte	5
 9084 0617 00       		.byte	0
 9085 0618 00       		.byte	0
 9086 0619 00       		.byte	0
 9087 061a 00       		.byte	0
 9088 061b 00       		.byte	0
 9089 061c 00       		.byte	0
 9090 061d 00       		.byte	0
 9091 061e 00       		.byte	0
 9092 061f 00       		.byte	0
 9093 0620 00       		.byte	0
 9094 0621 00       		.byte	0
 9095 0622 00       		.byte	0
 9096 0623 48       		.byte	72
 9097 0624 3F       		.byte	63
 9098 0625 00       		.byte	0
 9099 0626 00       		.byte	0
 9100 0627 40       		.byte	64
 9101 0628 00       		.byte	0
 9102 0629 00       		.byte	0
 9103 062a 0000     		.space	2
 9106              	glProbeStilCtrl:
 9107 062c 01       		.byte	1
 9108 062d 01       		.byte	1
 9109 062e 00       		.byte	0
 9110 062f 00       		.byte	0
 9111 0630 48       		.byte	72
 9112 0631 3F       		.byte	63
 9113 0632 00       		.byte	0
 9114 0633 00       		.byte	0
 9115 0634 40       		.byte	64
 9116 0635 00       		.byte	0
 9117 0636 00       		.byte	0
 9118 0637 00       		.space	1
 9121              	glProbeStilCtrl20:
 9122 0638 01       		.byte	1
 9123 0639 01       		.byte	1
 9124 063a 00       		.byte	0
 9125 063b 00       		.byte	0
 9126 063c D2       		.byte	-46
 9127 063d 0F       		.byte	15
 9128 063e 00       		.byte	0
 9129 063f 00       		.byte	0
 9130 0640 40       		.byte	64
 9131 0641 00       		.byte	0
 9132 0642 00       		.byte	0
 9135              	snapButFlag:
 9136 0643 01       		.byte	1
 9139              	CyFxGpifTransition:
 9140 0644 0000     		.short	0
 9141 0646 5555     		.short	21845
 9142 0648 8888     		.short	-30584
 9143 064a AAAA     		.short	-21846
 9144 064c 3333     		.short	13107
 9145 064e 0000     		.space	2
 9148              	CyFxGpifWavedata:
 9149 0650 0181731E 		.word	510886145
 9150 0654 00000000 		.word	0
 9151 0658 00000080 		.word	-2147483648
 9152 065c 00000000 		.word	0
 9153 0660 00000000 		.word	0
 9154 0664 00000000 		.word	0
 9155 0668 0201702E 		.word	779092226
 9156 066c 00010000 		.word	256
 9157 0670 A0000080 		.word	-2147483488
 9158 0674 00000000 		.word	0
 9159 0678 00000000 		.word	0
 9160 067c 00000000 		.word	0
 9161 0680 0380722E 		.word	779255811
 9162 0684 02010020 		.word	536871170
 9163 0688 60000080 		.word	-2147483552
 9164 068c 00000000 		.word	0
 9165 0690 00000000 		.word	0
 9166 0694 00000000 		.word	0
 9167 0698 0460722E 		.word	779247620
 9168 069c 02010024 		.word	603980034
 9169 06a0 90000080 		.word	-2147483504
 9170 06a4 0594731E 		.word	510891013
 9171 06a8 06000000 		.word	6
 9172 06ac 00000080 		.word	-2147483648
 9173 06b0 0380722E 		.word	779255811
 9174 06b4 02010020 		.word	536871170
 9175 06b8 60000080 		.word	-2147483552
 9176 06bc 0693731E 		.word	510890758
 9177 06c0 06000000 		.word	6
 9178 06c4 00000080 		.word	-2147483648
 9179 06c8 0720703E 		.word	1047535623
 9180 06cc 08010000 		.word	264
 9181 06d0 00000080 		.word	-2147483648
 9182 06d4 0820703E 		.word	1047535624
 9183 06d8 08010000 		.word	264
 9184 06dc 00000080 		.word	-2147483648
 9185 06e0 0920703E 		.word	1047535625
 9186 06e4 08010000 		.word	264
 9187 06e8 00000080 		.word	-2147483648
 9188 06ec 0A20703E 		.word	1047535626
 9189 06f0 08010000 		.word	264
 9190 06f4 00000080 		.word	-2147483648
 9191 06f8 0380722E 		.word	779255811
 9192 06fc 02010020 		.word	536871170
 9193 0700 60000080 		.word	-2147483552
 9194 0704 0B000000 		.word	11
 9195 0708 00000000 		.word	0
 9196 070c 00010080 		.word	-2147483392
 9197 0710 0460722E 		.word	779247620
 9198 0714 02010024 		.word	603980034
 9199 0718 90000080 		.word	-2147483504
 9200 071c 0D000000 		.word	13
 9201 0720 00000000 		.word	0
 9202 0724 00010080 		.word	-2147483392
 9203 0728 0460722E 		.word	779247620
 9204 072c 02010024 		.word	603980034
 9205 0730 90000080 		.word	-2147483504
 9206 0734 0C000000 		.word	12
 9207 0738 00000000 		.word	0
 9208 073c 00010080 		.word	-2147483392
 9209 0740 0380722E 		.word	779255811
 9210 0744 02010020 		.word	536871170
 9211 0748 60000080 		.word	-2147483552
 9212 074c 0E000000 		.word	14
 9213 0750 00000000 		.word	0
 9214 0754 00010080 		.word	-2147483392
 9215 0758 00000000 		.word	0
 9216 075c 00000000 		.word	0
 9217 0760 00000000 		.word	0
 9218 0764 00000000 		.word	0
 9219 0768 00000000 		.word	0
 9220 076c 00000000 		.word	0
 9223              	CyFxGpifWavedataPosition:
 9224 0770 00       		.byte	0
 9225 0771 01       		.byte	1
 9226 0772 02       		.byte	2
 9227 0773 03       		.byte	3
 9228 0774 04       		.byte	4
 9229 0775 05       		.byte	5
 9230 0776 06       		.byte	6
 9231 0777 07       		.byte	7
 9232 0778 08       		.byte	8
 9233 0779 09       		.byte	9
 9234 077a 0A       		.byte	10
 9235 077b 0B       		.byte	11
 9236 077c 0B       		.byte	11
 9237 077d 0B       		.byte	11
 9238 077e 0B       		.byte	11
 9239 077f 00       		.space	1
 9242              	CyFxGpifRegValue:
 9243 0780 08830080 		.word	-2147450104
 9244 0784 67000000 		.word	103
 9245 0788 00000000 		.word	0
 9246 078c 46000000 		.word	70
 9247 0790 00000000 		.word	0
 9248 0794 00000000 		.word	0
 9249 0798 02000000 		.word	2
 9250 079c 82000000 		.word	130
 9251 07a0 82070000 		.word	1922
 9252 07a4 40040000 		.word	1088
 9253 07a8 FCFF0000 		.word	65532
 9254 07ac 28000000 		.word	40
 9255 07b0 00000000 		.word	0
 9256 07b4 00000000 		.word	0
 9257 07b8 00000000 		.word	0
 9258 07bc 00000000 		.word	0
 9259 07c0 01000000 		.word	1
 9260 07c4 00000000 		.word	0
 9261 07c8 00000000 		.word	0
 9262 07cc 00000000 		.word	0
 9263 07d0 00000000 		.word	0
 9264 07d4 00000000 		.word	0
 9265 07d8 00000000 		.word	0
 9266 07dc 00000000 		.word	0
 9267 07e0 00000000 		.word	0
 9268 07e4 00000000 		.word	0
 9269 07e8 00000000 		.word	0
 9270 07ec 00000000 		.word	0
 9271 07f0 00000000 		.word	0
 9272 07f4 06000000 		.word	6
 9273 07f8 00000000 		.word	0
 9274 07fc FFFF0000 		.word	65535
 9275 0800 09010000 		.word	265
 9276 0804 00000000 		.word	0
 9277 0808 F71F0000 		.word	8183
 9278 080c 00000000 		.word	0
 9279 0810 FFFF0000 		.word	65535
 9280 0814 09010000 		.word	265
 9281 0818 00000000 		.word	0
 9282 081c F71F0000 		.word	8183
 9283 0820 00000000 		.word	0
 9284 0824 00000000 		.word	0
 9285 0828 00000000 		.word	0
 9286 082c 00000000 		.word	0
 9287 0830 00000000 		.word	0
 9288 0834 00000000 		.word	0
 9289 0838 00000000 		.word	0
 9290 083c 00000000 		.word	0
 9291 0840 00000000 		.word	0
 9292 0844 00000000 		.word	0
 9293 0848 00000000 		.word	0
 9294 084c 00000000 		.word	0
 9295 0850 00000000 		.word	0
 9296 0854 00000000 		.word	0
 9297 0858 00000000 		.word	0
 9298 085c 00000000 		.word	0
 9299 0860 00000000 		.word	0
 9300 0864 00000000 		.word	0
 9301 0868 00000000 		.word	0
 9302 086c 00000000 		.word	0
 9303 0870 00000000 		.word	0
 9304 0874 00000000 		.word	0
 9305 0878 00000000 		.word	0
 9306 087c 00040180 		.word	-2147417088
 9307 0880 01040180 		.word	-2147417087
 9308 0884 02040180 		.word	-2147417086
 9309 0888 03040180 		.word	-2147417085
 9310 088c 00000000 		.word	0
 9311 0890 00000000 		.word	0
 9312 0894 00000000 		.word	0
 9313 0898 00000000 		.word	0
 9314 089c 00000000 		.word	0
 9315 08a0 00000000 		.word	0
 9316 08a4 00000000 		.word	0
 9317 08a8 00000000 		.word	0
 9318 08ac C1FFFFFF 		.word	-63
 9321              	CyFxGpifTransition_usb2:
 9322 08b0 0000     		.short	0
 9323 08b2 5555     		.short	21845
 9324 08b4 AAAA     		.short	-21846
 9325 08b6 8888     		.short	-30584
 9326 08b8 1111     		.short	4369
 9327 08ba 4444     		.short	17476
 9328 08bc 3333     		.short	13107
 9329 08be CCCC     		.short	-13108
 9332              	CyFxGpifWavedata_usb2:
 9333 08c0 0181731E 		.word	510886145
 9334 08c4 00000000 		.word	0
 9335 08c8 00000080 		.word	-2147483648
 9336 08cc 00000000 		.word	0
 9337 08d0 00000000 		.word	0
 9338 08d4 00000000 		.word	0
 9339 08d8 0201703E 		.word	1047527682
 9340 08dc 00010000 		.word	256
 9341 08e0 A00000C0 		.word	-1073741664
 9342 08e4 00000000 		.word	0
 9343 08e8 00000000 		.word	0
 9344 08ec 00000000 		.word	0
 9345 08f0 0394731E 		.word	510891011
 9346 08f4 04000020 		.word	536870916
 9347 08f8 60004080 		.word	-2143289248
 9348 08fc 00000000 		.word	0
 9349 0900 00000000 		.word	0
 9350 0904 00000000 		.word	0
 9351 0908 0620702E 		.word	779100166
 9352 090c 0C000000 		.word	12
 9353 0910 00000080 		.word	-2147483648
 9354 0914 0620702E 		.word	779100166
 9355 0918 0C000000 		.word	12
 9356 091c 00000080 		.word	-2147483648
 9357 0920 0394731E 		.word	510891011
 9358 0924 04000020 		.word	536870916
 9359 0928 60004080 		.word	-2143289248
 9360 092c 0620702E 		.word	779100166
 9361 0930 0C000000 		.word	12
 9362 0934 00000080 		.word	-2147483648
 9363 0938 0C93731E 		.word	510890764
 9364 093c 04000024 		.word	603979780
 9365 0940 90004080 		.word	-2143289200
 9366 0944 0D20702E 		.word	779100173
 9367 0948 0C000000 		.word	12
 9368 094c 00000080 		.word	-2147483648
 9369 0950 0780724E 		.word	1316126727
 9370 0954 0A000000 		.word	10
 9371 0958 00000080 		.word	-2147483648
 9372 095c 08000000 		.word	8
 9373 0960 00000000 		.word	0
 9374 0964 00010080 		.word	-2147483392
 9375 0968 0920702E 		.word	779100169
 9376 096c 0C010000 		.word	268
 9377 0970 00000080 		.word	-2147483648
 9378 0974 0A01701E 		.word	510656778
 9379 0978 0E000100 		.word	65550
 9380 097c 00000080 		.word	-2147483648
 9381 0980 00000000 		.word	0
 9382 0984 00000000 		.word	0
 9383 0988 00000000 		.word	0
 9384 098c 00000000 		.word	0
 9385 0990 00000000 		.word	0
 9386 0994 00000000 		.word	0
 9387 0998 0394731E 		.word	510891011
 9388 099c 04000020 		.word	536870916
 9389 09a0 60004080 		.word	-2143289248
 9390 09a4 08000000 		.word	8
 9391 09a8 00000000 		.word	0
 9392 09ac 00010080 		.word	-2147483392
 9393 09b0 0B000000 		.word	11
 9394 09b4 00000000 		.word	0
 9395 09b8 00010080 		.word	-2147483392
 9396 09bc 0C93731E 		.word	510890764
 9397 09c0 04000024 		.word	603979780
 9398 09c4 90004080 		.word	-2143289200
 9399 09c8 0D20702E 		.word	779100173
 9400 09cc 0C000000 		.word	12
 9401 09d0 00000080 		.word	-2147483648
 9402 09d4 0D20702E 		.word	779100173
 9403 09d8 0C000000 		.word	12
 9404 09dc 00000080 		.word	-2147483648
 9405 09e0 0E60724E 		.word	1316118542
 9406 09e4 0A000000 		.word	10
 9407 09e8 00000080 		.word	-2147483648
 9408 09ec 0F000000 		.word	15
 9409 09f0 00000000 		.word	0
 9410 09f4 00010080 		.word	-2147483392
 9411 09f8 1020702E 		.word	779100176
 9412 09fc 0C010000 		.word	268
 9413 0a00 00000080 		.word	-2147483648
 9414 0a04 1101701E 		.word	510656785
 9415 0a08 0E000100 		.word	65550
 9416 0a0c 00000080 		.word	-2147483648
 9417 0a10 0C93731E 		.word	510890764
 9418 0a14 04000024 		.word	603979780
 9419 0a18 90004080 		.word	-2143289200
 9420 0a1c 0F000000 		.word	15
 9421 0a20 00000000 		.word	0
 9422 0a24 00010080 		.word	-2147483392
 9423 0a28 12000000 		.word	18
 9424 0a2c 00000000 		.word	0
 9425 0a30 00010080 		.word	-2147483392
 9426 0a34 0394731E 		.word	510891011
 9427 0a38 04000020 		.word	536870916
 9428 0a3c 60004080 		.word	-2143289248
 9429 0a40 0480732E 		.word	779321348
 9430 0a44 02010000 		.word	258
 9431 0a48 000040C0 		.word	-1069547520
 9432 0a4c 0580732E 		.word	779321349
 9433 0a50 02010000 		.word	258
 9434 0a54 000040C0 		.word	-1069547520
 9435 0a58 0580732E 		.word	779321349
 9436 0a5c 02010000 		.word	258
 9437 0a60 000040C0 		.word	-1069547520
 9438 0a64 0480732E 		.word	779321348
 9439 0a68 02010000 		.word	258
 9440 0a6c 000040C0 		.word	-1069547520
 9443              	CyFxGpifWavedataPosition_usb2:
 9444 0a70 00       		.byte	0
 9445 0a71 01       		.byte	1
 9446 0a72 02       		.byte	2
 9447 0a73 03       		.byte	3
 9448 0a74 04       		.byte	4
 9449 0a75 05       		.byte	5
 9450 0a76 06       		.byte	6
 9451 0a77 07       		.byte	7
 9452 0a78 08       		.byte	8
 9453 0a79 09       		.byte	9
 9454 0a7a 0A       		.byte	10
 9455 0a7b 08       		.byte	8
 9456 0a7c 0B       		.byte	11
 9457 0a7d 0C       		.byte	12
 9458 0a7e 0D       		.byte	13
 9459 0a7f 08       		.byte	8
 9460 0a80 0E       		.byte	14
 9461 0a81 0F       		.byte	15
 9462 0a82 08       		.byte	8
 9463 0a83 08       		.byte	8
 9464 0a84 08       		.byte	8
 9465 0a85 08       		.byte	8
 9466 0a86 08       		.byte	8
 9467 0a87 08       		.byte	8
 9468 0a88 08       		.byte	8
 9469 0a89 08       		.byte	8
 9470 0a8a 08       		.byte	8
 9471 0a8b 08       		.byte	8
 9472 0a8c 08       		.byte	8
 9473 0a8d 08       		.byte	8
 9474 0a8e 08       		.byte	8
 9475 0a8f 08       		.byte	8
 9476 0a90 08       		.byte	8
 9477 0a91 08       		.byte	8
 9478 0a92 08       		.byte	8
 9479 0a93 08       		.byte	8
 9480 0a94 08       		.byte	8
 9481 0a95 08       		.byte	8
 9482 0a96 08       		.byte	8
 9483 0a97 08       		.byte	8
 9484 0a98 08       		.byte	8
 9485 0a99 08       		.byte	8
 9486 0a9a 08       		.byte	8
 9487 0a9b 08       		.byte	8
 9488 0a9c 08       		.byte	8
 9489 0a9d 08       		.byte	8
 9490 0a9e 08       		.byte	8
 9491 0a9f 08       		.byte	8
 9492 0aa0 08       		.byte	8
 9493 0aa1 08       		.byte	8
 9494 0aa2 08       		.byte	8
 9495 0aa3 08       		.byte	8
 9496 0aa4 08       		.byte	8
 9497 0aa5 08       		.byte	8
 9498 0aa6 08       		.byte	8
 9499 0aa7 08       		.byte	8
 9500 0aa8 08       		.byte	8
 9501 0aa9 08       		.byte	8
 9502 0aaa 08       		.byte	8
 9503 0aab 08       		.byte	8
 9504 0aac 08       		.byte	8
 9505 0aad 08       		.byte	8
 9506 0aae 08       		.byte	8
 9507 0aaf 08       		.byte	8
 9508 0ab0 08       		.byte	8
 9509 0ab1 08       		.byte	8
 9510 0ab2 08       		.byte	8
 9511 0ab3 08       		.byte	8
 9512 0ab4 08       		.byte	8
 9513 0ab5 08       		.byte	8
 9514 0ab6 08       		.byte	8
 9515 0ab7 08       		.byte	8
 9516 0ab8 08       		.byte	8
 9517 0ab9 08       		.byte	8
 9518 0aba 08       		.byte	8
 9519 0abb 08       		.byte	8
 9520 0abc 08       		.byte	8
 9521 0abd 08       		.byte	8
 9522 0abe 08       		.byte	8
 9523 0abf 08       		.byte	8
 9524 0ac0 08       		.byte	8
 9525 0ac1 08       		.byte	8
 9526 0ac2 08       		.byte	8
 9527 0ac3 08       		.byte	8
 9528 0ac4 08       		.byte	8
 9529 0ac5 08       		.byte	8
 9530 0ac6 08       		.byte	8
 9531 0ac7 08       		.byte	8
 9532 0ac8 08       		.byte	8
 9533 0ac9 08       		.byte	8
 9534 0aca 08       		.byte	8
 9535 0acb 08       		.byte	8
 9536 0acc 08       		.byte	8
 9537 0acd 08       		.byte	8
 9538 0ace 08       		.byte	8
 9539 0acf 08       		.byte	8
 9540 0ad0 08       		.byte	8
 9541 0ad1 08       		.byte	8
 9542 0ad2 08       		.byte	8
 9543 0ad3 08       		.byte	8
 9544 0ad4 08       		.byte	8
 9545 0ad5 08       		.byte	8
 9546 0ad6 08       		.byte	8
 9547 0ad7 08       		.byte	8
 9548 0ad8 08       		.byte	8
 9549 0ad9 08       		.byte	8
 9550 0ada 08       		.byte	8
 9551 0adb 08       		.byte	8
 9552 0adc 08       		.byte	8
 9553 0add 08       		.byte	8
 9554 0ade 08       		.byte	8
 9555 0adf 08       		.byte	8
 9556 0ae0 08       		.byte	8
 9557 0ae1 08       		.byte	8
 9558 0ae2 08       		.byte	8
 9559 0ae3 08       		.byte	8
 9560 0ae4 08       		.byte	8
 9561 0ae5 08       		.byte	8
 9562 0ae6 08       		.byte	8
 9563 0ae7 08       		.byte	8
 9564 0ae8 08       		.byte	8
 9565 0ae9 08       		.byte	8
 9566 0aea 08       		.byte	8
 9567 0aeb 08       		.byte	8
 9568 0aec 08       		.byte	8
 9569 0aed 08       		.byte	8
 9570 0aee 08       		.byte	8
 9571 0aef 08       		.byte	8
 9572 0af0 00       		.byte	0
 9573 0af1 01       		.byte	1
 9574 0af2 02       		.byte	2
 9575 0af3 10       		.byte	16
 9576 0af4 04       		.byte	4
 9577 0af5 05       		.byte	5
 9578 0af6 06       		.byte	6
 9579 0af7 07       		.byte	7
 9580 0af8 08       		.byte	8
 9581 0af9 09       		.byte	9
 9582 0afa 0A       		.byte	10
 9583 0afb 08       		.byte	8
 9584 0afc 11       		.byte	17
 9585 0afd 0C       		.byte	12
 9586 0afe 0D       		.byte	13
 9587 0aff 08       		.byte	8
 9588 0b00 0E       		.byte	14
 9589 0b01 0F       		.byte	15
 9590 0b02 08       		.byte	8
 9591 0b03 00       		.space	1
 9594              	CyFxGpifRegValue_usb2:
 9595 0b04 08830080 		.word	-2147450104
 9596 0b08 67000000 		.word	103
 9597 0b0c 01000000 		.word	1
 9598 0b10 46000000 		.word	70
 9599 0b14 00000000 		.word	0
 9600 0b18 00000000 		.word	0
 9601 0b1c 02000000 		.word	2
 9602 0b20 82000000 		.word	130
 9603 0b24 82070000 		.word	1922
 9604 0b28 40040000 		.word	1088
 9605 0b2c FCFF0000 		.word	65532
 9606 0b30 28000000 		.word	40
 9607 0b34 00000000 		.word	0
 9608 0b38 00000000 		.word	0
 9609 0b3c 00000000 		.word	0
 9610 0b40 00000000 		.word	0
 9611 0b44 01000000 		.word	1
 9612 0b48 00000000 		.word	0
 9613 0b4c 00000000 		.word	0
 9614 0b50 00000000 		.word	0
 9615 0b54 00000000 		.word	0
 9616 0b58 00000000 		.word	0
 9617 0b5c 00000000 		.word	0
 9618 0b60 00000000 		.word	0
 9619 0b64 00000000 		.word	0
 9620 0b68 00000000 		.word	0
 9621 0b6c 00000000 		.word	0
 9622 0b70 00000000 		.word	0
 9623 0b74 00000000 		.word	0
 9624 0b78 06000000 		.word	6
 9625 0b7c 00000000 		.word	0
 9626 0b80 FFFF0000 		.word	65535
 9627 0b84 09010000 		.word	265
 9628 0b88 00000000 		.word	0
 9629 0b8c F71F0000 		.word	8183
 9630 0b90 00000000 		.word	0
 9631 0b94 FFFF0000 		.word	65535
 9632 0b98 09010000 		.word	265
 9633 0b9c 00000000 		.word	0
 9634 0ba0 F71F0000 		.word	8183
 9635 0ba4 00000000 		.word	0
 9636 0ba8 00000000 		.word	0
 9637 0bac 00000000 		.word	0
 9638 0bb0 00000000 		.word	0
 9639 0bb4 00000000 		.word	0
 9640 0bb8 00000000 		.word	0
 9641 0bbc 00000000 		.word	0
 9642 0bc0 00000000 		.word	0
 9643 0bc4 00000000 		.word	0
 9644 0bc8 00000000 		.word	0
 9645 0bcc 00000000 		.word	0
 9646 0bd0 00000000 		.word	0
 9647 0bd4 00000000 		.word	0
 9648 0bd8 00000000 		.word	0
 9649 0bdc 00000000 		.word	0
 9650 0be0 00000000 		.word	0
 9651 0be4 00000000 		.word	0
 9652 0be8 00000000 		.word	0
 9653 0bec 00000000 		.word	0
 9654 0bf0 00000000 		.word	0
 9655 0bf4 00000000 		.word	0
 9656 0bf8 00000000 		.word	0
 9657 0bfc 00000000 		.word	0
 9658 0c00 00040180 		.word	-2147417088
 9659 0c04 01040180 		.word	-2147417087
 9660 0c08 02040180 		.word	-2147417086
 9661 0c0c 03040180 		.word	-2147417085
 9662 0c10 00000000 		.word	0
 9663 0c14 00000000 		.word	0
 9664 0c18 00000000 		.word	0
 9665 0c1c 00000000 		.word	0
 9666 0c20 00000000 		.word	0
 9667 0c24 00000000 		.word	0
 9668 0c28 00000000 		.word	0
 9669 0c2c 00000000 		.word	0
 9670 0c30 C1FFFFFF 		.word	-63
 9673              	glProbeCtrl20:
 9674 0c34 00       		.byte	0
 9675 0c35 00       		.byte	0
 9676 0c36 01       		.byte	1
 9677 0c37 01       		.byte	1
 9678 0c38 80       		.byte	-128
 9679 0c39 1A       		.byte	26
 9680 0c3a 06       		.byte	6
 9681 0c3b 00       		.byte	0
 9682 0c3c 00       		.byte	0
 9683 0c3d 00       		.byte	0
 9684 0c3e 00       		.byte	0
 9685 0c3f 00       		.byte	0
 9686 0c40 00       		.byte	0
 9687 0c41 00       		.byte	0
 9688 0c42 00       		.byte	0
 9689 0c43 00       		.byte	0
 9690 0c44 00       		.byte	0
 9691 0c45 00       		.byte	0
 9692 0c46 00       		.byte	0
 9693 0c47 D2       		.byte	-46
 9694 0c48 0F       		.byte	15
 9695 0c49 00       		.byte	0
 9696 0c4a 00       		.byte	0
 9697 0c4b 40       		.byte	64
 9698 0c4c 00       		.byte	0
 9699 0c4d 00       		.byte	0
 9700 0c4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 9701              		.align	2
 9702              	.LC0:
 9703 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9703      7065722D 
 9703      74696D65 
 9703      72202564 
 9703      0D0A00
 9704 0013 00       		.space	1
 9705              	.LC1:
 9706 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9706      636F6D6D 
 9706      616E6420 
 9706      71756575 
 9706      65206973 
 9707 0037 00       		.space	1
 9708              	.LC2:
 9709 0038 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9709      5420656E 
 9709      636F756E 
 9709      74657265 
 9709      642E2E2E 
 9710              	.LC3:
 9711 0058 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9711      454E4420 
 9711      656E636F 
 9711      756E7465 
 9711      7265642E 
 9712 007a 0000     		.space	2
 9713              	.LC4:
 9714 007c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9714      64697363 
 9714      6F6E6E65 
 9714      63746564 
 9714      2E2E2E30 
 9715 009b 00       		.space	1
 9716              	.LC5:
 9717 009c 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9717      7220696E 
 9717      206D756C 
 9717      74696368 
 9717      616E6E65 
 9718 00cf 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 9718      2C20646D 
 9718      61446F6E 
 9718      65202578 
 9718      0D0A00
 9719 00e2 0000     		.space	2
 9720              	.LC6:
 9721 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9721      43595F46 
 9721      585F5556 
 9721      435F5649 
 9721      44454F5F 
 9722 0117 0A00     		.ascii	"\012\000"
 9723 0119 000000   		.space	3
 9724              	.LC7:
 9725 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9725      43595F46 
 9725      585F5556 
 9725      435F5649 
 9725      44454F5F 
 9726 014f 00       		.ascii	"\000"
 9727              	.LC8:
 9728 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9728      726E6174 
 9728      65207365 
 9728      7474696E 
 9728      6720302E 
 9729              	.LC9:
 9730 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9730      72206665 
 9730      61747572 
 9730      65207265 
 9730      71756573 
 9731 018b 00       		.space	1
 9732              	.LC10:
 9733 018c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9733      6F6D6D69 
 9733      74656F66 
 9733      20737461 
 9733      7465203D 
 9734              	.LC11:
 9735 01a4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9735      6E656C20 
 9735      53657420 
 9735      57726170 
 9735      55702066 
 9736 01d1 000000   		.space	3
 9737              	.LC12:
 9738 01d4 4572726F 		.ascii	"Error handler...\015\012\000"
 9738      72206861 
 9738      6E646C65 
 9738      722E2E2E 
 9738      0D0A00
 9739 01e7 00       		.space	1
 9740              	.LC13:
 9741 01e8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9741      69742045 
 9741      4F462066 
 9741      61696C65 
 9741      64210A00 
 9742              	.LC14:
 9743 01fc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9743      49324320 
 9743      636F6D6D 
 9743      616E6420 
 9743      69732030 
 9744 022f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9744      78257820 
 9744      30782578 
 9744      20307825 
 9744      78203078 
 9745              	.LC15:
 9746 0248 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9746      206C6967 
 9746      68742063 
 9746      6F6D7065 
 9746      6E736174 
 9747 027b 25640D0A 		.ascii	"%d\015\012\000"
 9747      00
 9748              	.LC16:
 9749 0280 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9749      49324320 
 9749      63757272 
 9749      656E7420 
 9749      64617461 
 9750 02b3 64202564 		.ascii	"d %d\015\012\000"
 9750      0D0A00
 9751 02ba 0000     		.space	2
 9752              	.LC17:
 9753 02bc 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9753      26414743 
 9753      2073656E 
 9753      7420746F 
 9753      20686F73 
 9754 02e2 0000     		.space	2
 9755              	.LC18:
 9756 02e4 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9756      26414743 
 9756      20676F74 
 9756      74656E20 
 9756      66726F6D 
 9757 030e 0000     		.space	2
 9758              	.LC19:
 9759 0310 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 9759      6C657665 
 9759      6C2E2025 
 9759      64202564 
 9759      3B202564 
 9760 032a 0000     		.space	2
 9761              	.LC20:
 9762 032c 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 9762      7365742E 
 9762      20256420 
 9762      25643B20 
 9762      25642025 
 9763              	.LC21:
 9764 0344 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9764      67657420 
 9764      64617461 
 9764      2066726F 
 9764      6D20686F 
 9765 0371 000000   		.space	3
 9766              	.LC22:
 9767 0374 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9767      52657175 
 9767      65737420 
 9767      30782578 
 9767      20706172 
 9768 03a7 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9768      6E642074 
 9768      6F20686F 
 9768      73742030 
 9768      78257820 
 9769 03c2 0000     		.space	2
 9770              	.LC23:
 9771 03c4 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9771      204F7020 
 9771      72656365 
 9771      69766573 
 9771      20284354 
 9772 03eb 00       		.space	1
 9773              	.LC24:
 9774 03ec 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9774      756C7420 
 9774      73656C65 
 9774      63746F72 
 9774      20284354 
 9775 040e 0000     		.space	2
 9776              	.LC25:
 9777 0410 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9777      756C7420 
 9777      72657175 
 9777      65737420 
 9777      28435429 
 9778 0431 000000   		.space	3
 9779              	.LC26:
 9780 0434 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9780      52657175 
 9780      65737420 
 9780      30782578 
 9780      20706172 
 9781 0467 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9781      20307825 
 9781      78202F20 
 9781      73656E64 
 9781      20746F20 
 9782 0494 00       		.ascii	"\000"
 9783 0495 000000   		.space	3
 9784              	.LC27:
 9785 0498 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9785      73706565 
 9785      64203D20 
 9785      25642065 
 9785      76656E66 
 9786 04c8 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9786      71756573 
 9786      74203D20 
 9786      30782578 
 9786      20775661 
 9787 04f8 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9787      203D2030 
 9787      78257820 
 9787      6973666C 
 9787      61672030 
 9788 0512 0000     		.space	2
 9789              	.LC28:
 9790 0514 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9790      64656661 
 9790      756C7420 
 9790      73657475 
 9790      70207265 
 9791              	.LC29:
 9792 0540 47657420 		.ascii	"Get UVC Prob(set) control %d %d %d\015\012\000"
 9792      55564320 
 9792      50726F62 
 9792      28736574 
 9792      2920636F 
 9793 0565 000000   		.space	3
 9794              	.LC30:
 9795 0568 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 9795      74686520 
 9795      76696465 
 9795      6F206D6F 
 9795      64652066 
 9796 0589 000000   		.space	3
 9797              	.LC31:
 9798 058c 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 9798      74686520 
 9798      76696465 
 9798      6F206D6F 
 9798      64652066 
 9799 05b1 000000   		.space	3
 9800              	.LC32:
 9801 05b4 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9801      43595F46 
 9801      585F5556 
 9801      435F5354 
 9801      5245414D 
 9802 05da 0000     		.space	2
 9803              	.LC33:
 9804 05dc 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 9804      55564320 
 9804      7374696C 
 9804      6C205072 
 9804      6F622873 
 9805 0607 00       		.space	1
 9806              	.LC34:
 9807 0608 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 9807      74686520 
 9807      7374696C 
 9807      6C206D6F 
 9807      64652066 
 9808 0629 000000   		.space	3
 9809              	.LC35:
 9810 062c 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 9810      7374696C 
 9810      6C20636F 
 9810      6D6D6974 
 9810      20636F6E 
 9811              	.LC36:
 9812 0654 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 9812      43595F46 
 9812      585F5556 
 9812      435F5354 
 9812      494C5F45 
 9813              	.LC37:
 9814 0678 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 9814      55564320 
 9814      7374696C 
 9814      6C207472 
 9814      69676765 
 9815 06a1 000000   		.space	3
 9816              	.LC38:
 9817 06a4 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9817      7374696C 
 9817      6C207472 
 9817      69676765 
 9817      7220636F 
 9818 06cb 00       		.space	1
 9819              	.LC39:
 9820 06cc 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9820      65642074 
 9820      6F207365 
 9820      6E642069 
 9820      6E746572 
 9821 06fd 0A00     		.ascii	"\012\000"
 9822 06ff 00       		.space	1
 9823              	.LC40:
 9824 0700 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9824      73657420 
 9824      64656620 
 9824      64617461 
 9824      20307825 
 9825 071f 00       		.space	1
 9826              	.LC41:
 9827 0720 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9827      73657420 
 9827      64656620 
 9827      64617461 
 9827      20307825 
 9828 0753 2E0D0A00 		.ascii	".\015\012\000"
 9829 0757 00       		.space	1
 9830              	.LC42:
 9831 0758 55415254 		.ascii	"UART initialization failed!\012\000"
 9831      20696E69 
 9831      7469616C 
 9831      697A6174 
 9831      696F6E20 
 9832 0775 000000   		.space	3
 9833              	.LC43:
 9834 0778 49324320 		.ascii	"I2C initialization failed!\012\000"
 9834      696E6974 
 9834      69616C69 
 9834      7A617469 
 9834      6F6E2066 
 9835              	.LC44:
 9836 0794 49324320 		.ascii	"I2C configuration failed!\012\000"
 9836      636F6E66 
 9836      69677572 
 9836      6174696F 
 9836      6E206661 
 9837 07af 00       		.space	1
 9838              	.LC45:
 9839 07b0 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9839      43726561 
 9839      74652045 
 9839      76656E74 
 9839      20666169 
 9840 07da 0000     		.space	2
 9841              	.LC46:
 9842 07dc 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9842      20496E69 
 9842      74206661 
 9842      696C6564 
 9842      2C204572 
 9843 07ff 00       		.space	1
 9844              	.LC47:
 9845 0800 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9845      204F7665 
 9845      72726964 
 9845      65206661 
 9845      696C6564 
 9846 0827 00       		.space	1
 9847              	.LC48:
 9848 0828 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9848      28323029 
 9848      204F7665 
 9848      72726964 
 9848      65206661 
 9849 0853 00       		.space	1
 9850              	.LC49:
 9851 0854 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9851      28323429 
 9851      204F7665 
 9851      72726964 
 9851      65206661 
 9852 087f 00       		.space	1
 9853              	.LC50:
 9854 0880 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9854      20536574 
 9854      20287265 
 9854      73657420 
 9854      32322920 
 9855 08b2 00       		.ascii	"\000"
 9856 08b3 00       		.space	1
 9857              	.LC51:
 9858 08b4 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9858      20536574 
 9858      2028706F 
 9858      77657220 
 9858      32302920 
 9859 08e6 00       		.ascii	"\000"
 9860 08e7 00       		.space	1
 9861              	.LC52:
 9862 08e8 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9862      20536574 
 9862      2028736E 
 9862      61702073 
 9862      686F7420 
 9863 091b 25640A00 		.ascii	"%d\012\000"
 9864 091f 00       		.space	1
 9865              	.LC53:
 9866 0920 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9866      46756E63 
 9866      74696F6E 
 9866      20466169 
 9866      6C656420 
 9867 094f 00       		.space	1
 9868              	.LC54:
 9869 0950 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9869      46756E63 
 9869      74696F6E 
 9869      20466169 
 9869      6C656420 
 9870 097f 00       		.space	1
 9871              	.LC55:
 9872 0980 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9872      53657420 
 9872      456E6470 
 9872      6F696E74 
 9872      20636F6E 
 9873 09b0 00       		.ascii	"\000"
 9874 09b1 000000   		.space	3
 9875              	.LC56:
 9876 09b4 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9876      496E7465 
 9876      72727570 
 9876      74205374 
 9876      61747573 
 9877 09e7 20436F64 		.ascii	" Code = %d\012\000"
 9877      65203D20 
 9877      25640A00 
 9878 09f3 00       		.space	1
 9879              	.LC57:
 9880 09f4 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9880      65642074 
 9880      6F20616C 
 9880      6C6F6361 
 9880      7465206D 
 9881 0a27 65720D0A 		.ascii	"er\015\012\000"
 9881      00
 9882              	.LC58:
 9883 0a2c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9883      4368616E 
 9883      6E656C20 
 9883      43726561 
 9883      74696F6E 
 9884 0a5a 0000     		.space	2
 9885              	.LC59:
 9886 0a5c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9886      436F6E6E 
 9886      65637420 
 9886      6661696C 
 9886      65642C20 
 9887 0a81 000000   		.space	3
 9888              	.LC60:
 9889 0a84 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 9889      74686520 
 9889      76696465 
 9889      6F206D6F 
 9889      64652066 
 9890 0aa6 0000     		.space	2
 9891              	.LC61:
 9892 0aa8 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9892      4368616E 
 9892      6E656C20 
 9892      52657365 
 9892      74204661 
 9893 0ad3 00       		.space	1
 9894              	.LC62:
 9895 0ad4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9895      4368616E 
 9895      6E656C20 
 9895      53657420 
 9895      5472616E 
 9896 0b05 00       		.ascii	"\000"
 9897 0b06 0000     		.space	2
 9898              	.LC63:
 9899 0b08 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9899      4368616E 
 9899      6E656C20 
 9899      53657420 
 9899      5472616E 
 9900 0b39 0A00     		.ascii	"\012\000"
 9901 0b3b 00       		.space	1
 9902              	.LC64:
 9903 0b3c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9903      75706572 
 9903      20677069 
 9903      6600
 9904 0b4a 0000     		.space	2
 9905              	.LC65:
 9906 0b4c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9906      69676820 
 9906      67706966 
 9906      00
 9907 0b59 000000   		.space	3
 9908              	.LC66:
 9909 0b5c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9909      696E6720 
 9909      47504946 
 9909      20436F6E 
 9909      66696775 
 9910 0b8f 0A00     		.ascii	"\012\000"
 9911 0b91 000000   		.space	3
 9912              	.LC67:
 9913 0b94 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9913      74696E67 
 9913      20475049 
 9913      46207374 
 9913      61746520 
 9914 0bc7 0D0A00   		.ascii	"\015\012\000"
 9915 0bca 0000     		.space	2
 9916              	.LC68:
 9917 0bcc 33303A55 		.ascii	"30:UVC App Thread\000"
 9917      56432041 
 9917      70702054 
 9917      68726561 
 9917      6400
 9918 0bde 0000     		.space	2
 9919              	.LC69:
 9920 0be0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9920      56432041 
 9920      70702045 
 9920      50302054 
 9920      68726561 
 9921 0bf6 0000     		.space	2
 9922              	.LC70:
 9923 0bf8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9923      32432041 
 9923      70702043 
 9923      54524C20 
 9923      54687265 
 9924 0c0f 00       		.bss
 9925              		.align	2
 9926              		.set	.LANCHOR0,. + 0
 9929              	glFxUVCEvent:
 9930 0000 00000000 		.space	40
 9930      00000000 
 9930      00000000 
 9930      00000000 
 9930      00000000 
 9933              	gpif_initialized:
 9934 0028 00000000 		.space	4
 9937              	streamingStarted:
 9938 002c 00000000 		.space	4
 9941              	isUsbConnected:
 9942 0030 00000000 		.space	4
 9945              	fb:
 9946 0034 0000     		.space	2
 9949              	pb:
 9950 0036 0000     		.space	2
 9953              	pbc:
 9954 0038 0000     		.space	2
 9955 003a 0000     		.space	2
 9958              	stiflag:
 9959 003c 00000000 		.space	4
 9962              	hitFV:
 9963 0040 00000000 		.space	4
 9966              	prodCount:
 9967 0044 0000     		.space	2
 9970              	consCount:
 9971 0046 0000     		.space	2
 9974              	clearFeatureRqtReceived:
 9975 0048 00000000 		.space	4
 9978              	usbSpeed:
 9979 004c 00       		.space	1
 9980 004d 000000   		.space	3
 9983              	I2CCMDArry:
 9984 0050 00000000 		.space	12
 9984      00000000 
 9984      00000000 
 9987              	glEp0Buffer:
 9988 005c 00000000 		.space	32
 9988      00000000 
 9988      00000000 
 9988      00000000 
 9988      00000000 
 9991              	WDRflag:
 9992 007c 00000000 		.space	4
 9995              	glCommitCtrl:
 9996 0080 00000000 		.space	32
 9996      00000000 
 9996      00000000 
 9996      00000000 
 9996      00000000 
 9999              	setRes:
 10000 00a0 00       		.space	1
 10003              	setstilRes:
 10004 00a1 00       		.space	1
 10007              	IMcount.7777:
 10008 00a2 00       		.space	1
 10009 00a3 00       		.space	1
 10012              	uvcAppThread:
 10013 00a4 00000000 		.space	168
 10013      00000000 
 10013      00000000 
 10013      00000000 
 10013      00000000 
 10016              	uvcAppEP0Thread:
 10017 014c 00000000 		.space	168
 10017      00000000 
 10017      00000000 
 10017      00000000 
 10017      00000000 
 10020              	i2cAppThread:
 10021 01f4 00000000 		.space	168
 10021      00000000 
 10021      00000000 
 10021      00000000 
 10021      00000000 
 10024              	testSnap:
 10025 029c 00       		.space	1
 10026 029d 00       		.space	1
 10029              	fbbak:
 10030 029e 0000     		.space	2
 10033              	pbbak:
 10034 02a0 0000     		.space	2
 10037              	pbcbak:
 10038 02a2 0000     		.space	2
 10041              	pbcpbak:
 10042 02a4 0000     		.space	2
 10043 02a6 0000     		.text
 10044              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:191    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:283    .text:0000020c $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:297    .text:0000022c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:294    .text:0000022c $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:316    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:320    .text:00000240 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:322    .text:00000240 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:501    .text:000003a0 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:510    .text:000003b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:513    .text:000003b0 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:735    .text:00000550 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:745    .text:0000056c $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:747    .text:0000056c CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1072   .text:00000834 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1088   .text:00000860 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1091   .text:00000860 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1128   .text:00000898 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1141   .text:000008c4 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1205   .text:00000934 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1212   .text:00000944 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1223   .text:0000095c $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1226   .text:0000095c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1354   .text:00000a70 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1359   .text:00000a78 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1362   .text:00000a78 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1425   .text:00000af8 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1637   .text:00000ca0 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1679   .text:00000d3c $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1744   .text:00000dc0 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:1784   .text:00000e58 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:3062   .text:00001a74 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:3082   .text:00001ab8 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:3085   .text:00001ab8 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:3253   .text:00001c14 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:3266   .text:00001c3c $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:3761   .text:0000214c $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:3772   .text:0000216c $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:4034   .text:00002428 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:4047   .text:00002450 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:4050   .text:00002450 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:4112   .text:000024cc $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:4120   .text:000024dc $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5393   .text:00002f9c $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5426   .text:0000300c $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5429   .text:0000300c CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5720   .text:000032c4 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5727   .text:000032d4 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5730   .text:000032d4 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5771   .text:00003318 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5776   .text:00003320 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5779   .text:00003320 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5804   .text:0000333c $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5808   .text:00003340 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:5811   .text:00003340 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7238   .text:00003e88 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7300   .text:00003f64 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7303   .text:00003f64 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7386   .text:00003ff0 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7395   .text:00004000 $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7398   .text:00004000 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7555   .text:00004178 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7571   .text:000041ac $a
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7574   .text:000041ac main
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9139   .data:00000644 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9148   .data:00000650 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9223   .data:00000770 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9242   .data:00000780 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7736   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9321   .data:000008b0 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9332   .data:000008c0 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9443   .data:00000a70 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9594   .data:00000b04 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7749   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9135   .data:00000643 snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10024  .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9945   .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9949   .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9953   .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10029  .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10033  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10037  .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10041  .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9941   .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9978   .bss:0000004c usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9974   .bss:00000048 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9937   .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9076   .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9106   .data:0000062c glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9673   .data:00000c34 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9121   .data:00000638 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:8731   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7713   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7717   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7761   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:7765   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:8088   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:8746   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:8753   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9701   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9925   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9929   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9933   .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9958   .bss:0000003c stiflag
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9962   .bss:00000040 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9966   .bss:00000044 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9970   .bss:00000046 consCount
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9983   .bss:00000050 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9987   .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9991   .bss:0000007c WDRflag
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9995   .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:9999   .bss:000000a0 setRes
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10003  .bss:000000a1 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10007  .bss:000000a2 IMcount.7777
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10012  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10016  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccKCNCs6.s:10020  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
