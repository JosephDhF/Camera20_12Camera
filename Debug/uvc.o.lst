   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** 
 105:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 106:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 107:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 108:../uvc.c      ****                                                            received. */
 109:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 110:../uvc.c      **** #ifdef BACKFLOW_DETECT
 111:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 112:../uvc.c      **** #endif
 113:../uvc.c      **** 
 114:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 115:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 116:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 117:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 118:../uvc.c      **** #endif
 119:../uvc.c      **** 
 120:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 121:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 122:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 123:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 125:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 126:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 127:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 128:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 129:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 131:../uvc.c      ****                                    with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 133:../uvc.c      ****                                    streaming with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 135:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 136:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 137:../uvc.c      **** };
 138:../uvc.c      **** 
 139:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 140:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 141:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 143:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 144:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 145:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 146:../uvc.c      **** };
 147:../uvc.c      **** 
 148:../uvc.c      **** 
 149:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 150:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 151:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 152:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 154:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 155:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 156:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 157:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 158:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 159:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 160:../uvc.c      ****                                    with adjustable compression parameters */
 161:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 162:../uvc.c      ****                                    streaming with adjustable compression parameters */
 163:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 164:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 169:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 170:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 171:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 172:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 173:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 174:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 175:../uvc.c      **** };
 176:../uvc.c      **** 
 177:../uvc.c      **** 
 178:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 179:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 180:../uvc.c      **** 
 181:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 182:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 183:../uvc.c      **** {
 184:../uvc.c      ****     0x0C,                               /* Header Length */
 185:../uvc.c      ****     0x8C,                               /* Bit field header field */
 186:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 188:../uvc.c      **** };
 189:../uvc.c      **** 
 190:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 191:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 192:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 193:../uvc.c      ****                                                            the current video frame. */
 194:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 195:../uvc.c      **** #ifndef CAM720
 196:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 197:../uvc.c      **** #else
 198:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 199:../uvc.c      **** #endif
 200:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 201:../uvc.c      **** 
 202:../uvc.c      **** /************ control parameters array ***********
 203:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 204:../uvc.c      ****  *    e.g.
 205:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 206:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 207:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 208:../uvc.c      ****  **************************************************/
 209:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 210:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 211:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 212:../uvc.c      **** #ifndef CAM720
 213:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 214:../uvc.c      **** #else
 215:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 216:../uvc.c      **** #endif
 217:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0,
 218:../uvc.c      **** 		{/*2*/ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0,
 219:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 220:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 221:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 222:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 223:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,
 224:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 225:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 228:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 229:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 233:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** #ifndef CAM720
 235:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 236:../uvc.c      **** #else
 237:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 238:../uvc.c      **** #endif
 239:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 240:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 241:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 242:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 244:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 246:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg1     , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 247:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 248:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		/**********************************
 252:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 253:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 254:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 255:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 256:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 257:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 258:../uvc.c      **** 		 *
 259:../uvc.c      **** 		 *********************************/
 260:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 261:../uvc.c      **** };
 262:../uvc.c      **** 
 263:../uvc.c      **** #ifndef CAM720
 264:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 265:../uvc.c      **** #else
 266:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 267:../uvc.c      **** #endif
 268:../uvc.c      **** 
 269:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 270:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 271:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 272:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 273:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 274:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 275:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 276:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 277:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 278:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 279:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 280:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 281:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 282:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 285:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** };
 287:../uvc.c      **** 
 288:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 289:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 290:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 291:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 292:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 293:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 294:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 295:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 296:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 297:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 298:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 299:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 300:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 302:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 303:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 304:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** };
 308:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 309:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 310:../uvc.c      **** /*
 311:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 312:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 313:../uvc.c      ****  */
 314:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 315:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 316:../uvc.c      **** };
 317:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 318:../uvc.c      **** 		0
 319:../uvc.c      **** };
 320:../uvc.c      **** 
 321:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 322:../uvc.c      **** 
 323:../uvc.c      **** void I2CCmdHandler(){
 324:../uvc.c      **** 	uint8_t buf[2];
 325:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 327:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 329:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 330:../uvc.c      **** 
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 332:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 333:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 334:../uvc.c      **** 
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 336:../uvc.c      **** 	{
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 338:../uvc.c      **** #if 0 //for debugging
 339:../uvc.c      **** 		/* test still image operation */
 340:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 341:../uvc.c      **** 			snapButFlag = 0; //press
 342:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 343:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 344:../uvc.c      **** 			snapButFlag = 0xf; //release
 345:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 346:../uvc.c      **** 		}
 347:../uvc.c      **** 
 348:../uvc.c      **** 		/* end of the test */
 349:../uvc.c      **** #endif
 350:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 355:../uvc.c      **** 			}
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 357:../uvc.c      **** 		}else{//not support currently
 358:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 359:../uvc.c      **** 		}
 360:../uvc.c      **** 	}else if(CmdType == 1){
 361:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 362:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 363:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 364:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 365:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 366:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 367:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 368:../uvc.c      **** 			}
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 370:../uvc.c      **** 		}else{//not support currently
 371:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 372:../uvc.c      **** 		}
 373:../uvc.c      **** 
 374:../uvc.c      **** 	}
 375:../uvc.c      **** }
 376:../uvc.c      **** 
 377:../uvc.c      **** /************************************
 378:../uvc.c      ****  * set Iris mode
 379:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 380:../uvc.c      ****  */
 381:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 382:../uvc.c      **** 	uint8_t dataIdx;
 383:../uvc.c      **** 	  dataIdx = 0;
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 388:../uvc.c      **** }
 389:../uvc.c      **** 
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 391:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 392:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 393:../uvc.c      ****     uint16_t readCount;
 394:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 395:../uvc.c      ****     uint8_t devAdd;
 396:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 397:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 398:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 399:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 400:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 401:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 402:../uvc.c      ****     }else{
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 404:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 405:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 406:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 407:../uvc.c      ****     }
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 409:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 410:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 411:../uvc.c      **** #endif
 412:../uvc.c      ****     reqData = bRequest;
 413:../uvc.c      ****     /*
 414:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 415:../uvc.c      ****      */
 416:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 417:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 418:../uvc.c      ****     	goto EndofSet;
 419:../uvc.c      ****     }
 420:../uvc.c      ****     switch (bRequest)
 421:../uvc.c      **** 		 {
 422:../uvc.c      **** 
 423:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 424:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 425:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 427:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 428:../uvc.c      **** 			  break;
 429:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 430:../uvc.c      **** 
 431:../uvc.c      **** 			 switch(CtrlID)
 432:../uvc.c      **** 			 {
 433:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 434:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 435:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 436:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 437:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 438:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 439:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 440:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 441:../uvc.c      **** 			 	 		 break;
 442:../uvc.c      **** 			 	 }
 443:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 444:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 445:../uvc.c      **** 					 if(CamMode == 1){//720p
 446:../uvc.c      **** 						if(sendData >= 3){
 447:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 448:../uvc.c      **** 							sendData = 0; //set back to default
 449:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 450:../uvc.c      **** 						}
 451:../uvc.c      **** 						sendData += 4;
 452:../uvc.c      **** 					 }
 453:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 454:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 455:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 456:../uvc.c      **** 					 break;
 457:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 460:../uvc.c      **** 			 		 }
 461:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 462:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 463:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 464:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 465:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 466:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 467:../uvc.c      **** #endif
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 469:../uvc.c      **** 			 		 {
 470:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 471:../uvc.c      **** 			 		 }
 472:../uvc.c      **** 			 		 break;
 473:../uvc.c      **** 				 case ExtAexModCtlID9:
 474:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 475:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 476:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 477:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 478:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 479:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 480:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 481:../uvc.c      **** 					 break;
 482:../uvc.c      **** 
 483:../uvc.c      **** 			 	 case BrgtCtlID1:
 484:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 485:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 486:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 488:../uvc.c      **** 					 }else{
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 490:../uvc.c      **** 					 }
 491:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 492:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 493:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 494:../uvc.c      **** 					 break;
 495:../uvc.c      **** 				 case HueCtlID5:
 496:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 499:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 500:../uvc.c      **** 					 break;
 501:../uvc.c      **** 				 case WBTLevCtlID11:
 502:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 503:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 504:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 505:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 506:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 507:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 508:../uvc.c      **** 					 break;
 509:../uvc.c      **** 				 case SaturCtlID6:
 510:../uvc.c      **** 				 default:
 511:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 512:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 513:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 514:../uvc.c      **** 					 break;
 515:../uvc.c      **** 			 }
 516:../uvc.c      **** 
 517:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 518:../uvc.c      **** 
 519:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 520:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 521:../uvc.c      **** #endif
 522:../uvc.c      **** 			  break;
 523:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 524:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 525:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 526:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 527:../uvc.c      **** 		 	 }
 528:../uvc.c      **** 
 529:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 530:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 531:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 532:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 533:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 534:../uvc.c      **** 			 }else
 535:../uvc.c      **** 			 {
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 537:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 538:../uvc.c      **** 			 }
 539:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 540:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 541:../uvc.c      **** 			  break;
 542:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 543:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 544:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 545:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 546:../uvc.c      **** 		 	 }
 547:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 548:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 549:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 550:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 551:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 552:../uvc.c      **** 			 }else
 553:../uvc.c      **** 			 {
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 555:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 556:../uvc.c      **** 			 }
 557:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 558:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 559:../uvc.c      **** 			  break;
 560:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 561:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 563:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 564:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 565:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 566:../uvc.c      **** 		 	 }
 567:../uvc.c      **** 		 	 else{
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 569:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 570:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 571:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 572:../uvc.c      **** 		 	 }
 573:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 574:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 575:../uvc.c      **** 			  break;
 576:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 577:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 579:../uvc.c      **** 		 	 }
 580:../uvc.c      **** 		 	 else{
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 582:../uvc.c      **** 		 	 }
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 584:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 585:../uvc.c      **** 			  Len = 1;
 586:../uvc.c      **** 			  break;
 587:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 588:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 589:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 590:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 591:../uvc.c      **** 		 	 }
 592:../uvc.c      **** 
 593:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 594:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 595:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 596:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 597:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 598:../uvc.c      **** 			 }else{
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 600:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 601:../uvc.c      **** 			 }
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 603:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 604:../uvc.c      **** 			  break;
 605:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 606:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 607:../uvc.c      **** 				  glEp0Buffer, &readCount);
 608:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 609:../uvc.c      **** 			   {
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 612:../uvc.c      **** 				  getData = glEp0Buffer[0];
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 614:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 615:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 616:../uvc.c      **** #endif
 617:../uvc.c      **** 				  switch(CtrlID)
 618:../uvc.c      **** 					 {
 619:../uvc.c      **** 						 case ExtShutCtlID0:
 620:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 621:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 622:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 623:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 625:../uvc.c      **** 									 }else{
 626:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 627:../uvc.c      **** 									 }
 628:../uvc.c      **** 								 }
 629:../uvc.c      **** 							 }else{
 630:../uvc.c      **** 								 Data1 = Data0 - 1;
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 632:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 634:../uvc.c      **** 									 }else{
 635:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 636:../uvc.c      **** 									 }
 637:../uvc.c      **** 								 }
 638:../uvc.c      **** 								 if(Data1 < 8){
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 641:../uvc.c      **** 								 }else{
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 644:../uvc.c      **** 								 }
 645:../uvc.c      **** 							 }
 646:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 647:../uvc.c      **** 							 dataIdx = 0;
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 649:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 651:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 652:../uvc.c      **** 							 break;
 653:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 655:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 656:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 657:../uvc.c      **** 							 dataIdx = 0;
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 659:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 660:../uvc.c      **** 							 if(getData != 0){
 661:../uvc.c      **** 								 dataIdx++;
 662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 663:../uvc.c      **** 							 }
 664:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 665:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 666:../uvc.c      **** 							 break;
 667:../uvc.c      **** 						 case ExtExRefCtlID10:
 668:../uvc.c      **** 							 dataIdx = 0;
 669:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 670:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 672:../uvc.c      **** 							 if(WDRflag)
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 674:../uvc.c      **** 							 else
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 676:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 677:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 678:../uvc.c      **** 						 case ExtCamMCtlID12:
 679:../uvc.c      **** 							 /*
 680:../uvc.c      **** 							 dataIdx = 0;
 681:../uvc.c      **** 							 if(Data0 <= 3){
 682:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 683:../uvc.c      **** 								 Data1 = Data0;
 684:../uvc.c      **** 							 }else{
 685:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 686:../uvc.c      **** 								 Data1 = Data0-4;
 687:../uvc.c      **** 							 }
 688:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 689:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 690:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 692:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 693:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 694:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 695:../uvc.c      **** 							 */
 696:../uvc.c      **** 							 break;
 697:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 698:../uvc.c      **** 							 dataIdx = 0;
 699:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 700:../uvc.c      **** 								 Data0 = 1;
 701:../uvc.c      **** 							 }else{ //save current sensor parameters.
 702:../uvc.c      **** 								 Data0 = 0;
 703:../uvc.c      **** 							 }
 704:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 706:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 708:../uvc.c      **** 							 break;
 709:../uvc.c      **** 						 case ExtI2CCtlID15:
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 712:../uvc.c      **** 					 		 }
 713:../uvc.c      **** 					 		I2CCmdHandler();
 714:../uvc.c      **** 							 break;
 715:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 716:../uvc.c      **** 							 dataIdx = 0;
 717:../uvc.c      **** #if 0 //seperate version
 718:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 719:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 720:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 721:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 722:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 723:../uvc.c      **** 							 }else{ //disable BLD window
 724:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 725:../uvc.c      **** 							 }
 726:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 727:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 728:../uvc.c      **** 							 dataIdx++;
 729:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 730:../uvc.c      **** 							 dataIdx++;
 731:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 732:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 733:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 734:../uvc.c      **** 							 dataIdx++;
 735:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 737:../uvc.c      **** #else //combination version
 738:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 739:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 740:../uvc.c      **** 						     /* end test */
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 742:../uvc.c      **** 							 dataIdx++;
 743:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 744:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 745:../uvc.c      **** 							 getData1 = Data1;
 746:../uvc.c      **** #endif
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 748:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 749:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 750:../uvc.c      **** 							 break;
 751:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 752:../uvc.c      **** 							 dataIdx = 0;
 753:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 755:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 756:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 757:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 758:../uvc.c      **** 							 break;
 759:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 760:../uvc.c      **** 							 dataIdx = 0;
 761:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 766:../uvc.c      **** 							 break;
 767:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 768:../uvc.c      **** 							 dataIdx = 0;
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 770:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 771:../uvc.c      **** 							  if(Data0&0x80){
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 773:../uvc.c      **** 							  }else{
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 775:../uvc.c      **** 							  }
 776:../uvc.c      **** 							 Data1 |= ~0x03;
 777:../uvc.c      **** 							 Data1 &= 0xC7;
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 779:../uvc.c      **** 						  	 dataIdx++;
 780:../uvc.c      **** 
 781:../uvc.c      **** 							 Data0 = (Data0 << 2);
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 783:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 784:../uvc.c      **** 
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 786:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 787:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 788:../uvc.c      **** 
 789:../uvc.c      **** 							 break;
 790:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 791:../uvc.c      **** 							 dataIdx = 0;
 792:../uvc.c      **** 
 793:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 795:../uvc.c      **** 							 dataIdx++;
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 797:../uvc.c      **** 							 dataIdx++;
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 799:../uvc.c      **** 							 dataIdx++;
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 801:../uvc.c      **** 							 dataIdx++;
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 803:../uvc.c      **** 							 dataIdx++;
 804:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 805:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 806:../uvc.c      **** 
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 809:../uvc.c      **** 							 break;
 810:../uvc.c      **** 						 case SaturCtlID6:
 811:../uvc.c      **** 							 dataIdx = 0;
 812:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 813:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 815:../uvc.c      **** 							 dataIdx++;
 816:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 817:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 820:../uvc.c      **** 							 break;
 821:../uvc.c      **** 
 822:../uvc.c      **** 						 case WBTLevCtlID11:
 823:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 824:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 825:../uvc.c      **** 							 dataIdx = 0;
 826:../uvc.c      **** 
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 829:../uvc.c      **** 							 dataIdx++;
 830:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 831:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 832:../uvc.c      **** 
 833:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 834:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 836:../uvc.c      **** 							 break;
 837:../uvc.c      **** 						 case MFreqCtlID4:
 838:../uvc.c      **** 							 dataIdx = 0;
 839:../uvc.c      **** 							 Data0 = Data0 - 1;
 840:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 841:../uvc.c      **** 								 Data0 = 0;
 842:../uvc.c      **** 							 else if(Data0 >2)
 843:../uvc.c      **** 								 Data0 = 1;
 844:../uvc.c      **** 
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 847:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 848:../uvc.c      **** 
 849:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 851:../uvc.c      **** 							 break;
 852:../uvc.c      **** 					 	 case BLCCtlID0:
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 854:../uvc.c      **** 							 if(Data0 == 3)
 855:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 856:../uvc.c      **** 							 else
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 859:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 860:../uvc.c      **** 							 {
 861:../uvc.c      **** 								 if(Data0 < 2){
 862:../uvc.c      **** 					 				 ;//Data0 += 4;
 863:../uvc.c      **** 					 			 }else{
 864:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 865:../uvc.c      **** 									Data0 = 0; //set to default.
 866:../uvc.c      **** 					 			 }
 867:../uvc.c      **** 					 		 }
 868:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 869:../uvc.c      **** 							 dataIdx = 0;
 870:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 874:../uvc.c      **** 
 875:../uvc.c      **** 					 		 break;
 876:../uvc.c      **** 						 default:
 877:../uvc.c      **** 							 dataIdx = 0;
 878:../uvc.c      **** 
 879:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 880:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 881:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 882:../uvc.c      **** 
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 885:../uvc.c      **** 							 break;
 886:../uvc.c      **** 					 }
 887:../uvc.c      **** 			   }else{
 888:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 889:../uvc.c      **** 			   }
 890:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 891:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 892:../uvc.c      **** #endif
 893:../uvc.c      **** 
 894:../uvc.c      **** 			  break;
 895:../uvc.c      **** 		  default:
 896:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 897:../uvc.c      **** 			  break;
 898:../uvc.c      **** 		 }
 899:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 900:../uvc.c      **** }
 901:../uvc.c      **** /************** CT control requests handler *************************/
 902:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 903:../uvc.c      **** 
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 905:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 906:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 907:../uvc.c      ****     uint16_t readCount;
 908:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 909:../uvc.c      ****     uint16_t diff, value, diffRd;
 910:../uvc.c      ****     uint8_t i, shutter, index;
 911:../uvc.c      ****     diff = 0xffff;
 912:../uvc.c      ****     shutter = 1;
 913:../uvc.c      ****     index = 1;
 914:../uvc.c      **** 
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 916:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 917:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 918:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 919:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 920:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 921:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 922:../uvc.c      **** #endif
 923:../uvc.c      ****     reqData = bRequest;
 924:../uvc.c      **** 
 925:../uvc.c      ****     switch (bRequest)
 926:../uvc.c      **** 		 {
 927:../uvc.c      **** 
 928:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 932:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 933:../uvc.c      **** 			  break;
 934:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 935:../uvc.c      **** 
 936:../uvc.c      **** 			 switch(CtrlID)
 937:../uvc.c      **** 			 {
 938:../uvc.c      **** 				 default:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 942:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 943:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 944:../uvc.c      **** 					 break;
 945:../uvc.c      **** 			 }
 946:../uvc.c      **** 
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 948:../uvc.c      **** 
 949:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 950:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 951:../uvc.c      **** #endif
 952:../uvc.c      **** 			  break;
 953:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 957:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 958:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 960:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 961:../uvc.c      **** 			  break;
 962:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 966:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 967:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 968:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 969:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 970:../uvc.c      **** 			  break;
 971:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 975:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 976:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 977:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 978:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 979:../uvc.c      **** 			  break;
 980:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 983:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 984:../uvc.c      **** 			  Len = 1;
 985:../uvc.c      **** 			  break;
 986:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 990:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 993:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 994:../uvc.c      **** 			  break;
 995:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 996:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 997:../uvc.c      **** 			  glEp0Buffer, &readCount);
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1000:../uvc.c      **** 			  value = Data1;
1001:../uvc.c      **** 
1002:../uvc.c      **** 			  switch(CtrlID)
1003:../uvc.c      **** 			  {
1004:../uvc.c      **** 		  	      case AutoExMCtlID1:
1005:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1006:../uvc.c      **** 
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1009:../uvc.c      **** 				    getData = glEp0Buffer[0];
1010:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1011:../uvc.c      **** 		  		    switch (getData){
1012:../uvc.c      **** 						case 1:
1013:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1014:../uvc.c      **** 							break;
1015:../uvc.c      **** 						case 2:
1016:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1017:../uvc.c      **** 							dataIdx = 0;
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1019:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1020:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1021:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1022:../uvc.c      **** 
1023:../uvc.c      **** 							break;
1024:../uvc.c      **** 						case 4:
1025:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1026:../uvc.c      **** 							break;
1027:../uvc.c      **** 						case 8:
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1029:../uvc.c      **** 			  		    	dataIdx = 0;
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1031:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1032:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1033:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1034:../uvc.c      **** 							break;
1035:../uvc.c      **** 		  		    }
1036:../uvc.c      **** #if 0
1037:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1038:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1039:../uvc.c      **** 						  dataIdx = 0;
1040:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1041:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1042:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1043:../uvc.c      **** 		  		    }
1044:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1045:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1046:../uvc.c      **** 		  		    }
1047:../uvc.c      **** #endif
1048:../uvc.c      **** 				    break;
1049:../uvc.c      **** 
1050:../uvc.c      **** 			  	  case ExTmACtlID3:
1051:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1052:../uvc.c      **** 
1053:../uvc.c      **** 					  value = (value << 8)|Data0;
1054:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1055:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1056:../uvc.c      **** 					  {
1057:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1058:../uvc.c      **** 						  {
1059:../uvc.c      **** 							if(value > ShutValueArry[i]){
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1061:../uvc.c      **** 							}else{
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1063:../uvc.c      **** 							}
1064:../uvc.c      **** 							  if(diff > diffRd){
1065:../uvc.c      **** 								  diff = diffRd;
1066:../uvc.c      **** 								  index = i;
1067:../uvc.c      **** 							  }
1068:../uvc.c      **** 						  }
1069:../uvc.c      **** 						  shutter = shutter+index;
1070:../uvc.c      **** 
1071:../uvc.c      **** 						  dataIdx = 0;
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1073:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1074:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1075:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1076:../uvc.c      **** 
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1081:../uvc.c      **** 					  }else{
1082:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1083:../uvc.c      **** 					  }
1084:../uvc.c      **** 					  getData = glEp0Buffer[0];
1085:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1086:../uvc.c      **** 					  break;
1087:../uvc.c      **** 			  	  case IriACtlID7:
1088:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1089:../uvc.c      **** 					  {
1090:../uvc.c      **** 							 dataIdx = 0;
1091:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1092:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1094:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1095:../uvc.c      **** 
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1099:../uvc.c      **** 					  }else{
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1101:../uvc.c      **** 					  }
1102:../uvc.c      **** 					  getData = glEp0Buffer[0];
1103:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1104:../uvc.c      **** 
1105:../uvc.c      **** 					  break;
1106:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1107:../uvc.c      **** 					  getData = glEp0Buffer[0];
1108:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1109:../uvc.c      **** #if 1
1110:../uvc.c      **** 					  dataIdx = 0;
1111:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1112:../uvc.c      **** 					  if(getData == 1)
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1114:../uvc.c      **** 					  else if(getData == 0xff)
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1116:../uvc.c      **** 					  else
1117:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1118:../uvc.c      **** 					  //dataIdx++;
1119:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1120:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1121:../uvc.c      **** #endif
1122:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1123:../uvc.c      **** 					  break;
1124:../uvc.c      **** 
1125:../uvc.c      **** 			  	  default:
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1128:../uvc.c      **** 			  		 break;
1129:../uvc.c      **** 			  }
1130:../uvc.c      **** 			  break;
1131:../uvc.c      **** 		  default:
1132:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1133:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1134:../uvc.c      **** 			  break;
1135:../uvc.c      **** 		 }
1136:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1137:../uvc.c      **** 
1138:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1139:../uvc.c      **** }
1140:../uvc.c      **** 
1141:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1142:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1143:../uvc.c      **** {
1144:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1145:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1146:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1147:../uvc.c      **** 
1148:../uvc.c      ****     CtrlID = BrgtCtlID1;
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1150:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1151:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1152:../uvc.c      ****     Data1 = Data0;
1153:../uvc.c      **** 
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1155:../uvc.c      ****     if(Data1&0x80){
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1157:../uvc.c      ****     }else{
1158:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1159:../uvc.c      ****     }
1160:../uvc.c      ****     Data0 = (Data0 << 2);
1161:../uvc.c      **** 
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1163:../uvc.c      **** 
1164:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1166:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1167:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1169:../uvc.c      **** 
1170:../uvc.c      ****     CtrlID = ConsCtlID2;
1171:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1172:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1173:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1174:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1175:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1177:../uvc.c      **** 
1178:../uvc.c      ****     CtrlID = HueCtlID5;
1179:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1180:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1181:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1190:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1191:../uvc.c      **** 
1192:../uvc.c      ****     CtrlID = SaturCtlID6;
1193:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1194:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1195:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1196:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1199:../uvc.c      **** 
1200:../uvc.c      ****     CtrlID = ShapCtlID7;
1201:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1202:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1203:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1204:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1205:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1207:../uvc.c      **** 
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1209:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1210:../uvc.c      **** 	return;
1211:../uvc.c      **** }
1212:../uvc.c      **** 
1213:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1214:../uvc.c      **** void
1215:../uvc.c      **** CyFxUVCAddHeader (
1216:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1217:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1218:../uvc.c      ****         )
1219:../uvc.c      **** {
1220:../uvc.c      ****     /* Copy header to buffer */
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1222:../uvc.c      **** 
1223:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1224:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1225:../uvc.c      ****     {
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1227:../uvc.c      ****     }
1228:../uvc.c      **** }
1229:../uvc.c      **** 
1230:../uvc.c      **** 
1231:../uvc.c      **** /* Application Error Handler */
1232:../uvc.c      **** void
1233:../uvc.c      **** CyFxAppErrorHandler (
1234:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1235:../uvc.c      ****         )
1236:../uvc.c      **** {
1237:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1238:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1239:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1240:../uvc.c      **** 
1241:../uvc.c      ****        This function can be modified to take additional error handling actions such
1242:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1243:../uvc.c      ****      */
1244:../uvc.c      ****     for (;;)
1245:../uvc.c      ****     {
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
1248:../uvc.c      ****     }
1249:../uvc.c      **** }
1250:../uvc.c      **** 
1251:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1252:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1253:../uvc.c      ****  */
1254:../uvc.c      **** static void
1255:../uvc.c      **** CyFxUVCApplnAbortHandler (
1256:../uvc.c      ****         void)
1257:../uvc.c      **** {
1258:../uvc.c      **** 	uint32_t flag;
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1260:../uvc.c      **** 	{
1261:../uvc.c      ****         /* Clear the Video Stream Request Event */
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1263:../uvc.c      **** 
1264:../uvc.c      ****         /* Set Video Stream Abort Event */
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1266:../uvc.c      **** 	}
1267:../uvc.c      **** }
1268:../uvc.c      **** 
1269:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1270:../uvc.c      **** static void
1271:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1272:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1273:../uvc.c      ****         uint16_t             evdata  /* Event data */
1274:../uvc.c      ****         )
1275:../uvc.c      **** {
1276:../uvc.c      ****     switch (evtype)
1277:../uvc.c      ****     {
1278:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1279:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1280:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1281:../uvc.c      ****             gpif_initialized = 0;
1282:../uvc.c      ****             streamingStarted = CyFalse;
1283:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1284:../uvc.c      ****             break;
1285:../uvc.c      **** 
1286:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1287:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1288:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1289:../uvc.c      ****             gpif_initialized = 0;
1290:../uvc.c      ****             streamingStarted = CyFalse;
1291:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1292:../uvc.c      ****             break;
1293:../uvc.c      **** 
1294:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1295:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1296:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1297:../uvc.c      ****             gpif_initialized = 0;
1298:../uvc.c      ****             isUsbConnected = CyFalse;
1299:../uvc.c      ****             streamingStarted = CyFalse;
1300:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1301:../uvc.c      ****             break;
1302:../uvc.c      **** 
1303:../uvc.c      **** #ifdef BACKFLOW_DETECT
1304:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1305:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1306:../uvc.c      ****             break;
1307:../uvc.c      **** #endif
1308:../uvc.c      **** 
1309:../uvc.c      ****         default:
1310:../uvc.c      ****             break;
1311:../uvc.c      ****     }
1312:../uvc.c      **** }
1313:../uvc.c      **** 
1314:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1315:../uvc.c      **** static CyBool_t
1316:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1317:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1318:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1319:../uvc.c      ****         )
1320:../uvc.c      **** {
1321:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1322:../uvc.c      ****     uint32_t status;
1323:../uvc.c      **** 
1324:../uvc.c      ****     /* Obtain Request Type and Request */
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1330:../uvc.c      **** 
1331:../uvc.c      ****     /* Check for UVC Class Requests */
1332:../uvc.c      ****     switch (bmReqType)
1333:../uvc.c      ****     {
1334:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1335:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1336:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1337:../uvc.c      ****             switch (wIndex & 0xFF)
1338:../uvc.c      ****             {
1339:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1340:../uvc.c      ****                     {
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
1342:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1343:../uvc.c      ****                                 CYU3P_EVENT_OR);
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1345:../uvc.c      ****                         {
1346:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1347:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1348:../uvc.c      ****                         }
1349:../uvc.c      ****                     }
1350:../uvc.c      ****                     break;
1351:../uvc.c      **** 
1352:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1353:../uvc.c      ****                     {
1354:../uvc.c      ****                         uvcHandleReq = CyTrue;
1355:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1356:../uvc.c      ****                                 CYU3P_EVENT_OR);
1357:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1358:../uvc.c      ****                         {
1359:../uvc.c      ****                             /* Error handling */
1360:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1361:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1362:../uvc.c      ****                         }
1363:../uvc.c      ****                     }
1364:../uvc.c      ****                     break;
1365:../uvc.c      **** 
1366:../uvc.c      ****                 default:
1367:../uvc.c      ****                     break;
1368:../uvc.c      ****             }
1369:../uvc.c      ****             break;
1370:../uvc.c      **** 
1371:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1372:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1373:../uvc.c      ****             {
1374:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1375:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1377:../uvc.c      ****                 {
1378:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1379:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1380:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1381:../uvc.c      ****                     gpif_initialized = 0;
1382:../uvc.c      ****                     streamingStarted = CyFalse;
1383:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1385:../uvc.c      ****                     CyU3PBusyWait (100);
1386:../uvc.c      **** 
1387:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1388:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1389:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1390:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1391:../uvc.c      ****                     CyU3PBusyWait (100);
1392:../uvc.c      **** 
1393:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1394:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
1396:../uvc.c      ****                     /* Complete Control request handshake */
1397:../uvc.c      ****                     CyU3PUsbAckSetup ();
1398:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1399:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1400:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1401:../uvc.c      **** 
1402:../uvc.c      ****                 }
1403:../uvc.c      ****             }
1404:../uvc.c      ****             break;
1405:../uvc.c      **** 
1406:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1407:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1408:../uvc.c      ****             {
1409:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1410:../uvc.c      ****                 {
1411:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1412:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1413:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1414:../uvc.c      ****                 	 * has started. */
1415:../uvc.c      ****                     if (streamingStarted == CyTrue)
1416:../uvc.c      ****                     {
1417:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1418:../uvc.c      **** 
1419:../uvc.c      ****                         /* Disable the GPIF state machine. */
1420:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1421:../uvc.c      ****                         gpif_initialized = 0;
1422:../uvc.c      ****                         streamingStarted = CyFalse;
1423:../uvc.c      **** 
1424:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1426:../uvc.c      ****                         CyU3PBusyWait (100);
1427:../uvc.c      **** 
1428:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1429:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1430:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1431:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1432:../uvc.c      ****                         CyU3PBusyWait (100);
1433:../uvc.c      **** 
1434:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1435:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1436:../uvc.c      **** 
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
1438:../uvc.c      ****                         /* Complete Control request handshake */
1439:../uvc.c      ****                         CyU3PUsbAckSetup ();
1440:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1441:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1442:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1443:../uvc.c      ****                     }
1444:../uvc.c      ****                     else
1445:../uvc.c      ****                     {
1446:../uvc.c      ****                         uvcHandleReq = CyTrue;
1447:../uvc.c      ****                         CyU3PUsbAckSetup ();
1448:../uvc.c      ****                     }
1449:../uvc.c      ****                 }
1450:../uvc.c      ****             }
1451:../uvc.c      ****             break;
1452:../uvc.c      **** 
1453:../uvc.c      ****         default:
1454:../uvc.c      ****             break;
1455:../uvc.c      ****     }
1456:../uvc.c      **** 
1457:../uvc.c      ****     /* Return status of request handling to the USB driver */
1458:../uvc.c      ****     return uvcHandleReq;
1459:../uvc.c      **** }
1460:../uvc.c      **** 
1461:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1462:../uvc.c      **** 
1463:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1464:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1465:../uvc.c      ****  */
1466:../uvc.c      **** void
1467:../uvc.c      **** CyFxUvcApplnDmaCallback (
1468:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1469:../uvc.c      ****         CyU3PDmaCbType_t      type,
1470:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1471:../uvc.c      ****         )
1472:../uvc.c      **** {
1473:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1474:../uvc.c      **** #if 1
1475:../uvc.c      ****     CyU3PReturnStatus_t status;
1476:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1477:../uvc.c      ****     {
1478:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1479:../uvc.c      ****             {
1480:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1481:../uvc.c      ****                 fb++;
1482:../uvc.c      ****             }
1483:../uvc.c      ****             else
1484:../uvc.c      ****             {
1485:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1486:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1487:../uvc.c      ****                 pb++;
1488:../uvc.c      ****                 pbc = input->buffer_p.count;
1489:../uvc.c      ****                // hitFV = CyTrue;
1490:../uvc.c      ****             }
1491:../uvc.c      **** 
1492:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1493:../uvc.c      ****             prodCount++;
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1495:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1496:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1497:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1498:../uvc.c      ****             {
1499:../uvc.c      ****                 prodCount--;
1500:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1501:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1502:../uvc.c      ****             }
1503:../uvc.c      ****     }
1504:../uvc.c      **** #endif
1505:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1506:../uvc.c      ****     {
1507:../uvc.c      ****         consCount++;
1508:../uvc.c      ****         streamingStarted = CyTrue;
1509:../uvc.c      ****     }
1510:../uvc.c      **** }
1511:../uvc.c      **** 
1512:../uvc.c      **** /*
1513:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1514:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1515:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1516:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1517:../uvc.c      ****  * to commit the buffer.
1518:../uvc.c      ****  */
1519:../uvc.c      **** static uint8_t
1520:../uvc.c      **** CyFxUvcAppCommitEOF (
1521:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1522:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1523:../uvc.c      ****         )
1524:../uvc.c      **** {
1525:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1526:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1527:../uvc.c      **** 
1528:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1529:../uvc.c      **** 
1530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1531:../uvc.c      ****     {
1532:../uvc.c      ****         switch (stateId)
1533:../uvc.c      ****         {
1534:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1535:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1536:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1537:../uvc.c      ****                 break;
1538:../uvc.c      **** 
1539:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1540:../uvc.c      ****                 socket = 0;
1541:../uvc.c      ****                 break;
1542:../uvc.c      **** 
1543:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1544:../uvc.c      ****                 socket = 1;
1545:../uvc.c      ****                 break;
1546:../uvc.c      **** 
1547:../uvc.c      ****             default:
1548:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1549:../uvc.c      ****                 /* Unexpected current state. Return error. */
1550:../uvc.c      ****                 return 1;
1551:../uvc.c      ****         }
1552:../uvc.c      ****     }
1553:../uvc.c      **** 
1554:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1555:../uvc.c      ****     {
1556:../uvc.c      ****         switch (stateId)
1557:../uvc.c      ****         {
1558:../uvc.c      **** #ifndef CAM720
1559:../uvc.c      **** #ifdef GPIFIIM
1560:../uvc.c      ****             case 13:
1561:../uvc.c      ****             case 24:
1562:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1563:../uvc.c      ****                 break;
1564:../uvc.c      **** 
1565:../uvc.c      ****             case 8:
1566:../uvc.c      ****                 socket = 0;
1567:../uvc.c      ****                 break;
1568:../uvc.c      **** 
1569:../uvc.c      ****             case 20:
1570:../uvc.c      ****                 socket = 1;
1571:../uvc.c      ****                 break;
1572:../uvc.c      **** #else
1573:../uvc.c      ****             case 11:
1574:../uvc.c      ****             case 18:
1575:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1576:../uvc.c      ****                 break;
1577:../uvc.c      **** 
1578:../uvc.c      ****             case 8:
1579:../uvc.c      ****                 socket = 0;
1580:../uvc.c      ****                 break;
1581:../uvc.c      **** 
1582:../uvc.c      ****             case 15:
1583:../uvc.c      ****                 socket = 1;
1584:../uvc.c      ****                 break;
1585:../uvc.c      **** #endif
1586:../uvc.c      **** #else
1587:../uvc.c      ****             case 11:
1588:../uvc.c      ****             case 18:
1589:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1590:../uvc.c      ****                 break;
1591:../uvc.c      **** 
1592:../uvc.c      ****             case 8:
1593:../uvc.c      ****                 socket = 0;
1594:../uvc.c      ****                 break;
1595:../uvc.c      **** 
1596:../uvc.c      ****             case 15:
1597:../uvc.c      ****                 socket = 1;
1598:../uvc.c      ****                 break;
1599:../uvc.c      **** 
1600:../uvc.c      **** #endif
1601:../uvc.c      ****              default:
1602:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1603:../uvc.c      ****                 /* Unexpected current state. Return error. */
1604:../uvc.c      ****                return 1;
1605:../uvc.c      ****         }
1606:../uvc.c      ****     }
1607:../uvc.c      **** 
1608:../uvc.c      ****     if (socket != 0xFF)
1609:../uvc.c      ****     {
1610:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1611:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1612:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1613:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1614:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1615:../uvc.c      ****         {
1616:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1617:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1618:../uvc.c      ****         }
1619:../uvc.c      ****     }
1620:../uvc.c      **** 
1621:../uvc.c      ****     return 0;
1622:../uvc.c      **** }
1623:../uvc.c      **** 
1624:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1625:../uvc.c      **** void
1626:../uvc.c      **** CyFxGpifCB (
1627:../uvc.c      ****         CyU3PGpifEventType event,
1628:../uvc.c      ****         uint8_t currentState
1629:../uvc.c      ****         )
1630:../uvc.c      **** {
1631:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1632:../uvc.c      ****     {
1633:../uvc.c      ****         hitFV = CyTrue;
1634:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1635:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1636:../uvc.c      ****     }
1637:../uvc.c      **** }
1638:../uvc.c      **** 
1639:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1640:../uvc.c      **** static void
1641:../uvc.c      **** CyFxUVCApplnDebugInit (
1642:../uvc.c      ****         void)
1643:../uvc.c      **** {
1644:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1645:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1646:../uvc.c      **** 
1647:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1648:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1649:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1650:../uvc.c      ****     {
1651:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1652:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1653:../uvc.c      ****     }
1654:../uvc.c      **** 
1655:../uvc.c      ****     /* Set UART Configuration */
1656:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1657:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1658:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1659:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1660:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1661:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1662:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1663:../uvc.c      **** 
1664:../uvc.c      ****     /* Set the UART configuration */
1665:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1667:../uvc.c      ****     {
1668:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1669:../uvc.c      ****     }
1670:../uvc.c      **** 
1671:../uvc.c      ****     /* Set the UART transfer */
1672:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1673:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1674:../uvc.c      ****     {
1675:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1676:../uvc.c      ****     }
1677:../uvc.c      **** 
1678:../uvc.c      ****     /* Initialize the Debug logger module. */
1679:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1680:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1681:../uvc.c      ****     {
1682:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1683:../uvc.c      ****     }
1684:../uvc.c      **** 
1685:../uvc.c      ****     /* Disable log message headers. */
1686:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1687:../uvc.c      **** }
1688:../uvc.c      **** 
1689:../uvc.c      **** /* I2C initialization. */
1690:../uvc.c      **** //static void
1691:../uvc.c      **** void
1692:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1693:../uvc.c      **** {
1694:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1695:../uvc.c      ****     CyU3PReturnStatus_t status;
1696:../uvc.c      **** 
1697:../uvc.c      ****     status = CyU3PI2cInit ();
1698:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1699:../uvc.c      ****     {
1700:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1701:../uvc.c      ****         CyFxAppErrorHandler (status);
1702:../uvc.c      ****     }
1703:../uvc.c      **** 
1704:../uvc.c      ****     /*  Set I2C Configuration */
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1706:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1708:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1709:../uvc.c      **** 
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1711:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1712:../uvc.c      ****     {
1713:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1714:../uvc.c      ****         CyFxAppErrorHandler (status);
1715:../uvc.c      ****     }
1716:../uvc.c      **** }
1717:../uvc.c      **** 
1718:../uvc.c      **** #ifdef BACKFLOW_DETECT
1719:../uvc.c      **** static void CyFxUvcAppPibCallback (
1720:../uvc.c      ****         CyU3PPibIntrType cbType,
1721:../uvc.c      ****         uint16_t cbArg)
1722:../uvc.c      **** {
1723:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1724:../uvc.c      ****     {
1725:../uvc.c      ****         if (!back_flow_detected)
1726:../uvc.c      ****         {
1727:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1728:../uvc.c      ****             back_flow_detected = 1;
1729:../uvc.c      ****         }
1730:../uvc.c      ****     }
1731:../uvc.c      **** }
1732:../uvc.c      **** #endif
1733:../uvc.c      **** 
1734:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1735:../uvc.c      **** static void
1736:../uvc.c      **** CyFxUvcAppDebugCallback (
1737:../uvc.c      ****         CyU3PDmaChannel   *handle,
1738:../uvc.c      ****         CyU3PDmaCbType_t   type,
1739:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1740:../uvc.c      **** {
1741:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1742:../uvc.c      ****     {
1743:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1744:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1745:../uvc.c      ****     }
1746:../uvc.c      **** }
1747:../uvc.c      **** #endif
1748:../uvc.c      **** 
1749:../uvc.c      **** #if 0
1750:../uvc.c      **** static void CyFxAppIntEpCb(
1751:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1752:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1753:../uvc.c      **** 		uint8_t  ebNum)
1754:../uvc.c      **** 		{
1755:../uvc.c      **** 			//CyBool_t value;
1756:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1757:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1758:../uvc.c      **** 
1759:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1760:../uvc.c      **** 		}
1761:../uvc.c      **** #endif
1762:../uvc.c      **** 
1763:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1764:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1765:../uvc.c      ****    configures the DMA module for the UVC Application */
1766:../uvc.c      **** static void
1767:../uvc.c      **** CyFxUVCApplnInit (void)
1768:../uvc.c      **** {
1769:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1770:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1771:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1772:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1773:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1774:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1775:../uvc.c      **** 
1776:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1777:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1778:../uvc.c      **** 
1779:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1780:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1781:../uvc.c      **** #endif
1782:../uvc.c      **** 
1783:../uvc.c      ****     /* Create UVC event group */
1784:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1785:../uvc.c      ****     if (apiRetStatus != 0)
1786:../uvc.c      ****     {
1787:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1788:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1789:../uvc.c      ****     }
1790:../uvc.c      **** 
1791:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1792:../uvc.c      ****     CyFxUvcAppPTZInit ();
1793:../uvc.c      **** #endif
1794:../uvc.c      **** 
1795:../uvc.c      ****     isUsbConnected = CyFalse;
1796:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1797:../uvc.c      **** 
1798:../uvc.c      ****     /* Init the GPIO module */
1799:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1800:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1801:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1802:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1803:../uvc.c      ****     gpioClock.halfDiv    = 0;
1804:../uvc.c      **** 
1805:../uvc.c      ****     /* Initialize Gpio interface */
1806:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1807:../uvc.c      ****     if (apiRetStatus != 0)
1808:../uvc.c      ****     {
1809:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1810:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1811:../uvc.c      ****     }
1812:../uvc.c      **** 
1813:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1814:../uvc.c      ****      * must use GpioOverride to configure it */
1815:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1816:../uvc.c      ****     if (apiRetStatus != 0)
1817:../uvc.c      ****     {
1818:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1819:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1820:../uvc.c      ****     }
1821:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1822:../uvc.c      ****     if (apiRetStatus != 0)
1823:../uvc.c      ****     {
1824:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1825:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1826:../uvc.c      ****     }
1827:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1828:../uvc.c      ****     if (apiRetStatus != 0)
1829:../uvc.c      ****     {
1830:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1831:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1832:../uvc.c      ****     }
1833:../uvc.c      **** 
1834:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1836:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1837:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1838:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1839:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1841:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1842:../uvc.c      ****     {
1843:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1844:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1845:../uvc.c      ****     }
1846:../uvc.c      **** 
1847:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1848:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1849:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1852:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1856:../uvc.c      ****     {
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1858:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1859:../uvc.c      ****     }
1860:../uvc.c      **** 
1861:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1862:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1863:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1864:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1865:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1866:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1867:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1870:../uvc.c      ****     {
1871:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1872:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1873:../uvc.c      ****     }
1874:../uvc.c      **** 
1875:../uvc.c      ****     /* Initialize the P-port. */
1876:../uvc.c      ****     pibclock.clkDiv      = 2;
1877:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1878:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1879:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1880:../uvc.c      **** 
1881:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1882:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1883:../uvc.c      ****     {
1884:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1885:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1886:../uvc.c      ****     }
1887:../uvc.c      **** 
1888:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1889:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1890:../uvc.c      **** 
1891:../uvc.c      **** #ifdef BACKFLOW_DETECT
1892:../uvc.c      ****     back_flow_detected = 0;
1893:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1894:../uvc.c      **** #endif
1895:../uvc.c      **** 
1896:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1897:../uvc.c      ****     SensorReset ();
1898:../uvc.c      ****     SensorInit ();
1899:../uvc.c      **** 
1900:../uvc.c      ****     /* USB initialization. */
1901:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1902:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1903:../uvc.c      ****     {
1904:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1905:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1906:../uvc.c      ****     }
1907:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1908:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1909:../uvc.c      **** 
1910:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1911:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1912:../uvc.c      **** 
1913:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1914:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1915:../uvc.c      **** 
1916:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1917:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1918:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1919:../uvc.c      **** 
1920:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1921:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1922:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1923:../uvc.c      **** 
1924:../uvc.c      ****     /* Configuration descriptors. */
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1926:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1927:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1928:../uvc.c      **** 
1929:../uvc.c      ****     /* String Descriptors */
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1931:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1933:../uvc.c      **** 
1934:../uvc.c      ****     /* Configure the status interrupt endpoint.
1935:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1936:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1937:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1938:../uvc.c      ****      */
1939:../uvc.c      ****     endPointConfig.enable   = 1;
1940:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1941:../uvc.c      ****     endPointConfig.pcktSize = 64;
1942:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1943:../uvc.c      ****     endPointConfig.streams  = 0;
1944:../uvc.c      ****     endPointConfig.burstLen = 1;
1945:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1947:../uvc.c      ****     {
1948:../uvc.c      ****         /* Error Handling */
1949:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1950:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1951:../uvc.c      ****     }
1952:../uvc.c      **** 
1953:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1954:../uvc.c      ****     dmaInterConfig.size           = 1024;
1955:../uvc.c      ****     dmaInterConfig.count          = 1;
1956:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1957:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1958:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1959:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1960:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1961:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1962:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1963:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1964:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1965:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1966:../uvc.c      ****             &dmaInterConfig);
1967:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1968:../uvc.c      ****     {
1969:../uvc.c      ****         /* Error handling */
1970:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1971:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1972:../uvc.c      ****     }
1973:../uvc.c      **** 
1974:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1975:../uvc.c      ****     if (glInterStaBuffer == 0)
1976:../uvc.c      ****     {
1977:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1978:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1979:../uvc.c      ****     }
1980:../uvc.c      **** 
1981:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1982:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1983:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1984:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1985:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1986:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1987:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1988:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1989:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1990:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
1991:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1992:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1993:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1994:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
1996:../uvc.c      ****             &dmaMultiConfig);
1997:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1998:../uvc.c      ****     {
1999:../uvc.c      ****         /* Error handling */
2000:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2001:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2002:../uvc.c      ****     }
2003:../uvc.c      **** 
2004:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2005:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2006:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2007:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2008:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2009:../uvc.c      ****      */
2010:../uvc.c      **** 
2011:../uvc.c      ****     endPointConfig.enable   = 1;
2012:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2013:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2014:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2015:../uvc.c      ****     endPointConfig.streams  = 0;
2016:../uvc.c      ****     endPointConfig.burstLen = 1;
2017:../uvc.c      **** 
2018:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2019:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2020:../uvc.c      ****     {
2021:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2022:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2023:../uvc.c      ****     }
2024:../uvc.c      **** 
2025:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2026:../uvc.c      **** 
2027:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2029:../uvc.c      ****     {
2030:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2031:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2032:../uvc.c      ****     }
2033:../uvc.c      **** 
2034:../uvc.c      ****     channelConfig.size           = 1024;
2035:../uvc.c      ****     channelConfig.count          = 1;
2036:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2037:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2038:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2039:../uvc.c      ****     channelConfig.prodHeader     = 0;
2040:../uvc.c      ****     channelConfig.prodFooter     = 0;
2041:../uvc.c      ****     channelConfig.consHeader     = 0;
2042:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2043:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2044:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2045:../uvc.c      **** 
2046:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2047:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2048:../uvc.c      ****     {
2049:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2050:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2051:../uvc.c      ****     }
2052:../uvc.c      **** 
2053:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2054:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2055:../uvc.c      ****     {
2056:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2057:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2058:../uvc.c      ****     }
2059:../uvc.c      **** 
2060:../uvc.c      ****     channelConfig.size           = 1024;
2061:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2062:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2063:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2064:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2065:../uvc.c      ****     channelConfig.prodHeader     = 0;
2066:../uvc.c      ****     channelConfig.prodFooter     = 0;
2067:../uvc.c      ****     channelConfig.consHeader     = 0;
2068:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2069:../uvc.c      ****     channelConfig.notification   = 0;
2070:../uvc.c      ****     channelConfig.cb             = 0;
2071:../uvc.c      **** 
2072:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2073:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2074:../uvc.c      ****     {
2075:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2076:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2077:../uvc.c      ****     }
2078:../uvc.c      **** 
2079:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2080:../uvc.c      ****     if (glDebugRspBuffer == 0)
2081:../uvc.c      ****     {
2082:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2083:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2084:../uvc.c      ****     }
2085:../uvc.c      **** #endif
2086:../uvc.c      **** 
2087:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2088:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2089:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2090:../uvc.c      ****     {
2091:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2092:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2093:../uvc.c      ****     }
2094:../uvc.c      **** 
2095:../uvc.c      ****     CyU3PBusyWait(100);
2096:../uvc.c      **** 
2097:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2098:../uvc.c      **** 
2099:../uvc.c      ****     endPointConfig.enable   = 1;
2100:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2101:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2102:../uvc.c      ****     {
2103:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2104:../uvc.c      ****     	endPointConfig.burstLen = 16;
2105:../uvc.c      ****     }
2106:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2107:../uvc.c      ****     {
2108:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2109:../uvc.c      ****     	endPointConfig.burstLen = 1;
2110:../uvc.c      ****     }
2111:../uvc.c      ****     endPointConfig.streams  = 0;
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2113:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2114:../uvc.c      ****     {
2115:../uvc.c      ****         /* Error Handling */
2116:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2117:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2118:../uvc.c      ****     }
2119:../uvc.c      **** #if 0    //for still image method 3 using
2120:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2121:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2122:../uvc.c      ****     {
2123:../uvc.c      ****         /* Error Handling */
2124:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2125:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2126:../uvc.c      ****     }
2127:../uvc.c      **** #endif
2128:../uvc.c      **** 
2129:../uvc.c      **** }
2130:../uvc.c      **** 
2131:../uvc.c      **** /*
2132:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2133:../uvc.c      ****  * streaming session is started.
2134:../uvc.c      ****  */
2135:../uvc.c      **** static void
2136:../uvc.c      **** CyFxUvcAppGpifInit (
2137:../uvc.c      ****         void)
2138:../uvc.c      **** {
2139:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2140:../uvc.c      **** 
2141:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2142:../uvc.c      ****     {
2143:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2144:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2145:../uvc.c      ****     }
2146:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2147:../uvc.c      ****     {
2148:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2149:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2150:../uvc.c      ****     }
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2152:../uvc.c      ****     {
2153:../uvc.c      ****         /* Error Handling */
2154:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2155:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2156:../uvc.c      ****     }
2157:../uvc.c      **** 
2158:../uvc.c      ****     /* Start the state machine from the designated start state. */
2159:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2160:../uvc.c      ****     {
2161:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2162:../uvc.c      ****     }
2163:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2164:../uvc.c      ****     {
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2166:../uvc.c      ****     }
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2168:../uvc.c      ****     {
2169:../uvc.c      ****         /* Error Handling */
2170:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2171:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2172:../uvc.c      ****     }
2173:../uvc.c      **** }
2174:../uvc.c      **** 
2175:../uvc.c      **** /*
2176:../uvc.c      ****  * Entry function for the UVC Application Thread
2177:../uvc.c      ****  */
2178:../uvc.c      **** 
2179:../uvc.c      **** uint32_t posTick;
2180:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2181:../uvc.c      **** 
2182:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2183:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2184:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2185:../uvc.c      **** }
2186:../uvc.c      **** 
2187:../uvc.c      **** 
2188:../uvc.c      **** void
2189:../uvc.c      **** UVCAppThread_Entry (
2190:../uvc.c      ****         uint32_t input)
2191:../uvc.c      **** {
2192:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2193:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2194:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2195:../uvc.c      ****     uint8_t i = 0;
2196:../uvc.c      ****     uint32_t flag;
2197:../uvc.c      ****     uint32_t prinflag = 0;
2198:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2199:../uvc.c      ****     uint32_t frameCnt = 0;
2200:../uvc.c      **** #endif
2201:../uvc.c      ****     /* Initialize the Uart Debug Module */
2202:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2203:../uvc.c      **** 
2204:../uvc.c      ****     /* Initialize the I2C interface */
2205:../uvc.c      **** 	while (i++ < 6){
2206:../uvc.c      **** 		CyU3PThreadSleep(500);
2207:../uvc.c      **** 	}
2208:../uvc.c      **** 
2209:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2210:../uvc.c      **** 
2211:../uvc.c      ****     /* Initialize the UVC Application */
2212:../uvc.c      ****     CyFxUVCApplnInit ();
2213:../uvc.c      **** 
2214:../uvc.c      ****     /*
2215:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2216:../uvc.c      **** 
2217:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2218:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2219:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2220:../uvc.c      **** 
2221:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2222:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2223:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2224:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2225:../uvc.c      **** 
2226:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2227:../uvc.c      ****        of handling the abort request.
2228:../uvc.c      ****      */
2229:../uvc.c      **** 
2230:../uvc.c      ****     for (;;)
2231:../uvc.c      ****     {
2232:../uvc.c      ****         /* Waiting for the Video Stream Event */
2233:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2234:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2235:../uvc.c      ****         {
2236:../uvc.c      **** #if 0 //test for new firmware no video bring up
2237:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2238:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2239:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2240:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2241:../uvc.c      ****             {
2242:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2243:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2244:../uvc.c      ****                 {
2245:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2246:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2247:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2248:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2249:../uvc.c      **** #endif
2250:../uvc.c      **** #endif
2251:../uvc.c      ****                     }
2252:../uvc.c      ****                 else
2253:../uvc.c      ****                 {
2254:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2255:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2256:../uvc.c      **** #ifdef USB_LOWRES_IMG
2257:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2258:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2259:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2260:../uvc.c      **** #endif
2261:../uvc.c      **** #endif
2262:../uvc.c      ****                 }
2263:../uvc.c      **** 
2264:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2265:../uvc.c      ****                 prodCount++;
2266:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2267:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2268:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2269:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2270:../uvc.c      ****                 {
2271:../uvc.c      ****                     prodCount--;
2272:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2273:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2274:../uvc.c      ****                 }
2275:../uvc.c      ****             }
2276:../uvc.c      **** #endif
2277:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2278:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2279:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2280:../uvc.c      ****             {
2281:../uvc.c      ****             	if(0&&(prinflag == 0)){
2282:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2283:../uvc.c      ****             		prinflag = 1;
2284:../uvc.c      ****             	}
2285:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2286:../uvc.c      ****             	fb=0;
2287:../uvc.c      ****             	pb=0;
2288:../uvc.c      ****             	pbc=0;
2289:../uvc.c      ****                 prodCount = 0;
2290:../uvc.c      ****                 consCount = 0;
2291:../uvc.c      ****                 hitFV     = CyFalse;
2292:../uvc.c      **** 
2293:../uvc.c      **** #ifdef BACKFLOW_DETECT
2294:../uvc.c      ****                 back_flow_detected = 0;
2295:../uvc.c      **** #endif
2296:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2297:../uvc.c      ****                 frameCnt++;
2298:../uvc.c      **** #endif
2299:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2300:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2301:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2302:../uvc.c      ****                 //}
2303:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2305:../uvc.c      ****                 if(stiflag){
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
2307:../uvc.c      ****                 	stiflag = CyFalse;
2308:../uvc.c      ****                 }else{
2309:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2310:../uvc.c      ****                 }
2311:../uvc.c      ****                 /* Reset the DMA channel. */
2312:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2313:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2314:../uvc.c      ****                 {
2315:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2316:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2317:../uvc.c      ****                 }
2318:../uvc.c      **** 
2319:../uvc.c      ****                 /* Start Channel Immediately */
2320:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2321:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2322:../uvc.c      ****                 {
2323:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2324:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2325:../uvc.c      ****                 }
2326:../uvc.c      **** 
2327:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2328:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2329:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2330:../uvc.c      ****                 }
2331:../uvc.c      ****         }
2332:../uvc.c      ****         else
2333:../uvc.c      ****         {
2334:../uvc.c      ****             /* If we have a stream abort request pending. */
2335:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2336:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2337:../uvc.c      ****             {
2338:../uvc.c      ****                 hitFV     = CyFalse;
2339:../uvc.c      ****                 prodCount = 0;
2340:../uvc.c      ****                 consCount = 0;
2341:../uvc.c      ****                 if(0&&(prinflag == 0)){
2342:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2343:../uvc.c      ****                 	prinflag = 1;
2344:../uvc.c      ****                 }
2345:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2346:../uvc.c      ****                 fb=0;
2347:../uvc.c      ****                 pb=0;
2348:../uvc.c      ****                 pbc=0;
2349:../uvc.c      **** 
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2351:../uvc.c      ****                 {
2352:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2353:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2354:../uvc.c      ****                     {
2355:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2356:../uvc.c      ****                     }
2357:../uvc.c      **** 
2358:../uvc.c      ****                     /* Flush the Endpoint memory */
2359:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2360:../uvc.c      ****                 }
2361:../uvc.c      **** 
2362:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2363:../uvc.c      ****             }
2364:../uvc.c      ****             else
2365:../uvc.c      ****             {
2366:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2367:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2368:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2369:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2370:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2371:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2372:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2373:../uvc.c      ****                 {
2374:../uvc.c      ****                     /* Error handling */
2375:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2376:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2377:../uvc.c      ****                 }
2378:../uvc.c      **** 
2379:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2380:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2381:../uvc.c      ****                 {
2382:../uvc.c      ****                     //for start up of the AF Lens
2383:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
2385:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2386:../uvc.c      ****                     CyU3PThreadSleep(500);
2387:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2388:../uvc.c      ****                    	CyU3PThreadSleep(300);
2389:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
2391:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2392:../uvc.c      ****                     CyU3PThreadSleep(500);
2393:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2394:../uvc.c      ****                     gpif_initialized = CyTrue;
2395:../uvc.c      ****                     CyU3PThreadSleep(200);
2396:../uvc.c      ****                     
2397:../uvc.c      ****                 }
2398:../uvc.c      ****                 else
2399:../uvc.c      ****                 {
2400:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2401:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2402:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2403:../uvc.c      ****                 }
2404:../uvc.c      ****             }
2405:../uvc.c      ****         }
2406:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2407:../uvc.c      **** 
2408:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2409:../uvc.c      ****         CyU3PThreadRelinquish ();
2410:../uvc.c      ****     }
2411:../uvc.c      **** }
2412:../uvc.c      **** 
2413:../uvc.c      **** /*
2414:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2415:../uvc.c      ****  */
2416:../uvc.c      **** 
2417:../uvc.c      **** static void
2418:../uvc.c      **** UVCHandleProcessingUnitRqts (
2419:../uvc.c      ****         void)
2420:../uvc.c      **** {
2421:../uvc.c      ****     uint8_t CtrlAdd;
2422:../uvc.c      **** #ifdef DbgInfo
2423:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2424:../uvc.c      **** #endif
2425:../uvc.c      ****     switch (wValue)
2426:../uvc.c      ****     {
2427:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2428:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2429:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2430:../uvc.c      ****     		break;
2431:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2432:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2433:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2434:../uvc.c      ****     		break;
2435:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2436:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2437:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2438:../uvc.c      **** 			break;
2439:../uvc.c      **** 
2440:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2441:../uvc.c      **** 
2442:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2443:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2444:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2445:../uvc.c      ****       		break;
2446:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2447:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2448:../uvc.c      ****      		ControlHandle(HueCtlID5);
2449:../uvc.c      ****      		break;
2450:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2451:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2452:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2453:../uvc.c      ****           		break;
2454:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2455:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2456:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2457:../uvc.c      ****           		break;
2458:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2459:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2460:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2461:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2462:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2463:../uvc.c      ****     		break;
2464:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2465:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2466:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2467:../uvc.c      ****     		break;
2468:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2469:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2470:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2471:../uvc.c      ****     		break;
2472:../uvc.c      **** 
2473:../uvc.c      ****         default:
2474:../uvc.c      ****             /*
2475:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2476:../uvc.c      ****              * other controls.
2477:../uvc.c      ****              */
2478:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2479:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2480:../uvc.c      ****             break;
2481:../uvc.c      ****     }
2482:../uvc.c      **** }
2483:../uvc.c      **** 
2484:../uvc.c      **** /*
2485:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2486:../uvc.c      ****  */
2487:../uvc.c      **** static void
2488:../uvc.c      **** UVCHandleCameraTerminalRqts (
2489:../uvc.c      ****         void)
2490:../uvc.c      **** {
2491:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2492:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2493:../uvc.c      ****     uint16_t readCount;
2494:../uvc.c      ****     uint16_t zoomVal;
2495:../uvc.c      ****     int32_t  panVal, tiltVal;
2496:../uvc.c      ****     CyBool_t sendData = CyFalse;
2497:../uvc.c      **** #endif
2498:../uvc.c      ****     uint8_t CtrlAdd;
2499:../uvc.c      **** 
2500:../uvc.c      ****     switch (wValue)
2501:../uvc.c      ****     {
2502:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2503:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2504:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2505:../uvc.c      ****     		break;
2506:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2507:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2508:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2509:../uvc.c      ****     		break;
2510:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2511:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2512:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2513:../uvc.c      **** 			break;
2514:../uvc.c      **** 
2515:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2516:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2517:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2518:../uvc.c      **** 			break;
2519:../uvc.c      **** 
2520:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2521:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2522:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2523:../uvc.c      ****       		break;
2524:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2525:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2526:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2527:../uvc.c      ****      		break;
2528:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2529:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2530:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2531:../uvc.c      ****           		break;
2532:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2533:../uvc.c      ****           		break;
2534:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2535:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2536:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2537:../uvc.c      ****      		break;
2538:../uvc.c      **** 
2539:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2540:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2541:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2542:../uvc.c      ****     		break;
2543:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2544:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2545:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2546:../uvc.c      ****     		break;
2547:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2548:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2549:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2550:../uvc.c      ****     		break;
2551:../uvc.c      **** 
2552:../uvc.c      ****         default:
2553:../uvc.c      ****             /*
2554:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2555:../uvc.c      ****              * other controls.
2556:../uvc.c      ****              */
2557:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2558:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2559:../uvc.c      ****             break;
2560:../uvc.c      ****     }
2561:../uvc.c      **** 
2562:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2563:../uvc.c      ****     switch (wValue)
2564:../uvc.c      ****     {
2565:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2566:../uvc.c      ****             switch (bRequest)
2567:../uvc.c      ****             {
2568:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2569:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2570:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2571:../uvc.c      ****                     break;
2572:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2573:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2574:../uvc.c      ****                     sendData = CyTrue;
2575:../uvc.c      ****                     break;
2576:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2577:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2578:../uvc.c      ****                     sendData = CyTrue;
2579:../uvc.c      ****                     break;
2580:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2581:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2582:../uvc.c      ****                     sendData = CyTrue;
2583:../uvc.c      ****                     break;
2584:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2585:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2586:../uvc.c      ****                     sendData = CyTrue;
2587:../uvc.c      ****                     break;
2588:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2589:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2590:../uvc.c      ****                     sendData = CyTrue;
2591:../uvc.c      ****                     break;
2592:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2593:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2594:../uvc.c      ****                             glEp0Buffer, &readCount);
2595:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2596:../uvc.c      ****                     {
2597:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2598:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2599:../uvc.c      ****                     }
2600:../uvc.c      ****                     break;
2601:../uvc.c      ****                 default:
2602:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2603:../uvc.c      ****                     break;
2604:../uvc.c      ****             }
2605:../uvc.c      **** 
2606:../uvc.c      ****             if (sendData)
2607:../uvc.c      ****             {
2608:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2609:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2610:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2611:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2612:../uvc.c      ****             }
2613:../uvc.c      ****             break;
2614:../uvc.c      **** 
2615:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2616:../uvc.c      ****             switch (bRequest)
2617:../uvc.c      ****             {
2618:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2619:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2620:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2621:../uvc.c      ****                     break;
2622:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2623:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2624:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2625:../uvc.c      ****                     sendData = CyTrue;
2626:../uvc.c      ****                     break;
2627:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2628:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2629:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2630:../uvc.c      ****                     sendData = CyTrue;
2631:../uvc.c      ****                     break;
2632:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2633:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2634:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2635:../uvc.c      ****                     sendData = CyTrue;
2636:../uvc.c      ****                     break;
2637:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2638:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2639:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2640:../uvc.c      ****                     sendData = CyTrue;
2641:../uvc.c      ****                     break;
2642:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2643:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2644:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2645:../uvc.c      ****                     sendData = CyTrue;
2646:../uvc.c      ****                     break;
2647:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2648:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2649:../uvc.c      ****                             glEp0Buffer, &readCount);
2650:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2651:../uvc.c      ****                     {
2652:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2653:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2654:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2655:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2656:../uvc.c      **** 
2657:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2658:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2659:../uvc.c      ****                     }
2660:../uvc.c      ****                     break;
2661:../uvc.c      ****                 default:
2662:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2663:../uvc.c      ****                     break;
2664:../uvc.c      ****             }
2665:../uvc.c      **** 
2666:../uvc.c      ****             if (sendData)
2667:../uvc.c      ****             {
2668:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2669:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2670:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2671:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2672:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2673:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2674:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2675:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2676:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2677:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2678:../uvc.c      ****             }
2679:../uvc.c      ****             break;
2680:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2681:../uvc.c      ****         default:
2682:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2683:../uvc.c      ****             break;
2684:../uvc.c      ****     }
2685:../uvc.c      **** #endif
2686:../uvc.c      **** }
2687:../uvc.c      **** 
2688:../uvc.c      **** /*
2689:../uvc.c      ****  * Handler for UVC Interface control requests.
2690:../uvc.c      ****  */
2691:../uvc.c      **** static void
2692:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2693:../uvc.c      ****         void)
2694:../uvc.c      **** {
2695:../uvc.c      **** 
2696:../uvc.c      ****     switch (wValue)
2697:../uvc.c      ****     {
2698:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2699:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2700:../uvc.c      ****     		break;
2701:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2702:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2703:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2704:../uvc.c      ****     		break;
2705:../uvc.c      ****     	default:
2706:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2707:../uvc.c      ****      		break;
2708:../uvc.c      ****     }
2709:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2710:../uvc.c      **** 
2711:../uvc.c      **** }
2712:../uvc.c      **** 
2713:../uvc.c      **** /*
2714:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2715:../uvc.c      ****  */
2716:../uvc.c      **** static void
2717:../uvc.c      **** UVCHandleExtensionUnitRqts (
2718:../uvc.c      ****         void)
2719:../uvc.c      **** {
2720:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2721:../uvc.c      **** 
2722:../uvc.c      **** #ifdef DbgInfo
2723:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2724:../uvc.c      **** #endif
2725:../uvc.c      ****     switch (wValue)
2726:../uvc.c      ****     {
2727:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2728:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2729:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2730:../uvc.c      ****     		break;
2731:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2732:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2733:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2734:../uvc.c      ****     		break;
2735:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2736:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2737:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2738:../uvc.c      ****      		break;
2739:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2740:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2741:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2742:../uvc.c      ****     		break;
2743:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2744:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2745:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2746:../uvc.c      ****     		break;
2747:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2748:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2749:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2750:../uvc.c      ****      		break;
2751:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2752:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2753:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2754:../uvc.c      ****     		break;
2755:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2756:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2757:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2758:../uvc.c      ****     		break;
2759:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2760:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2761:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2762:../uvc.c      ****      		break;
2763:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2764:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2765:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2766:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2767:../uvc.c      ****     		}else/* no support for 1080p camera */
2768:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2769:../uvc.c      ****     		break;
2770:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2771:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2772:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2773:../uvc.c      ****     		break;
2774:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2775:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2776:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2777:../uvc.c      ****     		break;
2778:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2779:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2780:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2781:../uvc.c      ****     		//break;
2782:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2783:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2784:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2785:../uvc.c      ****     		break;
2786:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2787:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2788:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2789:../uvc.c      ****     		break;
2790:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2791:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2792:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2793:../uvc.c      ****     		break;
2794:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2795:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2796:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2797:../uvc.c      ****     		break;
2798:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2799:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2800:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2801:../uvc.c      ****     		break;
2802:../uvc.c      ****    	default:
2803:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2804:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2805:../uvc.c      ****     		break;
2806:../uvc.c      ****     }
2807:../uvc.c      **** 
2808:../uvc.c      **** }
2809:../uvc.c      **** 
2810:../uvc.c      **** /*
2811:../uvc.c      ****  * Handler for the video streaming control requests.
2812:../uvc.c      ****  */
2813:../uvc.c      **** static void
2814:../uvc.c      **** UVCHandleVideoStreamingRqts (
2815:../uvc.c      ****         void)
2816:../uvc.c      **** {
2817:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2818:../uvc.c      ****     uint16_t readCount;
2819:../uvc.c      **** 
2820:../uvc.c      ****     switch (wValue)
2821:../uvc.c      ****     {
2822:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2823:../uvc.c      ****             switch (bRequest)
2824:../uvc.c      ****             {
2825:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2826:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2827:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2828:../uvc.c      ****                     break;
2829:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2830:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2831:../uvc.c      ****                     glEp0Buffer[1] = 0;
2832:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2833:../uvc.c      ****                     break;
2834:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2835:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2836:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2837:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2838:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2839:../uvc.c      ****                     {
2840:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2841:../uvc.c      ****                     }
2842:../uvc.c      ****                     else
2843:../uvc.c      ****                     {
2844:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2845:../uvc.c      ****                     }
2846:../uvc.c      ****                     break;
2847:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2848:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2849:../uvc.c      ****                             glCommitCtrl, &readCount);
2850:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2851:../uvc.c      ****                     {
2852:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2853:../uvc.c      ****                         {
2854:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2855:../uvc.c      ****                                active data structure. */
2856:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2857:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2858:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2859:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2860:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2861:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2862:../uvc.c      ****                         }
2863:../uvc.c      ****                     }
2864:../uvc.c      ****                     break;
2865:../uvc.c      ****                 default:
2866:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2867:../uvc.c      ****                     break;
2868:../uvc.c      ****             }
2869:../uvc.c      ****             break;
2870:../uvc.c      **** 
2871:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2872:../uvc.c      ****             switch (bRequest)
2873:../uvc.c      ****             {
2874:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2875:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2877:../uvc.c      ****                     break;
2878:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2879:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2880:../uvc.c      ****                     glEp0Buffer[1] = 0;
2881:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2882:../uvc.c      ****                     break;
2883:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2884:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2885:../uvc.c      ****                     {
2886:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2887:../uvc.c      ****                     }
2888:../uvc.c      ****                     else
2889:../uvc.c      ****                     {
2890:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2891:../uvc.c      ****                     }
2892:../uvc.c      ****                     break;
2893:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2894:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2895:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2896:../uvc.c      ****                        */
2897:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2898:../uvc.c      ****                             glCommitCtrl, &readCount);
2899:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2900:../uvc.c      ****                     {
2901:../uvc.c      **** #if 0
2902:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2903:../uvc.c      ****                         {
2904:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2905:../uvc.c      ****                         }
2906:../uvc.c      ****                         else
2907:../uvc.c      ****                         {
2908:../uvc.c      ****                             SensorScaling_VGA ();
2909:../uvc.c      ****                         }
2910:../uvc.c      **** #endif
2911:../uvc.c      ****                         /* We can start streaming video now. */
2912:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2913:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2914:../uvc.c      ****                         {
2915:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2916:../uvc.c      ****                         }
2917:../uvc.c      ****                     }
2918:../uvc.c      ****                     break;
2919:../uvc.c      **** 
2920:../uvc.c      ****                 default:
2921:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2922:../uvc.c      ****                     break;
2923:../uvc.c      ****             }
2924:../uvc.c      ****             break;
2925:../uvc.c      **** 
2926:../uvc.c      **** /* still image streaming handler */
2927:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2928:../uvc.c      ****                 switch (bRequest)
2929:../uvc.c      ****                 {
2930:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2931:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2932:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2933:../uvc.c      ****                         break;
2934:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2935:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2936:../uvc.c      ****                         glEp0Buffer[1] = 0;
2937:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2938:../uvc.c      ****                         break;
2939:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2940:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2941:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2942:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2943:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2944:../uvc.c      ****                         {
2945:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2946:../uvc.c      ****                         }
2947:../uvc.c      ****                         else
2948:../uvc.c      ****                         {
2949:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2950:../uvc.c      ****                         }
2951:../uvc.c      ****                         break;
2952:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2953:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2954:../uvc.c      ****                                 glCommitCtrl, &readCount);
2955:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2956:../uvc.c      ****                         {
2957:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
2958:../uvc.c      ****                             {
2959:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2960:../uvc.c      ****                                    active data structure. */
2961:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
2962:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
2963:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
2964:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
2965:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
2967:../uvc.c      ****                             }
2968:../uvc.c      ****                         }
2969:../uvc.c      ****                         break;
2970:../uvc.c      ****                     default:
2971:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2972:../uvc.c      ****                         break;
2973:../uvc.c      ****                 }
2974:../uvc.c      ****                 break;
2975:../uvc.c      **** 
2976:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
2977:../uvc.c      ****                 switch (bRequest)
2978:../uvc.c      ****                 {
2979:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2980:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2981:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2982:../uvc.c      ****                         break;
2983:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2984:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2985:../uvc.c      ****                         glEp0Buffer[1] = 0;
2986:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2987:../uvc.c      ****                         break;
2988:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2989:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2990:../uvc.c      ****                         {
2991:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2992:../uvc.c      ****                         }
2993:../uvc.c      ****                         else
2994:../uvc.c      ****                         {
2995:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2996:../uvc.c      ****                         }
2997:../uvc.c      ****                         break;
2998:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2999:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3000:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3001:../uvc.c      ****                            */
3002:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3003:../uvc.c      ****                                 glCommitCtrl, &readCount);
3004:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3005:../uvc.c      ****                         {
3006:../uvc.c      ****     #if 0
3007:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3008:../uvc.c      ****                             {
3009:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3010:../uvc.c      ****                             }
3011:../uvc.c      ****                             else
3012:../uvc.c      ****                             {
3013:../uvc.c      ****                                 SensorScaling_VGA ();
3014:../uvc.c      ****                             }
3015:../uvc.c      ****     #endif
3016:../uvc.c      ****                             /* We can start streaming video now. */
3017:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3018:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3019:../uvc.c      ****                             {
3020:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3021:../uvc.c      ****                             }
3022:../uvc.c      ****                         }
3023:../uvc.c      ****                         break;
3024:../uvc.c      **** 
3025:../uvc.c      ****                     default:
3026:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3027:../uvc.c      ****                         break;
3028:../uvc.c      ****                 }
3029:../uvc.c      ****                 break;
3030:../uvc.c      **** 
3031:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3032:../uvc.c      ****                 switch (bRequest)
3033:../uvc.c      ****                 {
3034:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3035:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3036:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3037:../uvc.c      ****                         break;
3038:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3039:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3040:../uvc.c      ****                         glEp0Buffer[1] = 0;
3041:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3042:../uvc.c      ****                         break;
3043:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3044:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3045:../uvc.c      ****                         {
3046:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3047:../uvc.c      ****                         }
3048:../uvc.c      ****                         else
3049:../uvc.c      ****                         {
3050:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3051:../uvc.c      ****                         }
3052:../uvc.c      ****                         break;
3053:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3054:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3055:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3056:../uvc.c      ****                            */
3057:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3058:../uvc.c      ****                                 glCommitCtrl, &readCount);
3059:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3060:../uvc.c      ****                         {
3061:../uvc.c      ****     #if 0
3062:../uvc.c      ****                             /* We can start streaming video now. */
3063:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3064:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3065:../uvc.c      ****                             {
3066:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3067:../uvc.c      ****                             }
3068:../uvc.c      ****     #endif
3069:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3070:../uvc.c      ****                         }else{
3071:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3072:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3073:../uvc.c      ****                         }
3074:../uvc.c      ****                         break;
3075:../uvc.c      **** 
3076:../uvc.c      ****                     default:
3077:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3078:../uvc.c      ****                         break;
3079:../uvc.c      ****                 }
3080:../uvc.c      ****                 break;
3081:../uvc.c      **** 
3082:../uvc.c      ****         default:
3083:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3084:../uvc.c      ****             break;
3085:../uvc.c      ****     }
3086:../uvc.c      **** }
3087:../uvc.c      **** 
3088:../uvc.c      **** /*
3089:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3090:../uvc.c      ****  */
3091:../uvc.c      **** void
3092:../uvc.c      **** UVCAppEP0Thread_Entry (
3093:../uvc.c      ****         uint32_t input)
3094:../uvc.c      **** {
3095:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3096:../uvc.c      ****     uint32_t eventFlag;
3097:../uvc.c      **** 	CyBool_t value;
3098:../uvc.c      **** 	CyBool_t *valueptr = &value;
3099:../uvc.c      **** 
3100:../uvc.c      **** 
3101:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3102:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3103:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3104:../uvc.c      **** 
3105:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3106:../uvc.c      **** #endif
3107:../uvc.c      **** 
3108:../uvc.c      ****     /* for interrupt status test */
3109:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3110:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3111:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3112:../uvc.c      **** 
3113:../uvc.c      ****     for (;;)
3114:../uvc.c      ****     {
3115:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3116:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3117:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3118:../uvc.c      ****         {
3119:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3120:../uvc.c      ****             if (!isUsbConnected)
3121:../uvc.c      ****             {
3122:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3123:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3124:../uvc.c      ****                 {
3125:../uvc.c      ****                     isUsbConnected = CyTrue;
3126:../uvc.c      ****                 }
3127:../uvc.c      ****             }
3128:../uvc.c      **** //#ifdef DbgInfo
3129:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3130:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3131:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3132:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3133:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3134:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3135:../uvc.c      **** //#endif
3136:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3137:../uvc.c      ****             {
3138:../uvc.c      ****             	switch ((wIndex >> 8))
3139:../uvc.c      ****                 {
3140:../uvc.c      **** 
3141:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3142:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3143:../uvc.c      ****                         break;
3144:../uvc.c      **** 
3145:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3146:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3147:../uvc.c      ****                         break;
3148:../uvc.c      **** 
3149:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3150:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3151:../uvc.c      ****                         break;
3152:../uvc.c      **** 
3153:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3154:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3155:../uvc.c      ****                         break;
3156:../uvc.c      **** 
3157:../uvc.c      ****                     default:
3158:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3159:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3160:../uvc.c      ****                         break;
3161:../uvc.c      ****                 }
3162:../uvc.c      ****             }
3163:../uvc.c      **** 
3164:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3165:../uvc.c      ****             {
3166:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3167:../uvc.c      **** 
3168:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3169:../uvc.c      ****                 {
3170:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3171:../uvc.c      ****                 }
3172:../uvc.c      ****                 else
3173:../uvc.c      ****                 {
3174:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3175:../uvc.c      ****                 }
3176:../uvc.c      ****             }
3177:../uvc.c      **** 
3178:../uvc.c      ****             /* handle interrupt status event */
3179:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3180:../uvc.c      ****             {
3181:../uvc.c      **** 
3182:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3183:../uvc.c      ****             	/** preparing interrupt status data **/
3184:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3185:../uvc.c      **** 
3186:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3187:../uvc.c      **** 
3188:../uvc.c      **** #if 1 //for real button
3189:../uvc.c      **** 				if(value&&(!snapButFlag)){
3190:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3191:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3192:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3193:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3194:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3195:../uvc.c      **** 
3196:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3197:../uvc.c      **** 					interStabuf.size   = 1024;
3198:../uvc.c      **** 					interStabuf.status = 0;
3199:../uvc.c      **** 
3200:../uvc.c      **** 					interStabuf.count = 4;
3201:../uvc.c      **** 
3202:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3203:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3204:../uvc.c      **** 
3205:../uvc.c      **** 					/** send a interrupt status data **/
3206:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3207:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3208:../uvc.c      **** 					{
3209:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3210:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3211:../uvc.c      **** 					}
3212:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3213:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3214:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3215:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3216:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3217:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3218:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3219:../uvc.c      **** 
3220:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3221:../uvc.c      **** 					interStabuf.size   = 1024;
3222:../uvc.c      **** 					interStabuf.status = 0;
3223:../uvc.c      **** 
3224:../uvc.c      **** 					interStabuf.count = 4;
3225:../uvc.c      **** 
3226:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3227:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3228:../uvc.c      **** 
3229:../uvc.c      **** 					/** send a interrupt status data **/
3230:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3231:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3232:../uvc.c      **** 					{
3233:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3234:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3235:../uvc.c      **** 					}
3236:../uvc.c      **** 
3237:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3238:../uvc.c      **** 					stiflag = CyTrue;
3239:../uvc.c      **** 				}
3240:../uvc.c      **** #else			//for botton simulation
3241:../uvc.c      **** 				if(snapButFlag == 0x0f){
3242:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3243:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3244:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3245:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3246:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3247:../uvc.c      **** 
3248:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3249:../uvc.c      **** 					interStabuf.size   = 1024;
3250:../uvc.c      **** 					interStabuf.status = 0;
3251:../uvc.c      **** 
3252:../uvc.c      **** 					interStabuf.count = 4;
3253:../uvc.c      **** 
3254:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3255:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3256:../uvc.c      **** 
3257:../uvc.c      **** 					/** send a interrupt status data **/
3258:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3259:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3260:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3261:../uvc.c      **** 					{
3262:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3263:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3264:../uvc.c      **** 					}
3265:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3266:../uvc.c      **** 
3267:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3268:../uvc.c      **** 				}else if(!snapButFlag){
3269:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3270:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3271:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3272:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3273:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3274:../uvc.c      **** 
3275:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3276:../uvc.c      **** 					interStabuf.size   = 1024;
3277:../uvc.c      **** 					interStabuf.status = 0;
3278:../uvc.c      **** 
3279:../uvc.c      **** 					interStabuf.count = 4;
3280:../uvc.c      **** 
3281:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3282:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3283:../uvc.c      **** 
3284:../uvc.c      **** 					/** send a interrupt status data **/
3285:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3286:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3287:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3288:../uvc.c      **** 					{
3289:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3290:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3291:../uvc.c      **** 					}
3292:../uvc.c      **** 
3293:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3294:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3295:../uvc.c      **** 				}
3296:../uvc.c      **** #endif
3297:../uvc.c      **** 
3298:../uvc.c      ****             }
3299:../uvc.c      **** 
3300:../uvc.c      **** 
3301:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3302:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3303:../uvc.c      ****             {
3304:../uvc.c      ****                 /* Get the command buffer */
3305:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3306:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3307:../uvc.c      ****                 {
3308:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3309:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3310:../uvc.c      ****                 }
3311:../uvc.c      **** 
3312:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3313:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3314:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3315:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3316:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3317:../uvc.c      ****                  * register value high byte and register value low byte.
3318:../uvc.c      ****                  */
3319:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3320:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3321:../uvc.c      ****                 {
3322:../uvc.c      ****                     if (dmaInfo.count == 3)
3323:../uvc.c      ****                     {
3324:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3325:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3326:../uvc.c      ****                         dmaInfo.count = 3;
3327:../uvc.c      ****                     }
3328:../uvc.c      ****                     else if (dmaInfo.count == 4)
3329:../uvc.c      ****                     {
3330:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3331:../uvc.c      ****                         {
3332:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3333:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3334:../uvc.c      ****                         }
3335:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3336:../uvc.c      ****                     }
3337:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3338:../uvc.c      ****                 }
3339:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3340:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3341:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3342:../uvc.c      ****                  */
3343:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3344:../uvc.c      ****                 {
3345:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3346:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3347:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3348:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3349:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3350:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3351:../uvc.c      ****                         	break;
3352:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3353:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3354:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3355:../uvc.c      ****                         	break;*/
3356:../uvc.c      ****                     dmaInfo.count -= 2;
3357:../uvc.c      ****                 }
3358:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3359:../uvc.c      ****                 else
3360:../uvc.c      ****                 {
3361:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3362:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3363:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3364:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3365:../uvc.c      ****                 }
3366:../uvc.c      **** 
3367:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3368:../uvc.c      ****                 dmaInfo.size   = 1024;
3369:../uvc.c      ****                 dmaInfo.status = 0;
3370:../uvc.c      **** 
3371:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3372:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3373:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3374:../uvc.c      ****                 {
3375:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3376:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3377:../uvc.c      ****                 }
3378:../uvc.c      **** 
3379:../uvc.c      ****                 /* Wait until the response has gone out. */
3380:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3381:../uvc.c      **** 
3382:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3383:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3384:../uvc.c      ****                 {
3385:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3386:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3387:../uvc.c      ****                 }
3388:../uvc.c      ****             }
3389:../uvc.c      **** #endif
3390:../uvc.c      ****         }
3391:../uvc.c      ****         /* Allow other ready threads to run. */
3392:../uvc.c      ****         CyU3PThreadRelinquish ();
3393:../uvc.c      ****     }
3394:../uvc.c      **** }
3395:../uvc.c      **** 
3396:../uvc.c      **** /*
3397:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3398:../uvc.c      ****  * added 10/2013
3399:../uvc.c      ****  */
3400:../uvc.c      **** /*
3401:../uvc.c      **** static uint8_t timeDelay[64] = {
3402:../uvc.c      **** 
3403:../uvc.c      **** };
3404:../uvc.c      **** */
3405:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3405 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3406:../uvc.c      **** 
3407:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3408:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3409:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3410:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3411:../uvc.c      **** 	VdstateDes *lcStaDes;
3412:../uvc.c      **** 	uint32_t flag = 0;
3413:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3414:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3415:../uvc.c      **** 	uint8_t i;
3416:../uvc.c      **** 	uint16_t delaytime;
3417:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3418:../uvc.c      **** 
3419:../uvc.c      **** #if 0 //for test the command queue
3420:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3421:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3422:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3423:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3424:../uvc.c      **** 		lcCmdDes += 1;
3425:../uvc.c      **** 	}
3426:../uvc.c      **** #endif
3427:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3428:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3428 0
  36 0004 00229FE5 		ldr	r2, .L22
3412:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3412 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3405:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3405 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3428 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 E8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3412:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3412 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3428 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3429:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3429 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 CC119FE5 		ldr	r1, .L22+8
  71 0044 CC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3430:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3430 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3431:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3431 0
  79 005c AC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3432:../uvc.c      **** 
3433:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3433 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3434:../uvc.c      ****         /* Allow other ready threads to run. */
3435:../uvc.c      **** 
3436:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3436 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3433:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3433 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3437:../uvc.c      **** 	}
3438:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3438 0
  92 0078 98019FE5 		ldr	r0, .L22+12
  93 007c 98119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 88719FE5 		ldr	r7, .L22+20
  99 0094 88B19FE5 		ldr	fp, .L22+24
3439:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3440:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3441:../uvc.c      **** 	//CyU3PThreadSleep(100);
3442:../uvc.c      **** 	//SetCurCmd();
3443:../uvc.c      **** 	/*********** the loop of the thread ***********/
3444:../uvc.c      **** 	for(;;){
3445:../uvc.c      **** 
3446:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3446 0
 101 0098 0060E0E3 		mvn	r6, #0
3447:../uvc.c      **** /*  // for test GPIO output
3448:../uvc.c      **** 		if(trigger)
3449:../uvc.c      **** 		{
3450:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3451:../uvc.c      **** 			{
3452:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3453:../uvc.c      **** 			}
3454:../uvc.c      **** 
3455:../uvc.c      **** 		}else{
3456:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3457:../uvc.c      **** 			{
3458:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3459:../uvc.c      **** 			}
3460:../uvc.c      **** 
3461:../uvc.c      **** 		}
3462:../uvc.c      **** */
3463:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3464:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3465:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3466:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3467:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3468:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3469:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3470:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3471:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3472:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3473:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3474:../uvc.c      **** #endif
3475:../uvc.c      **** 				}
3476:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3477:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3478:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3479:../uvc.c      **** 			}
3480:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3481:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3482:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3483:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3484:../uvc.c      **** 
3485:../uvc.c      **** 				/*
3486:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3487:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3488:../uvc.c      **** 				*/
3489:../uvc.c      **** 
3490:../uvc.c      **** 				/* find a available command */
3491:../uvc.c      **** 				i = 0;
3492:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3492 0
 103 009c 0090A0E3 		mov	r9, #0
3493:../uvc.c      **** 					i++;
3494:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3495:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3496:../uvc.c      **** 				}
3497:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3498:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3499:../uvc.c      **** 					i = lcCmdDes->curNum;
3500:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3501:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3502:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3503:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3504:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3505:../uvc.c      **** 						case 0x20:
3506:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3507:../uvc.c      **** 							delaytime = 500;
3508:../uvc.c      **** 							break;
3509:../uvc.c      **** 						case 0x21:
3510:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3511:../uvc.c      **** 							delaytime = 500;
3512:../uvc.c      **** 							break;
3513:../uvc.c      **** 						case 0x22:
3514:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3515:../uvc.c      **** 							delaytime = 300;
3516:../uvc.c      **** 							break;
3517:../uvc.c      **** 						case 0x23:
3518:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3519:../uvc.c      **** 							delaytime = 300;
3520:../uvc.c      **** 							break;
3521:../uvc.c      **** 						default:
3522:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3523:../uvc.c      **** 							break;
3524:../uvc.c      **** 					}
3525:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3526:../uvc.c      **** 					/** timer's ticket modify **/
3527:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3528:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3529:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3530:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3531:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3532:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3533:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3534:../uvc.c      **** #endif
3535:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3536:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3537:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3538:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3539:../uvc.c      **** 						}else{
3540:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3541:../uvc.c      **** 						}
3542:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3543:../uvc.c      **** 					}else{
3544:../uvc.c      **** 						lcCmdDes->curNum ++;
3545:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3545 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3446:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3446 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 70019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3463:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3463 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3480:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3480 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3482:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3482 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3483:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3483 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3492:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3492 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3494:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3494 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3493:../uvc.c      **** 					i++;
 140              		.loc 1 3493 0
 141 00f4 011083E2 		add	r1, r3, #1
3492:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3492 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3493:../uvc.c      **** 					i++;
 144              		.loc 1 3493 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3492:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3492 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3498:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3498 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2900000A 		beq	.L6
 157              	.LVL10:
3500:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3500 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3504:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3504 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3500:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3500 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3504:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3504 0
 166 0128 20C042E2 		sub	ip, r2, #32
3500:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3500 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3501:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3501 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3502:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3502 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3503:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3503 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3504:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3504 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 58010000 		.word	.L9
 185 014c 58010000 		.word	.L9
 186 0150 A4010000 		.word	.L11
 187 0154 A4010000 		.word	.L11
 188              	.L9:
3510:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 189              		.loc 1 3510 0
 190 0158 5230A0E3 		mov	r3, #82
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3512:../uvc.c      **** 							break;
 193              		.loc 1 3512 0
 194 0160 7D1FA0E3 		mov	r1, #500
 195              	.LVL16:
 196              	.L13:
3527:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3527 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 A0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3528:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3528 0
 202 0170 98009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3535:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3535 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3544:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3544 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3545 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3535:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3535 0
 215 0190 1000000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3546:../uvc.c      **** 					}
3547:../uvc.c      **** 				}else{
3548:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3549:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3550:../uvc.c      **** 				}
3551:../uvc.c      **** 			}
3552:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3552 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3553:../uvc.c      **** /*
3554:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3555:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3556:../uvc.c      **** */
3557:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3558:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3559:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3560:../uvc.c      **** #endif
3561:../uvc.c      **** 
3562:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3563:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3564:../uvc.c      **** #if 0
3565:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3566:../uvc.c      **** 
3567:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3568:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3569:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3570:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3571:../uvc.c      **** 			    i = 0;
3572:../uvc.c      **** 				 switch(cmdCopyIdx)
3573:../uvc.c      **** 				 {
3574:../uvc.c      **** 					 case BrgtCtlID1:
3575:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3576:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3577:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3578:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3579:../uvc.c      **** 							 i++;
3580:../uvc.c      **** 						 }
3581:../uvc.c      **** 						 else{
3582:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3583:../uvc.c      **** 						 }
3584:../uvc.c      **** 
3585:../uvc.c      **** 						 CyU3PBusyWait(500);
3586:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3587:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3588:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3589:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3590:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3591:../uvc.c      **** 						 }
3592:../uvc.c      **** 						 else{
3593:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3594:../uvc.c      **** 						 }
3595:../uvc.c      **** 						 break;
3596:../uvc.c      **** 					 case HueCtlID5:
3597:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3598:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3599:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3600:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3601:../uvc.c      **** 						 }
3602:../uvc.c      **** 						 else{
3603:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3604:../uvc.c      **** 						 }
3605:../uvc.c      **** 						 break;
3606:../uvc.c      **** 					 case SaturCtlID6:
3607:../uvc.c      **** 					 case WBTLevCtlID10:
3608:../uvc.c      **** 					 default:
3609:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3610:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3611:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3612:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3613:../uvc.c      **** 						 }
3614:../uvc.c      **** 						 else{
3615:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3616:../uvc.c      **** 						 }
3617:../uvc.c      **** 						 break;
3618:../uvc.c      **** 				 }
3619:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3620:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3621:../uvc.c      **** 			}
3622:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3623:../uvc.c      **** #endif
3624:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3625:../uvc.c      **** 		/* Allow other ready threads to run. */
3626:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3627:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3627 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3628:../uvc.c      **** 		}
 224              		.loc 1 3628 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L11:
3518:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
 228              		.loc 1 3518 0
 229 01a4 8230A0E3 		mov	r3, #130
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3520:../uvc.c      **** 							break;
 232              		.loc 1 3520 0
 233 01ac 4B1FA0E3 		mov	r1, #300
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3522:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3522 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3523:../uvc.c      **** 							break;
 241              		.loc 1 3523 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L6:
3548:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 245              		.loc 1 3548 0
 246 01c0 FA1FA0E3 		mov	r1, #1000
 247 01c4 44009FE5 		ldr	r0, .L22+4
 248 01c8 FEFFFFEB 		bl	_txe_timer_change
3549:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 249              		.loc 1 3549 0
 250 01cc 3C009FE5 		ldr	r0, .L22+4
 251 01d0 FEFFFFEB 		bl	_txe_timer_activate
 252 01d4 EEFFFFEA 		b	.L17
 253              	.LVL25:
 254              	.L21:
3537:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 255              		.loc 1 3537 0
 256 01d8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3536:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 257              		.loc 1 3536 0
 258 01dc 3C9084E5 		str	r9, [r4, #60]
3537:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 259              		.loc 1 3537 0
 260 01e0 23005CE3 		cmp	ip, #35
3538:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 261              		.loc 1 3538 0
 262 01e4 20C04C82 		subhi	ip, ip, #32
 263 01e8 8CC08C80 		addhi	ip, ip, ip, asl #1
3540:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 264              		.loc 1 3540 0
 265 01ec 8CC08C90 		addls	ip, ip, ip, asl #1
3538:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 266              		.loc 1 3538 0
 267 01f0 8CC18B80 		addhi	ip, fp, ip, asl #3
3540:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 268              		.loc 1 3540 0
 269 01f4 8CC18B90 		addls	ip, fp, ip, asl #3
3538:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 270              		.loc 1 3538 0
 271 01f8 1090CC85 		strhib	r9, [ip, #16]
3540:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 272              		.loc 1 3540 0
 273 01fc 9091CC95 		strlsb	r9, [ip, #400]
3542:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 274              		.loc 1 3542 0
 275 0200 344094E5 		ldr	r4, [r4, #52]
 276              	.LVL26:
 277 0204 104085E5 		str	r4, [r5, #16]
 278 0208 E1FFFFEA 		b	.L17
 279              	.L23:
 280              		.align	2
 281              	.L22:
 282 020c 00000000 		.word	I2CCmdCb
 283 0210 00000000 		.word	I2CCmdTimer
 284 0214 00000000 		.word	.LC0
 285 0218 00000000 		.word	cmdQu
 286 021c 14000000 		.word	.LC1
 287 0220 00000000 		.word	statQu
 288 0224 00000000 		.word	.LANCHOR1
 289 0228 00000000 		.word	.LANCHOR0
 290              		.cfi_endproc
 291              	.LFE25:
 293              		.align	2
 294              		.global	I2CCmdCb
 296              	I2CCmdCb:
 297              	.LFB17:
2182:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 298              		.loc 1 2182 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 0
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302              		@ link register save eliminated.
 303              	.LVL27:
2184:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 304              		.loc 1 2184 0
 305 022c 08009FE5 		ldr	r0, .L25
 306              	.LVL28:
 307 0230 2010A0E3 		mov	r1, #32
 308 0234 0020A0E3 		mov	r2, #0
2185:../uvc.c      **** }
 309              		.loc 1 2185 0
2184:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 310              		.loc 1 2184 0
 311 0238 FEFFFFEA 		b	_txe_event_flags_set
 312              	.L26:
 313              		.align	2
 314              	.L25:
 315 023c 00000000 		.word	.LANCHOR0
 316              		.cfi_endproc
 317              	.LFE17:
 319              		.align	2
 320              		.global	CyFxUvcApplnDmaCallback
 322              	CyFxUvcApplnDmaCallback:
 323              	.LFB10:
1472:../uvc.c      **** {
 324              		.loc 1 1472 0
 325              		.cfi_startproc
 326              		@ args = 0, pretend = 0, frame = 0
 327              		@ frame_needed = 0, uses_anonymous_args = 0
 328              	.LVL29:
1476:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 329              		.loc 1 1476 0
 330 0240 080051E3 		cmp	r1, #8
1472:../uvc.c      **** {
 331              		.loc 1 1472 0
 332 0244 30402DE9 		stmfd	sp!, {r4, r5, lr}
 333              	.LCFI2:
 334              		.cfi_def_cfa_offset 12
 335 0248 0240A0E1 		mov	r4, r2
 336              		.cfi_offset 14, -4
 337              		.cfi_offset 5, -8
 338              		.cfi_offset 4, -12
 339 024c 0CD04DE2 		sub	sp, sp, #12
 340              	.LCFI3:
 341              		.cfi_def_cfa_offset 24
1476:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 342              		.loc 1 1476 0
 343 0250 0B00000A 		beq	.L32
1505:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 344              		.loc 1 1505 0
 345 0254 100051E3 		cmp	r1, #16
 346 0258 0700001A 		bne	.L27
1507:../uvc.c      ****         consCount++;
 347              		.loc 1 1507 0
 348 025c 04319FE5 		ldr	r3, .L34
1508:../uvc.c      ****         streamingStarted = CyTrue;
 349              		.loc 1 1508 0
 350 0260 0120A0E3 		mov	r2, #1
 351              	.LVL30:
1507:../uvc.c      ****         consCount++;
 352              		.loc 1 1507 0
 353 0264 B0C3D3E1 		ldrh	ip, [r3, #48]
1508:../uvc.c      ****         streamingStarted = CyTrue;
 354              		.loc 1 1508 0
 355 0268 342083E5 		str	r2, [r3, #52]
1507:../uvc.c      ****         consCount++;
 356              		.loc 1 1507 0
 357 026c 02008CE0 		add	r0, ip, r2
 358              	.LVL31:
 359 0270 0018A0E1 		mov	r1, r0, asl #16
 360              	.LVL32:
 361 0274 2128A0E1 		mov	r2, r1, lsr #16
 362 0278 B023C3E1 		strh	r2, [r3, #48]	@ movhi
 363              	.L27:
1510:../uvc.c      **** }
 364              		.loc 1 1510 0
 365 027c 0CD08DE2 		add	sp, sp, #12
 366 0280 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 367              	.LVL33:
 368              	.L32:
1478:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 369              		.loc 1 1478 0
 370 0284 B420D2E1 		ldrh	r2, [r2, #4]
 371 0288 DC309FE5 		ldr	r3, .L34+4
 372 028c 030052E1 		cmp	r2, r3
 373 0290 2900000A 		beq	.L33
1486:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 374              		.loc 1 1486 0
 375 0294 005094E5 		ldr	r5, [r4, #0]
 376              	.LVL34:
 377              	.LBB12:
 378              	.LBB13:
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 379              		.loc 1 1221 0
 380 0298 D0109FE5 		ldr	r1, .L34+8
 381              	.LVL35:
 382 029c 0C0045E2 		sub	r0, r5, #12
 383              	.LVL36:
 384 02a0 0C20A0E3 		mov	r2, #12
 385 02a4 FEFFFFEB 		bl	CyU3PMemCopy
 386              	.LVL37:
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 387              		.loc 1 1226 0
 388 02a8 0BC055E5 		ldrb	ip, [r5, #-11]	@ zero_extendqisi2
 389              	.LBE13:
 390              	.LBE12:
1487:../uvc.c      ****                 pb++;
 391              		.loc 1 1487 0
 392 02ac B4309FE5 		ldr	r3, .L34
 393              	.LBB15:
 394              	.LBB14:
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 395              		.loc 1 1226 0
 396 02b0 02108CE3 		orr	r1, ip, #2
 397 02b4 0B1045E5 		strb	r1, [r5, #-11]
 398              	.LBE14:
 399              	.LBE15:
1487:../uvc.c      ****                 pb++;
 400              		.loc 1 1487 0
 401 02b8 BA02D3E1 		ldrh	r0, [r3, #42]
1488:../uvc.c      ****                 pbc = input->buffer_p.count;
 402              		.loc 1 1488 0
 403 02bc B410D4E1 		ldrh	r1, [r4, #4]
1487:../uvc.c      ****                 pb++;
 404              		.loc 1 1487 0
 405 02c0 012080E2 		add	r2, r0, #1
 406 02c4 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
1488:../uvc.c      ****                 pbc = input->buffer_p.count;
 407              		.loc 1 1488 0
 408 02c8 BC12C3E1 		strh	r1, [r3, #44]	@ movhi
 409              	.LVL38:
 410              	.L30:
1493:../uvc.c      ****             prodCount++;
 411              		.loc 1 1493 0
 412 02cc BEE2D3E1 		ldrh	lr, [r3, #46]
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 413              		.loc 1 1494 0
 414 02d0 0C1081E2 		add	r1, r1, #12
1493:../uvc.c      ****             prodCount++;
 415              		.loc 1 1493 0
 416 02d4 01C08EE2 		add	ip, lr, #1
 417 02d8 0C08A0E1 		mov	r0, ip, asl #16
 418 02dc 20E8A0E1 		mov	lr, r0, lsr #16
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 419              		.loc 1 1494 0
 420 02e0 0128A0E1 		mov	r2, r1, asl #16
 421 02e4 2218A0E1 		mov	r1, r2, lsr #16
 422 02e8 84009FE5 		ldr	r0, .L34+12
 423 02ec 0020A0E3 		mov	r2, #0
1493:../uvc.c      ****             prodCount++;
 424              		.loc 1 1493 0
 425 02f0 BEE2C3E1 		strh	lr, [r3, #46]	@ movhi
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 426              		.loc 1 1494 0
 427 02f4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 428              	.LVL39:
1493:../uvc.c      ****             prodCount++;
 429              		.loc 1 1493 0
 430 02f8 68109FE5 		ldr	r1, .L34
1497:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 431              		.loc 1 1497 0
 432 02fc 002050E2 		subs	r2, r0, #0
 433 0300 DDFFFF0A 		beq	.L27
1499:../uvc.c      ****                 prodCount--;
 434              		.loc 1 1499 0
 435 0304 BEC2D1E1 		ldrh	ip, [r1, #46]
1500:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 436              		.loc 1 1500 0
 437 0308 B430D4E1 		ldrh	r3, [r4, #4]
1499:../uvc.c      ****                 prodCount--;
 438              		.loc 1 1499 0
 439 030c 01004CE2 		sub	r0, ip, #1
 440              	.LVL40:
 441 0310 00E8A0E1 		mov	lr, r0, asl #16
 442 0314 2EC8A0E1 		mov	ip, lr, lsr #16
 443 0318 BEC2C1E1 		strh	ip, [r1, #46]	@ movhi
1500:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 444              		.loc 1 1500 0
 445 031c BEE2D1E1 		ldrh	lr, [r1, #46]
 446 0320 B003D1E1 		ldrh	r0, [r1, #48]
 447 0324 4C109FE5 		ldr	r1, .L34+16
 448 0328 0EC060E0 		rsb	ip, r0, lr
 449 032c 0400A0E3 		mov	r0, #4
 450 0330 00C08DE5 		str	ip, [sp, #0]
 451 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 452              	.LVL41:
 453 0338 CFFFFFEA 		b	.L27
 454              	.LVL42:
 455              	.L33:
1480:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 456              		.loc 1 1480 0
 457 033c 00E094E5 		ldr	lr, [r4, #0]
 458              	.LBB16:
 459              	.LBB17:
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 460              		.loc 1 1221 0
 461 0340 28109FE5 		ldr	r1, .L34+8
 462              	.LVL43:
 463 0344 0C004EE2 		sub	r0, lr, #12
 464              	.LVL44:
 465 0348 0C20A0E3 		mov	r2, #12
 466 034c FEFFFFEB 		bl	CyU3PMemCopy
 467              	.LVL45:
 468              	.LBE17:
 469              	.LBE16:
1481:../uvc.c      ****                 fb++;
 470              		.loc 1 1481 0
 471 0350 10309FE5 		ldr	r3, .L34
 472 0354 B410D4E1 		ldrh	r1, [r4, #4]
 473 0358 B8C2D3E1 		ldrh	ip, [r3, #40]
 474 035c 01008CE2 		add	r0, ip, #1
 475 0360 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 476 0364 D8FFFFEA 		b	.L30
 477              	.L35:
 478              		.align	2
 479              	.L34:
 480 0368 00000000 		.word	.LANCHOR0
 481 036c F03F0000 		.word	16368
 482 0370 80040000 		.word	.LANCHOR1+1152
 483 0374 00000000 		.word	glChHandleUVCStream
 484 0378 38000000 		.word	.LC2
 485              		.cfi_endproc
 486              	.LFE10:
 488              		.align	2
 490              	CyFxUVCApplnUSBEventCB:
 491              	.LFB8:
1275:../uvc.c      **** {
 492              		.loc 1 1275 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 8
 495              		@ frame_needed = 0, uses_anonymous_args = 0
 496              	.LVL46:
1276:../uvc.c      ****     switch (evtype)
 497              		.loc 1 1276 0
 498 037c 020050E3 		cmp	r0, #2
1275:../uvc.c      **** {
 499              		.loc 1 1275 0
 500 0380 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 501              	.LCFI4:
 502              		.cfi_def_cfa_offset 16
 503 0384 0130A0E1 		mov	r3, r1
 504 0388 10D04DE2 		sub	sp, sp, #16
 505              	.LCFI5:
 506              		.cfi_def_cfa_offset 32
1275:../uvc.c      **** {
 507              		.loc 1 1275 0
 508 038c 0040A0E1 		mov	r4, r0
 509              		.cfi_offset 14, -4
 510              		.cfi_offset 6, -8
 511              		.cfi_offset 5, -12
 512              		.cfi_offset 4, -16
1276:../uvc.c      ****     switch (evtype)
 513              		.loc 1 1276 0
 514 0390 3600000A 		beq	.L39
 515 0394 040050E3 		cmp	r0, #4
 516 0398 1F00000A 		beq	.L40
 517 039c 010050E3 		cmp	r0, #1
 518 03a0 0100000A 		beq	.L42
 519              	.LVL47:
 520              	.L36:
1312:../uvc.c      **** }
 521              		.loc 1 1312 0
 522 03a4 10D08DE2 		add	sp, sp, #16
 523 03a8 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 524              	.LVL48:
 525              	.L42:
1297:../uvc.c      ****             gpif_initialized = 0;
 526              		.loc 1 1297 0
 527 03ac 28519FE5 		ldr	r5, .L43
1295:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 528              		.loc 1 1295 0
 529 03b0 0020A0E1 		mov	r2, r0
 530 03b4 24119FE5 		ldr	r1, .L43+4
 531              	.LVL49:
 532 03b8 0400A0E3 		mov	r0, #4
 533              	.LVL50:
 534 03bc FEFFFFEB 		bl	CyU3PDebugPrint
1296:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 535              		.loc 1 1296 0
 536 03c0 0400A0E1 		mov	r0, r4
 537 03c4 FEFFFFEB 		bl	CyU3PGpifDisable
1297:../uvc.c      ****             gpif_initialized = 0;
 538              		.loc 1 1297 0
 539 03c8 00C0A0E3 		mov	ip, #0
 540              	.LBB24:
 541              	.LBB25:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 542              		.loc 1 1259 0
 543 03cc 0410A0E1 		mov	r1, r4
 544 03d0 0500A0E1 		mov	r0, r5
 545 03d4 0220A0E3 		mov	r2, #2
 546 03d8 0C308DE2 		add	r3, sp, #12
 547              	.LBE25:
 548              	.LBE24:
1297:../uvc.c      ****             gpif_initialized = 0;
 549              		.loc 1 1297 0
 550 03dc 38C085E5 		str	ip, [r5, #56]
1298:../uvc.c      ****             isUsbConnected = CyFalse;
 551              		.loc 1 1298 0
 552 03e0 3CC085E5 		str	ip, [r5, #60]
1299:../uvc.c      ****             streamingStarted = CyFalse;
 553              		.loc 1 1299 0
 554 03e4 34C085E5 		str	ip, [r5, #52]
 555              	.LBB27:
 556              	.LBB26:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 557              		.loc 1 1259 0
 558 03e8 00C08DE5 		str	ip, [sp, #0]
 559 03ec FEFFFFEB 		bl	_txe_event_flags_get
 560 03f0 004050E2 		subs	r4, r0, #0
 561 03f4 EAFFFF1A 		bne	.L36
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 562              		.loc 1 1262 0
 563 03f8 0110E0E3 		mvn	r1, #1
 564 03fc 0220A0E3 		mov	r2, #2
 565 0400 0500A0E1 		mov	r0, r5
 566              	.L41:
 567 0404 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 568              		.loc 1 1265 0
 569 0408 0500A0E1 		mov	r0, r5
 570 040c 0210A0E3 		mov	r1, #2
 571 0410 0420A0E1 		mov	r2, r4
 572 0414 FEFFFFEB 		bl	_txe_event_flags_set
 573 0418 E1FFFFEA 		b	.L36
 574              	.LVL51:
 575              	.L40:
 576              	.LBE26:
 577              	.LBE27:
1281:../uvc.c      ****             gpif_initialized = 0;
 578              		.loc 1 1281 0
 579 041c B8509FE5 		ldr	r5, .L43
1279:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 580              		.loc 1 1279 0
 581 0420 BC109FE5 		ldr	r1, .L43+8
 582              	.LVL52:
 583 0424 0020A0E1 		mov	r2, r0
 584 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 585              	.LVL53:
1280:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 586              		.loc 1 1280 0
 587 042c 0100A0E3 		mov	r0, #1
 588 0430 FEFFFFEB 		bl	CyU3PGpifDisable
1281:../uvc.c      ****             gpif_initialized = 0;
 589              		.loc 1 1281 0
 590 0434 00C0A0E3 		mov	ip, #0
 591              	.LBB28:
 592              	.LBB29:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 593              		.loc 1 1259 0
 594 0438 0110A0E3 		mov	r1, #1
 595 043c 0220A0E3 		mov	r2, #2
 596 0440 0500A0E1 		mov	r0, r5
 597 0444 0C308DE2 		add	r3, sp, #12
 598              	.LBE29:
 599              	.LBE28:
1281:../uvc.c      ****             gpif_initialized = 0;
 600              		.loc 1 1281 0
 601 0448 38C085E5 		str	ip, [r5, #56]
1282:../uvc.c      ****             streamingStarted = CyFalse;
 602              		.loc 1 1282 0
 603 044c 34C085E5 		str	ip, [r5, #52]
 604              	.LBB31:
 605              	.LBB30:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 606              		.loc 1 1259 0
 607 0450 00C08DE5 		str	ip, [sp, #0]
 608 0454 FEFFFFEB 		bl	_txe_event_flags_get
 609 0458 004050E2 		subs	r4, r0, #0
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 610              		.loc 1 1262 0
 611 045c 0500A001 		moveq	r0, r5
 612 0460 0110E003 		mvneq	r1, #1
 613 0464 0220A003 		moveq	r2, #2
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 614              		.loc 1 1259 0
 615 0468 CDFFFF1A 		bne	.L36
 616 046c E4FFFFEA 		b	.L41
 617              	.LVL54:
 618              	.L39:
 619              	.LBE30:
 620              	.LBE31:
1289:../uvc.c      ****             gpif_initialized = 0;
 621              		.loc 1 1289 0
 622 0470 64509FE5 		ldr	r5, .L43
1287:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 623              		.loc 1 1287 0
 624 0474 0020A0E1 		mov	r2, r0
 625 0478 68109FE5 		ldr	r1, .L43+12
 626              	.LVL55:
 627 047c 0400A0E3 		mov	r0, #4
 628              	.LVL56:
 629 0480 FEFFFFEB 		bl	CyU3PDebugPrint
1288:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 630              		.loc 1 1288 0
 631 0484 0100A0E3 		mov	r0, #1
 632 0488 FEFFFFEB 		bl	CyU3PGpifDisable
1289:../uvc.c      ****             gpif_initialized = 0;
 633              		.loc 1 1289 0
 634 048c 0060A0E3 		mov	r6, #0
 635              	.LBB32:
 636              	.LBB33:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 637              		.loc 1 1259 0
 638 0490 0500A0E1 		mov	r0, r5
 639 0494 0110A0E3 		mov	r1, #1
 640 0498 0420A0E1 		mov	r2, r4
 641 049c 0C308DE2 		add	r3, sp, #12
 642              	.LBE33:
 643              	.LBE32:
1289:../uvc.c      ****             gpif_initialized = 0;
 644              		.loc 1 1289 0
 645 04a0 386085E5 		str	r6, [r5, #56]
1290:../uvc.c      ****             streamingStarted = CyFalse;
 646              		.loc 1 1290 0
 647 04a4 346085E5 		str	r6, [r5, #52]
 648              	.LBB35:
 649              	.LBB34:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 650              		.loc 1 1259 0
 651 04a8 00608DE5 		str	r6, [sp, #0]
 652 04ac FEFFFFEB 		bl	_txe_event_flags_get
 653 04b0 006050E2 		subs	r6, r0, #0
 654 04b4 BAFFFF1A 		bne	.L36
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 655              		.loc 1 1262 0
 656 04b8 0420A0E1 		mov	r2, r4
 657 04bc 0500A0E1 		mov	r0, r5
 658 04c0 0110E0E3 		mvn	r1, #1
 659 04c4 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 660              		.loc 1 1265 0
 661 04c8 0500A0E1 		mov	r0, r5
 662 04cc 0410A0E1 		mov	r1, r4
 663 04d0 0620A0E1 		mov	r2, r6
 664 04d4 FEFFFFEB 		bl	_txe_event_flags_set
 665 04d8 B1FFFFEA 		b	.L36
 666              	.L44:
 667              		.align	2
 668              	.L43:
 669 04dc 00000000 		.word	.LANCHOR0
 670 04e0 C4000000 		.word	.LC5
 671 04e4 80000000 		.word	.LC3
 672 04e8 A0000000 		.word	.LC4
 673              	.LBE34:
 674              	.LBE35:
 675              		.cfi_endproc
 676              	.LFE8:
 678              		.align	2
 680              	CyFxUVCApplnUSBSetupCB:
 681              	.LFB9:
1320:../uvc.c      **** {
 682              		.loc 1 1320 0
 683              		.cfi_startproc
 684              		@ args = 0, pretend = 0, frame = 8
 685              		@ frame_needed = 0, uses_anonymous_args = 0
 686              	.LVL57:
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 687              		.loc 1 1325 0
 688 04ec C0329FE5 		ldr	r3, .L70
1320:../uvc.c      **** {
 689              		.loc 1 1320 0
 690 04f0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 691              	.LCFI6:
 692              		.cfi_def_cfa_offset 24
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 693              		.loc 1 1326 0
 694 04f4 BCC29FE5 		ldr	ip, .L70+4
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 695              		.loc 1 1325 0
 696 04f8 FF4000E2 		and	r4, r0, #255
 697              		.cfi_offset 14, -4
 698              		.cfi_offset 8, -8
 699              		.cfi_offset 7, -12
 700              		.cfi_offset 6, -16
 701              		.cfi_offset 5, -20
 702              		.cfi_offset 4, -24
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 703              		.loc 1 1326 0
 704 04fc FF8C00E2 		and	r8, r0, #65280
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 705              		.loc 1 1327 0
 706 0500 2078A0E1 		mov	r7, r0, lsr #16
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 707              		.loc 1 1325 0
 708 0504 0040C3E5 		strb	r4, [r3, #0]
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 709              		.loc 1 1327 0
 710 0508 AC229FE5 		ldr	r2, .L70+8
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 711              		.loc 1 1328 0
 712 050c AC029FE5 		ldr	r0, .L70+12
 713              	.LVL58:
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 714              		.loc 1 1329 0
 715 0510 AC329FE5 		ldr	r3, .L70+16
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 716              		.loc 1 1328 0
 717 0514 0158A0E1 		mov	r5, r1, asl #16
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 718              		.loc 1 1326 0
 719 0518 2884A0E1 		mov	r8, r8, lsr #8
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 720              		.loc 1 1328 0
 721 051c 2558A0E1 		mov	r5, r5, lsr #16
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 722              		.loc 1 1329 0
 723 0520 2118A0E1 		mov	r1, r1, lsr #16
 724              	.LVL59:
1332:../uvc.c      ****     switch (bmReqType)
 725              		.loc 1 1332 0
 726 0524 020054E3 		cmp	r4, #2
1320:../uvc.c      **** {
 727              		.loc 1 1320 0
 728 0528 10D04DE2 		sub	sp, sp, #16
 729              	.LCFI7:
 730              		.cfi_def_cfa_offset 40
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 731              		.loc 1 1326 0
 732 052c 0080CCE5 		strb	r8, [ip, #0]
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 733              		.loc 1 1327 0
 734 0530 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 735              		.loc 1 1328 0
 736 0534 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 737              		.loc 1 1329 0
 738 0538 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1332:../uvc.c      ****     switch (bmReqType)
 739              		.loc 1 1332 0
 740 053c 4F00000A 		beq	.L48
 741 0540 0600009A 		bls	.L66
 742 0544 210054E3 		cmp	r4, #33
 743 0548 3A00000A 		beq	.L49
 744 054c A10054E3 		cmp	r4, #161
 745 0550 3800000A 		beq	.L49
 746              	.L63:
1321:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 747              		.loc 1 1321 0
 748 0554 0000A0E3 		mov	r0, #0
 749              	.LVL60:
 750              	.L46:
1459:../uvc.c      **** }
 751              		.loc 1 1459 0
 752 0558 10D08DE2 		add	sp, sp, #16
 753 055c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 754              	.LVL61:
 755              	.L66:
1332:../uvc.c      ****     switch (bmReqType)
 756              		.loc 1 1332 0
 757 0560 010054E3 		cmp	r4, #1
 758 0564 FAFFFF1A 		bne	.L63
1372:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 759              		.loc 1 1372 0
 760 0568 0B0058E3 		cmp	r8, #11
 761 056c F8FFFF1A 		bne	.L63
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 762              		.loc 1 1376 0
 763 0570 010055E3 		cmp	r5, #1
 764 0574 F6FFFF1A 		bne	.L63
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 765              		.loc 1 1376 0 is_stmt 0 discriminator 1
 766 0578 000057E3 		cmp	r7, #0
 767 057c F4FFFF1A 		bne	.L63
1381:../uvc.c      ****                     gpif_initialized = 0;
 768              		.loc 1 1381 0 is_stmt 1
 769 0580 40429FE5 		ldr	r4, .L70+20
1379:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 770              		.loc 1 1379 0
 771 0584 40129FE5 		ldr	r1, .L70+24
 772 0588 0400A0E3 		mov	r0, #4
 773 058c FEFFFFEB 		bl	CyU3PDebugPrint
1380:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 774              		.loc 1 1380 0
 775 0590 0500A0E1 		mov	r0, r5
 776 0594 FEFFFFEB 		bl	CyU3PGpifDisable
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 777              		.loc 1 1384 0
 778 0598 0510A0E1 		mov	r1, r5
 779 059c 8300A0E3 		mov	r0, #131
1381:../uvc.c      ****                     gpif_initialized = 0;
 780              		.loc 1 1381 0
 781 05a0 387084E5 		str	r7, [r4, #56]
1382:../uvc.c      ****                     streamingStarted = CyFalse;
 782              		.loc 1 1382 0
 783 05a4 347084E5 		str	r7, [r4, #52]
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 784              		.loc 1 1384 0
 785 05a8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1385:../uvc.c      ****                     CyU3PBusyWait (100);
 786              		.loc 1 1385 0
 787 05ac 6400A0E3 		mov	r0, #100
 788 05b0 FEFFFFEB 		bl	CyU3PBusyWait
1388:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 789              		.loc 1 1388 0
 790 05b4 14029FE5 		ldr	r0, .L70+28
 791 05b8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1389:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 792              		.loc 1 1389 0
 793 05bc 8300A0E3 		mov	r0, #131
 794 05c0 FEFFFFEB 		bl	CyU3PUsbFlushEp
1390:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 795              		.loc 1 1390 0
 796 05c4 0710A0E1 		mov	r1, r7
 797 05c8 8300A0E3 		mov	r0, #131
 798 05cc FEFFFFEB 		bl	CyU3PUsbSetEpNak
1391:../uvc.c      ****                     CyU3PBusyWait (100);
 799              		.loc 1 1391 0
 800 05d0 6400A0E3 		mov	r0, #100
 801 05d4 FEFFFFEB 		bl	CyU3PBusyWait
1394:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 802              		.loc 1 1394 0
 803 05d8 0710A0E1 		mov	r1, r7
 804 05dc 0520A0E1 		mov	r2, r5
 805 05e0 8300A0E3 		mov	r0, #131
 806 05e4 FEFFFFEB 		bl	CyU3PUsbStall
 807              	.LVL62:
1397:../uvc.c      ****                     CyU3PUsbAckSetup ();
 808              		.loc 1 1397 0
 809 05e8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1399:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 810              		.loc 1 1399 0
 811 05ec 405084E5 		str	r5, [r4, #64]
 812              	.LBB40:
 813              	.LBB41:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 814              		.loc 1 1259 0
 815 05f0 0400A0E1 		mov	r0, r4
 816 05f4 0510A0E1 		mov	r1, r5
 817 05f8 0220A0E3 		mov	r2, #2
 818 05fc 0C308DE2 		add	r3, sp, #12
 819 0600 00708DE5 		str	r7, [sp, #0]
 820 0604 FEFFFFEB 		bl	_txe_event_flags_get
 821 0608 006050E2 		subs	r6, r0, #0
 822 060c 2E00001A 		bne	.L61
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 823              		.loc 1 1262 0
 824 0610 0110E0E3 		mvn	r1, #1
 825 0614 0220A0E3 		mov	r2, #2
 826 0618 0400A0E1 		mov	r0, r4
 827 061c FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 828              		.loc 1 1265 0
 829 0620 0400A0E1 		mov	r0, r4
 830 0624 0210A0E3 		mov	r1, #2
 831 0628 0620A0E1 		mov	r2, r6
 832 062c FEFFFFEB 		bl	_txe_event_flags_set
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
 833              		.loc 1 1395 0
 834 0630 0500A0E1 		mov	r0, r5
 835 0634 C7FFFFEA 		b	.L46
 836              	.LVL63:
 837              	.L49:
 838              	.LBE41:
 839              	.LBE40:
1337:../uvc.c      ****             switch (wIndex & 0xFF)
 840              		.loc 1 1337 0
 841 0638 FF5015E2 		ands	r5, r5, #255
 842 063c 1A00001A 		bne	.L67
 843              	.LVL64:
1342:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 844              		.loc 1 1342 0
 845 0640 0520A0E1 		mov	r2, r5
 846 0644 7C019FE5 		ldr	r0, .L70+20
 847 0648 0410A0E3 		mov	r1, #4
 848 064c FEFFFFEB 		bl	_txe_event_flags_set
 849              	.LVL65:
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 850              		.loc 1 1344 0
 851 0650 002050E2 		subs	r2, r0, #0
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
 852              		.loc 1 1341 0
 853 0654 0100A003 		moveq	r0, #1
 854              	.LVL66:
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 855              		.loc 1 1344 0
 856 0658 BEFFFF0A 		beq	.L46
1346:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 857              		.loc 1 1346 0
 858 065c 70119FE5 		ldr	r1, .L70+32
 859 0660 0400A0E3 		mov	r0, #4
 860 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 861              	.LVL67:
1347:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 862              		.loc 1 1347 0
 863 0668 0500A0E1 		mov	r0, r5
 864 066c 0110A0E3 		mov	r1, #1
 865 0670 0520A0E1 		mov	r2, r5
 866 0674 FEFFFFEB 		bl	CyU3PUsbStall
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
 867              		.loc 1 1341 0
 868 0678 0100A0E3 		mov	r0, #1
 869 067c B5FFFFEA 		b	.L46
 870              	.LVL68:
 871              	.L48:
1407:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 872              		.loc 1 1407 0
 873 0680 010058E3 		cmp	r8, #1
 874 0684 B2FFFF1A 		bne	.L63
1409:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 875              		.loc 1 1409 0
 876 0688 830055E3 		cmp	r5, #131
 877 068c B0FFFF1A 		bne	.L63
1415:../uvc.c      ****                     if (streamingStarted == CyTrue)
 878              		.loc 1 1415 0
 879 0690 30719FE5 		ldr	r7, .L70+20
 880 0694 346097E5 		ldr	r6, [r7, #52]
 881 0698 010056E3 		cmp	r6, #1
 882 069c 1500000A 		beq	.L68
 883              	.LVL69:
1447:../uvc.c      ****                         CyU3PUsbAckSetup ();
 884              		.loc 1 1447 0
 885 06a0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1446:../uvc.c      ****                         uvcHandleReq = CyTrue;
 886              		.loc 1 1446 0
 887 06a4 0800A0E1 		mov	r0, r8
 888 06a8 AAFFFFEA 		b	.L46
 889              	.LVL70:
 890              	.L67:
1337:../uvc.c      ****             switch (wIndex & 0xFF)
 891              		.loc 1 1337 0
 892 06ac 010055E3 		cmp	r5, #1
 893 06b0 A7FFFF1A 		bne	.L63
 894              	.LVL71:
1355:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 895              		.loc 1 1355 0
 896 06b4 0020A0E3 		mov	r2, #0
 897 06b8 08019FE5 		ldr	r0, .L70+20
 898 06bc 0810A0E3 		mov	r1, #8
 899 06c0 FEFFFFEB 		bl	_txe_event_flags_set
 900              	.LVL72:
1357:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 901              		.loc 1 1357 0
 902 06c4 002050E2 		subs	r2, r0, #0
 903 06c8 0100001A 		bne	.L69
 904              	.LVL73:
 905              	.L61:
 906              	.LBB43:
 907              	.LBB42:
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1395 0
 909 06cc 0500A0E1 		mov	r0, r5
 910 06d0 A0FFFFEA 		b	.L46
 911              	.LVL74:
 912              	.L69:
 913              	.LBE42:
 914              	.LBE43:
1360:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 915              		.loc 1 1360 0
 916 06d4 FC109FE5 		ldr	r1, .L70+36
 917 06d8 0400A0E3 		mov	r0, #4
 918              	.LVL75:
 919 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 920              	.LVL76:
1361:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 921              		.loc 1 1361 0
 922 06e0 0000A0E3 		mov	r0, #0
 923 06e4 0510A0E1 		mov	r1, r5
 924 06e8 0020A0E1 		mov	r2, r0
 925 06ec FEFFFFEB 		bl	CyU3PUsbStall
1354:../uvc.c      ****                         uvcHandleReq = CyTrue;
 926              		.loc 1 1354 0
 927 06f0 0500A0E1 		mov	r0, r5
 928 06f4 97FFFFEA 		b	.L46
 929              	.LVL77:
 930              	.L68:
1417:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 931              		.loc 1 1417 0
 932 06f8 DC109FE5 		ldr	r1, .L70+40
 933 06fc 0400A0E3 		mov	r0, #4
 934 0700 FEFFFFEB 		bl	CyU3PDebugPrint
1421:../uvc.c      ****                         gpif_initialized = 0;
 935              		.loc 1 1421 0
 936 0704 0080A0E3 		mov	r8, #0
1420:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 937              		.loc 1 1420 0
 938 0708 0600A0E1 		mov	r0, r6
 939 070c FEFFFFEB 		bl	CyU3PGpifDisable
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 940              		.loc 1 1425 0
 941 0710 0610A0E1 		mov	r1, r6
 942 0714 0500A0E1 		mov	r0, r5
1421:../uvc.c      ****                         gpif_initialized = 0;
 943              		.loc 1 1421 0
 944 0718 388087E5 		str	r8, [r7, #56]
1422:../uvc.c      ****                         streamingStarted = CyFalse;
 945              		.loc 1 1422 0
 946 071c 348087E5 		str	r8, [r7, #52]
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 947              		.loc 1 1425 0
 948 0720 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1426:../uvc.c      ****                         CyU3PBusyWait (100);
 949              		.loc 1 1426 0
 950 0724 6400A0E3 		mov	r0, #100
 951 0728 FEFFFFEB 		bl	CyU3PBusyWait
1429:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 952              		.loc 1 1429 0
 953 072c 9C009FE5 		ldr	r0, .L70+28
 954 0730 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1430:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 955              		.loc 1 1430 0
 956 0734 0500A0E1 		mov	r0, r5
 957 0738 FEFFFFEB 		bl	CyU3PUsbFlushEp
1431:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 958              		.loc 1 1431 0
 959 073c 0810A0E1 		mov	r1, r8
 960 0740 0500A0E1 		mov	r0, r5
 961 0744 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1432:../uvc.c      ****                         CyU3PBusyWait (100);
 962              		.loc 1 1432 0
 963 0748 6400A0E3 		mov	r0, #100
 964 074c FEFFFFEB 		bl	CyU3PBusyWait
1435:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 965              		.loc 1 1435 0
 966 0750 0810A0E1 		mov	r1, r8
 967 0754 0620A0E1 		mov	r2, r6
 968 0758 0500A0E1 		mov	r0, r5
 969 075c FEFFFFEB 		bl	CyU3PUsbStall
 970              	.LVL78:
1439:../uvc.c      ****                         CyU3PUsbAckSetup ();
 971              		.loc 1 1439 0
 972 0760 FEFFFFEB 		bl	CyU3PUsbAckSetup
1441:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 973              		.loc 1 1441 0
 974 0764 406087E5 		str	r6, [r7, #64]
 975              	.LBB44:
 976              	.LBB45:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 977              		.loc 1 1259 0
 978 0768 0700A0E1 		mov	r0, r7
 979 076c 0610A0E1 		mov	r1, r6
 980 0770 0420A0E1 		mov	r2, r4
 981 0774 0C308DE2 		add	r3, sp, #12
 982 0778 00808DE5 		str	r8, [sp, #0]
 983 077c FEFFFFEB 		bl	_txe_event_flags_get
 984 0780 005050E2 		subs	r5, r0, #0
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
 985              		.loc 1 1437 0
 986 0784 0600A011 		movne	r0, r6
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 987              		.loc 1 1259 0
 988 0788 72FFFF1A 		bne	.L46
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 989              		.loc 1 1262 0
 990 078c 0110E0E3 		mvn	r1, #1
 991 0790 0420A0E1 		mov	r2, r4
 992 0794 0700A0E1 		mov	r0, r7
 993 0798 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 994              		.loc 1 1265 0
 995 079c 0700A0E1 		mov	r0, r7
 996 07a0 0410A0E1 		mov	r1, r4
 997 07a4 0520A0E1 		mov	r2, r5
 998 07a8 FEFFFFEB 		bl	_txe_event_flags_set
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
 999              		.loc 1 1437 0
 1000 07ac 0600A0E1 		mov	r0, r6
 1001 07b0 68FFFFEA 		b	.L46
 1002              	.L71:
 1003              		.align	2
 1004              	.L70:
 1005 07b4 00000000 		.word	bmReqType
 1006 07b8 00000000 		.word	bRequest
 1007 07bc 00000000 		.word	wValue
 1008 07c0 00000000 		.word	wIndex
 1009 07c4 00000000 		.word	wLength
 1010 07c8 00000000 		.word	.LANCHOR0
 1011 07cc 50010000 		.word	.LC8
 1012 07d0 00000000 		.word	glChHandleUVCStream
 1013 07d4 E4000000 		.word	.LC6
 1014 07d8 1C010000 		.word	.LC7
 1015 07dc 68010000 		.word	.LC9
 1016              	.LBE45:
 1017              	.LBE44:
 1018              		.cfi_endproc
 1019              	.LFE9:
 1021              		.align	2
 1022              		.global	CyFxGpifCB
 1024              	CyFxGpifCB:
 1025              	.LFB12:
1630:../uvc.c      **** {
 1026              		.loc 1 1630 0
 1027              		.cfi_startproc
 1028              		@ args = 0, pretend = 0, frame = 0
 1029              		@ frame_needed = 0, uses_anonymous_args = 0
 1030              	.LVL79:
1631:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1031              		.loc 1 1631 0
 1032 07e0 010050E3 		cmp	r0, #1
1630:../uvc.c      **** {
 1033              		.loc 1 1630 0
 1034 07e4 10402DE9 		stmfd	sp!, {r4, lr}
 1035              	.LCFI8:
 1036              		.cfi_def_cfa_offset 8
1630:../uvc.c      **** {
 1037              		.loc 1 1630 0
 1038 07e8 0120A0E1 		mov	r2, r1
1631:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1039              		.loc 1 1631 0
 1040 07ec 1080BD18 		ldmnefd	sp!, {r4, pc}
 1041              		.cfi_offset 14, -4
 1042              		.cfi_offset 4, -8
1633:../uvc.c      ****         hitFV = CyTrue;
 1043              		.loc 1 1633 0
 1044 07f0 D0109FE5 		ldr	r1, .L88
 1045              	.LVL80:
 1046              	.LBB50:
 1047              	.LBB52:
1530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1048              		.loc 1 1530 0
 1049 07f4 4830D1E5 		ldrb	r3, [r1, #72]	@ zero_extendqisi2
 1050              	.LBE52:
 1051              	.LBE50:
1633:../uvc.c      ****         hitFV = CyTrue;
 1052              		.loc 1 1633 0
 1053 07f8 440081E5 		str	r0, [r1, #68]
 1054              	.LVL81:
 1055              	.LBB56:
 1056              	.LBB51:
1530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1057              		.loc 1 1530 0
 1058 07fc 030053E3 		cmp	r3, #3
 1059 0800 2800000A 		beq	.L87
1554:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1060              		.loc 1 1554 0
 1061 0804 020053E3 		cmp	r3, #2
 1062 0808 1080BD18 		ldmnefd	sp!, {r4, pc}
1556:../uvc.c      ****         switch (stateId)
 1063              		.loc 1 1556 0
 1064 080c 080042E2 		sub	r0, r2, #8
 1065              	.LVL82:
 1066 0810 0A0050E3 		cmp	r0, #10
 1067 0814 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1068 0818 1B0000EA 		b	.L80
 1069              	.L82:
 1070 081c 4C080000 		.word	.L76
 1071 0820 8C080000 		.word	.L80
 1072 0824 8C080000 		.word	.L80
 1073 0828 48080000 		.word	.L72
 1074 082c 8C080000 		.word	.L80
 1075 0830 8C080000 		.word	.L80
 1076 0834 8C080000 		.word	.L80
 1077 0838 84080000 		.word	.L86
 1078 083c 8C080000 		.word	.L80
 1079 0840 8C080000 		.word	.L80
 1080 0844 48080000 		.word	.L72
 1081              	.LVL83:
 1082              	.L72:
 1083 0848 1080BDE8 		ldmfd	sp!, {r4, pc}
 1084              	.LVL84:
 1085              	.L76:
1540:../uvc.c      ****                 socket = 0;
 1086              		.loc 1 1540 0
 1087 084c 0010A0E3 		mov	r1, #0
 1088              	.L77:
 1089              	.LVL85:
1613:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1090              		.loc 1 1613 0
 1091 0850 74009FE5 		ldr	r0, .L88+4
 1092 0854 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1093              	.LVL86:
1614:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1094              		.loc 1 1614 0
 1095 0858 002050E2 		subs	r2, r0, #0
 1096 085c F9FFFF0A 		beq	.L72
1616:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1097              		.loc 1 1616 0
 1098 0860 0400A0E3 		mov	r0, #4
 1099              	.LVL87:
 1100 0864 64109FE5 		ldr	r1, .L88+8
 1101 0868 FEFFFFEB 		bl	CyU3PDebugPrint
 1102              	.LVL88:
 1103              	.L83:
 1104              	.LBB53:
 1105              	.LBB54:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1106              		.loc 1 1246 0
 1107 086c 60109FE5 		ldr	r1, .L88+12
 1108 0870 0400A0E3 		mov	r0, #4
 1109 0874 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 1110              		.loc 1 1247 0
 1111 0878 FA0FA0E3 		mov	r0, #1000
 1112 087c FEFFFFEB 		bl	_tx_thread_sleep
 1113 0880 F9FFFFEA 		b	.L83
 1114              	.LVL89:
 1115              	.L86:
 1116              	.LBE54:
 1117              	.LBE53:
1597:../uvc.c      ****                 socket = 1;
 1118              		.loc 1 1597 0
 1119 0884 0110A0E3 		mov	r1, #1
 1120 0888 F0FFFFEA 		b	.L77
 1121              	.L80:
1602:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1122              		.loc 1 1602 0
 1123 088c 44109FE5 		ldr	r1, .L88+16
 1124 0890 0100A0E3 		mov	r0, #1
 1125 0894 FEFFFFEB 		bl	CyU3PDebugPrint
 1126              	.LVL90:
 1127              	.LBE51:
 1128              	.LBE56:
1635:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1129              		.loc 1 1635 0
 1130 0898 3C109FE5 		ldr	r1, .L88+20
 1131 089c 0400A0E3 		mov	r0, #4
1637:../uvc.c      **** }
 1132              		.loc 1 1637 0
 1133 08a0 1040BDE8 		ldmfd	sp!, {r4, lr}
1635:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1134              		.loc 1 1635 0
 1135 08a4 FEFFFFEA 		b	CyU3PDebugPrint
 1136              	.LVL91:
 1137              	.L87:
 1138              	.LBB57:
 1139              	.LBB55:
1532:../uvc.c      ****         switch (stateId)
 1140              		.loc 1 1532 0
 1141 08a8 0B3042E2 		sub	r3, r2, #11
 1142 08ac 030053E3 		cmp	r3, #3
 1143 08b0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1144 08b4 F4FFFFEA 		b	.L80
 1145              	.L78:
 1146 08b8 4C080000 		.word	.L76
 1147 08bc 84080000 		.word	.L86
 1148 08c0 48080000 		.word	.L72
 1149 08c4 48080000 		.word	.L72
 1150              	.L89:
 1151              		.align	2
 1152              	.L88:
 1153 08c8 00000000 		.word	.LANCHOR0
 1154 08cc 00000000 		.word	glChHandleUVCStream
 1155 08d0 A4010000 		.word	.LC11
 1156 08d4 D4010000 		.word	.LC12
 1157 08d8 8C010000 		.word	.LC10
 1158 08dc E8010000 		.word	.LC13
 1159              	.LBE55:
 1160              	.LBE57:
 1161              		.cfi_endproc
 1162              	.LFE12:
 1164              		.align	2
 1165              		.global	I2CCmdHandler
 1167              	I2CCmdHandler:
 1168              	.LFB0:
 323:../uvc.c      **** void I2CCmdHandler(){
 1169              		.loc 1 323 0
 1170              		.cfi_startproc
 1171              		@ args = 0, pretend = 0, frame = 8
 1172              		@ frame_needed = 0, uses_anonymous_args = 0
 1173 08e0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1174              	.LCFI9:
 1175              		.cfi_def_cfa_offset 36
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1176              		.loc 1 326 0
 1177 08e4 00419FE5 		ldr	r4, .L96
 1178              		.cfi_offset 14, -4
 1179              		.cfi_offset 11, -8
 1180              		.cfi_offset 10, -12
 1181              		.cfi_offset 9, -16
 1182              		.cfi_offset 8, -20
 1183              		.cfi_offset 7, -24
 1184              		.cfi_offset 6, -28
 1185              		.cfi_offset 5, -32
 1186              		.cfi_offset 4, -36
 323:../uvc.c      **** void I2CCmdHandler(){
 1187              		.loc 1 323 0
 1188 08e8 34D04DE2 		sub	sp, sp, #52
 1189              	.LCFI10:
 1190              		.cfi_def_cfa_offset 88
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1191              		.loc 1 326 0
 1192 08ec 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1193              	.LVL92:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1194              		.loc 1 331 0
 1195 08f0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1196              		.loc 1 328 0
 1197 08f4 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1198              	.LVL93:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1199              		.loc 1 331 0
 1200 08f8 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1201 08fc 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1202 0900 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1203 0904 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1204 0908 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1205 090c 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1206 0910 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1207 0914 1C208DE5 		str	r2, [sp, #28]
 1208 0918 0400A0E3 		mov	r0, #4
 1209 091c 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 1210 0920 C8109FE5 		ldr	r1, .L96+4
 1211 0924 0520A0E1 		mov	r2, r5
 1212 0928 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1213 092c 08808DE5 		str	r8, [sp, #8]
 1214 0930 0CA08DE5 		str	sl, [sp, #12]
 1215 0934 10908DE5 		str	r9, [sp, #16]
 1216 0938 14B08DE5 		str	fp, [sp, #20]
 1217 093c 18608DE5 		str	r6, [sp, #24]
 1218 0940 20C08DE5 		str	ip, [sp, #32]
 1219 0944 FEFFFFEB 		bl	CyU3PDebugPrint
 1220              	.LVL94:
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1221              		.loc 1 335 0
 1222 0948 000055E3 		cmp	r5, #0
 1223 094c 0300000A 		beq	.L94
 360:../uvc.c      **** 	}else if(CmdType == 1){
 1224              		.loc 1 360 0
 1225 0950 010055E3 		cmp	r5, #1
 1226 0954 1400000A 		beq	.L95
 1227              	.LVL95:
 1228              	.L90:
 375:../uvc.c      **** }
 1229              		.loc 1 375 0
 1230 0958 34D08DE2 		add	sp, sp, #52
 1231 095c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1232              	.LVL96:
 1233              	.L94:
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1234              		.loc 1 351 0
 1235 0960 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1236 0964 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1237 0968 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1238              		.loc 1 337 0
 1239 096c 0FE0A0E3 		mov	lr, #15
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1240              		.loc 1 351 0
 1241 0970 2CC08DE2 		add	ip, sp, #44
 1242 0974 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1243 0978 010080E3 		orr	r0, r0, #1
 1244 097c 011081E3 		orr	r1, r1, #1
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1245              		.loc 1 337 0
 1246 0980 57E0C4E5 		strb	lr, [r4, #87]
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1247              		.loc 1 351 0
 1248 0984 00C08DE5 		str	ip, [sp, #0]
 1249 0988 FEFFFFEB 		bl	SensorRead2B
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1250              		.loc 1 352 0
 1251 098c 2C00DDE5 		ldrb	r0, [sp, #44]	@ zero_extendqisi2
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 1252              		.loc 1 353 0
 1253 0990 020056E3 		cmp	r6, #2
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1254              		.loc 1 352 0
 1255 0994 5500C4E5 		strb	r0, [r4, #85]
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1256              		.loc 1 354 0
 1257 0998 2D00DD05 		ldreqb	r0, [sp, #45]	@ zero_extendqisi2
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1258              		.loc 1 356 0
 1259 099c 0030E0E3 		mvn	r3, #0
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1260              		.loc 1 354 0
 1261 09a0 5600C405 		streqb	r0, [r4, #86]
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1262              		.loc 1 356 0
 1263 09a4 5730C4E5 		strb	r3, [r4, #87]
 1264 09a8 EAFFFFEA 		b	.L90
 1265              	.L95:
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1266              		.loc 1 369 0
 1267 09ac 54C0D4E5 		ldrb	ip, [r4, #84]	@ zero_extendqisi2
 1268 09b0 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1269 09b4 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 362:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1270              		.loc 1 362 0
 1271 09b8 5550D4E5 		ldrb	r5, [r4, #85]	@ zero_extendqisi2
 1272              	.LVL97:
 363:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1273              		.loc 1 363 0
 1274 09bc 56E0D4E5 		ldrb	lr, [r4, #86]	@ zero_extendqisi2
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1275              		.loc 1 369 0
 1276 09c0 00C08DE5 		str	ip, [sp, #0]
 1277 09c4 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1278 09c8 2CC08DE2 		add	ip, sp, #44
 1279 09cc 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1280 09d0 FE1001E2 		and	r1, r1, #254
 1281 09d4 FE0000E2 		and	r0, r0, #254
 362:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1282              		.loc 1 362 0
 1283 09d8 2C50CDE5 		strb	r5, [sp, #44]
 363:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1284              		.loc 1 363 0
 1285 09dc 2DE0CDE5 		strb	lr, [sp, #45]
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1286              		.loc 1 369 0
 1287 09e0 04C08DE5 		str	ip, [sp, #4]
 1288 09e4 FEFFFFEB 		bl	SensorWrite2B
 1289 09e8 DAFFFFEA 		b	.L90
 1290              	.L97:
 1291              		.align	2
 1292              	.L96:
 1293 09ec 00000000 		.word	.LANCHOR0
 1294 09f0 FC010000 		.word	.LC14
 1295              		.cfi_endproc
 1296              	.LFE0:
 1298              		.align	2
 1299              		.global	setIrisauto
 1301              	setIrisauto:
 1302              	.LFB1:
 381:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1303              		.loc 1 381 0
 1304              		.cfi_startproc
 1305              		@ args = 0, pretend = 0, frame = 0
 1306              		@ frame_needed = 0, uses_anonymous_args = 0
 1307              	.LVL98:
 1308 09f4 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1309              	.LCFI11:
 1310              		.cfi_def_cfa_offset 16
 1311 09f8 0160A0E1 		mov	r6, r1
 1312              		.cfi_offset 14, -4
 1313              		.cfi_offset 6, -8
 1314              		.cfi_offset 5, -12
 1315              		.cfi_offset 4, -16
 1316 09fc 08D04DE2 		sub	sp, sp, #8
 1317              	.LCFI12:
 1318              		.cfi_def_cfa_offset 24
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1319              		.loc 1 385 0
 1320 0a00 0050A0E3 		mov	r5, #0
 381:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1321              		.loc 1 381 0
 1322 0a04 0040A0E1 		mov	r4, r0
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1323              		.loc 1 384 0
 1324 0a08 0010E0E3 		mvn	r1, #0
 1325              	.LVL99:
 1326 0a0c 1C0090E5 		ldr	r0, [r0, #28]
 1327              	.LVL100:
 1328 0a10 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1329              		.loc 1 385 0
 1330 0a14 060065E0 		rsb	r0, r5, r6
 1331 0a18 00C070E2 		rsbs	ip, r0, #0
 1332 0a1c 00C0ACE0 		adc	ip, ip, r0
 1333 0a20 2010A0E3 		mov	r1, #32
 1334 0a24 2720A0E3 		mov	r2, #39
 1335 0a28 3030A0E3 		mov	r3, #48
 1336 0a2c 0400A0E1 		mov	r0, r4
 1337 0a30 00C08DE5 		str	ip, [sp, #0]
 1338 0a34 04508DE5 		str	r5, [sp, #4]
 1339 0a38 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 1340              		.loc 1 386 0
 1341 0a3c 050056E1 		cmp	r6, r5
 1342 0a40 0260A003 		moveq	r6, #2
 1343 0a44 0560A011 		movne	r6, r5
 1344 0a48 0400A0E1 		mov	r0, r4
 1345 0a4c 2110A0E3 		mov	r1, #33
 1346 0a50 2520A0E3 		mov	r2, #37
 1347 0a54 3030A0E3 		mov	r3, #48
 1348 0a58 00608DE5 		str	r6, [sp, #0]
 1349 0a5c 04508DE5 		str	r5, [sp, #4]
 1350 0a60 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1351              		.loc 1 387 0
 1352 0a64 1C0094E5 		ldr	r0, [r4, #28]
 388:../uvc.c      **** }
 1353              		.loc 1 388 0
 1354 0a68 08D08DE2 		add	sp, sp, #8
 1355 0a6c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1356              		.loc 1 387 0
 1357 0a70 FEFFFFEA 		b	_txe_mutex_put
 1358              		.cfi_endproc
 1359              	.LFE1:
 1361              		.align	2
 1362              		.global	ControlHandle
 1364              	ControlHandle:
 1365              	.LFB2:
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1366              		.loc 1 390 0
 1367              		.cfi_startproc
 1368              		@ args = 0, pretend = 0, frame = 24
 1369              		@ frame_needed = 0, uses_anonymous_args = 0
 1370              	.LVL101:
 1371 0a74 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1372              	.LCFI13:
 1373              		.cfi_def_cfa_offset 36
 397:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1374              		.loc 1 397 0
 1375 0a78 230050E3 		cmp	r0, #35
 396:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1376              		.loc 1 396 0
 1377 0a7c 207040E2 		sub	r7, r0, #32
 1378              		.cfi_offset 14, -4
 1379              		.cfi_offset 11, -8
 1380              		.cfi_offset 10, -12
 1381              		.cfi_offset 9, -16
 1382              		.cfi_offset 8, -20
 1383              		.cfi_offset 7, -24
 1384              		.cfi_offset 6, -28
 1385              		.cfi_offset 5, -32
 1386              		.cfi_offset 4, -36
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1387              		.loc 1 390 0
 1388 0a80 2CD04DE2 		sub	sp, sp, #44
 1389              	.LCFI14:
 1390              		.cfi_def_cfa_offset 80
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1391              		.loc 1 390 0
 1392 0a84 0040A0E1 		mov	r4, r0
 396:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1393              		.loc 1 396 0
 1394 0a88 FF7007E2 		and	r7, r7, #255
 1395              	.LVL102:
 397:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1396              		.loc 1 397 0
 1397 0a8c 2400009A 		bls	.L102
 398:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1398              		.loc 1 398 0
 1399 0a90 586F9FE5 		ldr	r6, .L211
 1400 0a94 872087E0 		add	r2, r7, r7, asl #1
 1401 0a98 8221A0E1 		mov	r2, r2, asl #3
 1402 0a9c 023086E0 		add	r3, r6, r2
 399:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1403              		.loc 1 399 0
 1404 0aa0 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 400:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1405              		.loc 1 400 0
 1406 0aa4 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 401:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1407              		.loc 1 401 0
 1408 0aa8 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 412:../uvc.c      ****     reqData = bRequest;
 1409              		.loc 1 412 0
 1410 0aac 403F9FE5 		ldr	r3, .L211+4
 398:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1411              		.loc 1 398 0
 1412 0ab0 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1413              	.LVL103:
 412:../uvc.c      ****     reqData = bRequest;
 1414              		.loc 1 412 0
 1415 0ab4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1416              	.LVL104:
 420:../uvc.c      ****     switch (bRequest)
 1417              		.loc 1 420 0
 1418 0ab8 830055E3 		cmp	r5, #131
 1419 0abc 2300000A 		beq	.L108
 1420              	.LVL105:
 1421              	.L206:
 1422 0ac0 2C00009A 		bls	.L204
 1423 0ac4 850055E3 		cmp	r5, #133
 1424 0ac8 8B00000A 		beq	.L110
 1425 0acc 7900003A 		bcc	.L109
 1426 0ad0 860055E3 		cmp	r5, #134
 1427 0ad4 C800000A 		beq	.L111
 1428 0ad8 870055E3 		cmp	r5, #135
 1429 0adc BC00000A 		beq	.L205
 1430              	.L104:
 896:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1431              		.loc 1 896 0
 1432 0ae0 0000A0E3 		mov	r0, #0
 1433 0ae4 0110A0E3 		mov	r1, #1
 1434 0ae8 0020A0E1 		mov	r2, r0
 1435 0aec FEFFFFEB 		bl	CyU3PUsbStall
 897:../uvc.c      **** 			  break;
 1436              		.loc 1 897 0
 1437 0af0 FFC0A0E3 		mov	ip, #255
 1438 0af4 0C70A0E1 		mov	r7, ip
 1439              	.LVL106:
 1440 0af8 0CE0A0E1 		mov	lr, ip
 1441 0afc 0C40A0E1 		mov	r4, ip
 1442              	.LVL107:
 1443              	.L114:
 899:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1444              		.loc 1 899 0
 1445 0b00 F01E9FE5 		ldr	r1, .L211+8
 1446 0b04 0520A0E1 		mov	r2, r5
 1447 0b08 0430A0E1 		mov	r3, r4
 1448 0b0c 0400A0E3 		mov	r0, #4
 1449 0b10 00E08DE5 		str	lr, [sp, #0]
 1450 0b14 80108DE9 		stmib	sp, {r7, ip}	@ phole stm
 1451 0b18 FEFFFFEB 		bl	CyU3PDebugPrint
 900:../uvc.c      **** }
 1452              		.loc 1 900 0
 1453 0b1c 2CD08DE2 		add	sp, sp, #44
 1454 0b20 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1455              	.LVL108:
 1456              	.L102:
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1457              		.loc 1 403 0
 1458 0b24 C46E9FE5 		ldr	r6, .L211
 412:../uvc.c      ****     reqData = bRequest;
 1459              		.loc 1 412 0
 1460 0b28 C43E9FE5 		ldr	r3, .L211+4
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1461              		.loc 1 403 0
 1462 0b2c 805080E0 		add	r5, r0, r0, asl #1
 1463 0b30 850186E0 		add	r0, r6, r5, asl #3
 1464              	.LVL109:
 412:../uvc.c      ****     reqData = bRequest;
 1465              		.loc 1 412 0
 1466 0b34 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1467              		.loc 1 403 0
 1468 0b38 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1469              	.LVL110:
 420:../uvc.c      ****     switch (bRequest)
 1470              		.loc 1 420 0
 1471 0b3c 830055E3 		cmp	r5, #131
 404:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1472              		.loc 1 404 0
 1473 0b40 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1474              	.LVL111:
 405:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1475              		.loc 1 405 0
 1476 0b44 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1477              	.LVL112:
 406:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1478              		.loc 1 406 0
 1479 0b48 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1480              	.LVL113:
 420:../uvc.c      ****     switch (bRequest)
 1481              		.loc 1 420 0
 1482 0b4c DBFFFF1A 		bne	.L206
 1483              	.LVL114:
 1484              	.L108:
 543:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1485              		.loc 1 543 0
 1486 0b50 230054E3 		cmp	r4, #35
 1487 0b54 C600009A 		bls	.L138
 544:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1488              		.loc 1 544 0
 1489 0b58 870087E0 		add	r0, r7, r7, asl #1
 1490 0b5c 806186E0 		add	r6, r6, r0, asl #3
 1491 0b60 94AE9FE5 		ldr	sl, .L211+12
 1492 0b64 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
 545:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1493              		.loc 1 545 0
 1494 0b68 06E0D6E5 		ldrb	lr, [r6, #6]	@ zero_extendqisi2
 544:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1495              		.loc 1 544 0
 1496 0b6c 58C0CAE5 		strb	ip, [sl, #88]
 545:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1497              		.loc 1 545 0
 1498 0b70 59E0CAE5 		strb	lr, [sl, #89]
 1499 0b74 0B0000EA 		b	.L146
 1500              	.L204:
 420:../uvc.c      ****     switch (bRequest)
 1501              		.loc 1 420 0
 1502 0b78 810055E3 		cmp	r5, #129
 1503 0b7c 6A00000A 		beq	.L106
 1504 0b80 1000009A 		bls	.L207
 524:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1505              		.loc 1 524 0
 1506 0b84 230054E3 		cmp	r4, #35
 1507 0b88 AD00009A 		bls	.L135
 525:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1508              		.loc 1 525 0
 1509 0b8c 87A087E0 		add	sl, r7, r7, asl #1
 1510 0b90 8A6186E0 		add	r6, r6, sl, asl #3
 1511 0b94 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 1512 0b98 5CAE9FE5 		ldr	sl, .L211+12
 526:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1513              		.loc 1 526 0
 1514 0b9c 0470D6E5 		ldrb	r7, [r6, #4]	@ zero_extendqisi2
 1515              	.LVL115:
 525:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1516              		.loc 1 525 0
 1517 0ba0 5840CAE5 		strb	r4, [sl, #88]
 526:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1518              		.loc 1 526 0
 1519 0ba4 5970CAE5 		strb	r7, [sl, #89]
 1520              	.L146:
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1521              		.loc 1 602 0
 1522 0ba8 0800A0E1 		mov	r0, r8
 1523 0bac 4C1E9FE5 		ldr	r1, .L211+16
 1524 0bb0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1525              	.LVL116:
 604:../uvc.c      **** 			  break;
 1526              		.loc 1 604 0
 1527 0bb4 FFC0A0E3 		mov	ip, #255
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1528              		.loc 1 602 0
 1529 0bb8 5870DAE5 		ldrb	r7, [sl, #88]	@ zero_extendqisi2
 604:../uvc.c      **** 			  break;
 1530              		.loc 1 604 0
 1531 0bbc 0CE0A0E1 		mov	lr, ip
 1532 0bc0 0C40A0E1 		mov	r4, ip
 1533 0bc4 CDFFFFEA 		b	.L114
 1534              	.LVL117:
 1535              	.L207:
 420:../uvc.c      ****     switch (bRequest)
 1536              		.loc 1 420 0
 1537 0bc8 010055E3 		cmp	r5, #1
 1538 0bcc C3FFFF1A 		bne	.L104
 606:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1539              		.loc 1 606 0
 1540 0bd0 241E9FE5 		ldr	r1, .L211+12
 1541 0bd4 26208DE2 		add	r2, sp, #38
 1542 0bd8 2000A0E3 		mov	r0, #32
 1543 0bdc 581081E2 		add	r1, r1, #88
 1544 0be0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1545              	.LVL118:
 608:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1546              		.loc 1 608 0
 1547 0be4 002050E2 		subs	r2, r0, #0
 1548 0be8 4E03001A 		bne	.L148
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1549              		.loc 1 611 0
 1550 0bec 08CE9FE5 		ldr	ip, .L211+12
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1551              		.loc 1 610 0
 1552 0bf0 040E9FE5 		ldr	r0, .L211+12
 1553              	.LVL119:
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1554              		.loc 1 611 0
 1555 0bf4 59E0DCE5 		ldrb	lr, [ip, #89]	@ zero_extendqisi2
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1556              		.loc 1 613 0
 1557 0bf8 FC2D9FE5 		ldr	r2, .L211+12
 1558              	.LVL120:
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1559              		.loc 1 610 0
 1560 0bfc 5830D0E5 		ldrb	r3, [r0, #88]	@ zero_extendqisi2
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1561              		.loc 1 611 0
 1562 0c00 1CE08DE5 		str	lr, [sp, #28]
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1563              		.loc 1 613 0
 1564 0c04 5AE0D2E5 		ldrb	lr, [r2, #90]	@ zero_extendqisi2
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1565              		.loc 1 610 0
 1566 0c08 14308DE5 		str	r3, [sp, #20]
 1567              	.LVL121:
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1568              		.loc 1 613 0
 1569 0c0c 18E08DE5 		str	lr, [sp, #24]
 1570              	.LVL122:
 617:../uvc.c      **** 				  switch(CtrlID)
 1571              		.loc 1 617 0
 1572 0c10 260054E3 		cmp	r4, #38
 1573 0c14 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1574 0c18 B30200EA 		b	.L149
 1575              	.L165:
 1576 0c1c 2C160000 		.word	.L150
 1577 0c20 68150000 		.word	.L151
 1578 0c24 EC160000 		.word	.L149
 1579 0c28 EC160000 		.word	.L149
 1580 0c2c 04150000 		.word	.L152
 1581 0c30 C4130000 		.word	.L153
 1582 0c34 48130000 		.word	.L154
 1583 0c38 EC160000 		.word	.L149
 1584 0c3c EC160000 		.word	.L149
 1585 0c40 EC160000 		.word	.L149
 1586 0c44 EC160000 		.word	.L149
 1587 0c48 C0120000 		.word	.L155
 1588 0c4c EC160000 		.word	.L149
 1589 0c50 EC160000 		.word	.L149
 1590 0c54 EC160000 		.word	.L149
 1591 0c58 EC160000 		.word	.L149
 1592 0c5c A4180000 		.word	.L156
 1593 0c60 EC160000 		.word	.L149
 1594 0c64 EC160000 		.word	.L149
 1595 0c68 EC160000 		.word	.L149
 1596 0c6c EC160000 		.word	.L149
 1597 0c70 EC160000 		.word	.L149
 1598 0c74 EC160000 		.word	.L149
 1599 0c78 EC160000 		.word	.L149
 1600 0c7c EC160000 		.word	.L149
 1601 0c80 00180000 		.word	.L157
 1602 0c84 64170000 		.word	.L158
 1603 0c88 EC160000 		.word	.L149
 1604 0c8c 54170000 		.word	.L159
 1605 0c90 EC160000 		.word	.L149
 1606 0c94 64120000 		.word	.L160
 1607 0c98 E0110000 		.word	.L161
 1608 0c9c EC160000 		.word	.L149
 1609 0ca0 EC160000 		.word	.L149
 1610 0ca4 EC160000 		.word	.L149
 1611 0ca8 EC160000 		.word	.L149
 1612 0cac 44110000 		.word	.L162
 1613 0cb0 2C110000 		.word	.L163
 1614 0cb4 C8100000 		.word	.L164
 1615              	.LVL123:
 1616              	.L109:
 561:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1617              		.loc 1 561 0
 1618 0cb8 230054E3 		cmp	r4, #35
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1619              		.loc 1 562 0
 1620 0cbc 87708780 		addhi	r7, r7, r7, asl #1
 1621              	.LVL124:
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1622              		.loc 1 568 0
 1623 0cc0 84408490 		addls	r4, r4, r4, asl #1
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1624              		.loc 1 562 0
 1625 0cc4 87618680 		addhi	r6, r6, r7, asl #3
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1626              		.loc 1 568 0
 1627 0cc8 84618690 		addls	r6, r6, r4, asl #3
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1628              		.loc 1 562 0
 1629 0ccc 28AD9F85 		ldrhi	sl, .L211+12
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1630              		.loc 1 568 0
 1631 0cd0 24AD9F95 		ldrls	sl, .L211+12
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1632              		.loc 1 562 0
 1633 0cd4 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 563:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1634              		.loc 1 563 0
 1635 0cd8 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1636              		.loc 1 568 0
 1637 0cdc 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 569:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1638              		.loc 1 569 0
 1639 0ce0 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 570:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1640              		.loc 1 570 0
 1641 0ce4 0030A0E3 		mov	r3, #0
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1642              		.loc 1 568 0
 1643 0ce8 5810CAE5 		strb	r1, [sl, #88]
 569:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1644              		.loc 1 569 0
 1645 0cec 5920CAE5 		strb	r2, [sl, #89]
 570:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1646              		.loc 1 570 0
 1647 0cf0 5A30CAE5 		strb	r3, [sl, #90]
 571:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1648              		.loc 1 571 0
 1649 0cf4 5B30CAE5 		strb	r3, [sl, #91]
 1650 0cf8 AAFFFFEA 		b	.L146
 1651              	.LVL125:
 1652              	.L110:
 424:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1653              		.loc 1 424 0
 1654 0cfc F84C9FE5 		ldr	r4, .L211+12
 425:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1655              		.loc 1 425 0
 1656 0d00 00C0A0E3 		mov	ip, #0
 1657 0d04 59C0C4E5 		strb	ip, [r4, #89]
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1658              		.loc 1 426 0
 1659 0d08 581084E2 		add	r1, r4, #88
 424:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1660              		.loc 1 424 0
 1661 0d0c 5880C4E5 		strb	r8, [r4, #88]
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1662              		.loc 1 426 0
 1663 0d10 0200A0E3 		mov	r0, #2
 1664 0d14 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1665              	.LVL126:
 428:../uvc.c      **** 			  break;
 1666              		.loc 1 428 0
 1667 0d18 FFC0A0E3 		mov	ip, #255
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1668              		.loc 1 426 0
 1669 0d1c 5870D4E5 		ldrb	r7, [r4, #88]	@ zero_extendqisi2
 1670              	.LVL127:
 428:../uvc.c      **** 			  break;
 1671              		.loc 1 428 0
 1672 0d20 0CE0A0E1 		mov	lr, ip
 1673 0d24 0C40A0E1 		mov	r4, ip
 1674 0d28 74FFFFEA 		b	.L114
 1675              	.LVL128:
 1676              	.L106:
 431:../uvc.c      **** 			 switch(CtrlID)
 1677              		.loc 1 431 0
 1678 0d2c 011044E2 		sub	r1, r4, #1
 1679 0d30 250051E3 		cmp	r1, #37
 1680 0d34 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1681 0d38 D00000EA 		b	.L115
 1682              	.L123:
 1683 0d3c 50100000 		.word	.L116
 1684 0d40 80100000 		.word	.L115
 1685 0d44 80100000 		.word	.L115
 1686 0d48 80100000 		.word	.L115
 1687 0d4c 30100000 		.word	.L117
 1688 0d50 80100000 		.word	.L115
 1689 0d54 80100000 		.word	.L115
 1690 0d58 80100000 		.word	.L115
 1691 0d5c 80100000 		.word	.L115
 1692 0d60 80100000 		.word	.L115
 1693 0d64 A4100000 		.word	.L118
 1694 0d68 80100000 		.word	.L115
 1695 0d6c 80100000 		.word	.L115
 1696 0d70 80100000 		.word	.L115
 1697 0d74 80100000 		.word	.L115
 1698 0d78 80100000 		.word	.L115
 1699 0d7c 80100000 		.word	.L115
 1700 0d80 80100000 		.word	.L115
 1701 0d84 80100000 		.word	.L115
 1702 0d88 80100000 		.word	.L115
 1703 0d8c 80100000 		.word	.L115
 1704 0d90 80100000 		.word	.L115
 1705 0d94 80100000 		.word	.L115
 1706 0d98 80100000 		.word	.L115
 1707 0d9c F40F0000 		.word	.L119
 1708 0da0 80100000 		.word	.L115
 1709 0da4 80100000 		.word	.L115
 1710 0da8 C80F0000 		.word	.L120
 1711 0dac 80100000 		.word	.L115
 1712 0db0 80100000 		.word	.L115
 1713 0db4 2C0F0000 		.word	.L121
 1714 0db8 80100000 		.word	.L115
 1715 0dbc 80100000 		.word	.L115
 1716 0dc0 80100000 		.word	.L115
 1717 0dc4 80100000 		.word	.L115
 1718 0dc8 F00E0000 		.word	.L122
 1719 0dcc F00E0000 		.word	.L122
 1720 0dd0 F00E0000 		.word	.L122
 1721              	.L205:
 588:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1722              		.loc 1 588 0
 1723 0dd4 230054E3 		cmp	r4, #35
 1724 0dd8 3100009A 		bls	.L145
 589:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1725              		.loc 1 589 0
 1726 0ddc 877087E0 		add	r7, r7, r7, asl #1
 1727              	.LVL129:
 1728 0de0 876186E0 		add	r6, r6, r7, asl #3
 1729 0de4 10AC9FE5 		ldr	sl, .L211+12
 1730 0de8 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 590:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1731              		.loc 1 590 0
 1732 0dec 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 589:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1733              		.loc 1 589 0
 1734 0df0 5820CAE5 		strb	r2, [sl, #88]
 590:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1735              		.loc 1 590 0
 1736 0df4 5910CAE5 		strb	r1, [sl, #89]
 1737 0df8 6AFFFFEA 		b	.L146
 1738              	.LVL130:
 1739              	.L111:
 577:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1740              		.loc 1 577 0
 1741 0dfc 230054E3 		cmp	r4, #35
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1742              		.loc 1 578 0
 1743 0e00 87708780 		addhi	r7, r7, r7, asl #1
 1744              	.LVL131:
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1745              		.loc 1 581 0
 1746 0e04 84408490 		addls	r4, r4, r4, asl #1
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1747              		.loc 1 578 0
 1748 0e08 87618680 		addhi	r6, r6, r7, asl #3
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1749              		.loc 1 581 0
 1750 0e0c 84618690 		addls	r6, r6, r4, asl #3
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1751              		.loc 1 578 0
 1752 0e10 E48B9F85 		ldrhi	r8, .L211+12
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1753              		.loc 1 581 0
 1754 0e14 E08B9F95 		ldrls	r8, .L211+12
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1755              		.loc 1 578 0
 1756 0e18 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1757              		.loc 1 581 0
 1758 0e1c 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1759              		.loc 1 583 0
 1760 0e20 0100A0E3 		mov	r0, #1
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1761              		.loc 1 581 0
 1762 0e24 5830C8E5 		strb	r3, [r8, #88]
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1763              		.loc 1 583 0
 1764 0e28 D01B9FE5 		ldr	r1, .L211+16
 1765 0e2c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1766              	.LVL132:
 586:../uvc.c      **** 			  break;
 1767              		.loc 1 586 0
 1768 0e30 FFC0A0E3 		mov	ip, #255
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1769              		.loc 1 583 0
 1770 0e34 5870D8E5 		ldrb	r7, [r8, #88]	@ zero_extendqisi2
 586:../uvc.c      **** 			  break;
 1771              		.loc 1 586 0
 1772 0e38 0CE0A0E1 		mov	lr, ip
 1773 0e3c 0C40A0E1 		mov	r4, ip
 1774 0e40 2EFFFFEA 		b	.L114
 1775              	.LVL133:
 1776              	.L135:
 529:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1777              		.loc 1 529 0
 1778 0e44 0B0054E3 		cmp	r4, #11
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1779              		.loc 1 536 0
 1780 0e48 84408410 		addne	r4, r4, r4, asl #1
 1781 0e4c 84618610 		addne	r6, r6, r4, asl #3
 1782 0e50 A4AB9F15 		ldrne	sl, .L211+12
 530:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1783              		.loc 1 530 0
 1784 0e54 A0AB9F05 		ldreq	sl, .L211+12
 1785 0e58 A43B9F05 		ldreq	r3, .L211+20
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1786              		.loc 1 536 0
 1787 0e5c 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 537:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1788              		.loc 1 537 0
 1789 0e60 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 530:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1790              		.loc 1 530 0
 1791 0e64 58308A05 		streq	r3, [sl, #88]
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1792              		.loc 1 536 0
 1793 0e68 5820CA15 		strneb	r2, [sl, #88]
 537:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1794              		.loc 1 537 0
 1795 0e6c 5930CA15 		strneb	r3, [sl, #89]
 1796 0e70 4CFFFFEA 		b	.L146
 1797              	.L138:
 547:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1798              		.loc 1 547 0
 1799 0e74 0B0054E3 		cmp	r4, #11
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1800              		.loc 1 554 0
 1801 0e78 84408410 		addne	r4, r4, r4, asl #1
 1802 0e7c 84618610 		addne	r6, r6, r4, asl #3
 1803 0e80 74AB9F15 		ldrne	sl, .L211+12
 548:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1804              		.loc 1 548 0
 1805 0e84 70AB9F05 		ldreq	sl, .L211+12
 1806 0e88 783B9F05 		ldreq	r3, .L211+24
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1807              		.loc 1 554 0
 1808 0e8c 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 555:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1809              		.loc 1 555 0
 1810 0e90 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 548:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1811              		.loc 1 548 0
 1812 0e94 58308A05 		streq	r3, [sl, #88]
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1813              		.loc 1 554 0
 1814 0e98 5820CA15 		strneb	r2, [sl, #88]
 555:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1815              		.loc 1 555 0
 1816 0e9c 5930CA15 		strneb	r3, [sl, #89]
 1817 0ea0 40FFFFEA 		b	.L146
 1818              	.L145:
 593:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1819              		.loc 1 593 0
 1820 0ea4 0B0054E3 		cmp	r4, #11
 1821 0ea8 0700000A 		beq	.L208
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1822              		.loc 1 599 0
 1823 0eac 84A084E0 		add	sl, r4, r4, asl #1
 1824 0eb0 8A6186E0 		add	r6, r6, sl, asl #3
 1825 0eb4 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1826 0eb8 3CAB9FE5 		ldr	sl, .L211+12
 600:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1827              		.loc 1 600 0
 1828 0ebc 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1829              		.loc 1 599 0
 1830 0ec0 5830CAE5 		strb	r3, [sl, #88]
 600:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1831              		.loc 1 600 0
 1832 0ec4 5900CAE5 		strb	r0, [sl, #89]
 1833 0ec8 36FFFFEA 		b	.L146
 1834              	.L208:
 594:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1835              		.loc 1 594 0
 1836 0ecc 28AB9FE5 		ldr	sl, .L211+12
 1837 0ed0 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 596:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1838              		.loc 1 596 0
 1839 0ed4 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 595:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1840              		.loc 1 595 0
 1841 0ed8 0040A0E3 		mov	r4, #0
 594:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1842              		.loc 1 594 0
 1843 0edc 58C0CAE5 		strb	ip, [sl, #88]
 595:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1844              		.loc 1 595 0
 1845 0ee0 5940CAE5 		strb	r4, [sl, #89]
 596:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1846              		.loc 1 596 0
 1847 0ee4 5AE0CAE5 		strb	lr, [sl, #90]
 597:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1848              		.loc 1 597 0
 1849 0ee8 5B40CAE5 		strb	r4, [sl, #91]
 1850 0eec 2DFFFFEA 		b	.L146
 1851              	.L122:
 437:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1852              		.loc 1 437 0
 1853 0ef0 877087E0 		add	r7, r7, r7, asl #1
 1854              	.LVL134:
 1855 0ef4 876186E0 		add	r6, r6, r7, asl #3
 1856 0ef8 FCEA9FE5 		ldr	lr, .L211+12
 1857 0efc 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 438:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1858              		.loc 1 438 0
 1859 0f00 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 437:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1860              		.loc 1 437 0
 1861 0f04 5840CEE5 		strb	r4, [lr, #88]
 438:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1862              		.loc 1 438 0
 1863 0f08 5960CEE5 		strb	r6, [lr, #89]
 1864              	.LVL135:
 1865              	.L126:
 517:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1866              		.loc 1 517 0
 1867 0f0c 0800A0E1 		mov	r0, r8
 1868 0f10 E81A9FE5 		ldr	r1, .L211+16
 1869 0f14 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 522:../uvc.c      **** 			  break;
 1870              		.loc 1 522 0
 1871 0f18 FFE0A0E3 		mov	lr, #255
 517:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1872              		.loc 1 517 0
 1873 0f1c 0470A0E1 		mov	r7, r4
 1874 0f20 06C0A0E1 		mov	ip, r6
 522:../uvc.c      **** 			  break;
 1875              		.loc 1 522 0
 1876 0f24 0E40A0E1 		mov	r4, lr
 1877              	.LVL136:
 1878 0f28 F4FEFFEA 		b	.L114
 1879              	.LVL137:
 1880              	.L121:
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1881              		.loc 1 458 0 discriminator 1
 1882 0f2c 000058E3 		cmp	r8, #0
 1883 0f30 A702000A 		beq	.L199
 456:../uvc.c      **** 					 break;
 1884              		.loc 1 456 0
 1885 0f34 28E1A0E1 		mov	lr, r8, lsr #2
 1886 0f38 00005EE3 		cmp	lr, #0
 1887 0f3c 03005813 		cmpne	r8, #3
 1888 0f40 0020A083 		movhi	r2, #0
 1889 0f44 0120A093 		movls	r2, #1
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1890              		.loc 1 390 0
 1891 0f48 0E31A0E1 		mov	r3, lr, asl #2
 456:../uvc.c      **** 					 break;
 1892              		.loc 1 456 0
 1893 0f4c A402009A 		bls	.L187
 1894 0f50 A81A9FE5 		ldr	r1, .L211+16
 1895 0f54 0C0041E2 		sub	r0, r1, #12
 1896              	.LVL138:
 1897              	.L130:
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1898              		.loc 1 459 0 discriminator 2
 1899 0f58 044090E4 		ldr	r4, [r0], #4
 1900 0f5c 01C082E2 		add	ip, r2, #1
 1901 0f60 FF200CE2 		and	r2, ip, #255
 1902 0f64 02005EE1 		cmp	lr, r2
 1903 0f68 044081E4 		str	r4, [r1], #4
 1904 0f6c F9FFFF8A 		bhi	.L130
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1905              		.loc 1 459 0 is_stmt 0
 1906 0f70 030058E1 		cmp	r8, r3
 1907 0f74 800A9F15 		ldrne	r0, .L211+12
 1908 0f78 9502000A 		beq	.L199
 1909              	.L191:
 1910 0f7c 03E080E0 		add	lr, r0, r3
 1911 0f80 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1912              		.loc 1 458 0 is_stmt 1
 1913 0f84 016083E2 		add	r6, r3, #1
 1914 0f88 FF3006E2 		and	r3, r6, #255
 1915              	.LVL139:
 1916 0f8c 030058E1 		cmp	r8, r3
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1917              		.loc 1 459 0
 1918 0f90 5810CEE5 		strb	r1, [lr, #88]
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1919              		.loc 1 458 0
 1920 0f94 F8FFFF8A 		bhi	.L191
 1921              	.LVL140:
 1922              	.L125:
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1923              		.loc 1 468 0
 1924 0f98 5770D0E5 		ldrb	r7, [r0, #87]	@ zero_extendqisi2
 1925              	.LVL141:
 461:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1926              		.loc 1 461 0
 1927 0f9c 583A9FE5 		ldr	r3, .L211+12
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1928              		.loc 1 468 0
 1929 0fa0 FF0057E3 		cmp	r7, #255
 461:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1930              		.loc 1 461 0
 1931 0fa4 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1932              	.LVL142:
 462:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1933              		.loc 1 462 0
 1934 0fa8 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 1935              	.LVL143:
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1936              		.loc 1 468 0
 1937 0fac D6FFFF0A 		beq	.L126
 470:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1938              		.loc 1 470 0
 1939 0fb0 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1940 0fb4 501A9FE5 		ldr	r1, .L211+28
 1941 0fb8 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1942 0fbc 0400A0E3 		mov	r0, #4
 1943 0fc0 FEFFFFEB 		bl	CyU3PDebugPrint
 1944 0fc4 D0FFFFEA 		b	.L126
 1945              	.LVL144:
 1946              	.L120:
 444:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 1947              		.loc 1 444 0
 1948 0fc8 2D34D6E5 		ldrb	r3, [r6, #1069]	@ zero_extendqisi2
 1949              	.LVL145:
 446:../uvc.c      **** 						if(sendData >= 3){
 1950              		.loc 1 446 0
 1951 0fcc 020053E3 		cmp	r3, #2
 1952 0fd0 04308392 		addls	r3, r3, #4
 1953              	.LVL146:
 1954 0fd4 FF400392 		andls	r4, r3, #255
 1955 0fd8 7402008A 		bhi	.L209
 1956              	.L134:
 1957              	.LVL147:
 491:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 1958              		.loc 1 491 0
 1959 0fdc 183A9FE5 		ldr	r3, .L211+12
 492:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1960              		.loc 1 492 0
 1961 0fe0 0010A0E3 		mov	r1, #0
 491:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 1962              		.loc 1 491 0
 1963 0fe4 5840C3E5 		strb	r4, [r3, #88]
 492:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1964              		.loc 1 492 0
 1965 0fe8 5910C3E5 		strb	r1, [r3, #89]
 1966              	.LVL148:
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 1967              		.loc 1 408 0
 1968 0fec FF60A0E3 		mov	r6, #255
 494:../uvc.c      **** 					 break;
 1969              		.loc 1 494 0
 1970 0ff0 C5FFFFEA 		b	.L126
 1971              	.LVL149:
 1972              	.L119:
 474:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1973              		.loc 1 474 0
 1974 0ff4 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 1975 0ff8 FCC99FE5 		ldr	ip, .L211+12
 476:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1976              		.loc 1 476 0
 1977 0ffc E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 475:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1978              		.loc 1 475 0
 1979 1000 00E0A0E3 		mov	lr, #0
 474:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1980              		.loc 1 474 0
 1981 1004 5840CCE5 		strb	r4, [ip, #88]
 475:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1982              		.loc 1 475 0
 1983 1008 59E0CCE5 		strb	lr, [ip, #89]
 476:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1984              		.loc 1 476 0
 1985 100c 5A60CCE5 		strb	r6, [ip, #90]
 477:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1986              		.loc 1 477 0
 1987 1010 5BE0CCE5 		strb	lr, [ip, #91]
 1988              	.LVL150:
 480:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 1989              		.loc 1 480 0
 1990 1014 F4199FE5 		ldr	r1, .L211+32
 1991 1018 0420A0E1 		mov	r2, r4
 1992 101c 0E30A0E1 		mov	r3, lr
 1993 1020 0400A0E3 		mov	r0, #4
 1994 1024 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 1995 1028 FEFFFFEB 		bl	CyU3PDebugPrint
 481:../uvc.c      **** 					 break;
 1996              		.loc 1 481 0
 1997 102c B6FFFFEA 		b	.L126
 1998              	.LVL151:
 1999              	.L117:
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2000              		.loc 1 497 0
 2001 1030 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 2002 1034 C0799FE5 		ldr	r7, .L211+12
 2003              	.LVL152:
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2004              		.loc 1 498 0
 2005 1038 0060A0E3 		mov	r6, #0
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2006              		.loc 1 497 0
 2007 103c 804024E2 		eor	r4, r4, #128
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2008              		.loc 1 498 0
 2009 1040 5960C7E5 		strb	r6, [r7, #89]
 2010              	.LVL153:
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2011              		.loc 1 497 0
 2012 1044 5840C7E5 		strb	r4, [r7, #88]
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2013              		.loc 1 408 0
 2014 1048 FF60A0E3 		mov	r6, #255
 500:../uvc.c      **** 					 break;
 2015              		.loc 1 500 0
 2016 104c AEFFFFEA 		b	.L126
 2017              	.LVL154:
 2018              	.L116:
 486:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2019              		.loc 1 486 0
 2020 1050 A601D6E5 		ldrb	r0, [r6, #422]	@ zero_extendqisi2
 484:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2021              		.loc 1 484 0
 2022 1054 A521D6E5 		ldrb	r2, [r6, #421]	@ zero_extendqisi2
 2023              	.LVL155:
 486:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2024              		.loc 1 486 0
 2025 1058 020010E3 		tst	r0, #2
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2026              		.loc 1 489 0
 2027 105c 2221A001 		moveq	r2, r2, lsr #2
 2028              	.LVL156:
 2029 1060 822CE001 		mvneq	r2, r2, asl #25
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2030              		.loc 1 487 0
 2031 1064 0003A011 		movne	r0, r0, asl #6
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2032              		.loc 1 489 0
 2033 1068 A22CE001 		mvneq	r2, r2, lsr #25
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2034              		.loc 1 487 0
 2035 106c 40400012 		andne	r4, r0, #64
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2036              		.loc 1 489 0
 2037 1070 00038201 		orreq	r0, r2, r0, asl #6
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2038              		.loc 1 487 0
 2039 1074 22418411 		orrne	r4, r4, r2, lsr #2
 2040              	.LVL157:
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2041              		.loc 1 489 0
 2042 1078 FF400002 		andeq	r4, r0, #255
 2043              	.LVL158:
 2044 107c D6FFFFEA 		b	.L134
 2045              	.LVL159:
 2046              	.L115:
 511:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2047              		.loc 1 511 0
 2048 1080 843084E0 		add	r3, r4, r4, asl #1
 2049 1084 831186E0 		add	r1, r6, r3, asl #3
 2050 1088 6C299FE5 		ldr	r2, .L211+12
 2051 108c 8D41D1E5 		ldrb	r4, [r1, #397]	@ zero_extendqisi2
 512:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2052              		.loc 1 512 0
 2053 1090 0000A0E3 		mov	r0, #0
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2054              		.loc 1 408 0
 2055 1094 FF60A0E3 		mov	r6, #255
 511:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2056              		.loc 1 511 0
 2057 1098 5840C2E5 		strb	r4, [r2, #88]
 512:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2058              		.loc 1 512 0
 2059 109c 5900C2E5 		strb	r0, [r2, #89]
 2060              	.LVL160:
 514:../uvc.c      **** 					 break;
 2061              		.loc 1 514 0
 2062 10a0 99FFFFEA 		b	.L126
 2063              	.LVL161:
 2064              	.L118:
 502:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2065              		.loc 1 502 0
 2066 10a4 50C99FE5 		ldr	ip, .L211+12
 2067 10a8 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 504:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2068              		.loc 1 504 0
 2069 10ac 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 503:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2070              		.loc 1 503 0
 2071 10b0 00E0A0E3 		mov	lr, #0
 502:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2072              		.loc 1 502 0
 2073 10b4 5840CCE5 		strb	r4, [ip, #88]
 503:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2074              		.loc 1 503 0
 2075 10b8 59E0CCE5 		strb	lr, [ip, #89]
 504:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2076              		.loc 1 504 0
 2077 10bc 5A60CCE5 		strb	r6, [ip, #90]
 505:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2078              		.loc 1 505 0
 2079 10c0 5BE0CCE5 		strb	lr, [ip, #91]
 2080              	.LVL162:
 508:../uvc.c      **** 					 break;
 2081              		.loc 1 508 0
 2082 10c4 90FFFFEA 		b	.L126
 2083              	.LVL163:
 2084              	.L164:
 761:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2085              		.loc 1 761 0
 2086 10c8 44499FE5 		ldr	r4, .L211+36
 2087 10cc 0010E0E3 		mvn	r1, #0
 2088 10d0 1C0094E5 		ldr	r0, [r4, #28]
 2089 10d4 FEFFFFEB 		bl	_txe_mutex_get
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2090              		.loc 1 762 0
 2091 10d8 2610A0E3 		mov	r1, #38
 2092              	.L203:
 2093 10dc 14C09DE5 		ldr	ip, [sp, #20]
 2094 10e0 00E0A0E3 		mov	lr, #0
 2095 10e4 0A30A0E1 		mov	r3, sl
 2096 10e8 0920A0E1 		mov	r2, r9
 2097 10ec 0400A0E1 		mov	r0, r4
 2098 10f0 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2099 10f4 FEFFFFEB 		bl	cmdSet
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2100              		.loc 1 763 0
 2101 10f8 1C0094E5 		ldr	r0, [r4, #28]
 2102 10fc FEFFFFEB 		bl	_txe_mutex_put
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2103              		.loc 1 764 0
 2104 1100 14109DE5 		ldr	r1, [sp, #20]
 2105 1104 873087E0 		add	r3, r7, r7, asl #1
 2106 1108 836186E0 		add	r6, r6, r3, asl #3
 766:../uvc.c      **** 							 break;
 2107              		.loc 1 766 0
 2108 110c FFC0A0E3 		mov	ip, #255
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2109              		.loc 1 765 0
 2110 1110 0100A0E3 		mov	r0, #1
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2111              		.loc 1 764 0
 2112 1114 0D10C6E5 		strb	r1, [r6, #13]
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2113              		.loc 1 765 0
 2114 1118 1000C6E5 		strb	r0, [r6, #16]
 2115 111c 0140A0E1 		mov	r4, r1
 2116 1120 18E09DE5 		ldr	lr, [sp, #24]
 766:../uvc.c      **** 							 break;
 2117              		.loc 1 766 0
 2118 1124 0C70A0E1 		mov	r7, ip
 2119              	.LVL164:
 2120 1128 74FEFFEA 		b	.L114
 2121              	.LVL165:
 2122              	.L163:
 753:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2123              		.loc 1 753 0
 2124 112c E0489FE5 		ldr	r4, .L211+36
 2125 1130 0010E0E3 		mvn	r1, #0
 2126 1134 1C0094E5 		ldr	r0, [r4, #28]
 2127 1138 FEFFFFEB 		bl	_txe_mutex_get
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2128              		.loc 1 754 0
 2129 113c 2510A0E3 		mov	r1, #37
 2130 1140 E5FFFFEA 		b	.L203
 2131              	.LVL166:
 2132              	.L162:
 739:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2133              		.loc 1 739 0
 2134 1144 C8489FE5 		ldr	r4, .L211+36
 2135 1148 0010E0E3 		mvn	r1, #0
 2136 114c 1C0094E5 		ldr	r0, [r4, #28]
 2137 1150 FEFFFFEB 		bl	_txe_mutex_get
 738:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2138              		.loc 1 738 0
 2139 1154 14209DE5 		ldr	r2, [sp, #20]
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2140              		.loc 1 741 0
 2141 1158 2410A0E3 		mov	r1, #36
 738:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2142              		.loc 1 738 0
 2143 115c 7F8002E2 		and	r8, r2, #127
 2144 1160 18808DE5 		str	r8, [sp, #24]
 2145              	.LVL167:
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2146              		.loc 1 741 0
 2147 1164 18C09DE5 		ldr	ip, [sp, #24]
 2148 1168 0920A0E1 		mov	r2, r9
 2149 116c 0A30A0E1 		mov	r3, sl
 2150 1170 0400A0E1 		mov	r0, r4
 2151 1174 00C08DE5 		str	ip, [sp, #0]
 2152 1178 00C0A0E3 		mov	ip, #0
 2153 117c 04C08DE5 		str	ip, [sp, #4]
 2154 1180 FEFFFFEB 		bl	cmdSet
 2155              	.LVL168:
 743:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2156              		.loc 1 743 0
 2157 1184 1CE09DE5 		ldr	lr, [sp, #28]
 2158 1188 0180A0E3 		mov	r8, #1
 2159 118c 2410A0E3 		mov	r1, #36
 2160 1190 0B20A0E1 		mov	r2, fp
 2161 1194 0A30A0E1 		mov	r3, sl
 2162 1198 0400A0E1 		mov	r0, r4
 2163 119c 00E08DE5 		str	lr, [sp, #0]
 2164 11a0 04808DE5 		str	r8, [sp, #4]
 2165 11a4 FEFFFFEB 		bl	cmdSet
 744:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2166              		.loc 1 744 0
 2167 11a8 1C0094E5 		ldr	r0, [r4, #28]
 2168 11ac FEFFFFEB 		bl	_txe_mutex_put
 2169              	.LVL169:
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2170              		.loc 1 747 0
 2171 11b0 87C087E0 		add	ip, r7, r7, asl #1
 2172 11b4 18409DE5 		ldr	r4, [sp, #24]
 748:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2173              		.loc 1 748 0
 2174 11b8 1C709DE5 		ldr	r7, [sp, #28]
 2175              	.LVL170:
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2176              		.loc 1 747 0
 2177 11bc 8C6186E0 		add	r6, r6, ip, asl #3
 750:../uvc.c      **** 							 break;
 2178              		.loc 1 750 0
 2179 11c0 FFC0A0E3 		mov	ip, #255
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2180              		.loc 1 747 0
 2181 11c4 0D40C6E5 		strb	r4, [r6, #13]
 748:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2182              		.loc 1 748 0
 2183 11c8 0E70C6E5 		strb	r7, [r6, #14]
 749:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2184              		.loc 1 749 0
 2185 11cc 07E0A0E1 		mov	lr, r7
 2186 11d0 1080C6E5 		strb	r8, [r6, #16]
 2187 11d4 14409DE5 		ldr	r4, [sp, #20]
 750:../uvc.c      **** 							 break;
 2188              		.loc 1 750 0
 2189 11d8 0C70A0E1 		mov	r7, ip
 2190 11dc 47FEFFEA 		b	.L114
 2191              	.LVL171:
 2192              	.L161:
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2193              		.loc 1 710 0 discriminator 1
 2194 11e0 000058E3 		cmp	r8, #0
 2195 11e4 1800000A 		beq	.L167
 708:../uvc.c      **** 							 break;
 2196              		.loc 1 708 0
 2197 11e8 28E1A0E1 		mov	lr, r8, lsr #2
 2198 11ec 00005EE3 		cmp	lr, #0
 2199 11f0 03005813 		cmpne	r8, #3
 2200 11f4 0020A083 		movhi	r2, #0
 2201 11f8 0120A093 		movls	r2, #1
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2202              		.loc 1 390 0
 2203 11fc 0E31A0E1 		mov	r3, lr, asl #2
 708:../uvc.c      **** 							 break;
 2204              		.loc 1 708 0
 2205 1200 F501009A 		bls	.L188
 2206 1204 0C189FE5 		ldr	r1, .L211+40
 2207 1208 0C0081E2 		add	r0, r1, #12
 2208              	.LVL172:
 2209              	.L178:
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2210              		.loc 1 711 0 discriminator 2
 2211 120c 047090E4 		ldr	r7, [r0], #4
 2212 1210 012082E2 		add	r2, r2, #1
 2213 1214 FF2002E2 		and	r2, r2, #255
 2214 1218 02005EE1 		cmp	lr, r2
 2215 121c 047081E4 		str	r7, [r1], #4
 2216 1220 F9FFFF8A 		bhi	.L178
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2217              		.loc 1 711 0 is_stmt 0
 2218 1224 030058E1 		cmp	r8, r3
 2219 1228 0700000A 		beq	.L167
 2220              	.L192:
 2221 122c C8E79FE5 		ldr	lr, .L211+12
 2222 1230 03008EE0 		add	r0, lr, r3
 2223 1234 5810D0E5 		ldrb	r1, [r0, #88]	@ zero_extendqisi2
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2224              		.loc 1 710 0 is_stmt 1
 2225 1238 013083E2 		add	r3, r3, #1
 2226 123c FF3003E2 		and	r3, r3, #255
 2227              	.LVL173:
 2228 1240 030058E1 		cmp	r8, r3
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2229              		.loc 1 711 0
 2230 1244 4C10C0E5 		strb	r1, [r0, #76]
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2231              		.loc 1 710 0
 2232 1248 F7FFFF8A 		bhi	.L192
 2233              	.LVL174:
 2234              	.L167:
 713:../uvc.c      **** 					 		I2CCmdHandler();
 2235              		.loc 1 713 0
 2236 124c FEFFFFEB 		bl	I2CCmdHandler
 714:../uvc.c      **** 							 break;
 2237              		.loc 1 714 0
 2238 1250 FFC0A0E3 		mov	ip, #255
 713:../uvc.c      **** 					 		I2CCmdHandler();
 2239              		.loc 1 713 0
 2240 1254 14409DE5 		ldr	r4, [sp, #20]
 2241 1258 18E09DE5 		ldr	lr, [sp, #24]
 714:../uvc.c      **** 							 break;
 2242              		.loc 1 714 0
 2243 125c 0C70A0E1 		mov	r7, ip
 2244 1260 26FEFFEA 		b	.L114
 2245              	.LVL175:
 2246              	.L160:
 704:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2247              		.loc 1 704 0
 2248 1264 A8779FE5 		ldr	r7, .L211+36
 2249              	.LVL176:
 2250 1268 0010E0E3 		mvn	r1, #0
 2251 126c 1C0097E5 		ldr	r0, [r7, #28]
 2252 1270 FEFFFFEB 		bl	_txe_mutex_get
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2253              		.loc 1 705 0
 2254 1274 14409DE5 		ldr	r4, [sp, #20]
 2255 1278 00E0A0E3 		mov	lr, #0
 2256 127c 01C074E2 		rsbs	ip, r4, #1
 2257 1280 00C0A033 		movcc	ip, #0
 2258 1284 1E10A0E3 		mov	r1, #30
 2259 1288 0920A0E1 		mov	r2, r9
 2260 128c 0A30A0E1 		mov	r3, sl
 2261 1290 0700A0E1 		mov	r0, r7
 2262 1294 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2263 1298 FEFFFFEB 		bl	cmdSet
 706:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2264              		.loc 1 706 0
 2265 129c 1C0097E5 		ldr	r0, [r7, #28]
 2266 12a0 FEFFFFEB 		bl	_txe_mutex_put
 708:../uvc.c      **** 							 break;
 2267              		.loc 1 708 0
 2268 12a4 FFC0A0E3 		mov	ip, #255
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2269              		.loc 1 707 0
 2270 12a8 0100A0E3 		mov	r0, #1
 2271 12ac 6004C6E5 		strb	r0, [r6, #1120]
 2272 12b0 14409DE5 		ldr	r4, [sp, #20]
 2273 12b4 18E09DE5 		ldr	lr, [sp, #24]
 708:../uvc.c      **** 							 break;
 2274              		.loc 1 708 0
 2275 12b8 0C70A0E1 		mov	r7, ip
 2276 12bc 0FFEFFEA 		b	.L114
 2277              	.LVL177:
 2278              	.L155:
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2279              		.loc 1 827 0
 2280 12c0 4C479FE5 		ldr	r4, .L211+36
 2281 12c4 0010E0E3 		mvn	r1, #0
 2282 12c8 1C0094E5 		ldr	r0, [r4, #28]
 2283 12cc FEFFFFEB 		bl	_txe_mutex_get
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2284              		.loc 1 828 0
 2285 12d0 14C09DE5 		ldr	ip, [sp, #20]
 2286 12d4 0B10A0E3 		mov	r1, #11
 2287 12d8 0920A0E1 		mov	r2, r9
 2288 12dc 0A30A0E1 		mov	r3, sl
 2289 12e0 0400A0E1 		mov	r0, r4
 2290 12e4 00C08DE5 		str	ip, [sp, #0]
 2291 12e8 00C0A0E3 		mov	ip, #0
 2292 12ec 04C08DE5 		str	ip, [sp, #4]
 2293 12f0 FEFFFFEB 		bl	cmdSet
 2294              	.LVL178:
 830:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2295              		.loc 1 830 0
 2296 12f4 18E09DE5 		ldr	lr, [sp, #24]
 2297 12f8 0170A0E3 		mov	r7, #1
 2298              	.LVL179:
 2299 12fc 0B10A0E3 		mov	r1, #11
 2300 1300 0B20A0E1 		mov	r2, fp
 2301 1304 0A30A0E1 		mov	r3, sl
 2302 1308 0400A0E1 		mov	r0, r4
 2303 130c 00E08DE5 		str	lr, [sp, #0]
 2304 1310 04708DE5 		str	r7, [sp, #4]
 2305 1314 FEFFFFEB 		bl	cmdSet
 831:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2306              		.loc 1 831 0
 2307 1318 1C0094E5 		ldr	r0, [r4, #28]
 2308 131c FEFFFFEB 		bl	_txe_mutex_put
 833:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2309              		.loc 1 833 0
 2310 1320 14109DE5 		ldr	r1, [sp, #20]
 834:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2311              		.loc 1 834 0
 2312 1324 18209DE5 		ldr	r2, [sp, #24]
 836:../uvc.c      **** 							 break;
 2313              		.loc 1 836 0
 2314 1328 FFC0A0E3 		mov	ip, #255
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2315              		.loc 1 835 0
 2316 132c 9872C6E5 		strb	r7, [r6, #664]
 833:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2317              		.loc 1 833 0
 2318 1330 8C14C6E5 		strb	r1, [r6, #1164]
 834:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2319              		.loc 1 834 0
 2320 1334 8E24C6E5 		strb	r2, [r6, #1166]
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2321              		.loc 1 835 0
 2322 1338 0140A0E1 		mov	r4, r1
 2323 133c 02E0A0E1 		mov	lr, r2
 836:../uvc.c      **** 							 break;
 2324              		.loc 1 836 0
 2325 1340 0C70A0E1 		mov	r7, ip
 2326 1344 EDFDFFEA 		b	.L114
 2327              	.LVL180:
 2328              	.L154:
 813:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2329              		.loc 1 813 0
 2330 1348 C4469FE5 		ldr	r4, .L211+36
 2331 134c 0010E0E3 		mvn	r1, #0
 2332 1350 1C0094E5 		ldr	r0, [r4, #28]
 2333 1354 FEFFFFEB 		bl	_txe_mutex_get
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2334              		.loc 1 814 0
 2335 1358 14C09DE5 		ldr	ip, [sp, #20]
 2336 135c 0610A0E3 		mov	r1, #6
 2337 1360 0920A0E1 		mov	r2, r9
 2338 1364 0A30A0E1 		mov	r3, sl
 2339 1368 0400A0E1 		mov	r0, r4
 2340 136c 00C08DE5 		str	ip, [sp, #0]
 2341 1370 00C0A0E3 		mov	ip, #0
 2342 1374 04C08DE5 		str	ip, [sp, #4]
 2343 1378 FEFFFFEB 		bl	cmdSet
 2344              	.LVL181:
 816:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2345              		.loc 1 816 0
 2346 137c 14E09DE5 		ldr	lr, [sp, #20]
 2347 1380 0170A0E3 		mov	r7, #1
 2348              	.LVL182:
 2349 1384 0610A0E3 		mov	r1, #6
 2350 1388 0B20A0E1 		mov	r2, fp
 2351 138c 0A30A0E1 		mov	r3, sl
 2352 1390 0400A0E1 		mov	r0, r4
 2353 1394 00E08DE5 		str	lr, [sp, #0]
 2354 1398 04708DE5 		str	r7, [sp, #4]
 2355 139c FEFFFFEB 		bl	cmdSet
 817:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2356              		.loc 1 817 0
 2357 13a0 1C0094E5 		ldr	r0, [r4, #28]
 2358 13a4 FEFFFFEB 		bl	_txe_mutex_put
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2359              		.loc 1 818 0
 2360 13a8 14409DE5 		ldr	r4, [sp, #20]
 820:../uvc.c      **** 							 break;
 2361              		.loc 1 820 0
 2362 13ac FFC0A0E3 		mov	ip, #255
 819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2363              		.loc 1 819 0
 2364 13b0 2072C6E5 		strb	r7, [r6, #544]
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2365              		.loc 1 818 0
 2366 13b4 1D42C6E5 		strb	r4, [r6, #541]
 819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2367              		.loc 1 819 0
 2368 13b8 18E09DE5 		ldr	lr, [sp, #24]
 820:../uvc.c      **** 							 break;
 2369              		.loc 1 820 0
 2370 13bc 0C70A0E1 		mov	r7, ip
 2371 13c0 CEFDFFEA 		b	.L114
 2372              	.LVL183:
 2373              	.L153:
 793:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2374              		.loc 1 793 0
 2375 13c4 48469FE5 		ldr	r4, .L211+36
 2376 13c8 0010E0E3 		mvn	r1, #0
 2377 13cc 1C0094E5 		ldr	r0, [r4, #28]
 2378 13d0 FEFFFFEB 		bl	_txe_mutex_get
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2379              		.loc 1 794 0
 2380 13d4 14309DE5 		ldr	r3, [sp, #20]
 2381 13d8 00C0A0E3 		mov	ip, #0
 2382 13dc 800043E2 		sub	r0, r3, #128
 2383 13e0 FF7000E2 		and	r7, r0, #255
 2384              	.LVL184:
 2385 13e4 0510A0E3 		mov	r1, #5
 2386 13e8 0920A0E1 		mov	r2, r9
 2387 13ec 0A30A0E1 		mov	r3, sl
 2388 13f0 0400A0E1 		mov	r0, r4
 2389 13f4 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2390 13f8 FEFFFFEB 		bl	cmdSet
 2391              	.LVL185:
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2392              		.loc 1 796 0
 2393 13fc 14109DE5 		ldr	r1, [sp, #20]
 2394 1400 DC20A0E3 		mov	r2, #220
 2395 1404 767041E2 		sub	r7, r1, #118
 2396 1408 FFC007E2 		and	ip, r7, #255
 2397 140c 0510A0E3 		mov	r1, #5
 2398 1410 0170A0E3 		mov	r7, #1
 2399 1414 0A30A0E1 		mov	r3, sl
 2400 1418 0400A0E1 		mov	r0, r4
 2401 141c 00C08DE5 		str	ip, [sp, #0]
 2402 1420 04708DE5 		str	r7, [sp, #4]
 2403 1424 FEFFFFEB 		bl	cmdSet
 2404              	.LVL186:
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2405              		.loc 1 798 0
 2406 1428 14209DE5 		ldr	r2, [sp, #20]
 2407 142c 0510A0E3 		mov	r1, #5
 2408 1430 7E3082E2 		add	r3, r2, #126
 2409 1434 FFC003E2 		and	ip, r3, #255
 2410 1438 DE20A0E3 		mov	r2, #222
 2411 143c 0A30A0E1 		mov	r3, sl
 2412 1440 0400A0E1 		mov	r0, r4
 2413 1444 00C08DE5 		str	ip, [sp, #0]
 2414 1448 02C0A0E3 		mov	ip, #2
 2415 144c 04C08DE5 		str	ip, [sp, #4]
 2416 1450 FEFFFFEB 		bl	cmdSet
 2417              	.LVL187:
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2418              		.loc 1 800 0
 2419 1454 14009DE5 		ldr	r0, [sp, #20]
 2420 1458 03E0A0E3 		mov	lr, #3
 2421 145c 721080E2 		add	r1, r0, #114
 2422 1460 FFC001E2 		and	ip, r1, #255
 2423 1464 E020A0E3 		mov	r2, #224
 2424 1468 0510A0E3 		mov	r1, #5
 2425 146c 0A30A0E1 		mov	r3, sl
 2426 1470 0400A0E1 		mov	r0, r4
 2427 1474 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2428 1478 FEFFFFEB 		bl	cmdSet
 2429              	.LVL188:
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2430              		.loc 1 802 0
 2431 147c 14209DE5 		ldr	r2, [sp, #20]
 2432 1480 0510A0E3 		mov	r1, #5
 2433 1484 6F3042E2 		sub	r3, r2, #111
 2434 1488 FFC003E2 		and	ip, r3, #255
 2435 148c DD20A0E3 		mov	r2, #221
 2436 1490 0A30A0E1 		mov	r3, sl
 2437 1494 0400A0E1 		mov	r0, r4
 2438 1498 00C08DE5 		str	ip, [sp, #0]
 2439 149c 04C0A0E3 		mov	ip, #4
 2440 14a0 04C08DE5 		str	ip, [sp, #4]
 2441 14a4 FEFFFFEB 		bl	cmdSet
 2442              	.LVL189:
 804:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2443              		.loc 1 804 0
 2444 14a8 4C059FE5 		ldr	r0, .L211+12
 2445 14ac 05E0A0E3 		mov	lr, #5
 2446 14b0 5810D0E5 		ldrb	r1, [r0, #88]	@ zero_extendqisi2
 2447 14b4 0A30A0E1 		mov	r3, sl
 2448 14b8 7F2081E2 		add	r2, r1, #127
 2449 14bc FFC002E2 		and	ip, r2, #255
 2450 14c0 0E10A0E1 		mov	r1, lr
 2451 14c4 0B20A0E1 		mov	r2, fp
 2452 14c8 0400A0E1 		mov	r0, r4
 2453 14cc 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2454 14d0 FEFFFFEB 		bl	cmdSet
 805:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2455              		.loc 1 805 0
 2456 14d4 1C0094E5 		ldr	r0, [r4, #28]
 2457 14d8 FEFFFFEB 		bl	_txe_mutex_put
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2458              		.loc 1 807 0
 2459 14dc 18359FE5 		ldr	r3, .L211+12
 809:../uvc.c      **** 							 break;
 2460              		.loc 1 809 0
 2461 14e0 FFC0A0E3 		mov	ip, #255
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2462              		.loc 1 807 0
 2463 14e4 5800D3E5 		ldrb	r0, [r3, #88]	@ zero_extendqisi2
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2464              		.loc 1 808 0
 2465 14e8 0872C6E5 		strb	r7, [r6, #520]
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2466              		.loc 1 807 0
 2467 14ec 801040E2 		sub	r1, r0, #128
 2468 14f0 0512C6E5 		strb	r1, [r6, #517]
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2469              		.loc 1 808 0
 2470 14f4 14409DE5 		ldr	r4, [sp, #20]
 2471 14f8 18E09DE5 		ldr	lr, [sp, #24]
 809:../uvc.c      **** 							 break;
 2472              		.loc 1 809 0
 2473 14fc 0C70A0E1 		mov	r7, ip
 2474 1500 7EFDFFEA 		b	.L114
 2475              	.LVL190:
 2476              	.L152:
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2477              		.loc 1 845 0
 2478 1504 08459FE5 		ldr	r4, .L211+36
 839:../uvc.c      **** 							 Data0 = Data0 - 1;
 2479              		.loc 1 839 0
 2480 1508 013043E2 		sub	r3, r3, #1
 2481 150c FF7003E2 		and	r7, r3, #255
 2482              	.LVL191:
 843:../uvc.c      **** 								 Data0 = 1;
 2483              		.loc 1 843 0
 2484 1510 020057E3 		cmp	r7, #2
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2485              		.loc 1 845 0
 2486 1514 0010E0E3 		mvn	r1, #0
 2487 1518 1C0094E5 		ldr	r0, [r4, #28]
 843:../uvc.c      **** 								 Data0 = 1;
 2488              		.loc 1 843 0
 2489 151c 0170A083 		movhi	r7, #1
 2490              	.LVL192:
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2491              		.loc 1 845 0
 2492 1520 FEFFFFEB 		bl	_txe_mutex_get
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2493              		.loc 1 846 0
 2494 1524 00C0A0E3 		mov	ip, #0
 2495 1528 0410A0E3 		mov	r1, #4
 2496 152c 0920A0E1 		mov	r2, r9
 2497 1530 0A30A0E1 		mov	r3, sl
 2498 1534 0400A0E1 		mov	r0, r4
 2499 1538 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2500 153c FEFFFFEB 		bl	cmdSet
 847:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2501              		.loc 1 847 0
 2502 1540 1C0094E5 		ldr	r0, [r4, #28]
 2503 1544 FEFFFFEB 		bl	_txe_mutex_put
 851:../uvc.c      **** 							 break;
 2504              		.loc 1 851 0
 2505 1548 FFC0A0E3 		mov	ip, #255
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2506              		.loc 1 850 0
 2507 154c 0100A0E3 		mov	r0, #1
 849:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2508              		.loc 1 849 0
 2509 1550 ED71C6E5 		strb	r7, [r6, #493]
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2510              		.loc 1 850 0
 2511 1554 F001C6E5 		strb	r0, [r6, #496]
 2512 1558 14409DE5 		ldr	r4, [sp, #20]
 2513 155c 18E09DE5 		ldr	lr, [sp, #24]
 851:../uvc.c      **** 							 break;
 2514              		.loc 1 851 0
 2515 1560 0C70A0E1 		mov	r7, ip
 2516 1564 65FDFFEA 		b	.L114
 2517              	.LVL193:
 2518              	.L151:
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2519              		.loc 1 769 0
 2520 1568 A4749FE5 		ldr	r7, .L211+36
 2521              	.LVL194:
 2522 156c 0010E0E3 		mvn	r1, #0
 2523 1570 1C0097E5 		ldr	r0, [r7, #28]
 2524 1574 FEFFFFEB 		bl	_txe_mutex_get
 771:../uvc.c      **** 							  if(Data0&0x80){
 2525              		.loc 1 771 0
 2526 1578 14C09DE5 		ldr	ip, [sp, #20]
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2527              		.loc 1 772 0
 2528 157c A641D6E5 		ldrb	r4, [r6, #422]	@ zero_extendqisi2
 771:../uvc.c      **** 							  if(Data0&0x80){
 2529              		.loc 1 771 0
 2530 1580 80001CE3 		tst	ip, #128
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2531              		.loc 1 774 0
 2532 1584 2C23A001 		moveq	r2, ip, lsr #6
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2533              		.loc 1 772 0
 2534 1588 8C2CA011 		movne	r2, ip, asl #25
 2535 158c 0340C413 		bicne	r4, r4, #3
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2536              		.loc 1 774 0
 2537 1590 0340C403 		biceq	r4, r4, #3
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2538              		.loc 1 778 0
 2539 1594 00C0A0E3 		mov	ip, #0
 2540 1598 04C08DE5 		str	ip, [sp, #4]
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2541              		.loc 1 774 0
 2542 159c 02208203 		orreq	r2, r2, #2
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2543              		.loc 1 772 0
 2544 15a0 A24F8411 		orrne	r4, r4, r2, lsr #31
 2545              	.LVL195:
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2546              		.loc 1 774 0
 2547 15a4 04408201 		orreq	r4, r2, r4
 2548              	.LVL196:
 776:../uvc.c      **** 							 Data1 |= ~0x03;
 2549              		.loc 1 776 0
 2550 15a8 043FE0E1 		mvn	r3, r4, asl #30
 2551 15ac 230FE0E1 		mvn	r0, r3, lsr #30
 2552              	.LVL197:
 777:../uvc.c      **** 							 Data1 &= 0xC7;
 2553              		.loc 1 777 0
 2554 15b0 C71000E2 		and	r1, r0, #199
 2555 15b4 1C108DE5 		str	r1, [sp, #28]
 2556              	.LVL198:
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2557              		.loc 1 778 0
 2558 15b8 1C809DE5 		ldr	r8, [sp, #28]
 2559 15bc 0110A0E3 		mov	r1, #1
 2560 15c0 0B20A0E1 		mov	r2, fp
 2561 15c4 0A30A0E1 		mov	r3, sl
 2562 15c8 44049FE5 		ldr	r0, .L211+36
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2563              		.loc 1 782 0
 2564 15cc 0140A0E1 		mov	r4, r1
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2565              		.loc 1 778 0
 2566 15d0 00808DE5 		str	r8, [sp, #0]
 2567 15d4 FEFFFFEB 		bl	cmdSet
 2568              	.LVL199:
 781:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2569              		.loc 1 781 0
 2570 15d8 14209DE5 		ldr	r2, [sp, #20]
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2571              		.loc 1 782 0
 2572 15dc 0410A0E1 		mov	r1, r4
 781:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2573              		.loc 1 781 0
 2574 15e0 0281A0E1 		mov	r8, r2, asl #2
 2575 15e4 FF8008E2 		and	r8, r8, #255
 2576              	.LVL200:
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2577              		.loc 1 782 0
 2578 15e8 0920A0E1 		mov	r2, r9
 2579 15ec 0A30A0E1 		mov	r3, sl
 2580 15f0 1C049FE5 		ldr	r0, .L211+36
 2581 15f4 04408DE5 		str	r4, [sp, #4]
 2582 15f8 00808DE5 		str	r8, [sp, #0]
 2583 15fc FEFFFFEB 		bl	cmdSet
 783:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2584              		.loc 1 783 0
 2585 1600 1C0097E5 		ldr	r0, [r7, #28]
 2586 1604 FEFFFFEB 		bl	_txe_mutex_put
 786:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2587              		.loc 1 786 0
 2588 1608 1C709DE5 		ldr	r7, [sp, #28]
 789:../uvc.c      **** 							 break;
 2589              		.loc 1 789 0
 2590 160c FFC0A0E3 		mov	ip, #255
 786:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2591              		.loc 1 786 0
 2592 1610 A671C6E5 		strb	r7, [r6, #422]
 787:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2593              		.loc 1 787 0
 2594 1614 A841C6E5 		strb	r4, [r6, #424]
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2595              		.loc 1 785 0
 2596 1618 A581C6E5 		strb	r8, [r6, #421]
 787:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2597              		.loc 1 787 0
 2598 161c 14409DE5 		ldr	r4, [sp, #20]
 2599 1620 18E09DE5 		ldr	lr, [sp, #24]
 789:../uvc.c      **** 							 break;
 2600              		.loc 1 789 0
 2601 1624 0C70A0E1 		mov	r7, ip
 2602 1628 34FDFFEA 		b	.L114
 2603              	.LVL201:
 2604              	.L150:
 2605 162c 03C0A0E1 		mov	ip, r3
 854:../uvc.c      **** 							 if(Data0 == 3)
 2606              		.loc 1 854 0
 2607 1630 030053E3 		cmp	r3, #3
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2608              		.loc 1 853 0
 2609 1634 8DC1C6E5 		strb	ip, [r6, #397]
 2610 1638 B0339FE5 		ldr	r3, .L211
 854:../uvc.c      **** 							 if(Data0 == 3)
 2611              		.loc 1 854 0
 2612 163c D600000A 		beq	.L210
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 2613              		.loc 1 857 0
 2614 1640 B4E39FE5 		ldr	lr, .L211+12
 861:../uvc.c      **** 								 if(Data0 < 2){
 2615              		.loc 1 861 0
 2616 1644 01005CE3 		cmp	ip, #1
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 2617              		.loc 1 857 0
 2618 1648 0000A0E3 		mov	r0, #0
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2619              		.loc 1 858 0
 2620 164c 0110A0E3 		mov	r1, #1
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 2621              		.loc 1 857 0
 2622 1650 78008EE5 		str	r0, [lr, #120]
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2623              		.loc 1 858 0
 2624 1654 9011C3E5 		strb	r1, [r3, #400]
 861:../uvc.c      **** 								 if(Data0 < 2){
 2625              		.loc 1 861 0
 2626 1658 0C60A091 		movls	r6, ip
 2627 165c 0C70A091 		movls	r7, ip
 2628              	.LVL202:
 2629 1660 0600009A 		bls	.L186
 2630              	.L185:
 864:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 2631              		.loc 1 864 0
 2632 1664 0400A0E3 		mov	r0, #4
 2633 1668 AC139FE5 		ldr	r1, .L211+44
 2634 166c 0120A0E3 		mov	r2, #1
 2635 1670 14309DE5 		ldr	r3, [sp, #20]
 2636 1674 FEFFFFEB 		bl	CyU3PDebugPrint
 2637              	.LVL203:
 2638 1678 0060A0E3 		mov	r6, #0
 865:../uvc.c      **** 									Data0 = 0; //set to default.
 2639              		.loc 1 865 0
 2640 167c 0670A0E1 		mov	r7, r6
 2641              	.LVL204:
 2642              	.L186:
 870:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2643              		.loc 1 870 0
 2644 1680 8C439FE5 		ldr	r4, .L211+36
 2645 1684 0010E0E3 		mvn	r1, #0
 2646 1688 1C0094E5 		ldr	r0, [r4, #28]
 2647 168c FEFFFFEB 		bl	_txe_mutex_get
 871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2648              		.loc 1 871 0
 2649 1690 00C0A0E3 		mov	ip, #0
 2650 1694 0C10A0E1 		mov	r1, ip
 2651 1698 0920A0E1 		mov	r2, r9
 2652 169c 0A30A0E1 		mov	r3, sl
 2653 16a0 0400A0E1 		mov	r0, r4
 2654 16a4 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2655 16a8 FEFFFFEB 		bl	cmdSet
 872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2656              		.loc 1 872 0
 2657 16ac 1C0094E5 		ldr	r0, [r4, #28]
 2658 16b0 FEFFFFEB 		bl	_txe_mutex_put
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2659              		.loc 1 873 0
 2660 16b4 40C39FE5 		ldr	ip, .L211+12
 2661 16b8 60139FE5 		ldr	r1, .L211+48
 2662 16bc 5A40DCE5 		ldrb	r4, [ip, #90]	@ zero_extendqisi2
 2663 16c0 5B70DCE5 		ldrb	r7, [ip, #91]	@ zero_extendqisi2
 2664              	.LVL205:
 2665 16c4 0400A0E3 		mov	r0, #4
 2666 16c8 0620A0E1 		mov	r2, r6
 2667 16cc 78309CE5 		ldr	r3, [ip, #120]
 2668 16d0 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2669              	.LVL206:
 2670              	.L202:
 2671 16d4 FEFFFFEB 		bl	CyU3PDebugPrint
 875:../uvc.c      **** 					 		 break;
 2672              		.loc 1 875 0
 2673 16d8 FFC0A0E3 		mov	ip, #255
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2674              		.loc 1 873 0
 2675 16dc 14409DE5 		ldr	r4, [sp, #20]
 2676 16e0 18E09DE5 		ldr	lr, [sp, #24]
 875:../uvc.c      **** 					 		 break;
 2677              		.loc 1 875 0
 2678 16e4 0C70A0E1 		mov	r7, ip
 2679 16e8 04FDFFEA 		b	.L114
 2680              	.LVL207:
 2681              	.L149:
 879:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2682              		.loc 1 879 0
 2683 16ec 20739FE5 		ldr	r7, .L211+36
 2684              	.LVL208:
 2685 16f0 0010E0E3 		mvn	r1, #0
 2686 16f4 1C0097E5 		ldr	r0, [r7, #28]
 2687 16f8 FEFFFFEB 		bl	_txe_mutex_get
 880:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2688              		.loc 1 880 0
 2689 16fc 14C09DE5 		ldr	ip, [sp, #20]
 2690 1700 0410A0E1 		mov	r1, r4
 2691 1704 0920A0E1 		mov	r2, r9
 2692 1708 0A30A0E1 		mov	r3, sl
 2693 170c 0700A0E1 		mov	r0, r7
 2694 1710 00C08DE5 		str	ip, [sp, #0]
 2695 1714 00C0A0E3 		mov	ip, #0
 2696 1718 04C08DE5 		str	ip, [sp, #4]
 2697 171c FEFFFFEB 		bl	cmdSet
 881:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2698              		.loc 1 881 0
 2699 1720 1C0097E5 		ldr	r0, [r7, #28]
 2700 1724 FEFFFFEB 		bl	_txe_mutex_put
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2701              		.loc 1 883 0
 2702 1728 14209DE5 		ldr	r2, [sp, #20]
 2703 172c 841084E0 		add	r1, r4, r4, asl #1
 2704 1730 816186E0 		add	r6, r6, r1, asl #3
 885:../uvc.c      **** 							 break;
 2705              		.loc 1 885 0
 2706 1734 FFC0A0E3 		mov	ip, #255
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2707              		.loc 1 884 0
 2708 1738 0130A0E3 		mov	r3, #1
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2709              		.loc 1 883 0
 2710 173c 8D21C6E5 		strb	r2, [r6, #397]
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2711              		.loc 1 884 0
 2712 1740 9031C6E5 		strb	r3, [r6, #400]
 2713 1744 0240A0E1 		mov	r4, r2
 2714 1748 18E09DE5 		ldr	lr, [sp, #24]
 885:../uvc.c      **** 							 break;
 2715              		.loc 1 885 0
 2716 174c 0C70A0E1 		mov	r7, ip
 2717 1750 EAFCFFEA 		b	.L114
 2718              	.LVL209:
 2719              	.L159:
 617:../uvc.c      **** 				  switch(CtrlID)
 2720              		.loc 1 617 0
 2721 1754 FFC0A0E3 		mov	ip, #255
 2722 1758 0340A0E1 		mov	r4, r3
 2723 175c 0C70A0E1 		mov	r7, ip
 2724              	.LVL210:
 2725 1760 E6FCFFEA 		b	.L114
 2726              	.LVL211:
 2727              	.L158:
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2728              		.loc 1 671 0
 2729 1764 A8729FE5 		ldr	r7, .L211+36
 2730              	.LVL212:
 669:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2731              		.loc 1 669 0
 2732 1768 FD33C6E5 		strb	r3, [r6, #1021]
 670:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2733              		.loc 1 670 0
 2734 176c 0130A0E3 		mov	r3, #1
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2735              		.loc 1 671 0
 2736 1770 1C0097E5 		ldr	r0, [r7, #28]
 2737 1774 0010E0E3 		mvn	r1, #0
 670:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2738              		.loc 1 670 0
 2739 1778 0034C6E5 		strb	r3, [r6, #1024]
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2740              		.loc 1 671 0
 2741 177c FEFFFFEB 		bl	_txe_mutex_get
 672:../uvc.c      **** 							 if(WDRflag)
 2742              		.loc 1 672 0
 2743 1780 74329FE5 		ldr	r3, .L211+12
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2744              		.loc 1 673 0
 2745 1784 1A10A0E3 		mov	r1, #26
 672:../uvc.c      **** 							 if(WDRflag)
 2746              		.loc 1 672 0
 2747 1788 784093E5 		ldr	r4, [r3, #120]
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2748              		.loc 1 673 0
 2749 178c 0700A0E1 		mov	r0, r7
 672:../uvc.c      **** 							 if(WDRflag)
 2750              		.loc 1 672 0
 2751 1790 000054E3 		cmp	r4, #0
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2752              		.loc 1 673 0
 2753 1794 14409D15 		ldrne	r4, [sp, #20]
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2754              		.loc 1 675 0
 2755 1798 14E09D05 		ldreq	lr, [sp, #20]
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2756              		.loc 1 673 0
 2757 179c 00408D15 		strne	r4, [sp, #0]
 2758 17a0 0B20A011 		movne	r2, fp
 2759 17a4 0040A013 		movne	r4, #0
 2760 17a8 0A30A011 		movne	r3, sl
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2761              		.loc 1 675 0
 2762 17ac 0920A001 		moveq	r2, r9
 2763 17b0 0A30A001 		moveq	r3, sl
 2764 17b4 04408DE5 		str	r4, [sp, #4]
 2765 17b8 00E08D05 		streq	lr, [sp, #0]
 2766 17bc FEFFFFEB 		bl	cmdSet
 676:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2767              		.loc 1 676 0
 2768 17c0 1C0097E5 		ldr	r0, [r7, #28]
 2769 17c4 FEFFFFEB 		bl	_txe_mutex_put
 677:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2770              		.loc 1 677 0
 2771 17c8 2C229FE5 		ldr	r2, .L211+12
 2772 17cc 14409DE5 		ldr	r4, [sp, #20]
 2773 17d0 5AC0D2E5 		ldrb	ip, [r2, #90]	@ zero_extendqisi2
 2774 17d4 5BE0D2E5 		ldrb	lr, [r2, #91]	@ zero_extendqisi2
 2775 17d8 783092E5 		ldr	r3, [r2, #120]
 2776 17dc 0400A0E3 		mov	r0, #4
 2777 17e0 3C129FE5 		ldr	r1, .L211+52
 2778 17e4 0420A0E1 		mov	r2, r4
 2779 17e8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2780 17ec FEFFFFEB 		bl	CyU3PDebugPrint
 2781 17f0 FFC0A0E3 		mov	ip, #255
 2782 17f4 18E09DE5 		ldr	lr, [sp, #24]
 2783 17f8 0C70A0E1 		mov	r7, ip
 2784 17fc BFFCFFEA 		b	.L114
 2785              	.LVL213:
 2786              	.L157:
 655:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2787              		.loc 1 655 0
 2788 1800 18209DE5 		ldr	r2, [sp, #24]
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2789              		.loc 1 658 0
 2790 1804 08429FE5 		ldr	r4, .L211+36
 656:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2791              		.loc 1 656 0
 2792 1808 0170A0E3 		mov	r7, #1
 2793              	.LVL214:
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2794              		.loc 1 658 0
 2795 180c 0010E0E3 		mvn	r1, #0
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2796              		.loc 1 654 0
 2797 1810 E533C6E5 		strb	r3, [r6, #997]
 655:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2798              		.loc 1 655 0
 2799 1814 E623C6E5 		strb	r2, [r6, #998]
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2800              		.loc 1 658 0
 2801 1818 1C0094E5 		ldr	r0, [r4, #28]
 656:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2802              		.loc 1 656 0
 2803 181c E873C6E5 		strb	r7, [r6, #1000]
 2804              	.LVL215:
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2805              		.loc 1 658 0
 2806 1820 FEFFFFEB 		bl	_txe_mutex_get
 659:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2807              		.loc 1 659 0
 2808 1824 14C09DE5 		ldr	ip, [sp, #20]
 2809 1828 1910A0E3 		mov	r1, #25
 2810 182c 00C08DE5 		str	ip, [sp, #0]
 2811 1830 0400A0E1 		mov	r0, r4
 2812 1834 00C0A0E3 		mov	ip, #0
 2813 1838 0920A0E1 		mov	r2, r9
 2814 183c 0A30A0E1 		mov	r3, sl
 2815 1840 04C08DE5 		str	ip, [sp, #4]
 2816 1844 FEFFFFEB 		bl	cmdSet
 660:../uvc.c      **** 							 if(getData != 0){
 2817              		.loc 1 660 0
 2818 1848 14109DE5 		ldr	r1, [sp, #20]
 2819 184c 000051E3 		cmp	r1, #0
 2820 1850 0700000A 		beq	.L174
 2821              	.LVL216:
 662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2822              		.loc 1 662 0
 2823 1854 18E09DE5 		ldr	lr, [sp, #24]
 2824 1858 0400A0E1 		mov	r0, r4
 2825 185c 1910A0E3 		mov	r1, #25
 2826 1860 0B20A0E1 		mov	r2, fp
 2827 1864 0A30A0E1 		mov	r3, sl
 2828 1868 00E08DE5 		str	lr, [sp, #0]
 2829 186c 04708DE5 		str	r7, [sp, #4]
 2830 1870 FEFFFFEB 		bl	cmdSet
 2831              	.LVL217:
 2832              	.L174:
 664:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2833              		.loc 1 664 0
 2834 1874 1C0094E5 		ldr	r0, [r4, #28]
 2835 1878 FEFFFFEB 		bl	_txe_mutex_put
 665:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2836              		.loc 1 665 0
 2837 187c 78119FE5 		ldr	r1, .L211+12
 2838 1880 74019FE5 		ldr	r0, .L211+12
 2839 1884 5A40D1E5 		ldrb	r4, [r1, #90]	@ zero_extendqisi2
 2840 1888 5B70D0E5 		ldrb	r7, [r0, #91]	@ zero_extendqisi2
 2841 188c 5820D1E5 		ldrb	r2, [r1, #88]	@ zero_extendqisi2
 2842 1890 5930D1E5 		ldrb	r3, [r1, #89]	@ zero_extendqisi2
 2843 1894 0400A0E3 		mov	r0, #4
 2844 1898 88119FE5 		ldr	r1, .L211+56
 2845 189c 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2846 18a0 8BFFFFEA 		b	.L202
 2847              	.LVL218:
 2848              	.L156:
 621:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2849              		.loc 1 621 0
 2850 18a4 000053E2 		subs	r0, r3, #0
 620:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2851              		.loc 1 620 0
 2852 18a8 0D03C6E5 		strb	r0, [r6, #781]
 2853 18ac 3C319FE5 		ldr	r3, .L211
 621:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2854              		.loc 1 621 0
 2855 18b0 2400001A 		bne	.L168
 622:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2856              		.loc 1 622 0
 2857 18b4 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2858 18b8 020052E3 		cmp	r2, #2
 2859 18bc 08005213 		cmpne	r2, #8
 2860 18c0 0300000A 		beq	.L169
 623:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2861              		.loc 1 623 0
 2862 18c4 010052E3 		cmp	r2, #1
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2863              		.loc 1 624 0
 2864 18c8 07208202 		addeq	r2, r2, #7
 626:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2865              		.loc 1 626 0
 2866 18cc 0220A013 		movne	r2, #2
 2867 18d0 B524C3E5 		strb	r2, [r3, #1205]
 2868              	.LVL219:
 2869              	.L169:
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2870              		.loc 1 648 0
 2871 18d4 38419FE5 		ldr	r4, .L211+36
 646:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2872              		.loc 1 646 0
 2873 18d8 0130A0E3 		mov	r3, #1
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2874              		.loc 1 648 0
 2875 18dc 0010E0E3 		mvn	r1, #0
 2876 18e0 1C0094E5 		ldr	r0, [r4, #28]
 646:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2877              		.loc 1 646 0
 2878 18e4 1033C6E5 		strb	r3, [r6, #784]
 2879              	.LVL220:
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2880              		.loc 1 648 0
 2881 18e8 FEFFFFEB 		bl	_txe_mutex_get
 649:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2882              		.loc 1 649 0
 2883 18ec 14C09DE5 		ldr	ip, [sp, #20]
 2884 18f0 00E0A0E3 		mov	lr, #0
 2885 18f4 1010A0E3 		mov	r1, #16
 2886 18f8 0920A0E1 		mov	r2, r9
 2887 18fc 0A30A0E1 		mov	r3, sl
 2888 1900 0400A0E1 		mov	r0, r4
 2889 1904 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2890 1908 FEFFFFEB 		bl	cmdSet
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2891              		.loc 1 650 0
 2892 190c 1C0094E5 		ldr	r0, [r4, #28]
 2893 1910 FEFFFFEB 		bl	_txe_mutex_put
 652:../uvc.c      **** 							 break;
 2894              		.loc 1 652 0
 2895 1914 FFC0A0E3 		mov	ip, #255
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2896              		.loc 1 650 0
 2897 1918 14409DE5 		ldr	r4, [sp, #20]
 2898 191c 18E09DE5 		ldr	lr, [sp, #24]
 652:../uvc.c      **** 							 break;
 2899              		.loc 1 652 0
 2900 1920 0C70A0E1 		mov	r7, ip
 2901 1924 75FCFFEA 		b	.L114
 2902              	.LVL221:
 2903              	.L148:
 888:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2904              		.loc 1 888 0
 2905 1928 0400A0E3 		mov	r0, #4
 2906              	.LVL222:
 2907 192c F8109FE5 		ldr	r1, .L211+60
 2908 1930 FEFFFFEB 		bl	CyU3PDebugPrint
 2909              	.LVL223:
 2910 1934 FFC0A0E3 		mov	ip, #255
 2911 1938 0C70A0E1 		mov	r7, ip
 2912              	.LVL224:
 2913 193c 0CE0A0E1 		mov	lr, ip
 2914 1940 0C40A0E1 		mov	r4, ip
 2915 1944 6DFCFFEA 		b	.L114
 2916              	.LVL225:
 2917              	.L168:
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2918              		.loc 1 631 0
 2919 1948 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 630:../uvc.c      **** 								 Data1 = Data0 - 1;
 2920              		.loc 1 630 0
 2921 194c 017040E2 		sub	r7, r0, #1
 2922              	.LVL226:
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2923              		.loc 1 631 0
 2924 1950 040052E3 		cmp	r2, #4
 2925 1954 01005213 		cmpne	r2, #1
 630:../uvc.c      **** 								 Data1 = Data0 - 1;
 2926              		.loc 1 630 0
 2927 1958 FF1007E2 		and	r1, r7, #255
 2928              	.LVL227:
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2929              		.loc 1 631 0
 2930 195c 0300000A 		beq	.L171
 632:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2931              		.loc 1 632 0
 2932 1960 080052E3 		cmp	r2, #8
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2933              		.loc 1 633 0
 2934 1964 0120A003 		moveq	r2, #1
 635:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2935              		.loc 1 635 0
 2936 1968 0420A013 		movne	r2, #4
 2937 196c B524C3E5 		strb	r2, [r3, #1205]
 2938              	.L171:
 638:../uvc.c      **** 								 if(Data1 < 8){
 2939              		.loc 1 638 0
 2940 1970 070051E3 		cmp	r1, #7
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2941              		.loc 1 639 0
 2942 1974 B4309F95 		ldrls	r3, .L211+64
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2943              		.loc 1 642 0
 2944 1978 0130A083 		movhi	r3, #1
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2945              		.loc 1 640 0
 2946 197c 81008390 		addls	r0, r3, r1, asl #1
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2947              		.loc 1 639 0
 2948 1980 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2949              		.loc 1 640 0
 2950 1984 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2951              		.loc 1 642 0
 2952 1988 E534C685 		strhib	r3, [r6, #1253]
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2953              		.loc 1 643 0
 2954 198c 0030A083 		movhi	r3, #0
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2955              		.loc 1 639 0
 2956 1990 E524C695 		strlsb	r2, [r6, #1253]
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2957              		.loc 1 643 0
 2958 1994 E634C6E5 		strb	r3, [r6, #1254]
 2959 1998 CDFFFFEA 		b	.L169
 2960              	.LVL228:
 2961              	.L210:
 855:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2962              		.loc 1 855 0
 2963 199c 58209FE5 		ldr	r2, .L211+12
 2964 19a0 0160A0E3 		mov	r6, #1
 2965 19a4 786082E5 		str	r6, [r2, #120]
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2966              		.loc 1 858 0
 2967 19a8 9061C3E5 		strb	r6, [r3, #400]
 2968 19ac 2CFFFFEA 		b	.L185
 2969              	.LVL229:
 2970              	.L209:
 447:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2971              		.loc 1 447 0
 2972 19b0 0120A0E3 		mov	r2, #1
 2973 19b4 0400A0E3 		mov	r0, #4
 2974 19b8 5C109FE5 		ldr	r1, .L211+44
 2975 19bc FEFFFFEB 		bl	CyU3PDebugPrint
 2976              	.LVL230:
 449:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2977              		.loc 1 449 0
 2978 19c0 28309FE5 		ldr	r3, .L211
 2979 19c4 0020A0E3 		mov	r2, #0
 2980 19c8 0440A0E3 		mov	r4, #4
 2981 19cc 2D24C3E5 		strb	r2, [r3, #1069]
 2982              	.LVL231:
 2983 19d0 81FDFFEA 		b	.L134
 2984              	.LVL232:
 2985              	.L199:
 2986 19d4 20009FE5 		ldr	r0, .L211+12
 2987 19d8 6EFDFFEA 		b	.L125
 2988              	.LVL233:
 2989              	.L188:
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2990              		.loc 1 390 0
 2991 19dc 0030A0E3 		mov	r3, #0
 2992 19e0 11FEFFEA 		b	.L192
 2993              	.LVL234:
 2994              	.L187:
 2995 19e4 10009FE5 		ldr	r0, .L211+12
 2996 19e8 0030A0E3 		mov	r3, #0
 2997 19ec 62FDFFEA 		b	.L191
 2998              	.L212:
 2999              		.align	2
 3000              	.L211:
 3001 19f0 00000000 		.word	.LANCHOR1
 3002 19f4 00000000 		.word	bRequest
 3003 19f8 74030000 		.word	.LC22
 3004 19fc 00000000 		.word	.LANCHOR0
 3005 1a00 58000000 		.word	.LANCHOR0+88
 3006 1a04 01000100 		.word	65537
 3007 1a08 FF00FF00 		.word	16711935
 3008 1a0c 80020000 		.word	.LC16
 3009 1a10 BC020000 		.word	.LC17
 3010 1a14 00000000 		.word	cmdQu
 3011 1a18 4C000000 		.word	.LANCHOR0+76
 3012 1a1c 48020000 		.word	.LC15
 3013 1a20 2C030000 		.word	.LC20
 3014 1a24 10030000 		.word	.LC19
 3015 1a28 E4020000 		.word	.LC18
 3016 1a2c 44030000 		.word	.LC21
 3017 1a30 00000000 		.word	.LANCHOR2
 3018              		.cfi_endproc
 3019              	.LFE2:
 3021              		.align	2
 3022              		.global	CTControlHandle
 3024              	CTControlHandle:
 3025              	.LFB3:
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3026              		.loc 1 904 0
 3027              		.cfi_startproc
 3028              		@ args = 0, pretend = 0, frame = 64
 3029              		@ frame_needed = 0, uses_anonymous_args = 0
 3030              	.LVL235:
 3031 1a34 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3032              	.LCFI15:
 3033              		.cfi_def_cfa_offset 36
 923:../uvc.c      ****     reqData = bRequest;
 3034              		.loc 1 923 0
 3035 1a38 60A99FE5 		ldr	sl, .L298
 3036              		.cfi_offset 14, -4
 3037              		.cfi_offset 11, -8
 3038              		.cfi_offset 10, -12
 3039              		.cfi_offset 9, -16
 3040              		.cfi_offset 8, -20
 3041              		.cfi_offset 7, -24
 3042              		.cfi_offset 6, -28
 3043              		.cfi_offset 5, -32
 3044              		.cfi_offset 4, -36
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3045              		.loc 1 915 0
 3046 1a3c 60899FE5 		ldr	r8, .L298+4
 923:../uvc.c      ****     reqData = bRequest;
 3047              		.loc 1 923 0
 3048 1a40 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3049              		.loc 1 915 0
 3050 1a44 8090A0E1 		mov	r9, r0, asl #1
 3051 1a48 002089E0 		add	r2, r9, r0
 3052 1a4c 822188E0 		add	r2, r8, r2, asl #3
 925:../uvc.c      ****     switch (bRequest)
 3053              		.loc 1 925 0
 3054 1a50 830055E3 		cmp	r5, #131
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3055              		.loc 1 904 0
 3056 1a54 5CD04DE2 		sub	sp, sp, #92
 3057              	.LCFI16:
 3058              		.cfi_def_cfa_offset 128
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3059              		.loc 1 904 0
 3060 1a58 0060A0E1 		mov	r6, r0
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3061              		.loc 1 915 0
 3062 1a5c 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3063              	.LVL236:
 916:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3064              		.loc 1 916 0
 3065 1a60 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3066              	.LVL237:
 918:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3067              		.loc 1 918 0
 3068 1a64 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3069              	.LVL238:
 925:../uvc.c      ****     switch (bRequest)
 3070              		.loc 1 925 0
 3071 1a68 7600000A 		beq	.L218
 3072 1a6c 2100009A 		bls	.L293
 3073 1a70 850055E3 		cmp	r5, #133
 3074 1a74 5900000A 		beq	.L220
 3075 1a78 4E00003A 		bcc	.L219
 3076 1a7c 860055E3 		cmp	r5, #134
 3077 1a80 8000000A 		beq	.L221
 3078 1a84 870055E3 		cmp	r5, #135
 3079 1a88 7600000A 		beq	.L294
 3080              	.L214:
1132:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3081              		.loc 1 1132 0
 3082 1a8c 0000A0E3 		mov	r0, #0
 3083              	.LVL239:
 3084 1a90 0110A0E3 		mov	r1, #1
 3085 1a94 0020A0E1 		mov	r2, r0
 3086 1a98 FEFFFFEB 		bl	CyU3PUsbStall
 3087              	.LVL240:
 3088 1a9c 04499FE5 		ldr	r4, .L298+8
1133:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3089              		.loc 1 1133 0
 3090 1aa0 0620A0E1 		mov	r2, r6
 3091 1aa4 0400A0E3 		mov	r0, #4
 3092 1aa8 FC189FE5 		ldr	r1, .L298+12
 3093 1aac 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3094 1ab0 FEFFFFEB 		bl	CyU3PDebugPrint
1134:../uvc.c      **** 			  break;
 3095              		.loc 1 1134 0
 3096 1ab4 FFC0A0E3 		mov	ip, #255
 3097 1ab8 0C60A0E1 		mov	r6, ip
 3098 1abc 0C80A0E1 		mov	r8, ip
 3099              	.LVL241:
 3100              	.L224:
1138:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3101              		.loc 1 1138 0
 3102 1ac0 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3103 1ac4 08C08DE5 		str	ip, [sp, #8]
 3104 1ac8 E0189FE5 		ldr	r1, .L298+16
 3105 1acc FFC0A0E3 		mov	ip, #255
 3106 1ad0 0520A0E1 		mov	r2, r5
 3107 1ad4 0830A0E1 		mov	r3, r8
 3108 1ad8 0400A0E3 		mov	r0, #4
 3109 1adc 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3110 1ae0 0CC08DE5 		str	ip, [sp, #12]
 3111 1ae4 10E08DE5 		str	lr, [sp, #16]
 3112 1ae8 14708DE5 		str	r7, [sp, #20]
 3113 1aec FEFFFFEB 		bl	CyU3PDebugPrint
1139:../uvc.c      **** }
 3114              		.loc 1 1139 0
 3115 1af0 5CD08DE2 		add	sp, sp, #92
 3116 1af4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3117              	.LVL242:
 3118              	.L293:
 925:../uvc.c      ****     switch (bRequest)
 3119              		.loc 1 925 0
 3120 1af8 810055E3 		cmp	r5, #129
 3121 1afc 4200000A 		beq	.L216
 3122 1b00 1100009A 		bls	.L295
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3123              		.loc 1 954 0
 3124 1b04 9C489FE5 		ldr	r4, .L298+8
 3125 1b08 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3126              		.loc 1 955 0
 3127 1b0c 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3128              		.loc 1 956 0
 3129 1b10 0A0050E3 		cmp	r0, #10
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3130              		.loc 1 954 0
 3131 1b14 5810C4E5 		strb	r1, [r4, #88]
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3132              		.loc 1 955 0
 3133 1b18 5960C4E5 		strb	r6, [r4, #89]
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3134              		.loc 1 956 0
 3135 1b1c 2C00000A 		beq	.L292
 3136              	.LVL243:
 3137              	.L231:
 990:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3138              		.loc 1 990 0
 3139 1b20 00E0A0E3 		mov	lr, #0
 3140 1b24 5AE0C4E5 		strb	lr, [r4, #90]
 3141              	.L232:
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3142              		.loc 1 991 0
 3143 1b28 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3144              		.loc 1 992 0
 3145 1b2c 0700A0E1 		mov	r0, r7
 3146              	.LVL244:
 3147 1b30 7C189FE5 		ldr	r1, .L298+20
 994:../uvc.c      **** 			  break;
 3148              		.loc 1 994 0
 3149 1b34 FF60A0E3 		mov	r6, #255
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3150              		.loc 1 991 0
 3151 1b38 5B30C4E5 		strb	r3, [r4, #91]
 994:../uvc.c      **** 			  break;
 3152              		.loc 1 994 0
 3153 1b3c 0680A0E1 		mov	r8, r6
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3154              		.loc 1 992 0
 3155 1b40 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3156              	.LVL245:
 3157 1b44 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 994:../uvc.c      **** 			  break;
 3158              		.loc 1 994 0
 3159 1b48 DCFFFFEA 		b	.L224
 3160              	.LVL246:
 3161              	.L295:
 925:../uvc.c      ****     switch (bRequest)
 3162              		.loc 1 925 0
 3163 1b4c 010055E3 		cmp	r5, #1
 3164 1b50 CDFFFF1A 		bne	.L214
 996:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3165              		.loc 1 996 0
 3166 1b54 4C489FE5 		ldr	r4, .L298+8
 3167 1b58 56208DE2 		add	r2, sp, #86
 3168 1b5c 2000A0E3 		mov	r0, #32
 3169              	.LVL247:
 3170 1b60 581084E2 		add	r1, r4, #88
 3171 1b64 2C308DE5 		str	r3, [sp, #44]
 3172 1b68 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3173              	.LVL248:
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3174              		.loc 1 998 0
 3175 1b6c 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3176              		.loc 1 999 0
 3177 1b70 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
1002:../uvc.c      **** 			  switch(CtrlID)
 3178              		.loc 1 1002 0
 3179 1b74 012046E2 		sub	r2, r6, #1
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3180              		.loc 1 998 0
 3181 1b78 30008DE5 		str	r0, [sp, #48]
 3182              	.LVL249:
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3183              		.loc 1 999 0
 3184 1b7c 34C08DE5 		str	ip, [sp, #52]
 3185              	.LVL250:
1002:../uvc.c      **** 			  switch(CtrlID)
 3186              		.loc 1 1002 0
 3187 1b80 2C309DE5 		ldr	r3, [sp, #44]
 3188 1b84 090052E3 		cmp	r2, #9
 3189 1b88 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3190 1b8c 550100EA 		b	.L233
 3191              	.L238:
 3192 1b90 A4200000 		.word	.L234
 3193 1b94 E8200000 		.word	.L233
 3194 1b98 B41D0000 		.word	.L235
 3195 1b9c E8200000 		.word	.L233
 3196 1ba0 E8200000 		.word	.L233
 3197 1ba4 E8200000 		.word	.L233
 3198 1ba8 301D0000 		.word	.L236
 3199 1bac E8200000 		.word	.L233
 3200 1bb0 E8200000 		.word	.L233
 3201 1bb4 B41C0000 		.word	.L237
 3202              	.LVL251:
 3203              	.L219:
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3204              		.loc 1 972 0
 3205 1bb8 E8479FE5 		ldr	r4, .L298+8
 3206 1bbc 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3207              		.loc 1 973 0
 3208 1bc0 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3209              		.loc 1 974 0
 3210 1bc4 0A0050E3 		cmp	r0, #10
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3211              		.loc 1 972 0
 3212 1bc8 5880C4E5 		strb	r8, [r4, #88]
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3213              		.loc 1 973 0
 3214 1bcc 5920C4E5 		strb	r2, [r4, #89]
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3215              		.loc 1 974 0
 3216 1bd0 D2FFFF1A 		bne	.L231
 3217              	.LVL252:
 3218              	.L292:
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3219              		.loc 1 989 0 discriminator 1
 3220 1bd4 0110A0E3 		mov	r1, #1
 3221 1bd8 5A10C4E5 		strb	r1, [r4, #90]
 3222 1bdc D1FFFFEA 		b	.L232
 3223              	.LVL253:
 3224              	.L220:
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3225              		.loc 1 929 0
 3226 1be0 C0479FE5 		ldr	r4, .L298+8
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3227              		.loc 1 930 0
 3228 1be4 0030A0E3 		mov	r3, #0
 3229              	.LVL254:
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3230              		.loc 1 931 0
 3231 1be8 0200A0E3 		mov	r0, #2
 3232              	.LVL255:
 3233 1bec 581084E2 		add	r1, r4, #88
 933:../uvc.c      **** 			  break;
 3234              		.loc 1 933 0
 3235 1bf0 FF60A0E3 		mov	r6, #255
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3236              		.loc 1 929 0
 3237 1bf4 5870C4E5 		strb	r7, [r4, #88]
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3238              		.loc 1 930 0
 3239 1bf8 5930C4E5 		strb	r3, [r4, #89]
 933:../uvc.c      **** 			  break;
 3240              		.loc 1 933 0
 3241 1bfc 0680A0E1 		mov	r8, r6
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3242              		.loc 1 931 0
 3243 1c00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3244              	.LVL256:
 3245 1c04 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 933:../uvc.c      **** 			  break;
 3246              		.loc 1 933 0
 3247 1c08 ACFFFFEA 		b	.L224
 3248              	.LVL257:
 3249              	.L216:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3250              		.loc 1 939 0
 3251 1c0c 94479FE5 		ldr	r4, .L298+8
 3252 1c10 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3253              		.loc 1 940 0
 3254 1c14 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3255              		.loc 1 941 0
 3256 1c18 0080A0E3 		mov	r8, #0
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3257              		.loc 1 947 0
 3258 1c1c 0700A0E1 		mov	r0, r7
 3259              	.LVL258:
 3260 1c20 581084E2 		add	r1, r4, #88
 952:../uvc.c      **** 			  break;
 3261              		.loc 1 952 0
 3262 1c24 FF60A0E3 		mov	r6, #255
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3263              		.loc 1 940 0
 3264 1c28 59C0C4E5 		strb	ip, [r4, #89]
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3265              		.loc 1 941 0
 3266 1c2c 5A80C4E5 		strb	r8, [r4, #90]
 942:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3267              		.loc 1 942 0
 3268 1c30 5B80C4E5 		strb	r8, [r4, #91]
 3269              	.LVL259:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3270              		.loc 1 939 0
 3271 1c34 58A0C4E5 		strb	sl, [r4, #88]
 952:../uvc.c      **** 			  break;
 3272              		.loc 1 952 0
 3273 1c38 0680A0E1 		mov	r8, r6
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3274              		.loc 1 947 0
 3275 1c3c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3276              	.LVL260:
 3277 1c40 0AC0A0E1 		mov	ip, sl
 952:../uvc.c      **** 			  break;
 3278              		.loc 1 952 0
 3279 1c44 9DFFFFEA 		b	.L224
 3280              	.LVL261:
 3281              	.L218:
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3282              		.loc 1 963 0
 3283 1c48 58479FE5 		ldr	r4, .L298+8
 3284 1c4c 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3285              	.LVL262:
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3286              		.loc 1 964 0
 3287 1c50 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3288              		.loc 1 965 0
 3289 1c54 0A0050E3 		cmp	r0, #10
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3290              		.loc 1 963 0
 3291 1c58 5830C4E5 		strb	r3, [r4, #88]
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3292              		.loc 1 964 0
 3293 1c5c 59E0C4E5 		strb	lr, [r4, #89]
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3294              		.loc 1 965 0
 3295 1c60 AEFFFF1A 		bne	.L231
 3296 1c64 DAFFFFEA 		b	.L292
 3297              	.LVL263:
 3298              	.L294:
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3299              		.loc 1 987 0
 3300 1c68 38479FE5 		ldr	r4, .L298+8
 3301 1c6c 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3302              		.loc 1 988 0
 3303 1c70 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3304              		.loc 1 989 0
 3305 1c74 0A0050E3 		cmp	r0, #10
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3306              		.loc 1 987 0
 3307 1c78 5860C4E5 		strb	r6, [r4, #88]
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3308              		.loc 1 988 0
 3309 1c7c 59C0C4E5 		strb	ip, [r4, #89]
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3310              		.loc 1 989 0
 3311 1c80 A6FFFF1A 		bne	.L231
 3312 1c84 D2FFFFEA 		b	.L292
 3313              	.L221:
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3314              		.loc 1 981 0
 3315 1c88 18479FE5 		ldr	r4, .L298+8
 3316 1c8c 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3317              	.LVL264:
 3318 1c90 0410A0E1 		mov	r1, r4
 3319 1c94 5800E1E5 		strb	r0, [r1, #88]!
 985:../uvc.c      **** 			  break;
 3320              		.loc 1 985 0
 3321 1c98 FF60A0E3 		mov	r6, #255
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3322              		.loc 1 982 0
 3323 1c9c 0100A0E3 		mov	r0, #1
 3324 1ca0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3325              	.LVL265:
 985:../uvc.c      **** 			  break;
 3326              		.loc 1 985 0
 3327 1ca4 0680A0E1 		mov	r8, r6
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3328              		.loc 1 982 0
 3329 1ca8 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 985:../uvc.c      **** 			  break;
 3330              		.loc 1 985 0
 3331 1cac 0170A0E3 		mov	r7, #1
 3332 1cb0 82FFFFEA 		b	.L224
 3333              	.LVL266:
 3334              	.L237:
1111:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3335              		.loc 1 1111 0
 3336 1cb4 FC669FE5 		ldr	r6, .L298+24
 3337 1cb8 0010E0E3 		mvn	r1, #0
 3338 1cbc 1C0096E5 		ldr	r0, [r6, #28]
 3339 1cc0 2C308DE5 		str	r3, [sp, #44]
 3340 1cc4 FEFFFFEB 		bl	_txe_mutex_get
1112:../uvc.c      **** 					  if(getData == 1)
 3341              		.loc 1 1112 0
 3342 1cc8 30E09DE5 		ldr	lr, [sp, #48]
 3343 1ccc 2C309DE5 		ldr	r3, [sp, #44]
 3344 1cd0 01005EE3 		cmp	lr, #1
 3345 1cd4 A901000A 		beq	.L296
1114:../uvc.c      **** 					  else if(getData == 0xff)
 3346              		.loc 1 1114 0
 3347 1cd8 FF005EE3 		cmp	lr, #255
 3348 1cdc 9E01000A 		beq	.L297
1117:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 3349              		.loc 1 1117 0
 3350 1ce0 0080A0E3 		mov	r8, #0
 3351 1ce4 0600A0E1 		mov	r0, r6
 3352 1ce8 2310A0E3 		mov	r1, #35
 3353 1cec 0B20A0E1 		mov	r2, fp
 3354 1cf0 00808DE5 		str	r8, [sp, #0]
 3355 1cf4 04808DE5 		str	r8, [sp, #4]
 3356 1cf8 FEFFFFEB 		bl	cmdSet
 3357              	.L290:
1120:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3358              		.loc 1 1120 0
 3359 1cfc 1C0096E5 		ldr	r0, [r6, #28]
 3360 1d00 FEFFFFEB 		bl	_txe_mutex_put
1122:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3361              		.loc 1 1122 0
 3362 1d04 30809DE5 		ldr	r8, [sp, #48]
 3363 1d08 34609DE5 		ldr	r6, [sp, #52]
 3364 1d0c 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3365 1d10 0400A0E3 		mov	r0, #4
 3366 1d14 A0169FE5 		ldr	r1, .L298+28
 3367 1d18 0820A0E1 		mov	r2, r8
 3368 1d1c 0630A0E1 		mov	r3, r6
 3369 1d20 00C08DE5 		str	ip, [sp, #0]
 3370 1d24 FEFFFFEB 		bl	CyU3PDebugPrint
1123:../uvc.c      **** 					  break;
 3371              		.loc 1 1123 0
 3372 1d28 FFC0A0E3 		mov	ip, #255
 3373 1d2c 63FFFFEA 		b	.L224
 3374              	.LVL267:
 3375              	.L236:
1088:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3376              		.loc 1 1088 0
 3377 1d30 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3378 1d34 010058E3 		cmp	r8, #1
 3379 1d38 08005813 		cmpne	r8, #8
 3380 1d3c 0000A013 		movne	r0, #0
 3381 1d40 0100A003 		moveq	r0, #1
 3382 1d44 8001001A 		bne	.L287
 3383              	.LVL268:
1091:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3384              		.loc 1 1091 0
 3385 1d48 68869FE5 		ldr	r8, .L298+24
 3386 1d4c 0010E0E3 		mvn	r1, #0
 3387 1d50 1C0098E5 		ldr	r0, [r8, #28]
 3388 1d54 2C308DE5 		str	r3, [sp, #44]
 3389 1d58 FEFFFFEB 		bl	_txe_mutex_get
1092:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3390              		.loc 1 1092 0
 3391 1d5c 30A09DE5 		ldr	sl, [sp, #48]
 3392 1d60 2210A0E3 		mov	r1, #34
 3393 1d64 0B20A0E1 		mov	r2, fp
 3394 1d68 2C309DE5 		ldr	r3, [sp, #44]
 3395 1d6c 00C0A0E3 		mov	ip, #0
 3396 1d70 0800A0E1 		mov	r0, r8
 3397 1d74 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3398 1d78 FEFFFFEB 		bl	cmdSet
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3399              		.loc 1 1093 0
 3400 1d7c 1C0098E5 		ldr	r0, [r8, #28]
 3401 1d80 FEFFFFEB 		bl	_txe_mutex_put
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3402              		.loc 1 1096 0
 3403 1d84 18069FE5 		ldr	r0, .L298+4
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3404              		.loc 1 1097 0
 3405 1d88 34209DE5 		ldr	r2, [sp, #52]
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3406              		.loc 1 1096 0
 3407 1d8c 061089E0 		add	r1, r9, r6
 3408 1d90 813180E0 		add	r3, r0, r1, asl #3
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3409              		.loc 1 1098 0
 3410 1d94 0160A0E3 		mov	r6, #1
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3411              		.loc 1 1096 0
 3412 1d98 9DA4C3E5 		strb	sl, [r3, #1181]
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3413              		.loc 1 1097 0
 3414 1d9c 9E24C3E5 		strb	r2, [r3, #1182]
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3415              		.loc 1 1098 0
 3416 1da0 A064C3E5 		strb	r6, [r3, #1184]
 3417              	.LVL269:
 3418              	.L288:
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3419              		.loc 1 1100 0
 3420 1da4 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3421 1da8 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1105:../uvc.c      **** 					  break;
 3422              		.loc 1 1105 0
 3423 1dac FFC0A0E3 		mov	ip, #255
 3424 1db0 42FFFFEA 		b	.L224
 3425              	.LVL270:
 3426              	.L235:
1054:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3427              		.loc 1 1054 0
 3428 1db4 B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3429 1db8 010050E3 		cmp	r0, #1
 3430 1dbc 04005013 		cmpne	r0, #4
 3431 1dc0 5C01001A 		bne	.L245
1053:../uvc.c      **** 					  value = (value << 8)|Data0;
 3432              		.loc 1 1053 0
 3433 1dc4 30109DE5 		ldr	r1, [sp, #48]
 3434 1dc8 34E09DE5 		ldr	lr, [sp, #52]
 3435 1dcc 0E2481E1 		orr	r2, r1, lr, asl #8
1055:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3436              		.loc 1 1055 0
 3437 1dd0 F90052E3 		cmp	r2, #249
 3438 1dd4 5701008A 		bhi	.L245
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3439              		.loc 1 1060 0
 3440 1dd8 C8A042E2 		sub	sl, r2, #200
 3441 1ddc 0AC8A0E1 		mov	ip, sl, asl #16
 3442 1de0 3CC08DE5 		str	ip, [sp, #60]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3443              		.loc 1 1062 0
 3444 1de4 27A062E2 		rsb	sl, r2, #39
 3445 1de8 38A08DE5 		str	sl, [sp, #56]
 3446 1dec 3CA09DE5 		ldr	sl, [sp, #60]
 3447 1df0 C81062E2 		rsb	r1, r2, #200
 3448 1df4 C80052E3 		cmp	r2, #200
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3449              		.loc 1 1060 0
 3450 1df8 640042E2 		sub	r0, r2, #100
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3451              		.loc 1 1062 0
 3452 1dfc 0118A0E1 		mov	r1, r1, asl #16
 3453 1e00 64E062E2 		rsb	lr, r2, #100
 3454 1e04 2A18A081 		movhi	r1, sl, lsr #16
 3455 1e08 2118A091 		movls	r1, r1, lsr #16
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3456              		.loc 1 1060 0
 3457 1e0c 00C8A0E1 		mov	ip, r0, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3458              		.loc 1 1062 0
 3459 1e10 640052E3 		cmp	r2, #100
 3460 1e14 0E08A0E1 		mov	r0, lr, asl #16
 3461 1e18 2C08A081 		movhi	r0, ip, lsr #16
 3462 1e1c 38C09DE5 		ldr	ip, [sp, #56]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3463              		.loc 1 1060 0
 3464 1e20 14A042E2 		sub	sl, r2, #20
 3465 1e24 38A08DE5 		str	sl, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3466              		.loc 1 1062 0
 3467 1e28 2008A091 		movls	r0, r0, lsr #16
 3468 1e2c 14A062E2 		rsb	sl, r2, #20
 3469 1e30 3CA08DE5 		str	sl, [sp, #60]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3470              		.loc 1 1060 0
 3471 1e34 27E042E2 		sub	lr, r2, #39
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3472              		.loc 1 1062 0
 3473 1e38 000051E1 		cmp	r1, r0
 3474 1e3c 01A0A031 		movcc	sl, r1
 3475 1e40 00A0A021 		movcs	sl, r0
 3476 1e44 0CC8A0E1 		mov	ip, ip, asl #16
 3477 1e48 270052E3 		cmp	r2, #39
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3478              		.loc 1 1060 0
 3479 1e4c 0EE8A0E1 		mov	lr, lr, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3480              		.loc 1 1062 0
 3481 1e50 2CE8A091 		movls	lr, ip, lsr #16
 3482 1e54 64C59FE5 		ldr	ip, .L298+32
 3483 1e58 20A08DE5 		str	sl, [sp, #32]
 3484 1e5c 01A06CE0 		rsb	sl, ip, r1
 3485 1e60 2EE8A081 		movhi	lr, lr, lsr #16
 3486 1e64 00C07AE2 		rsbs	ip, sl, #0
 3487 1e68 0AC0ACE0 		adc	ip, ip, sl
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3488              		.loc 1 1060 0
 3489 1e6c 38A09DE5 		ldr	sl, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3490              		.loc 1 1062 0
 3491 1e70 44C08DE5 		str	ip, [sp, #68]
 3492              	.LVL271:
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3493              		.loc 1 1060 0
 3494 1e74 0AC8A0E1 		mov	ip, sl, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3495              		.loc 1 1062 0
 3496 1e78 3CA09DE5 		ldr	sl, [sp, #60]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3497              		.loc 1 1060 0
 3498 1e7c 4CC08DE5 		str	ip, [sp, #76]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3499              		.loc 1 1062 0
 3500 1e80 0AC8A0E1 		mov	ip, sl, asl #16
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3501              		.loc 1 1060 0
 3502 1e84 0AA042E2 		sub	sl, r2, #10
 3503 1e88 48A08DE5 		str	sl, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3504              		.loc 1 1062 0
 3505 1e8c 20A09DE5 		ldr	sl, [sp, #32]
 3506 1e90 3CC08DE5 		str	ip, [sp, #60]
 3507 1e94 0A005EE1 		cmp	lr, sl
 3508 1e98 0EA0A031 		movcc	sl, lr
 3509 1e9c 0AC062E2 		rsb	ip, r2, #10
 3510 1ea0 40C08DE5 		str	ip, [sp, #64]
 3511 1ea4 38A08DE5 		str	sl, [sp, #56]
 3512 1ea8 3CC09DE5 		ldr	ip, [sp, #60]
 3513 1eac 4CA09DE5 		ldr	sl, [sp, #76]
 3514 1eb0 140052E3 		cmp	r2, #20
 3515 1eb4 2CA8A091 		movls	sl, ip, lsr #16
 3516 1eb8 2AA8A081 		movhi	sl, sl, lsr #16
 3517 1ebc 44C09DE5 		ldr	ip, [sp, #68]
 3518 1ec0 010050E1 		cmp	r0, r1
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3519              		.loc 1 1060 0
 3520 1ec4 48109DE5 		ldr	r1, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3521              		.loc 1 1062 0
 3522 1ec8 01C0A033 		movcc	ip, #1
 3523 1ecc 3CA08DE5 		str	sl, [sp, #60]
 3524 1ed0 24C08DE5 		str	ip, [sp, #36]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3525              		.loc 1 1060 0
 3526 1ed4 01A8A0E1 		mov	sl, r1, asl #16
 3527 1ed8 05C042E2 		sub	ip, r2, #5
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3528              		.loc 1 1062 0
 3529 1edc 051062E2 		rsb	r1, r2, #5
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3530              		.loc 1 1060 0
 3531 1ee0 48A08DE5 		str	sl, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3532              		.loc 1 1062 0
 3533 1ee4 40009DE5 		ldr	r0, [sp, #64]
 3534 1ee8 38A09DE5 		ldr	sl, [sp, #56]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3535              		.loc 1 1060 0
 3536 1eec 40C08DE5 		str	ip, [sp, #64]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3537              		.loc 1 1062 0
 3538 1ef0 3CC09DE5 		ldr	ip, [sp, #60]
 3539 1ef4 4C108DE5 		str	r1, [sp, #76]
 3540 1ef8 48109DE5 		ldr	r1, [sp, #72]
 3541 1efc 0008A0E1 		mov	r0, r0, asl #16
 3542 1f00 0A005CE1 		cmp	ip, sl
 3543 1f04 0AC0A021 		movcs	ip, sl
 3544 1f08 0A0052E3 		cmp	r2, #10
 3545 1f0c 20A09DE5 		ldr	sl, [sp, #32]
 3546 1f10 2108A081 		movhi	r0, r1, lsr #16
 3547 1f14 2008A091 		movls	r0, r0, lsr #16
 3548 1f18 48008DE5 		str	r0, [sp, #72]
 3549 1f1c 24009DE5 		ldr	r0, [sp, #36]
 3550 1f20 0A005EE1 		cmp	lr, sl
 3551 1f24 0200A033 		movcc	r0, #2
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3552              		.loc 1 1060 0
 3553 1f28 02E042E2 		sub	lr, r2, #2
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3554              		.loc 1 1062 0
 3555 1f2c 44C08DE5 		str	ip, [sp, #68]
 3556 1f30 24008DE5 		str	r0, [sp, #36]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3557              		.loc 1 1060 0
 3558 1f34 40C09DE5 		ldr	ip, [sp, #64]
 3559 1f38 1CE08DE5 		str	lr, [sp, #28]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3560              		.loc 1 1062 0
 3561 1f3c 44009DE5 		ldr	r0, [sp, #68]
 3562 1f40 48E09DE5 		ldr	lr, [sp, #72]
 3563 1f44 4C109DE5 		ldr	r1, [sp, #76]
 3564 1f48 02A062E2 		rsb	sl, r2, #2
 3565 1f4c 00005EE1 		cmp	lr, r0
 3566 1f50 00E0A021 		movcs	lr, r0
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3567              		.loc 1 1060 0
 3568 1f54 0CC8A0E1 		mov	ip, ip, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3569              		.loc 1 1062 0
 3570 1f58 050052E3 		cmp	r2, #5
 3571 1f5c 40A08DE5 		str	sl, [sp, #64]
 3572 1f60 0118A0E1 		mov	r1, r1, asl #16
 3573 1f64 3CA09DE5 		ldr	sl, [sp, #60]
 3574 1f68 2C18A081 		movhi	r1, ip, lsr #16
 3575 1f6c 38C09DE5 		ldr	ip, [sp, #56]
 3576 1f70 4CE08DE5 		str	lr, [sp, #76]
 3577 1f74 24009DE5 		ldr	r0, [sp, #36]
 3578 1f78 40E09DE5 		ldr	lr, [sp, #64]
 3579 1f7c 2118A091 		movls	r1, r1, lsr #16
 3580 1f80 0C005AE1 		cmp	sl, ip
 3581 1f84 20108DE5 		str	r1, [sp, #32]
 3582 1f88 0300A033 		movcc	r0, #3
 3583 1f8c 38008DE5 		str	r0, [sp, #56]
 3584 1f90 4CA09DE5 		ldr	sl, [sp, #76]
 3585 1f94 0E08A0E1 		mov	r0, lr, asl #16
 3586 1f98 20E09DE5 		ldr	lr, [sp, #32]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3587              		.loc 1 1060 0
 3588 1f9c 1C109DE5 		ldr	r1, [sp, #28]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3589              		.loc 1 1062 0
 3590 1fa0 0A005EE1 		cmp	lr, sl
 3591 1fa4 0AE0A021 		movcs	lr, sl
 3592 1fa8 44C09DE5 		ldr	ip, [sp, #68]
 3593 1fac 48A09DE5 		ldr	sl, [sp, #72]
 3594 1fb0 020052E3 		cmp	r2, #2
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3595              		.loc 1 1060 0
 3596 1fb4 0118A0E1 		mov	r1, r1, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3597              		.loc 1 1062 0
 3598 1fb8 2018A091 		movls	r1, r0, lsr #16
 3599 1fbc 38009DE5 		ldr	r0, [sp, #56]
 3600 1fc0 2118A081 		movhi	r1, r1, lsr #16
 3601 1fc4 0C005AE1 		cmp	sl, ip
 3602 1fc8 0400A033 		movcc	r0, #4
 3603 1fcc 40008DE5 		str	r0, [sp, #64]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3604              		.loc 1 1060 0
 3605 1fd0 010042E2 		sub	r0, r2, #1
 3606 1fd4 38008DE5 		str	r0, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3607              		.loc 1 1062 0
 3608 1fd8 4CA09DE5 		ldr	sl, [sp, #76]
 3609 1fdc 20009DE5 		ldr	r0, [sp, #32]
 3610 1fe0 01C062E2 		rsb	ip, r2, #1
 3611 1fe4 3CC08DE5 		str	ip, [sp, #60]
 3612 1fe8 0A0050E1 		cmp	r0, sl
1069:../uvc.c      **** 						  shutter = shutter+index;
 3613              		.loc 1 1069 0
 3614 1fec 38A09DE5 		ldr	sl, [sp, #56]
 3615 1ff0 3C009DE5 		ldr	r0, [sp, #60]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3616              		.loc 1 1062 0
 3617 1ff4 40C09DE5 		ldr	ip, [sp, #64]
 3618 1ff8 05C0A033 		movcc	ip, #5
1069:../uvc.c      **** 						  shutter = shutter+index;
 3619              		.loc 1 1069 0
 3620 1ffc 010052E3 		cmp	r2, #1
 3621 2000 0028A091 		movls	r2, r0, asl #16
 3622 2004 0A28A081 		movhi	r2, sl, asl #16
 3623 2008 0E0051E1 		cmp	r1, lr
 3624 200c 01A0A031 		movcc	sl, r1
 3625 2010 0EA0A021 		movcs	sl, lr
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3626              		.loc 1 1062 0
 3627 2014 0E0051E1 		cmp	r1, lr
 3628 2018 0C10A021 		movcs	r1, ip
 3629 201c 0610A033 		movcc	r1, #6
1069:../uvc.c      **** 						  shutter = shutter+index;
 3630              		.loc 1 1069 0
 3631 2020 22085AE1 		cmp	sl, r2, lsr #16
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3632              		.loc 1 1072 0
 3633 2024 8CA39FE5 		ldr	sl, .L298+24
1069:../uvc.c      **** 						  shutter = shutter+index;
 3634              		.loc 1 1069 0
 3635 2028 0120A091 		movls	r2, r1
 3636 202c 0720A083 		movhi	r2, #7
 3637 2030 012082E2 		add	r2, r2, #1
 3638 2034 FFE002E2 		and	lr, r2, #255
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3639              		.loc 1 1072 0
 3640 2038 0010E0E3 		mvn	r1, #0
 3641 203c 1C009AE5 		ldr	r0, [sl, #28]
1069:../uvc.c      **** 						  shutter = shutter+index;
 3642              		.loc 1 1069 0
 3643 2040 38E08DE5 		str	lr, [sp, #56]
 3644              	.LVL272:
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3645              		.loc 1 1072 0
 3646 2044 2C308DE5 		str	r3, [sp, #44]
 3647 2048 FEFFFFEB 		bl	_txe_mutex_get
1073:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3648              		.loc 1 1073 0
 3649 204c 38C09DE5 		ldr	ip, [sp, #56]
 3650 2050 0310A0E3 		mov	r1, #3
 3651 2054 0B20A0E1 		mov	r2, fp
 3652 2058 2C309DE5 		ldr	r3, [sp, #44]
 3653 205c 00C08DE5 		str	ip, [sp, #0]
 3654 2060 0A00A0E1 		mov	r0, sl
 3655 2064 00C0A0E3 		mov	ip, #0
 3656 2068 04C08DE5 		str	ip, [sp, #4]
 3657 206c FEFFFFEB 		bl	cmdSet
1074:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3658              		.loc 1 1074 0
 3659 2070 1C009AE5 		ldr	r0, [sl, #28]
 3660 2074 FEFFFFEB 		bl	_txe_mutex_put
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3661              		.loc 1 1077 0
 3662 2078 30009DE5 		ldr	r0, [sp, #48]
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3663              		.loc 1 1078 0
 3664 207c 34C09DE5 		ldr	ip, [sp, #52]
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3665              		.loc 1 1080 0
 3666 2080 38309DE5 		ldr	r3, [sp, #56]
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3667              		.loc 1 1077 0
 3668 2084 061089E0 		add	r1, r9, r6
 3669 2088 816188E0 		add	r6, r8, r1, asl #3
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3670              		.loc 1 1079 0
 3671 208c 0120A0E3 		mov	r2, #1
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3672              		.loc 1 1077 0
 3673 2090 9D04C6E5 		strb	r0, [r6, #1181]
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3674              		.loc 1 1078 0
 3675 2094 9EC4C6E5 		strb	ip, [r6, #1182]
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3676              		.loc 1 1079 0
 3677 2098 A024C6E5 		strb	r2, [r6, #1184]
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3678              		.loc 1 1080 0
 3679 209c 0D33C8E5 		strb	r3, [r8, #781]
 3680 20a0 3FFFFFEA 		b	.L288
 3681              	.LVL273:
 3682              	.L234:
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3683              		.loc 1 1007 0
 3684 20a4 062089E0 		add	r2, r9, r6
 3685 20a8 826188E0 		add	r6, r8, r2, asl #3
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3686              		.loc 1 1008 0
 3687 20ac 0110A0E3 		mov	r1, #1
1011:../uvc.c      **** 		  		    switch (getData){
 3688              		.loc 1 1011 0
 3689 20b0 01E040E2 		sub	lr, r0, #1
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3690              		.loc 1 1007 0
 3691 20b4 9D04C6E5 		strb	r0, [r6, #1181]
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3692              		.loc 1 1008 0
 3693 20b8 A014C6E5 		strb	r1, [r6, #1184]
 3694              	.LVL274:
1011:../uvc.c      **** 		  		    switch (getData){
 3695              		.loc 1 1011 0
 3696 20bc 07005EE3 		cmp	lr, #7
 3697 20c0 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3698 20c4 970000EA 		b	.L239
 3699              	.L244:
 3700 20c8 BC220000 		.word	.L240
 3701 20cc 20220000 		.word	.L241
 3702 20d0 28230000 		.word	.L239
 3703 20d4 BC210000 		.word	.L242
 3704 20d8 28230000 		.word	.L239
 3705 20dc 28230000 		.word	.L239
 3706 20e0 28230000 		.word	.L239
 3707 20e4 1C210000 		.word	.L243
 3708              	.LVL275:
 3709              	.L233:
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3710              		.loc 1 1127 0
 3711 20e8 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3712              		.loc 1 1126 0
 3713 20ec 30A09DE5 		ldr	sl, [sp, #48]
 3714 20f0 069089E0 		add	r9, r9, r6
 3715 20f4 89E188E0 		add	lr, r8, r9, asl #3
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3716              		.loc 1 1127 0
 3717 20f8 0620A0E1 		mov	r2, r6
 3718 20fc 0400A0E3 		mov	r0, #4
 3719 2100 BC129FE5 		ldr	r1, .L298+36
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3720              		.loc 1 1126 0
 3721 2104 9DA4CEE5 		strb	sl, [lr, #1181]
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3722              		.loc 1 1127 0
 3723 2108 FEFFFFEB 		bl	CyU3PDebugPrint
1128:../uvc.c      **** 			  		 break;
 3724              		.loc 1 1128 0
 3725 210c FFC0A0E3 		mov	ip, #255
 3726 2110 0C60A0E1 		mov	r6, ip
 3727 2114 0C80A0E1 		mov	r8, ip
 3728 2118 68FEFFEA 		b	.L224
 3729              	.LVL276:
 3730              	.L243:
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3731              		.loc 1 1030 0
 3732 211c 94629FE5 		ldr	r6, .L298+24
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3733              		.loc 1 1028 0
 3734 2120 00A0A0E3 		mov	sl, #0
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3735              		.loc 1 1030 0
 3736 2124 1C0096E5 		ldr	r0, [r6, #28]
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3737              		.loc 1 1028 0
 3738 2128 0DA3C8E5 		strb	sl, [r8, #781]
 3739              	.LVL277:
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3740              		.loc 1 1030 0
 3741 212c 0010E0E3 		mvn	r1, #0
 3742 2130 2C308DE5 		str	r3, [sp, #44]
 3743 2134 FEFFFFEB 		bl	_txe_mutex_get
1031:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3744              		.loc 1 1031 0
 3745 2138 0B20A0E1 		mov	r2, fp
 3746 213c 2C309DE5 		ldr	r3, [sp, #44]
 3747 2140 1010A0E3 		mov	r1, #16
 3748 2144 0600A0E1 		mov	r0, r6
 3749 2148 00A08DE5 		str	sl, [sp, #0]
 3750 214c 04A08DE5 		str	sl, [sp, #4]
 3751 2150 FEFFFFEB 		bl	cmdSet
1032:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3752              		.loc 1 1032 0
 3753 2154 1C0096E5 		ldr	r0, [r6, #28]
 3754 2158 FEFFFFEB 		bl	_txe_mutex_put
 3755              	.LVL278:
 3756              	.LBB66:
 3757              	.LBB67:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3758              		.loc 1 384 0
 3759 215c 0010E0E3 		mvn	r1, #0
 3760 2160 1C0096E5 		ldr	r0, [r6, #28]
 3761 2164 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3762              		.loc 1 385 0
 3763 2168 0180A0E3 		mov	r8, #1
 3764 216c 2010A0E3 		mov	r1, #32
 3765 2170 2720A0E3 		mov	r2, #39
 3766 2174 3030A0E3 		mov	r3, #48
 3767 2178 0600A0E1 		mov	r0, r6
 3768 217c 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3769 2180 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3770              		.loc 1 386 0
 3771 2184 02C0A0E3 		mov	ip, #2
 3772 2188 2110A0E3 		mov	r1, #33
 3773 218c 2520A0E3 		mov	r2, #37
 3774 2190 3030A0E3 		mov	r3, #48
 3775 2194 0600A0E1 		mov	r0, r6
 3776 2198 00C08DE5 		str	ip, [sp, #0]
 3777 219c 04A08DE5 		str	sl, [sp, #4]
 3778 21a0 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3779              		.loc 1 387 0
 3780 21a4 1C0096E5 		ldr	r0, [r6, #28]
 3781 21a8 FEFFFFEB 		bl	_txe_mutex_put
 3782              	.LBE67:
 3783              	.LBE66:
1034:../uvc.c      **** 							break;
 3784              		.loc 1 1034 0
 3785 21ac FFC0A0E3 		mov	ip, #255
 3786 21b0 0C60A0E1 		mov	r6, ip
 3787 21b4 0880A0E3 		mov	r8, #8
 3788 21b8 40FEFFEA 		b	.L224
 3789              	.LVL279:
 3790              	.L242:
 3791              	.LBB68:
 3792              	.LBB69:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3793              		.loc 1 384 0
 3794 21bc F4819FE5 		ldr	r8, .L298+24
 3795 21c0 0010E0E3 		mvn	r1, #0
 3796 21c4 1C0098E5 		ldr	r0, [r8, #28]
 3797 21c8 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3798              		.loc 1 385 0
 3799 21cc 0060A0E3 		mov	r6, #0
 3800 21d0 2010A0E3 		mov	r1, #32
 3801 21d4 2720A0E3 		mov	r2, #39
 3802 21d8 3030A0E3 		mov	r3, #48
 3803 21dc 0800A0E1 		mov	r0, r8
 3804 21e0 00608DE5 		str	r6, [sp, #0]
 3805 21e4 04608DE5 		str	r6, [sp, #4]
 3806 21e8 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3807              		.loc 1 386 0
 3808 21ec 2110A0E3 		mov	r1, #33
 3809 21f0 2520A0E3 		mov	r2, #37
 3810 21f4 3030A0E3 		mov	r3, #48
 3811 21f8 0800A0E1 		mov	r0, r8
 3812 21fc 00608DE5 		str	r6, [sp, #0]
 3813 2200 04608DE5 		str	r6, [sp, #4]
 3814 2204 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3815              		.loc 1 387 0
 3816 2208 1C0098E5 		ldr	r0, [r8, #28]
 3817 220c FEFFFFEB 		bl	_txe_mutex_put
 3818 2210 FFC0A0E3 		mov	ip, #255
 3819 2214 0C60A0E1 		mov	r6, ip
 3820 2218 0480A0E3 		mov	r8, #4
 3821 221c 27FEFFEA 		b	.L224
 3822              	.LVL280:
 3823              	.L241:
 3824              	.LBE69:
 3825              	.LBE68:
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3826              		.loc 1 1018 0
 3827 2220 90A19FE5 		ldr	sl, .L298+24
1016:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3828              		.loc 1 1016 0
 3829 2224 0060A0E3 		mov	r6, #0
 3830 2228 0D63C8E5 		strb	r6, [r8, #781]
 3831              	.LVL281:
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3832              		.loc 1 1018 0
 3833 222c 0010E0E3 		mvn	r1, #0
 3834 2230 1C009AE5 		ldr	r0, [sl, #28]
 3835 2234 2C308DE5 		str	r3, [sp, #44]
 3836 2238 FEFFFFEB 		bl	_txe_mutex_get
1019:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3837              		.loc 1 1019 0
 3838 223c 0B20A0E1 		mov	r2, fp
 3839 2240 2C309DE5 		ldr	r3, [sp, #44]
 3840 2244 1010A0E3 		mov	r1, #16
 3841 2248 0A00A0E1 		mov	r0, sl
 3842 224c 00608DE5 		str	r6, [sp, #0]
 3843 2250 04608DE5 		str	r6, [sp, #4]
 3844 2254 FEFFFFEB 		bl	cmdSet
1020:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3845              		.loc 1 1020 0
 3846 2258 1C009AE5 		ldr	r0, [sl, #28]
 3847 225c FEFFFFEB 		bl	_txe_mutex_put
 3848              	.LVL282:
 3849              	.LBB70:
 3850              	.LBB71:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3851              		.loc 1 384 0
 3852 2260 0010E0E3 		mvn	r1, #0
 3853 2264 1C009AE5 		ldr	r0, [sl, #28]
 3854 2268 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3855              		.loc 1 385 0
 3856 226c 2010A0E3 		mov	r1, #32
 3857 2270 2720A0E3 		mov	r2, #39
 3858 2274 3030A0E3 		mov	r3, #48
 3859 2278 0A00A0E1 		mov	r0, sl
 3860 227c 00608DE5 		str	r6, [sp, #0]
 3861 2280 04608DE5 		str	r6, [sp, #4]
 3862 2284 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3863              		.loc 1 386 0
 3864 2288 2110A0E3 		mov	r1, #33
 3865 228c 2520A0E3 		mov	r2, #37
 3866 2290 3030A0E3 		mov	r3, #48
 3867 2294 0A00A0E1 		mov	r0, sl
 3868 2298 00608DE5 		str	r6, [sp, #0]
 3869 229c 04608DE5 		str	r6, [sp, #4]
 3870 22a0 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3871              		.loc 1 387 0
 3872 22a4 1C009AE5 		ldr	r0, [sl, #28]
 3873 22a8 FEFFFFEB 		bl	_txe_mutex_put
 3874 22ac FFC0A0E3 		mov	ip, #255
 3875 22b0 0C60A0E1 		mov	r6, ip
 3876 22b4 0280A0E3 		mov	r8, #2
 3877 22b8 00FEFFEA 		b	.L224
 3878              	.LVL283:
 3879              	.L240:
 3880              	.LBE71:
 3881              	.LBE70:
 3882              	.LBB72:
 3883              	.LBB73:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3884              		.loc 1 384 0
 3885 22bc F4609FE5 		ldr	r6, .L298+24
 3886 22c0 0010E0E3 		mvn	r1, #0
 3887 22c4 1C0096E5 		ldr	r0, [r6, #28]
 3888 22c8 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3889              		.loc 1 385 0
 3890 22cc 0080A0E3 		mov	r8, #0
 3891 22d0 01A0A0E3 		mov	sl, #1
 3892 22d4 2010A0E3 		mov	r1, #32
 3893 22d8 2720A0E3 		mov	r2, #39
 3894 22dc 3030A0E3 		mov	r3, #48
 3895 22e0 0600A0E1 		mov	r0, r6
 3896 22e4 04808DE5 		str	r8, [sp, #4]
 3897 22e8 00A08DE5 		str	sl, [sp, #0]
 3898 22ec FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3899              		.loc 1 386 0
 3900 22f0 02C0A0E3 		mov	ip, #2
 3901 22f4 2110A0E3 		mov	r1, #33
 3902 22f8 2520A0E3 		mov	r2, #37
 3903 22fc 3030A0E3 		mov	r3, #48
 3904 2300 0600A0E1 		mov	r0, r6
 3905 2304 00C08DE5 		str	ip, [sp, #0]
 3906 2308 04808DE5 		str	r8, [sp, #4]
 3907 230c FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3908              		.loc 1 387 0
 3909 2310 1C0096E5 		ldr	r0, [r6, #28]
 3910 2314 FEFFFFEB 		bl	_txe_mutex_put
 3911              	.LBE73:
 3912              	.LBE72:
1014:../uvc.c      **** 							break;
 3913              		.loc 1 1014 0
 3914 2318 FFC0A0E3 		mov	ip, #255
 3915 231c 0C60A0E1 		mov	r6, ip
 3916 2320 0A80A0E1 		mov	r8, sl
 3917 2324 E5FDFFEA 		b	.L224
 3918              	.LVL284:
 3919              	.L239:
1011:../uvc.c      **** 		  		    switch (getData){
 3920              		.loc 1 1011 0
 3921 2328 FFC0A0E3 		mov	ip, #255
 3922 232c 0080A0E1 		mov	r8, r0
 3923 2330 0C60A0E1 		mov	r6, ip
 3924 2334 E1FDFFEA 		b	.L224
 3925              	.LVL285:
 3926              	.L245:
1082:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3927              		.loc 1 1082 0
 3928 2338 0000A0E3 		mov	r0, #0
 3929 233c 0110A0E3 		mov	r1, #1
 3930 2340 0020A0E1 		mov	r2, r0
 3931 2344 FEFFFFEB 		bl	CyU3PUsbStall
 3932              	.LVL286:
 3933 2348 95FEFFEA 		b	.L288
 3934              	.LVL287:
 3935              	.L287:
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3936              		.loc 1 1100 0
 3937 234c 0110A0E3 		mov	r1, #1
 3938 2350 0020A0E1 		mov	r2, r0
 3939 2354 FEFFFFEB 		bl	CyU3PUsbStall
 3940 2358 91FEFFEA 		b	.L288
 3941              	.LVL288:
 3942              	.L297:
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3943              		.loc 1 1115 0
 3944 235c 08E0A0E3 		mov	lr, #8
 3945 2360 00C0A0E3 		mov	ip, #0
 3946 2364 0600A0E1 		mov	r0, r6
 3947 2368 2310A0E3 		mov	r1, #35
 3948 236c 0B20A0E1 		mov	r2, fp
 3949 2370 00E08DE5 		str	lr, [sp, #0]
 3950 2374 04C08DE5 		str	ip, [sp, #4]
 3951 2378 FEFFFFEB 		bl	cmdSet
 3952 237c 5EFEFFEA 		b	.L290
 3953              	.L296:
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3954              		.loc 1 1113 0
 3955 2380 0480A0E3 		mov	r8, #4
 3956 2384 00E0A0E3 		mov	lr, #0
 3957 2388 0600A0E1 		mov	r0, r6
 3958 238c 2310A0E3 		mov	r1, #35
 3959 2390 0B20A0E1 		mov	r2, fp
 3960 2394 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3961 2398 FEFFFFEB 		bl	cmdSet
 3962 239c 56FEFFEA 		b	.L290
 3963              	.L299:
 3964              		.align	2
 3965              	.L298:
 3966 23a0 00000000 		.word	bRequest
 3967 23a4 00000000 		.word	.LANCHOR1
 3968 23a8 00000000 		.word	.LANCHOR0
 3969 23ac 10040000 		.word	.LC25
 3970 23b0 34040000 		.word	.LC26
 3971 23b4 58000000 		.word	.LANCHOR0+88
 3972 23b8 00000000 		.word	cmdQu
 3973 23bc C4030000 		.word	.LC23
 3974 23c0 FFFF0000 		.word	65535
 3975 23c4 EC030000 		.word	.LC24
 3976              		.cfi_endproc
 3977              	.LFE3:
 3979              		.align	2
 3980              		.global	UVCAppEP0Thread_Entry
 3982              	UVCAppEP0Thread_Entry:
 3983              	.LFB24:
3094:../uvc.c      **** {
 3984              		.loc 1 3094 0
 3985              		.cfi_startproc
 3986              		@ args = 0, pretend = 0, frame = 32
 3987              		@ frame_needed = 0, uses_anonymous_args = 0
 3988              	.LVL289:
 3989 23c8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3990              	.LCFI17:
 3991              		.cfi_def_cfa_offset 36
 3992 23cc CC499FE5 		ldr	r4, .L447
 3993              		.cfi_offset 14, -4
 3994              		.cfi_offset 11, -8
 3995              		.cfi_offset 10, -12
 3996              		.cfi_offset 9, -16
 3997              		.cfi_offset 8, -20
 3998              		.cfi_offset 7, -24
 3999              		.cfi_offset 6, -28
 4000              		.cfi_offset 5, -32
 4001              		.cfi_offset 4, -36
 4002 23d0 CC699FE5 		ldr	r6, .L447+4
 4003 23d4 CCA99FE5 		ldr	sl, .L447+8
 4004 23d8 CC999FE5 		ldr	r9, .L447+12
 4005 23dc CC899FE5 		ldr	r8, .L447+16
 4006 23e0 CC799FE5 		ldr	r7, .L447+20
 4007 23e4 3CD04DE2 		sub	sp, sp, #60
 4008              	.LCFI18:
 4009              		.cfi_def_cfa_offset 96
 4010              	.LVL290:
3116:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4011              		.loc 1 3116 0
 4012 23e8 0450A0E1 		mov	r5, r4
 4013              	.LVL291:
 4014              	.L424:
 4015 23ec 00C0E0E3 		mvn	ip, #0
 4016 23f0 A8099FE5 		ldr	r0, .L447
 4017 23f4 4C10A0E3 		mov	r1, #76
 4018 23f8 0120A0E3 		mov	r2, #1
 4019 23fc 30308DE2 		add	r3, sp, #48
 4020 2400 00C08DE5 		str	ip, [sp, #0]
 4021 2404 FEFFFFEB 		bl	_txe_event_flags_get
 4022 2408 000050E3 		cmp	r0, #0
 4023 240c 3000001A 		bne	.L301
3120:../uvc.c      ****             if (!isUsbConnected)
 4024              		.loc 1 3120 0
 4025 2410 3C3095E5 		ldr	r3, [r5, #60]
 4026 2414 000053E3 		cmp	r3, #0
 4027 2418 8900000A 		beq	.L438
 4028              	.L302:
3129:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4029              		.loc 1 3129 0
 4030 241c 30309DE5 		ldr	r3, [sp, #48]
 4031 2420 0C0013E3 		tst	r3, #12
 4032 2424 7200001A 		bne	.L439
 4033              	.L303:
3136:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4034              		.loc 1 3136 0
 4035 2428 040013E3 		tst	r3, #4
 4036 242c 1C00000A 		beq	.L304
3138:../uvc.c      ****             	switch ((wIndex >> 8))
 4037              		.loc 1 3138 0
 4038 2430 B0E0D8E1 		ldrh	lr, [r8, #0]
 4039 2434 2E24A0E1 		mov	r2, lr, lsr #8
 4040 2438 030052E3 		cmp	r2, #3
 4041 243c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4042 2440 120000EA 		b	.L305
 4043              	.L310:
 4044 2444 90240000 		.word	.L305
 4045 2448 74250000 		.word	.L307
 4046 244c 54240000 		.word	.L308
 4047 2450 B0250000 		.word	.L309
 4048              	.L308:
 4049              	.LBB88:
 4050              	.LBB90:
2425:../uvc.c      ****     switch (wValue)
 4051              		.loc 1 2425 0
 4052 2454 B020D9E1 		ldrh	r2, [r9, #0]
 4053 2458 060C52E3 		cmp	r2, #1536
 4054 245c D501000A 		beq	.L316
 4055 2460 CC00008A 		bhi	.L322
 4056 2464 030C52E3 		cmp	r2, #768
 4057 2468 CE01000A 		beq	.L314
 4058 246c C501008A 		bhi	.L323
 4059 2470 010C52E3 		cmp	r2, #256
 4060 2474 6401000A 		beq	.L312
 4061 2478 020C52E3 		cmp	r2, #512
 4062 247c 5E01000A 		beq	.L440
 4063              	.L325:
 4064              	.LBE90:
 4065              	.LBE88:
 4066              	.LBB93:
 4067              	.LBB97:
2557:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4068              		.loc 1 2557 0
 4069 2480 30199FE5 		ldr	r1, .L447+24
 4070 2484 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4071 2488 0400A0E3 		mov	r0, #4
 4072 248c FEFFFFEB 		bl	CyU3PDebugPrint
 4073              	.L305:
 4074              	.LBE97:
 4075              	.LBE93:
3159:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4076              		.loc 1 3159 0
 4077 2490 0000A0E3 		mov	r0, #0
 4078 2494 0110A0E3 		mov	r1, #1
 4079 2498 0020A0E1 		mov	r2, r0
 4080 249c FEFFFFEB 		bl	CyU3PUsbStall
 4081 24a0 30309DE5 		ldr	r3, [sp, #48]
 4082              	.L304:
3164:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4083              		.loc 1 3164 0
 4084 24a4 080013E3 		tst	r3, #8
 4085 24a8 0700000A 		beq	.L366
3168:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4086              		.loc 1 3168 0
 4087 24ac B030D8E1 		ldrh	r3, [r8, #0]
 4088 24b0 010053E3 		cmp	r3, #1
 4089 24b4 6800000A 		beq	.L367
 4090              	.L368:
 4091              	.LBB102:
 4092              	.LBB108:
3083:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4093              		.loc 1 3083 0
 4094 24b8 0000A0E3 		mov	r0, #0
 4095 24bc 0110A0E3 		mov	r1, #1
 4096 24c0 0020A0E1 		mov	r2, r0
 4097 24c4 FEFFFFEB 		bl	CyU3PUsbStall
 4098              	.L428:
 4099 24c8 30309DE5 		ldr	r3, [sp, #48]
 4100              	.L366:
 4101              	.LBE108:
 4102              	.LBE102:
3179:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4103              		.loc 1 3179 0
 4104 24cc 400013E3 		tst	r3, #64
 4105 24d0 0100001A 		bne	.L441
 4106              	.L301:
3392:../uvc.c      ****         CyU3PThreadRelinquish ();
 4107              		.loc 1 3392 0
 4108 24d4 FEFFFFEB 		bl	_txe_thread_relinquish
3393:../uvc.c      ****     }
 4109              		.loc 1 3393 0
 4110 24d8 C3FFFFEA 		b	.L424
 4111              	.L441:
3184:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4112              		.loc 1 3184 0
 4113 24dc 1800A0E3 		mov	r0, #24
 4114 24e0 2C108DE2 		add	r1, sp, #44
 4115 24e4 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3189:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4116              		.loc 1 3189 0
 4117 24e8 2C209DE5 		ldr	r2, [sp, #44]
 4118 24ec 000052E3 		cmp	r2, #0
 4119 24f0 6D00000A 		beq	.L419
3189:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4120              		.loc 1 3189 0 is_stmt 0 discriminator 1
 4121 24f4 5F36D6E5 		ldrb	r3, [r6, #1631]	@ zero_extendqisi2
 4122 24f8 000053E3 		cmp	r3, #0
 4123 24fc F4FFFF1A 		bne	.L301
3191:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4124              		.loc 1 3191 0 is_stmt 1
 4125 2500 002097E5 		ldr	r2, [r7, #0]
 4126 2504 02B0A0E3 		mov	fp, #2
 4127 2508 00B0C2E5 		strb	fp, [r2, #0]
3192:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4128              		.loc 1 3192 0
 4129 250c 001097E5 		ldr	r1, [r7, #0]
 4130 2510 01B0A0E3 		mov	fp, #1
 4131 2514 01B0C1E5 		strb	fp, [r1, #1]
3193:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4132              		.loc 1 3193 0
 4133 2518 000097E5 		ldr	r0, [r7, #0]
3197:../uvc.c      **** 					interStabuf.size   = 1024;
 4134              		.loc 1 3197 0
 4135 251c 01EBA0E3 		mov	lr, #1024	@ movhi
3193:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4136              		.loc 1 3193 0
 4137 2520 0230C0E5 		strb	r3, [r0, #2]
3194:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4138              		.loc 1 3194 0
 4139 2524 00C097E5 		ldr	ip, [r7, #0]
3203:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4140              		.loc 1 3203 0
 4141 2528 0010E0E3 		mvn	r1, #0
3194:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4142              		.loc 1 3194 0
 4143 252c 0330CCE5 		strb	r3, [ip, #3]
3196:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4144              		.loc 1 3196 0
 4145 2530 002097E5 		ldr	r2, [r7, #0]
3200:../uvc.c      **** 					interStabuf.count = 4;
 4146              		.loc 1 3200 0
 4147 2534 04C0A0E3 		mov	ip, #4	@ movhi
3203:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4148              		.loc 1 3203 0
 4149 2538 7C089FE5 		ldr	r0, .L447+28
3196:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4150              		.loc 1 3196 0
 4151 253c 20208DE5 		str	r2, [sp, #32]
3197:../uvc.c      **** 					interStabuf.size   = 1024;
 4152              		.loc 1 3197 0
 4153 2540 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3198:../uvc.c      **** 					interStabuf.status = 0;
 4154              		.loc 1 3198 0
 4155 2544 B832CDE1 		strh	r3, [sp, #40]	@ movhi
3200:../uvc.c      **** 					interStabuf.count = 4;
 4156              		.loc 1 3200 0
 4157 2548 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
3203:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4158              		.loc 1 3203 0
 4159 254c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3206:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4160              		.loc 1 3206 0
 4161 2550 64089FE5 		ldr	r0, .L447+28
 4162 2554 20108DE2 		add	r1, sp, #32
 4163 2558 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4164              	.LVL292:
3207:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4165              		.loc 1 3207 0
 4166 255c 002050E2 		subs	r2, r0, #0
 4167 2560 6301001A 		bne	.L442
3212:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4168              		.loc 1 3212 0
 4169 2564 38389FE5 		ldr	r3, .L447+4
 4170 2568 5FB6C3E5 		strb	fp, [r3, #1631]
3392:../uvc.c      ****         CyU3PThreadRelinquish ();
 4171              		.loc 1 3392 0
 4172 256c FEFFFFEB 		bl	_txe_thread_relinquish
 4173              	.LVL293:
 4174 2570 9DFFFFEA 		b	.L424
 4175              	.L307:
 4176              	.LBB114:
 4177              	.LBB98:
2500:../uvc.c      ****     switch (wValue)
 4178              		.loc 1 2500 0
 4179 2574 B020D9E1 		ldrh	r2, [r9, #0]
 4180 2578 060C52E3 		cmp	r2, #1536
 4181 257c D100000A 		beq	.L331
 4182 2580 8F00008A 		bhi	.L337
 4183 2584 030C52E3 		cmp	r2, #768
 4184 2588 1301000A 		beq	.L328
 4185 258c 0A01008A 		bhi	.L338
 4186 2590 010C52E3 		cmp	r2, #256
 4187 2594 5201000A 		beq	.L326
 4188 2598 020C52E3 		cmp	r2, #512
 4189 259c B7FFFF1A 		bne	.L325
 4190              	.LVL294:
2508:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4191              		.loc 1 2508 0
 4192 25a0 0100A0E3 		mov	r0, #1
 4193 25a4 FEFFFFEB 		bl	CTControlHandle
 4194              	.LVL295:
 4195 25a8 30309DE5 		ldr	r3, [sp, #48]
 4196 25ac BCFFFFEA 		b	.L304
 4197              	.L309:
 4198              	.LBE98:
 4199              	.LBE114:
 4200              	.LBB115:
 4201              	.LBB120:
2725:../uvc.c      ****     switch (wValue)
 4202              		.loc 1 2725 0
 4203 25b0 B030D9E1 		ldrh	r3, [r9, #0]
 4204 25b4 090C53E3 		cmp	r3, #2304
 4205 25b8 EA01000A 		beq	.L352
 4206 25bc 8800008A 		bhi	.L361
 4207 25c0 010B53E3 		cmp	r3, #1024
 4208 25c4 EB01000A 		beq	.L347
 4209 25c8 8301008A 		bhi	.L362
 4210 25cc 020C53E3 		cmp	r3, #512
 4211 25d0 E001000A 		beq	.L345
 4212 25d4 030C53E3 		cmp	r3, #768
 4213 25d8 BF01000A 		beq	.L346
 4214 25dc 010C53E3 		cmp	r3, #256
 4215 25e0 AAFFFF1A 		bne	.L305
 4216              	.LVL296:
2729:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4217              		.loc 1 2729 0
 4218 25e4 1000A0E3 		mov	r0, #16
 4219 25e8 FEFFFFEB 		bl	ControlHandle
 4220              	.LVL297:
 4221 25ec 30309DE5 		ldr	r3, [sp, #48]
 4222 25f0 ABFFFFEA 		b	.L304
 4223              	.L439:
 4224              	.LBE120:
 4225              	.LBE115:
3130:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4226              		.loc 1 3130 0
 4227 25f4 C4B79FE5 		ldr	fp, .L447+32
 4228 25f8 B0C0D9E1 		ldrh	ip, [r9, #0]
 4229 25fc B000D8E1 		ldrh	r0, [r8, #0]
 4230 2600 BC179FE5 		ldr	r1, .L447+36
 4231 2604 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4232 2608 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4233 260c 0C008DE5 		str	r0, [sp, #12]
 4234 2610 08C08DE5 		str	ip, [sp, #8]
 4235 2614 B0C0D1E1 		ldrh	ip, [r1, #0]
 4236 2618 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4237 261c 04B08DE5 		str	fp, [sp, #4]
 4238 2620 0400A0E3 		mov	r0, #4
 4239 2624 9C179FE5 		ldr	r1, .L447+40
 4240 2628 00B0A0E3 		mov	fp, #0
 4241 262c 00E08DE5 		str	lr, [sp, #0]
 4242 2630 10C08DE5 		str	ip, [sp, #16]
 4243 2634 14B08DE5 		str	fp, [sp, #20]
 4244 2638 FEFFFFEB 		bl	CyU3PDebugPrint
 4245 263c 30309DE5 		ldr	r3, [sp, #48]
 4246 2640 78FFFFEA 		b	.L303
 4247              	.L438:
3122:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4248              		.loc 1 3122 0
 4249 2644 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3123:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4250              		.loc 1 3123 0
 4251 2648 000050E3 		cmp	r0, #0
3122:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4252              		.loc 1 3122 0
 4253 264c 4800C5E5 		strb	r0, [r5, #72]
3125:../uvc.c      ****                     isUsbConnected = CyTrue;
 4254              		.loc 1 3125 0
 4255 2650 0100A013 		movne	r0, #1
 4256 2654 3C008515 		strne	r0, [r5, #60]
 4257 2658 6FFFFFEA 		b	.L302
 4258              	.L367:
 4259              	.LVL298:
 4260              	.LBB125:
 4261              	.LBB107:
2820:../uvc.c      ****     switch (wValue)
 4262              		.loc 1 2820 0
 4263 265c B020D9E1 		ldrh	r2, [r9, #0]
 4264 2660 030C52E3 		cmp	r2, #768
 4265 2664 7D00000A 		beq	.L371
 4266 2668 3300008A 		bhi	.L374
 4267 266c 010C52E3 		cmp	r2, #256
 4268 2670 8700000A 		beq	.L369
 4269 2674 020C52E3 		cmp	r2, #512
 4270 2678 8EFFFF1A 		bne	.L368
2872:../uvc.c      ****             switch (bRequest)
 4271              		.loc 1 2872 0
 4272 267c 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4273 2680 810053E3 		cmp	r3, #129
 4274 2684 8700000A 		beq	.L413
 4275 2688 2201008A 		bhi	.L389
 4276 268c 010053E3 		cmp	r3, #1
 4277 2690 8001000A 		beq	.L443
 4278              	.L393:
2971:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4279              		.loc 1 2971 0
 4280 2694 0000A0E3 		mov	r0, #0
 4281 2698 0110A0E3 		mov	r1, #1
 4282 269c 0020A0E1 		mov	r2, r0
 4283 26a0 FEFFFFEB 		bl	CyU3PUsbStall
 4284 26a4 30309DE5 		ldr	r3, [sp, #48]
 4285 26a8 87FFFFEA 		b	.L366
 4286              	.LVL299:
 4287              	.L419:
 4288              	.LBE107:
 4289              	.LBE125:
3213:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4290              		.loc 1 3213 0
 4291 26ac 5FE6D6E5 		ldrb	lr, [r6, #1631]	@ zero_extendqisi2
 4292 26b0 00005EE3 		cmp	lr, #0
 4293 26b4 86FFFF0A 		beq	.L301
3215:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4294              		.loc 1 3215 0
 4295 26b8 003097E5 		ldr	r3, [r7, #0]
 4296 26bc 02B0A0E3 		mov	fp, #2
 4297 26c0 00B0C3E5 		strb	fp, [r3, #0]
3216:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4298              		.loc 1 3216 0
 4299 26c4 001097E5 		ldr	r1, [r7, #0]
 4300 26c8 01B0A0E3 		mov	fp, #1
 4301 26cc 01B0C1E5 		strb	fp, [r1, #1]
3217:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4302              		.loc 1 3217 0
 4303 26d0 000097E5 		ldr	r0, [r7, #0]
3221:../uvc.c      **** 					interStabuf.size   = 1024;
 4304              		.loc 1 3221 0
 4305 26d4 01EBA0E3 		mov	lr, #1024	@ movhi
3217:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4306              		.loc 1 3217 0
 4307 26d8 0220C0E5 		strb	r2, [r0, #2]
3218:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4308              		.loc 1 3218 0
 4309 26dc 00C097E5 		ldr	ip, [r7, #0]
3227:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4310              		.loc 1 3227 0
 4311 26e0 0010E0E3 		mvn	r1, #0
3218:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4312              		.loc 1 3218 0
 4313 26e4 03B0CCE5 		strb	fp, [ip, #3]
3220:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4314              		.loc 1 3220 0
 4315 26e8 003097E5 		ldr	r3, [r7, #0]
3222:../uvc.c      **** 					interStabuf.status = 0;
 4316              		.loc 1 3222 0
 4317 26ec 02C0A0E1 		mov	ip, r2	@ movhi
 4318 26f0 B822CDE1 		strh	r2, [sp, #40]	@ movhi
3227:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4319              		.loc 1 3227 0
 4320 26f4 C0069FE5 		ldr	r0, .L447+28
3224:../uvc.c      **** 					interStabuf.count = 4;
 4321              		.loc 1 3224 0
 4322 26f8 0420A0E3 		mov	r2, #4	@ movhi
3220:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4323              		.loc 1 3220 0
 4324 26fc 20308DE5 		str	r3, [sp, #32]
3224:../uvc.c      **** 					interStabuf.count = 4;
 4325              		.loc 1 3224 0
 4326 2700 B422CDE1 		strh	r2, [sp, #36]	@ movhi
3221:../uvc.c      **** 					interStabuf.size   = 1024;
 4327              		.loc 1 3221 0
 4328 2704 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3227:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4329              		.loc 1 3227 0
 4330 2708 1CC08DE5 		str	ip, [sp, #28]
 4331 270c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3230:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4332              		.loc 1 3230 0
 4333 2710 A4069FE5 		ldr	r0, .L447+28
 4334 2714 20108DE2 		add	r1, sp, #32
 4335 2718 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4336              	.LVL300:
3231:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4337              		.loc 1 3231 0
 4338 271c 1C309DE5 		ldr	r3, [sp, #28]
 4339 2720 002050E2 		subs	r2, r0, #0
 4340 2724 BC00001A 		bne	.L444
3237:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4341              		.loc 1 3237 0
 4342 2728 74269FE5 		ldr	r2, .L447+4
3238:../uvc.c      **** 					stiflag = CyTrue;
 4343              		.loc 1 3238 0
 4344 272c 9CB084E5 		str	fp, [r4, #156]
3237:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4345              		.loc 1 3237 0
 4346 2730 5F36C2E5 		strb	r3, [r2, #1631]
3392:../uvc.c      ****         CyU3PThreadRelinquish ();
 4347              		.loc 1 3392 0
 4348 2734 FEFFFFEB 		bl	_txe_thread_relinquish
 4349              	.LVL301:
 4350 2738 2BFFFFEA 		b	.L424
 4351              	.LVL302:
 4352              	.L374:
 4353              	.LBB126:
 4354              	.LBB109:
2820:../uvc.c      ****     switch (wValue)
 4355              		.loc 1 2820 0
 4356 273c 010B52E3 		cmp	r2, #1024
 4357 2740 3400000A 		beq	.L372
 4358 2744 050C52E3 		cmp	r2, #1280
 4359 2748 5AFFFF1A 		bne	.L368
3032:../uvc.c      ****                 switch (bRequest)
 4360              		.loc 1 3032 0
 4361 274c 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4362 2750 810052E3 		cmp	r2, #129
 4363 2754 5300000A 		beq	.L413
 4364 2758 1A01008A 		bhi	.L416
 4365 275c 010052E3 		cmp	r2, #1
 4366 2760 54FFFF1A 		bne	.L368
3057:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4367              		.loc 1 3057 0
 4368 2764 2000A0E3 		mov	r0, #32
 4369 2768 5C169FE5 		ldr	r1, .L447+44
 4370 276c 36208DE2 		add	r2, sp, #54
 4371 2770 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4372              	.LVL303:
3059:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4373              		.loc 1 3059 0
 4374 2774 000050E3 		cmp	r0, #0
 4375 2778 8201001A 		bne	.L418
3069:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4376              		.loc 1 3069 0
 4377 277c 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 4378 2780 040080E2 		add	r0, r0, #4
 4379              	.LVL304:
 4380 2784 44169FE5 		ldr	r1, .L447+48
 4381 2788 B623DDE1 		ldrh	r2, [sp, #54]
 4382 278c FEFFFFEB 		bl	CyU3PDebugPrint
 4383              	.LVL305:
 4384 2790 30309DE5 		ldr	r3, [sp, #48]
 4385 2794 4CFFFFEA 		b	.L366
 4386              	.L322:
 4387              	.LBE109:
 4388              	.LBE126:
 4389              	.LBB127:
 4390              	.LBB91:
2425:../uvc.c      ****     switch (wValue)
 4391              		.loc 1 2425 0
 4392 2798 0A0C52E3 		cmp	r2, #2560
 4393 279c F100000A 		beq	.L319
 4394 27a0 E600008A 		bhi	.L324
 4395 27a4 070C52E3 		cmp	r2, #1792
 4396 27a8 E000000A 		beq	.L317
 4397 27ac 020B52E3 		cmp	r2, #2048
 4398 27b0 32FFFF1A 		bne	.L325
 4399              	.LVL306:
2456:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4400              		.loc 1 2456 0
 4401 27b4 0700A0E3 		mov	r0, #7
 4402 27b8 FEFFFFEB 		bl	ControlHandle
 4403              	.LVL307:
 4404 27bc 30309DE5 		ldr	r3, [sp, #48]
 4405 27c0 37FFFFEA 		b	.L304
 4406              	.L337:
 4407              	.LBE91:
 4408              	.LBE127:
 4409              	.LBB128:
 4410              	.LBB96:
2500:../uvc.c      ****     switch (wValue)
 4411              		.loc 1 2500 0
 4412 27c4 090C52E3 		cmp	r2, #2304
 4413 27c8 2201000A 		beq	.L333
 4414 27cc 1701008A 		bhi	.L339
 4415 27d0 070C52E3 		cmp	r2, #1792
 4416 27d4 0901000A 		beq	.L332
 4417 27d8 020B52E3 		cmp	r2, #2048
 4418 27dc 27FFFF1A 		bne	.L325
 4419 27e0 2FFFFFEA 		b	.L304
 4420              	.L361:
 4421              	.LBE96:
 4422              	.LBE128:
 4423              	.LBB129:
 4424              	.LBB119:
2725:../uvc.c      ****     switch (wValue)
 4425              		.loc 1 2725 0
 4426 27e4 0F0C53E3 		cmp	r3, #3840
 4427 27e8 5601000A 		beq	.L356
 4428 27ec 3900008A 		bhi	.L364
 4429 27f0 0B0C53E3 		cmp	r3, #2816
 4430 27f4 4F01000A 		beq	.L354
 4431 27f8 0D0C53E3 		cmp	r3, #3328
 4432 27fc 4901000A 		beq	.L355
 4433 2800 0A0C53E3 		cmp	r3, #2560
 4434 2804 21FFFF1A 		bne	.L305
 4435              	.LVL308:
2766:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4436              		.loc 1 2766 0
 4437 2808 1900A0E3 		mov	r0, #25
 4438 280c FEFFFFEB 		bl	ControlHandle
 4439              	.LVL309:
 4440 2810 30309DE5 		ldr	r3, [sp, #48]
 4441 2814 22FFFFEA 		b	.L304
 4442              	.LVL310:
 4443              	.L372:
 4444              	.LBE119:
 4445              	.LBE129:
 4446              	.LBB130:
 4447              	.LBB106:
2977:../uvc.c      ****                 switch (bRequest)
 4448              		.loc 1 2977 0
 4449 2818 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4450 281c 81005BE3 		cmp	fp, #129
 4451 2820 1300000A 		beq	.L404
 4452 2824 8500008A 		bhi	.L407
 4453 2828 01005BE3 		cmp	fp, #1
 4454 282c 21FFFF1A 		bne	.L368
3002:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4455              		.loc 1 3002 0
 4456 2830 36208DE2 		add	r2, sp, #54
 4457 2834 2000A0E3 		mov	r0, #32
 4458 2838 8C159FE5 		ldr	r1, .L447+44
 4459 283c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4460              	.LVL311:
3004:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4461              		.loc 1 3004 0
 4462 2840 002050E2 		subs	r2, r0, #0
 4463 2844 1FFFFF1A 		bne	.L428
3017:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4464              		.loc 1 3017 0
 4465 2848 50059FE5 		ldr	r0, .L447
 4466              	.LVL312:
 4467 284c 0B10A0E1 		mov	r1, fp
 4468 2850 FEFFFFEB 		bl	_txe_event_flags_set
 4469              	.LVL313:
3018:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4470              		.loc 1 3018 0
 4471 2854 002050E2 		subs	r2, r0, #0
 4472 2858 1AFFFF0A 		beq	.L428
 4473 285c 190100EA 		b	.L410
 4474              	.LVL314:
 4475              	.L371:
2928:../uvc.c      ****                 switch (bRequest)
 4476              		.loc 1 2928 0
 4477 2860 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4478 2864 830052E3 		cmp	r2, #131
 4479 2868 9800008A 		bhi	.L398
 4480 286c 810052E3 		cmp	r2, #129
 4481 2870 7D00003A 		bcc	.L445
 4482              	.L404:
2989:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4483              		.loc 1 2989 0
 4484 2874 48B0D4E5 		ldrb	fp, [r4, #72]	@ zero_extendqisi2
2991:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4485              		.loc 1 2991 0
 4486 2878 0B00A0E3 		mov	r0, #11
2989:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4487              		.loc 1 2989 0
 4488 287c 03005BE3 		cmp	fp, #3
2991:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4489              		.loc 1 2991 0
 4490 2880 4C159F05 		ldreq	r1, .L447+52
2995:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4491              		.loc 1 2995 0
 4492 2884 4C159F15 		ldrne	r1, .L447+56
 4493 2888 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4494 288c 30309DE5 		ldr	r3, [sp, #48]
 4495 2890 0DFFFFEA 		b	.L366
 4496              	.L369:
2823:../uvc.c      ****             switch (bRequest)
 4497              		.loc 1 2823 0
 4498 2894 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4499 2898 830052E3 		cmp	r2, #131
 4500 289c 2F00008A 		bhi	.L380
 4501 28a0 810052E3 		cmp	r2, #129
 4502 28a4 1400003A 		bcc	.L446
 4503              	.L413:
3044:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4504              		.loc 1 3044 0
 4505 28a8 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3046:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4506              		.loc 1 3046 0
 4507 28ac 1A00A0E3 		mov	r0, #26
3044:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4508              		.loc 1 3044 0
 4509 28b0 030052E3 		cmp	r2, #3
3046:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4510              		.loc 1 3046 0
 4511 28b4 20159F05 		ldreq	r1, .L447+60
3050:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4512              		.loc 1 3050 0
 4513 28b8 20159F15 		ldrne	r1, .L447+64
 4514 28bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4515 28c0 30309DE5 		ldr	r3, [sp, #48]
 4516 28c4 00FFFFEA 		b	.L366
 4517              	.LVL315:
 4518              	.L331:
 4519              	.LBE106:
 4520              	.LBE130:
 4521              	.LBB131:
 4522              	.LBB99:
2526:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4523              		.loc 1 2526 0
 4524 28c8 0500A0E3 		mov	r0, #5
 4525 28cc FEFFFFEB 		bl	CTControlHandle
 4526              	.LVL316:
 4527 28d0 30309DE5 		ldr	r3, [sp, #48]
 4528 28d4 F2FEFFEA 		b	.L304
 4529              	.L364:
 4530              	.LBE99:
 4531              	.LBE131:
 4532              	.LBB132:
 4533              	.LBB121:
2725:../uvc.c      ****     switch (wValue)
 4534              		.loc 1 2725 0
 4535 28d8 110C53E3 		cmp	r3, #4352
 4536 28dc E900000A 		beq	.L358
 4537 28e0 2D00008A 		bhi	.L365
 4538 28e4 010A53E3 		cmp	r3, #4096
 4539 28e8 E8FEFF1A 		bne	.L305
 4540              	.LVL317:
2788:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4541              		.loc 1 2788 0
 4542 28ec 1F00A0E3 		mov	r0, #31
 4543 28f0 FEFFFFEB 		bl	ControlHandle
 4544              	.LVL318:
 4545 28f4 30309DE5 		ldr	r3, [sp, #48]
 4546 28f8 E9FEFFEA 		b	.L304
 4547              	.LVL319:
 4548              	.L446:
 4549              	.LBE121:
 4550              	.LBE132:
 4551              	.LBB133:
 4552              	.LBB110:
2823:../uvc.c      ****             switch (bRequest)
 4553              		.loc 1 2823 0
 4554 28fc 010052E3 		cmp	r2, #1
 4555 2900 63FFFF1A 		bne	.L393
2848:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4556              		.loc 1 2848 0
 4557 2904 2000A0E3 		mov	r0, #32
 4558 2908 BC149FE5 		ldr	r1, .L447+44
 4559 290c 36208DE2 		add	r2, sp, #54
 4560 2910 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4561              	.LVL320:
2850:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4562              		.loc 1 2850 0
 4563 2914 000050E3 		cmp	r0, #0
 4564 2918 EAFEFF1A 		bne	.L428
2852:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4565              		.loc 1 2852 0
 4566 291c 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 4567 2920 030053E3 		cmp	r3, #3
 4568 2924 E7FEFF1A 		bne	.L428
2856:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4569              		.loc 1 2856 0
 4570 2928 7EE0D4E5 		ldrb	lr, [r4, #126]	@ zero_extendqisi2
2857:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4571              		.loc 1 2857 0
 4572 292c 7FC0D4E5 		ldrb	ip, [r4, #127]	@ zero_extendqisi2
2858:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4573              		.loc 1 2858 0
 4574 2930 8000D4E5 		ldrb	r0, [r4, #128]	@ zero_extendqisi2
 4575              	.LVL321:
2859:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4576              		.loc 1 2859 0
 4577 2934 8110D4E5 		ldrb	r1, [r4, #129]	@ zero_extendqisi2
2860:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4578              		.loc 1 2860 0
 4579 2938 8220D4E5 		ldrb	r2, [r4, #130]	@ zero_extendqisi2
2861:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4580              		.loc 1 2861 0
 4581 293c 83B0D4E5 		ldrb	fp, [r4, #131]	@ zero_extendqisi2
2856:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4582              		.loc 1 2856 0
 4583 2940 12E6C6E5 		strb	lr, [r6, #1554]
2857:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4584              		.loc 1 2857 0
 4585 2944 13C6C6E5 		strb	ip, [r6, #1555]
2858:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4586              		.loc 1 2858 0
 4587 2948 1406C6E5 		strb	r0, [r6, #1556]
2859:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4588              		.loc 1 2859 0
 4589 294c 1516C6E5 		strb	r1, [r6, #1557]
2860:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4590              		.loc 1 2860 0
 4591 2950 1626C6E5 		strb	r2, [r6, #1558]
2861:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4592              		.loc 1 2861 0
 4593 2954 17B6C6E5 		strb	fp, [r6, #1559]
 4594 2958 30309DE5 		ldr	r3, [sp, #48]
 4595 295c DAFEFFEA 		b	.L366
 4596              	.LVL322:
 4597              	.L380:
2823:../uvc.c      ****             switch (bRequest)
 4598              		.loc 1 2823 0
 4599 2960 860052E3 		cmp	r2, #134
 4600 2964 3900000A 		beq	.L431
 4601 2968 870052E3 		cmp	r2, #135
 4602 296c CDFFFF0A 		beq	.L413
 4603              	.L437:
2928:../uvc.c      ****                 switch (bRequest)
 4604              		.loc 1 2928 0
 4605 2970 850052E3 		cmp	r2, #133
 4606 2974 46FFFF1A 		bne	.L393
 4607              	.L405:
2986:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4608              		.loc 1 2986 0
 4609 2978 64149FE5 		ldr	r1, .L447+68
 4610 297c 0200A0E3 		mov	r0, #2
2984:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4611              		.loc 1 2984 0
 4612 2980 1A30A0E3 		mov	r3, #26
 4613              	.L429:
3039:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4614              		.loc 1 3039 0
 4615 2984 5830C4E5 		strb	r3, [r4, #88]
3040:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4616              		.loc 1 3040 0
 4617 2988 0030A0E3 		mov	r3, #0
 4618 298c 5930C4E5 		strb	r3, [r4, #89]
3041:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4619              		.loc 1 3041 0
 4620 2990 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4621 2994 30309DE5 		ldr	r3, [sp, #48]
 4622 2998 CBFEFFEA 		b	.L366
 4623              	.LVL323:
 4624              	.L365:
 4625              	.LBE110:
 4626              	.LBE133:
 4627              	.LBB134:
 4628              	.LBB118:
2725:../uvc.c      ****     switch (wValue)
 4629              		.loc 1 2725 0
 4630 299c 120C53E3 		cmp	r3, #4608
 4631 29a0 DC00000A 		beq	.L359
 4632 29a4 130C53E3 		cmp	r3, #4864
 4633 29a8 B8FEFF1A 		bne	.L305
 4634              	.LVL324:
2800:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 4635              		.loc 1 2800 0
 4636 29ac 2600A0E3 		mov	r0, #38
 4637 29b0 FEFFFFEB 		bl	ControlHandle
 4638              	.LVL325:
 4639 29b4 30309DE5 		ldr	r3, [sp, #48]
 4640 29b8 B9FEFFEA 		b	.L304
 4641              	.L338:
 4642              	.LBE118:
 4643              	.LBE134:
 4644              	.LBB135:
 4645              	.LBB95:
2500:../uvc.c      ****     switch (wValue)
 4646              		.loc 1 2500 0
 4647 29bc 010B52E3 		cmp	r2, #1024
 4648 29c0 0900000A 		beq	.L329
 4649 29c4 050C52E3 		cmp	r2, #1280
 4650 29c8 ACFEFF1A 		bne	.L325
 4651              	.LVL326:
2522:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4652              		.loc 1 2522 0
 4653 29cc 0400A0E3 		mov	r0, #4
 4654 29d0 FEFFFFEB 		bl	CTControlHandle
 4655              	.LVL327:
 4656 29d4 30309DE5 		ldr	r3, [sp, #48]
 4657 29d8 B1FEFFEA 		b	.L304
 4658              	.L328:
 4659              	.LVL328:
2512:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4660              		.loc 1 2512 0
 4661 29dc 0200A0E3 		mov	r0, #2
 4662 29e0 FEFFFFEB 		bl	CTControlHandle
 4663              	.LVL329:
 4664 29e4 30309DE5 		ldr	r3, [sp, #48]
 4665 29e8 ADFEFFEA 		b	.L304
 4666              	.L329:
 4667              	.LVL330:
2517:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4668              		.loc 1 2517 0
 4669 29ec 0300A0E3 		mov	r0, #3
 4670 29f0 FEFFFFEB 		bl	CTControlHandle
 4671              	.LVL331:
 4672 29f4 30309DE5 		ldr	r3, [sp, #48]
 4673 29f8 A9FEFFEA 		b	.L304
 4674              	.L440:
 4675              	.LVL332:
 4676              	.LBE95:
 4677              	.LBE135:
 4678              	.LBB136:
 4679              	.LBB89:
2433:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4680              		.loc 1 2433 0
 4681 29fc 0100A0E3 		mov	r0, #1
 4682 2a00 FEFFFFEB 		bl	ControlHandle
 4683              	.LVL333:
 4684 2a04 30309DE5 		ldr	r3, [sp, #48]
 4685 2a08 A5FEFFEA 		b	.L304
 4686              	.L312:
 4687              	.LVL334:
2429:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4688              		.loc 1 2429 0
 4689 2a0c 0000A0E3 		mov	r0, #0
 4690 2a10 FEFFFFEB 		bl	ControlHandle
 4691              	.LVL335:
 4692 2a14 30309DE5 		ldr	r3, [sp, #48]
 4693 2a18 A1FEFFEA 		b	.L304
 4694              	.LVL336:
 4695              	.L444:
 4696              	.LBE89:
 4697              	.LBE136:
3233:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4698              		.loc 1 3233 0
 4699 2a1c 0400A0E3 		mov	r0, #4
 4700              	.LVL337:
 4701 2a20 C0139FE5 		ldr	r1, .L447+72
 4702 2a24 FEFFFFEB 		bl	CyU3PDebugPrint
 4703              	.LVL338:
 4704              	.L423:
 4705              	.LBB137:
 4706              	.LBB138:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4707              		.loc 1 1246 0
 4708 2a28 BC139FE5 		ldr	r1, .L447+76
 4709 2a2c 0400A0E3 		mov	r0, #4
 4710 2a30 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 4711              		.loc 1 1247 0
 4712 2a34 FA0FA0E3 		mov	r0, #1000
 4713 2a38 FEFFFFEB 		bl	_tx_thread_sleep
 4714 2a3c F9FFFFEA 		b	.L423
 4715              	.LVL339:
 4716              	.L407:
 4717              	.LBE138:
 4718              	.LBE137:
 4719              	.LBB139:
 4720              	.LBB105:
2977:../uvc.c      ****                 switch (bRequest)
 4721              		.loc 1 2977 0
 4722 2a40 85005BE3 		cmp	fp, #133
 4723 2a44 CBFFFF0A 		beq	.L405
 4724 2a48 86005BE3 		cmp	fp, #134
 4725 2a4c 99FEFF1A 		bne	.L368
 4726              	.L431:
2981:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4727              		.loc 1 2981 0
 4728 2a50 0300A0E1 		mov	r0, r3
 4729              	.L426:
2875:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4730              		.loc 1 2875 0
 4731 2a54 0330A0E3 		mov	r3, #3
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4732              		.loc 1 2876 0
 4733 2a58 84139FE5 		ldr	r1, .L447+68
2875:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4734              		.loc 1 2875 0
 4735 2a5c 5830C4E5 		strb	r3, [r4, #88]
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4736              		.loc 1 2876 0
 4737 2a60 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4738 2a64 30309DE5 		ldr	r3, [sp, #48]
 4739 2a68 97FEFFEA 		b	.L366
 4740              	.L445:
2928:../uvc.c      ****                 switch (bRequest)
 4741              		.loc 1 2928 0
 4742 2a6c 010052E3 		cmp	r2, #1
 4743 2a70 07FFFF1A 		bne	.L393
2953:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4744              		.loc 1 2953 0
 4745 2a74 2000A0E3 		mov	r0, #32
 4746 2a78 4C139FE5 		ldr	r1, .L447+44
 4747 2a7c 36208DE2 		add	r2, sp, #54
 4748 2a80 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4749              	.LVL340:
2955:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4750              		.loc 1 2955 0
 4751 2a84 000050E3 		cmp	r0, #0
 4752 2a88 8EFEFF1A 		bne	.L428
2957:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4753              		.loc 1 2957 0
 4754 2a8c 48B0D5E5 		ldrb	fp, [r5, #72]	@ zero_extendqisi2
 4755 2a90 03005BE3 		cmp	fp, #3
 4756 2a94 8BFEFF1A 		bne	.L428
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4757              		.loc 1 2966 0
 4758 2a98 8230D5E5 		ldrb	r3, [r5, #130]	@ zero_extendqisi2
2961:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4759              		.loc 1 2961 0
 4760 2a9c 7DE0D5E5 		ldrb	lr, [r5, #125]	@ zero_extendqisi2
2962:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4761              		.loc 1 2962 0
 4762 2aa0 7EC0D5E5 		ldrb	ip, [r5, #126]	@ zero_extendqisi2
2963:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4763              		.loc 1 2963 0
 4764 2aa4 7F00D5E5 		ldrb	r0, [r5, #127]	@ zero_extendqisi2
 4765              	.LVL341:
2964:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4766              		.loc 1 2964 0
 4767 2aa8 8010D5E5 		ldrb	r1, [r5, #128]	@ zero_extendqisi2
2965:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4768              		.loc 1 2965 0
 4769 2aac 8120D5E5 		ldrb	r2, [r5, #129]	@ zero_extendqisi2
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4770              		.loc 1 2966 0
 4771 2ab0 4E36C6E5 		strb	r3, [r6, #1614]
2961:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4772              		.loc 1 2961 0
 4773 2ab4 49E6C6E5 		strb	lr, [r6, #1609]
2962:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4774              		.loc 1 2962 0
 4775 2ab8 4AC6C6E5 		strb	ip, [r6, #1610]
2963:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4776              		.loc 1 2963 0
 4777 2abc 4B06C6E5 		strb	r0, [r6, #1611]
2964:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4778              		.loc 1 2964 0
 4779 2ac0 4C16C6E5 		strb	r1, [r6, #1612]
2965:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4780              		.loc 1 2965 0
 4781 2ac4 4D26C6E5 		strb	r2, [r6, #1613]
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4782              		.loc 1 2966 0
 4783 2ac8 30309DE5 		ldr	r3, [sp, #48]
 4784 2acc 7EFEFFEA 		b	.L366
 4785              	.LVL342:
 4786              	.L398:
2928:../uvc.c      ****                 switch (bRequest)
 4787              		.loc 1 2928 0
 4788 2ad0 860052E3 		cmp	r2, #134
 4789 2ad4 DDFFFF0A 		beq	.L431
 4790 2ad8 870052E3 		cmp	r2, #135
 4791 2adc A3FFFF1A 		bne	.L437
 4792 2ae0 63FFFFEA 		b	.L404
 4793              	.LVL343:
 4794              	.L326:
 4795              	.LBE105:
 4796              	.LBE139:
 4797              	.LBB140:
 4798              	.LBB100:
2504:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4799              		.loc 1 2504 0
 4800 2ae4 0000A0E3 		mov	r0, #0
 4801 2ae8 FEFFFFEB 		bl	CTControlHandle
 4802              	.LVL344:
 4803 2aec 30309DE5 		ldr	r3, [sp, #48]
 4804 2af0 6BFEFFEA 		b	.L304
 4805              	.LVL345:
 4806              	.L442:
 4807              	.LBE100:
 4808              	.LBE140:
3209:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4809              		.loc 1 3209 0
 4810 2af4 0400A0E3 		mov	r0, #4
 4811              	.LVL346:
 4812 2af8 E8129FE5 		ldr	r1, .L447+72
 4813 2afc FEFFFFEB 		bl	CyU3PDebugPrint
 4814              	.LVL347:
 4815              	.L421:
 4816              	.LBB141:
 4817              	.LBB142:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4818              		.loc 1 1246 0
 4819 2b00 E4129FE5 		ldr	r1, .L447+76
 4820 2b04 0400A0E3 		mov	r0, #4
 4821 2b08 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 4822              		.loc 1 1247 0
 4823 2b0c FA0FA0E3 		mov	r0, #1000
 4824 2b10 FEFFFFEB 		bl	_tx_thread_sleep
 4825 2b14 F9FFFFEA 		b	.L421
 4826              	.LVL348:
 4827              	.L389:
 4828              	.LBE142:
 4829              	.LBE141:
 4830              	.LBB143:
 4831              	.LBB111:
2872:../uvc.c      ****             switch (bRequest)
 4832              		.loc 1 2872 0
 4833 2b18 850053E3 		cmp	r3, #133
 4834 2b1c 95FFFF0A 		beq	.L405
 4835 2b20 860053E3 		cmp	r3, #134
 4836 2b24 DAFEFF1A 		bne	.L393
 4837              	.L432:
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4838              		.loc 1 2876 0
 4839 2b28 0100A0E3 		mov	r0, #1
 4840 2b2c C8FFFFEA 		b	.L426
 4841              	.LVL349:
 4842              	.L317:
 4843              	.LBE111:
 4844              	.LBE143:
 4845              	.LBB144:
 4846              	.LBB92:
2452:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4847              		.loc 1 2452 0
 4848 2b30 0600A0E3 		mov	r0, #6
 4849 2b34 FEFFFFEB 		bl	ControlHandle
 4850              	.LVL350:
 4851 2b38 30309DE5 		ldr	r3, [sp, #48]
 4852 2b3c 58FEFFEA 		b	.L304
 4853              	.L324:
2425:../uvc.c      ****     switch (wValue)
 4854              		.loc 1 2425 0
 4855 2b40 0D0C52E3 		cmp	r2, #3328
 4856 2b44 0700000A 		beq	.L319
 4857 2b48 0E0C52E3 		cmp	r2, #3584
 4858 2b4c 0900000A 		beq	.L321
 4859 2b50 030B52E3 		cmp	r2, #3072
 4860 2b54 49FEFF1A 		bne	.L325
 4861              	.LVL351:
2466:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4862              		.loc 1 2466 0
 4863 2b58 0B00A0E3 		mov	r0, #11
 4864 2b5c FEFFFFEB 		bl	ControlHandle
 4865              	.LVL352:
 4866 2b60 30309DE5 		ldr	r3, [sp, #48]
 4867 2b64 4EFEFFEA 		b	.L304
 4868              	.L319:
 4869              	.LVL353:
2462:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4870              		.loc 1 2462 0
 4871 2b68 0900A0E3 		mov	r0, #9
 4872 2b6c FEFFFFEB 		bl	ControlHandle
 4873              	.LVL354:
 4874 2b70 30309DE5 		ldr	r3, [sp, #48]
 4875 2b74 4AFEFFEA 		b	.L304
 4876              	.L321:
 4877              	.LVL355:
2470:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4878              		.loc 1 2470 0
 4879 2b78 0E00A0E3 		mov	r0, #14
 4880 2b7c FEFFFFEB 		bl	ControlHandle
 4881              	.LVL356:
 4882 2b80 30309DE5 		ldr	r3, [sp, #48]
 4883 2b84 46FEFFEA 		b	.L304
 4884              	.L323:
2425:../uvc.c      ****     switch (wValue)
 4885              		.loc 1 2425 0
 4886 2b88 010B52E3 		cmp	r2, #1024
 4887 2b8c 44FEFF0A 		beq	.L304
 4888 2b90 050C52E3 		cmp	r2, #1280
 4889 2b94 39FEFF1A 		bne	.L325
 4890              	.LVL357:
2444:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4891              		.loc 1 2444 0
 4892 2b98 0400A0E3 		mov	r0, #4
 4893 2b9c FEFFFFEB 		bl	ControlHandle
 4894              	.LVL358:
 4895 2ba0 30309DE5 		ldr	r3, [sp, #48]
 4896 2ba4 3EFEFFEA 		b	.L304
 4897              	.L314:
 4898              	.LVL359:
2437:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4899              		.loc 1 2437 0
 4900 2ba8 0200A0E3 		mov	r0, #2
 4901 2bac FEFFFFEB 		bl	ControlHandle
 4902              	.LVL360:
 4903 2bb0 30309DE5 		ldr	r3, [sp, #48]
 4904 2bb4 3AFEFFEA 		b	.L304
 4905              	.L316:
 4906              	.LVL361:
2448:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4907              		.loc 1 2448 0
 4908 2bb8 0500A0E3 		mov	r0, #5
 4909 2bbc FEFFFFEB 		bl	ControlHandle
 4910              	.LVL362:
 4911 2bc0 30309DE5 		ldr	r3, [sp, #48]
 4912 2bc4 36FEFFEA 		b	.L304
 4913              	.LVL363:
 4914              	.L416:
 4915              	.LBE92:
 4916              	.LBE144:
 4917              	.LBB145:
 4918              	.LBB104:
3032:../uvc.c      ****                 switch (bRequest)
 4919              		.loc 1 3032 0
 4920 2bc8 850052E3 		cmp	r2, #133
 4921 2bcc 4E00000A 		beq	.L414
 4922 2bd0 860052E3 		cmp	r2, #134
 4923 2bd4 37FEFF1A 		bne	.L368
 4924 2bd8 D2FFFFEA 		b	.L432
 4925              	.LVL364:
 4926              	.L362:
 4927              	.LBE104:
 4928              	.LBE145:
 4929              	.LBB146:
 4930              	.LBB122:
2725:../uvc.c      ****     switch (wValue)
 4931              		.loc 1 2725 0
 4932 2bdc 060C53E3 		cmp	r3, #1536
 4933 2be0 4500000A 		beq	.L349
 4934 2be4 0900008A 		bhi	.L363
 4935 2be8 050C53E3 		cmp	r3, #1280
 4936 2bec 27FEFF1A 		bne	.L305
 4937              	.LVL365:
2745:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4938              		.loc 1 2745 0
 4939 2bf0 1400A0E3 		mov	r0, #20
 4940 2bf4 FEFFFFEB 		bl	ControlHandle
 4941              	.LVL366:
 4942 2bf8 30309DE5 		ldr	r3, [sp, #48]
 4943 2bfc 28FEFFEA 		b	.L304
 4944              	.L332:
 4945              	.LVL367:
 4946              	.LBE122:
 4947              	.LBE146:
 4948              	.LBB147:
 4949              	.LBB94:
2530:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 4950              		.loc 1 2530 0
 4951 2c00 0600A0E3 		mov	r0, #6
 4952 2c04 FEFFFFEB 		bl	CTControlHandle
 4953              	.LVL368:
 4954 2c08 30309DE5 		ldr	r3, [sp, #48]
 4955 2c0c 24FEFFEA 		b	.L304
 4956              	.L363:
 4957              	.LBE94:
 4958              	.LBE147:
 4959              	.LBB148:
 4960              	.LBB117:
2725:../uvc.c      ****     switch (wValue)
 4961              		.loc 1 2725 0
 4962 2c10 070C53E3 		cmp	r3, #1792
 4963 2c14 3400000A 		beq	.L350
 4964 2c18 020B53E3 		cmp	r3, #2048
 4965 2c1c 1BFEFF1A 		bne	.L305
 4966              	.LVL369:
2757:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 4967              		.loc 1 2757 0
 4968 2c20 1700A0E3 		mov	r0, #23
 4969 2c24 FEFFFFEB 		bl	ControlHandle
 4970              	.LVL370:
 4971 2c28 30309DE5 		ldr	r3, [sp, #48]
 4972 2c2c 1CFEFFEA 		b	.L304
 4973              	.L339:
 4974              	.LBE117:
 4975              	.LBE148:
 4976              	.LBB149:
 4977              	.LBB101:
2500:../uvc.c      ****     switch (wValue)
 4978              		.loc 1 2500 0
 4979 2c30 0B0C52E3 		cmp	r2, #2816
 4980 2c34 0F00000A 		beq	.L335
 4981 2c38 030B52E3 		cmp	r2, #3072
 4982 2c3c 0900000A 		beq	.L336
 4983 2c40 0A0C52E3 		cmp	r2, #2560
 4984 2c44 0DFEFF1A 		bne	.L325
 4985              	.LVL371:
2541:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 4986              		.loc 1 2541 0
 4987 2c48 0800A0E3 		mov	r0, #8
 4988 2c4c FEFFFFEB 		bl	CTControlHandle
 4989              	.LVL372:
 4990 2c50 30309DE5 		ldr	r3, [sp, #48]
 4991 2c54 12FEFFEA 		b	.L304
 4992              	.L333:
 4993              	.LVL373:
2536:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 4994              		.loc 1 2536 0
 4995 2c58 0700A0E3 		mov	r0, #7
 4996 2c5c FEFFFFEB 		bl	CTControlHandle
 4997              	.LVL374:
 4998 2c60 30309DE5 		ldr	r3, [sp, #48]
 4999 2c64 0EFEFFEA 		b	.L304
 5000              	.L336:
 5001              	.LVL375:
2549:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5002              		.loc 1 2549 0
 5003 2c68 0A00A0E3 		mov	r0, #10
 5004 2c6c FEFFFFEB 		bl	CTControlHandle
 5005              	.LVL376:
 5006 2c70 30309DE5 		ldr	r3, [sp, #48]
 5007 2c74 0AFEFFEA 		b	.L304
 5008              	.L335:
 5009              	.LVL377:
2545:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5010              		.loc 1 2545 0
 5011 2c78 0900A0E3 		mov	r0, #9
 5012 2c7c FEFFFFEB 		bl	CTControlHandle
 5013              	.LVL378:
 5014 2c80 30309DE5 		ldr	r3, [sp, #48]
 5015 2c84 06FEFFEA 		b	.L304
 5016              	.L358:
 5017              	.LVL379:
 5018              	.LBE101:
 5019              	.LBE149:
 5020              	.LBB150:
 5021              	.LBB123:
2792:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 5022              		.loc 1 2792 0
 5023 2c88 2400A0E3 		mov	r0, #36
 5024 2c8c FEFFFFEB 		bl	ControlHandle
 5025              	.LVL380:
 5026 2c90 30309DE5 		ldr	r3, [sp, #48]
 5027 2c94 02FEFFEA 		b	.L304
 5028              	.LVL381:
 5029              	.L443:
 5030              	.LBE123:
 5031              	.LBE150:
 5032              	.LBB151:
 5033              	.LBB112:
2897:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5034              		.loc 1 2897 0
 5035 2c98 2000A0E3 		mov	r0, #32
 5036 2c9c 28119FE5 		ldr	r1, .L447+44
 5037 2ca0 36208DE2 		add	r2, sp, #54
 5038 2ca4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5039              	.LVL382:
2899:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5040              		.loc 1 2899 0
 5041 2ca8 000050E3 		cmp	r0, #0
 5042 2cac 05FEFF1A 		bne	.L428
2912:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5043              		.loc 1 2912 0
 5044 2cb0 0020A0E3 		mov	r2, #0
 5045 2cb4 E4009FE5 		ldr	r0, .L447
 5046              	.LVL383:
 5047 2cb8 0110A0E3 		mov	r1, #1
 5048 2cbc FEFFFFEB 		bl	_txe_event_flags_set
 5049              	.LVL384:
2913:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5050              		.loc 1 2913 0
 5051 2cc0 002050E2 		subs	r2, r0, #0
 5052 2cc4 FFFDFF0A 		beq	.L428
 5053              	.L410:
3020:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5054              		.loc 1 3020 0
 5055 2cc8 0400A0E3 		mov	r0, #4
 5056              	.LVL385:
 5057 2ccc 1C119FE5 		ldr	r1, .L447+80
 5058 2cd0 FEFFFFEB 		bl	CyU3PDebugPrint
 5059              	.LVL386:
 5060 2cd4 30309DE5 		ldr	r3, [sp, #48]
 5061 2cd8 FBFDFFEA 		b	.L366
 5062              	.L346:
 5063              	.LVL387:
 5064              	.LBE112:
 5065              	.LBE151:
 5066              	.LBB152:
 5067              	.LBB116:
2737:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5068              		.loc 1 2737 0
 5069 2cdc 1200A0E3 		mov	r0, #18
 5070 2ce0 FEFFFFEB 		bl	ControlHandle
 5071              	.LVL388:
 5072 2ce4 30309DE5 		ldr	r3, [sp, #48]
 5073 2ce8 EDFDFFEA 		b	.L304
 5074              	.L350:
 5075              	.LVL389:
2753:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5076              		.loc 1 2753 0
 5077 2cec 1600A0E3 		mov	r0, #22
 5078 2cf0 FEFFFFEB 		bl	ControlHandle
 5079              	.LVL390:
 5080 2cf4 30309DE5 		ldr	r3, [sp, #48]
 5081 2cf8 E9FDFFEA 		b	.L304
 5082              	.L349:
 5083              	.LVL391:
2749:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5084              		.loc 1 2749 0
 5085 2cfc 1500A0E3 		mov	r0, #21
 5086 2d00 FEFFFFEB 		bl	ControlHandle
 5087              	.LVL392:
 5088 2d04 30309DE5 		ldr	r3, [sp, #48]
 5089 2d08 E5FDFFEA 		b	.L304
 5090              	.LVL393:
 5091              	.L414:
 5092              	.LBE116:
 5093              	.LBE152:
 5094              	.LBB153:
 5095              	.LBB103:
3041:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5096              		.loc 1 3041 0
 5097 2d0c 0200A0E3 		mov	r0, #2
 5098 2d10 CC109FE5 		ldr	r1, .L447+68
 5099 2d14 1AFFFFEA 		b	.L429
 5100              	.LVL394:
 5101              	.L359:
 5102              	.LBE103:
 5103              	.LBE153:
 5104              	.LBB154:
 5105              	.LBB124:
2796:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 5106              		.loc 1 2796 0
 5107 2d18 2500A0E3 		mov	r0, #37
 5108 2d1c FEFFFFEB 		bl	ControlHandle
 5109              	.LVL395:
 5110 2d20 30309DE5 		ldr	r3, [sp, #48]
 5111 2d24 DEFDFFEA 		b	.L304
 5112              	.L355:
 5113              	.LVL396:
2776:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5114              		.loc 1 2776 0
 5115 2d28 1C00A0E3 		mov	r0, #28
 5116 2d2c FEFFFFEB 		bl	ControlHandle
 5117              	.LVL397:
 5118 2d30 30309DE5 		ldr	r3, [sp, #48]
 5119 2d34 DAFDFFEA 		b	.L304
 5120              	.L354:
 5121              	.LVL398:
2772:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5122              		.loc 1 2772 0
 5123 2d38 1A00A0E3 		mov	r0, #26
 5124 2d3c FEFFFFEB 		bl	ControlHandle
 5125              	.LVL399:
 5126 2d40 30309DE5 		ldr	r3, [sp, #48]
 5127 2d44 D6FDFFEA 		b	.L304
 5128              	.L356:
 5129              	.LVL400:
2784:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5130              		.loc 1 2784 0
 5131 2d48 1E00A0E3 		mov	r0, #30
 5132 2d4c FEFFFFEB 		bl	ControlHandle
 5133              	.LVL401:
 5134 2d50 30309DE5 		ldr	r3, [sp, #48]
 5135 2d54 D2FDFFEA 		b	.L304
 5136              	.L345:
 5137              	.LVL402:
2733:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5138              		.loc 1 2733 0
 5139 2d58 1100A0E3 		mov	r0, #17
 5140 2d5c FEFFFFEB 		bl	ControlHandle
 5141              	.LVL403:
 5142 2d60 30309DE5 		ldr	r3, [sp, #48]
 5143 2d64 CEFDFFEA 		b	.L304
 5144              	.L352:
 5145              	.LVL404:
2761:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5146              		.loc 1 2761 0
 5147 2d68 1800A0E3 		mov	r0, #24
 5148 2d6c FEFFFFEB 		bl	ControlHandle
 5149              	.LVL405:
 5150 2d70 30309DE5 		ldr	r3, [sp, #48]
 5151 2d74 CAFDFFEA 		b	.L304
 5152              	.L347:
 5153              	.LVL406:
2741:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5154              		.loc 1 2741 0
 5155 2d78 1300A0E3 		mov	r0, #19
 5156 2d7c FEFFFFEB 		bl	ControlHandle
 5157              	.LVL407:
 5158 2d80 30309DE5 		ldr	r3, [sp, #48]
 5159 2d84 C6FDFFEA 		b	.L304
 5160              	.LVL408:
 5161              	.L418:
 5162              	.LBE124:
 5163              	.LBE154:
 5164              	.LBB155:
 5165              	.LBB113:
3071:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5166              		.loc 1 3071 0
 5167 2d88 64109FE5 		ldr	r1, .L447+84
 5168 2d8c B623DDE1 		ldrh	r2, [sp, #54]
 5169 2d90 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 5170 2d94 0400A0E3 		mov	r0, #4
 5171              	.LVL409:
 5172 2d98 FEFFFFEB 		bl	CyU3PDebugPrint
 5173 2d9c C5FDFFEA 		b	.L368
 5174              	.L448:
 5175              		.align	2
 5176              	.L447:
 5177 2da0 00000000 		.word	.LANCHOR0
 5178 2da4 00000000 		.word	.LANCHOR1
 5179 2da8 00000000 		.word	bRequest
 5180 2dac 00000000 		.word	wValue
 5181 2db0 00000000 		.word	wIndex
 5182 2db4 00000000 		.word	glInterStaBuffer
 5183 2db8 14050000 		.word	.LC28
 5184 2dbc 00000000 		.word	glChHandleInterStat
 5185 2dc0 00000000 		.word	bmReqType
 5186 2dc4 00000000 		.word	wLength
 5187 2dc8 98040000 		.word	.LC27
 5188 2dcc 7C000000 		.word	.LANCHOR0+124
 5189 2dd0 68050000 		.word	.LC30
 5190 2dd4 48060000 		.word	.LANCHOR1+1608
 5191 2dd8 54060000 		.word	.LANCHOR1+1620
 5192 2ddc 10060000 		.word	.LANCHOR1+1552
 5193 2de0 2C060000 		.word	.LANCHOR1+1580
 5194 2de4 58000000 		.word	.LANCHOR0+88
 5195 2de8 B8050000 		.word	.LC32
 5196 2dec D4010000 		.word	.LC12
 5197 2df0 40050000 		.word	.LC29
 5198 2df4 90050000 		.word	.LC31
 5199              	.LBE113:
 5200              	.LBE155:
 5201              		.cfi_endproc
 5202              	.LFE24:
 5204              		.align	2
 5205              		.global	CamDefSet
 5207              	CamDefSet:
 5208              	.LFB4:
1143:../uvc.c      **** {
 5209              		.loc 1 1143 0
 5210              		.cfi_startproc
 5211              		@ args = 0, pretend = 0, frame = 24
 5212              		@ frame_needed = 0, uses_anonymous_args = 0
 5213              	.LVL410:
 5214 2df8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5215              	.LCFI19:
 5216              		.cfi_def_cfa_offset 36
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5217              		.loc 1 1149 0
 5218 2dfc AC429FE5 		ldr	r4, .L452
 5219              		.cfi_offset 14, -4
 5220              		.cfi_offset 11, -8
 5221              		.cfi_offset 10, -12
 5222              		.cfi_offset 9, -16
 5223              		.cfi_offset 8, -20
 5224              		.cfi_offset 7, -24
 5225              		.cfi_offset 6, -28
 5226              		.cfi_offset 5, -32
 5227              		.cfi_offset 4, -36
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5228              		.loc 1 1154 0
 5229 2e00 AC229FE5 		ldr	r2, .L452+4
1151:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5230              		.loc 1 1151 0
 5231 2e04 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1143:../uvc.c      **** {
 5232              		.loc 1 1143 0
 5233 2e08 2CD04DE2 		sub	sp, sp, #44
 5234              	.LCFI20:
 5235              		.cfi_def_cfa_offset 80
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5236              		.loc 1 1154 0
 5237 2e0c 1C0092E5 		ldr	r0, [r2, #28]
 5238 2e10 0010E0E3 		mvn	r1, #0
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5239              		.loc 1 1156 0
 5240 2e14 2963A0E1 		mov	r6, r9, lsr #6
1150:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5241              		.loc 1 1150 0
 5242 2e18 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5243              		.loc 1 1149 0
 5244 2e1c 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5245              	.LVL411:
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5246              		.loc 1 1154 0
 5247 2e20 FEFFFFEB 		bl	_txe_mutex_get
1155:../uvc.c      ****     if(Data1&0x80){
 5248              		.loc 1 1155 0
 5249 2e24 800019E3 		tst	r9, #128
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5250              		.loc 1 1156 0
 5251 2e28 01600612 		andne	r6, r6, #1
 5252 2e2c 0660E011 		mvnne	r6, r6
 5253 2e30 3B600612 		andne	r6, r6, #59
 5254 2e34 0660E011 		mvnne	r6, r6
 5255 2e38 FF600612 		andne	r6, r6, #255
 5256              	.LVL412:
1158:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5257              		.loc 1 1158 0
 5258 2e3c C6608603 		orreq	r6, r6, #198
 5259              	.LVL413:
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5260              		.loc 1 1162 0
 5261 2e40 0080A0E3 		mov	r8, #0
 5262 2e44 0A20A0E1 		mov	r2, sl
 5263 2e48 0730A0E1 		mov	r3, r7
 5264 2e4c 0110A0E3 		mov	r1, #1
1160:../uvc.c      ****     Data0 = (Data0 << 2);
 5265              		.loc 1 1160 0
 5266 2e50 0951A0E1 		mov	r5, r9, asl #2
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5267              		.loc 1 1162 0
 5268 2e54 58029FE5 		ldr	r0, .L452+4
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5269              		.loc 1 1165 0
 5270 2e58 0190A0E3 		mov	r9, #1
 5271              	.LVL414:
1160:../uvc.c      ****     Data0 = (Data0 << 2);
 5272              		.loc 1 1160 0
 5273 2e5c FF5005E2 		and	r5, r5, #255
 5274              	.LVL415:
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5275              		.loc 1 1162 0
 5276 2e60 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5277 2e64 FEFFFFEB 		bl	cmdSet
 5278              	.LVL416:
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5279              		.loc 1 1165 0
 5280 2e68 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5281 2e6c 0910A0E1 		mov	r1, r9
 5282 2e70 0730A0E1 		mov	r3, r7
 5283 2e74 38029FE5 		ldr	r0, .L452+4
 5284 2e78 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5285 2e7c FEFFFFEB 		bl	cmdSet
 5286              	.LVL417:
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5287              		.loc 1 1168 0
 5288 2e80 0620A0E1 		mov	r2, r6
 5289 2e84 0530A0E1 		mov	r3, r5
 5290 2e88 28129FE5 		ldr	r1, .L452+8
 5291 2e8c 0400A0E3 		mov	r0, #4
1167:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5292              		.loc 1 1167 0
 5293 2e90 A661C4E5 		strb	r6, [r4, #422]
1166:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5294              		.loc 1 1166 0
 5295 2e94 A551C4E5 		strb	r5, [r4, #421]
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5296              		.loc 1 1168 0
 5297 2e98 FEFFFFEB 		bl	CyU3PDebugPrint
 5298              	.LVL418:
1173:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5299              		.loc 1 1173 0
 5300 2e9c BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5301              	.LVL419:
1174:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5302              		.loc 1 1174 0
 5303 2ea0 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5304 2ea4 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5305 2ea8 0210A0E3 		mov	r1, #2
 5306 2eac 00029FE5 		ldr	r0, .L452+4
 5307 2eb0 00B08DE5 		str	fp, [sp, #0]
 5308 2eb4 04808DE5 		str	r8, [sp, #4]
 5309 2eb8 FEFFFFEB 		bl	cmdSet
 5310              	.LVL420:
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5311              		.loc 1 1176 0
 5312 2ebc 0B20A0E1 		mov	r2, fp
 5313 2ec0 0530A0E1 		mov	r3, r5
 5314 2ec4 EC119FE5 		ldr	r1, .L452+8
 5315 2ec8 0400A0E3 		mov	r0, #4
1175:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5316              		.loc 1 1175 0
 5317 2ecc BD51C4E5 		strb	r5, [r4, #445]
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5318              		.loc 1 1176 0
 5319 2ed0 FEFFFFEB 		bl	CyU3PDebugPrint
 5320              	.LVL421:
1181:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5321              		.loc 1 1181 0
 5322 2ed4 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1180:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5323              		.loc 1 1180 0
 5324 2ed8 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5325              	.LVL422:
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5326              		.loc 1 1182 0
 5327 2edc 80B047E2 		sub	fp, r7, #128
 5328 2ee0 FF100BE2 		and	r1, fp, #255
 5329 2ee4 14108DE5 		str	r1, [sp, #20]
 5330 2ee8 14C09DE5 		ldr	ip, [sp, #20]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5331              		.loc 1 1183 0
 5332 2eec 760047E2 		sub	r0, r7, #118
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5333              		.loc 1 1184 0
 5334 2ef0 7EE087E2 		add	lr, r7, #126
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5335              		.loc 1 1182 0
 5336 2ef4 0630A0E1 		mov	r3, r6
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5337              		.loc 1 1183 0
 5338 2ef8 18008DE5 		str	r0, [sp, #24]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5339              		.loc 1 1182 0
 5340 2efc 0510A0E3 		mov	r1, #5
 5341 2f00 DF20A0E3 		mov	r2, #223
 5342 2f04 A8019FE5 		ldr	r0, .L452+4
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5343              		.loc 1 1184 0
 5344 2f08 1CE08DE5 		str	lr, [sp, #28]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5345              		.loc 1 1182 0
 5346 2f0c 00C08DE5 		str	ip, [sp, #0]
 5347 2f10 04808DE5 		str	r8, [sp, #4]
 5348 2f14 FEFFFFEB 		bl	cmdSet
 5349              	.LVL423:
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5350              		.loc 1 1183 0
 5351 2f18 18A09DE5 		ldr	sl, [sp, #24]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5352              		.loc 1 1185 0
 5353 2f1c 72E087E2 		add	lr, r7, #114
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5354              		.loc 1 1183 0
 5355 2f20 FFC00AE2 		and	ip, sl, #255
 5356 2f24 0630A0E1 		mov	r3, r6
 5357 2f28 0510A0E3 		mov	r1, #5
 5358 2f2c DC20A0E3 		mov	r2, #220
 5359 2f30 7C019FE5 		ldr	r0, .L452+4
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5360              		.loc 1 1185 0
 5361 2f34 20E08DE5 		str	lr, [sp, #32]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5362              		.loc 1 1183 0
 5363 2f38 00C08DE5 		str	ip, [sp, #0]
 5364 2f3c 04908DE5 		str	r9, [sp, #4]
 5365 2f40 FEFFFFEB 		bl	cmdSet
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5366              		.loc 1 1184 0
 5367 2f44 1C009DE5 		ldr	r0, [sp, #28]
 5368 2f48 02E0A0E3 		mov	lr, #2
 5369 2f4c FFC000E2 		and	ip, r0, #255
 5370 2f50 0630A0E1 		mov	r3, r6
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5371              		.loc 1 1186 0
 5372 2f54 6FA047E2 		sub	sl, r7, #111
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5373              		.loc 1 1184 0
 5374 2f58 0510A0E3 		mov	r1, #5
 5375 2f5c DE20A0E3 		mov	r2, #222
 5376 2f60 4C019FE5 		ldr	r0, .L452+4
 5377 2f64 04E08DE5 		str	lr, [sp, #4]
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5378              		.loc 1 1186 0
 5379 2f68 24A08DE5 		str	sl, [sp, #36]
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5380              		.loc 1 1184 0
 5381 2f6c 00C08DE5 		str	ip, [sp, #0]
 5382 2f70 FEFFFFEB 		bl	cmdSet
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5383              		.loc 1 1185 0
 5384 2f74 20A09DE5 		ldr	sl, [sp, #32]
 5385 2f78 0630A0E1 		mov	r3, r6
 5386 2f7c FFC00AE2 		and	ip, sl, #255
 5387 2f80 00C08DE5 		str	ip, [sp, #0]
 5388 2f84 0510A0E3 		mov	r1, #5
 5389 2f88 03C0A0E3 		mov	ip, #3
 5390 2f8c E020A0E3 		mov	r2, #224
 5391 2f90 1C019FE5 		ldr	r0, .L452+4
 5392 2f94 04C08DE5 		str	ip, [sp, #4]
 5393 2f98 FEFFFFEB 		bl	cmdSet
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5394              		.loc 1 1186 0
 5395 2f9c 24009DE5 		ldr	r0, [sp, #36]
 5396 2fa0 04A0A0E3 		mov	sl, #4
 5397 2fa4 FFC000E2 		and	ip, r0, #255
 5398 2fa8 0630A0E1 		mov	r3, r6
 5399 2fac 0510A0E3 		mov	r1, #5
 5400 2fb0 DD20A0E3 		mov	r2, #221
 5401 2fb4 F8009FE5 		ldr	r0, .L452+4
 5402 2fb8 00C08DE5 		str	ip, [sp, #0]
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5403              		.loc 1 1187 0
 5404 2fbc 7F7087E2 		add	r7, r7, #127
 5405              	.LVL424:
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5406              		.loc 1 1186 0
 5407 2fc0 04A08DE5 		str	sl, [sp, #4]
 5408 2fc4 FEFFFFEB 		bl	cmdSet
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5409              		.loc 1 1187 0
 5410 2fc8 05E0A0E3 		mov	lr, #5
 5411 2fcc 0E10A0E1 		mov	r1, lr
 5412 2fd0 0630A0E1 		mov	r3, r6
 5413 2fd4 E120A0E3 		mov	r2, #225
 5414 2fd8 FF6007E2 		and	r6, r7, #255
 5415              	.LVL425:
 5416 2fdc D0009FE5 		ldr	r0, .L452+4
 5417 2fe0 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5418 2fe4 FEFFFFEB 		bl	cmdSet
 5419              	.LVL426:
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5420              		.loc 1 1188 0
 5421 2fe8 14C09DE5 		ldr	ip, [sp, #20]
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5422              		.loc 1 1189 0
 5423 2fec 24E09DE5 		ldr	lr, [sp, #36]
 5424 2ff0 1C609DE5 		ldr	r6, [sp, #28]
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5425              		.loc 1 1188 0
 5426 2ff4 05C2C4E5 		strb	ip, [r4, #517]
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5427              		.loc 1 1189 0
 5428 2ff8 20C09DE5 		ldr	ip, [sp, #32]
 5429 2ffc 0B20A0E1 		mov	r2, fp
 5430 3000 18309DE5 		ldr	r3, [sp, #24]
 5431 3004 B0109FE5 		ldr	r1, .L452+12
 5432 3008 0A00A0E1 		mov	r0, sl
 5433 300c 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5434 3010 0C708DE5 		str	r7, [sp, #12]
 5435 3014 FEFFFFEB 		bl	CyU3PDebugPrint
 5436              	.LVL427:
1193:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5437              		.loc 1 1193 0
 5438 3018 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5439              	.LVL428:
1194:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5440              		.loc 1 1194 0
 5441 301c 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5442              	.LVL429:
1195:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5443              		.loc 1 1195 0
 5444 3020 0730A0E1 		mov	r3, r7
 5445 3024 0610A0E3 		mov	r1, #6
 5446 3028 8520A0E3 		mov	r2, #133
 5447 302c 80009FE5 		ldr	r0, .L452+4
 5448 3030 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5449 3034 FEFFFFEB 		bl	cmdSet
1196:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5450              		.loc 1 1196 0
 5451 3038 0730A0E1 		mov	r3, r7
 5452 303c 0610A0E3 		mov	r1, #6
 5453 3040 8620A0E3 		mov	r2, #134
 5454 3044 68009FE5 		ldr	r0, .L452+4
 5455 3048 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5456 304c FEFFFFEB 		bl	cmdSet
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5457              		.loc 1 1198 0
 5458 3050 0620A0E1 		mov	r2, r6
 5459 3054 0530A0E1 		mov	r3, r5
 5460 3058 58109FE5 		ldr	r1, .L452+8
 5461 305c 0A00A0E1 		mov	r0, sl
1197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5462              		.loc 1 1197 0
 5463 3060 1D62C4E5 		strb	r6, [r4, #541]
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5464              		.loc 1 1198 0
 5465 3064 FEFFFFEB 		bl	CyU3PDebugPrint
 5466              	.LVL430:
1203:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5467              		.loc 1 1203 0
 5468 3068 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5469              	.LVL431:
1204:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5470              		.loc 1 1204 0
 5471 306c 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5472 3070 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5473 3074 0710A0E3 		mov	r1, #7
 5474 3078 34009FE5 		ldr	r0, .L452+4
 5475 307c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5476 3080 FEFFFFEB 		bl	cmdSet
 5477              	.LVL432:
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5478              		.loc 1 1206 0
 5479 3084 0530A0E1 		mov	r3, r5
 5480 3088 0A00A0E1 		mov	r0, sl
 5481 308c 24109FE5 		ldr	r1, .L452+8
 5482 3090 0620A0E1 		mov	r2, r6
1205:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5483              		.loc 1 1205 0
 5484 3094 3552C4E5 		strb	r5, [r4, #565]
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5485              		.loc 1 1206 0
 5486 3098 FEFFFFEB 		bl	CyU3PDebugPrint
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5487              		.loc 1 1208 0
 5488 309c 10309FE5 		ldr	r3, .L452+4
 5489 30a0 1C0093E5 		ldr	r0, [r3, #28]
1211:../uvc.c      **** }
 5490              		.loc 1 1211 0
 5491 30a4 2CD08DE2 		add	sp, sp, #44
 5492 30a8 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5493              		.loc 1 1208 0
 5494 30ac FEFFFFEA 		b	_txe_mutex_put
 5495              	.L453:
 5496              		.align	2
 5497              	.L452:
 5498 30b0 00000000 		.word	.LANCHOR1
 5499 30b4 00000000 		.word	cmdQu
 5500 30b8 EC050000 		.word	.LC33
 5501 30bc 0C060000 		.word	.LC34
 5502              		.cfi_endproc
 5503              	.LFE4:
 5505              		.align	2
 5506              		.global	CyFxUVCAddHeader
 5508              	CyFxUVCAddHeader:
 5509              	.LFB5:
1219:../uvc.c      **** {
 5510              		.loc 1 1219 0
 5511              		.cfi_startproc
 5512              		@ args = 0, pretend = 0, frame = 0
 5513              		@ frame_needed = 0, uses_anonymous_args = 0
 5514              	.LVL433:
 5515 30c0 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5516              	.LCFI21:
 5517              		.cfi_def_cfa_offset 16
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5518              		.loc 1 1221 0
 5519 30c4 0C20A0E3 		mov	r2, #12
1219:../uvc.c      **** {
 5520              		.loc 1 1219 0
 5521 30c8 0150A0E1 		mov	r5, r1
 5522              		.cfi_offset 14, -4
 5523              		.cfi_offset 5, -8
 5524              		.cfi_offset 4, -12
 5525              		.cfi_offset 3, -16
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5526              		.loc 1 1221 0
 5527 30cc 18109FE5 		ldr	r1, .L456
 5528              	.LVL434:
1219:../uvc.c      **** {
 5529              		.loc 1 1219 0
 5530 30d0 0040A0E1 		mov	r4, r0
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5531              		.loc 1 1221 0
 5532 30d4 FEFFFFEB 		bl	CyU3PMemCopy
 5533              	.LVL435:
1224:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5534              		.loc 1 1224 0
 5535 30d8 020015E3 		tst	r5, #2
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5536              		.loc 1 1226 0
 5537 30dc 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5538 30e0 02308313 		orrne	r3, r3, #2
 5539 30e4 0130C415 		strneb	r3, [r4, #1]
 5540 30e8 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5541              	.L457:
 5542              		.align	2
 5543              	.L456:
 5544 30ec 80040000 		.word	.LANCHOR1+1152
 5545              		.cfi_endproc
 5546              	.LFE5:
 5548              		.align	2
 5549              		.global	CyFxAppErrorHandler
 5551              	CyFxAppErrorHandler:
 5552              	.LFB6:
1236:../uvc.c      **** {
 5553              		.loc 1 1236 0
 5554              		.cfi_startproc
 5555              		@ args = 0, pretend = 0, frame = 0
 5556              		@ frame_needed = 0, uses_anonymous_args = 0
 5557              	.LVL436:
 5558 30f0 08402DE9 		stmfd	sp!, {r3, lr}
 5559              	.LCFI22:
 5560              		.cfi_def_cfa_offset 8
 5561              	.LVL437:
 5562              	.L459:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5563              		.loc 1 1246 0 discriminator 1
 5564 30f4 10109FE5 		ldr	r1, .L460
 5565 30f8 0400A0E3 		mov	r0, #4
 5566              		.cfi_offset 14, -4
 5567              		.cfi_offset 3, -8
 5568 30fc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 5569              		.loc 1 1247 0 discriminator 1
 5570 3100 FA0FA0E3 		mov	r0, #1000
 5571 3104 FEFFFFEB 		bl	_tx_thread_sleep
 5572 3108 F9FFFFEA 		b	.L459
 5573              	.L461:
 5574              		.align	2
 5575              	.L460:
 5576 310c D4010000 		.word	.LC12
 5577              		.cfi_endproc
 5578              	.LFE6:
 5580              		.align	2
 5581              		.global	UVCAppThread_Entry
 5583              	UVCAppThread_Entry:
 5584              	.LFB18:
2191:../uvc.c      **** {
 5585              		.loc 1 2191 0
 5586              		.cfi_startproc
 5587              		@ args = 0, pretend = 0, frame = 176
 5588              		@ frame_needed = 0, uses_anonymous_args = 0
 5589              	.LVL438:
 5590 3110 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5591              	.LCFI23:
 5592              		.cfi_def_cfa_offset 28
 5593 3114 BCD04DE2 		sub	sp, sp, #188
 5594              	.LCFI24:
 5595              		.cfi_def_cfa_offset 216
 5596              	.LBB212:
 5597              	.LBB213:
1648:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5598              		.loc 1 1648 0
 5599              		.cfi_offset 14, -4
 5600              		.cfi_offset 10, -8
 5601              		.cfi_offset 8, -12
 5602              		.cfi_offset 7, -16
 5603              		.cfi_offset 6, -20
 5604              		.cfi_offset 5, -24
 5605              		.cfi_offset 4, -28
 5606 3118 FEFFFFEB 		bl	CyU3PUartInit
 5607              	.LVL439:
1649:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5608              		.loc 1 1649 0
 5609 311c 004050E2 		subs	r4, r0, #0
 5610 3120 0400000A 		beq	.L463
1651:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5611              		.loc 1 1651 0
 5612 3124 0400A0E3 		mov	r0, #4
 5613              	.LVL440:
 5614 3128 A41A9FE5 		ldr	r1, .L557
 5615 312c FEFFFFEB 		bl	CyU3PDebugPrint
1652:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5616              		.loc 1 1652 0
 5617 3130 0400A0E1 		mov	r0, r4
 5618 3134 FEFFFFEB 		bl	CyFxAppErrorHandler
 5619              	.L463:
1656:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5620              		.loc 1 1656 0
 5621 3138 98CA9FE5 		ldr	ip, .L557+4
1658:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5622              		.loc 1 1658 0
 5623 313c 0030A0E3 		mov	r3, #0
1657:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5624              		.loc 1 1657 0
 5625 3140 0120A0E3 		mov	r2, #1
1665:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5626              		.loc 1 1665 0
 5627 3144 50008DE2 		add	r0, sp, #80
 5628 3148 0310A0E1 		mov	r1, r3
1656:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5629              		.loc 1 1656 0
 5630 314c 60C08DE5 		str	ip, [sp, #96]
1657:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5631              		.loc 1 1657 0
 5632 3150 6420CDE5 		strb	r2, [sp, #100]
1658:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5633              		.loc 1 1658 0
 5634 3154 6530CDE5 		strb	r3, [sp, #101]
1659:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5635              		.loc 1 1659 0
 5636 3158 50208DE5 		str	r2, [sp, #80]
1660:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5637              		.loc 1 1660 0
 5638 315c 54308DE5 		str	r3, [sp, #84]
1661:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5639              		.loc 1 1661 0
 5640 3160 58308DE5 		str	r3, [sp, #88]
1662:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5641              		.loc 1 1662 0
 5642 3164 5C208DE5 		str	r2, [sp, #92]
1665:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5643              		.loc 1 1665 0
 5644 3168 FEFFFFEB 		bl	CyU3PUartSetConfig
 5645              	.LVL441:
1666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5646              		.loc 1 1666 0
 5647 316c 000050E3 		cmp	r0, #0
 5648 3170 0000000A 		beq	.L464
1668:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5649              		.loc 1 1668 0
 5650 3174 FEFFFFEB 		bl	CyFxAppErrorHandler
 5651              	.LVL442:
 5652              	.L464:
1672:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5653              		.loc 1 1672 0
 5654 3178 0000E0E3 		mvn	r0, #0
 5655 317c FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5656              	.LVL443:
1673:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5657              		.loc 1 1673 0
 5658 3180 000050E3 		cmp	r0, #0
 5659 3184 0000000A 		beq	.L465
1675:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5660              		.loc 1 1675 0
 5661 3188 FEFFFFEB 		bl	CyFxAppErrorHandler
 5662              	.LVL444:
 5663              	.L465:
1679:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5664              		.loc 1 1679 0
 5665 318c 0300A0E3 		mov	r0, #3
 5666 3190 0410A0E3 		mov	r1, #4
 5667 3194 FEFFFFEB 		bl	CyU3PDebugInit
 5668              	.LVL445:
1680:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5669              		.loc 1 1680 0
 5670 3198 000050E3 		cmp	r0, #0
 5671 319c 0000000A 		beq	.L466
1682:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5672              		.loc 1 1682 0
 5673 31a0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5674              	.LVL446:
 5675              	.L466:
1686:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5676              		.loc 1 1686 0
 5677 31a4 0000A0E3 		mov	r0, #0
 5678 31a8 FEFFFFEB 		bl	CyU3PDebugPreamble
 5679              	.LVL447:
 5680              	.LBE213:
 5681              	.LBE212:
2206:../uvc.c      **** 		CyU3PThreadSleep(500);
 5682              		.loc 1 2206 0
 5683 31ac 7D0FA0E3 		mov	r0, #500
 5684 31b0 FEFFFFEB 		bl	_tx_thread_sleep
 5685              	.LVL448:
 5686 31b4 7D0FA0E3 		mov	r0, #500
 5687 31b8 FEFFFFEB 		bl	_tx_thread_sleep
 5688 31bc 7D0FA0E3 		mov	r0, #500
 5689 31c0 FEFFFFEB 		bl	_tx_thread_sleep
 5690 31c4 7D0FA0E3 		mov	r0, #500
 5691 31c8 FEFFFFEB 		bl	_tx_thread_sleep
 5692 31cc 7D0FA0E3 		mov	r0, #500
 5693 31d0 FEFFFFEB 		bl	_tx_thread_sleep
 5694 31d4 7D0FA0E3 		mov	r0, #500
 5695 31d8 FEFFFFEB 		bl	_tx_thread_sleep
 5696              	.LBB214:
 5697              	.LBB215:
1697:../uvc.c      ****     status = CyU3PI2cInit ();
 5698              		.loc 1 1697 0
 5699 31dc FEFFFFEB 		bl	CyU3PI2cInit
 5700              	.LVL449:
1698:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5701              		.loc 1 1698 0
 5702 31e0 002050E2 		subs	r2, r0, #0
 5703 31e4 0201001A 		bne	.L532
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5704              		.loc 1 1705 0
 5705 31e8 EC599FE5 		ldr	r5, .L557+8
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5706              		.loc 1 1707 0
 5707 31ec 0040E0E3 		mvn	r4, #0
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5708              		.loc 1 1710 0
 5709 31f0 0210A0E1 		mov	r1, r2
 5710 31f4 8C008DE2 		add	r0, sp, #140
 5711              	.LVL450:
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5712              		.loc 1 1705 0
 5713 31f8 8C508DE5 		str	r5, [sp, #140]
1706:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5714              		.loc 1 1706 0
 5715 31fc 90208DE5 		str	r2, [sp, #144]
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5716              		.loc 1 1707 0
 5717 3200 94408DE5 		str	r4, [sp, #148]
1708:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5718              		.loc 1 1708 0
 5719 3204 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5720              		.loc 1 1710 0
 5721 3208 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5722              	.LVL451:
1711:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5723              		.loc 1 1711 0
 5724 320c 001050E2 		subs	r1, r0, #0
 5725 3210 0001001A 		bne	.L533
 5726              	.LBE215:
 5727              	.LBE214:
 5728              	.LBB221:
 5729              	.LBB224:
1784:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5730              		.loc 1 1784 0
 5731 3214 C4699FE5 		ldr	r6, .L557+12
 5732 3218 2820A0E3 		mov	r2, #40
 5733 321c 0600A0E1 		mov	r0, r6
 5734              	.LVL452:
 5735 3220 FEFFFFEB 		bl	_txe_event_flags_create
 5736              	.LVL453:
1785:../uvc.c      ****     if (apiRetStatus != 0)
 5737              		.loc 1 1785 0
 5738 3224 002050E2 		subs	r2, r0, #0
 5739 3228 0301001A 		bne	.L534
1799:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5740              		.loc 1 1799 0
 5741 322c 0280A0E3 		mov	r8, #2
1806:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5742              		.loc 1 1806 0
 5743 3230 0210A0E1 		mov	r1, r2
 5744 3234 9C008DE2 		add	r0, sp, #156
 5745              	.LVL454:
1802:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5746              		.loc 1 1802 0
 5747 3238 017088E2 		add	r7, r8, #1
1795:../uvc.c      ****     isUsbConnected = CyFalse;
 5748              		.loc 1 1795 0
 5749 323c 3C2086E5 		str	r2, [r6, #60]
1796:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5750              		.loc 1 1796 0
 5751 3240 402086E5 		str	r2, [r6, #64]
1801:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5752              		.loc 1 1801 0
 5753 3244 A420CDE5 		strb	r2, [sp, #164]
1803:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5754              		.loc 1 1803 0
 5755 3248 A0208DE5 		str	r2, [sp, #160]
1799:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5756              		.loc 1 1799 0
 5757 324c 9C80CDE5 		strb	r8, [sp, #156]
1800:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5758              		.loc 1 1800 0
 5759 3250 9D80CDE5 		strb	r8, [sp, #157]
1802:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5760              		.loc 1 1802 0
 5761 3254 A570CDE5 		strb	r7, [sp, #165]
1806:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5762              		.loc 1 1806 0
 5763 3258 FEFFFFEB 		bl	CyU3PGpioInit
 5764              	.LVL455:
1807:../uvc.c      ****     if (apiRetStatus != 0)
 5765              		.loc 1 1807 0
 5766 325c 002050E2 		subs	r2, r0, #0
 5767 3260 7B01001A 		bne	.L535
1815:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5768              		.loc 1 1815 0
 5769 3264 1600A0E3 		mov	r0, #22
 5770              	.LVL456:
 5771 3268 0110A0E3 		mov	r1, #1
 5772 326c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5773              	.LVL457:
1816:../uvc.c      ****     if (apiRetStatus != 0)
 5774              		.loc 1 1816 0
 5775 3270 002050E2 		subs	r2, r0, #0
 5776 3274 6D01001A 		bne	.L536
1821:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5777              		.loc 1 1821 0
 5778 3278 1400A0E3 		mov	r0, #20
 5779              	.LVL458:
 5780 327c 0110A0E3 		mov	r1, #1
 5781 3280 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5782              	.LVL459:
1822:../uvc.c      ****     if (apiRetStatus != 0)
 5783              		.loc 1 1822 0
 5784 3284 002050E2 		subs	r2, r0, #0
 5785 3288 5F01001A 		bne	.L537
1827:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5786              		.loc 1 1827 0
 5787 328c 1800A0E3 		mov	r0, #24
 5788              	.LVL460:
 5789 3290 0110A0E3 		mov	r1, #1
 5790 3294 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5791              	.LVL461:
1828:../uvc.c      ****     if (apiRetStatus != 0)
 5792              		.loc 1 1828 0
 5793 3298 002050E2 		subs	r2, r0, #0
 5794 329c 5101001A 		bne	.L538
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5795              		.loc 1 1835 0
 5796 32a0 0140A0E3 		mov	r4, #1
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5797              		.loc 1 1840 0
 5798 32a4 1600A0E3 		mov	r0, #22
 5799              	.LVL462:
 5800 32a8 68108DE2 		add	r1, sp, #104
1838:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5801              		.loc 1 1838 0
 5802 32ac 74208DE5 		str	r2, [sp, #116]
1839:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5803              		.loc 1 1839 0
 5804 32b0 7820CDE5 		strb	r2, [sp, #120]
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5805              		.loc 1 1835 0
 5806 32b4 68408DE5 		str	r4, [sp, #104]
1836:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5807              		.loc 1 1836 0
 5808 32b8 6C408DE5 		str	r4, [sp, #108]
1837:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5809              		.loc 1 1837 0
 5810 32bc 70408DE5 		str	r4, [sp, #112]
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5811              		.loc 1 1840 0
 5812 32c0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5813              	.LVL463:
1841:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5814              		.loc 1 1841 0
 5815 32c4 002050E2 		subs	r2, r0, #0
 5816 32c8 1B01001A 		bne	.L539
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5817              		.loc 1 1854 0
 5818 32cc 1400A0E3 		mov	r0, #20
 5819              	.LVL464:
 5820 32d0 68108DE2 		add	r1, sp, #104
1852:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5821              		.loc 1 1852 0
 5822 32d4 74208DE5 		str	r2, [sp, #116]
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5823              		.loc 1 1853 0
 5824 32d8 7820CDE5 		strb	r2, [sp, #120]
1849:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5825              		.loc 1 1849 0
 5826 32dc 68408DE5 		str	r4, [sp, #104]
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5827              		.loc 1 1850 0
 5828 32e0 6C408DE5 		str	r4, [sp, #108]
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5829              		.loc 1 1851 0
 5830 32e4 70408DE5 		str	r4, [sp, #112]
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5831              		.loc 1 1854 0
 5832 32e8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5833              	.LVL465:
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5834              		.loc 1 1855 0
 5835 32ec 002050E2 		subs	r2, r0, #0
 5836 32f0 0801001A 		bne	.L540
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5837              		.loc 1 1868 0
 5838 32f4 1800A0E3 		mov	r0, #24
 5839              	.LVL466:
 5840 32f8 68108DE2 		add	r1, sp, #104
1863:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5841              		.loc 1 1863 0
 5842 32fc 68208DE5 		str	r2, [sp, #104]
1864:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5843              		.loc 1 1864 0
 5844 3300 6C208DE5 		str	r2, [sp, #108]
1865:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5845              		.loc 1 1865 0
 5846 3304 70208DE5 		str	r2, [sp, #112]
1867:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5847              		.loc 1 1867 0
 5848 3308 7820CDE5 		strb	r2, [sp, #120]
1866:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5849              		.loc 1 1866 0
 5850 330c 74408DE5 		str	r4, [sp, #116]
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5851              		.loc 1 1868 0
 5852 3310 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5853              	.LVL467:
1869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5854              		.loc 1 1869 0
 5855 3314 002050E2 		subs	r2, r0, #0
 5856 3318 F500001A 		bne	.L541
1878:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5857              		.loc 1 1878 0
 5858 331c 00A0A0E3 		mov	sl, #0
1876:../uvc.c      ****     pibclock.clkDiv      = 2;
 5859              		.loc 1 1876 0
 5860 3320 0270A0E3 		mov	r7, #2	@ movhi
1877:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5861              		.loc 1 1877 0
 5862 3324 0380A0E3 		mov	r8, #3
1881:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5863              		.loc 1 1881 0
 5864 3328 0100A0E3 		mov	r0, #1
 5865              	.LVL468:
 5866 332c 7C108DE2 		add	r1, sp, #124
1876:../uvc.c      ****     pibclock.clkDiv      = 2;
 5867              		.loc 1 1876 0
 5868 3330 BC77CDE1 		strh	r7, [sp, #124]	@ movhi
1877:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5869              		.loc 1 1877 0
 5870 3334 8880CDE5 		strb	r8, [sp, #136]
1878:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5871              		.loc 1 1878 0
 5872 3338 84A08DE5 		str	sl, [sp, #132]
1879:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5873              		.loc 1 1879 0
 5874 333c 80A08DE5 		str	sl, [sp, #128]
1881:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5875              		.loc 1 1881 0
 5876 3340 FEFFFFEB 		bl	CyU3PPibInit
 5877              	.LVL469:
1882:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5878              		.loc 1 1882 0
 5879 3344 002050E2 		subs	r2, r0, #0
 5880 3348 7A01001A 		bne	.L542
1889:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5881              		.loc 1 1889 0
 5882 334c 90089FE5 		ldr	r0, .L557+16
 5883              	.LVL470:
 5884 3350 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 5885              	.LVL471:
1897:../uvc.c      ****     SensorReset ();
 5886              		.loc 1 1897 0
 5887 3354 FEFFFFEB 		bl	SensorReset
1898:../uvc.c      ****     SensorInit ();
 5888              		.loc 1 1898 0
 5889 3358 FEFFFFEB 		bl	SensorInit
1901:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5890              		.loc 1 1901 0
 5891 335c FEFFFFEB 		bl	CyU3PUsbStart
 5892              	.LVL472:
1902:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5893              		.loc 1 1902 0
 5894 3360 004050E2 		subs	r4, r0, #0
 5895 3364 6901001A 		bne	.L543
1908:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 5896              		.loc 1 1908 0
 5897 3368 0410A0E1 		mov	r1, r4
 5898 336c 74089FE5 		ldr	r0, .L557+20
 5899              	.LVL473:
 5900 3370 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 5901              	.LVL474:
1911:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 5902              		.loc 1 1911 0
 5903 3374 70089FE5 		ldr	r0, .L557+24
 5904 3378 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1917:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 5905              		.loc 1 1917 0
 5906 337c 6C289FE5 		ldr	r2, .L557+28
 5907 3380 0410A0E1 		mov	r1, r4
 5908 3384 0100A0E3 		mov	r0, #1
 5909 3388 FEFFFFEB 		bl	CyU3PUsbSetDesc
1918:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 5910              		.loc 1 1918 0
 5911 338c 0410A0E1 		mov	r1, r4
 5912 3390 5C289FE5 		ldr	r2, .L557+32
 5913 3394 0400A0E1 		mov	r0, r4
 5914 3398 FEFFFFEB 		bl	CyU3PUsbSetDesc
1921:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 5915              		.loc 1 1921 0
 5916 339c 0410A0E1 		mov	r1, r4
 5917 33a0 50289FE5 		ldr	r2, .L557+36
 5918 33a4 0200A0E3 		mov	r0, #2
 5919 33a8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1922:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 5920              		.loc 1 1922 0
 5921 33ac 0410A0E1 		mov	r1, r4
 5922 33b0 44289FE5 		ldr	r2, .L557+40
 5923 33b4 0700A0E3 		mov	r0, #7
 5924 33b8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 5925              		.loc 1 1925 0
 5926 33bc 3C289FE5 		ldr	r2, .L557+44
 5927 33c0 0410A0E1 		mov	r1, r4
 5928 33c4 0400A0E3 		mov	r0, #4
 5929 33c8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1926:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 5930              		.loc 1 1926 0
 5931 33cc 0410A0E1 		mov	r1, r4
 5932 33d0 2C289FE5 		ldr	r2, .L557+48
 5933 33d4 0800A0E1 		mov	r0, r8
 5934 33d8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1927:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5935              		.loc 1 1927 0
 5936 33dc 0410A0E1 		mov	r1, r4
 5937 33e0 20289FE5 		ldr	r2, .L557+52
 5938 33e4 0600A0E3 		mov	r0, #6
 5939 33e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 5940              		.loc 1 1930 0
 5941 33ec 0410A0E1 		mov	r1, r4
 5942 33f0 14289FE5 		ldr	r2, .L557+56
 5943 33f4 0500A0E3 		mov	r0, #5
 5944 33f8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1931:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 5945              		.loc 1 1931 0
 5946 33fc 0110A0E3 		mov	r1, #1
 5947 3400 08289FE5 		ldr	r2, .L557+60
 5948 3404 0500A0E3 		mov	r0, #5
 5949 3408 FEFFFFEB 		bl	CyU3PUsbSetDesc
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 5950              		.loc 1 1932 0
 5951 340c 0210A0E3 		mov	r1, #2
 5952 3410 FC279FE5 		ldr	r2, .L557+64
 5953 3414 0500A0E3 		mov	r0, #5
 5954 3418 FEFFFFEB 		bl	CyU3PUsbSetDesc
1939:../uvc.c      ****     endPointConfig.enable   = 1;
 5955              		.loc 1 1939 0
 5956 341c 0150A0E3 		mov	r5, #1
1941:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5957              		.loc 1 1941 0
 5958 3420 4020A0E3 		mov	r2, #64	@ movhi
1945:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5959              		.loc 1 1945 0
 5960 3424 8200A0E3 		mov	r0, #130
 5961 3428 A8108DE2 		add	r1, sp, #168
1939:../uvc.c      ****     endPointConfig.enable   = 1;
 5962              		.loc 1 1939 0
 5963 342c A8508DE5 		str	r5, [sp, #168]
1940:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 5964              		.loc 1 1940 0
 5965 3430 AC80CDE5 		strb	r8, [sp, #172]
1941:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5966              		.loc 1 1941 0
 5967 3434 B02BCDE1 		strh	r2, [sp, #176]	@ movhi
1942:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 5968              		.loc 1 1942 0
 5969 3438 B340CDE5 		strb	r4, [sp, #179]
1943:../uvc.c      ****     endPointConfig.streams  = 0;
 5970              		.loc 1 1943 0
 5971 343c BE4ACDE1 		strh	r4, [sp, #174]	@ movhi
1944:../uvc.c      ****     endPointConfig.burstLen = 1;
 5972              		.loc 1 1944 0
 5973 3440 B250CDE5 		strb	r5, [sp, #178]
1945:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5974              		.loc 1 1945 0
 5975 3444 FEFFFFEB 		bl	CyU3PSetEpConfig
 5976              	.LVL475:
1946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5977              		.loc 1 1946 0
 5978 3448 003050E2 		subs	r3, r0, #0
 5979 344c 2501001A 		bne	.L544
1956:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5980              		.loc 1 1956 0
 5981 3450 C0C79FE5 		ldr	ip, .L557+68
1957:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5982              		.loc 1 1957 0
 5983 3454 C0E79FE5 		ldr	lr, .L557+72
1954:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5984              		.loc 1 1954 0
 5985 3458 018BA0E3 		mov	r8, #1024	@ movhi
1963:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5986              		.loc 1 1963 0
 5987 345c 10A0A0E3 		mov	sl, #16
1965:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5988              		.loc 1 1965 0
 5989 3460 B8079FE5 		ldr	r0, .L557+76
 5990              	.LVL476:
 5991 3464 0410A0E3 		mov	r1, #4
 5992 3468 34208DE2 		add	r2, sp, #52
1954:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5993              		.loc 1 1954 0
 5994 346c B483CDE1 		strh	r8, [sp, #52]	@ movhi
1955:../uvc.c      ****     dmaInterConfig.count          = 1;
 5995              		.loc 1 1955 0
 5996 3470 B653CDE1 		strh	r5, [sp, #54]	@ movhi
1956:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5997              		.loc 1 1956 0
 5998 3474 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1957:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5999              		.loc 1 1957 0
 6000 3478 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1958:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6001              		.loc 1 1958 0
 6002 347c BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1959:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6003              		.loc 1 1959 0
 6004 3480 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1960:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6005              		.loc 1 1960 0
 6006 3484 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1961:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6007              		.loc 1 1961 0
 6008 3488 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1962:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6009              		.loc 1 1962 0
 6010 348c 4440CDE5 		strb	r4, [sp, #68]
1963:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6011              		.loc 1 1963 0
 6012 3490 48A08DE5 		str	sl, [sp, #72]
1964:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6013              		.loc 1 1964 0
 6014 3494 4C308DE5 		str	r3, [sp, #76]
1965:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6015              		.loc 1 1965 0
 6016 3498 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6017              	.LVL477:
1967:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6018              		.loc 1 1967 0
 6019 349c 008050E2 		subs	r8, r0, #0
 6020 34a0 0601001A 		bne	.L545
1974:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6021              		.loc 1 1974 0
 6022 34a4 010BA0E3 		mov	r0, #1024
 6023              	.LVL478:
 6024 34a8 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6025 34ac 70179FE5 		ldr	r1, .L557+80
1975:../uvc.c      ****     if (glInterStaBuffer == 0)
 6026              		.loc 1 1975 0
 6027 34b0 000050E3 		cmp	r0, #0
1974:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6028              		.loc 1 1974 0
 6029 34b4 000081E5 		str	r0, [r1, #0]
1975:../uvc.c      ****     if (glInterStaBuffer == 0)
 6030              		.loc 1 1975 0
 6031 34b8 3001000A 		beq	.L546
1983:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6032              		.loc 1 1983 0
 6033 34bc 0430A0E3 		mov	r3, #4	@ movhi
 6034 34c0 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
1987:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6035              		.loc 1 1987 0
 6036 34c4 5C379FE5 		ldr	r3, .L557+84
1982:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6037              		.loc 1 1982 0
 6038 34c8 01E9A0E3 		mov	lr, #16384	@ movhi
 6039 34cc BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
1986:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6040              		.loc 1 1986 0
 6041 34d0 54E79FE5 		ldr	lr, .L557+88
1987:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6042              		.loc 1 1987 0
 6043 34d4 BA31CDE1 		strh	r3, [sp, #26]	@ movhi
1994:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6044              		.loc 1 1994 0
 6045 34d8 50379FE5 		ldr	r3, .L557+92
1985:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6046              		.loc 1 1985 0
 6047 34dc 01CCA0E3 		mov	ip, #256	@ movhi
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6048              		.loc 1 1995 0
 6049 34e0 0C208DE2 		add	r2, sp, #12
1985:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6050              		.loc 1 1985 0
 6051 34e4 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
1986:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6052              		.loc 1 1986 0
 6053 34e8 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
1989:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6054              		.loc 1 1989 0
 6055 34ec 0CC0A0E3 		mov	ip, #12	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6056              		.loc 1 1990 0
 6057 34f0 04E0A0E3 		mov	lr, #4	@ movhi
1992:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6058              		.loc 1 1992 0
 6059 34f4 2A40CDE5 		strb	r4, [sp, #42]
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6060              		.loc 1 1995 0
 6061 34f8 34079FE5 		ldr	r0, .L557+96
 6062 34fc 0710A0E3 		mov	r1, #7
1993:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6063              		.loc 1 1993 0
 6064 3500 1840A0E3 		mov	r4, #24
1984:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6065              		.loc 1 1984 0
 6066 3504 B071CDE1 		strh	r7, [sp, #16]	@ movhi
1988:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6067              		.loc 1 1988 0
 6068 3508 B282CDE1 		strh	r8, [sp, #34]	@ movhi
1989:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6069              		.loc 1 1989 0
 6070 350c B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6071              		.loc 1 1990 0
 6072 3510 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
1991:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6073              		.loc 1 1991 0
 6074 3514 B882CDE1 		strh	r8, [sp, #40]	@ movhi
1993:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6075              		.loc 1 1993 0
 6076 3518 2C408DE5 		str	r4, [sp, #44]
1994:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6077              		.loc 1 1994 0
 6078 351c 30308DE5 		str	r3, [sp, #48]
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6079              		.loc 1 1995 0
 6080 3520 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6081              	.LVL479:
1997:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6082              		.loc 1 1997 0
 6083 3524 002050E2 		subs	r2, r0, #0
 6084 3528 0B01001A 		bne	.L547
2088:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6085              		.loc 1 2088 0
 6086 352c 0500A0E1 		mov	r0, r5
 6087              	.LVL480:
 6088 3530 0510A0E1 		mov	r1, r5
 6089 3534 FEFFFFEB 		bl	CyU3PConnectState
 6090              	.LVL481:
2089:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6091              		.loc 1 2089 0
 6092 3538 002050E2 		subs	r2, r0, #0
 6093 353c 6300001A 		bne	.L548
2095:../uvc.c      ****     CyU3PBusyWait(100);
 6094              		.loc 1 2095 0
 6095 3540 6400A0E3 		mov	r0, #100
 6096              	.LVL482:
 6097 3544 FEFFFFEB 		bl	CyU3PBusyWait
 6098              	.LVL483:
2097:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6099              		.loc 1 2097 0
 6100 3548 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2099:../uvc.c      ****     endPointConfig.enable   = 1;
 6101              		.loc 1 2099 0
 6102 354c A8508DE5 		str	r5, [sp, #168]
2100:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6103              		.loc 1 2100 0
 6104 3550 AC70CDE5 		strb	r7, [sp, #172]
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6105              		.loc 1 2112 0
 6106 3554 A8108DE2 		add	r1, sp, #168
2101:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6107              		.loc 1 2101 0
 6108 3558 030050E3 		cmp	r0, #3
2097:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6109              		.loc 1 2097 0
 6110 355c 4800C6E5 		strb	r0, [r6, #72]
2108:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6111              		.loc 1 2108 0
 6112 3560 020CA013 		movne	r0, #512	@ movhi
2103:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6113              		.loc 1 2103 0
 6114 3564 017BA003 		moveq	r7, #1024	@ movhi
2108:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6115              		.loc 1 2108 0
 6116 3568 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2109:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6117              		.loc 1 2109 0
 6118 356c B250CD15 		strneb	r5, [sp, #178]
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6119              		.loc 1 2112 0
 6120 3570 8300A0E3 		mov	r0, #131
2111:../uvc.c      ****     endPointConfig.streams  = 0;
 6121              		.loc 1 2111 0
 6122 3574 0050A0E3 		mov	r5, #0	@ movhi
2103:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6123              		.loc 1 2103 0
 6124 3578 B07BCD01 		streqh	r7, [sp, #176]	@ movhi
2104:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6125              		.loc 1 2104 0
 6126 357c B2A0CD05 		streqb	sl, [sp, #178]
2111:../uvc.c      ****     endPointConfig.streams  = 0;
 6127              		.loc 1 2111 0
 6128 3580 BE5ACDE1 		strh	r5, [sp, #174]	@ movhi
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6129              		.loc 1 2112 0
 6130 3584 FEFFFFEB 		bl	CyU3PSetEpConfig
 6131              	.LVL484:
2113:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6132              		.loc 1 2113 0
 6133 3588 002050E2 		subs	r2, r0, #0
 6134 358c 4600001A 		bne	.L529
 6135 3590 A0869FE5 		ldr	r8, .L557+100
 6136              	.LBE224:
 6137              	.LBE221:
2233:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6138              		.loc 1 2233 0
 6139 3594 44569FE5 		ldr	r5, .L557+12
 6140 3598 0240A0E1 		mov	r4, r2
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6141              		.loc 1 2304 0
 6142 359c 0870A0E1 		mov	r7, r8
 6143              	.LVL485:
 6144              	.L503:
2233:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6145              		.loc 1 2233 0
 6146 35a0 38069FE5 		ldr	r0, .L557+12
 6147 35a4 0110A0E3 		mov	r1, #1
 6148 35a8 0220A0E3 		mov	r2, #2
 6149 35ac B4308DE2 		add	r3, sp, #180
 6150 35b0 00408DE5 		str	r4, [sp, #0]
 6151 35b4 FEFFFFEB 		bl	_txe_event_flags_get
 6152 35b8 000050E3 		cmp	r0, #0
 6153 35bc 2700001A 		bne	.L505
2279:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6154              		.loc 1 2279 0
 6155 35c0 44A095E5 		ldr	sl, [r5, #68]
 6156 35c4 00005AE3 		cmp	sl, #0
 6157 35c8 0300000A 		beq	.L506
2279:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6158              		.loc 1 2279 0 is_stmt 0 discriminator 1
 6159 35cc BE22D5E1 		ldrh	r2, [r5, #46]
 6160 35d0 B013D5E1 		ldrh	r1, [r5, #48]
 6161 35d4 010052E1 		cmp	r2, r1
 6162 35d8 6000000A 		beq	.L549
 6163              	.L506:
2406:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6164              		.loc 1 2406 0 is_stmt 1
 6165 35dc 4010A0E3 		mov	r1, #64
 6166 35e0 0020A0E3 		mov	r2, #0
 6167 35e4 F4059FE5 		ldr	r0, .L557+12
 6168 35e8 FEFFFFEB 		bl	_txe_event_flags_set
2409:../uvc.c      ****         CyU3PThreadRelinquish ();
 6169              		.loc 1 2409 0
 6170 35ec FEFFFFEB 		bl	_txe_thread_relinquish
2410:../uvc.c      ****     }
 6171              		.loc 1 2410 0
 6172 35f0 EAFFFFEA 		b	.L503
 6173              	.LVL486:
 6174              	.L532:
 6175              	.LBB259:
 6176              	.LBB220:
1700:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6177              		.loc 1 1700 0
 6178 35f4 0400A0E3 		mov	r0, #4
 6179              	.LVL487:
 6180 35f8 3C169FE5 		ldr	r1, .L557+104
 6181 35fc FEFFFFEB 		bl	CyU3PDebugPrint
 6182              	.LVL488:
 6183              	.L468:
 6184              	.LBB216:
 6185              	.LBB217:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6186              		.loc 1 1246 0
 6187 3600 38169FE5 		ldr	r1, .L557+108
 6188 3604 0400A0E3 		mov	r0, #4
 6189 3608 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6190              		.loc 1 1247 0
 6191 360c FA0FA0E3 		mov	r0, #1000
 6192 3610 FEFFFFEB 		bl	_tx_thread_sleep
 6193 3614 F9FFFFEA 		b	.L468
 6194              	.LVL489:
 6195              	.L533:
 6196              	.LBE217:
 6197              	.LBE216:
1713:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6198              		.loc 1 1713 0
 6199 3618 0400A0E3 		mov	r0, #4
 6200              	.LVL490:
 6201 361c 20169FE5 		ldr	r1, .L557+112
 6202              	.LVL491:
 6203 3620 FEFFFFEB 		bl	CyU3PDebugPrint
 6204              	.L470:
 6205              	.LBB218:
 6206              	.LBB219:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6207              		.loc 1 1246 0
 6208 3624 14169FE5 		ldr	r1, .L557+108
 6209 3628 0400A0E3 		mov	r0, #4
 6210 362c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6211              		.loc 1 1247 0
 6212 3630 FA0FA0E3 		mov	r0, #1000
 6213 3634 FEFFFFEB 		bl	_tx_thread_sleep
 6214 3638 F9FFFFEA 		b	.L470
 6215              	.LVL492:
 6216              	.L534:
 6217              	.LBE219:
 6218              	.LBE218:
 6219              	.LBE220:
 6220              	.LBE259:
 6221              	.LBB260:
 6222              	.LBB223:
1787:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6223              		.loc 1 1787 0
 6224 363c 0400A0E3 		mov	r0, #4
 6225              	.LVL493:
 6226 3640 00169FE5 		ldr	r1, .L557+116
 6227 3644 FEFFFFEB 		bl	CyU3PDebugPrint
 6228              	.LVL494:
 6229              	.L472:
 6230              	.LBB233:
 6231              	.LBB234:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6232              		.loc 1 1246 0
 6233 3648 F0159FE5 		ldr	r1, .L557+108
 6234 364c 0400A0E3 		mov	r0, #4
 6235 3650 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6236              		.loc 1 1247 0
 6237 3654 FA0FA0E3 		mov	r0, #1000
 6238 3658 FEFFFFEB 		bl	_tx_thread_sleep
 6239 365c F9FFFFEA 		b	.L472
 6240              	.LVL495:
 6241              	.L505:
 6242              	.LBE234:
 6243              	.LBE233:
 6244              	.LBE223:
 6245              	.LBE260:
2335:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6246              		.loc 1 2335 0
 6247 3660 78059FE5 		ldr	r0, .L557+12
 6248 3664 0210A0E3 		mov	r1, #2
 6249 3668 0320A0E3 		mov	r2, #3
 6250 366c B4308DE2 		add	r3, sp, #180
 6251 3670 00408DE5 		str	r4, [sp, #0]
 6252 3674 FEFFFFEB 		bl	_txe_event_flags_get
 6253 3678 000050E3 		cmp	r0, #0
 6254 367c DA00001A 		bne	.L513
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6255              		.loc 1 2350 0
 6256 3680 402095E5 		ldr	r2, [r5, #64]
2338:../uvc.c      ****                 hitFV     = CyFalse;
 6257              		.loc 1 2338 0
 6258 3684 444085E5 		str	r4, [r5, #68]
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6259              		.loc 1 2350 0
 6260 3688 000052E3 		cmp	r2, #0
2339:../uvc.c      ****                 prodCount = 0;
 6261              		.loc 1 2339 0
 6262 368c BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2346:../uvc.c      ****                 fb=0;
 6263              		.loc 1 2346 0
 6264 3690 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2340:../uvc.c      ****                 consCount = 0;
 6265              		.loc 1 2340 0
 6266 3694 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2347:../uvc.c      ****                 pb=0;
 6267              		.loc 1 2347 0
 6268 3698 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2348:../uvc.c      ****                 pbc=0;
 6269              		.loc 1 2348 0
 6270 369c BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6271              		.loc 1 2350 0
 6272 36a0 BF00000A 		beq	.L550
 6273              	.L514:
2362:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6274              		.loc 1 2362 0
 6275 36a4 404086E5 		str	r4, [r6, #64]
 6276 36a8 CBFFFFEA 		b	.L506
 6277              	.LVL496:
 6278              	.L529:
 6279              	.LBB261:
 6280              	.LBB257:
2116:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6281              		.loc 1 2116 0
 6282 36ac 0400A0E3 		mov	r0, #4
 6283              	.LVL497:
 6284 36b0 94159FE5 		ldr	r1, .L557+120
 6285 36b4 FEFFFFEB 		bl	CyU3PDebugPrint
 6286              	.LVL498:
 6287              	.L504:
 6288              	.LBB235:
 6289              	.LBB236:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6290              		.loc 1 1246 0
 6291 36b8 80159FE5 		ldr	r1, .L557+108
 6292 36bc 0400A0E3 		mov	r0, #4
 6293 36c0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6294              		.loc 1 1247 0
 6295 36c4 FA0FA0E3 		mov	r0, #1000
 6296 36c8 FEFFFFEB 		bl	_tx_thread_sleep
 6297 36cc F9FFFFEA 		b	.L504
 6298              	.LVL499:
 6299              	.L548:
 6300              	.LBE236:
 6301              	.LBE235:
2091:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6302              		.loc 1 2091 0
 6303 36d0 0400A0E3 		mov	r0, #4
 6304              	.LVL500:
 6305 36d4 74159FE5 		ldr	r1, .L557+124
 6306 36d8 FEFFFFEB 		bl	CyU3PDebugPrint
 6307              	.LVL501:
 6308              	.L500:
 6309              	.LBB237:
 6310              	.LBB238:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6311              		.loc 1 1246 0
 6312 36dc 5C159FE5 		ldr	r1, .L557+108
 6313 36e0 0400A0E3 		mov	r0, #4
 6314 36e4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6315              		.loc 1 1247 0
 6316 36e8 FA0FA0E3 		mov	r0, #1000
 6317 36ec FEFFFFEB 		bl	_tx_thread_sleep
 6318 36f0 F9FFFFEA 		b	.L500
 6319              	.LVL502:
 6320              	.L541:
 6321              	.LBE238:
 6322              	.LBE237:
1871:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6323              		.loc 1 1871 0
 6324 36f4 0400A0E3 		mov	r0, #4
 6325              	.LVL503:
 6326 36f8 54159FE5 		ldr	r1, .L557+128
 6327 36fc FEFFFFEB 		bl	CyU3PDebugPrint
 6328              	.LVL504:
 6329              	.L486:
 6330              	.LBB239:
 6331              	.LBB240:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6332              		.loc 1 1246 0
 6333 3700 38159FE5 		ldr	r1, .L557+108
 6334 3704 0400A0E3 		mov	r0, #4
 6335 3708 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6336              		.loc 1 1247 0
 6337 370c FA0FA0E3 		mov	r0, #1000
 6338 3710 FEFFFFEB 		bl	_tx_thread_sleep
 6339 3714 F9FFFFEA 		b	.L486
 6340              	.LVL505:
 6341              	.L540:
 6342              	.LBE240:
 6343              	.LBE239:
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6344              		.loc 1 1857 0
 6345 3718 0400A0E3 		mov	r0, #4
 6346              	.LVL506:
 6347 371c 34159FE5 		ldr	r1, .L557+132
 6348 3720 FEFFFFEB 		bl	CyU3PDebugPrint
 6349              	.LVL507:
 6350              	.L484:
 6351              	.LBB241:
 6352              	.LBB242:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6353              		.loc 1 1246 0
 6354 3724 14159FE5 		ldr	r1, .L557+108
 6355 3728 0400A0E3 		mov	r0, #4
 6356 372c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6357              		.loc 1 1247 0
 6358 3730 FA0FA0E3 		mov	r0, #1000
 6359 3734 FEFFFFEB 		bl	_tx_thread_sleep
 6360 3738 F9FFFFEA 		b	.L484
 6361              	.LVL508:
 6362              	.L539:
 6363              	.LBE242:
 6364              	.LBE241:
1843:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6365              		.loc 1 1843 0
 6366 373c 0400A0E3 		mov	r0, #4
 6367              	.LVL509:
 6368 3740 14159FE5 		ldr	r1, .L557+136
 6369 3744 FEFFFFEB 		bl	CyU3PDebugPrint
 6370              	.LVL510:
 6371              	.L482:
 6372              	.LBB243:
 6373              	.LBB244:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6374              		.loc 1 1246 0
 6375 3748 F0149FE5 		ldr	r1, .L557+108
 6376 374c 0400A0E3 		mov	r0, #4
 6377 3750 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6378              		.loc 1 1247 0
 6379 3754 FA0FA0E3 		mov	r0, #1000
 6380 3758 FEFFFFEB 		bl	_tx_thread_sleep
 6381 375c F9FFFFEA 		b	.L482
 6382              	.LVL511:
 6383              	.L549:
 6384              	.LBE244:
 6385              	.LBE243:
 6386              	.LBE257:
 6387              	.LBE261:
2289:../uvc.c      ****                 prodCount = 0;
 6388              		.loc 1 2289 0
 6389 3760 BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2290:../uvc.c      ****                 consCount = 0;
 6390              		.loc 1 2290 0
 6391 3764 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2291:../uvc.c      ****                 hitFV     = CyFalse;
 6392              		.loc 1 2291 0
 6393 3768 444085E5 		str	r4, [r5, #68]
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6394              		.loc 1 2304 0
 6395 376c 8104D8E5 		ldrb	r0, [r8, #1153]	@ zero_extendqisi2
2286:../uvc.c      ****             	fb=0;
 6396              		.loc 1 2286 0
 6397 3770 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6398              		.loc 1 2304 0
 6399 3774 01E020E2 		eor	lr, r0, #1
 6400 3778 81E4C8E5 		strb	lr, [r8, #1153]
2305:../uvc.c      ****                 if(stiflag){
 6401              		.loc 1 2305 0
 6402 377c 9C3095E5 		ldr	r3, [r5, #156]
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6403              		.loc 1 2306 0
 6404 3780 81C4D7E5 		ldrb	ip, [r7, #1153]	@ zero_extendqisi2
2305:../uvc.c      ****                 if(stiflag){
 6405              		.loc 1 2305 0
 6406 3784 000053E3 		cmp	r3, #0
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6407              		.loc 1 2306 0
 6408 3788 20C08C13 		orrne	ip, ip, #32
2309:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6409              		.loc 1 2309 0
 6410 378c DFC00C02 		andeq	ip, ip, #223
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6411              		.loc 1 2306 0
 6412 3790 81C4C715 		strneb	ip, [r7, #1153]
2309:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6413              		.loc 1 2309 0
 6414 3794 81C4C705 		streqb	ip, [r7, #1153]
2307:../uvc.c      ****                 	stiflag = CyFalse;
 6415              		.loc 1 2307 0
 6416 3798 9C408515 		strne	r4, [r5, #156]
2287:../uvc.c      ****             	pb=0;
 6417              		.loc 1 2287 0
 6418 379c BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2288:../uvc.c      ****             	pbc=0;
 6419              		.loc 1 2288 0
 6420 37a0 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2312:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6421              		.loc 1 2312 0
 6422 37a4 88049FE5 		ldr	r0, .L557+96
 6423 37a8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6424              	.LVL512:
2313:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6425              		.loc 1 2313 0
 6426 37ac 002050E2 		subs	r2, r0, #0
 6427 37b0 3900001A 		bne	.L551
2320:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6428              		.loc 1 2320 0
 6429 37b4 0210A0E1 		mov	r1, r2
 6430 37b8 74049FE5 		ldr	r0, .L557+96
 6431              	.LVL513:
 6432 37bc FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6433              	.LVL514:
2321:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6434              		.loc 1 2321 0
 6435 37c0 002050E2 		subs	r2, r0, #0
 6436 37c4 2B00001A 		bne	.L552
2329:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6437              		.loc 1 2329 0
 6438 37c8 5C049FE5 		ldr	r0, .L557+88
 6439              	.LVL515:
 6440 37cc 0210A0E1 		mov	r1, r2
 6441 37d0 02A0A0E3 		mov	sl, #2
 6442 37d4 0020A0E1 		mov	r2, r0
 6443              	.LVL516:
 6444 37d8 0130A0E1 		mov	r3, r1
 6445 37dc 00A08DE5 		str	sl, [sp, #0]
 6446 37e0 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6447              	.LVL517:
 6448 37e4 7CFFFFEA 		b	.L506
 6449              	.LVL518:
 6450              	.L538:
 6451              	.LBB262:
 6452              	.LBB222:
1830:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6453              		.loc 1 1830 0
 6454 37e8 0400A0E3 		mov	r0, #4
 6455              	.LVL519:
 6456 37ec 6C149FE5 		ldr	r1, .L557+140
 6457 37f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6458              	.LVL520:
 6459              	.L480:
 6460              	.LBB231:
 6461              	.LBB232:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6462              		.loc 1 1246 0
 6463 37f4 44149FE5 		ldr	r1, .L557+108
 6464 37f8 0400A0E3 		mov	r0, #4
 6465 37fc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6466              		.loc 1 1247 0
 6467 3800 FA0FA0E3 		mov	r0, #1000
 6468 3804 FEFFFFEB 		bl	_tx_thread_sleep
 6469 3808 F9FFFFEA 		b	.L480
 6470              	.LVL521:
 6471              	.L537:
 6472              	.LBE232:
 6473              	.LBE231:
1824:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6474              		.loc 1 1824 0
 6475 380c 0400A0E3 		mov	r0, #4
 6476              	.LVL522:
 6477 3810 4C149FE5 		ldr	r1, .L557+144
 6478 3814 FEFFFFEB 		bl	CyU3PDebugPrint
 6479              	.LVL523:
 6480              	.L478:
 6481              	.LBB229:
 6482              	.LBB230:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6483              		.loc 1 1246 0
 6484 3818 20149FE5 		ldr	r1, .L557+108
 6485 381c 0400A0E3 		mov	r0, #4
 6486 3820 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6487              		.loc 1 1247 0
 6488 3824 FA0FA0E3 		mov	r0, #1000
 6489 3828 FEFFFFEB 		bl	_tx_thread_sleep
 6490 382c F9FFFFEA 		b	.L478
 6491              	.LVL524:
 6492              	.L536:
 6493              	.LBE230:
 6494              	.LBE229:
1818:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6495              		.loc 1 1818 0
 6496 3830 0400A0E3 		mov	r0, #4
 6497              	.LVL525:
 6498 3834 2C149FE5 		ldr	r1, .L557+148
 6499 3838 FEFFFFEB 		bl	CyU3PDebugPrint
 6500              	.LVL526:
 6501              	.L476:
 6502              	.LBB227:
 6503              	.LBB228:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6504              		.loc 1 1246 0
 6505 383c FC139FE5 		ldr	r1, .L557+108
 6506 3840 0400A0E3 		mov	r0, #4
 6507 3844 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6508              		.loc 1 1247 0
 6509 3848 FA0FA0E3 		mov	r0, #1000
 6510 384c FEFFFFEB 		bl	_tx_thread_sleep
 6511 3850 F9FFFFEA 		b	.L476
 6512              	.LVL527:
 6513              	.L535:
 6514              	.LBE228:
 6515              	.LBE227:
1809:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6516              		.loc 1 1809 0
 6517 3854 0400A0E3 		mov	r0, #4
 6518              	.LVL528:
 6519 3858 0C149FE5 		ldr	r1, .L557+152
 6520 385c FEFFFFEB 		bl	CyU3PDebugPrint
 6521              	.LVL529:
 6522              	.L474:
 6523              	.LBB225:
 6524              	.LBB226:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6525              		.loc 1 1246 0
 6526 3860 D8139FE5 		ldr	r1, .L557+108
 6527 3864 0400A0E3 		mov	r0, #4
 6528 3868 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6529              		.loc 1 1247 0
 6530 386c FA0FA0E3 		mov	r0, #1000
 6531 3870 FEFFFFEB 		bl	_tx_thread_sleep
 6532 3874 F9FFFFEA 		b	.L474
 6533              	.LVL530:
 6534              	.L552:
 6535              	.LBE226:
 6536              	.LBE225:
 6537              	.LBE222:
 6538              	.LBE262:
2323:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6539              		.loc 1 2323 0
 6540 3878 0400A0E3 		mov	r0, #4
 6541              	.LVL531:
 6542 387c EC139FE5 		ldr	r1, .L557+156
 6543 3880 FEFFFFEB 		bl	CyU3PDebugPrint
 6544              	.LVL532:
 6545              	.L512:
 6546              	.LBB263:
 6547              	.LBB264:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6548              		.loc 1 1246 0
 6549 3884 B4139FE5 		ldr	r1, .L557+108
 6550 3888 0400A0E3 		mov	r0, #4
 6551 388c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6552              		.loc 1 1247 0
 6553 3890 FA0FA0E3 		mov	r0, #1000
 6554 3894 FEFFFFEB 		bl	_tx_thread_sleep
 6555 3898 F9FFFFEA 		b	.L512
 6556              	.LVL533:
 6557              	.L551:
 6558              	.LBE264:
 6559              	.LBE263:
2315:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6560              		.loc 1 2315 0
 6561 389c 0400A0E3 		mov	r0, #4
 6562              	.LVL534:
 6563 38a0 CC139FE5 		ldr	r1, .L557+160
 6564 38a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6565              	.LVL535:
 6566              	.L510:
 6567              	.LBB265:
 6568              	.LBB266:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6569              		.loc 1 1246 0
 6570 38a8 90139FE5 		ldr	r1, .L557+108
 6571 38ac 0400A0E3 		mov	r0, #4
 6572 38b0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6573              		.loc 1 1247 0
 6574 38b4 FA0FA0E3 		mov	r0, #1000
 6575 38b8 FEFFFFEB 		bl	_tx_thread_sleep
 6576 38bc F9FFFFEA 		b	.L510
 6577              	.LVL536:
 6578              	.L545:
 6579              	.LBE266:
 6580              	.LBE265:
 6581              	.LBB267:
 6582              	.LBB258:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6583              		.loc 1 1970 0
 6584 38c0 0400A0E3 		mov	r0, #4
 6585              	.LVL537:
 6586 38c4 AC139FE5 		ldr	r1, .L557+164
 6587 38c8 0820A0E1 		mov	r2, r8
 6588 38cc FEFFFFEB 		bl	CyU3PDebugPrint
 6589              	.L494:
 6590              	.LBB245:
 6591              	.LBB246:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6592              		.loc 1 1246 0
 6593 38d0 68139FE5 		ldr	r1, .L557+108
 6594 38d4 0400A0E3 		mov	r0, #4
 6595 38d8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6596              		.loc 1 1247 0
 6597 38dc FA0FA0E3 		mov	r0, #1000
 6598 38e0 FEFFFFEB 		bl	_tx_thread_sleep
 6599 38e4 F9FFFFEA 		b	.L494
 6600              	.LVL538:
 6601              	.L544:
 6602              	.LBE246:
 6603              	.LBE245:
1949:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6604              		.loc 1 1949 0
 6605 38e8 0400A0E3 		mov	r0, #4
 6606              	.LVL539:
 6607 38ec 58139FE5 		ldr	r1, .L557+120
 6608 38f0 0320A0E1 		mov	r2, r3
 6609 38f4 FEFFFFEB 		bl	CyU3PDebugPrint
 6610              	.LVL540:
 6611              	.L492:
 6612              	.LBB247:
 6613              	.LBB248:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6614              		.loc 1 1246 0
 6615 38f8 40139FE5 		ldr	r1, .L557+108
 6616 38fc 0400A0E3 		mov	r0, #4
 6617 3900 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6618              		.loc 1 1247 0
 6619 3904 FA0FA0E3 		mov	r0, #1000
 6620 3908 FEFFFFEB 		bl	_tx_thread_sleep
 6621 390c F9FFFFEA 		b	.L492
 6622              	.LVL541:
 6623              	.L543:
 6624              	.LBE248:
 6625              	.LBE247:
1904:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6626              		.loc 1 1904 0
 6627 3910 0400A0E3 		mov	r0, #4
 6628 3914 60139FE5 		ldr	r1, .L557+168
 6629 3918 0420A0E1 		mov	r2, r4
 6630 391c FEFFFFEB 		bl	CyU3PDebugPrint
 6631              	.L490:
 6632              	.LBB249:
 6633              	.LBB250:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6634              		.loc 1 1246 0
 6635 3920 18139FE5 		ldr	r1, .L557+108
 6636 3924 0400A0E3 		mov	r0, #4
 6637 3928 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6638              		.loc 1 1247 0
 6639 392c FA0FA0E3 		mov	r0, #1000
 6640 3930 FEFFFFEB 		bl	_tx_thread_sleep
 6641 3934 F9FFFFEA 		b	.L490
 6642              	.LVL542:
 6643              	.L542:
 6644              	.LBE250:
 6645              	.LBE249:
1884:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6646              		.loc 1 1884 0
 6647 3938 0400A0E3 		mov	r0, #4
 6648              	.LVL543:
 6649 393c 3C139FE5 		ldr	r1, .L557+172
 6650 3940 FEFFFFEB 		bl	CyU3PDebugPrint
 6651              	.LVL544:
 6652              	.L488:
 6653              	.LBB251:
 6654              	.LBB252:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6655              		.loc 1 1246 0
 6656 3944 F4129FE5 		ldr	r1, .L557+108
 6657 3948 0400A0E3 		mov	r0, #4
 6658 394c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6659              		.loc 1 1247 0
 6660 3950 FA0FA0E3 		mov	r0, #1000
 6661 3954 FEFFFFEB 		bl	_tx_thread_sleep
 6662 3958 F9FFFFEA 		b	.L488
 6663              	.LVL545:
 6664              	.L547:
 6665              	.LBE252:
 6666              	.LBE251:
2000:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6667              		.loc 1 2000 0
 6668 395c 0400A0E3 		mov	r0, #4
 6669              	.LVL546:
 6670 3960 1C139FE5 		ldr	r1, .L557+176
 6671 3964 FEFFFFEB 		bl	CyU3PDebugPrint
 6672              	.LVL547:
 6673              	.L498:
 6674              	.LBB253:
 6675              	.LBB254:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6676              		.loc 1 1246 0
 6677 3968 D0129FE5 		ldr	r1, .L557+108
 6678 396c 0400A0E3 		mov	r0, #4
 6679 3970 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6680              		.loc 1 1247 0
 6681 3974 FA0FA0E3 		mov	r0, #1000
 6682 3978 FEFFFFEB 		bl	_tx_thread_sleep
 6683 397c F9FFFFEA 		b	.L498
 6684              	.LVL548:
 6685              	.L546:
 6686              	.LBE254:
 6687              	.LBE253:
1977:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6688              		.loc 1 1977 0
 6689 3980 040080E2 		add	r0, r0, #4
 6690 3984 FC129FE5 		ldr	r1, .L557+180
 6691 3988 FEFFFFEB 		bl	CyU3PDebugPrint
 6692              	.LVL549:
 6693              	.L496:
 6694              	.LBB255:
 6695              	.LBB256:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6696              		.loc 1 1246 0
 6697 398c AC129FE5 		ldr	r1, .L557+108
 6698 3990 0400A0E3 		mov	r0, #4
 6699 3994 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6700              		.loc 1 1247 0
 6701 3998 FA0FA0E3 		mov	r0, #1000
 6702 399c FEFFFFEB 		bl	_tx_thread_sleep
 6703 39a0 F9FFFFEA 		b	.L496
 6704              	.LVL550:
 6705              	.L550:
 6706              	.LBE256:
 6707              	.LBE255:
 6708              	.LBE258:
 6709              	.LBE267:
2352:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6710              		.loc 1 2352 0
 6711 39a4 88029FE5 		ldr	r0, .L557+96
 6712 39a8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6713              	.LVL551:
2353:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6714              		.loc 1 2353 0
 6715 39ac 000050E3 		cmp	r0, #0
 6716 39b0 0200001A 		bne	.L530
2359:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6717              		.loc 1 2359 0
 6718 39b4 8300A0E3 		mov	r0, #131
 6719              	.LVL552:
 6720 39b8 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6721 39bc 38FFFFEA 		b	.L514
 6722              	.L530:
 6723              	.LBB268:
 6724              	.LBB269:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6725              		.loc 1 1246 0
 6726 39c0 78129FE5 		ldr	r1, .L557+108
 6727 39c4 0400A0E3 		mov	r0, #4
 6728 39c8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6729              		.loc 1 1247 0
 6730 39cc FA0FA0E3 		mov	r0, #1000
 6731 39d0 FEFFFFEB 		bl	_tx_thread_sleep
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6732              		.loc 1 1246 0
 6733 39d4 64129FE5 		ldr	r1, .L557+108
 6734 39d8 0400A0E3 		mov	r0, #4
 6735 39dc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6736              		.loc 1 1247 0
 6737 39e0 FA0FA0E3 		mov	r0, #1000
 6738 39e4 FEFFFFEB 		bl	_tx_thread_sleep
 6739 39e8 F4FFFFEA 		b	.L530
 6740              	.L513:
 6741              	.LBE269:
 6742              	.LBE268:
2367:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6743              		.loc 1 2367 0
 6744 39ec 00C0E0E3 		mvn	ip, #0
 6745 39f0 0110A0E3 		mov	r1, #1
 6746 39f4 0220A0E3 		mov	r2, #2
 6747 39f8 B4308DE2 		add	r3, sp, #180
 6748 39fc DC019FE5 		ldr	r0, .L557+12
 6749 3a00 00C08DE5 		str	ip, [sp, #0]
 6750 3a04 FEFFFFEB 		bl	_txe_event_flags_get
2371:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6751              		.loc 1 2371 0
 6752 3a08 0420A0E1 		mov	r2, r4
 6753 3a0c 20029FE5 		ldr	r0, .L557+96
 6754 3a10 0410A0E1 		mov	r1, r4
 6755 3a14 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6756              	.LVL553:
2372:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6757              		.loc 1 2372 0
 6758 3a18 002050E2 		subs	r2, r0, #0
 6759 3a1c 2F00001A 		bne	.L553
2380:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6760              		.loc 1 2380 0
 6761 3a20 383095E5 		ldr	r3, [r5, #56]
 6762 3a24 000053E3 		cmp	r3, #0
 6763 3a28 5800001A 		bne	.L519
2383:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6764              		.loc 1 2383 0
 6765 3a2c 3010A0E3 		mov	r1, #48
 6766 3a30 0120A0E3 		mov	r2, #1
 6767 3a34 823083E2 		add	r3, r3, #130
 6768 3a38 2100A0E3 		mov	r0, #33
 6769              	.LVL554:
 6770 3a3c FEFFFFEB 		bl	SensorSetIrisControl
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
 6771              		.loc 1 2384 0
 6772 3a40 7D0FA0E3 		mov	r0, #500
 6773 3a44 FEFFFFEB 		bl	_tx_thread_sleep
2385:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6774              		.loc 1 2385 0
 6775 3a48 3010A0E3 		mov	r1, #48
 6776 3a4c 0220A0E3 		mov	r2, #2
 6777 3a50 5230A0E3 		mov	r3, #82
 6778 3a54 2500A0E3 		mov	r0, #37
 6779 3a58 FEFFFFEB 		bl	SensorSetIrisControl
2386:../uvc.c      ****                     CyU3PThreadSleep(500);
 6780              		.loc 1 2386 0
 6781 3a5c 7D0FA0E3 		mov	r0, #500
 6782 3a60 FEFFFFEB 		bl	_tx_thread_sleep
2387:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
 6783              		.loc 1 2387 0
 6784 3a64 3010A0E3 		mov	r1, #48
 6785 3a68 0A20A0E3 		mov	r2, #10
 6786 3a6c 8230A0E3 		mov	r3, #130
 6787 3a70 2300A0E3 		mov	r0, #35
 6788 3a74 FEFFFFEB 		bl	SensorSetIrisControl
2388:../uvc.c      ****                    	CyU3PThreadSleep(300);
 6789              		.loc 1 2388 0
 6790 3a78 4B0FA0E3 		mov	r0, #300
 6791 3a7c FEFFFFEB 		bl	_tx_thread_sleep
2389:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6792              		.loc 1 2389 0
 6793 3a80 3010A0E3 		mov	r1, #48
 6794 3a84 0420A0E1 		mov	r2, r4
 6795 3a88 8230A0E3 		mov	r3, #130
 6796 3a8c 2100A0E3 		mov	r0, #33
 6797 3a90 FEFFFFEB 		bl	SensorSetIrisControl
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
 6798              		.loc 1 2390 0
 6799 3a94 7D0FA0E3 		mov	r0, #500
 6800 3a98 FEFFFFEB 		bl	_tx_thread_sleep
2391:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6801              		.loc 1 2391 0
 6802 3a9c 5230A0E3 		mov	r3, #82
 6803 3aa0 3010A0E3 		mov	r1, #48
 6804 3aa4 0420A0E1 		mov	r2, r4
 6805 3aa8 2500A0E3 		mov	r0, #37
 6806 3aac FEFFFFEB 		bl	SensorSetIrisControl
2392:../uvc.c      ****                     CyU3PThreadSleep(500);
 6807              		.loc 1 2392 0
 6808 3ab0 7D0FA0E3 		mov	r0, #500
 6809 3ab4 FEFFFFEB 		bl	_tx_thread_sleep
 6810              	.LVL555:
 6811              	.LBB270:
 6812              	.LBB272:
2141:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6813              		.loc 1 2141 0
 6814 3ab8 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6815 3abc 030053E3 		cmp	r3, #3
 6816 3ac0 2B00000A 		beq	.L554
2146:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6817              		.loc 1 2146 0
 6818 3ac4 020053E3 		cmp	r3, #2
 6819 3ac8 0D00000A 		beq	.L555
 6820              	.LVL556:
 6821              	.L522:
 6822              	.LBE272:
 6823              	.LBE270:
2394:../uvc.c      ****                     gpif_initialized = CyTrue;
 6824              		.loc 1 2394 0
 6825 3acc 0110A0E3 		mov	r1, #1
2395:../uvc.c      ****                     CyU3PThreadSleep(200);
 6826              		.loc 1 2395 0
 6827 3ad0 C800A0E3 		mov	r0, #200
2394:../uvc.c      ****                     gpif_initialized = CyTrue;
 6828              		.loc 1 2394 0
 6829 3ad4 381086E5 		str	r1, [r6, #56]
2395:../uvc.c      ****                     CyU3PThreadSleep(200);
 6830              		.loc 1 2395 0
 6831 3ad8 FEFFFFEB 		bl	_tx_thread_sleep
 6832 3adc BEFEFFEA 		b	.L506
 6833              	.LVL557:
 6834              	.L553:
2375:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6835              		.loc 1 2375 0
 6836 3ae0 0400A0E3 		mov	r0, #4
 6837              	.LVL558:
 6838 3ae4 A0119FE5 		ldr	r1, .L557+184
 6839 3ae8 FEFFFFEB 		bl	CyU3PDebugPrint
 6840              	.LVL559:
 6841              	.L518:
 6842              	.LBB278:
 6843              	.LBB279:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6844              		.loc 1 1246 0
 6845 3aec 4C119FE5 		ldr	r1, .L557+108
 6846 3af0 0400A0E3 		mov	r0, #4
 6847 3af4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6848              		.loc 1 1247 0
 6849 3af8 FA0FA0E3 		mov	r0, #1000
 6850 3afc FEFFFFEB 		bl	_tx_thread_sleep
 6851 3b00 F9FFFFEA 		b	.L518
 6852              	.LVL560:
 6853              	.L555:
 6854              	.LBE279:
 6855              	.LBE278:
 6856              	.LBB280:
 6857              	.LBB271:
2148:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6858              		.loc 1 2148 0
 6859 3b04 84119FE5 		ldr	r1, .L557+188
 6860 3b08 0100A0E3 		mov	r0, #1
 6861 3b0c FEFFFFEB 		bl	CyU3PDebugPrint
2149:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6862              		.loc 1 2149 0
 6863 3b10 7C019FE5 		ldr	r0, .L557+192
 6864 3b14 FEFFFFEB 		bl	CyU3PGpifLoad
 6865 3b18 0020A0E1 		mov	r2, r0
 6866              	.LVL561:
 6867              	.L521:
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6868              		.loc 1 2151 0
 6869 3b1c 000052E3 		cmp	r2, #0
 6870 3b20 2200001A 		bne	.L556
2159:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6871              		.loc 1 2159 0
 6872 3b24 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6873 3b28 030053E3 		cmp	r3, #3
 6874 3b2c 0100000A 		beq	.L531
2163:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6875              		.loc 1 2163 0
 6876 3b30 020053E3 		cmp	r3, #2
 6877 3b34 E4FFFF1A 		bne	.L522
 6878              	.L531:
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6879              		.loc 1 2165 0
 6880 3b38 0200A0E1 		mov	r0, r2
 6881              	.LVL562:
 6882 3b3c 0210A0E1 		mov	r1, r2
 6883 3b40 FEFFFFEB 		bl	CyU3PGpifSMStart
 6884              	.LVL563:
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6885              		.loc 1 2167 0
 6886 3b44 000050E3 		cmp	r0, #0
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6887              		.loc 1 2165 0
 6888 3b48 0020A0E1 		mov	r2, r0
 6889              	.LVL564:
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6890              		.loc 1 2167 0
 6891 3b4c DEFFFF0A 		beq	.L522
2170:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6892              		.loc 1 2170 0
 6893 3b50 0400A0E3 		mov	r0, #4
 6894              	.LVL565:
 6895 3b54 3C119FE5 		ldr	r1, .L557+196
 6896 3b58 FEFFFFEB 		bl	CyU3PDebugPrint
 6897              	.LVL566:
 6898              	.L527:
 6899              	.LBB273:
 6900              	.LBB274:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6901              		.loc 1 1246 0
 6902 3b5c DC109FE5 		ldr	r1, .L557+108
 6903 3b60 0400A0E3 		mov	r0, #4
 6904 3b64 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6905              		.loc 1 1247 0
 6906 3b68 FA0FA0E3 		mov	r0, #1000
 6907 3b6c FEFFFFEB 		bl	_tx_thread_sleep
 6908 3b70 F9FFFFEA 		b	.L527
 6909              	.LVL567:
 6910              	.L554:
 6911              	.LBE274:
 6912              	.LBE273:
2143:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6913              		.loc 1 2143 0
 6914 3b74 20119FE5 		ldr	r1, .L557+200
 6915 3b78 0100A0E3 		mov	r0, #1
 6916 3b7c FEFFFFEB 		bl	CyU3PDebugPrint
2144:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6917              		.loc 1 2144 0
 6918 3b80 18019FE5 		ldr	r0, .L557+204
 6919 3b84 FEFFFFEB 		bl	CyU3PGpifLoad
 6920 3b88 0020A0E1 		mov	r2, r0
 6921              	.LVL568:
 6922 3b8c E2FFFFEA 		b	.L521
 6923              	.LVL569:
 6924              	.L519:
 6925              	.LBE271:
 6926              	.LBE280:
2402:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6927              		.loc 1 2402 0
 6928 3b90 94009FE5 		ldr	r0, .L557+88
 6929              	.LVL570:
 6930 3b94 02E0A0E3 		mov	lr, #2
 6931 3b98 0410A0E1 		mov	r1, r4
 6932 3b9c 0020A0E1 		mov	r2, r0
 6933              	.LVL571:
 6934 3ba0 0430A0E1 		mov	r3, r4
 6935 3ba4 00E08DE5 		str	lr, [sp, #0]
 6936 3ba8 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6937 3bac 8AFEFFEA 		b	.L506
 6938              	.LVL572:
 6939              	.L556:
 6940              	.LBB281:
 6941              	.LBB277:
2154:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6942              		.loc 1 2154 0
 6943 3bb0 0400A0E3 		mov	r0, #4
 6944              	.LVL573:
 6945 3bb4 E8109FE5 		ldr	r1, .L557+208
 6946 3bb8 FEFFFFEB 		bl	CyU3PDebugPrint
 6947              	.LVL574:
 6948              	.L524:
 6949              	.LBB275:
 6950              	.LBB276:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6951              		.loc 1 1246 0
 6952 3bbc 7C109FE5 		ldr	r1, .L557+108
 6953 3bc0 0400A0E3 		mov	r0, #4
 6954 3bc4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6955              		.loc 1 1247 0
 6956 3bc8 FA0FA0E3 		mov	r0, #1000
 6957 3bcc FEFFFFEB 		bl	_tx_thread_sleep
 6958 3bd0 F9FFFFEA 		b	.L524
 6959              	.L558:
 6960              		.align	2
 6961              	.L557:
 6962 3bd4 44060000 		.word	.LC35
 6963 3bd8 00C20100 		.word	115200
 6964 3bdc A0860100 		.word	100000
 6965 3be0 00000000 		.word	.LANCHOR0
 6966 3be4 00000000 		.word	CyFxGpifCB
 6967 3be8 00000000 		.word	CyFxUVCApplnUSBSetupCB
 6968 3bec 00000000 		.word	CyFxUVCApplnUSBEventCB
 6969 3bf0 00000000 		.word	CyFxUSBDeviceDscr
 6970 3bf4 00000000 		.word	CyFxUSBDeviceDscrSS
 6971 3bf8 00000000 		.word	CyFxUSBDeviceQualDscr
 6972 3bfc 00000000 		.word	CyFxUSBBOSDscr
 6973 3c00 00000000 		.word	CyFxUSBHSConfigDscr
 6974 3c04 00000000 		.word	CyFxUSBFSConfigDscr
 6975 3c08 00000000 		.word	CyFxUSBSSConfigDscr
 6976 3c0c 00000000 		.word	CyFxUSBStringLangIDDscr
 6977 3c10 00000000 		.word	CyFxUSBManufactureDscr
 6978 3c14 00000000 		.word	CyFxUSBProductDscr
 6979 3c18 013F0000 		.word	16129
 6980 3c1c 02030000 		.word	770
 6981 3c20 00000000 		.word	glChHandleInterStat
 6982 3c24 00000000 		.word	glInterStaBuffer
 6983 3c28 03030000 		.word	771
 6984 3c2c 01010000 		.word	257
 6985 3c30 00000000 		.word	CyFxUvcApplnDmaCallback
 6986 3c34 00000000 		.word	glChHandleUVCStream
 6987 3c38 00000000 		.word	.LANCHOR1
 6988 3c3c 64060000 		.word	.LC36
 6989 3c40 D4010000 		.word	.LC12
 6990 3c44 80060000 		.word	.LC37
 6991 3c48 9C060000 		.word	.LC38
 6992 3c4c 6C080000 		.word	.LC48
 6993 3c50 48090000 		.word	.LC52
 6994 3c54 D4070000 		.word	.LC45
 6995 3c58 A0070000 		.word	.LC44
 6996 3c5c 6C070000 		.word	.LC43
 6997 3c60 40070000 		.word	.LC42
 6998 3c64 14070000 		.word	.LC41
 6999 3c68 EC060000 		.word	.LC40
 7000 3c6c C8060000 		.word	.LC39
 7001 3c70 9C090000 		.word	.LC54
 7002 3c74 70090000 		.word	.LC53
 7003 3c78 A0080000 		.word	.LC49
 7004 3c7c 3C080000 		.word	.LC47
 7005 3c80 0C080000 		.word	.LC46
 7006 3c84 18090000 		.word	.LC51
 7007 3c88 E0080000 		.word	.LC50
 7008 3c8c D0090000 		.word	.LC55
 7009 3c90 140A0000 		.word	.LC57
 7010 3c94 2C000000 		.word	.LANCHOR2+44
 7011 3c98 5C0A0000 		.word	.LC59
 7012 3c9c 040A0000 		.word	.LC56
 7013 3ca0 10000000 		.word	.LANCHOR2+16
 7014 3ca4 240A0000 		.word	.LC58
 7015              	.LBE276:
 7016              	.LBE275:
 7017              	.LBE277:
 7018              	.LBE281:
 7019              		.cfi_endproc
 7020              	.LFE18:
 7022              		.align	2
 7023              		.global	CyFxUVCApplnI2CInit
 7025              	CyFxUVCApplnI2CInit:
 7026              	.LFB14:
1693:../uvc.c      **** {
 7027              		.loc 1 1693 0
 7028              		.cfi_startproc
 7029              		@ args = 0, pretend = 0, frame = 16
 7030              		@ frame_needed = 0, uses_anonymous_args = 0
 7031 3ca8 04E02DE5 		str	lr, [sp, #-4]!
 7032              	.LCFI25:
 7033              		.cfi_def_cfa_offset 4
 7034 3cac 14D04DE2 		sub	sp, sp, #20
 7035              	.LCFI26:
 7036              		.cfi_def_cfa_offset 24
1697:../uvc.c      ****     status = CyU3PI2cInit ();
 7037              		.loc 1 1697 0
 7038              		.cfi_offset 14, -4
 7039 3cb0 FEFFFFEB 		bl	CyU3PI2cInit
 7040              	.LVL575:
1698:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7041              		.loc 1 1698 0
 7042 3cb4 002050E2 		subs	r2, r0, #0
 7043 3cb8 0B00001A 		bne	.L564
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7044              		.loc 1 1705 0
 7045 3cbc 70C09FE5 		ldr	ip, .L566
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7046              		.loc 1 1707 0
 7047 3cc0 0030E0E3 		mvn	r3, #0
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7048              		.loc 1 1710 0
 7049 3cc4 0D00A0E1 		mov	r0, sp
 7050              	.LVL576:
 7051 3cc8 0210A0E1 		mov	r1, r2
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7052              		.loc 1 1705 0
 7053 3ccc 00C08DE5 		str	ip, [sp, #0]
1706:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7054              		.loc 1 1706 0
 7055 3cd0 0C008DE9 		stmib	sp, {r2, r3}	@ phole stm
1708:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7056              		.loc 1 1708 0
 7057 3cd4 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7058              		.loc 1 1710 0
 7059 3cd8 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7060              	.LVL577:
1711:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7061              		.loc 1 1711 0
 7062 3cdc 000050E3 		cmp	r0, #0
 7063 3ce0 0A00001A 		bne	.L565
1716:../uvc.c      **** }
 7064              		.loc 1 1716 0
 7065 3ce4 14D08DE2 		add	sp, sp, #20
 7066 3ce8 04F09DE4 		ldmfd	sp!, {pc}
 7067              	.L564:
1700:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7068              		.loc 1 1700 0
 7069 3cec 0400A0E3 		mov	r0, #4
 7070              	.LVL578:
 7071 3cf0 40109FE5 		ldr	r1, .L566+4
 7072 3cf4 FEFFFFEB 		bl	CyU3PDebugPrint
 7073              	.LVL579:
 7074              	.L561:
 7075              	.LBB286:
 7076              	.LBB287:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7077              		.loc 1 1246 0
 7078 3cf8 3C109FE5 		ldr	r1, .L566+8
 7079 3cfc 0400A0E3 		mov	r0, #4
 7080 3d00 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 7081              		.loc 1 1247 0
 7082 3d04 FA0FA0E3 		mov	r0, #1000
 7083 3d08 FEFFFFEB 		bl	_tx_thread_sleep
 7084 3d0c F9FFFFEA 		b	.L561
 7085              	.LVL580:
 7086              	.L565:
 7087              	.LBE287:
 7088              	.LBE286:
1713:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7089              		.loc 1 1713 0
 7090 3d10 0400A0E3 		mov	r0, #4
 7091              	.LVL581:
 7092 3d14 24109FE5 		ldr	r1, .L566+12
 7093 3d18 FEFFFFEB 		bl	CyU3PDebugPrint
 7094              	.L563:
 7095              	.LBB288:
 7096              	.LBB289:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7097              		.loc 1 1246 0
 7098 3d1c 18109FE5 		ldr	r1, .L566+8
 7099 3d20 0400A0E3 		mov	r0, #4
 7100 3d24 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 7101              		.loc 1 1247 0
 7102 3d28 FA0FA0E3 		mov	r0, #1000
 7103 3d2c FEFFFFEB 		bl	_tx_thread_sleep
 7104 3d30 F9FFFFEA 		b	.L563
 7105              	.L567:
 7106              		.align	2
 7107              	.L566:
 7108 3d34 A0860100 		.word	100000
 7109 3d38 64060000 		.word	.LC36
 7110 3d3c D4010000 		.word	.LC12
 7111 3d40 80060000 		.word	.LC37
 7112              	.LBE289:
 7113              	.LBE288:
 7114              		.cfi_endproc
 7115              	.LFE14:
 7117              		.align	2
 7118              		.global	CyFxApplicationDefine
 7120              	CyFxApplicationDefine:
 7121              	.LFB26:
3629:../uvc.c      **** }
3630:../uvc.c      **** 
3631:../uvc.c      **** 
3632:../uvc.c      **** /*
3633:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3634:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3635:../uvc.c      ****  */
3636:../uvc.c      **** void
3637:../uvc.c      **** CyFxApplicationDefine (
3638:../uvc.c      ****         void)
3639:../uvc.c      **** {
 7122              		.loc 1 3639 0
 7123              		.cfi_startproc
 7124              		@ args = 0, pretend = 0, frame = 40
 7125              		@ frame_needed = 0, uses_anonymous_args = 0
 7126              	.LVL582:
 7127 3d44 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7128              	.LCFI27:
 7129              		.cfi_def_cfa_offset 36
3640:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3641:../uvc.c      ****     uint32_t retThrdCreate;
3642:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3643:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3644:../uvc.c      **** 
3645:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3646:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7130              		.loc 1 3646 0
 7131 3d48 010AA0E3 		mov	r0, #4096
3639:../uvc.c      **** {
 7132              		.loc 1 3639 0
 7133 3d4c 4CD04DE2 		sub	sp, sp, #76
 7134              	.LCFI28:
 7135              		.cfi_def_cfa_offset 112
 7136              		.loc 1 3646 0
 7137              		.cfi_offset 14, -4
 7138              		.cfi_offset 11, -8
 7139              		.cfi_offset 10, -12
 7140              		.cfi_offset 9, -16
 7141              		.cfi_offset 8, -20
 7142              		.cfi_offset 7, -24
 7143              		.cfi_offset 6, -28
 7144              		.cfi_offset 5, -32
 7145              		.cfi_offset 4, -36
 7146 3d50 FEFFFFEB 		bl	CyU3PMemAlloc
 7147 3d54 00A0A0E1 		mov	sl, r0
 7148              	.LVL583:
3647:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7149              		.loc 1 3647 0
 7150 3d58 010AA0E3 		mov	r0, #4096
 7151              	.LVL584:
 7152 3d5c FEFFFFEB 		bl	CyU3PMemAlloc
 7153 3d60 00B0A0E1 		mov	fp, r0
 7154              	.LVL585:
3648:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7155              		.loc 1 3648 0
 7156 3d64 010AA0E3 		mov	r0, #4096
 7157              	.LVL586:
 7158 3d68 FEFFFFEB 		bl	CyU3PMemAlloc
3649:../uvc.c      **** 
3650:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7159              		.loc 1 3650 0
 7160 3d6c 00005AE3 		cmp	sl, #0
 7161 3d70 00005B13 		cmpne	fp, #0
 7162 3d74 0090A013 		movne	r9, #0
 7163 3d78 0190A003 		moveq	r9, #1
3648:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7164              		.loc 1 3648 0
 7165 3d7c 24008DE5 		str	r0, [sp, #36]
 7166              	.LVL587:
 7167              		.loc 1 3650 0
 7168 3d80 0000001A 		bne	.L572
 7169              	.LVL588:
 7170              	.L569:
 7171              	.L571:
 7172 3d84 FEFFFFEA 		b	.L571
 7173              	.L572:
 7174              		.loc 1 3650 0 is_stmt 0 discriminator 1
 7175 3d88 000050E3 		cmp	r0, #0
 7176 3d8c FCFFFF0A 		beq	.L569
3651:../uvc.c      ****         goto fatalErrorHandler;
3652:../uvc.c      **** 
3653:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3654:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7177              		.loc 1 3654 0 is_stmt 1
 7178 3d90 28408DE2 		add	r4, sp, #40
 7179 3d94 0400A0E1 		mov	r0, r4
 7180 3d98 4010A0E3 		mov	r1, #64
 7181 3d9c 18219FE5 		ldr	r2, .L573
 7182 3da0 FEFFFFEB 		bl	cmdbufCreate
 7183 3da4 0450A0E1 		mov	r5, r4
 7184 3da8 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7185 3dac 0C719FE5 		ldr	r7, .L573+4
3655:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7186              		.loc 1 3655 0
 7187 3db0 0C819FE5 		ldr	r8, .L573+8
3654:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7188              		.loc 1 3654 0
 7189 3db4 07C0A0E1 		mov	ip, r7
 7190 3db8 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7191 3dbc 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3656:../uvc.c      **** 
3657:../uvc.c      **** 	/****** initialize command descriptor ***********/
3658:../uvc.c      **** 	cmdquInit(cmdQuptr);
3659:../uvc.c      **** 	cmdquInit(statQuptr);
3660:../uvc.c      **** 
3661:../uvc.c      ****     /* Create the UVC application thread. */
3662:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7192              		.loc 1 3662 0
 7193 3dc0 0860A0E3 		mov	r6, #8
3654:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7194              		.loc 1 3654 0
 7195 3dc4 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3655:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7196              		.loc 1 3655 0
 7197 3dc8 F8209FE5 		ldr	r2, .L573+12
 7198 3dcc 0400A0E1 		mov	r0, r4
 7199 3dd0 2010A0E3 		mov	r1, #32
 7200 3dd4 FEFFFFEB 		bl	cmdbufCreate
 7201 3dd8 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7202 3ddc 08C0A0E1 		mov	ip, r8
 7203 3de0 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7204 3de4 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7205              		.loc 1 3662 0
 7206 3de8 0140A0E3 		mov	r4, #1
3655:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7207              		.loc 1 3655 0
 7208 3dec 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3658:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7209              		.loc 1 3658 0
 7210 3df0 0700A0E1 		mov	r0, r7
 7211 3df4 FEFFFFEB 		bl	cmdquInit
3659:../uvc.c      **** 	cmdquInit(statQuptr);
 7212              		.loc 1 3659 0
 7213 3df8 0800A0E1 		mov	r0, r8
 7214 3dfc FEFFFFEB 		bl	cmdquInit
 7215              		.loc 1 3662 0
 7216 3e00 A850A0E3 		mov	r5, #168
 7217 3e04 01CAA0E3 		mov	ip, #4096
 7218 3e08 BC009FE5 		ldr	r0, .L573+16
 7219 3e0c BC109FE5 		ldr	r1, .L573+20
 7220 3e10 BC209FE5 		ldr	r2, .L573+24
 7221 3e14 0930A0E1 		mov	r3, r9
 7222 3e18 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7223 3e1c 08608DE5 		str	r6, [sp, #8]
 7224 3e20 0C608DE5 		str	r6, [sp, #12]
 7225 3e24 10908DE5 		str	r9, [sp, #16]
 7226 3e28 14408DE5 		str	r4, [sp, #20]
 7227 3e2c 18508DE5 		str	r5, [sp, #24]
 7228 3e30 FEFFFFEB 		bl	_txe_thread_create
 7229              	.LVL589:
3663:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3664:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3665:../uvc.c      ****             0,                                          /* No input parameter to thread */
3666:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3667:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3668:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3669:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3670:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3671:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3672:../uvc.c      ****             );
3673:../uvc.c      ****     if (retThrdCreate != 0)
 7230              		.loc 1 3673 0
 7231 3e34 00C050E2 		subs	ip, r0, #0
 7232 3e38 D1FFFF1A 		bne	.L569
3674:../uvc.c      ****     {
3675:../uvc.c      ****         goto fatalErrorHandler;
3676:../uvc.c      ****     }
3677:../uvc.c      **** 
3678:../uvc.c      ****     /* Create the control request handling thread. */
3679:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7233              		.loc 1 3679 0
 7234 3e3c 0C30A0E1 		mov	r3, ip
 7235 3e40 027BA0E3 		mov	r7, #2048
 7236 3e44 8C009FE5 		ldr	r0, .L573+28
 7237              	.LVL590:
 7238 3e48 8C109FE5 		ldr	r1, .L573+32
 7239 3e4c 8C209FE5 		ldr	r2, .L573+36
 7240 3e50 10C08DE5 		str	ip, [sp, #16]
 7241 3e54 00B08DE5 		str	fp, [sp, #0]
 7242 3e58 04708DE5 		str	r7, [sp, #4]
 7243 3e5c 08608DE5 		str	r6, [sp, #8]
 7244 3e60 0C608DE5 		str	r6, [sp, #12]
 7245 3e64 14408DE5 		str	r4, [sp, #20]
 7246 3e68 18508DE5 		str	r5, [sp, #24]
 7247 3e6c FEFFFFEB 		bl	_txe_thread_create
 7248              	.LVL591:
3680:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3681:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3682:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3683:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3684:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3685:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3686:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3687:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3688:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3689:../uvc.c      ****             );
3690:../uvc.c      ****     if (retThrdCreate != 0)
 7249              		.loc 1 3690 0
 7250 3e70 00C050E2 		subs	ip, r0, #0
 7251 3e74 C2FFFF1A 		bne	.L569
3691:../uvc.c      ****     {
3692:../uvc.c      ****         goto fatalErrorHandler;
3693:../uvc.c      ****     }
3694:../uvc.c      **** #if 1
3695:../uvc.c      ****     /* Create the I2C control command handling thread. */
3696:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7252              		.loc 1 3696 0
 7253 3e78 24E09DE5 		ldr	lr, [sp, #36]
 7254 3e7c 60009FE5 		ldr	r0, .L573+40
 7255              	.LVL592:
 7256 3e80 60109FE5 		ldr	r1, .L573+44
 7257 3e84 60209FE5 		ldr	r2, .L573+48
 7258 3e88 0C30A0E1 		mov	r3, ip
 7259 3e8c 00E08DE5 		str	lr, [sp, #0]
 7260 3e90 04708DE5 		str	r7, [sp, #4]
 7261 3e94 08608DE5 		str	r6, [sp, #8]
 7262 3e98 0C608DE5 		str	r6, [sp, #12]
 7263 3e9c 10C08DE5 		str	ip, [sp, #16]
 7264 3ea0 14408DE5 		str	r4, [sp, #20]
 7265 3ea4 18508DE5 		str	r5, [sp, #24]
 7266 3ea8 FEFFFFEB 		bl	_txe_thread_create
 7267              	.LVL593:
3697:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3698:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3699:../uvc.c      ****             0,                                          /* No input parameter to thread */
3700:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3701:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3702:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3703:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3704:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3705:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3706:../uvc.c      ****             );
3707:../uvc.c      ****     if (retThrdCreate != 0)
 7268              		.loc 1 3707 0
 7269 3eac 000050E3 		cmp	r0, #0
 7270 3eb0 B3FFFF1A 		bne	.L569
3708:../uvc.c      ****     {
3709:../uvc.c      ****         goto fatalErrorHandler;
3710:../uvc.c      ****     }
3711:../uvc.c      **** #endif
3712:../uvc.c      **** 
3713:../uvc.c      ****     return;
3714:../uvc.c      **** 
3715:../uvc.c      **** fatalErrorHandler:
3716:../uvc.c      ****     /* Add custom recovery or debug actions here */
3717:../uvc.c      ****     /* Loop indefinitely */
3718:../uvc.c      ****     while (1);
3719:../uvc.c      **** }
 7271              		.loc 1 3719 0
 7272 3eb4 4CD08DE2 		add	sp, sp, #76
 7273 3eb8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7274              	.L574:
 7275              		.align	2
 7276              	.L573:
 7277 3ebc 00000000 		.word	cmdQuMux
 7278 3ec0 00000000 		.word	cmdQu
 7279 3ec4 00000000 		.word	statQu
 7280 3ec8 00000000 		.word	staQuMux
 7281 3ecc A0000000 		.word	.LANCHOR0+160
 7282 3ed0 940A0000 		.word	.LC60
 7283 3ed4 00000000 		.word	UVCAppThread_Entry
 7284 3ed8 48010000 		.word	.LANCHOR0+328
 7285 3edc A80A0000 		.word	.LC61
 7286 3ee0 00000000 		.word	UVCAppEP0Thread_Entry
 7287 3ee4 F0010000 		.word	.LANCHOR0+496
 7288 3ee8 C00A0000 		.word	.LC62
 7289 3eec 00000000 		.word	I2cAppThread_Entry
 7290              		.cfi_endproc
 7291              	.LFE26:
 7293              		.align	2
 7294              		.global	main
 7296              	main:
 7297              	.LFB27:
3720:../uvc.c      **** 
3721:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3722:../uvc.c      ****  * the ThreadX RTOS here.
3723:../uvc.c      ****  */
3724:../uvc.c      **** int
3725:../uvc.c      **** main (
3726:../uvc.c      ****         void)
3727:../uvc.c      **** {
 7298              		.loc 1 3727 0
 7299              		.cfi_startproc
 7300              		@ args = 0, pretend = 0, frame = 56
 7301              		@ frame_needed = 0, uses_anonymous_args = 0
 7302 3ef0 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7303              	.LCFI29:
 7304              		.cfi_def_cfa_offset 12
3728:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3729:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3730:../uvc.c      **** 
3731:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3732:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3733:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3734:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3735:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3736:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7305              		.loc 1 3736 0
 7306 3ef4 0010A0E3 		mov	r1, #0
3727:../uvc.c      **** {
 7307              		.loc 1 3727 0
 7308 3ef8 3CD04DE2 		sub	sp, sp, #60
 7309              	.LCFI30:
 7310              		.cfi_def_cfa_offset 72
3733:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7311              		.loc 1 3733 0
 7312 3efc 0220A0E3 		mov	r2, #2
3737:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7313              		.loc 1 3737 0
 7314 3f00 033081E2 		add	r3, r1, #3
3732:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7315              		.loc 1 3732 0
 7316 3f04 0150A0E3 		mov	r5, #1
 7317              		.cfi_offset 14, -4
 7318              		.cfi_offset 5, -8
 7319              		.cfi_offset 4, -12
3738:../uvc.c      **** 
3739:../uvc.c      ****     /* Initialize the device */
3740:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7320              		.loc 1 3740 0
 7321 3f08 28008DE2 		add	r0, sp, #40
3732:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7322              		.loc 1 3732 0
 7323 3f0c 28508DE5 		str	r5, [sp, #40]
3733:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7324              		.loc 1 3733 0
 7325 3f10 2C20CDE5 		strb	r2, [sp, #44]
3734:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7326              		.loc 1 3734 0
 7327 3f14 2D20CDE5 		strb	r2, [sp, #45]
3735:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7328              		.loc 1 3735 0
 7329 3f18 2E20CDE5 		strb	r2, [sp, #46]
3736:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7330              		.loc 1 3736 0
 7331 3f1c 30108DE5 		str	r1, [sp, #48]
3737:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7332              		.loc 1 3737 0
 7333 3f20 3430CDE5 		strb	r3, [sp, #52]
 7334              		.loc 1 3740 0
 7335 3f24 FEFFFFEB 		bl	CyU3PDeviceInit
 7336              	.LVL594:
3741:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7337              		.loc 1 3741 0
 7338 3f28 004050E2 		subs	r4, r0, #0
 7339 3f2c 0000000A 		beq	.L578
 7340              	.L576:
 7341              	.L577:
 7342 3f30 FEFFFFEA 		b	.L577
 7343              	.L578:
3742:../uvc.c      ****     {
3743:../uvc.c      ****         goto handle_fatal_error;
3744:../uvc.c      ****     }
3745:../uvc.c      **** 
3746:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3747:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7344              		.loc 1 3747 0
 7345 3f34 0410A0E1 		mov	r1, r4
 7346 3f38 0420A0E1 		mov	r2, r4
 7347 3f3c 0500A0E1 		mov	r0, r5
 7348              	.LVL595:
 7349 3f40 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7350              	.LVL596:
3748:../uvc.c      **** 
3749:../uvc.c      ****     /* Configure the IO matrix for the device. */
3750:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3751:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3752:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3753:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3754:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3755:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3756:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3757:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3758:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3759:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3760:../uvc.c      **** 
3761:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7351              		.loc 1 3761 0
 7352 3f44 0D00A0E1 		mov	r0, sp
3751:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7353              		.loc 1 3751 0
 7354 3f48 1640CDE5 		strb	r4, [sp, #22]
3752:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7355              		.loc 1 3752 0
 7356 3f4c 18408DE5 		str	r4, [sp, #24]
3753:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7357              		.loc 1 3753 0
 7358 3f50 1C408DE5 		str	r4, [sp, #28]
3754:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7359              		.loc 1 3754 0
 7360 3f54 20408DE5 		str	r4, [sp, #32]
3755:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7361              		.loc 1 3755 0
 7362 3f58 24408DE5 		str	r4, [sp, #36]
3758:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7363              		.loc 1 3758 0
 7364 3f5c 0C408DE5 		str	r4, [sp, #12]
3759:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7365              		.loc 1 3759 0
 7366 3f60 10408DE5 		str	r4, [sp, #16]
3750:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7367              		.loc 1 3750 0
 7368 3f64 00508DE5 		str	r5, [sp, #0]
3756:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7369              		.loc 1 3756 0
 7370 3f68 04508DE5 		str	r5, [sp, #4]
3757:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7371              		.loc 1 3757 0
 7372 3f6c 08508DE5 		str	r5, [sp, #8]
 7373              		.loc 1 3761 0
 7374 3f70 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7375              	.LVL597:
3762:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7376              		.loc 1 3762 0
 7377 3f74 004050E2 		subs	r4, r0, #0
 7378 3f78 ECFFFF1A 		bne	.L576
3763:../uvc.c      ****     {
3764:../uvc.c      ****         goto handle_fatal_error;
3765:../uvc.c      ****     }
3766:../uvc.c      **** 
3767:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3768:../uvc.c      ****     CyU3PKernelEntry ();
 7379              		.loc 1 3768 0
 7380 3f7c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7381              	.LVL598:
3769:../uvc.c      **** 
3770:../uvc.c      ****     /* Dummy return to make the compiler happy */
3771:../uvc.c      ****     return 0;
3772:../uvc.c      **** 
3773:../uvc.c      **** handle_fatal_error:
3774:../uvc.c      ****     /* Cannot recover from this error. */
3775:../uvc.c      ****     while (1);
3776:../uvc.c      **** }
 7382              		.loc 1 3776 0
 7383 3f80 0400A0E1 		mov	r0, r4
 7384 3f84 3CD08DE2 		add	sp, sp, #60
 7385 3f88 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7386              		.cfi_endproc
 7387              	.LFE27:
 7389              		.global	CyFxGpifTransition
 7390              		.global	CyFxGpifWavedata
 7391              		.global	CyFxGpifWavedataPosition
 7392              		.global	CyFxGpifRegValue
 7393              		.global	CyFxGpifConfig
 7394              		.global	CyFxGpifTransition_usb2
 7395              		.global	CyFxGpifWavedata_usb2
 7396              		.global	CyFxGpifWavedataPosition_usb2
 7397              		.global	CyFxGpifRegValue_usb2
 7398              		.global	CyFxGpifConfig_usb2
 7399              		.global	snapButFlag
 7400              		.global	testSnap
 7401              		.global	fb
 7402              		.global	pb
 7403              		.global	pbc
 7404              		.global	fbbak
 7405              		.global	pbbak
 7406              		.global	pbcbak
 7407              		.global	pbcpbak
 7408              		.global	isUsbConnected
 7409              		.global	usbSpeed
 7410              		.global	clearFeatureRqtReceived
 7411              		.global	streamingStarted
 7412              		.global	glProbeCtrl
 7413              		.global	glProbeStilCtrl
 7414              		.global	glProbeCtrl20
 7415              		.global	glProbeStilCtrl20
 7416              		.global	glUVCHeader
 7417              		.comm	glChHandleUVCStream,220,4
 7418              		.comm	glChHandleStillStream,220,4
 7419              		.comm	glChHandleInterStat,160,4
 7420              		.comm	glInterStaBuffer,4,4
 7421              		.comm	cmdQu,32,4
 7422              		.comm	statQu,32,4
 7423              		.comm	cmdQuMux,56,4
 7424              		.comm	staQuMux,56,4
 7425              		.comm	timMux,56,4
 7426              		.comm	bmReqType,1,1
 7427              		.comm	bRequest,1,1
 7428              		.comm	wValue,2,2
 7429              		.comm	wIndex,2,2
 7430              		.comm	wLength,2,2
 7431              		.comm	posTick,4,4
 7432              		.comm	I2CCmdTimer,44,4
 7433              		.section	.rodata
 7434              		.align	2
 7435              		.set	.LANCHOR2,. + 0
 7438              	ExTime:
 7439 0000 9C       		.byte	-100
 7440 0001 00       		.byte	0
 7441 0002 4E       		.byte	78
 7442 0003 00       		.byte	0
 7443 0004 27       		.byte	39
 7444 0005 00       		.byte	0
 7445 0006 14       		.byte	20
 7446 0007 00       		.byte	0
 7447 0008 0A       		.byte	10
 7448 0009 00       		.byte	0
 7449 000a 05       		.byte	5
 7450 000b 00       		.byte	0
 7451 000c 02       		.byte	2
 7452 000d 00       		.byte	0
 7453 000e 01       		.byte	1
 7454 000f 00       		.byte	0
 7457              	CyFxGpifConfig:
 7458 0010 0F00     		.short	15
 7459 0012 0000     		.space	2
 7460 0014 00000000 		.word	CyFxGpifWavedata
 7461 0018 00000000 		.word	CyFxGpifWavedataPosition
 7462 001c 0500     		.short	5
 7463 001e 0000     		.space	2
 7464 0020 00000000 		.word	CyFxGpifTransition
 7465 0024 4C00     		.short	76
 7466 0026 0000     		.space	2
 7467 0028 00000000 		.word	CyFxGpifRegValue
 7470              	CyFxGpifConfig_usb2:
 7471 002c 9300     		.short	147
 7472 002e 0000     		.space	2
 7473 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7474 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7475 0038 0800     		.short	8
 7476 003a 0000     		.space	2
 7477 003c 00000000 		.word	CyFxGpifTransition_usb2
 7478 0040 4C00     		.short	76
 7479 0042 0000     		.space	2
 7480 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7481              		.data
 7482              		.align	2
 7483              		.set	.LANCHOR1,. + 0
 7486              	ExUCtrlParArry:
 7487 0000 00       		.byte	0
 7488 0001 00       		.byte	0
 7489 0002 04       		.byte	4
 7490 0003 01       		.byte	1
 7491 0004 00       		.byte	0
 7492 0005 38       		.byte	56
 7493 0006 01       		.byte	1
 7494 0007 01       		.byte	1
 7495 0008 00       		.byte	0
 7496 0009 03       		.byte	3
 7497 000a 00       		.byte	0
 7498 000b 4E       		.byte	78
 7499 000c 00       		.byte	0
 7500 000d 4E       		.byte	78
 7501 000e 00       		.byte	0
 7502 000f 30       		.byte	48
 7503 0010 01       		.byte	1
 7504 0011 00       		.byte	0
 7505 0012 00       		.byte	0
 7506 0013 00000000 		.space	5
 7506      00
 7507 0018 00       		.byte	0
 7508 0019 00       		.byte	0
 7509 001a 01       		.byte	1
 7510 001b 00       		.byte	0
 7511 001c 00       		.byte	0
 7512 001d 00       		.byte	0
 7513 001e 00       		.byte	0
 7514 001f 01       		.byte	1
 7515 0020 00       		.byte	0
 7516 0021 03       		.byte	3
 7517 0022 00       		.byte	0
 7518 0023 00       		.byte	0
 7519 0024 00       		.byte	0
 7520 0025 00       		.byte	0
 7521 0026 00       		.byte	0
 7522 0027 30       		.byte	48
 7523 0028 01       		.byte	1
 7524 0029 00       		.byte	0
 7525 002a 00       		.byte	0
 7526 002b 00000000 		.space	5
 7526      00
 7527 0030 00       		.byte	0
 7528 0031 00       		.byte	0
 7529 0032 02       		.byte	2
 7530 0033 00       		.byte	0
 7531 0034 00       		.byte	0
 7532 0035 FF       		.byte	-1
 7533 0036 00       		.byte	0
 7534 0037 01       		.byte	1
 7535 0038 00       		.byte	0
 7536 0039 03       		.byte	3
 7537 003a 00       		.byte	0
 7538 003b 01       		.byte	1
 7539 003c 00       		.byte	0
 7540 003d 00       		.byte	0
 7541 003e 00       		.byte	0
 7542 003f 30       		.byte	48
 7543 0040 01       		.byte	1
 7544 0041 01       		.byte	1
 7545 0042 00       		.byte	0
 7546 0043 00000000 		.space	5
 7546      00
 7547 0048 00       		.byte	0
 7548 0049 00       		.byte	0
 7549 004a 02       		.byte	2
 7550 004b 00       		.byte	0
 7551 004c 00       		.byte	0
 7552 004d 00       		.byte	0
 7553 004e 00       		.byte	0
 7554 004f 00       		.byte	0
 7555 0050 00       		.byte	0
 7556 0051 03       		.byte	3
 7557 0052 00       		.byte	0
 7558 0053 00       		.byte	0
 7559 0054 00       		.byte	0
 7560 0055 00       		.byte	0
 7561 0056 00       		.byte	0
 7562 0057 30       		.byte	48
 7563 0058 01       		.byte	1
 7564 0059 01       		.byte	1
 7565 005a 00       		.byte	0
 7566 005b 00000000 		.space	5
 7566      00
 7567 0060 13       		.byte	19
 7568 0061 14       		.byte	20
 7569 0062 02       		.byte	2
 7570 0063 01       		.byte	1
 7571 0064 00       		.byte	0
 7572 0065 03       		.byte	3
 7573 0066 00       		.byte	0
 7574 0067 01       		.byte	1
 7575 0068 00       		.byte	0
 7576 0069 03       		.byte	3
 7577 006a 00       		.byte	0
 7578 006b 23       		.byte	35
 7579 006c 37       		.byte	55
 7580 006d 23       		.byte	35
 7581 006e 37       		.byte	55
 7582 006f 30       		.byte	48
 7583 0070 01       		.byte	1
 7584 0071 00       		.byte	0
 7585 0072 00       		.byte	0
 7586 0073 00000000 		.space	5
 7586      00
 7587 0078 11       		.byte	17
 7588 0079 00       		.byte	0
 7589 007a 02       		.byte	2
 7590 007b 01       		.byte	1
 7591 007c 00       		.byte	0
 7592 007d 03       		.byte	3
 7593 007e 00       		.byte	0
 7594 007f 01       		.byte	1
 7595 0080 00       		.byte	0
 7596 0081 03       		.byte	3
 7597 0082 00       		.byte	0
 7598 0083 01       		.byte	1
 7599 0084 00       		.byte	0
 7600 0085 01       		.byte	1
 7601 0086 00       		.byte	0
 7602 0087 30       		.byte	48
 7603 0088 01       		.byte	1
 7604 0089 01       		.byte	1
 7605 008a 00       		.byte	0
 7606 008b 00000000 		.space	5
 7606      00
 7607 0090 17       		.byte	23
 7608 0091 00       		.byte	0
 7609 0092 01       		.byte	1
 7610 0093 01       		.byte	1
 7611 0094 00       		.byte	0
 7612 0095 02       		.byte	2
 7613 0096 00       		.byte	0
 7614 0097 01       		.byte	1
 7615 0098 00       		.byte	0
 7616 0099 03       		.byte	3
 7617 009a 00       		.byte	0
 7618 009b 00       		.byte	0
 7619 009c 00       		.byte	0
 7620 009d 00       		.byte	0
 7621 009e 00       		.byte	0
 7622 009f 30       		.byte	48
 7623 00a0 01       		.byte	1
 7624 00a1 01       		.byte	1
 7625 00a2 00       		.byte	0
 7626 00a3 00000000 		.space	5
 7626      00
 7627 00a8 00       		.byte	0
 7628 00a9 00       		.byte	0
 7629 00aa 04       		.byte	4
 7630 00ab 01       		.byte	1
 7631 00ac 00       		.byte	0
 7632 00ad 38       		.byte	56
 7633 00ae 01       		.byte	1
 7634 00af 01       		.byte	1
 7635 00b0 00       		.byte	0
 7636 00b1 03       		.byte	3
 7637 00b2 00       		.byte	0
 7638 00b3 4E       		.byte	78
 7639 00b4 00       		.byte	0
 7640 00b5 4E       		.byte	78
 7641 00b6 00       		.byte	0
 7642 00b7 30       		.byte	48
 7643 00b8 01       		.byte	1
 7644 00b9 00       		.byte	0
 7645 00ba 00       		.byte	0
 7646 00bb 00000000 		.space	5
 7646      00
 7647 00c0 00       		.byte	0
 7648 00c1 00       		.byte	0
 7649 00c2 01       		.byte	1
 7650 00c3 00       		.byte	0
 7651 00c4 00       		.byte	0
 7652 00c5 00       		.byte	0
 7653 00c6 00       		.byte	0
 7654 00c7 01       		.byte	1
 7655 00c8 00       		.byte	0
 7656 00c9 03       		.byte	3
 7657 00ca 00       		.byte	0
 7658 00cb 00       		.byte	0
 7659 00cc 00       		.byte	0
 7660 00cd 00       		.byte	0
 7661 00ce 00       		.byte	0
 7662 00cf 30       		.byte	48
 7663 00d0 01       		.byte	1
 7664 00d1 00       		.byte	0
 7665 00d2 00       		.byte	0
 7666 00d3 00000000 		.space	5
 7666      00
 7667 00d8 00       		.byte	0
 7668 00d9 00       		.byte	0
 7669 00da 02       		.byte	2
 7670 00db 00       		.byte	0
 7671 00dc 00       		.byte	0
 7672 00dd 05       		.byte	5
 7673 00de 00       		.byte	0
 7674 00df 01       		.byte	1
 7675 00e0 00       		.byte	0
 7676 00e1 03       		.byte	3
 7677 00e2 00       		.byte	0
 7678 00e3 00       		.byte	0
 7679 00e4 00       		.byte	0
 7680 00e5 00       		.byte	0
 7681 00e6 00       		.byte	0
 7682 00e7 30       		.byte	48
 7683 00e8 01       		.byte	1
 7684 00e9 00       		.byte	0
 7685 00ea 00       		.byte	0
 7686 00eb 00000000 		.space	5
 7686      00
 7687 00f0 00       		.byte	0
 7688 00f1 00       		.byte	0
 7689 00f2 03       		.byte	3
 7690 00f3 00       		.byte	0
 7691 00f4 00       		.byte	0
 7692 00f5 0A       		.byte	10
 7693 00f6 00       		.byte	0
 7694 00f7 01       		.byte	1
 7695 00f8 00       		.byte	0
 7696 00f9 03       		.byte	3
 7697 00fa 00       		.byte	0
 7698 00fb 00       		.byte	0
 7699 00fc 00       		.byte	0
 7700 00fd 00       		.byte	0
 7701 00fe 00       		.byte	0
 7702 00ff 30       		.byte	48
 7703 0100 01       		.byte	1
 7704 0101 00       		.byte	0
 7705 0102 00       		.byte	0
 7706 0103 00000000 		.space	5
 7706      00
 7707 0108 00       		.byte	0
 7708 0109 00       		.byte	0
 7709 010a 02       		.byte	2
 7710 010b 00       		.byte	0
 7711 010c 00       		.byte	0
 7712 010d 40       		.byte	64
 7713 010e 00       		.byte	0
 7714 010f 01       		.byte	1
 7715 0110 00       		.byte	0
 7716 0111 03       		.byte	3
 7717 0112 00       		.byte	0
 7718 0113 0F       		.byte	15
 7719 0114 11       		.byte	17
 7720 0115 00       		.byte	0
 7721 0116 00       		.byte	0
 7722 0117 30       		.byte	48
 7723 0118 01       		.byte	1
 7724 0119 00       		.byte	0
 7725 011a 00       		.byte	0
 7726 011b 00000000 		.space	5
 7726      00
 7727 0120 00       		.byte	0
 7728 0121 00       		.byte	0
 7729 0122 02       		.byte	2
 7730 0123 00       		.byte	0
 7731 0124 00       		.byte	0
 7732 0125 64       		.byte	100
 7733 0126 00       		.byte	0
 7734 0127 01       		.byte	1
 7735 0128 00       		.byte	0
 7736 0129 03       		.byte	3
 7737 012a 00       		.byte	0
 7738 012b 00       		.byte	0
 7739 012c 00       		.byte	0
 7740 012d 00       		.byte	0
 7741 012e 00       		.byte	0
 7742 012f 30       		.byte	48
 7743 0130 01       		.byte	1
 7744 0131 00       		.byte	0
 7745 0132 00       		.byte	0
 7746 0133 00000000 		.space	5
 7746      00
 7747 0138 00       		.byte	0
 7748 0139 00       		.byte	0
 7749 013a 02       		.byte	2
 7750 013b 00       		.byte	0
 7751 013c 00       		.byte	0
 7752 013d 64       		.byte	100
 7753 013e 00       		.byte	0
 7754 013f 01       		.byte	1
 7755 0140 00       		.byte	0
 7756 0141 03       		.byte	3
 7757 0142 00       		.byte	0
 7758 0143 00       		.byte	0
 7759 0144 00       		.byte	0
 7760 0145 00       		.byte	0
 7761 0146 00       		.byte	0
 7762 0147 30       		.byte	48
 7763 0148 01       		.byte	1
 7764 0149 00       		.byte	0
 7765 014a 00       		.byte	0
 7766 014b 00000000 		.space	5
 7766      00
 7767 0150 00       		.byte	0
 7768 0151 00       		.byte	0
 7769 0152 02       		.byte	2
 7770 0153 00       		.byte	0
 7771 0154 00       		.byte	0
 7772 0155 64       		.byte	100
 7773 0156 00       		.byte	0
 7774 0157 01       		.byte	1
 7775 0158 00       		.byte	0
 7776 0159 03       		.byte	3
 7777 015a 00       		.byte	0
 7778 015b 00       		.byte	0
 7779 015c 00       		.byte	0
 7780 015d 00       		.byte	0
 7781 015e 00       		.byte	0
 7782 015f 30       		.byte	48
 7783 0160 01       		.byte	1
 7784 0161 00       		.byte	0
 7785 0162 00       		.byte	0
 7786 0163 00000000 		.space	5
 7786      00
 7787 0168 00       		.byte	0
 7788 0169 00       		.byte	0
 7789 016a 02       		.byte	2
 7790 016b 00       		.byte	0
 7791 016c 00       		.byte	0
 7792 016d 64       		.byte	100
 7793 016e 00       		.byte	0
 7794 016f 01       		.byte	1
 7795 0170 00       		.byte	0
 7796 0171 03       		.byte	3
 7797 0172 00       		.byte	0
 7798 0173 00       		.byte	0
 7799 0174 00       		.byte	0
 7800 0175 00       		.byte	0
 7801 0176 00       		.byte	0
 7802 0177 30       		.byte	48
 7803 0178 01       		.byte	1
 7804 0179 00       		.byte	0
 7805 017a 00       		.byte	0
 7806 017b 00000000 		.space	5
 7806      00
 7809              	CtrlParArry:
 7810 0180 10       		.byte	16
 7811 0181 10       		.byte	16
 7812 0182 02       		.byte	2
 7813 0183 00       		.byte	0
 7814 0184 00       		.byte	0
 7815 0185 03       		.byte	3
 7816 0186 00       		.byte	0
 7817 0187 01       		.byte	1
 7818 0188 00       		.byte	0
 7819 0189 03       		.byte	3
 7820 018a 00       		.byte	0
 7821 018b 00       		.byte	0
 7822 018c 00       		.byte	0
 7823 018d 00       		.byte	0
 7824 018e 00       		.byte	0
 7825 018f 30       		.byte	48
 7826 0190 01       		.byte	1
 7827 0191 00       		.byte	0
 7828 0192 00       		.byte	0
 7829 0193 00000000 		.space	5
 7829      00
 7830 0198 01       		.byte	1
 7831 0199 00       		.byte	0
 7832 019a 02       		.byte	2
 7833 019b 00       		.byte	0
 7834 019c 00       		.byte	0
 7835 019d FF       		.byte	-1
 7836 019e 00       		.byte	0
 7837 019f 01       		.byte	1
 7838 01a0 00       		.byte	0
 7839 01a1 03       		.byte	3
 7840 01a2 00       		.byte	0
 7841 01a3 76       		.byte	118
 7842 01a4 00       		.byte	0
 7843 01a5 76       		.byte	118
 7844 01a6 C7       		.byte	-57
 7845 01a7 C6       		.byte	-58
 7846 01a8 01       		.byte	1
 7847 01a9 01       		.byte	1
 7848 01aa 00       		.byte	0
 7849 01ab 00000000 		.space	5
 7849      00
 7850 01b0 02       		.byte	2
 7851 01b1 02       		.byte	2
 7852 01b2 02       		.byte	2
 7853 01b3 00       		.byte	0
 7854 01b4 00       		.byte	0
 7855 01b5 FF       		.byte	-1
 7856 01b6 00       		.byte	0
 7857 01b7 01       		.byte	1
 7858 01b8 00       		.byte	0
 7859 01b9 03       		.byte	3
 7860 01ba 00       		.byte	0
 7861 01bb 70       		.byte	112
 7862 01bc 00       		.byte	0
 7863 01bd 70       		.byte	112
 7864 01be 00       		.byte	0
 7865 01bf C6       		.byte	-58
 7866 01c0 01       		.byte	1
 7867 01c1 01       		.byte	1
 7868 01c2 00       		.byte	0
 7869 01c3 00000000 		.space	5
 7869      00
 7870 01c8 00       		.byte	0
 7871 01c9 00       		.byte	0
 7872 01ca 02       		.byte	2
 7873 01cb 00       		.byte	0
 7874 01cc 00       		.byte	0
 7875 01cd 64       		.byte	100
 7876 01ce 00       		.byte	0
 7877 01cf 01       		.byte	1
 7878 01d0 00       		.byte	0
 7879 01d1 03       		.byte	3
 7880 01d2 00       		.byte	0
 7881 01d3 00       		.byte	0
 7882 01d4 00       		.byte	0
 7883 01d5 00       		.byte	0
 7884 01d6 00       		.byte	0
 7885 01d7 30       		.byte	48
 7886 01d8 01       		.byte	1
 7887 01d9 00       		.byte	0
 7888 01da 00       		.byte	0
 7889 01db 00000000 		.space	5
 7889      00
 7890 01e0 07       		.byte	7
 7891 01e1 07       		.byte	7
 7892 01e2 02       		.byte	2
 7893 01e3 00       		.byte	0
 7894 01e4 00       		.byte	0
 7895 01e5 01       		.byte	1
 7896 01e6 00       		.byte	0
 7897 01e7 01       		.byte	1
 7898 01e8 00       		.byte	0
 7899 01e9 03       		.byte	3
 7900 01ea 00       		.byte	0
 7901 01eb 01       		.byte	1
 7902 01ec 00       		.byte	0
 7903 01ed 01       		.byte	1
 7904 01ee 00       		.byte	0
 7905 01ef 30       		.byte	48
 7906 01f0 01       		.byte	1
 7907 01f1 00       		.byte	0
 7908 01f2 00       		.byte	0
 7909 01f3 00000000 		.space	5
 7909      00
 7910 01f8 DF       		.byte	-33
 7911 01f9 E1       		.byte	-31
 7912 01fa 02       		.byte	2
 7913 01fb 00       		.byte	0
 7914 01fc 00       		.byte	0
 7915 01fd FF       		.byte	-1
 7916 01fe 00       		.byte	0
 7917 01ff 01       		.byte	1
 7918 0200 00       		.byte	0
 7919 0201 03       		.byte	3
 7920 0202 00       		.byte	0
 7921 0203 80       		.byte	-128
 7922 0204 00       		.byte	0
 7923 0205 00       		.byte	0
 7924 0206 00       		.byte	0
 7925 0207 C6       		.byte	-58
 7926 0208 01       		.byte	1
 7927 0209 01       		.byte	1
 7928 020a 00       		.byte	0
 7929 020b 00000000 		.space	5
 7929      00
 7930 0210 85       		.byte	-123
 7931 0211 86       		.byte	-122
 7932 0212 02       		.byte	2
 7933 0213 00       		.byte	0
 7934 0214 00       		.byte	0
 7935 0215 64       		.byte	100
 7936 0216 00       		.byte	0
 7937 0217 01       		.byte	1
 7938 0218 00       		.byte	0
 7939 0219 03       		.byte	3
 7940 021a 00       		.byte	0
 7941 021b 32       		.byte	50
 7942 021c 00       		.byte	0
 7943 021d 32       		.byte	50
 7944 021e 00       		.byte	0
 7945 021f F2       		.byte	-14
 7946 0220 01       		.byte	1
 7947 0221 01       		.byte	1
 7948 0222 00       		.byte	0
 7949 0223 00000000 		.space	5
 7949      00
 7950 0228 06       		.byte	6
 7951 0229 06       		.byte	6
 7952 022a 02       		.byte	2
 7953 022b 00       		.byte	0
 7954 022c 00       		.byte	0
 7955 022d 40       		.byte	64
 7956 022e 00       		.byte	0
 7957 022f 01       		.byte	1
 7958 0230 00       		.byte	0
 7959 0231 03       		.byte	3
 7960 0232 00       		.byte	0
 7961 0233 20       		.byte	32
 7962 0234 00       		.byte	0
 7963 0235 20       		.byte	32
 7964 0236 00       		.byte	0
 7965 0237 30       		.byte	48
 7966 0238 01       		.byte	1
 7967 0239 01       		.byte	1
 7968 023a 00       		.byte	0
 7969 023b 00000000 		.space	5
 7969      00
 7970 0240 00       		.byte	0
 7971 0241 00       		.byte	0
 7972 0242 02       		.byte	2
 7973 0243 00       		.byte	0
 7974 0244 00       		.byte	0
 7975 0245 64       		.byte	100
 7976 0246 00       		.byte	0
 7977 0247 01       		.byte	1
 7978 0248 00       		.byte	0
 7979 0249 03       		.byte	3
 7980 024a 00       		.byte	0
 7981 024b 00       		.byte	0
 7982 024c 00       		.byte	0
 7983 024d 00       		.byte	0
 7984 024e 00       		.byte	0
 7985 024f 30       		.byte	48
 7986 0250 01       		.byte	1
 7987 0251 00       		.byte	0
 7988 0252 00       		.byte	0
 7989 0253 00000000 		.space	5
 7989      00
 7990 0258 08       		.byte	8
 7991 0259 08       		.byte	8
 7992 025a 02       		.byte	2
 7993 025b 00       		.byte	0
 7994 025c 00       		.byte	0
 7995 025d 05       		.byte	5
 7996 025e 00       		.byte	0
 7997 025f 01       		.byte	1
 7998 0260 00       		.byte	0
 7999 0261 03       		.byte	3
 8000 0262 00       		.byte	0
 8001 0263 00       		.byte	0
 8002 0264 00       		.byte	0
 8003 0265 00       		.byte	0
 8004 0266 00       		.byte	0
 8005 0267 30       		.byte	48
 8006 0268 01       		.byte	1
 8007 0269 00       		.byte	0
 8008 026a 00       		.byte	0
 8009 026b 00000000 		.space	5
 8009      00
 8010 0270 00       		.byte	0
 8011 0271 00       		.byte	0
 8012 0272 02       		.byte	2
 8013 0273 00       		.byte	0
 8014 0274 00       		.byte	0
 8015 0275 40       		.byte	64
 8016 0276 00       		.byte	0
 8017 0277 01       		.byte	1
 8018 0278 00       		.byte	0
 8019 0279 03       		.byte	3
 8020 027a 00       		.byte	0
 8021 027b 00       		.byte	0
 8022 027c 00       		.byte	0
 8023 027d 00       		.byte	0
 8024 027e 00       		.byte	0
 8025 027f 30       		.byte	48
 8026 0280 01       		.byte	1
 8027 0281 00       		.byte	0
 8028 0282 00       		.byte	0
 8029 0283 00000000 		.space	5
 8029      00
 8030 0288 09       		.byte	9
 8031 0289 0A       		.byte	10
 8032 028a 04       		.byte	4
 8033 028b 00       		.byte	0
 8034 028c 00       		.byte	0
 8035 028d 40       		.byte	64
 8036 028e 00       		.byte	0
 8037 028f 01       		.byte	1
 8038 0290 00       		.byte	0
 8039 0291 03       		.byte	3
 8040 0292 00       		.byte	0
 8041 0293 20       		.byte	32
 8042 0294 38       		.byte	56
 8043 0295 20       		.byte	32
 8044 0296 38       		.byte	56
 8045 0297 30       		.byte	48
 8046 0298 01       		.byte	1
 8047 0299 00       		.byte	0
 8048 029a 00       		.byte	0
 8049 029b 00000000 		.space	5
 8049      00
 8050 02a0 00       		.byte	0
 8051 02a1 00       		.byte	0
 8052 02a2 02       		.byte	2
 8053 02a3 00       		.byte	0
 8054 02a4 00       		.byte	0
 8055 02a5 64       		.byte	100
 8056 02a6 00       		.byte	0
 8057 02a7 01       		.byte	1
 8058 02a8 00       		.byte	0
 8059 02a9 03       		.byte	3
 8060 02aa 00       		.byte	0
 8061 02ab 00       		.byte	0
 8062 02ac 00       		.byte	0
 8063 02ad 00       		.byte	0
 8064 02ae 00       		.byte	0
 8065 02af 30       		.byte	48
 8066 02b0 01       		.byte	1
 8067 02b1 00       		.byte	0
 8068 02b2 00       		.byte	0
 8069 02b3 00000000 		.space	5
 8069      00
 8070 02b8 00       		.byte	0
 8071 02b9 00       		.byte	0
 8072 02ba 02       		.byte	2
 8073 02bb 00       		.byte	0
 8074 02bc 00       		.byte	0
 8075 02bd 64       		.byte	100
 8076 02be 00       		.byte	0
 8077 02bf 01       		.byte	1
 8078 02c0 00       		.byte	0
 8079 02c1 03       		.byte	3
 8080 02c2 00       		.byte	0
 8081 02c3 00       		.byte	0
 8082 02c4 00       		.byte	0
 8083 02c5 00       		.byte	0
 8084 02c6 00       		.byte	0
 8085 02c7 30       		.byte	48
 8086 02c8 01       		.byte	1
 8087 02c9 00       		.byte	0
 8088 02ca 00       		.byte	0
 8089 02cb 00000000 		.space	5
 8089      00
 8090 02d0 2A       		.byte	42
 8091 02d1 2A       		.byte	42
 8092 02d2 02       		.byte	2
 8093 02d3 00       		.byte	0
 8094 02d4 00       		.byte	0
 8095 02d5 1B       		.byte	27
 8096 02d6 00       		.byte	0
 8097 02d7 01       		.byte	1
 8098 02d8 00       		.byte	0
 8099 02d9 03       		.byte	3
 8100 02da 00       		.byte	0
 8101 02db 00       		.byte	0
 8102 02dc 00       		.byte	0
 8103 02dd 00       		.byte	0
 8104 02de 00       		.byte	0
 8105 02df 30       		.byte	48
 8106 02e0 01       		.byte	1
 8107 02e1 00       		.byte	0
 8108 02e2 00       		.byte	0
 8109 02e3 00000000 		.space	5
 8109      00
 8110 02e8 00       		.byte	0
 8111 02e9 00       		.byte	0
 8112 02ea 02       		.byte	2
 8113 02eb 00       		.byte	0
 8114 02ec 00       		.byte	0
 8115 02ed 64       		.byte	100
 8116 02ee 00       		.byte	0
 8117 02ef 01       		.byte	1
 8118 02f0 00       		.byte	0
 8119 02f1 03       		.byte	3
 8120 02f2 00       		.byte	0
 8121 02f3 00       		.byte	0
 8122 02f4 00       		.byte	0
 8123 02f5 00       		.byte	0
 8124 02f6 00       		.byte	0
 8125 02f7 30       		.byte	48
 8126 02f8 01       		.byte	1
 8127 02f9 00       		.byte	0
 8128 02fa 00       		.byte	0
 8129 02fb 00000000 		.space	5
 8129      00
 8130 0300 00       		.byte	0
 8131 0301 00       		.byte	0
 8132 0302 02       		.byte	2
 8133 0303 00       		.byte	0
 8134 0304 00       		.byte	0
 8135 0305 12       		.byte	18
 8136 0306 00       		.byte	0
 8137 0307 01       		.byte	1
 8138 0308 00       		.byte	0
 8139 0309 03       		.byte	3
 8140 030a 00       		.byte	0
 8141 030b 00       		.byte	0
 8142 030c 00       		.byte	0
 8143 030d 00       		.byte	0
 8144 030e 00       		.byte	0
 8145 030f 30       		.byte	48
 8146 0310 01       		.byte	1
 8147 0311 00       		.byte	0
 8148 0312 00       		.byte	0
 8149 0313 00000000 		.space	5
 8149      00
 8150 0318 01       		.byte	1
 8151 0319 01       		.byte	1
 8152 031a 02       		.byte	2
 8153 031b 00       		.byte	0
 8154 031c 00       		.byte	0
 8155 031d 09       		.byte	9
 8156 031e 00       		.byte	0
 8157 031f 01       		.byte	1
 8158 0320 00       		.byte	0
 8159 0321 03       		.byte	3
 8160 0322 00       		.byte	0
 8161 0323 00       		.byte	0
 8162 0324 00       		.byte	0
 8163 0325 01       		.byte	1
 8164 0326 00       		.byte	0
 8165 0327 30       		.byte	48
 8166 0328 01       		.byte	1
 8167 0329 00       		.byte	0
 8168 032a 00       		.byte	0
 8169 032b 00000000 		.space	5
 8169      00
 8170 0330 05       		.byte	5
 8171 0331 05       		.byte	5
 8172 0332 02       		.byte	2
 8173 0333 00       		.byte	0
 8174 0334 00       		.byte	0
 8175 0335 03       		.byte	3
 8176 0336 00       		.byte	0
 8177 0337 01       		.byte	1
 8178 0338 00       		.byte	0
 8179 0339 03       		.byte	3
 8180 033a 00       		.byte	0
 8181 033b 00       		.byte	0
 8182 033c 00       		.byte	0
 8183 033d 00       		.byte	0
 8184 033e 00       		.byte	0
 8185 033f 30       		.byte	48
 8186 0340 01       		.byte	1
 8187 0341 00       		.byte	0
 8188 0342 00       		.byte	0
 8189 0343 00000000 		.space	5
 8189      00
 8190 0348 18       		.byte	24
 8191 0349 18       		.byte	24
 8192 034a 02       		.byte	2
 8193 034b 00       		.byte	0
 8194 034c 00       		.byte	0
 8195 034d 01       		.byte	1
 8196 034e 00       		.byte	0
 8197 034f 01       		.byte	1
 8198 0350 00       		.byte	0
 8199 0351 03       		.byte	3
 8200 0352 00       		.byte	0
 8201 0353 00       		.byte	0
 8202 0354 00       		.byte	0
 8203 0355 00       		.byte	0
 8204 0356 00       		.byte	0
 8205 0357 30       		.byte	48
 8206 0358 01       		.byte	1
 8207 0359 00       		.byte	0
 8208 035a 00       		.byte	0
 8209 035b 00000000 		.space	5
 8209      00
 8210 0360 19       		.byte	25
 8211 0361 19       		.byte	25
 8212 0362 01       		.byte	1
 8213 0363 00       		.byte	0
 8214 0364 00       		.byte	0
 8215 0365 40       		.byte	64
 8216 0366 00       		.byte	0
 8217 0367 01       		.byte	1
 8218 0368 00       		.byte	0
 8219 0369 03       		.byte	3
 8220 036a 00       		.byte	0
 8221 036b 20       		.byte	32
 8222 036c 00       		.byte	0
 8223 036d 20       		.byte	32
 8224 036e 00       		.byte	0
 8225 036f 30       		.byte	48
 8226 0370 01       		.byte	1
 8227 0371 00       		.byte	0
 8228 0372 00       		.byte	0
 8229 0373 00000000 		.space	5
 8229      00
 8230 0378 20       		.byte	32
 8231 0379 20       		.byte	32
 8232 037a 02       		.byte	2
 8233 037b 00       		.byte	0
 8234 037c 00       		.byte	0
 8235 037d 02       		.byte	2
 8236 037e 00       		.byte	0
 8237 037f 01       		.byte	1
 8238 0380 00       		.byte	0
 8239 0381 03       		.byte	3
 8240 0382 00       		.byte	0
 8241 0383 00       		.byte	0
 8242 0384 00       		.byte	0
 8243 0385 00       		.byte	0
 8244 0386 00       		.byte	0
 8245 0387 30       		.byte	48
 8246 0388 01       		.byte	1
 8247 0389 00       		.byte	0
 8248 038a 00       		.byte	0
 8249 038b 00000000 		.space	5
 8249      00
 8250 0390 22       		.byte	34
 8251 0391 22       		.byte	34
 8252 0392 02       		.byte	2
 8253 0393 00       		.byte	0
 8254 0394 00       		.byte	0
 8255 0395 3F       		.byte	63
 8256 0396 00       		.byte	0
 8257 0397 01       		.byte	1
 8258 0398 00       		.byte	0
 8259 0399 03       		.byte	3
 8260 039a 00       		.byte	0
 8261 039b 00       		.byte	0
 8262 039c 00       		.byte	0
 8263 039d 00       		.byte	0
 8264 039e 00       		.byte	0
 8265 039f 30       		.byte	48
 8266 03a0 01       		.byte	1
 8267 03a1 00       		.byte	0
 8268 03a2 00       		.byte	0
 8269 03a3 00000000 		.space	5
 8269      00
 8270 03a8 23       		.byte	35
 8271 03a9 23       		.byte	35
 8272 03aa 02       		.byte	2
 8273 03ab 00       		.byte	0
 8274 03ac 00       		.byte	0
 8275 03ad 64       		.byte	100
 8276 03ae 00       		.byte	0
 8277 03af 01       		.byte	1
 8278 03b0 00       		.byte	0
 8279 03b1 03       		.byte	3
 8280 03b2 00       		.byte	0
 8281 03b3 10       		.byte	16
 8282 03b4 00       		.byte	0
 8283 03b5 10       		.byte	16
 8284 03b6 00       		.byte	0
 8285 03b7 30       		.byte	48
 8286 03b8 01       		.byte	1
 8287 03b9 00       		.byte	0
 8288 03ba 00       		.byte	0
 8289 03bb 00000000 		.space	5
 8289      00
 8290 03c0 24       		.byte	36
 8291 03c1 24       		.byte	36
 8292 03c2 02       		.byte	2
 8293 03c3 00       		.byte	0
 8294 03c4 00       		.byte	0
 8295 03c5 64       		.byte	100
 8296 03c6 00       		.byte	0
 8297 03c7 01       		.byte	1
 8298 03c8 00       		.byte	0
 8299 03c9 03       		.byte	3
 8300 03ca 00       		.byte	0
 8301 03cb 10       		.byte	16
 8302 03cc 00       		.byte	0
 8303 03cd 10       		.byte	16
 8304 03ce 00       		.byte	0
 8305 03cf 30       		.byte	48
 8306 03d0 01       		.byte	1
 8307 03d1 00       		.byte	0
 8308 03d2 00       		.byte	0
 8309 03d3 00000000 		.space	5
 8309      00
 8310 03d8 02       		.byte	2
 8311 03d9 03       		.byte	3
 8312 03da 04       		.byte	4
 8313 03db 00       		.byte	0
 8314 03dc 00       		.byte	0
 8315 03dd 7F       		.byte	127
 8316 03de 00       		.byte	0
 8317 03df 01       		.byte	1
 8318 03e0 00       		.byte	0
 8319 03e1 03       		.byte	3
 8320 03e2 00       		.byte	0
 8321 03e3 00       		.byte	0
 8322 03e4 20       		.byte	32
 8323 03e5 00       		.byte	0
 8324 03e6 20       		.byte	32
 8325 03e7 30       		.byte	48
 8326 03e8 01       		.byte	1
 8327 03e9 00       		.byte	0
 8328 03ea 00       		.byte	0
 8329 03eb 00000000 		.space	5
 8329      00
 8330 03f0 04       		.byte	4
 8331 03f1 0C       		.byte	12
 8332 03f2 02       		.byte	2
 8333 03f3 00       		.byte	0
 8334 03f4 00       		.byte	0
 8335 03f5 40       		.byte	64
 8336 03f6 00       		.byte	0
 8337 03f7 01       		.byte	1
 8338 03f8 00       		.byte	0
 8339 03f9 03       		.byte	3
 8340 03fa 00       		.byte	0
 8341 03fb 20       		.byte	32
 8342 03fc 00       		.byte	0
 8343 03fd 20       		.byte	32
 8344 03fe 00       		.byte	0
 8345 03ff 30       		.byte	48
 8346 0400 01       		.byte	1
 8347 0401 00       		.byte	0
 8348 0402 00       		.byte	0
 8349 0403 00000000 		.space	5
 8349      00
 8350 0408 00       		.byte	0
 8351 0409 00       		.byte	0
 8352 040a 02       		.byte	2
 8353 040b 00       		.byte	0
 8354 040c 00       		.byte	0
 8355 040d 19       		.byte	25
 8356 040e 00       		.byte	0
 8357 040f 01       		.byte	1
 8358 0410 00       		.byte	0
 8359 0411 03       		.byte	3
 8360 0412 00       		.byte	0
 8361 0413 00       		.byte	0
 8362 0414 00       		.byte	0
 8363 0415 00       		.byte	0
 8364 0416 00       		.byte	0
 8365 0417 30       		.byte	48
 8366 0418 01       		.byte	1
 8367 0419 00       		.byte	0
 8368 041a 00       		.byte	0
 8369 041b 00000000 		.space	5
 8369      00
 8370 0420 10       		.byte	16
 8371 0421 10       		.byte	16
 8372 0422 02       		.byte	2
 8373 0423 00       		.byte	0
 8374 0424 00       		.byte	0
 8375 0425 06       		.byte	6
 8376 0426 00       		.byte	0
 8377 0427 01       		.byte	1
 8378 0428 00       		.byte	0
 8379 0429 03       		.byte	3
 8380 042a 00       		.byte	0
 8381 042b 00       		.byte	0
 8382 042c 00       		.byte	0
 8383 042d 00       		.byte	0
 8384 042e 00       		.byte	0
 8385 042f 30       		.byte	48
 8386 0430 01       		.byte	1
 8387 0431 00       		.byte	0
 8388 0432 00       		.byte	0
 8389 0433 00000000 		.space	5
 8389      00
 8390 0438 00       		.byte	0
 8391 0439 00       		.byte	0
 8392 043a 02       		.byte	2
 8393 043b 00       		.byte	0
 8394 043c 00       		.byte	0
 8395 043d 03       		.byte	3
 8396 043e 00       		.byte	0
 8397 043f 01       		.byte	1
 8398 0440 00       		.byte	0
 8399 0441 03       		.byte	3
 8400 0442 00       		.byte	0
 8401 0443 00       		.byte	0
 8402 0444 00       		.byte	0
 8403 0445 00       		.byte	0
 8404 0446 00       		.byte	0
 8405 0447 30       		.byte	48
 8406 0448 01       		.byte	1
 8407 0449 00       		.byte	0
 8408 044a 00       		.byte	0
 8409 044b 00000000 		.space	5
 8409      00
 8410 0450 50       		.byte	80
 8411 0451 50       		.byte	80
 8412 0452 01       		.byte	1
 8413 0453 00       		.byte	0
 8414 0454 00       		.byte	0
 8415 0455 03       		.byte	3
 8416 0456 00       		.byte	0
 8417 0457 01       		.byte	1
 8418 0458 00       		.byte	0
 8419 0459 03       		.byte	3
 8420 045a 00       		.byte	0
 8421 045b 00       		.byte	0
 8422 045c 00       		.byte	0
 8423 045d 00       		.byte	0
 8424 045e 00       		.byte	0
 8425 045f 30       		.byte	48
 8426 0460 01       		.byte	1
 8427 0461 00       		.byte	0
 8428 0462 00       		.byte	0
 8429 0463 00000000 		.space	5
 8429      00
 8430 0468 00       		.byte	0
 8431 0469 00       		.byte	0
 8432 046a 0B       		.byte	11
 8433 046b 00       		.byte	0
 8434 046c 00       		.byte	0
 8435 046d FF       		.byte	-1
 8436 046e FF       		.byte	-1
 8437 046f 01       		.byte	1
 8438 0470 00       		.byte	0
 8439 0471 03       		.byte	3
 8440 0472 00       		.byte	0
 8441 0473 00       		.byte	0
 8442 0474 00       		.byte	0
 8443 0475 00       		.byte	0
 8444 0476 00       		.byte	0
 8445 0477 00       		.byte	0
 8446 0478 01       		.byte	1
 8447 0479 00       		.byte	0
 8448 047a 00       		.byte	0
 8449 047b 00000000 		.space	5
 8449      00
 8452              	glUVCHeader:
 8453 0480 0C       		.byte	12
 8454 0481 8C       		.byte	-116
 8455 0482 00       		.byte	0
 8456 0483 00       		.byte	0
 8457 0484 00       		.byte	0
 8458 0485 00       		.byte	0
 8459 0486 00       		.byte	0
 8460 0487 00       		.byte	0
 8461 0488 00       		.byte	0
 8462 0489 00       		.byte	0
 8463 048a 00       		.byte	0
 8464 048b 00       		.byte	0
 8467              	WBMenuCmpArry:
 8468 048c 20       		.byte	32
 8469 048d 0F       		.byte	15
 8470 048e 38       		.byte	56
 8471 048f F0       		.byte	-16
 8474              	CTCtrlParArry:
 8475 0490 00       		.byte	0
 8476 0491 00       		.byte	0
 8477 0492 01       		.byte	1
 8478 0493 00       		.byte	0
 8479 0494 00       		.byte	0
 8480 0495 03       		.byte	3
 8481 0496 00       		.byte	0
 8482 0497 01       		.byte	1
 8483 0498 00       		.byte	0
 8484 0499 03       		.byte	3
 8485 049a 00       		.byte	0
 8486 049b 03       		.byte	3
 8487 049c 00       		.byte	0
 8488 049d 03       		.byte	3
 8489 049e 00       		.byte	0
 8490 049f 30       		.byte	48
 8491 04a0 01       		.byte	1
 8492 04a1 00       		.byte	0
 8493 04a2 00       		.byte	0
 8494 04a3 00000000 		.space	5
 8494      00
 8495 04a8 00       		.byte	0
 8496 04a9 00       		.byte	0
 8497 04aa 01       		.byte	1
 8498 04ab 01       		.byte	1
 8499 04ac 00       		.byte	0
 8500 04ad 0F       		.byte	15
 8501 04ae 00       		.byte	0
 8502 04af 0F       		.byte	15
 8503 04b0 00       		.byte	0
 8504 04b1 03       		.byte	3
 8505 04b2 00       		.byte	0
 8506 04b3 02       		.byte	2
 8507 04b4 00       		.byte	0
 8508 04b5 02       		.byte	2
 8509 04b6 00       		.byte	0
 8510 04b7 30       		.byte	48
 8511 04b8 01       		.byte	1
 8512 04b9 01       		.byte	1
 8513 04ba 00       		.byte	0
 8514 04bb 00000000 		.space	5
 8514      00
 8515 04c0 02       		.byte	2
 8516 04c1 00       		.byte	0
 8517 04c2 01       		.byte	1
 8518 04c3 00       		.byte	0
 8519 04c4 00       		.byte	0
 8520 04c5 01       		.byte	1
 8521 04c6 00       		.byte	0
 8522 04c7 01       		.byte	1
 8523 04c8 00       		.byte	0
 8524 04c9 03       		.byte	3
 8525 04ca 00       		.byte	0
 8526 04cb 00       		.byte	0
 8527 04cc 00       		.byte	0
 8528 04cd 00       		.byte	0
 8529 04ce 00       		.byte	0
 8530 04cf 30       		.byte	48
 8531 04d0 01       		.byte	1
 8532 04d1 01       		.byte	1
 8533 04d2 00       		.byte	0
 8534 04d3 00000000 		.space	5
 8534      00
 8535 04d8 00       		.byte	0
 8536 04d9 00       		.byte	0
 8537 04da 04       		.byte	4
 8538 04db 01       		.byte	1
 8539 04dc 00       		.byte	0
 8540 04dd 38       		.byte	56
 8541 04de 01       		.byte	1
 8542 04df 01       		.byte	1
 8543 04e0 00       		.byte	0
 8544 04e1 03       		.byte	3
 8545 04e2 00       		.byte	0
 8546 04e3 4E       		.byte	78
 8547 04e4 00       		.byte	0
 8548 04e5 4E       		.byte	78
 8549 04e6 00       		.byte	0
 8550 04e7 30       		.byte	48
 8551 04e8 01       		.byte	1
 8552 04e9 00       		.byte	0
 8553 04ea 00       		.byte	0
 8554 04eb 00000000 		.space	5
 8554      00
 8555 04f0 04       		.byte	4
 8556 04f1 00       		.byte	0
 8557 04f2 01       		.byte	1
 8558 04f3 00       		.byte	0
 8559 04f4 00       		.byte	0
 8560 04f5 00       		.byte	0
 8561 04f6 00       		.byte	0
 8562 04f7 01       		.byte	1
 8563 04f8 00       		.byte	0
 8564 04f9 03       		.byte	3
 8565 04fa 00       		.byte	0
 8566 04fb 00       		.byte	0
 8567 04fc 00       		.byte	0
 8568 04fd 00       		.byte	0
 8569 04fe 00       		.byte	0
 8570 04ff 30       		.byte	48
 8571 0500 01       		.byte	1
 8572 0501 00       		.byte	0
 8573 0502 00       		.byte	0
 8574 0503 00000000 		.space	5
 8574      00
 8575 0508 05       		.byte	5
 8576 0509 00       		.byte	0
 8577 050a 02       		.byte	2
 8578 050b 00       		.byte	0
 8579 050c 00       		.byte	0
 8580 050d FF       		.byte	-1
 8581 050e 00       		.byte	0
 8582 050f 01       		.byte	1
 8583 0510 00       		.byte	0
 8584 0511 03       		.byte	3
 8585 0512 00       		.byte	0
 8586 0513 01       		.byte	1
 8587 0514 00       		.byte	0
 8588 0515 00       		.byte	0
 8589 0516 00       		.byte	0
 8590 0517 30       		.byte	48
 8591 0518 01       		.byte	1
 8592 0519 01       		.byte	1
 8593 051a 00       		.byte	0
 8594 051b 00000000 		.space	5
 8594      00
 8595 0520 06       		.byte	6
 8596 0521 00       		.byte	0
 8597 0522 02       		.byte	2
 8598 0523 00       		.byte	0
 8599 0524 00       		.byte	0
 8600 0525 00       		.byte	0
 8601 0526 00       		.byte	0
 8602 0527 00       		.byte	0
 8603 0528 00       		.byte	0
 8604 0529 03       		.byte	3
 8605 052a 00       		.byte	0
 8606 052b 00       		.byte	0
 8607 052c 00       		.byte	0
 8608 052d 00       		.byte	0
 8609 052e 00       		.byte	0
 8610 052f 30       		.byte	48
 8611 0530 01       		.byte	1
 8612 0531 01       		.byte	1
 8613 0532 00       		.byte	0
 8614 0533 00000000 		.space	5
 8614      00
 8615 0538 23       		.byte	35
 8616 0539 00       		.byte	0
 8617 053a 02       		.byte	2
 8618 053b 00       		.byte	0
 8619 053c 00       		.byte	0
 8620 053d 30       		.byte	48
 8621 053e 00       		.byte	0
 8622 053f 01       		.byte	1
 8623 0540 00       		.byte	0
 8624 0541 03       		.byte	3
 8625 0542 0A       		.byte	10
 8626 0543 00       		.byte	0
 8627 0544 00       		.byte	0
 8628 0545 0A       		.byte	10
 8629 0546 00       		.byte	0
 8630 0547 30       		.byte	48
 8631 0548 01       		.byte	1
 8632 0549 01       		.byte	1
 8633 054a 00       		.byte	0
 8634 054b 00000000 		.space	5
 8634      00
 8635 0550 08       		.byte	8
 8636 0551 00       		.byte	0
 8637 0552 01       		.byte	1
 8638 0553 00       		.byte	0
 8639 0554 00       		.byte	0
 8640 0555 7F       		.byte	127
 8641 0556 00       		.byte	0
 8642 0557 01       		.byte	1
 8643 0558 00       		.byte	0
 8644 0559 03       		.byte	3
 8645 055a 00       		.byte	0
 8646 055b 00       		.byte	0
 8647 055c 00       		.byte	0
 8648 055d 00       		.byte	0
 8649 055e 00       		.byte	0
 8650 055f 30       		.byte	48
 8651 0560 01       		.byte	1
 8652 0561 00       		.byte	0
 8653 0562 00       		.byte	0
 8654 0563 00000000 		.space	5
 8654      00
 8655 0568 09       		.byte	9
 8656 0569 00       		.byte	0
 8657 056a 02       		.byte	2
 8658 056b 00       		.byte	0
 8659 056c 00       		.byte	0
 8660 056d 05       		.byte	5
 8661 056e 00       		.byte	0
 8662 056f 01       		.byte	1
 8663 0570 00       		.byte	0
 8664 0571 03       		.byte	3
 8665 0572 00       		.byte	0
 8666 0573 00       		.byte	0
 8667 0574 00       		.byte	0
 8668 0575 00       		.byte	0
 8669 0576 00       		.byte	0
 8670 0577 30       		.byte	48
 8671 0578 01       		.byte	1
 8672 0579 00       		.byte	0
 8673 057a 00       		.byte	0
 8674 057b 00000000 		.space	5
 8674      00
 8675 0580 10       		.byte	16
 8676 0581 00       		.byte	0
 8677 0582 03       		.byte	3
 8678 0583 00       		.byte	0
 8679 0584 00       		.byte	0
 8680 0585 00       		.byte	0
 8681 0586 00       		.byte	0
 8682 0587 00       		.byte	0
 8683 0588 00       		.byte	0
 8684 0589 03       		.byte	3
 8685 058a 00       		.byte	0
 8686 058b 00       		.byte	0
 8687 058c 00       		.byte	0
 8688 058d 00       		.byte	0
 8689 058e 00       		.byte	0
 8690 058f 30       		.byte	48
 8691 0590 01       		.byte	1
 8692 0591 00       		.byte	0
 8693 0592 00       		.byte	0
 8694 0593 00000000 		.space	5
 8694      00
 8695 0598 00       		.byte	0
 8696 0599 00       		.byte	0
 8697 059a 02       		.byte	2
 8698 059b 00       		.byte	0
 8699 059c 00       		.byte	0
 8700 059d 40       		.byte	64
 8701 059e 00       		.byte	0
 8702 059f 01       		.byte	1
 8703 05a0 00       		.byte	0
 8704 05a1 03       		.byte	3
 8705 05a2 00       		.byte	0
 8706 05a3 0F       		.byte	15
 8707 05a4 11       		.byte	17
 8708 05a5 00       		.byte	0
 8709 05a6 00       		.byte	0
 8710 05a7 30       		.byte	48
 8711 05a8 01       		.byte	1
 8712 05a9 00       		.byte	0
 8713 05aa 00       		.byte	0
 8714 05ab 00000000 		.space	5
 8714      00
 8715 05b0 00       		.byte	0
 8716 05b1 00       		.byte	0
 8717 05b2 02       		.byte	2
 8718 05b3 00       		.byte	0
 8719 05b4 00       		.byte	0
 8720 05b5 64       		.byte	100
 8721 05b6 00       		.byte	0
 8722 05b7 01       		.byte	1
 8723 05b8 00       		.byte	0
 8724 05b9 03       		.byte	3
 8725 05ba 00       		.byte	0
 8726 05bb 00       		.byte	0
 8727 05bc 00       		.byte	0
 8728 05bd 00       		.byte	0
 8729 05be 00       		.byte	0
 8730 05bf 30       		.byte	48
 8731 05c0 01       		.byte	1
 8732 05c1 00       		.byte	0
 8733 05c2 00       		.byte	0
 8734 05c3 00000000 		.space	5
 8734      00
 8735 05c8 00       		.byte	0
 8736 05c9 00       		.byte	0
 8737 05ca 02       		.byte	2
 8738 05cb 00       		.byte	0
 8739 05cc 00       		.byte	0
 8740 05cd 64       		.byte	100
 8741 05ce 00       		.byte	0
 8742 05cf 01       		.byte	1
 8743 05d0 00       		.byte	0
 8744 05d1 03       		.byte	3
 8745 05d2 00       		.byte	0
 8746 05d3 00       		.byte	0
 8747 05d4 00       		.byte	0
 8748 05d5 00       		.byte	0
 8749 05d6 00       		.byte	0
 8750 05d7 30       		.byte	48
 8751 05d8 01       		.byte	1
 8752 05d9 00       		.byte	0
 8753 05da 00       		.byte	0
 8754 05db 00000000 		.space	5
 8754      00
 8755 05e0 00       		.byte	0
 8756 05e1 00       		.byte	0
 8757 05e2 02       		.byte	2
 8758 05e3 00       		.byte	0
 8759 05e4 00       		.byte	0
 8760 05e5 64       		.byte	100
 8761 05e6 00       		.byte	0
 8762 05e7 01       		.byte	1
 8763 05e8 00       		.byte	0
 8764 05e9 03       		.byte	3
 8765 05ea 00       		.byte	0
 8766 05eb 00       		.byte	0
 8767 05ec 00       		.byte	0
 8768 05ed 00       		.byte	0
 8769 05ee 00       		.byte	0
 8770 05ef 30       		.byte	48
 8771 05f0 01       		.byte	1
 8772 05f1 00       		.byte	0
 8773 05f2 00       		.byte	0
 8774 05f3 00000000 		.space	5
 8774      00
 8775 05f8 00       		.byte	0
 8776 05f9 00       		.byte	0
 8777 05fa 02       		.byte	2
 8778 05fb 00       		.byte	0
 8779 05fc 00       		.byte	0
 8780 05fd 64       		.byte	100
 8781 05fe 00       		.byte	0
 8782 05ff 01       		.byte	1
 8783 0600 00       		.byte	0
 8784 0601 03       		.byte	3
 8785 0602 00       		.byte	0
 8786 0603 00       		.byte	0
 8787 0604 00       		.byte	0
 8788 0605 00       		.byte	0
 8789 0606 00       		.byte	0
 8790 0607 30       		.byte	48
 8791 0608 01       		.byte	1
 8792 0609 00       		.byte	0
 8793 060a 00       		.byte	0
 8794 060b 00000000 		.space	5
 8794      00
 8797              	glProbeCtrl:
 8798 0610 00       		.byte	0
 8799 0611 00       		.byte	0
 8800 0612 01       		.byte	1
 8801 0613 01       		.byte	1
 8802 0614 15       		.byte	21
 8803 0615 16       		.byte	22
 8804 0616 05       		.byte	5
 8805 0617 00       		.byte	0
 8806 0618 00       		.byte	0
 8807 0619 00       		.byte	0
 8808 061a 00       		.byte	0
 8809 061b 00       		.byte	0
 8810 061c 00       		.byte	0
 8811 061d 00       		.byte	0
 8812 061e 00       		.byte	0
 8813 061f 00       		.byte	0
 8814 0620 00       		.byte	0
 8815 0621 00       		.byte	0
 8816 0622 00       		.byte	0
 8817 0623 48       		.byte	72
 8818 0624 3F       		.byte	63
 8819 0625 00       		.byte	0
 8820 0626 00       		.byte	0
 8821 0627 40       		.byte	64
 8822 0628 00       		.byte	0
 8823 0629 00       		.byte	0
 8824 062a 0000     		.space	2
 8827              	glProbeCtrl20:
 8828 062c 00       		.byte	0
 8829 062d 00       		.byte	0
 8830 062e 01       		.byte	1
 8831 062f 01       		.byte	1
 8832 0630 80       		.byte	-128
 8833 0631 1A       		.byte	26
 8834 0632 06       		.byte	6
 8835 0633 00       		.byte	0
 8836 0634 00       		.byte	0
 8837 0635 00       		.byte	0
 8838 0636 00       		.byte	0
 8839 0637 00       		.byte	0
 8840 0638 00       		.byte	0
 8841 0639 00       		.byte	0
 8842 063a 00       		.byte	0
 8843 063b 00       		.byte	0
 8844 063c 00       		.byte	0
 8845 063d 00       		.byte	0
 8846 063e 00       		.byte	0
 8847 063f D2       		.byte	-46
 8848 0640 0F       		.byte	15
 8849 0641 00       		.byte	0
 8850 0642 00       		.byte	0
 8851 0643 40       		.byte	64
 8852 0644 00       		.byte	0
 8853 0645 00       		.byte	0
 8854 0646 0000     		.space	2
 8857              	glProbeStilCtrl:
 8858 0648 01       		.byte	1
 8859 0649 01       		.byte	1
 8860 064a 00       		.byte	0
 8861 064b 00       		.byte	0
 8862 064c 48       		.byte	72
 8863 064d 3F       		.byte	63
 8864 064e 00       		.byte	0
 8865 064f 00       		.byte	0
 8866 0650 40       		.byte	64
 8867 0651 00       		.byte	0
 8868 0652 00       		.byte	0
 8869 0653 00       		.space	1
 8872              	glProbeStilCtrl20:
 8873 0654 01       		.byte	1
 8874 0655 01       		.byte	1
 8875 0656 00       		.byte	0
 8876 0657 00       		.byte	0
 8877 0658 D2       		.byte	-46
 8878 0659 0F       		.byte	15
 8879 065a 00       		.byte	0
 8880 065b 00       		.byte	0
 8881 065c 40       		.byte	64
 8882 065d 00       		.byte	0
 8883 065e 00       		.byte	0
 8886              	snapButFlag:
 8887 065f 01       		.byte	1
 8890              	CyFxGpifTransition:
 8891 0660 0000     		.short	0
 8892 0662 5555     		.short	21845
 8893 0664 8888     		.short	-30584
 8894 0666 AAAA     		.short	-21846
 8895 0668 3333     		.short	13107
 8896 066a 0000     		.space	2
 8899              	CyFxGpifWavedata:
 8900 066c 0181731E 		.word	510886145
 8901 0670 00000000 		.word	0
 8902 0674 00000080 		.word	-2147483648
 8903 0678 00000000 		.word	0
 8904 067c 00000000 		.word	0
 8905 0680 00000000 		.word	0
 8906 0684 0201702E 		.word	779092226
 8907 0688 00010000 		.word	256
 8908 068c A0000080 		.word	-2147483488
 8909 0690 00000000 		.word	0
 8910 0694 00000000 		.word	0
 8911 0698 00000000 		.word	0
 8912 069c 0380722E 		.word	779255811
 8913 06a0 02010020 		.word	536871170
 8914 06a4 60000080 		.word	-2147483552
 8915 06a8 00000000 		.word	0
 8916 06ac 00000000 		.word	0
 8917 06b0 00000000 		.word	0
 8918 06b4 0460722E 		.word	779247620
 8919 06b8 02010024 		.word	603980034
 8920 06bc 90000080 		.word	-2147483504
 8921 06c0 0594731E 		.word	510891013
 8922 06c4 06000000 		.word	6
 8923 06c8 00000080 		.word	-2147483648
 8924 06cc 0380722E 		.word	779255811
 8925 06d0 02010020 		.word	536871170
 8926 06d4 60000080 		.word	-2147483552
 8927 06d8 0693731E 		.word	510890758
 8928 06dc 06000000 		.word	6
 8929 06e0 00000080 		.word	-2147483648
 8930 06e4 0720703E 		.word	1047535623
 8931 06e8 08010000 		.word	264
 8932 06ec 00000080 		.word	-2147483648
 8933 06f0 0820703E 		.word	1047535624
 8934 06f4 08010000 		.word	264
 8935 06f8 00000080 		.word	-2147483648
 8936 06fc 0920703E 		.word	1047535625
 8937 0700 08010000 		.word	264
 8938 0704 00000080 		.word	-2147483648
 8939 0708 0A20703E 		.word	1047535626
 8940 070c 08010000 		.word	264
 8941 0710 00000080 		.word	-2147483648
 8942 0714 0380722E 		.word	779255811
 8943 0718 02010020 		.word	536871170
 8944 071c 60000080 		.word	-2147483552
 8945 0720 0B000000 		.word	11
 8946 0724 00000000 		.word	0
 8947 0728 00010080 		.word	-2147483392
 8948 072c 0460722E 		.word	779247620
 8949 0730 02010024 		.word	603980034
 8950 0734 90000080 		.word	-2147483504
 8951 0738 0D000000 		.word	13
 8952 073c 00000000 		.word	0
 8953 0740 00010080 		.word	-2147483392
 8954 0744 0460722E 		.word	779247620
 8955 0748 02010024 		.word	603980034
 8956 074c 90000080 		.word	-2147483504
 8957 0750 0C000000 		.word	12
 8958 0754 00000000 		.word	0
 8959 0758 00010080 		.word	-2147483392
 8960 075c 0380722E 		.word	779255811
 8961 0760 02010020 		.word	536871170
 8962 0764 60000080 		.word	-2147483552
 8963 0768 0E000000 		.word	14
 8964 076c 00000000 		.word	0
 8965 0770 00010080 		.word	-2147483392
 8966 0774 00000000 		.word	0
 8967 0778 00000000 		.word	0
 8968 077c 00000000 		.word	0
 8969 0780 00000000 		.word	0
 8970 0784 00000000 		.word	0
 8971 0788 00000000 		.word	0
 8974              	CyFxGpifWavedataPosition:
 8975 078c 00       		.byte	0
 8976 078d 01       		.byte	1
 8977 078e 02       		.byte	2
 8978 078f 03       		.byte	3
 8979 0790 04       		.byte	4
 8980 0791 05       		.byte	5
 8981 0792 06       		.byte	6
 8982 0793 07       		.byte	7
 8983 0794 08       		.byte	8
 8984 0795 09       		.byte	9
 8985 0796 0A       		.byte	10
 8986 0797 0B       		.byte	11
 8987 0798 0B       		.byte	11
 8988 0799 0B       		.byte	11
 8989 079a 0B       		.byte	11
 8990 079b 00       		.space	1
 8993              	CyFxGpifRegValue:
 8994 079c 08830080 		.word	-2147450104
 8995 07a0 67000000 		.word	103
 8996 07a4 00000000 		.word	0
 8997 07a8 46000000 		.word	70
 8998 07ac 00000000 		.word	0
 8999 07b0 00000000 		.word	0
 9000 07b4 02000000 		.word	2
 9001 07b8 82000000 		.word	130
 9002 07bc 82070000 		.word	1922
 9003 07c0 40040000 		.word	1088
 9004 07c4 FCFF0000 		.word	65532
 9005 07c8 28000000 		.word	40
 9006 07cc 00000000 		.word	0
 9007 07d0 00000000 		.word	0
 9008 07d4 00000000 		.word	0
 9009 07d8 00000000 		.word	0
 9010 07dc 01000000 		.word	1
 9011 07e0 00000000 		.word	0
 9012 07e4 00000000 		.word	0
 9013 07e8 00000000 		.word	0
 9014 07ec 00000000 		.word	0
 9015 07f0 00000000 		.word	0
 9016 07f4 00000000 		.word	0
 9017 07f8 00000000 		.word	0
 9018 07fc 00000000 		.word	0
 9019 0800 00000000 		.word	0
 9020 0804 00000000 		.word	0
 9021 0808 00000000 		.word	0
 9022 080c 00000000 		.word	0
 9023 0810 06000000 		.word	6
 9024 0814 00000000 		.word	0
 9025 0818 FFFF0000 		.word	65535
 9026 081c 09010000 		.word	265
 9027 0820 00000000 		.word	0
 9028 0824 F71F0000 		.word	8183
 9029 0828 00000000 		.word	0
 9030 082c FFFF0000 		.word	65535
 9031 0830 09010000 		.word	265
 9032 0834 00000000 		.word	0
 9033 0838 F71F0000 		.word	8183
 9034 083c 00000000 		.word	0
 9035 0840 00000000 		.word	0
 9036 0844 00000000 		.word	0
 9037 0848 00000000 		.word	0
 9038 084c 00000000 		.word	0
 9039 0850 00000000 		.word	0
 9040 0854 00000000 		.word	0
 9041 0858 00000000 		.word	0
 9042 085c 00000000 		.word	0
 9043 0860 00000000 		.word	0
 9044 0864 00000000 		.word	0
 9045 0868 00000000 		.word	0
 9046 086c 00000000 		.word	0
 9047 0870 00000000 		.word	0
 9048 0874 00000000 		.word	0
 9049 0878 00000000 		.word	0
 9050 087c 00000000 		.word	0
 9051 0880 00000000 		.word	0
 9052 0884 00000000 		.word	0
 9053 0888 00000000 		.word	0
 9054 088c 00000000 		.word	0
 9055 0890 00000000 		.word	0
 9056 0894 00000000 		.word	0
 9057 0898 00040180 		.word	-2147417088
 9058 089c 01040180 		.word	-2147417087
 9059 08a0 02040180 		.word	-2147417086
 9060 08a4 03040180 		.word	-2147417085
 9061 08a8 00000000 		.word	0
 9062 08ac 00000000 		.word	0
 9063 08b0 00000000 		.word	0
 9064 08b4 00000000 		.word	0
 9065 08b8 00000000 		.word	0
 9066 08bc 00000000 		.word	0
 9067 08c0 00000000 		.word	0
 9068 08c4 00000000 		.word	0
 9069 08c8 C1FFFFFF 		.word	-63
 9072              	CyFxGpifTransition_usb2:
 9073 08cc 0000     		.short	0
 9074 08ce 5555     		.short	21845
 9075 08d0 AAAA     		.short	-21846
 9076 08d2 8888     		.short	-30584
 9077 08d4 1111     		.short	4369
 9078 08d6 4444     		.short	17476
 9079 08d8 3333     		.short	13107
 9080 08da CCCC     		.short	-13108
 9083              	CyFxGpifWavedata_usb2:
 9084 08dc 0181731E 		.word	510886145
 9085 08e0 00000000 		.word	0
 9086 08e4 00000080 		.word	-2147483648
 9087 08e8 00000000 		.word	0
 9088 08ec 00000000 		.word	0
 9089 08f0 00000000 		.word	0
 9090 08f4 0201703E 		.word	1047527682
 9091 08f8 00010000 		.word	256
 9092 08fc A00000C0 		.word	-1073741664
 9093 0900 00000000 		.word	0
 9094 0904 00000000 		.word	0
 9095 0908 00000000 		.word	0
 9096 090c 0394731E 		.word	510891011
 9097 0910 04000020 		.word	536870916
 9098 0914 60004080 		.word	-2143289248
 9099 0918 00000000 		.word	0
 9100 091c 00000000 		.word	0
 9101 0920 00000000 		.word	0
 9102 0924 0620702E 		.word	779100166
 9103 0928 0C000000 		.word	12
 9104 092c 00000080 		.word	-2147483648
 9105 0930 0620702E 		.word	779100166
 9106 0934 0C000000 		.word	12
 9107 0938 00000080 		.word	-2147483648
 9108 093c 0394731E 		.word	510891011
 9109 0940 04000020 		.word	536870916
 9110 0944 60004080 		.word	-2143289248
 9111 0948 0620702E 		.word	779100166
 9112 094c 0C000000 		.word	12
 9113 0950 00000080 		.word	-2147483648
 9114 0954 0C93731E 		.word	510890764
 9115 0958 04000024 		.word	603979780
 9116 095c 90004080 		.word	-2143289200
 9117 0960 0D20702E 		.word	779100173
 9118 0964 0C000000 		.word	12
 9119 0968 00000080 		.word	-2147483648
 9120 096c 0780724E 		.word	1316126727
 9121 0970 0A000000 		.word	10
 9122 0974 00000080 		.word	-2147483648
 9123 0978 08000000 		.word	8
 9124 097c 00000000 		.word	0
 9125 0980 00010080 		.word	-2147483392
 9126 0984 0920702E 		.word	779100169
 9127 0988 0C010000 		.word	268
 9128 098c 00000080 		.word	-2147483648
 9129 0990 0A01701E 		.word	510656778
 9130 0994 0E000100 		.word	65550
 9131 0998 00000080 		.word	-2147483648
 9132 099c 00000000 		.word	0
 9133 09a0 00000000 		.word	0
 9134 09a4 00000000 		.word	0
 9135 09a8 00000000 		.word	0
 9136 09ac 00000000 		.word	0
 9137 09b0 00000000 		.word	0
 9138 09b4 0394731E 		.word	510891011
 9139 09b8 04000020 		.word	536870916
 9140 09bc 60004080 		.word	-2143289248
 9141 09c0 08000000 		.word	8
 9142 09c4 00000000 		.word	0
 9143 09c8 00010080 		.word	-2147483392
 9144 09cc 0B000000 		.word	11
 9145 09d0 00000000 		.word	0
 9146 09d4 00010080 		.word	-2147483392
 9147 09d8 0C93731E 		.word	510890764
 9148 09dc 04000024 		.word	603979780
 9149 09e0 90004080 		.word	-2143289200
 9150 09e4 0D20702E 		.word	779100173
 9151 09e8 0C000000 		.word	12
 9152 09ec 00000080 		.word	-2147483648
 9153 09f0 0D20702E 		.word	779100173
 9154 09f4 0C000000 		.word	12
 9155 09f8 00000080 		.word	-2147483648
 9156 09fc 0E60724E 		.word	1316118542
 9157 0a00 0A000000 		.word	10
 9158 0a04 00000080 		.word	-2147483648
 9159 0a08 0F000000 		.word	15
 9160 0a0c 00000000 		.word	0
 9161 0a10 00010080 		.word	-2147483392
 9162 0a14 1020702E 		.word	779100176
 9163 0a18 0C010000 		.word	268
 9164 0a1c 00000080 		.word	-2147483648
 9165 0a20 1101701E 		.word	510656785
 9166 0a24 0E000100 		.word	65550
 9167 0a28 00000080 		.word	-2147483648
 9168 0a2c 0C93731E 		.word	510890764
 9169 0a30 04000024 		.word	603979780
 9170 0a34 90004080 		.word	-2143289200
 9171 0a38 0F000000 		.word	15
 9172 0a3c 00000000 		.word	0
 9173 0a40 00010080 		.word	-2147483392
 9174 0a44 12000000 		.word	18
 9175 0a48 00000000 		.word	0
 9176 0a4c 00010080 		.word	-2147483392
 9177 0a50 0394731E 		.word	510891011
 9178 0a54 04000020 		.word	536870916
 9179 0a58 60004080 		.word	-2143289248
 9180 0a5c 0480732E 		.word	779321348
 9181 0a60 02010000 		.word	258
 9182 0a64 000040C0 		.word	-1069547520
 9183 0a68 0580732E 		.word	779321349
 9184 0a6c 02010000 		.word	258
 9185 0a70 000040C0 		.word	-1069547520
 9186 0a74 0580732E 		.word	779321349
 9187 0a78 02010000 		.word	258
 9188 0a7c 000040C0 		.word	-1069547520
 9189 0a80 0480732E 		.word	779321348
 9190 0a84 02010000 		.word	258
 9191 0a88 000040C0 		.word	-1069547520
 9194              	CyFxGpifWavedataPosition_usb2:
 9195 0a8c 00       		.byte	0
 9196 0a8d 01       		.byte	1
 9197 0a8e 02       		.byte	2
 9198 0a8f 03       		.byte	3
 9199 0a90 04       		.byte	4
 9200 0a91 05       		.byte	5
 9201 0a92 06       		.byte	6
 9202 0a93 07       		.byte	7
 9203 0a94 08       		.byte	8
 9204 0a95 09       		.byte	9
 9205 0a96 0A       		.byte	10
 9206 0a97 08       		.byte	8
 9207 0a98 0B       		.byte	11
 9208 0a99 0C       		.byte	12
 9209 0a9a 0D       		.byte	13
 9210 0a9b 08       		.byte	8
 9211 0a9c 0E       		.byte	14
 9212 0a9d 0F       		.byte	15
 9213 0a9e 08       		.byte	8
 9214 0a9f 08       		.byte	8
 9215 0aa0 08       		.byte	8
 9216 0aa1 08       		.byte	8
 9217 0aa2 08       		.byte	8
 9218 0aa3 08       		.byte	8
 9219 0aa4 08       		.byte	8
 9220 0aa5 08       		.byte	8
 9221 0aa6 08       		.byte	8
 9222 0aa7 08       		.byte	8
 9223 0aa8 08       		.byte	8
 9224 0aa9 08       		.byte	8
 9225 0aaa 08       		.byte	8
 9226 0aab 08       		.byte	8
 9227 0aac 08       		.byte	8
 9228 0aad 08       		.byte	8
 9229 0aae 08       		.byte	8
 9230 0aaf 08       		.byte	8
 9231 0ab0 08       		.byte	8
 9232 0ab1 08       		.byte	8
 9233 0ab2 08       		.byte	8
 9234 0ab3 08       		.byte	8
 9235 0ab4 08       		.byte	8
 9236 0ab5 08       		.byte	8
 9237 0ab6 08       		.byte	8
 9238 0ab7 08       		.byte	8
 9239 0ab8 08       		.byte	8
 9240 0ab9 08       		.byte	8
 9241 0aba 08       		.byte	8
 9242 0abb 08       		.byte	8
 9243 0abc 08       		.byte	8
 9244 0abd 08       		.byte	8
 9245 0abe 08       		.byte	8
 9246 0abf 08       		.byte	8
 9247 0ac0 08       		.byte	8
 9248 0ac1 08       		.byte	8
 9249 0ac2 08       		.byte	8
 9250 0ac3 08       		.byte	8
 9251 0ac4 08       		.byte	8
 9252 0ac5 08       		.byte	8
 9253 0ac6 08       		.byte	8
 9254 0ac7 08       		.byte	8
 9255 0ac8 08       		.byte	8
 9256 0ac9 08       		.byte	8
 9257 0aca 08       		.byte	8
 9258 0acb 08       		.byte	8
 9259 0acc 08       		.byte	8
 9260 0acd 08       		.byte	8
 9261 0ace 08       		.byte	8
 9262 0acf 08       		.byte	8
 9263 0ad0 08       		.byte	8
 9264 0ad1 08       		.byte	8
 9265 0ad2 08       		.byte	8
 9266 0ad3 08       		.byte	8
 9267 0ad4 08       		.byte	8
 9268 0ad5 08       		.byte	8
 9269 0ad6 08       		.byte	8
 9270 0ad7 08       		.byte	8
 9271 0ad8 08       		.byte	8
 9272 0ad9 08       		.byte	8
 9273 0ada 08       		.byte	8
 9274 0adb 08       		.byte	8
 9275 0adc 08       		.byte	8
 9276 0add 08       		.byte	8
 9277 0ade 08       		.byte	8
 9278 0adf 08       		.byte	8
 9279 0ae0 08       		.byte	8
 9280 0ae1 08       		.byte	8
 9281 0ae2 08       		.byte	8
 9282 0ae3 08       		.byte	8
 9283 0ae4 08       		.byte	8
 9284 0ae5 08       		.byte	8
 9285 0ae6 08       		.byte	8
 9286 0ae7 08       		.byte	8
 9287 0ae8 08       		.byte	8
 9288 0ae9 08       		.byte	8
 9289 0aea 08       		.byte	8
 9290 0aeb 08       		.byte	8
 9291 0aec 08       		.byte	8
 9292 0aed 08       		.byte	8
 9293 0aee 08       		.byte	8
 9294 0aef 08       		.byte	8
 9295 0af0 08       		.byte	8
 9296 0af1 08       		.byte	8
 9297 0af2 08       		.byte	8
 9298 0af3 08       		.byte	8
 9299 0af4 08       		.byte	8
 9300 0af5 08       		.byte	8
 9301 0af6 08       		.byte	8
 9302 0af7 08       		.byte	8
 9303 0af8 08       		.byte	8
 9304 0af9 08       		.byte	8
 9305 0afa 08       		.byte	8
 9306 0afb 08       		.byte	8
 9307 0afc 08       		.byte	8
 9308 0afd 08       		.byte	8
 9309 0afe 08       		.byte	8
 9310 0aff 08       		.byte	8
 9311 0b00 08       		.byte	8
 9312 0b01 08       		.byte	8
 9313 0b02 08       		.byte	8
 9314 0b03 08       		.byte	8
 9315 0b04 08       		.byte	8
 9316 0b05 08       		.byte	8
 9317 0b06 08       		.byte	8
 9318 0b07 08       		.byte	8
 9319 0b08 08       		.byte	8
 9320 0b09 08       		.byte	8
 9321 0b0a 08       		.byte	8
 9322 0b0b 08       		.byte	8
 9323 0b0c 00       		.byte	0
 9324 0b0d 01       		.byte	1
 9325 0b0e 02       		.byte	2
 9326 0b0f 10       		.byte	16
 9327 0b10 04       		.byte	4
 9328 0b11 05       		.byte	5
 9329 0b12 06       		.byte	6
 9330 0b13 07       		.byte	7
 9331 0b14 08       		.byte	8
 9332 0b15 09       		.byte	9
 9333 0b16 0A       		.byte	10
 9334 0b17 08       		.byte	8
 9335 0b18 11       		.byte	17
 9336 0b19 0C       		.byte	12
 9337 0b1a 0D       		.byte	13
 9338 0b1b 08       		.byte	8
 9339 0b1c 0E       		.byte	14
 9340 0b1d 0F       		.byte	15
 9341 0b1e 08       		.byte	8
 9342 0b1f 00       		.space	1
 9345              	CyFxGpifRegValue_usb2:
 9346 0b20 08830080 		.word	-2147450104
 9347 0b24 67000000 		.word	103
 9348 0b28 01000000 		.word	1
 9349 0b2c 46000000 		.word	70
 9350 0b30 00000000 		.word	0
 9351 0b34 00000000 		.word	0
 9352 0b38 02000000 		.word	2
 9353 0b3c 82000000 		.word	130
 9354 0b40 82070000 		.word	1922
 9355 0b44 40040000 		.word	1088
 9356 0b48 FCFF0000 		.word	65532
 9357 0b4c 28000000 		.word	40
 9358 0b50 00000000 		.word	0
 9359 0b54 00000000 		.word	0
 9360 0b58 00000000 		.word	0
 9361 0b5c 00000000 		.word	0
 9362 0b60 01000000 		.word	1
 9363 0b64 00000000 		.word	0
 9364 0b68 00000000 		.word	0
 9365 0b6c 00000000 		.word	0
 9366 0b70 00000000 		.word	0
 9367 0b74 00000000 		.word	0
 9368 0b78 00000000 		.word	0
 9369 0b7c 00000000 		.word	0
 9370 0b80 00000000 		.word	0
 9371 0b84 00000000 		.word	0
 9372 0b88 00000000 		.word	0
 9373 0b8c 00000000 		.word	0
 9374 0b90 00000000 		.word	0
 9375 0b94 06000000 		.word	6
 9376 0b98 00000000 		.word	0
 9377 0b9c FFFF0000 		.word	65535
 9378 0ba0 09010000 		.word	265
 9379 0ba4 00000000 		.word	0
 9380 0ba8 F71F0000 		.word	8183
 9381 0bac 00000000 		.word	0
 9382 0bb0 FFFF0000 		.word	65535
 9383 0bb4 09010000 		.word	265
 9384 0bb8 00000000 		.word	0
 9385 0bbc F71F0000 		.word	8183
 9386 0bc0 00000000 		.word	0
 9387 0bc4 00000000 		.word	0
 9388 0bc8 00000000 		.word	0
 9389 0bcc 00000000 		.word	0
 9390 0bd0 00000000 		.word	0
 9391 0bd4 00000000 		.word	0
 9392 0bd8 00000000 		.word	0
 9393 0bdc 00000000 		.word	0
 9394 0be0 00000000 		.word	0
 9395 0be4 00000000 		.word	0
 9396 0be8 00000000 		.word	0
 9397 0bec 00000000 		.word	0
 9398 0bf0 00000000 		.word	0
 9399 0bf4 00000000 		.word	0
 9400 0bf8 00000000 		.word	0
 9401 0bfc 00000000 		.word	0
 9402 0c00 00000000 		.word	0
 9403 0c04 00000000 		.word	0
 9404 0c08 00000000 		.word	0
 9405 0c0c 00000000 		.word	0
 9406 0c10 00000000 		.word	0
 9407 0c14 00000000 		.word	0
 9408 0c18 00000000 		.word	0
 9409 0c1c 00040180 		.word	-2147417088
 9410 0c20 01040180 		.word	-2147417087
 9411 0c24 02040180 		.word	-2147417086
 9412 0c28 03040180 		.word	-2147417085
 9413 0c2c 00000000 		.word	0
 9414 0c30 00000000 		.word	0
 9415 0c34 00000000 		.word	0
 9416 0c38 00000000 		.word	0
 9417 0c3c 00000000 		.word	0
 9418 0c40 00000000 		.word	0
 9419 0c44 00000000 		.word	0
 9420 0c48 00000000 		.word	0
 9421 0c4c C1FFFFFF 		.word	-63
 9422              		.section	.rodata.str1.4,"aMS",%progbits,1
 9423              		.align	2
 9424              	.LC0:
 9425 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9425      7065722D 
 9425      74696D65 
 9425      72202564 
 9425      0D0A00
 9426 0013 00       		.space	1
 9427              	.LC1:
 9428 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9428      636F6D6D 
 9428      616E6420 
 9428      71756575 
 9428      65206973 
 9429 0037 00       		.space	1
 9430              	.LC2:
 9431 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9431      7220696E 
 9431      206D756C 
 9431      74696368 
 9431      616E6E65 
 9432 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 9432      2C20646D 
 9432      61446F6E 
 9432      65202578 
 9432      0D0A00
 9433 007e 0000     		.space	2
 9434              	.LC3:
 9435 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9435      5420656E 
 9435      636F756E 
 9435      74657265 
 9435      642E2E2E 
 9436              	.LC4:
 9437 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9437      454E4420 
 9437      656E636F 
 9437      756E7465 
 9437      7265642E 
 9438 00c2 0000     		.space	2
 9439              	.LC5:
 9440 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9440      64697363 
 9440      6F6E6E65 
 9440      63746564 
 9440      2E2E2E30 
 9441 00e3 00       		.space	1
 9442              	.LC6:
 9443 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9443      43595F46 
 9443      585F5556 
 9443      435F5649 
 9443      44454F5F 
 9444 0117 0A00     		.ascii	"\012\000"
 9445 0119 000000   		.space	3
 9446              	.LC7:
 9447 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9447      43595F46 
 9447      585F5556 
 9447      435F5649 
 9447      44454F5F 
 9448 014f 00       		.ascii	"\000"
 9449              	.LC8:
 9450 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9450      726E6174 
 9450      65207365 
 9450      7474696E 
 9450      6720302E 
 9451              	.LC9:
 9452 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9452      72206665 
 9452      61747572 
 9452      65207265 
 9452      71756573 
 9453 018b 00       		.space	1
 9454              	.LC10:
 9455 018c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9455      6F6D6D69 
 9455      74656F66 
 9455      20737461 
 9455      7465203D 
 9456              	.LC11:
 9457 01a4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9457      6E656C20 
 9457      53657420 
 9457      57726170 
 9457      55702066 
 9458 01d1 000000   		.space	3
 9459              	.LC12:
 9460 01d4 4572726F 		.ascii	"Error handler...\015\012\000"
 9460      72206861 
 9460      6E646C65 
 9460      722E2E2E 
 9460      0D0A00
 9461 01e7 00       		.space	1
 9462              	.LC13:
 9463 01e8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9463      69742045 
 9463      4F462066 
 9463      61696C65 
 9463      64210A00 
 9464              	.LC14:
 9465 01fc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9465      49324320 
 9465      636F6D6D 
 9465      616E6420 
 9465      69732030 
 9466 022f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9466      78257820 
 9466      30782578 
 9466      20307825 
 9466      78203078 
 9467              	.LC15:
 9468 0248 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9468      206C6967 
 9468      68742063 
 9468      6F6D7065 
 9468      6E736174 
 9469 027b 25640D0A 		.ascii	"%d\015\012\000"
 9469      00
 9470              	.LC16:
 9471 0280 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9471      49324320 
 9471      63757272 
 9471      656E7420 
 9471      64617461 
 9472 02b3 64202564 		.ascii	"d %d\015\012\000"
 9472      0D0A00
 9473 02ba 0000     		.space	2
 9474              	.LC17:
 9475 02bc 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9475      26414743 
 9475      2073656E 
 9475      7420746F 
 9475      20686F73 
 9476 02e2 0000     		.space	2
 9477              	.LC18:
 9478 02e4 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9478      26414743 
 9478      20676F74 
 9478      74656E20 
 9478      66726F6D 
 9479 030e 0000     		.space	2
 9480              	.LC19:
 9481 0310 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 9481      6C657665 
 9481      6C2E2025 
 9481      64202564 
 9481      3B202564 
 9482 032a 0000     		.space	2
 9483              	.LC20:
 9484 032c 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 9484      7365742E 
 9484      20256420 
 9484      25643B20 
 9484      25642025 
 9485              	.LC21:
 9486 0344 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9486      67657420 
 9486      64617461 
 9486      2066726F 
 9486      6D20686F 
 9487 0371 000000   		.space	3
 9488              	.LC22:
 9489 0374 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9489      52657175 
 9489      65737420 
 9489      30782578 
 9489      20706172 
 9490 03a7 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9490      6E642074 
 9490      6F20686F 
 9490      73742030 
 9490      78257820 
 9491 03c2 0000     		.space	2
 9492              	.LC23:
 9493 03c4 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9493      204F7020 
 9493      72656365 
 9493      69766573 
 9493      20284354 
 9494 03eb 00       		.space	1
 9495              	.LC24:
 9496 03ec 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9496      756C7420 
 9496      73656C65 
 9496      63746F72 
 9496      20284354 
 9497 040e 0000     		.space	2
 9498              	.LC25:
 9499 0410 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9499      756C7420 
 9499      72657175 
 9499      65737420 
 9499      28435429 
 9500 0431 000000   		.space	3
 9501              	.LC26:
 9502 0434 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9502      52657175 
 9502      65737420 
 9502      30782578 
 9502      20706172 
 9503 0467 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9503      20307825 
 9503      78202F20 
 9503      73656E64 
 9503      20746F20 
 9504 0494 00       		.ascii	"\000"
 9505 0495 000000   		.space	3
 9506              	.LC27:
 9507 0498 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9507      73706565 
 9507      64203D20 
 9507      25642065 
 9507      76656E66 
 9508 04c8 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9508      71756573 
 9508      74203D20 
 9508      30782578 
 9508      20775661 
 9509 04f8 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9509      203D2030 
 9509      78257820 
 9509      6973666C 
 9509      61672030 
 9510 0512 0000     		.space	2
 9511              	.LC28:
 9512 0514 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9512      64656661 
 9512      756C7420 
 9512      73657475 
 9512      70207265 
 9513              	.LC29:
 9514 0540 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9514      43595F46 
 9514      585F5556 
 9514      435F5354 
 9514      5245414D 
 9515 0566 0000     		.space	2
 9516              	.LC30:
 9517 0568 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9517      55564320 
 9517      7374696C 
 9517      6C207472 
 9517      69676765 
 9518 058e 0000     		.space	2
 9519              	.LC31:
 9520 0590 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9520      7374696C 
 9520      6C207472 
 9520      69676765 
 9520      7220636F 
 9521 05b7 00       		.space	1
 9522              	.LC32:
 9523 05b8 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9523      65642074 
 9523      6F207365 
 9523      6E642069 
 9523      6E746572 
 9524 05e9 0A00     		.ascii	"\012\000"
 9525 05eb 00       		.space	1
 9526              	.LC33:
 9527 05ec 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9527      73657420 
 9527      64656620 
 9527      64617461 
 9527      20307825 
 9528 060b 00       		.space	1
 9529              	.LC34:
 9530 060c 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9530      73657420 
 9530      64656620 
 9530      64617461 
 9530      20307825 
 9531 063f 2E0D0A00 		.ascii	".\015\012\000"
 9532 0643 00       		.space	1
 9533              	.LC35:
 9534 0644 55415254 		.ascii	"UART initialization failed!\012\000"
 9534      20696E69 
 9534      7469616C 
 9534      697A6174 
 9534      696F6E20 
 9535 0661 000000   		.space	3
 9536              	.LC36:
 9537 0664 49324320 		.ascii	"I2C initialization failed!\012\000"
 9537      696E6974 
 9537      69616C69 
 9537      7A617469 
 9537      6F6E2066 
 9538              	.LC37:
 9539 0680 49324320 		.ascii	"I2C configuration failed!\012\000"
 9539      636F6E66 
 9539      69677572 
 9539      6174696F 
 9539      6E206661 
 9540 069b 00       		.space	1
 9541              	.LC38:
 9542 069c 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9542      43726561 
 9542      74652045 
 9542      76656E74 
 9542      20666169 
 9543 06c6 0000     		.space	2
 9544              	.LC39:
 9545 06c8 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9545      20496E69 
 9545      74206661 
 9545      696C6564 
 9545      2C204572 
 9546 06eb 00       		.space	1
 9547              	.LC40:
 9548 06ec 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9548      204F7665 
 9548      72726964 
 9548      65206661 
 9548      696C6564 
 9549 0713 00       		.space	1
 9550              	.LC41:
 9551 0714 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9551      28323029 
 9551      204F7665 
 9551      72726964 
 9551      65206661 
 9552 073f 00       		.space	1
 9553              	.LC42:
 9554 0740 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9554      28323429 
 9554      204F7665 
 9554      72726964 
 9554      65206661 
 9555 076b 00       		.space	1
 9556              	.LC43:
 9557 076c 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9557      20536574 
 9557      20287265 
 9557      73657420 
 9557      32322920 
 9558 079e 00       		.ascii	"\000"
 9559 079f 00       		.space	1
 9560              	.LC44:
 9561 07a0 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9561      20536574 
 9561      2028706F 
 9561      77657220 
 9561      32302920 
 9562 07d2 00       		.ascii	"\000"
 9563 07d3 00       		.space	1
 9564              	.LC45:
 9565 07d4 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9565      20536574 
 9565      2028736E 
 9565      61702073 
 9565      686F7420 
 9566 0807 25640A00 		.ascii	"%d\012\000"
 9567 080b 00       		.space	1
 9568              	.LC46:
 9569 080c 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9569      46756E63 
 9569      74696F6E 
 9569      20466169 
 9569      6C656420 
 9570 083b 00       		.space	1
 9571              	.LC47:
 9572 083c 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9572      46756E63 
 9572      74696F6E 
 9572      20466169 
 9572      6C656420 
 9573 086b 00       		.space	1
 9574              	.LC48:
 9575 086c 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9575      53657420 
 9575      456E6470 
 9575      6F696E74 
 9575      20636F6E 
 9576 089c 00       		.ascii	"\000"
 9577 089d 000000   		.space	3
 9578              	.LC49:
 9579 08a0 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9579      496E7465 
 9579      72727570 
 9579      74205374 
 9579      61747573 
 9580 08d3 20436F64 		.ascii	" Code = %d\012\000"
 9580      65203D20 
 9580      25640A00 
 9581 08df 00       		.space	1
 9582              	.LC50:
 9583 08e0 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9583      65642074 
 9583      6F20616C 
 9583      6C6F6361 
 9583      7465206D 
 9584 0913 65720D0A 		.ascii	"er\015\012\000"
 9584      00
 9585              	.LC51:
 9586 0918 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9586      4368616E 
 9586      6E656C20 
 9586      43726561 
 9586      74696F6E 
 9587 0946 0000     		.space	2
 9588              	.LC52:
 9589 0948 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9589      436F6E6E 
 9589      65637420 
 9589      6661696C 
 9589      65642C20 
 9590 096d 000000   		.space	3
 9591              	.LC53:
 9592 0970 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9592      4368616E 
 9592      6E656C20 
 9592      52657365 
 9592      74204661 
 9593 099b 00       		.space	1
 9594              	.LC54:
 9595 099c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9595      4368616E 
 9595      6E656C20 
 9595      53657420 
 9595      5472616E 
 9596 09cd 00       		.ascii	"\000"
 9597 09ce 0000     		.space	2
 9598              	.LC55:
 9599 09d0 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9599      4368616E 
 9599      6E656C20 
 9599      53657420 
 9599      5472616E 
 9600 0a01 0A00     		.ascii	"\012\000"
 9601 0a03 00       		.space	1
 9602              	.LC56:
 9603 0a04 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9603      75706572 
 9603      20677069 
 9603      6600
 9604 0a12 0000     		.space	2
 9605              	.LC57:
 9606 0a14 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9606      69676820 
 9606      67706966 
 9606      00
 9607 0a21 000000   		.space	3
 9608              	.LC58:
 9609 0a24 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9609      696E6720 
 9609      47504946 
 9609      20436F6E 
 9609      66696775 
 9610 0a57 0A00     		.ascii	"\012\000"
 9611 0a59 000000   		.space	3
 9612              	.LC59:
 9613 0a5c 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9613      74696E67 
 9613      20475049 
 9613      46207374 
 9613      61746520 
 9614 0a8f 0D0A00   		.ascii	"\015\012\000"
 9615 0a92 0000     		.space	2
 9616              	.LC60:
 9617 0a94 33303A55 		.ascii	"30:UVC App Thread\000"
 9617      56432041 
 9617      70702054 
 9617      68726561 
 9617      6400
 9618 0aa6 0000     		.space	2
 9619              	.LC61:
 9620 0aa8 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9620      56432041 
 9620      70702045 
 9620      50302054 
 9620      68726561 
 9621 0abe 0000     		.space	2
 9622              	.LC62:
 9623 0ac0 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9623      32432041 
 9623      70702043 
 9623      54524C20 
 9623      54687265 
 9624 0ad7 00       		.bss
 9625              		.align	2
 9626              		.set	.LANCHOR0,. + 0
 9629              	glFxUVCEvent:
 9630 0000 00000000 		.space	40
 9630      00000000 
 9630      00000000 
 9630      00000000 
 9630      00000000 
 9633              	fb:
 9634 0028 0000     		.space	2
 9637              	pb:
 9638 002a 0000     		.space	2
 9641              	pbc:
 9642 002c 0000     		.space	2
 9645              	prodCount:
 9646 002e 0000     		.space	2
 9649              	consCount:
 9650 0030 0000     		.space	2
 9651 0032 0000     		.space	2
 9654              	streamingStarted:
 9655 0034 00000000 		.space	4
 9658              	gpif_initialized:
 9659 0038 00000000 		.space	4
 9662              	isUsbConnected:
 9663 003c 00000000 		.space	4
 9666              	clearFeatureRqtReceived:
 9667 0040 00000000 		.space	4
 9670              	hitFV:
 9671 0044 00000000 		.space	4
 9674              	usbSpeed:
 9675 0048 00       		.space	1
 9676 0049 000000   		.space	3
 9679              	I2CCMDArry:
 9680 004c 00000000 		.space	12
 9680      00000000 
 9680      00000000 
 9683              	glEp0Buffer:
 9684 0058 00000000 		.space	32
 9684      00000000 
 9684      00000000 
 9684      00000000 
 9684      00000000 
 9687              	WDRflag:
 9688 0078 00000000 		.space	4
 9691              	glCommitCtrl:
 9692 007c 00000000 		.space	32
 9692      00000000 
 9692      00000000 
 9692      00000000 
 9692      00000000 
 9695              	stiflag:
 9696 009c 00000000 		.space	4
 9699              	uvcAppThread:
 9700 00a0 00000000 		.space	168
 9700      00000000 
 9700      00000000 
 9700      00000000 
 9700      00000000 
 9703              	uvcAppEP0Thread:
 9704 0148 00000000 		.space	168
 9704      00000000 
 9704      00000000 
 9704      00000000 
 9704      00000000 
 9707              	i2cAppThread:
 9708 01f0 00000000 		.space	168
 9708      00000000 
 9708      00000000 
 9708      00000000 
 9708      00000000 
 9711              	testSnap:
 9712 0298 00       		.space	1
 9713 0299 00       		.space	1
 9716              	fbbak:
 9717 029a 0000     		.space	2
 9720              	pbbak:
 9721 029c 0000     		.space	2
 9724              	pbcbak:
 9725 029e 0000     		.space	2
 9728              	pbcpbak:
 9729 02a0 0000     		.space	2
 9730 02a2 0000     		.text
 9731              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:282    .text:0000020c $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:296    .text:0000022c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:293    .text:0000022c $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:315    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:319    .text:00000240 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:322    .text:00000240 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:480    .text:00000368 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:488    .text:0000037c $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:490    .text:0000037c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:669    .text:000004dc $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:678    .text:000004ec $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:680    .text:000004ec CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1005   .text:000007b4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1021   .text:000007e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1024   .text:000007e0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1070   .text:0000081c $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1083   .text:00000848 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1146   .text:000008b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1153   .text:000008c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1164   .text:000008e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1167   .text:000008e0 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1293   .text:000009ec $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1298   .text:000009f4 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1301   .text:000009f4 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1364   .text:00000a74 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1576   .text:00000c1c $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1618   .text:00000cb8 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1683   .text:00000d3c $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:1723   .text:00000dd4 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3001   .text:000019f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3021   .text:00001a34 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3024   .text:00001a34 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3192   .text:00001b90 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3205   .text:00001bb8 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3700   .text:000020c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3711   .text:000020e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3966   .text:000023a0 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3979   .text:000023c8 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:3982   .text:000023c8 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:4044   .text:00002444 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:4052   .text:00002454 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5177   .text:00002da0 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5204   .text:00002df8 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5207   .text:00002df8 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5498   .text:000030b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5505   .text:000030c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5508   .text:000030c0 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5544   .text:000030ec $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5548   .text:000030f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5551   .text:000030f0 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5576   .text:0000310c $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5580   .text:00003110 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:5583   .text:00003110 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:6962   .text:00003bd4 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7022   .text:00003ca8 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7025   .text:00003ca8 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7108   .text:00003d34 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7117   .text:00003d44 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7120   .text:00003d44 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7277   .text:00003ebc $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7293   .text:00003ef0 $a
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7296   .text:00003ef0 main
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8890   .data:00000660 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8899   .data:0000066c CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8974   .data:0000078c CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8993   .data:0000079c CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7457   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9072   .data:000008cc CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9083   .data:000008dc CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9194   .data:00000a8c CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9345   .data:00000b20 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7470   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8886   .data:0000065f snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9711   .bss:00000298 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9633   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9637   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9641   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9716   .bss:0000029a fbbak
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9720   .bss:0000029c pbbak
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9724   .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9728   .bss:000002a0 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9662   .bss:0000003c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9674   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9666   .bss:00000040 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9654   .bss:00000034 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8797   .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8857   .data:00000648 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8827   .data:0000062c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8872   .data:00000654 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8452   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7434   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7438   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7482   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7486   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:7809   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8467   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:8474   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9423   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9625   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9629   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9645   .bss:0000002e prodCount
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9649   .bss:00000030 consCount
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9658   .bss:00000038 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9670   .bss:00000044 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9679   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9683   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9687   .bss:00000078 WDRflag
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9691   .bss:0000007c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9695   .bss:0000009c stiflag
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9699   .bss:000000a0 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9703   .bss:00000148 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccm0hoq8.s:9707   .bss:000001f0 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
