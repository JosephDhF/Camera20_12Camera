   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** 
 105:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 106:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 107:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 108:../uvc.c      ****                                                            received. */
 109:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 110:../uvc.c      **** #ifdef BACKFLOW_DETECT
 111:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 112:../uvc.c      **** #endif
 113:../uvc.c      **** 
 114:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 115:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 116:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 117:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 118:../uvc.c      **** #endif
 119:../uvc.c      **** 
 120:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 121:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 122:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 123:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 125:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 126:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 127:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 128:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 129:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 131:../uvc.c      ****                                    with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 133:../uvc.c      ****                                    streaming with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 135:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 136:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 137:../uvc.c      **** };
 138:../uvc.c      **** 
 139:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 140:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 141:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 143:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 144:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 145:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 146:../uvc.c      **** };
 147:../uvc.c      **** 
 148:../uvc.c      **** 
 149:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 150:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 151:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 152:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 154:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 155:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 156:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 157:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 158:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 159:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 160:../uvc.c      ****                                    with adjustable compression parameters */
 161:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 162:../uvc.c      ****                                    streaming with adjustable compression parameters */
 163:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 164:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 169:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 170:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 171:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 172:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 173:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 174:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 175:../uvc.c      **** };
 176:../uvc.c      **** 
 177:../uvc.c      **** 
 178:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 179:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 180:../uvc.c      **** 
 181:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 182:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 183:../uvc.c      **** {
 184:../uvc.c      ****     0x0C,                               /* Header Length */
 185:../uvc.c      ****     0x8C,                               /* Bit field header field */
 186:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 188:../uvc.c      **** };
 189:../uvc.c      **** 
 190:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 191:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 192:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 193:../uvc.c      ****                                                            the current video frame. */
 194:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 195:../uvc.c      **** #ifndef CAM720
 196:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 197:../uvc.c      **** #else
 198:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 199:../uvc.c      **** #endif
 200:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 201:../uvc.c      **** 
 202:../uvc.c      **** /************ control parameters array ***********
 203:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 204:../uvc.c      ****  *    e.g.
 205:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 206:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 207:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 208:../uvc.c      ****  **************************************************/
 209:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 210:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 211:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 212:../uvc.c      **** #ifndef CAM720
 213:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 214:../uvc.c      **** #else
 215:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 216:../uvc.c      **** #endif
 217:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0,
 218:../uvc.c      **** 		{/*2*/ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0,
 219:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 220:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 221:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 222:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 223:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,
 224:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 225:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 228:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 229:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 233:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** #ifndef CAM720
 235:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 236:../uvc.c      **** #else
 237:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 238:../uvc.c      **** #endif
 239:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 240:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 241:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 242:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 244:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 246:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg1     , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 247:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 248:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		/**********************************
 252:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 253:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 254:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 255:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 256:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 257:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 258:../uvc.c      **** 		 *
 259:../uvc.c      **** 		 *********************************/
 260:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 261:../uvc.c      **** };
 262:../uvc.c      **** 
 263:../uvc.c      **** #ifndef CAM720
 264:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 265:../uvc.c      **** #else
 266:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 267:../uvc.c      **** #endif
 268:../uvc.c      **** 
 269:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 270:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 271:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 272:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 273:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 274:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 275:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 276:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 277:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 278:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 279:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 280:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 281:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 282:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 285:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** };
 287:../uvc.c      **** 
 288:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 289:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 290:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 291:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 292:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 293:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 294:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 295:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 296:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 297:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 298:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 299:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 300:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 302:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 303:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 304:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** };
 308:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 309:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 310:../uvc.c      **** /*
 311:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 312:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 313:../uvc.c      ****  */
 314:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 315:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 316:../uvc.c      **** };
 317:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 318:../uvc.c      **** 		0
 319:../uvc.c      **** };
 320:../uvc.c      **** 
 321:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 322:../uvc.c      **** 
 323:../uvc.c      **** void I2CCmdHandler(){
 324:../uvc.c      **** 	uint8_t buf[2];
 325:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 327:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 329:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 330:../uvc.c      **** 
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 332:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 333:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 334:../uvc.c      **** 
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 336:../uvc.c      **** 	{
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 338:../uvc.c      **** #if 0 //for debugging
 339:../uvc.c      **** 		/* test still image operation */
 340:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 341:../uvc.c      **** 			snapButFlag = 0; //press
 342:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 343:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 344:../uvc.c      **** 			snapButFlag = 0xf; //release
 345:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 346:../uvc.c      **** 		}
 347:../uvc.c      **** 
 348:../uvc.c      **** 		/* end of the test */
 349:../uvc.c      **** #endif
 350:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 355:../uvc.c      **** 			}
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 357:../uvc.c      **** 		}else{//not support currently
 358:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 359:../uvc.c      **** 		}
 360:../uvc.c      **** 	}else if(CmdType == 1){
 361:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 362:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 363:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 364:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 365:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 366:../uvc.c      **** 			}
 367:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 368:../uvc.c      **** 		}else{//not support currently
 369:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 370:../uvc.c      **** 		}
 371:../uvc.c      **** 
 372:../uvc.c      **** 	}
 373:../uvc.c      **** }
 374:../uvc.c      **** 
 375:../uvc.c      **** /************************************
 376:../uvc.c      ****  * set Iris mode
 377:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 378:../uvc.c      ****  */
 379:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 380:../uvc.c      **** 	uint8_t dataIdx;
 381:../uvc.c      **** 	  dataIdx = 0;
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 386:../uvc.c      **** }
 387:../uvc.c      **** 
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 389:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 390:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 391:../uvc.c      ****     uint16_t readCount;
 392:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 393:../uvc.c      ****     uint8_t devAdd;
 394:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 395:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 396:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 397:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 398:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 399:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 400:../uvc.c      ****     }else{
 401:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 402:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 403:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 404:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 405:../uvc.c      ****     }
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 407:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 408:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 409:../uvc.c      **** #endif
 410:../uvc.c      ****     reqData = bRequest;
 411:../uvc.c      ****     /*
 412:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 413:../uvc.c      ****      */
 414:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 415:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 416:../uvc.c      ****     	goto EndofSet;
 417:../uvc.c      ****     }
 418:../uvc.c      ****     switch (bRequest)
 419:../uvc.c      **** 		 {
 420:../uvc.c      **** 
 421:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 422:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 423:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 424:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 425:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 426:../uvc.c      **** 			  break;
 427:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 428:../uvc.c      **** 
 429:../uvc.c      **** 			 switch(CtrlID)
 430:../uvc.c      **** 			 {
 431:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 432:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 433:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 434:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 435:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 436:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 437:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 438:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 439:../uvc.c      **** 			 	 		 break;
 440:../uvc.c      **** 			 	 }
 441:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 442:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 443:../uvc.c      **** 					 if(CamMode == 1){//720p
 444:../uvc.c      **** 						if(sendData >= 3){
 445:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 446:../uvc.c      **** 							sendData = 0; //set back to default
 447:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 448:../uvc.c      **** 						}
 449:../uvc.c      **** 						sendData += 4;
 450:../uvc.c      **** 					 }
 451:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 452:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 453:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 454:../uvc.c      **** 					 break;
 455:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 456:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 457:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 458:../uvc.c      **** 			 		 }
 459:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 460:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 461:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 462:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 463:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 464:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 465:../uvc.c      **** #endif
 466:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 467:../uvc.c      **** 			 		 {
 468:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 469:../uvc.c      **** 			 		 }
 470:../uvc.c      **** 			 		 break;
 471:../uvc.c      **** 				 case ExtAexModCtlID9:
 472:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 474:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 475:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 476:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 477:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 478:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 479:../uvc.c      **** 					 break;
 480:../uvc.c      **** 
 481:../uvc.c      **** 			 	 case BrgtCtlID1:
 482:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 483:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 484:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 485:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 486:../uvc.c      **** 					 }else{
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 488:../uvc.c      **** 					 }
 489:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 490:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 491:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 492:../uvc.c      **** 					 break;
 493:../uvc.c      **** 				 case HueCtlID5:
 494:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 495:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 497:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 498:../uvc.c      **** 					 break;
 499:../uvc.c      **** 				 case WBTLevCtlID11:
 500:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 502:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 503:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 504:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 505:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 506:../uvc.c      **** 					 break;
 507:../uvc.c      **** 				 case SaturCtlID6:
 508:../uvc.c      **** 				 default:
 509:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 510:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 511:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 512:../uvc.c      **** 					 break;
 513:../uvc.c      **** 			 }
 514:../uvc.c      **** 
 515:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 516:../uvc.c      **** 
 517:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 518:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 519:../uvc.c      **** #endif
 520:../uvc.c      **** 			  break;
 521:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 522:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 523:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 524:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 525:../uvc.c      **** 		 	 }
 526:../uvc.c      **** 
 527:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 528:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 529:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 530:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 531:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 532:../uvc.c      **** 			 }else
 533:../uvc.c      **** 			 {
 534:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 535:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 536:../uvc.c      **** 			 }
 537:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 538:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 539:../uvc.c      **** 			  break;
 540:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 541:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 542:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 543:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 544:../uvc.c      **** 		 	 }
 545:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 546:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 547:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 548:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 549:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 550:../uvc.c      **** 			 }else
 551:../uvc.c      **** 			 {
 552:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 553:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 554:../uvc.c      **** 			 }
 555:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 556:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 557:../uvc.c      **** 			  break;
 558:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 559:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 561:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 562:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 563:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 564:../uvc.c      **** 		 	 }
 565:../uvc.c      **** 		 	 else{
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 567:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 568:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 569:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 570:../uvc.c      **** 		 	 }
 571:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 572:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 573:../uvc.c      **** 			  break;
 574:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 575:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 577:../uvc.c      **** 		 	 }
 578:../uvc.c      **** 		 	 else{
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 580:../uvc.c      **** 		 	 }
 581:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 582:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 583:../uvc.c      **** 			  Len = 1;
 584:../uvc.c      **** 			  break;
 585:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 586:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 589:../uvc.c      **** 		 	 }
 590:../uvc.c      **** 
 591:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 593:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 594:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 595:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 596:../uvc.c      **** 			 }else{
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 598:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 599:../uvc.c      **** 			 }
 600:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 601:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 602:../uvc.c      **** 			  break;
 603:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 604:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 605:../uvc.c      **** 				  glEp0Buffer, &readCount);
 606:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 607:../uvc.c      **** 			   {
 608:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 609:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 610:../uvc.c      **** 				  getData = glEp0Buffer[0];
 611:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 612:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 613:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 614:../uvc.c      **** #endif
 615:../uvc.c      **** 				  switch(CtrlID)
 616:../uvc.c      **** 					 {
 617:../uvc.c      **** 						 case ExtShutCtlID0:
 618:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 619:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 620:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 621:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 622:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 623:../uvc.c      **** 									 }else{
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 625:../uvc.c      **** 									 }
 626:../uvc.c      **** 								 }
 627:../uvc.c      **** 							 }else{
 628:../uvc.c      **** 								 Data1 = Data0 - 1;
 629:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 630:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 631:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 632:../uvc.c      **** 									 }else{
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 634:../uvc.c      **** 									 }
 635:../uvc.c      **** 								 }
 636:../uvc.c      **** 								 if(Data1 < 8){
 637:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 638:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 639:../uvc.c      **** 								 }else{
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 641:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 642:../uvc.c      **** 								 }
 643:../uvc.c      **** 							 }
 644:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 645:../uvc.c      **** 							 dataIdx = 0;
 646:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 647:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 648:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 649:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 650:../uvc.c      **** 							 break;
 651:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 652:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 653:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 655:../uvc.c      **** 							 dataIdx = 0;
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 657:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 658:../uvc.c      **** 							 if(getData != 0){
 659:../uvc.c      **** 								 dataIdx++;
 660:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 661:../uvc.c      **** 							 }
 662:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 663:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 664:../uvc.c      **** 							 break;
 665:../uvc.c      **** 						 case ExtExRefCtlID10:
 666:../uvc.c      **** 							 dataIdx = 0;
 667:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 668:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 669:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 670:../uvc.c      **** 							 if(WDRflag)
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 672:../uvc.c      **** 							 else
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 674:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 675:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 676:../uvc.c      **** 						 case ExtCamMCtlID12:
 677:../uvc.c      **** 							 /*
 678:../uvc.c      **** 							 dataIdx = 0;
 679:../uvc.c      **** 							 if(Data0 <= 3){
 680:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 681:../uvc.c      **** 								 Data1 = Data0;
 682:../uvc.c      **** 							 }else{
 683:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 684:../uvc.c      **** 								 Data1 = Data0-4;
 685:../uvc.c      **** 							 }
 686:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 687:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 688:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 689:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 690:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 691:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 692:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 693:../uvc.c      **** 							 */
 694:../uvc.c      **** 							 break;
 695:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 696:../uvc.c      **** 							 dataIdx = 0;
 697:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 698:../uvc.c      **** 								 Data0 = 1;
 699:../uvc.c      **** 							 }else{ //save current sensor parameters.
 700:../uvc.c      **** 								 Data0 = 0;
 701:../uvc.c      **** 							 }
 702:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 703:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 704:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 705:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 706:../uvc.c      **** 							 break;
 707:../uvc.c      **** 						 case ExtI2CCtlID15:
 708:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 709:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 710:../uvc.c      **** 					 		 }
 711:../uvc.c      **** 					 		I2CCmdHandler();
 712:../uvc.c      **** 							 break;
 713:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 714:../uvc.c      **** 							 dataIdx = 0;
 715:../uvc.c      **** #if 0 //seperate version
 716:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 717:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 718:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 719:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 720:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 721:../uvc.c      **** 							 }else{ //disable BLD window
 722:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 723:../uvc.c      **** 							 }
 724:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 725:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 726:../uvc.c      **** 							 dataIdx++;
 727:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 728:../uvc.c      **** 							 dataIdx++;
 729:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 730:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 731:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 732:../uvc.c      **** 							 dataIdx++;
 733:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 734:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 735:../uvc.c      **** #else //combination version
 736:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 737:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 738:../uvc.c      **** 						     /* end test */
 739:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 740:../uvc.c      **** 							 dataIdx++;
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 742:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 743:../uvc.c      **** 							 getData1 = Data1;
 744:../uvc.c      **** #endif
 745:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 746:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 748:../uvc.c      **** 							 break;
 749:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 750:../uvc.c      **** 							 dataIdx = 0;
 751:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 752:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 753:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 754:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 755:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 756:../uvc.c      **** 							 break;
 757:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 758:../uvc.c      **** 							 dataIdx = 0;
 759:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 760:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 761:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 762:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 764:../uvc.c      **** 							 break;
 765:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 766:../uvc.c      **** 							 dataIdx = 0;
 767:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 768:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 769:../uvc.c      **** 							  if(Data0&0x80){
 770:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 771:../uvc.c      **** 							  }else{
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 773:../uvc.c      **** 							  }
 774:../uvc.c      **** 							 Data1 |= ~0x03;
 775:../uvc.c      **** 							 Data1 &= 0xC7;
 776:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 777:../uvc.c      **** 						  	 dataIdx++;
 778:../uvc.c      **** 
 779:../uvc.c      **** 							 Data0 = (Data0 << 2);
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 781:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 782:../uvc.c      **** 
 783:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 784:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 786:../uvc.c      **** 
 787:../uvc.c      **** 							 break;
 788:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 789:../uvc.c      **** 							 dataIdx = 0;
 790:../uvc.c      **** 
 791:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 792:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 793:../uvc.c      **** 							 dataIdx++;
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 795:../uvc.c      **** 							 dataIdx++;
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 797:../uvc.c      **** 							 dataIdx++;
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 799:../uvc.c      **** 							 dataIdx++;
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 801:../uvc.c      **** 							 dataIdx++;
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 803:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 804:../uvc.c      **** 
 805:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 806:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 807:../uvc.c      **** 							 break;
 808:../uvc.c      **** 						 case SaturCtlID6:
 809:../uvc.c      **** 							 dataIdx = 0;
 810:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 811:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 812:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 813:../uvc.c      **** 							 dataIdx++;
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 816:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 818:../uvc.c      **** 							 break;
 819:../uvc.c      **** 
 820:../uvc.c      **** 						 case WBTLevCtlID11:
 821:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 822:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 823:../uvc.c      **** 							 dataIdx = 0;
 824:../uvc.c      **** 
 825:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 826:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 827:../uvc.c      **** 							 dataIdx++;
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 830:../uvc.c      **** 
 831:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 832:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 833:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 834:../uvc.c      **** 							 break;
 835:../uvc.c      **** 						 case MFreqCtlID4:
 836:../uvc.c      **** 							 dataIdx = 0;
 837:../uvc.c      **** 							 Data0 = Data0 - 1;
 838:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 839:../uvc.c      **** 								 Data0 = 0;
 840:../uvc.c      **** 							 else if(Data0 >2)
 841:../uvc.c      **** 								 Data0 = 1;
 842:../uvc.c      **** 
 843:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 845:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 846:../uvc.c      **** 
 847:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 849:../uvc.c      **** 							 break;
 850:../uvc.c      **** 					 	 case BLCCtlID0:
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 852:../uvc.c      **** 							 if(Data0 == 3)
 853:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 854:../uvc.c      **** 							 else
 855:../uvc.c      **** 								 WDRflag = CyFalse;
 856:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 857:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 858:../uvc.c      **** 							 {
 859:../uvc.c      **** 								 if(Data0 < 2){
 860:../uvc.c      **** 					 				 ;//Data0 += 4;
 861:../uvc.c      **** 					 			 }else{
 862:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 863:../uvc.c      **** 									Data0 = 0; //set to default.
 864:../uvc.c      **** 					 			 }
 865:../uvc.c      **** 					 		 }
 866:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 867:../uvc.c      **** 							 dataIdx = 0;
 868:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 869:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 870:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 871:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 872:../uvc.c      **** 
 873:../uvc.c      **** 					 		 break;
 874:../uvc.c      **** 						 default:
 875:../uvc.c      **** 							 dataIdx = 0;
 876:../uvc.c      **** 
 877:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 878:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 879:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 880:../uvc.c      **** 
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 883:../uvc.c      **** 							 break;
 884:../uvc.c      **** 					 }
 885:../uvc.c      **** 			   }else{
 886:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 887:../uvc.c      **** 			   }
 888:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 889:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 890:../uvc.c      **** #endif
 891:../uvc.c      **** 
 892:../uvc.c      **** 			  break;
 893:../uvc.c      **** 		  default:
 894:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 895:../uvc.c      **** 			  break;
 896:../uvc.c      **** 		 }
 897:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 898:../uvc.c      **** }
 899:../uvc.c      **** /************** CT control requests handler *************************/
 900:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 901:../uvc.c      **** 
 902:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 903:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 904:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 905:../uvc.c      ****     uint16_t readCount;
 906:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 907:../uvc.c      ****     uint16_t diff, value, diffRd;
 908:../uvc.c      ****     uint8_t i, shutter, index;
 909:../uvc.c      ****     diff = 0xffff;
 910:../uvc.c      ****     shutter = 1;
 911:../uvc.c      ****     index = 1;
 912:../uvc.c      **** 
 913:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 914:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 915:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 916:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 917:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 918:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 919:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 920:../uvc.c      **** #endif
 921:../uvc.c      ****     reqData = bRequest;
 922:../uvc.c      **** 
 923:../uvc.c      ****     switch (bRequest)
 924:../uvc.c      **** 		 {
 925:../uvc.c      **** 
 926:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 927:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 928:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 929:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 930:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 931:../uvc.c      **** 			  break;
 932:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 933:../uvc.c      **** 
 934:../uvc.c      **** 			 switch(CtrlID)
 935:../uvc.c      **** 			 {
 936:../uvc.c      **** 				 default:
 937:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 938:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 939:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 940:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 941:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 942:../uvc.c      **** 					 break;
 943:../uvc.c      **** 			 }
 944:../uvc.c      **** 
 945:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 946:../uvc.c      **** 
 947:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 948:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 949:../uvc.c      **** #endif
 950:../uvc.c      **** 			  break;
 951:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 952:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 953:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 954:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 955:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 956:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 957:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 958:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 959:../uvc.c      **** 			  break;
 960:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 961:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 962:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 963:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 964:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 965:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 966:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 967:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 968:../uvc.c      **** 			  break;
 969:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 970:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 971:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 972:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 973:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 974:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 975:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 976:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 977:../uvc.c      **** 			  break;
 978:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 979:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 981:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 982:../uvc.c      **** 			  Len = 1;
 983:../uvc.c      **** 			  break;
 984:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 985:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 986:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 987:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 988:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 989:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 990:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 991:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 992:../uvc.c      **** 			  break;
 993:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 994:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 995:../uvc.c      **** 			  glEp0Buffer, &readCount);
 996:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 997:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 998:../uvc.c      **** 			  value = Data1;
 999:../uvc.c      **** 
1000:../uvc.c      **** 			  switch(CtrlID)
1001:../uvc.c      **** 			  {
1002:../uvc.c      **** 		  	      case AutoExMCtlID1:
1003:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1004:../uvc.c      **** 
1005:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1006:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1007:../uvc.c      **** 				    getData = glEp0Buffer[0];
1008:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1009:../uvc.c      **** 		  		    switch (getData){
1010:../uvc.c      **** 						case 1:
1011:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1012:../uvc.c      **** 							break;
1013:../uvc.c      **** 						case 2:
1014:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1015:../uvc.c      **** 							dataIdx = 0;
1016:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1017:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1018:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1019:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1020:../uvc.c      **** 
1021:../uvc.c      **** 							break;
1022:../uvc.c      **** 						case 4:
1023:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1024:../uvc.c      **** 							break;
1025:../uvc.c      **** 						case 8:
1026:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1027:../uvc.c      **** 			  		    	dataIdx = 0;
1028:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1029:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1030:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1031:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1032:../uvc.c      **** 							break;
1033:../uvc.c      **** 		  		    }
1034:../uvc.c      **** #if 0
1035:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1036:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1037:../uvc.c      **** 						  dataIdx = 0;
1038:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1039:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1040:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1041:../uvc.c      **** 		  		    }
1042:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1043:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1044:../uvc.c      **** 		  		    }
1045:../uvc.c      **** #endif
1046:../uvc.c      **** 				    break;
1047:../uvc.c      **** 
1048:../uvc.c      **** 			  	  case ExTmACtlID3:
1049:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1050:../uvc.c      **** 
1051:../uvc.c      **** 					  value = (value << 8)|Data0;
1052:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1053:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1054:../uvc.c      **** 					  {
1055:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1056:../uvc.c      **** 						  {
1057:../uvc.c      **** 							if(value > ShutValueArry[i]){
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1059:../uvc.c      **** 							}else{
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1061:../uvc.c      **** 							}
1062:../uvc.c      **** 							  if(diff > diffRd){
1063:../uvc.c      **** 								  diff = diffRd;
1064:../uvc.c      **** 								  index = i;
1065:../uvc.c      **** 							  }
1066:../uvc.c      **** 						  }
1067:../uvc.c      **** 						  shutter = shutter+index;
1068:../uvc.c      **** 
1069:../uvc.c      **** 						  dataIdx = 0;
1070:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1071:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1072:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1073:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1074:../uvc.c      **** 
1075:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1076:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1078:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1079:../uvc.c      **** 					  }else{
1080:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1081:../uvc.c      **** 					  }
1082:../uvc.c      **** 					  getData = glEp0Buffer[0];
1083:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1084:../uvc.c      **** 					  break;
1085:../uvc.c      **** 			  	  case IriACtlID7:
1086:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1087:../uvc.c      **** 					  {
1088:../uvc.c      **** 							 dataIdx = 0;
1089:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1090:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1091:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1092:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1093:../uvc.c      **** 
1094:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1095:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1097:../uvc.c      **** 					  }else{
1098:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1099:../uvc.c      **** 					  }
1100:../uvc.c      **** 					  getData = glEp0Buffer[0];
1101:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1102:../uvc.c      **** 
1103:../uvc.c      **** 					  break;
1104:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1105:../uvc.c      **** 					  getData = glEp0Buffer[0];
1106:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1107:../uvc.c      **** #if 1
1108:../uvc.c      **** 					  dataIdx = 0;
1109:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1110:../uvc.c      **** 					  if(getData == 1)
1111:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1112:../uvc.c      **** 					  else if(getData == 0xff)
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1114:../uvc.c      **** 					  else
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1116:../uvc.c      **** 					  //dataIdx++;
1117:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1118:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1119:../uvc.c      **** #endif
1120:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1121:../uvc.c      **** 					  break;
1122:../uvc.c      **** 
1123:../uvc.c      **** 			  	  default:
1124:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1125:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1126:../uvc.c      **** 			  		 break;
1127:../uvc.c      **** 			  }
1128:../uvc.c      **** 			  break;
1129:../uvc.c      **** 		  default:
1130:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1131:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1132:../uvc.c      **** 			  break;
1133:../uvc.c      **** 		 }
1134:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1135:../uvc.c      **** 
1136:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1137:../uvc.c      **** }
1138:../uvc.c      **** 
1139:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1140:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1141:../uvc.c      **** {
1142:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1143:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1144:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1145:../uvc.c      **** 
1146:../uvc.c      ****     CtrlID = BrgtCtlID1;
1147:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1148:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1149:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1150:../uvc.c      ****     Data1 = Data0;
1151:../uvc.c      **** 
1152:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1153:../uvc.c      ****     if(Data1&0x80){
1154:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1155:../uvc.c      ****     }else{
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1157:../uvc.c      ****     }
1158:../uvc.c      ****     Data0 = (Data0 << 2);
1159:../uvc.c      **** 
1160:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1161:../uvc.c      **** 
1162:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1164:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1165:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1167:../uvc.c      **** 
1168:../uvc.c      ****     CtrlID = ConsCtlID2;
1169:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1170:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1171:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1172:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1173:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1174:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1175:../uvc.c      **** 
1176:../uvc.c      ****     CtrlID = HueCtlID5;
1177:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1178:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1179:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1186:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1187:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1188:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1189:../uvc.c      **** 
1190:../uvc.c      ****     CtrlID = SaturCtlID6;
1191:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1192:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1193:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1194:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1195:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1196:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1197:../uvc.c      **** 
1198:../uvc.c      ****     CtrlID = ShapCtlID7;
1199:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1200:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1201:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1202:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1203:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1204:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1205:../uvc.c      **** 
1206:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1207:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1208:../uvc.c      **** 	return;
1209:../uvc.c      **** }
1210:../uvc.c      **** 
1211:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1212:../uvc.c      **** void
1213:../uvc.c      **** CyFxUVCAddHeader (
1214:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1215:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1216:../uvc.c      ****         )
1217:../uvc.c      **** {
1218:../uvc.c      ****     /* Copy header to buffer */
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1220:../uvc.c      **** 
1221:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1222:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1223:../uvc.c      ****     {
1224:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1225:../uvc.c      ****     }
1226:../uvc.c      **** }
1227:../uvc.c      **** 
1228:../uvc.c      **** 
1229:../uvc.c      **** /* Application Error Handler */
1230:../uvc.c      **** void
1231:../uvc.c      **** CyFxAppErrorHandler (
1232:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1233:../uvc.c      ****         )
1234:../uvc.c      **** {
1235:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1236:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1237:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1238:../uvc.c      **** 
1239:../uvc.c      ****        This function can be modified to take additional error handling actions such
1240:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1241:../uvc.c      ****      */
1242:../uvc.c      ****     for (;;)
1243:../uvc.c      ****     {
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
1246:../uvc.c      ****     }
1247:../uvc.c      **** }
1248:../uvc.c      **** 
1249:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1250:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1251:../uvc.c      ****  */
1252:../uvc.c      **** static void
1253:../uvc.c      **** CyFxUVCApplnAbortHandler (
1254:../uvc.c      ****         void)
1255:../uvc.c      **** {
1256:../uvc.c      **** 	uint32_t flag;
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1258:../uvc.c      **** 	{
1259:../uvc.c      ****         /* Clear the Video Stream Request Event */
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1261:../uvc.c      **** 
1262:../uvc.c      ****         /* Set Video Stream Abort Event */
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1264:../uvc.c      **** 	}
1265:../uvc.c      **** }
1266:../uvc.c      **** 
1267:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1268:../uvc.c      **** static void
1269:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1270:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1271:../uvc.c      ****         uint16_t             evdata  /* Event data */
1272:../uvc.c      ****         )
1273:../uvc.c      **** {
1274:../uvc.c      ****     switch (evtype)
1275:../uvc.c      ****     {
1276:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1277:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1278:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1279:../uvc.c      ****             gpif_initialized = 0;
1280:../uvc.c      ****             streamingStarted = CyFalse;
1281:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1282:../uvc.c      ****             break;
1283:../uvc.c      **** 
1284:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1285:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1286:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1287:../uvc.c      ****             gpif_initialized = 0;
1288:../uvc.c      ****             streamingStarted = CyFalse;
1289:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1290:../uvc.c      ****             break;
1291:../uvc.c      **** 
1292:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1293:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1294:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1295:../uvc.c      ****             gpif_initialized = 0;
1296:../uvc.c      ****             isUsbConnected = CyFalse;
1297:../uvc.c      ****             streamingStarted = CyFalse;
1298:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1299:../uvc.c      ****             break;
1300:../uvc.c      **** 
1301:../uvc.c      **** #ifdef BACKFLOW_DETECT
1302:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1303:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1304:../uvc.c      ****             break;
1305:../uvc.c      **** #endif
1306:../uvc.c      **** 
1307:../uvc.c      ****         default:
1308:../uvc.c      ****             break;
1309:../uvc.c      ****     }
1310:../uvc.c      **** }
1311:../uvc.c      **** 
1312:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1313:../uvc.c      **** static CyBool_t
1314:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1315:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1316:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1317:../uvc.c      ****         )
1318:../uvc.c      **** {
1319:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1320:../uvc.c      ****     uint32_t status;
1321:../uvc.c      **** 
1322:../uvc.c      ****     /* Obtain Request Type and Request */
1323:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1325:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1327:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1328:../uvc.c      **** 
1329:../uvc.c      ****     /* Check for UVC Class Requests */
1330:../uvc.c      ****     switch (bmReqType)
1331:../uvc.c      ****     {
1332:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1333:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1334:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1335:../uvc.c      ****             switch (wIndex & 0xFF)
1336:../uvc.c      ****             {
1337:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1338:../uvc.c      ****                     {
1339:../uvc.c      ****                         uvcHandleReq = CyTrue;
1340:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1341:../uvc.c      ****                                 CYU3P_EVENT_OR);
1342:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1343:../uvc.c      ****                         {
1344:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1345:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1346:../uvc.c      ****                         }
1347:../uvc.c      ****                     }
1348:../uvc.c      ****                     break;
1349:../uvc.c      **** 
1350:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1351:../uvc.c      ****                     {
1352:../uvc.c      ****                         uvcHandleReq = CyTrue;
1353:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1354:../uvc.c      ****                                 CYU3P_EVENT_OR);
1355:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1356:../uvc.c      ****                         {
1357:../uvc.c      ****                             /* Error handling */
1358:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1359:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1360:../uvc.c      ****                         }
1361:../uvc.c      ****                     }
1362:../uvc.c      ****                     break;
1363:../uvc.c      **** 
1364:../uvc.c      ****                 default:
1365:../uvc.c      ****                     break;
1366:../uvc.c      ****             }
1367:../uvc.c      ****             break;
1368:../uvc.c      **** 
1369:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1370:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1371:../uvc.c      ****             {
1372:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1373:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1374:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1375:../uvc.c      ****                 {
1376:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1377:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1378:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1379:../uvc.c      ****                     gpif_initialized = 0;
1380:../uvc.c      ****                     streamingStarted = CyFalse;
1381:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1382:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1383:../uvc.c      ****                     CyU3PBusyWait (100);
1384:../uvc.c      **** 
1385:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1386:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1387:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1388:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1389:../uvc.c      ****                     CyU3PBusyWait (100);
1390:../uvc.c      **** 
1391:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1392:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1393:../uvc.c      ****                     uvcHandleReq = CyTrue;
1394:../uvc.c      ****                     /* Complete Control request handshake */
1395:../uvc.c      ****                     CyU3PUsbAckSetup ();
1396:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1397:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1398:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1399:../uvc.c      **** 
1400:../uvc.c      ****                 }
1401:../uvc.c      ****             }
1402:../uvc.c      ****             break;
1403:../uvc.c      **** 
1404:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1405:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1406:../uvc.c      ****             {
1407:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1408:../uvc.c      ****                 {
1409:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1410:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1411:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1412:../uvc.c      ****                 	 * has started. */
1413:../uvc.c      ****                     if (streamingStarted == CyTrue)
1414:../uvc.c      ****                     {
1415:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1416:../uvc.c      **** 
1417:../uvc.c      ****                         /* Disable the GPIF state machine. */
1418:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1419:../uvc.c      ****                         gpif_initialized = 0;
1420:../uvc.c      ****                         streamingStarted = CyFalse;
1421:../uvc.c      **** 
1422:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1423:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1424:../uvc.c      ****                         CyU3PBusyWait (100);
1425:../uvc.c      **** 
1426:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1427:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1428:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1429:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1430:../uvc.c      ****                         CyU3PBusyWait (100);
1431:../uvc.c      **** 
1432:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1433:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1434:../uvc.c      **** 
1435:../uvc.c      ****                         uvcHandleReq = CyTrue;
1436:../uvc.c      ****                         /* Complete Control request handshake */
1437:../uvc.c      ****                         CyU3PUsbAckSetup ();
1438:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1439:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1440:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1441:../uvc.c      ****                     }
1442:../uvc.c      ****                     else
1443:../uvc.c      ****                     {
1444:../uvc.c      ****                         uvcHandleReq = CyTrue;
1445:../uvc.c      ****                         CyU3PUsbAckSetup ();
1446:../uvc.c      ****                     }
1447:../uvc.c      ****                 }
1448:../uvc.c      ****             }
1449:../uvc.c      ****             break;
1450:../uvc.c      **** 
1451:../uvc.c      ****         default:
1452:../uvc.c      ****             break;
1453:../uvc.c      ****     }
1454:../uvc.c      **** 
1455:../uvc.c      ****     /* Return status of request handling to the USB driver */
1456:../uvc.c      ****     return uvcHandleReq;
1457:../uvc.c      **** }
1458:../uvc.c      **** 
1459:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1460:../uvc.c      **** 
1461:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1462:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1463:../uvc.c      ****  */
1464:../uvc.c      **** void
1465:../uvc.c      **** CyFxUvcApplnDmaCallback (
1466:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1467:../uvc.c      ****         CyU3PDmaCbType_t      type,
1468:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1469:../uvc.c      ****         )
1470:../uvc.c      **** {
1471:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1472:../uvc.c      **** #if 1
1473:../uvc.c      ****     CyU3PReturnStatus_t status;
1474:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1475:../uvc.c      ****     {
1476:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1477:../uvc.c      ****             {
1478:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1479:../uvc.c      ****                 fb++;
1480:../uvc.c      ****             }
1481:../uvc.c      ****             else
1482:../uvc.c      ****             {
1483:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1484:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1485:../uvc.c      ****                 pb++;
1486:../uvc.c      ****                 pbc = input->buffer_p.count;
1487:../uvc.c      ****                // hitFV = CyTrue;
1488:../uvc.c      ****             }
1489:../uvc.c      **** 
1490:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1491:../uvc.c      ****             prodCount++;
1492:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1493:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1494:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1495:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1496:../uvc.c      ****             {
1497:../uvc.c      ****                 prodCount--;
1498:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1499:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1500:../uvc.c      ****             }
1501:../uvc.c      ****     }
1502:../uvc.c      **** #endif
1503:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1504:../uvc.c      ****     {
1505:../uvc.c      ****         consCount++;
1506:../uvc.c      ****         streamingStarted = CyTrue;
1507:../uvc.c      ****     }
1508:../uvc.c      **** }
1509:../uvc.c      **** 
1510:../uvc.c      **** /*
1511:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1512:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1513:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1514:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1515:../uvc.c      ****  * to commit the buffer.
1516:../uvc.c      ****  */
1517:../uvc.c      **** static uint8_t
1518:../uvc.c      **** CyFxUvcAppCommitEOF (
1519:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1520:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1521:../uvc.c      ****         )
1522:../uvc.c      **** {
1523:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1524:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1525:../uvc.c      **** 
1526:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1527:../uvc.c      **** 
1528:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1529:../uvc.c      ****     {
1530:../uvc.c      ****         switch (stateId)
1531:../uvc.c      ****         {
1532:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1533:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1534:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1535:../uvc.c      ****                 break;
1536:../uvc.c      **** 
1537:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1538:../uvc.c      ****                 socket = 0;
1539:../uvc.c      ****                 break;
1540:../uvc.c      **** 
1541:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1542:../uvc.c      ****                 socket = 1;
1543:../uvc.c      ****                 break;
1544:../uvc.c      **** 
1545:../uvc.c      ****             default:
1546:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1547:../uvc.c      ****                 /* Unexpected current state. Return error. */
1548:../uvc.c      ****                 return 1;
1549:../uvc.c      ****         }
1550:../uvc.c      ****     }
1551:../uvc.c      **** 
1552:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1553:../uvc.c      ****     {
1554:../uvc.c      ****         switch (stateId)
1555:../uvc.c      ****         {
1556:../uvc.c      **** #ifndef CAM720
1557:../uvc.c      **** #ifdef GPIFIIM
1558:../uvc.c      ****             case 13:
1559:../uvc.c      ****             case 24:
1560:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1561:../uvc.c      ****                 break;
1562:../uvc.c      **** 
1563:../uvc.c      ****             case 8:
1564:../uvc.c      ****                 socket = 0;
1565:../uvc.c      ****                 break;
1566:../uvc.c      **** 
1567:../uvc.c      ****             case 20:
1568:../uvc.c      ****                 socket = 1;
1569:../uvc.c      ****                 break;
1570:../uvc.c      **** #else
1571:../uvc.c      ****             case 11:
1572:../uvc.c      ****             case 18:
1573:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1574:../uvc.c      ****                 break;
1575:../uvc.c      **** 
1576:../uvc.c      ****             case 8:
1577:../uvc.c      ****                 socket = 0;
1578:../uvc.c      ****                 break;
1579:../uvc.c      **** 
1580:../uvc.c      ****             case 15:
1581:../uvc.c      ****                 socket = 1;
1582:../uvc.c      ****                 break;
1583:../uvc.c      **** #endif
1584:../uvc.c      **** #else
1585:../uvc.c      ****             case 11:
1586:../uvc.c      ****             case 18:
1587:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1588:../uvc.c      ****                 break;
1589:../uvc.c      **** 
1590:../uvc.c      ****             case 8:
1591:../uvc.c      ****                 socket = 0;
1592:../uvc.c      ****                 break;
1593:../uvc.c      **** 
1594:../uvc.c      ****             case 15:
1595:../uvc.c      ****                 socket = 1;
1596:../uvc.c      ****                 break;
1597:../uvc.c      **** 
1598:../uvc.c      **** #endif
1599:../uvc.c      ****              default:
1600:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1601:../uvc.c      ****                 /* Unexpected current state. Return error. */
1602:../uvc.c      ****                return 1;
1603:../uvc.c      ****         }
1604:../uvc.c      ****     }
1605:../uvc.c      **** 
1606:../uvc.c      ****     if (socket != 0xFF)
1607:../uvc.c      ****     {
1608:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1609:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1610:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1611:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1612:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1613:../uvc.c      ****         {
1614:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1615:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1616:../uvc.c      ****         }
1617:../uvc.c      ****     }
1618:../uvc.c      **** 
1619:../uvc.c      ****     return 0;
1620:../uvc.c      **** }
1621:../uvc.c      **** 
1622:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1623:../uvc.c      **** void
1624:../uvc.c      **** CyFxGpifCB (
1625:../uvc.c      ****         CyU3PGpifEventType event,
1626:../uvc.c      ****         uint8_t currentState
1627:../uvc.c      ****         )
1628:../uvc.c      **** {
1629:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1630:../uvc.c      ****     {
1631:../uvc.c      ****         hitFV = CyTrue;
1632:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1633:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1634:../uvc.c      ****     }
1635:../uvc.c      **** }
1636:../uvc.c      **** 
1637:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1638:../uvc.c      **** static void
1639:../uvc.c      **** CyFxUVCApplnDebugInit (
1640:../uvc.c      ****         void)
1641:../uvc.c      **** {
1642:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1643:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1644:../uvc.c      **** 
1645:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1646:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1647:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1648:../uvc.c      ****     {
1649:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1650:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1651:../uvc.c      ****     }
1652:../uvc.c      **** 
1653:../uvc.c      ****     /* Set UART Configuration */
1654:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1655:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1656:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1657:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1658:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1659:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1660:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1661:../uvc.c      **** 
1662:../uvc.c      ****     /* Set the UART configuration */
1663:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1664:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1665:../uvc.c      ****     {
1666:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1667:../uvc.c      ****     }
1668:../uvc.c      **** 
1669:../uvc.c      ****     /* Set the UART transfer */
1670:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1671:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1672:../uvc.c      ****     {
1673:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1674:../uvc.c      ****     }
1675:../uvc.c      **** 
1676:../uvc.c      ****     /* Initialize the Debug logger module. */
1677:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1678:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1679:../uvc.c      ****     {
1680:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1681:../uvc.c      ****     }
1682:../uvc.c      **** 
1683:../uvc.c      ****     /* Disable log message headers. */
1684:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1685:../uvc.c      **** }
1686:../uvc.c      **** 
1687:../uvc.c      **** /* I2C initialization. */
1688:../uvc.c      **** //static void
1689:../uvc.c      **** void
1690:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1691:../uvc.c      **** {
1692:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1693:../uvc.c      ****     CyU3PReturnStatus_t status;
1694:../uvc.c      **** 
1695:../uvc.c      ****     status = CyU3PI2cInit ();
1696:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1697:../uvc.c      ****     {
1698:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1699:../uvc.c      ****         CyFxAppErrorHandler (status);
1700:../uvc.c      ****     }
1701:../uvc.c      **** 
1702:../uvc.c      ****     /*  Set I2C Configuration */
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1704:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1705:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1706:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1707:../uvc.c      **** 
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1709:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1710:../uvc.c      ****     {
1711:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1712:../uvc.c      ****         CyFxAppErrorHandler (status);
1713:../uvc.c      ****     }
1714:../uvc.c      **** }
1715:../uvc.c      **** 
1716:../uvc.c      **** #ifdef BACKFLOW_DETECT
1717:../uvc.c      **** static void CyFxUvcAppPibCallback (
1718:../uvc.c      ****         CyU3PPibIntrType cbType,
1719:../uvc.c      ****         uint16_t cbArg)
1720:../uvc.c      **** {
1721:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1722:../uvc.c      ****     {
1723:../uvc.c      ****         if (!back_flow_detected)
1724:../uvc.c      ****         {
1725:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1726:../uvc.c      ****             back_flow_detected = 1;
1727:../uvc.c      ****         }
1728:../uvc.c      ****     }
1729:../uvc.c      **** }
1730:../uvc.c      **** #endif
1731:../uvc.c      **** 
1732:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1733:../uvc.c      **** static void
1734:../uvc.c      **** CyFxUvcAppDebugCallback (
1735:../uvc.c      ****         CyU3PDmaChannel   *handle,
1736:../uvc.c      ****         CyU3PDmaCbType_t   type,
1737:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1738:../uvc.c      **** {
1739:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1740:../uvc.c      ****     {
1741:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1742:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1743:../uvc.c      ****     }
1744:../uvc.c      **** }
1745:../uvc.c      **** #endif
1746:../uvc.c      **** 
1747:../uvc.c      **** #if 0
1748:../uvc.c      **** static void CyFxAppIntEpCb(
1749:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1750:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1751:../uvc.c      **** 		uint8_t  ebNum)
1752:../uvc.c      **** 		{
1753:../uvc.c      **** 			//CyBool_t value;
1754:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1755:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1756:../uvc.c      **** 
1757:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1758:../uvc.c      **** 		}
1759:../uvc.c      **** #endif
1760:../uvc.c      **** 
1761:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1762:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1763:../uvc.c      ****    configures the DMA module for the UVC Application */
1764:../uvc.c      **** static void
1765:../uvc.c      **** CyFxUVCApplnInit (void)
1766:../uvc.c      **** {
1767:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1768:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1769:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1770:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1771:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1772:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1773:../uvc.c      **** 
1774:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1775:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1776:../uvc.c      **** 
1777:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1778:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1779:../uvc.c      **** #endif
1780:../uvc.c      **** 
1781:../uvc.c      ****     /* Create UVC event group */
1782:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1783:../uvc.c      ****     if (apiRetStatus != 0)
1784:../uvc.c      ****     {
1785:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1786:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1787:../uvc.c      ****     }
1788:../uvc.c      **** 
1789:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1790:../uvc.c      ****     CyFxUvcAppPTZInit ();
1791:../uvc.c      **** #endif
1792:../uvc.c      **** 
1793:../uvc.c      ****     isUsbConnected = CyFalse;
1794:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1795:../uvc.c      **** 
1796:../uvc.c      ****     /* Init the GPIO module */
1797:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1798:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1799:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1800:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1801:../uvc.c      ****     gpioClock.halfDiv    = 0;
1802:../uvc.c      **** 
1803:../uvc.c      ****     /* Initialize Gpio interface */
1804:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1805:../uvc.c      ****     if (apiRetStatus != 0)
1806:../uvc.c      ****     {
1807:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1808:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1809:../uvc.c      ****     }
1810:../uvc.c      **** 
1811:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1812:../uvc.c      ****      * must use GpioOverride to configure it */
1813:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1814:../uvc.c      ****     if (apiRetStatus != 0)
1815:../uvc.c      ****     {
1816:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1817:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1818:../uvc.c      ****     }
1819:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1820:../uvc.c      ****     if (apiRetStatus != 0)
1821:../uvc.c      ****     {
1822:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1823:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1824:../uvc.c      ****     }
1825:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1826:../uvc.c      ****     if (apiRetStatus != 0)
1827:../uvc.c      ****     {
1828:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1829:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1830:../uvc.c      ****     }
1831:../uvc.c      **** 
1832:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1833:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1834:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1835:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1836:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1837:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1838:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1839:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1840:../uvc.c      ****     {
1841:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1842:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1843:../uvc.c      ****     }
1844:../uvc.c      **** 
1845:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1846:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1847:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1848:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1849:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1850:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1851:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1852:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1853:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1854:../uvc.c      ****     {
1855:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1856:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1857:../uvc.c      ****     }
1858:../uvc.c      **** 
1859:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1860:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1861:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1862:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1863:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1864:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1865:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1866:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1867:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1868:../uvc.c      ****     {
1869:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1870:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1871:../uvc.c      ****     }
1872:../uvc.c      **** 
1873:../uvc.c      ****     /* Initialize the P-port. */
1874:../uvc.c      ****     pibclock.clkDiv      = 2;
1875:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1876:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1877:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1878:../uvc.c      **** 
1879:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1881:../uvc.c      ****     {
1882:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1884:../uvc.c      ****     }
1885:../uvc.c      **** 
1886:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1887:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1888:../uvc.c      **** 
1889:../uvc.c      **** #ifdef BACKFLOW_DETECT
1890:../uvc.c      ****     back_flow_detected = 0;
1891:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1892:../uvc.c      **** #endif
1893:../uvc.c      **** 
1894:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1895:../uvc.c      ****     SensorReset ();
1896:../uvc.c      ****     SensorInit ();
1897:../uvc.c      **** 
1898:../uvc.c      ****     /* USB initialization. */
1899:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1900:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1901:../uvc.c      ****     {
1902:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1903:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1904:../uvc.c      ****     }
1905:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1906:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1907:../uvc.c      **** 
1908:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1909:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1910:../uvc.c      **** 
1911:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1912:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1913:../uvc.c      **** 
1914:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1915:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1916:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1917:../uvc.c      **** 
1918:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1919:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1920:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1921:../uvc.c      **** 
1922:../uvc.c      ****     /* Configuration descriptors. */
1923:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1924:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1926:../uvc.c      **** 
1927:../uvc.c      ****     /* String Descriptors */
1928:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1929:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1931:../uvc.c      **** 
1932:../uvc.c      ****     /* Configure the status interrupt endpoint.
1933:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1934:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1935:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1936:../uvc.c      ****      */
1937:../uvc.c      ****     endPointConfig.enable   = 1;
1938:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1939:../uvc.c      ****     endPointConfig.pcktSize = 64;
1940:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1941:../uvc.c      ****     endPointConfig.streams  = 0;
1942:../uvc.c      ****     endPointConfig.burstLen = 1;
1943:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1944:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1945:../uvc.c      ****     {
1946:../uvc.c      ****         /* Error Handling */
1947:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1948:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1949:../uvc.c      ****     }
1950:../uvc.c      **** 
1951:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1952:../uvc.c      ****     dmaInterConfig.size           = 1024;
1953:../uvc.c      ****     dmaInterConfig.count          = 1;
1954:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1955:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1956:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1957:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1958:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1959:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1960:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1961:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1962:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1963:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1964:../uvc.c      ****             &dmaInterConfig);
1965:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1966:../uvc.c      ****     {
1967:../uvc.c      ****         /* Error handling */
1968:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1969:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1970:../uvc.c      ****     }
1971:../uvc.c      **** 
1972:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1973:../uvc.c      ****     if (glInterStaBuffer == 0)
1974:../uvc.c      ****     {
1975:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1976:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1977:../uvc.c      ****     }
1978:../uvc.c      **** 
1979:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1980:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1981:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1982:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1983:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1984:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1985:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1986:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1987:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1988:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
1989:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1990:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1991:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1992:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1993:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
1994:../uvc.c      ****             &dmaMultiConfig);
1995:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1996:../uvc.c      ****     {
1997:../uvc.c      ****         /* Error handling */
1998:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
1999:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2000:../uvc.c      ****     }
2001:../uvc.c      **** 
2002:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2003:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2004:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2005:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2006:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2007:../uvc.c      ****      */
2008:../uvc.c      **** 
2009:../uvc.c      ****     endPointConfig.enable   = 1;
2010:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2011:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2012:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2013:../uvc.c      ****     endPointConfig.streams  = 0;
2014:../uvc.c      ****     endPointConfig.burstLen = 1;
2015:../uvc.c      **** 
2016:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2017:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2018:../uvc.c      ****     {
2019:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2020:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2021:../uvc.c      ****     }
2022:../uvc.c      **** 
2023:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2024:../uvc.c      **** 
2025:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2026:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2027:../uvc.c      ****     {
2028:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2029:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2030:../uvc.c      ****     }
2031:../uvc.c      **** 
2032:../uvc.c      ****     channelConfig.size           = 1024;
2033:../uvc.c      ****     channelConfig.count          = 1;
2034:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2035:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2036:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2037:../uvc.c      ****     channelConfig.prodHeader     = 0;
2038:../uvc.c      ****     channelConfig.prodFooter     = 0;
2039:../uvc.c      ****     channelConfig.consHeader     = 0;
2040:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2041:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2042:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2043:../uvc.c      **** 
2044:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2045:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2046:../uvc.c      ****     {
2047:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2048:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2049:../uvc.c      ****     }
2050:../uvc.c      **** 
2051:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2052:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2053:../uvc.c      ****     {
2054:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2055:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2056:../uvc.c      ****     }
2057:../uvc.c      **** 
2058:../uvc.c      ****     channelConfig.size           = 1024;
2059:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2060:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2061:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2062:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2063:../uvc.c      ****     channelConfig.prodHeader     = 0;
2064:../uvc.c      ****     channelConfig.prodFooter     = 0;
2065:../uvc.c      ****     channelConfig.consHeader     = 0;
2066:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2067:../uvc.c      ****     channelConfig.notification   = 0;
2068:../uvc.c      ****     channelConfig.cb             = 0;
2069:../uvc.c      **** 
2070:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2071:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2072:../uvc.c      ****     {
2073:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2074:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2075:../uvc.c      ****     }
2076:../uvc.c      **** 
2077:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2078:../uvc.c      ****     if (glDebugRspBuffer == 0)
2079:../uvc.c      ****     {
2080:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2081:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2082:../uvc.c      ****     }
2083:../uvc.c      **** #endif
2084:../uvc.c      **** 
2085:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2086:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2087:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2088:../uvc.c      ****     {
2089:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2090:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2091:../uvc.c      ****     }
2092:../uvc.c      **** 
2093:../uvc.c      ****     CyU3PBusyWait(100);
2094:../uvc.c      **** 
2095:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2096:../uvc.c      **** 
2097:../uvc.c      ****     endPointConfig.enable   = 1;
2098:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2099:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2100:../uvc.c      ****     {
2101:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2102:../uvc.c      ****     	endPointConfig.burstLen = 16;
2103:../uvc.c      ****     }
2104:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2105:../uvc.c      ****     {
2106:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2107:../uvc.c      ****     	endPointConfig.burstLen = 1;
2108:../uvc.c      ****     }
2109:../uvc.c      ****     endPointConfig.streams  = 0;
2110:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2111:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2112:../uvc.c      ****     {
2113:../uvc.c      ****         /* Error Handling */
2114:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2115:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2116:../uvc.c      ****     }
2117:../uvc.c      **** #if 0    //for still image method 3 using
2118:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2119:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2120:../uvc.c      ****     {
2121:../uvc.c      ****         /* Error Handling */
2122:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2123:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2124:../uvc.c      ****     }
2125:../uvc.c      **** #endif
2126:../uvc.c      **** 
2127:../uvc.c      **** }
2128:../uvc.c      **** 
2129:../uvc.c      **** /*
2130:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2131:../uvc.c      ****  * streaming session is started.
2132:../uvc.c      ****  */
2133:../uvc.c      **** static void
2134:../uvc.c      **** CyFxUvcAppGpifInit (
2135:../uvc.c      ****         void)
2136:../uvc.c      **** {
2137:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2138:../uvc.c      **** 
2139:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2140:../uvc.c      ****     {
2141:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2142:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2143:../uvc.c      ****     }
2144:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2145:../uvc.c      ****     {
2146:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2147:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2148:../uvc.c      ****     }
2149:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2150:../uvc.c      ****     {
2151:../uvc.c      ****         /* Error Handling */
2152:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2153:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2154:../uvc.c      ****     }
2155:../uvc.c      **** 
2156:../uvc.c      ****     /* Start the state machine from the designated start state. */
2157:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2158:../uvc.c      ****     {
2159:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2160:../uvc.c      ****     }
2161:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2162:../uvc.c      ****     {
2163:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2164:../uvc.c      ****     }
2165:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2166:../uvc.c      ****     {
2167:../uvc.c      ****         /* Error Handling */
2168:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2169:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2170:../uvc.c      ****     }
2171:../uvc.c      **** }
2172:../uvc.c      **** 
2173:../uvc.c      **** /*
2174:../uvc.c      ****  * Entry function for the UVC Application Thread
2175:../uvc.c      ****  */
2176:../uvc.c      **** 
2177:../uvc.c      **** uint32_t posTick;
2178:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2179:../uvc.c      **** 
2180:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2181:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2182:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2183:../uvc.c      **** }
2184:../uvc.c      **** 
2185:../uvc.c      **** 
2186:../uvc.c      **** void
2187:../uvc.c      **** UVCAppThread_Entry (
2188:../uvc.c      ****         uint32_t input)
2189:../uvc.c      **** {
2190:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2191:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2192:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2193:../uvc.c      ****     uint8_t i = 0;
2194:../uvc.c      ****     uint32_t flag;
2195:../uvc.c      ****     uint32_t prinflag = 0;
2196:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2197:../uvc.c      ****     uint32_t frameCnt = 0;
2198:../uvc.c      **** #endif
2199:../uvc.c      ****     /* Initialize the Uart Debug Module */
2200:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2201:../uvc.c      **** 
2202:../uvc.c      ****     /* Initialize the I2C interface */
2203:../uvc.c      **** 	while (i++ < 6){
2204:../uvc.c      **** 		CyU3PThreadSleep(500);
2205:../uvc.c      **** 	}
2206:../uvc.c      **** 
2207:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2208:../uvc.c      **** 
2209:../uvc.c      ****     /* Initialize the UVC Application */
2210:../uvc.c      ****     CyFxUVCApplnInit ();
2211:../uvc.c      **** 
2212:../uvc.c      ****     /*
2213:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2214:../uvc.c      **** 
2215:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2216:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2217:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2218:../uvc.c      **** 
2219:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2220:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2221:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2222:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2223:../uvc.c      **** 
2224:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2225:../uvc.c      ****        of handling the abort request.
2226:../uvc.c      ****      */
2227:../uvc.c      **** 
2228:../uvc.c      ****     for (;;)
2229:../uvc.c      ****     {
2230:../uvc.c      ****         /* Waiting for the Video Stream Event */
2231:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2232:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2233:../uvc.c      ****         {
2234:../uvc.c      **** #if 0 //test for new firmware no video bring up
2235:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2236:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2237:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2238:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2239:../uvc.c      ****             {
2240:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2241:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2242:../uvc.c      ****                 {
2243:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2244:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2245:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2246:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2247:../uvc.c      **** #endif
2248:../uvc.c      **** #endif
2249:../uvc.c      ****                     }
2250:../uvc.c      ****                 else
2251:../uvc.c      ****                 {
2252:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2253:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2254:../uvc.c      **** #ifdef USB_LOWRES_IMG
2255:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2256:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2257:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2258:../uvc.c      **** #endif
2259:../uvc.c      **** #endif
2260:../uvc.c      ****                 }
2261:../uvc.c      **** 
2262:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2263:../uvc.c      ****                 prodCount++;
2264:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2265:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2266:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2267:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2268:../uvc.c      ****                 {
2269:../uvc.c      ****                     prodCount--;
2270:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2271:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2272:../uvc.c      ****                 }
2273:../uvc.c      ****             }
2274:../uvc.c      **** #endif
2275:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2276:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2277:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2278:../uvc.c      ****             {
2279:../uvc.c      ****             	if(0&&(prinflag == 0)){
2280:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2281:../uvc.c      ****             		prinflag = 1;
2282:../uvc.c      ****             	}
2283:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2284:../uvc.c      ****             	fb=0;
2285:../uvc.c      ****             	pb=0;
2286:../uvc.c      ****             	pbc=0;
2287:../uvc.c      ****                 prodCount = 0;
2288:../uvc.c      ****                 consCount = 0;
2289:../uvc.c      ****                 hitFV     = CyFalse;
2290:../uvc.c      **** 
2291:../uvc.c      **** #ifdef BACKFLOW_DETECT
2292:../uvc.c      ****                 back_flow_detected = 0;
2293:../uvc.c      **** #endif
2294:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2295:../uvc.c      ****                 frameCnt++;
2296:../uvc.c      **** #endif
2297:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2298:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2299:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2300:../uvc.c      ****                 //}
2301:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2302:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2303:../uvc.c      ****                 if(stiflag){
2304:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
2305:../uvc.c      ****                 	stiflag = CyFalse;
2306:../uvc.c      ****                 }else{
2307:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2308:../uvc.c      ****                 }
2309:../uvc.c      ****                 /* Reset the DMA channel. */
2310:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2311:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2312:../uvc.c      ****                 {
2313:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2314:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2315:../uvc.c      ****                 }
2316:../uvc.c      **** 
2317:../uvc.c      ****                 /* Start Channel Immediately */
2318:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2319:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2320:../uvc.c      ****                 {
2321:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2322:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2323:../uvc.c      ****                 }
2324:../uvc.c      **** 
2325:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2326:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2327:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2328:../uvc.c      ****                 }
2329:../uvc.c      ****         }
2330:../uvc.c      ****         else
2331:../uvc.c      ****         {
2332:../uvc.c      ****             /* If we have a stream abort request pending. */
2333:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2334:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2335:../uvc.c      ****             {
2336:../uvc.c      ****                 hitFV     = CyFalse;
2337:../uvc.c      ****                 prodCount = 0;
2338:../uvc.c      ****                 consCount = 0;
2339:../uvc.c      ****                 if(0&&(prinflag == 0)){
2340:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2341:../uvc.c      ****                 	prinflag = 1;
2342:../uvc.c      ****                 }
2343:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2344:../uvc.c      ****                 fb=0;
2345:../uvc.c      ****                 pb=0;
2346:../uvc.c      ****                 pbc=0;
2347:../uvc.c      **** 
2348:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2349:../uvc.c      ****                 {
2350:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2351:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2352:../uvc.c      ****                     {
2353:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2354:../uvc.c      ****                     }
2355:../uvc.c      **** 
2356:../uvc.c      ****                     /* Flush the Endpoint memory */
2357:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2358:../uvc.c      ****                 }
2359:../uvc.c      **** 
2360:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2361:../uvc.c      ****             }
2362:../uvc.c      ****             else
2363:../uvc.c      ****             {
2364:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2365:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2366:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2367:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2368:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2369:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2370:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2371:../uvc.c      ****                 {
2372:../uvc.c      ****                     /* Error handling */
2373:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2374:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2375:../uvc.c      ****                 }
2376:../uvc.c      **** 
2377:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2378:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2379:../uvc.c      ****                 {
2380:../uvc.c      ****                     //for start up of the AF Lens
2381:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2382:../uvc.c      ****                     CyU3PThreadSleep(500);
2383:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
2385:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2386:../uvc.c      ****                    	CyU3PThreadSleep(300);
2387:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2388:../uvc.c      ****                     CyU3PThreadSleep(500);
2389:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
2391:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2392:../uvc.c      ****                     gpif_initialized = CyTrue;
2393:../uvc.c      ****                     CyU3PThreadSleep(200);
2394:../uvc.c      ****                     
2395:../uvc.c      ****                 }
2396:../uvc.c      ****                 else
2397:../uvc.c      ****                 {
2398:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2399:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2401:../uvc.c      ****                 }
2402:../uvc.c      ****             }
2403:../uvc.c      ****         }
2404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2405:../uvc.c      **** 
2406:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2407:../uvc.c      ****         CyU3PThreadRelinquish ();
2408:../uvc.c      ****     }
2409:../uvc.c      **** }
2410:../uvc.c      **** 
2411:../uvc.c      **** /*
2412:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2413:../uvc.c      ****  */
2414:../uvc.c      **** 
2415:../uvc.c      **** static void
2416:../uvc.c      **** UVCHandleProcessingUnitRqts (
2417:../uvc.c      ****         void)
2418:../uvc.c      **** {
2419:../uvc.c      ****     uint8_t CtrlAdd;
2420:../uvc.c      **** #ifdef DbgInfo
2421:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2422:../uvc.c      **** #endif
2423:../uvc.c      ****     switch (wValue)
2424:../uvc.c      ****     {
2425:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2426:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2428:../uvc.c      ****     		break;
2429:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2430:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2432:../uvc.c      ****     		break;
2433:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2434:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2436:../uvc.c      **** 			break;
2437:../uvc.c      **** 
2438:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2439:../uvc.c      **** 
2440:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2441:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2443:../uvc.c      ****       		break;
2444:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2445:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2446:../uvc.c      ****      		ControlHandle(HueCtlID5);
2447:../uvc.c      ****      		break;
2448:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2449:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2451:../uvc.c      ****           		break;
2452:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2453:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2455:../uvc.c      ****           		break;
2456:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2457:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2458:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2459:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2461:../uvc.c      ****     		break;
2462:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2463:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2465:../uvc.c      ****     		break;
2466:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2467:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2469:../uvc.c      ****     		break;
2470:../uvc.c      **** 
2471:../uvc.c      ****         default:
2472:../uvc.c      ****             /*
2473:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2474:../uvc.c      ****              * other controls.
2475:../uvc.c      ****              */
2476:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2477:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2478:../uvc.c      ****             break;
2479:../uvc.c      ****     }
2480:../uvc.c      **** }
2481:../uvc.c      **** 
2482:../uvc.c      **** /*
2483:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2484:../uvc.c      ****  */
2485:../uvc.c      **** static void
2486:../uvc.c      **** UVCHandleCameraTerminalRqts (
2487:../uvc.c      ****         void)
2488:../uvc.c      **** {
2489:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2490:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2491:../uvc.c      ****     uint16_t readCount;
2492:../uvc.c      ****     uint16_t zoomVal;
2493:../uvc.c      ****     int32_t  panVal, tiltVal;
2494:../uvc.c      ****     CyBool_t sendData = CyFalse;
2495:../uvc.c      **** #endif
2496:../uvc.c      ****     uint8_t CtrlAdd;
2497:../uvc.c      **** 
2498:../uvc.c      ****     switch (wValue)
2499:../uvc.c      ****     {
2500:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2501:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2503:../uvc.c      ****     		break;
2504:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2505:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2507:../uvc.c      ****     		break;
2508:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2509:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2511:../uvc.c      **** 			break;
2512:../uvc.c      **** 
2513:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2514:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2516:../uvc.c      **** 			break;
2517:../uvc.c      **** 
2518:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2519:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2521:../uvc.c      ****       		break;
2522:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2523:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2525:../uvc.c      ****      		break;
2526:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2527:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2529:../uvc.c      ****           		break;
2530:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2531:../uvc.c      ****           		break;
2532:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2533:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2535:../uvc.c      ****      		break;
2536:../uvc.c      **** 
2537:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2538:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2540:../uvc.c      ****     		break;
2541:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2542:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2544:../uvc.c      ****     		break;
2545:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2546:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2548:../uvc.c      ****     		break;
2549:../uvc.c      **** 
2550:../uvc.c      ****         default:
2551:../uvc.c      ****             /*
2552:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2553:../uvc.c      ****              * other controls.
2554:../uvc.c      ****              */
2555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2556:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2557:../uvc.c      ****             break;
2558:../uvc.c      ****     }
2559:../uvc.c      **** 
2560:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2561:../uvc.c      ****     switch (wValue)
2562:../uvc.c      ****     {
2563:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2564:../uvc.c      ****             switch (bRequest)
2565:../uvc.c      ****             {
2566:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2567:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2568:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2569:../uvc.c      ****                     break;
2570:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2571:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2572:../uvc.c      ****                     sendData = CyTrue;
2573:../uvc.c      ****                     break;
2574:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2575:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2576:../uvc.c      ****                     sendData = CyTrue;
2577:../uvc.c      ****                     break;
2578:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2579:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2580:../uvc.c      ****                     sendData = CyTrue;
2581:../uvc.c      ****                     break;
2582:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2583:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2584:../uvc.c      ****                     sendData = CyTrue;
2585:../uvc.c      ****                     break;
2586:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2587:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2588:../uvc.c      ****                     sendData = CyTrue;
2589:../uvc.c      ****                     break;
2590:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2591:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2592:../uvc.c      ****                             glEp0Buffer, &readCount);
2593:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2594:../uvc.c      ****                     {
2595:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2596:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2597:../uvc.c      ****                     }
2598:../uvc.c      ****                     break;
2599:../uvc.c      ****                 default:
2600:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2601:../uvc.c      ****                     break;
2602:../uvc.c      ****             }
2603:../uvc.c      **** 
2604:../uvc.c      ****             if (sendData)
2605:../uvc.c      ****             {
2606:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2607:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2608:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2609:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2610:../uvc.c      ****             }
2611:../uvc.c      ****             break;
2612:../uvc.c      **** 
2613:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2614:../uvc.c      ****             switch (bRequest)
2615:../uvc.c      ****             {
2616:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2617:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2618:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2619:../uvc.c      ****                     break;
2620:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2621:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2622:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2623:../uvc.c      ****                     sendData = CyTrue;
2624:../uvc.c      ****                     break;
2625:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2626:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2627:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2628:../uvc.c      ****                     sendData = CyTrue;
2629:../uvc.c      ****                     break;
2630:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2631:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2632:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2633:../uvc.c      ****                     sendData = CyTrue;
2634:../uvc.c      ****                     break;
2635:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2636:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2637:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2638:../uvc.c      ****                     sendData = CyTrue;
2639:../uvc.c      ****                     break;
2640:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2641:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2642:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2643:../uvc.c      ****                     sendData = CyTrue;
2644:../uvc.c      ****                     break;
2645:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2646:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2647:../uvc.c      ****                             glEp0Buffer, &readCount);
2648:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2649:../uvc.c      ****                     {
2650:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2651:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2652:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2653:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2654:../uvc.c      **** 
2655:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2656:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2657:../uvc.c      ****                     }
2658:../uvc.c      ****                     break;
2659:../uvc.c      ****                 default:
2660:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2661:../uvc.c      ****                     break;
2662:../uvc.c      ****             }
2663:../uvc.c      **** 
2664:../uvc.c      ****             if (sendData)
2665:../uvc.c      ****             {
2666:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2667:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2668:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2669:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2670:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2671:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2672:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2673:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2674:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2675:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2676:../uvc.c      ****             }
2677:../uvc.c      ****             break;
2678:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2679:../uvc.c      ****         default:
2680:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2681:../uvc.c      ****             break;
2682:../uvc.c      ****     }
2683:../uvc.c      **** #endif
2684:../uvc.c      **** }
2685:../uvc.c      **** 
2686:../uvc.c      **** /*
2687:../uvc.c      ****  * Handler for UVC Interface control requests.
2688:../uvc.c      ****  */
2689:../uvc.c      **** static void
2690:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2691:../uvc.c      ****         void)
2692:../uvc.c      **** {
2693:../uvc.c      **** 
2694:../uvc.c      ****     switch (wValue)
2695:../uvc.c      ****     {
2696:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2697:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2698:../uvc.c      ****     		break;
2699:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2700:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2701:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2702:../uvc.c      ****     		break;
2703:../uvc.c      ****     	default:
2704:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2705:../uvc.c      ****      		break;
2706:../uvc.c      ****     }
2707:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2708:../uvc.c      **** 
2709:../uvc.c      **** }
2710:../uvc.c      **** 
2711:../uvc.c      **** /*
2712:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2713:../uvc.c      ****  */
2714:../uvc.c      **** static void
2715:../uvc.c      **** UVCHandleExtensionUnitRqts (
2716:../uvc.c      ****         void)
2717:../uvc.c      **** {
2718:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2719:../uvc.c      **** 
2720:../uvc.c      **** #ifdef DbgInfo
2721:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2722:../uvc.c      **** #endif
2723:../uvc.c      ****     switch (wValue)
2724:../uvc.c      ****     {
2725:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2726:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2727:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2728:../uvc.c      ****     		break;
2729:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2730:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2731:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2732:../uvc.c      ****     		break;
2733:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2734:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2735:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2736:../uvc.c      ****      		break;
2737:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2738:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2739:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2740:../uvc.c      ****     		break;
2741:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2742:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2743:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2744:../uvc.c      ****     		break;
2745:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2746:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2747:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2748:../uvc.c      ****      		break;
2749:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2750:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2751:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2752:../uvc.c      ****     		break;
2753:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2754:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2755:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2756:../uvc.c      ****     		break;
2757:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2758:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2759:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2760:../uvc.c      ****      		break;
2761:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2762:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2763:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2764:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2765:../uvc.c      ****     		}else/* no support for 1080p camera */
2766:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2767:../uvc.c      ****     		break;
2768:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2769:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2770:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2771:../uvc.c      ****     		break;
2772:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2773:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2774:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2775:../uvc.c      ****     		break;
2776:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2777:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2778:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2779:../uvc.c      ****     		//break;
2780:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2781:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2782:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2783:../uvc.c      ****     		break;
2784:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2785:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2786:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2787:../uvc.c      ****     		break;
2788:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2789:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2790:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2791:../uvc.c      ****     		break;
2792:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2793:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2794:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2795:../uvc.c      ****     		break;
2796:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2797:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2798:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2799:../uvc.c      ****     		break;
2800:../uvc.c      ****    	default:
2801:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2802:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2803:../uvc.c      ****     		break;
2804:../uvc.c      ****     }
2805:../uvc.c      **** 
2806:../uvc.c      **** }
2807:../uvc.c      **** 
2808:../uvc.c      **** /*
2809:../uvc.c      ****  * Handler for the video streaming control requests.
2810:../uvc.c      ****  */
2811:../uvc.c      **** static void
2812:../uvc.c      **** UVCHandleVideoStreamingRqts (
2813:../uvc.c      ****         void)
2814:../uvc.c      **** {
2815:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2816:../uvc.c      ****     uint16_t readCount;
2817:../uvc.c      **** 
2818:../uvc.c      ****     switch (wValue)
2819:../uvc.c      ****     {
2820:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2821:../uvc.c      ****             switch (bRequest)
2822:../uvc.c      ****             {
2823:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2824:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2825:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2826:../uvc.c      ****                     break;
2827:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2828:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2829:../uvc.c      ****                     glEp0Buffer[1] = 0;
2830:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2831:../uvc.c      ****                     break;
2832:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2833:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2834:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2835:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2836:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2837:../uvc.c      ****                     {
2838:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2839:../uvc.c      ****                     }
2840:../uvc.c      ****                     else
2841:../uvc.c      ****                     {
2842:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2843:../uvc.c      ****                     }
2844:../uvc.c      ****                     break;
2845:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2846:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2847:../uvc.c      ****                             glCommitCtrl, &readCount);
2848:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2849:../uvc.c      ****                     {
2850:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2851:../uvc.c      ****                         {
2852:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2853:../uvc.c      ****                                active data structure. */
2854:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2855:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2856:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2857:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2858:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2859:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2860:../uvc.c      ****                         }
2861:../uvc.c      ****                     }
2862:../uvc.c      ****                     break;
2863:../uvc.c      ****                 default:
2864:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2865:../uvc.c      ****                     break;
2866:../uvc.c      ****             }
2867:../uvc.c      ****             break;
2868:../uvc.c      **** 
2869:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2870:../uvc.c      ****             switch (bRequest)
2871:../uvc.c      ****             {
2872:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2873:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2874:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2875:../uvc.c      ****                     break;
2876:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2877:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2878:../uvc.c      ****                     glEp0Buffer[1] = 0;
2879:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2880:../uvc.c      ****                     break;
2881:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2882:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2883:../uvc.c      ****                     {
2884:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2885:../uvc.c      ****                     }
2886:../uvc.c      ****                     else
2887:../uvc.c      ****                     {
2888:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2889:../uvc.c      ****                     }
2890:../uvc.c      ****                     break;
2891:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2892:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2893:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2894:../uvc.c      ****                        */
2895:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2896:../uvc.c      ****                             glCommitCtrl, &readCount);
2897:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2898:../uvc.c      ****                     {
2899:../uvc.c      **** #if 0
2900:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2901:../uvc.c      ****                         {
2902:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2903:../uvc.c      ****                         }
2904:../uvc.c      ****                         else
2905:../uvc.c      ****                         {
2906:../uvc.c      ****                             SensorScaling_VGA ();
2907:../uvc.c      ****                         }
2908:../uvc.c      **** #endif
2909:../uvc.c      ****                         /* We can start streaming video now. */
2910:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2911:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2912:../uvc.c      ****                         {
2913:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2914:../uvc.c      ****                         }
2915:../uvc.c      ****                     }
2916:../uvc.c      ****                     break;
2917:../uvc.c      **** 
2918:../uvc.c      ****                 default:
2919:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2920:../uvc.c      ****                     break;
2921:../uvc.c      ****             }
2922:../uvc.c      ****             break;
2923:../uvc.c      **** 
2924:../uvc.c      **** /* still image streaming handler */
2925:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2926:../uvc.c      ****                 switch (bRequest)
2927:../uvc.c      ****                 {
2928:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2929:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2930:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2931:../uvc.c      ****                         break;
2932:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2933:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2934:../uvc.c      ****                         glEp0Buffer[1] = 0;
2935:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2936:../uvc.c      ****                         break;
2937:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2938:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2939:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2940:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2941:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2942:../uvc.c      ****                         {
2943:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2944:../uvc.c      ****                         }
2945:../uvc.c      ****                         else
2946:../uvc.c      ****                         {
2947:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2948:../uvc.c      ****                         }
2949:../uvc.c      ****                         break;
2950:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2951:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2952:../uvc.c      ****                                 glCommitCtrl, &readCount);
2953:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2954:../uvc.c      ****                         {
2955:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
2956:../uvc.c      ****                             {
2957:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2958:../uvc.c      ****                                    active data structure. */
2959:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
2960:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
2961:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
2962:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
2963:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
2964:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
2965:../uvc.c      ****                             }
2966:../uvc.c      ****                         }
2967:../uvc.c      ****                         break;
2968:../uvc.c      ****                     default:
2969:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2970:../uvc.c      ****                         break;
2971:../uvc.c      ****                 }
2972:../uvc.c      ****                 break;
2973:../uvc.c      **** 
2974:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
2975:../uvc.c      ****                 switch (bRequest)
2976:../uvc.c      ****                 {
2977:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2978:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2979:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2980:../uvc.c      ****                         break;
2981:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2982:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2983:../uvc.c      ****                         glEp0Buffer[1] = 0;
2984:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2985:../uvc.c      ****                         break;
2986:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2987:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2988:../uvc.c      ****                         {
2989:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2990:../uvc.c      ****                         }
2991:../uvc.c      ****                         else
2992:../uvc.c      ****                         {
2993:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2994:../uvc.c      ****                         }
2995:../uvc.c      ****                         break;
2996:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2997:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
2998:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
2999:../uvc.c      ****                            */
3000:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3001:../uvc.c      ****                                 glCommitCtrl, &readCount);
3002:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3003:../uvc.c      ****                         {
3004:../uvc.c      ****     #if 0
3005:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3006:../uvc.c      ****                             {
3007:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3008:../uvc.c      ****                             }
3009:../uvc.c      ****                             else
3010:../uvc.c      ****                             {
3011:../uvc.c      ****                                 SensorScaling_VGA ();
3012:../uvc.c      ****                             }
3013:../uvc.c      ****     #endif
3014:../uvc.c      ****                             /* We can start streaming video now. */
3015:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3016:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3017:../uvc.c      ****                             {
3018:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3019:../uvc.c      ****                             }
3020:../uvc.c      ****                         }
3021:../uvc.c      ****                         break;
3022:../uvc.c      **** 
3023:../uvc.c      ****                     default:
3024:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3025:../uvc.c      ****                         break;
3026:../uvc.c      ****                 }
3027:../uvc.c      ****                 break;
3028:../uvc.c      **** 
3029:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3030:../uvc.c      ****                 switch (bRequest)
3031:../uvc.c      ****                 {
3032:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3033:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3034:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3035:../uvc.c      ****                         break;
3036:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3037:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3038:../uvc.c      ****                         glEp0Buffer[1] = 0;
3039:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3040:../uvc.c      ****                         break;
3041:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3042:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3043:../uvc.c      ****                         {
3044:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3045:../uvc.c      ****                         }
3046:../uvc.c      ****                         else
3047:../uvc.c      ****                         {
3048:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3049:../uvc.c      ****                         }
3050:../uvc.c      ****                         break;
3051:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3052:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3053:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3054:../uvc.c      ****                            */
3055:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3056:../uvc.c      ****                                 glCommitCtrl, &readCount);
3057:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3058:../uvc.c      ****                         {
3059:../uvc.c      ****     #if 0
3060:../uvc.c      ****                             /* We can start streaming video now. */
3061:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3062:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3063:../uvc.c      ****                             {
3064:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3065:../uvc.c      ****                             }
3066:../uvc.c      ****     #endif
3067:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3068:../uvc.c      ****                         }else{
3069:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3070:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3071:../uvc.c      ****                         }
3072:../uvc.c      ****                         break;
3073:../uvc.c      **** 
3074:../uvc.c      ****                     default:
3075:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3076:../uvc.c      ****                         break;
3077:../uvc.c      ****                 }
3078:../uvc.c      ****                 break;
3079:../uvc.c      **** 
3080:../uvc.c      ****         default:
3081:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3082:../uvc.c      ****             break;
3083:../uvc.c      ****     }
3084:../uvc.c      **** }
3085:../uvc.c      **** 
3086:../uvc.c      **** /*
3087:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3088:../uvc.c      ****  */
3089:../uvc.c      **** void
3090:../uvc.c      **** UVCAppEP0Thread_Entry (
3091:../uvc.c      ****         uint32_t input)
3092:../uvc.c      **** {
3093:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3094:../uvc.c      ****     uint32_t eventFlag;
3095:../uvc.c      **** 	CyBool_t value;
3096:../uvc.c      **** 	CyBool_t *valueptr = &value;
3097:../uvc.c      **** 
3098:../uvc.c      **** 
3099:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3100:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3101:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3102:../uvc.c      **** 
3103:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3104:../uvc.c      **** #endif
3105:../uvc.c      **** 
3106:../uvc.c      ****     /* for interrupt status test */
3107:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3108:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3109:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3110:../uvc.c      **** 
3111:../uvc.c      ****     for (;;)
3112:../uvc.c      ****     {
3113:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3114:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3115:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3116:../uvc.c      ****         {
3117:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3118:../uvc.c      ****             if (!isUsbConnected)
3119:../uvc.c      ****             {
3120:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3121:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3122:../uvc.c      ****                 {
3123:../uvc.c      ****                     isUsbConnected = CyTrue;
3124:../uvc.c      ****                 }
3125:../uvc.c      ****             }
3126:../uvc.c      **** //#ifdef DbgInfo
3127:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3128:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3129:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3130:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3131:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3132:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3133:../uvc.c      **** //#endif
3134:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3135:../uvc.c      ****             {
3136:../uvc.c      ****             	switch ((wIndex >> 8))
3137:../uvc.c      ****                 {
3138:../uvc.c      **** 
3139:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3140:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3141:../uvc.c      ****                         break;
3142:../uvc.c      **** 
3143:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3144:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3145:../uvc.c      ****                         break;
3146:../uvc.c      **** 
3147:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3148:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3149:../uvc.c      ****                         break;
3150:../uvc.c      **** 
3151:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3152:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3153:../uvc.c      ****                         break;
3154:../uvc.c      **** 
3155:../uvc.c      ****                     default:
3156:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3157:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3158:../uvc.c      ****                         break;
3159:../uvc.c      ****                 }
3160:../uvc.c      ****             }
3161:../uvc.c      **** 
3162:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3163:../uvc.c      ****             {
3164:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3165:../uvc.c      **** 
3166:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3167:../uvc.c      ****                 {
3168:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3169:../uvc.c      ****                 }
3170:../uvc.c      ****                 else
3171:../uvc.c      ****                 {
3172:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3173:../uvc.c      ****                 }
3174:../uvc.c      ****             }
3175:../uvc.c      **** 
3176:../uvc.c      ****             /* handle interrupt status event */
3177:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3178:../uvc.c      ****             {
3179:../uvc.c      **** 
3180:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3181:../uvc.c      ****             	/** preparing interrupt status data **/
3182:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3183:../uvc.c      **** 
3184:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3185:../uvc.c      **** 
3186:../uvc.c      **** #if 1 //for real button
3187:../uvc.c      **** 				if(value&&(!snapButFlag)){
3188:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3189:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3190:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3191:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3192:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3193:../uvc.c      **** 
3194:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3195:../uvc.c      **** 					interStabuf.size   = 1024;
3196:../uvc.c      **** 					interStabuf.status = 0;
3197:../uvc.c      **** 
3198:../uvc.c      **** 					interStabuf.count = 4;
3199:../uvc.c      **** 
3200:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3202:../uvc.c      **** 
3203:../uvc.c      **** 					/** send a interrupt status data **/
3204:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3205:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3206:../uvc.c      **** 					{
3207:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3208:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3209:../uvc.c      **** 					}
3210:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3211:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3212:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3213:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3214:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3215:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3216:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3217:../uvc.c      **** 
3218:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3219:../uvc.c      **** 					interStabuf.size   = 1024;
3220:../uvc.c      **** 					interStabuf.status = 0;
3221:../uvc.c      **** 
3222:../uvc.c      **** 					interStabuf.count = 4;
3223:../uvc.c      **** 
3224:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3225:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3226:../uvc.c      **** 
3227:../uvc.c      **** 					/** send a interrupt status data **/
3228:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3229:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3230:../uvc.c      **** 					{
3231:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3232:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3233:../uvc.c      **** 					}
3234:../uvc.c      **** 
3235:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3236:../uvc.c      **** 					stiflag = CyTrue;
3237:../uvc.c      **** 				}
3238:../uvc.c      **** #else			//for botton simulation
3239:../uvc.c      **** 				if(snapButFlag == 0x0f){
3240:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3241:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3242:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3243:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3244:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3245:../uvc.c      **** 
3246:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3247:../uvc.c      **** 					interStabuf.size   = 1024;
3248:../uvc.c      **** 					interStabuf.status = 0;
3249:../uvc.c      **** 
3250:../uvc.c      **** 					interStabuf.count = 4;
3251:../uvc.c      **** 
3252:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3253:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3254:../uvc.c      **** 
3255:../uvc.c      **** 					/** send a interrupt status data **/
3256:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3257:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3258:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3259:../uvc.c      **** 					{
3260:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3261:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3262:../uvc.c      **** 					}
3263:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3264:../uvc.c      **** 
3265:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3266:../uvc.c      **** 				}else if(!snapButFlag){
3267:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3268:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3269:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3270:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3271:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3272:../uvc.c      **** 
3273:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3274:../uvc.c      **** 					interStabuf.size   = 1024;
3275:../uvc.c      **** 					interStabuf.status = 0;
3276:../uvc.c      **** 
3277:../uvc.c      **** 					interStabuf.count = 4;
3278:../uvc.c      **** 
3279:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3280:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3281:../uvc.c      **** 
3282:../uvc.c      **** 					/** send a interrupt status data **/
3283:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3284:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3285:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3286:../uvc.c      **** 					{
3287:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3288:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3289:../uvc.c      **** 					}
3290:../uvc.c      **** 
3291:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3292:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3293:../uvc.c      **** 				}
3294:../uvc.c      **** #endif
3295:../uvc.c      **** 
3296:../uvc.c      ****             }
3297:../uvc.c      **** 
3298:../uvc.c      **** 
3299:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3300:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3301:../uvc.c      ****             {
3302:../uvc.c      ****                 /* Get the command buffer */
3303:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3304:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3305:../uvc.c      ****                 {
3306:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3307:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3308:../uvc.c      ****                 }
3309:../uvc.c      **** 
3310:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3311:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3312:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3313:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3314:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3315:../uvc.c      ****                  * register value high byte and register value low byte.
3316:../uvc.c      ****                  */
3317:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3318:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3319:../uvc.c      ****                 {
3320:../uvc.c      ****                     if (dmaInfo.count == 3)
3321:../uvc.c      ****                     {
3322:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3323:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3324:../uvc.c      ****                         dmaInfo.count = 3;
3325:../uvc.c      ****                     }
3326:../uvc.c      ****                     else if (dmaInfo.count == 4)
3327:../uvc.c      ****                     {
3328:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3329:../uvc.c      ****                         {
3330:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3331:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3332:../uvc.c      ****                         }
3333:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3334:../uvc.c      ****                     }
3335:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3336:../uvc.c      ****                 }
3337:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3338:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3339:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3340:../uvc.c      ****                  */
3341:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3342:../uvc.c      ****                 {
3343:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3344:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3345:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3346:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3347:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3348:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3349:../uvc.c      ****                         	break;
3350:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3351:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3352:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3353:../uvc.c      ****                         	break;*/
3354:../uvc.c      ****                     dmaInfo.count -= 2;
3355:../uvc.c      ****                 }
3356:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3357:../uvc.c      ****                 else
3358:../uvc.c      ****                 {
3359:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3360:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3361:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3362:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3363:../uvc.c      ****                 }
3364:../uvc.c      **** 
3365:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3366:../uvc.c      ****                 dmaInfo.size   = 1024;
3367:../uvc.c      ****                 dmaInfo.status = 0;
3368:../uvc.c      **** 
3369:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3370:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3371:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3372:../uvc.c      ****                 {
3373:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3374:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3375:../uvc.c      ****                 }
3376:../uvc.c      **** 
3377:../uvc.c      ****                 /* Wait until the response has gone out. */
3378:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3379:../uvc.c      **** 
3380:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3381:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3382:../uvc.c      ****                 {
3383:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3384:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3385:../uvc.c      ****                 }
3386:../uvc.c      ****             }
3387:../uvc.c      **** #endif
3388:../uvc.c      ****         }
3389:../uvc.c      ****         /* Allow other ready threads to run. */
3390:../uvc.c      ****         CyU3PThreadRelinquish ();
3391:../uvc.c      ****     }
3392:../uvc.c      **** }
3393:../uvc.c      **** 
3394:../uvc.c      **** /*
3395:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3396:../uvc.c      ****  * added 10/2013
3397:../uvc.c      ****  */
3398:../uvc.c      **** /*
3399:../uvc.c      **** static uint8_t timeDelay[64] = {
3400:../uvc.c      **** 
3401:../uvc.c      **** };
3402:../uvc.c      **** */
3403:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3403 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3404:../uvc.c      **** 
3405:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3406:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3407:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3408:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3409:../uvc.c      **** 	VdstateDes *lcStaDes;
3410:../uvc.c      **** 	uint32_t flag = 0;
3411:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3412:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3413:../uvc.c      **** 	uint8_t i;
3414:../uvc.c      **** 	uint16_t delaytime;
3415:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3416:../uvc.c      **** 
3417:../uvc.c      **** #if 0 //for test the command queue
3418:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3419:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3420:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3421:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3422:../uvc.c      **** 		lcCmdDes += 1;
3423:../uvc.c      **** 	}
3424:../uvc.c      **** #endif
3425:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3426:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3426 0
  36 0004 00229FE5 		ldr	r2, .L22
3410:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3410 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3403:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3403 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3426 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 E8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3410:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3410 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3426 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3427:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3427 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 CC119FE5 		ldr	r1, .L22+8
  71 0044 CC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3428:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3428 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3429:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3429 0
  79 005c AC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3430:../uvc.c      **** 
3431:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3431 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3432:../uvc.c      ****         /* Allow other ready threads to run. */
3433:../uvc.c      **** 
3434:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3434 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3431:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3431 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3435:../uvc.c      **** 	}
3436:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3436 0
  92 0078 98019FE5 		ldr	r0, .L22+12
  93 007c 98119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 88719FE5 		ldr	r7, .L22+20
  99 0094 88B19FE5 		ldr	fp, .L22+24
3437:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3438:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3439:../uvc.c      **** 	//CyU3PThreadSleep(100);
3440:../uvc.c      **** 	//SetCurCmd();
3441:../uvc.c      **** 	/*********** the loop of the thread ***********/
3442:../uvc.c      **** 	for(;;){
3443:../uvc.c      **** 
3444:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3444 0
 101 0098 0060E0E3 		mvn	r6, #0
3445:../uvc.c      **** /*  // for test GPIO output
3446:../uvc.c      **** 		if(trigger)
3447:../uvc.c      **** 		{
3448:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3449:../uvc.c      **** 			{
3450:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3451:../uvc.c      **** 			}
3452:../uvc.c      **** 
3453:../uvc.c      **** 		}else{
3454:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3455:../uvc.c      **** 			{
3456:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3457:../uvc.c      **** 			}
3458:../uvc.c      **** 
3459:../uvc.c      **** 		}
3460:../uvc.c      **** */
3461:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3462:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3463:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3464:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3465:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3466:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3467:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3468:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3469:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3470:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3471:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3472:../uvc.c      **** #endif
3473:../uvc.c      **** 				}
3474:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3475:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3476:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3477:../uvc.c      **** 			}
3478:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3479:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3480:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3481:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3482:../uvc.c      **** 
3483:../uvc.c      **** 				/*
3484:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3485:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3486:../uvc.c      **** 				*/
3487:../uvc.c      **** 
3488:../uvc.c      **** 				/* find a available command */
3489:../uvc.c      **** 				i = 0;
3490:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3490 0
 103 009c 0090A0E3 		mov	r9, #0
3491:../uvc.c      **** 					i++;
3492:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3493:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3494:../uvc.c      **** 				}
3495:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3496:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3497:../uvc.c      **** 					i = lcCmdDes->curNum;
3498:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3499:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3500:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3501:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3502:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3503:../uvc.c      **** 						case 0x20:
3504:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3505:../uvc.c      **** 							delaytime = 500;
3506:../uvc.c      **** 							break;
3507:../uvc.c      **** 						case 0x21:
3508:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3509:../uvc.c      **** 							delaytime = 500;
3510:../uvc.c      **** 							break;
3511:../uvc.c      **** 						case 0x22:
3512:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3513:../uvc.c      **** 							delaytime = 300;
3514:../uvc.c      **** 							break;
3515:../uvc.c      **** 						case 0x23:
3516:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3517:../uvc.c      **** 							delaytime = 300;
3518:../uvc.c      **** 							break;
3519:../uvc.c      **** 						default:
3520:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3521:../uvc.c      **** 							break;
3522:../uvc.c      **** 					}
3523:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3524:../uvc.c      **** 					/** timer's ticket modify **/
3525:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3526:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3527:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3528:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3529:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3530:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3531:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3532:../uvc.c      **** #endif
3533:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3534:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3535:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3536:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3537:../uvc.c      **** 						}else{
3538:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3539:../uvc.c      **** 						}
3540:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3541:../uvc.c      **** 					}else{
3542:../uvc.c      **** 						lcCmdDes->curNum ++;
3543:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3543 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3444:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3444 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 70019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3461:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3461 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3478:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3478 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3480:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3480 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3481:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3481 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3490:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3490 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3492:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3492 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3491:../uvc.c      **** 					i++;
 140              		.loc 1 3491 0
 141 00f4 011083E2 		add	r1, r3, #1
3490:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3490 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3491:../uvc.c      **** 					i++;
 144              		.loc 1 3491 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3490:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3490 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3496:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3496 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2900000A 		beq	.L6
 157              	.LVL10:
3498:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3498 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3502:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3502 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3498:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3498 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3502:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3502 0
 166 0128 20C042E2 		sub	ip, r2, #32
3498:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3498 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3499:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3499 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3500:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3500 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3501:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3501 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3502:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3502 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 58010000 		.word	.L9
 185 014c 58010000 		.word	.L9
 186 0150 A4010000 		.word	.L11
 187 0154 A4010000 		.word	.L11
 188              	.L9:
3508:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 189              		.loc 1 3508 0
 190 0158 5230A0E3 		mov	r3, #82
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3510:../uvc.c      **** 							break;
 193              		.loc 1 3510 0
 194 0160 7D1FA0E3 		mov	r1, #500
 195              	.LVL16:
 196              	.L13:
3525:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3525 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 A0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3526:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3526 0
 202 0170 98009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3533:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3533 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3542:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3542 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3543 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3533:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3533 0
 215 0190 1000000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3544:../uvc.c      **** 					}
3545:../uvc.c      **** 				}else{
3546:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3547:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3548:../uvc.c      **** 				}
3549:../uvc.c      **** 			}
3550:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3550 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3551:../uvc.c      **** /*
3552:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3553:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3554:../uvc.c      **** */
3555:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3556:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3557:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3558:../uvc.c      **** #endif
3559:../uvc.c      **** 
3560:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3561:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3562:../uvc.c      **** #if 0
3563:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3564:../uvc.c      **** 
3565:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3566:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3567:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3568:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3569:../uvc.c      **** 			    i = 0;
3570:../uvc.c      **** 				 switch(cmdCopyIdx)
3571:../uvc.c      **** 				 {
3572:../uvc.c      **** 					 case BrgtCtlID1:
3573:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3574:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3575:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3576:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3577:../uvc.c      **** 							 i++;
3578:../uvc.c      **** 						 }
3579:../uvc.c      **** 						 else{
3580:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3581:../uvc.c      **** 						 }
3582:../uvc.c      **** 
3583:../uvc.c      **** 						 CyU3PBusyWait(500);
3584:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3585:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3586:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3587:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3588:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3589:../uvc.c      **** 						 }
3590:../uvc.c      **** 						 else{
3591:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3592:../uvc.c      **** 						 }
3593:../uvc.c      **** 						 break;
3594:../uvc.c      **** 					 case HueCtlID5:
3595:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3596:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3597:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3598:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3599:../uvc.c      **** 						 }
3600:../uvc.c      **** 						 else{
3601:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3602:../uvc.c      **** 						 }
3603:../uvc.c      **** 						 break;
3604:../uvc.c      **** 					 case SaturCtlID6:
3605:../uvc.c      **** 					 case WBTLevCtlID10:
3606:../uvc.c      **** 					 default:
3607:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3608:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3609:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3610:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3611:../uvc.c      **** 						 }
3612:../uvc.c      **** 						 else{
3613:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3614:../uvc.c      **** 						 }
3615:../uvc.c      **** 						 break;
3616:../uvc.c      **** 				 }
3617:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3618:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3619:../uvc.c      **** 			}
3620:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3621:../uvc.c      **** #endif
3622:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3623:../uvc.c      **** 		/* Allow other ready threads to run. */
3624:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3625:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3625 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3626:../uvc.c      **** 		}
 224              		.loc 1 3626 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L11:
3516:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
 228              		.loc 1 3516 0
 229 01a4 8230A0E3 		mov	r3, #130
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3518:../uvc.c      **** 							break;
 232              		.loc 1 3518 0
 233 01ac 4B1FA0E3 		mov	r1, #300
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3520:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3520 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3521:../uvc.c      **** 							break;
 241              		.loc 1 3521 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L6:
3546:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 245              		.loc 1 3546 0
 246 01c0 FA1FA0E3 		mov	r1, #1000
 247 01c4 44009FE5 		ldr	r0, .L22+4
 248 01c8 FEFFFFEB 		bl	_txe_timer_change
3547:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 249              		.loc 1 3547 0
 250 01cc 3C009FE5 		ldr	r0, .L22+4
 251 01d0 FEFFFFEB 		bl	_txe_timer_activate
 252 01d4 EEFFFFEA 		b	.L17
 253              	.LVL25:
 254              	.L21:
3535:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 255              		.loc 1 3535 0
 256 01d8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3534:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 257              		.loc 1 3534 0
 258 01dc 3C9084E5 		str	r9, [r4, #60]
3535:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 259              		.loc 1 3535 0
 260 01e0 23005CE3 		cmp	ip, #35
3536:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 261              		.loc 1 3536 0
 262 01e4 20C04C82 		subhi	ip, ip, #32
 263 01e8 8CC08C80 		addhi	ip, ip, ip, asl #1
3538:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 264              		.loc 1 3538 0
 265 01ec 8CC08C90 		addls	ip, ip, ip, asl #1
3536:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 266              		.loc 1 3536 0
 267 01f0 8CC18B80 		addhi	ip, fp, ip, asl #3
3538:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 268              		.loc 1 3538 0
 269 01f4 8CC18B90 		addls	ip, fp, ip, asl #3
3536:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 270              		.loc 1 3536 0
 271 01f8 1090CC85 		strhib	r9, [ip, #16]
3538:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 272              		.loc 1 3538 0
 273 01fc 9091CC95 		strlsb	r9, [ip, #400]
3540:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 274              		.loc 1 3540 0
 275 0200 344094E5 		ldr	r4, [r4, #52]
 276              	.LVL26:
 277 0204 104085E5 		str	r4, [r5, #16]
 278 0208 E1FFFFEA 		b	.L17
 279              	.L23:
 280              		.align	2
 281              	.L22:
 282 020c 00000000 		.word	I2CCmdCb
 283 0210 00000000 		.word	I2CCmdTimer
 284 0214 00000000 		.word	.LC0
 285 0218 00000000 		.word	cmdQu
 286 021c 14000000 		.word	.LC1
 287 0220 00000000 		.word	statQu
 288 0224 00000000 		.word	.LANCHOR1
 289 0228 00000000 		.word	.LANCHOR0
 290              		.cfi_endproc
 291              	.LFE25:
 293              		.align	2
 294              		.global	I2CCmdCb
 296              	I2CCmdCb:
 297              	.LFB17:
2180:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 298              		.loc 1 2180 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 0
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302              		@ link register save eliminated.
 303              	.LVL27:
2182:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 304              		.loc 1 2182 0
 305 022c 08009FE5 		ldr	r0, .L25
 306              	.LVL28:
 307 0230 2010A0E3 		mov	r1, #32
 308 0234 0020A0E3 		mov	r2, #0
2183:../uvc.c      **** }
 309              		.loc 1 2183 0
2182:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 310              		.loc 1 2182 0
 311 0238 FEFFFFEA 		b	_txe_event_flags_set
 312              	.L26:
 313              		.align	2
 314              	.L25:
 315 023c 00000000 		.word	.LANCHOR0
 316              		.cfi_endproc
 317              	.LFE17:
 319              		.align	2
 320              		.global	CyFxUvcApplnDmaCallback
 322              	CyFxUvcApplnDmaCallback:
 323              	.LFB10:
1470:../uvc.c      **** {
 324              		.loc 1 1470 0
 325              		.cfi_startproc
 326              		@ args = 0, pretend = 0, frame = 0
 327              		@ frame_needed = 0, uses_anonymous_args = 0
 328              	.LVL29:
1474:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 329              		.loc 1 1474 0
 330 0240 080051E3 		cmp	r1, #8
1470:../uvc.c      **** {
 331              		.loc 1 1470 0
 332 0244 30402DE9 		stmfd	sp!, {r4, r5, lr}
 333              	.LCFI2:
 334              		.cfi_def_cfa_offset 12
 335 0248 0240A0E1 		mov	r4, r2
 336              		.cfi_offset 14, -4
 337              		.cfi_offset 5, -8
 338              		.cfi_offset 4, -12
 339 024c 0CD04DE2 		sub	sp, sp, #12
 340              	.LCFI3:
 341              		.cfi_def_cfa_offset 24
1474:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 342              		.loc 1 1474 0
 343 0250 0B00000A 		beq	.L32
1503:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 344              		.loc 1 1503 0
 345 0254 100051E3 		cmp	r1, #16
 346 0258 0700001A 		bne	.L27
1505:../uvc.c      ****         consCount++;
 347              		.loc 1 1505 0
 348 025c 04319FE5 		ldr	r3, .L34
1506:../uvc.c      ****         streamingStarted = CyTrue;
 349              		.loc 1 1506 0
 350 0260 0120A0E3 		mov	r2, #1
 351              	.LVL30:
1505:../uvc.c      ****         consCount++;
 352              		.loc 1 1505 0
 353 0264 B0C3D3E1 		ldrh	ip, [r3, #48]
1506:../uvc.c      ****         streamingStarted = CyTrue;
 354              		.loc 1 1506 0
 355 0268 342083E5 		str	r2, [r3, #52]
1505:../uvc.c      ****         consCount++;
 356              		.loc 1 1505 0
 357 026c 02008CE0 		add	r0, ip, r2
 358              	.LVL31:
 359 0270 0018A0E1 		mov	r1, r0, asl #16
 360              	.LVL32:
 361 0274 2128A0E1 		mov	r2, r1, lsr #16
 362 0278 B023C3E1 		strh	r2, [r3, #48]	@ movhi
 363              	.L27:
1508:../uvc.c      **** }
 364              		.loc 1 1508 0
 365 027c 0CD08DE2 		add	sp, sp, #12
 366 0280 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 367              	.LVL33:
 368              	.L32:
1476:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 369              		.loc 1 1476 0
 370 0284 B420D2E1 		ldrh	r2, [r2, #4]
 371 0288 DC309FE5 		ldr	r3, .L34+4
 372 028c 030052E1 		cmp	r2, r3
 373 0290 2900000A 		beq	.L33
1484:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 374              		.loc 1 1484 0
 375 0294 005094E5 		ldr	r5, [r4, #0]
 376              	.LVL34:
 377              	.LBB12:
 378              	.LBB13:
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 379              		.loc 1 1219 0
 380 0298 D0109FE5 		ldr	r1, .L34+8
 381              	.LVL35:
 382 029c 0C0045E2 		sub	r0, r5, #12
 383              	.LVL36:
 384 02a0 0C20A0E3 		mov	r2, #12
 385 02a4 FEFFFFEB 		bl	CyU3PMemCopy
 386              	.LVL37:
1224:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 387              		.loc 1 1224 0
 388 02a8 0BC055E5 		ldrb	ip, [r5, #-11]	@ zero_extendqisi2
 389              	.LBE13:
 390              	.LBE12:
1485:../uvc.c      ****                 pb++;
 391              		.loc 1 1485 0
 392 02ac B4309FE5 		ldr	r3, .L34
 393              	.LBB15:
 394              	.LBB14:
1224:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 395              		.loc 1 1224 0
 396 02b0 02108CE3 		orr	r1, ip, #2
 397 02b4 0B1045E5 		strb	r1, [r5, #-11]
 398              	.LBE14:
 399              	.LBE15:
1485:../uvc.c      ****                 pb++;
 400              		.loc 1 1485 0
 401 02b8 BA02D3E1 		ldrh	r0, [r3, #42]
1486:../uvc.c      ****                 pbc = input->buffer_p.count;
 402              		.loc 1 1486 0
 403 02bc B410D4E1 		ldrh	r1, [r4, #4]
1485:../uvc.c      ****                 pb++;
 404              		.loc 1 1485 0
 405 02c0 012080E2 		add	r2, r0, #1
 406 02c4 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
1486:../uvc.c      ****                 pbc = input->buffer_p.count;
 407              		.loc 1 1486 0
 408 02c8 BC12C3E1 		strh	r1, [r3, #44]	@ movhi
 409              	.LVL38:
 410              	.L30:
1491:../uvc.c      ****             prodCount++;
 411              		.loc 1 1491 0
 412 02cc BEE2D3E1 		ldrh	lr, [r3, #46]
1492:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 413              		.loc 1 1492 0
 414 02d0 0C1081E2 		add	r1, r1, #12
1491:../uvc.c      ****             prodCount++;
 415              		.loc 1 1491 0
 416 02d4 01C08EE2 		add	ip, lr, #1
 417 02d8 0C08A0E1 		mov	r0, ip, asl #16
 418 02dc 20E8A0E1 		mov	lr, r0, lsr #16
1492:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 419              		.loc 1 1492 0
 420 02e0 0128A0E1 		mov	r2, r1, asl #16
 421 02e4 2218A0E1 		mov	r1, r2, lsr #16
 422 02e8 84009FE5 		ldr	r0, .L34+12
 423 02ec 0020A0E3 		mov	r2, #0
1491:../uvc.c      ****             prodCount++;
 424              		.loc 1 1491 0
 425 02f0 BEE2C3E1 		strh	lr, [r3, #46]	@ movhi
1492:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 426              		.loc 1 1492 0
 427 02f4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 428              	.LVL39:
1491:../uvc.c      ****             prodCount++;
 429              		.loc 1 1491 0
 430 02f8 68109FE5 		ldr	r1, .L34
1495:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 431              		.loc 1 1495 0
 432 02fc 002050E2 		subs	r2, r0, #0
 433 0300 DDFFFF0A 		beq	.L27
1497:../uvc.c      ****                 prodCount--;
 434              		.loc 1 1497 0
 435 0304 BEC2D1E1 		ldrh	ip, [r1, #46]
1498:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 436              		.loc 1 1498 0
 437 0308 B430D4E1 		ldrh	r3, [r4, #4]
1497:../uvc.c      ****                 prodCount--;
 438              		.loc 1 1497 0
 439 030c 01004CE2 		sub	r0, ip, #1
 440              	.LVL40:
 441 0310 00E8A0E1 		mov	lr, r0, asl #16
 442 0314 2EC8A0E1 		mov	ip, lr, lsr #16
 443 0318 BEC2C1E1 		strh	ip, [r1, #46]	@ movhi
1498:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 444              		.loc 1 1498 0
 445 031c BEE2D1E1 		ldrh	lr, [r1, #46]
 446 0320 B003D1E1 		ldrh	r0, [r1, #48]
 447 0324 4C109FE5 		ldr	r1, .L34+16
 448 0328 0EC060E0 		rsb	ip, r0, lr
 449 032c 0400A0E3 		mov	r0, #4
 450 0330 00C08DE5 		str	ip, [sp, #0]
 451 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 452              	.LVL41:
 453 0338 CFFFFFEA 		b	.L27
 454              	.LVL42:
 455              	.L33:
1478:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 456              		.loc 1 1478 0
 457 033c 00E094E5 		ldr	lr, [r4, #0]
 458              	.LBB16:
 459              	.LBB17:
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 460              		.loc 1 1219 0
 461 0340 28109FE5 		ldr	r1, .L34+8
 462              	.LVL43:
 463 0344 0C004EE2 		sub	r0, lr, #12
 464              	.LVL44:
 465 0348 0C20A0E3 		mov	r2, #12
 466 034c FEFFFFEB 		bl	CyU3PMemCopy
 467              	.LVL45:
 468              	.LBE17:
 469              	.LBE16:
1479:../uvc.c      ****                 fb++;
 470              		.loc 1 1479 0
 471 0350 10309FE5 		ldr	r3, .L34
 472 0354 B410D4E1 		ldrh	r1, [r4, #4]
 473 0358 B8C2D3E1 		ldrh	ip, [r3, #40]
 474 035c 01008CE2 		add	r0, ip, #1
 475 0360 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 476 0364 D8FFFFEA 		b	.L30
 477              	.L35:
 478              		.align	2
 479              	.L34:
 480 0368 00000000 		.word	.LANCHOR0
 481 036c F03F0000 		.word	16368
 482 0370 80040000 		.word	.LANCHOR1+1152
 483 0374 00000000 		.word	glChHandleUVCStream
 484 0378 38000000 		.word	.LC2
 485              		.cfi_endproc
 486              	.LFE10:
 488              		.align	2
 490              	CyFxUVCApplnUSBEventCB:
 491              	.LFB8:
1273:../uvc.c      **** {
 492              		.loc 1 1273 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 8
 495              		@ frame_needed = 0, uses_anonymous_args = 0
 496              	.LVL46:
1274:../uvc.c      ****     switch (evtype)
 497              		.loc 1 1274 0
 498 037c 020050E3 		cmp	r0, #2
1273:../uvc.c      **** {
 499              		.loc 1 1273 0
 500 0380 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 501              	.LCFI4:
 502              		.cfi_def_cfa_offset 16
 503 0384 0130A0E1 		mov	r3, r1
 504 0388 10D04DE2 		sub	sp, sp, #16
 505              	.LCFI5:
 506              		.cfi_def_cfa_offset 32
1273:../uvc.c      **** {
 507              		.loc 1 1273 0
 508 038c 0040A0E1 		mov	r4, r0
 509              		.cfi_offset 14, -4
 510              		.cfi_offset 6, -8
 511              		.cfi_offset 5, -12
 512              		.cfi_offset 4, -16
1274:../uvc.c      ****     switch (evtype)
 513              		.loc 1 1274 0
 514 0390 3600000A 		beq	.L39
 515 0394 040050E3 		cmp	r0, #4
 516 0398 1F00000A 		beq	.L40
 517 039c 010050E3 		cmp	r0, #1
 518 03a0 0100000A 		beq	.L42
 519              	.LVL47:
 520              	.L36:
1310:../uvc.c      **** }
 521              		.loc 1 1310 0
 522 03a4 10D08DE2 		add	sp, sp, #16
 523 03a8 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 524              	.LVL48:
 525              	.L42:
1295:../uvc.c      ****             gpif_initialized = 0;
 526              		.loc 1 1295 0
 527 03ac 28519FE5 		ldr	r5, .L43
1293:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 528              		.loc 1 1293 0
 529 03b0 0020A0E1 		mov	r2, r0
 530 03b4 24119FE5 		ldr	r1, .L43+4
 531              	.LVL49:
 532 03b8 0400A0E3 		mov	r0, #4
 533              	.LVL50:
 534 03bc FEFFFFEB 		bl	CyU3PDebugPrint
1294:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 535              		.loc 1 1294 0
 536 03c0 0400A0E1 		mov	r0, r4
 537 03c4 FEFFFFEB 		bl	CyU3PGpifDisable
1295:../uvc.c      ****             gpif_initialized = 0;
 538              		.loc 1 1295 0
 539 03c8 00C0A0E3 		mov	ip, #0
 540              	.LBB24:
 541              	.LBB25:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 542              		.loc 1 1257 0
 543 03cc 0410A0E1 		mov	r1, r4
 544 03d0 0500A0E1 		mov	r0, r5
 545 03d4 0220A0E3 		mov	r2, #2
 546 03d8 0C308DE2 		add	r3, sp, #12
 547              	.LBE25:
 548              	.LBE24:
1295:../uvc.c      ****             gpif_initialized = 0;
 549              		.loc 1 1295 0
 550 03dc 38C085E5 		str	ip, [r5, #56]
1296:../uvc.c      ****             isUsbConnected = CyFalse;
 551              		.loc 1 1296 0
 552 03e0 3CC085E5 		str	ip, [r5, #60]
1297:../uvc.c      ****             streamingStarted = CyFalse;
 553              		.loc 1 1297 0
 554 03e4 34C085E5 		str	ip, [r5, #52]
 555              	.LBB27:
 556              	.LBB26:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 557              		.loc 1 1257 0
 558 03e8 00C08DE5 		str	ip, [sp, #0]
 559 03ec FEFFFFEB 		bl	_txe_event_flags_get
 560 03f0 004050E2 		subs	r4, r0, #0
 561 03f4 EAFFFF1A 		bne	.L36
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 562              		.loc 1 1260 0
 563 03f8 0110E0E3 		mvn	r1, #1
 564 03fc 0220A0E3 		mov	r2, #2
 565 0400 0500A0E1 		mov	r0, r5
 566              	.L41:
 567 0404 FEFFFFEB 		bl	_txe_event_flags_set
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 568              		.loc 1 1263 0
 569 0408 0500A0E1 		mov	r0, r5
 570 040c 0210A0E3 		mov	r1, #2
 571 0410 0420A0E1 		mov	r2, r4
 572 0414 FEFFFFEB 		bl	_txe_event_flags_set
 573 0418 E1FFFFEA 		b	.L36
 574              	.LVL51:
 575              	.L40:
 576              	.LBE26:
 577              	.LBE27:
1279:../uvc.c      ****             gpif_initialized = 0;
 578              		.loc 1 1279 0
 579 041c B8509FE5 		ldr	r5, .L43
1277:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 580              		.loc 1 1277 0
 581 0420 BC109FE5 		ldr	r1, .L43+8
 582              	.LVL52:
 583 0424 0020A0E1 		mov	r2, r0
 584 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 585              	.LVL53:
1278:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 586              		.loc 1 1278 0
 587 042c 0100A0E3 		mov	r0, #1
 588 0430 FEFFFFEB 		bl	CyU3PGpifDisable
1279:../uvc.c      ****             gpif_initialized = 0;
 589              		.loc 1 1279 0
 590 0434 00C0A0E3 		mov	ip, #0
 591              	.LBB28:
 592              	.LBB29:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 593              		.loc 1 1257 0
 594 0438 0110A0E3 		mov	r1, #1
 595 043c 0220A0E3 		mov	r2, #2
 596 0440 0500A0E1 		mov	r0, r5
 597 0444 0C308DE2 		add	r3, sp, #12
 598              	.LBE29:
 599              	.LBE28:
1279:../uvc.c      ****             gpif_initialized = 0;
 600              		.loc 1 1279 0
 601 0448 38C085E5 		str	ip, [r5, #56]
1280:../uvc.c      ****             streamingStarted = CyFalse;
 602              		.loc 1 1280 0
 603 044c 34C085E5 		str	ip, [r5, #52]
 604              	.LBB31:
 605              	.LBB30:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 606              		.loc 1 1257 0
 607 0450 00C08DE5 		str	ip, [sp, #0]
 608 0454 FEFFFFEB 		bl	_txe_event_flags_get
 609 0458 004050E2 		subs	r4, r0, #0
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 610              		.loc 1 1260 0
 611 045c 0500A001 		moveq	r0, r5
 612 0460 0110E003 		mvneq	r1, #1
 613 0464 0220A003 		moveq	r2, #2
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 614              		.loc 1 1257 0
 615 0468 CDFFFF1A 		bne	.L36
 616 046c E4FFFFEA 		b	.L41
 617              	.LVL54:
 618              	.L39:
 619              	.LBE30:
 620              	.LBE31:
1287:../uvc.c      ****             gpif_initialized = 0;
 621              		.loc 1 1287 0
 622 0470 64509FE5 		ldr	r5, .L43
1285:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 623              		.loc 1 1285 0
 624 0474 0020A0E1 		mov	r2, r0
 625 0478 68109FE5 		ldr	r1, .L43+12
 626              	.LVL55:
 627 047c 0400A0E3 		mov	r0, #4
 628              	.LVL56:
 629 0480 FEFFFFEB 		bl	CyU3PDebugPrint
1286:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 630              		.loc 1 1286 0
 631 0484 0100A0E3 		mov	r0, #1
 632 0488 FEFFFFEB 		bl	CyU3PGpifDisable
1287:../uvc.c      ****             gpif_initialized = 0;
 633              		.loc 1 1287 0
 634 048c 0060A0E3 		mov	r6, #0
 635              	.LBB32:
 636              	.LBB33:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 637              		.loc 1 1257 0
 638 0490 0500A0E1 		mov	r0, r5
 639 0494 0110A0E3 		mov	r1, #1
 640 0498 0420A0E1 		mov	r2, r4
 641 049c 0C308DE2 		add	r3, sp, #12
 642              	.LBE33:
 643              	.LBE32:
1287:../uvc.c      ****             gpif_initialized = 0;
 644              		.loc 1 1287 0
 645 04a0 386085E5 		str	r6, [r5, #56]
1288:../uvc.c      ****             streamingStarted = CyFalse;
 646              		.loc 1 1288 0
 647 04a4 346085E5 		str	r6, [r5, #52]
 648              	.LBB35:
 649              	.LBB34:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 650              		.loc 1 1257 0
 651 04a8 00608DE5 		str	r6, [sp, #0]
 652 04ac FEFFFFEB 		bl	_txe_event_flags_get
 653 04b0 006050E2 		subs	r6, r0, #0
 654 04b4 BAFFFF1A 		bne	.L36
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 655              		.loc 1 1260 0
 656 04b8 0420A0E1 		mov	r2, r4
 657 04bc 0500A0E1 		mov	r0, r5
 658 04c0 0110E0E3 		mvn	r1, #1
 659 04c4 FEFFFFEB 		bl	_txe_event_flags_set
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 660              		.loc 1 1263 0
 661 04c8 0500A0E1 		mov	r0, r5
 662 04cc 0410A0E1 		mov	r1, r4
 663 04d0 0620A0E1 		mov	r2, r6
 664 04d4 FEFFFFEB 		bl	_txe_event_flags_set
 665 04d8 B1FFFFEA 		b	.L36
 666              	.L44:
 667              		.align	2
 668              	.L43:
 669 04dc 00000000 		.word	.LANCHOR0
 670 04e0 C4000000 		.word	.LC5
 671 04e4 80000000 		.word	.LC3
 672 04e8 A0000000 		.word	.LC4
 673              	.LBE34:
 674              	.LBE35:
 675              		.cfi_endproc
 676              	.LFE8:
 678              		.align	2
 680              	CyFxUVCApplnUSBSetupCB:
 681              	.LFB9:
1318:../uvc.c      **** {
 682              		.loc 1 1318 0
 683              		.cfi_startproc
 684              		@ args = 0, pretend = 0, frame = 8
 685              		@ frame_needed = 0, uses_anonymous_args = 0
 686              	.LVL57:
1323:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 687              		.loc 1 1323 0
 688 04ec C0329FE5 		ldr	r3, .L70
1318:../uvc.c      **** {
 689              		.loc 1 1318 0
 690 04f0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 691              	.LCFI6:
 692              		.cfi_def_cfa_offset 24
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 693              		.loc 1 1324 0
 694 04f4 BCC29FE5 		ldr	ip, .L70+4
1323:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 695              		.loc 1 1323 0
 696 04f8 FF4000E2 		and	r4, r0, #255
 697              		.cfi_offset 14, -4
 698              		.cfi_offset 8, -8
 699              		.cfi_offset 7, -12
 700              		.cfi_offset 6, -16
 701              		.cfi_offset 5, -20
 702              		.cfi_offset 4, -24
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 703              		.loc 1 1324 0
 704 04fc FF8C00E2 		and	r8, r0, #65280
1325:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 705              		.loc 1 1325 0
 706 0500 2078A0E1 		mov	r7, r0, lsr #16
1323:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 707              		.loc 1 1323 0
 708 0504 0040C3E5 		strb	r4, [r3, #0]
1325:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 709              		.loc 1 1325 0
 710 0508 AC229FE5 		ldr	r2, .L70+8
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 711              		.loc 1 1326 0
 712 050c AC029FE5 		ldr	r0, .L70+12
 713              	.LVL58:
1327:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 714              		.loc 1 1327 0
 715 0510 AC329FE5 		ldr	r3, .L70+16
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 716              		.loc 1 1326 0
 717 0514 0158A0E1 		mov	r5, r1, asl #16
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 718              		.loc 1 1324 0
 719 0518 2884A0E1 		mov	r8, r8, lsr #8
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 720              		.loc 1 1326 0
 721 051c 2558A0E1 		mov	r5, r5, lsr #16
1327:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 722              		.loc 1 1327 0
 723 0520 2118A0E1 		mov	r1, r1, lsr #16
 724              	.LVL59:
1330:../uvc.c      ****     switch (bmReqType)
 725              		.loc 1 1330 0
 726 0524 020054E3 		cmp	r4, #2
1318:../uvc.c      **** {
 727              		.loc 1 1318 0
 728 0528 10D04DE2 		sub	sp, sp, #16
 729              	.LCFI7:
 730              		.cfi_def_cfa_offset 40
1324:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 731              		.loc 1 1324 0
 732 052c 0080CCE5 		strb	r8, [ip, #0]
1325:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 733              		.loc 1 1325 0
 734 0530 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1326:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 735              		.loc 1 1326 0
 736 0534 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1327:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 737              		.loc 1 1327 0
 738 0538 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1330:../uvc.c      ****     switch (bmReqType)
 739              		.loc 1 1330 0
 740 053c 4F00000A 		beq	.L48
 741 0540 0600009A 		bls	.L66
 742 0544 210054E3 		cmp	r4, #33
 743 0548 3A00000A 		beq	.L49
 744 054c A10054E3 		cmp	r4, #161
 745 0550 3800000A 		beq	.L49
 746              	.L63:
1319:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 747              		.loc 1 1319 0
 748 0554 0000A0E3 		mov	r0, #0
 749              	.LVL60:
 750              	.L46:
1457:../uvc.c      **** }
 751              		.loc 1 1457 0
 752 0558 10D08DE2 		add	sp, sp, #16
 753 055c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 754              	.LVL61:
 755              	.L66:
1330:../uvc.c      ****     switch (bmReqType)
 756              		.loc 1 1330 0
 757 0560 010054E3 		cmp	r4, #1
 758 0564 FAFFFF1A 		bne	.L63
1370:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 759              		.loc 1 1370 0
 760 0568 0B0058E3 		cmp	r8, #11
 761 056c F8FFFF1A 		bne	.L63
1374:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 762              		.loc 1 1374 0
 763 0570 010055E3 		cmp	r5, #1
 764 0574 F6FFFF1A 		bne	.L63
1374:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 765              		.loc 1 1374 0 is_stmt 0 discriminator 1
 766 0578 000057E3 		cmp	r7, #0
 767 057c F4FFFF1A 		bne	.L63
1379:../uvc.c      ****                     gpif_initialized = 0;
 768              		.loc 1 1379 0 is_stmt 1
 769 0580 40429FE5 		ldr	r4, .L70+20
1377:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 770              		.loc 1 1377 0
 771 0584 40129FE5 		ldr	r1, .L70+24
 772 0588 0400A0E3 		mov	r0, #4
 773 058c FEFFFFEB 		bl	CyU3PDebugPrint
1378:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 774              		.loc 1 1378 0
 775 0590 0500A0E1 		mov	r0, r5
 776 0594 FEFFFFEB 		bl	CyU3PGpifDisable
1382:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 777              		.loc 1 1382 0
 778 0598 0510A0E1 		mov	r1, r5
 779 059c 8300A0E3 		mov	r0, #131
1379:../uvc.c      ****                     gpif_initialized = 0;
 780              		.loc 1 1379 0
 781 05a0 387084E5 		str	r7, [r4, #56]
1380:../uvc.c      ****                     streamingStarted = CyFalse;
 782              		.loc 1 1380 0
 783 05a4 347084E5 		str	r7, [r4, #52]
1382:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 784              		.loc 1 1382 0
 785 05a8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1383:../uvc.c      ****                     CyU3PBusyWait (100);
 786              		.loc 1 1383 0
 787 05ac 6400A0E3 		mov	r0, #100
 788 05b0 FEFFFFEB 		bl	CyU3PBusyWait
1386:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 789              		.loc 1 1386 0
 790 05b4 14029FE5 		ldr	r0, .L70+28
 791 05b8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1387:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 792              		.loc 1 1387 0
 793 05bc 8300A0E3 		mov	r0, #131
 794 05c0 FEFFFFEB 		bl	CyU3PUsbFlushEp
1388:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 795              		.loc 1 1388 0
 796 05c4 0710A0E1 		mov	r1, r7
 797 05c8 8300A0E3 		mov	r0, #131
 798 05cc FEFFFFEB 		bl	CyU3PUsbSetEpNak
1389:../uvc.c      ****                     CyU3PBusyWait (100);
 799              		.loc 1 1389 0
 800 05d0 6400A0E3 		mov	r0, #100
 801 05d4 FEFFFFEB 		bl	CyU3PBusyWait
1392:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 802              		.loc 1 1392 0
 803 05d8 0710A0E1 		mov	r1, r7
 804 05dc 0520A0E1 		mov	r2, r5
 805 05e0 8300A0E3 		mov	r0, #131
 806 05e4 FEFFFFEB 		bl	CyU3PUsbStall
 807              	.LVL62:
1395:../uvc.c      ****                     CyU3PUsbAckSetup ();
 808              		.loc 1 1395 0
 809 05e8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1397:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 810              		.loc 1 1397 0
 811 05ec 405084E5 		str	r5, [r4, #64]
 812              	.LBB40:
 813              	.LBB41:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 814              		.loc 1 1257 0
 815 05f0 0400A0E1 		mov	r0, r4
 816 05f4 0510A0E1 		mov	r1, r5
 817 05f8 0220A0E3 		mov	r2, #2
 818 05fc 0C308DE2 		add	r3, sp, #12
 819 0600 00708DE5 		str	r7, [sp, #0]
 820 0604 FEFFFFEB 		bl	_txe_event_flags_get
 821 0608 006050E2 		subs	r6, r0, #0
 822 060c 2E00001A 		bne	.L61
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 823              		.loc 1 1260 0
 824 0610 0110E0E3 		mvn	r1, #1
 825 0614 0220A0E3 		mov	r2, #2
 826 0618 0400A0E1 		mov	r0, r4
 827 061c FEFFFFEB 		bl	_txe_event_flags_set
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 828              		.loc 1 1263 0
 829 0620 0400A0E1 		mov	r0, r4
 830 0624 0210A0E3 		mov	r1, #2
 831 0628 0620A0E1 		mov	r2, r6
 832 062c FEFFFFEB 		bl	_txe_event_flags_set
1393:../uvc.c      ****                     uvcHandleReq = CyTrue;
 833              		.loc 1 1393 0
 834 0630 0500A0E1 		mov	r0, r5
 835 0634 C7FFFFEA 		b	.L46
 836              	.LVL63:
 837              	.L49:
 838              	.LBE41:
 839              	.LBE40:
1335:../uvc.c      ****             switch (wIndex & 0xFF)
 840              		.loc 1 1335 0
 841 0638 FF5015E2 		ands	r5, r5, #255
 842 063c 1A00001A 		bne	.L67
 843              	.LVL64:
1340:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 844              		.loc 1 1340 0
 845 0640 0520A0E1 		mov	r2, r5
 846 0644 7C019FE5 		ldr	r0, .L70+20
 847 0648 0410A0E3 		mov	r1, #4
 848 064c FEFFFFEB 		bl	_txe_event_flags_set
 849              	.LVL65:
1342:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 850              		.loc 1 1342 0
 851 0650 002050E2 		subs	r2, r0, #0
1339:../uvc.c      ****                         uvcHandleReq = CyTrue;
 852              		.loc 1 1339 0
 853 0654 0100A003 		moveq	r0, #1
 854              	.LVL66:
1342:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 855              		.loc 1 1342 0
 856 0658 BEFFFF0A 		beq	.L46
1344:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 857              		.loc 1 1344 0
 858 065c 70119FE5 		ldr	r1, .L70+32
 859 0660 0400A0E3 		mov	r0, #4
 860 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 861              	.LVL67:
1345:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 862              		.loc 1 1345 0
 863 0668 0500A0E1 		mov	r0, r5
 864 066c 0110A0E3 		mov	r1, #1
 865 0670 0520A0E1 		mov	r2, r5
 866 0674 FEFFFFEB 		bl	CyU3PUsbStall
1339:../uvc.c      ****                         uvcHandleReq = CyTrue;
 867              		.loc 1 1339 0
 868 0678 0100A0E3 		mov	r0, #1
 869 067c B5FFFFEA 		b	.L46
 870              	.LVL68:
 871              	.L48:
1405:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 872              		.loc 1 1405 0
 873 0680 010058E3 		cmp	r8, #1
 874 0684 B2FFFF1A 		bne	.L63
1407:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 875              		.loc 1 1407 0
 876 0688 830055E3 		cmp	r5, #131
 877 068c B0FFFF1A 		bne	.L63
1413:../uvc.c      ****                     if (streamingStarted == CyTrue)
 878              		.loc 1 1413 0
 879 0690 30719FE5 		ldr	r7, .L70+20
 880 0694 346097E5 		ldr	r6, [r7, #52]
 881 0698 010056E3 		cmp	r6, #1
 882 069c 1500000A 		beq	.L68
 883              	.LVL69:
1445:../uvc.c      ****                         CyU3PUsbAckSetup ();
 884              		.loc 1 1445 0
 885 06a0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1444:../uvc.c      ****                         uvcHandleReq = CyTrue;
 886              		.loc 1 1444 0
 887 06a4 0800A0E1 		mov	r0, r8
 888 06a8 AAFFFFEA 		b	.L46
 889              	.LVL70:
 890              	.L67:
1335:../uvc.c      ****             switch (wIndex & 0xFF)
 891              		.loc 1 1335 0
 892 06ac 010055E3 		cmp	r5, #1
 893 06b0 A7FFFF1A 		bne	.L63
 894              	.LVL71:
1353:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 895              		.loc 1 1353 0
 896 06b4 0020A0E3 		mov	r2, #0
 897 06b8 08019FE5 		ldr	r0, .L70+20
 898 06bc 0810A0E3 		mov	r1, #8
 899 06c0 FEFFFFEB 		bl	_txe_event_flags_set
 900              	.LVL72:
1355:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 901              		.loc 1 1355 0
 902 06c4 002050E2 		subs	r2, r0, #0
 903 06c8 0100001A 		bne	.L69
 904              	.LVL73:
 905              	.L61:
 906              	.LBB43:
 907              	.LBB42:
1393:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1393 0
 909 06cc 0500A0E1 		mov	r0, r5
 910 06d0 A0FFFFEA 		b	.L46
 911              	.LVL74:
 912              	.L69:
 913              	.LBE42:
 914              	.LBE43:
1358:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 915              		.loc 1 1358 0
 916 06d4 FC109FE5 		ldr	r1, .L70+36
 917 06d8 0400A0E3 		mov	r0, #4
 918              	.LVL75:
 919 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 920              	.LVL76:
1359:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 921              		.loc 1 1359 0
 922 06e0 0000A0E3 		mov	r0, #0
 923 06e4 0510A0E1 		mov	r1, r5
 924 06e8 0020A0E1 		mov	r2, r0
 925 06ec FEFFFFEB 		bl	CyU3PUsbStall
1352:../uvc.c      ****                         uvcHandleReq = CyTrue;
 926              		.loc 1 1352 0
 927 06f0 0500A0E1 		mov	r0, r5
 928 06f4 97FFFFEA 		b	.L46
 929              	.LVL77:
 930              	.L68:
1415:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 931              		.loc 1 1415 0
 932 06f8 DC109FE5 		ldr	r1, .L70+40
 933 06fc 0400A0E3 		mov	r0, #4
 934 0700 FEFFFFEB 		bl	CyU3PDebugPrint
1419:../uvc.c      ****                         gpif_initialized = 0;
 935              		.loc 1 1419 0
 936 0704 0080A0E3 		mov	r8, #0
1418:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 937              		.loc 1 1418 0
 938 0708 0600A0E1 		mov	r0, r6
 939 070c FEFFFFEB 		bl	CyU3PGpifDisable
1423:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 940              		.loc 1 1423 0
 941 0710 0610A0E1 		mov	r1, r6
 942 0714 0500A0E1 		mov	r0, r5
1419:../uvc.c      ****                         gpif_initialized = 0;
 943              		.loc 1 1419 0
 944 0718 388087E5 		str	r8, [r7, #56]
1420:../uvc.c      ****                         streamingStarted = CyFalse;
 945              		.loc 1 1420 0
 946 071c 348087E5 		str	r8, [r7, #52]
1423:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 947              		.loc 1 1423 0
 948 0720 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1424:../uvc.c      ****                         CyU3PBusyWait (100);
 949              		.loc 1 1424 0
 950 0724 6400A0E3 		mov	r0, #100
 951 0728 FEFFFFEB 		bl	CyU3PBusyWait
1427:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 952              		.loc 1 1427 0
 953 072c 9C009FE5 		ldr	r0, .L70+28
 954 0730 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1428:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 955              		.loc 1 1428 0
 956 0734 0500A0E1 		mov	r0, r5
 957 0738 FEFFFFEB 		bl	CyU3PUsbFlushEp
1429:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 958              		.loc 1 1429 0
 959 073c 0810A0E1 		mov	r1, r8
 960 0740 0500A0E1 		mov	r0, r5
 961 0744 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1430:../uvc.c      ****                         CyU3PBusyWait (100);
 962              		.loc 1 1430 0
 963 0748 6400A0E3 		mov	r0, #100
 964 074c FEFFFFEB 		bl	CyU3PBusyWait
1433:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 965              		.loc 1 1433 0
 966 0750 0810A0E1 		mov	r1, r8
 967 0754 0620A0E1 		mov	r2, r6
 968 0758 0500A0E1 		mov	r0, r5
 969 075c FEFFFFEB 		bl	CyU3PUsbStall
 970              	.LVL78:
1437:../uvc.c      ****                         CyU3PUsbAckSetup ();
 971              		.loc 1 1437 0
 972 0760 FEFFFFEB 		bl	CyU3PUsbAckSetup
1439:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 973              		.loc 1 1439 0
 974 0764 406087E5 		str	r6, [r7, #64]
 975              	.LBB44:
 976              	.LBB45:
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 977              		.loc 1 1257 0
 978 0768 0700A0E1 		mov	r0, r7
 979 076c 0610A0E1 		mov	r1, r6
 980 0770 0420A0E1 		mov	r2, r4
 981 0774 0C308DE2 		add	r3, sp, #12
 982 0778 00808DE5 		str	r8, [sp, #0]
 983 077c FEFFFFEB 		bl	_txe_event_flags_get
 984 0780 005050E2 		subs	r5, r0, #0
1435:../uvc.c      ****                         uvcHandleReq = CyTrue;
 985              		.loc 1 1435 0
 986 0784 0600A011 		movne	r0, r6
1257:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 987              		.loc 1 1257 0
 988 0788 72FFFF1A 		bne	.L46
1260:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 989              		.loc 1 1260 0
 990 078c 0110E0E3 		mvn	r1, #1
 991 0790 0420A0E1 		mov	r2, r4
 992 0794 0700A0E1 		mov	r0, r7
 993 0798 FEFFFFEB 		bl	_txe_event_flags_set
1263:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 994              		.loc 1 1263 0
 995 079c 0700A0E1 		mov	r0, r7
 996 07a0 0410A0E1 		mov	r1, r4
 997 07a4 0520A0E1 		mov	r2, r5
 998 07a8 FEFFFFEB 		bl	_txe_event_flags_set
1435:../uvc.c      ****                         uvcHandleReq = CyTrue;
 999              		.loc 1 1435 0
 1000 07ac 0600A0E1 		mov	r0, r6
 1001 07b0 68FFFFEA 		b	.L46
 1002              	.L71:
 1003              		.align	2
 1004              	.L70:
 1005 07b4 00000000 		.word	bmReqType
 1006 07b8 00000000 		.word	bRequest
 1007 07bc 00000000 		.word	wValue
 1008 07c0 00000000 		.word	wIndex
 1009 07c4 00000000 		.word	wLength
 1010 07c8 00000000 		.word	.LANCHOR0
 1011 07cc 50010000 		.word	.LC8
 1012 07d0 00000000 		.word	glChHandleUVCStream
 1013 07d4 E4000000 		.word	.LC6
 1014 07d8 1C010000 		.word	.LC7
 1015 07dc 68010000 		.word	.LC9
 1016              	.LBE45:
 1017              	.LBE44:
 1018              		.cfi_endproc
 1019              	.LFE9:
 1021              		.align	2
 1022              		.global	CyFxGpifCB
 1024              	CyFxGpifCB:
 1025              	.LFB12:
1628:../uvc.c      **** {
 1026              		.loc 1 1628 0
 1027              		.cfi_startproc
 1028              		@ args = 0, pretend = 0, frame = 0
 1029              		@ frame_needed = 0, uses_anonymous_args = 0
 1030              	.LVL79:
1629:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1031              		.loc 1 1629 0
 1032 07e0 010050E3 		cmp	r0, #1
1628:../uvc.c      **** {
 1033              		.loc 1 1628 0
 1034 07e4 10402DE9 		stmfd	sp!, {r4, lr}
 1035              	.LCFI8:
 1036              		.cfi_def_cfa_offset 8
1628:../uvc.c      **** {
 1037              		.loc 1 1628 0
 1038 07e8 0120A0E1 		mov	r2, r1
1629:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1039              		.loc 1 1629 0
 1040 07ec 1080BD18 		ldmnefd	sp!, {r4, pc}
 1041              		.cfi_offset 14, -4
 1042              		.cfi_offset 4, -8
1631:../uvc.c      ****         hitFV = CyTrue;
 1043              		.loc 1 1631 0
 1044 07f0 D0109FE5 		ldr	r1, .L88
 1045              	.LVL80:
 1046              	.LBB50:
 1047              	.LBB52:
1528:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1048              		.loc 1 1528 0
 1049 07f4 4830D1E5 		ldrb	r3, [r1, #72]	@ zero_extendqisi2
 1050              	.LBE52:
 1051              	.LBE50:
1631:../uvc.c      ****         hitFV = CyTrue;
 1052              		.loc 1 1631 0
 1053 07f8 440081E5 		str	r0, [r1, #68]
 1054              	.LVL81:
 1055              	.LBB56:
 1056              	.LBB51:
1528:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1057              		.loc 1 1528 0
 1058 07fc 030053E3 		cmp	r3, #3
 1059 0800 2800000A 		beq	.L87
1552:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1060              		.loc 1 1552 0
 1061 0804 020053E3 		cmp	r3, #2
 1062 0808 1080BD18 		ldmnefd	sp!, {r4, pc}
1554:../uvc.c      ****         switch (stateId)
 1063              		.loc 1 1554 0
 1064 080c 080042E2 		sub	r0, r2, #8
 1065              	.LVL82:
 1066 0810 0A0050E3 		cmp	r0, #10
 1067 0814 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1068 0818 1B0000EA 		b	.L80
 1069              	.L82:
 1070 081c 4C080000 		.word	.L76
 1071 0820 8C080000 		.word	.L80
 1072 0824 8C080000 		.word	.L80
 1073 0828 48080000 		.word	.L72
 1074 082c 8C080000 		.word	.L80
 1075 0830 8C080000 		.word	.L80
 1076 0834 8C080000 		.word	.L80
 1077 0838 84080000 		.word	.L86
 1078 083c 8C080000 		.word	.L80
 1079 0840 8C080000 		.word	.L80
 1080 0844 48080000 		.word	.L72
 1081              	.LVL83:
 1082              	.L72:
 1083 0848 1080BDE8 		ldmfd	sp!, {r4, pc}
 1084              	.LVL84:
 1085              	.L76:
1538:../uvc.c      ****                 socket = 0;
 1086              		.loc 1 1538 0
 1087 084c 0010A0E3 		mov	r1, #0
 1088              	.L77:
 1089              	.LVL85:
1611:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1090              		.loc 1 1611 0
 1091 0850 74009FE5 		ldr	r0, .L88+4
 1092 0854 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1093              	.LVL86:
1612:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1094              		.loc 1 1612 0
 1095 0858 002050E2 		subs	r2, r0, #0
 1096 085c F9FFFF0A 		beq	.L72
1614:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1097              		.loc 1 1614 0
 1098 0860 0400A0E3 		mov	r0, #4
 1099              	.LVL87:
 1100 0864 64109FE5 		ldr	r1, .L88+8
 1101 0868 FEFFFFEB 		bl	CyU3PDebugPrint
 1102              	.LVL88:
 1103              	.L83:
 1104              	.LBB53:
 1105              	.LBB54:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1106              		.loc 1 1244 0
 1107 086c 60109FE5 		ldr	r1, .L88+12
 1108 0870 0400A0E3 		mov	r0, #4
 1109 0874 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 1110              		.loc 1 1245 0
 1111 0878 FA0FA0E3 		mov	r0, #1000
 1112 087c FEFFFFEB 		bl	_tx_thread_sleep
 1113 0880 F9FFFFEA 		b	.L83
 1114              	.LVL89:
 1115              	.L86:
 1116              	.LBE54:
 1117              	.LBE53:
1581:../uvc.c      ****                 socket = 1;
 1118              		.loc 1 1581 0
 1119 0884 0110A0E3 		mov	r1, #1
 1120 0888 F0FFFFEA 		b	.L77
 1121              	.L80:
1600:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1122              		.loc 1 1600 0
 1123 088c 44109FE5 		ldr	r1, .L88+16
 1124 0890 0100A0E3 		mov	r0, #1
 1125 0894 FEFFFFEB 		bl	CyU3PDebugPrint
 1126              	.LVL90:
 1127              	.LBE51:
 1128              	.LBE56:
1633:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1129              		.loc 1 1633 0
 1130 0898 3C109FE5 		ldr	r1, .L88+20
 1131 089c 0400A0E3 		mov	r0, #4
1635:../uvc.c      **** }
 1132              		.loc 1 1635 0
 1133 08a0 1040BDE8 		ldmfd	sp!, {r4, lr}
1633:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1134              		.loc 1 1633 0
 1135 08a4 FEFFFFEA 		b	CyU3PDebugPrint
 1136              	.LVL91:
 1137              	.L87:
 1138              	.LBB57:
 1139              	.LBB55:
1530:../uvc.c      ****         switch (stateId)
 1140              		.loc 1 1530 0
 1141 08a8 0B3042E2 		sub	r3, r2, #11
 1142 08ac 030053E3 		cmp	r3, #3
 1143 08b0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1144 08b4 F4FFFFEA 		b	.L80
 1145              	.L78:
 1146 08b8 4C080000 		.word	.L76
 1147 08bc 84080000 		.word	.L86
 1148 08c0 48080000 		.word	.L72
 1149 08c4 48080000 		.word	.L72
 1150              	.L89:
 1151              		.align	2
 1152              	.L88:
 1153 08c8 00000000 		.word	.LANCHOR0
 1154 08cc 00000000 		.word	glChHandleUVCStream
 1155 08d0 A4010000 		.word	.LC11
 1156 08d4 D4010000 		.word	.LC12
 1157 08d8 8C010000 		.word	.LC10
 1158 08dc E8010000 		.word	.LC13
 1159              	.LBE55:
 1160              	.LBE57:
 1161              		.cfi_endproc
 1162              	.LFE12:
 1164              		.align	2
 1165              		.global	I2CCmdHandler
 1167              	I2CCmdHandler:
 1168              	.LFB0:
 323:../uvc.c      **** void I2CCmdHandler(){
 1169              		.loc 1 323 0
 1170              		.cfi_startproc
 1171              		@ args = 0, pretend = 0, frame = 8
 1172              		@ frame_needed = 0, uses_anonymous_args = 0
 1173 08e0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1174              	.LCFI9:
 1175              		.cfi_def_cfa_offset 36
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1176              		.loc 1 326 0
 1177 08e4 E8409FE5 		ldr	r4, .L96
 1178              		.cfi_offset 14, -4
 1179              		.cfi_offset 11, -8
 1180              		.cfi_offset 10, -12
 1181              		.cfi_offset 9, -16
 1182              		.cfi_offset 8, -20
 1183              		.cfi_offset 7, -24
 1184              		.cfi_offset 6, -28
 1185              		.cfi_offset 5, -32
 1186              		.cfi_offset 4, -36
 323:../uvc.c      **** void I2CCmdHandler(){
 1187              		.loc 1 323 0
 1188 08e8 34D04DE2 		sub	sp, sp, #52
 1189              	.LCFI10:
 1190              		.cfi_def_cfa_offset 88
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1191              		.loc 1 326 0
 1192 08ec 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1193              	.LVL92:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1194              		.loc 1 331 0
 1195 08f0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1196              		.loc 1 328 0
 1197 08f4 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1198              	.LVL93:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1199              		.loc 1 331 0
 1200 08f8 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1201 08fc 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1202 0900 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1203 0904 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1204 0908 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1205 090c 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1206 0910 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1207 0914 1C208DE5 		str	r2, [sp, #28]
 1208 0918 0400A0E3 		mov	r0, #4
 1209 091c 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 1210 0920 B0109FE5 		ldr	r1, .L96+4
 1211 0924 0520A0E1 		mov	r2, r5
 1212 0928 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1213 092c 08808DE5 		str	r8, [sp, #8]
 1214 0930 0CA08DE5 		str	sl, [sp, #12]
 1215 0934 10908DE5 		str	r9, [sp, #16]
 1216 0938 14B08DE5 		str	fp, [sp, #20]
 1217 093c 18608DE5 		str	r6, [sp, #24]
 1218 0940 20C08DE5 		str	ip, [sp, #32]
 1219 0944 FEFFFFEB 		bl	CyU3PDebugPrint
 1220              	.LVL94:
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1221              		.loc 1 335 0
 1222 0948 000055E3 		cmp	r5, #0
 1223 094c 0300000A 		beq	.L94
 360:../uvc.c      **** 	}else if(CmdType == 1){
 1224              		.loc 1 360 0
 1225 0950 010055E3 		cmp	r5, #1
 1226 0954 1400000A 		beq	.L95
 1227              	.L90:
 373:../uvc.c      **** }
 1228              		.loc 1 373 0
 1229 0958 34D08DE2 		add	sp, sp, #52
 1230 095c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1231              	.L94:
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1232              		.loc 1 351 0
 1233 0960 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1234 0964 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1235 0968 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1236              		.loc 1 337 0
 1237 096c 0FE0A0E3 		mov	lr, #15
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1238              		.loc 1 351 0
 1239 0970 2CC08DE2 		add	ip, sp, #44
 1240 0974 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1241 0978 010080E3 		orr	r0, r0, #1
 1242 097c 011081E3 		orr	r1, r1, #1
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1243              		.loc 1 337 0
 1244 0980 57E0C4E5 		strb	lr, [r4, #87]
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1245              		.loc 1 351 0
 1246 0984 00C08DE5 		str	ip, [sp, #0]
 1247 0988 FEFFFFEB 		bl	SensorRead2B
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1248              		.loc 1 352 0
 1249 098c 2C00DDE5 		ldrb	r0, [sp, #44]	@ zero_extendqisi2
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 1250              		.loc 1 353 0
 1251 0990 020056E3 		cmp	r6, #2
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1252              		.loc 1 352 0
 1253 0994 5500C4E5 		strb	r0, [r4, #85]
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1254              		.loc 1 354 0
 1255 0998 2D00DD05 		ldreqb	r0, [sp, #45]	@ zero_extendqisi2
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1256              		.loc 1 356 0
 1257 099c 0030E0E3 		mvn	r3, #0
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1258              		.loc 1 354 0
 1259 09a0 5600C405 		streqb	r0, [r4, #86]
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1260              		.loc 1 356 0
 1261 09a4 5730C4E5 		strb	r3, [r4, #87]
 1262 09a8 EAFFFFEA 		b	.L90
 1263              	.L95:
 367:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1264              		.loc 1 367 0
 1265 09ac 4E10D4E5 		ldrb	r1, [r4, #78]	@ zero_extendqisi2
 1266 09b0 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1267 09b4 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1268 09b8 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1269 09bc 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1270 09c0 FE0001E2 		and	r0, r1, #254
 1271 09c4 FE100EE2 		and	r1, lr, #254
 1272 09c8 00C08DE5 		str	ip, [sp, #0]
 1273 09cc FEFFFFEB 		bl	SensorWrite2B
 1274 09d0 E0FFFFEA 		b	.L90
 1275              	.L97:
 1276              		.align	2
 1277              	.L96:
 1278 09d4 00000000 		.word	.LANCHOR0
 1279 09d8 FC010000 		.word	.LC14
 1280              		.cfi_endproc
 1281              	.LFE0:
 1283              		.align	2
 1284              		.global	setIrisauto
 1286              	setIrisauto:
 1287              	.LFB1:
 379:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1288              		.loc 1 379 0
 1289              		.cfi_startproc
 1290              		@ args = 0, pretend = 0, frame = 0
 1291              		@ frame_needed = 0, uses_anonymous_args = 0
 1292              	.LVL95:
 1293 09dc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1294              	.LCFI11:
 1295              		.cfi_def_cfa_offset 16
 1296 09e0 0160A0E1 		mov	r6, r1
 1297              		.cfi_offset 14, -4
 1298              		.cfi_offset 6, -8
 1299              		.cfi_offset 5, -12
 1300              		.cfi_offset 4, -16
 1301 09e4 08D04DE2 		sub	sp, sp, #8
 1302              	.LCFI12:
 1303              		.cfi_def_cfa_offset 24
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1304              		.loc 1 383 0
 1305 09e8 0050A0E3 		mov	r5, #0
 379:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1306              		.loc 1 379 0
 1307 09ec 0040A0E1 		mov	r4, r0
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1308              		.loc 1 382 0
 1309 09f0 0010E0E3 		mvn	r1, #0
 1310              	.LVL96:
 1311 09f4 1C0090E5 		ldr	r0, [r0, #28]
 1312              	.LVL97:
 1313 09f8 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1314              		.loc 1 383 0
 1315 09fc 060065E0 		rsb	r0, r5, r6
 1316 0a00 00C070E2 		rsbs	ip, r0, #0
 1317 0a04 00C0ACE0 		adc	ip, ip, r0
 1318 0a08 2010A0E3 		mov	r1, #32
 1319 0a0c 2720A0E3 		mov	r2, #39
 1320 0a10 3030A0E3 		mov	r3, #48
 1321 0a14 0400A0E1 		mov	r0, r4
 1322 0a18 00C08DE5 		str	ip, [sp, #0]
 1323 0a1c 04508DE5 		str	r5, [sp, #4]
 1324 0a20 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 1325              		.loc 1 384 0
 1326 0a24 050056E1 		cmp	r6, r5
 1327 0a28 0260A003 		moveq	r6, #2
 1328 0a2c 0560A011 		movne	r6, r5
 1329 0a30 0400A0E1 		mov	r0, r4
 1330 0a34 2110A0E3 		mov	r1, #33
 1331 0a38 2520A0E3 		mov	r2, #37
 1332 0a3c 3030A0E3 		mov	r3, #48
 1333 0a40 00608DE5 		str	r6, [sp, #0]
 1334 0a44 04508DE5 		str	r5, [sp, #4]
 1335 0a48 FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1336              		.loc 1 385 0
 1337 0a4c 1C0094E5 		ldr	r0, [r4, #28]
 386:../uvc.c      **** }
 1338              		.loc 1 386 0
 1339 0a50 08D08DE2 		add	sp, sp, #8
 1340 0a54 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1341              		.loc 1 385 0
 1342 0a58 FEFFFFEA 		b	_txe_mutex_put
 1343              		.cfi_endproc
 1344              	.LFE1:
 1346              		.align	2
 1347              		.global	ControlHandle
 1349              	ControlHandle:
 1350              	.LFB2:
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1351              		.loc 1 388 0
 1352              		.cfi_startproc
 1353              		@ args = 0, pretend = 0, frame = 24
 1354              		@ frame_needed = 0, uses_anonymous_args = 0
 1355              	.LVL98:
 1356 0a5c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1357              	.LCFI13:
 1358              		.cfi_def_cfa_offset 36
 395:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1359              		.loc 1 395 0
 1360 0a60 230050E3 		cmp	r0, #35
 394:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1361              		.loc 1 394 0
 1362 0a64 207040E2 		sub	r7, r0, #32
 1363              		.cfi_offset 14, -4
 1364              		.cfi_offset 11, -8
 1365              		.cfi_offset 10, -12
 1366              		.cfi_offset 9, -16
 1367              		.cfi_offset 8, -20
 1368              		.cfi_offset 7, -24
 1369              		.cfi_offset 6, -28
 1370              		.cfi_offset 5, -32
 1371              		.cfi_offset 4, -36
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1372              		.loc 1 388 0
 1373 0a68 2CD04DE2 		sub	sp, sp, #44
 1374              	.LCFI14:
 1375              		.cfi_def_cfa_offset 80
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1376              		.loc 1 388 0
 1377 0a6c 0040A0E1 		mov	r4, r0
 394:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1378              		.loc 1 394 0
 1379 0a70 FF7007E2 		and	r7, r7, #255
 1380              	.LVL99:
 395:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1381              		.loc 1 395 0
 1382 0a74 2400009A 		bls	.L102
 396:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1383              		.loc 1 396 0
 1384 0a78 EC6E9FE5 		ldr	r6, .L206
 1385 0a7c 872087E0 		add	r2, r7, r7, asl #1
 1386 0a80 8221A0E1 		mov	r2, r2, asl #3
 1387 0a84 023086E0 		add	r3, r6, r2
 397:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1388              		.loc 1 397 0
 1389 0a88 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 398:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1390              		.loc 1 398 0
 1391 0a8c 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 399:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1392              		.loc 1 399 0
 1393 0a90 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 410:../uvc.c      ****     reqData = bRequest;
 1394              		.loc 1 410 0
 1395 0a94 D43E9FE5 		ldr	r3, .L206+4
 396:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1396              		.loc 1 396 0
 1397 0a98 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1398              	.LVL100:
 410:../uvc.c      ****     reqData = bRequest;
 1399              		.loc 1 410 0
 1400 0a9c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1401              	.LVL101:
 418:../uvc.c      ****     switch (bRequest)
 1402              		.loc 1 418 0
 1403 0aa0 830055E3 		cmp	r5, #131
 1404 0aa4 2300000A 		beq	.L108
 1405              	.LVL102:
 1406              	.L203:
 1407 0aa8 2C00009A 		bls	.L201
 1408 0aac 850055E3 		cmp	r5, #133
 1409 0ab0 8B00000A 		beq	.L110
 1410 0ab4 7900003A 		bcc	.L109
 1411 0ab8 860055E3 		cmp	r5, #134
 1412 0abc C800000A 		beq	.L111
 1413 0ac0 870055E3 		cmp	r5, #135
 1414 0ac4 BC00000A 		beq	.L202
 1415              	.L104:
 894:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1416              		.loc 1 894 0
 1417 0ac8 0000A0E3 		mov	r0, #0
 1418 0acc 0110A0E3 		mov	r1, #1
 1419 0ad0 0020A0E1 		mov	r2, r0
 1420 0ad4 FEFFFFEB 		bl	CyU3PUsbStall
 895:../uvc.c      **** 			  break;
 1421              		.loc 1 895 0
 1422 0ad8 FFC0A0E3 		mov	ip, #255
 1423 0adc 0C70A0E1 		mov	r7, ip
 1424              	.LVL103:
 1425 0ae0 0CE0A0E1 		mov	lr, ip
 1426 0ae4 0C40A0E1 		mov	r4, ip
 1427              	.LVL104:
 1428              	.L114:
 897:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1429              		.loc 1 897 0
 1430 0ae8 841E9FE5 		ldr	r1, .L206+8
 1431 0aec 0520A0E1 		mov	r2, r5
 1432 0af0 0430A0E1 		mov	r3, r4
 1433 0af4 0400A0E3 		mov	r0, #4
 1434 0af8 00E08DE5 		str	lr, [sp, #0]
 1435 0afc 80108DE9 		stmib	sp, {r7, ip}	@ phole stm
 1436 0b00 FEFFFFEB 		bl	CyU3PDebugPrint
 898:../uvc.c      **** }
 1437              		.loc 1 898 0
 1438 0b04 2CD08DE2 		add	sp, sp, #44
 1439 0b08 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1440              	.LVL105:
 1441              	.L102:
 401:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1442              		.loc 1 401 0
 1443 0b0c 586E9FE5 		ldr	r6, .L206
 410:../uvc.c      ****     reqData = bRequest;
 1444              		.loc 1 410 0
 1445 0b10 583E9FE5 		ldr	r3, .L206+4
 401:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1446              		.loc 1 401 0
 1447 0b14 805080E0 		add	r5, r0, r0, asl #1
 1448 0b18 850186E0 		add	r0, r6, r5, asl #3
 1449              	.LVL106:
 410:../uvc.c      ****     reqData = bRequest;
 1450              		.loc 1 410 0
 1451 0b1c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 401:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1452              		.loc 1 401 0
 1453 0b20 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1454              	.LVL107:
 418:../uvc.c      ****     switch (bRequest)
 1455              		.loc 1 418 0
 1456 0b24 830055E3 		cmp	r5, #131
 402:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1457              		.loc 1 402 0
 1458 0b28 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1459              	.LVL108:
 403:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1460              		.loc 1 403 0
 1461 0b2c 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1462              	.LVL109:
 404:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1463              		.loc 1 404 0
 1464 0b30 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1465              	.LVL110:
 418:../uvc.c      ****     switch (bRequest)
 1466              		.loc 1 418 0
 1467 0b34 DBFFFF1A 		bne	.L203
 1468              	.LVL111:
 1469              	.L108:
 541:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1470              		.loc 1 541 0
 1471 0b38 230054E3 		cmp	r4, #35
 1472 0b3c C600009A 		bls	.L136
 542:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1473              		.loc 1 542 0
 1474 0b40 870087E0 		add	r0, r7, r7, asl #1
 1475 0b44 806186E0 		add	r6, r6, r0, asl #3
 1476 0b48 28AE9FE5 		ldr	sl, .L206+12
 1477 0b4c 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
 543:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1478              		.loc 1 543 0
 1479 0b50 06E0D6E5 		ldrb	lr, [r6, #6]	@ zero_extendqisi2
 542:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1480              		.loc 1 542 0
 1481 0b54 58C0CAE5 		strb	ip, [sl, #88]
 543:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1482              		.loc 1 543 0
 1483 0b58 59E0CAE5 		strb	lr, [sl, #89]
 1484 0b5c 0B0000EA 		b	.L144
 1485              	.L201:
 418:../uvc.c      ****     switch (bRequest)
 1486              		.loc 1 418 0
 1487 0b60 810055E3 		cmp	r5, #129
 1488 0b64 6A00000A 		beq	.L106
 1489 0b68 1000009A 		bls	.L204
 522:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1490              		.loc 1 522 0
 1491 0b6c 230054E3 		cmp	r4, #35
 1492 0b70 AD00009A 		bls	.L133
 523:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1493              		.loc 1 523 0
 1494 0b74 87A087E0 		add	sl, r7, r7, asl #1
 1495 0b78 8A6186E0 		add	r6, r6, sl, asl #3
 1496 0b7c 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 1497 0b80 F0AD9FE5 		ldr	sl, .L206+12
 524:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1498              		.loc 1 524 0
 1499 0b84 0470D6E5 		ldrb	r7, [r6, #4]	@ zero_extendqisi2
 1500              	.LVL112:
 523:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1501              		.loc 1 523 0
 1502 0b88 5840CAE5 		strb	r4, [sl, #88]
 524:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1503              		.loc 1 524 0
 1504 0b8c 5970CAE5 		strb	r7, [sl, #89]
 1505              	.L144:
 600:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1506              		.loc 1 600 0
 1507 0b90 0800A0E1 		mov	r0, r8
 1508 0b94 E01D9FE5 		ldr	r1, .L206+16
 1509 0b98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1510              	.LVL113:
 602:../uvc.c      **** 			  break;
 1511              		.loc 1 602 0
 1512 0b9c FFC0A0E3 		mov	ip, #255
 600:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1513              		.loc 1 600 0
 1514 0ba0 5870DAE5 		ldrb	r7, [sl, #88]	@ zero_extendqisi2
 602:../uvc.c      **** 			  break;
 1515              		.loc 1 602 0
 1516 0ba4 0CE0A0E1 		mov	lr, ip
 1517 0ba8 0C40A0E1 		mov	r4, ip
 1518 0bac CDFFFFEA 		b	.L114
 1519              	.LVL114:
 1520              	.L204:
 418:../uvc.c      ****     switch (bRequest)
 1521              		.loc 1 418 0
 1522 0bb0 010055E3 		cmp	r5, #1
 1523 0bb4 C3FFFF1A 		bne	.L104
 604:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1524              		.loc 1 604 0
 1525 0bb8 B81D9FE5 		ldr	r1, .L206+12
 1526 0bbc 26208DE2 		add	r2, sp, #38
 1527 0bc0 2000A0E3 		mov	r0, #32
 1528 0bc4 581081E2 		add	r1, r1, #88
 1529 0bc8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1530              	.LVL115:
 606:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1531              		.loc 1 606 0
 1532 0bcc 002050E2 		subs	r2, r0, #0
 1533 0bd0 4103001A 		bne	.L146
 608:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1534              		.loc 1 608 0
 1535 0bd4 9C3D9FE5 		ldr	r3, .L206+12
 609:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1536              		.loc 1 609 0
 1537 0bd8 980D9FE5 		ldr	r0, .L206+12
 1538              	.LVL116:
 611:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1539              		.loc 1 611 0
 1540 0bdc 94ED9FE5 		ldr	lr, .L206+12
 608:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1541              		.loc 1 608 0
 1542 0be0 5830D3E5 		ldrb	r3, [r3, #88]	@ zero_extendqisi2
 609:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1543              		.loc 1 609 0
 1544 0be4 59C0D0E5 		ldrb	ip, [r0, #89]	@ zero_extendqisi2
 611:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1545              		.loc 1 611 0
 1546 0be8 5AE0DEE5 		ldrb	lr, [lr, #90]	@ zero_extendqisi2
 608:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1547              		.loc 1 608 0
 1548 0bec 14308DE5 		str	r3, [sp, #20]
 1549              	.LVL117:
 609:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1550              		.loc 1 609 0
 1551 0bf0 1CC08DE5 		str	ip, [sp, #28]
 1552              	.LVL118:
 611:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1553              		.loc 1 611 0
 1554 0bf4 18E08DE5 		str	lr, [sp, #24]
 1555              	.LVL119:
 615:../uvc.c      **** 				  switch(CtrlID)
 1556              		.loc 1 615 0
 1557 0bf8 260054E3 		cmp	r4, #38
 1558 0bfc 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1559 0c00 1B0300EA 		b	.L147
 1560              	.L163:
 1561 0c04 F8170000 		.word	.L148
 1562 0c08 38170000 		.word	.L149
 1563 0c0c 74180000 		.word	.L147
 1564 0c10 74180000 		.word	.L147
 1565 0c14 D4160000 		.word	.L150
 1566 0c18 94150000 		.word	.L151
 1567 0c1c 18150000 		.word	.L152
 1568 0c20 74180000 		.word	.L147
 1569 0c24 74180000 		.word	.L147
 1570 0c28 74180000 		.word	.L147
 1571 0c2c 74180000 		.word	.L147
 1572 0c30 90140000 		.word	.L153
 1573 0c34 74180000 		.word	.L147
 1574 0c38 74180000 		.word	.L147
 1575 0c3c 74180000 		.word	.L147
 1576 0c40 74180000 		.word	.L147
 1577 0c44 0C140000 		.word	.L154
 1578 0c48 74180000 		.word	.L147
 1579 0c4c 74180000 		.word	.L147
 1580 0c50 74180000 		.word	.L147
 1581 0c54 74180000 		.word	.L147
 1582 0c58 74180000 		.word	.L147
 1583 0c5c 74180000 		.word	.L147
 1584 0c60 74180000 		.word	.L147
 1585 0c64 74180000 		.word	.L147
 1586 0c68 54130000 		.word	.L155
 1587 0c6c BC120000 		.word	.L156
 1588 0c70 74180000 		.word	.L147
 1589 0c74 AC120000 		.word	.L157
 1590 0c78 74180000 		.word	.L147
 1591 0c7c 50120000 		.word	.L158
 1592 0c80 CC110000 		.word	.L159
 1593 0c84 74180000 		.word	.L147
 1594 0c88 74180000 		.word	.L147
 1595 0c8c 74180000 		.word	.L147
 1596 0c90 74180000 		.word	.L147
 1597 0c94 30110000 		.word	.L160
 1598 0c98 18110000 		.word	.L161
 1599 0c9c B4100000 		.word	.L162
 1600              	.LVL120:
 1601              	.L109:
 559:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1602              		.loc 1 559 0
 1603 0ca0 230054E3 		cmp	r4, #35
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1604              		.loc 1 560 0
 1605 0ca4 87708780 		addhi	r7, r7, r7, asl #1
 1606              	.LVL121:
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1607              		.loc 1 566 0
 1608 0ca8 84408490 		addls	r4, r4, r4, asl #1
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1609              		.loc 1 560 0
 1610 0cac 87618680 		addhi	r6, r6, r7, asl #3
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1611              		.loc 1 566 0
 1612 0cb0 84618690 		addls	r6, r6, r4, asl #3
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1613              		.loc 1 560 0
 1614 0cb4 BCAC9F85 		ldrhi	sl, .L206+12
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1615              		.loc 1 566 0
 1616 0cb8 B8AC9F95 		ldrls	sl, .L206+12
 560:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1617              		.loc 1 560 0
 1618 0cbc 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 561:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1619              		.loc 1 561 0
 1620 0cc0 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1621              		.loc 1 566 0
 1622 0cc4 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 567:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1623              		.loc 1 567 0
 1624 0cc8 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 568:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1625              		.loc 1 568 0
 1626 0ccc 0030A0E3 		mov	r3, #0
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1627              		.loc 1 566 0
 1628 0cd0 5810CAE5 		strb	r1, [sl, #88]
 567:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1629              		.loc 1 567 0
 1630 0cd4 5920CAE5 		strb	r2, [sl, #89]
 568:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1631              		.loc 1 568 0
 1632 0cd8 5A30CAE5 		strb	r3, [sl, #90]
 569:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1633              		.loc 1 569 0
 1634 0cdc 5B30CAE5 		strb	r3, [sl, #91]
 1635 0ce0 AAFFFFEA 		b	.L144
 1636              	.LVL122:
 1637              	.L110:
 422:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1638              		.loc 1 422 0
 1639 0ce4 8C4C9FE5 		ldr	r4, .L206+12
 423:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1640              		.loc 1 423 0
 1641 0ce8 00C0A0E3 		mov	ip, #0
 1642 0cec 59C0C4E5 		strb	ip, [r4, #89]
 424:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1643              		.loc 1 424 0
 1644 0cf0 581084E2 		add	r1, r4, #88
 422:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1645              		.loc 1 422 0
 1646 0cf4 5880C4E5 		strb	r8, [r4, #88]
 424:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1647              		.loc 1 424 0
 1648 0cf8 0200A0E3 		mov	r0, #2
 1649 0cfc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1650              	.LVL123:
 426:../uvc.c      **** 			  break;
 1651              		.loc 1 426 0
 1652 0d00 FFC0A0E3 		mov	ip, #255
 424:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1653              		.loc 1 424 0
 1654 0d04 5870D4E5 		ldrb	r7, [r4, #88]	@ zero_extendqisi2
 1655              	.LVL124:
 426:../uvc.c      **** 			  break;
 1656              		.loc 1 426 0
 1657 0d08 0CE0A0E1 		mov	lr, ip
 1658 0d0c 0C40A0E1 		mov	r4, ip
 1659 0d10 74FFFFEA 		b	.L114
 1660              	.LVL125:
 1661              	.L106:
 429:../uvc.c      **** 			 switch(CtrlID)
 1662              		.loc 1 429 0
 1663 0d14 011044E2 		sub	r1, r4, #1
 1664 0d18 250051E3 		cmp	r1, #37
 1665 0d1c 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1666 0d20 DA0000EA 		b	.L115
 1667              	.L123:
 1668 0d24 4C100000 		.word	.L116
 1669 0d28 90100000 		.word	.L115
 1670 0d2c 90100000 		.word	.L115
 1671 0d30 90100000 		.word	.L115
 1672 0d34 2C100000 		.word	.L117
 1673 0d38 90100000 		.word	.L115
 1674 0d3c 90100000 		.word	.L115
 1675 0d40 90100000 		.word	.L115
 1676 0d44 90100000 		.word	.L115
 1677 0d48 90100000 		.word	.L115
 1678 0d4c 08100000 		.word	.L118
 1679 0d50 90100000 		.word	.L115
 1680 0d54 90100000 		.word	.L115
 1681 0d58 90100000 		.word	.L115
 1682 0d5c 90100000 		.word	.L115
 1683 0d60 90100000 		.word	.L115
 1684 0d64 90100000 		.word	.L115
 1685 0d68 90100000 		.word	.L115
 1686 0d6c 90100000 		.word	.L115
 1687 0d70 90100000 		.word	.L115
 1688 0d74 90100000 		.word	.L115
 1689 0d78 90100000 		.word	.L115
 1690 0d7c 90100000 		.word	.L115
 1691 0d80 90100000 		.word	.L115
 1692 0d84 CC0F0000 		.word	.L119
 1693 0d88 90100000 		.word	.L115
 1694 0d8c 90100000 		.word	.L115
 1695 0d90 B00F0000 		.word	.L120
 1696 0d94 90100000 		.word	.L115
 1697 0d98 90100000 		.word	.L115
 1698 0d9c 140F0000 		.word	.L121
 1699 0da0 90100000 		.word	.L115
 1700 0da4 90100000 		.word	.L115
 1701 0da8 90100000 		.word	.L115
 1702 0dac 90100000 		.word	.L115
 1703 0db0 D80E0000 		.word	.L122
 1704 0db4 D80E0000 		.word	.L122
 1705 0db8 D80E0000 		.word	.L122
 1706              	.L202:
 586:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1707              		.loc 1 586 0
 1708 0dbc 230054E3 		cmp	r4, #35
 1709 0dc0 3100009A 		bls	.L143
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1710              		.loc 1 587 0
 1711 0dc4 877087E0 		add	r7, r7, r7, asl #1
 1712              	.LVL126:
 1713 0dc8 876186E0 		add	r6, r6, r7, asl #3
 1714 0dcc A4AB9FE5 		ldr	sl, .L206+12
 1715 0dd0 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1716              		.loc 1 588 0
 1717 0dd4 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1718              		.loc 1 587 0
 1719 0dd8 5820CAE5 		strb	r2, [sl, #88]
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1720              		.loc 1 588 0
 1721 0ddc 5910CAE5 		strb	r1, [sl, #89]
 1722 0de0 6AFFFFEA 		b	.L144
 1723              	.LVL127:
 1724              	.L111:
 575:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1725              		.loc 1 575 0
 1726 0de4 230054E3 		cmp	r4, #35
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1727              		.loc 1 576 0
 1728 0de8 87708780 		addhi	r7, r7, r7, asl #1
 1729              	.LVL128:
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1730              		.loc 1 579 0
 1731 0dec 84408490 		addls	r4, r4, r4, asl #1
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1732              		.loc 1 576 0
 1733 0df0 87618680 		addhi	r6, r6, r7, asl #3
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1734              		.loc 1 579 0
 1735 0df4 84618690 		addls	r6, r6, r4, asl #3
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1736              		.loc 1 576 0
 1737 0df8 788B9F85 		ldrhi	r8, .L206+12
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1738              		.loc 1 579 0
 1739 0dfc 748B9F95 		ldrls	r8, .L206+12
 576:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1740              		.loc 1 576 0
 1741 0e00 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1742              		.loc 1 579 0
 1743 0e04 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 581:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1744              		.loc 1 581 0
 1745 0e08 0100A0E3 		mov	r0, #1
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1746              		.loc 1 579 0
 1747 0e0c 5830C8E5 		strb	r3, [r8, #88]
 581:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1748              		.loc 1 581 0
 1749 0e10 641B9FE5 		ldr	r1, .L206+16
 1750 0e14 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1751              	.LVL129:
 584:../uvc.c      **** 			  break;
 1752              		.loc 1 584 0
 1753 0e18 FFC0A0E3 		mov	ip, #255
 581:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1754              		.loc 1 581 0
 1755 0e1c 5870D8E5 		ldrb	r7, [r8, #88]	@ zero_extendqisi2
 584:../uvc.c      **** 			  break;
 1756              		.loc 1 584 0
 1757 0e20 0CE0A0E1 		mov	lr, ip
 1758 0e24 0C40A0E1 		mov	r4, ip
 1759 0e28 2EFFFFEA 		b	.L114
 1760              	.LVL130:
 1761              	.L133:
 527:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1762              		.loc 1 527 0
 1763 0e2c 0B0054E3 		cmp	r4, #11
 534:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1764              		.loc 1 534 0
 1765 0e30 84408410 		addne	r4, r4, r4, asl #1
 1766 0e34 84618610 		addne	r6, r6, r4, asl #3
 1767 0e38 38AB9F15 		ldrne	sl, .L206+12
 528:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1768              		.loc 1 528 0
 1769 0e3c 34AB9F05 		ldreq	sl, .L206+12
 1770 0e40 383B9F05 		ldreq	r3, .L206+20
 534:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1771              		.loc 1 534 0
 1772 0e44 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 535:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1773              		.loc 1 535 0
 1774 0e48 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 528:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1775              		.loc 1 528 0
 1776 0e4c 58308A05 		streq	r3, [sl, #88]
 534:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1777              		.loc 1 534 0
 1778 0e50 5820CA15 		strneb	r2, [sl, #88]
 535:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1779              		.loc 1 535 0
 1780 0e54 5930CA15 		strneb	r3, [sl, #89]
 1781 0e58 4CFFFFEA 		b	.L144
 1782              	.L136:
 545:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1783              		.loc 1 545 0
 1784 0e5c 0B0054E3 		cmp	r4, #11
 552:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1785              		.loc 1 552 0
 1786 0e60 84408410 		addne	r4, r4, r4, asl #1
 1787 0e64 84618610 		addne	r6, r6, r4, asl #3
 1788 0e68 08AB9F15 		ldrne	sl, .L206+12
 546:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1789              		.loc 1 546 0
 1790 0e6c 04AB9F05 		ldreq	sl, .L206+12
 1791 0e70 0C3B9F05 		ldreq	r3, .L206+24
 552:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1792              		.loc 1 552 0
 1793 0e74 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 553:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1794              		.loc 1 553 0
 1795 0e78 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 546:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1796              		.loc 1 546 0
 1797 0e7c 58308A05 		streq	r3, [sl, #88]
 552:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1798              		.loc 1 552 0
 1799 0e80 5820CA15 		strneb	r2, [sl, #88]
 553:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1800              		.loc 1 553 0
 1801 0e84 5930CA15 		strneb	r3, [sl, #89]
 1802 0e88 40FFFFEA 		b	.L144
 1803              	.L143:
 591:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1804              		.loc 1 591 0
 1805 0e8c 0B0054E3 		cmp	r4, #11
 1806 0e90 0700000A 		beq	.L205
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1807              		.loc 1 597 0
 1808 0e94 84A084E0 		add	sl, r4, r4, asl #1
 1809 0e98 8A6186E0 		add	r6, r6, sl, asl #3
 1810 0e9c 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1811 0ea0 D0AA9FE5 		ldr	sl, .L206+12
 598:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1812              		.loc 1 598 0
 1813 0ea4 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1814              		.loc 1 597 0
 1815 0ea8 5830CAE5 		strb	r3, [sl, #88]
 598:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1816              		.loc 1 598 0
 1817 0eac 5900CAE5 		strb	r0, [sl, #89]
 1818 0eb0 36FFFFEA 		b	.L144
 1819              	.L205:
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1820              		.loc 1 592 0
 1821 0eb4 BCAA9FE5 		ldr	sl, .L206+12
 1822 0eb8 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 594:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1823              		.loc 1 594 0
 1824 0ebc 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 593:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1825              		.loc 1 593 0
 1826 0ec0 0040A0E3 		mov	r4, #0
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1827              		.loc 1 592 0
 1828 0ec4 58C0CAE5 		strb	ip, [sl, #88]
 593:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1829              		.loc 1 593 0
 1830 0ec8 5940CAE5 		strb	r4, [sl, #89]
 594:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1831              		.loc 1 594 0
 1832 0ecc 5AE0CAE5 		strb	lr, [sl, #90]
 595:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1833              		.loc 1 595 0
 1834 0ed0 5B40CAE5 		strb	r4, [sl, #91]
 1835 0ed4 2DFFFFEA 		b	.L144
 1836              	.L122:
 435:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1837              		.loc 1 435 0
 1838 0ed8 877087E0 		add	r7, r7, r7, asl #1
 1839              	.LVL131:
 1840 0edc 876186E0 		add	r6, r6, r7, asl #3
 1841 0ee0 90EA9FE5 		ldr	lr, .L206+12
 1842 0ee4 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 436:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1843              		.loc 1 436 0
 1844 0ee8 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 435:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1845              		.loc 1 435 0
 1846 0eec 5840CEE5 		strb	r4, [lr, #88]
 436:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1847              		.loc 1 436 0
 1848 0ef0 5960CEE5 		strb	r6, [lr, #89]
 1849              	.LVL132:
 1850              	.L126:
 515:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1851              		.loc 1 515 0
 1852 0ef4 0800A0E1 		mov	r0, r8
 1853 0ef8 7C1A9FE5 		ldr	r1, .L206+16
 1854 0efc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 520:../uvc.c      **** 			  break;
 1855              		.loc 1 520 0
 1856 0f00 FFE0A0E3 		mov	lr, #255
 515:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1857              		.loc 1 515 0
 1858 0f04 0470A0E1 		mov	r7, r4
 1859 0f08 06C0A0E1 		mov	ip, r6
 520:../uvc.c      **** 			  break;
 1860              		.loc 1 520 0
 1861 0f0c 0E40A0E1 		mov	r4, lr
 1862              	.LVL133:
 1863 0f10 F4FEFFEA 		b	.L114
 1864              	.LVL134:
 1865              	.L121:
 456:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1866              		.loc 1 456 0 discriminator 1
 1867 0f14 000058E3 		cmp	r8, #0
 1868 0f18 8C02000A 		beq	.L196
 454:../uvc.c      **** 					 break;
 1869              		.loc 1 454 0
 1870 0f1c 28E1A0E1 		mov	lr, r8, lsr #2
 1871 0f20 00005EE3 		cmp	lr, #0
 1872 0f24 03005813 		cmpne	r8, #3
 1873 0f28 0020A083 		movhi	r2, #0
 1874 0f2c 0120A093 		movls	r2, #1
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1875              		.loc 1 388 0
 1876 0f30 0E31A0E1 		mov	r3, lr, asl #2
 454:../uvc.c      **** 					 break;
 1877              		.loc 1 454 0
 1878 0f34 8902009A 		bls	.L184
 1879 0f38 3C1A9FE5 		ldr	r1, .L206+16
 1880 0f3c 0C0041E2 		sub	r0, r1, #12
 1881              	.LVL135:
 1882              	.L128:
 457:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1883              		.loc 1 457 0 discriminator 2
 1884 0f40 044090E4 		ldr	r4, [r0], #4
 1885 0f44 01C082E2 		add	ip, r2, #1
 1886 0f48 FF200CE2 		and	r2, ip, #255
 1887 0f4c 02005EE1 		cmp	lr, r2
 1888 0f50 044081E4 		str	r4, [r1], #4
 1889 0f54 F9FFFF8A 		bhi	.L128
 457:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1890              		.loc 1 457 0 is_stmt 0
 1891 0f58 030058E1 		cmp	r8, r3
 1892 0f5c 140A9F15 		ldrne	r0, .L206+12
 1893 0f60 7A02000A 		beq	.L196
 1894              	.L188:
 1895 0f64 03E080E0 		add	lr, r0, r3
 1896 0f68 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 456:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1897              		.loc 1 456 0 is_stmt 1
 1898 0f6c 016083E2 		add	r6, r3, #1
 1899 0f70 FF3006E2 		and	r3, r6, #255
 1900              	.LVL136:
 1901 0f74 030058E1 		cmp	r8, r3
 457:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1902              		.loc 1 457 0
 1903 0f78 5810CEE5 		strb	r1, [lr, #88]
 456:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1904              		.loc 1 456 0
 1905 0f7c F8FFFF8A 		bhi	.L188
 1906              	.LVL137:
 1907              	.L125:
 466:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1908              		.loc 1 466 0
 1909 0f80 5770D0E5 		ldrb	r7, [r0, #87]	@ zero_extendqisi2
 1910              	.LVL138:
 459:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1911              		.loc 1 459 0
 1912 0f84 EC399FE5 		ldr	r3, .L206+12
 466:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1913              		.loc 1 466 0
 1914 0f88 FF0057E3 		cmp	r7, #255
 459:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1915              		.loc 1 459 0
 1916 0f8c 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1917              	.LVL139:
 460:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1918              		.loc 1 460 0
 1919 0f90 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 1920              	.LVL140:
 466:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1921              		.loc 1 466 0
 1922 0f94 D6FFFF0A 		beq	.L126
 468:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1923              		.loc 1 468 0
 1924 0f98 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1925 0f9c E4199FE5 		ldr	r1, .L206+28
 1926 0fa0 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1927 0fa4 0400A0E3 		mov	r0, #4
 1928 0fa8 FEFFFFEB 		bl	CyU3PDebugPrint
 1929 0fac D0FFFFEA 		b	.L126
 1930              	.LVL141:
 1931              	.L120:
 452:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 1932              		.loc 1 452 0
 1933 0fb0 C0399FE5 		ldr	r3, .L206+12
 442:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 1934              		.loc 1 442 0
 1935 0fb4 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 1936              	.LVL142:
 453:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1937              		.loc 1 453 0
 1938 0fb8 0020A0E3 		mov	r2, #0
 452:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 1939              		.loc 1 452 0
 1940 0fbc 5840C3E5 		strb	r4, [r3, #88]
 453:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1941              		.loc 1 453 0
 1942 0fc0 5920C3E5 		strb	r2, [r3, #89]
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 1943              		.loc 1 406 0
 1944 0fc4 FF60A0E3 		mov	r6, #255
 454:../uvc.c      **** 					 break;
 1945              		.loc 1 454 0
 1946 0fc8 C9FFFFEA 		b	.L126
 1947              	.LVL143:
 1948              	.L119:
 472:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1949              		.loc 1 472 0
 1950 0fcc E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 1951 0fd0 A0C99FE5 		ldr	ip, .L206+12
 474:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1952              		.loc 1 474 0
 1953 0fd4 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1954              		.loc 1 473 0
 1955 0fd8 00E0A0E3 		mov	lr, #0
 472:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1956              		.loc 1 472 0
 1957 0fdc 5840CCE5 		strb	r4, [ip, #88]
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1958              		.loc 1 473 0
 1959 0fe0 59E0CCE5 		strb	lr, [ip, #89]
 474:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1960              		.loc 1 474 0
 1961 0fe4 5A60CCE5 		strb	r6, [ip, #90]
 475:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1962              		.loc 1 475 0
 1963 0fe8 5BE0CCE5 		strb	lr, [ip, #91]
 1964              	.LVL144:
 478:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 1965              		.loc 1 478 0
 1966 0fec 98199FE5 		ldr	r1, .L206+32
 1967 0ff0 0420A0E1 		mov	r2, r4
 1968 0ff4 0E30A0E1 		mov	r3, lr
 1969 0ff8 0400A0E3 		mov	r0, #4
 1970 0ffc 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 1971 1000 FEFFFFEB 		bl	CyU3PDebugPrint
 479:../uvc.c      **** 					 break;
 1972              		.loc 1 479 0
 1973 1004 BAFFFFEA 		b	.L126
 1974              	.LVL145:
 1975              	.L118:
 500:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 1976              		.loc 1 500 0
 1977 1008 68C99FE5 		ldr	ip, .L206+12
 1978 100c 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 502:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 1979              		.loc 1 502 0
 1980 1010 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1981              		.loc 1 501 0
 1982 1014 00E0A0E3 		mov	lr, #0
 500:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 1983              		.loc 1 500 0
 1984 1018 5840CCE5 		strb	r4, [ip, #88]
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1985              		.loc 1 501 0
 1986 101c 59E0CCE5 		strb	lr, [ip, #89]
 502:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 1987              		.loc 1 502 0
 1988 1020 5A60CCE5 		strb	r6, [ip, #90]
 503:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1989              		.loc 1 503 0
 1990 1024 5BE0CCE5 		strb	lr, [ip, #91]
 1991              	.LVL146:
 506:../uvc.c      **** 					 break;
 1992              		.loc 1 506 0
 1993 1028 B1FFFFEA 		b	.L126
 1994              	.LVL147:
 1995              	.L117:
 495:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 1996              		.loc 1 495 0
 1997 102c 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 1998 1030 40799FE5 		ldr	r7, .L206+12
 1999              	.LVL148:
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2000              		.loc 1 496 0
 2001 1034 0060A0E3 		mov	r6, #0
 495:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2002              		.loc 1 495 0
 2003 1038 804024E2 		eor	r4, r4, #128
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2004              		.loc 1 496 0
 2005 103c 5960C7E5 		strb	r6, [r7, #89]
 2006              	.LVL149:
 495:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2007              		.loc 1 495 0
 2008 1040 5840C7E5 		strb	r4, [r7, #88]
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2009              		.loc 1 406 0
 2010 1044 FF60A0E3 		mov	r6, #255
 498:../uvc.c      **** 					 break;
 2011              		.loc 1 498 0
 2012 1048 A9FFFFEA 		b	.L126
 2013              	.LVL150:
 2014              	.L116:
 484:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2015              		.loc 1 484 0
 2016 104c A631D6E5 		ldrb	r3, [r6, #422]	@ zero_extendqisi2
 482:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2017              		.loc 1 482 0
 2018 1050 A511D6E5 		ldrb	r1, [r6, #421]	@ zero_extendqisi2
 2019              	.LVL151:
 484:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2020              		.loc 1 484 0
 2021 1054 020013E3 		tst	r3, #2
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2022              		.loc 1 487 0
 2023 1058 2111A001 		moveq	r1, r1, lsr #2
 2024              	.LVL152:
 2025 105c 811CE001 		mvneq	r1, r1, asl #25
 489:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2026              		.loc 1 489 0
 2027 1060 10299FE5 		ldr	r2, .L206+12
 485:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2028              		.loc 1 485 0
 2029 1064 0333A011 		movne	r3, r3, asl #6
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2030              		.loc 1 487 0
 2031 1068 A11CE001 		mvneq	r1, r1, lsr #25
 485:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2032              		.loc 1 485 0
 2033 106c 40400312 		andne	r4, r3, #64
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2034              		.loc 1 487 0
 2035 1070 03338101 		orreq	r3, r1, r3, asl #6
 485:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2036              		.loc 1 485 0
 2037 1074 21418411 		orrne	r4, r4, r1, lsr #2
 2038              	.LVL153:
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2039              		.loc 1 487 0
 2040 1078 FF400302 		andeq	r4, r3, #255
 2041              	.LVL154:
 490:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2042              		.loc 1 490 0
 2043 107c 0000A0E3 		mov	r0, #0
 489:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2044              		.loc 1 489 0
 2045 1080 5840C2E5 		strb	r4, [r2, #88]
 490:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2046              		.loc 1 490 0
 2047 1084 5900C2E5 		strb	r0, [r2, #89]
 2048              	.LVL155:
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2049              		.loc 1 406 0
 2050 1088 FF60A0E3 		mov	r6, #255
 492:../uvc.c      **** 					 break;
 2051              		.loc 1 492 0
 2052 108c 98FFFFEA 		b	.L126
 2053              	.LVL156:
 2054              	.L115:
 509:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2055              		.loc 1 509 0
 2056 1090 841084E0 		add	r1, r4, r4, asl #1
 2057 1094 813186E0 		add	r3, r6, r1, asl #3
 2058 1098 D8289FE5 		ldr	r2, .L206+12
 2059 109c 8D41D3E5 		ldrb	r4, [r3, #397]	@ zero_extendqisi2
 510:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2060              		.loc 1 510 0
 2061 10a0 0000A0E3 		mov	r0, #0
 406:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2062              		.loc 1 406 0
 2063 10a4 FF60A0E3 		mov	r6, #255
 509:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2064              		.loc 1 509 0
 2065 10a8 5840C2E5 		strb	r4, [r2, #88]
 510:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2066              		.loc 1 510 0
 2067 10ac 5900C2E5 		strb	r0, [r2, #89]
 2068              	.LVL157:
 512:../uvc.c      **** 					 break;
 2069              		.loc 1 512 0
 2070 10b0 8FFFFFEA 		b	.L126
 2071              	.LVL158:
 2072              	.L162:
 759:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2073              		.loc 1 759 0
 2074 10b4 D4489FE5 		ldr	r4, .L206+36
 2075 10b8 0010E0E3 		mvn	r1, #0
 2076 10bc 1C0094E5 		ldr	r0, [r4, #28]
 2077 10c0 FEFFFFEB 		bl	_txe_mutex_get
 2078              	.LVL159:
 760:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2079              		.loc 1 760 0
 2080 10c4 2610A0E3 		mov	r1, #38
 2081              	.L200:
 2082 10c8 14C09DE5 		ldr	ip, [sp, #20]
 2083 10cc 00E0A0E3 		mov	lr, #0
 2084 10d0 0A30A0E1 		mov	r3, sl
 2085 10d4 0920A0E1 		mov	r2, r9
 2086 10d8 0400A0E1 		mov	r0, r4
 2087 10dc 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2088 10e0 FEFFFFEB 		bl	cmdSet
 761:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2089              		.loc 1 761 0
 2090 10e4 1C0094E5 		ldr	r0, [r4, #28]
 2091 10e8 FEFFFFEB 		bl	_txe_mutex_put
 762:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2092              		.loc 1 762 0
 2093 10ec 14109DE5 		ldr	r1, [sp, #20]
 2094 10f0 873087E0 		add	r3, r7, r7, asl #1
 2095 10f4 836186E0 		add	r6, r6, r3, asl #3
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2096              		.loc 1 763 0
 2097 10f8 0170A0E3 		mov	r7, #1
 2098              	.LVL160:
 764:../uvc.c      **** 							 break;
 2099              		.loc 1 764 0
 2100 10fc FFC0A0E3 		mov	ip, #255
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2101              		.loc 1 763 0
 2102 1100 1070C6E5 		strb	r7, [r6, #16]
 762:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2103              		.loc 1 762 0
 2104 1104 0D10C6E5 		strb	r1, [r6, #13]
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2105              		.loc 1 763 0
 2106 1108 0140A0E1 		mov	r4, r1
 2107 110c 18E09DE5 		ldr	lr, [sp, #24]
 764:../uvc.c      **** 							 break;
 2108              		.loc 1 764 0
 2109 1110 0C70A0E1 		mov	r7, ip
 2110 1114 73FEFFEA 		b	.L114
 2111              	.LVL161:
 2112              	.L161:
 751:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2113              		.loc 1 751 0
 2114 1118 70489FE5 		ldr	r4, .L206+36
 2115 111c 0010E0E3 		mvn	r1, #0
 2116 1120 1C0094E5 		ldr	r0, [r4, #28]
 2117 1124 FEFFFFEB 		bl	_txe_mutex_get
 2118              	.LVL162:
 752:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2119              		.loc 1 752 0
 2120 1128 2510A0E3 		mov	r1, #37
 2121 112c E5FFFFEA 		b	.L200
 2122              	.LVL163:
 2123              	.L160:
 737:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2124              		.loc 1 737 0
 2125 1130 58489FE5 		ldr	r4, .L206+36
 2126 1134 0010E0E3 		mvn	r1, #0
 2127 1138 1C0094E5 		ldr	r0, [r4, #28]
 2128 113c FEFFFFEB 		bl	_txe_mutex_get
 2129              	.LVL164:
 736:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2130              		.loc 1 736 0
 2131 1140 14209DE5 		ldr	r2, [sp, #20]
 739:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2132              		.loc 1 739 0
 2133 1144 2410A0E3 		mov	r1, #36
 736:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2134              		.loc 1 736 0
 2135 1148 7F8002E2 		and	r8, r2, #127
 2136 114c 18808DE5 		str	r8, [sp, #24]
 2137              	.LVL165:
 739:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2138              		.loc 1 739 0
 2139 1150 18C09DE5 		ldr	ip, [sp, #24]
 2140 1154 0920A0E1 		mov	r2, r9
 2141 1158 0A30A0E1 		mov	r3, sl
 2142 115c 0400A0E1 		mov	r0, r4
 2143 1160 00C08DE5 		str	ip, [sp, #0]
 2144 1164 00C0A0E3 		mov	ip, #0
 2145 1168 04C08DE5 		str	ip, [sp, #4]
 2146 116c FEFFFFEB 		bl	cmdSet
 2147              	.LVL166:
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2148              		.loc 1 741 0
 2149 1170 1CE09DE5 		ldr	lr, [sp, #28]
 2150 1174 0180A0E3 		mov	r8, #1
 2151 1178 2410A0E3 		mov	r1, #36
 2152 117c 0B20A0E1 		mov	r2, fp
 2153 1180 0A30A0E1 		mov	r3, sl
 2154 1184 0400A0E1 		mov	r0, r4
 2155 1188 00E08DE5 		str	lr, [sp, #0]
 2156 118c 04808DE5 		str	r8, [sp, #4]
 2157 1190 FEFFFFEB 		bl	cmdSet
 742:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2158              		.loc 1 742 0
 2159 1194 1C0094E5 		ldr	r0, [r4, #28]
 2160 1198 FEFFFFEB 		bl	_txe_mutex_put
 2161              	.LVL167:
 745:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2162              		.loc 1 745 0
 2163 119c 18409DE5 		ldr	r4, [sp, #24]
 746:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2164              		.loc 1 746 0
 2165 11a0 1C009DE5 		ldr	r0, [sp, #28]
 745:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2166              		.loc 1 745 0
 2167 11a4 87C087E0 		add	ip, r7, r7, asl #1
 2168 11a8 8C6186E0 		add	r6, r6, ip, asl #3
 748:../uvc.c      **** 							 break;
 2169              		.loc 1 748 0
 2170 11ac FFC0A0E3 		mov	ip, #255
 745:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2171              		.loc 1 745 0
 2172 11b0 0D40C6E5 		strb	r4, [r6, #13]
 746:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2173              		.loc 1 746 0
 2174 11b4 0E00C6E5 		strb	r0, [r6, #14]
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2175              		.loc 1 747 0
 2176 11b8 1080C6E5 		strb	r8, [r6, #16]
 2177 11bc 14409DE5 		ldr	r4, [sp, #20]
 2178 11c0 00E0A0E1 		mov	lr, r0
 748:../uvc.c      **** 							 break;
 2179              		.loc 1 748 0
 2180 11c4 0C70A0E1 		mov	r7, ip
 2181              	.LVL168:
 2182 11c8 46FEFFEA 		b	.L114
 2183              	.LVL169:
 2184              	.L159:
 708:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2185              		.loc 1 708 0 discriminator 1
 2186 11cc 000058E3 		cmp	r8, #0
 2187 11d0 1800000A 		beq	.L165
 706:../uvc.c      **** 							 break;
 2188              		.loc 1 706 0
 2189 11d4 28E1A0E1 		mov	lr, r8, lsr #2
 2190 11d8 00005EE3 		cmp	lr, #0
 2191 11dc 03005813 		cmpne	r8, #3
 2192 11e0 0020A083 		movhi	r2, #0
 2193 11e4 0120A093 		movls	r2, #1
 2194              	.LVL170:
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2195              		.loc 1 388 0
 2196 11e8 0E31A0E1 		mov	r3, lr, asl #2
 706:../uvc.c      **** 							 break;
 2197              		.loc 1 706 0
 2198 11ec D901009A 		bls	.L185
 2199 11f0 9C179FE5 		ldr	r1, .L206+40
 2200 11f4 0C0081E2 		add	r0, r1, #12
 2201              	.LVL171:
 2202              	.L176:
 709:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2203              		.loc 1 709 0 discriminator 2
 2204 11f8 044090E4 		ldr	r4, [r0], #4
 2205 11fc 012082E2 		add	r2, r2, #1
 2206 1200 FF2002E2 		and	r2, r2, #255
 2207 1204 02005EE1 		cmp	lr, r2
 2208 1208 044081E4 		str	r4, [r1], #4
 2209 120c F9FFFF8A 		bhi	.L176
 709:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2210              		.loc 1 709 0 is_stmt 0
 2211 1210 030058E1 		cmp	r8, r3
 2212 1214 0700000A 		beq	.L165
 2213              	.LVL172:
 2214              	.L189:
 2215 1218 58E79FE5 		ldr	lr, .L206+12
 2216 121c 03708EE0 		add	r7, lr, r3
 2217 1220 5810D7E5 		ldrb	r1, [r7, #88]	@ zero_extendqisi2
 708:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2218              		.loc 1 708 0 is_stmt 1
 2219 1224 013083E2 		add	r3, r3, #1
 2220 1228 FF3003E2 		and	r3, r3, #255
 2221              	.LVL173:
 2222 122c 030058E1 		cmp	r8, r3
 709:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2223              		.loc 1 709 0
 2224 1230 4C10C7E5 		strb	r1, [r7, #76]
 708:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2225              		.loc 1 708 0
 2226 1234 F7FFFF8A 		bhi	.L189
 2227              	.LVL174:
 2228              	.L165:
 711:../uvc.c      **** 					 		I2CCmdHandler();
 2229              		.loc 1 711 0
 2230 1238 FEFFFFEB 		bl	I2CCmdHandler
 712:../uvc.c      **** 							 break;
 2231              		.loc 1 712 0
 2232 123c FFC0A0E3 		mov	ip, #255
 711:../uvc.c      **** 					 		I2CCmdHandler();
 2233              		.loc 1 711 0
 2234 1240 14409DE5 		ldr	r4, [sp, #20]
 2235 1244 18E09DE5 		ldr	lr, [sp, #24]
 712:../uvc.c      **** 							 break;
 2236              		.loc 1 712 0
 2237 1248 0C70A0E1 		mov	r7, ip
 2238 124c 25FEFFEA 		b	.L114
 2239              	.LVL175:
 2240              	.L158:
 702:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2241              		.loc 1 702 0
 2242 1250 38779FE5 		ldr	r7, .L206+36
 2243              	.LVL176:
 2244 1254 0010E0E3 		mvn	r1, #0
 2245 1258 1C0097E5 		ldr	r0, [r7, #28]
 2246 125c FEFFFFEB 		bl	_txe_mutex_get
 2247              	.LVL177:
 703:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2248              		.loc 1 703 0
 2249 1260 14009DE5 		ldr	r0, [sp, #20]
 2250 1264 00E0A0E3 		mov	lr, #0
 2251 1268 01C070E2 		rsbs	ip, r0, #1
 2252 126c 00C0A033 		movcc	ip, #0
 2253 1270 1E10A0E3 		mov	r1, #30
 2254 1274 0920A0E1 		mov	r2, r9
 2255 1278 0A30A0E1 		mov	r3, sl
 2256 127c 0700A0E1 		mov	r0, r7
 2257 1280 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2258 1284 FEFFFFEB 		bl	cmdSet
 704:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2259              		.loc 1 704 0
 2260 1288 1C0097E5 		ldr	r0, [r7, #28]
 2261 128c FEFFFFEB 		bl	_txe_mutex_put
 705:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2262              		.loc 1 705 0
 2263 1290 0140A0E3 		mov	r4, #1
 706:../uvc.c      **** 							 break;
 2264              		.loc 1 706 0
 2265 1294 FFC0A0E3 		mov	ip, #255
 705:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2266              		.loc 1 705 0
 2267 1298 6044C6E5 		strb	r4, [r6, #1120]
 2268 129c 18E09DE5 		ldr	lr, [sp, #24]
 2269 12a0 14409DE5 		ldr	r4, [sp, #20]
 706:../uvc.c      **** 							 break;
 2270              		.loc 1 706 0
 2271 12a4 0C70A0E1 		mov	r7, ip
 2272 12a8 0EFEFFEA 		b	.L114
 2273              	.LVL178:
 2274              	.L157:
 615:../uvc.c      **** 				  switch(CtrlID)
 2275              		.loc 1 615 0
 2276 12ac FFC0A0E3 		mov	ip, #255
 2277 12b0 0340A0E1 		mov	r4, r3
 2278 12b4 0C70A0E1 		mov	r7, ip
 2279              	.LVL179:
 2280 12b8 0AFEFFEA 		b	.L114
 2281              	.LVL180:
 2282              	.L156:
 669:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2283              		.loc 1 669 0
 2284 12bc CC769FE5 		ldr	r7, .L206+36
 2285              	.LVL181:
 667:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2286              		.loc 1 667 0
 2287 12c0 FD33C6E5 		strb	r3, [r6, #1021]
 668:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2288              		.loc 1 668 0
 2289 12c4 0130A0E3 		mov	r3, #1
 2290 12c8 0034C6E5 		strb	r3, [r6, #1024]
 669:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2291              		.loc 1 669 0
 2292 12cc 0010E0E3 		mvn	r1, #0
 2293 12d0 1C0097E5 		ldr	r0, [r7, #28]
 2294 12d4 FEFFFFEB 		bl	_txe_mutex_get
 2295              	.LVL182:
 670:../uvc.c      **** 							 if(WDRflag)
 2296              		.loc 1 670 0
 2297 12d8 10C696E5 		ldr	ip, [r6, #1552]
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2298              		.loc 1 671 0
 2299 12dc 1A10A0E3 		mov	r1, #26
 670:../uvc.c      **** 							 if(WDRflag)
 2300              		.loc 1 670 0
 2301 12e0 00005CE3 		cmp	ip, #0
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2302              		.loc 1 671 0
 2303 12e4 14C09D15 		ldrne	ip, [sp, #20]
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2304              		.loc 1 673 0
 2305 12e8 14E09D05 		ldreq	lr, [sp, #20]
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2306              		.loc 1 671 0
 2307 12ec 00C08D15 		strne	ip, [sp, #0]
 2308 12f0 0B20A011 		movne	r2, fp
 2309 12f4 00C0A013 		movne	ip, #0
 2310 12f8 0A30A011 		movne	r3, sl
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2311              		.loc 1 673 0
 2312 12fc 0920A001 		moveq	r2, r9
 2313 1300 0A30A001 		moveq	r3, sl
 671:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2314              		.loc 1 671 0
 2315 1304 0700A0E1 		mov	r0, r7
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2316              		.loc 1 673 0
 2317 1308 04C08DE5 		str	ip, [sp, #4]
 2318 130c 00E08D05 		streq	lr, [sp, #0]
 2319 1310 FEFFFFEB 		bl	cmdSet
 674:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2320              		.loc 1 674 0
 2321 1314 1C0097E5 		ldr	r0, [r7, #28]
 2322 1318 FEFFFFEB 		bl	_txe_mutex_put
 675:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2323              		.loc 1 675 0
 2324 131c 54269FE5 		ldr	r2, .L206+12
 2325 1320 103696E5 		ldr	r3, [r6, #1552]
 2326 1324 5AC0D2E5 		ldrb	ip, [r2, #90]	@ zero_extendqisi2
 2327 1328 5BE0D2E5 		ldrb	lr, [r2, #91]	@ zero_extendqisi2
 2328 132c 14409DE5 		ldr	r4, [sp, #20]
 2329 1330 60169FE5 		ldr	r1, .L206+44
 2330 1334 0400A0E3 		mov	r0, #4
 2331              	.L199:
 871:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2332              		.loc 1 871 0
 2333 1338 0420A0E1 		mov	r2, r4
 2334 133c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2335 1340 FEFFFFEB 		bl	CyU3PDebugPrint
 873:../uvc.c      **** 					 		 break;
 2336              		.loc 1 873 0
 2337 1344 FFC0A0E3 		mov	ip, #255
 871:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2338              		.loc 1 871 0
 2339 1348 18E09DE5 		ldr	lr, [sp, #24]
 873:../uvc.c      **** 					 		 break;
 2340              		.loc 1 873 0
 2341 134c 0C70A0E1 		mov	r7, ip
 2342 1350 E4FDFFEA 		b	.L114
 2343              	.LVL183:
 2344              	.L155:
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2345              		.loc 1 656 0
 2346 1354 34469FE5 		ldr	r4, .L206+36
 652:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2347              		.loc 1 652 0
 2348 1358 E533C6E5 		strb	r3, [r6, #997]
 653:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2349              		.loc 1 653 0
 2350 135c 18309DE5 		ldr	r3, [sp, #24]
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2351              		.loc 1 654 0
 2352 1360 0170A0E3 		mov	r7, #1
 2353              	.LVL184:
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2354              		.loc 1 656 0
 2355 1364 0010E0E3 		mvn	r1, #0
 653:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2356              		.loc 1 653 0
 2357 1368 E633C6E5 		strb	r3, [r6, #998]
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2358              		.loc 1 656 0
 2359 136c 1C0094E5 		ldr	r0, [r4, #28]
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2360              		.loc 1 654 0
 2361 1370 E873C6E5 		strb	r7, [r6, #1000]
 2362              	.LVL185:
 656:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2363              		.loc 1 656 0
 2364 1374 FEFFFFEB 		bl	_txe_mutex_get
 2365              	.LVL186:
 657:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2366              		.loc 1 657 0
 2367 1378 14C09DE5 		ldr	ip, [sp, #20]
 2368 137c 1910A0E3 		mov	r1, #25
 2369 1380 00C08DE5 		str	ip, [sp, #0]
 2370 1384 0400A0E1 		mov	r0, r4
 2371 1388 00C0A0E3 		mov	ip, #0
 2372 138c 0920A0E1 		mov	r2, r9
 2373 1390 0A30A0E1 		mov	r3, sl
 2374 1394 04C08DE5 		str	ip, [sp, #4]
 2375 1398 FEFFFFEB 		bl	cmdSet
 658:../uvc.c      **** 							 if(getData != 0){
 2376              		.loc 1 658 0
 2377 139c 14109DE5 		ldr	r1, [sp, #20]
 2378 13a0 000051E3 		cmp	r1, #0
 2379 13a4 0700000A 		beq	.L172
 2380              	.LVL187:
 660:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2381              		.loc 1 660 0
 2382 13a8 18E09DE5 		ldr	lr, [sp, #24]
 2383 13ac 0400A0E1 		mov	r0, r4
 2384 13b0 1910A0E3 		mov	r1, #25
 2385 13b4 0B20A0E1 		mov	r2, fp
 2386 13b8 0A30A0E1 		mov	r3, sl
 2387 13bc 00E08DE5 		str	lr, [sp, #0]
 2388 13c0 04708DE5 		str	r7, [sp, #4]
 2389 13c4 FEFFFFEB 		bl	cmdSet
 2390              	.LVL188:
 2391              	.L172:
 662:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2392              		.loc 1 662 0
 2393 13c8 1C0094E5 		ldr	r0, [r4, #28]
 2394 13cc FEFFFFEB 		bl	_txe_mutex_put
 663:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2395              		.loc 1 663 0
 2396 13d0 A0159FE5 		ldr	r1, .L206+12
 2397 13d4 9C059FE5 		ldr	r0, .L206+12
 2398 13d8 5A40D1E5 		ldrb	r4, [r1, #90]	@ zero_extendqisi2
 2399 13dc 5B70D0E5 		ldrb	r7, [r0, #91]	@ zero_extendqisi2
 2400 13e0 5820D1E5 		ldrb	r2, [r1, #88]	@ zero_extendqisi2
 2401 13e4 5930D1E5 		ldrb	r3, [r1, #89]	@ zero_extendqisi2
 2402 13e8 0400A0E3 		mov	r0, #4
 2403 13ec A8159FE5 		ldr	r1, .L206+48
 2404 13f0 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2405 13f4 FEFFFFEB 		bl	CyU3PDebugPrint
 664:../uvc.c      **** 							 break;
 2406              		.loc 1 664 0
 2407 13f8 FFC0A0E3 		mov	ip, #255
 663:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2408              		.loc 1 663 0
 2409 13fc 14409DE5 		ldr	r4, [sp, #20]
 2410 1400 18E09DE5 		ldr	lr, [sp, #24]
 664:../uvc.c      **** 							 break;
 2411              		.loc 1 664 0
 2412 1404 0C70A0E1 		mov	r7, ip
 2413 1408 B6FDFFEA 		b	.L114
 2414              	.LVL189:
 2415              	.L154:
 619:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2416              		.loc 1 619 0
 2417 140c 000053E2 		subs	r0, r3, #0
 618:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2418              		.loc 1 618 0
 2419 1410 0D03C6E5 		strb	r0, [r6, #781]
 2420 1414 50359FE5 		ldr	r3, .L206
 619:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2421              		.loc 1 619 0
 2422 1418 3701001A 		bne	.L166
 620:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2423              		.loc 1 620 0
 2424 141c B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2425              	.LVL190:
 2426 1420 020052E3 		cmp	r2, #2
 2427 1424 08005213 		cmpne	r2, #8
 2428 1428 0300000A 		beq	.L167
 621:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2429              		.loc 1 621 0
 2430 142c 010052E3 		cmp	r2, #1
 622:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2431              		.loc 1 622 0
 2432 1430 07208202 		addeq	r2, r2, #7
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2433              		.loc 1 624 0
 2434 1434 0220A013 		movne	r2, #2
 2435 1438 B524C3E5 		strb	r2, [r3, #1205]
 2436              	.LVL191:
 2437              	.L167:
 646:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2438              		.loc 1 646 0
 2439 143c 4C459FE5 		ldr	r4, .L206+36
 644:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2440              		.loc 1 644 0
 2441 1440 0120A0E3 		mov	r2, #1
 646:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2442              		.loc 1 646 0
 2443 1444 0010E0E3 		mvn	r1, #0
 2444 1448 1C0094E5 		ldr	r0, [r4, #28]
 644:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2445              		.loc 1 644 0
 2446 144c 1023C6E5 		strb	r2, [r6, #784]
 2447              	.LVL192:
 646:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2448              		.loc 1 646 0
 2449 1450 FEFFFFEB 		bl	_txe_mutex_get
 647:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2450              		.loc 1 647 0
 2451 1454 14C09DE5 		ldr	ip, [sp, #20]
 2452 1458 00E0A0E3 		mov	lr, #0
 2453 145c 1010A0E3 		mov	r1, #16
 2454 1460 0920A0E1 		mov	r2, r9
 2455 1464 0A30A0E1 		mov	r3, sl
 2456 1468 0400A0E1 		mov	r0, r4
 2457 146c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2458 1470 FEFFFFEB 		bl	cmdSet
 648:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2459              		.loc 1 648 0
 2460 1474 1C0094E5 		ldr	r0, [r4, #28]
 2461 1478 FEFFFFEB 		bl	_txe_mutex_put
 650:../uvc.c      **** 							 break;
 2462              		.loc 1 650 0
 2463 147c FFC0A0E3 		mov	ip, #255
 648:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2464              		.loc 1 648 0
 2465 1480 14409DE5 		ldr	r4, [sp, #20]
 2466 1484 18E09DE5 		ldr	lr, [sp, #24]
 650:../uvc.c      **** 							 break;
 2467              		.loc 1 650 0
 2468 1488 0C70A0E1 		mov	r7, ip
 2469 148c 95FDFFEA 		b	.L114
 2470              	.LVL193:
 2471              	.L153:
 825:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2472              		.loc 1 825 0
 2473 1490 F8449FE5 		ldr	r4, .L206+36
 2474 1494 0010E0E3 		mvn	r1, #0
 2475 1498 1C0094E5 		ldr	r0, [r4, #28]
 2476 149c FEFFFFEB 		bl	_txe_mutex_get
 2477              	.LVL194:
 826:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2478              		.loc 1 826 0
 2479 14a0 14C09DE5 		ldr	ip, [sp, #20]
 2480 14a4 0B10A0E3 		mov	r1, #11
 2481 14a8 0920A0E1 		mov	r2, r9
 2482 14ac 0A30A0E1 		mov	r3, sl
 2483 14b0 0400A0E1 		mov	r0, r4
 2484 14b4 00C08DE5 		str	ip, [sp, #0]
 2485 14b8 00C0A0E3 		mov	ip, #0
 2486 14bc 04C08DE5 		str	ip, [sp, #4]
 2487 14c0 FEFFFFEB 		bl	cmdSet
 2488              	.LVL195:
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2489              		.loc 1 828 0
 2490 14c4 18E09DE5 		ldr	lr, [sp, #24]
 2491 14c8 0170A0E3 		mov	r7, #1
 2492              	.LVL196:
 2493 14cc 0B20A0E1 		mov	r2, fp
 2494 14d0 0B10A0E3 		mov	r1, #11
 2495 14d4 0A30A0E1 		mov	r3, sl
 2496 14d8 0400A0E1 		mov	r0, r4
 2497 14dc 00E08DE5 		str	lr, [sp, #0]
 2498 14e0 04708DE5 		str	r7, [sp, #4]
 2499 14e4 FEFFFFEB 		bl	cmdSet
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2500              		.loc 1 829 0
 2501 14e8 1C0094E5 		ldr	r0, [r4, #28]
 2502 14ec FEFFFFEB 		bl	_txe_mutex_put
 831:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2503              		.loc 1 831 0
 2504 14f0 14009DE5 		ldr	r0, [sp, #20]
 832:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2505              		.loc 1 832 0
 2506 14f4 18209DE5 		ldr	r2, [sp, #24]
 834:../uvc.c      **** 							 break;
 2507              		.loc 1 834 0
 2508 14f8 FFC0A0E3 		mov	ip, #255
 833:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2509              		.loc 1 833 0
 2510 14fc 9872C6E5 		strb	r7, [r6, #664]
 831:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2511              		.loc 1 831 0
 2512 1500 8C04C6E5 		strb	r0, [r6, #1164]
 832:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2513              		.loc 1 832 0
 2514 1504 8E24C6E5 		strb	r2, [r6, #1166]
 833:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2515              		.loc 1 833 0
 2516 1508 0040A0E1 		mov	r4, r0
 2517 150c 02E0A0E1 		mov	lr, r2
 834:../uvc.c      **** 							 break;
 2518              		.loc 1 834 0
 2519 1510 0C70A0E1 		mov	r7, ip
 2520 1514 73FDFFEA 		b	.L114
 2521              	.LVL197:
 2522              	.L152:
 811:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2523              		.loc 1 811 0
 2524 1518 70449FE5 		ldr	r4, .L206+36
 2525 151c 0010E0E3 		mvn	r1, #0
 2526 1520 1C0094E5 		ldr	r0, [r4, #28]
 2527 1524 FEFFFFEB 		bl	_txe_mutex_get
 2528              	.LVL198:
 812:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2529              		.loc 1 812 0
 2530 1528 14C09DE5 		ldr	ip, [sp, #20]
 2531 152c 0610A0E3 		mov	r1, #6
 2532 1530 0920A0E1 		mov	r2, r9
 2533 1534 0A30A0E1 		mov	r3, sl
 2534 1538 0400A0E1 		mov	r0, r4
 2535 153c 00C08DE5 		str	ip, [sp, #0]
 2536 1540 00C0A0E3 		mov	ip, #0
 2537 1544 04C08DE5 		str	ip, [sp, #4]
 2538 1548 FEFFFFEB 		bl	cmdSet
 2539              	.LVL199:
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2540              		.loc 1 814 0
 2541 154c 14E09DE5 		ldr	lr, [sp, #20]
 2542 1550 0170A0E3 		mov	r7, #1
 2543              	.LVL200:
 2544 1554 0610A0E3 		mov	r1, #6
 2545 1558 0B20A0E1 		mov	r2, fp
 2546 155c 0A30A0E1 		mov	r3, sl
 2547 1560 0400A0E1 		mov	r0, r4
 2548 1564 00E08DE5 		str	lr, [sp, #0]
 2549 1568 04708DE5 		str	r7, [sp, #4]
 2550 156c FEFFFFEB 		bl	cmdSet
 815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2551              		.loc 1 815 0
 2552 1570 1C0094E5 		ldr	r0, [r4, #28]
 2553 1574 FEFFFFEB 		bl	_txe_mutex_put
 816:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2554              		.loc 1 816 0
 2555 1578 14409DE5 		ldr	r4, [sp, #20]
 818:../uvc.c      **** 							 break;
 2556              		.loc 1 818 0
 2557 157c FFC0A0E3 		mov	ip, #255
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2558              		.loc 1 817 0
 2559 1580 2072C6E5 		strb	r7, [r6, #544]
 816:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2560              		.loc 1 816 0
 2561 1584 1D42C6E5 		strb	r4, [r6, #541]
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2562              		.loc 1 817 0
 2563 1588 18E09DE5 		ldr	lr, [sp, #24]
 818:../uvc.c      **** 							 break;
 2564              		.loc 1 818 0
 2565 158c 0C70A0E1 		mov	r7, ip
 2566 1590 54FDFFEA 		b	.L114
 2567              	.LVL201:
 2568              	.L151:
 791:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2569              		.loc 1 791 0
 2570 1594 F4439FE5 		ldr	r4, .L206+36
 2571 1598 0010E0E3 		mvn	r1, #0
 2572 159c 1C0094E5 		ldr	r0, [r4, #28]
 2573 15a0 FEFFFFEB 		bl	_txe_mutex_get
 2574              	.LVL202:
 792:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2575              		.loc 1 792 0
 2576 15a4 14309DE5 		ldr	r3, [sp, #20]
 2577 15a8 00C0A0E3 		mov	ip, #0
 2578 15ac 801043E2 		sub	r1, r3, #128
 2579 15b0 FF7001E2 		and	r7, r1, #255
 2580              	.LVL203:
 2581 15b4 0920A0E1 		mov	r2, r9
 2582 15b8 0510A0E3 		mov	r1, #5
 2583 15bc 0A30A0E1 		mov	r3, sl
 2584 15c0 0400A0E1 		mov	r0, r4
 2585 15c4 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2586 15c8 FEFFFFEB 		bl	cmdSet
 2587              	.LVL204:
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2588              		.loc 1 794 0
 2589 15cc 14009DE5 		ldr	r0, [sp, #20]
 2590 15d0 0510A0E3 		mov	r1, #5
 2591 15d4 767040E2 		sub	r7, r0, #118
 2592 15d8 FFC007E2 		and	ip, r7, #255
 2593 15dc DC20A0E3 		mov	r2, #220
 2594 15e0 0170A0E3 		mov	r7, #1
 2595 15e4 0A30A0E1 		mov	r3, sl
 2596 15e8 0400A0E1 		mov	r0, r4
 2597 15ec 00C08DE5 		str	ip, [sp, #0]
 2598 15f0 04708DE5 		str	r7, [sp, #4]
 2599 15f4 FEFFFFEB 		bl	cmdSet
 2600              	.LVL205:
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2601              		.loc 1 796 0
 2602 15f8 14209DE5 		ldr	r2, [sp, #20]
 2603 15fc 0510A0E3 		mov	r1, #5
 2604 1600 7E3082E2 		add	r3, r2, #126
 2605 1604 FFC003E2 		and	ip, r3, #255
 2606 1608 DE20A0E3 		mov	r2, #222
 2607 160c 0A30A0E1 		mov	r3, sl
 2608 1610 0400A0E1 		mov	r0, r4
 2609 1614 00C08DE5 		str	ip, [sp, #0]
 2610 1618 02C0A0E3 		mov	ip, #2
 2611 161c 04C08DE5 		str	ip, [sp, #4]
 2612 1620 FEFFFFEB 		bl	cmdSet
 2613              	.LVL206:
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2614              		.loc 1 798 0
 2615 1624 14109DE5 		ldr	r1, [sp, #20]
 2616 1628 03E0A0E3 		mov	lr, #3
 2617 162c 720081E2 		add	r0, r1, #114
 2618 1630 FFC000E2 		and	ip, r0, #255
 2619 1634 0510A0E3 		mov	r1, #5
 2620 1638 E020A0E3 		mov	r2, #224
 2621 163c 0A30A0E1 		mov	r3, sl
 2622 1640 0400A0E1 		mov	r0, r4
 2623 1644 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2624 1648 FEFFFFEB 		bl	cmdSet
 2625              	.LVL207:
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2626              		.loc 1 800 0
 2627 164c 14209DE5 		ldr	r2, [sp, #20]
 2628 1650 0510A0E3 		mov	r1, #5
 2629 1654 6F3042E2 		sub	r3, r2, #111
 2630 1658 FFC003E2 		and	ip, r3, #255
 2631 165c DD20A0E3 		mov	r2, #221
 2632 1660 0A30A0E1 		mov	r3, sl
 2633 1664 0400A0E1 		mov	r0, r4
 2634 1668 00C08DE5 		str	ip, [sp, #0]
 2635 166c 04C0A0E3 		mov	ip, #4
 2636 1670 04C08DE5 		str	ip, [sp, #4]
 2637 1674 FEFFFFEB 		bl	cmdSet
 2638              	.LVL208:
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2639              		.loc 1 802 0
 2640 1678 F8129FE5 		ldr	r1, .L206+12
 2641 167c 05E0A0E3 		mov	lr, #5
 2642 1680 5800D1E5 		ldrb	r0, [r1, #88]	@ zero_extendqisi2
 2643 1684 0A30A0E1 		mov	r3, sl
 2644 1688 7F2080E2 		add	r2, r0, #127
 2645 168c FFC002E2 		and	ip, r2, #255
 2646 1690 0E10A0E1 		mov	r1, lr
 2647 1694 0B20A0E1 		mov	r2, fp
 2648 1698 0400A0E1 		mov	r0, r4
 2649 169c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2650 16a0 FEFFFFEB 		bl	cmdSet
 803:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2651              		.loc 1 803 0
 2652 16a4 1C0094E5 		ldr	r0, [r4, #28]
 2653 16a8 FEFFFFEB 		bl	_txe_mutex_put
 805:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2654              		.loc 1 805 0
 2655 16ac C4429FE5 		ldr	r4, .L206+12
 807:../uvc.c      **** 							 break;
 2656              		.loc 1 807 0
 2657 16b0 FFC0A0E3 		mov	ip, #255
 805:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2658              		.loc 1 805 0
 2659 16b4 5830D4E5 		ldrb	r3, [r4, #88]	@ zero_extendqisi2
 806:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2660              		.loc 1 806 0
 2661 16b8 0872C6E5 		strb	r7, [r6, #520]
 805:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2662              		.loc 1 805 0
 2663 16bc 801043E2 		sub	r1, r3, #128
 2664 16c0 0512C6E5 		strb	r1, [r6, #517]
 806:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2665              		.loc 1 806 0
 2666 16c4 14409DE5 		ldr	r4, [sp, #20]
 2667 16c8 18E09DE5 		ldr	lr, [sp, #24]
 807:../uvc.c      **** 							 break;
 2668              		.loc 1 807 0
 2669 16cc 0C70A0E1 		mov	r7, ip
 2670 16d0 04FDFFEA 		b	.L114
 2671              	.LVL209:
 2672              	.L150:
 843:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2673              		.loc 1 843 0
 2674 16d4 B4429FE5 		ldr	r4, .L206+36
 837:../uvc.c      **** 							 Data0 = Data0 - 1;
 2675              		.loc 1 837 0
 2676 16d8 013043E2 		sub	r3, r3, #1
 2677 16dc FF7003E2 		and	r7, r3, #255
 2678              	.LVL210:
 841:../uvc.c      **** 								 Data0 = 1;
 2679              		.loc 1 841 0
 2680 16e0 020057E3 		cmp	r7, #2
 843:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2681              		.loc 1 843 0
 2682 16e4 0010E0E3 		mvn	r1, #0
 2683 16e8 1C0094E5 		ldr	r0, [r4, #28]
 841:../uvc.c      **** 								 Data0 = 1;
 2684              		.loc 1 841 0
 2685 16ec 0170A083 		movhi	r7, #1
 2686              	.LVL211:
 843:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2687              		.loc 1 843 0
 2688 16f0 FEFFFFEB 		bl	_txe_mutex_get
 2689              	.LVL212:
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2690              		.loc 1 844 0
 2691 16f4 00C0A0E3 		mov	ip, #0
 2692 16f8 0410A0E3 		mov	r1, #4
 2693 16fc 0920A0E1 		mov	r2, r9
 2694 1700 0A30A0E1 		mov	r3, sl
 2695 1704 0400A0E1 		mov	r0, r4
 2696 1708 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2697 170c FEFFFFEB 		bl	cmdSet
 845:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2698              		.loc 1 845 0
 2699 1710 1C0094E5 		ldr	r0, [r4, #28]
 2700 1714 FEFFFFEB 		bl	_txe_mutex_put
 849:../uvc.c      **** 							 break;
 2701              		.loc 1 849 0
 2702 1718 FFC0A0E3 		mov	ip, #255
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2703              		.loc 1 848 0
 2704 171c 0110A0E3 		mov	r1, #1
 847:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2705              		.loc 1 847 0
 2706 1720 ED71C6E5 		strb	r7, [r6, #493]
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2707              		.loc 1 848 0
 2708 1724 F011C6E5 		strb	r1, [r6, #496]
 2709 1728 14409DE5 		ldr	r4, [sp, #20]
 2710 172c 18E09DE5 		ldr	lr, [sp, #24]
 849:../uvc.c      **** 							 break;
 2711              		.loc 1 849 0
 2712 1730 0C70A0E1 		mov	r7, ip
 2713 1734 EBFCFFEA 		b	.L114
 2714              	.LVL213:
 2715              	.L149:
 767:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2716              		.loc 1 767 0
 2717 1738 50729FE5 		ldr	r7, .L206+36
 2718              	.LVL214:
 2719 173c 0010E0E3 		mvn	r1, #0
 2720 1740 1C0097E5 		ldr	r0, [r7, #28]
 2721 1744 FEFFFFEB 		bl	_txe_mutex_get
 2722              	.LVL215:
 769:../uvc.c      **** 							  if(Data0&0x80){
 2723              		.loc 1 769 0
 2724 1748 14009DE5 		ldr	r0, [sp, #20]
 770:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2725              		.loc 1 770 0
 2726 174c A6C1D6E5 		ldrb	ip, [r6, #422]	@ zero_extendqisi2
 769:../uvc.c      **** 							  if(Data0&0x80){
 2727              		.loc 1 769 0
 2728 1750 800010E3 		tst	r0, #128
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2729              		.loc 1 772 0
 2730 1754 2023A001 		moveq	r2, r0, lsr #6
 770:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2731              		.loc 1 770 0
 2732 1758 802CA011 		movne	r2, r0, asl #25
 2733 175c 03C0CC13 		bicne	ip, ip, #3
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2734              		.loc 1 772 0
 2735 1760 03C0CC03 		biceq	ip, ip, #3
 776:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2736              		.loc 1 776 0
 2737 1764 24029FE5 		ldr	r0, .L206+36
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2738              		.loc 1 772 0
 2739 1768 02208203 		orreq	r2, r2, #2
 770:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2740              		.loc 1 770 0
 2741 176c A2CF8C11 		orrne	ip, ip, r2, lsr #31
 2742              	.LVL216:
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2743              		.loc 1 772 0
 2744 1770 0CC08201 		orreq	ip, r2, ip
 2745              	.LVL217:
 774:../uvc.c      **** 							 Data1 |= ~0x03;
 2746              		.loc 1 774 0
 2747 1774 0C4FE0E1 		mvn	r4, ip, asl #30
 2748 1778 243FE0E1 		mvn	r3, r4, lsr #30
 2749              	.LVL218:
 775:../uvc.c      **** 							 Data1 &= 0xC7;
 2750              		.loc 1 775 0
 2751 177c C71003E2 		and	r1, r3, #199
 2752 1780 1C108DE5 		str	r1, [sp, #28]
 2753              	.LVL219:
 776:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2754              		.loc 1 776 0
 2755 1784 1C809DE5 		ldr	r8, [sp, #28]
 2756 1788 00C0A0E3 		mov	ip, #0
 2757 178c 0110A0E3 		mov	r1, #1
 2758 1790 0B20A0E1 		mov	r2, fp
 2759 1794 0A30A0E1 		mov	r3, sl
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2760              		.loc 1 780 0
 2761 1798 0140A0E1 		mov	r4, r1
 776:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2762              		.loc 1 776 0
 2763 179c 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2764 17a0 FEFFFFEB 		bl	cmdSet
 2765              	.LVL220:
 779:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2766              		.loc 1 779 0
 2767 17a4 14209DE5 		ldr	r2, [sp, #20]
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2768              		.loc 1 780 0
 2769 17a8 0410A0E1 		mov	r1, r4
 779:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2770              		.loc 1 779 0
 2771 17ac 0281A0E1 		mov	r8, r2, asl #2
 2772 17b0 FF8008E2 		and	r8, r8, #255
 2773              	.LVL221:
 780:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2774              		.loc 1 780 0
 2775 17b4 0920A0E1 		mov	r2, r9
 2776 17b8 0A30A0E1 		mov	r3, sl
 2777 17bc CC019FE5 		ldr	r0, .L206+36
 2778 17c0 04408DE5 		str	r4, [sp, #4]
 2779 17c4 00808DE5 		str	r8, [sp, #0]
 2780 17c8 FEFFFFEB 		bl	cmdSet
 781:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2781              		.loc 1 781 0
 2782 17cc 1C0097E5 		ldr	r0, [r7, #28]
 2783 17d0 FEFFFFEB 		bl	_txe_mutex_put
 784:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2784              		.loc 1 784 0
 2785 17d4 1C009DE5 		ldr	r0, [sp, #28]
 787:../uvc.c      **** 							 break;
 2786              		.loc 1 787 0
 2787 17d8 FFC0A0E3 		mov	ip, #255
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2788              		.loc 1 785 0
 2789 17dc A841C6E5 		strb	r4, [r6, #424]
 783:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2790              		.loc 1 783 0
 2791 17e0 A581C6E5 		strb	r8, [r6, #421]
 784:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2792              		.loc 1 784 0
 2793 17e4 A601C6E5 		strb	r0, [r6, #422]
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2794              		.loc 1 785 0
 2795 17e8 14409DE5 		ldr	r4, [sp, #20]
 2796 17ec 18E09DE5 		ldr	lr, [sp, #24]
 787:../uvc.c      **** 							 break;
 2797              		.loc 1 787 0
 2798 17f0 0C70A0E1 		mov	r7, ip
 2799 17f4 BBFCFFEA 		b	.L114
 2800              	.LVL222:
 2801              	.L148:
 868:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2802              		.loc 1 868 0
 2803 17f8 90719FE5 		ldr	r7, .L206+36
 2804              	.LVL223:
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2805              		.loc 1 851 0
 2806 17fc 68019FE5 		ldr	r0, .L206
 852:../uvc.c      **** 							 if(Data0 == 3)
 2807              		.loc 1 852 0
 2808 1800 030053E3 		cmp	r3, #3
 853:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2809              		.loc 1 853 0
 2810 1804 0120A003 		moveq	r2, #1
 2811              	.LVL224:
 855:../uvc.c      **** 								 WDRflag = CyFalse;
 2812              		.loc 1 855 0
 2813 1808 0020A013 		movne	r2, #0
 856:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2814              		.loc 1 856 0
 2815 180c 01C0A0E3 		mov	ip, #1
 2816 1810 90C1C6E5 		strb	ip, [r6, #400]
 2817              	.LVL225:
 855:../uvc.c      **** 								 WDRflag = CyFalse;
 2818              		.loc 1 855 0
 2819 1814 102680E5 		str	r2, [r0, #1552]
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2820              		.loc 1 851 0
 2821 1818 8D31C6E5 		strb	r3, [r6, #397]
 868:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2822              		.loc 1 868 0
 2823 181c 0010E0E3 		mvn	r1, #0
 2824 1820 1C0097E5 		ldr	r0, [r7, #28]
 2825 1824 FEFFFFEB 		bl	_txe_mutex_get
 869:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2826              		.loc 1 869 0
 2827 1828 14E09DE5 		ldr	lr, [sp, #20]
 2828 182c 0040A0E3 		mov	r4, #0
 2829 1830 0410A0E1 		mov	r1, r4
 2830 1834 0920A0E1 		mov	r2, r9
 2831 1838 0A30A0E1 		mov	r3, sl
 2832 183c 0700A0E1 		mov	r0, r7
 2833 1840 00E08DE5 		str	lr, [sp, #0]
 2834 1844 04408DE5 		str	r4, [sp, #4]
 2835 1848 FEFFFFEB 		bl	cmdSet
 870:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2836              		.loc 1 870 0
 2837 184c 1C0097E5 		ldr	r0, [r7, #28]
 2838 1850 FEFFFFEB 		bl	_txe_mutex_put
 871:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2839              		.loc 1 871 0
 2840 1854 1C219FE5 		ldr	r2, .L206+12
 2841 1858 103696E5 		ldr	r3, [r6, #1552]
 2842 185c 5AC0D2E5 		ldrb	ip, [r2, #90]	@ zero_extendqisi2
 2843 1860 5BE0D2E5 		ldrb	lr, [r2, #91]	@ zero_extendqisi2
 2844 1864 14409DE5 		ldr	r4, [sp, #20]
 2845 1868 0400A0E3 		mov	r0, #4
 2846 186c 2C119FE5 		ldr	r1, .L206+52
 2847 1870 B0FEFFEA 		b	.L199
 2848              	.LVL226:
 2849              	.L147:
 877:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2850              		.loc 1 877 0
 2851 1874 14719FE5 		ldr	r7, .L206+36
 2852              	.LVL227:
 2853 1878 0010E0E3 		mvn	r1, #0
 2854 187c 1C0097E5 		ldr	r0, [r7, #28]
 2855 1880 FEFFFFEB 		bl	_txe_mutex_get
 2856              	.LVL228:
 878:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2857              		.loc 1 878 0
 2858 1884 14C09DE5 		ldr	ip, [sp, #20]
 2859 1888 0410A0E1 		mov	r1, r4
 2860 188c 0920A0E1 		mov	r2, r9
 2861 1890 0A30A0E1 		mov	r3, sl
 2862 1894 0700A0E1 		mov	r0, r7
 2863 1898 00C08DE5 		str	ip, [sp, #0]
 2864 189c 00C0A0E3 		mov	ip, #0
 2865 18a0 04C08DE5 		str	ip, [sp, #4]
 2866 18a4 FEFFFFEB 		bl	cmdSet
 879:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2867              		.loc 1 879 0
 2868 18a8 1C0097E5 		ldr	r0, [r7, #28]
 2869 18ac FEFFFFEB 		bl	_txe_mutex_put
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2870              		.loc 1 881 0
 2871 18b0 14209DE5 		ldr	r2, [sp, #20]
 2872 18b4 847084E0 		add	r7, r4, r4, asl #1
 2873 18b8 876186E0 		add	r6, r6, r7, asl #3
 883:../uvc.c      **** 							 break;
 2874              		.loc 1 883 0
 2875 18bc FFC0A0E3 		mov	ip, #255
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2876              		.loc 1 882 0
 2877 18c0 0130A0E3 		mov	r3, #1
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2878              		.loc 1 881 0
 2879 18c4 8D21C6E5 		strb	r2, [r6, #397]
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2880              		.loc 1 882 0
 2881 18c8 9031C6E5 		strb	r3, [r6, #400]
 2882 18cc 0240A0E1 		mov	r4, r2
 2883 18d0 18E09DE5 		ldr	lr, [sp, #24]
 883:../uvc.c      **** 							 break;
 2884              		.loc 1 883 0
 2885 18d4 0C70A0E1 		mov	r7, ip
 2886 18d8 82FCFFEA 		b	.L114
 2887              	.LVL229:
 2888              	.L146:
 886:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2889              		.loc 1 886 0
 2890 18dc 0400A0E3 		mov	r0, #4
 2891              	.LVL230:
 2892 18e0 BC109FE5 		ldr	r1, .L206+56
 2893 18e4 FEFFFFEB 		bl	CyU3PDebugPrint
 2894              	.LVL231:
 2895 18e8 FFC0A0E3 		mov	ip, #255
 2896 18ec 0C70A0E1 		mov	r7, ip
 2897              	.LVL232:
 2898 18f0 0CE0A0E1 		mov	lr, ip
 2899 18f4 0C40A0E1 		mov	r4, ip
 2900 18f8 7AFCFFEA 		b	.L114
 2901              	.LVL233:
 2902              	.L166:
 629:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2903              		.loc 1 629 0
 2904 18fc B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2905              	.LVL234:
 628:../uvc.c      **** 								 Data1 = Data0 - 1;
 2906              		.loc 1 628 0
 2907 1900 017040E2 		sub	r7, r0, #1
 2908              	.LVL235:
 629:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2909              		.loc 1 629 0
 2910 1904 040052E3 		cmp	r2, #4
 2911 1908 01005213 		cmpne	r2, #1
 628:../uvc.c      **** 								 Data1 = Data0 - 1;
 2912              		.loc 1 628 0
 2913 190c FF1007E2 		and	r1, r7, #255
 2914              	.LVL236:
 629:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2915              		.loc 1 629 0
 2916 1910 0300000A 		beq	.L169
 630:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2917              		.loc 1 630 0
 2918 1914 080052E3 		cmp	r2, #8
 631:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2919              		.loc 1 631 0
 2920 1918 0120A003 		moveq	r2, #1
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2921              		.loc 1 633 0
 2922 191c 0420A013 		movne	r2, #4
 2923 1920 B524C3E5 		strb	r2, [r3, #1205]
 2924              	.L169:
 636:../uvc.c      **** 								 if(Data1 < 8){
 2925              		.loc 1 636 0
 2926 1924 070051E3 		cmp	r1, #7
 637:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2927              		.loc 1 637 0
 2928 1928 78309F95 		ldrls	r3, .L206+60
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2929              		.loc 1 640 0
 2930 192c 0130A083 		movhi	r3, #1
 638:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2931              		.loc 1 638 0
 2932 1930 81008390 		addls	r0, r3, r1, asl #1
 637:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2933              		.loc 1 637 0
 2934 1934 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 638:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2935              		.loc 1 638 0
 2936 1938 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2937              		.loc 1 640 0
 2938 193c E534C685 		strhib	r3, [r6, #1253]
 641:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2939              		.loc 1 641 0
 2940 1940 0030A083 		movhi	r3, #0
 637:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2941              		.loc 1 637 0
 2942 1944 E524C695 		strlsb	r2, [r6, #1253]
 641:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2943              		.loc 1 641 0
 2944 1948 E634C6E5 		strb	r3, [r6, #1254]
 2945 194c BAFEFFEA 		b	.L167
 2946              	.LVL237:
 2947              	.L196:
 2948 1950 20009FE5 		ldr	r0, .L206+12
 2949 1954 89FDFFEA 		b	.L125
 2950              	.LVL238:
 2951              	.L185:
 388:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2952              		.loc 1 388 0
 2953 1958 0030A0E3 		mov	r3, #0
 2954 195c 2DFEFFEA 		b	.L189
 2955              	.LVL239:
 2956              	.L184:
 2957 1960 10009FE5 		ldr	r0, .L206+12
 2958 1964 0030A0E3 		mov	r3, #0
 2959 1968 7DFDFFEA 		b	.L188
 2960              	.L207:
 2961              		.align	2
 2962              	.L206:
 2963 196c 00000000 		.word	.LANCHOR1
 2964 1970 00000000 		.word	bRequest
 2965 1974 3C030000 		.word	.LC21
 2966 1978 00000000 		.word	.LANCHOR0
 2967 197c 58000000 		.word	.LANCHOR0+88
 2968 1980 01000100 		.word	65537
 2969 1984 FF00FF00 		.word	16711935
 2970 1988 48020000 		.word	.LC15
 2971 198c 84020000 		.word	.LC16
 2972 1990 00000000 		.word	cmdQu
 2973 1994 4C000000 		.word	.LANCHOR0+76
 2974 1998 D8020000 		.word	.LC18
 2975 199c AC020000 		.word	.LC17
 2976 19a0 F4020000 		.word	.LC19
 2977 19a4 0C030000 		.word	.LC20
 2978 19a8 00000000 		.word	.LANCHOR2
 2979              		.cfi_endproc
 2980              	.LFE2:
 2982              		.align	2
 2983              		.global	CTControlHandle
 2985              	CTControlHandle:
 2986              	.LFB3:
 902:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 2987              		.loc 1 902 0
 2988              		.cfi_startproc
 2989              		@ args = 0, pretend = 0, frame = 64
 2990              		@ frame_needed = 0, uses_anonymous_args = 0
 2991              	.LVL240:
 2992 19ac F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2993              	.LCFI15:
 2994              		.cfi_def_cfa_offset 36
 921:../uvc.c      ****     reqData = bRequest;
 2995              		.loc 1 921 0
 2996 19b0 60A99FE5 		ldr	sl, .L293
 2997              		.cfi_offset 14, -4
 2998              		.cfi_offset 11, -8
 2999              		.cfi_offset 10, -12
 3000              		.cfi_offset 9, -16
 3001              		.cfi_offset 8, -20
 3002              		.cfi_offset 7, -24
 3003              		.cfi_offset 6, -28
 3004              		.cfi_offset 5, -32
 3005              		.cfi_offset 4, -36
 913:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3006              		.loc 1 913 0
 3007 19b4 60899FE5 		ldr	r8, .L293+4
 921:../uvc.c      ****     reqData = bRequest;
 3008              		.loc 1 921 0
 3009 19b8 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 913:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3010              		.loc 1 913 0
 3011 19bc 8090A0E1 		mov	r9, r0, asl #1
 3012 19c0 002089E0 		add	r2, r9, r0
 3013 19c4 822188E0 		add	r2, r8, r2, asl #3
 923:../uvc.c      ****     switch (bRequest)
 3014              		.loc 1 923 0
 3015 19c8 830055E3 		cmp	r5, #131
 902:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3016              		.loc 1 902 0
 3017 19cc 5CD04DE2 		sub	sp, sp, #92
 3018              	.LCFI16:
 3019              		.cfi_def_cfa_offset 128
 902:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3020              		.loc 1 902 0
 3021 19d0 0060A0E1 		mov	r6, r0
 913:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3022              		.loc 1 913 0
 3023 19d4 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3024              	.LVL241:
 914:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3025              		.loc 1 914 0
 3026 19d8 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3027              	.LVL242:
 916:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3028              		.loc 1 916 0
 3029 19dc 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3030              	.LVL243:
 923:../uvc.c      ****     switch (bRequest)
 3031              		.loc 1 923 0
 3032 19e0 7600000A 		beq	.L213
 3033 19e4 2100009A 		bls	.L288
 3034 19e8 850055E3 		cmp	r5, #133
 3035 19ec 5900000A 		beq	.L215
 3036 19f0 4E00003A 		bcc	.L214
 3037 19f4 860055E3 		cmp	r5, #134
 3038 19f8 8000000A 		beq	.L216
 3039 19fc 870055E3 		cmp	r5, #135
 3040 1a00 7600000A 		beq	.L289
 3041              	.L209:
1130:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3042              		.loc 1 1130 0
 3043 1a04 0000A0E3 		mov	r0, #0
 3044              	.LVL244:
 3045 1a08 0110A0E3 		mov	r1, #1
 3046 1a0c 0020A0E1 		mov	r2, r0
 3047 1a10 FEFFFFEB 		bl	CyU3PUsbStall
 3048              	.LVL245:
 3049 1a14 04499FE5 		ldr	r4, .L293+8
1131:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3050              		.loc 1 1131 0
 3051 1a18 0620A0E1 		mov	r2, r6
 3052 1a1c 0400A0E3 		mov	r0, #4
 3053 1a20 FC189FE5 		ldr	r1, .L293+12
 3054 1a24 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3055 1a28 FEFFFFEB 		bl	CyU3PDebugPrint
1132:../uvc.c      **** 			  break;
 3056              		.loc 1 1132 0
 3057 1a2c FFC0A0E3 		mov	ip, #255
 3058 1a30 0C60A0E1 		mov	r6, ip
 3059 1a34 0C80A0E1 		mov	r8, ip
 3060              	.LVL246:
 3061              	.L219:
1136:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3062              		.loc 1 1136 0
 3063 1a38 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3064 1a3c 08C08DE5 		str	ip, [sp, #8]
 3065 1a40 E0189FE5 		ldr	r1, .L293+16
 3066 1a44 FFC0A0E3 		mov	ip, #255
 3067 1a48 0520A0E1 		mov	r2, r5
 3068 1a4c 0830A0E1 		mov	r3, r8
 3069 1a50 0400A0E3 		mov	r0, #4
 3070 1a54 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3071 1a58 0CC08DE5 		str	ip, [sp, #12]
 3072 1a5c 10E08DE5 		str	lr, [sp, #16]
 3073 1a60 14708DE5 		str	r7, [sp, #20]
 3074 1a64 FEFFFFEB 		bl	CyU3PDebugPrint
1137:../uvc.c      **** }
 3075              		.loc 1 1137 0
 3076 1a68 5CD08DE2 		add	sp, sp, #92
 3077 1a6c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3078              	.LVL247:
 3079              	.L288:
 923:../uvc.c      ****     switch (bRequest)
 3080              		.loc 1 923 0
 3081 1a70 810055E3 		cmp	r5, #129
 3082 1a74 4200000A 		beq	.L211
 3083 1a78 1100009A 		bls	.L290
 952:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3084              		.loc 1 952 0
 3085 1a7c 9C489FE5 		ldr	r4, .L293+8
 3086 1a80 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 953:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3087              		.loc 1 953 0
 3088 1a84 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 954:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3089              		.loc 1 954 0
 3090 1a88 0A0050E3 		cmp	r0, #10
 952:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3091              		.loc 1 952 0
 3092 1a8c 5810C4E5 		strb	r1, [r4, #88]
 953:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3093              		.loc 1 953 0
 3094 1a90 5960C4E5 		strb	r6, [r4, #89]
 954:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3095              		.loc 1 954 0
 3096 1a94 2C00000A 		beq	.L287
 3097              	.LVL248:
 3098              	.L226:
 988:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3099              		.loc 1 988 0
 3100 1a98 00E0A0E3 		mov	lr, #0
 3101 1a9c 5AE0C4E5 		strb	lr, [r4, #90]
 3102              	.L227:
 989:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3103              		.loc 1 989 0
 3104 1aa0 0030A0E3 		mov	r3, #0
 990:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3105              		.loc 1 990 0
 3106 1aa4 0700A0E1 		mov	r0, r7
 3107              	.LVL249:
 3108 1aa8 7C189FE5 		ldr	r1, .L293+20
 992:../uvc.c      **** 			  break;
 3109              		.loc 1 992 0
 3110 1aac FF60A0E3 		mov	r6, #255
 989:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3111              		.loc 1 989 0
 3112 1ab0 5B30C4E5 		strb	r3, [r4, #91]
 992:../uvc.c      **** 			  break;
 3113              		.loc 1 992 0
 3114 1ab4 0680A0E1 		mov	r8, r6
 990:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3115              		.loc 1 990 0
 3116 1ab8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3117              	.LVL250:
 3118 1abc 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 992:../uvc.c      **** 			  break;
 3119              		.loc 1 992 0
 3120 1ac0 DCFFFFEA 		b	.L219
 3121              	.LVL251:
 3122              	.L290:
 923:../uvc.c      ****     switch (bRequest)
 3123              		.loc 1 923 0
 3124 1ac4 010055E3 		cmp	r5, #1
 3125 1ac8 CDFFFF1A 		bne	.L209
 994:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3126              		.loc 1 994 0
 3127 1acc 4C489FE5 		ldr	r4, .L293+8
 3128 1ad0 56208DE2 		add	r2, sp, #86
 3129 1ad4 2000A0E3 		mov	r0, #32
 3130              	.LVL252:
 3131 1ad8 581084E2 		add	r1, r4, #88
 3132 1adc 2C308DE5 		str	r3, [sp, #44]
 3133 1ae0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3134              	.LVL253:
 996:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3135              		.loc 1 996 0
 3136 1ae4 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 997:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3137              		.loc 1 997 0
 3138 1ae8 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
1000:../uvc.c      **** 			  switch(CtrlID)
 3139              		.loc 1 1000 0
 3140 1aec 012046E2 		sub	r2, r6, #1
 996:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3141              		.loc 1 996 0
 3142 1af0 30008DE5 		str	r0, [sp, #48]
 3143              	.LVL254:
 997:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3144              		.loc 1 997 0
 3145 1af4 34C08DE5 		str	ip, [sp, #52]
 3146              	.LVL255:
1000:../uvc.c      **** 			  switch(CtrlID)
 3147              		.loc 1 1000 0
 3148 1af8 2C309DE5 		ldr	r3, [sp, #44]
 3149 1afc 090052E3 		cmp	r2, #9
 3150 1b00 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3151 1b04 550100EA 		b	.L228
 3152              	.L233:
 3153 1b08 1C200000 		.word	.L229
 3154 1b0c 60200000 		.word	.L228
 3155 1b10 2C1D0000 		.word	.L230
 3156 1b14 60200000 		.word	.L228
 3157 1b18 60200000 		.word	.L228
 3158 1b1c 60200000 		.word	.L228
 3159 1b20 A81C0000 		.word	.L231
 3160 1b24 60200000 		.word	.L228
 3161 1b28 60200000 		.word	.L228
 3162 1b2c 2C1C0000 		.word	.L232
 3163              	.LVL256:
 3164              	.L214:
 970:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3165              		.loc 1 970 0
 3166 1b30 E8479FE5 		ldr	r4, .L293+8
 3167 1b34 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 971:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3168              		.loc 1 971 0
 3169 1b38 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 972:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3170              		.loc 1 972 0
 3171 1b3c 0A0050E3 		cmp	r0, #10
 970:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3172              		.loc 1 970 0
 3173 1b40 5880C4E5 		strb	r8, [r4, #88]
 971:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3174              		.loc 1 971 0
 3175 1b44 5920C4E5 		strb	r2, [r4, #89]
 972:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3176              		.loc 1 972 0
 3177 1b48 D2FFFF1A 		bne	.L226
 3178              	.LVL257:
 3179              	.L287:
 987:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3180              		.loc 1 987 0 discriminator 1
 3181 1b4c 0110A0E3 		mov	r1, #1
 3182 1b50 5A10C4E5 		strb	r1, [r4, #90]
 3183 1b54 D1FFFFEA 		b	.L227
 3184              	.LVL258:
 3185              	.L215:
 927:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3186              		.loc 1 927 0
 3187 1b58 C0479FE5 		ldr	r4, .L293+8
 928:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3188              		.loc 1 928 0
 3189 1b5c 0030A0E3 		mov	r3, #0
 3190              	.LVL259:
 929:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3191              		.loc 1 929 0
 3192 1b60 0200A0E3 		mov	r0, #2
 3193              	.LVL260:
 3194 1b64 581084E2 		add	r1, r4, #88
 931:../uvc.c      **** 			  break;
 3195              		.loc 1 931 0
 3196 1b68 FF60A0E3 		mov	r6, #255
 927:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3197              		.loc 1 927 0
 3198 1b6c 5870C4E5 		strb	r7, [r4, #88]
 928:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3199              		.loc 1 928 0
 3200 1b70 5930C4E5 		strb	r3, [r4, #89]
 931:../uvc.c      **** 			  break;
 3201              		.loc 1 931 0
 3202 1b74 0680A0E1 		mov	r8, r6
 929:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3203              		.loc 1 929 0
 3204 1b78 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3205              	.LVL261:
 3206 1b7c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 931:../uvc.c      **** 			  break;
 3207              		.loc 1 931 0
 3208 1b80 ACFFFFEA 		b	.L219
 3209              	.LVL262:
 3210              	.L211:
 937:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3211              		.loc 1 937 0
 3212 1b84 94479FE5 		ldr	r4, .L293+8
 3213 1b88 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 938:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3214              		.loc 1 938 0
 3215 1b8c 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 939:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3216              		.loc 1 939 0
 3217 1b90 0080A0E3 		mov	r8, #0
 945:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3218              		.loc 1 945 0
 3219 1b94 0700A0E1 		mov	r0, r7
 3220              	.LVL263:
 3221 1b98 581084E2 		add	r1, r4, #88
 950:../uvc.c      **** 			  break;
 3222              		.loc 1 950 0
 3223 1b9c FF60A0E3 		mov	r6, #255
 938:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3224              		.loc 1 938 0
 3225 1ba0 59C0C4E5 		strb	ip, [r4, #89]
 939:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3226              		.loc 1 939 0
 3227 1ba4 5A80C4E5 		strb	r8, [r4, #90]
 940:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3228              		.loc 1 940 0
 3229 1ba8 5B80C4E5 		strb	r8, [r4, #91]
 3230              	.LVL264:
 937:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3231              		.loc 1 937 0
 3232 1bac 58A0C4E5 		strb	sl, [r4, #88]
 950:../uvc.c      **** 			  break;
 3233              		.loc 1 950 0
 3234 1bb0 0680A0E1 		mov	r8, r6
 945:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3235              		.loc 1 945 0
 3236 1bb4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3237              	.LVL265:
 3238 1bb8 0AC0A0E1 		mov	ip, sl
 950:../uvc.c      **** 			  break;
 3239              		.loc 1 950 0
 3240 1bbc 9DFFFFEA 		b	.L219
 3241              	.LVL266:
 3242              	.L213:
 961:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3243              		.loc 1 961 0
 3244 1bc0 58479FE5 		ldr	r4, .L293+8
 3245 1bc4 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3246              	.LVL267:
 962:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3247              		.loc 1 962 0
 3248 1bc8 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 963:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3249              		.loc 1 963 0
 3250 1bcc 0A0050E3 		cmp	r0, #10
 961:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3251              		.loc 1 961 0
 3252 1bd0 5830C4E5 		strb	r3, [r4, #88]
 962:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3253              		.loc 1 962 0
 3254 1bd4 59E0C4E5 		strb	lr, [r4, #89]
 963:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3255              		.loc 1 963 0
 3256 1bd8 AEFFFF1A 		bne	.L226
 3257 1bdc DAFFFFEA 		b	.L287
 3258              	.LVL268:
 3259              	.L289:
 985:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3260              		.loc 1 985 0
 3261 1be0 38479FE5 		ldr	r4, .L293+8
 3262 1be4 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 986:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3263              		.loc 1 986 0
 3264 1be8 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 987:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3265              		.loc 1 987 0
 3266 1bec 0A0050E3 		cmp	r0, #10
 985:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3267              		.loc 1 985 0
 3268 1bf0 5860C4E5 		strb	r6, [r4, #88]
 986:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3269              		.loc 1 986 0
 3270 1bf4 59C0C4E5 		strb	ip, [r4, #89]
 987:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3271              		.loc 1 987 0
 3272 1bf8 A6FFFF1A 		bne	.L226
 3273 1bfc D2FFFFEA 		b	.L287
 3274              	.L216:
 979:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3275              		.loc 1 979 0
 3276 1c00 18479FE5 		ldr	r4, .L293+8
 3277 1c04 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3278              	.LVL269:
 3279 1c08 0410A0E1 		mov	r1, r4
 3280 1c0c 5800E1E5 		strb	r0, [r1, #88]!
 983:../uvc.c      **** 			  break;
 3281              		.loc 1 983 0
 3282 1c10 FF60A0E3 		mov	r6, #255
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3283              		.loc 1 980 0
 3284 1c14 0100A0E3 		mov	r0, #1
 3285 1c18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3286              	.LVL270:
 983:../uvc.c      **** 			  break;
 3287              		.loc 1 983 0
 3288 1c1c 0680A0E1 		mov	r8, r6
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3289              		.loc 1 980 0
 3290 1c20 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 983:../uvc.c      **** 			  break;
 3291              		.loc 1 983 0
 3292 1c24 0170A0E3 		mov	r7, #1
 3293 1c28 82FFFFEA 		b	.L219
 3294              	.LVL271:
 3295              	.L232:
1109:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3296              		.loc 1 1109 0
 3297 1c2c FC669FE5 		ldr	r6, .L293+24
 3298 1c30 0010E0E3 		mvn	r1, #0
 3299 1c34 1C0096E5 		ldr	r0, [r6, #28]
 3300 1c38 2C308DE5 		str	r3, [sp, #44]
 3301 1c3c FEFFFFEB 		bl	_txe_mutex_get
1110:../uvc.c      **** 					  if(getData == 1)
 3302              		.loc 1 1110 0
 3303 1c40 30E09DE5 		ldr	lr, [sp, #48]
 3304 1c44 2C309DE5 		ldr	r3, [sp, #44]
 3305 1c48 01005EE3 		cmp	lr, #1
 3306 1c4c A901000A 		beq	.L291
1112:../uvc.c      **** 					  else if(getData == 0xff)
 3307              		.loc 1 1112 0
 3308 1c50 FF005EE3 		cmp	lr, #255
 3309 1c54 9E01000A 		beq	.L292
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 3310              		.loc 1 1115 0
 3311 1c58 0080A0E3 		mov	r8, #0
 3312 1c5c 0600A0E1 		mov	r0, r6
 3313 1c60 2310A0E3 		mov	r1, #35
 3314 1c64 0B20A0E1 		mov	r2, fp
 3315 1c68 00808DE5 		str	r8, [sp, #0]
 3316 1c6c 04808DE5 		str	r8, [sp, #4]
 3317 1c70 FEFFFFEB 		bl	cmdSet
 3318              	.L285:
1118:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3319              		.loc 1 1118 0
 3320 1c74 1C0096E5 		ldr	r0, [r6, #28]
 3321 1c78 FEFFFFEB 		bl	_txe_mutex_put
1120:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3322              		.loc 1 1120 0
 3323 1c7c 30809DE5 		ldr	r8, [sp, #48]
 3324 1c80 34609DE5 		ldr	r6, [sp, #52]
 3325 1c84 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3326 1c88 0400A0E3 		mov	r0, #4
 3327 1c8c A0169FE5 		ldr	r1, .L293+28
 3328 1c90 0820A0E1 		mov	r2, r8
 3329 1c94 0630A0E1 		mov	r3, r6
 3330 1c98 00C08DE5 		str	ip, [sp, #0]
 3331 1c9c FEFFFFEB 		bl	CyU3PDebugPrint
1121:../uvc.c      **** 					  break;
 3332              		.loc 1 1121 0
 3333 1ca0 FFC0A0E3 		mov	ip, #255
 3334 1ca4 63FFFFEA 		b	.L219
 3335              	.LVL272:
 3336              	.L231:
1086:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3337              		.loc 1 1086 0
 3338 1ca8 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3339 1cac 010058E3 		cmp	r8, #1
 3340 1cb0 08005813 		cmpne	r8, #8
 3341 1cb4 0000A013 		movne	r0, #0
 3342 1cb8 0100A003 		moveq	r0, #1
 3343 1cbc 8001001A 		bne	.L282
 3344              	.LVL273:
1089:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3345              		.loc 1 1089 0
 3346 1cc0 68869FE5 		ldr	r8, .L293+24
 3347 1cc4 0010E0E3 		mvn	r1, #0
 3348 1cc8 1C0098E5 		ldr	r0, [r8, #28]
 3349 1ccc 2C308DE5 		str	r3, [sp, #44]
 3350 1cd0 FEFFFFEB 		bl	_txe_mutex_get
1090:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3351              		.loc 1 1090 0
 3352 1cd4 30A09DE5 		ldr	sl, [sp, #48]
 3353 1cd8 2210A0E3 		mov	r1, #34
 3354 1cdc 0B20A0E1 		mov	r2, fp
 3355 1ce0 2C309DE5 		ldr	r3, [sp, #44]
 3356 1ce4 00C0A0E3 		mov	ip, #0
 3357 1ce8 0800A0E1 		mov	r0, r8
 3358 1cec 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3359 1cf0 FEFFFFEB 		bl	cmdSet
1091:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3360              		.loc 1 1091 0
 3361 1cf4 1C0098E5 		ldr	r0, [r8, #28]
 3362 1cf8 FEFFFFEB 		bl	_txe_mutex_put
1094:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3363              		.loc 1 1094 0
 3364 1cfc 18069FE5 		ldr	r0, .L293+4
1095:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3365              		.loc 1 1095 0
 3366 1d00 34209DE5 		ldr	r2, [sp, #52]
1094:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3367              		.loc 1 1094 0
 3368 1d04 061089E0 		add	r1, r9, r6
 3369 1d08 813180E0 		add	r3, r0, r1, asl #3
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3370              		.loc 1 1096 0
 3371 1d0c 0160A0E3 		mov	r6, #1
1094:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3372              		.loc 1 1094 0
 3373 1d10 9DA4C3E5 		strb	sl, [r3, #1181]
1095:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3374              		.loc 1 1095 0
 3375 1d14 9E24C3E5 		strb	r2, [r3, #1182]
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3376              		.loc 1 1096 0
 3377 1d18 A064C3E5 		strb	r6, [r3, #1184]
 3378              	.LVL274:
 3379              	.L283:
1098:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3380              		.loc 1 1098 0
 3381 1d1c 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3382 1d20 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1103:../uvc.c      **** 					  break;
 3383              		.loc 1 1103 0
 3384 1d24 FFC0A0E3 		mov	ip, #255
 3385 1d28 42FFFFEA 		b	.L219
 3386              	.LVL275:
 3387              	.L230:
1052:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3388              		.loc 1 1052 0
 3389 1d2c B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3390 1d30 010050E3 		cmp	r0, #1
 3391 1d34 04005013 		cmpne	r0, #4
 3392 1d38 5C01001A 		bne	.L240
1051:../uvc.c      **** 					  value = (value << 8)|Data0;
 3393              		.loc 1 1051 0
 3394 1d3c 30109DE5 		ldr	r1, [sp, #48]
 3395 1d40 34E09DE5 		ldr	lr, [sp, #52]
 3396 1d44 0E2481E1 		orr	r2, r1, lr, asl #8
1053:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3397              		.loc 1 1053 0
 3398 1d48 F90052E3 		cmp	r2, #249
 3399 1d4c 5701008A 		bhi	.L240
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3400              		.loc 1 1058 0
 3401 1d50 C8A042E2 		sub	sl, r2, #200
 3402 1d54 0AC8A0E1 		mov	ip, sl, asl #16
 3403 1d58 3CC08DE5 		str	ip, [sp, #60]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3404              		.loc 1 1060 0
 3405 1d5c 27A062E2 		rsb	sl, r2, #39
 3406 1d60 38A08DE5 		str	sl, [sp, #56]
 3407 1d64 3CA09DE5 		ldr	sl, [sp, #60]
 3408 1d68 C81062E2 		rsb	r1, r2, #200
 3409 1d6c C80052E3 		cmp	r2, #200
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3410              		.loc 1 1058 0
 3411 1d70 640042E2 		sub	r0, r2, #100
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3412              		.loc 1 1060 0
 3413 1d74 0118A0E1 		mov	r1, r1, asl #16
 3414 1d78 64E062E2 		rsb	lr, r2, #100
 3415 1d7c 2A18A081 		movhi	r1, sl, lsr #16
 3416 1d80 2118A091 		movls	r1, r1, lsr #16
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3417              		.loc 1 1058 0
 3418 1d84 00C8A0E1 		mov	ip, r0, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3419              		.loc 1 1060 0
 3420 1d88 640052E3 		cmp	r2, #100
 3421 1d8c 0E08A0E1 		mov	r0, lr, asl #16
 3422 1d90 2C08A081 		movhi	r0, ip, lsr #16
 3423 1d94 38C09DE5 		ldr	ip, [sp, #56]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3424              		.loc 1 1058 0
 3425 1d98 14A042E2 		sub	sl, r2, #20
 3426 1d9c 38A08DE5 		str	sl, [sp, #56]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3427              		.loc 1 1060 0
 3428 1da0 2008A091 		movls	r0, r0, lsr #16
 3429 1da4 14A062E2 		rsb	sl, r2, #20
 3430 1da8 3CA08DE5 		str	sl, [sp, #60]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3431              		.loc 1 1058 0
 3432 1dac 27E042E2 		sub	lr, r2, #39
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3433              		.loc 1 1060 0
 3434 1db0 000051E1 		cmp	r1, r0
 3435 1db4 01A0A031 		movcc	sl, r1
 3436 1db8 00A0A021 		movcs	sl, r0
 3437 1dbc 0CC8A0E1 		mov	ip, ip, asl #16
 3438 1dc0 270052E3 		cmp	r2, #39
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3439              		.loc 1 1058 0
 3440 1dc4 0EE8A0E1 		mov	lr, lr, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3441              		.loc 1 1060 0
 3442 1dc8 2CE8A091 		movls	lr, ip, lsr #16
 3443 1dcc 64C59FE5 		ldr	ip, .L293+32
 3444 1dd0 20A08DE5 		str	sl, [sp, #32]
 3445 1dd4 01A06CE0 		rsb	sl, ip, r1
 3446 1dd8 2EE8A081 		movhi	lr, lr, lsr #16
 3447 1ddc 00C07AE2 		rsbs	ip, sl, #0
 3448 1de0 0AC0ACE0 		adc	ip, ip, sl
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3449              		.loc 1 1058 0
 3450 1de4 38A09DE5 		ldr	sl, [sp, #56]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3451              		.loc 1 1060 0
 3452 1de8 44C08DE5 		str	ip, [sp, #68]
 3453              	.LVL276:
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3454              		.loc 1 1058 0
 3455 1dec 0AC8A0E1 		mov	ip, sl, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3456              		.loc 1 1060 0
 3457 1df0 3CA09DE5 		ldr	sl, [sp, #60]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3458              		.loc 1 1058 0
 3459 1df4 4CC08DE5 		str	ip, [sp, #76]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3460              		.loc 1 1060 0
 3461 1df8 0AC8A0E1 		mov	ip, sl, asl #16
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3462              		.loc 1 1058 0
 3463 1dfc 0AA042E2 		sub	sl, r2, #10
 3464 1e00 48A08DE5 		str	sl, [sp, #72]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3465              		.loc 1 1060 0
 3466 1e04 20A09DE5 		ldr	sl, [sp, #32]
 3467 1e08 3CC08DE5 		str	ip, [sp, #60]
 3468 1e0c 0A005EE1 		cmp	lr, sl
 3469 1e10 0EA0A031 		movcc	sl, lr
 3470 1e14 0AC062E2 		rsb	ip, r2, #10
 3471 1e18 40C08DE5 		str	ip, [sp, #64]
 3472 1e1c 38A08DE5 		str	sl, [sp, #56]
 3473 1e20 3CC09DE5 		ldr	ip, [sp, #60]
 3474 1e24 4CA09DE5 		ldr	sl, [sp, #76]
 3475 1e28 140052E3 		cmp	r2, #20
 3476 1e2c 2CA8A091 		movls	sl, ip, lsr #16
 3477 1e30 2AA8A081 		movhi	sl, sl, lsr #16
 3478 1e34 44C09DE5 		ldr	ip, [sp, #68]
 3479 1e38 010050E1 		cmp	r0, r1
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3480              		.loc 1 1058 0
 3481 1e3c 48109DE5 		ldr	r1, [sp, #72]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3482              		.loc 1 1060 0
 3483 1e40 01C0A033 		movcc	ip, #1
 3484 1e44 3CA08DE5 		str	sl, [sp, #60]
 3485 1e48 24C08DE5 		str	ip, [sp, #36]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3486              		.loc 1 1058 0
 3487 1e4c 01A8A0E1 		mov	sl, r1, asl #16
 3488 1e50 05C042E2 		sub	ip, r2, #5
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3489              		.loc 1 1060 0
 3490 1e54 051062E2 		rsb	r1, r2, #5
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3491              		.loc 1 1058 0
 3492 1e58 48A08DE5 		str	sl, [sp, #72]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3493              		.loc 1 1060 0
 3494 1e5c 40009DE5 		ldr	r0, [sp, #64]
 3495 1e60 38A09DE5 		ldr	sl, [sp, #56]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3496              		.loc 1 1058 0
 3497 1e64 40C08DE5 		str	ip, [sp, #64]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3498              		.loc 1 1060 0
 3499 1e68 3CC09DE5 		ldr	ip, [sp, #60]
 3500 1e6c 4C108DE5 		str	r1, [sp, #76]
 3501 1e70 48109DE5 		ldr	r1, [sp, #72]
 3502 1e74 0008A0E1 		mov	r0, r0, asl #16
 3503 1e78 0A005CE1 		cmp	ip, sl
 3504 1e7c 0AC0A021 		movcs	ip, sl
 3505 1e80 0A0052E3 		cmp	r2, #10
 3506 1e84 20A09DE5 		ldr	sl, [sp, #32]
 3507 1e88 2108A081 		movhi	r0, r1, lsr #16
 3508 1e8c 2008A091 		movls	r0, r0, lsr #16
 3509 1e90 48008DE5 		str	r0, [sp, #72]
 3510 1e94 24009DE5 		ldr	r0, [sp, #36]
 3511 1e98 0A005EE1 		cmp	lr, sl
 3512 1e9c 0200A033 		movcc	r0, #2
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3513              		.loc 1 1058 0
 3514 1ea0 02E042E2 		sub	lr, r2, #2
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3515              		.loc 1 1060 0
 3516 1ea4 44C08DE5 		str	ip, [sp, #68]
 3517 1ea8 24008DE5 		str	r0, [sp, #36]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3518              		.loc 1 1058 0
 3519 1eac 40C09DE5 		ldr	ip, [sp, #64]
 3520 1eb0 1CE08DE5 		str	lr, [sp, #28]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3521              		.loc 1 1060 0
 3522 1eb4 44009DE5 		ldr	r0, [sp, #68]
 3523 1eb8 48E09DE5 		ldr	lr, [sp, #72]
 3524 1ebc 4C109DE5 		ldr	r1, [sp, #76]
 3525 1ec0 02A062E2 		rsb	sl, r2, #2
 3526 1ec4 00005EE1 		cmp	lr, r0
 3527 1ec8 00E0A021 		movcs	lr, r0
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3528              		.loc 1 1058 0
 3529 1ecc 0CC8A0E1 		mov	ip, ip, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3530              		.loc 1 1060 0
 3531 1ed0 050052E3 		cmp	r2, #5
 3532 1ed4 40A08DE5 		str	sl, [sp, #64]
 3533 1ed8 0118A0E1 		mov	r1, r1, asl #16
 3534 1edc 3CA09DE5 		ldr	sl, [sp, #60]
 3535 1ee0 2C18A081 		movhi	r1, ip, lsr #16
 3536 1ee4 38C09DE5 		ldr	ip, [sp, #56]
 3537 1ee8 4CE08DE5 		str	lr, [sp, #76]
 3538 1eec 24009DE5 		ldr	r0, [sp, #36]
 3539 1ef0 40E09DE5 		ldr	lr, [sp, #64]
 3540 1ef4 2118A091 		movls	r1, r1, lsr #16
 3541 1ef8 0C005AE1 		cmp	sl, ip
 3542 1efc 20108DE5 		str	r1, [sp, #32]
 3543 1f00 0300A033 		movcc	r0, #3
 3544 1f04 38008DE5 		str	r0, [sp, #56]
 3545 1f08 4CA09DE5 		ldr	sl, [sp, #76]
 3546 1f0c 0E08A0E1 		mov	r0, lr, asl #16
 3547 1f10 20E09DE5 		ldr	lr, [sp, #32]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3548              		.loc 1 1058 0
 3549 1f14 1C109DE5 		ldr	r1, [sp, #28]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3550              		.loc 1 1060 0
 3551 1f18 0A005EE1 		cmp	lr, sl
 3552 1f1c 0AE0A021 		movcs	lr, sl
 3553 1f20 44C09DE5 		ldr	ip, [sp, #68]
 3554 1f24 48A09DE5 		ldr	sl, [sp, #72]
 3555 1f28 020052E3 		cmp	r2, #2
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3556              		.loc 1 1058 0
 3557 1f2c 0118A0E1 		mov	r1, r1, asl #16
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3558              		.loc 1 1060 0
 3559 1f30 2018A091 		movls	r1, r0, lsr #16
 3560 1f34 38009DE5 		ldr	r0, [sp, #56]
 3561 1f38 2118A081 		movhi	r1, r1, lsr #16
 3562 1f3c 0C005AE1 		cmp	sl, ip
 3563 1f40 0400A033 		movcc	r0, #4
 3564 1f44 40008DE5 		str	r0, [sp, #64]
1058:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3565              		.loc 1 1058 0
 3566 1f48 010042E2 		sub	r0, r2, #1
 3567 1f4c 38008DE5 		str	r0, [sp, #56]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3568              		.loc 1 1060 0
 3569 1f50 4CA09DE5 		ldr	sl, [sp, #76]
 3570 1f54 20009DE5 		ldr	r0, [sp, #32]
 3571 1f58 01C062E2 		rsb	ip, r2, #1
 3572 1f5c 3CC08DE5 		str	ip, [sp, #60]
 3573 1f60 0A0050E1 		cmp	r0, sl
1067:../uvc.c      **** 						  shutter = shutter+index;
 3574              		.loc 1 1067 0
 3575 1f64 38A09DE5 		ldr	sl, [sp, #56]
 3576 1f68 3C009DE5 		ldr	r0, [sp, #60]
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3577              		.loc 1 1060 0
 3578 1f6c 40C09DE5 		ldr	ip, [sp, #64]
 3579 1f70 05C0A033 		movcc	ip, #5
1067:../uvc.c      **** 						  shutter = shutter+index;
 3580              		.loc 1 1067 0
 3581 1f74 010052E3 		cmp	r2, #1
 3582 1f78 0028A091 		movls	r2, r0, asl #16
 3583 1f7c 0A28A081 		movhi	r2, sl, asl #16
 3584 1f80 0E0051E1 		cmp	r1, lr
 3585 1f84 01A0A031 		movcc	sl, r1
 3586 1f88 0EA0A021 		movcs	sl, lr
1060:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3587              		.loc 1 1060 0
 3588 1f8c 0E0051E1 		cmp	r1, lr
 3589 1f90 0C10A021 		movcs	r1, ip
 3590 1f94 0610A033 		movcc	r1, #6
1067:../uvc.c      **** 						  shutter = shutter+index;
 3591              		.loc 1 1067 0
 3592 1f98 22085AE1 		cmp	sl, r2, lsr #16
1070:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3593              		.loc 1 1070 0
 3594 1f9c 8CA39FE5 		ldr	sl, .L293+24
1067:../uvc.c      **** 						  shutter = shutter+index;
 3595              		.loc 1 1067 0
 3596 1fa0 0120A091 		movls	r2, r1
 3597 1fa4 0720A083 		movhi	r2, #7
 3598 1fa8 012082E2 		add	r2, r2, #1
 3599 1fac FFE002E2 		and	lr, r2, #255
1070:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3600              		.loc 1 1070 0
 3601 1fb0 0010E0E3 		mvn	r1, #0
 3602 1fb4 1C009AE5 		ldr	r0, [sl, #28]
1067:../uvc.c      **** 						  shutter = shutter+index;
 3603              		.loc 1 1067 0
 3604 1fb8 38E08DE5 		str	lr, [sp, #56]
 3605              	.LVL277:
1070:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3606              		.loc 1 1070 0
 3607 1fbc 2C308DE5 		str	r3, [sp, #44]
 3608 1fc0 FEFFFFEB 		bl	_txe_mutex_get
1071:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3609              		.loc 1 1071 0
 3610 1fc4 38C09DE5 		ldr	ip, [sp, #56]
 3611 1fc8 0310A0E3 		mov	r1, #3
 3612 1fcc 0B20A0E1 		mov	r2, fp
 3613 1fd0 2C309DE5 		ldr	r3, [sp, #44]
 3614 1fd4 00C08DE5 		str	ip, [sp, #0]
 3615 1fd8 0A00A0E1 		mov	r0, sl
 3616 1fdc 00C0A0E3 		mov	ip, #0
 3617 1fe0 04C08DE5 		str	ip, [sp, #4]
 3618 1fe4 FEFFFFEB 		bl	cmdSet
1072:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3619              		.loc 1 1072 0
 3620 1fe8 1C009AE5 		ldr	r0, [sl, #28]
 3621 1fec FEFFFFEB 		bl	_txe_mutex_put
1075:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3622              		.loc 1 1075 0
 3623 1ff0 30009DE5 		ldr	r0, [sp, #48]
1076:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3624              		.loc 1 1076 0
 3625 1ff4 34C09DE5 		ldr	ip, [sp, #52]
1078:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3626              		.loc 1 1078 0
 3627 1ff8 38309DE5 		ldr	r3, [sp, #56]
1075:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3628              		.loc 1 1075 0
 3629 1ffc 061089E0 		add	r1, r9, r6
 3630 2000 816188E0 		add	r6, r8, r1, asl #3
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3631              		.loc 1 1077 0
 3632 2004 0120A0E3 		mov	r2, #1
1075:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3633              		.loc 1 1075 0
 3634 2008 9D04C6E5 		strb	r0, [r6, #1181]
1076:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3635              		.loc 1 1076 0
 3636 200c 9EC4C6E5 		strb	ip, [r6, #1182]
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3637              		.loc 1 1077 0
 3638 2010 A024C6E5 		strb	r2, [r6, #1184]
1078:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3639              		.loc 1 1078 0
 3640 2014 0D33C8E5 		strb	r3, [r8, #781]
 3641 2018 3FFFFFEA 		b	.L283
 3642              	.LVL278:
 3643              	.L229:
1005:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3644              		.loc 1 1005 0
 3645 201c 062089E0 		add	r2, r9, r6
 3646 2020 826188E0 		add	r6, r8, r2, asl #3
1006:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3647              		.loc 1 1006 0
 3648 2024 0110A0E3 		mov	r1, #1
1009:../uvc.c      **** 		  		    switch (getData){
 3649              		.loc 1 1009 0
 3650 2028 01E040E2 		sub	lr, r0, #1
1005:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3651              		.loc 1 1005 0
 3652 202c 9D04C6E5 		strb	r0, [r6, #1181]
1006:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3653              		.loc 1 1006 0
 3654 2030 A014C6E5 		strb	r1, [r6, #1184]
 3655              	.LVL279:
1009:../uvc.c      **** 		  		    switch (getData){
 3656              		.loc 1 1009 0
 3657 2034 07005EE3 		cmp	lr, #7
 3658 2038 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3659 203c 970000EA 		b	.L234
 3660              	.L239:
 3661 2040 34220000 		.word	.L235
 3662 2044 98210000 		.word	.L236
 3663 2048 A0220000 		.word	.L234
 3664 204c 34210000 		.word	.L237
 3665 2050 A0220000 		.word	.L234
 3666 2054 A0220000 		.word	.L234
 3667 2058 A0220000 		.word	.L234
 3668 205c 94200000 		.word	.L238
 3669              	.LVL280:
 3670              	.L228:
1125:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3671              		.loc 1 1125 0
 3672 2060 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1124:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3673              		.loc 1 1124 0
 3674 2064 30A09DE5 		ldr	sl, [sp, #48]
 3675 2068 069089E0 		add	r9, r9, r6
 3676 206c 89E188E0 		add	lr, r8, r9, asl #3
1125:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3677              		.loc 1 1125 0
 3678 2070 0620A0E1 		mov	r2, r6
 3679 2074 0400A0E3 		mov	r0, #4
 3680 2078 BC129FE5 		ldr	r1, .L293+36
1124:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3681              		.loc 1 1124 0
 3682 207c 9DA4CEE5 		strb	sl, [lr, #1181]
1125:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3683              		.loc 1 1125 0
 3684 2080 FEFFFFEB 		bl	CyU3PDebugPrint
1126:../uvc.c      **** 			  		 break;
 3685              		.loc 1 1126 0
 3686 2084 FFC0A0E3 		mov	ip, #255
 3687 2088 0C60A0E1 		mov	r6, ip
 3688 208c 0C80A0E1 		mov	r8, ip
 3689 2090 68FEFFEA 		b	.L219
 3690              	.LVL281:
 3691              	.L238:
1028:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3692              		.loc 1 1028 0
 3693 2094 94629FE5 		ldr	r6, .L293+24
1026:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3694              		.loc 1 1026 0
 3695 2098 00A0A0E3 		mov	sl, #0
1028:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3696              		.loc 1 1028 0
 3697 209c 1C0096E5 		ldr	r0, [r6, #28]
1026:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3698              		.loc 1 1026 0
 3699 20a0 0DA3C8E5 		strb	sl, [r8, #781]
 3700              	.LVL282:
1028:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3701              		.loc 1 1028 0
 3702 20a4 0010E0E3 		mvn	r1, #0
 3703 20a8 2C308DE5 		str	r3, [sp, #44]
 3704 20ac FEFFFFEB 		bl	_txe_mutex_get
1029:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3705              		.loc 1 1029 0
 3706 20b0 0B20A0E1 		mov	r2, fp
 3707 20b4 2C309DE5 		ldr	r3, [sp, #44]
 3708 20b8 1010A0E3 		mov	r1, #16
 3709 20bc 0600A0E1 		mov	r0, r6
 3710 20c0 00A08DE5 		str	sl, [sp, #0]
 3711 20c4 04A08DE5 		str	sl, [sp, #4]
 3712 20c8 FEFFFFEB 		bl	cmdSet
1030:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3713              		.loc 1 1030 0
 3714 20cc 1C0096E5 		ldr	r0, [r6, #28]
 3715 20d0 FEFFFFEB 		bl	_txe_mutex_put
 3716              	.LVL283:
 3717              	.LBB66:
 3718              	.LBB67:
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3719              		.loc 1 382 0
 3720 20d4 0010E0E3 		mvn	r1, #0
 3721 20d8 1C0096E5 		ldr	r0, [r6, #28]
 3722 20dc FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3723              		.loc 1 383 0
 3724 20e0 0180A0E3 		mov	r8, #1
 3725 20e4 2010A0E3 		mov	r1, #32
 3726 20e8 2720A0E3 		mov	r2, #39
 3727 20ec 3030A0E3 		mov	r3, #48
 3728 20f0 0600A0E1 		mov	r0, r6
 3729 20f4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3730 20f8 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3731              		.loc 1 384 0
 3732 20fc 02C0A0E3 		mov	ip, #2
 3733 2100 2110A0E3 		mov	r1, #33
 3734 2104 2520A0E3 		mov	r2, #37
 3735 2108 3030A0E3 		mov	r3, #48
 3736 210c 0600A0E1 		mov	r0, r6
 3737 2110 00C08DE5 		str	ip, [sp, #0]
 3738 2114 04A08DE5 		str	sl, [sp, #4]
 3739 2118 FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3740              		.loc 1 385 0
 3741 211c 1C0096E5 		ldr	r0, [r6, #28]
 3742 2120 FEFFFFEB 		bl	_txe_mutex_put
 3743              	.LBE67:
 3744              	.LBE66:
1032:../uvc.c      **** 							break;
 3745              		.loc 1 1032 0
 3746 2124 FFC0A0E3 		mov	ip, #255
 3747 2128 0C60A0E1 		mov	r6, ip
 3748 212c 0880A0E3 		mov	r8, #8
 3749 2130 40FEFFEA 		b	.L219
 3750              	.LVL284:
 3751              	.L237:
 3752              	.LBB68:
 3753              	.LBB69:
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3754              		.loc 1 382 0
 3755 2134 F4819FE5 		ldr	r8, .L293+24
 3756 2138 0010E0E3 		mvn	r1, #0
 3757 213c 1C0098E5 		ldr	r0, [r8, #28]
 3758 2140 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3759              		.loc 1 383 0
 3760 2144 0060A0E3 		mov	r6, #0
 3761 2148 2010A0E3 		mov	r1, #32
 3762 214c 2720A0E3 		mov	r2, #39
 3763 2150 3030A0E3 		mov	r3, #48
 3764 2154 0800A0E1 		mov	r0, r8
 3765 2158 00608DE5 		str	r6, [sp, #0]
 3766 215c 04608DE5 		str	r6, [sp, #4]
 3767 2160 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3768              		.loc 1 384 0
 3769 2164 2110A0E3 		mov	r1, #33
 3770 2168 2520A0E3 		mov	r2, #37
 3771 216c 3030A0E3 		mov	r3, #48
 3772 2170 0800A0E1 		mov	r0, r8
 3773 2174 00608DE5 		str	r6, [sp, #0]
 3774 2178 04608DE5 		str	r6, [sp, #4]
 3775 217c FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3776              		.loc 1 385 0
 3777 2180 1C0098E5 		ldr	r0, [r8, #28]
 3778 2184 FEFFFFEB 		bl	_txe_mutex_put
 3779 2188 FFC0A0E3 		mov	ip, #255
 3780 218c 0C60A0E1 		mov	r6, ip
 3781 2190 0480A0E3 		mov	r8, #4
 3782 2194 27FEFFEA 		b	.L219
 3783              	.LVL285:
 3784              	.L236:
 3785              	.LBE69:
 3786              	.LBE68:
1016:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3787              		.loc 1 1016 0
 3788 2198 90A19FE5 		ldr	sl, .L293+24
1014:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3789              		.loc 1 1014 0
 3790 219c 0060A0E3 		mov	r6, #0
 3791 21a0 0D63C8E5 		strb	r6, [r8, #781]
 3792              	.LVL286:
1016:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3793              		.loc 1 1016 0
 3794 21a4 0010E0E3 		mvn	r1, #0
 3795 21a8 1C009AE5 		ldr	r0, [sl, #28]
 3796 21ac 2C308DE5 		str	r3, [sp, #44]
 3797 21b0 FEFFFFEB 		bl	_txe_mutex_get
1017:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3798              		.loc 1 1017 0
 3799 21b4 0B20A0E1 		mov	r2, fp
 3800 21b8 2C309DE5 		ldr	r3, [sp, #44]
 3801 21bc 1010A0E3 		mov	r1, #16
 3802 21c0 0A00A0E1 		mov	r0, sl
 3803 21c4 00608DE5 		str	r6, [sp, #0]
 3804 21c8 04608DE5 		str	r6, [sp, #4]
 3805 21cc FEFFFFEB 		bl	cmdSet
1018:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3806              		.loc 1 1018 0
 3807 21d0 1C009AE5 		ldr	r0, [sl, #28]
 3808 21d4 FEFFFFEB 		bl	_txe_mutex_put
 3809              	.LVL287:
 3810              	.LBB70:
 3811              	.LBB71:
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3812              		.loc 1 382 0
 3813 21d8 0010E0E3 		mvn	r1, #0
 3814 21dc 1C009AE5 		ldr	r0, [sl, #28]
 3815 21e0 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3816              		.loc 1 383 0
 3817 21e4 2010A0E3 		mov	r1, #32
 3818 21e8 2720A0E3 		mov	r2, #39
 3819 21ec 3030A0E3 		mov	r3, #48
 3820 21f0 0A00A0E1 		mov	r0, sl
 3821 21f4 00608DE5 		str	r6, [sp, #0]
 3822 21f8 04608DE5 		str	r6, [sp, #4]
 3823 21fc FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3824              		.loc 1 384 0
 3825 2200 2110A0E3 		mov	r1, #33
 3826 2204 2520A0E3 		mov	r2, #37
 3827 2208 3030A0E3 		mov	r3, #48
 3828 220c 0A00A0E1 		mov	r0, sl
 3829 2210 00608DE5 		str	r6, [sp, #0]
 3830 2214 04608DE5 		str	r6, [sp, #4]
 3831 2218 FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3832              		.loc 1 385 0
 3833 221c 1C009AE5 		ldr	r0, [sl, #28]
 3834 2220 FEFFFFEB 		bl	_txe_mutex_put
 3835 2224 FFC0A0E3 		mov	ip, #255
 3836 2228 0C60A0E1 		mov	r6, ip
 3837 222c 0280A0E3 		mov	r8, #2
 3838 2230 00FEFFEA 		b	.L219
 3839              	.LVL288:
 3840              	.L235:
 3841              	.LBE71:
 3842              	.LBE70:
 3843              	.LBB72:
 3844              	.LBB73:
 382:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3845              		.loc 1 382 0
 3846 2234 F4609FE5 		ldr	r6, .L293+24
 3847 2238 0010E0E3 		mvn	r1, #0
 3848 223c 1C0096E5 		ldr	r0, [r6, #28]
 3849 2240 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3850              		.loc 1 383 0
 3851 2244 0080A0E3 		mov	r8, #0
 3852 2248 01A0A0E3 		mov	sl, #1
 3853 224c 2010A0E3 		mov	r1, #32
 3854 2250 2720A0E3 		mov	r2, #39
 3855 2254 3030A0E3 		mov	r3, #48
 3856 2258 0600A0E1 		mov	r0, r6
 3857 225c 04808DE5 		str	r8, [sp, #4]
 3858 2260 00A08DE5 		str	sl, [sp, #0]
 3859 2264 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value 
 3860              		.loc 1 384 0
 3861 2268 02C0A0E3 		mov	ip, #2
 3862 226c 2110A0E3 		mov	r1, #33
 3863 2270 2520A0E3 		mov	r2, #37
 3864 2274 3030A0E3 		mov	r3, #48
 3865 2278 0600A0E1 		mov	r0, r6
 3866 227c 00C08DE5 		str	ip, [sp, #0]
 3867 2280 04808DE5 		str	r8, [sp, #4]
 3868 2284 FEFFFFEB 		bl	cmdSet
 385:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3869              		.loc 1 385 0
 3870 2288 1C0096E5 		ldr	r0, [r6, #28]
 3871 228c FEFFFFEB 		bl	_txe_mutex_put
 3872              	.LBE73:
 3873              	.LBE72:
1012:../uvc.c      **** 							break;
 3874              		.loc 1 1012 0
 3875 2290 FFC0A0E3 		mov	ip, #255
 3876 2294 0C60A0E1 		mov	r6, ip
 3877 2298 0A80A0E1 		mov	r8, sl
 3878 229c E5FDFFEA 		b	.L219
 3879              	.LVL289:
 3880              	.L234:
1009:../uvc.c      **** 		  		    switch (getData){
 3881              		.loc 1 1009 0
 3882 22a0 FFC0A0E3 		mov	ip, #255
 3883 22a4 0080A0E1 		mov	r8, r0
 3884 22a8 0C60A0E1 		mov	r6, ip
 3885 22ac E1FDFFEA 		b	.L219
 3886              	.LVL290:
 3887              	.L240:
1080:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3888              		.loc 1 1080 0
 3889 22b0 0000A0E3 		mov	r0, #0
 3890 22b4 0110A0E3 		mov	r1, #1
 3891 22b8 0020A0E1 		mov	r2, r0
 3892 22bc FEFFFFEB 		bl	CyU3PUsbStall
 3893              	.LVL291:
 3894 22c0 95FEFFEA 		b	.L283
 3895              	.LVL292:
 3896              	.L282:
1098:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3897              		.loc 1 1098 0
 3898 22c4 0110A0E3 		mov	r1, #1
 3899 22c8 0020A0E1 		mov	r2, r0
 3900 22cc FEFFFFEB 		bl	CyU3PUsbStall
 3901 22d0 91FEFFEA 		b	.L283
 3902              	.LVL293:
 3903              	.L292:
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3904              		.loc 1 1113 0
 3905 22d4 08E0A0E3 		mov	lr, #8
 3906 22d8 00C0A0E3 		mov	ip, #0
 3907 22dc 0600A0E1 		mov	r0, r6
 3908 22e0 2310A0E3 		mov	r1, #35
 3909 22e4 0B20A0E1 		mov	r2, fp
 3910 22e8 00E08DE5 		str	lr, [sp, #0]
 3911 22ec 04C08DE5 		str	ip, [sp, #4]
 3912 22f0 FEFFFFEB 		bl	cmdSet
 3913 22f4 5EFEFFEA 		b	.L285
 3914              	.L291:
1111:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3915              		.loc 1 1111 0
 3916 22f8 0480A0E3 		mov	r8, #4
 3917 22fc 00E0A0E3 		mov	lr, #0
 3918 2300 0600A0E1 		mov	r0, r6
 3919 2304 2310A0E3 		mov	r1, #35
 3920 2308 0B20A0E1 		mov	r2, fp
 3921 230c 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3922 2310 FEFFFFEB 		bl	cmdSet
 3923 2314 56FEFFEA 		b	.L285
 3924              	.L294:
 3925              		.align	2
 3926              	.L293:
 3927 2318 00000000 		.word	bRequest
 3928 231c 00000000 		.word	.LANCHOR1
 3929 2320 00000000 		.word	.LANCHOR0
 3930 2324 D8030000 		.word	.LC24
 3931 2328 FC030000 		.word	.LC25
 3932 232c 58000000 		.word	.LANCHOR0+88
 3933 2330 00000000 		.word	cmdQu
 3934 2334 8C030000 		.word	.LC22
 3935 2338 FFFF0000 		.word	65535
 3936 233c B4030000 		.word	.LC23
 3937              		.cfi_endproc
 3938              	.LFE3:
 3940              		.align	2
 3941              		.global	UVCAppEP0Thread_Entry
 3943              	UVCAppEP0Thread_Entry:
 3944              	.LFB24:
3092:../uvc.c      **** {
 3945              		.loc 1 3092 0
 3946              		.cfi_startproc
 3947              		@ args = 0, pretend = 0, frame = 32
 3948              		@ frame_needed = 0, uses_anonymous_args = 0
 3949              	.LVL294:
 3950 2340 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3951              	.LCFI17:
 3952              		.cfi_def_cfa_offset 36
 3953 2344 DC499FE5 		ldr	r4, .L442
 3954              		.cfi_offset 14, -4
 3955              		.cfi_offset 11, -8
 3956              		.cfi_offset 10, -12
 3957              		.cfi_offset 9, -16
 3958              		.cfi_offset 8, -20
 3959              		.cfi_offset 7, -24
 3960              		.cfi_offset 6, -28
 3961              		.cfi_offset 5, -32
 3962              		.cfi_offset 4, -36
 3963 2348 DC699FE5 		ldr	r6, .L442+4
 3964 234c DC899FE5 		ldr	r8, .L442+8
 3965 2350 DC999FE5 		ldr	r9, .L442+12
 3966 2354 DCA99FE5 		ldr	sl, .L442+16
 3967 2358 DC799FE5 		ldr	r7, .L442+20
 3968 235c 3CD04DE2 		sub	sp, sp, #60
 3969              	.LCFI18:
 3970              		.cfi_def_cfa_offset 96
 3971              	.LVL295:
3114:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 3972              		.loc 1 3114 0
 3973 2360 0450A0E1 		mov	r5, r4
 3974              	.LVL296:
 3975              	.L419:
 3976 2364 00C0E0E3 		mvn	ip, #0
 3977 2368 B8099FE5 		ldr	r0, .L442
 3978 236c 4C10A0E3 		mov	r1, #76
 3979 2370 0120A0E3 		mov	r2, #1
 3980 2374 30308DE2 		add	r3, sp, #48
 3981 2378 00C08DE5 		str	ip, [sp, #0]
 3982 237c FEFFFFEB 		bl	_txe_event_flags_get
 3983 2380 000050E3 		cmp	r0, #0
 3984 2384 3000001A 		bne	.L296
3118:../uvc.c      ****             if (!isUsbConnected)
 3985              		.loc 1 3118 0
 3986 2388 3C3095E5 		ldr	r3, [r5, #60]
 3987 238c 000053E3 		cmp	r3, #0
 3988 2390 8900000A 		beq	.L433
 3989              	.L297:
3127:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 3990              		.loc 1 3127 0
 3991 2394 30309DE5 		ldr	r3, [sp, #48]
 3992 2398 0C0013E3 		tst	r3, #12
 3993 239c 7200001A 		bne	.L434
 3994              	.L298:
3134:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 3995              		.loc 1 3134 0
 3996 23a0 040013E3 		tst	r3, #4
 3997 23a4 1C00000A 		beq	.L299
3136:../uvc.c      ****             	switch ((wIndex >> 8))
 3998              		.loc 1 3136 0
 3999 23a8 B0E0DAE1 		ldrh	lr, [sl, #0]
 4000 23ac 2E24A0E1 		mov	r2, lr, lsr #8
 4001 23b0 030052E3 		cmp	r2, #3
 4002 23b4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4003 23b8 120000EA 		b	.L300
 4004              	.L305:
 4005 23bc 08240000 		.word	.L300
 4006 23c0 EC240000 		.word	.L302
 4007 23c4 CC230000 		.word	.L303
 4008 23c8 28250000 		.word	.L304
 4009              	.L303:
 4010              	.LBB88:
 4011              	.LBB90:
2423:../uvc.c      ****     switch (wValue)
 4012              		.loc 1 2423 0
 4013 23cc B020D9E1 		ldrh	r2, [r9, #0]
 4014 23d0 060C52E3 		cmp	r2, #1536
 4015 23d4 D901000A 		beq	.L311
 4016 23d8 CC00008A 		bhi	.L317
 4017 23dc 030C52E3 		cmp	r2, #768
 4018 23e0 D201000A 		beq	.L309
 4019 23e4 C901008A 		bhi	.L318
 4020 23e8 010C52E3 		cmp	r2, #256
 4021 23ec 6801000A 		beq	.L307
 4022 23f0 020C52E3 		cmp	r2, #512
 4023 23f4 6201000A 		beq	.L435
 4024              	.L320:
 4025              	.LBE90:
 4026              	.LBE88:
 4027              	.LBB93:
 4028              	.LBB97:
2555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4029              		.loc 1 2555 0
 4030 23f8 40199FE5 		ldr	r1, .L442+24
 4031 23fc 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4032 2400 0400A0E3 		mov	r0, #4
 4033 2404 FEFFFFEB 		bl	CyU3PDebugPrint
 4034              	.L300:
 4035              	.LBE97:
 4036              	.LBE93:
3157:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4037              		.loc 1 3157 0
 4038 2408 0000A0E3 		mov	r0, #0
 4039 240c 0110A0E3 		mov	r1, #1
 4040 2410 0020A0E1 		mov	r2, r0
 4041 2414 FEFFFFEB 		bl	CyU3PUsbStall
 4042 2418 30309DE5 		ldr	r3, [sp, #48]
 4043              	.L299:
3162:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4044              		.loc 1 3162 0
 4045 241c 080013E3 		tst	r3, #8
 4046 2420 0700000A 		beq	.L361
3166:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4047              		.loc 1 3166 0
 4048 2424 B030DAE1 		ldrh	r3, [sl, #0]
 4049 2428 010053E3 		cmp	r3, #1
 4050 242c 6800000A 		beq	.L362
 4051              	.L363:
 4052              	.LBB102:
 4053              	.LBB108:
3081:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4054              		.loc 1 3081 0
 4055 2430 0000A0E3 		mov	r0, #0
 4056 2434 0110A0E3 		mov	r1, #1
 4057 2438 0020A0E1 		mov	r2, r0
 4058 243c FEFFFFEB 		bl	CyU3PUsbStall
 4059              	.L423:
 4060 2440 30309DE5 		ldr	r3, [sp, #48]
 4061              	.L361:
 4062              	.LBE108:
 4063              	.LBE102:
3177:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4064              		.loc 1 3177 0
 4065 2444 400013E3 		tst	r3, #64
 4066 2448 0100001A 		bne	.L436
 4067              	.L296:
3390:../uvc.c      ****         CyU3PThreadRelinquish ();
 4068              		.loc 1 3390 0
 4069 244c FEFFFFEB 		bl	_txe_thread_relinquish
3391:../uvc.c      ****     }
 4070              		.loc 1 3391 0
 4071 2450 C3FFFFEA 		b	.L419
 4072              	.L436:
3182:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4073              		.loc 1 3182 0
 4074 2454 1800A0E3 		mov	r0, #24
 4075 2458 2C108DE2 		add	r1, sp, #44
 4076 245c FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3187:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4077              		.loc 1 3187 0
 4078 2460 2C209DE5 		ldr	r2, [sp, #44]
 4079 2464 000052E3 		cmp	r2, #0
 4080 2468 6D00000A 		beq	.L414
3187:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4081              		.loc 1 3187 0 is_stmt 0 discriminator 1
 4082 246c 6336D6E5 		ldrb	r3, [r6, #1635]	@ zero_extendqisi2
 4083 2470 000053E3 		cmp	r3, #0
 4084 2474 F4FFFF1A 		bne	.L296
3189:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4085              		.loc 1 3189 0 is_stmt 1
 4086 2478 002097E5 		ldr	r2, [r7, #0]
 4087 247c 02B0A0E3 		mov	fp, #2
 4088 2480 00B0C2E5 		strb	fp, [r2, #0]
3190:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4089              		.loc 1 3190 0
 4090 2484 001097E5 		ldr	r1, [r7, #0]
 4091 2488 01B0A0E3 		mov	fp, #1
 4092 248c 01B0C1E5 		strb	fp, [r1, #1]
3191:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4093              		.loc 1 3191 0
 4094 2490 000097E5 		ldr	r0, [r7, #0]
3195:../uvc.c      **** 					interStabuf.size   = 1024;
 4095              		.loc 1 3195 0
 4096 2494 01EBA0E3 		mov	lr, #1024	@ movhi
3191:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4097              		.loc 1 3191 0
 4098 2498 0230C0E5 		strb	r3, [r0, #2]
3192:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4099              		.loc 1 3192 0
 4100 249c 00C097E5 		ldr	ip, [r7, #0]
3201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4101              		.loc 1 3201 0
 4102 24a0 0010E0E3 		mvn	r1, #0
3192:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4103              		.loc 1 3192 0
 4104 24a4 0330CCE5 		strb	r3, [ip, #3]
3194:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4105              		.loc 1 3194 0
 4106 24a8 002097E5 		ldr	r2, [r7, #0]
3198:../uvc.c      **** 					interStabuf.count = 4;
 4107              		.loc 1 3198 0
 4108 24ac 04C0A0E3 		mov	ip, #4	@ movhi
3201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4109              		.loc 1 3201 0
 4110 24b0 8C089FE5 		ldr	r0, .L442+28
3194:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4111              		.loc 1 3194 0
 4112 24b4 20208DE5 		str	r2, [sp, #32]
3195:../uvc.c      **** 					interStabuf.size   = 1024;
 4113              		.loc 1 3195 0
 4114 24b8 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3196:../uvc.c      **** 					interStabuf.status = 0;
 4115              		.loc 1 3196 0
 4116 24bc B832CDE1 		strh	r3, [sp, #40]	@ movhi
3198:../uvc.c      **** 					interStabuf.count = 4;
 4117              		.loc 1 3198 0
 4118 24c0 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
3201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4119              		.loc 1 3201 0
 4120 24c4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3204:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4121              		.loc 1 3204 0
 4122 24c8 74089FE5 		ldr	r0, .L442+28
 4123 24cc 20108DE2 		add	r1, sp, #32
 4124 24d0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4125              	.LVL297:
3205:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4126              		.loc 1 3205 0
 4127 24d4 002050E2 		subs	r2, r0, #0
 4128 24d8 6701001A 		bne	.L437
3210:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4129              		.loc 1 3210 0
 4130 24dc 48389FE5 		ldr	r3, .L442+4
 4131 24e0 63B6C3E5 		strb	fp, [r3, #1635]
3390:../uvc.c      ****         CyU3PThreadRelinquish ();
 4132              		.loc 1 3390 0
 4133 24e4 FEFFFFEB 		bl	_txe_thread_relinquish
 4134              	.LVL298:
 4135 24e8 9DFFFFEA 		b	.L419
 4136              	.L302:
 4137              	.LBB114:
 4138              	.LBB98:
2498:../uvc.c      ****     switch (wValue)
 4139              		.loc 1 2498 0
 4140 24ec B020D9E1 		ldrh	r2, [r9, #0]
 4141 24f0 060C52E3 		cmp	r2, #1536
 4142 24f4 D500000A 		beq	.L326
 4143 24f8 8F00008A 		bhi	.L332
 4144 24fc 030C52E3 		cmp	r2, #768
 4145 2500 1701000A 		beq	.L323
 4146 2504 0E01008A 		bhi	.L333
 4147 2508 010C52E3 		cmp	r2, #256
 4148 250c 5601000A 		beq	.L321
 4149 2510 020C52E3 		cmp	r2, #512
 4150 2514 B7FFFF1A 		bne	.L320
 4151              	.LVL299:
2506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4152              		.loc 1 2506 0
 4153 2518 0100A0E3 		mov	r0, #1
 4154 251c FEFFFFEB 		bl	CTControlHandle
 4155              	.LVL300:
 4156 2520 30309DE5 		ldr	r3, [sp, #48]
 4157 2524 BCFFFFEA 		b	.L299
 4158              	.L304:
 4159              	.LBE98:
 4160              	.LBE114:
 4161              	.LBB115:
 4162              	.LBB120:
2723:../uvc.c      ****     switch (wValue)
 4163              		.loc 1 2723 0
 4164 2528 B020D9E1 		ldrh	r2, [r9, #0]
 4165 252c 090C52E3 		cmp	r2, #2304
 4166 2530 EE01000A 		beq	.L347
 4167 2534 8800008A 		bhi	.L356
 4168 2538 010B52E3 		cmp	r2, #1024
 4169 253c EF01000A 		beq	.L342
 4170 2540 8701008A 		bhi	.L357
 4171 2544 020C52E3 		cmp	r2, #512
 4172 2548 E401000A 		beq	.L340
 4173 254c 030C52E3 		cmp	r2, #768
 4174 2550 C301000A 		beq	.L341
 4175 2554 010C52E3 		cmp	r2, #256
 4176 2558 AAFFFF1A 		bne	.L300
 4177              	.LVL301:
2727:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4178              		.loc 1 2727 0
 4179 255c 1000A0E3 		mov	r0, #16
 4180 2560 FEFFFFEB 		bl	ControlHandle
 4181              	.LVL302:
 4182 2564 30309DE5 		ldr	r3, [sp, #48]
 4183 2568 ABFFFFEA 		b	.L299
 4184              	.L434:
 4185              	.LBE120:
 4186              	.LBE115:
3128:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4187              		.loc 1 3128 0
 4188 256c D4B79FE5 		ldr	fp, .L442+32
 4189 2570 B0C0D9E1 		ldrh	ip, [r9, #0]
 4190 2574 B000DAE1 		ldrh	r0, [sl, #0]
 4191 2578 CC179FE5 		ldr	r1, .L442+36
 4192 257c 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4193 2580 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4194 2584 0C008DE5 		str	r0, [sp, #12]
 4195 2588 08C08DE5 		str	ip, [sp, #8]
 4196 258c B0C0D1E1 		ldrh	ip, [r1, #0]
 4197 2590 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4198 2594 04B08DE5 		str	fp, [sp, #4]
 4199 2598 0400A0E3 		mov	r0, #4
 4200 259c AC179FE5 		ldr	r1, .L442+40
 4201 25a0 00B0A0E3 		mov	fp, #0
 4202 25a4 00E08DE5 		str	lr, [sp, #0]
 4203 25a8 10C08DE5 		str	ip, [sp, #16]
 4204 25ac 14B08DE5 		str	fp, [sp, #20]
 4205 25b0 FEFFFFEB 		bl	CyU3PDebugPrint
 4206 25b4 30309DE5 		ldr	r3, [sp, #48]
 4207 25b8 78FFFFEA 		b	.L298
 4208              	.L433:
3120:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4209              		.loc 1 3120 0
 4210 25bc FEFFFFEB 		bl	CyU3PUsbGetSpeed
3121:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4211              		.loc 1 3121 0
 4212 25c0 000050E3 		cmp	r0, #0
3120:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4213              		.loc 1 3120 0
 4214 25c4 4800C5E5 		strb	r0, [r5, #72]
3123:../uvc.c      ****                     isUsbConnected = CyTrue;
 4215              		.loc 1 3123 0
 4216 25c8 0100A013 		movne	r0, #1
 4217 25cc 3C008515 		strne	r0, [r5, #60]
 4218 25d0 6FFFFFEA 		b	.L297
 4219              	.L362:
 4220              	.LVL303:
 4221              	.LBB125:
 4222              	.LBB107:
2818:../uvc.c      ****     switch (wValue)
 4223              		.loc 1 2818 0
 4224 25d4 B020D9E1 		ldrh	r2, [r9, #0]
 4225 25d8 030C52E3 		cmp	r2, #768
 4226 25dc 8100000A 		beq	.L366
 4227 25e0 3300008A 		bhi	.L369
 4228 25e4 010C52E3 		cmp	r2, #256
 4229 25e8 8B00000A 		beq	.L364
 4230 25ec 020C52E3 		cmp	r2, #512
 4231 25f0 8EFFFF1A 		bne	.L363
2870:../uvc.c      ****             switch (bRequest)
 4232              		.loc 1 2870 0
 4233 25f4 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4234 25f8 810053E3 		cmp	r3, #129
 4235 25fc 8B00000A 		beq	.L408
 4236 2600 2601008A 		bhi	.L384
 4237 2604 010053E3 		cmp	r3, #1
 4238 2608 8401000A 		beq	.L438
 4239              	.L388:
2969:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4240              		.loc 1 2969 0
 4241 260c 0000A0E3 		mov	r0, #0
 4242 2610 0110A0E3 		mov	r1, #1
 4243 2614 0020A0E1 		mov	r2, r0
 4244 2618 FEFFFFEB 		bl	CyU3PUsbStall
 4245 261c 30309DE5 		ldr	r3, [sp, #48]
 4246 2620 87FFFFEA 		b	.L361
 4247              	.LVL304:
 4248              	.L414:
 4249              	.LBE107:
 4250              	.LBE125:
3211:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4251              		.loc 1 3211 0
 4252 2624 63E6D6E5 		ldrb	lr, [r6, #1635]	@ zero_extendqisi2
 4253 2628 00005EE3 		cmp	lr, #0
 4254 262c 86FFFF0A 		beq	.L296
3213:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4255              		.loc 1 3213 0
 4256 2630 003097E5 		ldr	r3, [r7, #0]
 4257 2634 02B0A0E3 		mov	fp, #2
 4258 2638 00B0C3E5 		strb	fp, [r3, #0]
3214:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4259              		.loc 1 3214 0
 4260 263c 001097E5 		ldr	r1, [r7, #0]
 4261 2640 01B0A0E3 		mov	fp, #1
 4262 2644 01B0C1E5 		strb	fp, [r1, #1]
3215:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4263              		.loc 1 3215 0
 4264 2648 000097E5 		ldr	r0, [r7, #0]
3219:../uvc.c      **** 					interStabuf.size   = 1024;
 4265              		.loc 1 3219 0
 4266 264c 01EBA0E3 		mov	lr, #1024	@ movhi
3215:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4267              		.loc 1 3215 0
 4268 2650 0220C0E5 		strb	r2, [r0, #2]
3216:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4269              		.loc 1 3216 0
 4270 2654 00C097E5 		ldr	ip, [r7, #0]
3225:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4271              		.loc 1 3225 0
 4272 2658 0010E0E3 		mvn	r1, #0
3216:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4273              		.loc 1 3216 0
 4274 265c 03B0CCE5 		strb	fp, [ip, #3]
3218:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4275              		.loc 1 3218 0
 4276 2660 003097E5 		ldr	r3, [r7, #0]
3220:../uvc.c      **** 					interStabuf.status = 0;
 4277              		.loc 1 3220 0
 4278 2664 02C0A0E1 		mov	ip, r2	@ movhi
 4279 2668 B822CDE1 		strh	r2, [sp, #40]	@ movhi
3225:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4280              		.loc 1 3225 0
 4281 266c D0069FE5 		ldr	r0, .L442+28
3222:../uvc.c      **** 					interStabuf.count = 4;
 4282              		.loc 1 3222 0
 4283 2670 0420A0E3 		mov	r2, #4	@ movhi
3218:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4284              		.loc 1 3218 0
 4285 2674 20308DE5 		str	r3, [sp, #32]
3222:../uvc.c      **** 					interStabuf.count = 4;
 4286              		.loc 1 3222 0
 4287 2678 B422CDE1 		strh	r2, [sp, #36]	@ movhi
3219:../uvc.c      **** 					interStabuf.size   = 1024;
 4288              		.loc 1 3219 0
 4289 267c B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3225:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4290              		.loc 1 3225 0
 4291 2680 1CC08DE5 		str	ip, [sp, #28]
 4292 2684 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3228:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4293              		.loc 1 3228 0
 4294 2688 B4069FE5 		ldr	r0, .L442+28
 4295 268c 20108DE2 		add	r1, sp, #32
 4296 2690 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4297              	.LVL305:
3229:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4298              		.loc 1 3229 0
 4299 2694 1C309DE5 		ldr	r3, [sp, #28]
 4300 2698 002050E2 		subs	r2, r0, #0
 4301 269c C000001A 		bne	.L439
3235:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4302              		.loc 1 3235 0
 4303 26a0 84269FE5 		ldr	r2, .L442+4
3236:../uvc.c      **** 					stiflag = CyTrue;
 4304              		.loc 1 3236 0
 4305 26a4 98B084E5 		str	fp, [r4, #152]
3235:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4306              		.loc 1 3235 0
 4307 26a8 6336C2E5 		strb	r3, [r2, #1635]
3390:../uvc.c      ****         CyU3PThreadRelinquish ();
 4308              		.loc 1 3390 0
 4309 26ac FEFFFFEB 		bl	_txe_thread_relinquish
 4310              	.LVL306:
 4311 26b0 2BFFFFEA 		b	.L419
 4312              	.LVL307:
 4313              	.L369:
 4314              	.LBB126:
 4315              	.LBB109:
2818:../uvc.c      ****     switch (wValue)
 4316              		.loc 1 2818 0
 4317 26b4 010B52E3 		cmp	r2, #1024
 4318 26b8 3800000A 		beq	.L367
 4319 26bc 050C52E3 		cmp	r2, #1280
 4320 26c0 5AFFFF1A 		bne	.L363
3030:../uvc.c      ****                 switch (bRequest)
 4321              		.loc 1 3030 0
 4322 26c4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4323 26c8 810052E3 		cmp	r2, #129
 4324 26cc 5700000A 		beq	.L408
 4325 26d0 1E01008A 		bhi	.L411
 4326 26d4 010052E3 		cmp	r2, #1
 4327 26d8 54FFFF1A 		bne	.L363
3055:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4328              		.loc 1 3055 0
 4329 26dc 2000A0E3 		mov	r0, #32
 4330 26e0 6C169FE5 		ldr	r1, .L442+44
 4331 26e4 36208DE2 		add	r2, sp, #54
 4332 26e8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4333              	.LVL308:
3057:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4334              		.loc 1 3057 0
 4335 26ec 000050E3 		cmp	r0, #0
 4336 26f0 8601001A 		bne	.L413
3067:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4337              		.loc 1 3067 0
 4338 26f4 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 4339 26f8 040080E2 		add	r0, r0, #4
 4340              	.LVL309:
 4341 26fc 54169FE5 		ldr	r1, .L442+48
 4342 2700 B623DDE1 		ldrh	r2, [sp, #54]
 4343 2704 FEFFFFEB 		bl	CyU3PDebugPrint
 4344              	.LVL310:
 4345 2708 30309DE5 		ldr	r3, [sp, #48]
 4346 270c 4CFFFFEA 		b	.L361
 4347              	.L317:
 4348              	.LBE109:
 4349              	.LBE126:
 4350              	.LBB127:
 4351              	.LBB91:
2423:../uvc.c      ****     switch (wValue)
 4352              		.loc 1 2423 0
 4353 2710 0A0C52E3 		cmp	r2, #2560
 4354 2714 F500000A 		beq	.L314
 4355 2718 EA00008A 		bhi	.L319
 4356 271c 070C52E3 		cmp	r2, #1792
 4357 2720 E400000A 		beq	.L312
 4358 2724 020B52E3 		cmp	r2, #2048
 4359 2728 32FFFF1A 		bne	.L320
 4360              	.LVL311:
2454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4361              		.loc 1 2454 0
 4362 272c 0700A0E3 		mov	r0, #7
 4363 2730 FEFFFFEB 		bl	ControlHandle
 4364              	.LVL312:
 4365 2734 30309DE5 		ldr	r3, [sp, #48]
 4366 2738 37FFFFEA 		b	.L299
 4367              	.L332:
 4368              	.LBE91:
 4369              	.LBE127:
 4370              	.LBB128:
 4371              	.LBB96:
2498:../uvc.c      ****     switch (wValue)
 4372              		.loc 1 2498 0
 4373 273c 090C52E3 		cmp	r2, #2304
 4374 2740 2601000A 		beq	.L328
 4375 2744 1B01008A 		bhi	.L334
 4376 2748 070C52E3 		cmp	r2, #1792
 4377 274c 0D01000A 		beq	.L327
 4378 2750 020B52E3 		cmp	r2, #2048
 4379 2754 27FFFF1A 		bne	.L320
 4380 2758 2FFFFFEA 		b	.L299
 4381              	.L356:
 4382              	.LBE96:
 4383              	.LBE128:
 4384              	.LBB129:
 4385              	.LBB119:
2723:../uvc.c      ****     switch (wValue)
 4386              		.loc 1 2723 0
 4387 275c 0F0C52E3 		cmp	r2, #3840
 4388 2760 5A01000A 		beq	.L351
 4389 2764 3D00008A 		bhi	.L359
 4390 2768 0B0C52E3 		cmp	r2, #2816
 4391 276c 5301000A 		beq	.L349
 4392 2770 0D0C52E3 		cmp	r2, #3328
 4393 2774 4D01000A 		beq	.L350
 4394 2778 0A0C52E3 		cmp	r2, #2560
 4395 277c 21FFFF1A 		bne	.L300
2766:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
 4396              		.loc 1 2766 0
 4397 2780 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4398 2784 00C0A0E3 		mov	ip, #0
 4399 2788 0400A0E3 		mov	r0, #4
 4400 278c C8159FE5 		ldr	r1, .L442+52
 4401 2790 00C08DE5 		str	ip, [sp, #0]
 4402 2794 FEFFFFEB 		bl	CyU3PDebugPrint
 4403 2798 30309DE5 		ldr	r3, [sp, #48]
 4404 279c 1EFFFFEA 		b	.L299
 4405              	.LVL313:
 4406              	.L367:
 4407              	.LBE119:
 4408              	.LBE129:
 4409              	.LBB130:
 4410              	.LBB106:
2975:../uvc.c      ****                 switch (bRequest)
 4411              		.loc 1 2975 0
 4412 27a0 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4413 27a4 81005BE3 		cmp	fp, #129
 4414 27a8 1300000A 		beq	.L399
 4415 27ac 8500008A 		bhi	.L402
 4416 27b0 01005BE3 		cmp	fp, #1
 4417 27b4 1DFFFF1A 		bne	.L363
3000:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4418              		.loc 1 3000 0
 4419 27b8 36208DE2 		add	r2, sp, #54
 4420 27bc 2000A0E3 		mov	r0, #32
 4421 27c0 8C159FE5 		ldr	r1, .L442+44
 4422 27c4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4423              	.LVL314:
3002:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4424              		.loc 1 3002 0
 4425 27c8 002050E2 		subs	r2, r0, #0
 4426 27cc 1BFFFF1A 		bne	.L423
3015:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4427              		.loc 1 3015 0
 4428 27d0 50059FE5 		ldr	r0, .L442
 4429              	.LVL315:
 4430 27d4 0B10A0E1 		mov	r1, fp
 4431 27d8 FEFFFFEB 		bl	_txe_event_flags_set
 4432              	.LVL316:
3016:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4433              		.loc 1 3016 0
 4434 27dc 002050E2 		subs	r2, r0, #0
 4435 27e0 16FFFF0A 		beq	.L423
 4436 27e4 190100EA 		b	.L405
 4437              	.LVL317:
 4438              	.L366:
2926:../uvc.c      ****                 switch (bRequest)
 4439              		.loc 1 2926 0
 4440 27e8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4441 27ec 830052E3 		cmp	r2, #131
 4442 27f0 9800008A 		bhi	.L393
 4443 27f4 810052E3 		cmp	r2, #129
 4444 27f8 7D00003A 		bcc	.L440
 4445              	.L399:
2987:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4446              		.loc 1 2987 0
 4447 27fc 48B0D4E5 		ldrb	fp, [r4, #72]	@ zero_extendqisi2
2989:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4448              		.loc 1 2989 0
 4449 2800 0B00A0E3 		mov	r0, #11
2987:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4450              		.loc 1 2987 0
 4451 2804 03005BE3 		cmp	fp, #3
2989:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4452              		.loc 1 2989 0
 4453 2808 50159F05 		ldreq	r1, .L442+56
2993:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4454              		.loc 1 2993 0
 4455 280c 50159F15 		ldrne	r1, .L442+60
 4456 2810 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4457 2814 30309DE5 		ldr	r3, [sp, #48]
 4458 2818 09FFFFEA 		b	.L361
 4459              	.L364:
2821:../uvc.c      ****             switch (bRequest)
 4460              		.loc 1 2821 0
 4461 281c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4462 2820 830052E3 		cmp	r2, #131
 4463 2824 2F00008A 		bhi	.L375
 4464 2828 810052E3 		cmp	r2, #129
 4465 282c 1400003A 		bcc	.L441
 4466              	.L408:
3042:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4467              		.loc 1 3042 0
 4468 2830 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3044:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4469              		.loc 1 3044 0
 4470 2834 1A00A0E3 		mov	r0, #26
3042:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4471              		.loc 1 3042 0
 4472 2838 030052E3 		cmp	r2, #3
3044:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4473              		.loc 1 3044 0
 4474 283c 24159F05 		ldreq	r1, .L442+64
3048:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4475              		.loc 1 3048 0
 4476 2840 24159F15 		ldrne	r1, .L442+68
 4477 2844 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4478 2848 30309DE5 		ldr	r3, [sp, #48]
 4479 284c FCFEFFEA 		b	.L361
 4480              	.LVL318:
 4481              	.L326:
 4482              	.LBE106:
 4483              	.LBE130:
 4484              	.LBB131:
 4485              	.LBB99:
2524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4486              		.loc 1 2524 0
 4487 2850 0500A0E3 		mov	r0, #5
 4488 2854 FEFFFFEB 		bl	CTControlHandle
 4489              	.LVL319:
 4490 2858 30309DE5 		ldr	r3, [sp, #48]
 4491 285c EEFEFFEA 		b	.L299
 4492              	.L359:
 4493              	.LBE99:
 4494              	.LBE131:
 4495              	.LBB132:
 4496              	.LBB121:
2723:../uvc.c      ****     switch (wValue)
 4497              		.loc 1 2723 0
 4498 2860 110C52E3 		cmp	r2, #4352
 4499 2864 E900000A 		beq	.L353
 4500 2868 2D00008A 		bhi	.L360
 4501 286c 010A52E3 		cmp	r2, #4096
 4502 2870 E4FEFF1A 		bne	.L300
 4503              	.LVL320:
2786:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4504              		.loc 1 2786 0
 4505 2874 1F00A0E3 		mov	r0, #31
 4506 2878 FEFFFFEB 		bl	ControlHandle
 4507              	.LVL321:
 4508 287c 30309DE5 		ldr	r3, [sp, #48]
 4509 2880 E5FEFFEA 		b	.L299
 4510              	.LVL322:
 4511              	.L441:
 4512              	.LBE121:
 4513              	.LBE132:
 4514              	.LBB133:
 4515              	.LBB110:
2821:../uvc.c      ****             switch (bRequest)
 4516              		.loc 1 2821 0
 4517 2884 010052E3 		cmp	r2, #1
 4518 2888 5FFFFF1A 		bne	.L388
2846:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4519              		.loc 1 2846 0
 4520 288c 2000A0E3 		mov	r0, #32
 4521 2890 BC149FE5 		ldr	r1, .L442+44
 4522 2894 36208DE2 		add	r2, sp, #54
 4523 2898 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4524              	.LVL323:
2848:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4525              		.loc 1 2848 0
 4526 289c 000050E3 		cmp	r0, #0
 4527 28a0 E6FEFF1A 		bne	.L423
2850:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4528              		.loc 1 2850 0
 4529 28a4 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 4530 28a8 030053E3 		cmp	r3, #3
 4531 28ac E3FEFF1A 		bne	.L423
2854:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4532              		.loc 1 2854 0
 4533 28b0 7AE0D4E5 		ldrb	lr, [r4, #122]	@ zero_extendqisi2
2855:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4534              		.loc 1 2855 0
 4535 28b4 7BC0D4E5 		ldrb	ip, [r4, #123]	@ zero_extendqisi2
2856:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4536              		.loc 1 2856 0
 4537 28b8 7C00D4E5 		ldrb	r0, [r4, #124]	@ zero_extendqisi2
 4538              	.LVL324:
2857:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4539              		.loc 1 2857 0
 4540 28bc 7D10D4E5 		ldrb	r1, [r4, #125]	@ zero_extendqisi2
2858:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4541              		.loc 1 2858 0
 4542 28c0 7E20D4E5 		ldrb	r2, [r4, #126]	@ zero_extendqisi2
2859:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4543              		.loc 1 2859 0
 4544 28c4 7FB0D4E5 		ldrb	fp, [r4, #127]	@ zero_extendqisi2
2854:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4545              		.loc 1 2854 0
 4546 28c8 16E6C6E5 		strb	lr, [r6, #1558]
2855:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4547              		.loc 1 2855 0
 4548 28cc 17C6C6E5 		strb	ip, [r6, #1559]
2856:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4549              		.loc 1 2856 0
 4550 28d0 1806C6E5 		strb	r0, [r6, #1560]
2857:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4551              		.loc 1 2857 0
 4552 28d4 1916C6E5 		strb	r1, [r6, #1561]
2858:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4553              		.loc 1 2858 0
 4554 28d8 1A26C6E5 		strb	r2, [r6, #1562]
2859:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4555              		.loc 1 2859 0
 4556 28dc 1BB6C6E5 		strb	fp, [r6, #1563]
 4557 28e0 30309DE5 		ldr	r3, [sp, #48]
 4558 28e4 D6FEFFEA 		b	.L361
 4559              	.LVL325:
 4560              	.L375:
2821:../uvc.c      ****             switch (bRequest)
 4561              		.loc 1 2821 0
 4562 28e8 860052E3 		cmp	r2, #134
 4563 28ec 3900000A 		beq	.L426
 4564 28f0 870052E3 		cmp	r2, #135
 4565 28f4 CDFFFF0A 		beq	.L408
 4566              	.L432:
2926:../uvc.c      ****                 switch (bRequest)
 4567              		.loc 1 2926 0
 4568 28f8 850052E3 		cmp	r2, #133
 4569 28fc 42FFFF1A 		bne	.L388
 4570              	.L400:
2984:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4571              		.loc 1 2984 0
 4572 2900 68149FE5 		ldr	r1, .L442+72
 4573 2904 0200A0E3 		mov	r0, #2
2982:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4574              		.loc 1 2982 0
 4575 2908 1A30A0E3 		mov	r3, #26
 4576              	.L424:
3037:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4577              		.loc 1 3037 0
 4578 290c 5830C4E5 		strb	r3, [r4, #88]
3038:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4579              		.loc 1 3038 0
 4580 2910 0030A0E3 		mov	r3, #0
 4581 2914 5930C4E5 		strb	r3, [r4, #89]
3039:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4582              		.loc 1 3039 0
 4583 2918 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4584 291c 30309DE5 		ldr	r3, [sp, #48]
 4585 2920 C7FEFFEA 		b	.L361
 4586              	.LVL326:
 4587              	.L360:
 4588              	.LBE110:
 4589              	.LBE133:
 4590              	.LBB134:
 4591              	.LBB118:
2723:../uvc.c      ****     switch (wValue)
 4592              		.loc 1 2723 0
 4593 2924 120C52E3 		cmp	r2, #4608
 4594 2928 DC00000A 		beq	.L354
 4595 292c 130C52E3 		cmp	r2, #4864
 4596 2930 B4FEFF1A 		bne	.L300
 4597              	.LVL327:
2798:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 4598              		.loc 1 2798 0
 4599 2934 2600A0E3 		mov	r0, #38
 4600 2938 FEFFFFEB 		bl	ControlHandle
 4601              	.LVL328:
 4602 293c 30309DE5 		ldr	r3, [sp, #48]
 4603 2940 B5FEFFEA 		b	.L299
 4604              	.L333:
 4605              	.LBE118:
 4606              	.LBE134:
 4607              	.LBB135:
 4608              	.LBB95:
2498:../uvc.c      ****     switch (wValue)
 4609              		.loc 1 2498 0
 4610 2944 010B52E3 		cmp	r2, #1024
 4611 2948 0900000A 		beq	.L324
 4612 294c 050C52E3 		cmp	r2, #1280
 4613 2950 A8FEFF1A 		bne	.L320
 4614              	.LVL329:
2520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4615              		.loc 1 2520 0
 4616 2954 0400A0E3 		mov	r0, #4
 4617 2958 FEFFFFEB 		bl	CTControlHandle
 4618              	.LVL330:
 4619 295c 30309DE5 		ldr	r3, [sp, #48]
 4620 2960 ADFEFFEA 		b	.L299
 4621              	.L323:
 4622              	.LVL331:
2510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4623              		.loc 1 2510 0
 4624 2964 0200A0E3 		mov	r0, #2
 4625 2968 FEFFFFEB 		bl	CTControlHandle
 4626              	.LVL332:
 4627 296c 30309DE5 		ldr	r3, [sp, #48]
 4628 2970 A9FEFFEA 		b	.L299
 4629              	.L324:
 4630              	.LVL333:
2515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4631              		.loc 1 2515 0
 4632 2974 0300A0E3 		mov	r0, #3
 4633 2978 FEFFFFEB 		bl	CTControlHandle
 4634              	.LVL334:
 4635 297c 30309DE5 		ldr	r3, [sp, #48]
 4636 2980 A5FEFFEA 		b	.L299
 4637              	.L435:
 4638              	.LVL335:
 4639              	.LBE95:
 4640              	.LBE135:
 4641              	.LBB136:
 4642              	.LBB89:
2431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4643              		.loc 1 2431 0
 4644 2984 0100A0E3 		mov	r0, #1
 4645 2988 FEFFFFEB 		bl	ControlHandle
 4646              	.LVL336:
 4647 298c 30309DE5 		ldr	r3, [sp, #48]
 4648 2990 A1FEFFEA 		b	.L299
 4649              	.L307:
 4650              	.LVL337:
2427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4651              		.loc 1 2427 0
 4652 2994 0000A0E3 		mov	r0, #0
 4653 2998 FEFFFFEB 		bl	ControlHandle
 4654              	.LVL338:
 4655 299c 30309DE5 		ldr	r3, [sp, #48]
 4656 29a0 9DFEFFEA 		b	.L299
 4657              	.LVL339:
 4658              	.L439:
 4659              	.LBE89:
 4660              	.LBE136:
3231:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4661              		.loc 1 3231 0
 4662 29a4 0400A0E3 		mov	r0, #4
 4663              	.LVL340:
 4664 29a8 C4139FE5 		ldr	r1, .L442+76
 4665 29ac FEFFFFEB 		bl	CyU3PDebugPrint
 4666              	.LVL341:
 4667              	.L418:
 4668              	.LBB137:
 4669              	.LBB138:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4670              		.loc 1 1244 0
 4671 29b0 C0139FE5 		ldr	r1, .L442+80
 4672 29b4 0400A0E3 		mov	r0, #4
 4673 29b8 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 4674              		.loc 1 1245 0
 4675 29bc FA0FA0E3 		mov	r0, #1000
 4676 29c0 FEFFFFEB 		bl	_tx_thread_sleep
 4677 29c4 F9FFFFEA 		b	.L418
 4678              	.LVL342:
 4679              	.L402:
 4680              	.LBE138:
 4681              	.LBE137:
 4682              	.LBB139:
 4683              	.LBB105:
2975:../uvc.c      ****                 switch (bRequest)
 4684              		.loc 1 2975 0
 4685 29c8 85005BE3 		cmp	fp, #133
 4686 29cc CBFFFF0A 		beq	.L400
 4687 29d0 86005BE3 		cmp	fp, #134
 4688 29d4 95FEFF1A 		bne	.L363
 4689              	.L426:
2979:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4690              		.loc 1 2979 0
 4691 29d8 0300A0E1 		mov	r0, r3
 4692              	.L421:
2873:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4693              		.loc 1 2873 0
 4694 29dc 0330A0E3 		mov	r3, #3
2874:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4695              		.loc 1 2874 0
 4696 29e0 88139FE5 		ldr	r1, .L442+72
2873:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4697              		.loc 1 2873 0
 4698 29e4 5830C4E5 		strb	r3, [r4, #88]
2874:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4699              		.loc 1 2874 0
 4700 29e8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4701 29ec 30309DE5 		ldr	r3, [sp, #48]
 4702 29f0 93FEFFEA 		b	.L361
 4703              	.L440:
2926:../uvc.c      ****                 switch (bRequest)
 4704              		.loc 1 2926 0
 4705 29f4 010052E3 		cmp	r2, #1
 4706 29f8 03FFFF1A 		bne	.L388
2951:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4707              		.loc 1 2951 0
 4708 29fc 2000A0E3 		mov	r0, #32
 4709 2a00 4C139FE5 		ldr	r1, .L442+44
 4710 2a04 36208DE2 		add	r2, sp, #54
 4711 2a08 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4712              	.LVL343:
2953:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4713              		.loc 1 2953 0
 4714 2a0c 000050E3 		cmp	r0, #0
 4715 2a10 8AFEFF1A 		bne	.L423
2955:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4716              		.loc 1 2955 0
 4717 2a14 48B0D5E5 		ldrb	fp, [r5, #72]	@ zero_extendqisi2
 4718 2a18 03005BE3 		cmp	fp, #3
 4719 2a1c 87FEFF1A 		bne	.L423
2964:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4720              		.loc 1 2964 0
 4721 2a20 7E30D5E5 		ldrb	r3, [r5, #126]	@ zero_extendqisi2
2959:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4722              		.loc 1 2959 0
 4723 2a24 79E0D5E5 		ldrb	lr, [r5, #121]	@ zero_extendqisi2
2960:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4724              		.loc 1 2960 0
 4725 2a28 7AC0D5E5 		ldrb	ip, [r5, #122]	@ zero_extendqisi2
2961:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4726              		.loc 1 2961 0
 4727 2a2c 7B00D5E5 		ldrb	r0, [r5, #123]	@ zero_extendqisi2
 4728              	.LVL344:
2962:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4729              		.loc 1 2962 0
 4730 2a30 7C10D5E5 		ldrb	r1, [r5, #124]	@ zero_extendqisi2
2963:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4731              		.loc 1 2963 0
 4732 2a34 7D20D5E5 		ldrb	r2, [r5, #125]	@ zero_extendqisi2
2964:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4733              		.loc 1 2964 0
 4734 2a38 5236C6E5 		strb	r3, [r6, #1618]
2959:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4735              		.loc 1 2959 0
 4736 2a3c 4DE6C6E5 		strb	lr, [r6, #1613]
2960:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4737              		.loc 1 2960 0
 4738 2a40 4EC6C6E5 		strb	ip, [r6, #1614]
2961:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4739              		.loc 1 2961 0
 4740 2a44 4F06C6E5 		strb	r0, [r6, #1615]
2962:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4741              		.loc 1 2962 0
 4742 2a48 5016C6E5 		strb	r1, [r6, #1616]
2963:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4743              		.loc 1 2963 0
 4744 2a4c 5126C6E5 		strb	r2, [r6, #1617]
2964:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4745              		.loc 1 2964 0
 4746 2a50 30309DE5 		ldr	r3, [sp, #48]
 4747 2a54 7AFEFFEA 		b	.L361
 4748              	.LVL345:
 4749              	.L393:
2926:../uvc.c      ****                 switch (bRequest)
 4750              		.loc 1 2926 0
 4751 2a58 860052E3 		cmp	r2, #134
 4752 2a5c DDFFFF0A 		beq	.L426
 4753 2a60 870052E3 		cmp	r2, #135
 4754 2a64 A3FFFF1A 		bne	.L432
 4755 2a68 63FFFFEA 		b	.L399
 4756              	.LVL346:
 4757              	.L321:
 4758              	.LBE105:
 4759              	.LBE139:
 4760              	.LBB140:
 4761              	.LBB100:
2502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4762              		.loc 1 2502 0
 4763 2a6c 0000A0E3 		mov	r0, #0
 4764 2a70 FEFFFFEB 		bl	CTControlHandle
 4765              	.LVL347:
 4766 2a74 30309DE5 		ldr	r3, [sp, #48]
 4767 2a78 67FEFFEA 		b	.L299
 4768              	.LVL348:
 4769              	.L437:
 4770              	.LBE100:
 4771              	.LBE140:
3207:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4772              		.loc 1 3207 0
 4773 2a7c 0400A0E3 		mov	r0, #4
 4774              	.LVL349:
 4775 2a80 EC129FE5 		ldr	r1, .L442+76
 4776 2a84 FEFFFFEB 		bl	CyU3PDebugPrint
 4777              	.LVL350:
 4778              	.L416:
 4779              	.LBB141:
 4780              	.LBB142:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4781              		.loc 1 1244 0
 4782 2a88 E8129FE5 		ldr	r1, .L442+80
 4783 2a8c 0400A0E3 		mov	r0, #4
 4784 2a90 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 4785              		.loc 1 1245 0
 4786 2a94 FA0FA0E3 		mov	r0, #1000
 4787 2a98 FEFFFFEB 		bl	_tx_thread_sleep
 4788 2a9c F9FFFFEA 		b	.L416
 4789              	.LVL351:
 4790              	.L384:
 4791              	.LBE142:
 4792              	.LBE141:
 4793              	.LBB143:
 4794              	.LBB111:
2870:../uvc.c      ****             switch (bRequest)
 4795              		.loc 1 2870 0
 4796 2aa0 850053E3 		cmp	r3, #133
 4797 2aa4 95FFFF0A 		beq	.L400
 4798 2aa8 860053E3 		cmp	r3, #134
 4799 2aac D6FEFF1A 		bne	.L388
 4800              	.L427:
2874:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4801              		.loc 1 2874 0
 4802 2ab0 0100A0E3 		mov	r0, #1
 4803 2ab4 C8FFFFEA 		b	.L421
 4804              	.LVL352:
 4805              	.L312:
 4806              	.LBE111:
 4807              	.LBE143:
 4808              	.LBB144:
 4809              	.LBB92:
2450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4810              		.loc 1 2450 0
 4811 2ab8 0600A0E3 		mov	r0, #6
 4812 2abc FEFFFFEB 		bl	ControlHandle
 4813              	.LVL353:
 4814 2ac0 30309DE5 		ldr	r3, [sp, #48]
 4815 2ac4 54FEFFEA 		b	.L299
 4816              	.L319:
2423:../uvc.c      ****     switch (wValue)
 4817              		.loc 1 2423 0
 4818 2ac8 0D0C52E3 		cmp	r2, #3328
 4819 2acc 0700000A 		beq	.L314
 4820 2ad0 0E0C52E3 		cmp	r2, #3584
 4821 2ad4 0900000A 		beq	.L316
 4822 2ad8 030B52E3 		cmp	r2, #3072
 4823 2adc 45FEFF1A 		bne	.L320
 4824              	.LVL354:
2464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4825              		.loc 1 2464 0
 4826 2ae0 0B00A0E3 		mov	r0, #11
 4827 2ae4 FEFFFFEB 		bl	ControlHandle
 4828              	.LVL355:
 4829 2ae8 30309DE5 		ldr	r3, [sp, #48]
 4830 2aec 4AFEFFEA 		b	.L299
 4831              	.L314:
 4832              	.LVL356:
2460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4833              		.loc 1 2460 0
 4834 2af0 0900A0E3 		mov	r0, #9
 4835 2af4 FEFFFFEB 		bl	ControlHandle
 4836              	.LVL357:
 4837 2af8 30309DE5 		ldr	r3, [sp, #48]
 4838 2afc 46FEFFEA 		b	.L299
 4839              	.L316:
 4840              	.LVL358:
2468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4841              		.loc 1 2468 0
 4842 2b00 0E00A0E3 		mov	r0, #14
 4843 2b04 FEFFFFEB 		bl	ControlHandle
 4844              	.LVL359:
 4845 2b08 30309DE5 		ldr	r3, [sp, #48]
 4846 2b0c 42FEFFEA 		b	.L299
 4847              	.L318:
2423:../uvc.c      ****     switch (wValue)
 4848              		.loc 1 2423 0
 4849 2b10 010B52E3 		cmp	r2, #1024
 4850 2b14 40FEFF0A 		beq	.L299
 4851 2b18 050C52E3 		cmp	r2, #1280
 4852 2b1c 35FEFF1A 		bne	.L320
 4853              	.LVL360:
2442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4854              		.loc 1 2442 0
 4855 2b20 0400A0E3 		mov	r0, #4
 4856 2b24 FEFFFFEB 		bl	ControlHandle
 4857              	.LVL361:
 4858 2b28 30309DE5 		ldr	r3, [sp, #48]
 4859 2b2c 3AFEFFEA 		b	.L299
 4860              	.L309:
 4861              	.LVL362:
2435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4862              		.loc 1 2435 0
 4863 2b30 0200A0E3 		mov	r0, #2
 4864 2b34 FEFFFFEB 		bl	ControlHandle
 4865              	.LVL363:
 4866 2b38 30309DE5 		ldr	r3, [sp, #48]
 4867 2b3c 36FEFFEA 		b	.L299
 4868              	.L311:
 4869              	.LVL364:
2446:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4870              		.loc 1 2446 0
 4871 2b40 0500A0E3 		mov	r0, #5
 4872 2b44 FEFFFFEB 		bl	ControlHandle
 4873              	.LVL365:
 4874 2b48 30309DE5 		ldr	r3, [sp, #48]
 4875 2b4c 32FEFFEA 		b	.L299
 4876              	.LVL366:
 4877              	.L411:
 4878              	.LBE92:
 4879              	.LBE144:
 4880              	.LBB145:
 4881              	.LBB104:
3030:../uvc.c      ****                 switch (bRequest)
 4882              		.loc 1 3030 0
 4883 2b50 850052E3 		cmp	r2, #133
 4884 2b54 4E00000A 		beq	.L409
 4885 2b58 860052E3 		cmp	r2, #134
 4886 2b5c 33FEFF1A 		bne	.L363
 4887 2b60 D2FFFFEA 		b	.L427
 4888              	.LVL367:
 4889              	.L357:
 4890              	.LBE104:
 4891              	.LBE145:
 4892              	.LBB146:
 4893              	.LBB122:
2723:../uvc.c      ****     switch (wValue)
 4894              		.loc 1 2723 0
 4895 2b64 060C52E3 		cmp	r2, #1536
 4896 2b68 4500000A 		beq	.L344
 4897 2b6c 0900008A 		bhi	.L358
 4898 2b70 050C52E3 		cmp	r2, #1280
 4899 2b74 23FEFF1A 		bne	.L300
 4900              	.LVL368:
2743:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4901              		.loc 1 2743 0
 4902 2b78 1400A0E3 		mov	r0, #20
 4903 2b7c FEFFFFEB 		bl	ControlHandle
 4904              	.LVL369:
 4905 2b80 30309DE5 		ldr	r3, [sp, #48]
 4906 2b84 24FEFFEA 		b	.L299
 4907              	.L327:
 4908              	.LVL370:
 4909              	.LBE122:
 4910              	.LBE146:
 4911              	.LBB147:
 4912              	.LBB94:
2528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 4913              		.loc 1 2528 0
 4914 2b88 0600A0E3 		mov	r0, #6
 4915 2b8c FEFFFFEB 		bl	CTControlHandle
 4916              	.LVL371:
 4917 2b90 30309DE5 		ldr	r3, [sp, #48]
 4918 2b94 20FEFFEA 		b	.L299
 4919              	.L358:
 4920              	.LBE94:
 4921              	.LBE147:
 4922              	.LBB148:
 4923              	.LBB117:
2723:../uvc.c      ****     switch (wValue)
 4924              		.loc 1 2723 0
 4925 2b98 070C52E3 		cmp	r2, #1792
 4926 2b9c 3400000A 		beq	.L345
 4927 2ba0 020B52E3 		cmp	r2, #2048
 4928 2ba4 17FEFF1A 		bne	.L300
 4929              	.LVL372:
2755:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 4930              		.loc 1 2755 0
 4931 2ba8 1700A0E3 		mov	r0, #23
 4932 2bac FEFFFFEB 		bl	ControlHandle
 4933              	.LVL373:
 4934 2bb0 30309DE5 		ldr	r3, [sp, #48]
 4935 2bb4 18FEFFEA 		b	.L299
 4936              	.L334:
 4937              	.LBE117:
 4938              	.LBE148:
 4939              	.LBB149:
 4940              	.LBB101:
2498:../uvc.c      ****     switch (wValue)
 4941              		.loc 1 2498 0
 4942 2bb8 0B0C52E3 		cmp	r2, #2816
 4943 2bbc 0F00000A 		beq	.L330
 4944 2bc0 030B52E3 		cmp	r2, #3072
 4945 2bc4 0900000A 		beq	.L331
 4946 2bc8 0A0C52E3 		cmp	r2, #2560
 4947 2bcc 09FEFF1A 		bne	.L320
 4948              	.LVL374:
2539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 4949              		.loc 1 2539 0
 4950 2bd0 0800A0E3 		mov	r0, #8
 4951 2bd4 FEFFFFEB 		bl	CTControlHandle
 4952              	.LVL375:
 4953 2bd8 30309DE5 		ldr	r3, [sp, #48]
 4954 2bdc 0EFEFFEA 		b	.L299
 4955              	.L328:
 4956              	.LVL376:
2534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 4957              		.loc 1 2534 0
 4958 2be0 0700A0E3 		mov	r0, #7
 4959 2be4 FEFFFFEB 		bl	CTControlHandle
 4960              	.LVL377:
 4961 2be8 30309DE5 		ldr	r3, [sp, #48]
 4962 2bec 0AFEFFEA 		b	.L299
 4963              	.L331:
 4964              	.LVL378:
2547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 4965              		.loc 1 2547 0
 4966 2bf0 0A00A0E3 		mov	r0, #10
 4967 2bf4 FEFFFFEB 		bl	CTControlHandle
 4968              	.LVL379:
 4969 2bf8 30309DE5 		ldr	r3, [sp, #48]
 4970 2bfc 06FEFFEA 		b	.L299
 4971              	.L330:
 4972              	.LVL380:
2543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 4973              		.loc 1 2543 0
 4974 2c00 0900A0E3 		mov	r0, #9
 4975 2c04 FEFFFFEB 		bl	CTControlHandle
 4976              	.LVL381:
 4977 2c08 30309DE5 		ldr	r3, [sp, #48]
 4978 2c0c 02FEFFEA 		b	.L299
 4979              	.L353:
 4980              	.LVL382:
 4981              	.LBE101:
 4982              	.LBE149:
 4983              	.LBB150:
 4984              	.LBB123:
2790:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 4985              		.loc 1 2790 0
 4986 2c10 2400A0E3 		mov	r0, #36
 4987 2c14 FEFFFFEB 		bl	ControlHandle
 4988              	.LVL383:
 4989 2c18 30309DE5 		ldr	r3, [sp, #48]
 4990 2c1c FEFDFFEA 		b	.L299
 4991              	.LVL384:
 4992              	.L438:
 4993              	.LBE123:
 4994              	.LBE150:
 4995              	.LBB151:
 4996              	.LBB112:
2895:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4997              		.loc 1 2895 0
 4998 2c20 2000A0E3 		mov	r0, #32
 4999 2c24 28119FE5 		ldr	r1, .L442+44
 5000 2c28 36208DE2 		add	r2, sp, #54
 5001 2c2c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5002              	.LVL385:
2897:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5003              		.loc 1 2897 0
 5004 2c30 000050E3 		cmp	r0, #0
 5005 2c34 01FEFF1A 		bne	.L423
2910:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5006              		.loc 1 2910 0
 5007 2c38 0020A0E3 		mov	r2, #0
 5008 2c3c E4009FE5 		ldr	r0, .L442
 5009              	.LVL386:
 5010 2c40 0110A0E3 		mov	r1, #1
 5011 2c44 FEFFFFEB 		bl	_txe_event_flags_set
 5012              	.LVL387:
2911:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5013              		.loc 1 2911 0
 5014 2c48 002050E2 		subs	r2, r0, #0
 5015 2c4c FBFDFF0A 		beq	.L423
 5016              	.L405:
3018:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5017              		.loc 1 3018 0
 5018 2c50 0400A0E3 		mov	r0, #4
 5019              	.LVL388:
 5020 2c54 20119FE5 		ldr	r1, .L442+84
 5021 2c58 FEFFFFEB 		bl	CyU3PDebugPrint
 5022              	.LVL389:
 5023 2c5c 30309DE5 		ldr	r3, [sp, #48]
 5024 2c60 F7FDFFEA 		b	.L361
 5025              	.L341:
 5026              	.LVL390:
 5027              	.LBE112:
 5028              	.LBE151:
 5029              	.LBB152:
 5030              	.LBB116:
2735:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5031              		.loc 1 2735 0
 5032 2c64 1200A0E3 		mov	r0, #18
 5033 2c68 FEFFFFEB 		bl	ControlHandle
 5034              	.LVL391:
 5035 2c6c 30309DE5 		ldr	r3, [sp, #48]
 5036 2c70 E9FDFFEA 		b	.L299
 5037              	.L345:
 5038              	.LVL392:
2751:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5039              		.loc 1 2751 0
 5040 2c74 1600A0E3 		mov	r0, #22
 5041 2c78 FEFFFFEB 		bl	ControlHandle
 5042              	.LVL393:
 5043 2c7c 30309DE5 		ldr	r3, [sp, #48]
 5044 2c80 E5FDFFEA 		b	.L299
 5045              	.L344:
 5046              	.LVL394:
2747:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5047              		.loc 1 2747 0
 5048 2c84 1500A0E3 		mov	r0, #21
 5049 2c88 FEFFFFEB 		bl	ControlHandle
 5050              	.LVL395:
 5051 2c8c 30309DE5 		ldr	r3, [sp, #48]
 5052 2c90 E1FDFFEA 		b	.L299
 5053              	.LVL396:
 5054              	.L409:
 5055              	.LBE116:
 5056              	.LBE152:
 5057              	.LBB153:
 5058              	.LBB103:
3039:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5059              		.loc 1 3039 0
 5060 2c94 0200A0E3 		mov	r0, #2
 5061 2c98 D0109FE5 		ldr	r1, .L442+72
 5062 2c9c 1AFFFFEA 		b	.L424
 5063              	.LVL397:
 5064              	.L354:
 5065              	.LBE103:
 5066              	.LBE153:
 5067              	.LBB154:
 5068              	.LBB124:
2794:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 5069              		.loc 1 2794 0
 5070 2ca0 2500A0E3 		mov	r0, #37
 5071 2ca4 FEFFFFEB 		bl	ControlHandle
 5072              	.LVL398:
 5073 2ca8 30309DE5 		ldr	r3, [sp, #48]
 5074 2cac DAFDFFEA 		b	.L299
 5075              	.L350:
 5076              	.LVL399:
2774:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5077              		.loc 1 2774 0
 5078 2cb0 1C00A0E3 		mov	r0, #28
 5079 2cb4 FEFFFFEB 		bl	ControlHandle
 5080              	.LVL400:
 5081 2cb8 30309DE5 		ldr	r3, [sp, #48]
 5082 2cbc D6FDFFEA 		b	.L299
 5083              	.L349:
 5084              	.LVL401:
2770:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5085              		.loc 1 2770 0
 5086 2cc0 1A00A0E3 		mov	r0, #26
 5087 2cc4 FEFFFFEB 		bl	ControlHandle
 5088              	.LVL402:
 5089 2cc8 30309DE5 		ldr	r3, [sp, #48]
 5090 2ccc D2FDFFEA 		b	.L299
 5091              	.L351:
 5092              	.LVL403:
2782:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5093              		.loc 1 2782 0
 5094 2cd0 1E00A0E3 		mov	r0, #30
 5095 2cd4 FEFFFFEB 		bl	ControlHandle
 5096              	.LVL404:
 5097 2cd8 30309DE5 		ldr	r3, [sp, #48]
 5098 2cdc CEFDFFEA 		b	.L299
 5099              	.L340:
 5100              	.LVL405:
2731:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5101              		.loc 1 2731 0
 5102 2ce0 1100A0E3 		mov	r0, #17
 5103 2ce4 FEFFFFEB 		bl	ControlHandle
 5104              	.LVL406:
 5105 2ce8 30309DE5 		ldr	r3, [sp, #48]
 5106 2cec CAFDFFEA 		b	.L299
 5107              	.L347:
 5108              	.LVL407:
2759:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5109              		.loc 1 2759 0
 5110 2cf0 1800A0E3 		mov	r0, #24
 5111 2cf4 FEFFFFEB 		bl	ControlHandle
 5112              	.LVL408:
 5113 2cf8 30309DE5 		ldr	r3, [sp, #48]
 5114 2cfc C6FDFFEA 		b	.L299
 5115              	.L342:
 5116              	.LVL409:
2739:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5117              		.loc 1 2739 0
 5118 2d00 1300A0E3 		mov	r0, #19
 5119 2d04 FEFFFFEB 		bl	ControlHandle
 5120              	.LVL410:
 5121 2d08 30309DE5 		ldr	r3, [sp, #48]
 5122 2d0c C2FDFFEA 		b	.L299
 5123              	.LVL411:
 5124              	.L413:
 5125              	.LBE124:
 5126              	.LBE154:
 5127              	.LBB155:
 5128              	.LBB113:
3069:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5129              		.loc 1 3069 0
 5130 2d10 68109FE5 		ldr	r1, .L442+88
 5131 2d14 B623DDE1 		ldrh	r2, [sp, #54]
 5132 2d18 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 5133 2d1c 0400A0E3 		mov	r0, #4
 5134              	.LVL412:
 5135 2d20 FEFFFFEB 		bl	CyU3PDebugPrint
 5136 2d24 C1FDFFEA 		b	.L363
 5137              	.L443:
 5138              		.align	2
 5139              	.L442:
 5140 2d28 00000000 		.word	.LANCHOR0
 5141 2d2c 00000000 		.word	.LANCHOR1
 5142 2d30 00000000 		.word	bRequest
 5143 2d34 00000000 		.word	wValue
 5144 2d38 00000000 		.word	wIndex
 5145 2d3c 00000000 		.word	glInterStaBuffer
 5146 2d40 DC040000 		.word	.LC27
 5147 2d44 00000000 		.word	glChHandleInterStat
 5148 2d48 00000000 		.word	bmReqType
 5149 2d4c 00000000 		.word	wLength
 5150 2d50 60040000 		.word	.LC26
 5151 2d54 78000000 		.word	.LANCHOR0+120
 5152 2d58 70050000 		.word	.LC30
 5153 2d5c 08050000 		.word	.LC28
 5154 2d60 4C060000 		.word	.LANCHOR1+1612
 5155 2d64 58060000 		.word	.LANCHOR1+1624
 5156 2d68 14060000 		.word	.LANCHOR1+1556
 5157 2d6c 30060000 		.word	.LANCHOR1+1584
 5158 2d70 58000000 		.word	.LANCHOR0+88
 5159 2d74 C0050000 		.word	.LC32
 5160 2d78 D4010000 		.word	.LC12
 5161 2d7c 48050000 		.word	.LC29
 5162 2d80 98050000 		.word	.LC31
 5163              	.LBE113:
 5164              	.LBE155:
 5165              		.cfi_endproc
 5166              	.LFE24:
 5168              		.align	2
 5169              		.global	CamDefSet
 5171              	CamDefSet:
 5172              	.LFB4:
1141:../uvc.c      **** {
 5173              		.loc 1 1141 0
 5174              		.cfi_startproc
 5175              		@ args = 0, pretend = 0, frame = 24
 5176              		@ frame_needed = 0, uses_anonymous_args = 0
 5177              	.LVL413:
 5178 2d84 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5179              	.LCFI19:
 5180              		.cfi_def_cfa_offset 36
1147:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5181              		.loc 1 1147 0
 5182 2d88 AC429FE5 		ldr	r4, .L447
 5183              		.cfi_offset 14, -4
 5184              		.cfi_offset 11, -8
 5185              		.cfi_offset 10, -12
 5186              		.cfi_offset 9, -16
 5187              		.cfi_offset 8, -20
 5188              		.cfi_offset 7, -24
 5189              		.cfi_offset 6, -28
 5190              		.cfi_offset 5, -32
 5191              		.cfi_offset 4, -36
1152:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5192              		.loc 1 1152 0
 5193 2d8c AC229FE5 		ldr	r2, .L447+4
1149:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5194              		.loc 1 1149 0
 5195 2d90 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1141:../uvc.c      **** {
 5196              		.loc 1 1141 0
 5197 2d94 2CD04DE2 		sub	sp, sp, #44
 5198              	.LCFI20:
 5199              		.cfi_def_cfa_offset 80
1152:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5200              		.loc 1 1152 0
 5201 2d98 1C0092E5 		ldr	r0, [r2, #28]
 5202 2d9c 0010E0E3 		mvn	r1, #0
1154:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5203              		.loc 1 1154 0
 5204 2da0 2963A0E1 		mov	r6, r9, lsr #6
1148:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5205              		.loc 1 1148 0
 5206 2da4 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1147:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5207              		.loc 1 1147 0
 5208 2da8 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5209              	.LVL414:
1152:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5210              		.loc 1 1152 0
 5211 2dac FEFFFFEB 		bl	_txe_mutex_get
1153:../uvc.c      ****     if(Data1&0x80){
 5212              		.loc 1 1153 0
 5213 2db0 800019E3 		tst	r9, #128
1154:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5214              		.loc 1 1154 0
 5215 2db4 01600612 		andne	r6, r6, #1
 5216 2db8 0660E011 		mvnne	r6, r6
 5217 2dbc 3B600612 		andne	r6, r6, #59
 5218 2dc0 0660E011 		mvnne	r6, r6
 5219 2dc4 FF600612 		andne	r6, r6, #255
 5220              	.LVL415:
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5221              		.loc 1 1156 0
 5222 2dc8 C6608603 		orreq	r6, r6, #198
 5223              	.LVL416:
1160:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5224              		.loc 1 1160 0
 5225 2dcc 0080A0E3 		mov	r8, #0
 5226 2dd0 0A20A0E1 		mov	r2, sl
 5227 2dd4 0730A0E1 		mov	r3, r7
 5228 2dd8 0110A0E3 		mov	r1, #1
1158:../uvc.c      ****     Data0 = (Data0 << 2);
 5229              		.loc 1 1158 0
 5230 2ddc 0951A0E1 		mov	r5, r9, asl #2
1160:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5231              		.loc 1 1160 0
 5232 2de0 58029FE5 		ldr	r0, .L447+4
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5233              		.loc 1 1163 0
 5234 2de4 0190A0E3 		mov	r9, #1
 5235              	.LVL417:
1158:../uvc.c      ****     Data0 = (Data0 << 2);
 5236              		.loc 1 1158 0
 5237 2de8 FF5005E2 		and	r5, r5, #255
 5238              	.LVL418:
1160:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5239              		.loc 1 1160 0
 5240 2dec 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5241 2df0 FEFFFFEB 		bl	cmdSet
 5242              	.LVL419:
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5243              		.loc 1 1163 0
 5244 2df4 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5245 2df8 0910A0E1 		mov	r1, r9
 5246 2dfc 0730A0E1 		mov	r3, r7
 5247 2e00 38029FE5 		ldr	r0, .L447+4
 5248 2e04 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5249 2e08 FEFFFFEB 		bl	cmdSet
 5250              	.LVL420:
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5251              		.loc 1 1166 0
 5252 2e0c 0620A0E1 		mov	r2, r6
 5253 2e10 0530A0E1 		mov	r3, r5
 5254 2e14 28129FE5 		ldr	r1, .L447+8
 5255 2e18 0400A0E3 		mov	r0, #4
1165:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5256              		.loc 1 1165 0
 5257 2e1c A661C4E5 		strb	r6, [r4, #422]
1164:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5258              		.loc 1 1164 0
 5259 2e20 A551C4E5 		strb	r5, [r4, #421]
1166:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5260              		.loc 1 1166 0
 5261 2e24 FEFFFFEB 		bl	CyU3PDebugPrint
 5262              	.LVL421:
1171:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5263              		.loc 1 1171 0
 5264 2e28 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5265              	.LVL422:
1172:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5266              		.loc 1 1172 0
 5267 2e2c B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5268 2e30 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5269 2e34 0210A0E3 		mov	r1, #2
 5270 2e38 00029FE5 		ldr	r0, .L447+4
 5271 2e3c 00B08DE5 		str	fp, [sp, #0]
 5272 2e40 04808DE5 		str	r8, [sp, #4]
 5273 2e44 FEFFFFEB 		bl	cmdSet
 5274              	.LVL423:
1174:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5275              		.loc 1 1174 0
 5276 2e48 0B20A0E1 		mov	r2, fp
 5277 2e4c 0530A0E1 		mov	r3, r5
 5278 2e50 EC119FE5 		ldr	r1, .L447+8
 5279 2e54 0400A0E3 		mov	r0, #4
1173:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5280              		.loc 1 1173 0
 5281 2e58 BD51C4E5 		strb	r5, [r4, #445]
1174:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5282              		.loc 1 1174 0
 5283 2e5c FEFFFFEB 		bl	CyU3PDebugPrint
 5284              	.LVL424:
1179:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5285              		.loc 1 1179 0
 5286 2e60 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1178:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5287              		.loc 1 1178 0
 5288 2e64 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5289              	.LVL425:
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5290              		.loc 1 1180 0
 5291 2e68 80B047E2 		sub	fp, r7, #128
 5292 2e6c FF100BE2 		and	r1, fp, #255
 5293 2e70 14108DE5 		str	r1, [sp, #20]
 5294 2e74 14C09DE5 		ldr	ip, [sp, #20]
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5295              		.loc 1 1181 0
 5296 2e78 760047E2 		sub	r0, r7, #118
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5297              		.loc 1 1182 0
 5298 2e7c 7EE087E2 		add	lr, r7, #126
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5299              		.loc 1 1180 0
 5300 2e80 0630A0E1 		mov	r3, r6
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5301              		.loc 1 1181 0
 5302 2e84 18008DE5 		str	r0, [sp, #24]
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5303              		.loc 1 1180 0
 5304 2e88 0510A0E3 		mov	r1, #5
 5305 2e8c DF20A0E3 		mov	r2, #223
 5306 2e90 A8019FE5 		ldr	r0, .L447+4
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5307              		.loc 1 1182 0
 5308 2e94 1CE08DE5 		str	lr, [sp, #28]
1180:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5309              		.loc 1 1180 0
 5310 2e98 00C08DE5 		str	ip, [sp, #0]
 5311 2e9c 04808DE5 		str	r8, [sp, #4]
 5312 2ea0 FEFFFFEB 		bl	cmdSet
 5313              	.LVL426:
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5314              		.loc 1 1181 0
 5315 2ea4 18A09DE5 		ldr	sl, [sp, #24]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5316              		.loc 1 1183 0
 5317 2ea8 72E087E2 		add	lr, r7, #114
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5318              		.loc 1 1181 0
 5319 2eac FFC00AE2 		and	ip, sl, #255
 5320 2eb0 0630A0E1 		mov	r3, r6
 5321 2eb4 0510A0E3 		mov	r1, #5
 5322 2eb8 DC20A0E3 		mov	r2, #220
 5323 2ebc 7C019FE5 		ldr	r0, .L447+4
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5324              		.loc 1 1183 0
 5325 2ec0 20E08DE5 		str	lr, [sp, #32]
1181:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5326              		.loc 1 1181 0
 5327 2ec4 00C08DE5 		str	ip, [sp, #0]
 5328 2ec8 04908DE5 		str	r9, [sp, #4]
 5329 2ecc FEFFFFEB 		bl	cmdSet
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5330              		.loc 1 1182 0
 5331 2ed0 1C009DE5 		ldr	r0, [sp, #28]
 5332 2ed4 02E0A0E3 		mov	lr, #2
 5333 2ed8 FFC000E2 		and	ip, r0, #255
 5334 2edc 0630A0E1 		mov	r3, r6
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5335              		.loc 1 1184 0
 5336 2ee0 6FA047E2 		sub	sl, r7, #111
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5337              		.loc 1 1182 0
 5338 2ee4 0510A0E3 		mov	r1, #5
 5339 2ee8 DE20A0E3 		mov	r2, #222
 5340 2eec 4C019FE5 		ldr	r0, .L447+4
 5341 2ef0 04E08DE5 		str	lr, [sp, #4]
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5342              		.loc 1 1184 0
 5343 2ef4 24A08DE5 		str	sl, [sp, #36]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5344              		.loc 1 1182 0
 5345 2ef8 00C08DE5 		str	ip, [sp, #0]
 5346 2efc FEFFFFEB 		bl	cmdSet
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5347              		.loc 1 1183 0
 5348 2f00 20A09DE5 		ldr	sl, [sp, #32]
 5349 2f04 0630A0E1 		mov	r3, r6
 5350 2f08 FFC00AE2 		and	ip, sl, #255
 5351 2f0c 00C08DE5 		str	ip, [sp, #0]
 5352 2f10 0510A0E3 		mov	r1, #5
 5353 2f14 03C0A0E3 		mov	ip, #3
 5354 2f18 E020A0E3 		mov	r2, #224
 5355 2f1c 1C019FE5 		ldr	r0, .L447+4
 5356 2f20 04C08DE5 		str	ip, [sp, #4]
 5357 2f24 FEFFFFEB 		bl	cmdSet
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5358              		.loc 1 1184 0
 5359 2f28 24009DE5 		ldr	r0, [sp, #36]
 5360 2f2c 04A0A0E3 		mov	sl, #4
 5361 2f30 FFC000E2 		and	ip, r0, #255
 5362 2f34 0630A0E1 		mov	r3, r6
 5363 2f38 0510A0E3 		mov	r1, #5
 5364 2f3c DD20A0E3 		mov	r2, #221
 5365 2f40 F8009FE5 		ldr	r0, .L447+4
 5366 2f44 00C08DE5 		str	ip, [sp, #0]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5367              		.loc 1 1185 0
 5368 2f48 7F7087E2 		add	r7, r7, #127
 5369              	.LVL427:
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5370              		.loc 1 1184 0
 5371 2f4c 04A08DE5 		str	sl, [sp, #4]
 5372 2f50 FEFFFFEB 		bl	cmdSet
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5373              		.loc 1 1185 0
 5374 2f54 05E0A0E3 		mov	lr, #5
 5375 2f58 0E10A0E1 		mov	r1, lr
 5376 2f5c 0630A0E1 		mov	r3, r6
 5377 2f60 E120A0E3 		mov	r2, #225
 5378 2f64 FF6007E2 		and	r6, r7, #255
 5379              	.LVL428:
 5380 2f68 D0009FE5 		ldr	r0, .L447+4
 5381 2f6c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5382 2f70 FEFFFFEB 		bl	cmdSet
 5383              	.LVL429:
1186:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5384              		.loc 1 1186 0
 5385 2f74 14C09DE5 		ldr	ip, [sp, #20]
1187:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5386              		.loc 1 1187 0
 5387 2f78 24E09DE5 		ldr	lr, [sp, #36]
 5388 2f7c 1C609DE5 		ldr	r6, [sp, #28]
1186:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5389              		.loc 1 1186 0
 5390 2f80 05C2C4E5 		strb	ip, [r4, #517]
1187:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5391              		.loc 1 1187 0
 5392 2f84 20C09DE5 		ldr	ip, [sp, #32]
 5393 2f88 0B20A0E1 		mov	r2, fp
 5394 2f8c 18309DE5 		ldr	r3, [sp, #24]
 5395 2f90 B0109FE5 		ldr	r1, .L447+12
 5396 2f94 0A00A0E1 		mov	r0, sl
 5397 2f98 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5398 2f9c 0C708DE5 		str	r7, [sp, #12]
 5399 2fa0 FEFFFFEB 		bl	CyU3PDebugPrint
 5400              	.LVL430:
1191:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5401              		.loc 1 1191 0
 5402 2fa4 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5403              	.LVL431:
1192:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5404              		.loc 1 1192 0
 5405 2fa8 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5406              	.LVL432:
1193:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5407              		.loc 1 1193 0
 5408 2fac 0730A0E1 		mov	r3, r7
 5409 2fb0 0610A0E3 		mov	r1, #6
 5410 2fb4 8520A0E3 		mov	r2, #133
 5411 2fb8 80009FE5 		ldr	r0, .L447+4
 5412 2fbc 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5413 2fc0 FEFFFFEB 		bl	cmdSet
1194:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5414              		.loc 1 1194 0
 5415 2fc4 0730A0E1 		mov	r3, r7
 5416 2fc8 0610A0E3 		mov	r1, #6
 5417 2fcc 8620A0E3 		mov	r2, #134
 5418 2fd0 68009FE5 		ldr	r0, .L447+4
 5419 2fd4 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5420 2fd8 FEFFFFEB 		bl	cmdSet
1196:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5421              		.loc 1 1196 0
 5422 2fdc 0620A0E1 		mov	r2, r6
 5423 2fe0 0530A0E1 		mov	r3, r5
 5424 2fe4 58109FE5 		ldr	r1, .L447+8
 5425 2fe8 0A00A0E1 		mov	r0, sl
1195:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5426              		.loc 1 1195 0
 5427 2fec 1D62C4E5 		strb	r6, [r4, #541]
1196:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5428              		.loc 1 1196 0
 5429 2ff0 FEFFFFEB 		bl	CyU3PDebugPrint
 5430              	.LVL433:
1201:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5431              		.loc 1 1201 0
 5432 2ff4 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5433              	.LVL434:
1202:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5434              		.loc 1 1202 0
 5435 2ff8 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5436 2ffc 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5437 3000 0710A0E3 		mov	r1, #7
 5438 3004 34009FE5 		ldr	r0, .L447+4
 5439 3008 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5440 300c FEFFFFEB 		bl	cmdSet
 5441              	.LVL435:
1204:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5442              		.loc 1 1204 0
 5443 3010 0530A0E1 		mov	r3, r5
 5444 3014 0A00A0E1 		mov	r0, sl
 5445 3018 24109FE5 		ldr	r1, .L447+8
 5446 301c 0620A0E1 		mov	r2, r6
1203:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5447              		.loc 1 1203 0
 5448 3020 3552C4E5 		strb	r5, [r4, #565]
1204:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5449              		.loc 1 1204 0
 5450 3024 FEFFFFEB 		bl	CyU3PDebugPrint
1206:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5451              		.loc 1 1206 0
 5452 3028 10309FE5 		ldr	r3, .L447+4
 5453 302c 1C0093E5 		ldr	r0, [r3, #28]
1209:../uvc.c      **** }
 5454              		.loc 1 1209 0
 5455 3030 2CD08DE2 		add	sp, sp, #44
 5456 3034 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1206:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5457              		.loc 1 1206 0
 5458 3038 FEFFFFEA 		b	_txe_mutex_put
 5459              	.L448:
 5460              		.align	2
 5461              	.L447:
 5462 303c 00000000 		.word	.LANCHOR1
 5463 3040 00000000 		.word	cmdQu
 5464 3044 F4050000 		.word	.LC33
 5465 3048 14060000 		.word	.LC34
 5466              		.cfi_endproc
 5467              	.LFE4:
 5469              		.align	2
 5470              		.global	CyFxUVCAddHeader
 5472              	CyFxUVCAddHeader:
 5473              	.LFB5:
1217:../uvc.c      **** {
 5474              		.loc 1 1217 0
 5475              		.cfi_startproc
 5476              		@ args = 0, pretend = 0, frame = 0
 5477              		@ frame_needed = 0, uses_anonymous_args = 0
 5478              	.LVL436:
 5479 304c 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5480              	.LCFI21:
 5481              		.cfi_def_cfa_offset 16
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5482              		.loc 1 1219 0
 5483 3050 0C20A0E3 		mov	r2, #12
1217:../uvc.c      **** {
 5484              		.loc 1 1217 0
 5485 3054 0150A0E1 		mov	r5, r1
 5486              		.cfi_offset 14, -4
 5487              		.cfi_offset 5, -8
 5488              		.cfi_offset 4, -12
 5489              		.cfi_offset 3, -16
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5490              		.loc 1 1219 0
 5491 3058 18109FE5 		ldr	r1, .L451
 5492              	.LVL437:
1217:../uvc.c      **** {
 5493              		.loc 1 1217 0
 5494 305c 0040A0E1 		mov	r4, r0
1219:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5495              		.loc 1 1219 0
 5496 3060 FEFFFFEB 		bl	CyU3PMemCopy
 5497              	.LVL438:
1222:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5498              		.loc 1 1222 0
 5499 3064 020015E3 		tst	r5, #2
1224:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5500              		.loc 1 1224 0
 5501 3068 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5502 306c 02308313 		orrne	r3, r3, #2
 5503 3070 0130C415 		strneb	r3, [r4, #1]
 5504 3074 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5505              	.L452:
 5506              		.align	2
 5507              	.L451:
 5508 3078 80040000 		.word	.LANCHOR1+1152
 5509              		.cfi_endproc
 5510              	.LFE5:
 5512              		.align	2
 5513              		.global	CyFxAppErrorHandler
 5515              	CyFxAppErrorHandler:
 5516              	.LFB6:
1234:../uvc.c      **** {
 5517              		.loc 1 1234 0
 5518              		.cfi_startproc
 5519              		@ args = 0, pretend = 0, frame = 0
 5520              		@ frame_needed = 0, uses_anonymous_args = 0
 5521              	.LVL439:
 5522 307c 08402DE9 		stmfd	sp!, {r3, lr}
 5523              	.LCFI22:
 5524              		.cfi_def_cfa_offset 8
 5525              	.LVL440:
 5526              	.L454:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5527              		.loc 1 1244 0 discriminator 1
 5528 3080 10109FE5 		ldr	r1, .L455
 5529 3084 0400A0E3 		mov	r0, #4
 5530              		.cfi_offset 14, -4
 5531              		.cfi_offset 3, -8
 5532 3088 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 5533              		.loc 1 1245 0 discriminator 1
 5534 308c FA0FA0E3 		mov	r0, #1000
 5535 3090 FEFFFFEB 		bl	_tx_thread_sleep
 5536 3094 F9FFFFEA 		b	.L454
 5537              	.L456:
 5538              		.align	2
 5539              	.L455:
 5540 3098 D4010000 		.word	.LC12
 5541              		.cfi_endproc
 5542              	.LFE6:
 5544              		.align	2
 5545              		.global	UVCAppThread_Entry
 5547              	UVCAppThread_Entry:
 5548              	.LFB18:
2189:../uvc.c      **** {
 5549              		.loc 1 2189 0
 5550              		.cfi_startproc
 5551              		@ args = 0, pretend = 0, frame = 176
 5552              		@ frame_needed = 0, uses_anonymous_args = 0
 5553              	.LVL441:
 5554 309c F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5555              	.LCFI23:
 5556              		.cfi_def_cfa_offset 28
 5557 30a0 BCD04DE2 		sub	sp, sp, #188
 5558              	.LCFI24:
 5559              		.cfi_def_cfa_offset 216
 5560              	.LBB212:
 5561              	.LBB213:
1646:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5562              		.loc 1 1646 0
 5563              		.cfi_offset 14, -4
 5564              		.cfi_offset 10, -8
 5565              		.cfi_offset 8, -12
 5566              		.cfi_offset 7, -16
 5567              		.cfi_offset 6, -20
 5568              		.cfi_offset 5, -24
 5569              		.cfi_offset 4, -28
 5570 30a4 FEFFFFEB 		bl	CyU3PUartInit
 5571              	.LVL442:
1647:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5572              		.loc 1 1647 0
 5573 30a8 004050E2 		subs	r4, r0, #0
 5574 30ac 0400000A 		beq	.L458
1649:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5575              		.loc 1 1649 0
 5576 30b0 0400A0E3 		mov	r0, #4
 5577              	.LVL443:
 5578 30b4 A41A9FE5 		ldr	r1, .L552
 5579 30b8 FEFFFFEB 		bl	CyU3PDebugPrint
1650:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5580              		.loc 1 1650 0
 5581 30bc 0400A0E1 		mov	r0, r4
 5582 30c0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5583              	.L458:
1654:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5584              		.loc 1 1654 0
 5585 30c4 98CA9FE5 		ldr	ip, .L552+4
1656:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5586              		.loc 1 1656 0
 5587 30c8 0030A0E3 		mov	r3, #0
1655:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5588              		.loc 1 1655 0
 5589 30cc 0120A0E3 		mov	r2, #1
1663:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5590              		.loc 1 1663 0
 5591 30d0 50008DE2 		add	r0, sp, #80
 5592 30d4 0310A0E1 		mov	r1, r3
1654:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5593              		.loc 1 1654 0
 5594 30d8 60C08DE5 		str	ip, [sp, #96]
1655:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5595              		.loc 1 1655 0
 5596 30dc 6420CDE5 		strb	r2, [sp, #100]
1656:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5597              		.loc 1 1656 0
 5598 30e0 6530CDE5 		strb	r3, [sp, #101]
1657:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5599              		.loc 1 1657 0
 5600 30e4 50208DE5 		str	r2, [sp, #80]
1658:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5601              		.loc 1 1658 0
 5602 30e8 54308DE5 		str	r3, [sp, #84]
1659:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5603              		.loc 1 1659 0
 5604 30ec 58308DE5 		str	r3, [sp, #88]
1660:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5605              		.loc 1 1660 0
 5606 30f0 5C208DE5 		str	r2, [sp, #92]
1663:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5607              		.loc 1 1663 0
 5608 30f4 FEFFFFEB 		bl	CyU3PUartSetConfig
 5609              	.LVL444:
1664:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5610              		.loc 1 1664 0
 5611 30f8 000050E3 		cmp	r0, #0
 5612 30fc 0000000A 		beq	.L459
1666:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5613              		.loc 1 1666 0
 5614 3100 FEFFFFEB 		bl	CyFxAppErrorHandler
 5615              	.LVL445:
 5616              	.L459:
1670:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5617              		.loc 1 1670 0
 5618 3104 0000E0E3 		mvn	r0, #0
 5619 3108 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5620              	.LVL446:
1671:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5621              		.loc 1 1671 0
 5622 310c 000050E3 		cmp	r0, #0
 5623 3110 0000000A 		beq	.L460
1673:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5624              		.loc 1 1673 0
 5625 3114 FEFFFFEB 		bl	CyFxAppErrorHandler
 5626              	.LVL447:
 5627              	.L460:
1677:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5628              		.loc 1 1677 0
 5629 3118 0300A0E3 		mov	r0, #3
 5630 311c 0410A0E3 		mov	r1, #4
 5631 3120 FEFFFFEB 		bl	CyU3PDebugInit
 5632              	.LVL448:
1678:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5633              		.loc 1 1678 0
 5634 3124 000050E3 		cmp	r0, #0
 5635 3128 0000000A 		beq	.L461
1680:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5636              		.loc 1 1680 0
 5637 312c FEFFFFEB 		bl	CyFxAppErrorHandler
 5638              	.LVL449:
 5639              	.L461:
1684:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5640              		.loc 1 1684 0
 5641 3130 0000A0E3 		mov	r0, #0
 5642 3134 FEFFFFEB 		bl	CyU3PDebugPreamble
 5643              	.LVL450:
 5644              	.LBE213:
 5645              	.LBE212:
2204:../uvc.c      **** 		CyU3PThreadSleep(500);
 5646              		.loc 1 2204 0
 5647 3138 7D0FA0E3 		mov	r0, #500
 5648 313c FEFFFFEB 		bl	_tx_thread_sleep
 5649              	.LVL451:
 5650 3140 7D0FA0E3 		mov	r0, #500
 5651 3144 FEFFFFEB 		bl	_tx_thread_sleep
 5652 3148 7D0FA0E3 		mov	r0, #500
 5653 314c FEFFFFEB 		bl	_tx_thread_sleep
 5654 3150 7D0FA0E3 		mov	r0, #500
 5655 3154 FEFFFFEB 		bl	_tx_thread_sleep
 5656 3158 7D0FA0E3 		mov	r0, #500
 5657 315c FEFFFFEB 		bl	_tx_thread_sleep
 5658 3160 7D0FA0E3 		mov	r0, #500
 5659 3164 FEFFFFEB 		bl	_tx_thread_sleep
 5660              	.LBB214:
 5661              	.LBB215:
1695:../uvc.c      ****     status = CyU3PI2cInit ();
 5662              		.loc 1 1695 0
 5663 3168 FEFFFFEB 		bl	CyU3PI2cInit
 5664              	.LVL452:
1696:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5665              		.loc 1 1696 0
 5666 316c 002050E2 		subs	r2, r0, #0
 5667 3170 0201001A 		bne	.L527
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5668              		.loc 1 1703 0
 5669 3174 EC599FE5 		ldr	r5, .L552+8
1705:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5670              		.loc 1 1705 0
 5671 3178 0040E0E3 		mvn	r4, #0
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5672              		.loc 1 1708 0
 5673 317c 0210A0E1 		mov	r1, r2
 5674 3180 8C008DE2 		add	r0, sp, #140
 5675              	.LVL453:
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5676              		.loc 1 1703 0
 5677 3184 8C508DE5 		str	r5, [sp, #140]
1704:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5678              		.loc 1 1704 0
 5679 3188 90208DE5 		str	r2, [sp, #144]
1705:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5680              		.loc 1 1705 0
 5681 318c 94408DE5 		str	r4, [sp, #148]
1706:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5682              		.loc 1 1706 0
 5683 3190 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5684              		.loc 1 1708 0
 5685 3194 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5686              	.LVL454:
1709:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5687              		.loc 1 1709 0
 5688 3198 001050E2 		subs	r1, r0, #0
 5689 319c 0001001A 		bne	.L528
 5690              	.LBE215:
 5691              	.LBE214:
 5692              	.LBB221:
 5693              	.LBB224:
1782:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5694              		.loc 1 1782 0
 5695 31a0 C4699FE5 		ldr	r6, .L552+12
 5696 31a4 2820A0E3 		mov	r2, #40
 5697 31a8 0600A0E1 		mov	r0, r6
 5698              	.LVL455:
 5699 31ac FEFFFFEB 		bl	_txe_event_flags_create
 5700              	.LVL456:
1783:../uvc.c      ****     if (apiRetStatus != 0)
 5701              		.loc 1 1783 0
 5702 31b0 002050E2 		subs	r2, r0, #0
 5703 31b4 0301001A 		bne	.L529
1797:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5704              		.loc 1 1797 0
 5705 31b8 0280A0E3 		mov	r8, #2
1804:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5706              		.loc 1 1804 0
 5707 31bc 0210A0E1 		mov	r1, r2
 5708 31c0 9C008DE2 		add	r0, sp, #156
 5709              	.LVL457:
1800:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5710              		.loc 1 1800 0
 5711 31c4 017088E2 		add	r7, r8, #1
1793:../uvc.c      ****     isUsbConnected = CyFalse;
 5712              		.loc 1 1793 0
 5713 31c8 3C2086E5 		str	r2, [r6, #60]
1794:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5714              		.loc 1 1794 0
 5715 31cc 402086E5 		str	r2, [r6, #64]
1799:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5716              		.loc 1 1799 0
 5717 31d0 A420CDE5 		strb	r2, [sp, #164]
1801:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5718              		.loc 1 1801 0
 5719 31d4 A0208DE5 		str	r2, [sp, #160]
1797:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5720              		.loc 1 1797 0
 5721 31d8 9C80CDE5 		strb	r8, [sp, #156]
1798:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5722              		.loc 1 1798 0
 5723 31dc 9D80CDE5 		strb	r8, [sp, #157]
1800:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5724              		.loc 1 1800 0
 5725 31e0 A570CDE5 		strb	r7, [sp, #165]
1804:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5726              		.loc 1 1804 0
 5727 31e4 FEFFFFEB 		bl	CyU3PGpioInit
 5728              	.LVL458:
1805:../uvc.c      ****     if (apiRetStatus != 0)
 5729              		.loc 1 1805 0
 5730 31e8 002050E2 		subs	r2, r0, #0
 5731 31ec 7B01001A 		bne	.L530
1813:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5732              		.loc 1 1813 0
 5733 31f0 1600A0E3 		mov	r0, #22
 5734              	.LVL459:
 5735 31f4 0110A0E3 		mov	r1, #1
 5736 31f8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5737              	.LVL460:
1814:../uvc.c      ****     if (apiRetStatus != 0)
 5738              		.loc 1 1814 0
 5739 31fc 002050E2 		subs	r2, r0, #0
 5740 3200 6D01001A 		bne	.L531
1819:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5741              		.loc 1 1819 0
 5742 3204 1400A0E3 		mov	r0, #20
 5743              	.LVL461:
 5744 3208 0110A0E3 		mov	r1, #1
 5745 320c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5746              	.LVL462:
1820:../uvc.c      ****     if (apiRetStatus != 0)
 5747              		.loc 1 1820 0
 5748 3210 002050E2 		subs	r2, r0, #0
 5749 3214 5F01001A 		bne	.L532
1825:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5750              		.loc 1 1825 0
 5751 3218 1800A0E3 		mov	r0, #24
 5752              	.LVL463:
 5753 321c 0110A0E3 		mov	r1, #1
 5754 3220 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5755              	.LVL464:
1826:../uvc.c      ****     if (apiRetStatus != 0)
 5756              		.loc 1 1826 0
 5757 3224 002050E2 		subs	r2, r0, #0
 5758 3228 5101001A 		bne	.L533
1833:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5759              		.loc 1 1833 0
 5760 322c 0140A0E3 		mov	r4, #1
1838:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5761              		.loc 1 1838 0
 5762 3230 1600A0E3 		mov	r0, #22
 5763              	.LVL465:
 5764 3234 68108DE2 		add	r1, sp, #104
1836:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5765              		.loc 1 1836 0
 5766 3238 74208DE5 		str	r2, [sp, #116]
1837:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5767              		.loc 1 1837 0
 5768 323c 7820CDE5 		strb	r2, [sp, #120]
1833:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5769              		.loc 1 1833 0
 5770 3240 68408DE5 		str	r4, [sp, #104]
1834:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5771              		.loc 1 1834 0
 5772 3244 6C408DE5 		str	r4, [sp, #108]
1835:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5773              		.loc 1 1835 0
 5774 3248 70408DE5 		str	r4, [sp, #112]
1838:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5775              		.loc 1 1838 0
 5776 324c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5777              	.LVL466:
1839:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5778              		.loc 1 1839 0
 5779 3250 002050E2 		subs	r2, r0, #0
 5780 3254 1B01001A 		bne	.L534
1852:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5781              		.loc 1 1852 0
 5782 3258 1400A0E3 		mov	r0, #20
 5783              	.LVL467:
 5784 325c 68108DE2 		add	r1, sp, #104
1850:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5785              		.loc 1 1850 0
 5786 3260 74208DE5 		str	r2, [sp, #116]
1851:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5787              		.loc 1 1851 0
 5788 3264 7820CDE5 		strb	r2, [sp, #120]
1847:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5789              		.loc 1 1847 0
 5790 3268 68408DE5 		str	r4, [sp, #104]
1848:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5791              		.loc 1 1848 0
 5792 326c 6C408DE5 		str	r4, [sp, #108]
1849:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5793              		.loc 1 1849 0
 5794 3270 70408DE5 		str	r4, [sp, #112]
1852:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5795              		.loc 1 1852 0
 5796 3274 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5797              	.LVL468:
1853:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5798              		.loc 1 1853 0
 5799 3278 002050E2 		subs	r2, r0, #0
 5800 327c 0801001A 		bne	.L535
1866:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5801              		.loc 1 1866 0
 5802 3280 1800A0E3 		mov	r0, #24
 5803              	.LVL469:
 5804 3284 68108DE2 		add	r1, sp, #104
1861:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5805              		.loc 1 1861 0
 5806 3288 68208DE5 		str	r2, [sp, #104]
1862:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5807              		.loc 1 1862 0
 5808 328c 6C208DE5 		str	r2, [sp, #108]
1863:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5809              		.loc 1 1863 0
 5810 3290 70208DE5 		str	r2, [sp, #112]
1865:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5811              		.loc 1 1865 0
 5812 3294 7820CDE5 		strb	r2, [sp, #120]
1864:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5813              		.loc 1 1864 0
 5814 3298 74408DE5 		str	r4, [sp, #116]
1866:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5815              		.loc 1 1866 0
 5816 329c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5817              	.LVL470:
1867:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5818              		.loc 1 1867 0
 5819 32a0 002050E2 		subs	r2, r0, #0
 5820 32a4 F500001A 		bne	.L536
1876:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5821              		.loc 1 1876 0
 5822 32a8 00A0A0E3 		mov	sl, #0
1874:../uvc.c      ****     pibclock.clkDiv      = 2;
 5823              		.loc 1 1874 0
 5824 32ac 0270A0E3 		mov	r7, #2	@ movhi
1875:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5825              		.loc 1 1875 0
 5826 32b0 0380A0E3 		mov	r8, #3
1879:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5827              		.loc 1 1879 0
 5828 32b4 0100A0E3 		mov	r0, #1
 5829              	.LVL471:
 5830 32b8 7C108DE2 		add	r1, sp, #124
1874:../uvc.c      ****     pibclock.clkDiv      = 2;
 5831              		.loc 1 1874 0
 5832 32bc BC77CDE1 		strh	r7, [sp, #124]	@ movhi
1875:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5833              		.loc 1 1875 0
 5834 32c0 8880CDE5 		strb	r8, [sp, #136]
1876:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5835              		.loc 1 1876 0
 5836 32c4 84A08DE5 		str	sl, [sp, #132]
1877:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5837              		.loc 1 1877 0
 5838 32c8 80A08DE5 		str	sl, [sp, #128]
1879:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5839              		.loc 1 1879 0
 5840 32cc FEFFFFEB 		bl	CyU3PPibInit
 5841              	.LVL472:
1880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5842              		.loc 1 1880 0
 5843 32d0 002050E2 		subs	r2, r0, #0
 5844 32d4 7A01001A 		bne	.L537
1887:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5845              		.loc 1 1887 0
 5846 32d8 90089FE5 		ldr	r0, .L552+16
 5847              	.LVL473:
 5848 32dc FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 5849              	.LVL474:
1895:../uvc.c      ****     SensorReset ();
 5850              		.loc 1 1895 0
 5851 32e0 FEFFFFEB 		bl	SensorReset
1896:../uvc.c      ****     SensorInit ();
 5852              		.loc 1 1896 0
 5853 32e4 FEFFFFEB 		bl	SensorInit
1899:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5854              		.loc 1 1899 0
 5855 32e8 FEFFFFEB 		bl	CyU3PUsbStart
 5856              	.LVL475:
1900:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5857              		.loc 1 1900 0
 5858 32ec 004050E2 		subs	r4, r0, #0
 5859 32f0 6901001A 		bne	.L538
1906:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 5860              		.loc 1 1906 0
 5861 32f4 0410A0E1 		mov	r1, r4
 5862 32f8 74089FE5 		ldr	r0, .L552+20
 5863              	.LVL476:
 5864 32fc FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 5865              	.LVL477:
1909:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 5866              		.loc 1 1909 0
 5867 3300 70089FE5 		ldr	r0, .L552+24
 5868 3304 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1915:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 5869              		.loc 1 1915 0
 5870 3308 6C289FE5 		ldr	r2, .L552+28
 5871 330c 0410A0E1 		mov	r1, r4
 5872 3310 0100A0E3 		mov	r0, #1
 5873 3314 FEFFFFEB 		bl	CyU3PUsbSetDesc
1916:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 5874              		.loc 1 1916 0
 5875 3318 0410A0E1 		mov	r1, r4
 5876 331c 5C289FE5 		ldr	r2, .L552+32
 5877 3320 0400A0E1 		mov	r0, r4
 5878 3324 FEFFFFEB 		bl	CyU3PUsbSetDesc
1919:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 5879              		.loc 1 1919 0
 5880 3328 0410A0E1 		mov	r1, r4
 5881 332c 50289FE5 		ldr	r2, .L552+36
 5882 3330 0200A0E3 		mov	r0, #2
 5883 3334 FEFFFFEB 		bl	CyU3PUsbSetDesc
1920:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 5884              		.loc 1 1920 0
 5885 3338 0410A0E1 		mov	r1, r4
 5886 333c 44289FE5 		ldr	r2, .L552+40
 5887 3340 0700A0E3 		mov	r0, #7
 5888 3344 FEFFFFEB 		bl	CyU3PUsbSetDesc
1923:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 5889              		.loc 1 1923 0
 5890 3348 3C289FE5 		ldr	r2, .L552+44
 5891 334c 0410A0E1 		mov	r1, r4
 5892 3350 0400A0E3 		mov	r0, #4
 5893 3354 FEFFFFEB 		bl	CyU3PUsbSetDesc
1924:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 5894              		.loc 1 1924 0
 5895 3358 0410A0E1 		mov	r1, r4
 5896 335c 2C289FE5 		ldr	r2, .L552+48
 5897 3360 0800A0E1 		mov	r0, r8
 5898 3364 FEFFFFEB 		bl	CyU3PUsbSetDesc
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5899              		.loc 1 1925 0
 5900 3368 0410A0E1 		mov	r1, r4
 5901 336c 20289FE5 		ldr	r2, .L552+52
 5902 3370 0600A0E3 		mov	r0, #6
 5903 3374 FEFFFFEB 		bl	CyU3PUsbSetDesc
1928:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 5904              		.loc 1 1928 0
 5905 3378 0410A0E1 		mov	r1, r4
 5906 337c 14289FE5 		ldr	r2, .L552+56
 5907 3380 0500A0E3 		mov	r0, #5
 5908 3384 FEFFFFEB 		bl	CyU3PUsbSetDesc
1929:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 5909              		.loc 1 1929 0
 5910 3388 0110A0E3 		mov	r1, #1
 5911 338c 08289FE5 		ldr	r2, .L552+60
 5912 3390 0500A0E3 		mov	r0, #5
 5913 3394 FEFFFFEB 		bl	CyU3PUsbSetDesc
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 5914              		.loc 1 1930 0
 5915 3398 0210A0E3 		mov	r1, #2
 5916 339c FC279FE5 		ldr	r2, .L552+64
 5917 33a0 0500A0E3 		mov	r0, #5
 5918 33a4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1937:../uvc.c      ****     endPointConfig.enable   = 1;
 5919              		.loc 1 1937 0
 5920 33a8 0150A0E3 		mov	r5, #1
1939:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5921              		.loc 1 1939 0
 5922 33ac 4020A0E3 		mov	r2, #64	@ movhi
1943:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5923              		.loc 1 1943 0
 5924 33b0 8200A0E3 		mov	r0, #130
 5925 33b4 A8108DE2 		add	r1, sp, #168
1937:../uvc.c      ****     endPointConfig.enable   = 1;
 5926              		.loc 1 1937 0
 5927 33b8 A8508DE5 		str	r5, [sp, #168]
1938:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 5928              		.loc 1 1938 0
 5929 33bc AC80CDE5 		strb	r8, [sp, #172]
1939:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5930              		.loc 1 1939 0
 5931 33c0 B02BCDE1 		strh	r2, [sp, #176]	@ movhi
1940:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 5932              		.loc 1 1940 0
 5933 33c4 B340CDE5 		strb	r4, [sp, #179]
1941:../uvc.c      ****     endPointConfig.streams  = 0;
 5934              		.loc 1 1941 0
 5935 33c8 BE4ACDE1 		strh	r4, [sp, #174]	@ movhi
1942:../uvc.c      ****     endPointConfig.burstLen = 1;
 5936              		.loc 1 1942 0
 5937 33cc B250CDE5 		strb	r5, [sp, #178]
1943:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5938              		.loc 1 1943 0
 5939 33d0 FEFFFFEB 		bl	CyU3PSetEpConfig
 5940              	.LVL478:
1944:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5941              		.loc 1 1944 0
 5942 33d4 003050E2 		subs	r3, r0, #0
 5943 33d8 2501001A 		bne	.L539
1954:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5944              		.loc 1 1954 0
 5945 33dc C0C79FE5 		ldr	ip, .L552+68
1955:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5946              		.loc 1 1955 0
 5947 33e0 C0E79FE5 		ldr	lr, .L552+72
1952:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5948              		.loc 1 1952 0
 5949 33e4 018BA0E3 		mov	r8, #1024	@ movhi
1961:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5950              		.loc 1 1961 0
 5951 33e8 10A0A0E3 		mov	sl, #16
1963:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5952              		.loc 1 1963 0
 5953 33ec B8079FE5 		ldr	r0, .L552+76
 5954              	.LVL479:
 5955 33f0 0410A0E3 		mov	r1, #4
 5956 33f4 34208DE2 		add	r2, sp, #52
1952:../uvc.c      ****     dmaInterConfig.size           = 1024;
 5957              		.loc 1 1952 0
 5958 33f8 B483CDE1 		strh	r8, [sp, #52]	@ movhi
1953:../uvc.c      ****     dmaInterConfig.count          = 1;
 5959              		.loc 1 1953 0
 5960 33fc B653CDE1 		strh	r5, [sp, #54]	@ movhi
1954:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5961              		.loc 1 1954 0
 5962 3400 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1955:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 5963              		.loc 1 1955 0
 5964 3404 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1956:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 5965              		.loc 1 1956 0
 5966 3408 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1957:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 5967              		.loc 1 1957 0
 5968 340c BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1958:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 5969              		.loc 1 1958 0
 5970 3410 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1959:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 5971              		.loc 1 1959 0
 5972 3414 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1960:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 5973              		.loc 1 1960 0
 5974 3418 4440CDE5 		strb	r4, [sp, #68]
1961:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5975              		.loc 1 1961 0
 5976 341c 48A08DE5 		str	sl, [sp, #72]
1962:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 5977              		.loc 1 1962 0
 5978 3420 4C308DE5 		str	r3, [sp, #76]
1963:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5979              		.loc 1 1963 0
 5980 3424 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 5981              	.LVL480:
1965:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5982              		.loc 1 1965 0
 5983 3428 008050E2 		subs	r8, r0, #0
 5984 342c 0601001A 		bne	.L540
1972:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 5985              		.loc 1 1972 0
 5986 3430 010BA0E3 		mov	r0, #1024
 5987              	.LVL481:
 5988 3434 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 5989 3438 70179FE5 		ldr	r1, .L552+80
1973:../uvc.c      ****     if (glInterStaBuffer == 0)
 5990              		.loc 1 1973 0
 5991 343c 000050E3 		cmp	r0, #0
1972:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 5992              		.loc 1 1972 0
 5993 3440 000081E5 		str	r0, [r1, #0]
1973:../uvc.c      ****     if (glInterStaBuffer == 0)
 5994              		.loc 1 1973 0
 5995 3444 3001000A 		beq	.L541
1981:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 5996              		.loc 1 1981 0
 5997 3448 0430A0E3 		mov	r3, #4	@ movhi
 5998 344c BE30CDE1 		strh	r3, [sp, #14]	@ movhi
1985:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 5999              		.loc 1 1985 0
 6000 3450 5C379FE5 		ldr	r3, .L552+84
1980:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6001              		.loc 1 1980 0
 6002 3454 01E9A0E3 		mov	lr, #16384	@ movhi
 6003 3458 BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
1984:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6004              		.loc 1 1984 0
 6005 345c 54E79FE5 		ldr	lr, .L552+88
1985:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6006              		.loc 1 1985 0
 6007 3460 BA31CDE1 		strh	r3, [sp, #26]	@ movhi
1992:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6008              		.loc 1 1992 0
 6009 3464 50379FE5 		ldr	r3, .L552+92
1983:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6010              		.loc 1 1983 0
 6011 3468 01CCA0E3 		mov	ip, #256	@ movhi
1993:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6012              		.loc 1 1993 0
 6013 346c 0C208DE2 		add	r2, sp, #12
1983:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6014              		.loc 1 1983 0
 6015 3470 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
1984:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6016              		.loc 1 1984 0
 6017 3474 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
1987:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6018              		.loc 1 1987 0
 6019 3478 0CC0A0E3 		mov	ip, #12	@ movhi
1988:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6020              		.loc 1 1988 0
 6021 347c 04E0A0E3 		mov	lr, #4	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6022              		.loc 1 1990 0
 6023 3480 2A40CDE5 		strb	r4, [sp, #42]
1993:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6024              		.loc 1 1993 0
 6025 3484 34079FE5 		ldr	r0, .L552+96
 6026 3488 0710A0E3 		mov	r1, #7
1991:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6027              		.loc 1 1991 0
 6028 348c 1840A0E3 		mov	r4, #24
1982:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6029              		.loc 1 1982 0
 6030 3490 B071CDE1 		strh	r7, [sp, #16]	@ movhi
1986:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6031              		.loc 1 1986 0
 6032 3494 B282CDE1 		strh	r8, [sp, #34]	@ movhi
1987:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6033              		.loc 1 1987 0
 6034 3498 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
1988:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6035              		.loc 1 1988 0
 6036 349c B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
1989:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6037              		.loc 1 1989 0
 6038 34a0 B882CDE1 		strh	r8, [sp, #40]	@ movhi
1991:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6039              		.loc 1 1991 0
 6040 34a4 2C408DE5 		str	r4, [sp, #44]
1992:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6041              		.loc 1 1992 0
 6042 34a8 30308DE5 		str	r3, [sp, #48]
1993:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6043              		.loc 1 1993 0
 6044 34ac FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6045              	.LVL482:
1995:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6046              		.loc 1 1995 0
 6047 34b0 002050E2 		subs	r2, r0, #0
 6048 34b4 0B01001A 		bne	.L542
2086:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6049              		.loc 1 2086 0
 6050 34b8 0500A0E1 		mov	r0, r5
 6051              	.LVL483:
 6052 34bc 0510A0E1 		mov	r1, r5
 6053 34c0 FEFFFFEB 		bl	CyU3PConnectState
 6054              	.LVL484:
2087:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6055              		.loc 1 2087 0
 6056 34c4 002050E2 		subs	r2, r0, #0
 6057 34c8 6300001A 		bne	.L543
2093:../uvc.c      ****     CyU3PBusyWait(100);
 6058              		.loc 1 2093 0
 6059 34cc 6400A0E3 		mov	r0, #100
 6060              	.LVL485:
 6061 34d0 FEFFFFEB 		bl	CyU3PBusyWait
 6062              	.LVL486:
2095:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6063              		.loc 1 2095 0
 6064 34d4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2097:../uvc.c      ****     endPointConfig.enable   = 1;
 6065              		.loc 1 2097 0
 6066 34d8 A8508DE5 		str	r5, [sp, #168]
2098:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6067              		.loc 1 2098 0
 6068 34dc AC70CDE5 		strb	r7, [sp, #172]
2110:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6069              		.loc 1 2110 0
 6070 34e0 A8108DE2 		add	r1, sp, #168
2099:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6071              		.loc 1 2099 0
 6072 34e4 030050E3 		cmp	r0, #3
2095:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6073              		.loc 1 2095 0
 6074 34e8 4800C6E5 		strb	r0, [r6, #72]
2106:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6075              		.loc 1 2106 0
 6076 34ec 020CA013 		movne	r0, #512	@ movhi
2101:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6077              		.loc 1 2101 0
 6078 34f0 017BA003 		moveq	r7, #1024	@ movhi
2106:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6079              		.loc 1 2106 0
 6080 34f4 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2107:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6081              		.loc 1 2107 0
 6082 34f8 B250CD15 		strneb	r5, [sp, #178]
2110:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6083              		.loc 1 2110 0
 6084 34fc 8300A0E3 		mov	r0, #131
2109:../uvc.c      ****     endPointConfig.streams  = 0;
 6085              		.loc 1 2109 0
 6086 3500 0050A0E3 		mov	r5, #0	@ movhi
2101:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6087              		.loc 1 2101 0
 6088 3504 B07BCD01 		streqh	r7, [sp, #176]	@ movhi
2102:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6089              		.loc 1 2102 0
 6090 3508 B2A0CD05 		streqb	sl, [sp, #178]
2109:../uvc.c      ****     endPointConfig.streams  = 0;
 6091              		.loc 1 2109 0
 6092 350c BE5ACDE1 		strh	r5, [sp, #174]	@ movhi
2110:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6093              		.loc 1 2110 0
 6094 3510 FEFFFFEB 		bl	CyU3PSetEpConfig
 6095              	.LVL487:
2111:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6096              		.loc 1 2111 0
 6097 3514 002050E2 		subs	r2, r0, #0
 6098 3518 4600001A 		bne	.L524
 6099 351c A0869FE5 		ldr	r8, .L552+100
 6100              	.LBE224:
 6101              	.LBE221:
2231:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6102              		.loc 1 2231 0
 6103 3520 44569FE5 		ldr	r5, .L552+12
 6104 3524 0240A0E1 		mov	r4, r2
2302:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6105              		.loc 1 2302 0
 6106 3528 0870A0E1 		mov	r7, r8
 6107              	.LVL488:
 6108              	.L498:
2231:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6109              		.loc 1 2231 0
 6110 352c 38069FE5 		ldr	r0, .L552+12
 6111 3530 0110A0E3 		mov	r1, #1
 6112 3534 0220A0E3 		mov	r2, #2
 6113 3538 B4308DE2 		add	r3, sp, #180
 6114 353c 00408DE5 		str	r4, [sp, #0]
 6115 3540 FEFFFFEB 		bl	_txe_event_flags_get
 6116 3544 000050E3 		cmp	r0, #0
 6117 3548 2700001A 		bne	.L500
2277:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6118              		.loc 1 2277 0
 6119 354c 44A095E5 		ldr	sl, [r5, #68]
 6120 3550 00005AE3 		cmp	sl, #0
 6121 3554 0300000A 		beq	.L501
2277:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6122              		.loc 1 2277 0 is_stmt 0 discriminator 1
 6123 3558 BE22D5E1 		ldrh	r2, [r5, #46]
 6124 355c B013D5E1 		ldrh	r1, [r5, #48]
 6125 3560 010052E1 		cmp	r2, r1
 6126 3564 6000000A 		beq	.L544
 6127              	.L501:
2404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6128              		.loc 1 2404 0 is_stmt 1
 6129 3568 4010A0E3 		mov	r1, #64
 6130 356c 0020A0E3 		mov	r2, #0
 6131 3570 F4059FE5 		ldr	r0, .L552+12
 6132 3574 FEFFFFEB 		bl	_txe_event_flags_set
2407:../uvc.c      ****         CyU3PThreadRelinquish ();
 6133              		.loc 1 2407 0
 6134 3578 FEFFFFEB 		bl	_txe_thread_relinquish
2408:../uvc.c      ****     }
 6135              		.loc 1 2408 0
 6136 357c EAFFFFEA 		b	.L498
 6137              	.LVL489:
 6138              	.L527:
 6139              	.LBB259:
 6140              	.LBB220:
1698:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6141              		.loc 1 1698 0
 6142 3580 0400A0E3 		mov	r0, #4
 6143              	.LVL490:
 6144 3584 3C169FE5 		ldr	r1, .L552+104
 6145 3588 FEFFFFEB 		bl	CyU3PDebugPrint
 6146              	.LVL491:
 6147              	.L463:
 6148              	.LBB216:
 6149              	.LBB217:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6150              		.loc 1 1244 0
 6151 358c 38169FE5 		ldr	r1, .L552+108
 6152 3590 0400A0E3 		mov	r0, #4
 6153 3594 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6154              		.loc 1 1245 0
 6155 3598 FA0FA0E3 		mov	r0, #1000
 6156 359c FEFFFFEB 		bl	_tx_thread_sleep
 6157 35a0 F9FFFFEA 		b	.L463
 6158              	.LVL492:
 6159              	.L528:
 6160              	.LBE217:
 6161              	.LBE216:
1711:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6162              		.loc 1 1711 0
 6163 35a4 0400A0E3 		mov	r0, #4
 6164              	.LVL493:
 6165 35a8 20169FE5 		ldr	r1, .L552+112
 6166              	.LVL494:
 6167 35ac FEFFFFEB 		bl	CyU3PDebugPrint
 6168              	.L465:
 6169              	.LBB218:
 6170              	.LBB219:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6171              		.loc 1 1244 0
 6172 35b0 14169FE5 		ldr	r1, .L552+108
 6173 35b4 0400A0E3 		mov	r0, #4
 6174 35b8 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6175              		.loc 1 1245 0
 6176 35bc FA0FA0E3 		mov	r0, #1000
 6177 35c0 FEFFFFEB 		bl	_tx_thread_sleep
 6178 35c4 F9FFFFEA 		b	.L465
 6179              	.LVL495:
 6180              	.L529:
 6181              	.LBE219:
 6182              	.LBE218:
 6183              	.LBE220:
 6184              	.LBE259:
 6185              	.LBB260:
 6186              	.LBB223:
1785:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6187              		.loc 1 1785 0
 6188 35c8 0400A0E3 		mov	r0, #4
 6189              	.LVL496:
 6190 35cc 00169FE5 		ldr	r1, .L552+116
 6191 35d0 FEFFFFEB 		bl	CyU3PDebugPrint
 6192              	.LVL497:
 6193              	.L467:
 6194              	.LBB233:
 6195              	.LBB234:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6196              		.loc 1 1244 0
 6197 35d4 F0159FE5 		ldr	r1, .L552+108
 6198 35d8 0400A0E3 		mov	r0, #4
 6199 35dc FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6200              		.loc 1 1245 0
 6201 35e0 FA0FA0E3 		mov	r0, #1000
 6202 35e4 FEFFFFEB 		bl	_tx_thread_sleep
 6203 35e8 F9FFFFEA 		b	.L467
 6204              	.LVL498:
 6205              	.L500:
 6206              	.LBE234:
 6207              	.LBE233:
 6208              	.LBE223:
 6209              	.LBE260:
2333:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6210              		.loc 1 2333 0
 6211 35ec 78059FE5 		ldr	r0, .L552+12
 6212 35f0 0210A0E3 		mov	r1, #2
 6213 35f4 0320A0E3 		mov	r2, #3
 6214 35f8 B4308DE2 		add	r3, sp, #180
 6215 35fc 00408DE5 		str	r4, [sp, #0]
 6216 3600 FEFFFFEB 		bl	_txe_event_flags_get
 6217 3604 000050E3 		cmp	r0, #0
 6218 3608 DA00001A 		bne	.L508
2348:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6219              		.loc 1 2348 0
 6220 360c 402095E5 		ldr	r2, [r5, #64]
2336:../uvc.c      ****                 hitFV     = CyFalse;
 6221              		.loc 1 2336 0
 6222 3610 444085E5 		str	r4, [r5, #68]
2348:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6223              		.loc 1 2348 0
 6224 3614 000052E3 		cmp	r2, #0
2337:../uvc.c      ****                 prodCount = 0;
 6225              		.loc 1 2337 0
 6226 3618 BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2344:../uvc.c      ****                 fb=0;
 6227              		.loc 1 2344 0
 6228 361c B842C5E1 		strh	r4, [r5, #40]	@ movhi
2338:../uvc.c      ****                 consCount = 0;
 6229              		.loc 1 2338 0
 6230 3620 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2345:../uvc.c      ****                 pb=0;
 6231              		.loc 1 2345 0
 6232 3624 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2346:../uvc.c      ****                 pbc=0;
 6233              		.loc 1 2346 0
 6234 3628 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2348:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6235              		.loc 1 2348 0
 6236 362c BF00000A 		beq	.L545
 6237              	.L509:
2360:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6238              		.loc 1 2360 0
 6239 3630 404086E5 		str	r4, [r6, #64]
 6240 3634 CBFFFFEA 		b	.L501
 6241              	.LVL499:
 6242              	.L524:
 6243              	.LBB261:
 6244              	.LBB257:
2114:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6245              		.loc 1 2114 0
 6246 3638 0400A0E3 		mov	r0, #4
 6247              	.LVL500:
 6248 363c 94159FE5 		ldr	r1, .L552+120
 6249 3640 FEFFFFEB 		bl	CyU3PDebugPrint
 6250              	.LVL501:
 6251              	.L499:
 6252              	.LBB235:
 6253              	.LBB236:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6254              		.loc 1 1244 0
 6255 3644 80159FE5 		ldr	r1, .L552+108
 6256 3648 0400A0E3 		mov	r0, #4
 6257 364c FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6258              		.loc 1 1245 0
 6259 3650 FA0FA0E3 		mov	r0, #1000
 6260 3654 FEFFFFEB 		bl	_tx_thread_sleep
 6261 3658 F9FFFFEA 		b	.L499
 6262              	.LVL502:
 6263              	.L543:
 6264              	.LBE236:
 6265              	.LBE235:
2089:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6266              		.loc 1 2089 0
 6267 365c 0400A0E3 		mov	r0, #4
 6268              	.LVL503:
 6269 3660 74159FE5 		ldr	r1, .L552+124
 6270 3664 FEFFFFEB 		bl	CyU3PDebugPrint
 6271              	.LVL504:
 6272              	.L495:
 6273              	.LBB237:
 6274              	.LBB238:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6275              		.loc 1 1244 0
 6276 3668 5C159FE5 		ldr	r1, .L552+108
 6277 366c 0400A0E3 		mov	r0, #4
 6278 3670 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6279              		.loc 1 1245 0
 6280 3674 FA0FA0E3 		mov	r0, #1000
 6281 3678 FEFFFFEB 		bl	_tx_thread_sleep
 6282 367c F9FFFFEA 		b	.L495
 6283              	.LVL505:
 6284              	.L536:
 6285              	.LBE238:
 6286              	.LBE237:
1869:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6287              		.loc 1 1869 0
 6288 3680 0400A0E3 		mov	r0, #4
 6289              	.LVL506:
 6290 3684 54159FE5 		ldr	r1, .L552+128
 6291 3688 FEFFFFEB 		bl	CyU3PDebugPrint
 6292              	.LVL507:
 6293              	.L481:
 6294              	.LBB239:
 6295              	.LBB240:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6296              		.loc 1 1244 0
 6297 368c 38159FE5 		ldr	r1, .L552+108
 6298 3690 0400A0E3 		mov	r0, #4
 6299 3694 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6300              		.loc 1 1245 0
 6301 3698 FA0FA0E3 		mov	r0, #1000
 6302 369c FEFFFFEB 		bl	_tx_thread_sleep
 6303 36a0 F9FFFFEA 		b	.L481
 6304              	.LVL508:
 6305              	.L535:
 6306              	.LBE240:
 6307              	.LBE239:
1855:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6308              		.loc 1 1855 0
 6309 36a4 0400A0E3 		mov	r0, #4
 6310              	.LVL509:
 6311 36a8 34159FE5 		ldr	r1, .L552+132
 6312 36ac FEFFFFEB 		bl	CyU3PDebugPrint
 6313              	.LVL510:
 6314              	.L479:
 6315              	.LBB241:
 6316              	.LBB242:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6317              		.loc 1 1244 0
 6318 36b0 14159FE5 		ldr	r1, .L552+108
 6319 36b4 0400A0E3 		mov	r0, #4
 6320 36b8 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6321              		.loc 1 1245 0
 6322 36bc FA0FA0E3 		mov	r0, #1000
 6323 36c0 FEFFFFEB 		bl	_tx_thread_sleep
 6324 36c4 F9FFFFEA 		b	.L479
 6325              	.LVL511:
 6326              	.L534:
 6327              	.LBE242:
 6328              	.LBE241:
1841:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6329              		.loc 1 1841 0
 6330 36c8 0400A0E3 		mov	r0, #4
 6331              	.LVL512:
 6332 36cc 14159FE5 		ldr	r1, .L552+136
 6333 36d0 FEFFFFEB 		bl	CyU3PDebugPrint
 6334              	.LVL513:
 6335              	.L477:
 6336              	.LBB243:
 6337              	.LBB244:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6338              		.loc 1 1244 0
 6339 36d4 F0149FE5 		ldr	r1, .L552+108
 6340 36d8 0400A0E3 		mov	r0, #4
 6341 36dc FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6342              		.loc 1 1245 0
 6343 36e0 FA0FA0E3 		mov	r0, #1000
 6344 36e4 FEFFFFEB 		bl	_tx_thread_sleep
 6345 36e8 F9FFFFEA 		b	.L477
 6346              	.LVL514:
 6347              	.L544:
 6348              	.LBE244:
 6349              	.LBE243:
 6350              	.LBE257:
 6351              	.LBE261:
2287:../uvc.c      ****                 prodCount = 0;
 6352              		.loc 1 2287 0
 6353 36ec BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2288:../uvc.c      ****                 consCount = 0;
 6354              		.loc 1 2288 0
 6355 36f0 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2289:../uvc.c      ****                 hitFV     = CyFalse;
 6356              		.loc 1 2289 0
 6357 36f4 444085E5 		str	r4, [r5, #68]
2302:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6358              		.loc 1 2302 0
 6359 36f8 8104D8E5 		ldrb	r0, [r8, #1153]	@ zero_extendqisi2
2284:../uvc.c      ****             	fb=0;
 6360              		.loc 1 2284 0
 6361 36fc B842C5E1 		strh	r4, [r5, #40]	@ movhi
2302:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6362              		.loc 1 2302 0
 6363 3700 01E020E2 		eor	lr, r0, #1
 6364 3704 81E4C8E5 		strb	lr, [r8, #1153]
2303:../uvc.c      ****                 if(stiflag){
 6365              		.loc 1 2303 0
 6366 3708 983095E5 		ldr	r3, [r5, #152]
2304:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6367              		.loc 1 2304 0
 6368 370c 81C4D7E5 		ldrb	ip, [r7, #1153]	@ zero_extendqisi2
2303:../uvc.c      ****                 if(stiflag){
 6369              		.loc 1 2303 0
 6370 3710 000053E3 		cmp	r3, #0
2304:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6371              		.loc 1 2304 0
 6372 3714 20C08C13 		orrne	ip, ip, #32
2307:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6373              		.loc 1 2307 0
 6374 3718 DFC00C02 		andeq	ip, ip, #223
2304:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6375              		.loc 1 2304 0
 6376 371c 81C4C715 		strneb	ip, [r7, #1153]
2307:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6377              		.loc 1 2307 0
 6378 3720 81C4C705 		streqb	ip, [r7, #1153]
2305:../uvc.c      ****                 	stiflag = CyFalse;
 6379              		.loc 1 2305 0
 6380 3724 98408515 		strne	r4, [r5, #152]
2285:../uvc.c      ****             	pb=0;
 6381              		.loc 1 2285 0
 6382 3728 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2286:../uvc.c      ****             	pbc=0;
 6383              		.loc 1 2286 0
 6384 372c BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2310:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6385              		.loc 1 2310 0
 6386 3730 88049FE5 		ldr	r0, .L552+96
 6387 3734 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6388              	.LVL515:
2311:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6389              		.loc 1 2311 0
 6390 3738 002050E2 		subs	r2, r0, #0
 6391 373c 3900001A 		bne	.L546
2318:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6392              		.loc 1 2318 0
 6393 3740 0210A0E1 		mov	r1, r2
 6394 3744 74049FE5 		ldr	r0, .L552+96
 6395              	.LVL516:
 6396 3748 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6397              	.LVL517:
2319:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6398              		.loc 1 2319 0
 6399 374c 002050E2 		subs	r2, r0, #0
 6400 3750 2B00001A 		bne	.L547
2327:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6401              		.loc 1 2327 0
 6402 3754 5C049FE5 		ldr	r0, .L552+88
 6403              	.LVL518:
 6404 3758 0210A0E1 		mov	r1, r2
 6405 375c 02A0A0E3 		mov	sl, #2
 6406 3760 0020A0E1 		mov	r2, r0
 6407              	.LVL519:
 6408 3764 0130A0E1 		mov	r3, r1
 6409 3768 00A08DE5 		str	sl, [sp, #0]
 6410 376c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6411              	.LVL520:
 6412 3770 7CFFFFEA 		b	.L501
 6413              	.LVL521:
 6414              	.L533:
 6415              	.LBB262:
 6416              	.LBB222:
1828:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6417              		.loc 1 1828 0
 6418 3774 0400A0E3 		mov	r0, #4
 6419              	.LVL522:
 6420 3778 6C149FE5 		ldr	r1, .L552+140
 6421 377c FEFFFFEB 		bl	CyU3PDebugPrint
 6422              	.LVL523:
 6423              	.L475:
 6424              	.LBB231:
 6425              	.LBB232:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6426              		.loc 1 1244 0
 6427 3780 44149FE5 		ldr	r1, .L552+108
 6428 3784 0400A0E3 		mov	r0, #4
 6429 3788 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6430              		.loc 1 1245 0
 6431 378c FA0FA0E3 		mov	r0, #1000
 6432 3790 FEFFFFEB 		bl	_tx_thread_sleep
 6433 3794 F9FFFFEA 		b	.L475
 6434              	.LVL524:
 6435              	.L532:
 6436              	.LBE232:
 6437              	.LBE231:
1822:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6438              		.loc 1 1822 0
 6439 3798 0400A0E3 		mov	r0, #4
 6440              	.LVL525:
 6441 379c 4C149FE5 		ldr	r1, .L552+144
 6442 37a0 FEFFFFEB 		bl	CyU3PDebugPrint
 6443              	.LVL526:
 6444              	.L473:
 6445              	.LBB229:
 6446              	.LBB230:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6447              		.loc 1 1244 0
 6448 37a4 20149FE5 		ldr	r1, .L552+108
 6449 37a8 0400A0E3 		mov	r0, #4
 6450 37ac FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6451              		.loc 1 1245 0
 6452 37b0 FA0FA0E3 		mov	r0, #1000
 6453 37b4 FEFFFFEB 		bl	_tx_thread_sleep
 6454 37b8 F9FFFFEA 		b	.L473
 6455              	.LVL527:
 6456              	.L531:
 6457              	.LBE230:
 6458              	.LBE229:
1816:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6459              		.loc 1 1816 0
 6460 37bc 0400A0E3 		mov	r0, #4
 6461              	.LVL528:
 6462 37c0 2C149FE5 		ldr	r1, .L552+148
 6463 37c4 FEFFFFEB 		bl	CyU3PDebugPrint
 6464              	.LVL529:
 6465              	.L471:
 6466              	.LBB227:
 6467              	.LBB228:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6468              		.loc 1 1244 0
 6469 37c8 FC139FE5 		ldr	r1, .L552+108
 6470 37cc 0400A0E3 		mov	r0, #4
 6471 37d0 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6472              		.loc 1 1245 0
 6473 37d4 FA0FA0E3 		mov	r0, #1000
 6474 37d8 FEFFFFEB 		bl	_tx_thread_sleep
 6475 37dc F9FFFFEA 		b	.L471
 6476              	.LVL530:
 6477              	.L530:
 6478              	.LBE228:
 6479              	.LBE227:
1807:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6480              		.loc 1 1807 0
 6481 37e0 0400A0E3 		mov	r0, #4
 6482              	.LVL531:
 6483 37e4 0C149FE5 		ldr	r1, .L552+152
 6484 37e8 FEFFFFEB 		bl	CyU3PDebugPrint
 6485              	.LVL532:
 6486              	.L469:
 6487              	.LBB225:
 6488              	.LBB226:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6489              		.loc 1 1244 0
 6490 37ec D8139FE5 		ldr	r1, .L552+108
 6491 37f0 0400A0E3 		mov	r0, #4
 6492 37f4 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6493              		.loc 1 1245 0
 6494 37f8 FA0FA0E3 		mov	r0, #1000
 6495 37fc FEFFFFEB 		bl	_tx_thread_sleep
 6496 3800 F9FFFFEA 		b	.L469
 6497              	.LVL533:
 6498              	.L547:
 6499              	.LBE226:
 6500              	.LBE225:
 6501              	.LBE222:
 6502              	.LBE262:
2321:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6503              		.loc 1 2321 0
 6504 3804 0400A0E3 		mov	r0, #4
 6505              	.LVL534:
 6506 3808 EC139FE5 		ldr	r1, .L552+156
 6507 380c FEFFFFEB 		bl	CyU3PDebugPrint
 6508              	.LVL535:
 6509              	.L507:
 6510              	.LBB263:
 6511              	.LBB264:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6512              		.loc 1 1244 0
 6513 3810 B4139FE5 		ldr	r1, .L552+108
 6514 3814 0400A0E3 		mov	r0, #4
 6515 3818 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6516              		.loc 1 1245 0
 6517 381c FA0FA0E3 		mov	r0, #1000
 6518 3820 FEFFFFEB 		bl	_tx_thread_sleep
 6519 3824 F9FFFFEA 		b	.L507
 6520              	.LVL536:
 6521              	.L546:
 6522              	.LBE264:
 6523              	.LBE263:
2313:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6524              		.loc 1 2313 0
 6525 3828 0400A0E3 		mov	r0, #4
 6526              	.LVL537:
 6527 382c CC139FE5 		ldr	r1, .L552+160
 6528 3830 FEFFFFEB 		bl	CyU3PDebugPrint
 6529              	.LVL538:
 6530              	.L505:
 6531              	.LBB265:
 6532              	.LBB266:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6533              		.loc 1 1244 0
 6534 3834 90139FE5 		ldr	r1, .L552+108
 6535 3838 0400A0E3 		mov	r0, #4
 6536 383c FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6537              		.loc 1 1245 0
 6538 3840 FA0FA0E3 		mov	r0, #1000
 6539 3844 FEFFFFEB 		bl	_tx_thread_sleep
 6540 3848 F9FFFFEA 		b	.L505
 6541              	.LVL539:
 6542              	.L540:
 6543              	.LBE266:
 6544              	.LBE265:
 6545              	.LBB267:
 6546              	.LBB258:
1968:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6547              		.loc 1 1968 0
 6548 384c 0400A0E3 		mov	r0, #4
 6549              	.LVL540:
 6550 3850 AC139FE5 		ldr	r1, .L552+164
 6551 3854 0820A0E1 		mov	r2, r8
 6552 3858 FEFFFFEB 		bl	CyU3PDebugPrint
 6553              	.L489:
 6554              	.LBB245:
 6555              	.LBB246:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6556              		.loc 1 1244 0
 6557 385c 68139FE5 		ldr	r1, .L552+108
 6558 3860 0400A0E3 		mov	r0, #4
 6559 3864 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6560              		.loc 1 1245 0
 6561 3868 FA0FA0E3 		mov	r0, #1000
 6562 386c FEFFFFEB 		bl	_tx_thread_sleep
 6563 3870 F9FFFFEA 		b	.L489
 6564              	.LVL541:
 6565              	.L539:
 6566              	.LBE246:
 6567              	.LBE245:
1947:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6568              		.loc 1 1947 0
 6569 3874 0400A0E3 		mov	r0, #4
 6570              	.LVL542:
 6571 3878 58139FE5 		ldr	r1, .L552+120
 6572 387c 0320A0E1 		mov	r2, r3
 6573 3880 FEFFFFEB 		bl	CyU3PDebugPrint
 6574              	.LVL543:
 6575              	.L487:
 6576              	.LBB247:
 6577              	.LBB248:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6578              		.loc 1 1244 0
 6579 3884 40139FE5 		ldr	r1, .L552+108
 6580 3888 0400A0E3 		mov	r0, #4
 6581 388c FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6582              		.loc 1 1245 0
 6583 3890 FA0FA0E3 		mov	r0, #1000
 6584 3894 FEFFFFEB 		bl	_tx_thread_sleep
 6585 3898 F9FFFFEA 		b	.L487
 6586              	.LVL544:
 6587              	.L538:
 6588              	.LBE248:
 6589              	.LBE247:
1902:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6590              		.loc 1 1902 0
 6591 389c 0400A0E3 		mov	r0, #4
 6592 38a0 60139FE5 		ldr	r1, .L552+168
 6593 38a4 0420A0E1 		mov	r2, r4
 6594 38a8 FEFFFFEB 		bl	CyU3PDebugPrint
 6595              	.L485:
 6596              	.LBB249:
 6597              	.LBB250:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6598              		.loc 1 1244 0
 6599 38ac 18139FE5 		ldr	r1, .L552+108
 6600 38b0 0400A0E3 		mov	r0, #4
 6601 38b4 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6602              		.loc 1 1245 0
 6603 38b8 FA0FA0E3 		mov	r0, #1000
 6604 38bc FEFFFFEB 		bl	_tx_thread_sleep
 6605 38c0 F9FFFFEA 		b	.L485
 6606              	.LVL545:
 6607              	.L537:
 6608              	.LBE250:
 6609              	.LBE249:
1882:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6610              		.loc 1 1882 0
 6611 38c4 0400A0E3 		mov	r0, #4
 6612              	.LVL546:
 6613 38c8 3C139FE5 		ldr	r1, .L552+172
 6614 38cc FEFFFFEB 		bl	CyU3PDebugPrint
 6615              	.LVL547:
 6616              	.L483:
 6617              	.LBB251:
 6618              	.LBB252:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6619              		.loc 1 1244 0
 6620 38d0 F4129FE5 		ldr	r1, .L552+108
 6621 38d4 0400A0E3 		mov	r0, #4
 6622 38d8 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6623              		.loc 1 1245 0
 6624 38dc FA0FA0E3 		mov	r0, #1000
 6625 38e0 FEFFFFEB 		bl	_tx_thread_sleep
 6626 38e4 F9FFFFEA 		b	.L483
 6627              	.LVL548:
 6628              	.L542:
 6629              	.LBE252:
 6630              	.LBE251:
1998:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6631              		.loc 1 1998 0
 6632 38e8 0400A0E3 		mov	r0, #4
 6633              	.LVL549:
 6634 38ec 1C139FE5 		ldr	r1, .L552+176
 6635 38f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6636              	.LVL550:
 6637              	.L493:
 6638              	.LBB253:
 6639              	.LBB254:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6640              		.loc 1 1244 0
 6641 38f4 D0129FE5 		ldr	r1, .L552+108
 6642 38f8 0400A0E3 		mov	r0, #4
 6643 38fc FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6644              		.loc 1 1245 0
 6645 3900 FA0FA0E3 		mov	r0, #1000
 6646 3904 FEFFFFEB 		bl	_tx_thread_sleep
 6647 3908 F9FFFFEA 		b	.L493
 6648              	.LVL551:
 6649              	.L541:
 6650              	.LBE254:
 6651              	.LBE253:
1975:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6652              		.loc 1 1975 0
 6653 390c 040080E2 		add	r0, r0, #4
 6654 3910 FC129FE5 		ldr	r1, .L552+180
 6655 3914 FEFFFFEB 		bl	CyU3PDebugPrint
 6656              	.LVL552:
 6657              	.L491:
 6658              	.LBB255:
 6659              	.LBB256:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6660              		.loc 1 1244 0
 6661 3918 AC129FE5 		ldr	r1, .L552+108
 6662 391c 0400A0E3 		mov	r0, #4
 6663 3920 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6664              		.loc 1 1245 0
 6665 3924 FA0FA0E3 		mov	r0, #1000
 6666 3928 FEFFFFEB 		bl	_tx_thread_sleep
 6667 392c F9FFFFEA 		b	.L491
 6668              	.LVL553:
 6669              	.L545:
 6670              	.LBE256:
 6671              	.LBE255:
 6672              	.LBE258:
 6673              	.LBE267:
2350:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6674              		.loc 1 2350 0
 6675 3930 88029FE5 		ldr	r0, .L552+96
 6676 3934 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6677              	.LVL554:
2351:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6678              		.loc 1 2351 0
 6679 3938 000050E3 		cmp	r0, #0
 6680 393c 0200001A 		bne	.L525
2357:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6681              		.loc 1 2357 0
 6682 3940 8300A0E3 		mov	r0, #131
 6683              	.LVL555:
 6684 3944 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6685 3948 38FFFFEA 		b	.L509
 6686              	.L525:
 6687              	.LBB268:
 6688              	.LBB269:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6689              		.loc 1 1244 0
 6690 394c 78129FE5 		ldr	r1, .L552+108
 6691 3950 0400A0E3 		mov	r0, #4
 6692 3954 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6693              		.loc 1 1245 0
 6694 3958 FA0FA0E3 		mov	r0, #1000
 6695 395c FEFFFFEB 		bl	_tx_thread_sleep
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6696              		.loc 1 1244 0
 6697 3960 64129FE5 		ldr	r1, .L552+108
 6698 3964 0400A0E3 		mov	r0, #4
 6699 3968 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6700              		.loc 1 1245 0
 6701 396c FA0FA0E3 		mov	r0, #1000
 6702 3970 FEFFFFEB 		bl	_tx_thread_sleep
 6703 3974 F4FFFFEA 		b	.L525
 6704              	.L508:
 6705              	.LBE269:
 6706              	.LBE268:
2365:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6707              		.loc 1 2365 0
 6708 3978 00C0E0E3 		mvn	ip, #0
 6709 397c 0110A0E3 		mov	r1, #1
 6710 3980 0220A0E3 		mov	r2, #2
 6711 3984 B4308DE2 		add	r3, sp, #180
 6712 3988 DC019FE5 		ldr	r0, .L552+12
 6713 398c 00C08DE5 		str	ip, [sp, #0]
 6714 3990 FEFFFFEB 		bl	_txe_event_flags_get
2369:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6715              		.loc 1 2369 0
 6716 3994 0420A0E1 		mov	r2, r4
 6717 3998 20029FE5 		ldr	r0, .L552+96
 6718 399c 0410A0E1 		mov	r1, r4
 6719 39a0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6720              	.LVL556:
2370:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6721              		.loc 1 2370 0
 6722 39a4 002050E2 		subs	r2, r0, #0
 6723 39a8 2F00001A 		bne	.L548
2378:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6724              		.loc 1 2378 0
 6725 39ac 383095E5 		ldr	r3, [r5, #56]
 6726 39b0 000053E3 		cmp	r3, #0
 6727 39b4 5800001A 		bne	.L514
2381:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6728              		.loc 1 2381 0
 6729 39b8 3010A0E3 		mov	r1, #48
 6730 39bc 0120A0E3 		mov	r2, #1
 6731 39c0 823083E2 		add	r3, r3, #130
 6732 39c4 2100A0E3 		mov	r0, #33
 6733              	.LVL557:
 6734 39c8 FEFFFFEB 		bl	SensorSetIrisControl
2382:../uvc.c      ****                     CyU3PThreadSleep(500);
 6735              		.loc 1 2382 0
 6736 39cc 7D0FA0E3 		mov	r0, #500
 6737 39d0 FEFFFFEB 		bl	_tx_thread_sleep
2383:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6738              		.loc 1 2383 0
 6739 39d4 3010A0E3 		mov	r1, #48
 6740 39d8 0220A0E3 		mov	r2, #2
 6741 39dc 5230A0E3 		mov	r3, #82
 6742 39e0 2500A0E3 		mov	r0, #37
 6743 39e4 FEFFFFEB 		bl	SensorSetIrisControl
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
 6744              		.loc 1 2384 0
 6745 39e8 7D0FA0E3 		mov	r0, #500
 6746 39ec FEFFFFEB 		bl	_tx_thread_sleep
2385:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
 6747              		.loc 1 2385 0
 6748 39f0 3010A0E3 		mov	r1, #48
 6749 39f4 0A20A0E3 		mov	r2, #10
 6750 39f8 8230A0E3 		mov	r3, #130
 6751 39fc 2300A0E3 		mov	r0, #35
 6752 3a00 FEFFFFEB 		bl	SensorSetIrisControl
2386:../uvc.c      ****                    	CyU3PThreadSleep(300);
 6753              		.loc 1 2386 0
 6754 3a04 4B0FA0E3 		mov	r0, #300
 6755 3a08 FEFFFFEB 		bl	_tx_thread_sleep
2387:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6756              		.loc 1 2387 0
 6757 3a0c 3010A0E3 		mov	r1, #48
 6758 3a10 0420A0E1 		mov	r2, r4
 6759 3a14 8230A0E3 		mov	r3, #130
 6760 3a18 2100A0E3 		mov	r0, #33
 6761 3a1c FEFFFFEB 		bl	SensorSetIrisControl
2388:../uvc.c      ****                     CyU3PThreadSleep(500);
 6762              		.loc 1 2388 0
 6763 3a20 7D0FA0E3 		mov	r0, #500
 6764 3a24 FEFFFFEB 		bl	_tx_thread_sleep
2389:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6765              		.loc 1 2389 0
 6766 3a28 5230A0E3 		mov	r3, #82
 6767 3a2c 3010A0E3 		mov	r1, #48
 6768 3a30 0420A0E1 		mov	r2, r4
 6769 3a34 2500A0E3 		mov	r0, #37
 6770 3a38 FEFFFFEB 		bl	SensorSetIrisControl
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
 6771              		.loc 1 2390 0
 6772 3a3c 7D0FA0E3 		mov	r0, #500
 6773 3a40 FEFFFFEB 		bl	_tx_thread_sleep
 6774              	.LVL558:
 6775              	.LBB270:
 6776              	.LBB272:
2139:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6777              		.loc 1 2139 0
 6778 3a44 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6779 3a48 030053E3 		cmp	r3, #3
 6780 3a4c 2B00000A 		beq	.L549
2144:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6781              		.loc 1 2144 0
 6782 3a50 020053E3 		cmp	r3, #2
 6783 3a54 0D00000A 		beq	.L550
 6784              	.LVL559:
 6785              	.L517:
 6786              	.LBE272:
 6787              	.LBE270:
2392:../uvc.c      ****                     gpif_initialized = CyTrue;
 6788              		.loc 1 2392 0
 6789 3a58 0110A0E3 		mov	r1, #1
2393:../uvc.c      ****                     CyU3PThreadSleep(200);
 6790              		.loc 1 2393 0
 6791 3a5c C800A0E3 		mov	r0, #200
2392:../uvc.c      ****                     gpif_initialized = CyTrue;
 6792              		.loc 1 2392 0
 6793 3a60 381086E5 		str	r1, [r6, #56]
2393:../uvc.c      ****                     CyU3PThreadSleep(200);
 6794              		.loc 1 2393 0
 6795 3a64 FEFFFFEB 		bl	_tx_thread_sleep
 6796 3a68 BEFEFFEA 		b	.L501
 6797              	.LVL560:
 6798              	.L548:
2373:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6799              		.loc 1 2373 0
 6800 3a6c 0400A0E3 		mov	r0, #4
 6801              	.LVL561:
 6802 3a70 A0119FE5 		ldr	r1, .L552+184
 6803 3a74 FEFFFFEB 		bl	CyU3PDebugPrint
 6804              	.LVL562:
 6805              	.L513:
 6806              	.LBB278:
 6807              	.LBB279:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6808              		.loc 1 1244 0
 6809 3a78 4C119FE5 		ldr	r1, .L552+108
 6810 3a7c 0400A0E3 		mov	r0, #4
 6811 3a80 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6812              		.loc 1 1245 0
 6813 3a84 FA0FA0E3 		mov	r0, #1000
 6814 3a88 FEFFFFEB 		bl	_tx_thread_sleep
 6815 3a8c F9FFFFEA 		b	.L513
 6816              	.LVL563:
 6817              	.L550:
 6818              	.LBE279:
 6819              	.LBE278:
 6820              	.LBB280:
 6821              	.LBB271:
2146:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6822              		.loc 1 2146 0
 6823 3a90 84119FE5 		ldr	r1, .L552+188
 6824 3a94 0100A0E3 		mov	r0, #1
 6825 3a98 FEFFFFEB 		bl	CyU3PDebugPrint
2147:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6826              		.loc 1 2147 0
 6827 3a9c 7C019FE5 		ldr	r0, .L552+192
 6828 3aa0 FEFFFFEB 		bl	CyU3PGpifLoad
 6829 3aa4 0020A0E1 		mov	r2, r0
 6830              	.LVL564:
 6831              	.L516:
2149:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6832              		.loc 1 2149 0
 6833 3aa8 000052E3 		cmp	r2, #0
 6834 3aac 2200001A 		bne	.L551
2157:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6835              		.loc 1 2157 0
 6836 3ab0 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6837 3ab4 030053E3 		cmp	r3, #3
 6838 3ab8 0100000A 		beq	.L526
2161:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6839              		.loc 1 2161 0
 6840 3abc 020053E3 		cmp	r3, #2
 6841 3ac0 E4FFFF1A 		bne	.L517
 6842              	.L526:
2163:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6843              		.loc 1 2163 0
 6844 3ac4 0200A0E1 		mov	r0, r2
 6845              	.LVL565:
 6846 3ac8 0210A0E1 		mov	r1, r2
 6847 3acc FEFFFFEB 		bl	CyU3PGpifSMStart
 6848              	.LVL566:
2165:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6849              		.loc 1 2165 0
 6850 3ad0 000050E3 		cmp	r0, #0
2163:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6851              		.loc 1 2163 0
 6852 3ad4 0020A0E1 		mov	r2, r0
 6853              	.LVL567:
2165:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6854              		.loc 1 2165 0
 6855 3ad8 DEFFFF0A 		beq	.L517
2168:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6856              		.loc 1 2168 0
 6857 3adc 0400A0E3 		mov	r0, #4
 6858              	.LVL568:
 6859 3ae0 3C119FE5 		ldr	r1, .L552+196
 6860 3ae4 FEFFFFEB 		bl	CyU3PDebugPrint
 6861              	.LVL569:
 6862              	.L522:
 6863              	.LBB273:
 6864              	.LBB274:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6865              		.loc 1 1244 0
 6866 3ae8 DC109FE5 		ldr	r1, .L552+108
 6867 3aec 0400A0E3 		mov	r0, #4
 6868 3af0 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6869              		.loc 1 1245 0
 6870 3af4 FA0FA0E3 		mov	r0, #1000
 6871 3af8 FEFFFFEB 		bl	_tx_thread_sleep
 6872 3afc F9FFFFEA 		b	.L522
 6873              	.LVL570:
 6874              	.L549:
 6875              	.LBE274:
 6876              	.LBE273:
2141:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6877              		.loc 1 2141 0
 6878 3b00 20119FE5 		ldr	r1, .L552+200
 6879 3b04 0100A0E3 		mov	r0, #1
 6880 3b08 FEFFFFEB 		bl	CyU3PDebugPrint
2142:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6881              		.loc 1 2142 0
 6882 3b0c 18019FE5 		ldr	r0, .L552+204
 6883 3b10 FEFFFFEB 		bl	CyU3PGpifLoad
 6884 3b14 0020A0E1 		mov	r2, r0
 6885              	.LVL571:
 6886 3b18 E2FFFFEA 		b	.L516
 6887              	.LVL572:
 6888              	.L514:
 6889              	.LBE271:
 6890              	.LBE280:
2400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6891              		.loc 1 2400 0
 6892 3b1c 94009FE5 		ldr	r0, .L552+88
 6893              	.LVL573:
 6894 3b20 02E0A0E3 		mov	lr, #2
 6895 3b24 0410A0E1 		mov	r1, r4
 6896 3b28 0020A0E1 		mov	r2, r0
 6897              	.LVL574:
 6898 3b2c 0430A0E1 		mov	r3, r4
 6899 3b30 00E08DE5 		str	lr, [sp, #0]
 6900 3b34 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6901 3b38 8AFEFFEA 		b	.L501
 6902              	.LVL575:
 6903              	.L551:
 6904              	.LBB281:
 6905              	.LBB277:
2152:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6906              		.loc 1 2152 0
 6907 3b3c 0400A0E3 		mov	r0, #4
 6908              	.LVL576:
 6909 3b40 E8109FE5 		ldr	r1, .L552+208
 6910 3b44 FEFFFFEB 		bl	CyU3PDebugPrint
 6911              	.LVL577:
 6912              	.L519:
 6913              	.LBB275:
 6914              	.LBB276:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6915              		.loc 1 1244 0
 6916 3b48 7C109FE5 		ldr	r1, .L552+108
 6917 3b4c 0400A0E3 		mov	r0, #4
 6918 3b50 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 6919              		.loc 1 1245 0
 6920 3b54 FA0FA0E3 		mov	r0, #1000
 6921 3b58 FEFFFFEB 		bl	_tx_thread_sleep
 6922 3b5c F9FFFFEA 		b	.L519
 6923              	.L553:
 6924              		.align	2
 6925              	.L552:
 6926 3b60 4C060000 		.word	.LC35
 6927 3b64 00C20100 		.word	115200
 6928 3b68 A0860100 		.word	100000
 6929 3b6c 00000000 		.word	.LANCHOR0
 6930 3b70 00000000 		.word	CyFxGpifCB
 6931 3b74 00000000 		.word	CyFxUVCApplnUSBSetupCB
 6932 3b78 00000000 		.word	CyFxUVCApplnUSBEventCB
 6933 3b7c 00000000 		.word	CyFxUSBDeviceDscr
 6934 3b80 00000000 		.word	CyFxUSBDeviceDscrSS
 6935 3b84 00000000 		.word	CyFxUSBDeviceQualDscr
 6936 3b88 00000000 		.word	CyFxUSBBOSDscr
 6937 3b8c 00000000 		.word	CyFxUSBHSConfigDscr
 6938 3b90 00000000 		.word	CyFxUSBFSConfigDscr
 6939 3b94 00000000 		.word	CyFxUSBSSConfigDscr
 6940 3b98 00000000 		.word	CyFxUSBStringLangIDDscr
 6941 3b9c 00000000 		.word	CyFxUSBManufactureDscr
 6942 3ba0 00000000 		.word	CyFxUSBProductDscr
 6943 3ba4 013F0000 		.word	16129
 6944 3ba8 02030000 		.word	770
 6945 3bac 00000000 		.word	glChHandleInterStat
 6946 3bb0 00000000 		.word	glInterStaBuffer
 6947 3bb4 03030000 		.word	771
 6948 3bb8 01010000 		.word	257
 6949 3bbc 00000000 		.word	CyFxUvcApplnDmaCallback
 6950 3bc0 00000000 		.word	glChHandleUVCStream
 6951 3bc4 00000000 		.word	.LANCHOR1
 6952 3bc8 6C060000 		.word	.LC36
 6953 3bcc D4010000 		.word	.LC12
 6954 3bd0 88060000 		.word	.LC37
 6955 3bd4 A4060000 		.word	.LC38
 6956 3bd8 74080000 		.word	.LC48
 6957 3bdc 50090000 		.word	.LC52
 6958 3be0 DC070000 		.word	.LC45
 6959 3be4 A8070000 		.word	.LC44
 6960 3be8 74070000 		.word	.LC43
 6961 3bec 48070000 		.word	.LC42
 6962 3bf0 1C070000 		.word	.LC41
 6963 3bf4 F4060000 		.word	.LC40
 6964 3bf8 D0060000 		.word	.LC39
 6965 3bfc A4090000 		.word	.LC54
 6966 3c00 78090000 		.word	.LC53
 6967 3c04 A8080000 		.word	.LC49
 6968 3c08 44080000 		.word	.LC47
 6969 3c0c 14080000 		.word	.LC46
 6970 3c10 20090000 		.word	.LC51
 6971 3c14 E8080000 		.word	.LC50
 6972 3c18 D8090000 		.word	.LC55
 6973 3c1c 1C0A0000 		.word	.LC57
 6974 3c20 2C000000 		.word	.LANCHOR2+44
 6975 3c24 640A0000 		.word	.LC59
 6976 3c28 0C0A0000 		.word	.LC56
 6977 3c2c 10000000 		.word	.LANCHOR2+16
 6978 3c30 2C0A0000 		.word	.LC58
 6979              	.LBE276:
 6980              	.LBE275:
 6981              	.LBE277:
 6982              	.LBE281:
 6983              		.cfi_endproc
 6984              	.LFE18:
 6986              		.align	2
 6987              		.global	CyFxUVCApplnI2CInit
 6989              	CyFxUVCApplnI2CInit:
 6990              	.LFB14:
1691:../uvc.c      **** {
 6991              		.loc 1 1691 0
 6992              		.cfi_startproc
 6993              		@ args = 0, pretend = 0, frame = 16
 6994              		@ frame_needed = 0, uses_anonymous_args = 0
 6995 3c34 04E02DE5 		str	lr, [sp, #-4]!
 6996              	.LCFI25:
 6997              		.cfi_def_cfa_offset 4
 6998 3c38 14D04DE2 		sub	sp, sp, #20
 6999              	.LCFI26:
 7000              		.cfi_def_cfa_offset 24
1695:../uvc.c      ****     status = CyU3PI2cInit ();
 7001              		.loc 1 1695 0
 7002              		.cfi_offset 14, -4
 7003 3c3c FEFFFFEB 		bl	CyU3PI2cInit
 7004              	.LVL578:
1696:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7005              		.loc 1 1696 0
 7006 3c40 002050E2 		subs	r2, r0, #0
 7007 3c44 0B00001A 		bne	.L559
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7008              		.loc 1 1703 0
 7009 3c48 70C09FE5 		ldr	ip, .L561
1705:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7010              		.loc 1 1705 0
 7011 3c4c 0030E0E3 		mvn	r3, #0
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7012              		.loc 1 1708 0
 7013 3c50 0D00A0E1 		mov	r0, sp
 7014              	.LVL579:
 7015 3c54 0210A0E1 		mov	r1, r2
1703:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7016              		.loc 1 1703 0
 7017 3c58 00C08DE5 		str	ip, [sp, #0]
1704:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7018              		.loc 1 1704 0
 7019 3c5c 0C008DE9 		stmib	sp, {r2, r3}	@ phole stm
1706:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7020              		.loc 1 1706 0
 7021 3c60 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1708:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7022              		.loc 1 1708 0
 7023 3c64 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7024              	.LVL580:
1709:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7025              		.loc 1 1709 0
 7026 3c68 000050E3 		cmp	r0, #0
 7027 3c6c 0A00001A 		bne	.L560
1714:../uvc.c      **** }
 7028              		.loc 1 1714 0
 7029 3c70 14D08DE2 		add	sp, sp, #20
 7030 3c74 04F09DE4 		ldmfd	sp!, {pc}
 7031              	.L559:
1698:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7032              		.loc 1 1698 0
 7033 3c78 0400A0E3 		mov	r0, #4
 7034              	.LVL581:
 7035 3c7c 40109FE5 		ldr	r1, .L561+4
 7036 3c80 FEFFFFEB 		bl	CyU3PDebugPrint
 7037              	.LVL582:
 7038              	.L556:
 7039              	.LBB286:
 7040              	.LBB287:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7041              		.loc 1 1244 0
 7042 3c84 3C109FE5 		ldr	r1, .L561+8
 7043 3c88 0400A0E3 		mov	r0, #4
 7044 3c8c FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 7045              		.loc 1 1245 0
 7046 3c90 FA0FA0E3 		mov	r0, #1000
 7047 3c94 FEFFFFEB 		bl	_tx_thread_sleep
 7048 3c98 F9FFFFEA 		b	.L556
 7049              	.LVL583:
 7050              	.L560:
 7051              	.LBE287:
 7052              	.LBE286:
1711:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7053              		.loc 1 1711 0
 7054 3c9c 0400A0E3 		mov	r0, #4
 7055              	.LVL584:
 7056 3ca0 24109FE5 		ldr	r1, .L561+12
 7057 3ca4 FEFFFFEB 		bl	CyU3PDebugPrint
 7058              	.L558:
 7059              	.LBB288:
 7060              	.LBB289:
1244:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7061              		.loc 1 1244 0
 7062 3ca8 18109FE5 		ldr	r1, .L561+8
 7063 3cac 0400A0E3 		mov	r0, #4
 7064 3cb0 FEFFFFEB 		bl	CyU3PDebugPrint
1245:../uvc.c      ****         CyU3PThreadSleep (1000);
 7065              		.loc 1 1245 0
 7066 3cb4 FA0FA0E3 		mov	r0, #1000
 7067 3cb8 FEFFFFEB 		bl	_tx_thread_sleep
 7068 3cbc F9FFFFEA 		b	.L558
 7069              	.L562:
 7070              		.align	2
 7071              	.L561:
 7072 3cc0 A0860100 		.word	100000
 7073 3cc4 6C060000 		.word	.LC36
 7074 3cc8 D4010000 		.word	.LC12
 7075 3ccc 88060000 		.word	.LC37
 7076              	.LBE289:
 7077              	.LBE288:
 7078              		.cfi_endproc
 7079              	.LFE14:
 7081              		.align	2
 7082              		.global	CyFxApplicationDefine
 7084              	CyFxApplicationDefine:
 7085              	.LFB26:
3627:../uvc.c      **** }
3628:../uvc.c      **** 
3629:../uvc.c      **** 
3630:../uvc.c      **** /*
3631:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3632:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3633:../uvc.c      ****  */
3634:../uvc.c      **** void
3635:../uvc.c      **** CyFxApplicationDefine (
3636:../uvc.c      ****         void)
3637:../uvc.c      **** {
 7086              		.loc 1 3637 0
 7087              		.cfi_startproc
 7088              		@ args = 0, pretend = 0, frame = 40
 7089              		@ frame_needed = 0, uses_anonymous_args = 0
 7090              	.LVL585:
 7091 3cd0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7092              	.LCFI27:
 7093              		.cfi_def_cfa_offset 36
3638:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3639:../uvc.c      ****     uint32_t retThrdCreate;
3640:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3641:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3642:../uvc.c      **** 
3643:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3644:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7094              		.loc 1 3644 0
 7095 3cd4 010AA0E3 		mov	r0, #4096
3637:../uvc.c      **** {
 7096              		.loc 1 3637 0
 7097 3cd8 4CD04DE2 		sub	sp, sp, #76
 7098              	.LCFI28:
 7099              		.cfi_def_cfa_offset 112
 7100              		.loc 1 3644 0
 7101              		.cfi_offset 14, -4
 7102              		.cfi_offset 11, -8
 7103              		.cfi_offset 10, -12
 7104              		.cfi_offset 9, -16
 7105              		.cfi_offset 8, -20
 7106              		.cfi_offset 7, -24
 7107              		.cfi_offset 6, -28
 7108              		.cfi_offset 5, -32
 7109              		.cfi_offset 4, -36
 7110 3cdc FEFFFFEB 		bl	CyU3PMemAlloc
 7111 3ce0 00A0A0E1 		mov	sl, r0
 7112              	.LVL586:
3645:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7113              		.loc 1 3645 0
 7114 3ce4 010AA0E3 		mov	r0, #4096
 7115              	.LVL587:
 7116 3ce8 FEFFFFEB 		bl	CyU3PMemAlloc
 7117 3cec 00B0A0E1 		mov	fp, r0
 7118              	.LVL588:
3646:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7119              		.loc 1 3646 0
 7120 3cf0 010AA0E3 		mov	r0, #4096
 7121              	.LVL589:
 7122 3cf4 FEFFFFEB 		bl	CyU3PMemAlloc
3647:../uvc.c      **** 
3648:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7123              		.loc 1 3648 0
 7124 3cf8 00005AE3 		cmp	sl, #0
 7125 3cfc 00005B13 		cmpne	fp, #0
 7126 3d00 0090A013 		movne	r9, #0
 7127 3d04 0190A003 		moveq	r9, #1
3646:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7128              		.loc 1 3646 0
 7129 3d08 24008DE5 		str	r0, [sp, #36]
 7130              	.LVL590:
 7131              		.loc 1 3648 0
 7132 3d0c 0000001A 		bne	.L567
 7133              	.LVL591:
 7134              	.L564:
 7135              	.L566:
 7136 3d10 FEFFFFEA 		b	.L566
 7137              	.L567:
 7138              		.loc 1 3648 0 is_stmt 0 discriminator 1
 7139 3d14 000050E3 		cmp	r0, #0
 7140 3d18 FCFFFF0A 		beq	.L564
3649:../uvc.c      ****         goto fatalErrorHandler;
3650:../uvc.c      **** 
3651:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3652:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7141              		.loc 1 3652 0 is_stmt 1
 7142 3d1c 28408DE2 		add	r4, sp, #40
 7143 3d20 0400A0E1 		mov	r0, r4
 7144 3d24 4010A0E3 		mov	r1, #64
 7145 3d28 18219FE5 		ldr	r2, .L568
 7146 3d2c FEFFFFEB 		bl	cmdbufCreate
 7147 3d30 0450A0E1 		mov	r5, r4
 7148 3d34 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7149 3d38 0C719FE5 		ldr	r7, .L568+4
3653:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7150              		.loc 1 3653 0
 7151 3d3c 0C819FE5 		ldr	r8, .L568+8
3652:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7152              		.loc 1 3652 0
 7153 3d40 07C0A0E1 		mov	ip, r7
 7154 3d44 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7155 3d48 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3654:../uvc.c      **** 
3655:../uvc.c      **** 	/****** initialize command descriptor ***********/
3656:../uvc.c      **** 	cmdquInit(cmdQuptr);
3657:../uvc.c      **** 	cmdquInit(statQuptr);
3658:../uvc.c      **** 
3659:../uvc.c      ****     /* Create the UVC application thread. */
3660:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7156              		.loc 1 3660 0
 7157 3d4c 0860A0E3 		mov	r6, #8
3652:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7158              		.loc 1 3652 0
 7159 3d50 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3653:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7160              		.loc 1 3653 0
 7161 3d54 F8209FE5 		ldr	r2, .L568+12
 7162 3d58 0400A0E1 		mov	r0, r4
 7163 3d5c 2010A0E3 		mov	r1, #32
 7164 3d60 FEFFFFEB 		bl	cmdbufCreate
 7165 3d64 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7166 3d68 08C0A0E1 		mov	ip, r8
 7167 3d6c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7168 3d70 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7169              		.loc 1 3660 0
 7170 3d74 0140A0E3 		mov	r4, #1
3653:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7171              		.loc 1 3653 0
 7172 3d78 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3656:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7173              		.loc 1 3656 0
 7174 3d7c 0700A0E1 		mov	r0, r7
 7175 3d80 FEFFFFEB 		bl	cmdquInit
3657:../uvc.c      **** 	cmdquInit(statQuptr);
 7176              		.loc 1 3657 0
 7177 3d84 0800A0E1 		mov	r0, r8
 7178 3d88 FEFFFFEB 		bl	cmdquInit
 7179              		.loc 1 3660 0
 7180 3d8c A850A0E3 		mov	r5, #168
 7181 3d90 01CAA0E3 		mov	ip, #4096
 7182 3d94 BC009FE5 		ldr	r0, .L568+16
 7183 3d98 BC109FE5 		ldr	r1, .L568+20
 7184 3d9c BC209FE5 		ldr	r2, .L568+24
 7185 3da0 0930A0E1 		mov	r3, r9
 7186 3da4 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7187 3da8 08608DE5 		str	r6, [sp, #8]
 7188 3dac 0C608DE5 		str	r6, [sp, #12]
 7189 3db0 10908DE5 		str	r9, [sp, #16]
 7190 3db4 14408DE5 		str	r4, [sp, #20]
 7191 3db8 18508DE5 		str	r5, [sp, #24]
 7192 3dbc FEFFFFEB 		bl	_txe_thread_create
 7193              	.LVL592:
3661:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3662:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3663:../uvc.c      ****             0,                                          /* No input parameter to thread */
3664:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3665:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3666:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3667:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3668:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3669:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3670:../uvc.c      ****             );
3671:../uvc.c      ****     if (retThrdCreate != 0)
 7194              		.loc 1 3671 0
 7195 3dc0 00C050E2 		subs	ip, r0, #0
 7196 3dc4 D1FFFF1A 		bne	.L564
3672:../uvc.c      ****     {
3673:../uvc.c      ****         goto fatalErrorHandler;
3674:../uvc.c      ****     }
3675:../uvc.c      **** 
3676:../uvc.c      ****     /* Create the control request handling thread. */
3677:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7197              		.loc 1 3677 0
 7198 3dc8 0C30A0E1 		mov	r3, ip
 7199 3dcc 027BA0E3 		mov	r7, #2048
 7200 3dd0 8C009FE5 		ldr	r0, .L568+28
 7201              	.LVL593:
 7202 3dd4 8C109FE5 		ldr	r1, .L568+32
 7203 3dd8 8C209FE5 		ldr	r2, .L568+36
 7204 3ddc 10C08DE5 		str	ip, [sp, #16]
 7205 3de0 00B08DE5 		str	fp, [sp, #0]
 7206 3de4 04708DE5 		str	r7, [sp, #4]
 7207 3de8 08608DE5 		str	r6, [sp, #8]
 7208 3dec 0C608DE5 		str	r6, [sp, #12]
 7209 3df0 14408DE5 		str	r4, [sp, #20]
 7210 3df4 18508DE5 		str	r5, [sp, #24]
 7211 3df8 FEFFFFEB 		bl	_txe_thread_create
 7212              	.LVL594:
3678:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3679:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3680:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3681:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3682:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3683:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3684:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3685:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3686:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3687:../uvc.c      ****             );
3688:../uvc.c      ****     if (retThrdCreate != 0)
 7213              		.loc 1 3688 0
 7214 3dfc 00C050E2 		subs	ip, r0, #0
 7215 3e00 C2FFFF1A 		bne	.L564
3689:../uvc.c      ****     {
3690:../uvc.c      ****         goto fatalErrorHandler;
3691:../uvc.c      ****     }
3692:../uvc.c      **** #if 1
3693:../uvc.c      ****     /* Create the I2C control command handling thread. */
3694:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7216              		.loc 1 3694 0
 7217 3e04 24E09DE5 		ldr	lr, [sp, #36]
 7218 3e08 60009FE5 		ldr	r0, .L568+40
 7219              	.LVL595:
 7220 3e0c 60109FE5 		ldr	r1, .L568+44
 7221 3e10 60209FE5 		ldr	r2, .L568+48
 7222 3e14 0C30A0E1 		mov	r3, ip
 7223 3e18 00E08DE5 		str	lr, [sp, #0]
 7224 3e1c 04708DE5 		str	r7, [sp, #4]
 7225 3e20 08608DE5 		str	r6, [sp, #8]
 7226 3e24 0C608DE5 		str	r6, [sp, #12]
 7227 3e28 10C08DE5 		str	ip, [sp, #16]
 7228 3e2c 14408DE5 		str	r4, [sp, #20]
 7229 3e30 18508DE5 		str	r5, [sp, #24]
 7230 3e34 FEFFFFEB 		bl	_txe_thread_create
 7231              	.LVL596:
3695:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3696:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3697:../uvc.c      ****             0,                                          /* No input parameter to thread */
3698:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3699:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3700:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3701:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3702:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3703:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3704:../uvc.c      ****             );
3705:../uvc.c      ****     if (retThrdCreate != 0)
 7232              		.loc 1 3705 0
 7233 3e38 000050E3 		cmp	r0, #0
 7234 3e3c B3FFFF1A 		bne	.L564
3706:../uvc.c      ****     {
3707:../uvc.c      ****         goto fatalErrorHandler;
3708:../uvc.c      ****     }
3709:../uvc.c      **** #endif
3710:../uvc.c      **** 
3711:../uvc.c      ****     return;
3712:../uvc.c      **** 
3713:../uvc.c      **** fatalErrorHandler:
3714:../uvc.c      ****     /* Add custom recovery or debug actions here */
3715:../uvc.c      ****     /* Loop indefinitely */
3716:../uvc.c      ****     while (1);
3717:../uvc.c      **** }
 7235              		.loc 1 3717 0
 7236 3e40 4CD08DE2 		add	sp, sp, #76
 7237 3e44 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7238              	.L569:
 7239              		.align	2
 7240              	.L568:
 7241 3e48 00000000 		.word	cmdQuMux
 7242 3e4c 00000000 		.word	cmdQu
 7243 3e50 00000000 		.word	statQu
 7244 3e54 00000000 		.word	staQuMux
 7245 3e58 9C000000 		.word	.LANCHOR0+156
 7246 3e5c 9C0A0000 		.word	.LC60
 7247 3e60 00000000 		.word	UVCAppThread_Entry
 7248 3e64 44010000 		.word	.LANCHOR0+324
 7249 3e68 B00A0000 		.word	.LC61
 7250 3e6c 00000000 		.word	UVCAppEP0Thread_Entry
 7251 3e70 EC010000 		.word	.LANCHOR0+492
 7252 3e74 C80A0000 		.word	.LC62
 7253 3e78 00000000 		.word	I2cAppThread_Entry
 7254              		.cfi_endproc
 7255              	.LFE26:
 7257              		.align	2
 7258              		.global	main
 7260              	main:
 7261              	.LFB27:
3718:../uvc.c      **** 
3719:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3720:../uvc.c      ****  * the ThreadX RTOS here.
3721:../uvc.c      ****  */
3722:../uvc.c      **** int
3723:../uvc.c      **** main (
3724:../uvc.c      ****         void)
3725:../uvc.c      **** {
 7262              		.loc 1 3725 0
 7263              		.cfi_startproc
 7264              		@ args = 0, pretend = 0, frame = 56
 7265              		@ frame_needed = 0, uses_anonymous_args = 0
 7266 3e7c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7267              	.LCFI29:
 7268              		.cfi_def_cfa_offset 12
3726:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3727:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3728:../uvc.c      **** 
3729:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3730:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3731:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3732:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3733:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3734:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7269              		.loc 1 3734 0
 7270 3e80 0010A0E3 		mov	r1, #0
3725:../uvc.c      **** {
 7271              		.loc 1 3725 0
 7272 3e84 3CD04DE2 		sub	sp, sp, #60
 7273              	.LCFI30:
 7274              		.cfi_def_cfa_offset 72
3731:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7275              		.loc 1 3731 0
 7276 3e88 0220A0E3 		mov	r2, #2
3735:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7277              		.loc 1 3735 0
 7278 3e8c 033081E2 		add	r3, r1, #3
3730:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7279              		.loc 1 3730 0
 7280 3e90 0150A0E3 		mov	r5, #1
 7281              		.cfi_offset 14, -4
 7282              		.cfi_offset 5, -8
 7283              		.cfi_offset 4, -12
3736:../uvc.c      **** 
3737:../uvc.c      ****     /* Initialize the device */
3738:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7284              		.loc 1 3738 0
 7285 3e94 28008DE2 		add	r0, sp, #40
3730:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7286              		.loc 1 3730 0
 7287 3e98 28508DE5 		str	r5, [sp, #40]
3731:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7288              		.loc 1 3731 0
 7289 3e9c 2C20CDE5 		strb	r2, [sp, #44]
3732:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7290              		.loc 1 3732 0
 7291 3ea0 2D20CDE5 		strb	r2, [sp, #45]
3733:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7292              		.loc 1 3733 0
 7293 3ea4 2E20CDE5 		strb	r2, [sp, #46]
3734:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7294              		.loc 1 3734 0
 7295 3ea8 30108DE5 		str	r1, [sp, #48]
3735:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7296              		.loc 1 3735 0
 7297 3eac 3430CDE5 		strb	r3, [sp, #52]
 7298              		.loc 1 3738 0
 7299 3eb0 FEFFFFEB 		bl	CyU3PDeviceInit
 7300              	.LVL597:
3739:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7301              		.loc 1 3739 0
 7302 3eb4 004050E2 		subs	r4, r0, #0
 7303 3eb8 0000000A 		beq	.L573
 7304              	.L571:
 7305              	.L572:
 7306 3ebc FEFFFFEA 		b	.L572
 7307              	.L573:
3740:../uvc.c      ****     {
3741:../uvc.c      ****         goto handle_fatal_error;
3742:../uvc.c      ****     }
3743:../uvc.c      **** 
3744:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3745:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7308              		.loc 1 3745 0
 7309 3ec0 0410A0E1 		mov	r1, r4
 7310 3ec4 0420A0E1 		mov	r2, r4
 7311 3ec8 0500A0E1 		mov	r0, r5
 7312              	.LVL598:
 7313 3ecc FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7314              	.LVL599:
3746:../uvc.c      **** 
3747:../uvc.c      ****     /* Configure the IO matrix for the device. */
3748:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3749:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3750:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3751:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3752:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3753:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3754:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3755:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3756:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3757:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3758:../uvc.c      **** 
3759:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7315              		.loc 1 3759 0
 7316 3ed0 0D00A0E1 		mov	r0, sp
3749:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7317              		.loc 1 3749 0
 7318 3ed4 1640CDE5 		strb	r4, [sp, #22]
3750:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7319              		.loc 1 3750 0
 7320 3ed8 18408DE5 		str	r4, [sp, #24]
3751:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7321              		.loc 1 3751 0
 7322 3edc 1C408DE5 		str	r4, [sp, #28]
3752:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7323              		.loc 1 3752 0
 7324 3ee0 20408DE5 		str	r4, [sp, #32]
3753:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7325              		.loc 1 3753 0
 7326 3ee4 24408DE5 		str	r4, [sp, #36]
3756:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7327              		.loc 1 3756 0
 7328 3ee8 0C408DE5 		str	r4, [sp, #12]
3757:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7329              		.loc 1 3757 0
 7330 3eec 10408DE5 		str	r4, [sp, #16]
3748:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7331              		.loc 1 3748 0
 7332 3ef0 00508DE5 		str	r5, [sp, #0]
3754:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7333              		.loc 1 3754 0
 7334 3ef4 04508DE5 		str	r5, [sp, #4]
3755:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7335              		.loc 1 3755 0
 7336 3ef8 08508DE5 		str	r5, [sp, #8]
 7337              		.loc 1 3759 0
 7338 3efc FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7339              	.LVL600:
3760:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7340              		.loc 1 3760 0
 7341 3f00 004050E2 		subs	r4, r0, #0
 7342 3f04 ECFFFF1A 		bne	.L571
3761:../uvc.c      ****     {
3762:../uvc.c      ****         goto handle_fatal_error;
3763:../uvc.c      ****     }
3764:../uvc.c      **** 
3765:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3766:../uvc.c      ****     CyU3PKernelEntry ();
 7343              		.loc 1 3766 0
 7344 3f08 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7345              	.LVL601:
3767:../uvc.c      **** 
3768:../uvc.c      ****     /* Dummy return to make the compiler happy */
3769:../uvc.c      ****     return 0;
3770:../uvc.c      **** 
3771:../uvc.c      **** handle_fatal_error:
3772:../uvc.c      ****     /* Cannot recover from this error. */
3773:../uvc.c      ****     while (1);
3774:../uvc.c      **** }
 7346              		.loc 1 3774 0
 7347 3f0c 0400A0E1 		mov	r0, r4
 7348 3f10 3CD08DE2 		add	sp, sp, #60
 7349 3f14 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7350              		.cfi_endproc
 7351              	.LFE27:
 7353              		.global	CyFxGpifTransition
 7354              		.global	CyFxGpifWavedata
 7355              		.global	CyFxGpifWavedataPosition
 7356              		.global	CyFxGpifRegValue
 7357              		.global	CyFxGpifConfig
 7358              		.global	CyFxGpifTransition_usb2
 7359              		.global	CyFxGpifWavedata_usb2
 7360              		.global	CyFxGpifWavedataPosition_usb2
 7361              		.global	CyFxGpifRegValue_usb2
 7362              		.global	CyFxGpifConfig_usb2
 7363              		.global	snapButFlag
 7364              		.global	testSnap
 7365              		.global	fb
 7366              		.global	pb
 7367              		.global	pbc
 7368              		.global	fbbak
 7369              		.global	pbbak
 7370              		.global	pbcbak
 7371              		.global	pbcpbak
 7372              		.global	isUsbConnected
 7373              		.global	usbSpeed
 7374              		.global	clearFeatureRqtReceived
 7375              		.global	streamingStarted
 7376              		.global	glProbeCtrl
 7377              		.global	glProbeStilCtrl
 7378              		.global	glProbeCtrl20
 7379              		.global	glProbeStilCtrl20
 7380              		.global	glUVCHeader
 7381              		.comm	glChHandleUVCStream,220,4
 7382              		.comm	glChHandleStillStream,220,4
 7383              		.comm	glChHandleInterStat,160,4
 7384              		.comm	glInterStaBuffer,4,4
 7385              		.comm	cmdQu,32,4
 7386              		.comm	statQu,32,4
 7387              		.comm	cmdQuMux,56,4
 7388              		.comm	staQuMux,56,4
 7389              		.comm	timMux,56,4
 7390              		.comm	bmReqType,1,1
 7391              		.comm	bRequest,1,1
 7392              		.comm	wValue,2,2
 7393              		.comm	wIndex,2,2
 7394              		.comm	wLength,2,2
 7395              		.comm	posTick,4,4
 7396              		.comm	I2CCmdTimer,44,4
 7397              		.section	.rodata
 7398              		.align	2
 7399              		.set	.LANCHOR2,. + 0
 7402              	ExTime:
 7403 0000 9C       		.byte	-100
 7404 0001 00       		.byte	0
 7405 0002 4E       		.byte	78
 7406 0003 00       		.byte	0
 7407 0004 27       		.byte	39
 7408 0005 00       		.byte	0
 7409 0006 14       		.byte	20
 7410 0007 00       		.byte	0
 7411 0008 0A       		.byte	10
 7412 0009 00       		.byte	0
 7413 000a 05       		.byte	5
 7414 000b 00       		.byte	0
 7415 000c 02       		.byte	2
 7416 000d 00       		.byte	0
 7417 000e 01       		.byte	1
 7418 000f 00       		.byte	0
 7421              	CyFxGpifConfig:
 7422 0010 0F00     		.short	15
 7423 0012 0000     		.space	2
 7424 0014 00000000 		.word	CyFxGpifWavedata
 7425 0018 00000000 		.word	CyFxGpifWavedataPosition
 7426 001c 0500     		.short	5
 7427 001e 0000     		.space	2
 7428 0020 00000000 		.word	CyFxGpifTransition
 7429 0024 4C00     		.short	76
 7430 0026 0000     		.space	2
 7431 0028 00000000 		.word	CyFxGpifRegValue
 7434              	CyFxGpifConfig_usb2:
 7435 002c 9300     		.short	147
 7436 002e 0000     		.space	2
 7437 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7438 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7439 0038 0800     		.short	8
 7440 003a 0000     		.space	2
 7441 003c 00000000 		.word	CyFxGpifTransition_usb2
 7442 0040 4C00     		.short	76
 7443 0042 0000     		.space	2
 7444 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7445              		.data
 7446              		.align	2
 7447              		.set	.LANCHOR1,. + 0
 7450              	ExUCtrlParArry:
 7451 0000 00       		.byte	0
 7452 0001 00       		.byte	0
 7453 0002 04       		.byte	4
 7454 0003 01       		.byte	1
 7455 0004 00       		.byte	0
 7456 0005 38       		.byte	56
 7457 0006 01       		.byte	1
 7458 0007 01       		.byte	1
 7459 0008 00       		.byte	0
 7460 0009 03       		.byte	3
 7461 000a 00       		.byte	0
 7462 000b 4E       		.byte	78
 7463 000c 00       		.byte	0
 7464 000d 4E       		.byte	78
 7465 000e 00       		.byte	0
 7466 000f 30       		.byte	48
 7467 0010 01       		.byte	1
 7468 0011 00       		.byte	0
 7469 0012 00       		.byte	0
 7470 0013 00000000 		.space	5
 7470      00
 7471 0018 00       		.byte	0
 7472 0019 00       		.byte	0
 7473 001a 01       		.byte	1
 7474 001b 00       		.byte	0
 7475 001c 00       		.byte	0
 7476 001d 00       		.byte	0
 7477 001e 00       		.byte	0
 7478 001f 01       		.byte	1
 7479 0020 00       		.byte	0
 7480 0021 03       		.byte	3
 7481 0022 00       		.byte	0
 7482 0023 00       		.byte	0
 7483 0024 00       		.byte	0
 7484 0025 00       		.byte	0
 7485 0026 00       		.byte	0
 7486 0027 30       		.byte	48
 7487 0028 01       		.byte	1
 7488 0029 00       		.byte	0
 7489 002a 00       		.byte	0
 7490 002b 00000000 		.space	5
 7490      00
 7491 0030 00       		.byte	0
 7492 0031 00       		.byte	0
 7493 0032 02       		.byte	2
 7494 0033 00       		.byte	0
 7495 0034 00       		.byte	0
 7496 0035 FF       		.byte	-1
 7497 0036 00       		.byte	0
 7498 0037 01       		.byte	1
 7499 0038 00       		.byte	0
 7500 0039 03       		.byte	3
 7501 003a 00       		.byte	0
 7502 003b 01       		.byte	1
 7503 003c 00       		.byte	0
 7504 003d 00       		.byte	0
 7505 003e 00       		.byte	0
 7506 003f 30       		.byte	48
 7507 0040 01       		.byte	1
 7508 0041 01       		.byte	1
 7509 0042 00       		.byte	0
 7510 0043 00000000 		.space	5
 7510      00
 7511 0048 00       		.byte	0
 7512 0049 00       		.byte	0
 7513 004a 02       		.byte	2
 7514 004b 00       		.byte	0
 7515 004c 00       		.byte	0
 7516 004d 00       		.byte	0
 7517 004e 00       		.byte	0
 7518 004f 00       		.byte	0
 7519 0050 00       		.byte	0
 7520 0051 03       		.byte	3
 7521 0052 00       		.byte	0
 7522 0053 00       		.byte	0
 7523 0054 00       		.byte	0
 7524 0055 00       		.byte	0
 7525 0056 00       		.byte	0
 7526 0057 30       		.byte	48
 7527 0058 01       		.byte	1
 7528 0059 01       		.byte	1
 7529 005a 00       		.byte	0
 7530 005b 00000000 		.space	5
 7530      00
 7531 0060 13       		.byte	19
 7532 0061 14       		.byte	20
 7533 0062 02       		.byte	2
 7534 0063 01       		.byte	1
 7535 0064 00       		.byte	0
 7536 0065 03       		.byte	3
 7537 0066 00       		.byte	0
 7538 0067 01       		.byte	1
 7539 0068 00       		.byte	0
 7540 0069 03       		.byte	3
 7541 006a 00       		.byte	0
 7542 006b 23       		.byte	35
 7543 006c 37       		.byte	55
 7544 006d 23       		.byte	35
 7545 006e 37       		.byte	55
 7546 006f 30       		.byte	48
 7547 0070 01       		.byte	1
 7548 0071 00       		.byte	0
 7549 0072 00       		.byte	0
 7550 0073 00000000 		.space	5
 7550      00
 7551 0078 11       		.byte	17
 7552 0079 00       		.byte	0
 7553 007a 02       		.byte	2
 7554 007b 01       		.byte	1
 7555 007c 00       		.byte	0
 7556 007d 03       		.byte	3
 7557 007e 00       		.byte	0
 7558 007f 01       		.byte	1
 7559 0080 00       		.byte	0
 7560 0081 03       		.byte	3
 7561 0082 00       		.byte	0
 7562 0083 01       		.byte	1
 7563 0084 00       		.byte	0
 7564 0085 01       		.byte	1
 7565 0086 00       		.byte	0
 7566 0087 30       		.byte	48
 7567 0088 01       		.byte	1
 7568 0089 01       		.byte	1
 7569 008a 00       		.byte	0
 7570 008b 00000000 		.space	5
 7570      00
 7571 0090 17       		.byte	23
 7572 0091 00       		.byte	0
 7573 0092 01       		.byte	1
 7574 0093 01       		.byte	1
 7575 0094 00       		.byte	0
 7576 0095 02       		.byte	2
 7577 0096 00       		.byte	0
 7578 0097 01       		.byte	1
 7579 0098 00       		.byte	0
 7580 0099 03       		.byte	3
 7581 009a 00       		.byte	0
 7582 009b 00       		.byte	0
 7583 009c 00       		.byte	0
 7584 009d 00       		.byte	0
 7585 009e 00       		.byte	0
 7586 009f 30       		.byte	48
 7587 00a0 01       		.byte	1
 7588 00a1 01       		.byte	1
 7589 00a2 00       		.byte	0
 7590 00a3 00000000 		.space	5
 7590      00
 7591 00a8 00       		.byte	0
 7592 00a9 00       		.byte	0
 7593 00aa 04       		.byte	4
 7594 00ab 01       		.byte	1
 7595 00ac 00       		.byte	0
 7596 00ad 38       		.byte	56
 7597 00ae 01       		.byte	1
 7598 00af 01       		.byte	1
 7599 00b0 00       		.byte	0
 7600 00b1 03       		.byte	3
 7601 00b2 00       		.byte	0
 7602 00b3 4E       		.byte	78
 7603 00b4 00       		.byte	0
 7604 00b5 4E       		.byte	78
 7605 00b6 00       		.byte	0
 7606 00b7 30       		.byte	48
 7607 00b8 01       		.byte	1
 7608 00b9 00       		.byte	0
 7609 00ba 00       		.byte	0
 7610 00bb 00000000 		.space	5
 7610      00
 7611 00c0 00       		.byte	0
 7612 00c1 00       		.byte	0
 7613 00c2 01       		.byte	1
 7614 00c3 00       		.byte	0
 7615 00c4 00       		.byte	0
 7616 00c5 00       		.byte	0
 7617 00c6 00       		.byte	0
 7618 00c7 01       		.byte	1
 7619 00c8 00       		.byte	0
 7620 00c9 03       		.byte	3
 7621 00ca 00       		.byte	0
 7622 00cb 00       		.byte	0
 7623 00cc 00       		.byte	0
 7624 00cd 00       		.byte	0
 7625 00ce 00       		.byte	0
 7626 00cf 30       		.byte	48
 7627 00d0 01       		.byte	1
 7628 00d1 00       		.byte	0
 7629 00d2 00       		.byte	0
 7630 00d3 00000000 		.space	5
 7630      00
 7631 00d8 00       		.byte	0
 7632 00d9 00       		.byte	0
 7633 00da 02       		.byte	2
 7634 00db 00       		.byte	0
 7635 00dc 00       		.byte	0
 7636 00dd 05       		.byte	5
 7637 00de 00       		.byte	0
 7638 00df 01       		.byte	1
 7639 00e0 00       		.byte	0
 7640 00e1 03       		.byte	3
 7641 00e2 00       		.byte	0
 7642 00e3 00       		.byte	0
 7643 00e4 00       		.byte	0
 7644 00e5 00       		.byte	0
 7645 00e6 00       		.byte	0
 7646 00e7 30       		.byte	48
 7647 00e8 01       		.byte	1
 7648 00e9 00       		.byte	0
 7649 00ea 00       		.byte	0
 7650 00eb 00000000 		.space	5
 7650      00
 7651 00f0 00       		.byte	0
 7652 00f1 00       		.byte	0
 7653 00f2 03       		.byte	3
 7654 00f3 00       		.byte	0
 7655 00f4 00       		.byte	0
 7656 00f5 0A       		.byte	10
 7657 00f6 00       		.byte	0
 7658 00f7 01       		.byte	1
 7659 00f8 00       		.byte	0
 7660 00f9 03       		.byte	3
 7661 00fa 00       		.byte	0
 7662 00fb 00       		.byte	0
 7663 00fc 00       		.byte	0
 7664 00fd 00       		.byte	0
 7665 00fe 00       		.byte	0
 7666 00ff 30       		.byte	48
 7667 0100 01       		.byte	1
 7668 0101 00       		.byte	0
 7669 0102 00       		.byte	0
 7670 0103 00000000 		.space	5
 7670      00
 7671 0108 00       		.byte	0
 7672 0109 00       		.byte	0
 7673 010a 02       		.byte	2
 7674 010b 00       		.byte	0
 7675 010c 00       		.byte	0
 7676 010d 40       		.byte	64
 7677 010e 00       		.byte	0
 7678 010f 01       		.byte	1
 7679 0110 00       		.byte	0
 7680 0111 03       		.byte	3
 7681 0112 00       		.byte	0
 7682 0113 0F       		.byte	15
 7683 0114 11       		.byte	17
 7684 0115 00       		.byte	0
 7685 0116 00       		.byte	0
 7686 0117 30       		.byte	48
 7687 0118 01       		.byte	1
 7688 0119 00       		.byte	0
 7689 011a 00       		.byte	0
 7690 011b 00000000 		.space	5
 7690      00
 7691 0120 00       		.byte	0
 7692 0121 00       		.byte	0
 7693 0122 02       		.byte	2
 7694 0123 00       		.byte	0
 7695 0124 00       		.byte	0
 7696 0125 64       		.byte	100
 7697 0126 00       		.byte	0
 7698 0127 01       		.byte	1
 7699 0128 00       		.byte	0
 7700 0129 03       		.byte	3
 7701 012a 00       		.byte	0
 7702 012b 00       		.byte	0
 7703 012c 00       		.byte	0
 7704 012d 00       		.byte	0
 7705 012e 00       		.byte	0
 7706 012f 30       		.byte	48
 7707 0130 01       		.byte	1
 7708 0131 00       		.byte	0
 7709 0132 00       		.byte	0
 7710 0133 00000000 		.space	5
 7710      00
 7711 0138 00       		.byte	0
 7712 0139 00       		.byte	0
 7713 013a 02       		.byte	2
 7714 013b 00       		.byte	0
 7715 013c 00       		.byte	0
 7716 013d 64       		.byte	100
 7717 013e 00       		.byte	0
 7718 013f 01       		.byte	1
 7719 0140 00       		.byte	0
 7720 0141 03       		.byte	3
 7721 0142 00       		.byte	0
 7722 0143 00       		.byte	0
 7723 0144 00       		.byte	0
 7724 0145 00       		.byte	0
 7725 0146 00       		.byte	0
 7726 0147 30       		.byte	48
 7727 0148 01       		.byte	1
 7728 0149 00       		.byte	0
 7729 014a 00       		.byte	0
 7730 014b 00000000 		.space	5
 7730      00
 7731 0150 00       		.byte	0
 7732 0151 00       		.byte	0
 7733 0152 02       		.byte	2
 7734 0153 00       		.byte	0
 7735 0154 00       		.byte	0
 7736 0155 64       		.byte	100
 7737 0156 00       		.byte	0
 7738 0157 01       		.byte	1
 7739 0158 00       		.byte	0
 7740 0159 03       		.byte	3
 7741 015a 00       		.byte	0
 7742 015b 00       		.byte	0
 7743 015c 00       		.byte	0
 7744 015d 00       		.byte	0
 7745 015e 00       		.byte	0
 7746 015f 30       		.byte	48
 7747 0160 01       		.byte	1
 7748 0161 00       		.byte	0
 7749 0162 00       		.byte	0
 7750 0163 00000000 		.space	5
 7750      00
 7751 0168 00       		.byte	0
 7752 0169 00       		.byte	0
 7753 016a 02       		.byte	2
 7754 016b 00       		.byte	0
 7755 016c 00       		.byte	0
 7756 016d 64       		.byte	100
 7757 016e 00       		.byte	0
 7758 016f 01       		.byte	1
 7759 0170 00       		.byte	0
 7760 0171 03       		.byte	3
 7761 0172 00       		.byte	0
 7762 0173 00       		.byte	0
 7763 0174 00       		.byte	0
 7764 0175 00       		.byte	0
 7765 0176 00       		.byte	0
 7766 0177 30       		.byte	48
 7767 0178 01       		.byte	1
 7768 0179 00       		.byte	0
 7769 017a 00       		.byte	0
 7770 017b 00000000 		.space	5
 7770      00
 7773              	CtrlParArry:
 7774 0180 10       		.byte	16
 7775 0181 10       		.byte	16
 7776 0182 02       		.byte	2
 7777 0183 00       		.byte	0
 7778 0184 00       		.byte	0
 7779 0185 03       		.byte	3
 7780 0186 00       		.byte	0
 7781 0187 01       		.byte	1
 7782 0188 00       		.byte	0
 7783 0189 03       		.byte	3
 7784 018a 00       		.byte	0
 7785 018b 00       		.byte	0
 7786 018c 00       		.byte	0
 7787 018d 03       		.byte	3
 7788 018e 00       		.byte	0
 7789 018f 30       		.byte	48
 7790 0190 01       		.byte	1
 7791 0191 00       		.byte	0
 7792 0192 00       		.byte	0
 7793 0193 00000000 		.space	5
 7793      00
 7794 0198 01       		.byte	1
 7795 0199 00       		.byte	0
 7796 019a 02       		.byte	2
 7797 019b 00       		.byte	0
 7798 019c 00       		.byte	0
 7799 019d FF       		.byte	-1
 7800 019e 00       		.byte	0
 7801 019f 01       		.byte	1
 7802 01a0 00       		.byte	0
 7803 01a1 03       		.byte	3
 7804 01a2 00       		.byte	0
 7805 01a3 76       		.byte	118
 7806 01a4 00       		.byte	0
 7807 01a5 76       		.byte	118
 7808 01a6 C7       		.byte	-57
 7809 01a7 C6       		.byte	-58
 7810 01a8 01       		.byte	1
 7811 01a9 01       		.byte	1
 7812 01aa 00       		.byte	0
 7813 01ab 00000000 		.space	5
 7813      00
 7814 01b0 02       		.byte	2
 7815 01b1 02       		.byte	2
 7816 01b2 02       		.byte	2
 7817 01b3 00       		.byte	0
 7818 01b4 00       		.byte	0
 7819 01b5 FF       		.byte	-1
 7820 01b6 00       		.byte	0
 7821 01b7 01       		.byte	1
 7822 01b8 00       		.byte	0
 7823 01b9 03       		.byte	3
 7824 01ba 00       		.byte	0
 7825 01bb 70       		.byte	112
 7826 01bc 00       		.byte	0
 7827 01bd 70       		.byte	112
 7828 01be 00       		.byte	0
 7829 01bf C6       		.byte	-58
 7830 01c0 01       		.byte	1
 7831 01c1 01       		.byte	1
 7832 01c2 00       		.byte	0
 7833 01c3 00000000 		.space	5
 7833      00
 7834 01c8 00       		.byte	0
 7835 01c9 00       		.byte	0
 7836 01ca 02       		.byte	2
 7837 01cb 00       		.byte	0
 7838 01cc 00       		.byte	0
 7839 01cd 64       		.byte	100
 7840 01ce 00       		.byte	0
 7841 01cf 01       		.byte	1
 7842 01d0 00       		.byte	0
 7843 01d1 03       		.byte	3
 7844 01d2 00       		.byte	0
 7845 01d3 00       		.byte	0
 7846 01d4 00       		.byte	0
 7847 01d5 00       		.byte	0
 7848 01d6 00       		.byte	0
 7849 01d7 30       		.byte	48
 7850 01d8 01       		.byte	1
 7851 01d9 00       		.byte	0
 7852 01da 00       		.byte	0
 7853 01db 00000000 		.space	5
 7853      00
 7854 01e0 07       		.byte	7
 7855 01e1 07       		.byte	7
 7856 01e2 02       		.byte	2
 7857 01e3 00       		.byte	0
 7858 01e4 00       		.byte	0
 7859 01e5 01       		.byte	1
 7860 01e6 00       		.byte	0
 7861 01e7 01       		.byte	1
 7862 01e8 00       		.byte	0
 7863 01e9 03       		.byte	3
 7864 01ea 00       		.byte	0
 7865 01eb 01       		.byte	1
 7866 01ec 00       		.byte	0
 7867 01ed 01       		.byte	1
 7868 01ee 00       		.byte	0
 7869 01ef 30       		.byte	48
 7870 01f0 01       		.byte	1
 7871 01f1 00       		.byte	0
 7872 01f2 00       		.byte	0
 7873 01f3 00000000 		.space	5
 7873      00
 7874 01f8 DF       		.byte	-33
 7875 01f9 E1       		.byte	-31
 7876 01fa 02       		.byte	2
 7877 01fb 00       		.byte	0
 7878 01fc 00       		.byte	0
 7879 01fd FF       		.byte	-1
 7880 01fe 00       		.byte	0
 7881 01ff 01       		.byte	1
 7882 0200 00       		.byte	0
 7883 0201 03       		.byte	3
 7884 0202 00       		.byte	0
 7885 0203 80       		.byte	-128
 7886 0204 00       		.byte	0
 7887 0205 00       		.byte	0
 7888 0206 00       		.byte	0
 7889 0207 C6       		.byte	-58
 7890 0208 01       		.byte	1
 7891 0209 01       		.byte	1
 7892 020a 00       		.byte	0
 7893 020b 00000000 		.space	5
 7893      00
 7894 0210 85       		.byte	-123
 7895 0211 86       		.byte	-122
 7896 0212 02       		.byte	2
 7897 0213 00       		.byte	0
 7898 0214 00       		.byte	0
 7899 0215 64       		.byte	100
 7900 0216 00       		.byte	0
 7901 0217 01       		.byte	1
 7902 0218 00       		.byte	0
 7903 0219 03       		.byte	3
 7904 021a 00       		.byte	0
 7905 021b 32       		.byte	50
 7906 021c 00       		.byte	0
 7907 021d 32       		.byte	50
 7908 021e 00       		.byte	0
 7909 021f F2       		.byte	-14
 7910 0220 01       		.byte	1
 7911 0221 01       		.byte	1
 7912 0222 00       		.byte	0
 7913 0223 00000000 		.space	5
 7913      00
 7914 0228 06       		.byte	6
 7915 0229 06       		.byte	6
 7916 022a 02       		.byte	2
 7917 022b 00       		.byte	0
 7918 022c 00       		.byte	0
 7919 022d 40       		.byte	64
 7920 022e 00       		.byte	0
 7921 022f 01       		.byte	1
 7922 0230 00       		.byte	0
 7923 0231 03       		.byte	3
 7924 0232 00       		.byte	0
 7925 0233 20       		.byte	32
 7926 0234 00       		.byte	0
 7927 0235 20       		.byte	32
 7928 0236 00       		.byte	0
 7929 0237 30       		.byte	48
 7930 0238 01       		.byte	1
 7931 0239 01       		.byte	1
 7932 023a 00       		.byte	0
 7933 023b 00000000 		.space	5
 7933      00
 7934 0240 00       		.byte	0
 7935 0241 00       		.byte	0
 7936 0242 02       		.byte	2
 7937 0243 00       		.byte	0
 7938 0244 00       		.byte	0
 7939 0245 64       		.byte	100
 7940 0246 00       		.byte	0
 7941 0247 01       		.byte	1
 7942 0248 00       		.byte	0
 7943 0249 03       		.byte	3
 7944 024a 00       		.byte	0
 7945 024b 00       		.byte	0
 7946 024c 00       		.byte	0
 7947 024d 00       		.byte	0
 7948 024e 00       		.byte	0
 7949 024f 30       		.byte	48
 7950 0250 01       		.byte	1
 7951 0251 00       		.byte	0
 7952 0252 00       		.byte	0
 7953 0253 00000000 		.space	5
 7953      00
 7954 0258 08       		.byte	8
 7955 0259 08       		.byte	8
 7956 025a 02       		.byte	2
 7957 025b 00       		.byte	0
 7958 025c 00       		.byte	0
 7959 025d 05       		.byte	5
 7960 025e 00       		.byte	0
 7961 025f 01       		.byte	1
 7962 0260 00       		.byte	0
 7963 0261 03       		.byte	3
 7964 0262 00       		.byte	0
 7965 0263 00       		.byte	0
 7966 0264 00       		.byte	0
 7967 0265 00       		.byte	0
 7968 0266 00       		.byte	0
 7969 0267 30       		.byte	48
 7970 0268 01       		.byte	1
 7971 0269 00       		.byte	0
 7972 026a 00       		.byte	0
 7973 026b 00000000 		.space	5
 7973      00
 7974 0270 00       		.byte	0
 7975 0271 00       		.byte	0
 7976 0272 02       		.byte	2
 7977 0273 00       		.byte	0
 7978 0274 00       		.byte	0
 7979 0275 40       		.byte	64
 7980 0276 00       		.byte	0
 7981 0277 01       		.byte	1
 7982 0278 00       		.byte	0
 7983 0279 03       		.byte	3
 7984 027a 00       		.byte	0
 7985 027b 00       		.byte	0
 7986 027c 00       		.byte	0
 7987 027d 00       		.byte	0
 7988 027e 00       		.byte	0
 7989 027f 30       		.byte	48
 7990 0280 01       		.byte	1
 7991 0281 00       		.byte	0
 7992 0282 00       		.byte	0
 7993 0283 00000000 		.space	5
 7993      00
 7994 0288 09       		.byte	9
 7995 0289 0A       		.byte	10
 7996 028a 04       		.byte	4
 7997 028b 00       		.byte	0
 7998 028c 00       		.byte	0
 7999 028d 40       		.byte	64
 8000 028e 00       		.byte	0
 8001 028f 01       		.byte	1
 8002 0290 00       		.byte	0
 8003 0291 03       		.byte	3
 8004 0292 00       		.byte	0
 8005 0293 20       		.byte	32
 8006 0294 38       		.byte	56
 8007 0295 20       		.byte	32
 8008 0296 38       		.byte	56
 8009 0297 30       		.byte	48
 8010 0298 01       		.byte	1
 8011 0299 00       		.byte	0
 8012 029a 00       		.byte	0
 8013 029b 00000000 		.space	5
 8013      00
 8014 02a0 00       		.byte	0
 8015 02a1 00       		.byte	0
 8016 02a2 02       		.byte	2
 8017 02a3 00       		.byte	0
 8018 02a4 00       		.byte	0
 8019 02a5 64       		.byte	100
 8020 02a6 00       		.byte	0
 8021 02a7 01       		.byte	1
 8022 02a8 00       		.byte	0
 8023 02a9 03       		.byte	3
 8024 02aa 00       		.byte	0
 8025 02ab 00       		.byte	0
 8026 02ac 00       		.byte	0
 8027 02ad 00       		.byte	0
 8028 02ae 00       		.byte	0
 8029 02af 30       		.byte	48
 8030 02b0 01       		.byte	1
 8031 02b1 00       		.byte	0
 8032 02b2 00       		.byte	0
 8033 02b3 00000000 		.space	5
 8033      00
 8034 02b8 00       		.byte	0
 8035 02b9 00       		.byte	0
 8036 02ba 02       		.byte	2
 8037 02bb 00       		.byte	0
 8038 02bc 00       		.byte	0
 8039 02bd 64       		.byte	100
 8040 02be 00       		.byte	0
 8041 02bf 01       		.byte	1
 8042 02c0 00       		.byte	0
 8043 02c1 03       		.byte	3
 8044 02c2 00       		.byte	0
 8045 02c3 00       		.byte	0
 8046 02c4 00       		.byte	0
 8047 02c5 00       		.byte	0
 8048 02c6 00       		.byte	0
 8049 02c7 30       		.byte	48
 8050 02c8 01       		.byte	1
 8051 02c9 00       		.byte	0
 8052 02ca 00       		.byte	0
 8053 02cb 00000000 		.space	5
 8053      00
 8054 02d0 2A       		.byte	42
 8055 02d1 2A       		.byte	42
 8056 02d2 02       		.byte	2
 8057 02d3 00       		.byte	0
 8058 02d4 00       		.byte	0
 8059 02d5 1B       		.byte	27
 8060 02d6 00       		.byte	0
 8061 02d7 01       		.byte	1
 8062 02d8 00       		.byte	0
 8063 02d9 03       		.byte	3
 8064 02da 00       		.byte	0
 8065 02db 00       		.byte	0
 8066 02dc 00       		.byte	0
 8067 02dd 00       		.byte	0
 8068 02de 00       		.byte	0
 8069 02df 30       		.byte	48
 8070 02e0 01       		.byte	1
 8071 02e1 00       		.byte	0
 8072 02e2 00       		.byte	0
 8073 02e3 00000000 		.space	5
 8073      00
 8074 02e8 00       		.byte	0
 8075 02e9 00       		.byte	0
 8076 02ea 02       		.byte	2
 8077 02eb 00       		.byte	0
 8078 02ec 00       		.byte	0
 8079 02ed 64       		.byte	100
 8080 02ee 00       		.byte	0
 8081 02ef 01       		.byte	1
 8082 02f0 00       		.byte	0
 8083 02f1 03       		.byte	3
 8084 02f2 00       		.byte	0
 8085 02f3 00       		.byte	0
 8086 02f4 00       		.byte	0
 8087 02f5 00       		.byte	0
 8088 02f6 00       		.byte	0
 8089 02f7 30       		.byte	48
 8090 02f8 01       		.byte	1
 8091 02f9 00       		.byte	0
 8092 02fa 00       		.byte	0
 8093 02fb 00000000 		.space	5
 8093      00
 8094 0300 00       		.byte	0
 8095 0301 00       		.byte	0
 8096 0302 02       		.byte	2
 8097 0303 00       		.byte	0
 8098 0304 00       		.byte	0
 8099 0305 12       		.byte	18
 8100 0306 00       		.byte	0
 8101 0307 01       		.byte	1
 8102 0308 00       		.byte	0
 8103 0309 03       		.byte	3
 8104 030a 00       		.byte	0
 8105 030b 00       		.byte	0
 8106 030c 00       		.byte	0
 8107 030d 00       		.byte	0
 8108 030e 00       		.byte	0
 8109 030f 30       		.byte	48
 8110 0310 01       		.byte	1
 8111 0311 00       		.byte	0
 8112 0312 00       		.byte	0
 8113 0313 00000000 		.space	5
 8113      00
 8114 0318 01       		.byte	1
 8115 0319 01       		.byte	1
 8116 031a 02       		.byte	2
 8117 031b 00       		.byte	0
 8118 031c 00       		.byte	0
 8119 031d 09       		.byte	9
 8120 031e 00       		.byte	0
 8121 031f 01       		.byte	1
 8122 0320 00       		.byte	0
 8123 0321 03       		.byte	3
 8124 0322 00       		.byte	0
 8125 0323 00       		.byte	0
 8126 0324 00       		.byte	0
 8127 0325 01       		.byte	1
 8128 0326 00       		.byte	0
 8129 0327 30       		.byte	48
 8130 0328 01       		.byte	1
 8131 0329 00       		.byte	0
 8132 032a 00       		.byte	0
 8133 032b 00000000 		.space	5
 8133      00
 8134 0330 05       		.byte	5
 8135 0331 05       		.byte	5
 8136 0332 02       		.byte	2
 8137 0333 00       		.byte	0
 8138 0334 00       		.byte	0
 8139 0335 03       		.byte	3
 8140 0336 00       		.byte	0
 8141 0337 01       		.byte	1
 8142 0338 00       		.byte	0
 8143 0339 03       		.byte	3
 8144 033a 00       		.byte	0
 8145 033b 00       		.byte	0
 8146 033c 00       		.byte	0
 8147 033d 03       		.byte	3
 8148 033e 00       		.byte	0
 8149 033f 30       		.byte	48
 8150 0340 01       		.byte	1
 8151 0341 00       		.byte	0
 8152 0342 00       		.byte	0
 8153 0343 00000000 		.space	5
 8153      00
 8154 0348 18       		.byte	24
 8155 0349 18       		.byte	24
 8156 034a 02       		.byte	2
 8157 034b 00       		.byte	0
 8158 034c 00       		.byte	0
 8159 034d 01       		.byte	1
 8160 034e 00       		.byte	0
 8161 034f 01       		.byte	1
 8162 0350 00       		.byte	0
 8163 0351 03       		.byte	3
 8164 0352 00       		.byte	0
 8165 0353 00       		.byte	0
 8166 0354 00       		.byte	0
 8167 0355 00       		.byte	0
 8168 0356 00       		.byte	0
 8169 0357 30       		.byte	48
 8170 0358 01       		.byte	1
 8171 0359 00       		.byte	0
 8172 035a 00       		.byte	0
 8173 035b 00000000 		.space	5
 8173      00
 8174 0360 19       		.byte	25
 8175 0361 19       		.byte	25
 8176 0362 01       		.byte	1
 8177 0363 00       		.byte	0
 8178 0364 00       		.byte	0
 8179 0365 40       		.byte	64
 8180 0366 00       		.byte	0
 8181 0367 01       		.byte	1
 8182 0368 00       		.byte	0
 8183 0369 03       		.byte	3
 8184 036a 00       		.byte	0
 8185 036b 20       		.byte	32
 8186 036c 00       		.byte	0
 8187 036d 20       		.byte	32
 8188 036e 00       		.byte	0
 8189 036f 30       		.byte	48
 8190 0370 01       		.byte	1
 8191 0371 00       		.byte	0
 8192 0372 00       		.byte	0
 8193 0373 00000000 		.space	5
 8193      00
 8194 0378 20       		.byte	32
 8195 0379 20       		.byte	32
 8196 037a 02       		.byte	2
 8197 037b 00       		.byte	0
 8198 037c 00       		.byte	0
 8199 037d 02       		.byte	2
 8200 037e 00       		.byte	0
 8201 037f 01       		.byte	1
 8202 0380 00       		.byte	0
 8203 0381 03       		.byte	3
 8204 0382 00       		.byte	0
 8205 0383 00       		.byte	0
 8206 0384 00       		.byte	0
 8207 0385 00       		.byte	0
 8208 0386 00       		.byte	0
 8209 0387 30       		.byte	48
 8210 0388 01       		.byte	1
 8211 0389 00       		.byte	0
 8212 038a 00       		.byte	0
 8213 038b 00000000 		.space	5
 8213      00
 8214 0390 22       		.byte	34
 8215 0391 22       		.byte	34
 8216 0392 02       		.byte	2
 8217 0393 00       		.byte	0
 8218 0394 00       		.byte	0
 8219 0395 3F       		.byte	63
 8220 0396 00       		.byte	0
 8221 0397 01       		.byte	1
 8222 0398 00       		.byte	0
 8223 0399 03       		.byte	3
 8224 039a 00       		.byte	0
 8225 039b 00       		.byte	0
 8226 039c 00       		.byte	0
 8227 039d 00       		.byte	0
 8228 039e 00       		.byte	0
 8229 039f 30       		.byte	48
 8230 03a0 01       		.byte	1
 8231 03a1 00       		.byte	0
 8232 03a2 00       		.byte	0
 8233 03a3 00000000 		.space	5
 8233      00
 8234 03a8 23       		.byte	35
 8235 03a9 23       		.byte	35
 8236 03aa 02       		.byte	2
 8237 03ab 00       		.byte	0
 8238 03ac 00       		.byte	0
 8239 03ad 64       		.byte	100
 8240 03ae 00       		.byte	0
 8241 03af 01       		.byte	1
 8242 03b0 00       		.byte	0
 8243 03b1 03       		.byte	3
 8244 03b2 00       		.byte	0
 8245 03b3 10       		.byte	16
 8246 03b4 00       		.byte	0
 8247 03b5 10       		.byte	16
 8248 03b6 00       		.byte	0
 8249 03b7 30       		.byte	48
 8250 03b8 01       		.byte	1
 8251 03b9 00       		.byte	0
 8252 03ba 00       		.byte	0
 8253 03bb 00000000 		.space	5
 8253      00
 8254 03c0 24       		.byte	36
 8255 03c1 24       		.byte	36
 8256 03c2 02       		.byte	2
 8257 03c3 00       		.byte	0
 8258 03c4 00       		.byte	0
 8259 03c5 64       		.byte	100
 8260 03c6 00       		.byte	0
 8261 03c7 01       		.byte	1
 8262 03c8 00       		.byte	0
 8263 03c9 03       		.byte	3
 8264 03ca 00       		.byte	0
 8265 03cb 10       		.byte	16
 8266 03cc 00       		.byte	0
 8267 03cd 10       		.byte	16
 8268 03ce 00       		.byte	0
 8269 03cf 30       		.byte	48
 8270 03d0 01       		.byte	1
 8271 03d1 00       		.byte	0
 8272 03d2 00       		.byte	0
 8273 03d3 00000000 		.space	5
 8273      00
 8274 03d8 02       		.byte	2
 8275 03d9 03       		.byte	3
 8276 03da 04       		.byte	4
 8277 03db 00       		.byte	0
 8278 03dc 00       		.byte	0
 8279 03dd 7F       		.byte	127
 8280 03de 00       		.byte	0
 8281 03df 01       		.byte	1
 8282 03e0 00       		.byte	0
 8283 03e1 03       		.byte	3
 8284 03e2 00       		.byte	0
 8285 03e3 00       		.byte	0
 8286 03e4 20       		.byte	32
 8287 03e5 00       		.byte	0
 8288 03e6 20       		.byte	32
 8289 03e7 30       		.byte	48
 8290 03e8 01       		.byte	1
 8291 03e9 00       		.byte	0
 8292 03ea 00       		.byte	0
 8293 03eb 00000000 		.space	5
 8293      00
 8294 03f0 04       		.byte	4
 8295 03f1 0C       		.byte	12
 8296 03f2 02       		.byte	2
 8297 03f3 00       		.byte	0
 8298 03f4 00       		.byte	0
 8299 03f5 40       		.byte	64
 8300 03f6 00       		.byte	0
 8301 03f7 01       		.byte	1
 8302 03f8 00       		.byte	0
 8303 03f9 03       		.byte	3
 8304 03fa 00       		.byte	0
 8305 03fb 20       		.byte	32
 8306 03fc 00       		.byte	0
 8307 03fd 20       		.byte	32
 8308 03fe 00       		.byte	0
 8309 03ff 30       		.byte	48
 8310 0400 01       		.byte	1
 8311 0401 00       		.byte	0
 8312 0402 00       		.byte	0
 8313 0403 00000000 		.space	5
 8313      00
 8314 0408 00       		.byte	0
 8315 0409 00       		.byte	0
 8316 040a 02       		.byte	2
 8317 040b 00       		.byte	0
 8318 040c 00       		.byte	0
 8319 040d 19       		.byte	25
 8320 040e 00       		.byte	0
 8321 040f 01       		.byte	1
 8322 0410 00       		.byte	0
 8323 0411 03       		.byte	3
 8324 0412 00       		.byte	0
 8325 0413 00       		.byte	0
 8326 0414 00       		.byte	0
 8327 0415 00       		.byte	0
 8328 0416 00       		.byte	0
 8329 0417 30       		.byte	48
 8330 0418 01       		.byte	1
 8331 0419 00       		.byte	0
 8332 041a 00       		.byte	0
 8333 041b 00000000 		.space	5
 8333      00
 8334 0420 10       		.byte	16
 8335 0421 10       		.byte	16
 8336 0422 02       		.byte	2
 8337 0423 00       		.byte	0
 8338 0424 00       		.byte	0
 8339 0425 06       		.byte	6
 8340 0426 00       		.byte	0
 8341 0427 01       		.byte	1
 8342 0428 00       		.byte	0
 8343 0429 03       		.byte	3
 8344 042a 00       		.byte	0
 8345 042b 00       		.byte	0
 8346 042c 00       		.byte	0
 8347 042d 00       		.byte	0
 8348 042e 00       		.byte	0
 8349 042f 30       		.byte	48
 8350 0430 01       		.byte	1
 8351 0431 00       		.byte	0
 8352 0432 00       		.byte	0
 8353 0433 00000000 		.space	5
 8353      00
 8354 0438 00       		.byte	0
 8355 0439 00       		.byte	0
 8356 043a 02       		.byte	2
 8357 043b 00       		.byte	0
 8358 043c 00       		.byte	0
 8359 043d 03       		.byte	3
 8360 043e 00       		.byte	0
 8361 043f 01       		.byte	1
 8362 0440 00       		.byte	0
 8363 0441 03       		.byte	3
 8364 0442 00       		.byte	0
 8365 0443 00       		.byte	0
 8366 0444 00       		.byte	0
 8367 0445 00       		.byte	0
 8368 0446 00       		.byte	0
 8369 0447 30       		.byte	48
 8370 0448 01       		.byte	1
 8371 0449 00       		.byte	0
 8372 044a 00       		.byte	0
 8373 044b 00000000 		.space	5
 8373      00
 8374 0450 50       		.byte	80
 8375 0451 50       		.byte	80
 8376 0452 01       		.byte	1
 8377 0453 00       		.byte	0
 8378 0454 00       		.byte	0
 8379 0455 03       		.byte	3
 8380 0456 00       		.byte	0
 8381 0457 01       		.byte	1
 8382 0458 00       		.byte	0
 8383 0459 03       		.byte	3
 8384 045a 00       		.byte	0
 8385 045b 00       		.byte	0
 8386 045c 00       		.byte	0
 8387 045d 00       		.byte	0
 8388 045e 00       		.byte	0
 8389 045f 30       		.byte	48
 8390 0460 01       		.byte	1
 8391 0461 00       		.byte	0
 8392 0462 00       		.byte	0
 8393 0463 00000000 		.space	5
 8393      00
 8394 0468 00       		.byte	0
 8395 0469 00       		.byte	0
 8396 046a 0B       		.byte	11
 8397 046b 00       		.byte	0
 8398 046c 00       		.byte	0
 8399 046d FF       		.byte	-1
 8400 046e FF       		.byte	-1
 8401 046f 01       		.byte	1
 8402 0470 00       		.byte	0
 8403 0471 03       		.byte	3
 8404 0472 00       		.byte	0
 8405 0473 00       		.byte	0
 8406 0474 00       		.byte	0
 8407 0475 00       		.byte	0
 8408 0476 00       		.byte	0
 8409 0477 00       		.byte	0
 8410 0478 01       		.byte	1
 8411 0479 00       		.byte	0
 8412 047a 00       		.byte	0
 8413 047b 00000000 		.space	5
 8413      00
 8416              	glUVCHeader:
 8417 0480 0C       		.byte	12
 8418 0481 8C       		.byte	-116
 8419 0482 00       		.byte	0
 8420 0483 00       		.byte	0
 8421 0484 00       		.byte	0
 8422 0485 00       		.byte	0
 8423 0486 00       		.byte	0
 8424 0487 00       		.byte	0
 8425 0488 00       		.byte	0
 8426 0489 00       		.byte	0
 8427 048a 00       		.byte	0
 8428 048b 00       		.byte	0
 8431              	WBMenuCmpArry:
 8432 048c 20       		.byte	32
 8433 048d 0F       		.byte	15
 8434 048e 38       		.byte	56
 8435 048f F0       		.byte	-16
 8438              	CTCtrlParArry:
 8439 0490 00       		.byte	0
 8440 0491 00       		.byte	0
 8441 0492 01       		.byte	1
 8442 0493 00       		.byte	0
 8443 0494 00       		.byte	0
 8444 0495 03       		.byte	3
 8445 0496 00       		.byte	0
 8446 0497 01       		.byte	1
 8447 0498 00       		.byte	0
 8448 0499 03       		.byte	3
 8449 049a 00       		.byte	0
 8450 049b 03       		.byte	3
 8451 049c 00       		.byte	0
 8452 049d 03       		.byte	3
 8453 049e 00       		.byte	0
 8454 049f 30       		.byte	48
 8455 04a0 01       		.byte	1
 8456 04a1 00       		.byte	0
 8457 04a2 00       		.byte	0
 8458 04a3 00000000 		.space	5
 8458      00
 8459 04a8 00       		.byte	0
 8460 04a9 00       		.byte	0
 8461 04aa 01       		.byte	1
 8462 04ab 01       		.byte	1
 8463 04ac 00       		.byte	0
 8464 04ad 0F       		.byte	15
 8465 04ae 00       		.byte	0
 8466 04af 0F       		.byte	15
 8467 04b0 00       		.byte	0
 8468 04b1 03       		.byte	3
 8469 04b2 00       		.byte	0
 8470 04b3 02       		.byte	2
 8471 04b4 00       		.byte	0
 8472 04b5 02       		.byte	2
 8473 04b6 00       		.byte	0
 8474 04b7 30       		.byte	48
 8475 04b8 01       		.byte	1
 8476 04b9 01       		.byte	1
 8477 04ba 00       		.byte	0
 8478 04bb 00000000 		.space	5
 8478      00
 8479 04c0 02       		.byte	2
 8480 04c1 00       		.byte	0
 8481 04c2 01       		.byte	1
 8482 04c3 00       		.byte	0
 8483 04c4 00       		.byte	0
 8484 04c5 01       		.byte	1
 8485 04c6 00       		.byte	0
 8486 04c7 01       		.byte	1
 8487 04c8 00       		.byte	0
 8488 04c9 03       		.byte	3
 8489 04ca 00       		.byte	0
 8490 04cb 00       		.byte	0
 8491 04cc 00       		.byte	0
 8492 04cd 00       		.byte	0
 8493 04ce 00       		.byte	0
 8494 04cf 30       		.byte	48
 8495 04d0 01       		.byte	1
 8496 04d1 01       		.byte	1
 8497 04d2 00       		.byte	0
 8498 04d3 00000000 		.space	5
 8498      00
 8499 04d8 00       		.byte	0
 8500 04d9 00       		.byte	0
 8501 04da 04       		.byte	4
 8502 04db 01       		.byte	1
 8503 04dc 00       		.byte	0
 8504 04dd 38       		.byte	56
 8505 04de 01       		.byte	1
 8506 04df 01       		.byte	1
 8507 04e0 00       		.byte	0
 8508 04e1 03       		.byte	3
 8509 04e2 00       		.byte	0
 8510 04e3 4E       		.byte	78
 8511 04e4 00       		.byte	0
 8512 04e5 4E       		.byte	78
 8513 04e6 00       		.byte	0
 8514 04e7 30       		.byte	48
 8515 04e8 01       		.byte	1
 8516 04e9 00       		.byte	0
 8517 04ea 00       		.byte	0
 8518 04eb 00000000 		.space	5
 8518      00
 8519 04f0 04       		.byte	4
 8520 04f1 00       		.byte	0
 8521 04f2 01       		.byte	1
 8522 04f3 00       		.byte	0
 8523 04f4 00       		.byte	0
 8524 04f5 00       		.byte	0
 8525 04f6 00       		.byte	0
 8526 04f7 01       		.byte	1
 8527 04f8 00       		.byte	0
 8528 04f9 03       		.byte	3
 8529 04fa 00       		.byte	0
 8530 04fb 00       		.byte	0
 8531 04fc 00       		.byte	0
 8532 04fd 00       		.byte	0
 8533 04fe 00       		.byte	0
 8534 04ff 30       		.byte	48
 8535 0500 01       		.byte	1
 8536 0501 00       		.byte	0
 8537 0502 00       		.byte	0
 8538 0503 00000000 		.space	5
 8538      00
 8539 0508 05       		.byte	5
 8540 0509 00       		.byte	0
 8541 050a 02       		.byte	2
 8542 050b 00       		.byte	0
 8543 050c 00       		.byte	0
 8544 050d FF       		.byte	-1
 8545 050e 00       		.byte	0
 8546 050f 01       		.byte	1
 8547 0510 00       		.byte	0
 8548 0511 03       		.byte	3
 8549 0512 00       		.byte	0
 8550 0513 01       		.byte	1
 8551 0514 00       		.byte	0
 8552 0515 00       		.byte	0
 8553 0516 00       		.byte	0
 8554 0517 30       		.byte	48
 8555 0518 01       		.byte	1
 8556 0519 01       		.byte	1
 8557 051a 00       		.byte	0
 8558 051b 00000000 		.space	5
 8558      00
 8559 0520 06       		.byte	6
 8560 0521 00       		.byte	0
 8561 0522 02       		.byte	2
 8562 0523 00       		.byte	0
 8563 0524 00       		.byte	0
 8564 0525 00       		.byte	0
 8565 0526 00       		.byte	0
 8566 0527 00       		.byte	0
 8567 0528 00       		.byte	0
 8568 0529 03       		.byte	3
 8569 052a 00       		.byte	0
 8570 052b 00       		.byte	0
 8571 052c 00       		.byte	0
 8572 052d 00       		.byte	0
 8573 052e 00       		.byte	0
 8574 052f 30       		.byte	48
 8575 0530 01       		.byte	1
 8576 0531 01       		.byte	1
 8577 0532 00       		.byte	0
 8578 0533 00000000 		.space	5
 8578      00
 8579 0538 23       		.byte	35
 8580 0539 00       		.byte	0
 8581 053a 02       		.byte	2
 8582 053b 00       		.byte	0
 8583 053c 00       		.byte	0
 8584 053d 30       		.byte	48
 8585 053e 00       		.byte	0
 8586 053f 01       		.byte	1
 8587 0540 00       		.byte	0
 8588 0541 03       		.byte	3
 8589 0542 0A       		.byte	10
 8590 0543 00       		.byte	0
 8591 0544 00       		.byte	0
 8592 0545 0A       		.byte	10
 8593 0546 00       		.byte	0
 8594 0547 30       		.byte	48
 8595 0548 01       		.byte	1
 8596 0549 01       		.byte	1
 8597 054a 00       		.byte	0
 8598 054b 00000000 		.space	5
 8598      00
 8599 0550 08       		.byte	8
 8600 0551 00       		.byte	0
 8601 0552 01       		.byte	1
 8602 0553 00       		.byte	0
 8603 0554 00       		.byte	0
 8604 0555 7F       		.byte	127
 8605 0556 00       		.byte	0
 8606 0557 01       		.byte	1
 8607 0558 00       		.byte	0
 8608 0559 03       		.byte	3
 8609 055a 00       		.byte	0
 8610 055b 00       		.byte	0
 8611 055c 00       		.byte	0
 8612 055d 00       		.byte	0
 8613 055e 00       		.byte	0
 8614 055f 30       		.byte	48
 8615 0560 01       		.byte	1
 8616 0561 00       		.byte	0
 8617 0562 00       		.byte	0
 8618 0563 00000000 		.space	5
 8618      00
 8619 0568 09       		.byte	9
 8620 0569 00       		.byte	0
 8621 056a 02       		.byte	2
 8622 056b 00       		.byte	0
 8623 056c 00       		.byte	0
 8624 056d 05       		.byte	5
 8625 056e 00       		.byte	0
 8626 056f 01       		.byte	1
 8627 0570 00       		.byte	0
 8628 0571 03       		.byte	3
 8629 0572 00       		.byte	0
 8630 0573 00       		.byte	0
 8631 0574 00       		.byte	0
 8632 0575 00       		.byte	0
 8633 0576 00       		.byte	0
 8634 0577 30       		.byte	48
 8635 0578 01       		.byte	1
 8636 0579 00       		.byte	0
 8637 057a 00       		.byte	0
 8638 057b 00000000 		.space	5
 8638      00
 8639 0580 10       		.byte	16
 8640 0581 00       		.byte	0
 8641 0582 03       		.byte	3
 8642 0583 00       		.byte	0
 8643 0584 00       		.byte	0
 8644 0585 00       		.byte	0
 8645 0586 00       		.byte	0
 8646 0587 00       		.byte	0
 8647 0588 00       		.byte	0
 8648 0589 03       		.byte	3
 8649 058a 00       		.byte	0
 8650 058b 00       		.byte	0
 8651 058c 00       		.byte	0
 8652 058d 00       		.byte	0
 8653 058e 00       		.byte	0
 8654 058f 30       		.byte	48
 8655 0590 01       		.byte	1
 8656 0591 00       		.byte	0
 8657 0592 00       		.byte	0
 8658 0593 00000000 		.space	5
 8658      00
 8659 0598 00       		.byte	0
 8660 0599 00       		.byte	0
 8661 059a 02       		.byte	2
 8662 059b 00       		.byte	0
 8663 059c 00       		.byte	0
 8664 059d 40       		.byte	64
 8665 059e 00       		.byte	0
 8666 059f 01       		.byte	1
 8667 05a0 00       		.byte	0
 8668 05a1 03       		.byte	3
 8669 05a2 00       		.byte	0
 8670 05a3 0F       		.byte	15
 8671 05a4 11       		.byte	17
 8672 05a5 00       		.byte	0
 8673 05a6 00       		.byte	0
 8674 05a7 30       		.byte	48
 8675 05a8 01       		.byte	1
 8676 05a9 00       		.byte	0
 8677 05aa 00       		.byte	0
 8678 05ab 00000000 		.space	5
 8678      00
 8679 05b0 00       		.byte	0
 8680 05b1 00       		.byte	0
 8681 05b2 02       		.byte	2
 8682 05b3 00       		.byte	0
 8683 05b4 00       		.byte	0
 8684 05b5 64       		.byte	100
 8685 05b6 00       		.byte	0
 8686 05b7 01       		.byte	1
 8687 05b8 00       		.byte	0
 8688 05b9 03       		.byte	3
 8689 05ba 00       		.byte	0
 8690 05bb 00       		.byte	0
 8691 05bc 00       		.byte	0
 8692 05bd 00       		.byte	0
 8693 05be 00       		.byte	0
 8694 05bf 30       		.byte	48
 8695 05c0 01       		.byte	1
 8696 05c1 00       		.byte	0
 8697 05c2 00       		.byte	0
 8698 05c3 00000000 		.space	5
 8698      00
 8699 05c8 00       		.byte	0
 8700 05c9 00       		.byte	0
 8701 05ca 02       		.byte	2
 8702 05cb 00       		.byte	0
 8703 05cc 00       		.byte	0
 8704 05cd 64       		.byte	100
 8705 05ce 00       		.byte	0
 8706 05cf 01       		.byte	1
 8707 05d0 00       		.byte	0
 8708 05d1 03       		.byte	3
 8709 05d2 00       		.byte	0
 8710 05d3 00       		.byte	0
 8711 05d4 00       		.byte	0
 8712 05d5 00       		.byte	0
 8713 05d6 00       		.byte	0
 8714 05d7 30       		.byte	48
 8715 05d8 01       		.byte	1
 8716 05d9 00       		.byte	0
 8717 05da 00       		.byte	0
 8718 05db 00000000 		.space	5
 8718      00
 8719 05e0 00       		.byte	0
 8720 05e1 00       		.byte	0
 8721 05e2 02       		.byte	2
 8722 05e3 00       		.byte	0
 8723 05e4 00       		.byte	0
 8724 05e5 64       		.byte	100
 8725 05e6 00       		.byte	0
 8726 05e7 01       		.byte	1
 8727 05e8 00       		.byte	0
 8728 05e9 03       		.byte	3
 8729 05ea 00       		.byte	0
 8730 05eb 00       		.byte	0
 8731 05ec 00       		.byte	0
 8732 05ed 00       		.byte	0
 8733 05ee 00       		.byte	0
 8734 05ef 30       		.byte	48
 8735 05f0 01       		.byte	1
 8736 05f1 00       		.byte	0
 8737 05f2 00       		.byte	0
 8738 05f3 00000000 		.space	5
 8738      00
 8739 05f8 00       		.byte	0
 8740 05f9 00       		.byte	0
 8741 05fa 02       		.byte	2
 8742 05fb 00       		.byte	0
 8743 05fc 00       		.byte	0
 8744 05fd 64       		.byte	100
 8745 05fe 00       		.byte	0
 8746 05ff 01       		.byte	1
 8747 0600 00       		.byte	0
 8748 0601 03       		.byte	3
 8749 0602 00       		.byte	0
 8750 0603 00       		.byte	0
 8751 0604 00       		.byte	0
 8752 0605 00       		.byte	0
 8753 0606 00       		.byte	0
 8754 0607 30       		.byte	48
 8755 0608 01       		.byte	1
 8756 0609 00       		.byte	0
 8757 060a 00       		.byte	0
 8758 060b 00000000 		.space	5
 8758      00
 8761              	WDRflag:
 8762 0610 01000000 		.word	1
 8765              	glProbeCtrl:
 8766 0614 00       		.byte	0
 8767 0615 00       		.byte	0
 8768 0616 01       		.byte	1
 8769 0617 01       		.byte	1
 8770 0618 15       		.byte	21
 8771 0619 16       		.byte	22
 8772 061a 05       		.byte	5
 8773 061b 00       		.byte	0
 8774 061c 00       		.byte	0
 8775 061d 00       		.byte	0
 8776 061e 00       		.byte	0
 8777 061f 00       		.byte	0
 8778 0620 00       		.byte	0
 8779 0621 00       		.byte	0
 8780 0622 00       		.byte	0
 8781 0623 00       		.byte	0
 8782 0624 00       		.byte	0
 8783 0625 00       		.byte	0
 8784 0626 00       		.byte	0
 8785 0627 48       		.byte	72
 8786 0628 3F       		.byte	63
 8787 0629 00       		.byte	0
 8788 062a 00       		.byte	0
 8789 062b 40       		.byte	64
 8790 062c 00       		.byte	0
 8791 062d 00       		.byte	0
 8792 062e 0000     		.space	2
 8795              	glProbeCtrl20:
 8796 0630 00       		.byte	0
 8797 0631 00       		.byte	0
 8798 0632 01       		.byte	1
 8799 0633 01       		.byte	1
 8800 0634 80       		.byte	-128
 8801 0635 1A       		.byte	26
 8802 0636 06       		.byte	6
 8803 0637 00       		.byte	0
 8804 0638 00       		.byte	0
 8805 0639 00       		.byte	0
 8806 063a 00       		.byte	0
 8807 063b 00       		.byte	0
 8808 063c 00       		.byte	0
 8809 063d 00       		.byte	0
 8810 063e 00       		.byte	0
 8811 063f 00       		.byte	0
 8812 0640 00       		.byte	0
 8813 0641 00       		.byte	0
 8814 0642 00       		.byte	0
 8815 0643 D2       		.byte	-46
 8816 0644 0F       		.byte	15
 8817 0645 00       		.byte	0
 8818 0646 00       		.byte	0
 8819 0647 40       		.byte	64
 8820 0648 00       		.byte	0
 8821 0649 00       		.byte	0
 8822 064a 0000     		.space	2
 8825              	glProbeStilCtrl:
 8826 064c 01       		.byte	1
 8827 064d 01       		.byte	1
 8828 064e 00       		.byte	0
 8829 064f 00       		.byte	0
 8830 0650 48       		.byte	72
 8831 0651 3F       		.byte	63
 8832 0652 00       		.byte	0
 8833 0653 00       		.byte	0
 8834 0654 40       		.byte	64
 8835 0655 00       		.byte	0
 8836 0656 00       		.byte	0
 8837 0657 00       		.space	1
 8840              	glProbeStilCtrl20:
 8841 0658 01       		.byte	1
 8842 0659 01       		.byte	1
 8843 065a 00       		.byte	0
 8844 065b 00       		.byte	0
 8845 065c D2       		.byte	-46
 8846 065d 0F       		.byte	15
 8847 065e 00       		.byte	0
 8848 065f 00       		.byte	0
 8849 0660 40       		.byte	64
 8850 0661 00       		.byte	0
 8851 0662 00       		.byte	0
 8854              	snapButFlag:
 8855 0663 01       		.byte	1
 8858              	CyFxGpifTransition:
 8859 0664 0000     		.short	0
 8860 0666 5555     		.short	21845
 8861 0668 8888     		.short	-30584
 8862 066a AAAA     		.short	-21846
 8863 066c 3333     		.short	13107
 8864 066e 0000     		.space	2
 8867              	CyFxGpifWavedata:
 8868 0670 0181731E 		.word	510886145
 8869 0674 00000000 		.word	0
 8870 0678 00000080 		.word	-2147483648
 8871 067c 00000000 		.word	0
 8872 0680 00000000 		.word	0
 8873 0684 00000000 		.word	0
 8874 0688 0201702E 		.word	779092226
 8875 068c 00010000 		.word	256
 8876 0690 A0000080 		.word	-2147483488
 8877 0694 00000000 		.word	0
 8878 0698 00000000 		.word	0
 8879 069c 00000000 		.word	0
 8880 06a0 0380722E 		.word	779255811
 8881 06a4 02010020 		.word	536871170
 8882 06a8 60000080 		.word	-2147483552
 8883 06ac 00000000 		.word	0
 8884 06b0 00000000 		.word	0
 8885 06b4 00000000 		.word	0
 8886 06b8 0460722E 		.word	779247620
 8887 06bc 02010024 		.word	603980034
 8888 06c0 90000080 		.word	-2147483504
 8889 06c4 0594731E 		.word	510891013
 8890 06c8 06000000 		.word	6
 8891 06cc 00000080 		.word	-2147483648
 8892 06d0 0380722E 		.word	779255811
 8893 06d4 02010020 		.word	536871170
 8894 06d8 60000080 		.word	-2147483552
 8895 06dc 0693731E 		.word	510890758
 8896 06e0 06000000 		.word	6
 8897 06e4 00000080 		.word	-2147483648
 8898 06e8 0720703E 		.word	1047535623
 8899 06ec 08010000 		.word	264
 8900 06f0 00000080 		.word	-2147483648
 8901 06f4 0820703E 		.word	1047535624
 8902 06f8 08010000 		.word	264
 8903 06fc 00000080 		.word	-2147483648
 8904 0700 0920703E 		.word	1047535625
 8905 0704 08010000 		.word	264
 8906 0708 00000080 		.word	-2147483648
 8907 070c 0A20703E 		.word	1047535626
 8908 0710 08010000 		.word	264
 8909 0714 00000080 		.word	-2147483648
 8910 0718 0380722E 		.word	779255811
 8911 071c 02010020 		.word	536871170
 8912 0720 60000080 		.word	-2147483552
 8913 0724 0B000000 		.word	11
 8914 0728 00000000 		.word	0
 8915 072c 00010080 		.word	-2147483392
 8916 0730 0460722E 		.word	779247620
 8917 0734 02010024 		.word	603980034
 8918 0738 90000080 		.word	-2147483504
 8919 073c 0D000000 		.word	13
 8920 0740 00000000 		.word	0
 8921 0744 00010080 		.word	-2147483392
 8922 0748 0460722E 		.word	779247620
 8923 074c 02010024 		.word	603980034
 8924 0750 90000080 		.word	-2147483504
 8925 0754 0C000000 		.word	12
 8926 0758 00000000 		.word	0
 8927 075c 00010080 		.word	-2147483392
 8928 0760 0380722E 		.word	779255811
 8929 0764 02010020 		.word	536871170
 8930 0768 60000080 		.word	-2147483552
 8931 076c 0E000000 		.word	14
 8932 0770 00000000 		.word	0
 8933 0774 00010080 		.word	-2147483392
 8934 0778 00000000 		.word	0
 8935 077c 00000000 		.word	0
 8936 0780 00000000 		.word	0
 8937 0784 00000000 		.word	0
 8938 0788 00000000 		.word	0
 8939 078c 00000000 		.word	0
 8942              	CyFxGpifWavedataPosition:
 8943 0790 00       		.byte	0
 8944 0791 01       		.byte	1
 8945 0792 02       		.byte	2
 8946 0793 03       		.byte	3
 8947 0794 04       		.byte	4
 8948 0795 05       		.byte	5
 8949 0796 06       		.byte	6
 8950 0797 07       		.byte	7
 8951 0798 08       		.byte	8
 8952 0799 09       		.byte	9
 8953 079a 0A       		.byte	10
 8954 079b 0B       		.byte	11
 8955 079c 0B       		.byte	11
 8956 079d 0B       		.byte	11
 8957 079e 0B       		.byte	11
 8958 079f 00       		.space	1
 8961              	CyFxGpifRegValue:
 8962 07a0 08830080 		.word	-2147450104
 8963 07a4 67000000 		.word	103
 8964 07a8 00000000 		.word	0
 8965 07ac 46000000 		.word	70
 8966 07b0 00000000 		.word	0
 8967 07b4 00000000 		.word	0
 8968 07b8 02000000 		.word	2
 8969 07bc 82000000 		.word	130
 8970 07c0 82070000 		.word	1922
 8971 07c4 40040000 		.word	1088
 8972 07c8 FCFF0000 		.word	65532
 8973 07cc 28000000 		.word	40
 8974 07d0 00000000 		.word	0
 8975 07d4 00000000 		.word	0
 8976 07d8 00000000 		.word	0
 8977 07dc 00000000 		.word	0
 8978 07e0 01000000 		.word	1
 8979 07e4 00000000 		.word	0
 8980 07e8 00000000 		.word	0
 8981 07ec 00000000 		.word	0
 8982 07f0 00000000 		.word	0
 8983 07f4 00000000 		.word	0
 8984 07f8 00000000 		.word	0
 8985 07fc 00000000 		.word	0
 8986 0800 00000000 		.word	0
 8987 0804 00000000 		.word	0
 8988 0808 00000000 		.word	0
 8989 080c 00000000 		.word	0
 8990 0810 00000000 		.word	0
 8991 0814 06000000 		.word	6
 8992 0818 00000000 		.word	0
 8993 081c FFFF0000 		.word	65535
 8994 0820 09010000 		.word	265
 8995 0824 00000000 		.word	0
 8996 0828 F71F0000 		.word	8183
 8997 082c 00000000 		.word	0
 8998 0830 FFFF0000 		.word	65535
 8999 0834 09010000 		.word	265
 9000 0838 00000000 		.word	0
 9001 083c F71F0000 		.word	8183
 9002 0840 00000000 		.word	0
 9003 0844 00000000 		.word	0
 9004 0848 00000000 		.word	0
 9005 084c 00000000 		.word	0
 9006 0850 00000000 		.word	0
 9007 0854 00000000 		.word	0
 9008 0858 00000000 		.word	0
 9009 085c 00000000 		.word	0
 9010 0860 00000000 		.word	0
 9011 0864 00000000 		.word	0
 9012 0868 00000000 		.word	0
 9013 086c 00000000 		.word	0
 9014 0870 00000000 		.word	0
 9015 0874 00000000 		.word	0
 9016 0878 00000000 		.word	0
 9017 087c 00000000 		.word	0
 9018 0880 00000000 		.word	0
 9019 0884 00000000 		.word	0
 9020 0888 00000000 		.word	0
 9021 088c 00000000 		.word	0
 9022 0890 00000000 		.word	0
 9023 0894 00000000 		.word	0
 9024 0898 00000000 		.word	0
 9025 089c 00040180 		.word	-2147417088
 9026 08a0 01040180 		.word	-2147417087
 9027 08a4 02040180 		.word	-2147417086
 9028 08a8 03040180 		.word	-2147417085
 9029 08ac 00000000 		.word	0
 9030 08b0 00000000 		.word	0
 9031 08b4 00000000 		.word	0
 9032 08b8 00000000 		.word	0
 9033 08bc 00000000 		.word	0
 9034 08c0 00000000 		.word	0
 9035 08c4 00000000 		.word	0
 9036 08c8 00000000 		.word	0
 9037 08cc C1FFFFFF 		.word	-63
 9040              	CyFxGpifTransition_usb2:
 9041 08d0 0000     		.short	0
 9042 08d2 5555     		.short	21845
 9043 08d4 AAAA     		.short	-21846
 9044 08d6 8888     		.short	-30584
 9045 08d8 1111     		.short	4369
 9046 08da 4444     		.short	17476
 9047 08dc 3333     		.short	13107
 9048 08de CCCC     		.short	-13108
 9051              	CyFxGpifWavedata_usb2:
 9052 08e0 0181731E 		.word	510886145
 9053 08e4 00000000 		.word	0
 9054 08e8 00000080 		.word	-2147483648
 9055 08ec 00000000 		.word	0
 9056 08f0 00000000 		.word	0
 9057 08f4 00000000 		.word	0
 9058 08f8 0201703E 		.word	1047527682
 9059 08fc 00010000 		.word	256
 9060 0900 A00000C0 		.word	-1073741664
 9061 0904 00000000 		.word	0
 9062 0908 00000000 		.word	0
 9063 090c 00000000 		.word	0
 9064 0910 0394731E 		.word	510891011
 9065 0914 04000020 		.word	536870916
 9066 0918 60004080 		.word	-2143289248
 9067 091c 00000000 		.word	0
 9068 0920 00000000 		.word	0
 9069 0924 00000000 		.word	0
 9070 0928 0620702E 		.word	779100166
 9071 092c 0C000000 		.word	12
 9072 0930 00000080 		.word	-2147483648
 9073 0934 0620702E 		.word	779100166
 9074 0938 0C000000 		.word	12
 9075 093c 00000080 		.word	-2147483648
 9076 0940 0394731E 		.word	510891011
 9077 0944 04000020 		.word	536870916
 9078 0948 60004080 		.word	-2143289248
 9079 094c 0620702E 		.word	779100166
 9080 0950 0C000000 		.word	12
 9081 0954 00000080 		.word	-2147483648
 9082 0958 0C93731E 		.word	510890764
 9083 095c 04000024 		.word	603979780
 9084 0960 90004080 		.word	-2143289200
 9085 0964 0D20702E 		.word	779100173
 9086 0968 0C000000 		.word	12
 9087 096c 00000080 		.word	-2147483648
 9088 0970 0780724E 		.word	1316126727
 9089 0974 0A000000 		.word	10
 9090 0978 00000080 		.word	-2147483648
 9091 097c 08000000 		.word	8
 9092 0980 00000000 		.word	0
 9093 0984 00010080 		.word	-2147483392
 9094 0988 0920702E 		.word	779100169
 9095 098c 0C010000 		.word	268
 9096 0990 00000080 		.word	-2147483648
 9097 0994 0A01701E 		.word	510656778
 9098 0998 0E000100 		.word	65550
 9099 099c 00000080 		.word	-2147483648
 9100 09a0 00000000 		.word	0
 9101 09a4 00000000 		.word	0
 9102 09a8 00000000 		.word	0
 9103 09ac 00000000 		.word	0
 9104 09b0 00000000 		.word	0
 9105 09b4 00000000 		.word	0
 9106 09b8 0394731E 		.word	510891011
 9107 09bc 04000020 		.word	536870916
 9108 09c0 60004080 		.word	-2143289248
 9109 09c4 08000000 		.word	8
 9110 09c8 00000000 		.word	0
 9111 09cc 00010080 		.word	-2147483392
 9112 09d0 0B000000 		.word	11
 9113 09d4 00000000 		.word	0
 9114 09d8 00010080 		.word	-2147483392
 9115 09dc 0C93731E 		.word	510890764
 9116 09e0 04000024 		.word	603979780
 9117 09e4 90004080 		.word	-2143289200
 9118 09e8 0D20702E 		.word	779100173
 9119 09ec 0C000000 		.word	12
 9120 09f0 00000080 		.word	-2147483648
 9121 09f4 0D20702E 		.word	779100173
 9122 09f8 0C000000 		.word	12
 9123 09fc 00000080 		.word	-2147483648
 9124 0a00 0E60724E 		.word	1316118542
 9125 0a04 0A000000 		.word	10
 9126 0a08 00000080 		.word	-2147483648
 9127 0a0c 0F000000 		.word	15
 9128 0a10 00000000 		.word	0
 9129 0a14 00010080 		.word	-2147483392
 9130 0a18 1020702E 		.word	779100176
 9131 0a1c 0C010000 		.word	268
 9132 0a20 00000080 		.word	-2147483648
 9133 0a24 1101701E 		.word	510656785
 9134 0a28 0E000100 		.word	65550
 9135 0a2c 00000080 		.word	-2147483648
 9136 0a30 0C93731E 		.word	510890764
 9137 0a34 04000024 		.word	603979780
 9138 0a38 90004080 		.word	-2143289200
 9139 0a3c 0F000000 		.word	15
 9140 0a40 00000000 		.word	0
 9141 0a44 00010080 		.word	-2147483392
 9142 0a48 12000000 		.word	18
 9143 0a4c 00000000 		.word	0
 9144 0a50 00010080 		.word	-2147483392
 9145 0a54 0394731E 		.word	510891011
 9146 0a58 04000020 		.word	536870916
 9147 0a5c 60004080 		.word	-2143289248
 9148 0a60 0480732E 		.word	779321348
 9149 0a64 02010000 		.word	258
 9150 0a68 000040C0 		.word	-1069547520
 9151 0a6c 0580732E 		.word	779321349
 9152 0a70 02010000 		.word	258
 9153 0a74 000040C0 		.word	-1069547520
 9154 0a78 0580732E 		.word	779321349
 9155 0a7c 02010000 		.word	258
 9156 0a80 000040C0 		.word	-1069547520
 9157 0a84 0480732E 		.word	779321348
 9158 0a88 02010000 		.word	258
 9159 0a8c 000040C0 		.word	-1069547520
 9162              	CyFxGpifWavedataPosition_usb2:
 9163 0a90 00       		.byte	0
 9164 0a91 01       		.byte	1
 9165 0a92 02       		.byte	2
 9166 0a93 03       		.byte	3
 9167 0a94 04       		.byte	4
 9168 0a95 05       		.byte	5
 9169 0a96 06       		.byte	6
 9170 0a97 07       		.byte	7
 9171 0a98 08       		.byte	8
 9172 0a99 09       		.byte	9
 9173 0a9a 0A       		.byte	10
 9174 0a9b 08       		.byte	8
 9175 0a9c 0B       		.byte	11
 9176 0a9d 0C       		.byte	12
 9177 0a9e 0D       		.byte	13
 9178 0a9f 08       		.byte	8
 9179 0aa0 0E       		.byte	14
 9180 0aa1 0F       		.byte	15
 9181 0aa2 08       		.byte	8
 9182 0aa3 08       		.byte	8
 9183 0aa4 08       		.byte	8
 9184 0aa5 08       		.byte	8
 9185 0aa6 08       		.byte	8
 9186 0aa7 08       		.byte	8
 9187 0aa8 08       		.byte	8
 9188 0aa9 08       		.byte	8
 9189 0aaa 08       		.byte	8
 9190 0aab 08       		.byte	8
 9191 0aac 08       		.byte	8
 9192 0aad 08       		.byte	8
 9193 0aae 08       		.byte	8
 9194 0aaf 08       		.byte	8
 9195 0ab0 08       		.byte	8
 9196 0ab1 08       		.byte	8
 9197 0ab2 08       		.byte	8
 9198 0ab3 08       		.byte	8
 9199 0ab4 08       		.byte	8
 9200 0ab5 08       		.byte	8
 9201 0ab6 08       		.byte	8
 9202 0ab7 08       		.byte	8
 9203 0ab8 08       		.byte	8
 9204 0ab9 08       		.byte	8
 9205 0aba 08       		.byte	8
 9206 0abb 08       		.byte	8
 9207 0abc 08       		.byte	8
 9208 0abd 08       		.byte	8
 9209 0abe 08       		.byte	8
 9210 0abf 08       		.byte	8
 9211 0ac0 08       		.byte	8
 9212 0ac1 08       		.byte	8
 9213 0ac2 08       		.byte	8
 9214 0ac3 08       		.byte	8
 9215 0ac4 08       		.byte	8
 9216 0ac5 08       		.byte	8
 9217 0ac6 08       		.byte	8
 9218 0ac7 08       		.byte	8
 9219 0ac8 08       		.byte	8
 9220 0ac9 08       		.byte	8
 9221 0aca 08       		.byte	8
 9222 0acb 08       		.byte	8
 9223 0acc 08       		.byte	8
 9224 0acd 08       		.byte	8
 9225 0ace 08       		.byte	8
 9226 0acf 08       		.byte	8
 9227 0ad0 08       		.byte	8
 9228 0ad1 08       		.byte	8
 9229 0ad2 08       		.byte	8
 9230 0ad3 08       		.byte	8
 9231 0ad4 08       		.byte	8
 9232 0ad5 08       		.byte	8
 9233 0ad6 08       		.byte	8
 9234 0ad7 08       		.byte	8
 9235 0ad8 08       		.byte	8
 9236 0ad9 08       		.byte	8
 9237 0ada 08       		.byte	8
 9238 0adb 08       		.byte	8
 9239 0adc 08       		.byte	8
 9240 0add 08       		.byte	8
 9241 0ade 08       		.byte	8
 9242 0adf 08       		.byte	8
 9243 0ae0 08       		.byte	8
 9244 0ae1 08       		.byte	8
 9245 0ae2 08       		.byte	8
 9246 0ae3 08       		.byte	8
 9247 0ae4 08       		.byte	8
 9248 0ae5 08       		.byte	8
 9249 0ae6 08       		.byte	8
 9250 0ae7 08       		.byte	8
 9251 0ae8 08       		.byte	8
 9252 0ae9 08       		.byte	8
 9253 0aea 08       		.byte	8
 9254 0aeb 08       		.byte	8
 9255 0aec 08       		.byte	8
 9256 0aed 08       		.byte	8
 9257 0aee 08       		.byte	8
 9258 0aef 08       		.byte	8
 9259 0af0 08       		.byte	8
 9260 0af1 08       		.byte	8
 9261 0af2 08       		.byte	8
 9262 0af3 08       		.byte	8
 9263 0af4 08       		.byte	8
 9264 0af5 08       		.byte	8
 9265 0af6 08       		.byte	8
 9266 0af7 08       		.byte	8
 9267 0af8 08       		.byte	8
 9268 0af9 08       		.byte	8
 9269 0afa 08       		.byte	8
 9270 0afb 08       		.byte	8
 9271 0afc 08       		.byte	8
 9272 0afd 08       		.byte	8
 9273 0afe 08       		.byte	8
 9274 0aff 08       		.byte	8
 9275 0b00 08       		.byte	8
 9276 0b01 08       		.byte	8
 9277 0b02 08       		.byte	8
 9278 0b03 08       		.byte	8
 9279 0b04 08       		.byte	8
 9280 0b05 08       		.byte	8
 9281 0b06 08       		.byte	8
 9282 0b07 08       		.byte	8
 9283 0b08 08       		.byte	8
 9284 0b09 08       		.byte	8
 9285 0b0a 08       		.byte	8
 9286 0b0b 08       		.byte	8
 9287 0b0c 08       		.byte	8
 9288 0b0d 08       		.byte	8
 9289 0b0e 08       		.byte	8
 9290 0b0f 08       		.byte	8
 9291 0b10 00       		.byte	0
 9292 0b11 01       		.byte	1
 9293 0b12 02       		.byte	2
 9294 0b13 10       		.byte	16
 9295 0b14 04       		.byte	4
 9296 0b15 05       		.byte	5
 9297 0b16 06       		.byte	6
 9298 0b17 07       		.byte	7
 9299 0b18 08       		.byte	8
 9300 0b19 09       		.byte	9
 9301 0b1a 0A       		.byte	10
 9302 0b1b 08       		.byte	8
 9303 0b1c 11       		.byte	17
 9304 0b1d 0C       		.byte	12
 9305 0b1e 0D       		.byte	13
 9306 0b1f 08       		.byte	8
 9307 0b20 0E       		.byte	14
 9308 0b21 0F       		.byte	15
 9309 0b22 08       		.byte	8
 9310 0b23 00       		.space	1
 9313              	CyFxGpifRegValue_usb2:
 9314 0b24 08830080 		.word	-2147450104
 9315 0b28 67000000 		.word	103
 9316 0b2c 01000000 		.word	1
 9317 0b30 46000000 		.word	70
 9318 0b34 00000000 		.word	0
 9319 0b38 00000000 		.word	0
 9320 0b3c 02000000 		.word	2
 9321 0b40 82000000 		.word	130
 9322 0b44 82070000 		.word	1922
 9323 0b48 40040000 		.word	1088
 9324 0b4c FCFF0000 		.word	65532
 9325 0b50 28000000 		.word	40
 9326 0b54 00000000 		.word	0
 9327 0b58 00000000 		.word	0
 9328 0b5c 00000000 		.word	0
 9329 0b60 00000000 		.word	0
 9330 0b64 01000000 		.word	1
 9331 0b68 00000000 		.word	0
 9332 0b6c 00000000 		.word	0
 9333 0b70 00000000 		.word	0
 9334 0b74 00000000 		.word	0
 9335 0b78 00000000 		.word	0
 9336 0b7c 00000000 		.word	0
 9337 0b80 00000000 		.word	0
 9338 0b84 00000000 		.word	0
 9339 0b88 00000000 		.word	0
 9340 0b8c 00000000 		.word	0
 9341 0b90 00000000 		.word	0
 9342 0b94 00000000 		.word	0
 9343 0b98 06000000 		.word	6
 9344 0b9c 00000000 		.word	0
 9345 0ba0 FFFF0000 		.word	65535
 9346 0ba4 09010000 		.word	265
 9347 0ba8 00000000 		.word	0
 9348 0bac F71F0000 		.word	8183
 9349 0bb0 00000000 		.word	0
 9350 0bb4 FFFF0000 		.word	65535
 9351 0bb8 09010000 		.word	265
 9352 0bbc 00000000 		.word	0
 9353 0bc0 F71F0000 		.word	8183
 9354 0bc4 00000000 		.word	0
 9355 0bc8 00000000 		.word	0
 9356 0bcc 00000000 		.word	0
 9357 0bd0 00000000 		.word	0
 9358 0bd4 00000000 		.word	0
 9359 0bd8 00000000 		.word	0
 9360 0bdc 00000000 		.word	0
 9361 0be0 00000000 		.word	0
 9362 0be4 00000000 		.word	0
 9363 0be8 00000000 		.word	0
 9364 0bec 00000000 		.word	0
 9365 0bf0 00000000 		.word	0
 9366 0bf4 00000000 		.word	0
 9367 0bf8 00000000 		.word	0
 9368 0bfc 00000000 		.word	0
 9369 0c00 00000000 		.word	0
 9370 0c04 00000000 		.word	0
 9371 0c08 00000000 		.word	0
 9372 0c0c 00000000 		.word	0
 9373 0c10 00000000 		.word	0
 9374 0c14 00000000 		.word	0
 9375 0c18 00000000 		.word	0
 9376 0c1c 00000000 		.word	0
 9377 0c20 00040180 		.word	-2147417088
 9378 0c24 01040180 		.word	-2147417087
 9379 0c28 02040180 		.word	-2147417086
 9380 0c2c 03040180 		.word	-2147417085
 9381 0c30 00000000 		.word	0
 9382 0c34 00000000 		.word	0
 9383 0c38 00000000 		.word	0
 9384 0c3c 00000000 		.word	0
 9385 0c40 00000000 		.word	0
 9386 0c44 00000000 		.word	0
 9387 0c48 00000000 		.word	0
 9388 0c4c 00000000 		.word	0
 9389 0c50 C1FFFFFF 		.word	-63
 9390              		.section	.rodata.str1.4,"aMS",%progbits,1
 9391              		.align	2
 9392              	.LC0:
 9393 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9393      7065722D 
 9393      74696D65 
 9393      72202564 
 9393      0D0A00
 9394 0013 00       		.space	1
 9395              	.LC1:
 9396 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9396      636F6D6D 
 9396      616E6420 
 9396      71756575 
 9396      65206973 
 9397 0037 00       		.space	1
 9398              	.LC2:
 9399 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9399      7220696E 
 9399      206D756C 
 9399      74696368 
 9399      616E6E65 
 9400 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 9400      2C20646D 
 9400      61446F6E 
 9400      65202578 
 9400      0D0A00
 9401 007e 0000     		.space	2
 9402              	.LC3:
 9403 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9403      5420656E 
 9403      636F756E 
 9403      74657265 
 9403      642E2E2E 
 9404              	.LC4:
 9405 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9405      454E4420 
 9405      656E636F 
 9405      756E7465 
 9405      7265642E 
 9406 00c2 0000     		.space	2
 9407              	.LC5:
 9408 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9408      64697363 
 9408      6F6E6E65 
 9408      63746564 
 9408      2E2E2E30 
 9409 00e3 00       		.space	1
 9410              	.LC6:
 9411 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9411      43595F46 
 9411      585F5556 
 9411      435F5649 
 9411      44454F5F 
 9412 0117 0A00     		.ascii	"\012\000"
 9413 0119 000000   		.space	3
 9414              	.LC7:
 9415 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9415      43595F46 
 9415      585F5556 
 9415      435F5649 
 9415      44454F5F 
 9416 014f 00       		.ascii	"\000"
 9417              	.LC8:
 9418 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9418      726E6174 
 9418      65207365 
 9418      7474696E 
 9418      6720302E 
 9419              	.LC9:
 9420 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9420      72206665 
 9420      61747572 
 9420      65207265 
 9420      71756573 
 9421 018b 00       		.space	1
 9422              	.LC10:
 9423 018c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9423      6F6D6D69 
 9423      74656F66 
 9423      20737461 
 9423      7465203D 
 9424              	.LC11:
 9425 01a4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9425      6E656C20 
 9425      53657420 
 9425      57726170 
 9425      55702066 
 9426 01d1 000000   		.space	3
 9427              	.LC12:
 9428 01d4 4572726F 		.ascii	"Error handler...\015\012\000"
 9428      72206861 
 9428      6E646C65 
 9428      722E2E2E 
 9428      0D0A00
 9429 01e7 00       		.space	1
 9430              	.LC13:
 9431 01e8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9431      69742045 
 9431      4F462066 
 9431      61696C65 
 9431      64210A00 
 9432              	.LC14:
 9433 01fc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9433      49324320 
 9433      636F6D6D 
 9433      616E6420 
 9433      69732030 
 9434 022f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9434      78257820 
 9434      30782578 
 9434      20307825 
 9434      78203078 
 9435              	.LC15:
 9436 0248 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9436      49324320 
 9436      63757272 
 9436      656E7420 
 9436      64617461 
 9437 027b 64202564 		.ascii	"d %d\015\012\000"
 9437      0D0A00
 9438 0282 0000     		.space	2
 9439              	.LC16:
 9440 0284 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9440      26414743 
 9440      2073656E 
 9440      7420746F 
 9440      20686F73 
 9441 02aa 0000     		.space	2
 9442              	.LC17:
 9443 02ac 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9443      26414743 
 9443      20676F74 
 9443      74656E20 
 9443      66726F6D 
 9444 02d6 0000     		.space	2
 9445              	.LC18:
 9446 02d8 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 9446      6C657665 
 9446      6C2E2025 
 9446      64202564 
 9446      3B202564 
 9447 02f2 0000     		.space	2
 9448              	.LC19:
 9449 02f4 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 9449      7365742E 
 9449      20256420 
 9449      25643B20 
 9449      25642025 
 9450              	.LC20:
 9451 030c 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9451      67657420 
 9451      64617461 
 9451      2066726F 
 9451      6D20686F 
 9452 0339 000000   		.space	3
 9453              	.LC21:
 9454 033c 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9454      52657175 
 9454      65737420 
 9454      30782578 
 9454      20706172 
 9455 036f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9455      6E642074 
 9455      6F20686F 
 9455      73742030 
 9455      78257820 
 9456 038a 0000     		.space	2
 9457              	.LC22:
 9458 038c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9458      204F7020 
 9458      72656365 
 9458      69766573 
 9458      20284354 
 9459 03b3 00       		.space	1
 9460              	.LC23:
 9461 03b4 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9461      756C7420 
 9461      73656C65 
 9461      63746F72 
 9461      20284354 
 9462 03d6 0000     		.space	2
 9463              	.LC24:
 9464 03d8 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9464      756C7420 
 9464      72657175 
 9464      65737420 
 9464      28435429 
 9465 03f9 000000   		.space	3
 9466              	.LC25:
 9467 03fc 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9467      52657175 
 9467      65737420 
 9467      30782578 
 9467      20706172 
 9468 042f 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9468      20307825 
 9468      78202F20 
 9468      73656E64 
 9468      20746F20 
 9469 045c 00       		.ascii	"\000"
 9470 045d 000000   		.space	3
 9471              	.LC26:
 9472 0460 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9472      73706565 
 9472      64203D20 
 9472      25642065 
 9472      76656E66 
 9473 0490 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9473      71756573 
 9473      74203D20 
 9473      30782578 
 9473      20775661 
 9474 04c0 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9474      203D2030 
 9474      78257820 
 9474      6973666C 
 9474      61672030 
 9475 04da 0000     		.space	2
 9476              	.LC27:
 9477 04dc 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9477      64656661 
 9477      756C7420 
 9477      73657475 
 9477      70207265 
 9478              	.LC28:
 9479 0508 54686520 		.ascii	"The host command is not correct for 1080p camera 0x"
 9479      686F7374 
 9479      20636F6D 
 9479      6D616E64 
 9479      20697320 
 9480 053b 25782030 		.ascii	"%x 0x%x %d\015\012\000"
 9480      78257820 
 9480      25640D0A 
 9480      00
 9481              	.LC29:
 9482 0548 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9482      43595F46 
 9482      585F5556 
 9482      435F5354 
 9482      5245414D 
 9483 056e 0000     		.space	2
 9484              	.LC30:
 9485 0570 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9485      55564320 
 9485      7374696C 
 9485      6C207472 
 9485      69676765 
 9486 0596 0000     		.space	2
 9487              	.LC31:
 9488 0598 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9488      7374696C 
 9488      6C207472 
 9488      69676765 
 9488      7220636F 
 9489 05bf 00       		.space	1
 9490              	.LC32:
 9491 05c0 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9491      65642074 
 9491      6F207365 
 9491      6E642069 
 9491      6E746572 
 9492 05f1 0A00     		.ascii	"\012\000"
 9493 05f3 00       		.space	1
 9494              	.LC33:
 9495 05f4 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9495      73657420 
 9495      64656620 
 9495      64617461 
 9495      20307825 
 9496 0613 00       		.space	1
 9497              	.LC34:
 9498 0614 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9498      73657420 
 9498      64656620 
 9498      64617461 
 9498      20307825 
 9499 0647 2E0D0A00 		.ascii	".\015\012\000"
 9500 064b 00       		.space	1
 9501              	.LC35:
 9502 064c 55415254 		.ascii	"UART initialization failed!\012\000"
 9502      20696E69 
 9502      7469616C 
 9502      697A6174 
 9502      696F6E20 
 9503 0669 000000   		.space	3
 9504              	.LC36:
 9505 066c 49324320 		.ascii	"I2C initialization failed!\012\000"
 9505      696E6974 
 9505      69616C69 
 9505      7A617469 
 9505      6F6E2066 
 9506              	.LC37:
 9507 0688 49324320 		.ascii	"I2C configuration failed!\012\000"
 9507      636F6E66 
 9507      69677572 
 9507      6174696F 
 9507      6E206661 
 9508 06a3 00       		.space	1
 9509              	.LC38:
 9510 06a4 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9510      43726561 
 9510      74652045 
 9510      76656E74 
 9510      20666169 
 9511 06ce 0000     		.space	2
 9512              	.LC39:
 9513 06d0 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9513      20496E69 
 9513      74206661 
 9513      696C6564 
 9513      2C204572 
 9514 06f3 00       		.space	1
 9515              	.LC40:
 9516 06f4 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9516      204F7665 
 9516      72726964 
 9516      65206661 
 9516      696C6564 
 9517 071b 00       		.space	1
 9518              	.LC41:
 9519 071c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9519      28323029 
 9519      204F7665 
 9519      72726964 
 9519      65206661 
 9520 0747 00       		.space	1
 9521              	.LC42:
 9522 0748 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9522      28323429 
 9522      204F7665 
 9522      72726964 
 9522      65206661 
 9523 0773 00       		.space	1
 9524              	.LC43:
 9525 0774 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9525      20536574 
 9525      20287265 
 9525      73657420 
 9525      32322920 
 9526 07a6 00       		.ascii	"\000"
 9527 07a7 00       		.space	1
 9528              	.LC44:
 9529 07a8 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9529      20536574 
 9529      2028706F 
 9529      77657220 
 9529      32302920 
 9530 07da 00       		.ascii	"\000"
 9531 07db 00       		.space	1
 9532              	.LC45:
 9533 07dc 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9533      20536574 
 9533      2028736E 
 9533      61702073 
 9533      686F7420 
 9534 080f 25640A00 		.ascii	"%d\012\000"
 9535 0813 00       		.space	1
 9536              	.LC46:
 9537 0814 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9537      46756E63 
 9537      74696F6E 
 9537      20466169 
 9537      6C656420 
 9538 0843 00       		.space	1
 9539              	.LC47:
 9540 0844 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9540      46756E63 
 9540      74696F6E 
 9540      20466169 
 9540      6C656420 
 9541 0873 00       		.space	1
 9542              	.LC48:
 9543 0874 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9543      53657420 
 9543      456E6470 
 9543      6F696E74 
 9543      20636F6E 
 9544 08a4 00       		.ascii	"\000"
 9545 08a5 000000   		.space	3
 9546              	.LC49:
 9547 08a8 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9547      496E7465 
 9547      72727570 
 9547      74205374 
 9547      61747573 
 9548 08db 20436F64 		.ascii	" Code = %d\012\000"
 9548      65203D20 
 9548      25640A00 
 9549 08e7 00       		.space	1
 9550              	.LC50:
 9551 08e8 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9551      65642074 
 9551      6F20616C 
 9551      6C6F6361 
 9551      7465206D 
 9552 091b 65720D0A 		.ascii	"er\015\012\000"
 9552      00
 9553              	.LC51:
 9554 0920 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9554      4368616E 
 9554      6E656C20 
 9554      43726561 
 9554      74696F6E 
 9555 094e 0000     		.space	2
 9556              	.LC52:
 9557 0950 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9557      436F6E6E 
 9557      65637420 
 9557      6661696C 
 9557      65642C20 
 9558 0975 000000   		.space	3
 9559              	.LC53:
 9560 0978 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9560      4368616E 
 9560      6E656C20 
 9560      52657365 
 9560      74204661 
 9561 09a3 00       		.space	1
 9562              	.LC54:
 9563 09a4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9563      4368616E 
 9563      6E656C20 
 9563      53657420 
 9563      5472616E 
 9564 09d5 00       		.ascii	"\000"
 9565 09d6 0000     		.space	2
 9566              	.LC55:
 9567 09d8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9567      4368616E 
 9567      6E656C20 
 9567      53657420 
 9567      5472616E 
 9568 0a09 0A00     		.ascii	"\012\000"
 9569 0a0b 00       		.space	1
 9570              	.LC56:
 9571 0a0c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9571      75706572 
 9571      20677069 
 9571      6600
 9572 0a1a 0000     		.space	2
 9573              	.LC57:
 9574 0a1c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9574      69676820 
 9574      67706966 
 9574      00
 9575 0a29 000000   		.space	3
 9576              	.LC58:
 9577 0a2c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9577      696E6720 
 9577      47504946 
 9577      20436F6E 
 9577      66696775 
 9578 0a5f 0A00     		.ascii	"\012\000"
 9579 0a61 000000   		.space	3
 9580              	.LC59:
 9581 0a64 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9581      74696E67 
 9581      20475049 
 9581      46207374 
 9581      61746520 
 9582 0a97 0D0A00   		.ascii	"\015\012\000"
 9583 0a9a 0000     		.space	2
 9584              	.LC60:
 9585 0a9c 33303A55 		.ascii	"30:UVC App Thread\000"
 9585      56432041 
 9585      70702054 
 9585      68726561 
 9585      6400
 9586 0aae 0000     		.space	2
 9587              	.LC61:
 9588 0ab0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9588      56432041 
 9588      70702045 
 9588      50302054 
 9588      68726561 
 9589 0ac6 0000     		.space	2
 9590              	.LC62:
 9591 0ac8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9591      32432041 
 9591      70702043 
 9591      54524C20 
 9591      54687265 
 9592 0adf 00       		.bss
 9593              		.align	2
 9594              		.set	.LANCHOR0,. + 0
 9597              	glFxUVCEvent:
 9598 0000 00000000 		.space	40
 9598      00000000 
 9598      00000000 
 9598      00000000 
 9598      00000000 
 9601              	fb:
 9602 0028 0000     		.space	2
 9605              	pb:
 9606 002a 0000     		.space	2
 9609              	pbc:
 9610 002c 0000     		.space	2
 9613              	prodCount:
 9614 002e 0000     		.space	2
 9617              	consCount:
 9618 0030 0000     		.space	2
 9619 0032 0000     		.space	2
 9622              	streamingStarted:
 9623 0034 00000000 		.space	4
 9626              	gpif_initialized:
 9627 0038 00000000 		.space	4
 9630              	isUsbConnected:
 9631 003c 00000000 		.space	4
 9634              	clearFeatureRqtReceived:
 9635 0040 00000000 		.space	4
 9638              	hitFV:
 9639 0044 00000000 		.space	4
 9642              	usbSpeed:
 9643 0048 00       		.space	1
 9644 0049 000000   		.space	3
 9647              	I2CCMDArry:
 9648 004c 00000000 		.space	12
 9648      00000000 
 9648      00000000 
 9651              	glEp0Buffer:
 9652 0058 00000000 		.space	32
 9652      00000000 
 9652      00000000 
 9652      00000000 
 9652      00000000 
 9655              	glCommitCtrl:
 9656 0078 00000000 		.space	32
 9656      00000000 
 9656      00000000 
 9656      00000000 
 9656      00000000 
 9659              	stiflag:
 9660 0098 00000000 		.space	4
 9663              	uvcAppThread:
 9664 009c 00000000 		.space	168
 9664      00000000 
 9664      00000000 
 9664      00000000 
 9664      00000000 
 9667              	uvcAppEP0Thread:
 9668 0144 00000000 		.space	168
 9668      00000000 
 9668      00000000 
 9668      00000000 
 9668      00000000 
 9671              	i2cAppThread:
 9672 01ec 00000000 		.space	168
 9672      00000000 
 9672      00000000 
 9672      00000000 
 9672      00000000 
 9675              	testSnap:
 9676 0294 00       		.space	1
 9677 0295 00       		.space	1
 9680              	fbbak:
 9681 0296 0000     		.space	2
 9684              	pbbak:
 9685 0298 0000     		.space	2
 9688              	pbcbak:
 9689 029a 0000     		.space	2
 9692              	pbcpbak:
 9693 029c 0000     		.space	2
 9694 029e 0000     		.text
 9695              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:282    .text:0000020c $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:296    .text:0000022c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:293    .text:0000022c $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:315    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:319    .text:00000240 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:322    .text:00000240 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:480    .text:00000368 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:488    .text:0000037c $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:490    .text:0000037c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:669    .text:000004dc $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:678    .text:000004ec $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:680    .text:000004ec CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1005   .text:000007b4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1021   .text:000007e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1024   .text:000007e0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1070   .text:0000081c $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1083   .text:00000848 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1146   .text:000008b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1153   .text:000008c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1164   .text:000008e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1167   .text:000008e0 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1278   .text:000009d4 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1283   .text:000009dc $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1286   .text:000009dc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1349   .text:00000a5c ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1561   .text:00000c04 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1603   .text:00000ca0 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1668   .text:00000d24 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:1708   .text:00000dbc $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:2963   .text:0000196c $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:2982   .text:000019ac $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:2985   .text:000019ac CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:3153   .text:00001b08 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:3166   .text:00001b30 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:3661   .text:00002040 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:3672   .text:00002060 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:3927   .text:00002318 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:3940   .text:00002340 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:3943   .text:00002340 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:4005   .text:000023bc $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:4013   .text:000023cc $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5140   .text:00002d28 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5168   .text:00002d84 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5171   .text:00002d84 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5462   .text:0000303c $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5469   .text:0000304c $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5472   .text:0000304c CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5508   .text:00003078 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5512   .text:0000307c $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5515   .text:0000307c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5540   .text:00003098 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5544   .text:0000309c $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:5547   .text:0000309c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:6926   .text:00003b60 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:6986   .text:00003c34 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:6989   .text:00003c34 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7072   .text:00003cc0 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7081   .text:00003cd0 $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7084   .text:00003cd0 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7241   .text:00003e48 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7257   .text:00003e7c $a
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7260   .text:00003e7c main
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8858   .data:00000664 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8867   .data:00000670 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8942   .data:00000790 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8961   .data:000007a0 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7421   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9040   .data:000008d0 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9051   .data:000008e0 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9162   .data:00000a90 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9313   .data:00000b24 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7434   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8854   .data:00000663 snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9675   .bss:00000294 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9601   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9605   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9609   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9680   .bss:00000296 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9684   .bss:00000298 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9688   .bss:0000029a pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9692   .bss:0000029c pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9630   .bss:0000003c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9642   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9634   .bss:00000040 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9622   .bss:00000034 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8765   .data:00000614 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8825   .data:0000064c glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8795   .data:00000630 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8840   .data:00000658 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8416   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7398   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7402   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7446   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7450   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:7773   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8431   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8438   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:8761   .data:00000610 WDRflag
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9391   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9593   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9597   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9613   .bss:0000002e prodCount
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9617   .bss:00000030 consCount
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9626   .bss:00000038 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9638   .bss:00000044 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9647   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9651   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9655   .bss:00000078 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9659   .bss:00000098 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9663   .bss:0000009c uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9667   .bss:00000144 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccLxu7uO.s:9671   .bss:000001ec i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
