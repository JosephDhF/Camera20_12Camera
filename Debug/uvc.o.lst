   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 141:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 145:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 146:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 147:../uvc.c      **** };
 148:../uvc.c      **** 
 149:../uvc.c      **** 
 150:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 151:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 152:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 154:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 155:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 156:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 157:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 158:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 159:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 160:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 161:../uvc.c      ****                                    with adjustable compression parameters */
 162:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 163:../uvc.c      ****                                    streaming with adjustable compression parameters */
 164:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 165:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 170:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 171:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 173:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 174:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 175:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 176:../uvc.c      **** };
 177:../uvc.c      **** 
 178:../uvc.c      **** 
 179:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 180:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 181:../uvc.c      **** 
 182:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 183:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 184:../uvc.c      **** {
 185:../uvc.c      ****     0x0C,                               /* Header Length */
 186:../uvc.c      ****     0x8C,                               /* Bit field header field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 188:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 189:../uvc.c      **** };
 190:../uvc.c      **** 
 191:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 192:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 193:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 194:../uvc.c      ****                                                            the current video frame. */
 195:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 196:../uvc.c      **** #ifndef CAM720
 197:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 198:../uvc.c      **** #else
 199:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 200:../uvc.c      **** #endif
 201:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 202:../uvc.c      **** 
 203:../uvc.c      **** /************ control parameters array ***********
 204:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 205:../uvc.c      ****  *    e.g.
 206:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 207:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 208:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 209:../uvc.c      ****  **************************************************/
 210:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 211:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 212:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 213:../uvc.c      **** #ifndef CAM720
 214:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 215:../uvc.c      **** #else
 216:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 217:../uvc.c      **** #endif
 218:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0,
 219:../uvc.c      **** 		{/*2*/ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0,
 220:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 221:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 222:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 223:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 224:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,
 225:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 228:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 229:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 233:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 235:../uvc.c      **** #ifndef CAM720
 236:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 237:../uvc.c      **** #else
 238:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 239:../uvc.c      **** #endif
 240:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 241:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 242:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 244:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 246:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 247:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg1     , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 248:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		/**********************************
 253:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 254:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 255:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 256:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 257:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 258:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 259:../uvc.c      **** 		 *
 260:../uvc.c      **** 		 *********************************/
 261:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 262:../uvc.c      **** };
 263:../uvc.c      **** 
 264:../uvc.c      **** #ifndef CAM720
 265:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 266:../uvc.c      **** #else
 267:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 268:../uvc.c      **** #endif
 269:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 270:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 271:../uvc.c      **** 
 272:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 273:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 274:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 275:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 276:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 277:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 278:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 279:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 280:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 281:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 282:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 285:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 287:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 288:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 289:../uvc.c      **** };
 290:../uvc.c      **** 
 291:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 292:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 293:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 294:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 295:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 296:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 297:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 298:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 299:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 300:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 302:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 303:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 304:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 308:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 309:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 310:../uvc.c      **** };
 311:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 312:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 313:../uvc.c      **** /*
 314:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 315:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 316:../uvc.c      ****  */
 317:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 318:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 319:../uvc.c      **** };
 320:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 321:../uvc.c      **** 		0
 322:../uvc.c      **** };
 323:../uvc.c      **** 
 324:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 325:../uvc.c      **** 
 326:../uvc.c      **** void I2CCmdHandler(){
 327:../uvc.c      **** 	uint8_t buf[2];
 328:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 329:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 330:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 331:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 332:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 333:../uvc.c      **** 
 334:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 335:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 336:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 337:../uvc.c      **** 
 338:../uvc.c      **** 	if(CmdType == 0)//I2C read
 339:../uvc.c      **** 	{
 340:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 341:../uvc.c      **** #if 0 //for debugging
 342:../uvc.c      **** 		/* test still image operation */
 343:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 344:../uvc.c      **** 			snapButFlag = 0; //press
 345:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 346:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 347:../uvc.c      **** 			snapButFlag = 0xf; //release
 348:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 349:../uvc.c      **** 		}
 350:../uvc.c      **** 
 351:../uvc.c      **** 		/* end of the test */
 352:../uvc.c      **** #endif
 353:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 354:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 355:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 356:../uvc.c      **** 			if(CmdDataLen == 2){
 357:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 358:../uvc.c      **** 			}
 359:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 360:../uvc.c      **** 		}else{//not support currently
 361:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 362:../uvc.c      **** 		}
 363:../uvc.c      **** 	}else if(CmdType == 1){
 364:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 365:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 366:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 367:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 368:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 369:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 370:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 371:../uvc.c      **** 			}
 372:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 373:../uvc.c      **** 		}else{//not support currently
 374:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 375:../uvc.c      **** 		}
 376:../uvc.c      **** 
 377:../uvc.c      **** 	}
 378:../uvc.c      **** }
 379:../uvc.c      **** 
 380:../uvc.c      **** /************************************
 381:../uvc.c      ****  * set Iris mode
 382:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 383:../uvc.c      ****  */
 384:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 385:../uvc.c      **** 	uint8_t dataIdx;
 386:../uvc.c      **** 	  dataIdx = 0;
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 391:../uvc.c      **** }
 392:../uvc.c      **** 
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 394:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 395:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 396:../uvc.c      ****     uint16_t readCount;
 397:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 398:../uvc.c      ****     uint8_t devAdd;
 399:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 400:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 401:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 402:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 403:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 404:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 405:../uvc.c      ****     }else{
 406:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 407:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 408:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 409:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 410:../uvc.c      ****     }
 411:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 412:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 413:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 414:../uvc.c      **** #endif
 415:../uvc.c      ****     reqData = bRequest;
 416:../uvc.c      ****     /*
 417:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 418:../uvc.c      ****      */
 419:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 420:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 421:../uvc.c      ****     	goto EndofSet;
 422:../uvc.c      ****     }
 423:../uvc.c      ****     switch (bRequest)
 424:../uvc.c      **** 		 {
 425:../uvc.c      **** 
 426:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 427:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 428:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 429:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 430:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 431:../uvc.c      **** 			  break;
 432:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 433:../uvc.c      **** 
 434:../uvc.c      **** 			 switch(CtrlID)
 435:../uvc.c      **** 			 {
 436:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 437:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 438:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 439:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 440:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 441:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 442:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 443:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 444:../uvc.c      **** 			 	 		 break;
 445:../uvc.c      **** 			 	 }
 446:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 447:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 448:../uvc.c      **** 					 if(CamMode == 1){//720p
 449:../uvc.c      **** 						if(sendData >= 3){
 450:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 451:../uvc.c      **** 							sendData = 0; //set back to default
 452:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 453:../uvc.c      **** 						}
 454:../uvc.c      **** 						sendData += 4;
 455:../uvc.c      **** 					 }
 456:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 457:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 458:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 459:../uvc.c      **** 					 break;
 460:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 461:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 462:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 463:../uvc.c      **** 			 		 }
 464:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 465:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 466:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 467:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 468:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 469:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 470:../uvc.c      **** #endif
 471:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 472:../uvc.c      **** 			 		 {
 473:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 474:../uvc.c      **** 			 		 }
 475:../uvc.c      **** 			 		 break;
 476:../uvc.c      **** 				 case ExtAexModCtlID9:
 477:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 478:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 479:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 480:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 481:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 482:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 483:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 484:../uvc.c      **** 					 break;
 485:../uvc.c      **** 
 486:../uvc.c      **** 			 	 case BrgtCtlID1:
 487:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 488:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 489:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 490:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 491:../uvc.c      **** 					 }else{
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 493:../uvc.c      **** 					 }
 494:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 496:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 497:../uvc.c      **** 					 break;
 498:../uvc.c      **** 				 case HueCtlID5:
 499:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 500:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 502:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 503:../uvc.c      **** 					 break;
 504:../uvc.c      **** 				 case WBTLevCtlID11:
 505:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 506:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 507:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 508:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 509:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 510:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 511:../uvc.c      **** 					 break;
 512:../uvc.c      **** 				 case SaturCtlID6:
 513:../uvc.c      **** 				 default:
 514:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 515:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 516:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 517:../uvc.c      **** 					 break;
 518:../uvc.c      **** 			 }
 519:../uvc.c      **** 
 520:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 521:../uvc.c      **** 
 522:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 523:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 524:../uvc.c      **** #endif
 525:../uvc.c      **** 			  break;
 526:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 527:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 528:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 529:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 530:../uvc.c      **** 		 	 }
 531:../uvc.c      **** 
 532:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 533:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 534:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 535:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 536:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 537:../uvc.c      **** 			 }else
 538:../uvc.c      **** 			 {
 539:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 540:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 541:../uvc.c      **** 			 }
 542:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 543:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 544:../uvc.c      **** 			  break;
 545:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 546:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 548:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 549:../uvc.c      **** 		 	 }
 550:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 551:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 552:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 553:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 554:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 555:../uvc.c      **** 			 }else
 556:../uvc.c      **** 			 {
 557:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 558:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 559:../uvc.c      **** 			 }
 560:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 561:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 562:../uvc.c      **** 			  break;
 563:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 564:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 566:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 567:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 568:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 569:../uvc.c      **** 		 	 }
 570:../uvc.c      **** 		 	 else{
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 572:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 573:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 574:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 575:../uvc.c      **** 		 	 }
 576:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 577:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 578:../uvc.c      **** 			  break;
 579:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 580:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 582:../uvc.c      **** 		 	 }
 583:../uvc.c      **** 		 	 else{
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 585:../uvc.c      **** 		 	 }
 586:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 587:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 588:../uvc.c      **** 			  Len = 1;
 589:../uvc.c      **** 			  break;
 590:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 591:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 592:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 593:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 594:../uvc.c      **** 		 	 }
 595:../uvc.c      **** 
 596:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 598:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 599:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 600:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 601:../uvc.c      **** 			 }else{
 602:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 603:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 604:../uvc.c      **** 			 }
 605:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 606:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 607:../uvc.c      **** 			  break;
 608:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 609:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 610:../uvc.c      **** 				  glEp0Buffer, &readCount);
 611:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 612:../uvc.c      **** 			   {
 613:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 614:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 615:../uvc.c      **** 				  getData = glEp0Buffer[0];
 616:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 617:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 618:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 619:../uvc.c      **** #endif
 620:../uvc.c      **** 				  switch(CtrlID)
 621:../uvc.c      **** 					 {
 622:../uvc.c      **** 						 case ExtShutCtlID0:
 623:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 624:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 625:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 626:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 627:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 628:../uvc.c      **** 									 }else{
 629:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 630:../uvc.c      **** 									 }
 631:../uvc.c      **** 								 }
 632:../uvc.c      **** 							 }else{
 633:../uvc.c      **** 								 Data1 = Data0 - 1;
 634:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 635:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 636:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 637:../uvc.c      **** 									 }else{
 638:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 639:../uvc.c      **** 									 }
 640:../uvc.c      **** 								 }
 641:../uvc.c      **** 								 if(Data1 < 8){
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 644:../uvc.c      **** 								 }else{
 645:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 646:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 647:../uvc.c      **** 								 }
 648:../uvc.c      **** 							 }
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 650:../uvc.c      **** 							 dataIdx = 0;
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 652:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 653:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 654:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 655:../uvc.c      **** 							 break;
 656:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 657:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 658:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 659:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 660:../uvc.c      **** 							 dataIdx = 0;
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 662:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 663:../uvc.c      **** 							 if(getData != 0){
 664:../uvc.c      **** 								 dataIdx++;
 665:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 666:../uvc.c      **** 							 }
 667:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 668:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 669:../uvc.c      **** 							 break;
 670:../uvc.c      **** 						 case ExtExRefCtlID10:
 671:../uvc.c      **** 							 dataIdx = 0;
 672:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 673:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 674:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 675:../uvc.c      **** 							 if(WDRflag)
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 677:../uvc.c      **** 							 else
 678:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 680:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 681:../uvc.c      **** 						 case ExtCamMCtlID12:
 682:../uvc.c      **** 							 /*
 683:../uvc.c      **** 							 dataIdx = 0;
 684:../uvc.c      **** 							 if(Data0 <= 3){
 685:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 686:../uvc.c      **** 								 Data1 = Data0;
 687:../uvc.c      **** 							 }else{
 688:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 689:../uvc.c      **** 								 Data1 = Data0-4;
 690:../uvc.c      **** 							 }
 691:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 692:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 693:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 694:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 695:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 696:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 697:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 698:../uvc.c      **** 							 */
 699:../uvc.c      **** 							 break;
 700:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 701:../uvc.c      **** 							 dataIdx = 0;
 702:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 703:../uvc.c      **** 								 Data0 = 1;
 704:../uvc.c      **** 							 }else{ //save current sensor parameters.
 705:../uvc.c      **** 								 Data0 = 0;
 706:../uvc.c      **** 							 }
 707:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 708:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 709:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 710:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 711:../uvc.c      **** 							 break;
 712:../uvc.c      **** 						 case ExtI2CCtlID15:
 713:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 714:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 715:../uvc.c      **** 					 		 }
 716:../uvc.c      **** 					 		I2CCmdHandler();
 717:../uvc.c      **** 							 break;
 718:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 719:../uvc.c      **** 							 dataIdx = 0;
 720:../uvc.c      **** #if 0 //seperate version
 721:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 722:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 723:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 724:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 725:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 726:../uvc.c      **** 							 }else{ //disable BLD window
 727:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 728:../uvc.c      **** 							 }
 729:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 730:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 731:../uvc.c      **** 							 dataIdx++;
 732:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 733:../uvc.c      **** 							 dataIdx++;
 734:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 735:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 736:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 737:../uvc.c      **** 							 dataIdx++;
 738:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 739:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 740:../uvc.c      **** #else //combination version
 741:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 742:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 743:../uvc.c      **** 						     /* end test */
 744:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 745:../uvc.c      **** 							 dataIdx++;
 746:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 747:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 748:../uvc.c      **** 							 getData1 = Data1;
 749:../uvc.c      **** #endif
 750:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 751:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 752:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 753:../uvc.c      **** 							 break;
 754:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 755:../uvc.c      **** 							 dataIdx = 0;
 756:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 758:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 759:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 760:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 761:../uvc.c      **** 							 break;
 762:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 763:../uvc.c      **** 							 dataIdx = 0;
 764:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 765:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 766:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 767:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 768:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 769:../uvc.c      **** 							 break;
 770:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 771:../uvc.c      **** 							 dataIdx = 0;
 772:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 773:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 774:../uvc.c      **** 							  if(Data0&0x80){
 775:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 776:../uvc.c      **** 							  }else{
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 778:../uvc.c      **** 							  }
 779:../uvc.c      **** 							 Data1 |= ~0x03;
 780:../uvc.c      **** 							 Data1 &= 0xC7;
 781:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 782:../uvc.c      **** 						  	 dataIdx++;
 783:../uvc.c      **** 
 784:../uvc.c      **** 							 Data0 = (Data0 << 2);
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 786:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 787:../uvc.c      **** 
 788:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 791:../uvc.c      **** 
 792:../uvc.c      **** 							 break;
 793:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 794:../uvc.c      **** 							 dataIdx = 0;
 795:../uvc.c      **** 
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 797:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 798:../uvc.c      **** 							 dataIdx++;
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 800:../uvc.c      **** 							 dataIdx++;
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 802:../uvc.c      **** 							 dataIdx++;
 803:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 804:../uvc.c      **** 							 dataIdx++;
 805:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 806:../uvc.c      **** 							 dataIdx++;
 807:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 808:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 809:../uvc.c      **** 
 810:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 811:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 812:../uvc.c      **** 							 break;
 813:../uvc.c      **** 						 case SaturCtlID6:
 814:../uvc.c      **** 							 dataIdx = 0;
 815:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 816:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 817:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 818:../uvc.c      **** 							 dataIdx++;
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 821:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 823:../uvc.c      **** 							 break;
 824:../uvc.c      **** 
 825:../uvc.c      **** 						 case WBTLevCtlID11:
 826:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 827:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 828:../uvc.c      **** 							 dataIdx = 0;
 829:../uvc.c      **** 
 830:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 831:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 832:../uvc.c      **** 							 dataIdx++;
 833:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 834:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 835:../uvc.c      **** 
 836:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 837:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 838:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 839:../uvc.c      **** 							 break;
 840:../uvc.c      **** 						 case MFreqCtlID4:
 841:../uvc.c      **** 							 dataIdx = 0;
 842:../uvc.c      **** 							 Data0 = Data0 - 1;
 843:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 844:../uvc.c      **** 								 Data0 = 0;
 845:../uvc.c      **** 							 else if(Data0 >2)
 846:../uvc.c      **** 								 Data0 = 1;
 847:../uvc.c      **** 
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 851:../uvc.c      **** 
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 854:../uvc.c      **** 							 break;
 855:../uvc.c      **** 					 	 case BLCCtlID0:
 856:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 857:../uvc.c      **** 							 if(Data0 == 3)
 858:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 859:../uvc.c      **** 							 else
 860:../uvc.c      **** 								 WDRflag = CyFalse;
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 862:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 863:../uvc.c      **** 							 {
 864:../uvc.c      **** 								 if(Data0 < 2){
 865:../uvc.c      **** 					 				 ;//Data0 += 4;
 866:../uvc.c      **** 					 			 }else{
 867:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 868:../uvc.c      **** 									Data0 = 0; //set to default.
 869:../uvc.c      **** 					 			 }
 870:../uvc.c      **** 					 		 }
 871:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 872:../uvc.c      **** 							 dataIdx = 0;
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 875:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 876:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 877:../uvc.c      **** 
 878:../uvc.c      **** 					 		 break;
 879:../uvc.c      **** 						 default:
 880:../uvc.c      **** 							 dataIdx = 0;
 881:../uvc.c      **** 
 882:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 883:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 884:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 885:../uvc.c      **** 
 886:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 887:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 888:../uvc.c      **** 							 break;
 889:../uvc.c      **** 					 }
 890:../uvc.c      **** 			   }else{
 891:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 892:../uvc.c      **** 			   }
 893:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 894:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 895:../uvc.c      **** #endif
 896:../uvc.c      **** 
 897:../uvc.c      **** 			  break;
 898:../uvc.c      **** 		  default:
 899:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 900:../uvc.c      **** 			  break;
 901:../uvc.c      **** 		 }
 902:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 903:../uvc.c      **** }
 904:../uvc.c      **** /************** CT control requests handler *************************/
 905:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 906:../uvc.c      **** 
 907:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 908:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 909:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 910:../uvc.c      ****     uint16_t readCount;
 911:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 912:../uvc.c      ****     uint16_t diff, value, diffRd;
 913:../uvc.c      ****     uint8_t i, shutter, index;
 914:../uvc.c      ****     diff = 0xffff;
 915:../uvc.c      ****     shutter = 1;
 916:../uvc.c      ****     index = 1;
 917:../uvc.c      **** 
 918:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 919:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 920:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 921:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 922:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 923:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 924:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 925:../uvc.c      **** #endif
 926:../uvc.c      ****     reqData = bRequest;
 927:../uvc.c      **** 
 928:../uvc.c      ****     switch (bRequest)
 929:../uvc.c      **** 		 {
 930:../uvc.c      **** 
 931:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 932:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 933:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 934:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 935:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 936:../uvc.c      **** 			  break;
 937:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 938:../uvc.c      **** 
 939:../uvc.c      **** 			 switch(CtrlID)
 940:../uvc.c      **** 			 {
 941:../uvc.c      **** 				 default:
 942:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 943:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 944:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 945:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 946:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 947:../uvc.c      **** 					 break;
 948:../uvc.c      **** 			 }
 949:../uvc.c      **** 
 950:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 951:../uvc.c      **** 
 952:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 953:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 954:../uvc.c      **** #endif
 955:../uvc.c      **** 			  break;
 956:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 957:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 958:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 959:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 960:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 961:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 962:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 963:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 964:../uvc.c      **** 			  break;
 965:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 966:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 967:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 968:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 969:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 970:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 971:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 972:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 973:../uvc.c      **** 			  break;
 974:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 975:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 976:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 977:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 978:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 979:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 981:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 982:../uvc.c      **** 			  break;
 983:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 984:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 985:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 986:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 987:../uvc.c      **** 			  Len = 1;
 988:../uvc.c      **** 			  break;
 989:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 990:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 991:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 993:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 994:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 995:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 996:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 997:../uvc.c      **** 			  break;
 998:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 999:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1000:../uvc.c      **** 			  glEp0Buffer, &readCount);
1001:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1002:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1003:../uvc.c      **** 			  value = Data1;
1004:../uvc.c      **** 
1005:../uvc.c      **** 			  switch(CtrlID)
1006:../uvc.c      **** 			  {
1007:../uvc.c      **** 		  	      case AutoExMCtlID1:
1008:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1009:../uvc.c      **** 
1010:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1011:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1012:../uvc.c      **** 				    getData = glEp0Buffer[0];
1013:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1014:../uvc.c      **** 		  		    switch (getData){
1015:../uvc.c      **** 						case 1:
1016:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1017:../uvc.c      **** 							break;
1018:../uvc.c      **** 						case 2:
1019:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1020:../uvc.c      **** 							dataIdx = 0;
1021:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1022:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1023:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1024:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1025:../uvc.c      **** 
1026:../uvc.c      **** 							break;
1027:../uvc.c      **** 						case 4:
1028:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1029:../uvc.c      **** 							break;
1030:../uvc.c      **** 						case 8:
1031:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1032:../uvc.c      **** 			  		    	dataIdx = 0;
1033:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1034:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1035:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1036:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1037:../uvc.c      **** 							break;
1038:../uvc.c      **** 		  		    }
1039:../uvc.c      **** #if 0
1040:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1041:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1042:../uvc.c      **** 						  dataIdx = 0;
1043:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1044:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1045:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1046:../uvc.c      **** 		  		    }
1047:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1048:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1049:../uvc.c      **** 		  		    }
1050:../uvc.c      **** #endif
1051:../uvc.c      **** 				    break;
1052:../uvc.c      **** 
1053:../uvc.c      **** 			  	  case ExTmACtlID3:
1054:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1055:../uvc.c      **** 
1056:../uvc.c      **** 					  value = (value << 8)|Data0;
1057:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1058:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1059:../uvc.c      **** 					  {
1060:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1061:../uvc.c      **** 						  {
1062:../uvc.c      **** 							if(value > ShutValueArry[i]){
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1064:../uvc.c      **** 							}else{
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1066:../uvc.c      **** 							}
1067:../uvc.c      **** 							  if(diff > diffRd){
1068:../uvc.c      **** 								  diff = diffRd;
1069:../uvc.c      **** 								  index = i;
1070:../uvc.c      **** 							  }
1071:../uvc.c      **** 						  }
1072:../uvc.c      **** 						  shutter = shutter+index;
1073:../uvc.c      **** 
1074:../uvc.c      **** 						  dataIdx = 0;
1075:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1076:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1077:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1078:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1079:../uvc.c      **** 
1080:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1081:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1082:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1083:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1084:../uvc.c      **** 					  }else{
1085:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1086:../uvc.c      **** 					  }
1087:../uvc.c      **** 					  getData = glEp0Buffer[0];
1088:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1089:../uvc.c      **** 					  break;
1090:../uvc.c      **** 			  	  case IriACtlID7:
1091:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1092:../uvc.c      **** 					  {
1093:../uvc.c      **** 							 dataIdx = 0;
1094:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1095:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1096:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1097:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1098:../uvc.c      **** 
1099:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1100:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1101:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1102:../uvc.c      **** 					  }else{
1103:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1104:../uvc.c      **** 					  }
1105:../uvc.c      **** 					  getData = glEp0Buffer[0];
1106:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1107:../uvc.c      **** 
1108:../uvc.c      **** 					  break;
1109:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1110:../uvc.c      **** 					  getData = glEp0Buffer[0];
1111:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1112:../uvc.c      **** #if 1
1113:../uvc.c      **** 					  dataIdx = 0;
1114:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1115:../uvc.c      **** 					  if(getData == 1)
1116:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1117:../uvc.c      **** 					  else if(getData == 0xff)
1118:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1119:../uvc.c      **** 					  else
1120:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1121:../uvc.c      **** 					  //dataIdx++;
1122:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1123:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1124:../uvc.c      **** #endif
1125:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1126:../uvc.c      **** 					  break;
1127:../uvc.c      **** 
1128:../uvc.c      **** 			  	  default:
1129:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1130:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1131:../uvc.c      **** 			  		 break;
1132:../uvc.c      **** 			  }
1133:../uvc.c      **** 			  break;
1134:../uvc.c      **** 		  default:
1135:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1136:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1137:../uvc.c      **** 			  break;
1138:../uvc.c      **** 		 }
1139:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1140:../uvc.c      **** 
1141:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1142:../uvc.c      **** }
1143:../uvc.c      **** 
1144:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1145:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1146:../uvc.c      **** {
1147:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1148:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1149:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1150:../uvc.c      **** 
1151:../uvc.c      ****     CtrlID = BrgtCtlID1;
1152:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1153:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1154:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1155:../uvc.c      ****     Data1 = Data0;
1156:../uvc.c      **** 
1157:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1158:../uvc.c      ****     if(Data1&0x80){
1159:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1160:../uvc.c      ****     }else{
1161:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1162:../uvc.c      ****     }
1163:../uvc.c      ****     Data0 = (Data0 << 2);
1164:../uvc.c      **** 
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1166:../uvc.c      **** 
1167:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1168:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1169:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1170:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1171:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1172:../uvc.c      **** 
1173:../uvc.c      ****     CtrlID = ConsCtlID2;
1174:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1175:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1176:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1177:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1178:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1179:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1180:../uvc.c      **** 
1181:../uvc.c      ****     CtrlID = HueCtlID5;
1182:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1183:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1184:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1188:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1190:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1191:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1192:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1193:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1194:../uvc.c      **** 
1195:../uvc.c      ****     CtrlID = SaturCtlID6;
1196:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1197:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1198:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1199:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1200:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1201:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1202:../uvc.c      **** 
1203:../uvc.c      ****     CtrlID = ShapCtlID7;
1204:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1205:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1206:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1207:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1208:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1209:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1210:../uvc.c      **** 
1211:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1212:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1213:../uvc.c      **** 	return;
1214:../uvc.c      **** }
1215:../uvc.c      **** 
1216:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1217:../uvc.c      **** void
1218:../uvc.c      **** CyFxUVCAddHeader (
1219:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1220:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1221:../uvc.c      ****         )
1222:../uvc.c      **** {
1223:../uvc.c      ****     /* Copy header to buffer */
1224:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1225:../uvc.c      **** 
1226:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1227:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1228:../uvc.c      ****     {
1229:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1230:../uvc.c      ****     }
1231:../uvc.c      **** }
1232:../uvc.c      **** 
1233:../uvc.c      **** 
1234:../uvc.c      **** /* Application Error Handler */
1235:../uvc.c      **** void
1236:../uvc.c      **** CyFxAppErrorHandler (
1237:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1238:../uvc.c      ****         )
1239:../uvc.c      **** {
1240:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1241:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1242:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1243:../uvc.c      **** 
1244:../uvc.c      ****        This function can be modified to take additional error handling actions such
1245:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1246:../uvc.c      ****      */
1247:../uvc.c      ****     for (;;)
1248:../uvc.c      ****     {
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
1251:../uvc.c      ****     }
1252:../uvc.c      **** }
1253:../uvc.c      **** 
1254:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1255:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1256:../uvc.c      ****  */
1257:../uvc.c      **** static void
1258:../uvc.c      **** CyFxUVCApplnAbortHandler (
1259:../uvc.c      ****         void)
1260:../uvc.c      **** {
1261:../uvc.c      **** 	uint32_t flag;
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1263:../uvc.c      **** 	{
1264:../uvc.c      ****         /* Clear the Video Stream Request Event */
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1266:../uvc.c      **** 
1267:../uvc.c      ****         /* Set Video Stream Abort Event */
1268:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1269:../uvc.c      **** 	}
1270:../uvc.c      **** }
1271:../uvc.c      **** 
1272:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1273:../uvc.c      **** static void
1274:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1275:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1276:../uvc.c      ****         uint16_t             evdata  /* Event data */
1277:../uvc.c      ****         )
1278:../uvc.c      **** {
1279:../uvc.c      ****     switch (evtype)
1280:../uvc.c      ****     {
1281:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1282:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1283:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1284:../uvc.c      ****             gpif_initialized = 0;
1285:../uvc.c      ****             streamingStarted = CyFalse;
1286:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1287:../uvc.c      ****             break;
1288:../uvc.c      **** 
1289:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1290:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1291:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1292:../uvc.c      ****             gpif_initialized = 0;
1293:../uvc.c      ****             streamingStarted = CyFalse;
1294:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1295:../uvc.c      ****             break;
1296:../uvc.c      **** 
1297:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1298:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1299:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1300:../uvc.c      ****             gpif_initialized = 0;
1301:../uvc.c      ****             isUsbConnected = CyFalse;
1302:../uvc.c      ****             streamingStarted = CyFalse;
1303:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1304:../uvc.c      ****             break;
1305:../uvc.c      **** 
1306:../uvc.c      **** #ifdef BACKFLOW_DETECT
1307:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1308:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1309:../uvc.c      ****             break;
1310:../uvc.c      **** #endif
1311:../uvc.c      **** 
1312:../uvc.c      ****         default:
1313:../uvc.c      ****             break;
1314:../uvc.c      ****     }
1315:../uvc.c      **** }
1316:../uvc.c      **** 
1317:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1318:../uvc.c      **** static CyBool_t
1319:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1320:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1321:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1322:../uvc.c      ****         )
1323:../uvc.c      **** {
1324:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1325:../uvc.c      ****     uint32_t status;
1326:../uvc.c      **** 
1327:../uvc.c      ****     /* Obtain Request Type and Request */
1328:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1329:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1330:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1331:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1332:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1333:../uvc.c      **** 
1334:../uvc.c      ****     /* Check for UVC Class Requests */
1335:../uvc.c      ****     switch (bmReqType)
1336:../uvc.c      ****     {
1337:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1338:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1339:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1340:../uvc.c      ****             switch (wIndex & 0xFF)
1341:../uvc.c      ****             {
1342:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1343:../uvc.c      ****                     {
1344:../uvc.c      ****                         uvcHandleReq = CyTrue;
1345:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1346:../uvc.c      ****                                 CYU3P_EVENT_OR);
1347:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1348:../uvc.c      ****                         {
1349:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1350:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1351:../uvc.c      ****                         }
1352:../uvc.c      ****                     }
1353:../uvc.c      ****                     break;
1354:../uvc.c      **** 
1355:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1356:../uvc.c      ****                     {
1357:../uvc.c      ****                         uvcHandleReq = CyTrue;
1358:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1359:../uvc.c      ****                                 CYU3P_EVENT_OR);
1360:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1361:../uvc.c      ****                         {
1362:../uvc.c      ****                             /* Error handling */
1363:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1364:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1365:../uvc.c      ****                         }
1366:../uvc.c      ****                     }
1367:../uvc.c      ****                     break;
1368:../uvc.c      **** 
1369:../uvc.c      ****                 default:
1370:../uvc.c      ****                     break;
1371:../uvc.c      ****             }
1372:../uvc.c      ****             break;
1373:../uvc.c      **** 
1374:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1375:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1376:../uvc.c      ****             {
1377:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1378:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1379:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1380:../uvc.c      ****                 {
1381:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1382:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1383:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1384:../uvc.c      ****                     gpif_initialized = 0;
1385:../uvc.c      ****                     streamingStarted = CyFalse;
1386:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1387:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1388:../uvc.c      ****                     CyU3PBusyWait (100);
1389:../uvc.c      **** 
1390:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1391:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1392:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1393:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1394:../uvc.c      ****                     CyU3PBusyWait (100);
1395:../uvc.c      **** 
1396:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1397:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1398:../uvc.c      ****                     uvcHandleReq = CyTrue;
1399:../uvc.c      ****                     /* Complete Control request handshake */
1400:../uvc.c      ****                     CyU3PUsbAckSetup ();
1401:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1402:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1403:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1404:../uvc.c      **** 
1405:../uvc.c      ****                 }
1406:../uvc.c      ****             }
1407:../uvc.c      ****             break;
1408:../uvc.c      **** 
1409:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1410:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1411:../uvc.c      ****             {
1412:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1413:../uvc.c      ****                 {
1414:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1415:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1416:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1417:../uvc.c      ****                 	 * has started. */
1418:../uvc.c      ****                     if (streamingStarted == CyTrue)
1419:../uvc.c      ****                     {
1420:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1421:../uvc.c      **** 
1422:../uvc.c      ****                         /* Disable the GPIF state machine. */
1423:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1424:../uvc.c      ****                         gpif_initialized = 0;
1425:../uvc.c      ****                         streamingStarted = CyFalse;
1426:../uvc.c      **** 
1427:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1428:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1429:../uvc.c      ****                         CyU3PBusyWait (100);
1430:../uvc.c      **** 
1431:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1432:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1433:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1434:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1435:../uvc.c      ****                         CyU3PBusyWait (100);
1436:../uvc.c      **** 
1437:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1438:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1439:../uvc.c      **** 
1440:../uvc.c      ****                         uvcHandleReq = CyTrue;
1441:../uvc.c      ****                         /* Complete Control request handshake */
1442:../uvc.c      ****                         CyU3PUsbAckSetup ();
1443:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1444:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1445:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1446:../uvc.c      ****                     }
1447:../uvc.c      ****                     else
1448:../uvc.c      ****                     {
1449:../uvc.c      ****                         uvcHandleReq = CyTrue;
1450:../uvc.c      ****                         CyU3PUsbAckSetup ();
1451:../uvc.c      ****                     }
1452:../uvc.c      ****                 }
1453:../uvc.c      ****             }
1454:../uvc.c      ****             break;
1455:../uvc.c      **** 
1456:../uvc.c      ****         default:
1457:../uvc.c      ****             break;
1458:../uvc.c      ****     }
1459:../uvc.c      **** 
1460:../uvc.c      ****     /* Return status of request handling to the USB driver */
1461:../uvc.c      ****     return uvcHandleReq;
1462:../uvc.c      **** }
1463:../uvc.c      **** 
1464:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1465:../uvc.c      **** 
1466:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1467:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1468:../uvc.c      ****  */
1469:../uvc.c      **** void
1470:../uvc.c      **** CyFxUvcApplnDmaCallback (
1471:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1472:../uvc.c      ****         CyU3PDmaCbType_t      type,
1473:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1474:../uvc.c      ****         )
1475:../uvc.c      **** {
1476:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1477:../uvc.c      **** #if 1
1478:../uvc.c      ****     CyU3PReturnStatus_t status;
1479:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1480:../uvc.c      ****     {
1481:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1482:../uvc.c      ****             {
1483:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1484:../uvc.c      ****                 fb++;
1485:../uvc.c      ****             }
1486:../uvc.c      ****             else
1487:../uvc.c      ****             {
1488:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1489:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1490:../uvc.c      ****                 pb++;
1491:../uvc.c      ****                 pbc = input->buffer_p.count;
1492:../uvc.c      ****                // hitFV = CyTrue;
1493:../uvc.c      ****             }
1494:../uvc.c      **** 
1495:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1496:../uvc.c      ****             prodCount++;
1497:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1498:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1499:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1500:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1501:../uvc.c      ****             {
1502:../uvc.c      ****                 prodCount--;
1503:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1504:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1505:../uvc.c      ****             }
1506:../uvc.c      ****     }
1507:../uvc.c      **** #endif
1508:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1509:../uvc.c      ****     {
1510:../uvc.c      ****         consCount++;
1511:../uvc.c      ****         streamingStarted = CyTrue;
1512:../uvc.c      ****     }
1513:../uvc.c      **** }
1514:../uvc.c      **** 
1515:../uvc.c      **** /*
1516:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1517:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1518:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1519:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1520:../uvc.c      ****  * to commit the buffer.
1521:../uvc.c      ****  */
1522:../uvc.c      **** static uint8_t
1523:../uvc.c      **** CyFxUvcAppCommitEOF (
1524:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1525:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1526:../uvc.c      ****         )
1527:../uvc.c      **** {
1528:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1529:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1530:../uvc.c      **** 
1531:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1532:../uvc.c      **** 
1533:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1534:../uvc.c      ****     {
1535:../uvc.c      ****         switch (stateId)
1536:../uvc.c      ****         {
1537:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1538:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1539:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1540:../uvc.c      ****                 break;
1541:../uvc.c      **** 
1542:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1543:../uvc.c      ****                 socket = 0;
1544:../uvc.c      ****                 break;
1545:../uvc.c      **** 
1546:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1547:../uvc.c      ****                 socket = 1;
1548:../uvc.c      ****                 break;
1549:../uvc.c      **** 
1550:../uvc.c      ****             default:
1551:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1552:../uvc.c      ****                 /* Unexpected current state. Return error. */
1553:../uvc.c      ****                 return 1;
1554:../uvc.c      ****         }
1555:../uvc.c      ****     }
1556:../uvc.c      **** 
1557:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1558:../uvc.c      ****     {
1559:../uvc.c      ****         switch (stateId)
1560:../uvc.c      ****         {
1561:../uvc.c      **** #ifndef CAM720
1562:../uvc.c      **** #ifdef GPIFIIM
1563:../uvc.c      ****             case 13:
1564:../uvc.c      ****             case 24:
1565:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1566:../uvc.c      ****                 break;
1567:../uvc.c      **** 
1568:../uvc.c      ****             case 8:
1569:../uvc.c      ****                 socket = 0;
1570:../uvc.c      ****                 break;
1571:../uvc.c      **** 
1572:../uvc.c      ****             case 20:
1573:../uvc.c      ****                 socket = 1;
1574:../uvc.c      ****                 break;
1575:../uvc.c      **** #else
1576:../uvc.c      ****             case 11:
1577:../uvc.c      ****             case 18:
1578:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1579:../uvc.c      ****                 break;
1580:../uvc.c      **** 
1581:../uvc.c      ****             case 8:
1582:../uvc.c      ****                 socket = 0;
1583:../uvc.c      ****                 break;
1584:../uvc.c      **** 
1585:../uvc.c      ****             case 15:
1586:../uvc.c      ****                 socket = 1;
1587:../uvc.c      ****                 break;
1588:../uvc.c      **** #endif
1589:../uvc.c      **** #else
1590:../uvc.c      ****             case 11:
1591:../uvc.c      ****             case 18:
1592:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1593:../uvc.c      ****                 break;
1594:../uvc.c      **** 
1595:../uvc.c      ****             case 8:
1596:../uvc.c      ****                 socket = 0;
1597:../uvc.c      ****                 break;
1598:../uvc.c      **** 
1599:../uvc.c      ****             case 15:
1600:../uvc.c      ****                 socket = 1;
1601:../uvc.c      ****                 break;
1602:../uvc.c      **** 
1603:../uvc.c      **** #endif
1604:../uvc.c      ****              default:
1605:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1606:../uvc.c      ****                 /* Unexpected current state. Return error. */
1607:../uvc.c      ****                return 1;
1608:../uvc.c      ****         }
1609:../uvc.c      ****     }
1610:../uvc.c      **** 
1611:../uvc.c      ****     if (socket != 0xFF)
1612:../uvc.c      ****     {
1613:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1614:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1615:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1616:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1617:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1618:../uvc.c      ****         {
1619:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1620:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1621:../uvc.c      ****         }
1622:../uvc.c      ****     }
1623:../uvc.c      **** 
1624:../uvc.c      ****     return 0;
1625:../uvc.c      **** }
1626:../uvc.c      **** 
1627:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1628:../uvc.c      **** void
1629:../uvc.c      **** CyFxGpifCB (
1630:../uvc.c      ****         CyU3PGpifEventType event,
1631:../uvc.c      ****         uint8_t currentState
1632:../uvc.c      ****         )
1633:../uvc.c      **** {
1634:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1635:../uvc.c      ****     {
1636:../uvc.c      ****         hitFV = CyTrue;
1637:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1638:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1639:../uvc.c      ****     }
1640:../uvc.c      **** }
1641:../uvc.c      **** 
1642:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1643:../uvc.c      **** static void
1644:../uvc.c      **** CyFxUVCApplnDebugInit (
1645:../uvc.c      ****         void)
1646:../uvc.c      **** {
1647:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1648:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1649:../uvc.c      **** 
1650:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1651:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1652:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1653:../uvc.c      ****     {
1654:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1655:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1656:../uvc.c      ****     }
1657:../uvc.c      **** 
1658:../uvc.c      ****     /* Set UART Configuration */
1659:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1660:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1661:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1662:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1663:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1664:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1665:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1666:../uvc.c      **** 
1667:../uvc.c      ****     /* Set the UART configuration */
1668:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1669:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1670:../uvc.c      ****     {
1671:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1672:../uvc.c      ****     }
1673:../uvc.c      **** 
1674:../uvc.c      ****     /* Set the UART transfer */
1675:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1676:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1677:../uvc.c      ****     {
1678:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1679:../uvc.c      ****     }
1680:../uvc.c      **** 
1681:../uvc.c      ****     /* Initialize the Debug logger module. */
1682:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1683:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1684:../uvc.c      ****     {
1685:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1686:../uvc.c      ****     }
1687:../uvc.c      **** 
1688:../uvc.c      ****     /* Disable log message headers. */
1689:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1690:../uvc.c      **** }
1691:../uvc.c      **** 
1692:../uvc.c      **** /* I2C initialization. */
1693:../uvc.c      **** //static void
1694:../uvc.c      **** void
1695:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1696:../uvc.c      **** {
1697:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1698:../uvc.c      ****     CyU3PReturnStatus_t status;
1699:../uvc.c      **** 
1700:../uvc.c      ****     status = CyU3PI2cInit ();
1701:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1702:../uvc.c      ****     {
1703:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1704:../uvc.c      ****         CyFxAppErrorHandler (status);
1705:../uvc.c      ****     }
1706:../uvc.c      **** 
1707:../uvc.c      ****     /*  Set I2C Configuration */
1708:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1709:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1710:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1711:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1712:../uvc.c      **** 
1713:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1714:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1715:../uvc.c      ****     {
1716:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1717:../uvc.c      ****         CyFxAppErrorHandler (status);
1718:../uvc.c      ****     }
1719:../uvc.c      **** }
1720:../uvc.c      **** 
1721:../uvc.c      **** #ifdef BACKFLOW_DETECT
1722:../uvc.c      **** static void CyFxUvcAppPibCallback (
1723:../uvc.c      ****         CyU3PPibIntrType cbType,
1724:../uvc.c      ****         uint16_t cbArg)
1725:../uvc.c      **** {
1726:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1727:../uvc.c      ****     {
1728:../uvc.c      ****         if (!back_flow_detected)
1729:../uvc.c      ****         {
1730:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1731:../uvc.c      ****             back_flow_detected = 1;
1732:../uvc.c      ****         }
1733:../uvc.c      ****     }
1734:../uvc.c      **** }
1735:../uvc.c      **** #endif
1736:../uvc.c      **** 
1737:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1738:../uvc.c      **** static void
1739:../uvc.c      **** CyFxUvcAppDebugCallback (
1740:../uvc.c      ****         CyU3PDmaChannel   *handle,
1741:../uvc.c      ****         CyU3PDmaCbType_t   type,
1742:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1743:../uvc.c      **** {
1744:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1745:../uvc.c      ****     {
1746:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1747:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1748:../uvc.c      ****     }
1749:../uvc.c      **** }
1750:../uvc.c      **** #endif
1751:../uvc.c      **** 
1752:../uvc.c      **** #if 0
1753:../uvc.c      **** static void CyFxAppIntEpCb(
1754:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1755:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1756:../uvc.c      **** 		uint8_t  ebNum)
1757:../uvc.c      **** 		{
1758:../uvc.c      **** 			//CyBool_t value;
1759:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1760:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1761:../uvc.c      **** 
1762:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1763:../uvc.c      **** 		}
1764:../uvc.c      **** #endif
1765:../uvc.c      **** 
1766:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1767:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1768:../uvc.c      ****    configures the DMA module for the UVC Application */
1769:../uvc.c      **** static void
1770:../uvc.c      **** CyFxUVCApplnInit (void)
1771:../uvc.c      **** {
1772:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1773:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1774:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1775:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1776:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1777:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1778:../uvc.c      **** 
1779:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1780:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1781:../uvc.c      **** 
1782:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1783:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1784:../uvc.c      **** #endif
1785:../uvc.c      **** 
1786:../uvc.c      ****     /* Create UVC event group */
1787:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1788:../uvc.c      ****     if (apiRetStatus != 0)
1789:../uvc.c      ****     {
1790:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1791:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1792:../uvc.c      ****     }
1793:../uvc.c      **** 
1794:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1795:../uvc.c      ****     CyFxUvcAppPTZInit ();
1796:../uvc.c      **** #endif
1797:../uvc.c      **** 
1798:../uvc.c      ****     isUsbConnected = CyFalse;
1799:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1800:../uvc.c      **** 
1801:../uvc.c      ****     /* Init the GPIO module */
1802:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1803:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1804:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1805:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1806:../uvc.c      ****     gpioClock.halfDiv    = 0;
1807:../uvc.c      **** 
1808:../uvc.c      ****     /* Initialize Gpio interface */
1809:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1810:../uvc.c      ****     if (apiRetStatus != 0)
1811:../uvc.c      ****     {
1812:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1813:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1814:../uvc.c      ****     }
1815:../uvc.c      **** 
1816:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1817:../uvc.c      ****      * must use GpioOverride to configure it */
1818:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1819:../uvc.c      ****     if (apiRetStatus != 0)
1820:../uvc.c      ****     {
1821:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1822:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1823:../uvc.c      ****     }
1824:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1825:../uvc.c      ****     if (apiRetStatus != 0)
1826:../uvc.c      ****     {
1827:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1828:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1829:../uvc.c      ****     }
1830:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1831:../uvc.c      ****     if (apiRetStatus != 0)
1832:../uvc.c      ****     {
1833:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1834:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1835:../uvc.c      ****     }
1836:../uvc.c      **** 
1837:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1838:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1839:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1840:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1841:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1842:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1843:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1844:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1845:../uvc.c      ****     {
1846:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1847:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1848:../uvc.c      ****     }
1849:../uvc.c      **** 
1850:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1851:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1852:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1853:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1854:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1855:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1856:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1857:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1858:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1859:../uvc.c      ****     {
1860:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1861:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1862:../uvc.c      ****     }
1863:../uvc.c      **** 
1864:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1865:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1866:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1867:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1868:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1869:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1870:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1871:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1872:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1873:../uvc.c      ****     {
1874:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1875:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1876:../uvc.c      ****     }
1877:../uvc.c      **** 
1878:../uvc.c      ****     /* Initialize the P-port. */
1879:../uvc.c      ****     pibclock.clkDiv      = 2;
1880:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1881:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1882:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1883:../uvc.c      **** 
1884:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1885:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1886:../uvc.c      ****     {
1887:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1888:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1889:../uvc.c      ****     }
1890:../uvc.c      **** 
1891:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1892:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1893:../uvc.c      **** 
1894:../uvc.c      **** #ifdef BACKFLOW_DETECT
1895:../uvc.c      ****     back_flow_detected = 0;
1896:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1897:../uvc.c      **** #endif
1898:../uvc.c      **** 
1899:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1900:../uvc.c      ****     SensorReset ();
1901:../uvc.c      ****     SensorInit ();
1902:../uvc.c      **** 
1903:../uvc.c      ****     /* USB initialization. */
1904:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1905:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1906:../uvc.c      ****     {
1907:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1908:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1909:../uvc.c      ****     }
1910:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1911:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1912:../uvc.c      **** 
1913:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1914:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1915:../uvc.c      **** 
1916:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1917:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1918:../uvc.c      **** 
1919:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1920:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1921:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1922:../uvc.c      **** 
1923:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1924:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1926:../uvc.c      **** 
1927:../uvc.c      ****     /* Configuration descriptors. */
1928:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1929:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1931:../uvc.c      **** 
1932:../uvc.c      ****     /* String Descriptors */
1933:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1934:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1935:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1936:../uvc.c      **** 
1937:../uvc.c      ****     /* Configure the status interrupt endpoint.
1938:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1939:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1940:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1941:../uvc.c      ****      */
1942:../uvc.c      ****     endPointConfig.enable   = 1;
1943:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1944:../uvc.c      ****     endPointConfig.pcktSize = 64;
1945:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1946:../uvc.c      ****     endPointConfig.streams  = 0;
1947:../uvc.c      ****     endPointConfig.burstLen = 1;
1948:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1949:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1950:../uvc.c      ****     {
1951:../uvc.c      ****         /* Error Handling */
1952:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1953:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1954:../uvc.c      ****     }
1955:../uvc.c      **** 
1956:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1957:../uvc.c      ****     dmaInterConfig.size           = 1024;
1958:../uvc.c      ****     dmaInterConfig.count          = 1;
1959:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1960:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1961:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1962:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1963:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1964:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1965:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1966:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1967:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1968:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1969:../uvc.c      ****             &dmaInterConfig);
1970:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1971:../uvc.c      ****     {
1972:../uvc.c      ****         /* Error handling */
1973:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1974:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1975:../uvc.c      ****     }
1976:../uvc.c      **** 
1977:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1978:../uvc.c      ****     if (glInterStaBuffer == 0)
1979:../uvc.c      ****     {
1980:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1981:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1982:../uvc.c      ****     }
1983:../uvc.c      **** 
1984:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1985:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
1986:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1987:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1988:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1989:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1990:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1991:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1992:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1993:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1994:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
1995:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1996:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1997:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1998:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1999:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2000:../uvc.c      ****             &dmaMultiConfig);
2001:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2002:../uvc.c      ****     {
2003:../uvc.c      ****         /* Error handling */
2004:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2005:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2006:../uvc.c      ****     }
2007:../uvc.c      **** 
2008:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2009:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2010:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2011:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2012:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2013:../uvc.c      ****      */
2014:../uvc.c      **** 
2015:../uvc.c      ****     endPointConfig.enable   = 1;
2016:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2017:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2018:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2019:../uvc.c      ****     endPointConfig.streams  = 0;
2020:../uvc.c      ****     endPointConfig.burstLen = 1;
2021:../uvc.c      **** 
2022:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2023:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2024:../uvc.c      ****     {
2025:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2026:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2027:../uvc.c      ****     }
2028:../uvc.c      **** 
2029:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2030:../uvc.c      **** 
2031:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2032:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2033:../uvc.c      ****     {
2034:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2035:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2036:../uvc.c      ****     }
2037:../uvc.c      **** 
2038:../uvc.c      ****     channelConfig.size           = 1024;
2039:../uvc.c      ****     channelConfig.count          = 1;
2040:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2041:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2042:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2043:../uvc.c      ****     channelConfig.prodHeader     = 0;
2044:../uvc.c      ****     channelConfig.prodFooter     = 0;
2045:../uvc.c      ****     channelConfig.consHeader     = 0;
2046:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2047:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2048:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2049:../uvc.c      **** 
2050:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2051:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2052:../uvc.c      ****     {
2053:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2054:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2055:../uvc.c      ****     }
2056:../uvc.c      **** 
2057:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2058:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2059:../uvc.c      ****     {
2060:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2061:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2062:../uvc.c      ****     }
2063:../uvc.c      **** 
2064:../uvc.c      ****     channelConfig.size           = 1024;
2065:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2066:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2067:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2068:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2069:../uvc.c      ****     channelConfig.prodHeader     = 0;
2070:../uvc.c      ****     channelConfig.prodFooter     = 0;
2071:../uvc.c      ****     channelConfig.consHeader     = 0;
2072:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2073:../uvc.c      ****     channelConfig.notification   = 0;
2074:../uvc.c      ****     channelConfig.cb             = 0;
2075:../uvc.c      **** 
2076:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2077:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2078:../uvc.c      ****     {
2079:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2080:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2081:../uvc.c      ****     }
2082:../uvc.c      **** 
2083:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2084:../uvc.c      ****     if (glDebugRspBuffer == 0)
2085:../uvc.c      ****     {
2086:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2087:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2088:../uvc.c      ****     }
2089:../uvc.c      **** #endif
2090:../uvc.c      **** 
2091:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2092:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2093:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2094:../uvc.c      ****     {
2095:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2096:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2097:../uvc.c      ****     }
2098:../uvc.c      **** 
2099:../uvc.c      ****     CyU3PBusyWait(100);
2100:../uvc.c      **** 
2101:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2102:../uvc.c      **** 
2103:../uvc.c      ****     endPointConfig.enable   = 1;
2104:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2105:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2106:../uvc.c      ****     {
2107:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2108:../uvc.c      ****     	endPointConfig.burstLen = 16;
2109:../uvc.c      ****     }
2110:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2111:../uvc.c      ****     {
2112:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2113:../uvc.c      ****     	endPointConfig.burstLen = 1;
2114:../uvc.c      ****     }
2115:../uvc.c      ****     endPointConfig.streams  = 0;
2116:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2117:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2118:../uvc.c      ****     {
2119:../uvc.c      ****         /* Error Handling */
2120:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2121:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2122:../uvc.c      ****     }
2123:../uvc.c      **** #if 0    //for still image method 3 using
2124:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2125:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2126:../uvc.c      ****     {
2127:../uvc.c      ****         /* Error Handling */
2128:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2129:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2130:../uvc.c      ****     }
2131:../uvc.c      **** #endif
2132:../uvc.c      **** 
2133:../uvc.c      **** }
2134:../uvc.c      **** 
2135:../uvc.c      **** /*
2136:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2137:../uvc.c      ****  * streaming session is started.
2138:../uvc.c      ****  */
2139:../uvc.c      **** static void
2140:../uvc.c      **** CyFxUvcAppGpifInit (
2141:../uvc.c      ****         void)
2142:../uvc.c      **** {
2143:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2144:../uvc.c      **** 
2145:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2146:../uvc.c      ****     {
2147:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2148:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2149:../uvc.c      ****     }
2150:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2151:../uvc.c      ****     {
2152:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2153:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2154:../uvc.c      ****     }
2155:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2156:../uvc.c      ****     {
2157:../uvc.c      ****         /* Error Handling */
2158:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2159:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2160:../uvc.c      ****     }
2161:../uvc.c      **** 
2162:../uvc.c      ****     /* Start the state machine from the designated start state. */
2163:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2164:../uvc.c      ****     {
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2166:../uvc.c      ****     }
2167:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2168:../uvc.c      ****     {
2169:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2170:../uvc.c      ****     }
2171:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2172:../uvc.c      ****     {
2173:../uvc.c      ****         /* Error Handling */
2174:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2175:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2176:../uvc.c      ****     }
2177:../uvc.c      **** }
2178:../uvc.c      **** 
2179:../uvc.c      **** /*
2180:../uvc.c      ****  * Entry function for the UVC Application Thread
2181:../uvc.c      ****  */
2182:../uvc.c      **** 
2183:../uvc.c      **** uint32_t posTick;
2184:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2185:../uvc.c      **** 
2186:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2187:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2188:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2189:../uvc.c      **** }
2190:../uvc.c      **** 
2191:../uvc.c      **** 
2192:../uvc.c      **** void
2193:../uvc.c      **** UVCAppThread_Entry (
2194:../uvc.c      ****         uint32_t input)
2195:../uvc.c      **** {
2196:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2197:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2198:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2199:../uvc.c      ****     uint8_t i = 0;
2200:../uvc.c      ****     uint32_t flag;
2201:../uvc.c      ****     uint32_t prinflag = 0;
2202:../uvc.c      **** static uint8_t IMcount = 0;
2203:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2204:../uvc.c      ****     uint32_t frameCnt = 0;
2205:../uvc.c      **** #endif
2206:../uvc.c      ****     /* Initialize the Uart Debug Module */
2207:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2208:../uvc.c      **** 
2209:../uvc.c      ****     /* Initialize the I2C interface */
2210:../uvc.c      **** 	while (i++ < 6){
2211:../uvc.c      **** 		CyU3PThreadSleep(500);
2212:../uvc.c      **** 	}
2213:../uvc.c      **** 
2214:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2215:../uvc.c      **** 
2216:../uvc.c      ****     /* Initialize the UVC Application */
2217:../uvc.c      ****     CyFxUVCApplnInit ();
2218:../uvc.c      **** 
2219:../uvc.c      ****     /*
2220:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2221:../uvc.c      **** 
2222:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2223:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2224:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2225:../uvc.c      **** 
2226:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2227:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2228:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2229:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2230:../uvc.c      **** 
2231:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2232:../uvc.c      ****        of handling the abort request.
2233:../uvc.c      ****      */
2234:../uvc.c      **** 
2235:../uvc.c      ****     for (;;)
2236:../uvc.c      ****     {
2237:../uvc.c      ****         /* Waiting for the Video Stream Event */
2238:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2239:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2240:../uvc.c      ****         {
2241:../uvc.c      **** #if 0 //test for new firmware no video bring up
2242:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2243:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2244:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2245:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2246:../uvc.c      ****             {
2247:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2248:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2249:../uvc.c      ****                 {
2250:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2251:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2252:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2253:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2254:../uvc.c      **** #endif
2255:../uvc.c      **** #endif
2256:../uvc.c      ****                     }
2257:../uvc.c      ****                 else
2258:../uvc.c      ****                 {
2259:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2260:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2261:../uvc.c      **** #ifdef USB_LOWRES_IMG
2262:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2263:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2264:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2265:../uvc.c      **** #endif
2266:../uvc.c      **** #endif
2267:../uvc.c      ****                 }
2268:../uvc.c      **** 
2269:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2270:../uvc.c      ****                 prodCount++;
2271:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2272:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2273:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2274:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2275:../uvc.c      ****                 {
2276:../uvc.c      ****                     prodCount--;
2277:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2278:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2279:../uvc.c      ****                 }
2280:../uvc.c      ****             }
2281:../uvc.c      **** #endif
2282:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2283:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2284:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2285:../uvc.c      ****             {
2286:../uvc.c      ****             	if(0&&(prinflag == 0)){
2287:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2288:../uvc.c      ****             		prinflag = 1;
2289:../uvc.c      ****             	}
2290:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2291:../uvc.c      ****             	fb=0;
2292:../uvc.c      ****             	pb=0;
2293:../uvc.c      ****             	pbc=0;
2294:../uvc.c      ****                 prodCount = 0;
2295:../uvc.c      ****                 consCount = 0;
2296:../uvc.c      ****                 hitFV     = CyFalse;
2297:../uvc.c      **** 
2298:../uvc.c      **** #ifdef BACKFLOW_DETECT
2299:../uvc.c      ****                 back_flow_detected = 0;
2300:../uvc.c      **** #endif
2301:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2302:../uvc.c      ****                 frameCnt++;
2303:../uvc.c      **** #endif
2304:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2305:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2306:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2307:../uvc.c      ****                 //}
2308:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2309:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2310:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2311:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2312:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2313:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2314:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2315:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2316:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2317:../uvc.c      ****                 		stiflag = 0xFF;
2318:../uvc.c      ****                 		IMcount = 0;
2319:../uvc.c      ****                 	}
2320:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2321:../uvc.c      **** 
2322:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2323:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2324:../uvc.c      ****                 		stiflag = 0x0F;
2325:../uvc.c      ****                 		IMcount = 0;
2326:../uvc.c      ****                 		}
2327:../uvc.c      ****                  		/*if(IMcount > 0x4){
2328:../uvc.c      ****                 			stiflag = 0x0F;
2329:../uvc.c      ****                 			IMcount = 0;
2330:../uvc.c      ****                 		}*/
2331:../uvc.c      **** 
2332:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2333:../uvc.c      ****                     //CyU3PThreadSleep(400);
2334:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2335:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2336:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2337:../uvc.c      **** 
2338:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2339:../uvc.c      ****                 	{
2340:../uvc.c      ****                     switch (setRes)
2341:../uvc.c      ****                      {
2342:../uvc.c      ****                  	case 1: //960
2343:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2344:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2345:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0xb, 0x0);
2346:../uvc.c      ****                  		break;
2347:../uvc.c      ****                  	case 2: //720
2348:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2349:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2350:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0x0b, 0x1);
2351:../uvc.c      ****                  		break;
2352:../uvc.c      ****                  	default:
2353:../uvc.c      ****                  		break;
2354:../uvc.c      ****                      }
2355:../uvc.c      ****                     IMcount = 0;
2356:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2357:../uvc.c      ****                 	stiflag = 0x0;
2358:../uvc.c      ****                 	}
2359:../uvc.c      ****                 }
2360:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2361:../uvc.c      ****                 /* Reset the DMA channel. */
2362:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2363:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2364:../uvc.c      ****                 {
2365:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2366:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2367:../uvc.c      ****                 }
2368:../uvc.c      **** 
2369:../uvc.c      ****                 /* Start Channel Immediately */
2370:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2371:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2372:../uvc.c      ****                 {
2373:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2374:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2375:../uvc.c      ****                 }
2376:../uvc.c      **** 
2377:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2378:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2379:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2380:../uvc.c      ****                 }
2381:../uvc.c      ****         }
2382:../uvc.c      ****         else
2383:../uvc.c      ****         {
2384:../uvc.c      ****             /* If we have a stream abort request pending. */
2385:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2386:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2387:../uvc.c      ****             {
2388:../uvc.c      ****                 hitFV     = CyFalse;
2389:../uvc.c      ****                 prodCount = 0;
2390:../uvc.c      ****                 consCount = 0;
2391:../uvc.c      ****                 if(0&&(prinflag == 0)){
2392:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2393:../uvc.c      ****                 	prinflag = 1;
2394:../uvc.c      ****                 }
2395:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2396:../uvc.c      ****                 fb=0;
2397:../uvc.c      ****                 pb=0;
2398:../uvc.c      ****                 pbc=0;
2399:../uvc.c      **** 
2400:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2401:../uvc.c      ****                 {
2402:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2403:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2404:../uvc.c      ****                     {
2405:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2406:../uvc.c      ****                     }
2407:../uvc.c      **** 
2408:../uvc.c      ****                     /* Flush the Endpoint memory */
2409:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2410:../uvc.c      ****                 }
2411:../uvc.c      **** 
2412:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2413:../uvc.c      ****             }
2414:../uvc.c      ****             else
2415:../uvc.c      ****             {
2416:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2417:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2418:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2419:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2420:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2421:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2422:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2423:../uvc.c      ****                 {
2424:../uvc.c      ****                     /* Error handling */
2425:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2426:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2427:../uvc.c      ****                 }
2428:../uvc.c      **** 
2429:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2430:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2431:../uvc.c      ****                 {
2432:../uvc.c      ****                     //for start up of the AF Lens
2433:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2434:../uvc.c      ****                     CyU3PThreadSleep(500);
2435:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2436:../uvc.c      ****                     CyU3PThreadSleep(500);
2437:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2438:../uvc.c      ****                    	CyU3PThreadSleep(300);
2439:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2440:../uvc.c      ****                     CyU3PThreadSleep(500);
2441:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2442:../uvc.c      ****                     CyU3PThreadSleep(500);
2443:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2444:../uvc.c      ****                     gpif_initialized = CyTrue;
2445:../uvc.c      ****                     CyU3PThreadSleep(200);
2446:../uvc.c      ****                     
2447:../uvc.c      ****                 }
2448:../uvc.c      ****                 else
2449:../uvc.c      ****                 {
2450:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2451:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2452:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2453:../uvc.c      ****                 }
2454:../uvc.c      ****             }
2455:../uvc.c      ****         }
2456:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2457:../uvc.c      **** 
2458:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2459:../uvc.c      ****         CyU3PThreadRelinquish ();
2460:../uvc.c      ****     }
2461:../uvc.c      **** }
2462:../uvc.c      **** 
2463:../uvc.c      **** /*
2464:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2465:../uvc.c      ****  */
2466:../uvc.c      **** 
2467:../uvc.c      **** static void
2468:../uvc.c      **** UVCHandleProcessingUnitRqts (
2469:../uvc.c      ****         void)
2470:../uvc.c      **** {
2471:../uvc.c      ****     uint8_t CtrlAdd;
2472:../uvc.c      **** #ifdef DbgInfo
2473:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2474:../uvc.c      **** #endif
2475:../uvc.c      ****     switch (wValue)
2476:../uvc.c      ****     {
2477:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2478:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2479:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2480:../uvc.c      ****     		break;
2481:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2482:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2483:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2484:../uvc.c      ****     		break;
2485:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2486:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2487:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2488:../uvc.c      **** 			break;
2489:../uvc.c      **** 
2490:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2491:../uvc.c      **** 
2492:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2493:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2494:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2495:../uvc.c      ****       		break;
2496:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2497:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2498:../uvc.c      ****      		ControlHandle(HueCtlID5);
2499:../uvc.c      ****      		break;
2500:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2501:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2502:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2503:../uvc.c      ****           		break;
2504:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2505:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2506:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2507:../uvc.c      ****           		break;
2508:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2509:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2510:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2511:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2512:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2513:../uvc.c      ****     		break;
2514:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2515:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2516:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2517:../uvc.c      ****     		break;
2518:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2519:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2520:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2521:../uvc.c      ****     		break;
2522:../uvc.c      **** 
2523:../uvc.c      ****         default:
2524:../uvc.c      ****             /*
2525:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2526:../uvc.c      ****              * other controls.
2527:../uvc.c      ****              */
2528:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2529:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2530:../uvc.c      ****             break;
2531:../uvc.c      ****     }
2532:../uvc.c      **** }
2533:../uvc.c      **** 
2534:../uvc.c      **** /*
2535:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2536:../uvc.c      ****  */
2537:../uvc.c      **** static void
2538:../uvc.c      **** UVCHandleCameraTerminalRqts (
2539:../uvc.c      ****         void)
2540:../uvc.c      **** {
2541:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2542:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2543:../uvc.c      ****     uint16_t readCount;
2544:../uvc.c      ****     uint16_t zoomVal;
2545:../uvc.c      ****     int32_t  panVal, tiltVal;
2546:../uvc.c      ****     CyBool_t sendData = CyFalse;
2547:../uvc.c      **** #endif
2548:../uvc.c      ****     uint8_t CtrlAdd;
2549:../uvc.c      **** 
2550:../uvc.c      ****     switch (wValue)
2551:../uvc.c      ****     {
2552:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2553:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2554:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2555:../uvc.c      ****     		break;
2556:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2557:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2558:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2559:../uvc.c      ****     		break;
2560:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2561:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2562:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2563:../uvc.c      **** 			break;
2564:../uvc.c      **** 
2565:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2566:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2567:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2568:../uvc.c      **** 			break;
2569:../uvc.c      **** 
2570:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2571:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2572:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2573:../uvc.c      ****       		break;
2574:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2575:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2576:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2577:../uvc.c      ****      		break;
2578:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2579:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2580:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2581:../uvc.c      ****           		break;
2582:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2583:../uvc.c      ****           		break;
2584:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2585:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2586:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2587:../uvc.c      ****      		break;
2588:../uvc.c      **** 
2589:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2590:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2591:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2592:../uvc.c      ****     		break;
2593:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2594:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2595:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2596:../uvc.c      ****     		break;
2597:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2598:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2599:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2600:../uvc.c      ****     		break;
2601:../uvc.c      **** 
2602:../uvc.c      ****         default:
2603:../uvc.c      ****             /*
2604:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2605:../uvc.c      ****              * other controls.
2606:../uvc.c      ****              */
2607:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2608:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2609:../uvc.c      ****             break;
2610:../uvc.c      ****     }
2611:../uvc.c      **** 
2612:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2613:../uvc.c      ****     switch (wValue)
2614:../uvc.c      ****     {
2615:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2616:../uvc.c      ****             switch (bRequest)
2617:../uvc.c      ****             {
2618:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2619:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2620:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2621:../uvc.c      ****                     break;
2622:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2623:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2624:../uvc.c      ****                     sendData = CyTrue;
2625:../uvc.c      ****                     break;
2626:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2627:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2628:../uvc.c      ****                     sendData = CyTrue;
2629:../uvc.c      ****                     break;
2630:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2631:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2632:../uvc.c      ****                     sendData = CyTrue;
2633:../uvc.c      ****                     break;
2634:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2635:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2636:../uvc.c      ****                     sendData = CyTrue;
2637:../uvc.c      ****                     break;
2638:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2639:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2640:../uvc.c      ****                     sendData = CyTrue;
2641:../uvc.c      ****                     break;
2642:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2643:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2644:../uvc.c      ****                             glEp0Buffer, &readCount);
2645:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2646:../uvc.c      ****                     {
2647:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2648:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2649:../uvc.c      ****                     }
2650:../uvc.c      ****                     break;
2651:../uvc.c      ****                 default:
2652:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2653:../uvc.c      ****                     break;
2654:../uvc.c      ****             }
2655:../uvc.c      **** 
2656:../uvc.c      ****             if (sendData)
2657:../uvc.c      ****             {
2658:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2659:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2660:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2661:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2662:../uvc.c      ****             }
2663:../uvc.c      ****             break;
2664:../uvc.c      **** 
2665:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2666:../uvc.c      ****             switch (bRequest)
2667:../uvc.c      ****             {
2668:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2669:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2670:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2671:../uvc.c      ****                     break;
2672:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2673:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2674:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2675:../uvc.c      ****                     sendData = CyTrue;
2676:../uvc.c      ****                     break;
2677:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2678:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2679:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2680:../uvc.c      ****                     sendData = CyTrue;
2681:../uvc.c      ****                     break;
2682:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2683:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2684:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2685:../uvc.c      ****                     sendData = CyTrue;
2686:../uvc.c      ****                     break;
2687:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2688:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2689:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2690:../uvc.c      ****                     sendData = CyTrue;
2691:../uvc.c      ****                     break;
2692:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2693:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2694:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2695:../uvc.c      ****                     sendData = CyTrue;
2696:../uvc.c      ****                     break;
2697:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2698:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2699:../uvc.c      ****                             glEp0Buffer, &readCount);
2700:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2701:../uvc.c      ****                     {
2702:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2703:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2704:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2705:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2706:../uvc.c      **** 
2707:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2708:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2709:../uvc.c      ****                     }
2710:../uvc.c      ****                     break;
2711:../uvc.c      ****                 default:
2712:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2713:../uvc.c      ****                     break;
2714:../uvc.c      ****             }
2715:../uvc.c      **** 
2716:../uvc.c      ****             if (sendData)
2717:../uvc.c      ****             {
2718:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2719:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2720:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2721:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2722:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2723:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2724:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2725:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2726:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2727:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2728:../uvc.c      ****             }
2729:../uvc.c      ****             break;
2730:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2731:../uvc.c      ****         default:
2732:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2733:../uvc.c      ****             break;
2734:../uvc.c      ****     }
2735:../uvc.c      **** #endif
2736:../uvc.c      **** }
2737:../uvc.c      **** 
2738:../uvc.c      **** /*
2739:../uvc.c      ****  * Handler for UVC Interface control requests.
2740:../uvc.c      ****  */
2741:../uvc.c      **** static void
2742:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2743:../uvc.c      ****         void)
2744:../uvc.c      **** {
2745:../uvc.c      **** 
2746:../uvc.c      ****     switch (wValue)
2747:../uvc.c      ****     {
2748:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2749:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2750:../uvc.c      ****     		break;
2751:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2752:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2753:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2754:../uvc.c      ****     		break;
2755:../uvc.c      ****     	default:
2756:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2757:../uvc.c      ****      		break;
2758:../uvc.c      ****     }
2759:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2760:../uvc.c      **** 
2761:../uvc.c      **** }
2762:../uvc.c      **** 
2763:../uvc.c      **** /*
2764:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2765:../uvc.c      ****  */
2766:../uvc.c      **** static void
2767:../uvc.c      **** UVCHandleExtensionUnitRqts (
2768:../uvc.c      ****         void)
2769:../uvc.c      **** {
2770:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2771:../uvc.c      **** 
2772:../uvc.c      **** #ifdef DbgInfo
2773:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2774:../uvc.c      **** #endif
2775:../uvc.c      ****     switch (wValue)
2776:../uvc.c      ****     {
2777:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2778:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2779:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2780:../uvc.c      ****     		break;
2781:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2782:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2783:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2784:../uvc.c      ****     		break;
2785:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2786:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2787:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2788:../uvc.c      ****      		break;
2789:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2790:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2791:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2792:../uvc.c      ****     		break;
2793:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2794:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2795:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2796:../uvc.c      ****     		break;
2797:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2798:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2799:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2800:../uvc.c      ****      		break;
2801:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2802:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2803:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2804:../uvc.c      ****     		break;
2805:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2806:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2807:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2808:../uvc.c      ****     		break;
2809:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2810:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2811:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2812:../uvc.c      ****      		break;
2813:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2814:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2815:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2816:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2817:../uvc.c      ****     		}else/* no support for 1080p camera */
2818:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2819:../uvc.c      ****     		break;
2820:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2821:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2822:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2823:../uvc.c      ****     		break;
2824:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2825:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2826:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2827:../uvc.c      ****     		break;
2828:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2829:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2830:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2831:../uvc.c      ****     		//break;
2832:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2833:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2834:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2835:../uvc.c      ****     		break;
2836:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2837:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2838:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2839:../uvc.c      ****     		break;
2840:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2841:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2842:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2843:../uvc.c      ****     		break;
2844:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2845:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2846:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2847:../uvc.c      ****     		break;
2848:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2849:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2850:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2851:../uvc.c      ****     		break;
2852:../uvc.c      ****    	default:
2853:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2854:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2855:../uvc.c      ****     		break;
2856:../uvc.c      ****     }
2857:../uvc.c      **** 
2858:../uvc.c      **** }
2859:../uvc.c      **** 
2860:../uvc.c      **** /*
2861:../uvc.c      ****  * Handler for the video streaming control requests.
2862:../uvc.c      ****  */
2863:../uvc.c      **** static void
2864:../uvc.c      **** UVCHandleVideoStreamingRqts (
2865:../uvc.c      ****         void)
2866:../uvc.c      **** {
2867:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2868:../uvc.c      ****     uint16_t readCount;
2869:../uvc.c      **** 
2870:../uvc.c      ****     switch (wValue)
2871:../uvc.c      ****     {
2872:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2873:../uvc.c      ****             switch (bRequest)
2874:../uvc.c      ****             {
2875:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2876:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2877:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2878:../uvc.c      ****                     break;
2879:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2880:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2881:../uvc.c      ****                     glEp0Buffer[1] = 0;
2882:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2883:../uvc.c      ****                     break;
2884:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2885:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2886:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2887:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2888:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED)//supports both SS and HS
2889:../uvc.c      ****                     {
2890:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2891:../uvc.c      ****                     }
2892:../uvc.c      ****                     else
2893:../uvc.c      ****                     {
2894:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2895:../uvc.c      ****                     }
2896:../uvc.c      ****                     break;
2897:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2898:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2899:../uvc.c      ****                             glCommitCtrl, &readCount);
2900:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2901:../uvc.c      ****                     {
2902:../uvc.c      ****                         //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
2903:../uvc.c      ****                         {
2904:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2905:../uvc.c      ****                                active data structure. */
2906:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2907:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2908:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2909:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2910:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2911:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2912:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d\r\n", readCount
2913:../uvc.c      ****                         }
2914:../uvc.c      ****                     }
2915:../uvc.c      ****                     break;
2916:../uvc.c      ****                 default:
2917:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2918:../uvc.c      ****                     break;
2919:../uvc.c      ****             }
2920:../uvc.c      ****             break;
2921:../uvc.c      **** 
2922:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2923:../uvc.c      ****             switch (bRequest)
2924:../uvc.c      ****             {
2925:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2926:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2927:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2928:../uvc.c      ****                     break;
2929:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2930:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2931:../uvc.c      ****                     glEp0Buffer[1] = 0;
2932:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2933:../uvc.c      ****                     break;
2934:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2935:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED) //support both SS and HS
2936:../uvc.c      ****                     {
2937:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2938:../uvc.c      ****                     }
2939:../uvc.c      ****                     else
2940:../uvc.c      ****                     {
2941:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2942:../uvc.c      ****                     }
2943:../uvc.c      ****                     break;
2944:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2945:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2946:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2947:../uvc.c      ****                        */
2948:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2949:../uvc.c      ****                             glCommitCtrl, &readCount);
2950:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)//supports both SS and HS
2951:../uvc.c      ****                     {
2952:../uvc.c      ****                         switch (glCommitCtrl[3])
2953:../uvc.c      ****                          {
2954:../uvc.c      ****                          	case 1: //960 or 480
2955:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
2956:../uvc.c      ****                          		CyU3PThreadSleep(500);
2957:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
2958:../uvc.c      ****                          		break;
2959:../uvc.c      ****                          	case 2: //720 or 360
2960:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
2961:../uvc.c      ****                          		CyU3PThreadSleep(500);
2962:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
2963:../uvc.c      ****                          		break;
2964:../uvc.c      ****                          	default:
2965:../uvc.c      ****                          		break;
2966:../uvc.c      ****                          }
2967:../uvc.c      ****                         setRes = glCommitCtrl[3];
2968:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
2969:../uvc.c      **** 
2970:../uvc.c      **** #if 0
2971:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2972:../uvc.c      ****                         {
2973:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2974:../uvc.c      ****                         }
2975:../uvc.c      ****                         else
2976:../uvc.c      ****                         {
2977:../uvc.c      ****                             SensorScaling_VGA ();
2978:../uvc.c      ****                         }
2979:../uvc.c      **** #endif
2980:../uvc.c      ****                         /* We can start streaming video now. */
2981:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2982:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2983:../uvc.c      ****                         {
2984:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2985:../uvc.c      ****                         }
2986:../uvc.c      ****                     }
2987:../uvc.c      ****                     break;
2988:../uvc.c      **** 
2989:../uvc.c      ****                 default:
2990:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2991:../uvc.c      ****                     break;
2992:../uvc.c      ****             }
2993:../uvc.c      ****             break;
2994:../uvc.c      **** 
2995:../uvc.c      **** /* still image streaming handler */
2996:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2997:../uvc.c      ****                 switch (bRequest)
2998:../uvc.c      ****                 {
2999:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3000:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3001:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3002:../uvc.c      ****                         break;
3003:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3004:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3005:../uvc.c      ****                         glEp0Buffer[1] = 0;
3006:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3007:../uvc.c      ****                         break;
3008:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3009:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3010:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3011:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3012:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3013:../uvc.c      ****                         {
3014:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3015:../uvc.c      ****                         }
3016:../uvc.c      ****                         else
3017:../uvc.c      ****                         {
3018:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3019:../uvc.c      ****                         }
3020:../uvc.c      ****                         break;
3021:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3022:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3023:../uvc.c      ****                                 glCommitCtrl, &readCount);
3024:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3025:../uvc.c      ****                         {
3026:../uvc.c      ****                             //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
3027:../uvc.c      ****                             {
3028:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3029:../uvc.c      ****                                    active data structure. */
3030:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3031:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3032:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3033:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3034:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3035:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3036:../uvc.c      ****                             }
3037:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3038:../uvc.c      ****                         }
3039:../uvc.c      ****                         break;
3040:../uvc.c      ****                     default:
3041:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3042:../uvc.c      ****                         break;
3043:../uvc.c      ****                 }
3044:../uvc.c      ****                 break;
3045:../uvc.c      **** 
3046:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3047:../uvc.c      ****                 switch (bRequest)
3048:../uvc.c      ****                 {
3049:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3050:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3051:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3052:../uvc.c      ****                         break;
3053:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3054:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3055:../uvc.c      ****                         glEp0Buffer[1] = 0;
3056:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3057:../uvc.c      ****                         break;
3058:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3059:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3060:../uvc.c      ****                         {
3061:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3062:../uvc.c      ****                         }
3063:../uvc.c      ****                         else
3064:../uvc.c      ****                         {
3065:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3066:../uvc.c      ****                         }
3067:../uvc.c      ****                         break;
3068:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3069:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3070:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3071:../uvc.c      ****                            */
3072:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3073:../uvc.c      ****                                 glCommitCtrl, &readCount);
3074:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3075:../uvc.c      ****                         {
3076:../uvc.c      ****     #if 0
3077:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3078:../uvc.c      ****                             {
3079:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3080:../uvc.c      ****                             }
3081:../uvc.c      ****                             else
3082:../uvc.c      ****                             {
3083:../uvc.c      ****                                 SensorScaling_VGA ();
3084:../uvc.c      ****                             }
3085:../uvc.c      ****                             /* We can start streaming video now. */
3086:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3087:../uvc.c      **** 
3088:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3089:../uvc.c      ****                             {
3090:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3091:../uvc.c      ****                             }
3092:../uvc.c      **** 	#endif
3093:../uvc.c      ****                            switch (glCommitCtrl[1])
3094:../uvc.c      ****                              {
3095:../uvc.c      ****                              	case 2: //720
3096:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*
3097:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3098:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3099:../uvc.c      ****                              		break;
3100:../uvc.c      ****                             	case 1: //960
3101:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*
3102:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3103:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3104:../uvc.c      ****                              		break;
3105:../uvc.c      ****                               	default:
3106:../uvc.c      ****                              		break;
3107:../uvc.c      ****                              }
3108:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3109:../uvc.c      **** 
3110:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3111:../uvc.c      **** 
3112:../uvc.c      ****                         }
3113:../uvc.c      ****                         break;
3114:../uvc.c      **** 
3115:../uvc.c      ****                     default:
3116:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3117:../uvc.c      ****                         break;
3118:../uvc.c      ****                 }
3119:../uvc.c      ****                 break;
3120:../uvc.c      **** 
3121:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3122:../uvc.c      ****                 switch (bRequest)
3123:../uvc.c      ****                 {
3124:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3125:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3126:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3127:../uvc.c      ****                         break;
3128:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3129:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3130:../uvc.c      ****                         glEp0Buffer[1] = 0;
3131:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3132:../uvc.c      ****                         break;
3133:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3134:../uvc.c      ****                         if (1 || usbSpeed == CY_U3P_SUPER_SPEED)// support both SS and HS
3135:../uvc.c      ****                         {
3136:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3137:../uvc.c      ****                         }
3138:../uvc.c      ****                         else
3139:../uvc.c      ****                         {
3140:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3141:../uvc.c      ****                         }
3142:../uvc.c      ****                         break;
3143:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3144:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3145:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3146:../uvc.c      ****                            */
3147:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3148:../uvc.c      ****                                 glCommitCtrl, &readCount);
3149:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3150:../uvc.c      ****                         {
3151:../uvc.c      ****     #if 1
3152:../uvc.c      ****                             /* We can start still streaming video now. */
3153:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3154:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3155:../uvc.c      ****                             {
3156:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3157:../uvc.c      ****                             }
3158:../uvc.c      ****     #endif
3159:../uvc.c      ****                             else{
3160:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3161:../uvc.c      ****                             //stillcont = 0;
3162:../uvc.c      ****                             }
3163:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3164:../uvc.c      ****                         }else{
3165:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3166:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3167:../uvc.c      ****                         }
3168:../uvc.c      ****                         break;
3169:../uvc.c      **** 
3170:../uvc.c      ****                     default:
3171:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3172:../uvc.c      ****                         break;
3173:../uvc.c      ****                 }
3174:../uvc.c      ****                 break;
3175:../uvc.c      **** 
3176:../uvc.c      ****         default:
3177:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3178:../uvc.c      ****             break;
3179:../uvc.c      ****     }
3180:../uvc.c      **** }
3181:../uvc.c      **** 
3182:../uvc.c      **** /*
3183:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3184:../uvc.c      ****  */
3185:../uvc.c      **** void
3186:../uvc.c      **** UVCAppEP0Thread_Entry (
3187:../uvc.c      ****         uint32_t input)
3188:../uvc.c      **** {
3189:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3190:../uvc.c      ****     uint32_t eventFlag;
3191:../uvc.c      **** 	CyBool_t value;
3192:../uvc.c      **** 	CyBool_t *valueptr = &value;
3193:../uvc.c      **** 
3194:../uvc.c      **** 
3195:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3196:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3197:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3198:../uvc.c      **** 
3199:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3200:../uvc.c      **** #endif
3201:../uvc.c      **** 
3202:../uvc.c      ****     /* for interrupt status test */
3203:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3204:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3205:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3206:../uvc.c      **** 
3207:../uvc.c      ****     for (;;)
3208:../uvc.c      ****     {
3209:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3210:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3211:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3212:../uvc.c      ****         {
3213:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3214:../uvc.c      ****             if (!isUsbConnected)
3215:../uvc.c      ****             {
3216:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3217:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3218:../uvc.c      ****                 {
3219:../uvc.c      ****                     isUsbConnected = CyTrue;
3220:../uvc.c      ****                 }
3221:../uvc.c      ****             }
3222:../uvc.c      **** //#ifdef DbgInfo
3223:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3224:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3225:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3226:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3227:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3228:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3229:../uvc.c      **** //#endif
3230:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3231:../uvc.c      ****             {
3232:../uvc.c      ****             	switch ((wIndex >> 8))
3233:../uvc.c      ****                 {
3234:../uvc.c      **** 
3235:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3236:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3237:../uvc.c      ****                         break;
3238:../uvc.c      **** 
3239:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3240:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3241:../uvc.c      ****                         break;
3242:../uvc.c      **** 
3243:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3244:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3245:../uvc.c      ****                         break;
3246:../uvc.c      **** 
3247:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3248:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3249:../uvc.c      ****                         break;
3250:../uvc.c      **** 
3251:../uvc.c      ****                     default:
3252:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3253:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3254:../uvc.c      ****                         break;
3255:../uvc.c      ****                 }
3256:../uvc.c      ****             }
3257:../uvc.c      **** 
3258:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3259:../uvc.c      ****             {
3260:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3261:../uvc.c      **** 
3262:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3263:../uvc.c      ****                 {
3264:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3265:../uvc.c      ****                 }
3266:../uvc.c      ****                 else
3267:../uvc.c      ****                 {
3268:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3269:../uvc.c      ****                 }
3270:../uvc.c      ****             }
3271:../uvc.c      **** 
3272:../uvc.c      ****             /* handle interrupt status event */
3273:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3274:../uvc.c      ****             {
3275:../uvc.c      **** 
3276:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3277:../uvc.c      ****             	/** preparing interrupt status data **/
3278:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3279:../uvc.c      **** 
3280:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3281:../uvc.c      **** 
3282:../uvc.c      **** #if 1 //for real button
3283:../uvc.c      **** 				if(value&&(!snapButFlag)){
3284:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3285:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3286:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3287:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3288:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3289:../uvc.c      **** 
3290:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3291:../uvc.c      **** 					interStabuf.size   = 1024;
3292:../uvc.c      **** 					interStabuf.status = 0;
3293:../uvc.c      **** 
3294:../uvc.c      **** 					interStabuf.count = 4;
3295:../uvc.c      **** 
3296:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3297:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3298:../uvc.c      **** 
3299:../uvc.c      **** 					/** send a interrupt status data **/
3300:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3301:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3302:../uvc.c      **** 					{
3303:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3304:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3305:../uvc.c      **** 					}
3306:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3307:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3308:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3309:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3310:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3311:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3312:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3313:../uvc.c      **** 
3314:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3315:../uvc.c      **** 					interStabuf.size   = 1024;
3316:../uvc.c      **** 					interStabuf.status = 0;
3317:../uvc.c      **** 
3318:../uvc.c      **** 					interStabuf.count = 4;
3319:../uvc.c      **** 
3320:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3321:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3322:../uvc.c      **** 
3323:../uvc.c      **** 					/** send a interrupt status data **/
3324:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3325:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3326:../uvc.c      **** 					{
3327:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3328:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3329:../uvc.c      **** 					}
3330:../uvc.c      **** 
3331:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3332:../uvc.c      **** 					stiflag = 0xFF;
3333:../uvc.c      **** 				}
3334:../uvc.c      **** #else			//for botton simulation
3335:../uvc.c      **** 				if(snapButFlag == 0x0f){
3336:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3337:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3338:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3339:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3340:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3341:../uvc.c      **** 
3342:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3343:../uvc.c      **** 					interStabuf.size   = 1024;
3344:../uvc.c      **** 					interStabuf.status = 0;
3345:../uvc.c      **** 
3346:../uvc.c      **** 					interStabuf.count = 4;
3347:../uvc.c      **** 
3348:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3349:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3350:../uvc.c      **** 
3351:../uvc.c      **** 					/** send a interrupt status data **/
3352:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3353:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3354:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3355:../uvc.c      **** 					{
3356:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3357:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3358:../uvc.c      **** 					}
3359:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3360:../uvc.c      **** 
3361:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3362:../uvc.c      **** 				}else if(!snapButFlag){
3363:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3364:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3365:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3366:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3367:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3368:../uvc.c      **** 
3369:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3370:../uvc.c      **** 					interStabuf.size   = 1024;
3371:../uvc.c      **** 					interStabuf.status = 0;
3372:../uvc.c      **** 
3373:../uvc.c      **** 					interStabuf.count = 4;
3374:../uvc.c      **** 
3375:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3376:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3377:../uvc.c      **** 
3378:../uvc.c      **** 					/** send a interrupt status data **/
3379:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3380:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3381:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3382:../uvc.c      **** 					{
3383:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3384:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3385:../uvc.c      **** 					}
3386:../uvc.c      **** 
3387:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3388:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3389:../uvc.c      **** 				}
3390:../uvc.c      **** #endif
3391:../uvc.c      **** 
3392:../uvc.c      ****             }
3393:../uvc.c      **** 
3394:../uvc.c      **** 
3395:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3396:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3397:../uvc.c      ****             {
3398:../uvc.c      ****                 /* Get the command buffer */
3399:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3400:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3401:../uvc.c      ****                 {
3402:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3403:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3404:../uvc.c      ****                 }
3405:../uvc.c      **** 
3406:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3407:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3408:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3409:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3410:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3411:../uvc.c      ****                  * register value high byte and register value low byte.
3412:../uvc.c      ****                  */
3413:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3414:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3415:../uvc.c      ****                 {
3416:../uvc.c      ****                     if (dmaInfo.count == 3)
3417:../uvc.c      ****                     {
3418:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3419:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3420:../uvc.c      ****                         dmaInfo.count = 3;
3421:../uvc.c      ****                     }
3422:../uvc.c      ****                     else if (dmaInfo.count == 4)
3423:../uvc.c      ****                     {
3424:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3425:../uvc.c      ****                         {
3426:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3427:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3428:../uvc.c      ****                         }
3429:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3430:../uvc.c      ****                     }
3431:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3432:../uvc.c      ****                 }
3433:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3434:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3435:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3436:../uvc.c      ****                  */
3437:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3438:../uvc.c      ****                 {
3439:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3440:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3441:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3442:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3443:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3444:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3445:../uvc.c      ****                         	break;
3446:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3447:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3448:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3449:../uvc.c      ****                         	break;*/
3450:../uvc.c      ****                     dmaInfo.count -= 2;
3451:../uvc.c      ****                 }
3452:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3453:../uvc.c      ****                 else
3454:../uvc.c      ****                 {
3455:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3456:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3457:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3458:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3459:../uvc.c      ****                 }
3460:../uvc.c      **** 
3461:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3462:../uvc.c      ****                 dmaInfo.size   = 1024;
3463:../uvc.c      ****                 dmaInfo.status = 0;
3464:../uvc.c      **** 
3465:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3466:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3467:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3468:../uvc.c      ****                 {
3469:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3470:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3471:../uvc.c      ****                 }
3472:../uvc.c      **** 
3473:../uvc.c      ****                 /* Wait until the response has gone out. */
3474:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3475:../uvc.c      **** 
3476:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3477:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3478:../uvc.c      ****                 {
3479:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3480:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3481:../uvc.c      ****                 }
3482:../uvc.c      ****             }
3483:../uvc.c      **** #endif
3484:../uvc.c      ****         }
3485:../uvc.c      ****         /* Allow other ready threads to run. */
3486:../uvc.c      ****         CyU3PThreadRelinquish ();
3487:../uvc.c      ****     }
3488:../uvc.c      **** }
3489:../uvc.c      **** 
3490:../uvc.c      **** /*
3491:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3492:../uvc.c      ****  * added 10/2013
3493:../uvc.c      ****  */
3494:../uvc.c      **** /*
3495:../uvc.c      **** static uint8_t timeDelay[64] = {
3496:../uvc.c      **** 
3497:../uvc.c      **** };
3498:../uvc.c      **** */
3499:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3499 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3500:../uvc.c      **** 
3501:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3502:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3503:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3504:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3505:../uvc.c      **** 	VdstateDes *lcStaDes;
3506:../uvc.c      **** 	uint32_t flag = 0;
3507:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3508:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3509:../uvc.c      **** 	uint8_t i;
3510:../uvc.c      **** 	uint16_t delaytime;
3511:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3512:../uvc.c      **** 
3513:../uvc.c      **** #if 0 //for test the command queue
3514:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3515:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3516:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3517:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3518:../uvc.c      **** 		lcCmdDes += 1;
3519:../uvc.c      **** 	}
3520:../uvc.c      **** #endif
3521:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3522:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3522 0
  36 0004 00229FE5 		ldr	r2, .L22
3506:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3506 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3499:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3499 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3522 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 E8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3506:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3506 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3522 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3523:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3523 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 CC119FE5 		ldr	r1, .L22+8
  71 0044 CC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3524:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3524 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3525:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3525 0
  79 005c AC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3526:../uvc.c      **** 
3527:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3527 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3528:../uvc.c      ****         /* Allow other ready threads to run. */
3529:../uvc.c      **** 
3530:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3530 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3527:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3527 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3531:../uvc.c      **** 	}
3532:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3532 0
  92 0078 98019FE5 		ldr	r0, .L22+12
  93 007c 98119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 88719FE5 		ldr	r7, .L22+20
  99 0094 88B19FE5 		ldr	fp, .L22+24
3533:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3534:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3535:../uvc.c      **** 	//CyU3PThreadSleep(100);
3536:../uvc.c      **** 	//SetCurCmd();
3537:../uvc.c      **** 	/*********** the loop of the thread ***********/
3538:../uvc.c      **** 	for(;;){
3539:../uvc.c      **** 
3540:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3540 0
 101 0098 0060E0E3 		mvn	r6, #0
3541:../uvc.c      **** /*  // for test GPIO output
3542:../uvc.c      **** 		if(trigger)
3543:../uvc.c      **** 		{
3544:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3545:../uvc.c      **** 			{
3546:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3547:../uvc.c      **** 			}
3548:../uvc.c      **** 
3549:../uvc.c      **** 		}else{
3550:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3551:../uvc.c      **** 			{
3552:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3553:../uvc.c      **** 			}
3554:../uvc.c      **** 
3555:../uvc.c      **** 		}
3556:../uvc.c      **** */
3557:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3558:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3559:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3560:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3561:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3562:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3563:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3564:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3565:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3566:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3567:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3568:../uvc.c      **** #endif
3569:../uvc.c      **** 				}
3570:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3571:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3572:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3573:../uvc.c      **** 			}
3574:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3575:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3576:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3577:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3578:../uvc.c      **** 
3579:../uvc.c      **** 				/*
3580:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3581:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3582:../uvc.c      **** 				*/
3583:../uvc.c      **** 
3584:../uvc.c      **** 				/* find a available command */
3585:../uvc.c      **** 				i = 0;
3586:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3586 0
 103 009c 0090A0E3 		mov	r9, #0
3587:../uvc.c      **** 					i++;
3588:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3589:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3590:../uvc.c      **** 				}
3591:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3592:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3593:../uvc.c      **** 					i = lcCmdDes->curNum;
3594:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3595:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3596:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3597:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3598:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3599:../uvc.c      **** 						case 0x20:
3600:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3601:../uvc.c      **** 							delaytime = 500;
3602:../uvc.c      **** 							break;
3603:../uvc.c      **** 						case 0x21:
3604:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3605:../uvc.c      **** 							delaytime = 500;
3606:../uvc.c      **** 							break;
3607:../uvc.c      **** 						case 0x22:
3608:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3609:../uvc.c      **** 							delaytime = 300;
3610:../uvc.c      **** 							break;
3611:../uvc.c      **** 						case 0x23:
3612:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3613:../uvc.c      **** 							delaytime = 300;
3614:../uvc.c      **** 							break;
3615:../uvc.c      **** 						default:
3616:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3617:../uvc.c      **** 							break;
3618:../uvc.c      **** 					}
3619:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3620:../uvc.c      **** 					/** timer's ticket modify **/
3621:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3622:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3623:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3624:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3625:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3626:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3627:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3628:../uvc.c      **** #endif
3629:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3630:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3631:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3632:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3633:../uvc.c      **** 						}else{
3634:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3635:../uvc.c      **** 						}
3636:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3637:../uvc.c      **** 					}else{
3638:../uvc.c      **** 						lcCmdDes->curNum ++;
3639:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3639 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3540:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3540 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 70019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3557:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3557 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3574:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3574 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3576:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3576 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3577:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3577 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3586:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3586 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3588:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3588 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3587:../uvc.c      **** 					i++;
 140              		.loc 1 3587 0
 141 00f4 011083E2 		add	r1, r3, #1
3586:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3586 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3587:../uvc.c      **** 					i++;
 144              		.loc 1 3587 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3586:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3586 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3592:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3592 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2900000A 		beq	.L6
 157              	.LVL10:
3594:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3594 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3598:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3598 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3594:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3594 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3598:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3598 0
 166 0128 20C042E2 		sub	ip, r2, #32
3594:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3594 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3595:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3595 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3596:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3596 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3597:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3597 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3598:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3598 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 58010000 		.word	.L9
 185 014c 58010000 		.word	.L9
 186 0150 A4010000 		.word	.L11
 187 0154 A4010000 		.word	.L11
 188              	.LVL15:
 189              	.L9:
3604:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 190              		.loc 1 3604 0
 191 0158 5230A0E3 		mov	r3, #82
 192 015c FEFFFFEB 		bl	SensorSetIrisControl
 193              	.LVL16:
3606:../uvc.c      **** 							break;
 194              		.loc 1 3606 0
 195 0160 7D1FA0E3 		mov	r1, #500
 196              	.LVL17:
 197              	.L13:
3621:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 198              		.loc 1 3621 0
 199 0164 0020A0E3 		mov	r2, #0
 200 0168 A0009FE5 		ldr	r0, .L22+4
 201 016c FEFFFFEB 		bl	_txe_timer_change
3622:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 202              		.loc 1 3622 0
 203 0170 98009FE5 		ldr	r0, .L22+4
 204 0174 FEFFFFEB 		bl	_txe_timer_activate
 205              	.LVL18:
3629:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 206              		.loc 1 3629 0
 207 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 208 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 209 0180 000051E1 		cmp	r1, r0
3638:../uvc.c      **** 						lcCmdDes->curNum ++;
 210              		.loc 1 3638 0
 211 0184 01008012 		addne	r0, r0, #1
 212 0188 0100C415 		strneb	r0, [r4, #1]
 213              		.loc 1 3639 0
 214 018c 3C808415 		strne	r8, [r4, #60]
3629:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 215              		.loc 1 3629 0
 216 0190 1000000A 		beq	.L21
 217              	.LVL19:
 218              	.L17:
3640:../uvc.c      **** 					}
3641:../uvc.c      **** 				}else{
3642:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3643:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3644:../uvc.c      **** 				}
3645:../uvc.c      **** 			}
3646:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 219              		.loc 1 3646 0
 220 0194 1C0095E5 		ldr	r0, [r5, #28]
 221 0198 FEFFFFEB 		bl	_txe_mutex_put
 222              	.LVL20:
3647:../uvc.c      **** /*
3648:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3649:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3650:../uvc.c      **** */
3651:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3652:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3653:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3654:../uvc.c      **** #endif
3655:../uvc.c      **** 
3656:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3657:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3658:../uvc.c      **** #if 0
3659:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3660:../uvc.c      **** 
3661:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3662:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3663:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3664:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3665:../uvc.c      **** 			    i = 0;
3666:../uvc.c      **** 				 switch(cmdCopyIdx)
3667:../uvc.c      **** 				 {
3668:../uvc.c      **** 					 case BrgtCtlID1:
3669:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3670:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3671:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3672:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3673:../uvc.c      **** 							 i++;
3674:../uvc.c      **** 						 }
3675:../uvc.c      **** 						 else{
3676:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3677:../uvc.c      **** 						 }
3678:../uvc.c      **** 
3679:../uvc.c      **** 						 CyU3PBusyWait(500);
3680:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3681:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3682:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3683:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3684:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3685:../uvc.c      **** 						 }
3686:../uvc.c      **** 						 else{
3687:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3688:../uvc.c      **** 						 }
3689:../uvc.c      **** 						 break;
3690:../uvc.c      **** 					 case HueCtlID5:
3691:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3692:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3693:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3694:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3695:../uvc.c      **** 						 }
3696:../uvc.c      **** 						 else{
3697:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3698:../uvc.c      **** 						 }
3699:../uvc.c      **** 						 break;
3700:../uvc.c      **** 					 case SaturCtlID6:
3701:../uvc.c      **** 					 case WBTLevCtlID10:
3702:../uvc.c      **** 					 default:
3703:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3704:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3705:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3706:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3707:../uvc.c      **** 						 }
3708:../uvc.c      **** 						 else{
3709:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3710:../uvc.c      **** 						 }
3711:../uvc.c      **** 						 break;
3712:../uvc.c      **** 				 }
3713:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3714:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3715:../uvc.c      **** 			}
3716:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3717:../uvc.c      **** #endif
3718:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3719:../uvc.c      **** 		/* Allow other ready threads to run. */
3720:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3721:../uvc.c      **** 			CyU3PThreadRelinquish ();
 223              		.loc 1 3721 0
 224 019c FEFFFFEB 		bl	_txe_thread_relinquish
3722:../uvc.c      **** 		}
 225              		.loc 1 3722 0
 226 01a0 BFFFFFEA 		b	.L18
 227              	.LVL21:
 228              	.L11:
3612:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
 229              		.loc 1 3612 0
 230 01a4 8230A0E3 		mov	r3, #130
 231 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 232              	.LVL22:
3614:../uvc.c      **** 							break;
 233              		.loc 1 3614 0
 234 01ac 4B1FA0E3 		mov	r1, #300
 235 01b0 EBFFFFEA 		b	.L13
 236              	.LVL23:
 237              	.L7:
3616:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 238              		.loc 1 3616 0
 239 01b4 FEFFFFEB 		bl	SensorSetControl
 240              	.LVL24:
 241 01b8 0A10A0E1 		mov	r1, sl
3617:../uvc.c      **** 							break;
 242              		.loc 1 3617 0
 243 01bc E8FFFFEA 		b	.L13
 244              	.LVL25:
 245              	.L6:
3642:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 246              		.loc 1 3642 0
 247 01c0 FA1FA0E3 		mov	r1, #1000
 248 01c4 44009FE5 		ldr	r0, .L22+4
 249 01c8 FEFFFFEB 		bl	_txe_timer_change
3643:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 250              		.loc 1 3643 0
 251 01cc 3C009FE5 		ldr	r0, .L22+4
 252 01d0 FEFFFFEB 		bl	_txe_timer_activate
 253 01d4 EEFFFFEA 		b	.L17
 254              	.LVL26:
 255              	.L21:
3631:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 256              		.loc 1 3631 0
 257 01d8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3630:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 258              		.loc 1 3630 0
 259 01dc 3C9084E5 		str	r9, [r4, #60]
3631:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 260              		.loc 1 3631 0
 261 01e0 23005CE3 		cmp	ip, #35
3632:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 262              		.loc 1 3632 0
 263 01e4 20C04C82 		subhi	ip, ip, #32
 264 01e8 8CC08C80 		addhi	ip, ip, ip, asl #1
3634:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 265              		.loc 1 3634 0
 266 01ec 8CC08C90 		addls	ip, ip, ip, asl #1
3632:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 267              		.loc 1 3632 0
 268 01f0 8CC18B80 		addhi	ip, fp, ip, asl #3
3634:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 269              		.loc 1 3634 0
 270 01f4 8CC18B90 		addls	ip, fp, ip, asl #3
3632:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 271              		.loc 1 3632 0
 272 01f8 1090CC85 		strhib	r9, [ip, #16]
3634:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3634 0
 274 01fc 9091CC95 		strlsb	r9, [ip, #400]
3636:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 275              		.loc 1 3636 0
 276 0200 344094E5 		ldr	r4, [r4, #52]
 277              	.LVL27:
 278 0204 104085E5 		str	r4, [r5, #16]
 279 0208 E1FFFFEA 		b	.L17
 280              	.L23:
 281              		.align	2
 282              	.L22:
 283 020c 00000000 		.word	I2CCmdCb
 284 0210 00000000 		.word	I2CCmdTimer
 285 0214 00000000 		.word	.LC0
 286 0218 00000000 		.word	cmdQu
 287 021c 14000000 		.word	.LC1
 288 0220 00000000 		.word	statQu
 289 0224 00000000 		.word	.LANCHOR1
 290 0228 00000000 		.word	.LANCHOR0
 291              		.cfi_endproc
 292              	.LFE25:
 294              		.align	2
 295              		.global	I2CCmdCb
 297              	I2CCmdCb:
 298              	.LFB17:
2186:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 299              		.loc 1 2186 0
 300              		.cfi_startproc
 301              		@ args = 0, pretend = 0, frame = 0
 302              		@ frame_needed = 0, uses_anonymous_args = 0
 303              		@ link register save eliminated.
 304              	.LVL28:
2188:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 305              		.loc 1 2188 0
 306 022c 08009FE5 		ldr	r0, .L25
 307              	.LVL29:
 308 0230 2010A0E3 		mov	r1, #32
 309 0234 0020A0E3 		mov	r2, #0
2189:../uvc.c      **** }
 310              		.loc 1 2189 0
2188:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 311              		.loc 1 2188 0
 312 0238 FEFFFFEA 		b	_txe_event_flags_set
 313              	.L26:
 314              		.align	2
 315              	.L25:
 316 023c 00000000 		.word	.LANCHOR0
 317              		.cfi_endproc
 318              	.LFE17:
 320              		.align	2
 321              		.global	CyFxUvcApplnDmaCallback
 323              	CyFxUvcApplnDmaCallback:
 324              	.LFB10:
1475:../uvc.c      **** {
 325              		.loc 1 1475 0
 326              		.cfi_startproc
 327              		@ args = 0, pretend = 0, frame = 0
 328              		@ frame_needed = 0, uses_anonymous_args = 0
 329              	.LVL30:
1479:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 330              		.loc 1 1479 0
 331 0240 080051E3 		cmp	r1, #8
1475:../uvc.c      **** {
 332              		.loc 1 1475 0
 333 0244 30402DE9 		stmfd	sp!, {r4, r5, lr}
 334              	.LCFI2:
 335              		.cfi_def_cfa_offset 12
 336 0248 0240A0E1 		mov	r4, r2
 337              		.cfi_offset 14, -4
 338              		.cfi_offset 5, -8
 339              		.cfi_offset 4, -12
 340 024c 0CD04DE2 		sub	sp, sp, #12
 341              	.LCFI3:
 342              		.cfi_def_cfa_offset 24
1479:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 343              		.loc 1 1479 0
 344 0250 0B00000A 		beq	.L32
1508:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 345              		.loc 1 1508 0
 346 0254 100051E3 		cmp	r1, #16
 347 0258 0700001A 		bne	.L27
1510:../uvc.c      ****         consCount++;
 348              		.loc 1 1510 0
 349 025c 04319FE5 		ldr	r3, .L34
1511:../uvc.c      ****         streamingStarted = CyTrue;
 350              		.loc 1 1511 0
 351 0260 0120A0E3 		mov	r2, #1
 352              	.LVL31:
1510:../uvc.c      ****         consCount++;
 353              		.loc 1 1510 0
 354 0264 B0C3D3E1 		ldrh	ip, [r3, #48]
1511:../uvc.c      ****         streamingStarted = CyTrue;
 355              		.loc 1 1511 0
 356 0268 342083E5 		str	r2, [r3, #52]
1510:../uvc.c      ****         consCount++;
 357              		.loc 1 1510 0
 358 026c 02008CE0 		add	r0, ip, r2
 359              	.LVL32:
 360 0270 0018A0E1 		mov	r1, r0, asl #16
 361              	.LVL33:
 362 0274 2128A0E1 		mov	r2, r1, lsr #16
 363 0278 B023C3E1 		strh	r2, [r3, #48]	@ movhi
 364              	.L27:
1513:../uvc.c      **** }
 365              		.loc 1 1513 0
 366 027c 0CD08DE2 		add	sp, sp, #12
 367 0280 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 368              	.LVL34:
 369              	.L32:
1481:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 370              		.loc 1 1481 0
 371 0284 B420D2E1 		ldrh	r2, [r2, #4]
 372 0288 DC309FE5 		ldr	r3, .L34+4
 373 028c 030052E1 		cmp	r2, r3
 374 0290 2900000A 		beq	.L33
1489:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 375              		.loc 1 1489 0
 376 0294 005094E5 		ldr	r5, [r4, #0]
 377              	.LVL35:
 378              	.LBB12:
 379              	.LBB13:
1224:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 380              		.loc 1 1224 0
 381 0298 D0109FE5 		ldr	r1, .L34+8
 382              	.LVL36:
 383 029c 0C0045E2 		sub	r0, r5, #12
 384              	.LVL37:
 385 02a0 0C20A0E3 		mov	r2, #12
 386 02a4 FEFFFFEB 		bl	CyU3PMemCopy
 387              	.LVL38:
1229:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 388              		.loc 1 1229 0
 389 02a8 0BC055E5 		ldrb	ip, [r5, #-11]	@ zero_extendqisi2
 390              	.LBE13:
 391              	.LBE12:
1490:../uvc.c      ****                 pb++;
 392              		.loc 1 1490 0
 393 02ac B4309FE5 		ldr	r3, .L34
 394              	.LBB15:
 395              	.LBB14:
1229:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 396              		.loc 1 1229 0
 397 02b0 02108CE3 		orr	r1, ip, #2
 398 02b4 0B1045E5 		strb	r1, [r5, #-11]
 399              	.LBE14:
 400              	.LBE15:
1490:../uvc.c      ****                 pb++;
 401              		.loc 1 1490 0
 402 02b8 BA02D3E1 		ldrh	r0, [r3, #42]
1491:../uvc.c      ****                 pbc = input->buffer_p.count;
 403              		.loc 1 1491 0
 404 02bc B410D4E1 		ldrh	r1, [r4, #4]
1490:../uvc.c      ****                 pb++;
 405              		.loc 1 1490 0
 406 02c0 012080E2 		add	r2, r0, #1
 407 02c4 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
1491:../uvc.c      ****                 pbc = input->buffer_p.count;
 408              		.loc 1 1491 0
 409 02c8 BC12C3E1 		strh	r1, [r3, #44]	@ movhi
 410              	.LVL39:
 411              	.L30:
1496:../uvc.c      ****             prodCount++;
 412              		.loc 1 1496 0
 413 02cc BEE2D3E1 		ldrh	lr, [r3, #46]
1497:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 414              		.loc 1 1497 0
 415 02d0 0C1081E2 		add	r1, r1, #12
1496:../uvc.c      ****             prodCount++;
 416              		.loc 1 1496 0
 417 02d4 01C08EE2 		add	ip, lr, #1
 418 02d8 0C08A0E1 		mov	r0, ip, asl #16
 419 02dc 20E8A0E1 		mov	lr, r0, lsr #16
1497:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 420              		.loc 1 1497 0
 421 02e0 0128A0E1 		mov	r2, r1, asl #16
 422 02e4 2218A0E1 		mov	r1, r2, lsr #16
 423 02e8 84009FE5 		ldr	r0, .L34+12
 424 02ec 0020A0E3 		mov	r2, #0
1496:../uvc.c      ****             prodCount++;
 425              		.loc 1 1496 0
 426 02f0 BEE2C3E1 		strh	lr, [r3, #46]	@ movhi
1497:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 427              		.loc 1 1497 0
 428 02f4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 429              	.LVL40:
1496:../uvc.c      ****             prodCount++;
 430              		.loc 1 1496 0
 431 02f8 68109FE5 		ldr	r1, .L34
1500:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 432              		.loc 1 1500 0
 433 02fc 002050E2 		subs	r2, r0, #0
 434 0300 DDFFFF0A 		beq	.L27
1502:../uvc.c      ****                 prodCount--;
 435              		.loc 1 1502 0
 436 0304 BEC2D1E1 		ldrh	ip, [r1, #46]
1503:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 437              		.loc 1 1503 0
 438 0308 B430D4E1 		ldrh	r3, [r4, #4]
1502:../uvc.c      ****                 prodCount--;
 439              		.loc 1 1502 0
 440 030c 01004CE2 		sub	r0, ip, #1
 441              	.LVL41:
 442 0310 00E8A0E1 		mov	lr, r0, asl #16
 443 0314 2EC8A0E1 		mov	ip, lr, lsr #16
 444 0318 BEC2C1E1 		strh	ip, [r1, #46]	@ movhi
1503:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 445              		.loc 1 1503 0
 446 031c BEE2D1E1 		ldrh	lr, [r1, #46]
 447 0320 B003D1E1 		ldrh	r0, [r1, #48]
 448 0324 4C109FE5 		ldr	r1, .L34+16
 449 0328 0EC060E0 		rsb	ip, r0, lr
 450 032c 0400A0E3 		mov	r0, #4
 451 0330 00C08DE5 		str	ip, [sp, #0]
 452 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 453              	.LVL42:
 454 0338 CFFFFFEA 		b	.L27
 455              	.LVL43:
 456              	.L33:
1483:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 457              		.loc 1 1483 0
 458 033c 00E094E5 		ldr	lr, [r4, #0]
 459              	.LBB16:
 460              	.LBB17:
1224:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 461              		.loc 1 1224 0
 462 0340 28109FE5 		ldr	r1, .L34+8
 463              	.LVL44:
 464 0344 0C004EE2 		sub	r0, lr, #12
 465              	.LVL45:
 466 0348 0C20A0E3 		mov	r2, #12
 467 034c FEFFFFEB 		bl	CyU3PMemCopy
 468              	.LVL46:
 469              	.LBE17:
 470              	.LBE16:
1484:../uvc.c      ****                 fb++;
 471              		.loc 1 1484 0
 472 0350 10309FE5 		ldr	r3, .L34
 473 0354 B410D4E1 		ldrh	r1, [r4, #4]
 474 0358 B8C2D3E1 		ldrh	ip, [r3, #40]
 475 035c 01008CE2 		add	r0, ip, #1
 476 0360 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 477 0364 D8FFFFEA 		b	.L30
 478              	.L35:
 479              		.align	2
 480              	.L34:
 481 0368 00000000 		.word	.LANCHOR0
 482 036c F03F0000 		.word	16368
 483 0370 80040000 		.word	.LANCHOR1+1152
 484 0374 00000000 		.word	glChHandleUVCStream
 485 0378 38000000 		.word	.LC2
 486              		.cfi_endproc
 487              	.LFE10:
 489              		.align	2
 491              	CyFxUVCApplnUSBEventCB:
 492              	.LFB8:
1278:../uvc.c      **** {
 493              		.loc 1 1278 0
 494              		.cfi_startproc
 495              		@ args = 0, pretend = 0, frame = 8
 496              		@ frame_needed = 0, uses_anonymous_args = 0
 497              	.LVL47:
1279:../uvc.c      ****     switch (evtype)
 498              		.loc 1 1279 0
 499 037c 020050E3 		cmp	r0, #2
1278:../uvc.c      **** {
 500              		.loc 1 1278 0
 501 0380 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 502              	.LCFI4:
 503              		.cfi_def_cfa_offset 16
 504 0384 0130A0E1 		mov	r3, r1
 505 0388 10D04DE2 		sub	sp, sp, #16
 506              	.LCFI5:
 507              		.cfi_def_cfa_offset 32
1278:../uvc.c      **** {
 508              		.loc 1 1278 0
 509 038c 0040A0E1 		mov	r4, r0
 510              		.cfi_offset 14, -4
 511              		.cfi_offset 6, -8
 512              		.cfi_offset 5, -12
 513              		.cfi_offset 4, -16
1279:../uvc.c      ****     switch (evtype)
 514              		.loc 1 1279 0
 515 0390 3600000A 		beq	.L39
 516 0394 040050E3 		cmp	r0, #4
 517 0398 1F00000A 		beq	.L40
 518 039c 010050E3 		cmp	r0, #1
 519 03a0 0100000A 		beq	.L42
 520              	.LVL48:
 521              	.L36:
1315:../uvc.c      **** }
 522              		.loc 1 1315 0
 523 03a4 10D08DE2 		add	sp, sp, #16
 524 03a8 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 525              	.LVL49:
 526              	.L42:
1300:../uvc.c      ****             gpif_initialized = 0;
 527              		.loc 1 1300 0
 528 03ac 28519FE5 		ldr	r5, .L43
1298:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 529              		.loc 1 1298 0
 530 03b0 0020A0E1 		mov	r2, r0
 531 03b4 24119FE5 		ldr	r1, .L43+4
 532              	.LVL50:
 533 03b8 0400A0E3 		mov	r0, #4
 534              	.LVL51:
 535 03bc FEFFFFEB 		bl	CyU3PDebugPrint
1299:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 536              		.loc 1 1299 0
 537 03c0 0400A0E1 		mov	r0, r4
 538 03c4 FEFFFFEB 		bl	CyU3PGpifDisable
1300:../uvc.c      ****             gpif_initialized = 0;
 539              		.loc 1 1300 0
 540 03c8 00C0A0E3 		mov	ip, #0
 541              	.LBB24:
 542              	.LBB25:
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 543              		.loc 1 1262 0
 544 03cc 0410A0E1 		mov	r1, r4
 545 03d0 0500A0E1 		mov	r0, r5
 546 03d4 0220A0E3 		mov	r2, #2
 547 03d8 0C308DE2 		add	r3, sp, #12
 548              	.LBE25:
 549              	.LBE24:
1300:../uvc.c      ****             gpif_initialized = 0;
 550              		.loc 1 1300 0
 551 03dc 38C085E5 		str	ip, [r5, #56]
1301:../uvc.c      ****             isUsbConnected = CyFalse;
 552              		.loc 1 1301 0
 553 03e0 3CC085E5 		str	ip, [r5, #60]
1302:../uvc.c      ****             streamingStarted = CyFalse;
 554              		.loc 1 1302 0
 555 03e4 34C085E5 		str	ip, [r5, #52]
 556              	.LBB27:
 557              	.LBB26:
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 558              		.loc 1 1262 0
 559 03e8 00C08DE5 		str	ip, [sp, #0]
 560 03ec FEFFFFEB 		bl	_txe_event_flags_get
 561 03f0 004050E2 		subs	r4, r0, #0
 562 03f4 EAFFFF1A 		bne	.L36
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 563              		.loc 1 1265 0
 564 03f8 0110E0E3 		mvn	r1, #1
 565 03fc 0220A0E3 		mov	r2, #2
 566 0400 0500A0E1 		mov	r0, r5
 567              	.L41:
 568 0404 FEFFFFEB 		bl	_txe_event_flags_set
1268:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 569              		.loc 1 1268 0
 570 0408 0500A0E1 		mov	r0, r5
 571 040c 0210A0E3 		mov	r1, #2
 572 0410 0420A0E1 		mov	r2, r4
 573 0414 FEFFFFEB 		bl	_txe_event_flags_set
 574 0418 E1FFFFEA 		b	.L36
 575              	.LVL52:
 576              	.L40:
 577              	.LBE26:
 578              	.LBE27:
1284:../uvc.c      ****             gpif_initialized = 0;
 579              		.loc 1 1284 0
 580 041c B8509FE5 		ldr	r5, .L43
1282:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 581              		.loc 1 1282 0
 582 0420 BC109FE5 		ldr	r1, .L43+8
 583              	.LVL53:
 584 0424 0020A0E1 		mov	r2, r0
 585 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 586              	.LVL54:
1283:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 587              		.loc 1 1283 0
 588 042c 0100A0E3 		mov	r0, #1
 589 0430 FEFFFFEB 		bl	CyU3PGpifDisable
1284:../uvc.c      ****             gpif_initialized = 0;
 590              		.loc 1 1284 0
 591 0434 00C0A0E3 		mov	ip, #0
 592              	.LBB28:
 593              	.LBB29:
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 594              		.loc 1 1262 0
 595 0438 0110A0E3 		mov	r1, #1
 596 043c 0220A0E3 		mov	r2, #2
 597 0440 0500A0E1 		mov	r0, r5
 598 0444 0C308DE2 		add	r3, sp, #12
 599              	.LBE29:
 600              	.LBE28:
1284:../uvc.c      ****             gpif_initialized = 0;
 601              		.loc 1 1284 0
 602 0448 38C085E5 		str	ip, [r5, #56]
1285:../uvc.c      ****             streamingStarted = CyFalse;
 603              		.loc 1 1285 0
 604 044c 34C085E5 		str	ip, [r5, #52]
 605              	.LBB31:
 606              	.LBB30:
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 607              		.loc 1 1262 0
 608 0450 00C08DE5 		str	ip, [sp, #0]
 609 0454 FEFFFFEB 		bl	_txe_event_flags_get
 610 0458 004050E2 		subs	r4, r0, #0
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 611              		.loc 1 1265 0
 612 045c 0500A001 		moveq	r0, r5
 613 0460 0110E003 		mvneq	r1, #1
 614 0464 0220A003 		moveq	r2, #2
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 615              		.loc 1 1262 0
 616 0468 CDFFFF1A 		bne	.L36
 617 046c E4FFFFEA 		b	.L41
 618              	.LVL55:
 619              	.L39:
 620              	.LBE30:
 621              	.LBE31:
1292:../uvc.c      ****             gpif_initialized = 0;
 622              		.loc 1 1292 0
 623 0470 64509FE5 		ldr	r5, .L43
1290:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 624              		.loc 1 1290 0
 625 0474 0020A0E1 		mov	r2, r0
 626 0478 68109FE5 		ldr	r1, .L43+12
 627              	.LVL56:
 628 047c 0400A0E3 		mov	r0, #4
 629              	.LVL57:
 630 0480 FEFFFFEB 		bl	CyU3PDebugPrint
1291:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 631              		.loc 1 1291 0
 632 0484 0100A0E3 		mov	r0, #1
 633 0488 FEFFFFEB 		bl	CyU3PGpifDisable
1292:../uvc.c      ****             gpif_initialized = 0;
 634              		.loc 1 1292 0
 635 048c 0060A0E3 		mov	r6, #0
 636              	.LBB32:
 637              	.LBB33:
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 638              		.loc 1 1262 0
 639 0490 0500A0E1 		mov	r0, r5
 640 0494 0110A0E3 		mov	r1, #1
 641 0498 0420A0E1 		mov	r2, r4
 642 049c 0C308DE2 		add	r3, sp, #12
 643              	.LBE33:
 644              	.LBE32:
1292:../uvc.c      ****             gpif_initialized = 0;
 645              		.loc 1 1292 0
 646 04a0 386085E5 		str	r6, [r5, #56]
1293:../uvc.c      ****             streamingStarted = CyFalse;
 647              		.loc 1 1293 0
 648 04a4 346085E5 		str	r6, [r5, #52]
 649              	.LBB35:
 650              	.LBB34:
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 651              		.loc 1 1262 0
 652 04a8 00608DE5 		str	r6, [sp, #0]
 653 04ac FEFFFFEB 		bl	_txe_event_flags_get
 654 04b0 006050E2 		subs	r6, r0, #0
 655 04b4 BAFFFF1A 		bne	.L36
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 656              		.loc 1 1265 0
 657 04b8 0420A0E1 		mov	r2, r4
 658 04bc 0500A0E1 		mov	r0, r5
 659 04c0 0110E0E3 		mvn	r1, #1
 660 04c4 FEFFFFEB 		bl	_txe_event_flags_set
1268:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 661              		.loc 1 1268 0
 662 04c8 0500A0E1 		mov	r0, r5
 663 04cc 0410A0E1 		mov	r1, r4
 664 04d0 0620A0E1 		mov	r2, r6
 665 04d4 FEFFFFEB 		bl	_txe_event_flags_set
 666 04d8 B1FFFFEA 		b	.L36
 667              	.L44:
 668              		.align	2
 669              	.L43:
 670 04dc 00000000 		.word	.LANCHOR0
 671 04e0 C4000000 		.word	.LC5
 672 04e4 80000000 		.word	.LC3
 673 04e8 A0000000 		.word	.LC4
 674              	.LBE34:
 675              	.LBE35:
 676              		.cfi_endproc
 677              	.LFE8:
 679              		.align	2
 681              	CyFxUVCApplnUSBSetupCB:
 682              	.LFB9:
1323:../uvc.c      **** {
 683              		.loc 1 1323 0
 684              		.cfi_startproc
 685              		@ args = 0, pretend = 0, frame = 8
 686              		@ frame_needed = 0, uses_anonymous_args = 0
 687              	.LVL58:
1328:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 688              		.loc 1 1328 0
 689 04ec C0329FE5 		ldr	r3, .L70
1323:../uvc.c      **** {
 690              		.loc 1 1323 0
 691 04f0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 692              	.LCFI6:
 693              		.cfi_def_cfa_offset 24
1329:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 694              		.loc 1 1329 0
 695 04f4 BCC29FE5 		ldr	ip, .L70+4
1328:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 696              		.loc 1 1328 0
 697 04f8 FF4000E2 		and	r4, r0, #255
 698              		.cfi_offset 14, -4
 699              		.cfi_offset 8, -8
 700              		.cfi_offset 7, -12
 701              		.cfi_offset 6, -16
 702              		.cfi_offset 5, -20
 703              		.cfi_offset 4, -24
1329:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 704              		.loc 1 1329 0
 705 04fc FF8C00E2 		and	r8, r0, #65280
1330:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 706              		.loc 1 1330 0
 707 0500 2078A0E1 		mov	r7, r0, lsr #16
1328:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 708              		.loc 1 1328 0
 709 0504 0040C3E5 		strb	r4, [r3, #0]
1330:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 710              		.loc 1 1330 0
 711 0508 AC229FE5 		ldr	r2, .L70+8
1331:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 712              		.loc 1 1331 0
 713 050c AC029FE5 		ldr	r0, .L70+12
 714              	.LVL59:
1332:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 715              		.loc 1 1332 0
 716 0510 AC329FE5 		ldr	r3, .L70+16
1331:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 717              		.loc 1 1331 0
 718 0514 0158A0E1 		mov	r5, r1, asl #16
1329:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 719              		.loc 1 1329 0
 720 0518 2884A0E1 		mov	r8, r8, lsr #8
1331:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 721              		.loc 1 1331 0
 722 051c 2558A0E1 		mov	r5, r5, lsr #16
1332:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 723              		.loc 1 1332 0
 724 0520 2118A0E1 		mov	r1, r1, lsr #16
 725              	.LVL60:
1335:../uvc.c      ****     switch (bmReqType)
 726              		.loc 1 1335 0
 727 0524 020054E3 		cmp	r4, #2
1323:../uvc.c      **** {
 728              		.loc 1 1323 0
 729 0528 10D04DE2 		sub	sp, sp, #16
 730              	.LCFI7:
 731              		.cfi_def_cfa_offset 40
1329:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 732              		.loc 1 1329 0
 733 052c 0080CCE5 		strb	r8, [ip, #0]
1330:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 734              		.loc 1 1330 0
 735 0530 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1331:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 736              		.loc 1 1331 0
 737 0534 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1332:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 738              		.loc 1 1332 0
 739 0538 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1335:../uvc.c      ****     switch (bmReqType)
 740              		.loc 1 1335 0
 741 053c 4F00000A 		beq	.L48
 742 0540 0600009A 		bls	.L66
 743 0544 210054E3 		cmp	r4, #33
 744 0548 3A00000A 		beq	.L49
 745 054c A10054E3 		cmp	r4, #161
 746 0550 3800000A 		beq	.L49
 747              	.L63:
1324:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 748              		.loc 1 1324 0
 749 0554 0000A0E3 		mov	r0, #0
 750              	.LVL61:
 751              	.L46:
1462:../uvc.c      **** }
 752              		.loc 1 1462 0
 753 0558 10D08DE2 		add	sp, sp, #16
 754 055c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 755              	.LVL62:
 756              	.L66:
1335:../uvc.c      ****     switch (bmReqType)
 757              		.loc 1 1335 0
 758 0560 010054E3 		cmp	r4, #1
 759 0564 FAFFFF1A 		bne	.L63
1375:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 760              		.loc 1 1375 0
 761 0568 0B0058E3 		cmp	r8, #11
 762 056c F8FFFF1A 		bne	.L63
1379:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 763              		.loc 1 1379 0
 764 0570 010055E3 		cmp	r5, #1
 765 0574 F6FFFF1A 		bne	.L63
1379:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 766              		.loc 1 1379 0 is_stmt 0 discriminator 1
 767 0578 000057E3 		cmp	r7, #0
 768 057c F4FFFF1A 		bne	.L63
1384:../uvc.c      ****                     gpif_initialized = 0;
 769              		.loc 1 1384 0 is_stmt 1
 770 0580 40429FE5 		ldr	r4, .L70+20
1382:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 771              		.loc 1 1382 0
 772 0584 40129FE5 		ldr	r1, .L70+24
 773 0588 0400A0E3 		mov	r0, #4
 774 058c FEFFFFEB 		bl	CyU3PDebugPrint
1383:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 775              		.loc 1 1383 0
 776 0590 0500A0E1 		mov	r0, r5
 777 0594 FEFFFFEB 		bl	CyU3PGpifDisable
1387:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 778              		.loc 1 1387 0
 779 0598 0510A0E1 		mov	r1, r5
 780 059c 8300A0E3 		mov	r0, #131
1384:../uvc.c      ****                     gpif_initialized = 0;
 781              		.loc 1 1384 0
 782 05a0 387084E5 		str	r7, [r4, #56]
1385:../uvc.c      ****                     streamingStarted = CyFalse;
 783              		.loc 1 1385 0
 784 05a4 347084E5 		str	r7, [r4, #52]
1387:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 785              		.loc 1 1387 0
 786 05a8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1388:../uvc.c      ****                     CyU3PBusyWait (100);
 787              		.loc 1 1388 0
 788 05ac 6400A0E3 		mov	r0, #100
 789 05b0 FEFFFFEB 		bl	CyU3PBusyWait
1391:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 790              		.loc 1 1391 0
 791 05b4 14029FE5 		ldr	r0, .L70+28
 792 05b8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1392:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 793              		.loc 1 1392 0
 794 05bc 8300A0E3 		mov	r0, #131
 795 05c0 FEFFFFEB 		bl	CyU3PUsbFlushEp
1393:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 796              		.loc 1 1393 0
 797 05c4 0710A0E1 		mov	r1, r7
 798 05c8 8300A0E3 		mov	r0, #131
 799 05cc FEFFFFEB 		bl	CyU3PUsbSetEpNak
1394:../uvc.c      ****                     CyU3PBusyWait (100);
 800              		.loc 1 1394 0
 801 05d0 6400A0E3 		mov	r0, #100
 802 05d4 FEFFFFEB 		bl	CyU3PBusyWait
1397:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 803              		.loc 1 1397 0
 804 05d8 0710A0E1 		mov	r1, r7
 805 05dc 0520A0E1 		mov	r2, r5
 806 05e0 8300A0E3 		mov	r0, #131
 807 05e4 FEFFFFEB 		bl	CyU3PUsbStall
 808              	.LVL63:
1400:../uvc.c      ****                     CyU3PUsbAckSetup ();
 809              		.loc 1 1400 0
 810 05e8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1402:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 811              		.loc 1 1402 0
 812 05ec 405084E5 		str	r5, [r4, #64]
 813              	.LBB40:
 814              	.LBB41:
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 815              		.loc 1 1262 0
 816 05f0 0400A0E1 		mov	r0, r4
 817 05f4 0510A0E1 		mov	r1, r5
 818 05f8 0220A0E3 		mov	r2, #2
 819 05fc 0C308DE2 		add	r3, sp, #12
 820 0600 00708DE5 		str	r7, [sp, #0]
 821 0604 FEFFFFEB 		bl	_txe_event_flags_get
 822 0608 006050E2 		subs	r6, r0, #0
 823 060c 2E00001A 		bne	.L61
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 824              		.loc 1 1265 0
 825 0610 0110E0E3 		mvn	r1, #1
 826 0614 0220A0E3 		mov	r2, #2
 827 0618 0400A0E1 		mov	r0, r4
 828 061c FEFFFFEB 		bl	_txe_event_flags_set
1268:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 829              		.loc 1 1268 0
 830 0620 0400A0E1 		mov	r0, r4
 831 0624 0210A0E3 		mov	r1, #2
 832 0628 0620A0E1 		mov	r2, r6
 833 062c FEFFFFEB 		bl	_txe_event_flags_set
1398:../uvc.c      ****                     uvcHandleReq = CyTrue;
 834              		.loc 1 1398 0
 835 0630 0500A0E1 		mov	r0, r5
 836 0634 C7FFFFEA 		b	.L46
 837              	.LVL64:
 838              	.L49:
 839              	.LBE41:
 840              	.LBE40:
1340:../uvc.c      ****             switch (wIndex & 0xFF)
 841              		.loc 1 1340 0
 842 0638 FF5015E2 		ands	r5, r5, #255
 843 063c 1A00001A 		bne	.L67
 844              	.LVL65:
1345:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 845              		.loc 1 1345 0
 846 0640 0520A0E1 		mov	r2, r5
 847 0644 7C019FE5 		ldr	r0, .L70+20
 848 0648 0410A0E3 		mov	r1, #4
 849 064c FEFFFFEB 		bl	_txe_event_flags_set
 850              	.LVL66:
1347:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 851              		.loc 1 1347 0
 852 0650 002050E2 		subs	r2, r0, #0
1344:../uvc.c      ****                         uvcHandleReq = CyTrue;
 853              		.loc 1 1344 0
 854 0654 0100A003 		moveq	r0, #1
 855              	.LVL67:
1347:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 856              		.loc 1 1347 0
 857 0658 BEFFFF0A 		beq	.L46
1349:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 858              		.loc 1 1349 0
 859 065c 70119FE5 		ldr	r1, .L70+32
 860 0660 0400A0E3 		mov	r0, #4
 861 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 862              	.LVL68:
1350:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 863              		.loc 1 1350 0
 864 0668 0500A0E1 		mov	r0, r5
 865 066c 0110A0E3 		mov	r1, #1
 866 0670 0520A0E1 		mov	r2, r5
 867 0674 FEFFFFEB 		bl	CyU3PUsbStall
1344:../uvc.c      ****                         uvcHandleReq = CyTrue;
 868              		.loc 1 1344 0
 869 0678 0100A0E3 		mov	r0, #1
 870 067c B5FFFFEA 		b	.L46
 871              	.LVL69:
 872              	.L48:
1410:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 873              		.loc 1 1410 0
 874 0680 010058E3 		cmp	r8, #1
 875 0684 B2FFFF1A 		bne	.L63
1412:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 876              		.loc 1 1412 0
 877 0688 830055E3 		cmp	r5, #131
 878 068c B0FFFF1A 		bne	.L63
1418:../uvc.c      ****                     if (streamingStarted == CyTrue)
 879              		.loc 1 1418 0
 880 0690 30719FE5 		ldr	r7, .L70+20
 881 0694 346097E5 		ldr	r6, [r7, #52]
 882 0698 010056E3 		cmp	r6, #1
 883 069c 1500000A 		beq	.L68
 884              	.LVL70:
1450:../uvc.c      ****                         CyU3PUsbAckSetup ();
 885              		.loc 1 1450 0
 886 06a0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1449:../uvc.c      ****                         uvcHandleReq = CyTrue;
 887              		.loc 1 1449 0
 888 06a4 0800A0E1 		mov	r0, r8
 889 06a8 AAFFFFEA 		b	.L46
 890              	.LVL71:
 891              	.L67:
1340:../uvc.c      ****             switch (wIndex & 0xFF)
 892              		.loc 1 1340 0
 893 06ac 010055E3 		cmp	r5, #1
 894 06b0 A7FFFF1A 		bne	.L63
 895              	.LVL72:
1358:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 896              		.loc 1 1358 0
 897 06b4 0020A0E3 		mov	r2, #0
 898 06b8 08019FE5 		ldr	r0, .L70+20
 899 06bc 0810A0E3 		mov	r1, #8
 900 06c0 FEFFFFEB 		bl	_txe_event_flags_set
 901              	.LVL73:
1360:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 902              		.loc 1 1360 0
 903 06c4 002050E2 		subs	r2, r0, #0
 904 06c8 0100001A 		bne	.L69
 905              	.LVL74:
 906              	.L61:
 907              	.LBB43:
 908              	.LBB42:
1398:../uvc.c      ****                     uvcHandleReq = CyTrue;
 909              		.loc 1 1398 0
 910 06cc 0500A0E1 		mov	r0, r5
 911 06d0 A0FFFFEA 		b	.L46
 912              	.LVL75:
 913              	.L69:
 914              	.LBE42:
 915              	.LBE43:
1363:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 916              		.loc 1 1363 0
 917 06d4 FC109FE5 		ldr	r1, .L70+36
 918 06d8 0400A0E3 		mov	r0, #4
 919              	.LVL76:
 920 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 921              	.LVL77:
1364:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 922              		.loc 1 1364 0
 923 06e0 0000A0E3 		mov	r0, #0
 924 06e4 0510A0E1 		mov	r1, r5
 925 06e8 0020A0E1 		mov	r2, r0
 926 06ec FEFFFFEB 		bl	CyU3PUsbStall
1357:../uvc.c      ****                         uvcHandleReq = CyTrue;
 927              		.loc 1 1357 0
 928 06f0 0500A0E1 		mov	r0, r5
 929 06f4 97FFFFEA 		b	.L46
 930              	.LVL78:
 931              	.L68:
1420:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 932              		.loc 1 1420 0
 933 06f8 DC109FE5 		ldr	r1, .L70+40
 934 06fc 0400A0E3 		mov	r0, #4
 935 0700 FEFFFFEB 		bl	CyU3PDebugPrint
1424:../uvc.c      ****                         gpif_initialized = 0;
 936              		.loc 1 1424 0
 937 0704 0080A0E3 		mov	r8, #0
1423:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 938              		.loc 1 1423 0
 939 0708 0600A0E1 		mov	r0, r6
 940 070c FEFFFFEB 		bl	CyU3PGpifDisable
1428:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 941              		.loc 1 1428 0
 942 0710 0610A0E1 		mov	r1, r6
 943 0714 0500A0E1 		mov	r0, r5
1424:../uvc.c      ****                         gpif_initialized = 0;
 944              		.loc 1 1424 0
 945 0718 388087E5 		str	r8, [r7, #56]
1425:../uvc.c      ****                         streamingStarted = CyFalse;
 946              		.loc 1 1425 0
 947 071c 348087E5 		str	r8, [r7, #52]
1428:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 948              		.loc 1 1428 0
 949 0720 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1429:../uvc.c      ****                         CyU3PBusyWait (100);
 950              		.loc 1 1429 0
 951 0724 6400A0E3 		mov	r0, #100
 952 0728 FEFFFFEB 		bl	CyU3PBusyWait
1432:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 953              		.loc 1 1432 0
 954 072c 9C009FE5 		ldr	r0, .L70+28
 955 0730 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1433:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 956              		.loc 1 1433 0
 957 0734 0500A0E1 		mov	r0, r5
 958 0738 FEFFFFEB 		bl	CyU3PUsbFlushEp
1434:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 959              		.loc 1 1434 0
 960 073c 0810A0E1 		mov	r1, r8
 961 0740 0500A0E1 		mov	r0, r5
 962 0744 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1435:../uvc.c      ****                         CyU3PBusyWait (100);
 963              		.loc 1 1435 0
 964 0748 6400A0E3 		mov	r0, #100
 965 074c FEFFFFEB 		bl	CyU3PBusyWait
1438:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 966              		.loc 1 1438 0
 967 0750 0810A0E1 		mov	r1, r8
 968 0754 0620A0E1 		mov	r2, r6
 969 0758 0500A0E1 		mov	r0, r5
 970 075c FEFFFFEB 		bl	CyU3PUsbStall
 971              	.LVL79:
1442:../uvc.c      ****                         CyU3PUsbAckSetup ();
 972              		.loc 1 1442 0
 973 0760 FEFFFFEB 		bl	CyU3PUsbAckSetup
1444:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 974              		.loc 1 1444 0
 975 0764 406087E5 		str	r6, [r7, #64]
 976              	.LBB44:
 977              	.LBB45:
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 978              		.loc 1 1262 0
 979 0768 0700A0E1 		mov	r0, r7
 980 076c 0610A0E1 		mov	r1, r6
 981 0770 0420A0E1 		mov	r2, r4
 982 0774 0C308DE2 		add	r3, sp, #12
 983 0778 00808DE5 		str	r8, [sp, #0]
 984 077c FEFFFFEB 		bl	_txe_event_flags_get
 985 0780 005050E2 		subs	r5, r0, #0
1440:../uvc.c      ****                         uvcHandleReq = CyTrue;
 986              		.loc 1 1440 0
 987 0784 0600A011 		movne	r0, r6
1262:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 988              		.loc 1 1262 0
 989 0788 72FFFF1A 		bne	.L46
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 990              		.loc 1 1265 0
 991 078c 0110E0E3 		mvn	r1, #1
 992 0790 0420A0E1 		mov	r2, r4
 993 0794 0700A0E1 		mov	r0, r7
 994 0798 FEFFFFEB 		bl	_txe_event_flags_set
1268:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 995              		.loc 1 1268 0
 996 079c 0700A0E1 		mov	r0, r7
 997 07a0 0410A0E1 		mov	r1, r4
 998 07a4 0520A0E1 		mov	r2, r5
 999 07a8 FEFFFFEB 		bl	_txe_event_flags_set
1440:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1000              		.loc 1 1440 0
 1001 07ac 0600A0E1 		mov	r0, r6
 1002 07b0 68FFFFEA 		b	.L46
 1003              	.L71:
 1004              		.align	2
 1005              	.L70:
 1006 07b4 00000000 		.word	bmReqType
 1007 07b8 00000000 		.word	bRequest
 1008 07bc 00000000 		.word	wValue
 1009 07c0 00000000 		.word	wIndex
 1010 07c4 00000000 		.word	wLength
 1011 07c8 00000000 		.word	.LANCHOR0
 1012 07cc 50010000 		.word	.LC8
 1013 07d0 00000000 		.word	glChHandleUVCStream
 1014 07d4 E4000000 		.word	.LC6
 1015 07d8 1C010000 		.word	.LC7
 1016 07dc 68010000 		.word	.LC9
 1017              	.LBE45:
 1018              	.LBE44:
 1019              		.cfi_endproc
 1020              	.LFE9:
 1022              		.align	2
 1023              		.global	CyFxGpifCB
 1025              	CyFxGpifCB:
 1026              	.LFB12:
1633:../uvc.c      **** {
 1027              		.loc 1 1633 0
 1028              		.cfi_startproc
 1029              		@ args = 0, pretend = 0, frame = 0
 1030              		@ frame_needed = 0, uses_anonymous_args = 0
 1031              	.LVL80:
1634:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1032              		.loc 1 1634 0
 1033 07e0 010050E3 		cmp	r0, #1
1633:../uvc.c      **** {
 1034              		.loc 1 1633 0
 1035 07e4 10402DE9 		stmfd	sp!, {r4, lr}
 1036              	.LCFI8:
 1037              		.cfi_def_cfa_offset 8
1633:../uvc.c      **** {
 1038              		.loc 1 1633 0
 1039 07e8 0120A0E1 		mov	r2, r1
1634:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1040              		.loc 1 1634 0
 1041 07ec 1080BD18 		ldmnefd	sp!, {r4, pc}
 1042              		.cfi_offset 14, -4
 1043              		.cfi_offset 4, -8
1636:../uvc.c      ****         hitFV = CyTrue;
 1044              		.loc 1 1636 0
 1045 07f0 D0109FE5 		ldr	r1, .L88
 1046              	.LVL81:
 1047              	.LBB50:
 1048              	.LBB52:
1533:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1049              		.loc 1 1533 0
 1050 07f4 4830D1E5 		ldrb	r3, [r1, #72]	@ zero_extendqisi2
 1051              	.LBE52:
 1052              	.LBE50:
1636:../uvc.c      ****         hitFV = CyTrue;
 1053              		.loc 1 1636 0
 1054 07f8 440081E5 		str	r0, [r1, #68]
 1055              	.LVL82:
 1056              	.LBB56:
 1057              	.LBB51:
1533:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1058              		.loc 1 1533 0
 1059 07fc 030053E3 		cmp	r3, #3
 1060 0800 2800000A 		beq	.L87
1557:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1061              		.loc 1 1557 0
 1062 0804 020053E3 		cmp	r3, #2
 1063 0808 1080BD18 		ldmnefd	sp!, {r4, pc}
1559:../uvc.c      ****         switch (stateId)
 1064              		.loc 1 1559 0
 1065 080c 080042E2 		sub	r0, r2, #8
 1066              	.LVL83:
 1067 0810 0A0050E3 		cmp	r0, #10
 1068 0814 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1069 0818 1B0000EA 		b	.L80
 1070              	.L82:
 1071 081c 4C080000 		.word	.L76
 1072 0820 8C080000 		.word	.L80
 1073 0824 8C080000 		.word	.L80
 1074 0828 48080000 		.word	.L72
 1075 082c 8C080000 		.word	.L80
 1076 0830 8C080000 		.word	.L80
 1077 0834 8C080000 		.word	.L80
 1078 0838 84080000 		.word	.L86
 1079 083c 8C080000 		.word	.L80
 1080 0840 8C080000 		.word	.L80
 1081 0844 48080000 		.word	.L72
 1082              	.LVL84:
 1083              	.L72:
 1084 0848 1080BDE8 		ldmfd	sp!, {r4, pc}
 1085              	.LVL85:
 1086              	.L76:
1543:../uvc.c      ****                 socket = 0;
 1087              		.loc 1 1543 0
 1088 084c 0010A0E3 		mov	r1, #0
 1089              	.L77:
 1090              	.LVL86:
1616:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1091              		.loc 1 1616 0
 1092 0850 74009FE5 		ldr	r0, .L88+4
 1093 0854 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1094              	.LVL87:
1617:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1095              		.loc 1 1617 0
 1096 0858 002050E2 		subs	r2, r0, #0
 1097 085c F9FFFF0A 		beq	.L72
1619:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1098              		.loc 1 1619 0
 1099 0860 0400A0E3 		mov	r0, #4
 1100              	.LVL88:
 1101 0864 64109FE5 		ldr	r1, .L88+8
 1102 0868 FEFFFFEB 		bl	CyU3PDebugPrint
 1103              	.LVL89:
 1104              	.L83:
 1105              	.LBB53:
 1106              	.LBB54:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1107              		.loc 1 1249 0
 1108 086c 60109FE5 		ldr	r1, .L88+12
 1109 0870 0400A0E3 		mov	r0, #4
 1110 0874 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 1111              		.loc 1 1250 0
 1112 0878 FA0FA0E3 		mov	r0, #1000
 1113 087c FEFFFFEB 		bl	_tx_thread_sleep
 1114 0880 F9FFFFEA 		b	.L83
 1115              	.LVL90:
 1116              	.L86:
 1117              	.LBE54:
 1118              	.LBE53:
1600:../uvc.c      ****                 socket = 1;
 1119              		.loc 1 1600 0
 1120 0884 0110A0E3 		mov	r1, #1
 1121 0888 F0FFFFEA 		b	.L77
 1122              	.L80:
1605:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1123              		.loc 1 1605 0
 1124 088c 44109FE5 		ldr	r1, .L88+16
 1125 0890 0100A0E3 		mov	r0, #1
 1126 0894 FEFFFFEB 		bl	CyU3PDebugPrint
 1127              	.LVL91:
 1128              	.LBE51:
 1129              	.LBE56:
1638:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1130              		.loc 1 1638 0
 1131 0898 3C109FE5 		ldr	r1, .L88+20
 1132 089c 0400A0E3 		mov	r0, #4
1640:../uvc.c      **** }
 1133              		.loc 1 1640 0
 1134 08a0 1040BDE8 		ldmfd	sp!, {r4, lr}
1638:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1135              		.loc 1 1638 0
 1136 08a4 FEFFFFEA 		b	CyU3PDebugPrint
 1137              	.LVL92:
 1138              	.L87:
 1139              	.LBB57:
 1140              	.LBB55:
1535:../uvc.c      ****         switch (stateId)
 1141              		.loc 1 1535 0
 1142 08a8 0B3042E2 		sub	r3, r2, #11
 1143 08ac 030053E3 		cmp	r3, #3
 1144 08b0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1145 08b4 F4FFFFEA 		b	.L80
 1146              	.L78:
 1147 08b8 4C080000 		.word	.L76
 1148 08bc 84080000 		.word	.L86
 1149 08c0 48080000 		.word	.L72
 1150 08c4 48080000 		.word	.L72
 1151              	.L89:
 1152              		.align	2
 1153              	.L88:
 1154 08c8 00000000 		.word	.LANCHOR0
 1155 08cc 00000000 		.word	glChHandleUVCStream
 1156 08d0 A4010000 		.word	.LC11
 1157 08d4 D4010000 		.word	.LC12
 1158 08d8 8C010000 		.word	.LC10
 1159 08dc E8010000 		.word	.LC13
 1160              	.LBE55:
 1161              	.LBE57:
 1162              		.cfi_endproc
 1163              	.LFE12:
 1165              		.align	2
 1166              		.global	I2CCmdHandler
 1168              	I2CCmdHandler:
 1169              	.LFB0:
 326:../uvc.c      **** void I2CCmdHandler(){
 1170              		.loc 1 326 0
 1171              		.cfi_startproc
 1172              		@ args = 0, pretend = 0, frame = 8
 1173              		@ frame_needed = 0, uses_anonymous_args = 0
 1174 08e0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1175              	.LCFI9:
 1176              		.cfi_def_cfa_offset 36
 329:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1177              		.loc 1 329 0
 1178 08e4 08419FE5 		ldr	r4, .L96
 1179              		.cfi_offset 14, -4
 1180              		.cfi_offset 11, -8
 1181              		.cfi_offset 10, -12
 1182              		.cfi_offset 9, -16
 1183              		.cfi_offset 8, -20
 1184              		.cfi_offset 7, -24
 1185              		.cfi_offset 6, -28
 1186              		.cfi_offset 5, -32
 1187              		.cfi_offset 4, -36
 326:../uvc.c      **** void I2CCmdHandler(){
 1188              		.loc 1 326 0
 1189 08e8 34D04DE2 		sub	sp, sp, #52
 1190              	.LCFI10:
 1191              		.cfi_def_cfa_offset 88
 329:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1192              		.loc 1 329 0
 1193 08ec 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1194              	.LVL93:
 334:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1195              		.loc 1 334 0
 1196 08f0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 331:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1197              		.loc 1 331 0
 1198 08f4 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1199              	.LVL94:
 334:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1200              		.loc 1 334 0
 1201 08f8 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1202 08fc 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1203 0900 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1204 0904 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1205 0908 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1206 090c 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1207 0910 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1208 0914 1C208DE5 		str	r2, [sp, #28]
 1209 0918 0400A0E3 		mov	r0, #4
 1210 091c 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 1211 0920 D0109FE5 		ldr	r1, .L96+4
 1212 0924 0520A0E1 		mov	r2, r5
 1213 0928 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1214 092c 08808DE5 		str	r8, [sp, #8]
 1215 0930 0CA08DE5 		str	sl, [sp, #12]
 1216 0934 10908DE5 		str	r9, [sp, #16]
 1217 0938 14B08DE5 		str	fp, [sp, #20]
 1218 093c 18608DE5 		str	r6, [sp, #24]
 1219 0940 20C08DE5 		str	ip, [sp, #32]
 1220 0944 FEFFFFEB 		bl	CyU3PDebugPrint
 1221              	.LVL95:
 338:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1222              		.loc 1 338 0
 1223 0948 000055E3 		cmp	r5, #0
 1224 094c 0300000A 		beq	.L94
 363:../uvc.c      **** 	}else if(CmdType == 1){
 1225              		.loc 1 363 0
 1226 0950 010055E3 		cmp	r5, #1
 1227 0954 1600000A 		beq	.L95
 1228              	.LVL96:
 1229              	.L90:
 378:../uvc.c      **** }
 1230              		.loc 1 378 0
 1231 0958 34D08DE2 		add	sp, sp, #52
 1232 095c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1233              	.LVL97:
 1234              	.L94:
 354:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1235              		.loc 1 354 0
 1236 0960 54C0D4E5 		ldrb	ip, [r4, #84]	@ zero_extendqisi2
 1237 0964 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1238 0968 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1239 096c 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 340:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1240              		.loc 1 340 0
 1241 0970 0FE0A0E3 		mov	lr, #15
 354:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1242              		.loc 1 354 0
 1243 0974 00C08DE5 		str	ip, [sp, #0]
 1244 0978 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1245 097c 2CC08DE2 		add	ip, sp, #44
 1246 0980 010080E3 		orr	r0, r0, #1
 1247 0984 011081E3 		orr	r1, r1, #1
 340:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1248              		.loc 1 340 0
 1249 0988 57E0C4E5 		strb	lr, [r4, #87]
 354:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1250              		.loc 1 354 0
 1251 098c 04C08DE5 		str	ip, [sp, #4]
 1252 0990 FEFFFFEB 		bl	SensorRead2B
 355:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1253              		.loc 1 355 0
 1254 0994 2C00DDE5 		ldrb	r0, [sp, #44]	@ zero_extendqisi2
 356:../uvc.c      **** 			if(CmdDataLen == 2){
 1255              		.loc 1 356 0
 1256 0998 020056E3 		cmp	r6, #2
 355:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1257              		.loc 1 355 0
 1258 099c 5500C4E5 		strb	r0, [r4, #85]
 357:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1259              		.loc 1 357 0
 1260 09a0 2D00DD05 		ldreqb	r0, [sp, #45]	@ zero_extendqisi2
 359:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1261              		.loc 1 359 0
 1262 09a4 0030E0E3 		mvn	r3, #0
 357:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1263              		.loc 1 357 0
 1264 09a8 5600C405 		streqb	r0, [r4, #86]
 359:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1265              		.loc 1 359 0
 1266 09ac 5730C4E5 		strb	r3, [r4, #87]
 1267 09b0 E8FFFFEA 		b	.L90
 1268              	.L95:
 372:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1269              		.loc 1 372 0
 1270 09b4 54C0D4E5 		ldrb	ip, [r4, #84]	@ zero_extendqisi2
 1271 09b8 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1272 09bc 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 365:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1273              		.loc 1 365 0
 1274 09c0 5550D4E5 		ldrb	r5, [r4, #85]	@ zero_extendqisi2
 1275              	.LVL98:
 366:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1276              		.loc 1 366 0
 1277 09c4 56E0D4E5 		ldrb	lr, [r4, #86]	@ zero_extendqisi2
 372:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1278              		.loc 1 372 0
 1279 09c8 00C08DE5 		str	ip, [sp, #0]
 1280 09cc 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1281 09d0 2CC08DE2 		add	ip, sp, #44
 1282 09d4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1283 09d8 FE1001E2 		and	r1, r1, #254
 1284 09dc FE0000E2 		and	r0, r0, #254
 365:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1285              		.loc 1 365 0
 1286 09e0 2C50CDE5 		strb	r5, [sp, #44]
 366:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1287              		.loc 1 366 0
 1288 09e4 2DE0CDE5 		strb	lr, [sp, #45]
 372:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1289              		.loc 1 372 0
 1290 09e8 04C08DE5 		str	ip, [sp, #4]
 1291 09ec FEFFFFEB 		bl	SensorWrite2B
 1292 09f0 D8FFFFEA 		b	.L90
 1293              	.L97:
 1294              		.align	2
 1295              	.L96:
 1296 09f4 00000000 		.word	.LANCHOR0
 1297 09f8 FC010000 		.word	.LC14
 1298              		.cfi_endproc
 1299              	.LFE0:
 1301              		.align	2
 1302              		.global	setIrisauto
 1304              	setIrisauto:
 1305              	.LFB1:
 384:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1306              		.loc 1 384 0
 1307              		.cfi_startproc
 1308              		@ args = 0, pretend = 0, frame = 0
 1309              		@ frame_needed = 0, uses_anonymous_args = 0
 1310              	.LVL99:
 1311 09fc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1312              	.LCFI11:
 1313              		.cfi_def_cfa_offset 16
 1314 0a00 0160A0E1 		mov	r6, r1
 1315              		.cfi_offset 14, -4
 1316              		.cfi_offset 6, -8
 1317              		.cfi_offset 5, -12
 1318              		.cfi_offset 4, -16
 1319 0a04 08D04DE2 		sub	sp, sp, #8
 1320              	.LCFI12:
 1321              		.cfi_def_cfa_offset 24
 384:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1322              		.loc 1 384 0
 1323 0a08 0040A0E1 		mov	r4, r0
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1324              		.loc 1 388 0
 1325 0a0c 0050A0E3 		mov	r5, #0
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1326              		.loc 1 387 0
 1327 0a10 0010E0E3 		mvn	r1, #0
 1328              	.LVL100:
 1329 0a14 1C0090E5 		ldr	r0, [r0, #28]
 1330              	.LVL101:
 1331 0a18 FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1332              		.loc 1 388 0
 1333 0a1c 060065E0 		rsb	r0, r5, r6
 1334 0a20 00C070E2 		rsbs	ip, r0, #0
 1335 0a24 00C0ACE0 		adc	ip, ip, r0
 1336 0a28 2010A0E3 		mov	r1, #32
 1337 0a2c 2720A0E3 		mov	r2, #39
 1338 0a30 3030A0E3 		mov	r3, #48
 1339 0a34 0400A0E1 		mov	r0, r4
 1340 0a38 00C08DE5 		str	ip, [sp, #0]
 1341 0a3c 04508DE5 		str	r5, [sp, #4]
 1342 0a40 FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1343              		.loc 1 389 0
 1344 0a44 050056E1 		cmp	r6, r5
 1345 0a48 0260A003 		moveq	r6, #2
 1346 0a4c 0160A013 		movne	r6, #1
 1347 0a50 0400A0E1 		mov	r0, r4
 1348 0a54 2110A0E3 		mov	r1, #33
 1349 0a58 2520A0E3 		mov	r2, #37
 1350 0a5c 3030A0E3 		mov	r3, #48
 1351 0a60 00608DE5 		str	r6, [sp, #0]
 1352 0a64 04508DE5 		str	r5, [sp, #4]
 1353 0a68 FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1354              		.loc 1 390 0
 1355 0a6c 1C0094E5 		ldr	r0, [r4, #28]
 391:../uvc.c      **** }
 1356              		.loc 1 391 0
 1357 0a70 08D08DE2 		add	sp, sp, #8
 1358 0a74 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1359              		.loc 1 390 0
 1360 0a78 FEFFFFEA 		b	_txe_mutex_put
 1361              		.cfi_endproc
 1362              	.LFE1:
 1364              		.align	2
 1365              		.global	ControlHandle
 1367              	ControlHandle:
 1368              	.LFB2:
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1369              		.loc 1 393 0
 1370              		.cfi_startproc
 1371              		@ args = 0, pretend = 0, frame = 24
 1372              		@ frame_needed = 0, uses_anonymous_args = 0
 1373              	.LVL102:
 1374 0a7c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1375              	.LCFI13:
 1376              		.cfi_def_cfa_offset 36
 400:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1377              		.loc 1 400 0
 1378 0a80 230050E3 		cmp	r0, #35
 399:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1379              		.loc 1 399 0
 1380 0a84 207040E2 		sub	r7, r0, #32
 1381              		.cfi_offset 14, -4
 1382              		.cfi_offset 11, -8
 1383              		.cfi_offset 10, -12
 1384              		.cfi_offset 9, -16
 1385              		.cfi_offset 8, -20
 1386              		.cfi_offset 7, -24
 1387              		.cfi_offset 6, -28
 1388              		.cfi_offset 5, -32
 1389              		.cfi_offset 4, -36
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1390              		.loc 1 393 0
 1391 0a88 2CD04DE2 		sub	sp, sp, #44
 1392              	.LCFI14:
 1393              		.cfi_def_cfa_offset 80
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1394              		.loc 1 393 0
 1395 0a8c 0040A0E1 		mov	r4, r0
 399:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1396              		.loc 1 399 0
 1397 0a90 FF7007E2 		and	r7, r7, #255
 1398              	.LVL103:
 400:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1399              		.loc 1 400 0
 1400 0a94 2400009A 		bls	.L102
 401:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1401              		.loc 1 401 0
 1402 0a98 586F9FE5 		ldr	r6, .L211
 1403 0a9c 872087E0 		add	r2, r7, r7, asl #1
 1404 0aa0 8221A0E1 		mov	r2, r2, asl #3
 1405 0aa4 023086E0 		add	r3, r6, r2
 402:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1406              		.loc 1 402 0
 1407 0aa8 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 403:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1408              		.loc 1 403 0
 1409 0aac 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 404:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1410              		.loc 1 404 0
 1411 0ab0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 415:../uvc.c      ****     reqData = bRequest;
 1412              		.loc 1 415 0
 1413 0ab4 403F9FE5 		ldr	r3, .L211+4
 401:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1414              		.loc 1 401 0
 1415 0ab8 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1416              	.LVL104:
 415:../uvc.c      ****     reqData = bRequest;
 1417              		.loc 1 415 0
 1418 0abc 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1419              	.LVL105:
 423:../uvc.c      ****     switch (bRequest)
 1420              		.loc 1 423 0
 1421 0ac0 830055E3 		cmp	r5, #131
 1422 0ac4 2300000A 		beq	.L108
 1423              	.LVL106:
 1424              	.L206:
 1425 0ac8 2C00009A 		bls	.L204
 1426 0acc 850055E3 		cmp	r5, #133
 1427 0ad0 8B00000A 		beq	.L110
 1428 0ad4 7900003A 		bcc	.L109
 1429 0ad8 860055E3 		cmp	r5, #134
 1430 0adc C800000A 		beq	.L111
 1431 0ae0 870055E3 		cmp	r5, #135
 1432 0ae4 BC00000A 		beq	.L205
 1433              	.L104:
 899:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1434              		.loc 1 899 0
 1435 0ae8 0000A0E3 		mov	r0, #0
 1436 0aec 0110A0E3 		mov	r1, #1
 1437 0af0 0020A0E1 		mov	r2, r0
 1438 0af4 FEFFFFEB 		bl	CyU3PUsbStall
 900:../uvc.c      **** 			  break;
 1439              		.loc 1 900 0
 1440 0af8 FFC0A0E3 		mov	ip, #255
 1441 0afc 0C70A0E1 		mov	r7, ip
 1442              	.LVL107:
 1443 0b00 0CE0A0E1 		mov	lr, ip
 1444 0b04 0C40A0E1 		mov	r4, ip
 1445              	.LVL108:
 1446              	.L114:
 902:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1447              		.loc 1 902 0
 1448 0b08 F01E9FE5 		ldr	r1, .L211+8
 1449 0b0c 0520A0E1 		mov	r2, r5
 1450 0b10 0430A0E1 		mov	r3, r4
 1451 0b14 0400A0E3 		mov	r0, #4
 1452 0b18 00E08DE5 		str	lr, [sp, #0]
 1453 0b1c 80108DE9 		stmib	sp, {r7, ip}	@ phole stm
 1454 0b20 FEFFFFEB 		bl	CyU3PDebugPrint
 903:../uvc.c      **** }
 1455              		.loc 1 903 0
 1456 0b24 2CD08DE2 		add	sp, sp, #44
 1457 0b28 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1458              	.LVL109:
 1459              	.L102:
 406:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1460              		.loc 1 406 0
 1461 0b2c C46E9FE5 		ldr	r6, .L211
 415:../uvc.c      ****     reqData = bRequest;
 1462              		.loc 1 415 0
 1463 0b30 C43E9FE5 		ldr	r3, .L211+4
 406:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1464              		.loc 1 406 0
 1465 0b34 805080E0 		add	r5, r0, r0, asl #1
 1466 0b38 850186E0 		add	r0, r6, r5, asl #3
 1467              	.LVL110:
 415:../uvc.c      ****     reqData = bRequest;
 1468              		.loc 1 415 0
 1469 0b3c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 406:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1470              		.loc 1 406 0
 1471 0b40 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1472              	.LVL111:
 423:../uvc.c      ****     switch (bRequest)
 1473              		.loc 1 423 0
 1474 0b44 830055E3 		cmp	r5, #131
 407:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1475              		.loc 1 407 0
 1476 0b48 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1477              	.LVL112:
 408:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1478              		.loc 1 408 0
 1479 0b4c 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1480              	.LVL113:
 409:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1481              		.loc 1 409 0
 1482 0b50 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1483              	.LVL114:
 423:../uvc.c      ****     switch (bRequest)
 1484              		.loc 1 423 0
 1485 0b54 DBFFFF1A 		bne	.L206
 1486              	.LVL115:
 1487              	.L108:
 546:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1488              		.loc 1 546 0
 1489 0b58 230054E3 		cmp	r4, #35
 1490 0b5c C600009A 		bls	.L138
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1491              		.loc 1 547 0
 1492 0b60 870087E0 		add	r0, r7, r7, asl #1
 1493 0b64 806186E0 		add	r6, r6, r0, asl #3
 1494 0b68 94AE9FE5 		ldr	sl, .L211+12
 1495 0b6c 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
 548:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1496              		.loc 1 548 0
 1497 0b70 06E0D6E5 		ldrb	lr, [r6, #6]	@ zero_extendqisi2
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1498              		.loc 1 547 0
 1499 0b74 58C0CAE5 		strb	ip, [sl, #88]
 548:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1500              		.loc 1 548 0
 1501 0b78 59E0CAE5 		strb	lr, [sl, #89]
 1502 0b7c 0B0000EA 		b	.L146
 1503              	.L204:
 423:../uvc.c      ****     switch (bRequest)
 1504              		.loc 1 423 0
 1505 0b80 810055E3 		cmp	r5, #129
 1506 0b84 6A00000A 		beq	.L106
 1507 0b88 1000009A 		bls	.L207
 527:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1508              		.loc 1 527 0
 1509 0b8c 230054E3 		cmp	r4, #35
 1510 0b90 AD00009A 		bls	.L135
 528:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1511              		.loc 1 528 0
 1512 0b94 87A087E0 		add	sl, r7, r7, asl #1
 1513 0b98 8A6186E0 		add	r6, r6, sl, asl #3
 1514 0b9c 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 1515 0ba0 5CAE9FE5 		ldr	sl, .L211+12
 529:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1516              		.loc 1 529 0
 1517 0ba4 0470D6E5 		ldrb	r7, [r6, #4]	@ zero_extendqisi2
 1518              	.LVL116:
 528:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1519              		.loc 1 528 0
 1520 0ba8 5840CAE5 		strb	r4, [sl, #88]
 529:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1521              		.loc 1 529 0
 1522 0bac 5970CAE5 		strb	r7, [sl, #89]
 1523              	.L146:
 605:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1524              		.loc 1 605 0
 1525 0bb0 0800A0E1 		mov	r0, r8
 1526 0bb4 4C1E9FE5 		ldr	r1, .L211+16
 1527 0bb8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1528              	.LVL117:
 607:../uvc.c      **** 			  break;
 1529              		.loc 1 607 0
 1530 0bbc FFC0A0E3 		mov	ip, #255
 605:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1531              		.loc 1 605 0
 1532 0bc0 5870DAE5 		ldrb	r7, [sl, #88]	@ zero_extendqisi2
 607:../uvc.c      **** 			  break;
 1533              		.loc 1 607 0
 1534 0bc4 0CE0A0E1 		mov	lr, ip
 1535 0bc8 0C40A0E1 		mov	r4, ip
 1536 0bcc CDFFFFEA 		b	.L114
 1537              	.LVL118:
 1538              	.L207:
 423:../uvc.c      ****     switch (bRequest)
 1539              		.loc 1 423 0
 1540 0bd0 010055E3 		cmp	r5, #1
 1541 0bd4 C3FFFF1A 		bne	.L104
 609:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1542              		.loc 1 609 0
 1543 0bd8 241E9FE5 		ldr	r1, .L211+12
 1544 0bdc 26208DE2 		add	r2, sp, #38
 1545 0be0 2000A0E3 		mov	r0, #32
 1546 0be4 581081E2 		add	r1, r1, #88
 1547 0be8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1548              	.LVL119:
 611:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1549              		.loc 1 611 0
 1550 0bec 002050E2 		subs	r2, r0, #0
 1551 0bf0 4E03001A 		bne	.L148
 614:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1552              		.loc 1 614 0
 1553 0bf4 08CE9FE5 		ldr	ip, .L211+12
 613:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1554              		.loc 1 613 0
 1555 0bf8 040E9FE5 		ldr	r0, .L211+12
 1556              	.LVL120:
 614:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1557              		.loc 1 614 0
 1558 0bfc 59E0DCE5 		ldrb	lr, [ip, #89]	@ zero_extendqisi2
 616:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1559              		.loc 1 616 0
 1560 0c00 FC2D9FE5 		ldr	r2, .L211+12
 1561              	.LVL121:
 613:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1562              		.loc 1 613 0
 1563 0c04 5830D0E5 		ldrb	r3, [r0, #88]	@ zero_extendqisi2
 614:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1564              		.loc 1 614 0
 1565 0c08 1CE08DE5 		str	lr, [sp, #28]
 616:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1566              		.loc 1 616 0
 1567 0c0c 5AE0D2E5 		ldrb	lr, [r2, #90]	@ zero_extendqisi2
 613:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1568              		.loc 1 613 0
 1569 0c10 14308DE5 		str	r3, [sp, #20]
 1570              	.LVL122:
 616:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1571              		.loc 1 616 0
 1572 0c14 18E08DE5 		str	lr, [sp, #24]
 1573              	.LVL123:
 620:../uvc.c      **** 				  switch(CtrlID)
 1574              		.loc 1 620 0
 1575 0c18 260054E3 		cmp	r4, #38
 1576 0c1c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1577 0c20 B30200EA 		b	.L149
 1578              	.L165:
 1579 0c24 34160000 		.word	.L150
 1580 0c28 70150000 		.word	.L151
 1581 0c2c F4160000 		.word	.L149
 1582 0c30 F4160000 		.word	.L149
 1583 0c34 0C150000 		.word	.L152
 1584 0c38 CC130000 		.word	.L153
 1585 0c3c 50130000 		.word	.L154
 1586 0c40 F4160000 		.word	.L149
 1587 0c44 F4160000 		.word	.L149
 1588 0c48 F4160000 		.word	.L149
 1589 0c4c F4160000 		.word	.L149
 1590 0c50 C8120000 		.word	.L155
 1591 0c54 F4160000 		.word	.L149
 1592 0c58 F4160000 		.word	.L149
 1593 0c5c F4160000 		.word	.L149
 1594 0c60 F4160000 		.word	.L149
 1595 0c64 AC180000 		.word	.L156
 1596 0c68 F4160000 		.word	.L149
 1597 0c6c F4160000 		.word	.L149
 1598 0c70 F4160000 		.word	.L149
 1599 0c74 F4160000 		.word	.L149
 1600 0c78 F4160000 		.word	.L149
 1601 0c7c F4160000 		.word	.L149
 1602 0c80 F4160000 		.word	.L149
 1603 0c84 F4160000 		.word	.L149
 1604 0c88 08180000 		.word	.L157
 1605 0c8c 6C170000 		.word	.L158
 1606 0c90 F4160000 		.word	.L149
 1607 0c94 5C170000 		.word	.L159
 1608 0c98 F4160000 		.word	.L149
 1609 0c9c 6C120000 		.word	.L160
 1610 0ca0 E8110000 		.word	.L161
 1611 0ca4 F4160000 		.word	.L149
 1612 0ca8 F4160000 		.word	.L149
 1613 0cac F4160000 		.word	.L149
 1614 0cb0 F4160000 		.word	.L149
 1615 0cb4 4C110000 		.word	.L162
 1616 0cb8 34110000 		.word	.L163
 1617 0cbc D0100000 		.word	.L164
 1618              	.LVL124:
 1619              	.L109:
 564:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1620              		.loc 1 564 0
 1621 0cc0 230054E3 		cmp	r4, #35
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1622              		.loc 1 565 0
 1623 0cc4 87708780 		addhi	r7, r7, r7, asl #1
 1624              	.LVL125:
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1625              		.loc 1 571 0
 1626 0cc8 84408490 		addls	r4, r4, r4, asl #1
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1627              		.loc 1 565 0
 1628 0ccc 87618680 		addhi	r6, r6, r7, asl #3
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1629              		.loc 1 571 0
 1630 0cd0 84618690 		addls	r6, r6, r4, asl #3
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1631              		.loc 1 565 0
 1632 0cd4 28AD9F85 		ldrhi	sl, .L211+12
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1633              		.loc 1 571 0
 1634 0cd8 24AD9F95 		ldrls	sl, .L211+12
 565:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1635              		.loc 1 565 0
 1636 0cdc 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 566:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1637              		.loc 1 566 0
 1638 0ce0 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1639              		.loc 1 571 0
 1640 0ce4 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 572:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1641              		.loc 1 572 0
 1642 0ce8 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 573:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1643              		.loc 1 573 0
 1644 0cec 0030A0E3 		mov	r3, #0
 571:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1645              		.loc 1 571 0
 1646 0cf0 5810CAE5 		strb	r1, [sl, #88]
 572:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1647              		.loc 1 572 0
 1648 0cf4 5920CAE5 		strb	r2, [sl, #89]
 573:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1649              		.loc 1 573 0
 1650 0cf8 5A30CAE5 		strb	r3, [sl, #90]
 574:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1651              		.loc 1 574 0
 1652 0cfc 5B30CAE5 		strb	r3, [sl, #91]
 1653 0d00 AAFFFFEA 		b	.L146
 1654              	.LVL126:
 1655              	.L110:
 427:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1656              		.loc 1 427 0
 1657 0d04 F84C9FE5 		ldr	r4, .L211+12
 428:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1658              		.loc 1 428 0
 1659 0d08 00C0A0E3 		mov	ip, #0
 1660 0d0c 59C0C4E5 		strb	ip, [r4, #89]
 429:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1661              		.loc 1 429 0
 1662 0d10 581084E2 		add	r1, r4, #88
 427:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1663              		.loc 1 427 0
 1664 0d14 5880C4E5 		strb	r8, [r4, #88]
 429:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1665              		.loc 1 429 0
 1666 0d18 0200A0E3 		mov	r0, #2
 1667 0d1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1668              	.LVL127:
 431:../uvc.c      **** 			  break;
 1669              		.loc 1 431 0
 1670 0d20 FFC0A0E3 		mov	ip, #255
 429:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1671              		.loc 1 429 0
 1672 0d24 5870D4E5 		ldrb	r7, [r4, #88]	@ zero_extendqisi2
 1673              	.LVL128:
 431:../uvc.c      **** 			  break;
 1674              		.loc 1 431 0
 1675 0d28 0CE0A0E1 		mov	lr, ip
 1676 0d2c 0C40A0E1 		mov	r4, ip
 1677 0d30 74FFFFEA 		b	.L114
 1678              	.LVL129:
 1679              	.L106:
 434:../uvc.c      **** 			 switch(CtrlID)
 1680              		.loc 1 434 0
 1681 0d34 011044E2 		sub	r1, r4, #1
 1682 0d38 250051E3 		cmp	r1, #37
 1683 0d3c 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1684 0d40 D00000EA 		b	.L115
 1685              	.L123:
 1686 0d44 58100000 		.word	.L116
 1687 0d48 88100000 		.word	.L115
 1688 0d4c 88100000 		.word	.L115
 1689 0d50 88100000 		.word	.L115
 1690 0d54 38100000 		.word	.L117
 1691 0d58 88100000 		.word	.L115
 1692 0d5c 88100000 		.word	.L115
 1693 0d60 88100000 		.word	.L115
 1694 0d64 88100000 		.word	.L115
 1695 0d68 88100000 		.word	.L115
 1696 0d6c AC100000 		.word	.L118
 1697 0d70 88100000 		.word	.L115
 1698 0d74 88100000 		.word	.L115
 1699 0d78 88100000 		.word	.L115
 1700 0d7c 88100000 		.word	.L115
 1701 0d80 88100000 		.word	.L115
 1702 0d84 88100000 		.word	.L115
 1703 0d88 88100000 		.word	.L115
 1704 0d8c 88100000 		.word	.L115
 1705 0d90 88100000 		.word	.L115
 1706 0d94 88100000 		.word	.L115
 1707 0d98 88100000 		.word	.L115
 1708 0d9c 88100000 		.word	.L115
 1709 0da0 88100000 		.word	.L115
 1710 0da4 FC0F0000 		.word	.L119
 1711 0da8 88100000 		.word	.L115
 1712 0dac 88100000 		.word	.L115
 1713 0db0 D00F0000 		.word	.L120
 1714 0db4 88100000 		.word	.L115
 1715 0db8 88100000 		.word	.L115
 1716 0dbc 340F0000 		.word	.L121
 1717 0dc0 88100000 		.word	.L115
 1718 0dc4 88100000 		.word	.L115
 1719 0dc8 88100000 		.word	.L115
 1720 0dcc 88100000 		.word	.L115
 1721 0dd0 F80E0000 		.word	.L122
 1722 0dd4 F80E0000 		.word	.L122
 1723 0dd8 F80E0000 		.word	.L122
 1724              	.L205:
 591:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1725              		.loc 1 591 0
 1726 0ddc 230054E3 		cmp	r4, #35
 1727 0de0 3100009A 		bls	.L145
 592:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1728              		.loc 1 592 0
 1729 0de4 877087E0 		add	r7, r7, r7, asl #1
 1730              	.LVL130:
 1731 0de8 876186E0 		add	r6, r6, r7, asl #3
 1732 0dec 10AC9FE5 		ldr	sl, .L211+12
 1733 0df0 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 593:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1734              		.loc 1 593 0
 1735 0df4 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 592:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1736              		.loc 1 592 0
 1737 0df8 5820CAE5 		strb	r2, [sl, #88]
 593:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1738              		.loc 1 593 0
 1739 0dfc 5910CAE5 		strb	r1, [sl, #89]
 1740 0e00 6AFFFFEA 		b	.L146
 1741              	.LVL131:
 1742              	.L111:
 580:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1743              		.loc 1 580 0
 1744 0e04 230054E3 		cmp	r4, #35
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1745              		.loc 1 581 0
 1746 0e08 87708780 		addhi	r7, r7, r7, asl #1
 1747              	.LVL132:
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1748              		.loc 1 584 0
 1749 0e0c 84408490 		addls	r4, r4, r4, asl #1
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1750              		.loc 1 581 0
 1751 0e10 87618680 		addhi	r6, r6, r7, asl #3
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1752              		.loc 1 584 0
 1753 0e14 84618690 		addls	r6, r6, r4, asl #3
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1754              		.loc 1 581 0
 1755 0e18 E48B9F85 		ldrhi	r8, .L211+12
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1756              		.loc 1 584 0
 1757 0e1c E08B9F95 		ldrls	r8, .L211+12
 581:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1758              		.loc 1 581 0
 1759 0e20 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1760              		.loc 1 584 0
 1761 0e24 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 586:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1762              		.loc 1 586 0
 1763 0e28 0100A0E3 		mov	r0, #1
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1764              		.loc 1 584 0
 1765 0e2c 5830C8E5 		strb	r3, [r8, #88]
 586:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1766              		.loc 1 586 0
 1767 0e30 D01B9FE5 		ldr	r1, .L211+16
 1768 0e34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1769              	.LVL133:
 589:../uvc.c      **** 			  break;
 1770              		.loc 1 589 0
 1771 0e38 FFC0A0E3 		mov	ip, #255
 586:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1772              		.loc 1 586 0
 1773 0e3c 5870D8E5 		ldrb	r7, [r8, #88]	@ zero_extendqisi2
 589:../uvc.c      **** 			  break;
 1774              		.loc 1 589 0
 1775 0e40 0CE0A0E1 		mov	lr, ip
 1776 0e44 0C40A0E1 		mov	r4, ip
 1777 0e48 2EFFFFEA 		b	.L114
 1778              	.LVL134:
 1779              	.L135:
 532:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1780              		.loc 1 532 0
 1781 0e4c 0B0054E3 		cmp	r4, #11
 539:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1782              		.loc 1 539 0
 1783 0e50 84408410 		addne	r4, r4, r4, asl #1
 1784 0e54 84618610 		addne	r6, r6, r4, asl #3
 1785 0e58 A4AB9F15 		ldrne	sl, .L211+12
 533:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1786              		.loc 1 533 0
 1787 0e5c A0AB9F05 		ldreq	sl, .L211+12
 1788 0e60 A43B9F05 		ldreq	r3, .L211+20
 539:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1789              		.loc 1 539 0
 1790 0e64 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 540:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1791              		.loc 1 540 0
 1792 0e68 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 533:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1793              		.loc 1 533 0
 1794 0e6c 58308A05 		streq	r3, [sl, #88]
 539:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1795              		.loc 1 539 0
 1796 0e70 5820CA15 		strneb	r2, [sl, #88]
 540:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1797              		.loc 1 540 0
 1798 0e74 5930CA15 		strneb	r3, [sl, #89]
 1799 0e78 4CFFFFEA 		b	.L146
 1800              	.L138:
 550:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1801              		.loc 1 550 0
 1802 0e7c 0B0054E3 		cmp	r4, #11
 557:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1803              		.loc 1 557 0
 1804 0e80 84408410 		addne	r4, r4, r4, asl #1
 1805 0e84 84618610 		addne	r6, r6, r4, asl #3
 1806 0e88 74AB9F15 		ldrne	sl, .L211+12
 551:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1807              		.loc 1 551 0
 1808 0e8c 70AB9F05 		ldreq	sl, .L211+12
 1809 0e90 783B9F05 		ldreq	r3, .L211+24
 557:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1810              		.loc 1 557 0
 1811 0e94 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 558:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1812              		.loc 1 558 0
 1813 0e98 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 551:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1814              		.loc 1 551 0
 1815 0e9c 58308A05 		streq	r3, [sl, #88]
 557:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1816              		.loc 1 557 0
 1817 0ea0 5820CA15 		strneb	r2, [sl, #88]
 558:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1818              		.loc 1 558 0
 1819 0ea4 5930CA15 		strneb	r3, [sl, #89]
 1820 0ea8 40FFFFEA 		b	.L146
 1821              	.L145:
 596:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1822              		.loc 1 596 0
 1823 0eac 0B0054E3 		cmp	r4, #11
 1824 0eb0 0700000A 		beq	.L208
 602:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1825              		.loc 1 602 0
 1826 0eb4 84A084E0 		add	sl, r4, r4, asl #1
 1827 0eb8 8A6186E0 		add	r6, r6, sl, asl #3
 1828 0ebc 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1829 0ec0 3CAB9FE5 		ldr	sl, .L211+12
 603:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1830              		.loc 1 603 0
 1831 0ec4 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 602:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1832              		.loc 1 602 0
 1833 0ec8 5830CAE5 		strb	r3, [sl, #88]
 603:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1834              		.loc 1 603 0
 1835 0ecc 5900CAE5 		strb	r0, [sl, #89]
 1836 0ed0 36FFFFEA 		b	.L146
 1837              	.L208:
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1838              		.loc 1 597 0
 1839 0ed4 28AB9FE5 		ldr	sl, .L211+12
 1840 0ed8 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 599:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1841              		.loc 1 599 0
 1842 0edc 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 598:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1843              		.loc 1 598 0
 1844 0ee0 0040A0E3 		mov	r4, #0
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1845              		.loc 1 597 0
 1846 0ee4 58C0CAE5 		strb	ip, [sl, #88]
 598:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1847              		.loc 1 598 0
 1848 0ee8 5940CAE5 		strb	r4, [sl, #89]
 599:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1849              		.loc 1 599 0
 1850 0eec 5AE0CAE5 		strb	lr, [sl, #90]
 600:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1851              		.loc 1 600 0
 1852 0ef0 5B40CAE5 		strb	r4, [sl, #91]
 1853 0ef4 2DFFFFEA 		b	.L146
 1854              	.L122:
 440:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1855              		.loc 1 440 0
 1856 0ef8 877087E0 		add	r7, r7, r7, asl #1
 1857              	.LVL135:
 1858 0efc 876186E0 		add	r6, r6, r7, asl #3
 1859 0f00 FCEA9FE5 		ldr	lr, .L211+12
 1860 0f04 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 441:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1861              		.loc 1 441 0
 1862 0f08 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 440:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1863              		.loc 1 440 0
 1864 0f0c 5840CEE5 		strb	r4, [lr, #88]
 441:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1865              		.loc 1 441 0
 1866 0f10 5960CEE5 		strb	r6, [lr, #89]
 1867              	.LVL136:
 1868              	.L126:
 520:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1869              		.loc 1 520 0
 1870 0f14 0800A0E1 		mov	r0, r8
 1871 0f18 E81A9FE5 		ldr	r1, .L211+16
 1872 0f1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 525:../uvc.c      **** 			  break;
 1873              		.loc 1 525 0
 1874 0f20 FFE0A0E3 		mov	lr, #255
 520:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1875              		.loc 1 520 0
 1876 0f24 0470A0E1 		mov	r7, r4
 1877 0f28 06C0A0E1 		mov	ip, r6
 525:../uvc.c      **** 			  break;
 1878              		.loc 1 525 0
 1879 0f2c 0E40A0E1 		mov	r4, lr
 1880              	.LVL137:
 1881 0f30 F4FEFFEA 		b	.L114
 1882              	.LVL138:
 1883              	.L121:
 461:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1884              		.loc 1 461 0 discriminator 1
 1885 0f34 000058E3 		cmp	r8, #0
 1886 0f38 A702000A 		beq	.L199
 459:../uvc.c      **** 					 break;
 1887              		.loc 1 459 0
 1888 0f3c 28E1A0E1 		mov	lr, r8, lsr #2
 1889 0f40 00005EE3 		cmp	lr, #0
 1890 0f44 03005813 		cmpne	r8, #3
 1891 0f48 0020A083 		movhi	r2, #0
 1892 0f4c 0120A093 		movls	r2, #1
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1893              		.loc 1 393 0
 1894 0f50 0E31A0E1 		mov	r3, lr, asl #2
 459:../uvc.c      **** 					 break;
 1895              		.loc 1 459 0
 1896 0f54 A402009A 		bls	.L187
 1897 0f58 A81A9FE5 		ldr	r1, .L211+16
 1898 0f5c 0C0041E2 		sub	r0, r1, #12
 1899              	.LVL139:
 1900              	.L130:
 462:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1901              		.loc 1 462 0 discriminator 2
 1902 0f60 044090E4 		ldr	r4, [r0], #4
 1903 0f64 01C082E2 		add	ip, r2, #1
 1904 0f68 FF200CE2 		and	r2, ip, #255
 1905 0f6c 02005EE1 		cmp	lr, r2
 1906 0f70 044081E4 		str	r4, [r1], #4
 1907 0f74 F9FFFF8A 		bhi	.L130
 462:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1908              		.loc 1 462 0 is_stmt 0
 1909 0f78 030058E1 		cmp	r8, r3
 1910 0f7c 800A9F15 		ldrne	r0, .L211+12
 1911 0f80 9502000A 		beq	.L199
 1912              	.L191:
 1913 0f84 03E080E0 		add	lr, r0, r3
 1914 0f88 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 461:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1915              		.loc 1 461 0 is_stmt 1
 1916 0f8c 016083E2 		add	r6, r3, #1
 1917 0f90 FF3006E2 		and	r3, r6, #255
 1918              	.LVL140:
 1919 0f94 030058E1 		cmp	r8, r3
 462:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1920              		.loc 1 462 0
 1921 0f98 5810CEE5 		strb	r1, [lr, #88]
 461:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1922              		.loc 1 461 0
 1923 0f9c F8FFFF8A 		bhi	.L191
 1924              	.LVL141:
 1925              	.L125:
 471:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1926              		.loc 1 471 0
 1927 0fa0 5770D0E5 		ldrb	r7, [r0, #87]	@ zero_extendqisi2
 1928              	.LVL142:
 464:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1929              		.loc 1 464 0
 1930 0fa4 583A9FE5 		ldr	r3, .L211+12
 471:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1931              		.loc 1 471 0
 1932 0fa8 FF0057E3 		cmp	r7, #255
 464:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1933              		.loc 1 464 0
 1934 0fac 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1935              	.LVL143:
 465:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1936              		.loc 1 465 0
 1937 0fb0 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 1938              	.LVL144:
 471:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1939              		.loc 1 471 0
 1940 0fb4 D6FFFF0A 		beq	.L126
 473:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1941              		.loc 1 473 0
 1942 0fb8 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1943 0fbc 501A9FE5 		ldr	r1, .L211+28
 1944 0fc0 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1945 0fc4 0400A0E3 		mov	r0, #4
 1946 0fc8 FEFFFFEB 		bl	CyU3PDebugPrint
 1947 0fcc D0FFFFEA 		b	.L126
 1948              	.LVL145:
 1949              	.L120:
 447:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 1950              		.loc 1 447 0
 1951 0fd0 2D34D6E5 		ldrb	r3, [r6, #1069]	@ zero_extendqisi2
 1952              	.LVL146:
 449:../uvc.c      **** 						if(sendData >= 3){
 1953              		.loc 1 449 0
 1954 0fd4 020053E3 		cmp	r3, #2
 1955 0fd8 04308392 		addls	r3, r3, #4
 1956              	.LVL147:
 1957 0fdc FF400392 		andls	r4, r3, #255
 1958 0fe0 7402008A 		bhi	.L209
 1959              	.L134:
 1960              	.LVL148:
 494:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 1961              		.loc 1 494 0
 1962 0fe4 183A9FE5 		ldr	r3, .L211+12
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1963              		.loc 1 495 0
 1964 0fe8 0010A0E3 		mov	r1, #0
 494:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 1965              		.loc 1 494 0
 1966 0fec 5840C3E5 		strb	r4, [r3, #88]
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1967              		.loc 1 495 0
 1968 0ff0 5910C3E5 		strb	r1, [r3, #89]
 1969              	.LVL149:
 411:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 1970              		.loc 1 411 0
 1971 0ff4 FF60A0E3 		mov	r6, #255
 497:../uvc.c      **** 					 break;
 1972              		.loc 1 497 0
 1973 0ff8 C5FFFFEA 		b	.L126
 1974              	.LVL150:
 1975              	.L119:
 477:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1976              		.loc 1 477 0
 1977 0ffc E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 1978 1000 FCC99FE5 		ldr	ip, .L211+12
 479:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1979              		.loc 1 479 0
 1980 1004 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 478:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1981              		.loc 1 478 0
 1982 1008 00E0A0E3 		mov	lr, #0
 477:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1983              		.loc 1 477 0
 1984 100c 5840CCE5 		strb	r4, [ip, #88]
 478:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1985              		.loc 1 478 0
 1986 1010 59E0CCE5 		strb	lr, [ip, #89]
 479:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1987              		.loc 1 479 0
 1988 1014 5A60CCE5 		strb	r6, [ip, #90]
 480:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1989              		.loc 1 480 0
 1990 1018 5BE0CCE5 		strb	lr, [ip, #91]
 1991              	.LVL151:
 483:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 1992              		.loc 1 483 0
 1993 101c F4199FE5 		ldr	r1, .L211+32
 1994 1020 0420A0E1 		mov	r2, r4
 1995 1024 0E30A0E1 		mov	r3, lr
 1996 1028 0400A0E3 		mov	r0, #4
 1997 102c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 1998 1030 FEFFFFEB 		bl	CyU3PDebugPrint
 484:../uvc.c      **** 					 break;
 1999              		.loc 1 484 0
 2000 1034 B6FFFFEA 		b	.L126
 2001              	.LVL152:
 2002              	.L117:
 500:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2003              		.loc 1 500 0
 2004 1038 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 2005 103c C0799FE5 		ldr	r7, .L211+12
 2006              	.LVL153:
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2007              		.loc 1 501 0
 2008 1040 0060A0E3 		mov	r6, #0
 500:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2009              		.loc 1 500 0
 2010 1044 804024E2 		eor	r4, r4, #128
 501:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2011              		.loc 1 501 0
 2012 1048 5960C7E5 		strb	r6, [r7, #89]
 2013              	.LVL154:
 500:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2014              		.loc 1 500 0
 2015 104c 5840C7E5 		strb	r4, [r7, #88]
 411:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2016              		.loc 1 411 0
 2017 1050 FF60A0E3 		mov	r6, #255
 503:../uvc.c      **** 					 break;
 2018              		.loc 1 503 0
 2019 1054 AEFFFFEA 		b	.L126
 2020              	.LVL155:
 2021              	.L116:
 489:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2022              		.loc 1 489 0
 2023 1058 A601D6E5 		ldrb	r0, [r6, #422]	@ zero_extendqisi2
 487:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2024              		.loc 1 487 0
 2025 105c A521D6E5 		ldrb	r2, [r6, #421]	@ zero_extendqisi2
 2026              	.LVL156:
 489:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2027              		.loc 1 489 0
 2028 1060 020010E3 		tst	r0, #2
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2029              		.loc 1 492 0
 2030 1064 2221A001 		moveq	r2, r2, lsr #2
 2031              	.LVL157:
 2032 1068 822CE001 		mvneq	r2, r2, asl #25
 490:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2033              		.loc 1 490 0
 2034 106c 0003A011 		movne	r0, r0, asl #6
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2035              		.loc 1 492 0
 2036 1070 A22CE001 		mvneq	r2, r2, lsr #25
 490:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2037              		.loc 1 490 0
 2038 1074 40400012 		andne	r4, r0, #64
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2039              		.loc 1 492 0
 2040 1078 00038201 		orreq	r0, r2, r0, asl #6
 490:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2041              		.loc 1 490 0
 2042 107c 22418411 		orrne	r4, r4, r2, lsr #2
 2043              	.LVL158:
 492:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2044              		.loc 1 492 0
 2045 1080 FF400002 		andeq	r4, r0, #255
 2046              	.LVL159:
 2047 1084 D6FFFFEA 		b	.L134
 2048              	.LVL160:
 2049              	.L115:
 514:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2050              		.loc 1 514 0
 2051 1088 843084E0 		add	r3, r4, r4, asl #1
 2052 108c 831186E0 		add	r1, r6, r3, asl #3
 2053 1090 6C299FE5 		ldr	r2, .L211+12
 2054 1094 8D41D1E5 		ldrb	r4, [r1, #397]	@ zero_extendqisi2
 515:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2055              		.loc 1 515 0
 2056 1098 0000A0E3 		mov	r0, #0
 411:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2057              		.loc 1 411 0
 2058 109c FF60A0E3 		mov	r6, #255
 514:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2059              		.loc 1 514 0
 2060 10a0 5840C2E5 		strb	r4, [r2, #88]
 515:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2061              		.loc 1 515 0
 2062 10a4 5900C2E5 		strb	r0, [r2, #89]
 2063              	.LVL161:
 517:../uvc.c      **** 					 break;
 2064              		.loc 1 517 0
 2065 10a8 99FFFFEA 		b	.L126
 2066              	.LVL162:
 2067              	.L118:
 505:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2068              		.loc 1 505 0
 2069 10ac 50C99FE5 		ldr	ip, .L211+12
 2070 10b0 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 507:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2071              		.loc 1 507 0
 2072 10b4 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 506:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2073              		.loc 1 506 0
 2074 10b8 00E0A0E3 		mov	lr, #0
 505:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2075              		.loc 1 505 0
 2076 10bc 5840CCE5 		strb	r4, [ip, #88]
 506:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2077              		.loc 1 506 0
 2078 10c0 59E0CCE5 		strb	lr, [ip, #89]
 507:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2079              		.loc 1 507 0
 2080 10c4 5A60CCE5 		strb	r6, [ip, #90]
 508:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2081              		.loc 1 508 0
 2082 10c8 5BE0CCE5 		strb	lr, [ip, #91]
 2083              	.LVL163:
 511:../uvc.c      **** 					 break;
 2084              		.loc 1 511 0
 2085 10cc 90FFFFEA 		b	.L126
 2086              	.LVL164:
 2087              	.L164:
 764:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2088              		.loc 1 764 0
 2089 10d0 44499FE5 		ldr	r4, .L211+36
 2090 10d4 0010E0E3 		mvn	r1, #0
 2091 10d8 1C0094E5 		ldr	r0, [r4, #28]
 2092 10dc FEFFFFEB 		bl	_txe_mutex_get
 765:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2093              		.loc 1 765 0
 2094 10e0 2610A0E3 		mov	r1, #38
 2095              	.L203:
 2096 10e4 14C09DE5 		ldr	ip, [sp, #20]
 2097 10e8 00E0A0E3 		mov	lr, #0
 2098 10ec 0A30A0E1 		mov	r3, sl
 2099 10f0 0920A0E1 		mov	r2, r9
 2100 10f4 0400A0E1 		mov	r0, r4
 2101 10f8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2102 10fc FEFFFFEB 		bl	cmdSet
 766:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2103              		.loc 1 766 0
 2104 1100 1C0094E5 		ldr	r0, [r4, #28]
 2105 1104 FEFFFFEB 		bl	_txe_mutex_put
 767:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2106              		.loc 1 767 0
 2107 1108 14109DE5 		ldr	r1, [sp, #20]
 2108 110c 873087E0 		add	r3, r7, r7, asl #1
 2109 1110 836186E0 		add	r6, r6, r3, asl #3
 769:../uvc.c      **** 							 break;
 2110              		.loc 1 769 0
 2111 1114 FFC0A0E3 		mov	ip, #255
 768:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2112              		.loc 1 768 0
 2113 1118 0100A0E3 		mov	r0, #1
 767:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2114              		.loc 1 767 0
 2115 111c 0D10C6E5 		strb	r1, [r6, #13]
 768:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2116              		.loc 1 768 0
 2117 1120 1000C6E5 		strb	r0, [r6, #16]
 2118 1124 0140A0E1 		mov	r4, r1
 2119 1128 18E09DE5 		ldr	lr, [sp, #24]
 769:../uvc.c      **** 							 break;
 2120              		.loc 1 769 0
 2121 112c 0C70A0E1 		mov	r7, ip
 2122              	.LVL165:
 2123 1130 74FEFFEA 		b	.L114
 2124              	.LVL166:
 2125              	.L163:
 756:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2126              		.loc 1 756 0
 2127 1134 E0489FE5 		ldr	r4, .L211+36
 2128 1138 0010E0E3 		mvn	r1, #0
 2129 113c 1C0094E5 		ldr	r0, [r4, #28]
 2130 1140 FEFFFFEB 		bl	_txe_mutex_get
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2131              		.loc 1 757 0
 2132 1144 2510A0E3 		mov	r1, #37
 2133 1148 E5FFFFEA 		b	.L203
 2134              	.LVL167:
 2135              	.L162:
 742:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2136              		.loc 1 742 0
 2137 114c C8489FE5 		ldr	r4, .L211+36
 2138 1150 0010E0E3 		mvn	r1, #0
 2139 1154 1C0094E5 		ldr	r0, [r4, #28]
 2140 1158 FEFFFFEB 		bl	_txe_mutex_get
 741:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2141              		.loc 1 741 0
 2142 115c 14209DE5 		ldr	r2, [sp, #20]
 744:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2143              		.loc 1 744 0
 2144 1160 2410A0E3 		mov	r1, #36
 741:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2145              		.loc 1 741 0
 2146 1164 7F8002E2 		and	r8, r2, #127
 2147 1168 18808DE5 		str	r8, [sp, #24]
 2148              	.LVL168:
 744:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2149              		.loc 1 744 0
 2150 116c 18C09DE5 		ldr	ip, [sp, #24]
 2151 1170 0920A0E1 		mov	r2, r9
 2152 1174 0A30A0E1 		mov	r3, sl
 2153 1178 0400A0E1 		mov	r0, r4
 2154 117c 00C08DE5 		str	ip, [sp, #0]
 2155 1180 00C0A0E3 		mov	ip, #0
 2156 1184 04C08DE5 		str	ip, [sp, #4]
 2157 1188 FEFFFFEB 		bl	cmdSet
 2158              	.LVL169:
 746:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2159              		.loc 1 746 0
 2160 118c 1CE09DE5 		ldr	lr, [sp, #28]
 2161 1190 0180A0E3 		mov	r8, #1
 2162 1194 2410A0E3 		mov	r1, #36
 2163 1198 0B20A0E1 		mov	r2, fp
 2164 119c 0A30A0E1 		mov	r3, sl
 2165 11a0 0400A0E1 		mov	r0, r4
 2166 11a4 00E08DE5 		str	lr, [sp, #0]
 2167 11a8 04808DE5 		str	r8, [sp, #4]
 2168 11ac FEFFFFEB 		bl	cmdSet
 747:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2169              		.loc 1 747 0
 2170 11b0 1C0094E5 		ldr	r0, [r4, #28]
 2171 11b4 FEFFFFEB 		bl	_txe_mutex_put
 2172              	.LVL170:
 750:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2173              		.loc 1 750 0
 2174 11b8 87C087E0 		add	ip, r7, r7, asl #1
 2175 11bc 18409DE5 		ldr	r4, [sp, #24]
 751:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2176              		.loc 1 751 0
 2177 11c0 1C709DE5 		ldr	r7, [sp, #28]
 2178              	.LVL171:
 750:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2179              		.loc 1 750 0
 2180 11c4 8C6186E0 		add	r6, r6, ip, asl #3
 753:../uvc.c      **** 							 break;
 2181              		.loc 1 753 0
 2182 11c8 FFC0A0E3 		mov	ip, #255
 750:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2183              		.loc 1 750 0
 2184 11cc 0D40C6E5 		strb	r4, [r6, #13]
 751:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2185              		.loc 1 751 0
 2186 11d0 0E70C6E5 		strb	r7, [r6, #14]
 752:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2187              		.loc 1 752 0
 2188 11d4 07E0A0E1 		mov	lr, r7
 2189 11d8 1080C6E5 		strb	r8, [r6, #16]
 2190 11dc 14409DE5 		ldr	r4, [sp, #20]
 753:../uvc.c      **** 							 break;
 2191              		.loc 1 753 0
 2192 11e0 0C70A0E1 		mov	r7, ip
 2193 11e4 47FEFFEA 		b	.L114
 2194              	.LVL172:
 2195              	.L161:
 713:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2196              		.loc 1 713 0 discriminator 1
 2197 11e8 000058E3 		cmp	r8, #0
 2198 11ec 1800000A 		beq	.L167
 711:../uvc.c      **** 							 break;
 2199              		.loc 1 711 0
 2200 11f0 28E1A0E1 		mov	lr, r8, lsr #2
 2201 11f4 00005EE3 		cmp	lr, #0
 2202 11f8 03005813 		cmpne	r8, #3
 2203 11fc 0020A083 		movhi	r2, #0
 2204 1200 0120A093 		movls	r2, #1
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2205              		.loc 1 393 0
 2206 1204 0E31A0E1 		mov	r3, lr, asl #2
 711:../uvc.c      **** 							 break;
 2207              		.loc 1 711 0
 2208 1208 F501009A 		bls	.L188
 2209 120c 0C189FE5 		ldr	r1, .L211+40
 2210 1210 0C0081E2 		add	r0, r1, #12
 2211              	.LVL173:
 2212              	.L178:
 714:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2213              		.loc 1 714 0 discriminator 2
 2214 1214 047090E4 		ldr	r7, [r0], #4
 2215 1218 012082E2 		add	r2, r2, #1
 2216 121c FF2002E2 		and	r2, r2, #255
 2217 1220 02005EE1 		cmp	lr, r2
 2218 1224 047081E4 		str	r7, [r1], #4
 2219 1228 F9FFFF8A 		bhi	.L178
 714:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2220              		.loc 1 714 0 is_stmt 0
 2221 122c 030058E1 		cmp	r8, r3
 2222 1230 0700000A 		beq	.L167
 2223              	.L192:
 2224 1234 C8E79FE5 		ldr	lr, .L211+12
 2225 1238 03008EE0 		add	r0, lr, r3
 2226 123c 5810D0E5 		ldrb	r1, [r0, #88]	@ zero_extendqisi2
 713:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2227              		.loc 1 713 0 is_stmt 1
 2228 1240 013083E2 		add	r3, r3, #1
 2229 1244 FF3003E2 		and	r3, r3, #255
 2230              	.LVL174:
 2231 1248 030058E1 		cmp	r8, r3
 714:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2232              		.loc 1 714 0
 2233 124c 4C10C0E5 		strb	r1, [r0, #76]
 713:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2234              		.loc 1 713 0
 2235 1250 F7FFFF8A 		bhi	.L192
 2236              	.LVL175:
 2237              	.L167:
 716:../uvc.c      **** 					 		I2CCmdHandler();
 2238              		.loc 1 716 0
 2239 1254 FEFFFFEB 		bl	I2CCmdHandler
 717:../uvc.c      **** 							 break;
 2240              		.loc 1 717 0
 2241 1258 FFC0A0E3 		mov	ip, #255
 716:../uvc.c      **** 					 		I2CCmdHandler();
 2242              		.loc 1 716 0
 2243 125c 14409DE5 		ldr	r4, [sp, #20]
 2244 1260 18E09DE5 		ldr	lr, [sp, #24]
 717:../uvc.c      **** 							 break;
 2245              		.loc 1 717 0
 2246 1264 0C70A0E1 		mov	r7, ip
 2247 1268 26FEFFEA 		b	.L114
 2248              	.LVL176:
 2249              	.L160:
 707:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2250              		.loc 1 707 0
 2251 126c A8779FE5 		ldr	r7, .L211+36
 2252              	.LVL177:
 2253 1270 0010E0E3 		mvn	r1, #0
 2254 1274 1C0097E5 		ldr	r0, [r7, #28]
 2255 1278 FEFFFFEB 		bl	_txe_mutex_get
 708:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2256              		.loc 1 708 0
 2257 127c 14409DE5 		ldr	r4, [sp, #20]
 2258 1280 00E0A0E3 		mov	lr, #0
 2259 1284 01C074E2 		rsbs	ip, r4, #1
 2260 1288 00C0A033 		movcc	ip, #0
 2261 128c 1E10A0E3 		mov	r1, #30
 2262 1290 0920A0E1 		mov	r2, r9
 2263 1294 0A30A0E1 		mov	r3, sl
 2264 1298 0700A0E1 		mov	r0, r7
 2265 129c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2266 12a0 FEFFFFEB 		bl	cmdSet
 709:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2267              		.loc 1 709 0
 2268 12a4 1C0097E5 		ldr	r0, [r7, #28]
 2269 12a8 FEFFFFEB 		bl	_txe_mutex_put
 711:../uvc.c      **** 							 break;
 2270              		.loc 1 711 0
 2271 12ac FFC0A0E3 		mov	ip, #255
 710:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2272              		.loc 1 710 0
 2273 12b0 0100A0E3 		mov	r0, #1
 2274 12b4 6004C6E5 		strb	r0, [r6, #1120]
 2275 12b8 14409DE5 		ldr	r4, [sp, #20]
 2276 12bc 18E09DE5 		ldr	lr, [sp, #24]
 711:../uvc.c      **** 							 break;
 2277              		.loc 1 711 0
 2278 12c0 0C70A0E1 		mov	r7, ip
 2279 12c4 0FFEFFEA 		b	.L114
 2280              	.LVL178:
 2281              	.L155:
 830:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2282              		.loc 1 830 0
 2283 12c8 4C479FE5 		ldr	r4, .L211+36
 2284 12cc 0010E0E3 		mvn	r1, #0
 2285 12d0 1C0094E5 		ldr	r0, [r4, #28]
 2286 12d4 FEFFFFEB 		bl	_txe_mutex_get
 831:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2287              		.loc 1 831 0
 2288 12d8 14C09DE5 		ldr	ip, [sp, #20]
 2289 12dc 0B10A0E3 		mov	r1, #11
 2290 12e0 0920A0E1 		mov	r2, r9
 2291 12e4 0A30A0E1 		mov	r3, sl
 2292 12e8 0400A0E1 		mov	r0, r4
 2293 12ec 00C08DE5 		str	ip, [sp, #0]
 2294 12f0 00C0A0E3 		mov	ip, #0
 2295 12f4 04C08DE5 		str	ip, [sp, #4]
 2296 12f8 FEFFFFEB 		bl	cmdSet
 2297              	.LVL179:
 833:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2298              		.loc 1 833 0
 2299 12fc 18E09DE5 		ldr	lr, [sp, #24]
 2300 1300 0170A0E3 		mov	r7, #1
 2301              	.LVL180:
 2302 1304 0B10A0E3 		mov	r1, #11
 2303 1308 0B20A0E1 		mov	r2, fp
 2304 130c 0A30A0E1 		mov	r3, sl
 2305 1310 0400A0E1 		mov	r0, r4
 2306 1314 00E08DE5 		str	lr, [sp, #0]
 2307 1318 04708DE5 		str	r7, [sp, #4]
 2308 131c FEFFFFEB 		bl	cmdSet
 834:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2309              		.loc 1 834 0
 2310 1320 1C0094E5 		ldr	r0, [r4, #28]
 2311 1324 FEFFFFEB 		bl	_txe_mutex_put
 836:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2312              		.loc 1 836 0
 2313 1328 14109DE5 		ldr	r1, [sp, #20]
 837:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2314              		.loc 1 837 0
 2315 132c 18209DE5 		ldr	r2, [sp, #24]
 839:../uvc.c      **** 							 break;
 2316              		.loc 1 839 0
 2317 1330 FFC0A0E3 		mov	ip, #255
 838:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2318              		.loc 1 838 0
 2319 1334 9872C6E5 		strb	r7, [r6, #664]
 836:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2320              		.loc 1 836 0
 2321 1338 8C14C6E5 		strb	r1, [r6, #1164]
 837:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2322              		.loc 1 837 0
 2323 133c 8E24C6E5 		strb	r2, [r6, #1166]
 838:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2324              		.loc 1 838 0
 2325 1340 0140A0E1 		mov	r4, r1
 2326 1344 02E0A0E1 		mov	lr, r2
 839:../uvc.c      **** 							 break;
 2327              		.loc 1 839 0
 2328 1348 0C70A0E1 		mov	r7, ip
 2329 134c EDFDFFEA 		b	.L114
 2330              	.LVL181:
 2331              	.L154:
 816:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2332              		.loc 1 816 0
 2333 1350 C4469FE5 		ldr	r4, .L211+36
 2334 1354 0010E0E3 		mvn	r1, #0
 2335 1358 1C0094E5 		ldr	r0, [r4, #28]
 2336 135c FEFFFFEB 		bl	_txe_mutex_get
 817:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2337              		.loc 1 817 0
 2338 1360 14C09DE5 		ldr	ip, [sp, #20]
 2339 1364 0610A0E3 		mov	r1, #6
 2340 1368 0920A0E1 		mov	r2, r9
 2341 136c 0A30A0E1 		mov	r3, sl
 2342 1370 0400A0E1 		mov	r0, r4
 2343 1374 00C08DE5 		str	ip, [sp, #0]
 2344 1378 00C0A0E3 		mov	ip, #0
 2345 137c 04C08DE5 		str	ip, [sp, #4]
 2346 1380 FEFFFFEB 		bl	cmdSet
 2347              	.LVL182:
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2348              		.loc 1 819 0
 2349 1384 14E09DE5 		ldr	lr, [sp, #20]
 2350 1388 0170A0E3 		mov	r7, #1
 2351              	.LVL183:
 2352 138c 0610A0E3 		mov	r1, #6
 2353 1390 0B20A0E1 		mov	r2, fp
 2354 1394 0A30A0E1 		mov	r3, sl
 2355 1398 0400A0E1 		mov	r0, r4
 2356 139c 00E08DE5 		str	lr, [sp, #0]
 2357 13a0 04708DE5 		str	r7, [sp, #4]
 2358 13a4 FEFFFFEB 		bl	cmdSet
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2359              		.loc 1 820 0
 2360 13a8 1C0094E5 		ldr	r0, [r4, #28]
 2361 13ac FEFFFFEB 		bl	_txe_mutex_put
 821:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2362              		.loc 1 821 0
 2363 13b0 14409DE5 		ldr	r4, [sp, #20]
 823:../uvc.c      **** 							 break;
 2364              		.loc 1 823 0
 2365 13b4 FFC0A0E3 		mov	ip, #255
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2366              		.loc 1 822 0
 2367 13b8 2072C6E5 		strb	r7, [r6, #544]
 821:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2368              		.loc 1 821 0
 2369 13bc 1D42C6E5 		strb	r4, [r6, #541]
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2370              		.loc 1 822 0
 2371 13c0 18E09DE5 		ldr	lr, [sp, #24]
 823:../uvc.c      **** 							 break;
 2372              		.loc 1 823 0
 2373 13c4 0C70A0E1 		mov	r7, ip
 2374 13c8 CEFDFFEA 		b	.L114
 2375              	.LVL184:
 2376              	.L153:
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2377              		.loc 1 796 0
 2378 13cc 48469FE5 		ldr	r4, .L211+36
 2379 13d0 0010E0E3 		mvn	r1, #0
 2380 13d4 1C0094E5 		ldr	r0, [r4, #28]
 2381 13d8 FEFFFFEB 		bl	_txe_mutex_get
 797:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2382              		.loc 1 797 0
 2383 13dc 14309DE5 		ldr	r3, [sp, #20]
 2384 13e0 00C0A0E3 		mov	ip, #0
 2385 13e4 800043E2 		sub	r0, r3, #128
 2386 13e8 FF7000E2 		and	r7, r0, #255
 2387              	.LVL185:
 2388 13ec 0510A0E3 		mov	r1, #5
 2389 13f0 0920A0E1 		mov	r2, r9
 2390 13f4 0A30A0E1 		mov	r3, sl
 2391 13f8 0400A0E1 		mov	r0, r4
 2392 13fc 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2393 1400 FEFFFFEB 		bl	cmdSet
 2394              	.LVL186:
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2395              		.loc 1 799 0
 2396 1404 14109DE5 		ldr	r1, [sp, #20]
 2397 1408 DC20A0E3 		mov	r2, #220
 2398 140c 767041E2 		sub	r7, r1, #118
 2399 1410 FFC007E2 		and	ip, r7, #255
 2400 1414 0510A0E3 		mov	r1, #5
 2401 1418 0170A0E3 		mov	r7, #1
 2402 141c 0A30A0E1 		mov	r3, sl
 2403 1420 0400A0E1 		mov	r0, r4
 2404 1424 00C08DE5 		str	ip, [sp, #0]
 2405 1428 04708DE5 		str	r7, [sp, #4]
 2406 142c FEFFFFEB 		bl	cmdSet
 2407              	.LVL187:
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2408              		.loc 1 801 0
 2409 1430 14209DE5 		ldr	r2, [sp, #20]
 2410 1434 0510A0E3 		mov	r1, #5
 2411 1438 7E3082E2 		add	r3, r2, #126
 2412 143c FFC003E2 		and	ip, r3, #255
 2413 1440 DE20A0E3 		mov	r2, #222
 2414 1444 0A30A0E1 		mov	r3, sl
 2415 1448 0400A0E1 		mov	r0, r4
 2416 144c 00C08DE5 		str	ip, [sp, #0]
 2417 1450 02C0A0E3 		mov	ip, #2
 2418 1454 04C08DE5 		str	ip, [sp, #4]
 2419 1458 FEFFFFEB 		bl	cmdSet
 2420              	.LVL188:
 803:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2421              		.loc 1 803 0
 2422 145c 14009DE5 		ldr	r0, [sp, #20]
 2423 1460 03E0A0E3 		mov	lr, #3
 2424 1464 721080E2 		add	r1, r0, #114
 2425 1468 FFC001E2 		and	ip, r1, #255
 2426 146c E020A0E3 		mov	r2, #224
 2427 1470 0510A0E3 		mov	r1, #5
 2428 1474 0A30A0E1 		mov	r3, sl
 2429 1478 0400A0E1 		mov	r0, r4
 2430 147c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2431 1480 FEFFFFEB 		bl	cmdSet
 2432              	.LVL189:
 805:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2433              		.loc 1 805 0
 2434 1484 14209DE5 		ldr	r2, [sp, #20]
 2435 1488 0510A0E3 		mov	r1, #5
 2436 148c 6F3042E2 		sub	r3, r2, #111
 2437 1490 FFC003E2 		and	ip, r3, #255
 2438 1494 DD20A0E3 		mov	r2, #221
 2439 1498 0A30A0E1 		mov	r3, sl
 2440 149c 0400A0E1 		mov	r0, r4
 2441 14a0 00C08DE5 		str	ip, [sp, #0]
 2442 14a4 04C0A0E3 		mov	ip, #4
 2443 14a8 04C08DE5 		str	ip, [sp, #4]
 2444 14ac FEFFFFEB 		bl	cmdSet
 2445              	.LVL190:
 807:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2446              		.loc 1 807 0
 2447 14b0 4C059FE5 		ldr	r0, .L211+12
 2448 14b4 05E0A0E3 		mov	lr, #5
 2449 14b8 5810D0E5 		ldrb	r1, [r0, #88]	@ zero_extendqisi2
 2450 14bc 0A30A0E1 		mov	r3, sl
 2451 14c0 7F2081E2 		add	r2, r1, #127
 2452 14c4 FFC002E2 		and	ip, r2, #255
 2453 14c8 0E10A0E1 		mov	r1, lr
 2454 14cc 0B20A0E1 		mov	r2, fp
 2455 14d0 0400A0E1 		mov	r0, r4
 2456 14d4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2457 14d8 FEFFFFEB 		bl	cmdSet
 808:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2458              		.loc 1 808 0
 2459 14dc 1C0094E5 		ldr	r0, [r4, #28]
 2460 14e0 FEFFFFEB 		bl	_txe_mutex_put
 810:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2461              		.loc 1 810 0
 2462 14e4 18359FE5 		ldr	r3, .L211+12
 812:../uvc.c      **** 							 break;
 2463              		.loc 1 812 0
 2464 14e8 FFC0A0E3 		mov	ip, #255
 810:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2465              		.loc 1 810 0
 2466 14ec 5800D3E5 		ldrb	r0, [r3, #88]	@ zero_extendqisi2
 811:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2467              		.loc 1 811 0
 2468 14f0 0872C6E5 		strb	r7, [r6, #520]
 810:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2469              		.loc 1 810 0
 2470 14f4 801040E2 		sub	r1, r0, #128
 2471 14f8 0512C6E5 		strb	r1, [r6, #517]
 811:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2472              		.loc 1 811 0
 2473 14fc 14409DE5 		ldr	r4, [sp, #20]
 2474 1500 18E09DE5 		ldr	lr, [sp, #24]
 812:../uvc.c      **** 							 break;
 2475              		.loc 1 812 0
 2476 1504 0C70A0E1 		mov	r7, ip
 2477 1508 7EFDFFEA 		b	.L114
 2478              	.LVL191:
 2479              	.L152:
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2480              		.loc 1 848 0
 2481 150c 08459FE5 		ldr	r4, .L211+36
 842:../uvc.c      **** 							 Data0 = Data0 - 1;
 2482              		.loc 1 842 0
 2483 1510 013043E2 		sub	r3, r3, #1
 2484 1514 FF7003E2 		and	r7, r3, #255
 2485              	.LVL192:
 846:../uvc.c      **** 								 Data0 = 1;
 2486              		.loc 1 846 0
 2487 1518 020057E3 		cmp	r7, #2
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2488              		.loc 1 848 0
 2489 151c 0010E0E3 		mvn	r1, #0
 2490 1520 1C0094E5 		ldr	r0, [r4, #28]
 846:../uvc.c      **** 								 Data0 = 1;
 2491              		.loc 1 846 0
 2492 1524 0170A083 		movhi	r7, #1
 2493              	.LVL193:
 848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2494              		.loc 1 848 0
 2495 1528 FEFFFFEB 		bl	_txe_mutex_get
 849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2496              		.loc 1 849 0
 2497 152c 00C0A0E3 		mov	ip, #0
 2498 1530 0410A0E3 		mov	r1, #4
 2499 1534 0920A0E1 		mov	r2, r9
 2500 1538 0A30A0E1 		mov	r3, sl
 2501 153c 0400A0E1 		mov	r0, r4
 2502 1540 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2503 1544 FEFFFFEB 		bl	cmdSet
 850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2504              		.loc 1 850 0
 2505 1548 1C0094E5 		ldr	r0, [r4, #28]
 2506 154c FEFFFFEB 		bl	_txe_mutex_put
 854:../uvc.c      **** 							 break;
 2507              		.loc 1 854 0
 2508 1550 FFC0A0E3 		mov	ip, #255
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2509              		.loc 1 853 0
 2510 1554 0100A0E3 		mov	r0, #1
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2511              		.loc 1 852 0
 2512 1558 ED71C6E5 		strb	r7, [r6, #493]
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2513              		.loc 1 853 0
 2514 155c F001C6E5 		strb	r0, [r6, #496]
 2515 1560 14409DE5 		ldr	r4, [sp, #20]
 2516 1564 18E09DE5 		ldr	lr, [sp, #24]
 854:../uvc.c      **** 							 break;
 2517              		.loc 1 854 0
 2518 1568 0C70A0E1 		mov	r7, ip
 2519 156c 65FDFFEA 		b	.L114
 2520              	.LVL194:
 2521              	.L151:
 772:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2522              		.loc 1 772 0
 2523 1570 A4749FE5 		ldr	r7, .L211+36
 2524              	.LVL195:
 2525 1574 0010E0E3 		mvn	r1, #0
 2526 1578 1C0097E5 		ldr	r0, [r7, #28]
 2527 157c FEFFFFEB 		bl	_txe_mutex_get
 774:../uvc.c      **** 							  if(Data0&0x80){
 2528              		.loc 1 774 0
 2529 1580 14C09DE5 		ldr	ip, [sp, #20]
 775:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2530              		.loc 1 775 0
 2531 1584 A641D6E5 		ldrb	r4, [r6, #422]	@ zero_extendqisi2
 774:../uvc.c      **** 							  if(Data0&0x80){
 2532              		.loc 1 774 0
 2533 1588 80001CE3 		tst	ip, #128
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2534              		.loc 1 777 0
 2535 158c 2C23A001 		moveq	r2, ip, lsr #6
 775:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2536              		.loc 1 775 0
 2537 1590 8C2CA011 		movne	r2, ip, asl #25
 2538 1594 0340C413 		bicne	r4, r4, #3
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2539              		.loc 1 777 0
 2540 1598 0340C403 		biceq	r4, r4, #3
 781:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2541              		.loc 1 781 0
 2542 159c 00C0A0E3 		mov	ip, #0
 2543 15a0 04C08DE5 		str	ip, [sp, #4]
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2544              		.loc 1 777 0
 2545 15a4 02208203 		orreq	r2, r2, #2
 775:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2546              		.loc 1 775 0
 2547 15a8 A24F8411 		orrne	r4, r4, r2, lsr #31
 2548              	.LVL196:
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2549              		.loc 1 777 0
 2550 15ac 04408201 		orreq	r4, r2, r4
 2551              	.LVL197:
 779:../uvc.c      **** 							 Data1 |= ~0x03;
 2552              		.loc 1 779 0
 2553 15b0 043FE0E1 		mvn	r3, r4, asl #30
 2554 15b4 230FE0E1 		mvn	r0, r3, lsr #30
 2555              	.LVL198:
 780:../uvc.c      **** 							 Data1 &= 0xC7;
 2556              		.loc 1 780 0
 2557 15b8 C71000E2 		and	r1, r0, #199
 2558 15bc 1C108DE5 		str	r1, [sp, #28]
 2559              	.LVL199:
 781:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2560              		.loc 1 781 0
 2561 15c0 1C809DE5 		ldr	r8, [sp, #28]
 2562 15c4 0110A0E3 		mov	r1, #1
 2563 15c8 0B20A0E1 		mov	r2, fp
 2564 15cc 0A30A0E1 		mov	r3, sl
 2565 15d0 44049FE5 		ldr	r0, .L211+36
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2566              		.loc 1 785 0
 2567 15d4 0140A0E1 		mov	r4, r1
 781:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2568              		.loc 1 781 0
 2569 15d8 00808DE5 		str	r8, [sp, #0]
 2570 15dc FEFFFFEB 		bl	cmdSet
 2571              	.LVL200:
 784:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2572              		.loc 1 784 0
 2573 15e0 14209DE5 		ldr	r2, [sp, #20]
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2574              		.loc 1 785 0
 2575 15e4 0410A0E1 		mov	r1, r4
 784:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2576              		.loc 1 784 0
 2577 15e8 0281A0E1 		mov	r8, r2, asl #2
 2578 15ec FF8008E2 		and	r8, r8, #255
 2579              	.LVL201:
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2580              		.loc 1 785 0
 2581 15f0 0920A0E1 		mov	r2, r9
 2582 15f4 0A30A0E1 		mov	r3, sl
 2583 15f8 1C049FE5 		ldr	r0, .L211+36
 2584 15fc 04408DE5 		str	r4, [sp, #4]
 2585 1600 00808DE5 		str	r8, [sp, #0]
 2586 1604 FEFFFFEB 		bl	cmdSet
 786:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2587              		.loc 1 786 0
 2588 1608 1C0097E5 		ldr	r0, [r7, #28]
 2589 160c FEFFFFEB 		bl	_txe_mutex_put
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2590              		.loc 1 789 0
 2591 1610 1C709DE5 		ldr	r7, [sp, #28]
 792:../uvc.c      **** 							 break;
 2592              		.loc 1 792 0
 2593 1614 FFC0A0E3 		mov	ip, #255
 789:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2594              		.loc 1 789 0
 2595 1618 A671C6E5 		strb	r7, [r6, #422]
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2596              		.loc 1 790 0
 2597 161c A841C6E5 		strb	r4, [r6, #424]
 788:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2598              		.loc 1 788 0
 2599 1620 A581C6E5 		strb	r8, [r6, #421]
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2600              		.loc 1 790 0
 2601 1624 14409DE5 		ldr	r4, [sp, #20]
 2602 1628 18E09DE5 		ldr	lr, [sp, #24]
 792:../uvc.c      **** 							 break;
 2603              		.loc 1 792 0
 2604 162c 0C70A0E1 		mov	r7, ip
 2605 1630 34FDFFEA 		b	.L114
 2606              	.LVL202:
 2607              	.L150:
 2608 1634 03C0A0E1 		mov	ip, r3
 857:../uvc.c      **** 							 if(Data0 == 3)
 2609              		.loc 1 857 0
 2610 1638 030053E3 		cmp	r3, #3
 856:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2611              		.loc 1 856 0
 2612 163c 8DC1C6E5 		strb	ip, [r6, #397]
 2613 1640 B0339FE5 		ldr	r3, .L211
 857:../uvc.c      **** 							 if(Data0 == 3)
 2614              		.loc 1 857 0
 2615 1644 D600000A 		beq	.L210
 860:../uvc.c      **** 								 WDRflag = CyFalse;
 2616              		.loc 1 860 0
 2617 1648 B4E39FE5 		ldr	lr, .L211+12
 864:../uvc.c      **** 								 if(Data0 < 2){
 2618              		.loc 1 864 0
 2619 164c 01005CE3 		cmp	ip, #1
 860:../uvc.c      **** 								 WDRflag = CyFalse;
 2620              		.loc 1 860 0
 2621 1650 0000A0E3 		mov	r0, #0
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2622              		.loc 1 861 0
 2623 1654 0110A0E3 		mov	r1, #1
 860:../uvc.c      **** 								 WDRflag = CyFalse;
 2624              		.loc 1 860 0
 2625 1658 78008EE5 		str	r0, [lr, #120]
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2626              		.loc 1 861 0
 2627 165c 9011C3E5 		strb	r1, [r3, #400]
 864:../uvc.c      **** 								 if(Data0 < 2){
 2628              		.loc 1 864 0
 2629 1660 0C60A091 		movls	r6, ip
 2630 1664 0C70A091 		movls	r7, ip
 2631              	.LVL203:
 2632 1668 0600009A 		bls	.L186
 2633              	.L185:
 867:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 2634              		.loc 1 867 0
 2635 166c 0400A0E3 		mov	r0, #4
 2636 1670 AC139FE5 		ldr	r1, .L211+44
 2637 1674 0120A0E3 		mov	r2, #1
 2638 1678 14309DE5 		ldr	r3, [sp, #20]
 2639 167c FEFFFFEB 		bl	CyU3PDebugPrint
 2640              	.LVL204:
 2641 1680 0060A0E3 		mov	r6, #0
 868:../uvc.c      **** 									Data0 = 0; //set to default.
 2642              		.loc 1 868 0
 2643 1684 0670A0E1 		mov	r7, r6
 2644              	.LVL205:
 2645              	.L186:
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2646              		.loc 1 873 0
 2647 1688 8C439FE5 		ldr	r4, .L211+36
 2648 168c 0010E0E3 		mvn	r1, #0
 2649 1690 1C0094E5 		ldr	r0, [r4, #28]
 2650 1694 FEFFFFEB 		bl	_txe_mutex_get
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2651              		.loc 1 874 0
 2652 1698 00C0A0E3 		mov	ip, #0
 2653 169c 0C10A0E1 		mov	r1, ip
 2654 16a0 0920A0E1 		mov	r2, r9
 2655 16a4 0A30A0E1 		mov	r3, sl
 2656 16a8 0400A0E1 		mov	r0, r4
 2657 16ac 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2658 16b0 FEFFFFEB 		bl	cmdSet
 875:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2659              		.loc 1 875 0
 2660 16b4 1C0094E5 		ldr	r0, [r4, #28]
 2661 16b8 FEFFFFEB 		bl	_txe_mutex_put
 876:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2662              		.loc 1 876 0
 2663 16bc 40C39FE5 		ldr	ip, .L211+12
 2664 16c0 60139FE5 		ldr	r1, .L211+48
 2665 16c4 5A40DCE5 		ldrb	r4, [ip, #90]	@ zero_extendqisi2
 2666 16c8 5B70DCE5 		ldrb	r7, [ip, #91]	@ zero_extendqisi2
 2667              	.LVL206:
 2668 16cc 0400A0E3 		mov	r0, #4
 2669 16d0 0620A0E1 		mov	r2, r6
 2670 16d4 78309CE5 		ldr	r3, [ip, #120]
 2671 16d8 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2672              	.LVL207:
 2673              	.L202:
 2674 16dc FEFFFFEB 		bl	CyU3PDebugPrint
 878:../uvc.c      **** 					 		 break;
 2675              		.loc 1 878 0
 2676 16e0 FFC0A0E3 		mov	ip, #255
 876:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2677              		.loc 1 876 0
 2678 16e4 14409DE5 		ldr	r4, [sp, #20]
 2679 16e8 18E09DE5 		ldr	lr, [sp, #24]
 878:../uvc.c      **** 					 		 break;
 2680              		.loc 1 878 0
 2681 16ec 0C70A0E1 		mov	r7, ip
 2682 16f0 04FDFFEA 		b	.L114
 2683              	.LVL208:
 2684              	.L149:
 882:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2685              		.loc 1 882 0
 2686 16f4 20739FE5 		ldr	r7, .L211+36
 2687              	.LVL209:
 2688 16f8 0010E0E3 		mvn	r1, #0
 2689 16fc 1C0097E5 		ldr	r0, [r7, #28]
 2690 1700 FEFFFFEB 		bl	_txe_mutex_get
 883:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2691              		.loc 1 883 0
 2692 1704 14C09DE5 		ldr	ip, [sp, #20]
 2693 1708 0410A0E1 		mov	r1, r4
 2694 170c 0920A0E1 		mov	r2, r9
 2695 1710 0A30A0E1 		mov	r3, sl
 2696 1714 0700A0E1 		mov	r0, r7
 2697 1718 00C08DE5 		str	ip, [sp, #0]
 2698 171c 00C0A0E3 		mov	ip, #0
 2699 1720 04C08DE5 		str	ip, [sp, #4]
 2700 1724 FEFFFFEB 		bl	cmdSet
 884:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2701              		.loc 1 884 0
 2702 1728 1C0097E5 		ldr	r0, [r7, #28]
 2703 172c FEFFFFEB 		bl	_txe_mutex_put
 886:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2704              		.loc 1 886 0
 2705 1730 14209DE5 		ldr	r2, [sp, #20]
 2706 1734 841084E0 		add	r1, r4, r4, asl #1
 2707 1738 816186E0 		add	r6, r6, r1, asl #3
 888:../uvc.c      **** 							 break;
 2708              		.loc 1 888 0
 2709 173c FFC0A0E3 		mov	ip, #255
 887:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2710              		.loc 1 887 0
 2711 1740 0130A0E3 		mov	r3, #1
 886:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2712              		.loc 1 886 0
 2713 1744 8D21C6E5 		strb	r2, [r6, #397]
 887:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2714              		.loc 1 887 0
 2715 1748 9031C6E5 		strb	r3, [r6, #400]
 2716 174c 0240A0E1 		mov	r4, r2
 2717 1750 18E09DE5 		ldr	lr, [sp, #24]
 888:../uvc.c      **** 							 break;
 2718              		.loc 1 888 0
 2719 1754 0C70A0E1 		mov	r7, ip
 2720 1758 EAFCFFEA 		b	.L114
 2721              	.LVL210:
 2722              	.L159:
 620:../uvc.c      **** 				  switch(CtrlID)
 2723              		.loc 1 620 0
 2724 175c FFC0A0E3 		mov	ip, #255
 2725 1760 0340A0E1 		mov	r4, r3
 2726 1764 0C70A0E1 		mov	r7, ip
 2727              	.LVL211:
 2728 1768 E6FCFFEA 		b	.L114
 2729              	.LVL212:
 2730              	.L158:
 674:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2731              		.loc 1 674 0
 2732 176c A8729FE5 		ldr	r7, .L211+36
 2733              	.LVL213:
 672:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2734              		.loc 1 672 0
 2735 1770 FD33C6E5 		strb	r3, [r6, #1021]
 673:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2736              		.loc 1 673 0
 2737 1774 0130A0E3 		mov	r3, #1
 674:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2738              		.loc 1 674 0
 2739 1778 1C0097E5 		ldr	r0, [r7, #28]
 2740 177c 0010E0E3 		mvn	r1, #0
 673:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2741              		.loc 1 673 0
 2742 1780 0034C6E5 		strb	r3, [r6, #1024]
 674:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2743              		.loc 1 674 0
 2744 1784 FEFFFFEB 		bl	_txe_mutex_get
 675:../uvc.c      **** 							 if(WDRflag)
 2745              		.loc 1 675 0
 2746 1788 74329FE5 		ldr	r3, .L211+12
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2747              		.loc 1 676 0
 2748 178c 1A10A0E3 		mov	r1, #26
 675:../uvc.c      **** 							 if(WDRflag)
 2749              		.loc 1 675 0
 2750 1790 784093E5 		ldr	r4, [r3, #120]
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2751              		.loc 1 676 0
 2752 1794 0700A0E1 		mov	r0, r7
 675:../uvc.c      **** 							 if(WDRflag)
 2753              		.loc 1 675 0
 2754 1798 000054E3 		cmp	r4, #0
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2755              		.loc 1 676 0
 2756 179c 14409D15 		ldrne	r4, [sp, #20]
 678:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2757              		.loc 1 678 0
 2758 17a0 14E09D05 		ldreq	lr, [sp, #20]
 676:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2759              		.loc 1 676 0
 2760 17a4 00408D15 		strne	r4, [sp, #0]
 2761 17a8 0B20A011 		movne	r2, fp
 2762 17ac 0040A013 		movne	r4, #0
 2763 17b0 0A30A011 		movne	r3, sl
 678:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2764              		.loc 1 678 0
 2765 17b4 0920A001 		moveq	r2, r9
 2766 17b8 0A30A001 		moveq	r3, sl
 2767 17bc 04408DE5 		str	r4, [sp, #4]
 2768 17c0 00E08D05 		streq	lr, [sp, #0]
 2769 17c4 FEFFFFEB 		bl	cmdSet
 679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2770              		.loc 1 679 0
 2771 17c8 1C0097E5 		ldr	r0, [r7, #28]
 2772 17cc FEFFFFEB 		bl	_txe_mutex_put
 680:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2773              		.loc 1 680 0
 2774 17d0 2C229FE5 		ldr	r2, .L211+12
 2775 17d4 14409DE5 		ldr	r4, [sp, #20]
 2776 17d8 5AC0D2E5 		ldrb	ip, [r2, #90]	@ zero_extendqisi2
 2777 17dc 5BE0D2E5 		ldrb	lr, [r2, #91]	@ zero_extendqisi2
 2778 17e0 783092E5 		ldr	r3, [r2, #120]
 2779 17e4 0400A0E3 		mov	r0, #4
 2780 17e8 3C129FE5 		ldr	r1, .L211+52
 2781 17ec 0420A0E1 		mov	r2, r4
 2782 17f0 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2783 17f4 FEFFFFEB 		bl	CyU3PDebugPrint
 2784 17f8 FFC0A0E3 		mov	ip, #255
 2785 17fc 18E09DE5 		ldr	lr, [sp, #24]
 2786 1800 0C70A0E1 		mov	r7, ip
 2787 1804 BFFCFFEA 		b	.L114
 2788              	.LVL214:
 2789              	.L157:
 658:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2790              		.loc 1 658 0
 2791 1808 18209DE5 		ldr	r2, [sp, #24]
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2792              		.loc 1 661 0
 2793 180c 08429FE5 		ldr	r4, .L211+36
 659:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2794              		.loc 1 659 0
 2795 1810 0170A0E3 		mov	r7, #1
 2796              	.LVL215:
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2797              		.loc 1 661 0
 2798 1814 0010E0E3 		mvn	r1, #0
 657:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2799              		.loc 1 657 0
 2800 1818 E533C6E5 		strb	r3, [r6, #997]
 658:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2801              		.loc 1 658 0
 2802 181c E623C6E5 		strb	r2, [r6, #998]
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2803              		.loc 1 661 0
 2804 1820 1C0094E5 		ldr	r0, [r4, #28]
 659:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2805              		.loc 1 659 0
 2806 1824 E873C6E5 		strb	r7, [r6, #1000]
 2807              	.LVL216:
 661:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2808              		.loc 1 661 0
 2809 1828 FEFFFFEB 		bl	_txe_mutex_get
 662:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2810              		.loc 1 662 0
 2811 182c 14C09DE5 		ldr	ip, [sp, #20]
 2812 1830 1910A0E3 		mov	r1, #25
 2813 1834 00C08DE5 		str	ip, [sp, #0]
 2814 1838 0400A0E1 		mov	r0, r4
 2815 183c 00C0A0E3 		mov	ip, #0
 2816 1840 0920A0E1 		mov	r2, r9
 2817 1844 0A30A0E1 		mov	r3, sl
 2818 1848 04C08DE5 		str	ip, [sp, #4]
 2819 184c FEFFFFEB 		bl	cmdSet
 663:../uvc.c      **** 							 if(getData != 0){
 2820              		.loc 1 663 0
 2821 1850 14109DE5 		ldr	r1, [sp, #20]
 2822 1854 000051E3 		cmp	r1, #0
 2823 1858 0700000A 		beq	.L174
 2824              	.LVL217:
 665:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2825              		.loc 1 665 0
 2826 185c 18E09DE5 		ldr	lr, [sp, #24]
 2827 1860 0400A0E1 		mov	r0, r4
 2828 1864 1910A0E3 		mov	r1, #25
 2829 1868 0B20A0E1 		mov	r2, fp
 2830 186c 0A30A0E1 		mov	r3, sl
 2831 1870 00E08DE5 		str	lr, [sp, #0]
 2832 1874 04708DE5 		str	r7, [sp, #4]
 2833 1878 FEFFFFEB 		bl	cmdSet
 2834              	.LVL218:
 2835              	.L174:
 667:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2836              		.loc 1 667 0
 2837 187c 1C0094E5 		ldr	r0, [r4, #28]
 2838 1880 FEFFFFEB 		bl	_txe_mutex_put
 668:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2839              		.loc 1 668 0
 2840 1884 78119FE5 		ldr	r1, .L211+12
 2841 1888 74019FE5 		ldr	r0, .L211+12
 2842 188c 5A40D1E5 		ldrb	r4, [r1, #90]	@ zero_extendqisi2
 2843 1890 5B70D0E5 		ldrb	r7, [r0, #91]	@ zero_extendqisi2
 2844 1894 5820D1E5 		ldrb	r2, [r1, #88]	@ zero_extendqisi2
 2845 1898 5930D1E5 		ldrb	r3, [r1, #89]	@ zero_extendqisi2
 2846 189c 0400A0E3 		mov	r0, #4
 2847 18a0 88119FE5 		ldr	r1, .L211+56
 2848 18a4 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2849 18a8 8BFFFFEA 		b	.L202
 2850              	.LVL219:
 2851              	.L156:
 624:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2852              		.loc 1 624 0
 2853 18ac 000053E2 		subs	r0, r3, #0
 623:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2854              		.loc 1 623 0
 2855 18b0 0D03C6E5 		strb	r0, [r6, #781]
 2856 18b4 3C319FE5 		ldr	r3, .L211
 624:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2857              		.loc 1 624 0
 2858 18b8 2400001A 		bne	.L168
 625:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2859              		.loc 1 625 0
 2860 18bc B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2861 18c0 020052E3 		cmp	r2, #2
 2862 18c4 08005213 		cmpne	r2, #8
 2863 18c8 0300000A 		beq	.L169
 626:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2864              		.loc 1 626 0
 2865 18cc 010052E3 		cmp	r2, #1
 627:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2866              		.loc 1 627 0
 2867 18d0 07208202 		addeq	r2, r2, #7
 629:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2868              		.loc 1 629 0
 2869 18d4 0220A013 		movne	r2, #2
 2870 18d8 B524C3E5 		strb	r2, [r3, #1205]
 2871              	.LVL220:
 2872              	.L169:
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2873              		.loc 1 651 0
 2874 18dc 38419FE5 		ldr	r4, .L211+36
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2875              		.loc 1 649 0
 2876 18e0 0130A0E3 		mov	r3, #1
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2877              		.loc 1 651 0
 2878 18e4 0010E0E3 		mvn	r1, #0
 2879 18e8 1C0094E5 		ldr	r0, [r4, #28]
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2880              		.loc 1 649 0
 2881 18ec 1033C6E5 		strb	r3, [r6, #784]
 2882              	.LVL221:
 651:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2883              		.loc 1 651 0
 2884 18f0 FEFFFFEB 		bl	_txe_mutex_get
 652:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2885              		.loc 1 652 0
 2886 18f4 14C09DE5 		ldr	ip, [sp, #20]
 2887 18f8 00E0A0E3 		mov	lr, #0
 2888 18fc 1010A0E3 		mov	r1, #16
 2889 1900 0920A0E1 		mov	r2, r9
 2890 1904 0A30A0E1 		mov	r3, sl
 2891 1908 0400A0E1 		mov	r0, r4
 2892 190c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2893 1910 FEFFFFEB 		bl	cmdSet
 653:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2894              		.loc 1 653 0
 2895 1914 1C0094E5 		ldr	r0, [r4, #28]
 2896 1918 FEFFFFEB 		bl	_txe_mutex_put
 655:../uvc.c      **** 							 break;
 2897              		.loc 1 655 0
 2898 191c FFC0A0E3 		mov	ip, #255
 653:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2899              		.loc 1 653 0
 2900 1920 14409DE5 		ldr	r4, [sp, #20]
 2901 1924 18E09DE5 		ldr	lr, [sp, #24]
 655:../uvc.c      **** 							 break;
 2902              		.loc 1 655 0
 2903 1928 0C70A0E1 		mov	r7, ip
 2904 192c 75FCFFEA 		b	.L114
 2905              	.LVL222:
 2906              	.L148:
 891:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2907              		.loc 1 891 0
 2908 1930 0400A0E3 		mov	r0, #4
 2909              	.LVL223:
 2910 1934 F8109FE5 		ldr	r1, .L211+60
 2911 1938 FEFFFFEB 		bl	CyU3PDebugPrint
 2912              	.LVL224:
 2913 193c FFC0A0E3 		mov	ip, #255
 2914 1940 0C70A0E1 		mov	r7, ip
 2915              	.LVL225:
 2916 1944 0CE0A0E1 		mov	lr, ip
 2917 1948 0C40A0E1 		mov	r4, ip
 2918 194c 6DFCFFEA 		b	.L114
 2919              	.LVL226:
 2920              	.L168:
 634:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2921              		.loc 1 634 0
 2922 1950 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 633:../uvc.c      **** 								 Data1 = Data0 - 1;
 2923              		.loc 1 633 0
 2924 1954 017040E2 		sub	r7, r0, #1
 2925              	.LVL227:
 634:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2926              		.loc 1 634 0
 2927 1958 040052E3 		cmp	r2, #4
 2928 195c 01005213 		cmpne	r2, #1
 633:../uvc.c      **** 								 Data1 = Data0 - 1;
 2929              		.loc 1 633 0
 2930 1960 FF1007E2 		and	r1, r7, #255
 2931              	.LVL228:
 634:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2932              		.loc 1 634 0
 2933 1964 0300000A 		beq	.L171
 635:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2934              		.loc 1 635 0
 2935 1968 080052E3 		cmp	r2, #8
 636:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2936              		.loc 1 636 0
 2937 196c 0120A003 		moveq	r2, #1
 638:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2938              		.loc 1 638 0
 2939 1970 0420A013 		movne	r2, #4
 2940 1974 B524C3E5 		strb	r2, [r3, #1205]
 2941              	.L171:
 641:../uvc.c      **** 								 if(Data1 < 8){
 2942              		.loc 1 641 0
 2943 1978 070051E3 		cmp	r1, #7
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2944              		.loc 1 642 0
 2945 197c B4309F95 		ldrls	r3, .L211+64
 645:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2946              		.loc 1 645 0
 2947 1980 0130A083 		movhi	r3, #1
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2948              		.loc 1 643 0
 2949 1984 81008390 		addls	r0, r3, r1, asl #1
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2950              		.loc 1 642 0
 2951 1988 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2952              		.loc 1 643 0
 2953 198c 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 645:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2954              		.loc 1 645 0
 2955 1990 E534C685 		strhib	r3, [r6, #1253]
 646:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2956              		.loc 1 646 0
 2957 1994 0030A083 		movhi	r3, #0
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2958              		.loc 1 642 0
 2959 1998 E524C695 		strlsb	r2, [r6, #1253]
 646:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2960              		.loc 1 646 0
 2961 199c E634C6E5 		strb	r3, [r6, #1254]
 2962 19a0 CDFFFFEA 		b	.L169
 2963              	.LVL229:
 2964              	.L210:
 858:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2965              		.loc 1 858 0
 2966 19a4 58209FE5 		ldr	r2, .L211+12
 2967 19a8 0160A0E3 		mov	r6, #1
 2968 19ac 786082E5 		str	r6, [r2, #120]
 861:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2969              		.loc 1 861 0
 2970 19b0 9061C3E5 		strb	r6, [r3, #400]
 2971 19b4 2CFFFFEA 		b	.L185
 2972              	.LVL230:
 2973              	.L209:
 450:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2974              		.loc 1 450 0
 2975 19b8 0120A0E3 		mov	r2, #1
 2976 19bc 0400A0E3 		mov	r0, #4
 2977 19c0 5C109FE5 		ldr	r1, .L211+44
 2978 19c4 FEFFFFEB 		bl	CyU3PDebugPrint
 2979              	.LVL231:
 452:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2980              		.loc 1 452 0
 2981 19c8 28309FE5 		ldr	r3, .L211
 2982 19cc 0020A0E3 		mov	r2, #0
 2983 19d0 0440A0E3 		mov	r4, #4
 2984 19d4 2D24C3E5 		strb	r2, [r3, #1069]
 2985              	.LVL232:
 2986 19d8 81FDFFEA 		b	.L134
 2987              	.LVL233:
 2988              	.L199:
 2989 19dc 20009FE5 		ldr	r0, .L211+12
 2990 19e0 6EFDFFEA 		b	.L125
 2991              	.LVL234:
 2992              	.L188:
 393:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2993              		.loc 1 393 0
 2994 19e4 0030A0E3 		mov	r3, #0
 2995 19e8 11FEFFEA 		b	.L192
 2996              	.LVL235:
 2997              	.L187:
 2998 19ec 10009FE5 		ldr	r0, .L211+12
 2999 19f0 0030A0E3 		mov	r3, #0
 3000 19f4 62FDFFEA 		b	.L191
 3001              	.L212:
 3002              		.align	2
 3003              	.L211:
 3004 19f8 00000000 		.word	.LANCHOR1
 3005 19fc 00000000 		.word	bRequest
 3006 1a00 74030000 		.word	.LC22
 3007 1a04 00000000 		.word	.LANCHOR0
 3008 1a08 58000000 		.word	.LANCHOR0+88
 3009 1a0c 01000100 		.word	65537
 3010 1a10 FF00FF00 		.word	16711935
 3011 1a14 80020000 		.word	.LC16
 3012 1a18 BC020000 		.word	.LC17
 3013 1a1c 00000000 		.word	cmdQu
 3014 1a20 4C000000 		.word	.LANCHOR0+76
 3015 1a24 48020000 		.word	.LC15
 3016 1a28 2C030000 		.word	.LC20
 3017 1a2c 10030000 		.word	.LC19
 3018 1a30 E4020000 		.word	.LC18
 3019 1a34 44030000 		.word	.LC21
 3020 1a38 00000000 		.word	.LANCHOR2
 3021              		.cfi_endproc
 3022              	.LFE2:
 3024              		.align	2
 3025              		.global	CTControlHandle
 3027              	CTControlHandle:
 3028              	.LFB3:
 907:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3029              		.loc 1 907 0
 3030              		.cfi_startproc
 3031              		@ args = 0, pretend = 0, frame = 64
 3032              		@ frame_needed = 0, uses_anonymous_args = 0
 3033              	.LVL236:
 3034 1a3c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3035              	.LCFI15:
 3036              		.cfi_def_cfa_offset 36
 926:../uvc.c      ****     reqData = bRequest;
 3037              		.loc 1 926 0
 3038 1a40 64A99FE5 		ldr	sl, .L298
 3039              		.cfi_offset 14, -4
 3040              		.cfi_offset 11, -8
 3041              		.cfi_offset 10, -12
 3042              		.cfi_offset 9, -16
 3043              		.cfi_offset 8, -20
 3044              		.cfi_offset 7, -24
 3045              		.cfi_offset 6, -28
 3046              		.cfi_offset 5, -32
 3047              		.cfi_offset 4, -36
 918:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3048              		.loc 1 918 0
 3049 1a44 64899FE5 		ldr	r8, .L298+4
 926:../uvc.c      ****     reqData = bRequest;
 3050              		.loc 1 926 0
 3051 1a48 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 918:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3052              		.loc 1 918 0
 3053 1a4c 8090A0E1 		mov	r9, r0, asl #1
 3054 1a50 002089E0 		add	r2, r9, r0
 3055 1a54 822188E0 		add	r2, r8, r2, asl #3
 928:../uvc.c      ****     switch (bRequest)
 3056              		.loc 1 928 0
 3057 1a58 830055E3 		cmp	r5, #131
 907:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3058              		.loc 1 907 0
 3059 1a5c 5CD04DE2 		sub	sp, sp, #92
 3060              	.LCFI16:
 3061              		.cfi_def_cfa_offset 128
 907:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3062              		.loc 1 907 0
 3063 1a60 0060A0E1 		mov	r6, r0
 918:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3064              		.loc 1 918 0
 3065 1a64 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3066              	.LVL237:
 919:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3067              		.loc 1 919 0
 3068 1a68 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3069              	.LVL238:
 921:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3070              		.loc 1 921 0
 3071 1a6c 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3072              	.LVL239:
 928:../uvc.c      ****     switch (bRequest)
 3073              		.loc 1 928 0
 3074 1a70 7600000A 		beq	.L218
 3075 1a74 2100009A 		bls	.L293
 3076 1a78 850055E3 		cmp	r5, #133
 3077 1a7c 5900000A 		beq	.L220
 3078 1a80 4E00003A 		bcc	.L219
 3079 1a84 860055E3 		cmp	r5, #134
 3080 1a88 8000000A 		beq	.L221
 3081 1a8c 870055E3 		cmp	r5, #135
 3082 1a90 7600000A 		beq	.L294
 3083              	.L214:
1135:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3084              		.loc 1 1135 0
 3085 1a94 0000A0E3 		mov	r0, #0
 3086              	.LVL240:
 3087 1a98 0110A0E3 		mov	r1, #1
 3088 1a9c 0020A0E1 		mov	r2, r0
 3089 1aa0 FEFFFFEB 		bl	CyU3PUsbStall
 3090              	.LVL241:
 3091 1aa4 08499FE5 		ldr	r4, .L298+8
1136:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3092              		.loc 1 1136 0
 3093 1aa8 0620A0E1 		mov	r2, r6
 3094 1aac 0400A0E3 		mov	r0, #4
 3095 1ab0 00199FE5 		ldr	r1, .L298+12
 3096 1ab4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3097 1ab8 FEFFFFEB 		bl	CyU3PDebugPrint
1137:../uvc.c      **** 			  break;
 3098              		.loc 1 1137 0
 3099 1abc FFC0A0E3 		mov	ip, #255
 3100 1ac0 0C60A0E1 		mov	r6, ip
 3101 1ac4 0C80A0E1 		mov	r8, ip
 3102              	.LVL242:
 3103              	.L224:
1141:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3104              		.loc 1 1141 0
 3105 1ac8 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3106 1acc 08C08DE5 		str	ip, [sp, #8]
 3107 1ad0 E4189FE5 		ldr	r1, .L298+16
 3108 1ad4 FFC0A0E3 		mov	ip, #255
 3109 1ad8 0520A0E1 		mov	r2, r5
 3110 1adc 0830A0E1 		mov	r3, r8
 3111 1ae0 0400A0E3 		mov	r0, #4
 3112 1ae4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3113 1ae8 0CC08DE5 		str	ip, [sp, #12]
 3114 1aec 10E08DE5 		str	lr, [sp, #16]
 3115 1af0 14708DE5 		str	r7, [sp, #20]
 3116 1af4 FEFFFFEB 		bl	CyU3PDebugPrint
1142:../uvc.c      **** }
 3117              		.loc 1 1142 0
 3118 1af8 5CD08DE2 		add	sp, sp, #92
 3119 1afc F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3120              	.LVL243:
 3121              	.L293:
 928:../uvc.c      ****     switch (bRequest)
 3122              		.loc 1 928 0
 3123 1b00 810055E3 		cmp	r5, #129
 3124 1b04 4200000A 		beq	.L216
 3125 1b08 1100009A 		bls	.L295
 957:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3126              		.loc 1 957 0
 3127 1b0c A0489FE5 		ldr	r4, .L298+8
 3128 1b10 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 958:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3129              		.loc 1 958 0
 3130 1b14 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 959:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3131              		.loc 1 959 0
 3132 1b18 0A0050E3 		cmp	r0, #10
 957:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3133              		.loc 1 957 0
 3134 1b1c 5810C4E5 		strb	r1, [r4, #88]
 958:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3135              		.loc 1 958 0
 3136 1b20 5960C4E5 		strb	r6, [r4, #89]
 959:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3137              		.loc 1 959 0
 3138 1b24 2C00000A 		beq	.L292
 3139              	.LVL244:
 3140              	.L231:
 993:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3141              		.loc 1 993 0
 3142 1b28 00E0A0E3 		mov	lr, #0
 3143 1b2c 5AE0C4E5 		strb	lr, [r4, #90]
 3144              	.L232:
 994:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3145              		.loc 1 994 0
 3146 1b30 0030A0E3 		mov	r3, #0
 995:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3147              		.loc 1 995 0
 3148 1b34 0700A0E1 		mov	r0, r7
 3149              	.LVL245:
 3150 1b38 80189FE5 		ldr	r1, .L298+20
 997:../uvc.c      **** 			  break;
 3151              		.loc 1 997 0
 3152 1b3c FF60A0E3 		mov	r6, #255
 994:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3153              		.loc 1 994 0
 3154 1b40 5B30C4E5 		strb	r3, [r4, #91]
 997:../uvc.c      **** 			  break;
 3155              		.loc 1 997 0
 3156 1b44 0680A0E1 		mov	r8, r6
 995:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3157              		.loc 1 995 0
 3158 1b48 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3159              	.LVL246:
 3160 1b4c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 997:../uvc.c      **** 			  break;
 3161              		.loc 1 997 0
 3162 1b50 DCFFFFEA 		b	.L224
 3163              	.LVL247:
 3164              	.L295:
 928:../uvc.c      ****     switch (bRequest)
 3165              		.loc 1 928 0
 3166 1b54 010055E3 		cmp	r5, #1
 3167 1b58 CDFFFF1A 		bne	.L214
 999:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3168              		.loc 1 999 0
 3169 1b5c 50489FE5 		ldr	r4, .L298+8
 3170 1b60 56208DE2 		add	r2, sp, #86
 3171 1b64 2000A0E3 		mov	r0, #32
 3172              	.LVL248:
 3173 1b68 581084E2 		add	r1, r4, #88
 3174 1b6c 2C308DE5 		str	r3, [sp, #44]
 3175 1b70 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3176              	.LVL249:
1001:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3177              		.loc 1 1001 0
 3178 1b74 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
1002:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3179              		.loc 1 1002 0
 3180 1b78 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
1005:../uvc.c      **** 			  switch(CtrlID)
 3181              		.loc 1 1005 0
 3182 1b7c 012046E2 		sub	r2, r6, #1
1001:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3183              		.loc 1 1001 0
 3184 1b80 30008DE5 		str	r0, [sp, #48]
 3185              	.LVL250:
1002:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3186              		.loc 1 1002 0
 3187 1b84 34C08DE5 		str	ip, [sp, #52]
 3188              	.LVL251:
1005:../uvc.c      **** 			  switch(CtrlID)
 3189              		.loc 1 1005 0
 3190 1b88 2C309DE5 		ldr	r3, [sp, #44]
 3191 1b8c 090052E3 		cmp	r2, #9
 3192 1b90 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3193 1b94 550100EA 		b	.L233
 3194              	.L238:
 3195 1b98 AC200000 		.word	.L234
 3196 1b9c F0200000 		.word	.L233
 3197 1ba0 BC1D0000 		.word	.L235
 3198 1ba4 F0200000 		.word	.L233
 3199 1ba8 F0200000 		.word	.L233
 3200 1bac F0200000 		.word	.L233
 3201 1bb0 381D0000 		.word	.L236
 3202 1bb4 F0200000 		.word	.L233
 3203 1bb8 F0200000 		.word	.L233
 3204 1bbc BC1C0000 		.word	.L237
 3205              	.LVL252:
 3206              	.L219:
 975:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3207              		.loc 1 975 0
 3208 1bc0 EC479FE5 		ldr	r4, .L298+8
 3209 1bc4 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 976:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3210              		.loc 1 976 0
 3211 1bc8 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 977:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3212              		.loc 1 977 0
 3213 1bcc 0A0050E3 		cmp	r0, #10
 975:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3214              		.loc 1 975 0
 3215 1bd0 5880C4E5 		strb	r8, [r4, #88]
 976:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3216              		.loc 1 976 0
 3217 1bd4 5920C4E5 		strb	r2, [r4, #89]
 977:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3218              		.loc 1 977 0
 3219 1bd8 D2FFFF1A 		bne	.L231
 3220              	.LVL253:
 3221              	.L292:
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3222              		.loc 1 992 0 discriminator 1
 3223 1bdc 0110A0E3 		mov	r1, #1
 3224 1be0 5A10C4E5 		strb	r1, [r4, #90]
 3225 1be4 D1FFFFEA 		b	.L232
 3226              	.LVL254:
 3227              	.L220:
 932:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3228              		.loc 1 932 0
 3229 1be8 C4479FE5 		ldr	r4, .L298+8
 933:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3230              		.loc 1 933 0
 3231 1bec 0030A0E3 		mov	r3, #0
 3232              	.LVL255:
 934:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3233              		.loc 1 934 0
 3234 1bf0 0200A0E3 		mov	r0, #2
 3235              	.LVL256:
 3236 1bf4 581084E2 		add	r1, r4, #88
 936:../uvc.c      **** 			  break;
 3237              		.loc 1 936 0
 3238 1bf8 FF60A0E3 		mov	r6, #255
 932:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3239              		.loc 1 932 0
 3240 1bfc 5870C4E5 		strb	r7, [r4, #88]
 933:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3241              		.loc 1 933 0
 3242 1c00 5930C4E5 		strb	r3, [r4, #89]
 936:../uvc.c      **** 			  break;
 3243              		.loc 1 936 0
 3244 1c04 0680A0E1 		mov	r8, r6
 934:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3245              		.loc 1 934 0
 3246 1c08 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3247              	.LVL257:
 3248 1c0c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 936:../uvc.c      **** 			  break;
 3249              		.loc 1 936 0
 3250 1c10 ACFFFFEA 		b	.L224
 3251              	.LVL258:
 3252              	.L216:
 942:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3253              		.loc 1 942 0
 3254 1c14 98479FE5 		ldr	r4, .L298+8
 3255 1c18 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 943:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3256              		.loc 1 943 0
 3257 1c1c 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 944:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3258              		.loc 1 944 0
 3259 1c20 0080A0E3 		mov	r8, #0
 950:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3260              		.loc 1 950 0
 3261 1c24 0700A0E1 		mov	r0, r7
 3262              	.LVL259:
 3263 1c28 581084E2 		add	r1, r4, #88
 955:../uvc.c      **** 			  break;
 3264              		.loc 1 955 0
 3265 1c2c FF60A0E3 		mov	r6, #255
 943:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3266              		.loc 1 943 0
 3267 1c30 59C0C4E5 		strb	ip, [r4, #89]
 944:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3268              		.loc 1 944 0
 3269 1c34 5A80C4E5 		strb	r8, [r4, #90]
 945:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3270              		.loc 1 945 0
 3271 1c38 5B80C4E5 		strb	r8, [r4, #91]
 3272              	.LVL260:
 942:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3273              		.loc 1 942 0
 3274 1c3c 58A0C4E5 		strb	sl, [r4, #88]
 955:../uvc.c      **** 			  break;
 3275              		.loc 1 955 0
 3276 1c40 0680A0E1 		mov	r8, r6
 950:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3277              		.loc 1 950 0
 3278 1c44 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3279              	.LVL261:
 3280 1c48 0AC0A0E1 		mov	ip, sl
 955:../uvc.c      **** 			  break;
 3281              		.loc 1 955 0
 3282 1c4c 9DFFFFEA 		b	.L224
 3283              	.LVL262:
 3284              	.L218:
 966:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3285              		.loc 1 966 0
 3286 1c50 5C479FE5 		ldr	r4, .L298+8
 3287 1c54 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3288              	.LVL263:
 967:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3289              		.loc 1 967 0
 3290 1c58 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 968:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3291              		.loc 1 968 0
 3292 1c5c 0A0050E3 		cmp	r0, #10
 966:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3293              		.loc 1 966 0
 3294 1c60 5830C4E5 		strb	r3, [r4, #88]
 967:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3295              		.loc 1 967 0
 3296 1c64 59E0C4E5 		strb	lr, [r4, #89]
 968:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3297              		.loc 1 968 0
 3298 1c68 AEFFFF1A 		bne	.L231
 3299 1c6c DAFFFFEA 		b	.L292
 3300              	.LVL264:
 3301              	.L294:
 990:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3302              		.loc 1 990 0
 3303 1c70 3C479FE5 		ldr	r4, .L298+8
 3304 1c74 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 991:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3305              		.loc 1 991 0
 3306 1c78 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3307              		.loc 1 992 0
 3308 1c7c 0A0050E3 		cmp	r0, #10
 990:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3309              		.loc 1 990 0
 3310 1c80 5860C4E5 		strb	r6, [r4, #88]
 991:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3311              		.loc 1 991 0
 3312 1c84 59C0C4E5 		strb	ip, [r4, #89]
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3313              		.loc 1 992 0
 3314 1c88 A6FFFF1A 		bne	.L231
 3315 1c8c D2FFFFEA 		b	.L292
 3316              	.L221:
 984:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3317              		.loc 1 984 0
 3318 1c90 1C479FE5 		ldr	r4, .L298+8
 3319 1c94 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3320              	.LVL265:
 3321 1c98 0410A0E1 		mov	r1, r4
 3322 1c9c 5800E1E5 		strb	r0, [r1, #88]!
 988:../uvc.c      **** 			  break;
 3323              		.loc 1 988 0
 3324 1ca0 FF60A0E3 		mov	r6, #255
 985:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3325              		.loc 1 985 0
 3326 1ca4 0100A0E3 		mov	r0, #1
 3327 1ca8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3328              	.LVL266:
 988:../uvc.c      **** 			  break;
 3329              		.loc 1 988 0
 3330 1cac 0680A0E1 		mov	r8, r6
 985:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3331              		.loc 1 985 0
 3332 1cb0 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 988:../uvc.c      **** 			  break;
 3333              		.loc 1 988 0
 3334 1cb4 0170A0E3 		mov	r7, #1
 3335 1cb8 82FFFFEA 		b	.L224
 3336              	.LVL267:
 3337              	.L237:
1114:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3338              		.loc 1 1114 0
 3339 1cbc 00679FE5 		ldr	r6, .L298+24
 3340 1cc0 0010E0E3 		mvn	r1, #0
 3341 1cc4 1C0096E5 		ldr	r0, [r6, #28]
 3342 1cc8 2C308DE5 		str	r3, [sp, #44]
 3343 1ccc FEFFFFEB 		bl	_txe_mutex_get
1115:../uvc.c      **** 					  if(getData == 1)
 3344              		.loc 1 1115 0
 3345 1cd0 30E09DE5 		ldr	lr, [sp, #48]
 3346 1cd4 2C309DE5 		ldr	r3, [sp, #44]
 3347 1cd8 01005EE3 		cmp	lr, #1
 3348 1cdc AA01000A 		beq	.L296
1117:../uvc.c      **** 					  else if(getData == 0xff)
 3349              		.loc 1 1117 0
 3350 1ce0 FF005EE3 		cmp	lr, #255
 3351 1ce4 9F01000A 		beq	.L297
1120:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 3352              		.loc 1 1120 0
 3353 1ce8 0080A0E3 		mov	r8, #0
 3354 1cec 0600A0E1 		mov	r0, r6
 3355 1cf0 2310A0E3 		mov	r1, #35
 3356 1cf4 0B20A0E1 		mov	r2, fp
 3357 1cf8 00808DE5 		str	r8, [sp, #0]
 3358 1cfc 04808DE5 		str	r8, [sp, #4]
 3359 1d00 FEFFFFEB 		bl	cmdSet
 3360              	.L290:
1123:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3361              		.loc 1 1123 0
 3362 1d04 1C0096E5 		ldr	r0, [r6, #28]
 3363 1d08 FEFFFFEB 		bl	_txe_mutex_put
1125:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3364              		.loc 1 1125 0
 3365 1d0c 30809DE5 		ldr	r8, [sp, #48]
 3366 1d10 34609DE5 		ldr	r6, [sp, #52]
 3367 1d14 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3368 1d18 0400A0E3 		mov	r0, #4
 3369 1d1c A4169FE5 		ldr	r1, .L298+28
 3370 1d20 0820A0E1 		mov	r2, r8
 3371 1d24 0630A0E1 		mov	r3, r6
 3372 1d28 00C08DE5 		str	ip, [sp, #0]
 3373 1d2c FEFFFFEB 		bl	CyU3PDebugPrint
1126:../uvc.c      **** 					  break;
 3374              		.loc 1 1126 0
 3375 1d30 FFC0A0E3 		mov	ip, #255
 3376 1d34 63FFFFEA 		b	.L224
 3377              	.LVL268:
 3378              	.L236:
1091:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3379              		.loc 1 1091 0
 3380 1d38 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3381 1d3c 010058E3 		cmp	r8, #1
 3382 1d40 08005813 		cmpne	r8, #8
 3383 1d44 0000A013 		movne	r0, #0
 3384 1d48 0100A003 		moveq	r0, #1
 3385 1d4c 8101001A 		bne	.L287
 3386              	.LVL269:
1094:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3387              		.loc 1 1094 0
 3388 1d50 6C869FE5 		ldr	r8, .L298+24
 3389 1d54 0010E0E3 		mvn	r1, #0
 3390 1d58 1C0098E5 		ldr	r0, [r8, #28]
 3391 1d5c 2C308DE5 		str	r3, [sp, #44]
 3392 1d60 FEFFFFEB 		bl	_txe_mutex_get
1095:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3393              		.loc 1 1095 0
 3394 1d64 30A09DE5 		ldr	sl, [sp, #48]
 3395 1d68 2210A0E3 		mov	r1, #34
 3396 1d6c 0B20A0E1 		mov	r2, fp
 3397 1d70 2C309DE5 		ldr	r3, [sp, #44]
 3398 1d74 00C0A0E3 		mov	ip, #0
 3399 1d78 0800A0E1 		mov	r0, r8
 3400 1d7c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3401 1d80 FEFFFFEB 		bl	cmdSet
1096:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3402              		.loc 1 1096 0
 3403 1d84 1C0098E5 		ldr	r0, [r8, #28]
 3404 1d88 FEFFFFEB 		bl	_txe_mutex_put
1099:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3405              		.loc 1 1099 0
 3406 1d8c 1C069FE5 		ldr	r0, .L298+4
1100:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3407              		.loc 1 1100 0
 3408 1d90 34209DE5 		ldr	r2, [sp, #52]
1099:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3409              		.loc 1 1099 0
 3410 1d94 061089E0 		add	r1, r9, r6
 3411 1d98 813180E0 		add	r3, r0, r1, asl #3
1101:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3412              		.loc 1 1101 0
 3413 1d9c 0160A0E3 		mov	r6, #1
1099:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3414              		.loc 1 1099 0
 3415 1da0 9DA4C3E5 		strb	sl, [r3, #1181]
1100:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3416              		.loc 1 1100 0
 3417 1da4 9E24C3E5 		strb	r2, [r3, #1182]
1101:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3418              		.loc 1 1101 0
 3419 1da8 A064C3E5 		strb	r6, [r3, #1184]
 3420              	.LVL270:
 3421              	.L288:
1103:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3422              		.loc 1 1103 0
 3423 1dac 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3424 1db0 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1108:../uvc.c      **** 					  break;
 3425              		.loc 1 1108 0
 3426 1db4 FFC0A0E3 		mov	ip, #255
 3427 1db8 42FFFFEA 		b	.L224
 3428              	.LVL271:
 3429              	.L235:
1057:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3430              		.loc 1 1057 0
 3431 1dbc B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3432 1dc0 010050E3 		cmp	r0, #1
 3433 1dc4 04005013 		cmpne	r0, #4
 3434 1dc8 5D01001A 		bne	.L245
1056:../uvc.c      **** 					  value = (value << 8)|Data0;
 3435              		.loc 1 1056 0
 3436 1dcc 30109DE5 		ldr	r1, [sp, #48]
 3437 1dd0 34E09DE5 		ldr	lr, [sp, #52]
 3438 1dd4 0E2481E1 		orr	r2, r1, lr, asl #8
1058:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3439              		.loc 1 1058 0
 3440 1dd8 F90052E3 		cmp	r2, #249
 3441 1ddc 5801008A 		bhi	.L245
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3442              		.loc 1 1063 0
 3443 1de0 C8A042E2 		sub	sl, r2, #200
 3444 1de4 0AC8A0E1 		mov	ip, sl, asl #16
 3445 1de8 3CC08DE5 		str	ip, [sp, #60]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3446              		.loc 1 1065 0
 3447 1dec 27A062E2 		rsb	sl, r2, #39
 3448 1df0 38A08DE5 		str	sl, [sp, #56]
 3449 1df4 3CA09DE5 		ldr	sl, [sp, #60]
 3450 1df8 C81062E2 		rsb	r1, r2, #200
 3451 1dfc C80052E3 		cmp	r2, #200
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3452              		.loc 1 1063 0
 3453 1e00 640042E2 		sub	r0, r2, #100
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3454              		.loc 1 1065 0
 3455 1e04 0118A0E1 		mov	r1, r1, asl #16
 3456 1e08 64E062E2 		rsb	lr, r2, #100
 3457 1e0c 2A18A081 		movhi	r1, sl, lsr #16
 3458 1e10 2118A091 		movls	r1, r1, lsr #16
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3459              		.loc 1 1063 0
 3460 1e14 00C8A0E1 		mov	ip, r0, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3461              		.loc 1 1065 0
 3462 1e18 640052E3 		cmp	r2, #100
 3463 1e1c 0E08A0E1 		mov	r0, lr, asl #16
 3464 1e20 2C08A081 		movhi	r0, ip, lsr #16
 3465 1e24 38C09DE5 		ldr	ip, [sp, #56]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3466              		.loc 1 1063 0
 3467 1e28 14A042E2 		sub	sl, r2, #20
 3468 1e2c 38A08DE5 		str	sl, [sp, #56]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3469              		.loc 1 1065 0
 3470 1e30 2008A091 		movls	r0, r0, lsr #16
 3471 1e34 14A062E2 		rsb	sl, r2, #20
 3472 1e38 3CA08DE5 		str	sl, [sp, #60]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3473              		.loc 1 1063 0
 3474 1e3c 27E042E2 		sub	lr, r2, #39
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3475              		.loc 1 1065 0
 3476 1e40 000051E1 		cmp	r1, r0
 3477 1e44 01A0A031 		movcc	sl, r1
 3478 1e48 00A0A021 		movcs	sl, r0
 3479 1e4c 0CC8A0E1 		mov	ip, ip, asl #16
 3480 1e50 270052E3 		cmp	r2, #39
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3481              		.loc 1 1063 0
 3482 1e54 0EE8A0E1 		mov	lr, lr, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3483              		.loc 1 1065 0
 3484 1e58 2CE8A091 		movls	lr, ip, lsr #16
 3485 1e5c 68C59FE5 		ldr	ip, .L298+32
 3486 1e60 20A08DE5 		str	sl, [sp, #32]
 3487 1e64 01A06CE0 		rsb	sl, ip, r1
 3488 1e68 2EE8A081 		movhi	lr, lr, lsr #16
 3489 1e6c 00C07AE2 		rsbs	ip, sl, #0
 3490 1e70 0AC0ACE0 		adc	ip, ip, sl
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3491              		.loc 1 1063 0
 3492 1e74 38A09DE5 		ldr	sl, [sp, #56]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3493              		.loc 1 1065 0
 3494 1e78 44C08DE5 		str	ip, [sp, #68]
 3495              	.LVL272:
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3496              		.loc 1 1063 0
 3497 1e7c 0AC8A0E1 		mov	ip, sl, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3498              		.loc 1 1065 0
 3499 1e80 3CA09DE5 		ldr	sl, [sp, #60]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3500              		.loc 1 1063 0
 3501 1e84 4CC08DE5 		str	ip, [sp, #76]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3502              		.loc 1 1065 0
 3503 1e88 0AC8A0E1 		mov	ip, sl, asl #16
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3504              		.loc 1 1063 0
 3505 1e8c 0AA042E2 		sub	sl, r2, #10
 3506 1e90 48A08DE5 		str	sl, [sp, #72]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3507              		.loc 1 1065 0
 3508 1e94 20A09DE5 		ldr	sl, [sp, #32]
 3509 1e98 3CC08DE5 		str	ip, [sp, #60]
 3510 1e9c 0A005EE1 		cmp	lr, sl
 3511 1ea0 0EA0A031 		movcc	sl, lr
 3512 1ea4 0AC062E2 		rsb	ip, r2, #10
 3513 1ea8 40C08DE5 		str	ip, [sp, #64]
 3514 1eac 38A08DE5 		str	sl, [sp, #56]
 3515 1eb0 3CC09DE5 		ldr	ip, [sp, #60]
 3516 1eb4 4CA09DE5 		ldr	sl, [sp, #76]
 3517 1eb8 140052E3 		cmp	r2, #20
 3518 1ebc 2CA8A091 		movls	sl, ip, lsr #16
 3519 1ec0 2AA8A081 		movhi	sl, sl, lsr #16
 3520 1ec4 44C09DE5 		ldr	ip, [sp, #68]
 3521 1ec8 010050E1 		cmp	r0, r1
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3522              		.loc 1 1063 0
 3523 1ecc 48109DE5 		ldr	r1, [sp, #72]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3524              		.loc 1 1065 0
 3525 1ed0 01C0A033 		movcc	ip, #1
 3526 1ed4 3CA08DE5 		str	sl, [sp, #60]
 3527 1ed8 24C08DE5 		str	ip, [sp, #36]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3528              		.loc 1 1063 0
 3529 1edc 01A8A0E1 		mov	sl, r1, asl #16
 3530 1ee0 05C042E2 		sub	ip, r2, #5
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3531              		.loc 1 1065 0
 3532 1ee4 051062E2 		rsb	r1, r2, #5
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3533              		.loc 1 1063 0
 3534 1ee8 48A08DE5 		str	sl, [sp, #72]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3535              		.loc 1 1065 0
 3536 1eec 40009DE5 		ldr	r0, [sp, #64]
 3537 1ef0 38A09DE5 		ldr	sl, [sp, #56]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3538              		.loc 1 1063 0
 3539 1ef4 40C08DE5 		str	ip, [sp, #64]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3540              		.loc 1 1065 0
 3541 1ef8 3CC09DE5 		ldr	ip, [sp, #60]
 3542 1efc 4C108DE5 		str	r1, [sp, #76]
 3543 1f00 48109DE5 		ldr	r1, [sp, #72]
 3544 1f04 0008A0E1 		mov	r0, r0, asl #16
 3545 1f08 0A005CE1 		cmp	ip, sl
 3546 1f0c 0AC0A021 		movcs	ip, sl
 3547 1f10 0A0052E3 		cmp	r2, #10
 3548 1f14 20A09DE5 		ldr	sl, [sp, #32]
 3549 1f18 2108A081 		movhi	r0, r1, lsr #16
 3550 1f1c 2008A091 		movls	r0, r0, lsr #16
 3551 1f20 48008DE5 		str	r0, [sp, #72]
 3552 1f24 24009DE5 		ldr	r0, [sp, #36]
 3553 1f28 0A005EE1 		cmp	lr, sl
 3554 1f2c 0200A033 		movcc	r0, #2
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3555              		.loc 1 1063 0
 3556 1f30 02E042E2 		sub	lr, r2, #2
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3557              		.loc 1 1065 0
 3558 1f34 44C08DE5 		str	ip, [sp, #68]
 3559 1f38 24008DE5 		str	r0, [sp, #36]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3560              		.loc 1 1063 0
 3561 1f3c 40C09DE5 		ldr	ip, [sp, #64]
 3562 1f40 1CE08DE5 		str	lr, [sp, #28]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3563              		.loc 1 1065 0
 3564 1f44 44009DE5 		ldr	r0, [sp, #68]
 3565 1f48 48E09DE5 		ldr	lr, [sp, #72]
 3566 1f4c 4C109DE5 		ldr	r1, [sp, #76]
 3567 1f50 02A062E2 		rsb	sl, r2, #2
 3568 1f54 00005EE1 		cmp	lr, r0
 3569 1f58 00E0A021 		movcs	lr, r0
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3570              		.loc 1 1063 0
 3571 1f5c 0CC8A0E1 		mov	ip, ip, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3572              		.loc 1 1065 0
 3573 1f60 050052E3 		cmp	r2, #5
 3574 1f64 40A08DE5 		str	sl, [sp, #64]
 3575 1f68 0118A0E1 		mov	r1, r1, asl #16
 3576 1f6c 3CA09DE5 		ldr	sl, [sp, #60]
 3577 1f70 2C18A081 		movhi	r1, ip, lsr #16
 3578 1f74 38C09DE5 		ldr	ip, [sp, #56]
 3579 1f78 4CE08DE5 		str	lr, [sp, #76]
 3580 1f7c 24009DE5 		ldr	r0, [sp, #36]
 3581 1f80 40E09DE5 		ldr	lr, [sp, #64]
 3582 1f84 2118A091 		movls	r1, r1, lsr #16
 3583 1f88 0C005AE1 		cmp	sl, ip
 3584 1f8c 20108DE5 		str	r1, [sp, #32]
 3585 1f90 0300A033 		movcc	r0, #3
 3586 1f94 38008DE5 		str	r0, [sp, #56]
 3587 1f98 4CA09DE5 		ldr	sl, [sp, #76]
 3588 1f9c 0E08A0E1 		mov	r0, lr, asl #16
 3589 1fa0 20E09DE5 		ldr	lr, [sp, #32]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3590              		.loc 1 1063 0
 3591 1fa4 1C109DE5 		ldr	r1, [sp, #28]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3592              		.loc 1 1065 0
 3593 1fa8 0A005EE1 		cmp	lr, sl
 3594 1fac 0AE0A021 		movcs	lr, sl
 3595 1fb0 44C09DE5 		ldr	ip, [sp, #68]
 3596 1fb4 48A09DE5 		ldr	sl, [sp, #72]
 3597 1fb8 020052E3 		cmp	r2, #2
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3598              		.loc 1 1063 0
 3599 1fbc 0118A0E1 		mov	r1, r1, asl #16
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3600              		.loc 1 1065 0
 3601 1fc0 2018A091 		movls	r1, r0, lsr #16
 3602 1fc4 38009DE5 		ldr	r0, [sp, #56]
 3603 1fc8 2118A081 		movhi	r1, r1, lsr #16
 3604 1fcc 0C005AE1 		cmp	sl, ip
 3605 1fd0 0400A033 		movcc	r0, #4
 3606 1fd4 40008DE5 		str	r0, [sp, #64]
1063:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3607              		.loc 1 1063 0
 3608 1fd8 010042E2 		sub	r0, r2, #1
 3609 1fdc 38008DE5 		str	r0, [sp, #56]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3610              		.loc 1 1065 0
 3611 1fe0 4CA09DE5 		ldr	sl, [sp, #76]
 3612 1fe4 20009DE5 		ldr	r0, [sp, #32]
 3613 1fe8 01C062E2 		rsb	ip, r2, #1
 3614 1fec 3CC08DE5 		str	ip, [sp, #60]
 3615 1ff0 0A0050E1 		cmp	r0, sl
1072:../uvc.c      **** 						  shutter = shutter+index;
 3616              		.loc 1 1072 0
 3617 1ff4 38A09DE5 		ldr	sl, [sp, #56]
 3618 1ff8 3C009DE5 		ldr	r0, [sp, #60]
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3619              		.loc 1 1065 0
 3620 1ffc 40C09DE5 		ldr	ip, [sp, #64]
 3621 2000 05C0A033 		movcc	ip, #5
1072:../uvc.c      **** 						  shutter = shutter+index;
 3622              		.loc 1 1072 0
 3623 2004 010052E3 		cmp	r2, #1
 3624 2008 0028A091 		movls	r2, r0, asl #16
 3625 200c 0A28A081 		movhi	r2, sl, asl #16
 3626 2010 0E0051E1 		cmp	r1, lr
 3627 2014 01A0A031 		movcc	sl, r1
 3628 2018 0EA0A021 		movcs	sl, lr
1065:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3629              		.loc 1 1065 0
 3630 201c 0E0051E1 		cmp	r1, lr
 3631 2020 0C10A021 		movcs	r1, ip
 3632 2024 0610A033 		movcc	r1, #6
1072:../uvc.c      **** 						  shutter = shutter+index;
 3633              		.loc 1 1072 0
 3634 2028 22085AE1 		cmp	sl, r2, lsr #16
1075:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3635              		.loc 1 1075 0
 3636 202c 90A39FE5 		ldr	sl, .L298+24
1072:../uvc.c      **** 						  shutter = shutter+index;
 3637              		.loc 1 1072 0
 3638 2030 0120A091 		movls	r2, r1
 3639 2034 0720A083 		movhi	r2, #7
 3640 2038 012082E2 		add	r2, r2, #1
 3641 203c FFE002E2 		and	lr, r2, #255
1075:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3642              		.loc 1 1075 0
 3643 2040 0010E0E3 		mvn	r1, #0
 3644 2044 1C009AE5 		ldr	r0, [sl, #28]
1072:../uvc.c      **** 						  shutter = shutter+index;
 3645              		.loc 1 1072 0
 3646 2048 38E08DE5 		str	lr, [sp, #56]
 3647              	.LVL273:
1075:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3648              		.loc 1 1075 0
 3649 204c 2C308DE5 		str	r3, [sp, #44]
 3650 2050 FEFFFFEB 		bl	_txe_mutex_get
1076:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3651              		.loc 1 1076 0
 3652 2054 38C09DE5 		ldr	ip, [sp, #56]
 3653 2058 0310A0E3 		mov	r1, #3
 3654 205c 0B20A0E1 		mov	r2, fp
 3655 2060 2C309DE5 		ldr	r3, [sp, #44]
 3656 2064 00C08DE5 		str	ip, [sp, #0]
 3657 2068 0A00A0E1 		mov	r0, sl
 3658 206c 00C0A0E3 		mov	ip, #0
 3659 2070 04C08DE5 		str	ip, [sp, #4]
 3660 2074 FEFFFFEB 		bl	cmdSet
1077:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3661              		.loc 1 1077 0
 3662 2078 1C009AE5 		ldr	r0, [sl, #28]
 3663 207c FEFFFFEB 		bl	_txe_mutex_put
1080:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3664              		.loc 1 1080 0
 3665 2080 30009DE5 		ldr	r0, [sp, #48]
1081:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3666              		.loc 1 1081 0
 3667 2084 34C09DE5 		ldr	ip, [sp, #52]
1083:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3668              		.loc 1 1083 0
 3669 2088 38309DE5 		ldr	r3, [sp, #56]
1080:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3670              		.loc 1 1080 0
 3671 208c 061089E0 		add	r1, r9, r6
 3672 2090 816188E0 		add	r6, r8, r1, asl #3
1082:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3673              		.loc 1 1082 0
 3674 2094 0120A0E3 		mov	r2, #1
1080:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3675              		.loc 1 1080 0
 3676 2098 9D04C6E5 		strb	r0, [r6, #1181]
1081:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3677              		.loc 1 1081 0
 3678 209c 9EC4C6E5 		strb	ip, [r6, #1182]
1082:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3679              		.loc 1 1082 0
 3680 20a0 A024C6E5 		strb	r2, [r6, #1184]
1083:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3681              		.loc 1 1083 0
 3682 20a4 0D33C8E5 		strb	r3, [r8, #781]
 3683 20a8 3FFFFFEA 		b	.L288
 3684              	.LVL274:
 3685              	.L234:
1010:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3686              		.loc 1 1010 0
 3687 20ac 062089E0 		add	r2, r9, r6
 3688 20b0 826188E0 		add	r6, r8, r2, asl #3
1011:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3689              		.loc 1 1011 0
 3690 20b4 0110A0E3 		mov	r1, #1
1014:../uvc.c      **** 		  		    switch (getData){
 3691              		.loc 1 1014 0
 3692 20b8 01E040E2 		sub	lr, r0, #1
1010:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3693              		.loc 1 1010 0
 3694 20bc 9D04C6E5 		strb	r0, [r6, #1181]
1011:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3695              		.loc 1 1011 0
 3696 20c0 A014C6E5 		strb	r1, [r6, #1184]
 3697              	.LVL275:
1014:../uvc.c      **** 		  		    switch (getData){
 3698              		.loc 1 1014 0
 3699 20c4 07005EE3 		cmp	lr, #7
 3700 20c8 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3701 20cc 980000EA 		b	.L239
 3702              	.L244:
 3703 20d0 C8220000 		.word	.L240
 3704 20d4 2C220000 		.word	.L241
 3705 20d8 34230000 		.word	.L239
 3706 20dc C4210000 		.word	.L242
 3707 20e0 34230000 		.word	.L239
 3708 20e4 34230000 		.word	.L239
 3709 20e8 34230000 		.word	.L239
 3710 20ec 24210000 		.word	.L243
 3711              	.LVL276:
 3712              	.L233:
1130:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3713              		.loc 1 1130 0
 3714 20f0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1129:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3715              		.loc 1 1129 0
 3716 20f4 30A09DE5 		ldr	sl, [sp, #48]
 3717 20f8 069089E0 		add	r9, r9, r6
 3718 20fc 89E188E0 		add	lr, r8, r9, asl #3
1130:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3719              		.loc 1 1130 0
 3720 2100 0620A0E1 		mov	r2, r6
 3721 2104 0400A0E3 		mov	r0, #4
 3722 2108 C0129FE5 		ldr	r1, .L298+36
1129:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3723              		.loc 1 1129 0
 3724 210c 9DA4CEE5 		strb	sl, [lr, #1181]
1130:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3725              		.loc 1 1130 0
 3726 2110 FEFFFFEB 		bl	CyU3PDebugPrint
1131:../uvc.c      **** 			  		 break;
 3727              		.loc 1 1131 0
 3728 2114 FFC0A0E3 		mov	ip, #255
 3729 2118 0C60A0E1 		mov	r6, ip
 3730 211c 0C80A0E1 		mov	r8, ip
 3731 2120 68FEFFEA 		b	.L224
 3732              	.LVL277:
 3733              	.L243:
1033:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3734              		.loc 1 1033 0
 3735 2124 98629FE5 		ldr	r6, .L298+24
1031:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3736              		.loc 1 1031 0
 3737 2128 00A0A0E3 		mov	sl, #0
1033:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3738              		.loc 1 1033 0
 3739 212c 1C0096E5 		ldr	r0, [r6, #28]
1031:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3740              		.loc 1 1031 0
 3741 2130 0DA3C8E5 		strb	sl, [r8, #781]
 3742              	.LVL278:
1033:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3743              		.loc 1 1033 0
 3744 2134 0010E0E3 		mvn	r1, #0
 3745 2138 2C308DE5 		str	r3, [sp, #44]
 3746 213c FEFFFFEB 		bl	_txe_mutex_get
1034:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3747              		.loc 1 1034 0
 3748 2140 0B20A0E1 		mov	r2, fp
 3749 2144 2C309DE5 		ldr	r3, [sp, #44]
 3750 2148 1010A0E3 		mov	r1, #16
 3751 214c 0600A0E1 		mov	r0, r6
 3752 2150 00A08DE5 		str	sl, [sp, #0]
 3753 2154 04A08DE5 		str	sl, [sp, #4]
 3754 2158 FEFFFFEB 		bl	cmdSet
1035:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3755              		.loc 1 1035 0
 3756 215c 1C0096E5 		ldr	r0, [r6, #28]
 3757 2160 FEFFFFEB 		bl	_txe_mutex_put
 3758              	.LVL279:
 3759              	.LBB66:
 3760              	.LBB67:
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3761              		.loc 1 387 0
 3762 2164 0010E0E3 		mvn	r1, #0
 3763 2168 1C0096E5 		ldr	r0, [r6, #28]
 3764 216c FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3765              		.loc 1 388 0
 3766 2170 01C0A0E3 		mov	ip, #1
 3767 2174 2010A0E3 		mov	r1, #32
 3768 2178 2720A0E3 		mov	r2, #39
 3769 217c 3030A0E3 		mov	r3, #48
 3770 2180 0600A0E1 		mov	r0, r6
 3771 2184 00C08DE5 		str	ip, [sp, #0]
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3772              		.loc 1 389 0
 3773 2188 0280A0E3 		mov	r8, #2
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3774              		.loc 1 388 0
 3775 218c 04A08DE5 		str	sl, [sp, #4]
 3776 2190 FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3777              		.loc 1 389 0
 3778 2194 2110A0E3 		mov	r1, #33
 3779 2198 2520A0E3 		mov	r2, #37
 3780 219c 3030A0E3 		mov	r3, #48
 3781 21a0 0600A0E1 		mov	r0, r6
 3782 21a4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3783 21a8 FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3784              		.loc 1 390 0
 3785 21ac 1C0096E5 		ldr	r0, [r6, #28]
 3786 21b0 FEFFFFEB 		bl	_txe_mutex_put
 3787              	.LBE67:
 3788              	.LBE66:
1037:../uvc.c      **** 							break;
 3789              		.loc 1 1037 0
 3790 21b4 FFC0A0E3 		mov	ip, #255
 3791 21b8 0C60A0E1 		mov	r6, ip
 3792 21bc 0880A0E3 		mov	r8, #8
 3793 21c0 40FEFFEA 		b	.L224
 3794              	.LVL280:
 3795              	.L242:
 3796              	.LBB68:
 3797              	.LBB69:
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3798              		.loc 1 387 0
 3799 21c4 F8619FE5 		ldr	r6, .L298+24
 3800 21c8 0010E0E3 		mvn	r1, #0
 3801 21cc 1C0096E5 		ldr	r0, [r6, #28]
 3802 21d0 FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3803              		.loc 1 388 0
 3804 21d4 0080A0E3 		mov	r8, #0
 3805 21d8 2010A0E3 		mov	r1, #32
 3806 21dc 2720A0E3 		mov	r2, #39
 3807 21e0 3030A0E3 		mov	r3, #48
 3808 21e4 0600A0E1 		mov	r0, r6
 3809 21e8 00808DE5 		str	r8, [sp, #0]
 3810 21ec 04808DE5 		str	r8, [sp, #4]
 3811 21f0 FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3812              		.loc 1 389 0
 3813 21f4 01C0A0E3 		mov	ip, #1
 3814 21f8 2110A0E3 		mov	r1, #33
 3815 21fc 2520A0E3 		mov	r2, #37
 3816 2200 3030A0E3 		mov	r3, #48
 3817 2204 0600A0E1 		mov	r0, r6
 3818 2208 00C08DE5 		str	ip, [sp, #0]
 3819 220c 04808DE5 		str	r8, [sp, #4]
 3820 2210 FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3821              		.loc 1 390 0
 3822 2214 1C0096E5 		ldr	r0, [r6, #28]
 3823 2218 FEFFFFEB 		bl	_txe_mutex_put
 3824 221c FFC0A0E3 		mov	ip, #255
 3825 2220 0C60A0E1 		mov	r6, ip
 3826 2224 0480A0E3 		mov	r8, #4
 3827 2228 26FEFFEA 		b	.L224
 3828              	.LVL281:
 3829              	.L241:
 3830              	.LBE69:
 3831              	.LBE68:
1021:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3832              		.loc 1 1021 0
 3833 222c 90619FE5 		ldr	r6, .L298+24
1019:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3834              		.loc 1 1019 0
 3835 2230 00A0A0E3 		mov	sl, #0
1021:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3836              		.loc 1 1021 0
 3837 2234 1C0096E5 		ldr	r0, [r6, #28]
1019:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3838              		.loc 1 1019 0
 3839 2238 0DA3C8E5 		strb	sl, [r8, #781]
 3840              	.LVL282:
1021:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3841              		.loc 1 1021 0
 3842 223c 0010E0E3 		mvn	r1, #0
 3843 2240 2C308DE5 		str	r3, [sp, #44]
 3844 2244 FEFFFFEB 		bl	_txe_mutex_get
1022:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3845              		.loc 1 1022 0
 3846 2248 0B20A0E1 		mov	r2, fp
 3847 224c 2C309DE5 		ldr	r3, [sp, #44]
 3848 2250 1010A0E3 		mov	r1, #16
 3849 2254 0600A0E1 		mov	r0, r6
 3850 2258 00A08DE5 		str	sl, [sp, #0]
 3851 225c 04A08DE5 		str	sl, [sp, #4]
 3852 2260 FEFFFFEB 		bl	cmdSet
1023:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3853              		.loc 1 1023 0
 3854 2264 1C0096E5 		ldr	r0, [r6, #28]
 3855 2268 FEFFFFEB 		bl	_txe_mutex_put
 3856              	.LVL283:
 3857              	.LBB70:
 3858              	.LBB71:
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3859              		.loc 1 387 0
 3860 226c 0010E0E3 		mvn	r1, #0
 3861 2270 1C0096E5 		ldr	r0, [r6, #28]
 3862 2274 FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3863              		.loc 1 388 0
 3864 2278 2010A0E3 		mov	r1, #32
 3865 227c 2720A0E3 		mov	r2, #39
 3866 2280 3030A0E3 		mov	r3, #48
 3867 2284 0600A0E1 		mov	r0, r6
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3868              		.loc 1 389 0
 3869 2288 0180A0E3 		mov	r8, #1
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3870              		.loc 1 388 0
 3871 228c 00A08DE5 		str	sl, [sp, #0]
 3872 2290 04A08DE5 		str	sl, [sp, #4]
 3873 2294 FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3874              		.loc 1 389 0
 3875 2298 2110A0E3 		mov	r1, #33
 3876 229c 2520A0E3 		mov	r2, #37
 3877 22a0 3030A0E3 		mov	r3, #48
 3878 22a4 0600A0E1 		mov	r0, r6
 3879 22a8 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3880 22ac FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3881              		.loc 1 390 0
 3882 22b0 1C0096E5 		ldr	r0, [r6, #28]
 3883 22b4 FEFFFFEB 		bl	_txe_mutex_put
 3884 22b8 FFC0A0E3 		mov	ip, #255
 3885 22bc 0C60A0E1 		mov	r6, ip
 3886 22c0 0280A0E3 		mov	r8, #2
 3887 22c4 FFFDFFEA 		b	.L224
 3888              	.LVL284:
 3889              	.L240:
 3890              	.LBE71:
 3891              	.LBE70:
 3892              	.LBB72:
 3893              	.LBB73:
 387:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3894              		.loc 1 387 0
 3895 22c8 F4609FE5 		ldr	r6, .L298+24
 3896 22cc 0010E0E3 		mvn	r1, #0
 3897 22d0 1C0096E5 		ldr	r0, [r6, #28]
 3898 22d4 FEFFFFEB 		bl	_txe_mutex_get
 388:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3899              		.loc 1 388 0
 3900 22d8 0080A0E3 		mov	r8, #0
 3901 22dc 01A0A0E3 		mov	sl, #1
 3902 22e0 2010A0E3 		mov	r1, #32
 3903 22e4 2720A0E3 		mov	r2, #39
 3904 22e8 3030A0E3 		mov	r3, #48
 3905 22ec 0600A0E1 		mov	r0, r6
 3906 22f0 04808DE5 		str	r8, [sp, #4]
 3907 22f4 00A08DE5 		str	sl, [sp, #0]
 3908 22f8 FEFFFFEB 		bl	cmdSet
 389:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3909              		.loc 1 389 0
 3910 22fc 02C0A0E3 		mov	ip, #2
 3911 2300 2110A0E3 		mov	r1, #33
 3912 2304 2520A0E3 		mov	r2, #37
 3913 2308 3030A0E3 		mov	r3, #48
 3914 230c 0600A0E1 		mov	r0, r6
 3915 2310 00C08DE5 		str	ip, [sp, #0]
 3916 2314 04808DE5 		str	r8, [sp, #4]
 3917 2318 FEFFFFEB 		bl	cmdSet
 390:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3918              		.loc 1 390 0
 3919 231c 1C0096E5 		ldr	r0, [r6, #28]
 3920 2320 FEFFFFEB 		bl	_txe_mutex_put
 3921              	.LBE73:
 3922              	.LBE72:
1017:../uvc.c      **** 							break;
 3923              		.loc 1 1017 0
 3924 2324 FFC0A0E3 		mov	ip, #255
 3925 2328 0C60A0E1 		mov	r6, ip
 3926 232c 0A80A0E1 		mov	r8, sl
 3927 2330 E4FDFFEA 		b	.L224
 3928              	.LVL285:
 3929              	.L239:
1014:../uvc.c      **** 		  		    switch (getData){
 3930              		.loc 1 1014 0
 3931 2334 FFC0A0E3 		mov	ip, #255
 3932 2338 0080A0E1 		mov	r8, r0
 3933 233c 0C60A0E1 		mov	r6, ip
 3934 2340 E0FDFFEA 		b	.L224
 3935              	.LVL286:
 3936              	.L245:
1085:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3937              		.loc 1 1085 0
 3938 2344 0000A0E3 		mov	r0, #0
 3939 2348 0110A0E3 		mov	r1, #1
 3940 234c 0020A0E1 		mov	r2, r0
 3941 2350 FEFFFFEB 		bl	CyU3PUsbStall
 3942              	.LVL287:
 3943 2354 94FEFFEA 		b	.L288
 3944              	.LVL288:
 3945              	.L287:
1103:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3946              		.loc 1 1103 0
 3947 2358 0110A0E3 		mov	r1, #1
 3948 235c 0020A0E1 		mov	r2, r0
 3949 2360 FEFFFFEB 		bl	CyU3PUsbStall
 3950 2364 90FEFFEA 		b	.L288
 3951              	.LVL289:
 3952              	.L297:
1118:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3953              		.loc 1 1118 0
 3954 2368 08E0A0E3 		mov	lr, #8
 3955 236c 00C0A0E3 		mov	ip, #0
 3956 2370 0600A0E1 		mov	r0, r6
 3957 2374 2310A0E3 		mov	r1, #35
 3958 2378 0B20A0E1 		mov	r2, fp
 3959 237c 00E08DE5 		str	lr, [sp, #0]
 3960 2380 04C08DE5 		str	ip, [sp, #4]
 3961 2384 FEFFFFEB 		bl	cmdSet
 3962 2388 5DFEFFEA 		b	.L290
 3963              	.L296:
1116:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3964              		.loc 1 1116 0
 3965 238c 0480A0E3 		mov	r8, #4
 3966 2390 00E0A0E3 		mov	lr, #0
 3967 2394 0600A0E1 		mov	r0, r6
 3968 2398 2310A0E3 		mov	r1, #35
 3969 239c 0B20A0E1 		mov	r2, fp
 3970 23a0 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3971 23a4 FEFFFFEB 		bl	cmdSet
 3972 23a8 55FEFFEA 		b	.L290
 3973              	.L299:
 3974              		.align	2
 3975              	.L298:
 3976 23ac 00000000 		.word	bRequest
 3977 23b0 00000000 		.word	.LANCHOR1
 3978 23b4 00000000 		.word	.LANCHOR0
 3979 23b8 10040000 		.word	.LC25
 3980 23bc 34040000 		.word	.LC26
 3981 23c0 58000000 		.word	.LANCHOR0+88
 3982 23c4 00000000 		.word	cmdQu
 3983 23c8 C4030000 		.word	.LC23
 3984 23cc FFFF0000 		.word	65535
 3985 23d0 EC030000 		.word	.LC24
 3986              		.cfi_endproc
 3987              	.LFE3:
 3989              		.align	2
 3990              		.global	UVCAppEP0Thread_Entry
 3992              	UVCAppEP0Thread_Entry:
 3993              	.LFB24:
3188:../uvc.c      **** {
 3994              		.loc 1 3188 0
 3995              		.cfi_startproc
 3996              		@ args = 0, pretend = 0, frame = 40
 3997              		@ frame_needed = 0, uses_anonymous_args = 0
 3998              	.LVL290:
 3999 23d4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4000              	.LCFI17:
 4001              		.cfi_def_cfa_offset 36
 4002 23d8 404B9FE5 		ldr	r4, .L446
 4003              		.cfi_offset 14, -4
 4004              		.cfi_offset 11, -8
 4005              		.cfi_offset 10, -12
 4006              		.cfi_offset 9, -16
 4007              		.cfi_offset 8, -20
 4008              		.cfi_offset 7, -24
 4009              		.cfi_offset 6, -28
 4010              		.cfi_offset 5, -32
 4011              		.cfi_offset 4, -36
 4012 23dc 406B9FE5 		ldr	r6, .L446+4
 4013 23e0 40AB9FE5 		ldr	sl, .L446+8
 4014 23e4 409B9FE5 		ldr	r9, .L446+12
 4015 23e8 408B9FE5 		ldr	r8, .L446+16
 4016 23ec 407B9FE5 		ldr	r7, .L446+20
 4017 23f0 44D04DE2 		sub	sp, sp, #68
 4018              	.LCFI18:
 4019              		.cfi_def_cfa_offset 104
 4020              	.LVL291:
3210:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4021              		.loc 1 3210 0
 4022 23f4 0450A0E1 		mov	r5, r4
 4023              	.LVL292:
 4024              	.L426:
 4025 23f8 00C0E0E3 		mvn	ip, #0
 4026 23fc 1C0B9FE5 		ldr	r0, .L446
 4027 2400 4C10A0E3 		mov	r1, #76
 4028 2404 0120A0E3 		mov	r2, #1
 4029 2408 38308DE2 		add	r3, sp, #56
 4030 240c 00C08DE5 		str	ip, [sp, #0]
 4031 2410 FEFFFFEB 		bl	_txe_event_flags_get
 4032 2414 000050E3 		cmp	r0, #0
 4033 2418 3000001A 		bne	.L301
3214:../uvc.c      ****             if (!isUsbConnected)
 4034              		.loc 1 3214 0
 4035 241c 3C3095E5 		ldr	r3, [r5, #60]
 4036 2420 000053E3 		cmp	r3, #0
 4037 2424 8900000A 		beq	.L437
 4038              	.L302:
3223:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4039              		.loc 1 3223 0
 4040 2428 38309DE5 		ldr	r3, [sp, #56]
 4041 242c 0C0013E3 		tst	r3, #12
 4042 2430 7200001A 		bne	.L438
 4043              	.L303:
3230:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4044              		.loc 1 3230 0
 4045 2434 040013E3 		tst	r3, #4
 4046 2438 1C00000A 		beq	.L304
3232:../uvc.c      ****             	switch ((wIndex >> 8))
 4047              		.loc 1 3232 0
 4048 243c B0E0D8E1 		ldrh	lr, [r8, #0]
 4049 2440 2E24A0E1 		mov	r2, lr, lsr #8
 4050 2444 030052E3 		cmp	r2, #3
 4051 2448 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4052 244c 120000EA 		b	.L305
 4053              	.L310:
 4054 2450 9C240000 		.word	.L305
 4055 2454 80250000 		.word	.L307
 4056 2458 60240000 		.word	.L308
 4057 245c BC250000 		.word	.L309
 4058              	.L308:
 4059              	.LBB88:
 4060              	.LBB90:
2475:../uvc.c      ****     switch (wValue)
 4061              		.loc 1 2475 0
 4062 2460 B020D9E1 		ldrh	r2, [r9, #0]
 4063 2464 060C52E3 		cmp	r2, #1536
 4064 2468 0302000A 		beq	.L316
 4065 246c D800008A 		bhi	.L322
 4066 2470 030C52E3 		cmp	r2, #768
 4067 2474 FC01000A 		beq	.L314
 4068 2478 F301008A 		bhi	.L323
 4069 247c 010C52E3 		cmp	r2, #256
 4070 2480 8901000A 		beq	.L312
 4071 2484 020C52E3 		cmp	r2, #512
 4072 2488 8301000A 		beq	.L439
 4073              	.L325:
 4074              	.LBE90:
 4075              	.LBE88:
 4076              	.LBB93:
 4077              	.LBB97:
2607:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4078              		.loc 1 2607 0
 4079 248c A41A9FE5 		ldr	r1, .L446+24
 4080 2490 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4081 2494 0400A0E3 		mov	r0, #4
 4082 2498 FEFFFFEB 		bl	CyU3PDebugPrint
 4083              	.L305:
 4084              	.LBE97:
 4085              	.LBE93:
3253:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4086              		.loc 1 3253 0
 4087 249c 0000A0E3 		mov	r0, #0
 4088 24a0 0110A0E3 		mov	r1, #1
 4089 24a4 0020A0E1 		mov	r2, r0
 4090 24a8 FEFFFFEB 		bl	CyU3PUsbStall
 4091 24ac 38309DE5 		ldr	r3, [sp, #56]
 4092              	.L304:
3258:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4093              		.loc 1 3258 0
 4094 24b0 080013E3 		tst	r3, #8
 4095 24b4 0700000A 		beq	.L366
3262:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4096              		.loc 1 3262 0
 4097 24b8 B030D8E1 		ldrh	r3, [r8, #0]
 4098 24bc 010053E3 		cmp	r3, #1
 4099 24c0 6800000A 		beq	.L367
 4100              	.L368:
 4101              	.LBB102:
 4102              	.LBB108:
3177:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4103              		.loc 1 3177 0
 4104 24c4 0000A0E3 		mov	r0, #0
 4105 24c8 0110A0E3 		mov	r1, #1
 4106 24cc 0020A0E1 		mov	r2, r0
 4107 24d0 FEFFFFEB 		bl	CyU3PUsbStall
 4108              	.L429:
 4109 24d4 38309DE5 		ldr	r3, [sp, #56]
 4110              	.L366:
 4111              	.LBE108:
 4112              	.LBE102:
3273:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4113              		.loc 1 3273 0
 4114 24d8 400013E3 		tst	r3, #64
 4115 24dc 0100001A 		bne	.L440
 4116              	.L301:
3486:../uvc.c      ****         CyU3PThreadRelinquish ();
 4117              		.loc 1 3486 0
 4118 24e0 FEFFFFEB 		bl	_txe_thread_relinquish
3487:../uvc.c      ****     }
 4119              		.loc 1 3487 0
 4120 24e4 C3FFFFEA 		b	.L426
 4121              	.L440:
3278:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4122              		.loc 1 3278 0
 4123 24e8 1800A0E3 		mov	r0, #24
 4124 24ec 34108DE2 		add	r1, sp, #52
 4125 24f0 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3283:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4126              		.loc 1 3283 0
 4127 24f4 34309DE5 		ldr	r3, [sp, #52]
 4128 24f8 000053E3 		cmp	r3, #0
 4129 24fc 6D00000A 		beq	.L421
3283:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4130              		.loc 1 3283 0 is_stmt 0 discriminator 1
 4131 2500 4336D6E5 		ldrb	r3, [r6, #1603]	@ zero_extendqisi2
 4132 2504 000053E3 		cmp	r3, #0
 4133 2508 F4FFFF1A 		bne	.L301
3285:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4134              		.loc 1 3285 0 is_stmt 1
 4135 250c 00C097E5 		ldr	ip, [r7, #0]
 4136 2510 02B0A0E3 		mov	fp, #2
 4137 2514 00B0CCE5 		strb	fp, [ip, #0]
3286:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4138              		.loc 1 3286 0
 4139 2518 001097E5 		ldr	r1, [r7, #0]
 4140 251c 01B0A0E3 		mov	fp, #1
 4141 2520 01B0C1E5 		strb	fp, [r1, #1]
3287:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4142              		.loc 1 3287 0
 4143 2524 000097E5 		ldr	r0, [r7, #0]
3291:../uvc.c      **** 					interStabuf.size   = 1024;
 4144              		.loc 1 3291 0
 4145 2528 01EBA0E3 		mov	lr, #1024	@ movhi
3287:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4146              		.loc 1 3287 0
 4147 252c 0230C0E5 		strb	r3, [r0, #2]
3288:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4148              		.loc 1 3288 0
 4149 2530 002097E5 		ldr	r2, [r7, #0]
3297:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4150              		.loc 1 3297 0
 4151 2534 0010E0E3 		mvn	r1, #0
3288:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4152              		.loc 1 3288 0
 4153 2538 0330C2E5 		strb	r3, [r2, #3]
3290:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4154              		.loc 1 3290 0
 4155 253c 00C097E5 		ldr	ip, [r7, #0]
3294:../uvc.c      **** 					interStabuf.count = 4;
 4156              		.loc 1 3294 0
 4157 2540 0420A0E3 		mov	r2, #4	@ movhi
3297:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4158              		.loc 1 3297 0
 4159 2544 F0099FE5 		ldr	r0, .L446+28
3294:../uvc.c      **** 					interStabuf.count = 4;
 4160              		.loc 1 3294 0
 4161 2548 BC22CDE1 		strh	r2, [sp, #44]	@ movhi
3291:../uvc.c      **** 					interStabuf.size   = 1024;
 4162              		.loc 1 3291 0
 4163 254c BEE2CDE1 		strh	lr, [sp, #46]	@ movhi
3290:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4164              		.loc 1 3290 0
 4165 2550 28C08DE5 		str	ip, [sp, #40]
3292:../uvc.c      **** 					interStabuf.status = 0;
 4166              		.loc 1 3292 0
 4167 2554 B033CDE1 		strh	r3, [sp, #48]	@ movhi
3297:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4168              		.loc 1 3297 0
 4169 2558 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3300:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4170              		.loc 1 3300 0
 4171 255c D8099FE5 		ldr	r0, .L446+28
 4172 2560 28108DE2 		add	r1, sp, #40
 4173 2564 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4174              	.LVL293:
3301:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4175              		.loc 1 3301 0
 4176 2568 002050E2 		subs	r2, r0, #0
 4177 256c 9101001A 		bne	.L441
3306:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4178              		.loc 1 3306 0
 4179 2570 AC399FE5 		ldr	r3, .L446+4
 4180 2574 43B6C3E5 		strb	fp, [r3, #1603]
3486:../uvc.c      ****         CyU3PThreadRelinquish ();
 4181              		.loc 1 3486 0
 4182 2578 FEFFFFEB 		bl	_txe_thread_relinquish
 4183              	.LVL294:
 4184 257c 9DFFFFEA 		b	.L426
 4185              	.L307:
 4186              	.LBB115:
 4187              	.LBB98:
2550:../uvc.c      ****     switch (wValue)
 4188              		.loc 1 2550 0
 4189 2580 B020D9E1 		ldrh	r2, [r9, #0]
 4190 2584 060C52E3 		cmp	r2, #1536
 4191 2588 ED00000A 		beq	.L331
 4192 258c 9B00008A 		bhi	.L337
 4193 2590 030C52E3 		cmp	r2, #768
 4194 2594 3801000A 		beq	.L328
 4195 2598 2F01008A 		bhi	.L338
 4196 259c 010C52E3 		cmp	r2, #256
 4197 25a0 8001000A 		beq	.L326
 4198 25a4 020C52E3 		cmp	r2, #512
 4199 25a8 B7FFFF1A 		bne	.L325
 4200              	.LVL295:
2558:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4201              		.loc 1 2558 0
 4202 25ac 0100A0E3 		mov	r0, #1
 4203 25b0 FEFFFFEB 		bl	CTControlHandle
 4204              	.LVL296:
 4205 25b4 38309DE5 		ldr	r3, [sp, #56]
 4206 25b8 BCFFFFEA 		b	.L304
 4207              	.L309:
 4208              	.LBE98:
 4209              	.LBE115:
 4210              	.LBB116:
 4211              	.LBB121:
2775:../uvc.c      ****     switch (wValue)
 4212              		.loc 1 2775 0
 4213 25bc B030D9E1 		ldrh	r3, [r9, #0]
 4214 25c0 090C53E3 		cmp	r3, #2304
 4215 25c4 4602000A 		beq	.L352
 4216 25c8 9400008A 		bhi	.L361
 4217 25cc 010B53E3 		cmp	r3, #1024
 4218 25d0 3F02000A 		beq	.L347
 4219 25d4 B101008A 		bhi	.L362
 4220 25d8 020C53E3 		cmp	r3, #512
 4221 25dc 3802000A 		beq	.L345
 4222 25e0 030C53E3 		cmp	r3, #768
 4223 25e4 1102000A 		beq	.L346
 4224 25e8 010C53E3 		cmp	r3, #256
 4225 25ec AAFFFF1A 		bne	.L305
 4226              	.LVL297:
2779:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4227              		.loc 1 2779 0
 4228 25f0 1000A0E3 		mov	r0, #16
 4229 25f4 FEFFFFEB 		bl	ControlHandle
 4230              	.LVL298:
 4231 25f8 38309DE5 		ldr	r3, [sp, #56]
 4232 25fc ABFFFFEA 		b	.L304
 4233              	.L438:
 4234              	.LBE121:
 4235              	.LBE116:
3224:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4236              		.loc 1 3224 0
 4237 2600 38B99FE5 		ldr	fp, .L446+32
 4238 2604 B0C0D9E1 		ldrh	ip, [r9, #0]
 4239 2608 B000D8E1 		ldrh	r0, [r8, #0]
 4240 260c 30199FE5 		ldr	r1, .L446+36
 4241 2610 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4242 2614 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4243 2618 0C008DE5 		str	r0, [sp, #12]
 4244 261c 08C08DE5 		str	ip, [sp, #8]
 4245 2620 B0C0D1E1 		ldrh	ip, [r1, #0]
 4246 2624 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4247 2628 04B08DE5 		str	fp, [sp, #4]
 4248 262c 0400A0E3 		mov	r0, #4
 4249 2630 10199FE5 		ldr	r1, .L446+40
 4250 2634 00B0A0E3 		mov	fp, #0
 4251 2638 00E08DE5 		str	lr, [sp, #0]
 4252 263c 10C08DE5 		str	ip, [sp, #16]
 4253 2640 14B08DE5 		str	fp, [sp, #20]
 4254 2644 FEFFFFEB 		bl	CyU3PDebugPrint
 4255 2648 38309DE5 		ldr	r3, [sp, #56]
 4256 264c 78FFFFEA 		b	.L303
 4257              	.L437:
3216:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4258              		.loc 1 3216 0
 4259 2650 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3217:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4260              		.loc 1 3217 0
 4261 2654 000050E3 		cmp	r0, #0
3216:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4262              		.loc 1 3216 0
 4263 2658 4800C5E5 		strb	r0, [r5, #72]
3219:../uvc.c      ****                     isUsbConnected = CyTrue;
 4264              		.loc 1 3219 0
 4265 265c 0100A013 		movne	r0, #1
 4266 2660 3C008515 		strne	r0, [r5, #60]
 4267 2664 6FFFFFEA 		b	.L302
 4268              	.L367:
 4269              	.LVL299:
 4270              	.LBB127:
 4271              	.LBB109:
2870:../uvc.c      ****     switch (wValue)
 4272              		.loc 1 2870 0
 4273 2668 B020D9E1 		ldrh	r2, [r9, #0]
 4274 266c 030C52E3 		cmp	r2, #768
 4275 2670 9C00000A 		beq	.L371
 4276 2674 3200008A 		bhi	.L374
 4277 2678 010C52E3 		cmp	r2, #256
 4278 267c A600000A 		beq	.L369
 4279 2680 020C52E3 		cmp	r2, #512
 4280 2684 8EFFFF1A 		bne	.L368
2923:../uvc.c      ****             switch (bRequest)
 4281              		.loc 1 2923 0
 4282 2688 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4283 268c 810053E3 		cmp	r3, #129
 4284 2690 A600000A 		beq	.L414
 4285 2694 5001008A 		bhi	.L387
 4286 2698 010053E3 		cmp	r3, #1
 4287 269c AE01000A 		beq	.L442
 4288              	.L393:
3041:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4289              		.loc 1 3041 0
 4290 26a0 0000A0E3 		mov	r0, #0
 4291 26a4 0110A0E3 		mov	r1, #1
 4292 26a8 0020A0E1 		mov	r2, r0
 4293 26ac FEFFFFEB 		bl	CyU3PUsbStall
 4294 26b0 38309DE5 		ldr	r3, [sp, #56]
 4295 26b4 87FFFFEA 		b	.L366
 4296              	.LVL300:
 4297              	.L421:
 4298              	.LBE109:
 4299              	.LBE127:
3307:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4300              		.loc 1 3307 0
 4301 26b8 43E6D6E5 		ldrb	lr, [r6, #1603]	@ zero_extendqisi2
 4302 26bc 00005EE3 		cmp	lr, #0
 4303 26c0 86FFFF0A 		beq	.L301
3309:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4304              		.loc 1 3309 0
 4305 26c4 00C097E5 		ldr	ip, [r7, #0]
 4306 26c8 02B0A0E3 		mov	fp, #2
 4307 26cc 00B0CCE5 		strb	fp, [ip, #0]
3310:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4308              		.loc 1 3310 0
 4309 26d0 001097E5 		ldr	r1, [r7, #0]
 4310 26d4 01E0A0E3 		mov	lr, #1
 4311 26d8 01E0C1E5 		strb	lr, [r1, #1]
3311:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4312              		.loc 1 3311 0
 4313 26dc 000097E5 		ldr	r0, [r7, #0]
3315:../uvc.c      **** 					interStabuf.size   = 1024;
 4314              		.loc 1 3315 0
 4315 26e0 01CBA0E3 		mov	ip, #1024	@ movhi
3311:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4316              		.loc 1 3311 0
 4317 26e4 0230C0E5 		strb	r3, [r0, #2]
3312:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4318              		.loc 1 3312 0
 4319 26e8 002097E5 		ldr	r2, [r7, #0]
3321:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4320              		.loc 1 3321 0
 4321 26ec 0010E0E3 		mvn	r1, #0
3312:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4322              		.loc 1 3312 0
 4323 26f0 03E0C2E5 		strb	lr, [r2, #3]
3314:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4324              		.loc 1 3314 0
 4325 26f4 00B097E5 		ldr	fp, [r7, #0]
3318:../uvc.c      **** 					interStabuf.count = 4;
 4326              		.loc 1 3318 0
 4327 26f8 0420A0E3 		mov	r2, #4	@ movhi
3321:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4328              		.loc 1 3321 0
 4329 26fc 38089FE5 		ldr	r0, .L446+28
3318:../uvc.c      **** 					interStabuf.count = 4;
 4330              		.loc 1 3318 0
 4331 2700 BC22CDE1 		strh	r2, [sp, #44]	@ movhi
3315:../uvc.c      **** 					interStabuf.size   = 1024;
 4332              		.loc 1 3315 0
 4333 2704 BEC2CDE1 		strh	ip, [sp, #46]	@ movhi
3314:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4334              		.loc 1 3314 0
 4335 2708 28B08DE5 		str	fp, [sp, #40]
3316:../uvc.c      **** 					interStabuf.status = 0;
 4336              		.loc 1 3316 0
 4337 270c B033CDE1 		strh	r3, [sp, #48]	@ movhi
 4338 2710 03B0A0E1 		mov	fp, r3	@ movhi
3321:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4339              		.loc 1 3321 0
 4340 2714 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3324:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4341              		.loc 1 3324 0
 4342 2718 1C089FE5 		ldr	r0, .L446+28
 4343 271c 28108DE2 		add	r1, sp, #40
 4344 2720 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4345              	.LVL301:
3325:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4346              		.loc 1 3325 0
 4347 2724 002050E2 		subs	r2, r0, #0
 4348 2728 E300001A 		bne	.L443
3331:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4349              		.loc 1 3331 0
 4350 272c F0E79FE5 		ldr	lr, .L446+4
3332:../uvc.c      **** 					stiflag = 0xFF;
 4351              		.loc 1 3332 0
 4352 2730 FF30A0E3 		mov	r3, #255
3331:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4353              		.loc 1 3331 0
 4354 2734 43B6CEE5 		strb	fp, [lr, #1603]
3332:../uvc.c      **** 					stiflag = 0xFF;
 4355              		.loc 1 3332 0
 4356 2738 A03084E5 		str	r3, [r4, #160]
3486:../uvc.c      ****         CyU3PThreadRelinquish ();
 4357              		.loc 1 3486 0
 4358 273c FEFFFFEB 		bl	_txe_thread_relinquish
 4359              	.LVL302:
 4360 2740 2CFFFFEA 		b	.L426
 4361              	.LVL303:
 4362              	.L374:
 4363              	.LBB128:
 4364              	.LBB107:
2870:../uvc.c      ****     switch (wValue)
 4365              		.loc 1 2870 0
 4366 2744 010B52E3 		cmp	r2, #1024
 4367 2748 4100000A 		beq	.L372
 4368 274c 050C52E3 		cmp	r2, #1280
 4369 2750 5BFFFF1A 		bne	.L368
3122:../uvc.c      ****                 switch (bRequest)
 4370              		.loc 1 3122 0
 4371 2754 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4372 2758 810052E3 		cmp	r2, #129
 4373 275c 7300000A 		beq	.L414
 4374 2760 4901008A 		bhi	.L417
 4375 2764 010052E3 		cmp	r2, #1
 4376 2768 55FFFF1A 		bne	.L368
3147:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4377              		.loc 1 3147 0
 4378 276c 2000A0E3 		mov	r0, #32
 4379 2770 D4179FE5 		ldr	r1, .L446+44
 4380 2774 3E208DE2 		add	r2, sp, #62
 4381 2778 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4382              	.LVL304:
3149:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4383              		.loc 1 3149 0
 4384 277c 000050E3 		cmp	r0, #0
 4385 2780 C901001A 		bne	.L418
3153:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4386              		.loc 1 3153 0
 4387 2784 0020A0E3 		mov	r2, #0
 4388 2788 90079FE5 		ldr	r0, .L446
 4389              	.LVL305:
 4390 278c 8010A0E3 		mov	r1, #128
 4391 2790 FEFFFFEB 		bl	_txe_event_flags_set
 4392              	.LVL306:
3154:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4393              		.loc 1 3154 0
 4394 2794 002050E2 		subs	r2, r0, #0
3160:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 4395              		.loc 1 3160 0
 4396 2798 F0B0A003 		moveq	fp, #240
 4397 279c A0B08505 		streq	fp, [r5, #160]
3154:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4398              		.loc 1 3154 0
 4399 27a0 0200000A 		beq	.L420
3156:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 4400              		.loc 1 3156 0
 4401 27a4 A4179FE5 		ldr	r1, .L446+48
 4402 27a8 0400A0E3 		mov	r0, #4
 4403              	.LVL307:
 4404 27ac FEFFFFEB 		bl	CyU3PDebugPrint
 4405              	.LVL308:
 4406              	.L420:
3163:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 4407              		.loc 1 3163 0
 4408 27b0 7DC0D4E5 		ldrb	ip, [r4, #125]	@ zero_extendqisi2
 4409 27b4 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 4410 27b8 BE23DDE1 		ldrh	r2, [sp, #62]
 4411              	.LVL309:
 4412 27bc 0400A0E3 		mov	r0, #4
 4413 27c0 8C179FE5 		ldr	r1, .L446+52
 4414 27c4 00C08DE5 		str	ip, [sp, #0]
 4415 27c8 FEFFFFEB 		bl	CyU3PDebugPrint
 4416 27cc 38309DE5 		ldr	r3, [sp, #56]
 4417 27d0 40FFFFEA 		b	.L366
 4418              	.LVL310:
 4419              	.L322:
 4420              	.LBE107:
 4421              	.LBE128:
 4422              	.LBB129:
 4423              	.LBB91:
2475:../uvc.c      ****     switch (wValue)
 4424              		.loc 1 2475 0
 4425 27d4 0A0C52E3 		cmp	r2, #2560
 4426 27d8 1301000A 		beq	.L319
 4427 27dc 0801008A 		bhi	.L324
 4428 27e0 070C52E3 		cmp	r2, #1792
 4429 27e4 0201000A 		beq	.L317
 4430 27e8 020B52E3 		cmp	r2, #2048
 4431 27ec 26FFFF1A 		bne	.L325
 4432              	.LVL311:
2506:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4433              		.loc 1 2506 0
 4434 27f0 0700A0E3 		mov	r0, #7
 4435 27f4 FEFFFFEB 		bl	ControlHandle
 4436              	.LVL312:
 4437 27f8 38309DE5 		ldr	r3, [sp, #56]
 4438 27fc 2BFFFFEA 		b	.L304
 4439              	.L337:
 4440              	.LBE91:
 4441              	.LBE129:
 4442              	.LBB130:
 4443              	.LBB96:
2550:../uvc.c      ****     switch (wValue)
 4444              		.loc 1 2550 0
 4445 2800 090C52E3 		cmp	r2, #2304
 4446 2804 4401000A 		beq	.L333
 4447 2808 3901008A 		bhi	.L339
 4448 280c 070C52E3 		cmp	r2, #1792
 4449 2810 2B01000A 		beq	.L332
 4450 2814 020B52E3 		cmp	r2, #2048
 4451 2818 1BFFFF1A 		bne	.L325
 4452 281c 23FFFFEA 		b	.L304
 4453              	.L361:
 4454              	.LBE96:
 4455              	.LBE130:
 4456              	.LBB131:
 4457              	.LBB122:
2775:../uvc.c      ****     switch (wValue)
 4458              		.loc 1 2775 0
 4459 2820 0F0C53E3 		cmp	r3, #3840
 4460 2824 9C01000A 		beq	.L356
 4461 2828 4900008A 		bhi	.L364
 4462 282c 0B0C53E3 		cmp	r3, #2816
 4463 2830 9501000A 		beq	.L354
 4464 2834 0D0C53E3 		cmp	r3, #3328
 4465 2838 8F01000A 		beq	.L355
 4466 283c 0A0C53E3 		cmp	r3, #2560
 4467 2840 15FFFF1A 		bne	.L305
 4468              	.LVL313:
2816:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4469              		.loc 1 2816 0
 4470 2844 1900A0E3 		mov	r0, #25
 4471 2848 FEFFFFEB 		bl	ControlHandle
 4472              	.LVL314:
 4473 284c 38309DE5 		ldr	r3, [sp, #56]
 4474 2850 16FFFFEA 		b	.L304
 4475              	.LVL315:
 4476              	.L372:
 4477              	.LBE122:
 4478              	.LBE131:
 4479              	.LBB132:
 4480              	.LBB110:
3047:../uvc.c      ****                 switch (bRequest)
 4481              		.loc 1 3047 0
 4482 2854 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4483 2858 810052E3 		cmp	r2, #129
 4484 285c 2600000A 		beq	.L403
 4485 2860 9E00008A 		bhi	.L406
 4486 2864 010052E3 		cmp	r2, #1
 4487 2868 15FFFF1A 		bne	.L368
3072:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4488              		.loc 1 3072 0
 4489 286c 2000A0E3 		mov	r0, #32
 4490 2870 D4169FE5 		ldr	r1, .L446+44
 4491 2874 3E208DE2 		add	r2, sp, #62
 4492 2878 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4493              	.LVL316:
3074:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4494              		.loc 1 3074 0
 4495 287c 000050E3 		cmp	r0, #0
 4496 2880 13FFFF1A 		bne	.L429
3093:../uvc.c      ****                            switch (glCommitCtrl[1])
 4497              		.loc 1 3093 0
 4498 2884 7D30D5E5 		ldrb	r3, [r5, #125]	@ zero_extendqisi2
 4499 2888 010053E3 		cmp	r3, #1
 4500 288c 9801000A 		beq	.L410
 4501 2890 020053E3 		cmp	r3, #2
 4502 2894 0900001A 		bne	.L409
3096:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*
 4503              		.loc 1 3096 0
 4504 2898 3010A0E3 		mov	r1, #48
 4505 289c 0120A0E3 		mov	r2, #1
 4506 28a0 503083E2 		add	r3, r3, #80
 4507 28a4 0B00A0E3 		mov	r0, #11
 4508              	.LVL317:
 4509 28a8 FEFFFFEB 		bl	SensorSetIrisControl
3098:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
 4510              		.loc 1 3098 0
 4511 28ac A4169FE5 		ldr	r1, .L446+56
 4512 28b0 0B20A0E3 		mov	r2, #11
 4513 28b4 0130A0E3 		mov	r3, #1
 4514 28b8 0400A0E3 		mov	r0, #4
 4515 28bc FEFFFFEB 		bl	CyU3PDebugPrint
 4516              	.L409:
3108:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 4517              		.loc 1 3108 0
 4518 28c0 7DE0D4E5 		ldrb	lr, [r4, #125]	@ zero_extendqisi2
3110:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 4519              		.loc 1 3110 0
 4520 28c4 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 4521 28c8 BE23DDE1 		ldrh	r2, [sp, #62]
 4522              	.LVL318:
 4523 28cc 0400A0E3 		mov	r0, #4
 4524 28d0 84169FE5 		ldr	r1, .L446+60
3108:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 4525              		.loc 1 3108 0
 4526 28d4 9DE0C4E5 		strb	lr, [r4, #157]
3110:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 4527              		.loc 1 3110 0
 4528 28d8 00E08DE5 		str	lr, [sp, #0]
 4529 28dc FEFFFFEB 		bl	CyU3PDebugPrint
 4530 28e0 38309DE5 		ldr	r3, [sp, #56]
 4531 28e4 FBFEFFEA 		b	.L366
 4532              	.LVL319:
 4533              	.L371:
2997:../uvc.c      ****                 switch (bRequest)
 4534              		.loc 1 2997 0
 4535 28e8 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4536 28ec 830052E3 		cmp	r2, #131
 4537 28f0 A700008A 		bhi	.L398
 4538 28f4 810052E3 		cmp	r2, #129
 4539 28f8 8300003A 		bcc	.L444
 4540              	.L403:
3059:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4541              		.loc 1 3059 0
 4542 28fc 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3061:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4543              		.loc 1 3061 0
 4544 2900 0B00A0E3 		mov	r0, #11
3059:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4545              		.loc 1 3059 0
 4546 2904 030052E3 		cmp	r2, #3
3061:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4547              		.loc 1 3061 0
 4548 2908 50169F05 		ldreq	r1, .L446+64
3065:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4549              		.loc 1 3065 0
 4550 290c 50169F15 		ldrne	r1, .L446+68
 4551 2910 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4552 2914 38309DE5 		ldr	r3, [sp, #56]
 4553 2918 EEFEFFEA 		b	.L366
 4554              	.L369:
2873:../uvc.c      ****             switch (bRequest)
 4555              		.loc 1 2873 0
 4556 291c 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4557 2920 830052E3 		cmp	r2, #131
 4558 2924 3500008A 		bhi	.L380
 4559 2928 810052E3 		cmp	r2, #129
 4560 292c 1100003A 		bcc	.L445
 4561              	.L414:
3136:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4562              		.loc 1 3136 0
 4563 2930 1A00A0E3 		mov	r0, #26
 4564 2934 2C169FE5 		ldr	r1, .L446+72
 4565 2938 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4566 293c 38309DE5 		ldr	r3, [sp, #56]
 4567 2940 E4FEFFEA 		b	.L366
 4568              	.LVL320:
 4569              	.L331:
 4570              	.LBE110:
 4571              	.LBE132:
 4572              	.LBB133:
 4573              	.LBB99:
2576:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4574              		.loc 1 2576 0
 4575 2944 0500A0E3 		mov	r0, #5
 4576 2948 FEFFFFEB 		bl	CTControlHandle
 4577              	.LVL321:
 4578 294c 38309DE5 		ldr	r3, [sp, #56]
 4579 2950 D6FEFFEA 		b	.L304
 4580              	.L364:
 4581              	.LBE99:
 4582              	.LBE133:
 4583              	.LBB134:
 4584              	.LBB120:
2775:../uvc.c      ****     switch (wValue)
 4585              		.loc 1 2775 0
 4586 2954 110C53E3 		cmp	r3, #4352
 4587 2958 FB00000A 		beq	.L358
 4588 295c 3600008A 		bhi	.L365
 4589 2960 010A53E3 		cmp	r3, #4096
 4590 2964 CCFEFF1A 		bne	.L305
 4591              	.LVL322:
2838:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4592              		.loc 1 2838 0
 4593 2968 1F00A0E3 		mov	r0, #31
 4594 296c FEFFFFEB 		bl	ControlHandle
 4595              	.LVL323:
 4596 2970 38309DE5 		ldr	r3, [sp, #56]
 4597 2974 CDFEFFEA 		b	.L304
 4598              	.LVL324:
 4599              	.L445:
 4600              	.LBE120:
 4601              	.LBE134:
 4602              	.LBB135:
 4603              	.LBB106:
2873:../uvc.c      ****             switch (bRequest)
 4604              		.loc 1 2873 0
 4605 2978 010052E3 		cmp	r2, #1
 4606 297c 47FFFF1A 		bne	.L393
2898:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4607              		.loc 1 2898 0
 4608 2980 2000A0E3 		mov	r0, #32
 4609 2984 C0159FE5 		ldr	r1, .L446+44
 4610 2988 3E208DE2 		add	r2, sp, #62
 4611 298c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4612              	.LVL325:
2900:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4613              		.loc 1 2900 0
 4614 2990 000050E3 		cmp	r0, #0
 4615 2994 CEFEFF1A 		bne	.L429
2908:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4616              		.loc 1 2908 0
 4617 2998 80C0D5E5 		ldrb	ip, [r5, #128]	@ zero_extendqisi2
2906:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4618              		.loc 1 2906 0
 4619 299c 7EB0D5E5 		ldrb	fp, [r5, #126]	@ zero_extendqisi2
2909:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4620              		.loc 1 2909 0
 4621 29a0 8100D5E5 		ldrb	r0, [r5, #129]	@ zero_extendqisi2
 4622              	.LVL326:
2908:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4623              		.loc 1 2908 0
 4624 29a4 1CC08DE5 		str	ip, [sp, #28]
2906:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4625              		.loc 1 2906 0
 4626 29a8 12B6C6E5 		strb	fp, [r6, #1554]
2908:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4627              		.loc 1 2908 0
 4628 29ac 1CB09DE5 		ldr	fp, [sp, #28]
2910:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4629              		.loc 1 2910 0
 4630 29b0 8210D5E5 		ldrb	r1, [r5, #130]	@ zero_extendqisi2
2909:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4631              		.loc 1 2909 0
 4632 29b4 20008DE5 		str	r0, [sp, #32]
2908:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4633              		.loc 1 2908 0
 4634 29b8 14B6C6E5 		strb	fp, [r6, #1556]
2909:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4635              		.loc 1 2909 0
 4636 29bc 20B09DE5 		ldr	fp, [sp, #32]
2910:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4637              		.loc 1 2910 0
 4638 29c0 24108DE5 		str	r1, [sp, #36]
2907:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4639              		.loc 1 2907 0
 4640 29c4 7FE0D5E5 		ldrb	lr, [r5, #127]	@ zero_extendqisi2
2911:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4641              		.loc 1 2911 0
 4642 29c8 83C0D5E5 		ldrb	ip, [r5, #131]	@ zero_extendqisi2
2909:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4643              		.loc 1 2909 0
 4644 29cc 15B6C6E5 		strb	fp, [r6, #1557]
2910:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4645              		.loc 1 2910 0
 4646 29d0 24B09DE5 		ldr	fp, [sp, #36]
2912:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d\r\n", readCount
 4647              		.loc 1 2912 0
 4648 29d4 7C30D5E5 		ldrb	r3, [r5, #124]	@ zero_extendqisi2
 4649 29d8 BE23DDE1 		ldrh	r2, [sp, #62]
 4650              	.LVL327:
 4651 29dc 0400A0E3 		mov	r0, #4
 4652 29e0 84159FE5 		ldr	r1, .L446+76
2907:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4653              		.loc 1 2907 0
 4654 29e4 13E6C6E5 		strb	lr, [r6, #1555]
2910:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4655              		.loc 1 2910 0
 4656 29e8 16B6C6E5 		strb	fp, [r6, #1558]
2911:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4657              		.loc 1 2911 0
 4658 29ec 17C6C6E5 		strb	ip, [r6, #1559]
2912:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d\r\n", readCount
 4659              		.loc 1 2912 0
 4660 29f0 00E08DE5 		str	lr, [sp, #0]
 4661 29f4 FEFFFFEB 		bl	CyU3PDebugPrint
 4662 29f8 38309DE5 		ldr	r3, [sp, #56]
 4663 29fc B5FEFFEA 		b	.L366
 4664              	.LVL328:
 4665              	.L380:
2873:../uvc.c      ****             switch (bRequest)
 4666              		.loc 1 2873 0
 4667 2a00 860052E3 		cmp	r2, #134
 4668 2a04 3900000A 		beq	.L432
 4669 2a08 870052E3 		cmp	r2, #135
 4670 2a0c C7FFFF0A 		beq	.L414
 4671              	.L436:
2997:../uvc.c      ****                 switch (bRequest)
 4672              		.loc 1 2997 0
 4673 2a10 850052E3 		cmp	r2, #133
 4674 2a14 21FFFF1A 		bne	.L393
 4675              	.L404:
3056:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4676              		.loc 1 3056 0
 4677 2a18 50159FE5 		ldr	r1, .L446+80
 4678 2a1c 0200A0E3 		mov	r0, #2
3054:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4679              		.loc 1 3054 0
 4680 2a20 1A30A0E3 		mov	r3, #26
 4681              	.L430:
3129:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4682              		.loc 1 3129 0
 4683 2a24 5830C4E5 		strb	r3, [r4, #88]
3130:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4684              		.loc 1 3130 0
 4685 2a28 0030A0E3 		mov	r3, #0
 4686 2a2c 5930C4E5 		strb	r3, [r4, #89]
3131:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4687              		.loc 1 3131 0
 4688 2a30 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4689 2a34 38309DE5 		ldr	r3, [sp, #56]
 4690 2a38 A6FEFFEA 		b	.L366
 4691              	.LVL329:
 4692              	.L365:
 4693              	.LBE106:
 4694              	.LBE135:
 4695              	.LBB136:
 4696              	.LBB123:
2775:../uvc.c      ****     switch (wValue)
 4697              		.loc 1 2775 0
 4698 2a3c 120C53E3 		cmp	r3, #4608
 4699 2a40 0901000A 		beq	.L359
 4700 2a44 130C53E3 		cmp	r3, #4864
 4701 2a48 93FEFF1A 		bne	.L305
 4702              	.LVL330:
2850:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 4703              		.loc 1 2850 0
 4704 2a4c 2600A0E3 		mov	r0, #38
 4705 2a50 FEFFFFEB 		bl	ControlHandle
 4706              	.LVL331:
 4707 2a54 38309DE5 		ldr	r3, [sp, #56]
 4708 2a58 94FEFFEA 		b	.L304
 4709              	.L338:
 4710              	.LBE123:
 4711              	.LBE136:
 4712              	.LBB137:
 4713              	.LBB95:
2550:../uvc.c      ****     switch (wValue)
 4714              		.loc 1 2550 0
 4715 2a5c 010B52E3 		cmp	r2, #1024
 4716 2a60 0900000A 		beq	.L329
 4717 2a64 050C52E3 		cmp	r2, #1280
 4718 2a68 87FEFF1A 		bne	.L325
 4719              	.LVL332:
2572:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4720              		.loc 1 2572 0
 4721 2a6c 0400A0E3 		mov	r0, #4
 4722 2a70 FEFFFFEB 		bl	CTControlHandle
 4723              	.LVL333:
 4724 2a74 38309DE5 		ldr	r3, [sp, #56]
 4725 2a78 8CFEFFEA 		b	.L304
 4726              	.L328:
 4727              	.LVL334:
2562:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4728              		.loc 1 2562 0
 4729 2a7c 0200A0E3 		mov	r0, #2
 4730 2a80 FEFFFFEB 		bl	CTControlHandle
 4731              	.LVL335:
 4732 2a84 38309DE5 		ldr	r3, [sp, #56]
 4733 2a88 88FEFFEA 		b	.L304
 4734              	.L329:
 4735              	.LVL336:
2567:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4736              		.loc 1 2567 0
 4737 2a8c 0300A0E3 		mov	r0, #3
 4738 2a90 FEFFFFEB 		bl	CTControlHandle
 4739              	.LVL337:
 4740 2a94 38309DE5 		ldr	r3, [sp, #56]
 4741 2a98 84FEFFEA 		b	.L304
 4742              	.L439:
 4743              	.LVL338:
 4744              	.LBE95:
 4745              	.LBE137:
 4746              	.LBB138:
 4747              	.LBB89:
2483:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4748              		.loc 1 2483 0
 4749 2a9c 0100A0E3 		mov	r0, #1
 4750 2aa0 FEFFFFEB 		bl	ControlHandle
 4751              	.LVL339:
 4752 2aa4 38309DE5 		ldr	r3, [sp, #56]
 4753 2aa8 80FEFFEA 		b	.L304
 4754              	.L312:
 4755              	.LVL340:
2479:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4756              		.loc 1 2479 0
 4757 2aac 0000A0E3 		mov	r0, #0
 4758 2ab0 FEFFFFEB 		bl	ControlHandle
 4759              	.LVL341:
 4760 2ab4 38309DE5 		ldr	r3, [sp, #56]
 4761 2ab8 7CFEFFEA 		b	.L304
 4762              	.LVL342:
 4763              	.L443:
 4764              	.LBE89:
 4765              	.LBE138:
3327:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4766              		.loc 1 3327 0
 4767 2abc 0400A0E3 		mov	r0, #4
 4768              	.LVL343:
 4769 2ac0 AC149FE5 		ldr	r1, .L446+84
 4770 2ac4 FEFFFFEB 		bl	CyU3PDebugPrint
 4771              	.LVL344:
 4772              	.L425:
 4773              	.LBB139:
 4774              	.LBB140:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4775              		.loc 1 1249 0
 4776 2ac8 A8149FE5 		ldr	r1, .L446+88
 4777 2acc 0400A0E3 		mov	r0, #4
 4778 2ad0 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 4779              		.loc 1 1250 0
 4780 2ad4 FA0FA0E3 		mov	r0, #1000
 4781 2ad8 FEFFFFEB 		bl	_tx_thread_sleep
 4782 2adc F9FFFFEA 		b	.L425
 4783              	.LVL345:
 4784              	.L406:
 4785              	.LBE140:
 4786              	.LBE139:
 4787              	.LBB141:
 4788              	.LBB111:
3047:../uvc.c      ****                 switch (bRequest)
 4789              		.loc 1 3047 0
 4790 2ae0 850052E3 		cmp	r2, #133
 4791 2ae4 CBFFFF0A 		beq	.L404
 4792 2ae8 860052E3 		cmp	r2, #134
 4793 2aec 74FEFF1A 		bne	.L368
 4794              	.L432:
3051:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4795              		.loc 1 3051 0
 4796 2af0 0300A0E1 		mov	r0, r3
 4797              	.L428:
2926:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4798              		.loc 1 2926 0
 4799 2af4 0330A0E3 		mov	r3, #3
2927:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4800              		.loc 1 2927 0
 4801 2af8 70149FE5 		ldr	r1, .L446+80
2926:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4802              		.loc 1 2926 0
 4803 2afc 5830C4E5 		strb	r3, [r4, #88]
2927:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4804              		.loc 1 2927 0
 4805 2b00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4806 2b04 38309DE5 		ldr	r3, [sp, #56]
 4807 2b08 72FEFFEA 		b	.L366
 4808              	.L444:
2997:../uvc.c      ****                 switch (bRequest)
 4809              		.loc 1 2997 0
 4810 2b0c 010052E3 		cmp	r2, #1
 4811 2b10 E2FEFF1A 		bne	.L393
3022:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4812              		.loc 1 3022 0
 4813 2b14 2000A0E3 		mov	r0, #32
 4814 2b18 2C149FE5 		ldr	r1, .L446+44
 4815 2b1c 3E208DE2 		add	r2, sp, #62
 4816 2b20 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4817              	.LVL346:
3024:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4818              		.loc 1 3024 0
 4819 2b24 000050E3 		cmp	r0, #0
 4820 2b28 69FEFF1A 		bne	.L429
3032:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4821              		.loc 1 3032 0
 4822 2b2c 7FC0D5E5 		ldrb	ip, [r5, #127]	@ zero_extendqisi2
3031:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4823              		.loc 1 3031 0
 4824 2b30 7EB0D5E5 		ldrb	fp, [r5, #126]	@ zero_extendqisi2
3033:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4825              		.loc 1 3033 0
 4826 2b34 8000D5E5 		ldrb	r0, [r5, #128]	@ zero_extendqisi2
 4827              	.LVL347:
3032:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4828              		.loc 1 3032 0
 4829 2b38 1CC08DE5 		str	ip, [sp, #28]
3031:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4830              		.loc 1 3031 0
 4831 2b3c 2EB6C6E5 		strb	fp, [r6, #1582]
3032:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4832              		.loc 1 3032 0
 4833 2b40 1CB09DE5 		ldr	fp, [sp, #28]
3034:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4834              		.loc 1 3034 0
 4835 2b44 8110D5E5 		ldrb	r1, [r5, #129]	@ zero_extendqisi2
3033:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4836              		.loc 1 3033 0
 4837 2b48 20008DE5 		str	r0, [sp, #32]
3032:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4838              		.loc 1 3032 0
 4839 2b4c 2FB6C6E5 		strb	fp, [r6, #1583]
3033:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4840              		.loc 1 3033 0
 4841 2b50 20B09DE5 		ldr	fp, [sp, #32]
3034:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4842              		.loc 1 3034 0
 4843 2b54 24108DE5 		str	r1, [sp, #36]
3030:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4844              		.loc 1 3030 0
 4845 2b58 7DE0D5E5 		ldrb	lr, [r5, #125]	@ zero_extendqisi2
3035:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4846              		.loc 1 3035 0
 4847 2b5c 82C0D5E5 		ldrb	ip, [r5, #130]	@ zero_extendqisi2
3033:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4848              		.loc 1 3033 0
 4849 2b60 30B6C6E5 		strb	fp, [r6, #1584]
3034:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4850              		.loc 1 3034 0
 4851 2b64 24B09DE5 		ldr	fp, [sp, #36]
3037:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 4852              		.loc 1 3037 0
 4853 2b68 7C30D5E5 		ldrb	r3, [r5, #124]	@ zero_extendqisi2
 4854 2b6c BE23DDE1 		ldrh	r2, [sp, #62]
 4855              	.LVL348:
 4856 2b70 0400A0E3 		mov	r0, #4
 4857 2b74 00149FE5 		ldr	r1, .L446+92
3030:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4858              		.loc 1 3030 0
 4859 2b78 2DE6C6E5 		strb	lr, [r6, #1581]
3034:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4860              		.loc 1 3034 0
 4861 2b7c 31B6C6E5 		strb	fp, [r6, #1585]
3035:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4862              		.loc 1 3035 0
 4863 2b80 32C6C6E5 		strb	ip, [r6, #1586]
3037:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 4864              		.loc 1 3037 0
 4865 2b84 00E08DE5 		str	lr, [sp, #0]
 4866 2b88 FEFFFFEB 		bl	CyU3PDebugPrint
 4867 2b8c 38309DE5 		ldr	r3, [sp, #56]
 4868 2b90 50FEFFEA 		b	.L366
 4869              	.LVL349:
 4870              	.L398:
2997:../uvc.c      ****                 switch (bRequest)
 4871              		.loc 1 2997 0
 4872 2b94 860052E3 		cmp	r2, #134
 4873 2b98 D4FFFF0A 		beq	.L432
 4874 2b9c 870052E3 		cmp	r2, #135
 4875 2ba0 9AFFFF1A 		bne	.L436
 4876 2ba4 54FFFFEA 		b	.L403
 4877              	.LVL350:
 4878              	.L326:
 4879              	.LBE111:
 4880              	.LBE141:
 4881              	.LBB142:
 4882              	.LBB100:
2554:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4883              		.loc 1 2554 0
 4884 2ba8 0000A0E3 		mov	r0, #0
 4885 2bac FEFFFFEB 		bl	CTControlHandle
 4886              	.LVL351:
 4887 2bb0 38309DE5 		ldr	r3, [sp, #56]
 4888 2bb4 3DFEFFEA 		b	.L304
 4889              	.LVL352:
 4890              	.L441:
 4891              	.LBE100:
 4892              	.LBE142:
3303:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4893              		.loc 1 3303 0
 4894 2bb8 0400A0E3 		mov	r0, #4
 4895              	.LVL353:
 4896 2bbc B0139FE5 		ldr	r1, .L446+84
 4897 2bc0 FEFFFFEB 		bl	CyU3PDebugPrint
 4898              	.LVL354:
 4899              	.L423:
 4900              	.LBB143:
 4901              	.LBB144:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4902              		.loc 1 1249 0
 4903 2bc4 AC139FE5 		ldr	r1, .L446+88
 4904 2bc8 0400A0E3 		mov	r0, #4
 4905 2bcc FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 4906              		.loc 1 1250 0
 4907 2bd0 FA0FA0E3 		mov	r0, #1000
 4908 2bd4 FEFFFFEB 		bl	_tx_thread_sleep
 4909 2bd8 F9FFFFEA 		b	.L423
 4910              	.LVL355:
 4911              	.L387:
 4912              	.LBE144:
 4913              	.LBE143:
 4914              	.LBB145:
 4915              	.LBB105:
2923:../uvc.c      ****             switch (bRequest)
 4916              		.loc 1 2923 0
 4917 2bdc 850053E3 		cmp	r3, #133
 4918 2be0 8CFFFF0A 		beq	.L404
 4919 2be4 860053E3 		cmp	r3, #134
 4920 2be8 ACFEFF1A 		bne	.L393
 4921              	.L433:
2927:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4922              		.loc 1 2927 0
 4923 2bec 0100A0E3 		mov	r0, #1
 4924 2bf0 BFFFFFEA 		b	.L428
 4925              	.LVL356:
 4926              	.L317:
 4927              	.LBE105:
 4928              	.LBE145:
 4929              	.LBB146:
 4930              	.LBB92:
2502:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4931              		.loc 1 2502 0
 4932 2bf4 0600A0E3 		mov	r0, #6
 4933 2bf8 FEFFFFEB 		bl	ControlHandle
 4934              	.LVL357:
 4935 2bfc 38309DE5 		ldr	r3, [sp, #56]
 4936 2c00 2AFEFFEA 		b	.L304
 4937              	.L324:
2475:../uvc.c      ****     switch (wValue)
 4938              		.loc 1 2475 0
 4939 2c04 0D0C52E3 		cmp	r2, #3328
 4940 2c08 0700000A 		beq	.L319
 4941 2c0c 0E0C52E3 		cmp	r2, #3584
 4942 2c10 0900000A 		beq	.L321
 4943 2c14 030B52E3 		cmp	r2, #3072
 4944 2c18 1BFEFF1A 		bne	.L325
 4945              	.LVL358:
2516:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4946              		.loc 1 2516 0
 4947 2c1c 0B00A0E3 		mov	r0, #11
 4948 2c20 FEFFFFEB 		bl	ControlHandle
 4949              	.LVL359:
 4950 2c24 38309DE5 		ldr	r3, [sp, #56]
 4951 2c28 20FEFFEA 		b	.L304
 4952              	.L319:
 4953              	.LVL360:
2512:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4954              		.loc 1 2512 0
 4955 2c2c 0900A0E3 		mov	r0, #9
 4956 2c30 FEFFFFEB 		bl	ControlHandle
 4957              	.LVL361:
 4958 2c34 38309DE5 		ldr	r3, [sp, #56]
 4959 2c38 1CFEFFEA 		b	.L304
 4960              	.L321:
 4961              	.LVL362:
2520:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4962              		.loc 1 2520 0
 4963 2c3c 0E00A0E3 		mov	r0, #14
 4964 2c40 FEFFFFEB 		bl	ControlHandle
 4965              	.LVL363:
 4966 2c44 38309DE5 		ldr	r3, [sp, #56]
 4967 2c48 18FEFFEA 		b	.L304
 4968              	.L323:
2475:../uvc.c      ****     switch (wValue)
 4969              		.loc 1 2475 0
 4970 2c4c 010B52E3 		cmp	r2, #1024
 4971 2c50 16FEFF0A 		beq	.L304
 4972 2c54 050C52E3 		cmp	r2, #1280
 4973 2c58 0BFEFF1A 		bne	.L325
 4974              	.LVL364:
2494:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4975              		.loc 1 2494 0
 4976 2c5c 0400A0E3 		mov	r0, #4
 4977 2c60 FEFFFFEB 		bl	ControlHandle
 4978              	.LVL365:
 4979 2c64 38309DE5 		ldr	r3, [sp, #56]
 4980 2c68 10FEFFEA 		b	.L304
 4981              	.L314:
 4982              	.LVL366:
2487:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4983              		.loc 1 2487 0
 4984 2c6c 0200A0E3 		mov	r0, #2
 4985 2c70 FEFFFFEB 		bl	ControlHandle
 4986              	.LVL367:
 4987 2c74 38309DE5 		ldr	r3, [sp, #56]
 4988 2c78 0CFEFFEA 		b	.L304
 4989              	.L316:
 4990              	.LVL368:
2498:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4991              		.loc 1 2498 0
 4992 2c7c 0500A0E3 		mov	r0, #5
 4993 2c80 FEFFFFEB 		bl	ControlHandle
 4994              	.LVL369:
 4995 2c84 38309DE5 		ldr	r3, [sp, #56]
 4996 2c88 08FEFFEA 		b	.L304
 4997              	.LVL370:
 4998              	.L417:
 4999              	.LBE92:
 5000              	.LBE146:
 5001              	.LBB147:
 5002              	.LBB112:
3122:../uvc.c      ****                 switch (bRequest)
 5003              		.loc 1 3122 0
 5004 2c8c 850052E3 		cmp	r2, #133
 5005 2c90 7200000A 		beq	.L415
 5006 2c94 860052E3 		cmp	r2, #134
 5007 2c98 09FEFF1A 		bne	.L368
 5008 2c9c D2FFFFEA 		b	.L433
 5009              	.LVL371:
 5010              	.L362:
 5011              	.LBE112:
 5012              	.LBE147:
 5013              	.LBB148:
 5014              	.LBB119:
2775:../uvc.c      ****     switch (wValue)
 5015              		.loc 1 2775 0
 5016 2ca0 060C53E3 		cmp	r3, #1536
 5017 2ca4 6900000A 		beq	.L349
 5018 2ca8 0900008A 		bhi	.L363
 5019 2cac 050C53E3 		cmp	r3, #1280
 5020 2cb0 F9FDFF1A 		bne	.L305
 5021              	.LVL372:
2795:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5022              		.loc 1 2795 0
 5023 2cb4 1400A0E3 		mov	r0, #20
 5024 2cb8 FEFFFFEB 		bl	ControlHandle
 5025              	.LVL373:
 5026 2cbc 38309DE5 		ldr	r3, [sp, #56]
 5027 2cc0 FAFDFFEA 		b	.L304
 5028              	.L332:
 5029              	.LVL374:
 5030              	.LBE119:
 5031              	.LBE148:
 5032              	.LBB149:
 5033              	.LBB94:
2580:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5034              		.loc 1 2580 0
 5035 2cc4 0600A0E3 		mov	r0, #6
 5036 2cc8 FEFFFFEB 		bl	CTControlHandle
 5037              	.LVL375:
 5038 2ccc 38309DE5 		ldr	r3, [sp, #56]
 5039 2cd0 F6FDFFEA 		b	.L304
 5040              	.L363:
 5041              	.LBE94:
 5042              	.LBE149:
 5043              	.LBB150:
 5044              	.LBB124:
2775:../uvc.c      ****     switch (wValue)
 5045              		.loc 1 2775 0
 5046 2cd4 070C53E3 		cmp	r3, #1792
 5047 2cd8 5800000A 		beq	.L350
 5048 2cdc 020B53E3 		cmp	r3, #2048
 5049 2ce0 EDFDFF1A 		bne	.L305
 5050              	.LVL376:
2807:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5051              		.loc 1 2807 0
 5052 2ce4 1700A0E3 		mov	r0, #23
 5053 2ce8 FEFFFFEB 		bl	ControlHandle
 5054              	.LVL377:
 5055 2cec 38309DE5 		ldr	r3, [sp, #56]
 5056 2cf0 EEFDFFEA 		b	.L304
 5057              	.L339:
 5058              	.LBE124:
 5059              	.LBE150:
 5060              	.LBB151:
 5061              	.LBB101:
2550:../uvc.c      ****     switch (wValue)
 5062              		.loc 1 2550 0
 5063 2cf4 0B0C52E3 		cmp	r2, #2816
 5064 2cf8 0F00000A 		beq	.L335
 5065 2cfc 030B52E3 		cmp	r2, #3072
 5066 2d00 0900000A 		beq	.L336
 5067 2d04 0A0C52E3 		cmp	r2, #2560
 5068 2d08 DFFDFF1A 		bne	.L325
 5069              	.LVL378:
2591:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5070              		.loc 1 2591 0
 5071 2d0c 0800A0E3 		mov	r0, #8
 5072 2d10 FEFFFFEB 		bl	CTControlHandle
 5073              	.LVL379:
 5074 2d14 38309DE5 		ldr	r3, [sp, #56]
 5075 2d18 E4FDFFEA 		b	.L304
 5076              	.L333:
 5077              	.LVL380:
2586:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5078              		.loc 1 2586 0
 5079 2d1c 0700A0E3 		mov	r0, #7
 5080 2d20 FEFFFFEB 		bl	CTControlHandle
 5081              	.LVL381:
 5082 2d24 38309DE5 		ldr	r3, [sp, #56]
 5083 2d28 E0FDFFEA 		b	.L304
 5084              	.L336:
 5085              	.LVL382:
2599:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5086              		.loc 1 2599 0
 5087 2d2c 0A00A0E3 		mov	r0, #10
 5088 2d30 FEFFFFEB 		bl	CTControlHandle
 5089              	.LVL383:
 5090 2d34 38309DE5 		ldr	r3, [sp, #56]
 5091 2d38 DCFDFFEA 		b	.L304
 5092              	.L335:
 5093              	.LVL384:
2595:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5094              		.loc 1 2595 0
 5095 2d3c 0900A0E3 		mov	r0, #9
 5096 2d40 FEFFFFEB 		bl	CTControlHandle
 5097              	.LVL385:
 5098 2d44 38309DE5 		ldr	r3, [sp, #56]
 5099 2d48 D8FDFFEA 		b	.L304
 5100              	.L358:
 5101              	.LVL386:
 5102              	.LBE101:
 5103              	.LBE151:
 5104              	.LBB152:
 5105              	.LBB118:
2842:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 5106              		.loc 1 2842 0
 5107 2d4c 2400A0E3 		mov	r0, #36
 5108 2d50 FEFFFFEB 		bl	ControlHandle
 5109              	.LVL387:
 5110 2d54 38309DE5 		ldr	r3, [sp, #56]
 5111 2d58 D4FDFFEA 		b	.L304
 5112              	.LVL388:
 5113              	.L442:
 5114              	.LBE118:
 5115              	.LBE152:
 5116              	.LBB153:
 5117              	.LBB104:
2948:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5118              		.loc 1 2948 0
 5119 2d5c 2000A0E3 		mov	r0, #32
 5120 2d60 E4119FE5 		ldr	r1, .L446+44
 5121 2d64 3E208DE2 		add	r2, sp, #62
 5122 2d68 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5123              	.LVL389:
2950:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)//supports both SS and HS
 5124              		.loc 1 2950 0
 5125 2d6c 000050E3 		cmp	r0, #0
 5126 2d70 D7FDFF1A 		bne	.L429
2952:../uvc.c      ****                         switch (glCommitCtrl[3])
 5127              		.loc 1 2952 0
 5128 2d74 7F30D4E5 		ldrb	r3, [r4, #127]	@ zero_extendqisi2
 5129 2d78 010053E3 		cmp	r3, #1
 5130 2d7c 1E00000A 		beq	.L390
 5131 2d80 020053E3 		cmp	r3, #2
 5132 2d84 0B00001A 		bne	.L389
2960:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
 5133              		.loc 1 2960 0
 5134 2d88 3010A0E3 		mov	r1, #48
 5135 2d8c 0120A0E3 		mov	r2, #1
 5136 2d90 5230A0E3 		mov	r3, #82
 5137 2d94 0B00A0E3 		mov	r0, #11
 5138              	.LVL390:
 5139 2d98 FEFFFFEB 		bl	SensorSetIrisControl
2961:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5140              		.loc 1 2961 0
 5141 2d9c 7D0FA0E3 		mov	r0, #500
 5142 2da0 FEFFFFEB 		bl	_tx_thread_sleep
2962:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
 5143              		.loc 1 2962 0
 5144 2da4 0400A0E3 		mov	r0, #4
 5145 2da8 D0119FE5 		ldr	r1, .L446+96
 5146 2dac 0120A0E3 		mov	r2, #1
 5147 2db0 0B30A0E3 		mov	r3, #11
 5148 2db4 FEFFFFEB 		bl	CyU3PDebugPrint
 5149              	.L389:
2967:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5150              		.loc 1 2967 0
 5151 2db8 7FE0D4E5 		ldrb	lr, [r4, #127]	@ zero_extendqisi2
2968:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5152              		.loc 1 2968 0
 5153 2dbc C0119FE5 		ldr	r1, .L446+100
 5154 2dc0 0E20A0E1 		mov	r2, lr
 5155 2dc4 0400A0E3 		mov	r0, #4
2967:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5156              		.loc 1 2967 0
 5157 2dc8 9CE0C4E5 		strb	lr, [r4, #156]
2968:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5158              		.loc 1 2968 0
 5159 2dcc FEFFFFEB 		bl	CyU3PDebugPrint
2981:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5160              		.loc 1 2981 0
 5161 2dd0 0020A0E3 		mov	r2, #0
 5162 2dd4 44019FE5 		ldr	r0, .L446
 5163 2dd8 0110A0E3 		mov	r1, #1
 5164 2ddc FEFFFFEB 		bl	_txe_event_flags_set
 5165              	.LVL391:
2982:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5166              		.loc 1 2982 0
 5167 2de0 002050E2 		subs	r2, r0, #0
 5168 2de4 BAFDFF0A 		beq	.L429
2984:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 5169              		.loc 1 2984 0
 5170 2de8 0400A0E3 		mov	r0, #4
 5171              	.LVL392:
 5172 2dec 94119FE5 		ldr	r1, .L446+104
 5173 2df0 FEFFFFEB 		bl	CyU3PDebugPrint
 5174              	.LVL393:
 5175 2df4 38309DE5 		ldr	r3, [sp, #56]
 5176 2df8 B6FDFFEA 		b	.L366
 5177              	.LVL394:
 5178              	.L390:
2955:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
 5179              		.loc 1 2955 0
 5180 2dfc 3010A0E3 		mov	r1, #48
 5181 2e00 0020A0E3 		mov	r2, #0
 5182 2e04 5230A0E3 		mov	r3, #82
 5183 2e08 0B00A0E3 		mov	r0, #11
 5184              	.LVL395:
 5185 2e0c FEFFFFEB 		bl	SensorSetIrisControl
2956:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5186              		.loc 1 2956 0
 5187 2e10 7D0FA0E3 		mov	r0, #500
 5188 2e14 FEFFFFEB 		bl	_tx_thread_sleep
2957:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
 5189              		.loc 1 2957 0
 5190 2e18 60119FE5 		ldr	r1, .L446+96
 5191 2e1c 0020A0E3 		mov	r2, #0
 5192 2e20 0B30A0E3 		mov	r3, #11
 5193 2e24 0400A0E3 		mov	r0, #4
 5194 2e28 FEFFFFEB 		bl	CyU3PDebugPrint
 5195 2e2c E1FFFFEA 		b	.L389
 5196              	.L346:
 5197              	.LVL396:
 5198              	.LBE104:
 5199              	.LBE153:
 5200              	.LBB154:
 5201              	.LBB125:
2787:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5202              		.loc 1 2787 0
 5203 2e30 1200A0E3 		mov	r0, #18
 5204 2e34 FEFFFFEB 		bl	ControlHandle
 5205              	.LVL397:
 5206 2e38 38309DE5 		ldr	r3, [sp, #56]
 5207 2e3c 9BFDFFEA 		b	.L304
 5208              	.L350:
 5209              	.LVL398:
2803:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5210              		.loc 1 2803 0
 5211 2e40 1600A0E3 		mov	r0, #22
 5212 2e44 FEFFFFEB 		bl	ControlHandle
 5213              	.LVL399:
 5214 2e48 38309DE5 		ldr	r3, [sp, #56]
 5215 2e4c 97FDFFEA 		b	.L304
 5216              	.L349:
 5217              	.LVL400:
2799:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5218              		.loc 1 2799 0
 5219 2e50 1500A0E3 		mov	r0, #21
 5220 2e54 FEFFFFEB 		bl	ControlHandle
 5221              	.LVL401:
 5222 2e58 38309DE5 		ldr	r3, [sp, #56]
 5223 2e5c 93FDFFEA 		b	.L304
 5224              	.LVL402:
 5225              	.L415:
 5226              	.LBE125:
 5227              	.LBE154:
 5228              	.LBB155:
 5229              	.LBB113:
3131:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5230              		.loc 1 3131 0
 5231 2e60 0200A0E3 		mov	r0, #2
 5232 2e64 04119FE5 		ldr	r1, .L446+80
 5233 2e68 EDFEFFEA 		b	.L430
 5234              	.LVL403:
 5235              	.L359:
 5236              	.LBE113:
 5237              	.LBE155:
 5238              	.LBB156:
 5239              	.LBB117:
2846:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 5240              		.loc 1 2846 0
 5241 2e6c 2500A0E3 		mov	r0, #37
 5242 2e70 FEFFFFEB 		bl	ControlHandle
 5243              	.LVL404:
 5244 2e74 38309DE5 		ldr	r3, [sp, #56]
 5245 2e78 8CFDFFEA 		b	.L304
 5246              	.L355:
 5247              	.LVL405:
2826:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5248              		.loc 1 2826 0
 5249 2e7c 1C00A0E3 		mov	r0, #28
 5250 2e80 FEFFFFEB 		bl	ControlHandle
 5251              	.LVL406:
 5252 2e84 38309DE5 		ldr	r3, [sp, #56]
 5253 2e88 88FDFFEA 		b	.L304
 5254              	.L354:
 5255              	.LVL407:
2822:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5256              		.loc 1 2822 0
 5257 2e8c 1A00A0E3 		mov	r0, #26
 5258 2e90 FEFFFFEB 		bl	ControlHandle
 5259              	.LVL408:
 5260 2e94 38309DE5 		ldr	r3, [sp, #56]
 5261 2e98 84FDFFEA 		b	.L304
 5262              	.L356:
 5263              	.LVL409:
2834:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5264              		.loc 1 2834 0
 5265 2e9c 1E00A0E3 		mov	r0, #30
 5266 2ea0 FEFFFFEB 		bl	ControlHandle
 5267              	.LVL410:
 5268 2ea4 38309DE5 		ldr	r3, [sp, #56]
 5269 2ea8 80FDFFEA 		b	.L304
 5270              	.LVL411:
 5271              	.L418:
 5272              	.LBE117:
 5273              	.LBE156:
 5274              	.LBB157:
 5275              	.LBB103:
3165:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5276              		.loc 1 3165 0
 5277 2eac D8109FE5 		ldr	r1, .L446+108
 5278 2eb0 BE23DDE1 		ldrh	r2, [sp, #62]
 5279 2eb4 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 5280 2eb8 0400A0E3 		mov	r0, #4
 5281              	.LVL412:
 5282 2ebc FEFFFFEB 		bl	CyU3PDebugPrint
 5283 2ec0 7FFDFFEA 		b	.L368
 5284              	.L345:
 5285              	.LVL413:
 5286              	.LBE103:
 5287              	.LBE157:
 5288              	.LBB158:
 5289              	.LBB126:
2783:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5290              		.loc 1 2783 0
 5291 2ec4 1100A0E3 		mov	r0, #17
 5292 2ec8 FEFFFFEB 		bl	ControlHandle
 5293              	.LVL414:
 5294 2ecc 38309DE5 		ldr	r3, [sp, #56]
 5295 2ed0 76FDFFEA 		b	.L304
 5296              	.L347:
 5297              	.LVL415:
2791:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5298              		.loc 1 2791 0
 5299 2ed4 1300A0E3 		mov	r0, #19
 5300 2ed8 FEFFFFEB 		bl	ControlHandle
 5301              	.LVL416:
 5302 2edc 38309DE5 		ldr	r3, [sp, #56]
 5303 2ee0 72FDFFEA 		b	.L304
 5304              	.L352:
 5305              	.LVL417:
2811:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5306              		.loc 1 2811 0
 5307 2ee4 1800A0E3 		mov	r0, #24
 5308 2ee8 FEFFFFEB 		bl	ControlHandle
 5309              	.LVL418:
 5310 2eec 38309DE5 		ldr	r3, [sp, #56]
 5311 2ef0 6EFDFFEA 		b	.L304
 5312              	.LVL419:
 5313              	.L410:
 5314              	.LBE126:
 5315              	.LBE158:
 5316              	.LBB159:
 5317              	.LBB114:
3101:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*
 5318              		.loc 1 3101 0
 5319 2ef4 3010A0E3 		mov	r1, #48
 5320 2ef8 0020A0E3 		mov	r2, #0
 5321 2efc 5230A0E3 		mov	r3, #82
 5322 2f00 0B00A0E3 		mov	r0, #11
 5323              	.LVL420:
 5324 2f04 FEFFFFEB 		bl	SensorSetIrisControl
3103:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
 5325              		.loc 1 3103 0
 5326 2f08 48109FE5 		ldr	r1, .L446+56
 5327 2f0c 0B20A0E3 		mov	r2, #11
 5328 2f10 0030A0E3 		mov	r3, #0
 5329 2f14 0400A0E3 		mov	r0, #4
 5330 2f18 FEFFFFEB 		bl	CyU3PDebugPrint
 5331 2f1c 67FEFFEA 		b	.L409
 5332              	.L447:
 5333              		.align	2
 5334              	.L446:
 5335 2f20 00000000 		.word	.LANCHOR0
 5336 2f24 00000000 		.word	.LANCHOR1
 5337 2f28 00000000 		.word	bRequest
 5338 2f2c 00000000 		.word	wValue
 5339 2f30 00000000 		.word	wIndex
 5340 2f34 00000000 		.word	glInterStaBuffer
 5341 2f38 14050000 		.word	.LC28
 5342 2f3c 00000000 		.word	glChHandleInterStat
 5343 2f40 00000000 		.word	bmReqType
 5344 2f44 00000000 		.word	wLength
 5345 2f48 98040000 		.word	.LC27
 5346 2f4c 7C000000 		.word	.LANCHOR0+124
 5347 2f50 54060000 		.word	.LC36
 5348 2f54 78060000 		.word	.LC37
 5349 2f58 08060000 		.word	.LC34
 5350 2f5c 2C060000 		.word	.LC35
 5351 2f60 2C060000 		.word	.LANCHOR1+1580
 5352 2f64 38060000 		.word	.LANCHOR1+1592
 5353 2f68 10060000 		.word	.LANCHOR1+1552
 5354 2f6c 40050000 		.word	.LC29
 5355 2f70 58000000 		.word	.LANCHOR0+88
 5356 2f74 CC060000 		.word	.LC39
 5357 2f78 D4010000 		.word	.LC12
 5358 2f7c DC050000 		.word	.LC33
 5359 2f80 68050000 		.word	.LC30
 5360 2f84 8C050000 		.word	.LC31
 5361 2f88 B4050000 		.word	.LC32
 5362 2f8c A4060000 		.word	.LC38
 5363              	.LBE114:
 5364              	.LBE159:
 5365              		.cfi_endproc
 5366              	.LFE24:
 5368              		.align	2
 5369              		.global	CamDefSet
 5371              	CamDefSet:
 5372              	.LFB4:
1146:../uvc.c      **** {
 5373              		.loc 1 1146 0
 5374              		.cfi_startproc
 5375              		@ args = 0, pretend = 0, frame = 24
 5376              		@ frame_needed = 0, uses_anonymous_args = 0
 5377              	.LVL421:
 5378 2f90 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5379              	.LCFI19:
 5380              		.cfi_def_cfa_offset 36
1152:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5381              		.loc 1 1152 0
 5382 2f94 AC429FE5 		ldr	r4, .L451
 5383              		.cfi_offset 14, -4
 5384              		.cfi_offset 11, -8
 5385              		.cfi_offset 10, -12
 5386              		.cfi_offset 9, -16
 5387              		.cfi_offset 8, -20
 5388              		.cfi_offset 7, -24
 5389              		.cfi_offset 6, -28
 5390              		.cfi_offset 5, -32
 5391              		.cfi_offset 4, -36
1157:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5392              		.loc 1 1157 0
 5393 2f98 AC229FE5 		ldr	r2, .L451+4
1154:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5394              		.loc 1 1154 0
 5395 2f9c A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1146:../uvc.c      **** {
 5396              		.loc 1 1146 0
 5397 2fa0 2CD04DE2 		sub	sp, sp, #44
 5398              	.LCFI20:
 5399              		.cfi_def_cfa_offset 80
1157:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5400              		.loc 1 1157 0
 5401 2fa4 1C0092E5 		ldr	r0, [r2, #28]
 5402 2fa8 0010E0E3 		mvn	r1, #0
1159:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5403              		.loc 1 1159 0
 5404 2fac 2963A0E1 		mov	r6, r9, lsr #6
1153:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5405              		.loc 1 1153 0
 5406 2fb0 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1152:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5407              		.loc 1 1152 0
 5408 2fb4 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5409              	.LVL422:
1157:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5410              		.loc 1 1157 0
 5411 2fb8 FEFFFFEB 		bl	_txe_mutex_get
1158:../uvc.c      ****     if(Data1&0x80){
 5412              		.loc 1 1158 0
 5413 2fbc 800019E3 		tst	r9, #128
1159:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5414              		.loc 1 1159 0
 5415 2fc0 01600612 		andne	r6, r6, #1
 5416 2fc4 0660E011 		mvnne	r6, r6
 5417 2fc8 3B600612 		andne	r6, r6, #59
 5418 2fcc 0660E011 		mvnne	r6, r6
 5419 2fd0 FF600612 		andne	r6, r6, #255
 5420              	.LVL423:
1161:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5421              		.loc 1 1161 0
 5422 2fd4 C6608603 		orreq	r6, r6, #198
 5423              	.LVL424:
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5424              		.loc 1 1165 0
 5425 2fd8 0080A0E3 		mov	r8, #0
 5426 2fdc 0A20A0E1 		mov	r2, sl
 5427 2fe0 0730A0E1 		mov	r3, r7
 5428 2fe4 0110A0E3 		mov	r1, #1
1163:../uvc.c      ****     Data0 = (Data0 << 2);
 5429              		.loc 1 1163 0
 5430 2fe8 0951A0E1 		mov	r5, r9, asl #2
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5431              		.loc 1 1165 0
 5432 2fec 58029FE5 		ldr	r0, .L451+4
1168:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5433              		.loc 1 1168 0
 5434 2ff0 0190A0E3 		mov	r9, #1
 5435              	.LVL425:
1163:../uvc.c      ****     Data0 = (Data0 << 2);
 5436              		.loc 1 1163 0
 5437 2ff4 FF5005E2 		and	r5, r5, #255
 5438              	.LVL426:
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5439              		.loc 1 1165 0
 5440 2ff8 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5441 2ffc FEFFFFEB 		bl	cmdSet
 5442              	.LVL427:
1168:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5443              		.loc 1 1168 0
 5444 3000 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5445 3004 0910A0E1 		mov	r1, r9
 5446 3008 0730A0E1 		mov	r3, r7
 5447 300c 38029FE5 		ldr	r0, .L451+4
 5448 3010 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5449 3014 FEFFFFEB 		bl	cmdSet
 5450              	.LVL428:
1171:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5451              		.loc 1 1171 0
 5452 3018 0620A0E1 		mov	r2, r6
 5453 301c 0530A0E1 		mov	r3, r5
 5454 3020 28129FE5 		ldr	r1, .L451+8
 5455 3024 0400A0E3 		mov	r0, #4
1170:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5456              		.loc 1 1170 0
 5457 3028 A661C4E5 		strb	r6, [r4, #422]
1169:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5458              		.loc 1 1169 0
 5459 302c A551C4E5 		strb	r5, [r4, #421]
1171:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5460              		.loc 1 1171 0
 5461 3030 FEFFFFEB 		bl	CyU3PDebugPrint
 5462              	.LVL429:
1176:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5463              		.loc 1 1176 0
 5464 3034 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5465              	.LVL430:
1177:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5466              		.loc 1 1177 0
 5467 3038 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5468 303c BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5469 3040 0210A0E3 		mov	r1, #2
 5470 3044 00029FE5 		ldr	r0, .L451+4
 5471 3048 00B08DE5 		str	fp, [sp, #0]
 5472 304c 04808DE5 		str	r8, [sp, #4]
 5473 3050 FEFFFFEB 		bl	cmdSet
 5474              	.LVL431:
1179:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5475              		.loc 1 1179 0
 5476 3054 0B20A0E1 		mov	r2, fp
 5477 3058 0530A0E1 		mov	r3, r5
 5478 305c EC119FE5 		ldr	r1, .L451+8
 5479 3060 0400A0E3 		mov	r0, #4
1178:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5480              		.loc 1 1178 0
 5481 3064 BD51C4E5 		strb	r5, [r4, #445]
1179:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5482              		.loc 1 1179 0
 5483 3068 FEFFFFEB 		bl	CyU3PDebugPrint
 5484              	.LVL432:
1184:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5485              		.loc 1 1184 0
 5486 306c 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1183:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5487              		.loc 1 1183 0
 5488 3070 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5489              	.LVL433:
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5490              		.loc 1 1185 0
 5491 3074 80B047E2 		sub	fp, r7, #128
 5492 3078 FF100BE2 		and	r1, fp, #255
 5493 307c 14108DE5 		str	r1, [sp, #20]
 5494 3080 14C09DE5 		ldr	ip, [sp, #20]
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5495              		.loc 1 1186 0
 5496 3084 760047E2 		sub	r0, r7, #118
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5497              		.loc 1 1187 0
 5498 3088 7EE087E2 		add	lr, r7, #126
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5499              		.loc 1 1185 0
 5500 308c 0630A0E1 		mov	r3, r6
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5501              		.loc 1 1186 0
 5502 3090 18008DE5 		str	r0, [sp, #24]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5503              		.loc 1 1185 0
 5504 3094 0510A0E3 		mov	r1, #5
 5505 3098 DF20A0E3 		mov	r2, #223
 5506 309c A8019FE5 		ldr	r0, .L451+4
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5507              		.loc 1 1187 0
 5508 30a0 1CE08DE5 		str	lr, [sp, #28]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5509              		.loc 1 1185 0
 5510 30a4 00C08DE5 		str	ip, [sp, #0]
 5511 30a8 04808DE5 		str	r8, [sp, #4]
 5512 30ac FEFFFFEB 		bl	cmdSet
 5513              	.LVL434:
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5514              		.loc 1 1186 0
 5515 30b0 18A09DE5 		ldr	sl, [sp, #24]
1188:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5516              		.loc 1 1188 0
 5517 30b4 72E087E2 		add	lr, r7, #114
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5518              		.loc 1 1186 0
 5519 30b8 FFC00AE2 		and	ip, sl, #255
 5520 30bc 0630A0E1 		mov	r3, r6
 5521 30c0 0510A0E3 		mov	r1, #5
 5522 30c4 DC20A0E3 		mov	r2, #220
 5523 30c8 7C019FE5 		ldr	r0, .L451+4
1188:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5524              		.loc 1 1188 0
 5525 30cc 20E08DE5 		str	lr, [sp, #32]
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5526              		.loc 1 1186 0
 5527 30d0 00C08DE5 		str	ip, [sp, #0]
 5528 30d4 04908DE5 		str	r9, [sp, #4]
 5529 30d8 FEFFFFEB 		bl	cmdSet
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5530              		.loc 1 1187 0
 5531 30dc 1C009DE5 		ldr	r0, [sp, #28]
 5532 30e0 02E0A0E3 		mov	lr, #2
 5533 30e4 FFC000E2 		and	ip, r0, #255
 5534 30e8 0630A0E1 		mov	r3, r6
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5535              		.loc 1 1189 0
 5536 30ec 6FA047E2 		sub	sl, r7, #111
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5537              		.loc 1 1187 0
 5538 30f0 0510A0E3 		mov	r1, #5
 5539 30f4 DE20A0E3 		mov	r2, #222
 5540 30f8 4C019FE5 		ldr	r0, .L451+4
 5541 30fc 04E08DE5 		str	lr, [sp, #4]
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5542              		.loc 1 1189 0
 5543 3100 24A08DE5 		str	sl, [sp, #36]
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5544              		.loc 1 1187 0
 5545 3104 00C08DE5 		str	ip, [sp, #0]
 5546 3108 FEFFFFEB 		bl	cmdSet
1188:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5547              		.loc 1 1188 0
 5548 310c 20A09DE5 		ldr	sl, [sp, #32]
 5549 3110 0630A0E1 		mov	r3, r6
 5550 3114 FFC00AE2 		and	ip, sl, #255
 5551 3118 00C08DE5 		str	ip, [sp, #0]
 5552 311c 0510A0E3 		mov	r1, #5
 5553 3120 03C0A0E3 		mov	ip, #3
 5554 3124 E020A0E3 		mov	r2, #224
 5555 3128 1C019FE5 		ldr	r0, .L451+4
 5556 312c 04C08DE5 		str	ip, [sp, #4]
 5557 3130 FEFFFFEB 		bl	cmdSet
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5558              		.loc 1 1189 0
 5559 3134 24009DE5 		ldr	r0, [sp, #36]
 5560 3138 04A0A0E3 		mov	sl, #4
 5561 313c FFC000E2 		and	ip, r0, #255
 5562 3140 0630A0E1 		mov	r3, r6
 5563 3144 0510A0E3 		mov	r1, #5
 5564 3148 DD20A0E3 		mov	r2, #221
 5565 314c F8009FE5 		ldr	r0, .L451+4
 5566 3150 00C08DE5 		str	ip, [sp, #0]
1190:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5567              		.loc 1 1190 0
 5568 3154 7F7087E2 		add	r7, r7, #127
 5569              	.LVL435:
1189:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5570              		.loc 1 1189 0
 5571 3158 04A08DE5 		str	sl, [sp, #4]
 5572 315c FEFFFFEB 		bl	cmdSet
1190:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5573              		.loc 1 1190 0
 5574 3160 05E0A0E3 		mov	lr, #5
 5575 3164 0E10A0E1 		mov	r1, lr
 5576 3168 0630A0E1 		mov	r3, r6
 5577 316c E120A0E3 		mov	r2, #225
 5578 3170 FF6007E2 		and	r6, r7, #255
 5579              	.LVL436:
 5580 3174 D0009FE5 		ldr	r0, .L451+4
 5581 3178 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5582 317c FEFFFFEB 		bl	cmdSet
 5583              	.LVL437:
1191:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5584              		.loc 1 1191 0
 5585 3180 14C09DE5 		ldr	ip, [sp, #20]
1192:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5586              		.loc 1 1192 0
 5587 3184 24E09DE5 		ldr	lr, [sp, #36]
 5588 3188 1C609DE5 		ldr	r6, [sp, #28]
1191:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5589              		.loc 1 1191 0
 5590 318c 05C2C4E5 		strb	ip, [r4, #517]
1192:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5591              		.loc 1 1192 0
 5592 3190 20C09DE5 		ldr	ip, [sp, #32]
 5593 3194 0B20A0E1 		mov	r2, fp
 5594 3198 18309DE5 		ldr	r3, [sp, #24]
 5595 319c B0109FE5 		ldr	r1, .L451+12
 5596 31a0 0A00A0E1 		mov	r0, sl
 5597 31a4 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5598 31a8 0C708DE5 		str	r7, [sp, #12]
 5599 31ac FEFFFFEB 		bl	CyU3PDebugPrint
 5600              	.LVL438:
1196:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5601              		.loc 1 1196 0
 5602 31b0 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5603              	.LVL439:
1197:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5604              		.loc 1 1197 0
 5605 31b4 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5606              	.LVL440:
1198:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5607              		.loc 1 1198 0
 5608 31b8 0730A0E1 		mov	r3, r7
 5609 31bc 0610A0E3 		mov	r1, #6
 5610 31c0 8520A0E3 		mov	r2, #133
 5611 31c4 80009FE5 		ldr	r0, .L451+4
 5612 31c8 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5613 31cc FEFFFFEB 		bl	cmdSet
1199:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5614              		.loc 1 1199 0
 5615 31d0 0730A0E1 		mov	r3, r7
 5616 31d4 0610A0E3 		mov	r1, #6
 5617 31d8 8620A0E3 		mov	r2, #134
 5618 31dc 68009FE5 		ldr	r0, .L451+4
 5619 31e0 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5620 31e4 FEFFFFEB 		bl	cmdSet
1201:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5621              		.loc 1 1201 0
 5622 31e8 0620A0E1 		mov	r2, r6
 5623 31ec 0530A0E1 		mov	r3, r5
 5624 31f0 58109FE5 		ldr	r1, .L451+8
 5625 31f4 0A00A0E1 		mov	r0, sl
1200:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5626              		.loc 1 1200 0
 5627 31f8 1D62C4E5 		strb	r6, [r4, #541]
1201:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5628              		.loc 1 1201 0
 5629 31fc FEFFFFEB 		bl	CyU3PDebugPrint
 5630              	.LVL441:
1206:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5631              		.loc 1 1206 0
 5632 3200 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5633              	.LVL442:
1207:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5634              		.loc 1 1207 0
 5635 3204 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5636 3208 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5637 320c 0710A0E3 		mov	r1, #7
 5638 3210 34009FE5 		ldr	r0, .L451+4
 5639 3214 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5640 3218 FEFFFFEB 		bl	cmdSet
 5641              	.LVL443:
1209:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5642              		.loc 1 1209 0
 5643 321c 0530A0E1 		mov	r3, r5
 5644 3220 0A00A0E1 		mov	r0, sl
 5645 3224 24109FE5 		ldr	r1, .L451+8
 5646 3228 0620A0E1 		mov	r2, r6
1208:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5647              		.loc 1 1208 0
 5648 322c 3552C4E5 		strb	r5, [r4, #565]
1209:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5649              		.loc 1 1209 0
 5650 3230 FEFFFFEB 		bl	CyU3PDebugPrint
1211:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5651              		.loc 1 1211 0
 5652 3234 10309FE5 		ldr	r3, .L451+4
 5653 3238 1C0093E5 		ldr	r0, [r3, #28]
1214:../uvc.c      **** }
 5654              		.loc 1 1214 0
 5655 323c 2CD08DE2 		add	sp, sp, #44
 5656 3240 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1211:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5657              		.loc 1 1211 0
 5658 3244 FEFFFFEA 		b	_txe_mutex_put
 5659              	.L452:
 5660              		.align	2
 5661              	.L451:
 5662 3248 00000000 		.word	.LANCHOR1
 5663 324c 00000000 		.word	cmdQu
 5664 3250 00070000 		.word	.LC40
 5665 3254 20070000 		.word	.LC41
 5666              		.cfi_endproc
 5667              	.LFE4:
 5669              		.align	2
 5670              		.global	CyFxUVCAddHeader
 5672              	CyFxUVCAddHeader:
 5673              	.LFB5:
1222:../uvc.c      **** {
 5674              		.loc 1 1222 0
 5675              		.cfi_startproc
 5676              		@ args = 0, pretend = 0, frame = 0
 5677              		@ frame_needed = 0, uses_anonymous_args = 0
 5678              	.LVL444:
 5679 3258 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5680              	.LCFI21:
 5681              		.cfi_def_cfa_offset 16
1224:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5682              		.loc 1 1224 0
 5683 325c 0C20A0E3 		mov	r2, #12
1222:../uvc.c      **** {
 5684              		.loc 1 1222 0
 5685 3260 0150A0E1 		mov	r5, r1
 5686              		.cfi_offset 14, -4
 5687              		.cfi_offset 5, -8
 5688              		.cfi_offset 4, -12
 5689              		.cfi_offset 3, -16
1224:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5690              		.loc 1 1224 0
 5691 3264 18109FE5 		ldr	r1, .L455
 5692              	.LVL445:
1222:../uvc.c      **** {
 5693              		.loc 1 1222 0
 5694 3268 0040A0E1 		mov	r4, r0
1224:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5695              		.loc 1 1224 0
 5696 326c FEFFFFEB 		bl	CyU3PMemCopy
 5697              	.LVL446:
1227:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5698              		.loc 1 1227 0
 5699 3270 020015E3 		tst	r5, #2
1229:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5700              		.loc 1 1229 0
 5701 3274 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5702 3278 02308313 		orrne	r3, r3, #2
 5703 327c 0130C415 		strneb	r3, [r4, #1]
 5704 3280 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5705              	.L456:
 5706              		.align	2
 5707              	.L455:
 5708 3284 80040000 		.word	.LANCHOR1+1152
 5709              		.cfi_endproc
 5710              	.LFE5:
 5712              		.align	2
 5713              		.global	CyFxAppErrorHandler
 5715              	CyFxAppErrorHandler:
 5716              	.LFB6:
1239:../uvc.c      **** {
 5717              		.loc 1 1239 0
 5718              		.cfi_startproc
 5719              		@ args = 0, pretend = 0, frame = 0
 5720              		@ frame_needed = 0, uses_anonymous_args = 0
 5721              	.LVL447:
 5722 3288 08402DE9 		stmfd	sp!, {r3, lr}
 5723              	.LCFI22:
 5724              		.cfi_def_cfa_offset 8
 5725              	.LVL448:
 5726              	.L458:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5727              		.loc 1 1249 0 discriminator 1
 5728 328c 10109FE5 		ldr	r1, .L459
 5729 3290 0400A0E3 		mov	r0, #4
 5730              		.cfi_offset 14, -4
 5731              		.cfi_offset 3, -8
 5732 3294 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 5733              		.loc 1 1250 0 discriminator 1
 5734 3298 FA0FA0E3 		mov	r0, #1000
 5735 329c FEFFFFEB 		bl	_tx_thread_sleep
 5736 32a0 F9FFFFEA 		b	.L458
 5737              	.L460:
 5738              		.align	2
 5739              	.L459:
 5740 32a4 D4010000 		.word	.LC12
 5741              		.cfi_endproc
 5742              	.LFE6:
 5744              		.align	2
 5745              		.global	UVCAppThread_Entry
 5747              	UVCAppThread_Entry:
 5748              	.LFB18:
2195:../uvc.c      **** {
 5749              		.loc 1 2195 0
 5750              		.cfi_startproc
 5751              		@ args = 0, pretend = 0, frame = 176
 5752              		@ frame_needed = 0, uses_anonymous_args = 0
 5753              	.LVL449:
 5754 32a8 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5755              	.LCFI23:
 5756              		.cfi_def_cfa_offset 28
 5757 32ac BCD04DE2 		sub	sp, sp, #188
 5758              	.LCFI24:
 5759              		.cfi_def_cfa_offset 216
 5760              	.LBB216:
 5761              	.LBB217:
1651:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5762              		.loc 1 1651 0
 5763              		.cfi_offset 14, -4
 5764              		.cfi_offset 10, -8
 5765              		.cfi_offset 8, -12
 5766              		.cfi_offset 7, -16
 5767              		.cfi_offset 6, -20
 5768              		.cfi_offset 5, -24
 5769              		.cfi_offset 4, -28
 5770 32b0 FEFFFFEB 		bl	CyU3PUartInit
 5771              	.LVL450:
1652:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5772              		.loc 1 1652 0
 5773 32b4 004050E2 		subs	r4, r0, #0
 5774 32b8 0400000A 		beq	.L462
1654:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5775              		.loc 1 1654 0
 5776 32bc 0400A0E3 		mov	r0, #4
 5777              	.LVL451:
 5778 32c0 B41B9FE5 		ldr	r1, .L563
 5779 32c4 FEFFFFEB 		bl	CyU3PDebugPrint
1655:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5780              		.loc 1 1655 0
 5781 32c8 0400A0E1 		mov	r0, r4
 5782 32cc FEFFFFEB 		bl	CyFxAppErrorHandler
 5783              	.L462:
1659:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5784              		.loc 1 1659 0
 5785 32d0 A8CB9FE5 		ldr	ip, .L563+4
1661:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5786              		.loc 1 1661 0
 5787 32d4 0030A0E3 		mov	r3, #0
1660:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5788              		.loc 1 1660 0
 5789 32d8 0120A0E3 		mov	r2, #1
1668:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5790              		.loc 1 1668 0
 5791 32dc 50008DE2 		add	r0, sp, #80
 5792 32e0 0310A0E1 		mov	r1, r3
1659:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5793              		.loc 1 1659 0
 5794 32e4 60C08DE5 		str	ip, [sp, #96]
1660:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5795              		.loc 1 1660 0
 5796 32e8 6420CDE5 		strb	r2, [sp, #100]
1661:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5797              		.loc 1 1661 0
 5798 32ec 6530CDE5 		strb	r3, [sp, #101]
1662:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5799              		.loc 1 1662 0
 5800 32f0 50208DE5 		str	r2, [sp, #80]
1663:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5801              		.loc 1 1663 0
 5802 32f4 54308DE5 		str	r3, [sp, #84]
1664:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5803              		.loc 1 1664 0
 5804 32f8 58308DE5 		str	r3, [sp, #88]
1665:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5805              		.loc 1 1665 0
 5806 32fc 5C208DE5 		str	r2, [sp, #92]
1668:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5807              		.loc 1 1668 0
 5808 3300 FEFFFFEB 		bl	CyU3PUartSetConfig
 5809              	.LVL452:
1669:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5810              		.loc 1 1669 0
 5811 3304 000050E3 		cmp	r0, #0
 5812 3308 0000000A 		beq	.L463
1671:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5813              		.loc 1 1671 0
 5814 330c FEFFFFEB 		bl	CyFxAppErrorHandler
 5815              	.LVL453:
 5816              	.L463:
1675:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5817              		.loc 1 1675 0
 5818 3310 0000E0E3 		mvn	r0, #0
 5819 3314 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5820              	.LVL454:
1676:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5821              		.loc 1 1676 0
 5822 3318 000050E3 		cmp	r0, #0
 5823 331c 0000000A 		beq	.L464
1678:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5824              		.loc 1 1678 0
 5825 3320 FEFFFFEB 		bl	CyFxAppErrorHandler
 5826              	.LVL455:
 5827              	.L464:
1682:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5828              		.loc 1 1682 0
 5829 3324 0300A0E3 		mov	r0, #3
 5830 3328 0410A0E3 		mov	r1, #4
 5831 332c FEFFFFEB 		bl	CyU3PDebugInit
 5832              	.LVL456:
1683:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5833              		.loc 1 1683 0
 5834 3330 000050E3 		cmp	r0, #0
 5835 3334 0000000A 		beq	.L465
1685:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5836              		.loc 1 1685 0
 5837 3338 FEFFFFEB 		bl	CyFxAppErrorHandler
 5838              	.LVL457:
 5839              	.L465:
1689:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5840              		.loc 1 1689 0
 5841 333c 0000A0E3 		mov	r0, #0
 5842 3340 FEFFFFEB 		bl	CyU3PDebugPreamble
 5843              	.LVL458:
 5844              	.LBE217:
 5845              	.LBE216:
2211:../uvc.c      **** 		CyU3PThreadSleep(500);
 5846              		.loc 1 2211 0
 5847 3344 7D0FA0E3 		mov	r0, #500
 5848 3348 FEFFFFEB 		bl	_tx_thread_sleep
 5849              	.LVL459:
 5850 334c 7D0FA0E3 		mov	r0, #500
 5851 3350 FEFFFFEB 		bl	_tx_thread_sleep
 5852 3354 7D0FA0E3 		mov	r0, #500
 5853 3358 FEFFFFEB 		bl	_tx_thread_sleep
 5854 335c 7D0FA0E3 		mov	r0, #500
 5855 3360 FEFFFFEB 		bl	_tx_thread_sleep
 5856 3364 7D0FA0E3 		mov	r0, #500
 5857 3368 FEFFFFEB 		bl	_tx_thread_sleep
 5858 336c 7D0FA0E3 		mov	r0, #500
 5859 3370 FEFFFFEB 		bl	_tx_thread_sleep
 5860              	.LBB218:
 5861              	.LBB219:
1700:../uvc.c      ****     status = CyU3PI2cInit ();
 5862              		.loc 1 1700 0
 5863 3374 FEFFFFEB 		bl	CyU3PI2cInit
 5864              	.LVL460:
1701:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5865              		.loc 1 1701 0
 5866 3378 002050E2 		subs	r2, r0, #0
 5867 337c 0701001A 		bne	.L535
1708:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5868              		.loc 1 1708 0
 5869 3380 FC5A9FE5 		ldr	r5, .L563+8
1710:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5870              		.loc 1 1710 0
 5871 3384 0040E0E3 		mvn	r4, #0
1713:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5872              		.loc 1 1713 0
 5873 3388 0210A0E1 		mov	r1, r2
 5874 338c 8C008DE2 		add	r0, sp, #140
 5875              	.LVL461:
1708:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5876              		.loc 1 1708 0
 5877 3390 8C508DE5 		str	r5, [sp, #140]
1709:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5878              		.loc 1 1709 0
 5879 3394 90208DE5 		str	r2, [sp, #144]
1710:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5880              		.loc 1 1710 0
 5881 3398 94408DE5 		str	r4, [sp, #148]
1711:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5882              		.loc 1 1711 0
 5883 339c B849CDE1 		strh	r4, [sp, #152]	@ movhi
1713:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5884              		.loc 1 1713 0
 5885 33a0 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5886              	.LVL462:
1714:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5887              		.loc 1 1714 0
 5888 33a4 001050E2 		subs	r1, r0, #0
 5889 33a8 0501001A 		bne	.L536
 5890              	.LBE219:
 5891              	.LBE218:
 5892              	.LBB225:
 5893              	.LBB228:
1787:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5894              		.loc 1 1787 0
 5895 33ac D44A9FE5 		ldr	r4, .L563+12
 5896 33b0 2820A0E3 		mov	r2, #40
 5897 33b4 0400A0E1 		mov	r0, r4
 5898              	.LVL463:
 5899 33b8 FEFFFFEB 		bl	_txe_event_flags_create
 5900              	.LVL464:
1788:../uvc.c      ****     if (apiRetStatus != 0)
 5901              		.loc 1 1788 0
 5902 33bc 002050E2 		subs	r2, r0, #0
 5903 33c0 0801001A 		bne	.L537
1802:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5904              		.loc 1 1802 0
 5905 33c4 0270A0E3 		mov	r7, #2
1809:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5906              		.loc 1 1809 0
 5907 33c8 0210A0E1 		mov	r1, r2
1798:../uvc.c      ****     isUsbConnected = CyFalse;
 5908              		.loc 1 1798 0
 5909 33cc 3C2084E5 		str	r2, [r4, #60]
1799:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5910              		.loc 1 1799 0
 5911 33d0 402084E5 		str	r2, [r4, #64]
1809:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5912              		.loc 1 1809 0
 5913 33d4 9C008DE2 		add	r0, sp, #156
 5914              	.LVL465:
1805:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5915              		.loc 1 1805 0
 5916 33d8 016087E2 		add	r6, r7, #1
1804:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5917              		.loc 1 1804 0
 5918 33dc A420CDE5 		strb	r2, [sp, #164]
1806:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5919              		.loc 1 1806 0
 5920 33e0 A0208DE5 		str	r2, [sp, #160]
1802:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5921              		.loc 1 1802 0
 5922 33e4 9C70CDE5 		strb	r7, [sp, #156]
1803:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5923              		.loc 1 1803 0
 5924 33e8 9D70CDE5 		strb	r7, [sp, #157]
1805:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5925              		.loc 1 1805 0
 5926 33ec A560CDE5 		strb	r6, [sp, #165]
1809:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5927              		.loc 1 1809 0
 5928 33f0 FEFFFFEB 		bl	CyU3PGpioInit
 5929              	.LVL466:
1810:../uvc.c      ****     if (apiRetStatus != 0)
 5930              		.loc 1 1810 0
 5931 33f4 002050E2 		subs	r2, r0, #0
 5932 33f8 7D01001A 		bne	.L538
1818:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5933              		.loc 1 1818 0
 5934 33fc 1600A0E3 		mov	r0, #22
 5935              	.LVL467:
 5936 3400 0110A0E3 		mov	r1, #1
 5937 3404 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5938              	.LVL468:
1819:../uvc.c      ****     if (apiRetStatus != 0)
 5939              		.loc 1 1819 0
 5940 3408 002050E2 		subs	r2, r0, #0
 5941 340c 6F01001A 		bne	.L539
1824:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5942              		.loc 1 1824 0
 5943 3410 1400A0E3 		mov	r0, #20
 5944              	.LVL469:
 5945 3414 0110A0E3 		mov	r1, #1
 5946 3418 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5947              	.LVL470:
1825:../uvc.c      ****     if (apiRetStatus != 0)
 5948              		.loc 1 1825 0
 5949 341c 002050E2 		subs	r2, r0, #0
 5950 3420 7C01001A 		bne	.L540
1830:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5951              		.loc 1 1830 0
 5952 3424 1800A0E3 		mov	r0, #24
 5953              	.LVL471:
 5954 3428 0110A0E3 		mov	r1, #1
 5955 342c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5956              	.LVL472:
1831:../uvc.c      ****     if (apiRetStatus != 0)
 5957              		.loc 1 1831 0
 5958 3430 002050E2 		subs	r2, r0, #0
 5959 3434 5C01001A 		bne	.L541
1838:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5960              		.loc 1 1838 0
 5961 3438 0150A0E3 		mov	r5, #1
1843:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5962              		.loc 1 1843 0
 5963 343c 1600A0E3 		mov	r0, #22
 5964              	.LVL473:
 5965 3440 68108DE2 		add	r1, sp, #104
1841:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5966              		.loc 1 1841 0
 5967 3444 74208DE5 		str	r2, [sp, #116]
1842:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5968              		.loc 1 1842 0
 5969 3448 7820CDE5 		strb	r2, [sp, #120]
1838:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5970              		.loc 1 1838 0
 5971 344c 68508DE5 		str	r5, [sp, #104]
1839:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5972              		.loc 1 1839 0
 5973 3450 6C508DE5 		str	r5, [sp, #108]
1840:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5974              		.loc 1 1840 0
 5975 3454 70508DE5 		str	r5, [sp, #112]
1843:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5976              		.loc 1 1843 0
 5977 3458 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5978              	.LVL474:
1844:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5979              		.loc 1 1844 0
 5980 345c 002050E2 		subs	r2, r0, #0
 5981 3460 2001001A 		bne	.L542
1857:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5982              		.loc 1 1857 0
 5983 3464 1400A0E3 		mov	r0, #20
 5984              	.LVL475:
 5985 3468 68108DE2 		add	r1, sp, #104
1855:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5986              		.loc 1 1855 0
 5987 346c 74208DE5 		str	r2, [sp, #116]
1856:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5988              		.loc 1 1856 0
 5989 3470 7820CDE5 		strb	r2, [sp, #120]
1852:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5990              		.loc 1 1852 0
 5991 3474 68508DE5 		str	r5, [sp, #104]
1853:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5992              		.loc 1 1853 0
 5993 3478 6C508DE5 		str	r5, [sp, #108]
1854:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5994              		.loc 1 1854 0
 5995 347c 70508DE5 		str	r5, [sp, #112]
1857:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5996              		.loc 1 1857 0
 5997 3480 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5998              	.LVL476:
1858:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5999              		.loc 1 1858 0
 6000 3484 002050E2 		subs	r2, r0, #0
 6001 3488 0D01001A 		bne	.L543
1871:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6002              		.loc 1 1871 0
 6003 348c 1800A0E3 		mov	r0, #24
 6004              	.LVL477:
 6005 3490 68108DE2 		add	r1, sp, #104
1866:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6006              		.loc 1 1866 0
 6007 3494 68208DE5 		str	r2, [sp, #104]
1867:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6008              		.loc 1 1867 0
 6009 3498 6C208DE5 		str	r2, [sp, #108]
1868:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6010              		.loc 1 1868 0
 6011 349c 70208DE5 		str	r2, [sp, #112]
1870:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6012              		.loc 1 1870 0
 6013 34a0 7820CDE5 		strb	r2, [sp, #120]
1869:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6014              		.loc 1 1869 0
 6015 34a4 74508DE5 		str	r5, [sp, #116]
1871:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6016              		.loc 1 1871 0
 6017 34a8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6018              	.LVL478:
1872:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6019              		.loc 1 1872 0
 6020 34ac 002050E2 		subs	r2, r0, #0
 6021 34b0 FA00001A 		bne	.L544
1881:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6022              		.loc 1 1881 0
 6023 34b4 0080A0E3 		mov	r8, #0
1879:../uvc.c      ****     pibclock.clkDiv      = 2;
 6024              		.loc 1 1879 0
 6025 34b8 0270A0E3 		mov	r7, #2	@ movhi
1880:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6026              		.loc 1 1880 0
 6027 34bc 0360A0E3 		mov	r6, #3
1884:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6028              		.loc 1 1884 0
 6029 34c0 0100A0E3 		mov	r0, #1
 6030              	.LVL479:
 6031 34c4 7C108DE2 		add	r1, sp, #124
1879:../uvc.c      ****     pibclock.clkDiv      = 2;
 6032              		.loc 1 1879 0
 6033 34c8 BC77CDE1 		strh	r7, [sp, #124]	@ movhi
1880:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6034              		.loc 1 1880 0
 6035 34cc 8860CDE5 		strb	r6, [sp, #136]
1881:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6036              		.loc 1 1881 0
 6037 34d0 84808DE5 		str	r8, [sp, #132]
1882:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6038              		.loc 1 1882 0
 6039 34d4 80808DE5 		str	r8, [sp, #128]
1884:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6040              		.loc 1 1884 0
 6041 34d8 FEFFFFEB 		bl	CyU3PPibInit
 6042              	.LVL480:
1885:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6043              		.loc 1 1885 0
 6044 34dc 002050E2 		subs	r2, r0, #0
 6045 34e0 BF01001A 		bne	.L545
1892:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 6046              		.loc 1 1892 0
 6047 34e4 A0099FE5 		ldr	r0, .L563+16
 6048              	.LVL481:
 6049 34e8 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6050              	.LVL482:
1900:../uvc.c      ****     SensorReset ();
 6051              		.loc 1 1900 0
 6052 34ec FEFFFFEB 		bl	SensorReset
1901:../uvc.c      ****     SensorInit ();
 6053              		.loc 1 1901 0
 6054 34f0 FEFFFFEB 		bl	SensorInit
1904:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 6055              		.loc 1 1904 0
 6056 34f4 FEFFFFEB 		bl	CyU3PUsbStart
 6057              	.LVL483:
1905:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6058              		.loc 1 1905 0
 6059 34f8 008050E2 		subs	r8, r0, #0
 6060 34fc AE01001A 		bne	.L546
1911:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6061              		.loc 1 1911 0
 6062 3500 0810A0E1 		mov	r1, r8
 6063 3504 84099FE5 		ldr	r0, .L563+20
 6064              	.LVL484:
 6065 3508 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6066              	.LVL485:
1914:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6067              		.loc 1 1914 0
 6068 350c 80099FE5 		ldr	r0, .L563+24
 6069 3510 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1920:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6070              		.loc 1 1920 0
 6071 3514 7C299FE5 		ldr	r2, .L563+28
 6072 3518 0810A0E1 		mov	r1, r8
 6073 351c 0100A0E3 		mov	r0, #1
 6074 3520 FEFFFFEB 		bl	CyU3PUsbSetDesc
1921:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6075              		.loc 1 1921 0
 6076 3524 0810A0E1 		mov	r1, r8
 6077 3528 6C299FE5 		ldr	r2, .L563+32
 6078 352c 0800A0E1 		mov	r0, r8
 6079 3530 FEFFFFEB 		bl	CyU3PUsbSetDesc
1924:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 6080              		.loc 1 1924 0
 6081 3534 0810A0E1 		mov	r1, r8
 6082 3538 60299FE5 		ldr	r2, .L563+36
 6083 353c 0200A0E3 		mov	r0, #2
 6084 3540 FEFFFFEB 		bl	CyU3PUsbSetDesc
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6085              		.loc 1 1925 0
 6086 3544 0810A0E1 		mov	r1, r8
 6087 3548 54299FE5 		ldr	r2, .L563+40
 6088 354c 0700A0E3 		mov	r0, #7
 6089 3550 FEFFFFEB 		bl	CyU3PUsbSetDesc
1928:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 6090              		.loc 1 1928 0
 6091 3554 4C299FE5 		ldr	r2, .L563+44
 6092 3558 0810A0E1 		mov	r1, r8
 6093 355c 0400A0E3 		mov	r0, #4
 6094 3560 FEFFFFEB 		bl	CyU3PUsbSetDesc
1929:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6095              		.loc 1 1929 0
 6096 3564 0810A0E1 		mov	r1, r8
 6097 3568 3C299FE5 		ldr	r2, .L563+48
 6098 356c 0600A0E1 		mov	r0, r6
 6099 3570 FEFFFFEB 		bl	CyU3PUsbSetDesc
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6100              		.loc 1 1930 0
 6101 3574 0810A0E1 		mov	r1, r8
 6102 3578 30299FE5 		ldr	r2, .L563+52
 6103 357c 0600A0E3 		mov	r0, #6
 6104 3580 FEFFFFEB 		bl	CyU3PUsbSetDesc
1933:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 6105              		.loc 1 1933 0
 6106 3584 0810A0E1 		mov	r1, r8
 6107 3588 24299FE5 		ldr	r2, .L563+56
 6108 358c 0500A0E3 		mov	r0, #5
 6109 3590 FEFFFFEB 		bl	CyU3PUsbSetDesc
1934:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6110              		.loc 1 1934 0
 6111 3594 0110A0E3 		mov	r1, #1
 6112 3598 18299FE5 		ldr	r2, .L563+60
 6113 359c 0500A0E3 		mov	r0, #5
 6114 35a0 FEFFFFEB 		bl	CyU3PUsbSetDesc
1935:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6115              		.loc 1 1935 0
 6116 35a4 0210A0E3 		mov	r1, #2
 6117 35a8 0C299FE5 		ldr	r2, .L563+64
 6118 35ac 0500A0E3 		mov	r0, #5
 6119 35b0 FEFFFFEB 		bl	CyU3PUsbSetDesc
1942:../uvc.c      ****     endPointConfig.enable   = 1;
 6120              		.loc 1 1942 0
 6121 35b4 0150A0E3 		mov	r5, #1
1948:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6122              		.loc 1 1948 0
 6123 35b8 8200A0E3 		mov	r0, #130
 6124 35bc A8108DE2 		add	r1, sp, #168
1944:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6125              		.loc 1 1944 0
 6126 35c0 40A0A0E3 		mov	sl, #64	@ movhi
1942:../uvc.c      ****     endPointConfig.enable   = 1;
 6127              		.loc 1 1942 0
 6128 35c4 A8508DE5 		str	r5, [sp, #168]
1943:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6129              		.loc 1 1943 0
 6130 35c8 AC60CDE5 		strb	r6, [sp, #172]
1944:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6131              		.loc 1 1944 0
 6132 35cc B0ABCDE1 		strh	sl, [sp, #176]	@ movhi
1945:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6133              		.loc 1 1945 0
 6134 35d0 B380CDE5 		strb	r8, [sp, #179]
1946:../uvc.c      ****     endPointConfig.streams  = 0;
 6135              		.loc 1 1946 0
 6136 35d4 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
1947:../uvc.c      ****     endPointConfig.burstLen = 1;
 6137              		.loc 1 1947 0
 6138 35d8 B250CDE5 		strb	r5, [sp, #178]
1948:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6139              		.loc 1 1948 0
 6140 35dc FEFFFFEB 		bl	CyU3PSetEpConfig
 6141              	.LVL486:
1949:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6142              		.loc 1 1949 0
 6143 35e0 003050E2 		subs	r3, r0, #0
 6144 35e4 6A01001A 		bne	.L547
1959:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6145              		.loc 1 1959 0
 6146 35e8 D0C89FE5 		ldr	ip, .L563+68
1960:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6147              		.loc 1 1960 0
 6148 35ec D0E89FE5 		ldr	lr, .L563+72
1957:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6149              		.loc 1 1957 0
 6150 35f0 016BA0E3 		mov	r6, #1024	@ movhi
1966:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6151              		.loc 1 1966 0
 6152 35f4 10A0A0E3 		mov	sl, #16
1968:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6153              		.loc 1 1968 0
 6154 35f8 C8089FE5 		ldr	r0, .L563+76
 6155              	.LVL487:
 6156 35fc 0410A0E3 		mov	r1, #4
 6157 3600 34208DE2 		add	r2, sp, #52
1957:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6158              		.loc 1 1957 0
 6159 3604 B463CDE1 		strh	r6, [sp, #52]	@ movhi
1958:../uvc.c      ****     dmaInterConfig.count          = 1;
 6160              		.loc 1 1958 0
 6161 3608 B653CDE1 		strh	r5, [sp, #54]	@ movhi
1959:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6162              		.loc 1 1959 0
 6163 360c B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1960:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6164              		.loc 1 1960 0
 6165 3610 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1961:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6166              		.loc 1 1961 0
 6167 3614 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1962:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6168              		.loc 1 1962 0
 6169 3618 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1963:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6170              		.loc 1 1963 0
 6171 361c B034CDE1 		strh	r3, [sp, #64]	@ movhi
1964:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6172              		.loc 1 1964 0
 6173 3620 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1965:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6174              		.loc 1 1965 0
 6175 3624 4480CDE5 		strb	r8, [sp, #68]
1966:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6176              		.loc 1 1966 0
 6177 3628 48A08DE5 		str	sl, [sp, #72]
1967:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6178              		.loc 1 1967 0
 6179 362c 4C308DE5 		str	r3, [sp, #76]
1968:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6180              		.loc 1 1968 0
 6181 3630 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6182              	.LVL488:
1970:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6183              		.loc 1 1970 0
 6184 3634 006050E2 		subs	r6, r0, #0
 6185 3638 4B01001A 		bne	.L548
1977:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6186              		.loc 1 1977 0
 6187 363c 010BA0E3 		mov	r0, #1024
 6188              	.LVL489:
 6189 3640 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6190 3644 80189FE5 		ldr	r1, .L563+80
1978:../uvc.c      ****     if (glInterStaBuffer == 0)
 6191              		.loc 1 1978 0
 6192 3648 000050E3 		cmp	r0, #0
1977:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6193              		.loc 1 1977 0
 6194 364c 000081E5 		str	r0, [r1, #0]
1978:../uvc.c      ****     if (glInterStaBuffer == 0)
 6195              		.loc 1 1978 0
 6196 3650 7501000A 		beq	.L549
1985:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 6197              		.loc 1 1985 0
 6198 3654 0610A0E1 		mov	r1, r6
 6199 3658 0620A0E1 		mov	r2, r6
 6200 365c 3830A0E3 		mov	r3, #56
 6201 3660 68089FE5 		ldr	r0, .L563+84
 6202 3664 FEFFFFEB 		bl	_txe_mutex_create
1987:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6203              		.loc 1 1987 0
 6204 3668 0430A0E3 		mov	r3, #4	@ movhi
 6205 366c BE30CDE1 		strh	r3, [sp, #14]	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6206              		.loc 1 1990 0
 6207 3670 5C389FE5 		ldr	r3, .L563+88
1986:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6208              		.loc 1 1986 0
 6209 3674 01C9A0E3 		mov	ip, #16384	@ movhi
 6210 3678 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
1989:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6211              		.loc 1 1989 0
 6212 367c 01CCA0E3 		mov	ip, #256	@ movhi
 6213 3680 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6214              		.loc 1 1990 0
 6215 3684 B431CDE1 		strh	r3, [sp, #20]	@ movhi
1991:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6216              		.loc 1 1991 0
 6217 3688 48C89FE5 		ldr	ip, .L563+92
1993:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6218              		.loc 1 1993 0
 6219 368c 0C30A0E3 		mov	r3, #12	@ movhi
 6220 3690 B432CDE1 		strh	r3, [sp, #36]	@ movhi
1998:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6221              		.loc 1 1998 0
 6222 3694 40389FE5 		ldr	r3, .L563+96
1999:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6223              		.loc 1 1999 0
 6224 3698 0C208DE2 		add	r2, sp, #12
1991:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6225              		.loc 1 1991 0
 6226 369c BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
1996:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6227              		.loc 1 1996 0
 6228 36a0 2A80CDE5 		strb	r8, [sp, #42]
1994:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6229              		.loc 1 1994 0
 6230 36a4 04C0A0E3 		mov	ip, #4	@ movhi
1999:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6231              		.loc 1 1999 0
 6232 36a8 30089FE5 		ldr	r0, .L563+100
 6233 36ac 0710A0E3 		mov	r1, #7
1997:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6234              		.loc 1 1997 0
 6235 36b0 1880A0E3 		mov	r8, #24
1988:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6236              		.loc 1 1988 0
 6237 36b4 B071CDE1 		strh	r7, [sp, #16]	@ movhi
1992:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6238              		.loc 1 1992 0
 6239 36b8 B262CDE1 		strh	r6, [sp, #34]	@ movhi
1994:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6240              		.loc 1 1994 0
 6241 36bc B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
1995:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6242              		.loc 1 1995 0
 6243 36c0 B862CDE1 		strh	r6, [sp, #40]	@ movhi
1997:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6244              		.loc 1 1997 0
 6245 36c4 2C808DE5 		str	r8, [sp, #44]
1998:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6246              		.loc 1 1998 0
 6247 36c8 30308DE5 		str	r3, [sp, #48]
1999:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6248              		.loc 1 1999 0
 6249 36cc FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6250              	.LVL490:
2001:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6251              		.loc 1 2001 0
 6252 36d0 002050E2 		subs	r2, r0, #0
 6253 36d4 4B01001A 		bne	.L550
2092:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6254              		.loc 1 2092 0
 6255 36d8 0500A0E1 		mov	r0, r5
 6256              	.LVL491:
 6257 36dc 0510A0E1 		mov	r1, r5
 6258 36e0 FEFFFFEB 		bl	CyU3PConnectState
 6259              	.LVL492:
2093:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6260              		.loc 1 2093 0
 6261 36e4 002050E2 		subs	r2, r0, #0
 6262 36e8 6300001A 		bne	.L551
2099:../uvc.c      ****     CyU3PBusyWait(100);
 6263              		.loc 1 2099 0
 6264 36ec 6400A0E3 		mov	r0, #100
 6265              	.LVL493:
 6266 36f0 FEFFFFEB 		bl	CyU3PBusyWait
 6267              	.LVL494:
2101:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6268              		.loc 1 2101 0
 6269 36f4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2115:../uvc.c      ****     endPointConfig.streams  = 0;
 6270              		.loc 1 2115 0
 6271 36f8 0020A0E3 		mov	r2, #0	@ movhi
2104:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6272              		.loc 1 2104 0
 6273 36fc AC70CDE5 		strb	r7, [sp, #172]
2116:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6274              		.loc 1 2116 0
 6275 3700 A8108DE2 		add	r1, sp, #168
2115:../uvc.c      ****     endPointConfig.streams  = 0;
 6276              		.loc 1 2115 0
 6277 3704 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2103:../uvc.c      ****     endPointConfig.enable   = 1;
 6278              		.loc 1 2103 0
 6279 3708 A8508DE5 		str	r5, [sp, #168]
2105:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6280              		.loc 1 2105 0
 6281 370c 030050E3 		cmp	r0, #3
2101:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6282              		.loc 1 2101 0
 6283 3710 4800C4E5 		strb	r0, [r4, #72]
2112:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6284              		.loc 1 2112 0
 6285 3714 020CA013 		movne	r0, #512	@ movhi
2107:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6286              		.loc 1 2107 0
 6287 3718 017BA003 		moveq	r7, #1024	@ movhi
2112:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6288              		.loc 1 2112 0
 6289 371c B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2116:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6290              		.loc 1 2116 0
 6291 3720 8300A0E3 		mov	r0, #131
2107:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6292              		.loc 1 2107 0
 6293 3724 B07BCD01 		streqh	r7, [sp, #176]	@ movhi
2108:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6294              		.loc 1 2108 0
 6295 3728 B2A0CD05 		streqb	sl, [sp, #178]
2113:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6296              		.loc 1 2113 0
 6297 372c B250CD15 		strneb	r5, [sp, #178]
2116:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6298              		.loc 1 2116 0
 6299 3730 FEFFFFEB 		bl	CyU3PSetEpConfig
 6300              	.LVL495:
2117:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6301              		.loc 1 2117 0
 6302 3734 002050E2 		subs	r2, r0, #0
 6303 3738 4600001A 		bne	.L532
 6304 373c A0779FE5 		ldr	r7, .L563+104
 6305              	.LBE228:
 6306              	.LBE225:
2238:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6307              		.loc 1 2238 0
 6308 3740 40579FE5 		ldr	r5, .L563+12
 6309 3744 0260A0E1 		mov	r6, r2
2417:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6310              		.loc 1 2417 0
 6311 3748 00A0E0E3 		mvn	sl, #0
 6312              	.LVL496:
 6313              	.L502:
2238:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6314              		.loc 1 2238 0
 6315 374c 34079FE5 		ldr	r0, .L563+12
 6316 3750 0110A0E3 		mov	r1, #1
 6317 3754 0220A0E3 		mov	r2, #2
 6318 3758 B4308DE2 		add	r3, sp, #180
 6319 375c 00608DE5 		str	r6, [sp, #0]
 6320 3760 FEFFFFEB 		bl	_txe_event_flags_get
 6321 3764 000050E3 		cmp	r0, #0
 6322 3768 2700001A 		bne	.L504
2284:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6323              		.loc 1 2284 0
 6324 376c 44E095E5 		ldr	lr, [r5, #68]
 6325 3770 00005EE3 		cmp	lr, #0
 6326 3774 0300000A 		beq	.L505
2284:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6327              		.loc 1 2284 0 is_stmt 0 discriminator 1
 6328 3778 BE12D5E1 		ldrh	r1, [r5, #46]
 6329 377c B083D5E1 		ldrh	r8, [r5, #48]
 6330 3780 080051E1 		cmp	r1, r8
 6331 3784 6000000A 		beq	.L552
 6332              	.L505:
2456:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6333              		.loc 1 2456 0 is_stmt 1
 6334 3788 4010A0E3 		mov	r1, #64
 6335 378c 0020A0E3 		mov	r2, #0
 6336 3790 F0069FE5 		ldr	r0, .L563+12
 6337 3794 FEFFFFEB 		bl	_txe_event_flags_set
2459:../uvc.c      ****         CyU3PThreadRelinquish ();
 6338              		.loc 1 2459 0
 6339 3798 FEFFFFEB 		bl	_txe_thread_relinquish
2460:../uvc.c      ****     }
 6340              		.loc 1 2460 0
 6341 379c EAFFFFEA 		b	.L502
 6342              	.LVL497:
 6343              	.L535:
 6344              	.LBB263:
 6345              	.LBB224:
1703:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6346              		.loc 1 1703 0
 6347 37a0 0400A0E3 		mov	r0, #4
 6348              	.LVL498:
 6349 37a4 3C179FE5 		ldr	r1, .L563+108
 6350 37a8 FEFFFFEB 		bl	CyU3PDebugPrint
 6351              	.LVL499:
 6352              	.L467:
 6353              	.LBB220:
 6354              	.LBB221:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6355              		.loc 1 1249 0
 6356 37ac 38179FE5 		ldr	r1, .L563+112
 6357 37b0 0400A0E3 		mov	r0, #4
 6358 37b4 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6359              		.loc 1 1250 0
 6360 37b8 FA0FA0E3 		mov	r0, #1000
 6361 37bc FEFFFFEB 		bl	_tx_thread_sleep
 6362 37c0 F9FFFFEA 		b	.L467
 6363              	.LVL500:
 6364              	.L536:
 6365              	.LBE221:
 6366              	.LBE220:
1716:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6367              		.loc 1 1716 0
 6368 37c4 0400A0E3 		mov	r0, #4
 6369              	.LVL501:
 6370 37c8 20179FE5 		ldr	r1, .L563+116
 6371              	.LVL502:
 6372 37cc FEFFFFEB 		bl	CyU3PDebugPrint
 6373              	.L469:
 6374              	.LBB222:
 6375              	.LBB223:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6376              		.loc 1 1249 0
 6377 37d0 14179FE5 		ldr	r1, .L563+112
 6378 37d4 0400A0E3 		mov	r0, #4
 6379 37d8 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6380              		.loc 1 1250 0
 6381 37dc FA0FA0E3 		mov	r0, #1000
 6382 37e0 FEFFFFEB 		bl	_tx_thread_sleep
 6383 37e4 F9FFFFEA 		b	.L469
 6384              	.LVL503:
 6385              	.L537:
 6386              	.LBE223:
 6387              	.LBE222:
 6388              	.LBE224:
 6389              	.LBE263:
 6390              	.LBB264:
 6391              	.LBB227:
1790:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6392              		.loc 1 1790 0
 6393 37e8 0400A0E3 		mov	r0, #4
 6394              	.LVL504:
 6395 37ec 00179FE5 		ldr	r1, .L563+120
 6396 37f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6397              	.LVL505:
 6398              	.L471:
 6399              	.LBB237:
 6400              	.LBB238:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6401              		.loc 1 1249 0
 6402 37f4 F0169FE5 		ldr	r1, .L563+112
 6403 37f8 0400A0E3 		mov	r0, #4
 6404 37fc FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6405              		.loc 1 1250 0
 6406 3800 FA0FA0E3 		mov	r0, #1000
 6407 3804 FEFFFFEB 		bl	_tx_thread_sleep
 6408 3808 F9FFFFEA 		b	.L471
 6409              	.LVL506:
 6410              	.L504:
 6411              	.LBE238:
 6412              	.LBE237:
 6413              	.LBE227:
 6414              	.LBE264:
2385:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6415              		.loc 1 2385 0
 6416 380c 74069FE5 		ldr	r0, .L563+12
 6417 3810 0210A0E3 		mov	r1, #2
 6418 3814 0320A0E3 		mov	r2, #3
 6419 3818 B4308DE2 		add	r3, sp, #180
 6420 381c 00608DE5 		str	r6, [sp, #0]
 6421 3820 FEFFFFEB 		bl	_txe_event_flags_get
 6422 3824 000050E3 		cmp	r0, #0
 6423 3828 1A01001A 		bne	.L516
2400:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6424              		.loc 1 2400 0
 6425 382c 403095E5 		ldr	r3, [r5, #64]
2388:../uvc.c      ****                 hitFV     = CyFalse;
 6426              		.loc 1 2388 0
 6427 3830 446085E5 		str	r6, [r5, #68]
2400:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6428              		.loc 1 2400 0
 6429 3834 000053E3 		cmp	r3, #0
2389:../uvc.c      ****                 prodCount = 0;
 6430              		.loc 1 2389 0
 6431 3838 BE62C5E1 		strh	r6, [r5, #46]	@ movhi
2396:../uvc.c      ****                 fb=0;
 6432              		.loc 1 2396 0
 6433 383c B862C5E1 		strh	r6, [r5, #40]	@ movhi
2390:../uvc.c      ****                 consCount = 0;
 6434              		.loc 1 2390 0
 6435 3840 B063C5E1 		strh	r6, [r5, #48]	@ movhi
2397:../uvc.c      ****                 pb=0;
 6436              		.loc 1 2397 0
 6437 3844 BA62C5E1 		strh	r6, [r5, #42]	@ movhi
2398:../uvc.c      ****                 pbc=0;
 6438              		.loc 1 2398 0
 6439 3848 BC62C5E1 		strh	r6, [r5, #44]	@ movhi
2400:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6440              		.loc 1 2400 0
 6441 384c FF00000A 		beq	.L553
 6442              	.L517:
2412:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6443              		.loc 1 2412 0
 6444 3850 406084E5 		str	r6, [r4, #64]
 6445 3854 CBFFFFEA 		b	.L505
 6446              	.LVL507:
 6447              	.L532:
 6448              	.LBB265:
 6449              	.LBB261:
2120:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6450              		.loc 1 2120 0
 6451 3858 0400A0E3 		mov	r0, #4
 6452              	.LVL508:
 6453 385c 94169FE5 		ldr	r1, .L563+124
 6454 3860 FEFFFFEB 		bl	CyU3PDebugPrint
 6455              	.LVL509:
 6456              	.L503:
 6457              	.LBB239:
 6458              	.LBB240:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6459              		.loc 1 1249 0
 6460 3864 80169FE5 		ldr	r1, .L563+112
 6461 3868 0400A0E3 		mov	r0, #4
 6462 386c FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6463              		.loc 1 1250 0
 6464 3870 FA0FA0E3 		mov	r0, #1000
 6465 3874 FEFFFFEB 		bl	_tx_thread_sleep
 6466 3878 F9FFFFEA 		b	.L503
 6467              	.LVL510:
 6468              	.L551:
 6469              	.LBE240:
 6470              	.LBE239:
2095:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6471              		.loc 1 2095 0
 6472 387c 0400A0E3 		mov	r0, #4
 6473              	.LVL511:
 6474 3880 74169FE5 		ldr	r1, .L563+128
 6475 3884 FEFFFFEB 		bl	CyU3PDebugPrint
 6476              	.LVL512:
 6477              	.L499:
 6478              	.LBB241:
 6479              	.LBB242:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6480              		.loc 1 1249 0
 6481 3888 5C169FE5 		ldr	r1, .L563+112
 6482 388c 0400A0E3 		mov	r0, #4
 6483 3890 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6484              		.loc 1 1250 0
 6485 3894 FA0FA0E3 		mov	r0, #1000
 6486 3898 FEFFFFEB 		bl	_tx_thread_sleep
 6487 389c F9FFFFEA 		b	.L499
 6488              	.LVL513:
 6489              	.L544:
 6490              	.LBE242:
 6491              	.LBE241:
1874:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6492              		.loc 1 1874 0
 6493 38a0 0400A0E3 		mov	r0, #4
 6494              	.LVL514:
 6495 38a4 54169FE5 		ldr	r1, .L563+132
 6496 38a8 FEFFFFEB 		bl	CyU3PDebugPrint
 6497              	.LVL515:
 6498              	.L485:
 6499              	.LBB243:
 6500              	.LBB244:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6501              		.loc 1 1249 0
 6502 38ac 38169FE5 		ldr	r1, .L563+112
 6503 38b0 0400A0E3 		mov	r0, #4
 6504 38b4 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6505              		.loc 1 1250 0
 6506 38b8 FA0FA0E3 		mov	r0, #1000
 6507 38bc FEFFFFEB 		bl	_tx_thread_sleep
 6508 38c0 F9FFFFEA 		b	.L485
 6509              	.LVL516:
 6510              	.L543:
 6511              	.LBE244:
 6512              	.LBE243:
1860:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6513              		.loc 1 1860 0
 6514 38c4 0400A0E3 		mov	r0, #4
 6515              	.LVL517:
 6516 38c8 34169FE5 		ldr	r1, .L563+136
 6517 38cc FEFFFFEB 		bl	CyU3PDebugPrint
 6518              	.LVL518:
 6519              	.L483:
 6520              	.LBB245:
 6521              	.LBB246:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6522              		.loc 1 1249 0
 6523 38d0 14169FE5 		ldr	r1, .L563+112
 6524 38d4 0400A0E3 		mov	r0, #4
 6525 38d8 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6526              		.loc 1 1250 0
 6527 38dc FA0FA0E3 		mov	r0, #1000
 6528 38e0 FEFFFFEB 		bl	_tx_thread_sleep
 6529 38e4 F9FFFFEA 		b	.L483
 6530              	.LVL519:
 6531              	.L542:
 6532              	.LBE246:
 6533              	.LBE245:
1846:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6534              		.loc 1 1846 0
 6535 38e8 0400A0E3 		mov	r0, #4
 6536              	.LVL520:
 6537 38ec 14169FE5 		ldr	r1, .L563+140
 6538 38f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6539              	.LVL521:
 6540              	.L481:
 6541              	.LBB247:
 6542              	.LBB248:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6543              		.loc 1 1249 0
 6544 38f4 F0159FE5 		ldr	r1, .L563+112
 6545 38f8 0400A0E3 		mov	r0, #4
 6546 38fc FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6547              		.loc 1 1250 0
 6548 3900 FA0FA0E3 		mov	r0, #1000
 6549 3904 FEFFFFEB 		bl	_tx_thread_sleep
 6550 3908 F9FFFFEA 		b	.L481
 6551              	.LVL522:
 6552              	.L552:
 6553              	.LBE248:
 6554              	.LBE247:
 6555              	.LBE261:
 6556              	.LBE265:
2294:../uvc.c      ****                 prodCount = 0;
 6557              		.loc 1 2294 0
 6558 390c BE62C5E1 		strh	r6, [r5, #46]	@ movhi
2309:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6559              		.loc 1 2309 0
 6560 3910 B8059FE5 		ldr	r0, .L563+84
2295:../uvc.c      ****                 consCount = 0;
 6561              		.loc 1 2295 0
 6562 3914 B063C5E1 		strh	r6, [r5, #48]	@ movhi
2309:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6563              		.loc 1 2309 0
 6564 3918 0010E0E3 		mvn	r1, #0
2291:../uvc.c      ****             	fb=0;
 6565              		.loc 1 2291 0
 6566 391c B862C5E1 		strh	r6, [r5, #40]	@ movhi
2292:../uvc.c      ****             	pb=0;
 6567              		.loc 1 2292 0
 6568 3920 BA62C5E1 		strh	r6, [r5, #42]	@ movhi
2293:../uvc.c      ****             	pbc=0;
 6569              		.loc 1 2293 0
 6570 3924 BC62C5E1 		strh	r6, [r5, #44]	@ movhi
2296:../uvc.c      ****                 hitFV     = CyFalse;
 6571              		.loc 1 2296 0
 6572 3928 446085E5 		str	r6, [r5, #68]
2309:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6573              		.loc 1 2309 0
 6574 392c FEFFFFEB 		bl	_txe_mutex_get
2310:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6575              		.loc 1 2310 0
 6576 3930 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
 6577 3934 01C022E2 		eor	ip, r2, #1
 6578 3938 81C4C7E5 		strb	ip, [r7, #1153]
2312:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 6579              		.loc 1 2312 0
 6580 393c A03095E5 		ldr	r3, [r5, #160]
 6581 3940 F00053E3 		cmp	r3, #240
 6582 3944 7C00000A 		beq	.L554
 6583              	.L506:
2320:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 6584              		.loc 1 2320 0
 6585 3948 A0E094E5 		ldr	lr, [r4, #160]
 6586 394c FF005EE3 		cmp	lr, #255
 6587 3950 6D00000A 		beq	.L555
2332:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 6588              		.loc 1 2332 0
 6589 3954 A00095E5 		ldr	r0, [r5, #160]
 6590 3958 AA0050E3 		cmp	r0, #170
 6591 395c 4800000A 		beq	.L556
 6592              	.L507:
2360:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 6593              		.loc 1 2360 0
 6594 3960 68059FE5 		ldr	r0, .L563+84
 6595 3964 FEFFFFEB 		bl	_txe_mutex_put
2362:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6596              		.loc 1 2362 0
 6597 3968 70059FE5 		ldr	r0, .L563+100
 6598 396c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6599              	.LVL523:
2363:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6600              		.loc 1 2363 0
 6601 3970 002050E2 		subs	r2, r0, #0
 6602 3974 3900001A 		bne	.L557
2370:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6603              		.loc 1 2370 0
 6604 3978 0210A0E1 		mov	r1, r2
 6605 397c 5C059FE5 		ldr	r0, .L563+100
 6606              	.LVL524:
 6607 3980 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6608              	.LVL525:
2371:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6609              		.loc 1 2371 0
 6610 3984 002050E2 		subs	r2, r0, #0
 6611 3988 2B00001A 		bne	.L558
2379:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6612              		.loc 1 2379 0
 6613 398c 40059FE5 		ldr	r0, .L563+88
 6614              	.LVL526:
 6615 3990 0210A0E1 		mov	r1, r2
 6616 3994 0280A0E3 		mov	r8, #2
 6617 3998 0020A0E1 		mov	r2, r0
 6618              	.LVL527:
 6619 399c 0130A0E1 		mov	r3, r1
 6620 39a0 00808DE5 		str	r8, [sp, #0]
 6621 39a4 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6622              	.LVL528:
 6623 39a8 76FFFFEA 		b	.L505
 6624              	.LVL529:
 6625              	.L541:
 6626              	.LBB266:
 6627              	.LBB226:
1833:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6628              		.loc 1 1833 0
 6629 39ac 0400A0E3 		mov	r0, #4
 6630              	.LVL530:
 6631 39b0 54159FE5 		ldr	r1, .L563+144
 6632 39b4 FEFFFFEB 		bl	CyU3PDebugPrint
 6633              	.LVL531:
 6634              	.L479:
 6635              	.LBB235:
 6636              	.LBB236:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6637              		.loc 1 1249 0
 6638 39b8 2C159FE5 		ldr	r1, .L563+112
 6639 39bc 0400A0E3 		mov	r0, #4
 6640 39c0 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6641              		.loc 1 1250 0
 6642 39c4 FA0FA0E3 		mov	r0, #1000
 6643 39c8 FEFFFFEB 		bl	_tx_thread_sleep
 6644 39cc F9FFFFEA 		b	.L479
 6645              	.LVL532:
 6646              	.L539:
 6647              	.LBE236:
 6648              	.LBE235:
1821:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6649              		.loc 1 1821 0
 6650 39d0 0400A0E3 		mov	r0, #4
 6651              	.LVL533:
 6652 39d4 34159FE5 		ldr	r1, .L563+148
 6653 39d8 FEFFFFEB 		bl	CyU3PDebugPrint
 6654              	.LVL534:
 6655              	.L475:
 6656              	.LBB233:
 6657              	.LBB234:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6658              		.loc 1 1249 0
 6659 39dc 08159FE5 		ldr	r1, .L563+112
 6660 39e0 0400A0E3 		mov	r0, #4
 6661 39e4 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6662              		.loc 1 1250 0
 6663 39e8 FA0FA0E3 		mov	r0, #1000
 6664 39ec FEFFFFEB 		bl	_tx_thread_sleep
 6665 39f0 F9FFFFEA 		b	.L475
 6666              	.LVL535:
 6667              	.L538:
 6668              	.LBE234:
 6669              	.LBE233:
1812:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6670              		.loc 1 1812 0
 6671 39f4 0400A0E3 		mov	r0, #4
 6672              	.LVL536:
 6673 39f8 14159FE5 		ldr	r1, .L563+152
 6674 39fc FEFFFFEB 		bl	CyU3PDebugPrint
 6675              	.LVL537:
 6676              	.L473:
 6677              	.LBB231:
 6678              	.LBB232:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6679              		.loc 1 1249 0
 6680 3a00 E4149FE5 		ldr	r1, .L563+112
 6681 3a04 0400A0E3 		mov	r0, #4
 6682 3a08 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6683              		.loc 1 1250 0
 6684 3a0c FA0FA0E3 		mov	r0, #1000
 6685 3a10 FEFFFFEB 		bl	_tx_thread_sleep
 6686 3a14 F9FFFFEA 		b	.L473
 6687              	.LVL538:
 6688              	.L540:
 6689              	.LBE232:
 6690              	.LBE231:
1827:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6691              		.loc 1 1827 0
 6692 3a18 0400A0E3 		mov	r0, #4
 6693              	.LVL539:
 6694 3a1c F4149FE5 		ldr	r1, .L563+156
 6695 3a20 FEFFFFEB 		bl	CyU3PDebugPrint
 6696              	.LVL540:
 6697              	.L477:
 6698              	.LBB229:
 6699              	.LBB230:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6700              		.loc 1 1249 0
 6701 3a24 C0149FE5 		ldr	r1, .L563+112
 6702 3a28 0400A0E3 		mov	r0, #4
 6703 3a2c FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6704              		.loc 1 1250 0
 6705 3a30 FA0FA0E3 		mov	r0, #1000
 6706 3a34 FEFFFFEB 		bl	_tx_thread_sleep
 6707 3a38 F9FFFFEA 		b	.L477
 6708              	.LVL541:
 6709              	.L558:
 6710              	.LBE230:
 6711              	.LBE229:
 6712              	.LBE226:
 6713              	.LBE266:
2373:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6714              		.loc 1 2373 0
 6715 3a3c 0400A0E3 		mov	r0, #4
 6716              	.LVL542:
 6717 3a40 D4149FE5 		ldr	r1, .L563+160
 6718 3a44 FEFFFFEB 		bl	CyU3PDebugPrint
 6719              	.LVL543:
 6720              	.L515:
 6721              	.LBB267:
 6722              	.LBB268:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6723              		.loc 1 1249 0
 6724 3a48 9C149FE5 		ldr	r1, .L563+112
 6725 3a4c 0400A0E3 		mov	r0, #4
 6726 3a50 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6727              		.loc 1 1250 0
 6728 3a54 FA0FA0E3 		mov	r0, #1000
 6729 3a58 FEFFFFEB 		bl	_tx_thread_sleep
 6730 3a5c F9FFFFEA 		b	.L515
 6731              	.LVL544:
 6732              	.L557:
 6733              	.LBE268:
 6734              	.LBE267:
2365:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6735              		.loc 1 2365 0
 6736 3a60 0400A0E3 		mov	r0, #4
 6737              	.LVL545:
 6738 3a64 B4149FE5 		ldr	r1, .L563+164
 6739 3a68 FEFFFFEB 		bl	CyU3PDebugPrint
 6740              	.LVL546:
 6741              	.L513:
 6742              	.LBB269:
 6743              	.LBB270:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6744              		.loc 1 1249 0
 6745 3a6c 78149FE5 		ldr	r1, .L563+112
 6746 3a70 0400A0E3 		mov	r0, #4
 6747 3a74 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6748              		.loc 1 1250 0
 6749 3a78 FA0FA0E3 		mov	r0, #1000
 6750 3a7c FEFFFFEB 		bl	_tx_thread_sleep
 6751 3a80 F9FFFFEA 		b	.L513
 6752              	.L556:
 6753              	.LBE270:
 6754              	.LBE269:
2338:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 6755              		.loc 1 2338 0
 6756 3a84 A410D5E5 		ldrb	r1, [r5, #164]	@ zero_extendqisi2
 6757 3a88 01E081E2 		add	lr, r1, #1
 6758 3a8c 020051E3 		cmp	r1, #2
 6759 3a90 A4E0C5E5 		strb	lr, [r5, #164]
 6760 3a94 B1FFFF9A 		bls	.L507
2340:../uvc.c      ****                     switch (setRes)
 6761              		.loc 1 2340 0
 6762 3a98 9C30D5E5 		ldrb	r3, [r5, #156]	@ zero_extendqisi2
 6763 3a9c 010053E3 		cmp	r3, #1
 6764 3aa0 0E00000A 		beq	.L510
 6765 3aa4 020053E3 		cmp	r3, #2
 6766 3aa8 0900001A 		bne	.L509
2348:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
 6767              		.loc 1 2348 0
 6768 3aac 3010A0E3 		mov	r1, #48
 6769 3ab0 0120A0E3 		mov	r2, #1
 6770 3ab4 5230A0E3 		mov	r3, #82
 6771 3ab8 0B00A0E3 		mov	r0, #11
 6772 3abc FEFFFFEB 		bl	SensorSetIrisControl
2350:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0x0b, 0x1);
 6773              		.loc 1 2350 0
 6774 3ac0 0400A0E3 		mov	r0, #4
 6775 3ac4 58149FE5 		ldr	r1, .L563+168
 6776 3ac8 0B20A0E3 		mov	r2, #11
 6777 3acc 0130A0E3 		mov	r3, #1
 6778 3ad0 FEFFFFEB 		bl	CyU3PDebugPrint
 6779              	.L509:
2355:../uvc.c      ****                     IMcount = 0;
 6780              		.loc 1 2355 0
 6781 3ad4 A460C4E5 		strb	r6, [r4, #164]
2357:../uvc.c      ****                 	stiflag = 0x0;
 6782              		.loc 1 2357 0
 6783 3ad8 A06084E5 		str	r6, [r4, #160]
 6784 3adc 9FFFFFEA 		b	.L507
 6785              	.L510:
2343:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
 6786              		.loc 1 2343 0
 6787 3ae0 3010A0E3 		mov	r1, #48
 6788 3ae4 0020A0E3 		mov	r2, #0
 6789 3ae8 5230A0E3 		mov	r3, #82
 6790 3aec 0B00A0E3 		mov	r0, #11
 6791 3af0 FEFFFFEB 		bl	SensorSetIrisControl
2345:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0xb, 0x0);
 6792              		.loc 1 2345 0
 6793 3af4 28149FE5 		ldr	r1, .L563+168
 6794 3af8 0B20A0E3 		mov	r2, #11
 6795 3afc 0030A0E3 		mov	r3, #0
 6796 3b00 0400A0E3 		mov	r0, #4
 6797 3b04 FEFFFFEB 		bl	CyU3PDebugPrint
2346:../uvc.c      ****                  		break;
 6798              		.loc 1 2346 0
 6799 3b08 F1FFFFEA 		b	.L509
 6800              	.L555:
2322:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 6801              		.loc 1 2322 0
 6802 3b0c A480D5E5 		ldrb	r8, [r5, #164]	@ zero_extendqisi2
 6803 3b10 011088E2 		add	r1, r8, #1
 6804 3b14 020058E3 		cmp	r8, #2
 6805 3b18 A410C5E5 		strb	r1, [r5, #164]
 6806 3b1c 8FFFFF9A 		bls	.L507
2323:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6807              		.loc 1 2323 0
 6808 3b20 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2324:../uvc.c      ****                 		stiflag = 0x0F;
 6809              		.loc 1 2324 0
 6810 3b24 0F30A0E3 		mov	r3, #15
2323:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6811              		.loc 1 2323 0
 6812 3b28 20C082E3 		orr	ip, r2, #32
 6813 3b2c 81C4C7E5 		strb	ip, [r7, #1153]
2325:../uvc.c      ****                 		IMcount = 0;
 6814              		.loc 1 2325 0
 6815 3b30 A460C5E5 		strb	r6, [r5, #164]
2324:../uvc.c      ****                 		stiflag = 0x0F;
 6816              		.loc 1 2324 0
 6817 3b34 A03085E5 		str	r3, [r5, #160]
 6818 3b38 88FFFFEA 		b	.L507
 6819              	.L554:
2312:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 6820              		.loc 1 2312 0 discriminator 1
 6821 3b3c 44039FE5 		ldr	r0, .L563+12
 6822 3b40 8010A0E3 		mov	r1, #128
 6823 3b44 0320A0E3 		mov	r2, #3
 6824 3b48 B4308DE2 		add	r3, sp, #180
 6825 3b4c 00608DE5 		str	r6, [sp, #0]
 6826 3b50 FEFFFFEB 		bl	_txe_event_flags_get
 6827 3b54 000050E3 		cmp	r0, #0
2317:../uvc.c      ****                 		stiflag = 0xFF;
 6828              		.loc 1 2317 0 discriminator 1
 6829 3b58 FF00A003 		moveq	r0, #255
 6830 3b5c A0008505 		streq	r0, [r5, #160]
2318:../uvc.c      ****                 		IMcount = 0;
 6831              		.loc 1 2318 0 discriminator 1
 6832 3b60 A460C505 		streqb	r6, [r5, #164]
2312:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 6833              		.loc 1 2312 0 discriminator 1
 6834 3b64 7DFFFF0A 		beq	.L507
 6835 3b68 76FFFFEA 		b	.L506
 6836              	.LVL547:
 6837              	.L548:
 6838              	.LBB271:
 6839              	.LBB262:
1973:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6840              		.loc 1 1973 0
 6841 3b6c 0400A0E3 		mov	r0, #4
 6842              	.LVL548:
 6843 3b70 B0139FE5 		ldr	r1, .L563+172
 6844 3b74 0620A0E1 		mov	r2, r6
 6845 3b78 FEFFFFEB 		bl	CyU3PDebugPrint
 6846              	.L493:
 6847              	.LBB249:
 6848              	.LBB250:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6849              		.loc 1 1249 0
 6850 3b7c 68139FE5 		ldr	r1, .L563+112
 6851 3b80 0400A0E3 		mov	r0, #4
 6852 3b84 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6853              		.loc 1 1250 0
 6854 3b88 FA0FA0E3 		mov	r0, #1000
 6855 3b8c FEFFFFEB 		bl	_tx_thread_sleep
 6856 3b90 F9FFFFEA 		b	.L493
 6857              	.LVL549:
 6858              	.L547:
 6859              	.LBE250:
 6860              	.LBE249:
1952:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6861              		.loc 1 1952 0
 6862 3b94 0400A0E3 		mov	r0, #4
 6863              	.LVL550:
 6864 3b98 58139FE5 		ldr	r1, .L563+124
 6865 3b9c 0320A0E1 		mov	r2, r3
 6866 3ba0 FEFFFFEB 		bl	CyU3PDebugPrint
 6867              	.LVL551:
 6868              	.L491:
 6869              	.LBB251:
 6870              	.LBB252:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6871              		.loc 1 1249 0
 6872 3ba4 40139FE5 		ldr	r1, .L563+112
 6873 3ba8 0400A0E3 		mov	r0, #4
 6874 3bac FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6875              		.loc 1 1250 0
 6876 3bb0 FA0FA0E3 		mov	r0, #1000
 6877 3bb4 FEFFFFEB 		bl	_tx_thread_sleep
 6878 3bb8 F9FFFFEA 		b	.L491
 6879              	.LVL552:
 6880              	.L546:
 6881              	.LBE252:
 6882              	.LBE251:
1907:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6883              		.loc 1 1907 0
 6884 3bbc 0400A0E3 		mov	r0, #4
 6885 3bc0 64139FE5 		ldr	r1, .L563+176
 6886 3bc4 0820A0E1 		mov	r2, r8
 6887 3bc8 FEFFFFEB 		bl	CyU3PDebugPrint
 6888              	.L489:
 6889              	.LBB253:
 6890              	.LBB254:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6891              		.loc 1 1249 0
 6892 3bcc 18139FE5 		ldr	r1, .L563+112
 6893 3bd0 0400A0E3 		mov	r0, #4
 6894 3bd4 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6895              		.loc 1 1250 0
 6896 3bd8 FA0FA0E3 		mov	r0, #1000
 6897 3bdc FEFFFFEB 		bl	_tx_thread_sleep
 6898 3be0 F9FFFFEA 		b	.L489
 6899              	.LVL553:
 6900              	.L545:
 6901              	.LBE254:
 6902              	.LBE253:
1887:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6903              		.loc 1 1887 0
 6904 3be4 0400A0E3 		mov	r0, #4
 6905              	.LVL554:
 6906 3be8 40139FE5 		ldr	r1, .L563+180
 6907 3bec FEFFFFEB 		bl	CyU3PDebugPrint
 6908              	.LVL555:
 6909              	.L487:
 6910              	.LBB255:
 6911              	.LBB256:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6912              		.loc 1 1249 0
 6913 3bf0 F4129FE5 		ldr	r1, .L563+112
 6914 3bf4 0400A0E3 		mov	r0, #4
 6915 3bf8 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6916              		.loc 1 1250 0
 6917 3bfc FA0FA0E3 		mov	r0, #1000
 6918 3c00 FEFFFFEB 		bl	_tx_thread_sleep
 6919 3c04 F9FFFFEA 		b	.L487
 6920              	.LVL556:
 6921              	.L550:
 6922              	.LBE256:
 6923              	.LBE255:
2004:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6924              		.loc 1 2004 0
 6925 3c08 0400A0E3 		mov	r0, #4
 6926              	.LVL557:
 6927 3c0c 20139FE5 		ldr	r1, .L563+184
 6928 3c10 FEFFFFEB 		bl	CyU3PDebugPrint
 6929              	.LVL558:
 6930              	.L497:
 6931              	.LBB257:
 6932              	.LBB258:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6933              		.loc 1 1249 0
 6934 3c14 D0129FE5 		ldr	r1, .L563+112
 6935 3c18 0400A0E3 		mov	r0, #4
 6936 3c1c FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6937              		.loc 1 1250 0
 6938 3c20 FA0FA0E3 		mov	r0, #1000
 6939 3c24 FEFFFFEB 		bl	_tx_thread_sleep
 6940 3c28 F9FFFFEA 		b	.L497
 6941              	.LVL559:
 6942              	.L549:
 6943              	.LBE258:
 6944              	.LBE257:
1980:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6945              		.loc 1 1980 0
 6946 3c2c 040080E2 		add	r0, r0, #4
 6947 3c30 00139FE5 		ldr	r1, .L563+188
 6948 3c34 FEFFFFEB 		bl	CyU3PDebugPrint
 6949              	.LVL560:
 6950              	.L495:
 6951              	.LBB259:
 6952              	.LBB260:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6953              		.loc 1 1249 0
 6954 3c38 AC129FE5 		ldr	r1, .L563+112
 6955 3c3c 0400A0E3 		mov	r0, #4
 6956 3c40 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6957              		.loc 1 1250 0
 6958 3c44 FA0FA0E3 		mov	r0, #1000
 6959 3c48 FEFFFFEB 		bl	_tx_thread_sleep
 6960 3c4c F9FFFFEA 		b	.L495
 6961              	.LVL561:
 6962              	.L553:
 6963              	.LBE260:
 6964              	.LBE259:
 6965              	.LBE262:
 6966              	.LBE271:
2402:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6967              		.loc 1 2402 0
 6968 3c50 88029FE5 		ldr	r0, .L563+100
 6969 3c54 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6970              	.LVL562:
2403:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6971              		.loc 1 2403 0
 6972 3c58 000050E3 		cmp	r0, #0
 6973 3c5c 0200001A 		bne	.L533
2409:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6974              		.loc 1 2409 0
 6975 3c60 8300A0E3 		mov	r0, #131
 6976              	.LVL563:
 6977 3c64 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6978 3c68 F8FEFFEA 		b	.L517
 6979              	.L533:
 6980              	.LBB272:
 6981              	.LBB273:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6982              		.loc 1 1249 0
 6983 3c6c 78129FE5 		ldr	r1, .L563+112
 6984 3c70 0400A0E3 		mov	r0, #4
 6985 3c74 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6986              		.loc 1 1250 0
 6987 3c78 FA0FA0E3 		mov	r0, #1000
 6988 3c7c FEFFFFEB 		bl	_tx_thread_sleep
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6989              		.loc 1 1249 0
 6990 3c80 64129FE5 		ldr	r1, .L563+112
 6991 3c84 0400A0E3 		mov	r0, #4
 6992 3c88 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 6993              		.loc 1 1250 0
 6994 3c8c FA0FA0E3 		mov	r0, #1000
 6995 3c90 FEFFFFEB 		bl	_tx_thread_sleep
 6996 3c94 F4FFFFEA 		b	.L533
 6997              	.L516:
 6998              	.LBE273:
 6999              	.LBE272:
2417:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7000              		.loc 1 2417 0
 7001 3c98 0110A0E3 		mov	r1, #1
 7002 3c9c 0220A0E3 		mov	r2, #2
 7003 3ca0 B4308DE2 		add	r3, sp, #180
 7004 3ca4 DC019FE5 		ldr	r0, .L563+12
 7005 3ca8 00A08DE5 		str	sl, [sp, #0]
 7006 3cac FEFFFFEB 		bl	_txe_event_flags_get
2421:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7007              		.loc 1 2421 0
 7008 3cb0 0620A0E1 		mov	r2, r6
 7009 3cb4 24029FE5 		ldr	r0, .L563+100
 7010 3cb8 0610A0E1 		mov	r1, r6
 7011 3cbc FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7012              	.LVL564:
2422:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7013              		.loc 1 2422 0
 7014 3cc0 002050E2 		subs	r2, r0, #0
 7015 3cc4 2F00001A 		bne	.L559
2430:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 7016              		.loc 1 2430 0
 7017 3cc8 383095E5 		ldr	r3, [r5, #56]
 7018 3ccc 000053E3 		cmp	r3, #0
 7019 3cd0 5800001A 		bne	.L522
2433:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 7020              		.loc 1 2433 0
 7021 3cd4 3010A0E3 		mov	r1, #48
 7022 3cd8 0120A0E3 		mov	r2, #1
 7023 3cdc 823083E2 		add	r3, r3, #130
 7024 3ce0 2100A0E3 		mov	r0, #33
 7025              	.LVL565:
 7026 3ce4 FEFFFFEB 		bl	SensorSetIrisControl
2434:../uvc.c      ****                     CyU3PThreadSleep(500);
 7027              		.loc 1 2434 0
 7028 3ce8 7D0FA0E3 		mov	r0, #500
 7029 3cec FEFFFFEB 		bl	_tx_thread_sleep
2435:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 7030              		.loc 1 2435 0
 7031 3cf0 3010A0E3 		mov	r1, #48
 7032 3cf4 0220A0E3 		mov	r2, #2
 7033 3cf8 5230A0E3 		mov	r3, #82
 7034 3cfc 2500A0E3 		mov	r0, #37
 7035 3d00 FEFFFFEB 		bl	SensorSetIrisControl
2436:../uvc.c      ****                     CyU3PThreadSleep(500);
 7036              		.loc 1 2436 0
 7037 3d04 7D0FA0E3 		mov	r0, #500
 7038 3d08 FEFFFFEB 		bl	_tx_thread_sleep
2437:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
 7039              		.loc 1 2437 0
 7040 3d0c 3010A0E3 		mov	r1, #48
 7041 3d10 0A20A0E3 		mov	r2, #10
 7042 3d14 8230A0E3 		mov	r3, #130
 7043 3d18 2300A0E3 		mov	r0, #35
 7044 3d1c FEFFFFEB 		bl	SensorSetIrisControl
2438:../uvc.c      ****                    	CyU3PThreadSleep(300);
 7045              		.loc 1 2438 0
 7046 3d20 4B0FA0E3 		mov	r0, #300
 7047 3d24 FEFFFFEB 		bl	_tx_thread_sleep
2439:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 7048              		.loc 1 2439 0
 7049 3d28 3010A0E3 		mov	r1, #48
 7050 3d2c 0620A0E1 		mov	r2, r6
 7051 3d30 8230A0E3 		mov	r3, #130
 7052 3d34 2100A0E3 		mov	r0, #33
 7053 3d38 FEFFFFEB 		bl	SensorSetIrisControl
2440:../uvc.c      ****                     CyU3PThreadSleep(500);
 7054              		.loc 1 2440 0
 7055 3d3c 7D0FA0E3 		mov	r0, #500
 7056 3d40 FEFFFFEB 		bl	_tx_thread_sleep
2441:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 7057              		.loc 1 2441 0
 7058 3d44 5230A0E3 		mov	r3, #82
 7059 3d48 3010A0E3 		mov	r1, #48
 7060 3d4c 0620A0E1 		mov	r2, r6
 7061 3d50 2500A0E3 		mov	r0, #37
 7062 3d54 FEFFFFEB 		bl	SensorSetIrisControl
2442:../uvc.c      ****                     CyU3PThreadSleep(500);
 7063              		.loc 1 2442 0
 7064 3d58 7D0FA0E3 		mov	r0, #500
 7065 3d5c FEFFFFEB 		bl	_tx_thread_sleep
 7066              	.LVL566:
 7067              	.LBB274:
 7068              	.LBB276:
2145:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7069              		.loc 1 2145 0
 7070 3d60 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 7071 3d64 030053E3 		cmp	r3, #3
 7072 3d68 2B00000A 		beq	.L560
2150:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 7073              		.loc 1 2150 0
 7074 3d6c 020053E3 		cmp	r3, #2
 7075 3d70 0D00000A 		beq	.L561
 7076              	.LVL567:
 7077              	.L525:
 7078              	.LBE276:
 7079              	.LBE274:
2444:../uvc.c      ****                     gpif_initialized = CyTrue;
 7080              		.loc 1 2444 0
 7081 3d74 01C0A0E3 		mov	ip, #1
 7082 3d78 38C084E5 		str	ip, [r4, #56]
2445:../uvc.c      ****                     CyU3PThreadSleep(200);
 7083              		.loc 1 2445 0
 7084 3d7c C800A0E3 		mov	r0, #200
 7085 3d80 FEFFFFEB 		bl	_tx_thread_sleep
 7086 3d84 7FFEFFEA 		b	.L505
 7087              	.LVL568:
 7088              	.L559:
2425:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 7089              		.loc 1 2425 0
 7090 3d88 0400A0E3 		mov	r0, #4
 7091              	.LVL569:
 7092 3d8c A8119FE5 		ldr	r1, .L563+192
 7093 3d90 FEFFFFEB 		bl	CyU3PDebugPrint
 7094              	.LVL570:
 7095              	.L521:
 7096              	.LBB282:
 7097              	.LBB283:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7098              		.loc 1 1249 0
 7099 3d94 50119FE5 		ldr	r1, .L563+112
 7100 3d98 0400A0E3 		mov	r0, #4
 7101 3d9c FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 7102              		.loc 1 1250 0
 7103 3da0 FA0FA0E3 		mov	r0, #1000
 7104 3da4 FEFFFFEB 		bl	_tx_thread_sleep
 7105 3da8 F9FFFFEA 		b	.L521
 7106              	.LVL571:
 7107              	.L561:
 7108              	.LBE283:
 7109              	.LBE282:
 7110              	.LBB284:
 7111              	.LBB275:
2152:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 7112              		.loc 1 2152 0
 7113 3dac 8C119FE5 		ldr	r1, .L563+196
 7114 3db0 0100A0E3 		mov	r0, #1
 7115 3db4 FEFFFFEB 		bl	CyU3PDebugPrint
2153:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7116              		.loc 1 2153 0
 7117 3db8 84019FE5 		ldr	r0, .L563+200
 7118 3dbc FEFFFFEB 		bl	CyU3PGpifLoad
 7119 3dc0 0020A0E1 		mov	r2, r0
 7120              	.LVL572:
 7121              	.L524:
2155:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7122              		.loc 1 2155 0
 7123 3dc4 000052E3 		cmp	r2, #0
 7124 3dc8 2200001A 		bne	.L562
2163:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7125              		.loc 1 2163 0
 7126 3dcc 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 7127 3dd0 030053E3 		cmp	r3, #3
 7128 3dd4 0100000A 		beq	.L534
2167:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 7129              		.loc 1 2167 0
 7130 3dd8 020053E3 		cmp	r3, #2
 7131 3ddc E4FFFF1A 		bne	.L525
 7132              	.L534:
2169:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7133              		.loc 1 2169 0
 7134 3de0 0200A0E1 		mov	r0, r2
 7135              	.LVL573:
 7136 3de4 0210A0E1 		mov	r1, r2
 7137 3de8 FEFFFFEB 		bl	CyU3PGpifSMStart
 7138              	.LVL574:
2171:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7139              		.loc 1 2171 0
 7140 3dec 000050E3 		cmp	r0, #0
2169:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7141              		.loc 1 2169 0
 7142 3df0 0020A0E1 		mov	r2, r0
 7143              	.LVL575:
2171:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7144              		.loc 1 2171 0
 7145 3df4 DEFFFF0A 		beq	.L525
2174:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 7146              		.loc 1 2174 0
 7147 3df8 0400A0E3 		mov	r0, #4
 7148              	.LVL576:
 7149 3dfc 44119FE5 		ldr	r1, .L563+204
 7150 3e00 FEFFFFEB 		bl	CyU3PDebugPrint
 7151              	.LVL577:
 7152              	.L530:
 7153              	.LBB277:
 7154              	.LBB278:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7155              		.loc 1 1249 0
 7156 3e04 E0109FE5 		ldr	r1, .L563+112
 7157 3e08 0400A0E3 		mov	r0, #4
 7158 3e0c FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 7159              		.loc 1 1250 0
 7160 3e10 FA0FA0E3 		mov	r0, #1000
 7161 3e14 FEFFFFEB 		bl	_tx_thread_sleep
 7162 3e18 F9FFFFEA 		b	.L530
 7163              	.LVL578:
 7164              	.L560:
 7165              	.LBE278:
 7166              	.LBE277:
2147:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 7167              		.loc 1 2147 0
 7168 3e1c 28119FE5 		ldr	r1, .L563+208
 7169 3e20 0100A0E3 		mov	r0, #1
 7170 3e24 FEFFFFEB 		bl	CyU3PDebugPrint
2148:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7171              		.loc 1 2148 0
 7172 3e28 20019FE5 		ldr	r0, .L563+212
 7173 3e2c FEFFFFEB 		bl	CyU3PGpifLoad
 7174 3e30 0020A0E1 		mov	r2, r0
 7175              	.LVL579:
 7176 3e34 E2FFFFEA 		b	.L524
 7177              	.LVL580:
 7178              	.L522:
 7179              	.LBE275:
 7180              	.LBE284:
2452:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7181              		.loc 1 2452 0
 7182 3e38 94009FE5 		ldr	r0, .L563+88
 7183              	.LVL581:
 7184 3e3c 02E0A0E3 		mov	lr, #2
 7185 3e40 0610A0E1 		mov	r1, r6
 7186 3e44 0020A0E1 		mov	r2, r0
 7187              	.LVL582:
 7188 3e48 0630A0E1 		mov	r3, r6
 7189 3e4c 00E08DE5 		str	lr, [sp, #0]
 7190 3e50 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7191 3e54 4BFEFFEA 		b	.L505
 7192              	.LVL583:
 7193              	.L562:
 7194              	.LBB285:
 7195              	.LBB281:
2158:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 7196              		.loc 1 2158 0
 7197 3e58 0400A0E3 		mov	r0, #4
 7198              	.LVL584:
 7199 3e5c F0109FE5 		ldr	r1, .L563+216
 7200 3e60 FEFFFFEB 		bl	CyU3PDebugPrint
 7201              	.LVL585:
 7202              	.L527:
 7203              	.LBB279:
 7204              	.LBB280:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7205              		.loc 1 1249 0
 7206 3e64 80109FE5 		ldr	r1, .L563+112
 7207 3e68 0400A0E3 		mov	r0, #4
 7208 3e6c FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 7209              		.loc 1 1250 0
 7210 3e70 FA0FA0E3 		mov	r0, #1000
 7211 3e74 FEFFFFEB 		bl	_tx_thread_sleep
 7212 3e78 F9FFFFEA 		b	.L527
 7213              	.L564:
 7214              		.align	2
 7215              	.L563:
 7216 3e7c 58070000 		.word	.LC42
 7217 3e80 00C20100 		.word	115200
 7218 3e84 A0860100 		.word	100000
 7219 3e88 00000000 		.word	.LANCHOR0
 7220 3e8c 00000000 		.word	CyFxGpifCB
 7221 3e90 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7222 3e94 00000000 		.word	CyFxUVCApplnUSBEventCB
 7223 3e98 00000000 		.word	CyFxUSBDeviceDscr
 7224 3e9c 00000000 		.word	CyFxUSBDeviceDscrSS
 7225 3ea0 00000000 		.word	CyFxUSBDeviceQualDscr
 7226 3ea4 00000000 		.word	CyFxUSBBOSDscr
 7227 3ea8 00000000 		.word	CyFxUSBHSConfigDscr
 7228 3eac 00000000 		.word	CyFxUSBFSConfigDscr
 7229 3eb0 00000000 		.word	CyFxUSBSSConfigDscr
 7230 3eb4 00000000 		.word	CyFxUSBStringLangIDDscr
 7231 3eb8 00000000 		.word	CyFxUSBManufactureDscr
 7232 3ebc 00000000 		.word	CyFxUSBProductDscr
 7233 3ec0 013F0000 		.word	16129
 7234 3ec4 02030000 		.word	770
 7235 3ec8 00000000 		.word	glChHandleInterStat
 7236 3ecc 00000000 		.word	glInterStaBuffer
 7237 3ed0 00000000 		.word	imgHdMux
 7238 3ed4 01010000 		.word	257
 7239 3ed8 03030000 		.word	771
 7240 3edc 00000000 		.word	CyFxUvcApplnDmaCallback
 7241 3ee0 00000000 		.word	glChHandleUVCStream
 7242 3ee4 00000000 		.word	.LANCHOR1
 7243 3ee8 78070000 		.word	.LC43
 7244 3eec D4010000 		.word	.LC12
 7245 3ef0 94070000 		.word	.LC44
 7246 3ef4 B0070000 		.word	.LC45
 7247 3ef8 80090000 		.word	.LC55
 7248 3efc 5C0A0000 		.word	.LC59
 7249 3f00 E8080000 		.word	.LC52
 7250 3f04 B4080000 		.word	.LC51
 7251 3f08 80080000 		.word	.LC50
 7252 3f0c 54080000 		.word	.LC49
 7253 3f10 00080000 		.word	.LC47
 7254 3f14 DC070000 		.word	.LC46
 7255 3f18 28080000 		.word	.LC48
 7256 3f1c D40A0000 		.word	.LC62
 7257 3f20 A80A0000 		.word	.LC61
 7258 3f24 840A0000 		.word	.LC60
 7259 3f28 B4090000 		.word	.LC56
 7260 3f2c 50090000 		.word	.LC54
 7261 3f30 20090000 		.word	.LC53
 7262 3f34 2C0A0000 		.word	.LC58
 7263 3f38 F4090000 		.word	.LC57
 7264 3f3c 080B0000 		.word	.LC63
 7265 3f40 4C0B0000 		.word	.LC65
 7266 3f44 2C000000 		.word	.LANCHOR2+44
 7267 3f48 940B0000 		.word	.LC67
 7268 3f4c 3C0B0000 		.word	.LC64
 7269 3f50 10000000 		.word	.LANCHOR2+16
 7270 3f54 5C0B0000 		.word	.LC66
 7271              	.LBE280:
 7272              	.LBE279:
 7273              	.LBE281:
 7274              	.LBE285:
 7275              		.cfi_endproc
 7276              	.LFE18:
 7278              		.align	2
 7279              		.global	CyFxUVCApplnI2CInit
 7281              	CyFxUVCApplnI2CInit:
 7282              	.LFB14:
1696:../uvc.c      **** {
 7283              		.loc 1 1696 0
 7284              		.cfi_startproc
 7285              		@ args = 0, pretend = 0, frame = 16
 7286              		@ frame_needed = 0, uses_anonymous_args = 0
 7287 3f58 04E02DE5 		str	lr, [sp, #-4]!
 7288              	.LCFI25:
 7289              		.cfi_def_cfa_offset 4
 7290 3f5c 14D04DE2 		sub	sp, sp, #20
 7291              	.LCFI26:
 7292              		.cfi_def_cfa_offset 24
1700:../uvc.c      ****     status = CyU3PI2cInit ();
 7293              		.loc 1 1700 0
 7294              		.cfi_offset 14, -4
 7295 3f60 FEFFFFEB 		bl	CyU3PI2cInit
 7296              	.LVL586:
1701:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7297              		.loc 1 1701 0
 7298 3f64 002050E2 		subs	r2, r0, #0
 7299 3f68 0B00001A 		bne	.L570
1708:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7300              		.loc 1 1708 0
 7301 3f6c 70C09FE5 		ldr	ip, .L572
1710:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7302              		.loc 1 1710 0
 7303 3f70 0030E0E3 		mvn	r3, #0
1713:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7304              		.loc 1 1713 0
 7305 3f74 0D00A0E1 		mov	r0, sp
 7306              	.LVL587:
 7307 3f78 0210A0E1 		mov	r1, r2
1708:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7308              		.loc 1 1708 0
 7309 3f7c 00C08DE5 		str	ip, [sp, #0]
1709:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7310              		.loc 1 1709 0
 7311 3f80 0C008DE9 		stmib	sp, {r2, r3}	@ phole stm
1711:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7312              		.loc 1 1711 0
 7313 3f84 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1713:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7314              		.loc 1 1713 0
 7315 3f88 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7316              	.LVL588:
1714:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7317              		.loc 1 1714 0
 7318 3f8c 000050E3 		cmp	r0, #0
 7319 3f90 0A00001A 		bne	.L571
1719:../uvc.c      **** }
 7320              		.loc 1 1719 0
 7321 3f94 14D08DE2 		add	sp, sp, #20
 7322 3f98 04F09DE4 		ldmfd	sp!, {pc}
 7323              	.L570:
1703:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7324              		.loc 1 1703 0
 7325 3f9c 0400A0E3 		mov	r0, #4
 7326              	.LVL589:
 7327 3fa0 40109FE5 		ldr	r1, .L572+4
 7328 3fa4 FEFFFFEB 		bl	CyU3PDebugPrint
 7329              	.LVL590:
 7330              	.L567:
 7331              	.LBB290:
 7332              	.LBB291:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7333              		.loc 1 1249 0
 7334 3fa8 3C109FE5 		ldr	r1, .L572+8
 7335 3fac 0400A0E3 		mov	r0, #4
 7336 3fb0 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 7337              		.loc 1 1250 0
 7338 3fb4 FA0FA0E3 		mov	r0, #1000
 7339 3fb8 FEFFFFEB 		bl	_tx_thread_sleep
 7340 3fbc F9FFFFEA 		b	.L567
 7341              	.LVL591:
 7342              	.L571:
 7343              	.LBE291:
 7344              	.LBE290:
1716:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7345              		.loc 1 1716 0
 7346 3fc0 0400A0E3 		mov	r0, #4
 7347              	.LVL592:
 7348 3fc4 24109FE5 		ldr	r1, .L572+12
 7349 3fc8 FEFFFFEB 		bl	CyU3PDebugPrint
 7350              	.L569:
 7351              	.LBB292:
 7352              	.LBB293:
1249:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7353              		.loc 1 1249 0
 7354 3fcc 18109FE5 		ldr	r1, .L572+8
 7355 3fd0 0400A0E3 		mov	r0, #4
 7356 3fd4 FEFFFFEB 		bl	CyU3PDebugPrint
1250:../uvc.c      ****         CyU3PThreadSleep (1000);
 7357              		.loc 1 1250 0
 7358 3fd8 FA0FA0E3 		mov	r0, #1000
 7359 3fdc FEFFFFEB 		bl	_tx_thread_sleep
 7360 3fe0 F9FFFFEA 		b	.L569
 7361              	.L573:
 7362              		.align	2
 7363              	.L572:
 7364 3fe4 A0860100 		.word	100000
 7365 3fe8 78070000 		.word	.LC43
 7366 3fec D4010000 		.word	.LC12
 7367 3ff0 94070000 		.word	.LC44
 7368              	.LBE293:
 7369              	.LBE292:
 7370              		.cfi_endproc
 7371              	.LFE14:
 7373              		.align	2
 7374              		.global	CyFxApplicationDefine
 7376              	CyFxApplicationDefine:
 7377              	.LFB26:
3723:../uvc.c      **** }
3724:../uvc.c      **** 
3725:../uvc.c      **** 
3726:../uvc.c      **** /*
3727:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3728:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3729:../uvc.c      ****  */
3730:../uvc.c      **** void
3731:../uvc.c      **** CyFxApplicationDefine (
3732:../uvc.c      ****         void)
3733:../uvc.c      **** {
 7378              		.loc 1 3733 0
 7379              		.cfi_startproc
 7380              		@ args = 0, pretend = 0, frame = 40
 7381              		@ frame_needed = 0, uses_anonymous_args = 0
 7382              	.LVL593:
 7383 3ff4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7384              	.LCFI27:
 7385              		.cfi_def_cfa_offset 36
3734:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3735:../uvc.c      ****     uint32_t retThrdCreate;
3736:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3737:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3738:../uvc.c      **** 
3739:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3740:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7386              		.loc 1 3740 0
 7387 3ff8 010AA0E3 		mov	r0, #4096
3733:../uvc.c      **** {
 7388              		.loc 1 3733 0
 7389 3ffc 4CD04DE2 		sub	sp, sp, #76
 7390              	.LCFI28:
 7391              		.cfi_def_cfa_offset 112
 7392              		.loc 1 3740 0
 7393              		.cfi_offset 14, -4
 7394              		.cfi_offset 11, -8
 7395              		.cfi_offset 10, -12
 7396              		.cfi_offset 9, -16
 7397              		.cfi_offset 8, -20
 7398              		.cfi_offset 7, -24
 7399              		.cfi_offset 6, -28
 7400              		.cfi_offset 5, -32
 7401              		.cfi_offset 4, -36
 7402 4000 FEFFFFEB 		bl	CyU3PMemAlloc
 7403 4004 00A0A0E1 		mov	sl, r0
 7404              	.LVL594:
3741:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7405              		.loc 1 3741 0
 7406 4008 010AA0E3 		mov	r0, #4096
 7407              	.LVL595:
 7408 400c FEFFFFEB 		bl	CyU3PMemAlloc
 7409 4010 00B0A0E1 		mov	fp, r0
 7410              	.LVL596:
3742:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7411              		.loc 1 3742 0
 7412 4014 010AA0E3 		mov	r0, #4096
 7413              	.LVL597:
 7414 4018 FEFFFFEB 		bl	CyU3PMemAlloc
3743:../uvc.c      **** 
3744:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7415              		.loc 1 3744 0
 7416 401c 00005AE3 		cmp	sl, #0
 7417 4020 00005B13 		cmpne	fp, #0
 7418 4024 0090A013 		movne	r9, #0
 7419 4028 0190A003 		moveq	r9, #1
3742:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7420              		.loc 1 3742 0
 7421 402c 24008DE5 		str	r0, [sp, #36]
 7422              	.LVL598:
 7423              		.loc 1 3744 0
 7424 4030 0000001A 		bne	.L578
 7425              	.LVL599:
 7426              	.L575:
 7427              	.L577:
 7428 4034 FEFFFFEA 		b	.L577
 7429              	.L578:
 7430              		.loc 1 3744 0 is_stmt 0 discriminator 1
 7431 4038 000050E3 		cmp	r0, #0
 7432 403c FCFFFF0A 		beq	.L575
3745:../uvc.c      ****         goto fatalErrorHandler;
3746:../uvc.c      **** 
3747:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3748:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7433              		.loc 1 3748 0 is_stmt 1
 7434 4040 28408DE2 		add	r4, sp, #40
 7435 4044 0400A0E1 		mov	r0, r4
 7436 4048 4010A0E3 		mov	r1, #64
 7437 404c 18219FE5 		ldr	r2, .L579
 7438 4050 FEFFFFEB 		bl	cmdbufCreate
 7439 4054 0450A0E1 		mov	r5, r4
 7440 4058 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7441 405c 0C719FE5 		ldr	r7, .L579+4
3749:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7442              		.loc 1 3749 0
 7443 4060 0C819FE5 		ldr	r8, .L579+8
3748:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7444              		.loc 1 3748 0
 7445 4064 07C0A0E1 		mov	ip, r7
 7446 4068 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7447 406c 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3750:../uvc.c      **** 
3751:../uvc.c      **** 	/****** initialize command descriptor ***********/
3752:../uvc.c      **** 	cmdquInit(cmdQuptr);
3753:../uvc.c      **** 	cmdquInit(statQuptr);
3754:../uvc.c      **** 
3755:../uvc.c      ****     /* Create the UVC application thread. */
3756:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7448              		.loc 1 3756 0
 7449 4070 0860A0E3 		mov	r6, #8
3748:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7450              		.loc 1 3748 0
 7451 4074 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3749:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7452              		.loc 1 3749 0
 7453 4078 F8209FE5 		ldr	r2, .L579+12
 7454 407c 0400A0E1 		mov	r0, r4
 7455 4080 2010A0E3 		mov	r1, #32
 7456 4084 FEFFFFEB 		bl	cmdbufCreate
 7457 4088 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7458 408c 08C0A0E1 		mov	ip, r8
 7459 4090 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7460 4094 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7461              		.loc 1 3756 0
 7462 4098 0140A0E3 		mov	r4, #1
3749:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7463              		.loc 1 3749 0
 7464 409c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3752:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7465              		.loc 1 3752 0
 7466 40a0 0700A0E1 		mov	r0, r7
 7467 40a4 FEFFFFEB 		bl	cmdquInit
3753:../uvc.c      **** 	cmdquInit(statQuptr);
 7468              		.loc 1 3753 0
 7469 40a8 0800A0E1 		mov	r0, r8
 7470 40ac FEFFFFEB 		bl	cmdquInit
 7471              		.loc 1 3756 0
 7472 40b0 A850A0E3 		mov	r5, #168
 7473 40b4 01CAA0E3 		mov	ip, #4096
 7474 40b8 BC009FE5 		ldr	r0, .L579+16
 7475 40bc BC109FE5 		ldr	r1, .L579+20
 7476 40c0 BC209FE5 		ldr	r2, .L579+24
 7477 40c4 0930A0E1 		mov	r3, r9
 7478 40c8 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7479 40cc 08608DE5 		str	r6, [sp, #8]
 7480 40d0 0C608DE5 		str	r6, [sp, #12]
 7481 40d4 10908DE5 		str	r9, [sp, #16]
 7482 40d8 14408DE5 		str	r4, [sp, #20]
 7483 40dc 18508DE5 		str	r5, [sp, #24]
 7484 40e0 FEFFFFEB 		bl	_txe_thread_create
 7485              	.LVL600:
3757:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3758:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3759:../uvc.c      ****             0,                                          /* No input parameter to thread */
3760:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3761:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3762:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3763:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3764:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3765:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3766:../uvc.c      ****             );
3767:../uvc.c      ****     if (retThrdCreate != 0)
 7486              		.loc 1 3767 0
 7487 40e4 00C050E2 		subs	ip, r0, #0
 7488 40e8 D1FFFF1A 		bne	.L575
3768:../uvc.c      ****     {
3769:../uvc.c      ****         goto fatalErrorHandler;
3770:../uvc.c      ****     }
3771:../uvc.c      **** 
3772:../uvc.c      ****     /* Create the control request handling thread. */
3773:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7489              		.loc 1 3773 0
 7490 40ec 0C30A0E1 		mov	r3, ip
 7491 40f0 027BA0E3 		mov	r7, #2048
 7492 40f4 8C009FE5 		ldr	r0, .L579+28
 7493              	.LVL601:
 7494 40f8 8C109FE5 		ldr	r1, .L579+32
 7495 40fc 8C209FE5 		ldr	r2, .L579+36
 7496 4100 10C08DE5 		str	ip, [sp, #16]
 7497 4104 00B08DE5 		str	fp, [sp, #0]
 7498 4108 04708DE5 		str	r7, [sp, #4]
 7499 410c 08608DE5 		str	r6, [sp, #8]
 7500 4110 0C608DE5 		str	r6, [sp, #12]
 7501 4114 14408DE5 		str	r4, [sp, #20]
 7502 4118 18508DE5 		str	r5, [sp, #24]
 7503 411c FEFFFFEB 		bl	_txe_thread_create
 7504              	.LVL602:
3774:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3775:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3776:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3777:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3778:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3779:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3780:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3781:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3782:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3783:../uvc.c      ****             );
3784:../uvc.c      ****     if (retThrdCreate != 0)
 7505              		.loc 1 3784 0
 7506 4120 00C050E2 		subs	ip, r0, #0
 7507 4124 C2FFFF1A 		bne	.L575
3785:../uvc.c      ****     {
3786:../uvc.c      ****         goto fatalErrorHandler;
3787:../uvc.c      ****     }
3788:../uvc.c      **** #if 1
3789:../uvc.c      ****     /* Create the I2C control command handling thread. */
3790:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7508              		.loc 1 3790 0
 7509 4128 24E09DE5 		ldr	lr, [sp, #36]
 7510 412c 60009FE5 		ldr	r0, .L579+40
 7511              	.LVL603:
 7512 4130 60109FE5 		ldr	r1, .L579+44
 7513 4134 60209FE5 		ldr	r2, .L579+48
 7514 4138 0C30A0E1 		mov	r3, ip
 7515 413c 00E08DE5 		str	lr, [sp, #0]
 7516 4140 04708DE5 		str	r7, [sp, #4]
 7517 4144 08608DE5 		str	r6, [sp, #8]
 7518 4148 0C608DE5 		str	r6, [sp, #12]
 7519 414c 10C08DE5 		str	ip, [sp, #16]
 7520 4150 14408DE5 		str	r4, [sp, #20]
 7521 4154 18508DE5 		str	r5, [sp, #24]
 7522 4158 FEFFFFEB 		bl	_txe_thread_create
 7523              	.LVL604:
3791:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3792:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3793:../uvc.c      ****             0,                                          /* No input parameter to thread */
3794:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3795:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3796:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3797:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3798:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3799:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3800:../uvc.c      ****             );
3801:../uvc.c      ****     if (retThrdCreate != 0)
 7524              		.loc 1 3801 0
 7525 415c 000050E3 		cmp	r0, #0
 7526 4160 B3FFFF1A 		bne	.L575
3802:../uvc.c      ****     {
3803:../uvc.c      ****         goto fatalErrorHandler;
3804:../uvc.c      ****     }
3805:../uvc.c      **** #endif
3806:../uvc.c      **** 
3807:../uvc.c      ****     return;
3808:../uvc.c      **** 
3809:../uvc.c      **** fatalErrorHandler:
3810:../uvc.c      ****     /* Add custom recovery or debug actions here */
3811:../uvc.c      ****     /* Loop indefinitely */
3812:../uvc.c      ****     while (1);
3813:../uvc.c      **** }
 7527              		.loc 1 3813 0
 7528 4164 4CD08DE2 		add	sp, sp, #76
 7529 4168 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7530              	.L580:
 7531              		.align	2
 7532              	.L579:
 7533 416c 00000000 		.word	cmdQuMux
 7534 4170 00000000 		.word	cmdQu
 7535 4174 00000000 		.word	statQu
 7536 4178 00000000 		.word	staQuMux
 7537 417c A8000000 		.word	.LANCHOR0+168
 7538 4180 CC0B0000 		.word	.LC68
 7539 4184 00000000 		.word	UVCAppThread_Entry
 7540 4188 50010000 		.word	.LANCHOR0+336
 7541 418c E00B0000 		.word	.LC69
 7542 4190 00000000 		.word	UVCAppEP0Thread_Entry
 7543 4194 F8010000 		.word	.LANCHOR0+504
 7544 4198 F80B0000 		.word	.LC70
 7545 419c 00000000 		.word	I2cAppThread_Entry
 7546              		.cfi_endproc
 7547              	.LFE26:
 7549              		.align	2
 7550              		.global	main
 7552              	main:
 7553              	.LFB27:
3814:../uvc.c      **** 
3815:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3816:../uvc.c      ****  * the ThreadX RTOS here.
3817:../uvc.c      ****  */
3818:../uvc.c      **** int
3819:../uvc.c      **** main (
3820:../uvc.c      ****         void)
3821:../uvc.c      **** {
 7554              		.loc 1 3821 0
 7555              		.cfi_startproc
 7556              		@ args = 0, pretend = 0, frame = 56
 7557              		@ frame_needed = 0, uses_anonymous_args = 0
 7558 41a0 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7559              	.LCFI29:
 7560              		.cfi_def_cfa_offset 12
3822:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3823:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3824:../uvc.c      **** 
3825:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3826:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3827:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3828:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3829:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3830:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7561              		.loc 1 3830 0
 7562 41a4 0010A0E3 		mov	r1, #0
3821:../uvc.c      **** {
 7563              		.loc 1 3821 0
 7564 41a8 3CD04DE2 		sub	sp, sp, #60
 7565              	.LCFI30:
 7566              		.cfi_def_cfa_offset 72
3827:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7567              		.loc 1 3827 0
 7568 41ac 0220A0E3 		mov	r2, #2
3831:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7569              		.loc 1 3831 0
 7570 41b0 033081E2 		add	r3, r1, #3
3826:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7571              		.loc 1 3826 0
 7572 41b4 0150A0E3 		mov	r5, #1
 7573              		.cfi_offset 14, -4
 7574              		.cfi_offset 5, -8
 7575              		.cfi_offset 4, -12
3832:../uvc.c      **** 
3833:../uvc.c      ****     /* Initialize the device */
3834:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7576              		.loc 1 3834 0
 7577 41b8 28008DE2 		add	r0, sp, #40
3826:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7578              		.loc 1 3826 0
 7579 41bc 28508DE5 		str	r5, [sp, #40]
3827:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7580              		.loc 1 3827 0
 7581 41c0 2C20CDE5 		strb	r2, [sp, #44]
3828:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7582              		.loc 1 3828 0
 7583 41c4 2D20CDE5 		strb	r2, [sp, #45]
3829:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7584              		.loc 1 3829 0
 7585 41c8 2E20CDE5 		strb	r2, [sp, #46]
3830:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7586              		.loc 1 3830 0
 7587 41cc 30108DE5 		str	r1, [sp, #48]
3831:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7588              		.loc 1 3831 0
 7589 41d0 3430CDE5 		strb	r3, [sp, #52]
 7590              		.loc 1 3834 0
 7591 41d4 FEFFFFEB 		bl	CyU3PDeviceInit
 7592              	.LVL605:
3835:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7593              		.loc 1 3835 0
 7594 41d8 004050E2 		subs	r4, r0, #0
 7595 41dc 0000000A 		beq	.L584
 7596              	.L582:
 7597              	.L583:
 7598 41e0 FEFFFFEA 		b	.L583
 7599              	.L584:
3836:../uvc.c      ****     {
3837:../uvc.c      ****         goto handle_fatal_error;
3838:../uvc.c      ****     }
3839:../uvc.c      **** 
3840:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3841:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7600              		.loc 1 3841 0
 7601 41e4 0410A0E1 		mov	r1, r4
 7602 41e8 0420A0E1 		mov	r2, r4
 7603 41ec 0500A0E1 		mov	r0, r5
 7604              	.LVL606:
 7605 41f0 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7606              	.LVL607:
3842:../uvc.c      **** 
3843:../uvc.c      ****     /* Configure the IO matrix for the device. */
3844:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3845:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3846:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3847:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3848:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3849:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3850:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3851:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3852:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3853:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3854:../uvc.c      **** 
3855:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7607              		.loc 1 3855 0
 7608 41f4 0D00A0E1 		mov	r0, sp
3845:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7609              		.loc 1 3845 0
 7610 41f8 1640CDE5 		strb	r4, [sp, #22]
3846:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7611              		.loc 1 3846 0
 7612 41fc 18408DE5 		str	r4, [sp, #24]
3847:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7613              		.loc 1 3847 0
 7614 4200 1C408DE5 		str	r4, [sp, #28]
3848:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7615              		.loc 1 3848 0
 7616 4204 20408DE5 		str	r4, [sp, #32]
3849:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7617              		.loc 1 3849 0
 7618 4208 24408DE5 		str	r4, [sp, #36]
3852:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7619              		.loc 1 3852 0
 7620 420c 0C408DE5 		str	r4, [sp, #12]
3853:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7621              		.loc 1 3853 0
 7622 4210 10408DE5 		str	r4, [sp, #16]
3844:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7623              		.loc 1 3844 0
 7624 4214 00508DE5 		str	r5, [sp, #0]
3850:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7625              		.loc 1 3850 0
 7626 4218 04508DE5 		str	r5, [sp, #4]
3851:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7627              		.loc 1 3851 0
 7628 421c 08508DE5 		str	r5, [sp, #8]
 7629              		.loc 1 3855 0
 7630 4220 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7631              	.LVL608:
3856:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7632              		.loc 1 3856 0
 7633 4224 004050E2 		subs	r4, r0, #0
 7634 4228 ECFFFF1A 		bne	.L582
3857:../uvc.c      ****     {
3858:../uvc.c      ****         goto handle_fatal_error;
3859:../uvc.c      ****     }
3860:../uvc.c      **** 
3861:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3862:../uvc.c      ****     CyU3PKernelEntry ();
 7635              		.loc 1 3862 0
 7636 422c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7637              	.LVL609:
3863:../uvc.c      **** 
3864:../uvc.c      ****     /* Dummy return to make the compiler happy */
3865:../uvc.c      ****     return 0;
3866:../uvc.c      **** 
3867:../uvc.c      **** handle_fatal_error:
3868:../uvc.c      ****     /* Cannot recover from this error. */
3869:../uvc.c      ****     while (1);
3870:../uvc.c      **** }
 7638              		.loc 1 3870 0
 7639 4230 0400A0E1 		mov	r0, r4
 7640 4234 3CD08DE2 		add	sp, sp, #60
 7641 4238 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7642              		.cfi_endproc
 7643              	.LFE27:
 7645              		.global	CyFxGpifTransition
 7646              		.global	CyFxGpifWavedata
 7647              		.global	CyFxGpifWavedataPosition
 7648              		.global	CyFxGpifRegValue
 7649              		.global	CyFxGpifConfig
 7650              		.global	CyFxGpifTransition_usb2
 7651              		.global	CyFxGpifWavedata_usb2
 7652              		.global	CyFxGpifWavedataPosition_usb2
 7653              		.global	CyFxGpifRegValue_usb2
 7654              		.global	CyFxGpifConfig_usb2
 7655              		.global	snapButFlag
 7656              		.global	testSnap
 7657              		.global	fb
 7658              		.global	pb
 7659              		.global	pbc
 7660              		.global	fbbak
 7661              		.global	pbbak
 7662              		.global	pbcbak
 7663              		.global	pbcpbak
 7664              		.global	isUsbConnected
 7665              		.global	usbSpeed
 7666              		.global	clearFeatureRqtReceived
 7667              		.global	streamingStarted
 7668              		.global	glProbeCtrl
 7669              		.global	glProbeStilCtrl
 7670              		.global	glProbeCtrl20
 7671              		.global	glProbeStilCtrl20
 7672              		.global	glUVCHeader
 7673              		.comm	glChHandleUVCStream,220,4
 7674              		.comm	glChHandleStillStream,220,4
 7675              		.comm	glChHandleInterStat,160,4
 7676              		.comm	glInterStaBuffer,4,4
 7677              		.comm	cmdQu,32,4
 7678              		.comm	statQu,32,4
 7679              		.comm	cmdQuMux,56,4
 7680              		.comm	staQuMux,56,4
 7681              		.comm	timMux,56,4
 7682              		.comm	imgHdMux,56,4
 7683              		.comm	bmReqType,1,1
 7684              		.comm	bRequest,1,1
 7685              		.comm	wValue,2,2
 7686              		.comm	wIndex,2,2
 7687              		.comm	wLength,2,2
 7688              		.comm	posTick,4,4
 7689              		.comm	I2CCmdTimer,44,4
 7690              		.section	.rodata
 7691              		.align	2
 7692              		.set	.LANCHOR2,. + 0
 7695              	ExTime:
 7696 0000 9C       		.byte	-100
 7697 0001 00       		.byte	0
 7698 0002 4E       		.byte	78
 7699 0003 00       		.byte	0
 7700 0004 27       		.byte	39
 7701 0005 00       		.byte	0
 7702 0006 14       		.byte	20
 7703 0007 00       		.byte	0
 7704 0008 0A       		.byte	10
 7705 0009 00       		.byte	0
 7706 000a 05       		.byte	5
 7707 000b 00       		.byte	0
 7708 000c 02       		.byte	2
 7709 000d 00       		.byte	0
 7710 000e 01       		.byte	1
 7711 000f 00       		.byte	0
 7714              	CyFxGpifConfig:
 7715 0010 0F00     		.short	15
 7716 0012 0000     		.space	2
 7717 0014 00000000 		.word	CyFxGpifWavedata
 7718 0018 00000000 		.word	CyFxGpifWavedataPosition
 7719 001c 0500     		.short	5
 7720 001e 0000     		.space	2
 7721 0020 00000000 		.word	CyFxGpifTransition
 7722 0024 4C00     		.short	76
 7723 0026 0000     		.space	2
 7724 0028 00000000 		.word	CyFxGpifRegValue
 7727              	CyFxGpifConfig_usb2:
 7728 002c 9300     		.short	147
 7729 002e 0000     		.space	2
 7730 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7731 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7732 0038 0800     		.short	8
 7733 003a 0000     		.space	2
 7734 003c 00000000 		.word	CyFxGpifTransition_usb2
 7735 0040 4C00     		.short	76
 7736 0042 0000     		.space	2
 7737 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7738              		.data
 7739              		.align	2
 7740              		.set	.LANCHOR1,. + 0
 7743              	ExUCtrlParArry:
 7744 0000 00       		.byte	0
 7745 0001 00       		.byte	0
 7746 0002 04       		.byte	4
 7747 0003 01       		.byte	1
 7748 0004 00       		.byte	0
 7749 0005 38       		.byte	56
 7750 0006 01       		.byte	1
 7751 0007 01       		.byte	1
 7752 0008 00       		.byte	0
 7753 0009 03       		.byte	3
 7754 000a 00       		.byte	0
 7755 000b 4E       		.byte	78
 7756 000c 00       		.byte	0
 7757 000d 4E       		.byte	78
 7758 000e 00       		.byte	0
 7759 000f 30       		.byte	48
 7760 0010 01       		.byte	1
 7761 0011 00       		.byte	0
 7762 0012 00       		.byte	0
 7763 0013 00000000 		.space	5
 7763      00
 7764 0018 00       		.byte	0
 7765 0019 00       		.byte	0
 7766 001a 01       		.byte	1
 7767 001b 00       		.byte	0
 7768 001c 00       		.byte	0
 7769 001d 00       		.byte	0
 7770 001e 00       		.byte	0
 7771 001f 01       		.byte	1
 7772 0020 00       		.byte	0
 7773 0021 03       		.byte	3
 7774 0022 00       		.byte	0
 7775 0023 00       		.byte	0
 7776 0024 00       		.byte	0
 7777 0025 00       		.byte	0
 7778 0026 00       		.byte	0
 7779 0027 30       		.byte	48
 7780 0028 01       		.byte	1
 7781 0029 00       		.byte	0
 7782 002a 00       		.byte	0
 7783 002b 00000000 		.space	5
 7783      00
 7784 0030 00       		.byte	0
 7785 0031 00       		.byte	0
 7786 0032 02       		.byte	2
 7787 0033 00       		.byte	0
 7788 0034 00       		.byte	0
 7789 0035 FF       		.byte	-1
 7790 0036 00       		.byte	0
 7791 0037 01       		.byte	1
 7792 0038 00       		.byte	0
 7793 0039 03       		.byte	3
 7794 003a 00       		.byte	0
 7795 003b 01       		.byte	1
 7796 003c 00       		.byte	0
 7797 003d 00       		.byte	0
 7798 003e 00       		.byte	0
 7799 003f 30       		.byte	48
 7800 0040 01       		.byte	1
 7801 0041 01       		.byte	1
 7802 0042 00       		.byte	0
 7803 0043 00000000 		.space	5
 7803      00
 7804 0048 00       		.byte	0
 7805 0049 00       		.byte	0
 7806 004a 02       		.byte	2
 7807 004b 00       		.byte	0
 7808 004c 00       		.byte	0
 7809 004d 00       		.byte	0
 7810 004e 00       		.byte	0
 7811 004f 00       		.byte	0
 7812 0050 00       		.byte	0
 7813 0051 03       		.byte	3
 7814 0052 00       		.byte	0
 7815 0053 00       		.byte	0
 7816 0054 00       		.byte	0
 7817 0055 00       		.byte	0
 7818 0056 00       		.byte	0
 7819 0057 30       		.byte	48
 7820 0058 01       		.byte	1
 7821 0059 01       		.byte	1
 7822 005a 00       		.byte	0
 7823 005b 00000000 		.space	5
 7823      00
 7824 0060 13       		.byte	19
 7825 0061 14       		.byte	20
 7826 0062 02       		.byte	2
 7827 0063 01       		.byte	1
 7828 0064 00       		.byte	0
 7829 0065 03       		.byte	3
 7830 0066 00       		.byte	0
 7831 0067 01       		.byte	1
 7832 0068 00       		.byte	0
 7833 0069 03       		.byte	3
 7834 006a 00       		.byte	0
 7835 006b 23       		.byte	35
 7836 006c 37       		.byte	55
 7837 006d 23       		.byte	35
 7838 006e 37       		.byte	55
 7839 006f 30       		.byte	48
 7840 0070 01       		.byte	1
 7841 0071 00       		.byte	0
 7842 0072 00       		.byte	0
 7843 0073 00000000 		.space	5
 7843      00
 7844 0078 11       		.byte	17
 7845 0079 00       		.byte	0
 7846 007a 02       		.byte	2
 7847 007b 01       		.byte	1
 7848 007c 00       		.byte	0
 7849 007d 03       		.byte	3
 7850 007e 00       		.byte	0
 7851 007f 01       		.byte	1
 7852 0080 00       		.byte	0
 7853 0081 03       		.byte	3
 7854 0082 00       		.byte	0
 7855 0083 01       		.byte	1
 7856 0084 00       		.byte	0
 7857 0085 01       		.byte	1
 7858 0086 00       		.byte	0
 7859 0087 30       		.byte	48
 7860 0088 01       		.byte	1
 7861 0089 01       		.byte	1
 7862 008a 00       		.byte	0
 7863 008b 00000000 		.space	5
 7863      00
 7864 0090 17       		.byte	23
 7865 0091 00       		.byte	0
 7866 0092 01       		.byte	1
 7867 0093 01       		.byte	1
 7868 0094 00       		.byte	0
 7869 0095 02       		.byte	2
 7870 0096 00       		.byte	0
 7871 0097 01       		.byte	1
 7872 0098 00       		.byte	0
 7873 0099 03       		.byte	3
 7874 009a 00       		.byte	0
 7875 009b 00       		.byte	0
 7876 009c 00       		.byte	0
 7877 009d 00       		.byte	0
 7878 009e 00       		.byte	0
 7879 009f 30       		.byte	48
 7880 00a0 01       		.byte	1
 7881 00a1 01       		.byte	1
 7882 00a2 00       		.byte	0
 7883 00a3 00000000 		.space	5
 7883      00
 7884 00a8 00       		.byte	0
 7885 00a9 00       		.byte	0
 7886 00aa 04       		.byte	4
 7887 00ab 01       		.byte	1
 7888 00ac 00       		.byte	0
 7889 00ad 38       		.byte	56
 7890 00ae 01       		.byte	1
 7891 00af 01       		.byte	1
 7892 00b0 00       		.byte	0
 7893 00b1 03       		.byte	3
 7894 00b2 00       		.byte	0
 7895 00b3 4E       		.byte	78
 7896 00b4 00       		.byte	0
 7897 00b5 4E       		.byte	78
 7898 00b6 00       		.byte	0
 7899 00b7 30       		.byte	48
 7900 00b8 01       		.byte	1
 7901 00b9 00       		.byte	0
 7902 00ba 00       		.byte	0
 7903 00bb 00000000 		.space	5
 7903      00
 7904 00c0 00       		.byte	0
 7905 00c1 00       		.byte	0
 7906 00c2 01       		.byte	1
 7907 00c3 00       		.byte	0
 7908 00c4 00       		.byte	0
 7909 00c5 00       		.byte	0
 7910 00c6 00       		.byte	0
 7911 00c7 01       		.byte	1
 7912 00c8 00       		.byte	0
 7913 00c9 03       		.byte	3
 7914 00ca 00       		.byte	0
 7915 00cb 00       		.byte	0
 7916 00cc 00       		.byte	0
 7917 00cd 00       		.byte	0
 7918 00ce 00       		.byte	0
 7919 00cf 30       		.byte	48
 7920 00d0 01       		.byte	1
 7921 00d1 00       		.byte	0
 7922 00d2 00       		.byte	0
 7923 00d3 00000000 		.space	5
 7923      00
 7924 00d8 00       		.byte	0
 7925 00d9 00       		.byte	0
 7926 00da 02       		.byte	2
 7927 00db 00       		.byte	0
 7928 00dc 00       		.byte	0
 7929 00dd 05       		.byte	5
 7930 00de 00       		.byte	0
 7931 00df 01       		.byte	1
 7932 00e0 00       		.byte	0
 7933 00e1 03       		.byte	3
 7934 00e2 00       		.byte	0
 7935 00e3 00       		.byte	0
 7936 00e4 00       		.byte	0
 7937 00e5 00       		.byte	0
 7938 00e6 00       		.byte	0
 7939 00e7 30       		.byte	48
 7940 00e8 01       		.byte	1
 7941 00e9 00       		.byte	0
 7942 00ea 00       		.byte	0
 7943 00eb 00000000 		.space	5
 7943      00
 7944 00f0 00       		.byte	0
 7945 00f1 00       		.byte	0
 7946 00f2 03       		.byte	3
 7947 00f3 00       		.byte	0
 7948 00f4 00       		.byte	0
 7949 00f5 0A       		.byte	10
 7950 00f6 00       		.byte	0
 7951 00f7 01       		.byte	1
 7952 00f8 00       		.byte	0
 7953 00f9 03       		.byte	3
 7954 00fa 00       		.byte	0
 7955 00fb 00       		.byte	0
 7956 00fc 00       		.byte	0
 7957 00fd 00       		.byte	0
 7958 00fe 00       		.byte	0
 7959 00ff 30       		.byte	48
 7960 0100 01       		.byte	1
 7961 0101 00       		.byte	0
 7962 0102 00       		.byte	0
 7963 0103 00000000 		.space	5
 7963      00
 7964 0108 00       		.byte	0
 7965 0109 00       		.byte	0
 7966 010a 02       		.byte	2
 7967 010b 00       		.byte	0
 7968 010c 00       		.byte	0
 7969 010d 40       		.byte	64
 7970 010e 00       		.byte	0
 7971 010f 01       		.byte	1
 7972 0110 00       		.byte	0
 7973 0111 03       		.byte	3
 7974 0112 00       		.byte	0
 7975 0113 0F       		.byte	15
 7976 0114 11       		.byte	17
 7977 0115 00       		.byte	0
 7978 0116 00       		.byte	0
 7979 0117 30       		.byte	48
 7980 0118 01       		.byte	1
 7981 0119 00       		.byte	0
 7982 011a 00       		.byte	0
 7983 011b 00000000 		.space	5
 7983      00
 7984 0120 00       		.byte	0
 7985 0121 00       		.byte	0
 7986 0122 02       		.byte	2
 7987 0123 00       		.byte	0
 7988 0124 00       		.byte	0
 7989 0125 64       		.byte	100
 7990 0126 00       		.byte	0
 7991 0127 01       		.byte	1
 7992 0128 00       		.byte	0
 7993 0129 03       		.byte	3
 7994 012a 00       		.byte	0
 7995 012b 00       		.byte	0
 7996 012c 00       		.byte	0
 7997 012d 00       		.byte	0
 7998 012e 00       		.byte	0
 7999 012f 30       		.byte	48
 8000 0130 01       		.byte	1
 8001 0131 00       		.byte	0
 8002 0132 00       		.byte	0
 8003 0133 00000000 		.space	5
 8003      00
 8004 0138 00       		.byte	0
 8005 0139 00       		.byte	0
 8006 013a 02       		.byte	2
 8007 013b 00       		.byte	0
 8008 013c 00       		.byte	0
 8009 013d 64       		.byte	100
 8010 013e 00       		.byte	0
 8011 013f 01       		.byte	1
 8012 0140 00       		.byte	0
 8013 0141 03       		.byte	3
 8014 0142 00       		.byte	0
 8015 0143 00       		.byte	0
 8016 0144 00       		.byte	0
 8017 0145 00       		.byte	0
 8018 0146 00       		.byte	0
 8019 0147 30       		.byte	48
 8020 0148 01       		.byte	1
 8021 0149 00       		.byte	0
 8022 014a 00       		.byte	0
 8023 014b 00000000 		.space	5
 8023      00
 8024 0150 00       		.byte	0
 8025 0151 00       		.byte	0
 8026 0152 02       		.byte	2
 8027 0153 00       		.byte	0
 8028 0154 00       		.byte	0
 8029 0155 64       		.byte	100
 8030 0156 00       		.byte	0
 8031 0157 01       		.byte	1
 8032 0158 00       		.byte	0
 8033 0159 03       		.byte	3
 8034 015a 00       		.byte	0
 8035 015b 00       		.byte	0
 8036 015c 00       		.byte	0
 8037 015d 00       		.byte	0
 8038 015e 00       		.byte	0
 8039 015f 30       		.byte	48
 8040 0160 01       		.byte	1
 8041 0161 00       		.byte	0
 8042 0162 00       		.byte	0
 8043 0163 00000000 		.space	5
 8043      00
 8044 0168 00       		.byte	0
 8045 0169 00       		.byte	0
 8046 016a 02       		.byte	2
 8047 016b 00       		.byte	0
 8048 016c 00       		.byte	0
 8049 016d 64       		.byte	100
 8050 016e 00       		.byte	0
 8051 016f 01       		.byte	1
 8052 0170 00       		.byte	0
 8053 0171 03       		.byte	3
 8054 0172 00       		.byte	0
 8055 0173 00       		.byte	0
 8056 0174 00       		.byte	0
 8057 0175 00       		.byte	0
 8058 0176 00       		.byte	0
 8059 0177 30       		.byte	48
 8060 0178 01       		.byte	1
 8061 0179 00       		.byte	0
 8062 017a 00       		.byte	0
 8063 017b 00000000 		.space	5
 8063      00
 8066              	CtrlParArry:
 8067 0180 10       		.byte	16
 8068 0181 10       		.byte	16
 8069 0182 02       		.byte	2
 8070 0183 00       		.byte	0
 8071 0184 00       		.byte	0
 8072 0185 03       		.byte	3
 8073 0186 00       		.byte	0
 8074 0187 01       		.byte	1
 8075 0188 00       		.byte	0
 8076 0189 03       		.byte	3
 8077 018a 00       		.byte	0
 8078 018b 00       		.byte	0
 8079 018c 00       		.byte	0
 8080 018d 00       		.byte	0
 8081 018e 00       		.byte	0
 8082 018f 30       		.byte	48
 8083 0190 01       		.byte	1
 8084 0191 00       		.byte	0
 8085 0192 00       		.byte	0
 8086 0193 00000000 		.space	5
 8086      00
 8087 0198 01       		.byte	1
 8088 0199 00       		.byte	0
 8089 019a 02       		.byte	2
 8090 019b 00       		.byte	0
 8091 019c 00       		.byte	0
 8092 019d FF       		.byte	-1
 8093 019e 00       		.byte	0
 8094 019f 01       		.byte	1
 8095 01a0 00       		.byte	0
 8096 01a1 03       		.byte	3
 8097 01a2 00       		.byte	0
 8098 01a3 76       		.byte	118
 8099 01a4 00       		.byte	0
 8100 01a5 76       		.byte	118
 8101 01a6 C7       		.byte	-57
 8102 01a7 C6       		.byte	-58
 8103 01a8 01       		.byte	1
 8104 01a9 01       		.byte	1
 8105 01aa 00       		.byte	0
 8106 01ab 00000000 		.space	5
 8106      00
 8107 01b0 02       		.byte	2
 8108 01b1 02       		.byte	2
 8109 01b2 02       		.byte	2
 8110 01b3 00       		.byte	0
 8111 01b4 00       		.byte	0
 8112 01b5 FF       		.byte	-1
 8113 01b6 00       		.byte	0
 8114 01b7 01       		.byte	1
 8115 01b8 00       		.byte	0
 8116 01b9 03       		.byte	3
 8117 01ba 00       		.byte	0
 8118 01bb 70       		.byte	112
 8119 01bc 00       		.byte	0
 8120 01bd 70       		.byte	112
 8121 01be 00       		.byte	0
 8122 01bf C6       		.byte	-58
 8123 01c0 01       		.byte	1
 8124 01c1 01       		.byte	1
 8125 01c2 00       		.byte	0
 8126 01c3 00000000 		.space	5
 8126      00
 8127 01c8 00       		.byte	0
 8128 01c9 00       		.byte	0
 8129 01ca 02       		.byte	2
 8130 01cb 00       		.byte	0
 8131 01cc 00       		.byte	0
 8132 01cd 64       		.byte	100
 8133 01ce 00       		.byte	0
 8134 01cf 01       		.byte	1
 8135 01d0 00       		.byte	0
 8136 01d1 03       		.byte	3
 8137 01d2 00       		.byte	0
 8138 01d3 00       		.byte	0
 8139 01d4 00       		.byte	0
 8140 01d5 00       		.byte	0
 8141 01d6 00       		.byte	0
 8142 01d7 30       		.byte	48
 8143 01d8 01       		.byte	1
 8144 01d9 00       		.byte	0
 8145 01da 00       		.byte	0
 8146 01db 00000000 		.space	5
 8146      00
 8147 01e0 07       		.byte	7
 8148 01e1 07       		.byte	7
 8149 01e2 02       		.byte	2
 8150 01e3 00       		.byte	0
 8151 01e4 00       		.byte	0
 8152 01e5 01       		.byte	1
 8153 01e6 00       		.byte	0
 8154 01e7 01       		.byte	1
 8155 01e8 00       		.byte	0
 8156 01e9 03       		.byte	3
 8157 01ea 00       		.byte	0
 8158 01eb 01       		.byte	1
 8159 01ec 00       		.byte	0
 8160 01ed 01       		.byte	1
 8161 01ee 00       		.byte	0
 8162 01ef 30       		.byte	48
 8163 01f0 01       		.byte	1
 8164 01f1 00       		.byte	0
 8165 01f2 00       		.byte	0
 8166 01f3 00000000 		.space	5
 8166      00
 8167 01f8 DF       		.byte	-33
 8168 01f9 E1       		.byte	-31
 8169 01fa 02       		.byte	2
 8170 01fb 00       		.byte	0
 8171 01fc 00       		.byte	0
 8172 01fd FF       		.byte	-1
 8173 01fe 00       		.byte	0
 8174 01ff 01       		.byte	1
 8175 0200 00       		.byte	0
 8176 0201 03       		.byte	3
 8177 0202 00       		.byte	0
 8178 0203 80       		.byte	-128
 8179 0204 00       		.byte	0
 8180 0205 00       		.byte	0
 8181 0206 00       		.byte	0
 8182 0207 C6       		.byte	-58
 8183 0208 01       		.byte	1
 8184 0209 01       		.byte	1
 8185 020a 00       		.byte	0
 8186 020b 00000000 		.space	5
 8186      00
 8187 0210 85       		.byte	-123
 8188 0211 86       		.byte	-122
 8189 0212 02       		.byte	2
 8190 0213 00       		.byte	0
 8191 0214 00       		.byte	0
 8192 0215 64       		.byte	100
 8193 0216 00       		.byte	0
 8194 0217 01       		.byte	1
 8195 0218 00       		.byte	0
 8196 0219 03       		.byte	3
 8197 021a 00       		.byte	0
 8198 021b 32       		.byte	50
 8199 021c 00       		.byte	0
 8200 021d 32       		.byte	50
 8201 021e 00       		.byte	0
 8202 021f F2       		.byte	-14
 8203 0220 01       		.byte	1
 8204 0221 01       		.byte	1
 8205 0222 00       		.byte	0
 8206 0223 00000000 		.space	5
 8206      00
 8207 0228 06       		.byte	6
 8208 0229 06       		.byte	6
 8209 022a 02       		.byte	2
 8210 022b 00       		.byte	0
 8211 022c 00       		.byte	0
 8212 022d 40       		.byte	64
 8213 022e 00       		.byte	0
 8214 022f 01       		.byte	1
 8215 0230 00       		.byte	0
 8216 0231 03       		.byte	3
 8217 0232 00       		.byte	0
 8218 0233 20       		.byte	32
 8219 0234 00       		.byte	0
 8220 0235 20       		.byte	32
 8221 0236 00       		.byte	0
 8222 0237 30       		.byte	48
 8223 0238 01       		.byte	1
 8224 0239 01       		.byte	1
 8225 023a 00       		.byte	0
 8226 023b 00000000 		.space	5
 8226      00
 8227 0240 00       		.byte	0
 8228 0241 00       		.byte	0
 8229 0242 02       		.byte	2
 8230 0243 00       		.byte	0
 8231 0244 00       		.byte	0
 8232 0245 64       		.byte	100
 8233 0246 00       		.byte	0
 8234 0247 01       		.byte	1
 8235 0248 00       		.byte	0
 8236 0249 03       		.byte	3
 8237 024a 00       		.byte	0
 8238 024b 00       		.byte	0
 8239 024c 00       		.byte	0
 8240 024d 00       		.byte	0
 8241 024e 00       		.byte	0
 8242 024f 30       		.byte	48
 8243 0250 01       		.byte	1
 8244 0251 00       		.byte	0
 8245 0252 00       		.byte	0
 8246 0253 00000000 		.space	5
 8246      00
 8247 0258 08       		.byte	8
 8248 0259 08       		.byte	8
 8249 025a 02       		.byte	2
 8250 025b 00       		.byte	0
 8251 025c 00       		.byte	0
 8252 025d 05       		.byte	5
 8253 025e 00       		.byte	0
 8254 025f 01       		.byte	1
 8255 0260 00       		.byte	0
 8256 0261 03       		.byte	3
 8257 0262 00       		.byte	0
 8258 0263 00       		.byte	0
 8259 0264 00       		.byte	0
 8260 0265 00       		.byte	0
 8261 0266 00       		.byte	0
 8262 0267 30       		.byte	48
 8263 0268 01       		.byte	1
 8264 0269 00       		.byte	0
 8265 026a 00       		.byte	0
 8266 026b 00000000 		.space	5
 8266      00
 8267 0270 00       		.byte	0
 8268 0271 00       		.byte	0
 8269 0272 02       		.byte	2
 8270 0273 00       		.byte	0
 8271 0274 00       		.byte	0
 8272 0275 40       		.byte	64
 8273 0276 00       		.byte	0
 8274 0277 01       		.byte	1
 8275 0278 00       		.byte	0
 8276 0279 03       		.byte	3
 8277 027a 00       		.byte	0
 8278 027b 00       		.byte	0
 8279 027c 00       		.byte	0
 8280 027d 00       		.byte	0
 8281 027e 00       		.byte	0
 8282 027f 30       		.byte	48
 8283 0280 01       		.byte	1
 8284 0281 00       		.byte	0
 8285 0282 00       		.byte	0
 8286 0283 00000000 		.space	5
 8286      00
 8287 0288 09       		.byte	9
 8288 0289 0A       		.byte	10
 8289 028a 04       		.byte	4
 8290 028b 00       		.byte	0
 8291 028c 00       		.byte	0
 8292 028d 40       		.byte	64
 8293 028e 00       		.byte	0
 8294 028f 01       		.byte	1
 8295 0290 00       		.byte	0
 8296 0291 03       		.byte	3
 8297 0292 00       		.byte	0
 8298 0293 20       		.byte	32
 8299 0294 38       		.byte	56
 8300 0295 20       		.byte	32
 8301 0296 38       		.byte	56
 8302 0297 30       		.byte	48
 8303 0298 01       		.byte	1
 8304 0299 00       		.byte	0
 8305 029a 00       		.byte	0
 8306 029b 00000000 		.space	5
 8306      00
 8307 02a0 00       		.byte	0
 8308 02a1 00       		.byte	0
 8309 02a2 02       		.byte	2
 8310 02a3 00       		.byte	0
 8311 02a4 00       		.byte	0
 8312 02a5 64       		.byte	100
 8313 02a6 00       		.byte	0
 8314 02a7 01       		.byte	1
 8315 02a8 00       		.byte	0
 8316 02a9 03       		.byte	3
 8317 02aa 00       		.byte	0
 8318 02ab 00       		.byte	0
 8319 02ac 00       		.byte	0
 8320 02ad 00       		.byte	0
 8321 02ae 00       		.byte	0
 8322 02af 30       		.byte	48
 8323 02b0 01       		.byte	1
 8324 02b1 00       		.byte	0
 8325 02b2 00       		.byte	0
 8326 02b3 00000000 		.space	5
 8326      00
 8327 02b8 00       		.byte	0
 8328 02b9 00       		.byte	0
 8329 02ba 02       		.byte	2
 8330 02bb 00       		.byte	0
 8331 02bc 00       		.byte	0
 8332 02bd 64       		.byte	100
 8333 02be 00       		.byte	0
 8334 02bf 01       		.byte	1
 8335 02c0 00       		.byte	0
 8336 02c1 03       		.byte	3
 8337 02c2 00       		.byte	0
 8338 02c3 00       		.byte	0
 8339 02c4 00       		.byte	0
 8340 02c5 00       		.byte	0
 8341 02c6 00       		.byte	0
 8342 02c7 30       		.byte	48
 8343 02c8 01       		.byte	1
 8344 02c9 00       		.byte	0
 8345 02ca 00       		.byte	0
 8346 02cb 00000000 		.space	5
 8346      00
 8347 02d0 2A       		.byte	42
 8348 02d1 2A       		.byte	42
 8349 02d2 02       		.byte	2
 8350 02d3 00       		.byte	0
 8351 02d4 00       		.byte	0
 8352 02d5 1B       		.byte	27
 8353 02d6 00       		.byte	0
 8354 02d7 01       		.byte	1
 8355 02d8 00       		.byte	0
 8356 02d9 03       		.byte	3
 8357 02da 00       		.byte	0
 8358 02db 00       		.byte	0
 8359 02dc 00       		.byte	0
 8360 02dd 00       		.byte	0
 8361 02de 00       		.byte	0
 8362 02df 30       		.byte	48
 8363 02e0 01       		.byte	1
 8364 02e1 00       		.byte	0
 8365 02e2 00       		.byte	0
 8366 02e3 00000000 		.space	5
 8366      00
 8367 02e8 00       		.byte	0
 8368 02e9 00       		.byte	0
 8369 02ea 02       		.byte	2
 8370 02eb 00       		.byte	0
 8371 02ec 00       		.byte	0
 8372 02ed 64       		.byte	100
 8373 02ee 00       		.byte	0
 8374 02ef 01       		.byte	1
 8375 02f0 00       		.byte	0
 8376 02f1 03       		.byte	3
 8377 02f2 00       		.byte	0
 8378 02f3 00       		.byte	0
 8379 02f4 00       		.byte	0
 8380 02f5 00       		.byte	0
 8381 02f6 00       		.byte	0
 8382 02f7 30       		.byte	48
 8383 02f8 01       		.byte	1
 8384 02f9 00       		.byte	0
 8385 02fa 00       		.byte	0
 8386 02fb 00000000 		.space	5
 8386      00
 8387 0300 00       		.byte	0
 8388 0301 00       		.byte	0
 8389 0302 02       		.byte	2
 8390 0303 00       		.byte	0
 8391 0304 00       		.byte	0
 8392 0305 12       		.byte	18
 8393 0306 00       		.byte	0
 8394 0307 01       		.byte	1
 8395 0308 00       		.byte	0
 8396 0309 03       		.byte	3
 8397 030a 00       		.byte	0
 8398 030b 00       		.byte	0
 8399 030c 00       		.byte	0
 8400 030d 00       		.byte	0
 8401 030e 00       		.byte	0
 8402 030f 30       		.byte	48
 8403 0310 01       		.byte	1
 8404 0311 00       		.byte	0
 8405 0312 00       		.byte	0
 8406 0313 00000000 		.space	5
 8406      00
 8407 0318 01       		.byte	1
 8408 0319 01       		.byte	1
 8409 031a 02       		.byte	2
 8410 031b 00       		.byte	0
 8411 031c 00       		.byte	0
 8412 031d 09       		.byte	9
 8413 031e 00       		.byte	0
 8414 031f 01       		.byte	1
 8415 0320 00       		.byte	0
 8416 0321 03       		.byte	3
 8417 0322 00       		.byte	0
 8418 0323 00       		.byte	0
 8419 0324 00       		.byte	0
 8420 0325 01       		.byte	1
 8421 0326 00       		.byte	0
 8422 0327 30       		.byte	48
 8423 0328 01       		.byte	1
 8424 0329 00       		.byte	0
 8425 032a 00       		.byte	0
 8426 032b 00000000 		.space	5
 8426      00
 8427 0330 05       		.byte	5
 8428 0331 05       		.byte	5
 8429 0332 02       		.byte	2
 8430 0333 00       		.byte	0
 8431 0334 00       		.byte	0
 8432 0335 03       		.byte	3
 8433 0336 00       		.byte	0
 8434 0337 01       		.byte	1
 8435 0338 00       		.byte	0
 8436 0339 03       		.byte	3
 8437 033a 00       		.byte	0
 8438 033b 00       		.byte	0
 8439 033c 00       		.byte	0
 8440 033d 00       		.byte	0
 8441 033e 00       		.byte	0
 8442 033f 30       		.byte	48
 8443 0340 01       		.byte	1
 8444 0341 00       		.byte	0
 8445 0342 00       		.byte	0
 8446 0343 00000000 		.space	5
 8446      00
 8447 0348 18       		.byte	24
 8448 0349 18       		.byte	24
 8449 034a 02       		.byte	2
 8450 034b 00       		.byte	0
 8451 034c 00       		.byte	0
 8452 034d 01       		.byte	1
 8453 034e 00       		.byte	0
 8454 034f 01       		.byte	1
 8455 0350 00       		.byte	0
 8456 0351 03       		.byte	3
 8457 0352 00       		.byte	0
 8458 0353 00       		.byte	0
 8459 0354 00       		.byte	0
 8460 0355 00       		.byte	0
 8461 0356 00       		.byte	0
 8462 0357 30       		.byte	48
 8463 0358 01       		.byte	1
 8464 0359 00       		.byte	0
 8465 035a 00       		.byte	0
 8466 035b 00000000 		.space	5
 8466      00
 8467 0360 19       		.byte	25
 8468 0361 19       		.byte	25
 8469 0362 01       		.byte	1
 8470 0363 00       		.byte	0
 8471 0364 00       		.byte	0
 8472 0365 40       		.byte	64
 8473 0366 00       		.byte	0
 8474 0367 01       		.byte	1
 8475 0368 00       		.byte	0
 8476 0369 03       		.byte	3
 8477 036a 00       		.byte	0
 8478 036b 20       		.byte	32
 8479 036c 00       		.byte	0
 8480 036d 20       		.byte	32
 8481 036e 00       		.byte	0
 8482 036f 30       		.byte	48
 8483 0370 01       		.byte	1
 8484 0371 00       		.byte	0
 8485 0372 00       		.byte	0
 8486 0373 00000000 		.space	5
 8486      00
 8487 0378 20       		.byte	32
 8488 0379 20       		.byte	32
 8489 037a 02       		.byte	2
 8490 037b 00       		.byte	0
 8491 037c 00       		.byte	0
 8492 037d 02       		.byte	2
 8493 037e 00       		.byte	0
 8494 037f 01       		.byte	1
 8495 0380 00       		.byte	0
 8496 0381 03       		.byte	3
 8497 0382 00       		.byte	0
 8498 0383 00       		.byte	0
 8499 0384 00       		.byte	0
 8500 0385 00       		.byte	0
 8501 0386 00       		.byte	0
 8502 0387 30       		.byte	48
 8503 0388 01       		.byte	1
 8504 0389 00       		.byte	0
 8505 038a 00       		.byte	0
 8506 038b 00000000 		.space	5
 8506      00
 8507 0390 22       		.byte	34
 8508 0391 22       		.byte	34
 8509 0392 02       		.byte	2
 8510 0393 00       		.byte	0
 8511 0394 00       		.byte	0
 8512 0395 3F       		.byte	63
 8513 0396 00       		.byte	0
 8514 0397 01       		.byte	1
 8515 0398 00       		.byte	0
 8516 0399 03       		.byte	3
 8517 039a 00       		.byte	0
 8518 039b 00       		.byte	0
 8519 039c 00       		.byte	0
 8520 039d 00       		.byte	0
 8521 039e 00       		.byte	0
 8522 039f 30       		.byte	48
 8523 03a0 01       		.byte	1
 8524 03a1 00       		.byte	0
 8525 03a2 00       		.byte	0
 8526 03a3 00000000 		.space	5
 8526      00
 8527 03a8 23       		.byte	35
 8528 03a9 23       		.byte	35
 8529 03aa 02       		.byte	2
 8530 03ab 00       		.byte	0
 8531 03ac 00       		.byte	0
 8532 03ad 64       		.byte	100
 8533 03ae 00       		.byte	0
 8534 03af 01       		.byte	1
 8535 03b0 00       		.byte	0
 8536 03b1 03       		.byte	3
 8537 03b2 00       		.byte	0
 8538 03b3 10       		.byte	16
 8539 03b4 00       		.byte	0
 8540 03b5 10       		.byte	16
 8541 03b6 00       		.byte	0
 8542 03b7 30       		.byte	48
 8543 03b8 01       		.byte	1
 8544 03b9 00       		.byte	0
 8545 03ba 00       		.byte	0
 8546 03bb 00000000 		.space	5
 8546      00
 8547 03c0 24       		.byte	36
 8548 03c1 24       		.byte	36
 8549 03c2 02       		.byte	2
 8550 03c3 00       		.byte	0
 8551 03c4 00       		.byte	0
 8552 03c5 64       		.byte	100
 8553 03c6 00       		.byte	0
 8554 03c7 01       		.byte	1
 8555 03c8 00       		.byte	0
 8556 03c9 03       		.byte	3
 8557 03ca 00       		.byte	0
 8558 03cb 10       		.byte	16
 8559 03cc 00       		.byte	0
 8560 03cd 10       		.byte	16
 8561 03ce 00       		.byte	0
 8562 03cf 30       		.byte	48
 8563 03d0 01       		.byte	1
 8564 03d1 00       		.byte	0
 8565 03d2 00       		.byte	0
 8566 03d3 00000000 		.space	5
 8566      00
 8567 03d8 02       		.byte	2
 8568 03d9 03       		.byte	3
 8569 03da 04       		.byte	4
 8570 03db 00       		.byte	0
 8571 03dc 00       		.byte	0
 8572 03dd 7F       		.byte	127
 8573 03de 00       		.byte	0
 8574 03df 01       		.byte	1
 8575 03e0 00       		.byte	0
 8576 03e1 03       		.byte	3
 8577 03e2 00       		.byte	0
 8578 03e3 00       		.byte	0
 8579 03e4 20       		.byte	32
 8580 03e5 00       		.byte	0
 8581 03e6 20       		.byte	32
 8582 03e7 30       		.byte	48
 8583 03e8 01       		.byte	1
 8584 03e9 00       		.byte	0
 8585 03ea 00       		.byte	0
 8586 03eb 00000000 		.space	5
 8586      00
 8587 03f0 04       		.byte	4
 8588 03f1 0C       		.byte	12
 8589 03f2 02       		.byte	2
 8590 03f3 00       		.byte	0
 8591 03f4 00       		.byte	0
 8592 03f5 40       		.byte	64
 8593 03f6 00       		.byte	0
 8594 03f7 01       		.byte	1
 8595 03f8 00       		.byte	0
 8596 03f9 03       		.byte	3
 8597 03fa 00       		.byte	0
 8598 03fb 20       		.byte	32
 8599 03fc 00       		.byte	0
 8600 03fd 20       		.byte	32
 8601 03fe 00       		.byte	0
 8602 03ff 30       		.byte	48
 8603 0400 01       		.byte	1
 8604 0401 00       		.byte	0
 8605 0402 00       		.byte	0
 8606 0403 00000000 		.space	5
 8606      00
 8607 0408 00       		.byte	0
 8608 0409 00       		.byte	0
 8609 040a 02       		.byte	2
 8610 040b 00       		.byte	0
 8611 040c 00       		.byte	0
 8612 040d 19       		.byte	25
 8613 040e 00       		.byte	0
 8614 040f 01       		.byte	1
 8615 0410 00       		.byte	0
 8616 0411 03       		.byte	3
 8617 0412 00       		.byte	0
 8618 0413 00       		.byte	0
 8619 0414 00       		.byte	0
 8620 0415 00       		.byte	0
 8621 0416 00       		.byte	0
 8622 0417 30       		.byte	48
 8623 0418 01       		.byte	1
 8624 0419 00       		.byte	0
 8625 041a 00       		.byte	0
 8626 041b 00000000 		.space	5
 8626      00
 8627 0420 10       		.byte	16
 8628 0421 10       		.byte	16
 8629 0422 02       		.byte	2
 8630 0423 00       		.byte	0
 8631 0424 00       		.byte	0
 8632 0425 06       		.byte	6
 8633 0426 00       		.byte	0
 8634 0427 01       		.byte	1
 8635 0428 00       		.byte	0
 8636 0429 03       		.byte	3
 8637 042a 00       		.byte	0
 8638 042b 00       		.byte	0
 8639 042c 00       		.byte	0
 8640 042d 00       		.byte	0
 8641 042e 00       		.byte	0
 8642 042f 30       		.byte	48
 8643 0430 01       		.byte	1
 8644 0431 00       		.byte	0
 8645 0432 00       		.byte	0
 8646 0433 00000000 		.space	5
 8646      00
 8647 0438 00       		.byte	0
 8648 0439 00       		.byte	0
 8649 043a 02       		.byte	2
 8650 043b 00       		.byte	0
 8651 043c 00       		.byte	0
 8652 043d 03       		.byte	3
 8653 043e 00       		.byte	0
 8654 043f 01       		.byte	1
 8655 0440 00       		.byte	0
 8656 0441 03       		.byte	3
 8657 0442 00       		.byte	0
 8658 0443 00       		.byte	0
 8659 0444 00       		.byte	0
 8660 0445 00       		.byte	0
 8661 0446 00       		.byte	0
 8662 0447 30       		.byte	48
 8663 0448 01       		.byte	1
 8664 0449 00       		.byte	0
 8665 044a 00       		.byte	0
 8666 044b 00000000 		.space	5
 8666      00
 8667 0450 50       		.byte	80
 8668 0451 50       		.byte	80
 8669 0452 01       		.byte	1
 8670 0453 00       		.byte	0
 8671 0454 00       		.byte	0
 8672 0455 03       		.byte	3
 8673 0456 00       		.byte	0
 8674 0457 01       		.byte	1
 8675 0458 00       		.byte	0
 8676 0459 03       		.byte	3
 8677 045a 00       		.byte	0
 8678 045b 00       		.byte	0
 8679 045c 00       		.byte	0
 8680 045d 00       		.byte	0
 8681 045e 00       		.byte	0
 8682 045f 30       		.byte	48
 8683 0460 01       		.byte	1
 8684 0461 00       		.byte	0
 8685 0462 00       		.byte	0
 8686 0463 00000000 		.space	5
 8686      00
 8687 0468 00       		.byte	0
 8688 0469 00       		.byte	0
 8689 046a 0B       		.byte	11
 8690 046b 00       		.byte	0
 8691 046c 00       		.byte	0
 8692 046d FF       		.byte	-1
 8693 046e FF       		.byte	-1
 8694 046f 01       		.byte	1
 8695 0470 00       		.byte	0
 8696 0471 03       		.byte	3
 8697 0472 00       		.byte	0
 8698 0473 00       		.byte	0
 8699 0474 00       		.byte	0
 8700 0475 00       		.byte	0
 8701 0476 00       		.byte	0
 8702 0477 00       		.byte	0
 8703 0478 01       		.byte	1
 8704 0479 00       		.byte	0
 8705 047a 00       		.byte	0
 8706 047b 00000000 		.space	5
 8706      00
 8709              	glUVCHeader:
 8710 0480 0C       		.byte	12
 8711 0481 8C       		.byte	-116
 8712 0482 00       		.byte	0
 8713 0483 00       		.byte	0
 8714 0484 00       		.byte	0
 8715 0485 00       		.byte	0
 8716 0486 00       		.byte	0
 8717 0487 00       		.byte	0
 8718 0488 00       		.byte	0
 8719 0489 00       		.byte	0
 8720 048a 00       		.byte	0
 8721 048b 00       		.byte	0
 8724              	WBMenuCmpArry:
 8725 048c 20       		.byte	32
 8726 048d 0F       		.byte	15
 8727 048e 38       		.byte	56
 8728 048f F0       		.byte	-16
 8731              	CTCtrlParArry:
 8732 0490 00       		.byte	0
 8733 0491 00       		.byte	0
 8734 0492 01       		.byte	1
 8735 0493 00       		.byte	0
 8736 0494 00       		.byte	0
 8737 0495 03       		.byte	3
 8738 0496 00       		.byte	0
 8739 0497 01       		.byte	1
 8740 0498 00       		.byte	0
 8741 0499 03       		.byte	3
 8742 049a 00       		.byte	0
 8743 049b 03       		.byte	3
 8744 049c 00       		.byte	0
 8745 049d 03       		.byte	3
 8746 049e 00       		.byte	0
 8747 049f 30       		.byte	48
 8748 04a0 01       		.byte	1
 8749 04a1 00       		.byte	0
 8750 04a2 00       		.byte	0
 8751 04a3 00000000 		.space	5
 8751      00
 8752 04a8 00       		.byte	0
 8753 04a9 00       		.byte	0
 8754 04aa 01       		.byte	1
 8755 04ab 01       		.byte	1
 8756 04ac 00       		.byte	0
 8757 04ad 0F       		.byte	15
 8758 04ae 00       		.byte	0
 8759 04af 0F       		.byte	15
 8760 04b0 00       		.byte	0
 8761 04b1 03       		.byte	3
 8762 04b2 00       		.byte	0
 8763 04b3 02       		.byte	2
 8764 04b4 00       		.byte	0
 8765 04b5 02       		.byte	2
 8766 04b6 00       		.byte	0
 8767 04b7 30       		.byte	48
 8768 04b8 01       		.byte	1
 8769 04b9 01       		.byte	1
 8770 04ba 00       		.byte	0
 8771 04bb 00000000 		.space	5
 8771      00
 8772 04c0 02       		.byte	2
 8773 04c1 00       		.byte	0
 8774 04c2 01       		.byte	1
 8775 04c3 00       		.byte	0
 8776 04c4 00       		.byte	0
 8777 04c5 01       		.byte	1
 8778 04c6 00       		.byte	0
 8779 04c7 01       		.byte	1
 8780 04c8 00       		.byte	0
 8781 04c9 03       		.byte	3
 8782 04ca 00       		.byte	0
 8783 04cb 00       		.byte	0
 8784 04cc 00       		.byte	0
 8785 04cd 00       		.byte	0
 8786 04ce 00       		.byte	0
 8787 04cf 30       		.byte	48
 8788 04d0 01       		.byte	1
 8789 04d1 01       		.byte	1
 8790 04d2 00       		.byte	0
 8791 04d3 00000000 		.space	5
 8791      00
 8792 04d8 00       		.byte	0
 8793 04d9 00       		.byte	0
 8794 04da 04       		.byte	4
 8795 04db 01       		.byte	1
 8796 04dc 00       		.byte	0
 8797 04dd 38       		.byte	56
 8798 04de 01       		.byte	1
 8799 04df 01       		.byte	1
 8800 04e0 00       		.byte	0
 8801 04e1 03       		.byte	3
 8802 04e2 00       		.byte	0
 8803 04e3 4E       		.byte	78
 8804 04e4 00       		.byte	0
 8805 04e5 4E       		.byte	78
 8806 04e6 00       		.byte	0
 8807 04e7 30       		.byte	48
 8808 04e8 01       		.byte	1
 8809 04e9 00       		.byte	0
 8810 04ea 00       		.byte	0
 8811 04eb 00000000 		.space	5
 8811      00
 8812 04f0 04       		.byte	4
 8813 04f1 00       		.byte	0
 8814 04f2 01       		.byte	1
 8815 04f3 00       		.byte	0
 8816 04f4 00       		.byte	0
 8817 04f5 00       		.byte	0
 8818 04f6 00       		.byte	0
 8819 04f7 01       		.byte	1
 8820 04f8 00       		.byte	0
 8821 04f9 03       		.byte	3
 8822 04fa 00       		.byte	0
 8823 04fb 00       		.byte	0
 8824 04fc 00       		.byte	0
 8825 04fd 00       		.byte	0
 8826 04fe 00       		.byte	0
 8827 04ff 30       		.byte	48
 8828 0500 01       		.byte	1
 8829 0501 00       		.byte	0
 8830 0502 00       		.byte	0
 8831 0503 00000000 		.space	5
 8831      00
 8832 0508 05       		.byte	5
 8833 0509 00       		.byte	0
 8834 050a 02       		.byte	2
 8835 050b 00       		.byte	0
 8836 050c 00       		.byte	0
 8837 050d FF       		.byte	-1
 8838 050e 00       		.byte	0
 8839 050f 01       		.byte	1
 8840 0510 00       		.byte	0
 8841 0511 03       		.byte	3
 8842 0512 00       		.byte	0
 8843 0513 01       		.byte	1
 8844 0514 00       		.byte	0
 8845 0515 00       		.byte	0
 8846 0516 00       		.byte	0
 8847 0517 30       		.byte	48
 8848 0518 01       		.byte	1
 8849 0519 01       		.byte	1
 8850 051a 00       		.byte	0
 8851 051b 00000000 		.space	5
 8851      00
 8852 0520 06       		.byte	6
 8853 0521 00       		.byte	0
 8854 0522 02       		.byte	2
 8855 0523 00       		.byte	0
 8856 0524 00       		.byte	0
 8857 0525 00       		.byte	0
 8858 0526 00       		.byte	0
 8859 0527 00       		.byte	0
 8860 0528 00       		.byte	0
 8861 0529 03       		.byte	3
 8862 052a 00       		.byte	0
 8863 052b 00       		.byte	0
 8864 052c 00       		.byte	0
 8865 052d 00       		.byte	0
 8866 052e 00       		.byte	0
 8867 052f 30       		.byte	48
 8868 0530 01       		.byte	1
 8869 0531 01       		.byte	1
 8870 0532 00       		.byte	0
 8871 0533 00000000 		.space	5
 8871      00
 8872 0538 23       		.byte	35
 8873 0539 00       		.byte	0
 8874 053a 02       		.byte	2
 8875 053b 00       		.byte	0
 8876 053c 00       		.byte	0
 8877 053d 30       		.byte	48
 8878 053e 00       		.byte	0
 8879 053f 01       		.byte	1
 8880 0540 00       		.byte	0
 8881 0541 03       		.byte	3
 8882 0542 0A       		.byte	10
 8883 0543 00       		.byte	0
 8884 0544 00       		.byte	0
 8885 0545 0A       		.byte	10
 8886 0546 00       		.byte	0
 8887 0547 30       		.byte	48
 8888 0548 01       		.byte	1
 8889 0549 01       		.byte	1
 8890 054a 00       		.byte	0
 8891 054b 00000000 		.space	5
 8891      00
 8892 0550 08       		.byte	8
 8893 0551 00       		.byte	0
 8894 0552 01       		.byte	1
 8895 0553 00       		.byte	0
 8896 0554 00       		.byte	0
 8897 0555 7F       		.byte	127
 8898 0556 00       		.byte	0
 8899 0557 01       		.byte	1
 8900 0558 00       		.byte	0
 8901 0559 03       		.byte	3
 8902 055a 00       		.byte	0
 8903 055b 00       		.byte	0
 8904 055c 00       		.byte	0
 8905 055d 00       		.byte	0
 8906 055e 00       		.byte	0
 8907 055f 30       		.byte	48
 8908 0560 01       		.byte	1
 8909 0561 00       		.byte	0
 8910 0562 00       		.byte	0
 8911 0563 00000000 		.space	5
 8911      00
 8912 0568 09       		.byte	9
 8913 0569 00       		.byte	0
 8914 056a 02       		.byte	2
 8915 056b 00       		.byte	0
 8916 056c 00       		.byte	0
 8917 056d 05       		.byte	5
 8918 056e 00       		.byte	0
 8919 056f 01       		.byte	1
 8920 0570 00       		.byte	0
 8921 0571 03       		.byte	3
 8922 0572 00       		.byte	0
 8923 0573 00       		.byte	0
 8924 0574 00       		.byte	0
 8925 0575 00       		.byte	0
 8926 0576 00       		.byte	0
 8927 0577 30       		.byte	48
 8928 0578 01       		.byte	1
 8929 0579 00       		.byte	0
 8930 057a 00       		.byte	0
 8931 057b 00000000 		.space	5
 8931      00
 8932 0580 10       		.byte	16
 8933 0581 00       		.byte	0
 8934 0582 03       		.byte	3
 8935 0583 00       		.byte	0
 8936 0584 00       		.byte	0
 8937 0585 00       		.byte	0
 8938 0586 00       		.byte	0
 8939 0587 00       		.byte	0
 8940 0588 00       		.byte	0
 8941 0589 03       		.byte	3
 8942 058a 00       		.byte	0
 8943 058b 00       		.byte	0
 8944 058c 00       		.byte	0
 8945 058d 00       		.byte	0
 8946 058e 00       		.byte	0
 8947 058f 30       		.byte	48
 8948 0590 01       		.byte	1
 8949 0591 00       		.byte	0
 8950 0592 00       		.byte	0
 8951 0593 00000000 		.space	5
 8951      00
 8952 0598 00       		.byte	0
 8953 0599 00       		.byte	0
 8954 059a 02       		.byte	2
 8955 059b 00       		.byte	0
 8956 059c 00       		.byte	0
 8957 059d 40       		.byte	64
 8958 059e 00       		.byte	0
 8959 059f 01       		.byte	1
 8960 05a0 00       		.byte	0
 8961 05a1 03       		.byte	3
 8962 05a2 00       		.byte	0
 8963 05a3 0F       		.byte	15
 8964 05a4 11       		.byte	17
 8965 05a5 00       		.byte	0
 8966 05a6 00       		.byte	0
 8967 05a7 30       		.byte	48
 8968 05a8 01       		.byte	1
 8969 05a9 00       		.byte	0
 8970 05aa 00       		.byte	0
 8971 05ab 00000000 		.space	5
 8971      00
 8972 05b0 00       		.byte	0
 8973 05b1 00       		.byte	0
 8974 05b2 02       		.byte	2
 8975 05b3 00       		.byte	0
 8976 05b4 00       		.byte	0
 8977 05b5 64       		.byte	100
 8978 05b6 00       		.byte	0
 8979 05b7 01       		.byte	1
 8980 05b8 00       		.byte	0
 8981 05b9 03       		.byte	3
 8982 05ba 00       		.byte	0
 8983 05bb 00       		.byte	0
 8984 05bc 00       		.byte	0
 8985 05bd 00       		.byte	0
 8986 05be 00       		.byte	0
 8987 05bf 30       		.byte	48
 8988 05c0 01       		.byte	1
 8989 05c1 00       		.byte	0
 8990 05c2 00       		.byte	0
 8991 05c3 00000000 		.space	5
 8991      00
 8992 05c8 00       		.byte	0
 8993 05c9 00       		.byte	0
 8994 05ca 02       		.byte	2
 8995 05cb 00       		.byte	0
 8996 05cc 00       		.byte	0
 8997 05cd 64       		.byte	100
 8998 05ce 00       		.byte	0
 8999 05cf 01       		.byte	1
 9000 05d0 00       		.byte	0
 9001 05d1 03       		.byte	3
 9002 05d2 00       		.byte	0
 9003 05d3 00       		.byte	0
 9004 05d4 00       		.byte	0
 9005 05d5 00       		.byte	0
 9006 05d6 00       		.byte	0
 9007 05d7 30       		.byte	48
 9008 05d8 01       		.byte	1
 9009 05d9 00       		.byte	0
 9010 05da 00       		.byte	0
 9011 05db 00000000 		.space	5
 9011      00
 9012 05e0 00       		.byte	0
 9013 05e1 00       		.byte	0
 9014 05e2 02       		.byte	2
 9015 05e3 00       		.byte	0
 9016 05e4 00       		.byte	0
 9017 05e5 64       		.byte	100
 9018 05e6 00       		.byte	0
 9019 05e7 01       		.byte	1
 9020 05e8 00       		.byte	0
 9021 05e9 03       		.byte	3
 9022 05ea 00       		.byte	0
 9023 05eb 00       		.byte	0
 9024 05ec 00       		.byte	0
 9025 05ed 00       		.byte	0
 9026 05ee 00       		.byte	0
 9027 05ef 30       		.byte	48
 9028 05f0 01       		.byte	1
 9029 05f1 00       		.byte	0
 9030 05f2 00       		.byte	0
 9031 05f3 00000000 		.space	5
 9031      00
 9032 05f8 00       		.byte	0
 9033 05f9 00       		.byte	0
 9034 05fa 02       		.byte	2
 9035 05fb 00       		.byte	0
 9036 05fc 00       		.byte	0
 9037 05fd 64       		.byte	100
 9038 05fe 00       		.byte	0
 9039 05ff 01       		.byte	1
 9040 0600 00       		.byte	0
 9041 0601 03       		.byte	3
 9042 0602 00       		.byte	0
 9043 0603 00       		.byte	0
 9044 0604 00       		.byte	0
 9045 0605 00       		.byte	0
 9046 0606 00       		.byte	0
 9047 0607 30       		.byte	48
 9048 0608 01       		.byte	1
 9049 0609 00       		.byte	0
 9050 060a 00       		.byte	0
 9051 060b 00000000 		.space	5
 9051      00
 9054              	glProbeCtrl:
 9055 0610 00       		.byte	0
 9056 0611 00       		.byte	0
 9057 0612 01       		.byte	1
 9058 0613 01       		.byte	1
 9059 0614 15       		.byte	21
 9060 0615 16       		.byte	22
 9061 0616 05       		.byte	5
 9062 0617 00       		.byte	0
 9063 0618 00       		.byte	0
 9064 0619 00       		.byte	0
 9065 061a 00       		.byte	0
 9066 061b 00       		.byte	0
 9067 061c 00       		.byte	0
 9068 061d 00       		.byte	0
 9069 061e 00       		.byte	0
 9070 061f 00       		.byte	0
 9071 0620 00       		.byte	0
 9072 0621 00       		.byte	0
 9073 0622 00       		.byte	0
 9074 0623 48       		.byte	72
 9075 0624 3F       		.byte	63
 9076 0625 00       		.byte	0
 9077 0626 00       		.byte	0
 9078 0627 40       		.byte	64
 9079 0628 00       		.byte	0
 9080 0629 00       		.byte	0
 9081 062a 0000     		.space	2
 9084              	glProbeStilCtrl:
 9085 062c 01       		.byte	1
 9086 062d 01       		.byte	1
 9087 062e 00       		.byte	0
 9088 062f 00       		.byte	0
 9089 0630 48       		.byte	72
 9090 0631 3F       		.byte	63
 9091 0632 00       		.byte	0
 9092 0633 00       		.byte	0
 9093 0634 40       		.byte	64
 9094 0635 00       		.byte	0
 9095 0636 00       		.byte	0
 9096 0637 00       		.space	1
 9099              	glProbeStilCtrl20:
 9100 0638 01       		.byte	1
 9101 0639 01       		.byte	1
 9102 063a 00       		.byte	0
 9103 063b 00       		.byte	0
 9104 063c D2       		.byte	-46
 9105 063d 0F       		.byte	15
 9106 063e 00       		.byte	0
 9107 063f 00       		.byte	0
 9108 0640 40       		.byte	64
 9109 0641 00       		.byte	0
 9110 0642 00       		.byte	0
 9113              	snapButFlag:
 9114 0643 01       		.byte	1
 9117              	CyFxGpifTransition:
 9118 0644 0000     		.short	0
 9119 0646 5555     		.short	21845
 9120 0648 8888     		.short	-30584
 9121 064a AAAA     		.short	-21846
 9122 064c 3333     		.short	13107
 9123 064e 0000     		.space	2
 9126              	CyFxGpifWavedata:
 9127 0650 0181731E 		.word	510886145
 9128 0654 00000000 		.word	0
 9129 0658 00000080 		.word	-2147483648
 9130 065c 00000000 		.word	0
 9131 0660 00000000 		.word	0
 9132 0664 00000000 		.word	0
 9133 0668 0201702E 		.word	779092226
 9134 066c 00010000 		.word	256
 9135 0670 A0000080 		.word	-2147483488
 9136 0674 00000000 		.word	0
 9137 0678 00000000 		.word	0
 9138 067c 00000000 		.word	0
 9139 0680 0380722E 		.word	779255811
 9140 0684 02010020 		.word	536871170
 9141 0688 60000080 		.word	-2147483552
 9142 068c 00000000 		.word	0
 9143 0690 00000000 		.word	0
 9144 0694 00000000 		.word	0
 9145 0698 0460722E 		.word	779247620
 9146 069c 02010024 		.word	603980034
 9147 06a0 90000080 		.word	-2147483504
 9148 06a4 0594731E 		.word	510891013
 9149 06a8 06000000 		.word	6
 9150 06ac 00000080 		.word	-2147483648
 9151 06b0 0380722E 		.word	779255811
 9152 06b4 02010020 		.word	536871170
 9153 06b8 60000080 		.word	-2147483552
 9154 06bc 0693731E 		.word	510890758
 9155 06c0 06000000 		.word	6
 9156 06c4 00000080 		.word	-2147483648
 9157 06c8 0720703E 		.word	1047535623
 9158 06cc 08010000 		.word	264
 9159 06d0 00000080 		.word	-2147483648
 9160 06d4 0820703E 		.word	1047535624
 9161 06d8 08010000 		.word	264
 9162 06dc 00000080 		.word	-2147483648
 9163 06e0 0920703E 		.word	1047535625
 9164 06e4 08010000 		.word	264
 9165 06e8 00000080 		.word	-2147483648
 9166 06ec 0A20703E 		.word	1047535626
 9167 06f0 08010000 		.word	264
 9168 06f4 00000080 		.word	-2147483648
 9169 06f8 0380722E 		.word	779255811
 9170 06fc 02010020 		.word	536871170
 9171 0700 60000080 		.word	-2147483552
 9172 0704 0B000000 		.word	11
 9173 0708 00000000 		.word	0
 9174 070c 00010080 		.word	-2147483392
 9175 0710 0460722E 		.word	779247620
 9176 0714 02010024 		.word	603980034
 9177 0718 90000080 		.word	-2147483504
 9178 071c 0D000000 		.word	13
 9179 0720 00000000 		.word	0
 9180 0724 00010080 		.word	-2147483392
 9181 0728 0460722E 		.word	779247620
 9182 072c 02010024 		.word	603980034
 9183 0730 90000080 		.word	-2147483504
 9184 0734 0C000000 		.word	12
 9185 0738 00000000 		.word	0
 9186 073c 00010080 		.word	-2147483392
 9187 0740 0380722E 		.word	779255811
 9188 0744 02010020 		.word	536871170
 9189 0748 60000080 		.word	-2147483552
 9190 074c 0E000000 		.word	14
 9191 0750 00000000 		.word	0
 9192 0754 00010080 		.word	-2147483392
 9193 0758 00000000 		.word	0
 9194 075c 00000000 		.word	0
 9195 0760 00000000 		.word	0
 9196 0764 00000000 		.word	0
 9197 0768 00000000 		.word	0
 9198 076c 00000000 		.word	0
 9201              	CyFxGpifWavedataPosition:
 9202 0770 00       		.byte	0
 9203 0771 01       		.byte	1
 9204 0772 02       		.byte	2
 9205 0773 03       		.byte	3
 9206 0774 04       		.byte	4
 9207 0775 05       		.byte	5
 9208 0776 06       		.byte	6
 9209 0777 07       		.byte	7
 9210 0778 08       		.byte	8
 9211 0779 09       		.byte	9
 9212 077a 0A       		.byte	10
 9213 077b 0B       		.byte	11
 9214 077c 0B       		.byte	11
 9215 077d 0B       		.byte	11
 9216 077e 0B       		.byte	11
 9217 077f 00       		.space	1
 9220              	CyFxGpifRegValue:
 9221 0780 08830080 		.word	-2147450104
 9222 0784 67000000 		.word	103
 9223 0788 00000000 		.word	0
 9224 078c 46000000 		.word	70
 9225 0790 00000000 		.word	0
 9226 0794 00000000 		.word	0
 9227 0798 02000000 		.word	2
 9228 079c 82000000 		.word	130
 9229 07a0 82070000 		.word	1922
 9230 07a4 40040000 		.word	1088
 9231 07a8 FCFF0000 		.word	65532
 9232 07ac 28000000 		.word	40
 9233 07b0 00000000 		.word	0
 9234 07b4 00000000 		.word	0
 9235 07b8 00000000 		.word	0
 9236 07bc 00000000 		.word	0
 9237 07c0 01000000 		.word	1
 9238 07c4 00000000 		.word	0
 9239 07c8 00000000 		.word	0
 9240 07cc 00000000 		.word	0
 9241 07d0 00000000 		.word	0
 9242 07d4 00000000 		.word	0
 9243 07d8 00000000 		.word	0
 9244 07dc 00000000 		.word	0
 9245 07e0 00000000 		.word	0
 9246 07e4 00000000 		.word	0
 9247 07e8 00000000 		.word	0
 9248 07ec 00000000 		.word	0
 9249 07f0 00000000 		.word	0
 9250 07f4 06000000 		.word	6
 9251 07f8 00000000 		.word	0
 9252 07fc FFFF0000 		.word	65535
 9253 0800 09010000 		.word	265
 9254 0804 00000000 		.word	0
 9255 0808 F71F0000 		.word	8183
 9256 080c 00000000 		.word	0
 9257 0810 FFFF0000 		.word	65535
 9258 0814 09010000 		.word	265
 9259 0818 00000000 		.word	0
 9260 081c F71F0000 		.word	8183
 9261 0820 00000000 		.word	0
 9262 0824 00000000 		.word	0
 9263 0828 00000000 		.word	0
 9264 082c 00000000 		.word	0
 9265 0830 00000000 		.word	0
 9266 0834 00000000 		.word	0
 9267 0838 00000000 		.word	0
 9268 083c 00000000 		.word	0
 9269 0840 00000000 		.word	0
 9270 0844 00000000 		.word	0
 9271 0848 00000000 		.word	0
 9272 084c 00000000 		.word	0
 9273 0850 00000000 		.word	0
 9274 0854 00000000 		.word	0
 9275 0858 00000000 		.word	0
 9276 085c 00000000 		.word	0
 9277 0860 00000000 		.word	0
 9278 0864 00000000 		.word	0
 9279 0868 00000000 		.word	0
 9280 086c 00000000 		.word	0
 9281 0870 00000000 		.word	0
 9282 0874 00000000 		.word	0
 9283 0878 00000000 		.word	0
 9284 087c 00040180 		.word	-2147417088
 9285 0880 01040180 		.word	-2147417087
 9286 0884 02040180 		.word	-2147417086
 9287 0888 03040180 		.word	-2147417085
 9288 088c 00000000 		.word	0
 9289 0890 00000000 		.word	0
 9290 0894 00000000 		.word	0
 9291 0898 00000000 		.word	0
 9292 089c 00000000 		.word	0
 9293 08a0 00000000 		.word	0
 9294 08a4 00000000 		.word	0
 9295 08a8 00000000 		.word	0
 9296 08ac C1FFFFFF 		.word	-63
 9299              	CyFxGpifTransition_usb2:
 9300 08b0 0000     		.short	0
 9301 08b2 5555     		.short	21845
 9302 08b4 AAAA     		.short	-21846
 9303 08b6 8888     		.short	-30584
 9304 08b8 1111     		.short	4369
 9305 08ba 4444     		.short	17476
 9306 08bc 3333     		.short	13107
 9307 08be CCCC     		.short	-13108
 9310              	CyFxGpifWavedata_usb2:
 9311 08c0 0181731E 		.word	510886145
 9312 08c4 00000000 		.word	0
 9313 08c8 00000080 		.word	-2147483648
 9314 08cc 00000000 		.word	0
 9315 08d0 00000000 		.word	0
 9316 08d4 00000000 		.word	0
 9317 08d8 0201703E 		.word	1047527682
 9318 08dc 00010000 		.word	256
 9319 08e0 A00000C0 		.word	-1073741664
 9320 08e4 00000000 		.word	0
 9321 08e8 00000000 		.word	0
 9322 08ec 00000000 		.word	0
 9323 08f0 0394731E 		.word	510891011
 9324 08f4 04000020 		.word	536870916
 9325 08f8 60004080 		.word	-2143289248
 9326 08fc 00000000 		.word	0
 9327 0900 00000000 		.word	0
 9328 0904 00000000 		.word	0
 9329 0908 0620702E 		.word	779100166
 9330 090c 0C000000 		.word	12
 9331 0910 00000080 		.word	-2147483648
 9332 0914 0620702E 		.word	779100166
 9333 0918 0C000000 		.word	12
 9334 091c 00000080 		.word	-2147483648
 9335 0920 0394731E 		.word	510891011
 9336 0924 04000020 		.word	536870916
 9337 0928 60004080 		.word	-2143289248
 9338 092c 0620702E 		.word	779100166
 9339 0930 0C000000 		.word	12
 9340 0934 00000080 		.word	-2147483648
 9341 0938 0C93731E 		.word	510890764
 9342 093c 04000024 		.word	603979780
 9343 0940 90004080 		.word	-2143289200
 9344 0944 0D20702E 		.word	779100173
 9345 0948 0C000000 		.word	12
 9346 094c 00000080 		.word	-2147483648
 9347 0950 0780724E 		.word	1316126727
 9348 0954 0A000000 		.word	10
 9349 0958 00000080 		.word	-2147483648
 9350 095c 08000000 		.word	8
 9351 0960 00000000 		.word	0
 9352 0964 00010080 		.word	-2147483392
 9353 0968 0920702E 		.word	779100169
 9354 096c 0C010000 		.word	268
 9355 0970 00000080 		.word	-2147483648
 9356 0974 0A01701E 		.word	510656778
 9357 0978 0E000100 		.word	65550
 9358 097c 00000080 		.word	-2147483648
 9359 0980 00000000 		.word	0
 9360 0984 00000000 		.word	0
 9361 0988 00000000 		.word	0
 9362 098c 00000000 		.word	0
 9363 0990 00000000 		.word	0
 9364 0994 00000000 		.word	0
 9365 0998 0394731E 		.word	510891011
 9366 099c 04000020 		.word	536870916
 9367 09a0 60004080 		.word	-2143289248
 9368 09a4 08000000 		.word	8
 9369 09a8 00000000 		.word	0
 9370 09ac 00010080 		.word	-2147483392
 9371 09b0 0B000000 		.word	11
 9372 09b4 00000000 		.word	0
 9373 09b8 00010080 		.word	-2147483392
 9374 09bc 0C93731E 		.word	510890764
 9375 09c0 04000024 		.word	603979780
 9376 09c4 90004080 		.word	-2143289200
 9377 09c8 0D20702E 		.word	779100173
 9378 09cc 0C000000 		.word	12
 9379 09d0 00000080 		.word	-2147483648
 9380 09d4 0D20702E 		.word	779100173
 9381 09d8 0C000000 		.word	12
 9382 09dc 00000080 		.word	-2147483648
 9383 09e0 0E60724E 		.word	1316118542
 9384 09e4 0A000000 		.word	10
 9385 09e8 00000080 		.word	-2147483648
 9386 09ec 0F000000 		.word	15
 9387 09f0 00000000 		.word	0
 9388 09f4 00010080 		.word	-2147483392
 9389 09f8 1020702E 		.word	779100176
 9390 09fc 0C010000 		.word	268
 9391 0a00 00000080 		.word	-2147483648
 9392 0a04 1101701E 		.word	510656785
 9393 0a08 0E000100 		.word	65550
 9394 0a0c 00000080 		.word	-2147483648
 9395 0a10 0C93731E 		.word	510890764
 9396 0a14 04000024 		.word	603979780
 9397 0a18 90004080 		.word	-2143289200
 9398 0a1c 0F000000 		.word	15
 9399 0a20 00000000 		.word	0
 9400 0a24 00010080 		.word	-2147483392
 9401 0a28 12000000 		.word	18
 9402 0a2c 00000000 		.word	0
 9403 0a30 00010080 		.word	-2147483392
 9404 0a34 0394731E 		.word	510891011
 9405 0a38 04000020 		.word	536870916
 9406 0a3c 60004080 		.word	-2143289248
 9407 0a40 0480732E 		.word	779321348
 9408 0a44 02010000 		.word	258
 9409 0a48 000040C0 		.word	-1069547520
 9410 0a4c 0580732E 		.word	779321349
 9411 0a50 02010000 		.word	258
 9412 0a54 000040C0 		.word	-1069547520
 9413 0a58 0580732E 		.word	779321349
 9414 0a5c 02010000 		.word	258
 9415 0a60 000040C0 		.word	-1069547520
 9416 0a64 0480732E 		.word	779321348
 9417 0a68 02010000 		.word	258
 9418 0a6c 000040C0 		.word	-1069547520
 9421              	CyFxGpifWavedataPosition_usb2:
 9422 0a70 00       		.byte	0
 9423 0a71 01       		.byte	1
 9424 0a72 02       		.byte	2
 9425 0a73 03       		.byte	3
 9426 0a74 04       		.byte	4
 9427 0a75 05       		.byte	5
 9428 0a76 06       		.byte	6
 9429 0a77 07       		.byte	7
 9430 0a78 08       		.byte	8
 9431 0a79 09       		.byte	9
 9432 0a7a 0A       		.byte	10
 9433 0a7b 08       		.byte	8
 9434 0a7c 0B       		.byte	11
 9435 0a7d 0C       		.byte	12
 9436 0a7e 0D       		.byte	13
 9437 0a7f 08       		.byte	8
 9438 0a80 0E       		.byte	14
 9439 0a81 0F       		.byte	15
 9440 0a82 08       		.byte	8
 9441 0a83 08       		.byte	8
 9442 0a84 08       		.byte	8
 9443 0a85 08       		.byte	8
 9444 0a86 08       		.byte	8
 9445 0a87 08       		.byte	8
 9446 0a88 08       		.byte	8
 9447 0a89 08       		.byte	8
 9448 0a8a 08       		.byte	8
 9449 0a8b 08       		.byte	8
 9450 0a8c 08       		.byte	8
 9451 0a8d 08       		.byte	8
 9452 0a8e 08       		.byte	8
 9453 0a8f 08       		.byte	8
 9454 0a90 08       		.byte	8
 9455 0a91 08       		.byte	8
 9456 0a92 08       		.byte	8
 9457 0a93 08       		.byte	8
 9458 0a94 08       		.byte	8
 9459 0a95 08       		.byte	8
 9460 0a96 08       		.byte	8
 9461 0a97 08       		.byte	8
 9462 0a98 08       		.byte	8
 9463 0a99 08       		.byte	8
 9464 0a9a 08       		.byte	8
 9465 0a9b 08       		.byte	8
 9466 0a9c 08       		.byte	8
 9467 0a9d 08       		.byte	8
 9468 0a9e 08       		.byte	8
 9469 0a9f 08       		.byte	8
 9470 0aa0 08       		.byte	8
 9471 0aa1 08       		.byte	8
 9472 0aa2 08       		.byte	8
 9473 0aa3 08       		.byte	8
 9474 0aa4 08       		.byte	8
 9475 0aa5 08       		.byte	8
 9476 0aa6 08       		.byte	8
 9477 0aa7 08       		.byte	8
 9478 0aa8 08       		.byte	8
 9479 0aa9 08       		.byte	8
 9480 0aaa 08       		.byte	8
 9481 0aab 08       		.byte	8
 9482 0aac 08       		.byte	8
 9483 0aad 08       		.byte	8
 9484 0aae 08       		.byte	8
 9485 0aaf 08       		.byte	8
 9486 0ab0 08       		.byte	8
 9487 0ab1 08       		.byte	8
 9488 0ab2 08       		.byte	8
 9489 0ab3 08       		.byte	8
 9490 0ab4 08       		.byte	8
 9491 0ab5 08       		.byte	8
 9492 0ab6 08       		.byte	8
 9493 0ab7 08       		.byte	8
 9494 0ab8 08       		.byte	8
 9495 0ab9 08       		.byte	8
 9496 0aba 08       		.byte	8
 9497 0abb 08       		.byte	8
 9498 0abc 08       		.byte	8
 9499 0abd 08       		.byte	8
 9500 0abe 08       		.byte	8
 9501 0abf 08       		.byte	8
 9502 0ac0 08       		.byte	8
 9503 0ac1 08       		.byte	8
 9504 0ac2 08       		.byte	8
 9505 0ac3 08       		.byte	8
 9506 0ac4 08       		.byte	8
 9507 0ac5 08       		.byte	8
 9508 0ac6 08       		.byte	8
 9509 0ac7 08       		.byte	8
 9510 0ac8 08       		.byte	8
 9511 0ac9 08       		.byte	8
 9512 0aca 08       		.byte	8
 9513 0acb 08       		.byte	8
 9514 0acc 08       		.byte	8
 9515 0acd 08       		.byte	8
 9516 0ace 08       		.byte	8
 9517 0acf 08       		.byte	8
 9518 0ad0 08       		.byte	8
 9519 0ad1 08       		.byte	8
 9520 0ad2 08       		.byte	8
 9521 0ad3 08       		.byte	8
 9522 0ad4 08       		.byte	8
 9523 0ad5 08       		.byte	8
 9524 0ad6 08       		.byte	8
 9525 0ad7 08       		.byte	8
 9526 0ad8 08       		.byte	8
 9527 0ad9 08       		.byte	8
 9528 0ada 08       		.byte	8
 9529 0adb 08       		.byte	8
 9530 0adc 08       		.byte	8
 9531 0add 08       		.byte	8
 9532 0ade 08       		.byte	8
 9533 0adf 08       		.byte	8
 9534 0ae0 08       		.byte	8
 9535 0ae1 08       		.byte	8
 9536 0ae2 08       		.byte	8
 9537 0ae3 08       		.byte	8
 9538 0ae4 08       		.byte	8
 9539 0ae5 08       		.byte	8
 9540 0ae6 08       		.byte	8
 9541 0ae7 08       		.byte	8
 9542 0ae8 08       		.byte	8
 9543 0ae9 08       		.byte	8
 9544 0aea 08       		.byte	8
 9545 0aeb 08       		.byte	8
 9546 0aec 08       		.byte	8
 9547 0aed 08       		.byte	8
 9548 0aee 08       		.byte	8
 9549 0aef 08       		.byte	8
 9550 0af0 00       		.byte	0
 9551 0af1 01       		.byte	1
 9552 0af2 02       		.byte	2
 9553 0af3 10       		.byte	16
 9554 0af4 04       		.byte	4
 9555 0af5 05       		.byte	5
 9556 0af6 06       		.byte	6
 9557 0af7 07       		.byte	7
 9558 0af8 08       		.byte	8
 9559 0af9 09       		.byte	9
 9560 0afa 0A       		.byte	10
 9561 0afb 08       		.byte	8
 9562 0afc 11       		.byte	17
 9563 0afd 0C       		.byte	12
 9564 0afe 0D       		.byte	13
 9565 0aff 08       		.byte	8
 9566 0b00 0E       		.byte	14
 9567 0b01 0F       		.byte	15
 9568 0b02 08       		.byte	8
 9569 0b03 00       		.space	1
 9572              	CyFxGpifRegValue_usb2:
 9573 0b04 08830080 		.word	-2147450104
 9574 0b08 67000000 		.word	103
 9575 0b0c 01000000 		.word	1
 9576 0b10 46000000 		.word	70
 9577 0b14 00000000 		.word	0
 9578 0b18 00000000 		.word	0
 9579 0b1c 02000000 		.word	2
 9580 0b20 82000000 		.word	130
 9581 0b24 82070000 		.word	1922
 9582 0b28 40040000 		.word	1088
 9583 0b2c FCFF0000 		.word	65532
 9584 0b30 28000000 		.word	40
 9585 0b34 00000000 		.word	0
 9586 0b38 00000000 		.word	0
 9587 0b3c 00000000 		.word	0
 9588 0b40 00000000 		.word	0
 9589 0b44 01000000 		.word	1
 9590 0b48 00000000 		.word	0
 9591 0b4c 00000000 		.word	0
 9592 0b50 00000000 		.word	0
 9593 0b54 00000000 		.word	0
 9594 0b58 00000000 		.word	0
 9595 0b5c 00000000 		.word	0
 9596 0b60 00000000 		.word	0
 9597 0b64 00000000 		.word	0
 9598 0b68 00000000 		.word	0
 9599 0b6c 00000000 		.word	0
 9600 0b70 00000000 		.word	0
 9601 0b74 00000000 		.word	0
 9602 0b78 06000000 		.word	6
 9603 0b7c 00000000 		.word	0
 9604 0b80 FFFF0000 		.word	65535
 9605 0b84 09010000 		.word	265
 9606 0b88 00000000 		.word	0
 9607 0b8c F71F0000 		.word	8183
 9608 0b90 00000000 		.word	0
 9609 0b94 FFFF0000 		.word	65535
 9610 0b98 09010000 		.word	265
 9611 0b9c 00000000 		.word	0
 9612 0ba0 F71F0000 		.word	8183
 9613 0ba4 00000000 		.word	0
 9614 0ba8 00000000 		.word	0
 9615 0bac 00000000 		.word	0
 9616 0bb0 00000000 		.word	0
 9617 0bb4 00000000 		.word	0
 9618 0bb8 00000000 		.word	0
 9619 0bbc 00000000 		.word	0
 9620 0bc0 00000000 		.word	0
 9621 0bc4 00000000 		.word	0
 9622 0bc8 00000000 		.word	0
 9623 0bcc 00000000 		.word	0
 9624 0bd0 00000000 		.word	0
 9625 0bd4 00000000 		.word	0
 9626 0bd8 00000000 		.word	0
 9627 0bdc 00000000 		.word	0
 9628 0be0 00000000 		.word	0
 9629 0be4 00000000 		.word	0
 9630 0be8 00000000 		.word	0
 9631 0bec 00000000 		.word	0
 9632 0bf0 00000000 		.word	0
 9633 0bf4 00000000 		.word	0
 9634 0bf8 00000000 		.word	0
 9635 0bfc 00000000 		.word	0
 9636 0c00 00040180 		.word	-2147417088
 9637 0c04 01040180 		.word	-2147417087
 9638 0c08 02040180 		.word	-2147417086
 9639 0c0c 03040180 		.word	-2147417085
 9640 0c10 00000000 		.word	0
 9641 0c14 00000000 		.word	0
 9642 0c18 00000000 		.word	0
 9643 0c1c 00000000 		.word	0
 9644 0c20 00000000 		.word	0
 9645 0c24 00000000 		.word	0
 9646 0c28 00000000 		.word	0
 9647 0c2c 00000000 		.word	0
 9648 0c30 C1FFFFFF 		.word	-63
 9651              	glProbeCtrl20:
 9652 0c34 00       		.byte	0
 9653 0c35 00       		.byte	0
 9654 0c36 01       		.byte	1
 9655 0c37 01       		.byte	1
 9656 0c38 80       		.byte	-128
 9657 0c39 1A       		.byte	26
 9658 0c3a 06       		.byte	6
 9659 0c3b 00       		.byte	0
 9660 0c3c 00       		.byte	0
 9661 0c3d 00       		.byte	0
 9662 0c3e 00       		.byte	0
 9663 0c3f 00       		.byte	0
 9664 0c40 00       		.byte	0
 9665 0c41 00       		.byte	0
 9666 0c42 00       		.byte	0
 9667 0c43 00       		.byte	0
 9668 0c44 00       		.byte	0
 9669 0c45 00       		.byte	0
 9670 0c46 00       		.byte	0
 9671 0c47 D2       		.byte	-46
 9672 0c48 0F       		.byte	15
 9673 0c49 00       		.byte	0
 9674 0c4a 00       		.byte	0
 9675 0c4b 40       		.byte	64
 9676 0c4c 00       		.byte	0
 9677 0c4d 00       		.byte	0
 9678 0c4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 9679              		.align	2
 9680              	.LC0:
 9681 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9681      7065722D 
 9681      74696D65 
 9681      72202564 
 9681      0D0A00
 9682 0013 00       		.space	1
 9683              	.LC1:
 9684 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9684      636F6D6D 
 9684      616E6420 
 9684      71756575 
 9684      65206973 
 9685 0037 00       		.space	1
 9686              	.LC2:
 9687 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9687      7220696E 
 9687      206D756C 
 9687      74696368 
 9687      616E6E65 
 9688 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 9688      2C20646D 
 9688      61446F6E 
 9688      65202578 
 9688      0D0A00
 9689 007e 0000     		.space	2
 9690              	.LC3:
 9691 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9691      5420656E 
 9691      636F756E 
 9691      74657265 
 9691      642E2E2E 
 9692              	.LC4:
 9693 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9693      454E4420 
 9693      656E636F 
 9693      756E7465 
 9693      7265642E 
 9694 00c2 0000     		.space	2
 9695              	.LC5:
 9696 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9696      64697363 
 9696      6F6E6E65 
 9696      63746564 
 9696      2E2E2E30 
 9697 00e3 00       		.space	1
 9698              	.LC6:
 9699 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9699      43595F46 
 9699      585F5556 
 9699      435F5649 
 9699      44454F5F 
 9700 0117 0A00     		.ascii	"\012\000"
 9701 0119 000000   		.space	3
 9702              	.LC7:
 9703 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9703      43595F46 
 9703      585F5556 
 9703      435F5649 
 9703      44454F5F 
 9704 014f 00       		.ascii	"\000"
 9705              	.LC8:
 9706 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9706      726E6174 
 9706      65207365 
 9706      7474696E 
 9706      6720302E 
 9707              	.LC9:
 9708 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9708      72206665 
 9708      61747572 
 9708      65207265 
 9708      71756573 
 9709 018b 00       		.space	1
 9710              	.LC10:
 9711 018c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9711      6F6D6D69 
 9711      74656F66 
 9711      20737461 
 9711      7465203D 
 9712              	.LC11:
 9713 01a4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9713      6E656C20 
 9713      53657420 
 9713      57726170 
 9713      55702066 
 9714 01d1 000000   		.space	3
 9715              	.LC12:
 9716 01d4 4572726F 		.ascii	"Error handler...\015\012\000"
 9716      72206861 
 9716      6E646C65 
 9716      722E2E2E 
 9716      0D0A00
 9717 01e7 00       		.space	1
 9718              	.LC13:
 9719 01e8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9719      69742045 
 9719      4F462066 
 9719      61696C65 
 9719      64210A00 
 9720              	.LC14:
 9721 01fc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9721      49324320 
 9721      636F6D6D 
 9721      616E6420 
 9721      69732030 
 9722 022f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9722      78257820 
 9722      30782578 
 9722      20307825 
 9722      78203078 
 9723              	.LC15:
 9724 0248 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9724      206C6967 
 9724      68742063 
 9724      6F6D7065 
 9724      6E736174 
 9725 027b 25640D0A 		.ascii	"%d\015\012\000"
 9725      00
 9726              	.LC16:
 9727 0280 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9727      49324320 
 9727      63757272 
 9727      656E7420 
 9727      64617461 
 9728 02b3 64202564 		.ascii	"d %d\015\012\000"
 9728      0D0A00
 9729 02ba 0000     		.space	2
 9730              	.LC17:
 9731 02bc 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9731      26414743 
 9731      2073656E 
 9731      7420746F 
 9731      20686F73 
 9732 02e2 0000     		.space	2
 9733              	.LC18:
 9734 02e4 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9734      26414743 
 9734      20676F74 
 9734      74656E20 
 9734      66726F6D 
 9735 030e 0000     		.space	2
 9736              	.LC19:
 9737 0310 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 9737      6C657665 
 9737      6C2E2025 
 9737      64202564 
 9737      3B202564 
 9738 032a 0000     		.space	2
 9739              	.LC20:
 9740 032c 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 9740      7365742E 
 9740      20256420 
 9740      25643B20 
 9740      25642025 
 9741              	.LC21:
 9742 0344 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9742      67657420 
 9742      64617461 
 9742      2066726F 
 9742      6D20686F 
 9743 0371 000000   		.space	3
 9744              	.LC22:
 9745 0374 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9745      52657175 
 9745      65737420 
 9745      30782578 
 9745      20706172 
 9746 03a7 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9746      6E642074 
 9746      6F20686F 
 9746      73742030 
 9746      78257820 
 9747 03c2 0000     		.space	2
 9748              	.LC23:
 9749 03c4 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9749      204F7020 
 9749      72656365 
 9749      69766573 
 9749      20284354 
 9750 03eb 00       		.space	1
 9751              	.LC24:
 9752 03ec 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9752      756C7420 
 9752      73656C65 
 9752      63746F72 
 9752      20284354 
 9753 040e 0000     		.space	2
 9754              	.LC25:
 9755 0410 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9755      756C7420 
 9755      72657175 
 9755      65737420 
 9755      28435429 
 9756 0431 000000   		.space	3
 9757              	.LC26:
 9758 0434 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9758      52657175 
 9758      65737420 
 9758      30782578 
 9758      20706172 
 9759 0467 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9759      20307825 
 9759      78202F20 
 9759      73656E64 
 9759      20746F20 
 9760 0494 00       		.ascii	"\000"
 9761 0495 000000   		.space	3
 9762              	.LC27:
 9763 0498 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9763      73706565 
 9763      64203D20 
 9763      25642065 
 9763      76656E66 
 9764 04c8 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9764      71756573 
 9764      74203D20 
 9764      30782578 
 9764      20775661 
 9765 04f8 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9765      203D2030 
 9765      78257820 
 9765      6973666C 
 9765      61672030 
 9766 0512 0000     		.space	2
 9767              	.LC28:
 9768 0514 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9768      64656661 
 9768      756C7420 
 9768      73657475 
 9768      70207265 
 9769              	.LC29:
 9770 0540 47657420 		.ascii	"Get UVC Prob(set) control %d %d %d\015\012\000"
 9770      55564320 
 9770      50726F62 
 9770      28736574 
 9770      2920636F 
 9771 0565 000000   		.space	3
 9772              	.LC30:
 9773 0568 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 9773      74686520 
 9773      76696465 
 9773      6F206D6F 
 9773      64652066 
 9774 0589 000000   		.space	3
 9775              	.LC31:
 9776 058c 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 9776      74686520 
 9776      76696465 
 9776      6F206D6F 
 9776      64652066 
 9777 05b1 000000   		.space	3
 9778              	.LC32:
 9779 05b4 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9779      43595F46 
 9779      585F5556 
 9779      435F5354 
 9779      5245414D 
 9780 05da 0000     		.space	2
 9781              	.LC33:
 9782 05dc 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 9782      55564320 
 9782      7374696C 
 9782      6C205072 
 9782      6F622873 
 9783 0607 00       		.space	1
 9784              	.LC34:
 9785 0608 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 9785      74686520 
 9785      7374696C 
 9785      6C206D6F 
 9785      64652066 
 9786 0629 000000   		.space	3
 9787              	.LC35:
 9788 062c 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 9788      7374696C 
 9788      6C20636F 
 9788      6D6D6974 
 9788      20636F6E 
 9789              	.LC36:
 9790 0654 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 9790      43595F46 
 9790      585F5556 
 9790      435F5354 
 9790      494C5F45 
 9791              	.LC37:
 9792 0678 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 9792      55564320 
 9792      7374696C 
 9792      6C207472 
 9792      69676765 
 9793 06a1 000000   		.space	3
 9794              	.LC38:
 9795 06a4 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9795      7374696C 
 9795      6C207472 
 9795      69676765 
 9795      7220636F 
 9796 06cb 00       		.space	1
 9797              	.LC39:
 9798 06cc 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9798      65642074 
 9798      6F207365 
 9798      6E642069 
 9798      6E746572 
 9799 06fd 0A00     		.ascii	"\012\000"
 9800 06ff 00       		.space	1
 9801              	.LC40:
 9802 0700 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9802      73657420 
 9802      64656620 
 9802      64617461 
 9802      20307825 
 9803 071f 00       		.space	1
 9804              	.LC41:
 9805 0720 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9805      73657420 
 9805      64656620 
 9805      64617461 
 9805      20307825 
 9806 0753 2E0D0A00 		.ascii	".\015\012\000"
 9807 0757 00       		.space	1
 9808              	.LC42:
 9809 0758 55415254 		.ascii	"UART initialization failed!\012\000"
 9809      20696E69 
 9809      7469616C 
 9809      697A6174 
 9809      696F6E20 
 9810 0775 000000   		.space	3
 9811              	.LC43:
 9812 0778 49324320 		.ascii	"I2C initialization failed!\012\000"
 9812      696E6974 
 9812      69616C69 
 9812      7A617469 
 9812      6F6E2066 
 9813              	.LC44:
 9814 0794 49324320 		.ascii	"I2C configuration failed!\012\000"
 9814      636F6E66 
 9814      69677572 
 9814      6174696F 
 9814      6E206661 
 9815 07af 00       		.space	1
 9816              	.LC45:
 9817 07b0 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9817      43726561 
 9817      74652045 
 9817      76656E74 
 9817      20666169 
 9818 07da 0000     		.space	2
 9819              	.LC46:
 9820 07dc 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9820      20496E69 
 9820      74206661 
 9820      696C6564 
 9820      2C204572 
 9821 07ff 00       		.space	1
 9822              	.LC47:
 9823 0800 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9823      204F7665 
 9823      72726964 
 9823      65206661 
 9823      696C6564 
 9824 0827 00       		.space	1
 9825              	.LC48:
 9826 0828 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9826      28323029 
 9826      204F7665 
 9826      72726964 
 9826      65206661 
 9827 0853 00       		.space	1
 9828              	.LC49:
 9829 0854 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9829      28323429 
 9829      204F7665 
 9829      72726964 
 9829      65206661 
 9830 087f 00       		.space	1
 9831              	.LC50:
 9832 0880 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9832      20536574 
 9832      20287265 
 9832      73657420 
 9832      32322920 
 9833 08b2 00       		.ascii	"\000"
 9834 08b3 00       		.space	1
 9835              	.LC51:
 9836 08b4 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9836      20536574 
 9836      2028706F 
 9836      77657220 
 9836      32302920 
 9837 08e6 00       		.ascii	"\000"
 9838 08e7 00       		.space	1
 9839              	.LC52:
 9840 08e8 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9840      20536574 
 9840      2028736E 
 9840      61702073 
 9840      686F7420 
 9841 091b 25640A00 		.ascii	"%d\012\000"
 9842 091f 00       		.space	1
 9843              	.LC53:
 9844 0920 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9844      46756E63 
 9844      74696F6E 
 9844      20466169 
 9844      6C656420 
 9845 094f 00       		.space	1
 9846              	.LC54:
 9847 0950 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9847      46756E63 
 9847      74696F6E 
 9847      20466169 
 9847      6C656420 
 9848 097f 00       		.space	1
 9849              	.LC55:
 9850 0980 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9850      53657420 
 9850      456E6470 
 9850      6F696E74 
 9850      20636F6E 
 9851 09b0 00       		.ascii	"\000"
 9852 09b1 000000   		.space	3
 9853              	.LC56:
 9854 09b4 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9854      496E7465 
 9854      72727570 
 9854      74205374 
 9854      61747573 
 9855 09e7 20436F64 		.ascii	" Code = %d\012\000"
 9855      65203D20 
 9855      25640A00 
 9856 09f3 00       		.space	1
 9857              	.LC57:
 9858 09f4 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9858      65642074 
 9858      6F20616C 
 9858      6C6F6361 
 9858      7465206D 
 9859 0a27 65720D0A 		.ascii	"er\015\012\000"
 9859      00
 9860              	.LC58:
 9861 0a2c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9861      4368616E 
 9861      6E656C20 
 9861      43726561 
 9861      74696F6E 
 9862 0a5a 0000     		.space	2
 9863              	.LC59:
 9864 0a5c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9864      436F6E6E 
 9864      65637420 
 9864      6661696C 
 9864      65642C20 
 9865 0a81 000000   		.space	3
 9866              	.LC60:
 9867 0a84 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 9867      74686520 
 9867      76696465 
 9867      6F206D6F 
 9867      64652066 
 9868 0aa6 0000     		.space	2
 9869              	.LC61:
 9870 0aa8 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9870      4368616E 
 9870      6E656C20 
 9870      52657365 
 9870      74204661 
 9871 0ad3 00       		.space	1
 9872              	.LC62:
 9873 0ad4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9873      4368616E 
 9873      6E656C20 
 9873      53657420 
 9873      5472616E 
 9874 0b05 00       		.ascii	"\000"
 9875 0b06 0000     		.space	2
 9876              	.LC63:
 9877 0b08 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9877      4368616E 
 9877      6E656C20 
 9877      53657420 
 9877      5472616E 
 9878 0b39 0A00     		.ascii	"\012\000"
 9879 0b3b 00       		.space	1
 9880              	.LC64:
 9881 0b3c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9881      75706572 
 9881      20677069 
 9881      6600
 9882 0b4a 0000     		.space	2
 9883              	.LC65:
 9884 0b4c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9884      69676820 
 9884      67706966 
 9884      00
 9885 0b59 000000   		.space	3
 9886              	.LC66:
 9887 0b5c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9887      696E6720 
 9887      47504946 
 9887      20436F6E 
 9887      66696775 
 9888 0b8f 0A00     		.ascii	"\012\000"
 9889 0b91 000000   		.space	3
 9890              	.LC67:
 9891 0b94 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9891      74696E67 
 9891      20475049 
 9891      46207374 
 9891      61746520 
 9892 0bc7 0D0A00   		.ascii	"\015\012\000"
 9893 0bca 0000     		.space	2
 9894              	.LC68:
 9895 0bcc 33303A55 		.ascii	"30:UVC App Thread\000"
 9895      56432041 
 9895      70702054 
 9895      68726561 
 9895      6400
 9896 0bde 0000     		.space	2
 9897              	.LC69:
 9898 0be0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9898      56432041 
 9898      70702045 
 9898      50302054 
 9898      68726561 
 9899 0bf6 0000     		.space	2
 9900              	.LC70:
 9901 0bf8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9901      32432041 
 9901      70702043 
 9901      54524C20 
 9901      54687265 
 9902 0c0f 00       		.bss
 9903              		.align	2
 9904              		.set	.LANCHOR0,. + 0
 9907              	glFxUVCEvent:
 9908 0000 00000000 		.space	40
 9908      00000000 
 9908      00000000 
 9908      00000000 
 9908      00000000 
 9911              	fb:
 9912 0028 0000     		.space	2
 9915              	pb:
 9916 002a 0000     		.space	2
 9919              	pbc:
 9920 002c 0000     		.space	2
 9923              	prodCount:
 9924 002e 0000     		.space	2
 9927              	consCount:
 9928 0030 0000     		.space	2
 9929 0032 0000     		.space	2
 9932              	streamingStarted:
 9933 0034 00000000 		.space	4
 9936              	gpif_initialized:
 9937 0038 00000000 		.space	4
 9940              	isUsbConnected:
 9941 003c 00000000 		.space	4
 9944              	clearFeatureRqtReceived:
 9945 0040 00000000 		.space	4
 9948              	hitFV:
 9949 0044 00000000 		.space	4
 9952              	usbSpeed:
 9953 0048 00       		.space	1
 9954 0049 000000   		.space	3
 9957              	I2CCMDArry:
 9958 004c 00000000 		.space	12
 9958      00000000 
 9958      00000000 
 9961              	glEp0Buffer:
 9962 0058 00000000 		.space	32
 9962      00000000 
 9962      00000000 
 9962      00000000 
 9962      00000000 
 9965              	WDRflag:
 9966 0078 00000000 		.space	4
 9969              	glCommitCtrl:
 9970 007c 00000000 		.space	32
 9970      00000000 
 9970      00000000 
 9970      00000000 
 9970      00000000 
 9973              	setRes:
 9974 009c 00       		.space	1
 9977              	setstilRes:
 9978 009d 00       		.space	1
 9979 009e 0000     		.space	2
 9982              	stiflag:
 9983 00a0 00000000 		.space	4
 9986              	IMcount.7777:
 9987 00a4 00       		.space	1
 9988 00a5 000000   		.space	3
 9991              	uvcAppThread:
 9992 00a8 00000000 		.space	168
 9992      00000000 
 9992      00000000 
 9992      00000000 
 9992      00000000 
 9995              	uvcAppEP0Thread:
 9996 0150 00000000 		.space	168
 9996      00000000 
 9996      00000000 
 9996      00000000 
 9996      00000000 
 9999              	i2cAppThread:
 10000 01f8 00000000 		.space	168
 10000      00000000 
 10000      00000000 
 10000      00000000 
 10000      00000000 
 10003              	testSnap:
 10004 02a0 00       		.space	1
 10005 02a1 00       		.space	1
 10008              	fbbak:
 10009 02a2 0000     		.space	2
 10012              	pbbak:
 10013 02a4 0000     		.space	2
 10016              	pbcbak:
 10017 02a6 0000     		.space	2
 10020              	pbcpbak:
 10021 02a8 0000     		.space	2
 10022 02aa 0000     		.text
 10023              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:191    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:283    .text:0000020c $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:297    .text:0000022c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:294    .text:0000022c $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:316    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:320    .text:00000240 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:323    .text:00000240 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:481    .text:00000368 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:489    .text:0000037c $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:491    .text:0000037c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:670    .text:000004dc $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:679    .text:000004ec $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:681    .text:000004ec CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1006   .text:000007b4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1022   .text:000007e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1025   .text:000007e0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1071   .text:0000081c $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1084   .text:00000848 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1147   .text:000008b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1154   .text:000008c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1165   .text:000008e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1168   .text:000008e0 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1296   .text:000009f4 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1301   .text:000009fc $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1304   .text:000009fc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1367   .text:00000a7c ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1579   .text:00000c24 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1621   .text:00000cc0 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1686   .text:00000d44 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:1726   .text:00000ddc $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3004   .text:000019f8 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3024   .text:00001a3c $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3027   .text:00001a3c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3195   .text:00001b98 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3208   .text:00001bc0 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3703   .text:000020d0 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3714   .text:000020f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3976   .text:000023ac $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3989   .text:000023d4 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:3992   .text:000023d4 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:4054   .text:00002450 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:4062   .text:00002460 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5335   .text:00002f20 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5368   .text:00002f90 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5371   .text:00002f90 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5662   .text:00003248 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5669   .text:00003258 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5672   .text:00003258 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5708   .text:00003284 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5712   .text:00003288 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5715   .text:00003288 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5740   .text:000032a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5744   .text:000032a8 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:5747   .text:000032a8 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7216   .text:00003e7c $d
                            *COM*:00000038 imgHdMux
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7278   .text:00003f58 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7281   .text:00003f58 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7364   .text:00003fe4 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7373   .text:00003ff4 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7376   .text:00003ff4 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7533   .text:0000416c $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7549   .text:000041a0 $a
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7552   .text:000041a0 main
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9117   .data:00000644 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9126   .data:00000650 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9201   .data:00000770 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9220   .data:00000780 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7714   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9299   .data:000008b0 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9310   .data:000008c0 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9421   .data:00000a70 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9572   .data:00000b04 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7727   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9113   .data:00000643 snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:10003  .bss:000002a0 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9911   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9915   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9919   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:10008  .bss:000002a2 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:10012  .bss:000002a4 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:10016  .bss:000002a6 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:10020  .bss:000002a8 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9940   .bss:0000003c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9952   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9944   .bss:00000040 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9932   .bss:00000034 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9054   .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9084   .data:0000062c glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9651   .data:00000c34 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9099   .data:00000638 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:8709   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7691   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7695   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7739   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:7743   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:8066   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:8724   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:8731   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9679   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9903   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9907   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9923   .bss:0000002e prodCount
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9927   .bss:00000030 consCount
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9936   .bss:00000038 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9948   .bss:00000044 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9957   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9961   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9965   .bss:00000078 WDRflag
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9969   .bss:0000007c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9973   .bss:0000009c setRes
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9977   .bss:0000009d setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9982   .bss:000000a0 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9986   .bss:000000a4 IMcount.7777
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9991   .bss:000000a8 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9995   .bss:00000150 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccOyFp1J.s:9999   .bss:000001f8 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
