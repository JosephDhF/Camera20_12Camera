   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB17:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 141:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 145:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 146:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 147:../uvc.c      **** };
 148:../uvc.c      **** 
 149:../uvc.c      **** 
 150:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 151:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 152:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 154:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 155:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 156:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 157:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 158:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 159:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 160:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 161:../uvc.c      ****                                    with adjustable compression parameters */
 162:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 163:../uvc.c      ****                                    streaming with adjustable compression parameters */
 164:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 165:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 170:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 171:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 173:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 174:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 175:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 176:../uvc.c      **** };
 177:../uvc.c      **** 
 178:../uvc.c      **** 
 179:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 180:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 181:../uvc.c      **** 
 182:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 183:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 184:../uvc.c      **** {
 185:../uvc.c      ****     0x0C,                               /* Header Length */
 186:../uvc.c      ****     0x8C,                               /* Bit field header field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 188:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 189:../uvc.c      **** };
 190:../uvc.c      **** 
 191:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 192:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 193:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 194:../uvc.c      ****                                                            the current video frame. */
 195:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 196:../uvc.c      **** #ifndef CAM720
 197:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 198:../uvc.c      **** #else
 199:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 200:../uvc.c      **** #endif
 201:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 202:../uvc.c      **** 
 203:../uvc.c      **** /************ control parameters array ***********
 204:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 205:../uvc.c      ****  *    e.g.
 206:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 207:../uvc.c      ****  *     2nd D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 208:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 209:../uvc.c      ****  **************************************************/
 210:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 211:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 212:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 213:../uvc.c      **** #ifndef CAM720
 214:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 215:../uvc.c      **** #else
 216:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 217:../uvc.c      **** #endif
 218:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  63,     0, 1, 0, 3, 0, 31, 0, 
 219:../uvc.c      **** 		{/*2*/0x7/*ContrastReg*/  , 0x7/*ContrastReg*/   , 2,    16,   0,  64,     0, 1, 0, 3, 0, 40, 0, 
 220:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 221:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 222:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 223:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 224:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   14,    0, 1, 0, 3, 0,   0, 0,
 225:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*9*/0x8/*WBModeReg*/    , 0x8/*WBModeReg*/     , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 228:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 229:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 233:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 235:../uvc.c      **** #ifndef CAM720
 236:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 237:../uvc.c      **** #else
 238:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 239:../uvc.c      **** #endif
 240:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 241:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 242:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 244:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 246:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  255,    0, 1, 0, 3, 0,   0,32
 247:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg0     , 2,    0,    0,   63,    0, 1, 0, 3, 0,  32, 0
 248:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		/**********************************
 253:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 254:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 255:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 256:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 257:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 258:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 259:../uvc.c      **** 		 *
 260:../uvc.c      **** 		 *********************************/
 261:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 262:../uvc.c      **** };
 263:../uvc.c      **** 
 264:../uvc.c      **** #ifndef CAM720
 265:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 266:../uvc.c      **** #else
 267:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 268:../uvc.c      **** #endif
 269:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 270:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 271:../uvc.c      **** 
 272:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 273:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 274:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 275:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 276:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 277:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 278:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 279:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 280:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 281:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 282:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 285:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 287:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 288:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 289:../uvc.c      **** };
 290:../uvc.c      **** 
 291:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 292:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 293:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 294:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 295:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 296:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 297:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 298:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 299:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 300:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 302:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 303:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 304:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 308:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 309:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 310:../uvc.c      **** };
 311:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 312:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 313:../uvc.c      **** 
 314:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 315:../uvc.c      **** 
 316:../uvc.c      **** /*
 317:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 318:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 319:../uvc.c      ****  */
 320:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 321:../uvc.c      **** 		0xa0, 0x0f, 0xf, 0xf0
 322:../uvc.c      **** };
 323:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 324:../uvc.c      **** 		0
 325:../uvc.c      **** };
 326:../uvc.c      **** 
 327:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 328:../uvc.c      **** 
 329:../uvc.c      **** void I2CCmdHandler(){
 330:../uvc.c      **** 	uint8_t buf[2];
 331:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 332:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 333:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 334:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 335:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 336:../uvc.c      **** 
 337:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 338:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 339:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 340:../uvc.c      **** 
 341:../uvc.c      **** 	if(CmdType == 0)//I2C read
 342:../uvc.c      **** 	{
 343:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 344:../uvc.c      **** #if 0 //for debugging
 345:../uvc.c      **** 		/* test still image operation */
 346:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 347:../uvc.c      **** 			snapButFlag = 0; //press
 348:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 349:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 350:../uvc.c      **** 			snapButFlag = 0xf; //release
 351:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 352:../uvc.c      **** 		}
 353:../uvc.c      **** 
 354:../uvc.c      **** 		/* end of the test */
 355:../uvc.c      **** #endif
 356:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 357:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 358:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 359:../uvc.c      **** 			if(CmdDataLen == 2){
 360:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 361:../uvc.c      **** 			}
 362:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 363:../uvc.c      **** 		}else{//not support currently
 364:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 365:../uvc.c      **** 		}
 366:../uvc.c      **** 	}else if(CmdType == 1){
 367:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 368:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 369:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 370:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 371:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 372:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 373:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 374:../uvc.c      **** 			}
 375:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 376:../uvc.c      **** 		}else{//not support currently
 377:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 378:../uvc.c      **** 		}
 379:../uvc.c      **** 
 380:../uvc.c      **** 	}
 381:../uvc.c      **** }
 382:../uvc.c      **** 
 383:../uvc.c      **** /************************************
 384:../uvc.c      ****  * set Iris mode
 385:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 386:../uvc.c      ****  */
 387:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 388:../uvc.c      **** 	uint8_t dataIdx;
 389:../uvc.c      **** 	  dataIdx = 0;
 390:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 392:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 393:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 394:../uvc.c      **** }
 395:../uvc.c      **** 
 396:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 397:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 398:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 399:../uvc.c      ****     uint16_t readCount;
 400:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 401:../uvc.c      ****     uint8_t devAdd;
 402:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 403:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 404:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 405:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 406:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 407:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 408:../uvc.c      ****     }else{
 409:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 410:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 411:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 412:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 413:../uvc.c      ****     }
 414:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 415:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 416:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 417:../uvc.c      **** #endif
 418:../uvc.c      ****     reqData = bRequest;
 419:../uvc.c      ****     /*
 420:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 421:../uvc.c      ****      */
 422:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 423:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 424:../uvc.c      ****     	goto EndofSet;
 425:../uvc.c      ****     }
 426:../uvc.c      ****     switch (bRequest)
 427:../uvc.c      **** 		 {
 428:../uvc.c      **** 
 429:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 430:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 431:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 432:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 433:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 434:../uvc.c      **** 			  break;
 435:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 436:../uvc.c      **** 
 437:../uvc.c      **** 			 switch(CtrlID)
 438:../uvc.c      **** 			 {
 439:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 440:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 441:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 442:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 443:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 444:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 445:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 446:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 447:../uvc.c      **** 			 	 		 break;
 448:../uvc.c      **** 			 	 }
 449:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 450:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 451:../uvc.c      **** 					 if(CamMode == 1){//720p or invendo
 452:../uvc.c      **** 						if(sendData >= 3){
 453:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 454:../uvc.c      **** 							sendData = 0; //set back to default
 455:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 456:../uvc.c      **** 						}
 457:../uvc.c      **** 						sendData += 4;
 458:../uvc.c      **** 					 }
 459:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 460:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 461:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 462:../uvc.c      **** 					 break;
 463:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 464:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 465:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 466:../uvc.c      **** 			 		 }
 467:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 468:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 469:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 470:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 471:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 472:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 473:../uvc.c      **** #endif
 474:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 475:../uvc.c      **** 			 		 {
 476:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 477:../uvc.c      **** 			 		 }
 478:../uvc.c      **** 			 		 break;
 479:../uvc.c      **** 				 case ExtAexModCtlID9:
 480:../uvc.c      **** 
 481:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 482:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 483:../uvc.c      **** 						 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 484:../uvc.c      **** 		 	 		 }else{
 485:../uvc.c      **** 		 	 			//remove for invendo
 486:../uvc.c      **** 		 	 			//glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 487:../uvc.c      **** 		 	 			//glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 488:../uvc.c      **** 		 	 			//CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 489:../uvc.c      **** 
 490:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 491:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 492:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 493:../uvc.c      **** 		 	 		 }
 494:../uvc.c      **** 
 495:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 496:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 497:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 498:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 499:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 500:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 501:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 502:../uvc.c      **** 					 break;
 503:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 504:../uvc.c      **** 			 	 case BrgtCtlID1:
 505:../uvc.c      **** 
 506:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 507:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 508:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 509:../uvc.c      **** 		 	 		 }else{
 510:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 511:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 512:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 513:../uvc.c      **** 
 514:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 515:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 516:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 517:../uvc.c      **** 		 	 		 }
 518:../uvc.c      **** 
 519:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 520:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 521:../uvc.c      **** 					 }else{
 522:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 523:../uvc.c      **** 					 }
 524:../uvc.c      **** 
 525:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 526:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 527:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 528:../uvc.c      **** 					 break;
 529:../uvc.c      **** #endif
 530:../uvc.c      **** 				 case HueCtlID5://TODO check sensor register
 531:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 532:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 533:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 534:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 535:../uvc.c      **** 					 break;
 536:../uvc.c      **** 				 case WBTLevCtlID11:
 537:../uvc.c      **** 
 538:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 539:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 540:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 541:../uvc.c      **** 		 	 		 }else{
 542:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd1, devAdd);
 543:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 544:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 545:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 546:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 547:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 548:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 549:../uvc.c      **** 		 	 		 }
 550:../uvc.c      **** 
 551:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 552:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 553:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 554:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 555:../uvc.c      **** 					 break;
 556:../uvc.c      **** 				 case SaturCtlID6://TODO check sensor register
 557:../uvc.c      **** 				 default:
 558:../uvc.c      **** 
 559:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 560:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 561:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 562:../uvc.c      **** 		 	 		 }else{
 563:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 564:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 565:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 566:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 567:../uvc.c      **** 		 	 		 }
 568:../uvc.c      **** 
 569:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 570:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 571:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 572:../uvc.c      **** 					 break;
 573:../uvc.c      **** 			 }
 574:../uvc.c      **** 
 575:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 576:../uvc.c      **** 
 577:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 578:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 579:../uvc.c      **** #endif
 580:../uvc.c      **** 			  break;
 581:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 582:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 583:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 584:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 585:../uvc.c      **** 		 	 }
 586:../uvc.c      **** 
 587:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 588:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 589:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 590:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 591:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 592:../uvc.c      **** 			 }else
 593:../uvc.c      **** 			 {
 594:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 595:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 596:../uvc.c      **** 			 }
 597:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 598:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 599:../uvc.c      **** 			  break;
 600:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 601:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 602:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 603:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 604:../uvc.c      **** 		 	 }
 605:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 606:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 607:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 608:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 609:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 610:../uvc.c      **** 			 }else
 611:../uvc.c      **** 			 {
 612:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 613:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 614:../uvc.c      **** 			 }
 615:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 616:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 617:../uvc.c      **** 			  break;
 618:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 619:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 620:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 621:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 622:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 623:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 624:../uvc.c      **** 		 	 }
 625:../uvc.c      **** 		 	 else{
 626:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 627:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 628:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 629:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 630:../uvc.c      **** 		 	 }
 631:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 632:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 633:../uvc.c      **** 			  break;
 634:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 635:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 636:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 637:../uvc.c      **** 		 	 }
 638:../uvc.c      **** 		 	 else{
 639:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 640:../uvc.c      **** 		 	 }
 641:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 642:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 643:../uvc.c      **** 			  Len = 1;
 644:../uvc.c      **** 			  break;
 645:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 646:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 647:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 648:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 649:../uvc.c      **** 		 	 }
 650:../uvc.c      **** 
 651:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 652:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 653:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 654:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 655:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 656:../uvc.c      **** 			 }else{
 657:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 658:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 659:../uvc.c      **** 			 }
 660:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 661:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 662:../uvc.c      **** 			  break;
 663:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 664:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 665:../uvc.c      **** 				  glEp0Buffer, &readCount);
 666:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 667:../uvc.c      **** 			   {
 668:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 669:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 670:../uvc.c      **** 				  getData = glEp0Buffer[0];
 671:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 672:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 673:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 674:../uvc.c      **** #endif
 675:../uvc.c      **** 				  switch(CtrlID)
 676:../uvc.c      **** 					 {
 677:../uvc.c      **** 						 case ExtShutCtlID0:
 678:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 679:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 680:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 681:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 682:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 683:../uvc.c      **** 									 }else{
 684:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 685:../uvc.c      **** 									 }
 686:../uvc.c      **** 								 }
 687:../uvc.c      **** 							 }else{
 688:../uvc.c      **** 								 Data1 = Data0 - 1;
 689:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 690:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 691:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 692:../uvc.c      **** 									 }else{
 693:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 694:../uvc.c      **** 									 }
 695:../uvc.c      **** 								 }
 696:../uvc.c      **** 								 if(Data1 < 8){
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 698:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 699:../uvc.c      **** 								 }else{
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 701:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 702:../uvc.c      **** 								 }
 703:../uvc.c      **** 							 }
 704:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 705:../uvc.c      **** 							 dataIdx = 0;
 706:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 707:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 708:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 709:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 710:../uvc.c      **** 							 break;
 711:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 714:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 715:../uvc.c      **** 							 dataIdx = 0;
 716:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 717:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 718:../uvc.c      **** 							 if(1 || (getData != 0)){
 719:../uvc.c      **** 								 //dataIdx++;
 720:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 721:../uvc.c      **** 							 }
 722:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 723:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 724:../uvc.c      **** 							 break;
 725:../uvc.c      **** 						 case ExtExRefCtlID10:
 726:../uvc.c      **** 							 dataIdx = 0;
 727:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 728:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 729:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 730:../uvc.c      **** 							 if(WDRflag)
 731:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 732:../uvc.c      **** 							 else
 733:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 734:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 735:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 736:../uvc.c      **** 						 case ExtCamMCtlID12:
 737:../uvc.c      **** 							 /*
 738:../uvc.c      **** 							 dataIdx = 0;
 739:../uvc.c      **** 							 if(Data0 <= 3){
 740:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 741:../uvc.c      **** 								 Data1 = Data0;
 742:../uvc.c      **** 							 }else{
 743:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 744:../uvc.c      **** 								 Data1 = Data0-4;
 745:../uvc.c      **** 							 }
 746:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 747:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 748:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 749:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 750:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 751:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 752:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 753:../uvc.c      **** 							 */
 754:../uvc.c      **** 							 break;
 755:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 756:../uvc.c      **** 							 dataIdx = 0;
 757:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 758:../uvc.c      **** 								 Data0 = 1;
 759:../uvc.c      **** 							 }else{ //save current sensor parameters.
 760:../uvc.c      **** 								 Data0 = 0;
 761:../uvc.c      **** 							 }
 762:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 763:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 764:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 765:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 766:../uvc.c      **** 							 break;
 767:../uvc.c      **** 						 case ExtI2CCtlID15:
 768:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 769:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 770:../uvc.c      **** 					 		 }
 771:../uvc.c      **** 					 		I2CCmdHandler();
 772:../uvc.c      **** 							 break;
 773:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 774:../uvc.c      **** 							 dataIdx = 0;
 775:../uvc.c      **** #if 0 //seperate version
 776:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 777:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 778:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 779:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 780:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 781:../uvc.c      **** 							 }else{ //disable BLD window
 782:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 783:../uvc.c      **** 							 }
 784:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 785:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 786:../uvc.c      **** 							 dataIdx++;
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 788:../uvc.c      **** 							 dataIdx++;
 789:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 790:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 791:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 792:../uvc.c      **** 							 dataIdx++;
 793:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 794:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 795:../uvc.c      **** #else //combination version
 796:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 797:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 798:../uvc.c      **** 						     /* end test */
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 800:../uvc.c      **** 							 dataIdx++;
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 802:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 803:../uvc.c      **** 							 getData1 = Data1;
 804:../uvc.c      **** #endif
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 807:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 808:../uvc.c      **** 							 break;
 809:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 810:../uvc.c      **** 							 dataIdx = 0;
 811:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 812:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 813:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 815:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 816:../uvc.c      **** 							 break;
 817:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 818:../uvc.c      **** 							 dataIdx = 0;
 819:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 820:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 821:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 823:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 824:../uvc.c      **** 							 break;
 825:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 826:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 827:../uvc.c      **** 							 dataIdx = 0;
 828:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 829:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 830:../uvc.c      **** 							  if(Data0&0x80){
 831:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 832:../uvc.c      **** 							  }else{
 833:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 834:../uvc.c      **** 							  }
 835:../uvc.c      **** 							 Data1 |= ~0x03;
 836:../uvc.c      **** 							 Data1 &= 0xC7;
 837:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 838:../uvc.c      **** 						  	 dataIdx++;
 839:../uvc.c      **** 
 840:../uvc.c      **** 							 Data0 = (Data0 << 2);
 841:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 842:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 843:../uvc.c      **** 
 844:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 845:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 846:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 847:../uvc.c      **** 
 848:../uvc.c      **** 							 break;
 849:../uvc.c      **** #endif
 850:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 851:../uvc.c      **** 							 dataIdx = 0;
 852:../uvc.c      **** 
 853:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 854:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 855:../uvc.c      **** 							 dataIdx++;
 856:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 857:../uvc.c      **** 							 dataIdx++;
 858:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 859:../uvc.c      **** 							 dataIdx++;
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 861:../uvc.c      **** 							 dataIdx++;
 862:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 863:../uvc.c      **** 							 dataIdx++;
 864:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 865:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 866:../uvc.c      **** 
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 868:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 869:../uvc.c      **** 							 break;
 870:../uvc.c      **** 						 case SaturCtlID6:
 871:../uvc.c      **** 							 dataIdx = 0;
 872:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 875:../uvc.c      **** 							 dataIdx++;
 876:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 877:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 878:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 879:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 880:../uvc.c      **** 							 break;
 881:../uvc.c      **** 
 882:../uvc.c      **** 						 case WBTLevCtlID11:
 883:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue to 0x9 or low to 0xa
 884:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red to 0xa or high to 0x9
 885:../uvc.c      **** 							 dataIdx = 0;
 886:../uvc.c      **** 
 887:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 888:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 889:../uvc.c      **** 							 dataIdx++;
 890:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data1, dataIdx);  //Second
 891:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 892:../uvc.c      **** 
 893:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 894:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 895:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 896:../uvc.c      **** 							 break;
 897:../uvc.c      **** 						 case MFreqCtlID4:
 898:../uvc.c      **** 							 dataIdx = 0;
 899:../uvc.c      **** 							 Data0 = Data0 - 1;
 900:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 901:../uvc.c      **** 								 Data0 = 0;
 902:../uvc.c      **** 							 else if(Data0 >2)
 903:../uvc.c      **** 								 Data0 = 1;
 904:../uvc.c      **** 
 905:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 906:../uvc.c      **** 							 //remove for Invendo
 907:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 908:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 909:../uvc.c      **** 
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 911:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 912:../uvc.c      **** 							 break;
 913:../uvc.c      **** 					 	 case BLCCtlID0:
 914:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 915:../uvc.c      **** 							 if(Data0 == 3)
 916:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 917:../uvc.c      **** 							 else
 918:../uvc.c      **** 								 WDRflag = CyFalse;
 919:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 920:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 921:../uvc.c      **** 							 {
 922:../uvc.c      **** 								 if(Data0 < 2){
 923:../uvc.c      **** 					 				 ;//Data0 += 4;
 924:../uvc.c      **** 					 			 }else{
 925:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 926:../uvc.c      **** 									Data0 = 0; //set to default.
 927:../uvc.c      **** 					 			 }
 928:../uvc.c      **** 					 		 }
 929:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 930:../uvc.c      **** 							 dataIdx = 0;
 931:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 932:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 933:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 934:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 935:../uvc.c      **** 
 936:../uvc.c      **** 					 		 break;
 937:../uvc.c      **** 						 default:
 938:../uvc.c      **** 							 dataIdx = 0;
 939:../uvc.c      **** 
 940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 941:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 942:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 943:../uvc.c      **** 
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 945:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 946:../uvc.c      **** 							 break;
 947:../uvc.c      **** 					 }
 948:../uvc.c      **** 			   }else{
 949:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 950:../uvc.c      **** 			   }
 951:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 952:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 953:../uvc.c      **** #endif
 954:../uvc.c      **** 
 955:../uvc.c      **** 			  break;
 956:../uvc.c      **** 		  default:
 957:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 958:../uvc.c      **** 			  break;
 959:../uvc.c      **** 		 }
 960:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 961:../uvc.c      **** }
 962:../uvc.c      **** /************** CT control requests handler *************************/
 963:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 964:../uvc.c      **** 
 965:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 966:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 967:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 968:../uvc.c      ****     uint16_t readCount;
 969:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 970:../uvc.c      ****     uint16_t diff, value, diffRd;
 971:../uvc.c      ****     uint8_t i, shutter, index;
 972:../uvc.c      ****     diff = 0xffff;
 973:../uvc.c      ****     shutter = 1;
 974:../uvc.c      ****     index = 1;
 975:../uvc.c      **** 
 976:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 977:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 978:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 979:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 980:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 981:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 982:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 983:../uvc.c      **** #endif
 984:../uvc.c      ****     reqData = bRequest;
 985:../uvc.c      **** 
 986:../uvc.c      ****     switch (bRequest)
 987:../uvc.c      **** 		 {
 988:../uvc.c      **** 
 989:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 990:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 991:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 993:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 994:../uvc.c      **** 			  break;
 995:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 996:../uvc.c      **** 
 997:../uvc.c      **** 			 switch(CtrlID)
 998:../uvc.c      **** 			 {
 999:../uvc.c      **** 				 default:
1000:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1001:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1002:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1003:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1004:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1005:../uvc.c      **** 					 break;
1006:../uvc.c      **** 			 }
1007:../uvc.c      **** 
1008:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1009:../uvc.c      **** 
1010:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1011:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1012:../uvc.c      **** #endif
1013:../uvc.c      **** 			  break;
1014:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1015:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1016:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1017:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1018:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1019:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1020:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1021:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1022:../uvc.c      **** 			  break;
1023:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1024:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1025:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1026:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1027:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1028:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1029:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1030:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1031:../uvc.c      **** 			  break;
1032:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1033:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1034:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1035:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1036:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1037:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1040:../uvc.c      **** 			  break;
1041:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1042:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1043:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1044:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1045:../uvc.c      **** 			  Len = 1;
1046:../uvc.c      **** 			  break;
1047:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1048:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1049:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1050:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1051:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1052:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1053:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1054:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1055:../uvc.c      **** 			  break;
1056:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1057:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1058:../uvc.c      **** 			  glEp0Buffer, &readCount);
1059:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1060:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1061:../uvc.c      **** 			  value = Data1;
1062:../uvc.c      **** 
1063:../uvc.c      **** 			  switch(CtrlID)
1064:../uvc.c      **** 			  {
1065:../uvc.c      **** 		  	      case AutoExMCtlID1:
1066:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1067:../uvc.c      **** 
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1069:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1070:../uvc.c      **** 				    getData = glEp0Buffer[0];
1071:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1072:../uvc.c      **** 		  		    switch (getData){
1073:../uvc.c      **** 						case 1:
1074:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1075:../uvc.c      **** 							break;
1076:../uvc.c      **** 						case 2:
1077:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1078:../uvc.c      **** 							dataIdx = 0;
1079:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1080:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1081:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1082:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1083:../uvc.c      **** 
1084:../uvc.c      **** 							break;
1085:../uvc.c      **** 						case 4:
1086:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1087:../uvc.c      **** 							break;
1088:../uvc.c      **** 						case 8:
1089:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1090:../uvc.c      **** 			  		    	dataIdx = 0;
1091:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1092:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1093:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1094:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1095:../uvc.c      **** 							break;
1096:../uvc.c      **** 		  		    }
1097:../uvc.c      **** #if 0
1098:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1099:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1100:../uvc.c      **** 						  dataIdx = 0;
1101:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1102:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1103:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1104:../uvc.c      **** 		  		    }
1105:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1106:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1107:../uvc.c      **** 		  		    }
1108:../uvc.c      **** #endif
1109:../uvc.c      **** 				    break;
1110:../uvc.c      **** 
1111:../uvc.c      **** 			  	  case ExTmACtlID3:
1112:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1113:../uvc.c      **** 
1114:../uvc.c      **** 					  value = (value << 8)|Data0;
1115:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1116:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1117:../uvc.c      **** 					  {
1118:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1119:../uvc.c      **** 						  {
1120:../uvc.c      **** 							if(value > ShutValueArry[i]){
1121:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1122:../uvc.c      **** 							}else{
1123:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1124:../uvc.c      **** 							}
1125:../uvc.c      **** 							  if(diff > diffRd){
1126:../uvc.c      **** 								  diff = diffRd;
1127:../uvc.c      **** 								  index = i;
1128:../uvc.c      **** 							  }
1129:../uvc.c      **** 						  }
1130:../uvc.c      **** 						  shutter = shutter+index;
1131:../uvc.c      **** 
1132:../uvc.c      **** 						  dataIdx = 0;
1133:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1134:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1135:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1136:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1137:../uvc.c      **** 
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1140:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1141:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1142:../uvc.c      **** 					  }else{
1143:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1144:../uvc.c      **** 					  }
1145:../uvc.c      **** 					  getData = glEp0Buffer[0];
1146:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1147:../uvc.c      **** 					  break;
1148:../uvc.c      **** 			  	  case IriACtlID7:
1149:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1150:../uvc.c      **** 					  {
1151:../uvc.c      **** 							 dataIdx = 0;
1152:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1153:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1154:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1155:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1156:../uvc.c      **** 
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1159:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1160:../uvc.c      **** 					  }else{
1161:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1162:../uvc.c      **** 					  }
1163:../uvc.c      **** 					  getData = glEp0Buffer[0];
1164:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1165:../uvc.c      **** 
1166:../uvc.c      **** 					  break;
1167:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1168:../uvc.c      **** 					  getData = glEp0Buffer[0];
1169:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1170:../uvc.c      **** #if 1
1171:../uvc.c      **** 					  dataIdx = 0;
1172:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1173:../uvc.c      **** 					  if(getData == 1)
1174:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1175:../uvc.c      **** 					  else if(getData == 0xff)
1176:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1177:../uvc.c      **** 					  else
1178:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1179:../uvc.c      **** 					  //dataIdx++;
1180:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1181:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1182:../uvc.c      **** #endif
1183:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1184:../uvc.c      **** 					  break;
1185:../uvc.c      **** 
1186:../uvc.c      **** 			  	  default:
1187:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1188:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1189:../uvc.c      **** 			  		 break;
1190:../uvc.c      **** 			  }
1191:../uvc.c      **** 			  break;
1192:../uvc.c      **** 		  default:
1193:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1194:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1195:../uvc.c      **** 			  break;
1196:../uvc.c      **** 		 }
1197:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1198:../uvc.c      **** 
1199:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1200:../uvc.c      **** }
1201:../uvc.c      **** 
1202:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1203:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1204:../uvc.c      **** {
1205:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1206:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1207:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1208:../uvc.c      **** 
1209:../uvc.c      ****     CtrlID = BrgtCtlID1;
1210:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1211:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1212:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1213:../uvc.c      ****     Data1 = Data0;
1214:../uvc.c      **** 
1215:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1216:../uvc.c      ****     if(Data1&0x80){
1217:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1218:../uvc.c      ****     }else{
1219:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1220:../uvc.c      ****     }
1221:../uvc.c      ****     Data0 = (Data0 << 2);
1222:../uvc.c      **** 
1223:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1224:../uvc.c      **** 
1225:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1226:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1227:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1228:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1229:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1230:../uvc.c      **** 
1231:../uvc.c      ****     CtrlID = ConsCtlID2;
1232:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1233:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1234:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1235:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1236:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1237:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1238:../uvc.c      **** 
1239:../uvc.c      ****     CtrlID = HueCtlID5;
1240:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1241:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1242:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1248:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1249:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1250:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1251:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1252:../uvc.c      **** 
1253:../uvc.c      ****     CtrlID = SaturCtlID6;
1254:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1255:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1256:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1257:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1258:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1259:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1260:../uvc.c      **** 
1261:../uvc.c      ****     CtrlID = ShapCtlID7;
1262:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1263:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1264:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1265:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1266:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1267:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1268:../uvc.c      **** 
1269:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1270:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1271:../uvc.c      **** 	return;
1272:../uvc.c      **** }
1273:../uvc.c      **** 
1274:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1275:../uvc.c      **** void
1276:../uvc.c      **** CyFxUVCAddHeader (
1277:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1278:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1279:../uvc.c      ****         )
1280:../uvc.c      **** {
1281:../uvc.c      ****     /* Copy header to buffer */
1282:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1283:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1284:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1285:../uvc.c      **** 
1286:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1287:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1288:../uvc.c      ****     {
1289:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1290:../uvc.c      ****     }
1291:../uvc.c      **** }
1292:../uvc.c      **** 
1293:../uvc.c      **** 
1294:../uvc.c      **** /* Application Error Handler */
1295:../uvc.c      **** void
1296:../uvc.c      **** CyFxAppErrorHandler (
1297:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1298:../uvc.c      ****         )
1299:../uvc.c      **** {
1300:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1301:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1302:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1303:../uvc.c      **** 
1304:../uvc.c      ****        This function can be modified to take additional error handling actions such
1305:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1306:../uvc.c      ****      */
1307:../uvc.c      ****     for (;;)
1308:../uvc.c      ****     {
1309:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1310:../uvc.c      ****         CyU3PThreadSleep (1000);
1311:../uvc.c      ****     }
1312:../uvc.c      **** }
1313:../uvc.c      **** 
1314:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1315:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1316:../uvc.c      ****  */
1317:../uvc.c      **** static void
1318:../uvc.c      **** CyFxUVCApplnAbortHandler (
1319:../uvc.c      ****         void)
1320:../uvc.c      **** {
1321:../uvc.c      **** 	uint32_t flag;
1322:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1323:../uvc.c      **** 	{
1324:../uvc.c      ****         /* Clear the Video Stream Request Event */
1325:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1326:../uvc.c      **** 
1327:../uvc.c      ****         /* Set Video Stream Abort Event */
1328:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1329:../uvc.c      **** 	}
1330:../uvc.c      **** }
1331:../uvc.c      **** 
1332:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1333:../uvc.c      **** static void
1334:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1335:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1336:../uvc.c      ****         uint16_t             evdata  /* Event data */
1337:../uvc.c      ****         )
1338:../uvc.c      **** {
1339:../uvc.c      ****     switch (evtype)
1340:../uvc.c      ****     {
1341:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1342:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1343:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1344:../uvc.c      ****             gpif_initialized = 0;
1345:../uvc.c      ****             streamingStarted = CyFalse;
1346:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1347:../uvc.c      ****             break;
1348:../uvc.c      **** 
1349:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1350:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1351:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1352:../uvc.c      ****             gpif_initialized = 0;
1353:../uvc.c      ****             streamingStarted = CyFalse;
1354:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1355:../uvc.c      ****             break;
1356:../uvc.c      **** 
1357:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1358:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1359:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1360:../uvc.c      ****             gpif_initialized = 0;
1361:../uvc.c      ****             isUsbConnected = CyFalse;
1362:../uvc.c      ****             streamingStarted = CyFalse;
1363:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1364:../uvc.c      ****             break;
1365:../uvc.c      **** 
1366:../uvc.c      **** #ifdef BACKFLOW_DETECT
1367:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1368:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1369:../uvc.c      ****             break;
1370:../uvc.c      **** #endif
1371:../uvc.c      **** 
1372:../uvc.c      ****         default:
1373:../uvc.c      ****             break;
1374:../uvc.c      ****     }
1375:../uvc.c      **** }
1376:../uvc.c      **** 
1377:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1378:../uvc.c      **** static CyBool_t
1379:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1380:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1381:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1382:../uvc.c      ****         )
1383:../uvc.c      **** {
1384:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1385:../uvc.c      ****     uint32_t status;
1386:../uvc.c      **** 
1387:../uvc.c      ****     /* Obtain Request Type and Request */
1388:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1389:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1390:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1391:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1392:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1393:../uvc.c      **** 
1394:../uvc.c      **** #if 1
1395:../uvc.c      ****    	CyU3PDebugPrint(4, "\n\rbRType = 0x%x, bRequest = 0x%x, wValue = 0x%x, wIndex = 0x%x, wLength= 
1396:../uvc.c      **** #endif
1397:../uvc.c      **** 
1398:../uvc.c      ****     /* Check for UVC Class Requests */
1399:../uvc.c      ****     switch (bmReqType)
1400:../uvc.c      ****     {
1401:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1402:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1403:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1404:../uvc.c      ****             switch (wIndex & 0xFF)
1405:../uvc.c      ****             {
1406:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1407:../uvc.c      ****                     {
1408:../uvc.c      ****                         uvcHandleReq = CyTrue;
1409:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1410:../uvc.c      ****                                 CYU3P_EVENT_OR);
1411:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1412:../uvc.c      ****                         {
1413:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1414:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1415:../uvc.c      ****                         }
1416:../uvc.c      ****                     }
1417:../uvc.c      ****                     break;
1418:../uvc.c      **** 
1419:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1420:../uvc.c      ****                     {
1421:../uvc.c      ****                         uvcHandleReq = CyTrue;
1422:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1423:../uvc.c      ****                                 CYU3P_EVENT_OR);
1424:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1425:../uvc.c      ****                         {
1426:../uvc.c      ****                             /* Error handling */
1427:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1428:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1429:../uvc.c      ****                         }
1430:../uvc.c      ****                     }
1431:../uvc.c      ****                     break;
1432:../uvc.c      **** 
1433:../uvc.c      ****                 default:
1434:../uvc.c      ****                     break;
1435:../uvc.c      ****             }
1436:../uvc.c      ****             break;
1437:../uvc.c      **** 
1438:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1439:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1440:../uvc.c      ****             {
1441:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1442:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1443:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1444:../uvc.c      ****                 {
1445:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1446:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1447:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1448:../uvc.c      ****                     gpif_initialized = 0;
1449:../uvc.c      ****                     streamingStarted = CyFalse;
1450:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1451:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1452:../uvc.c      ****                     CyU3PBusyWait (100);
1453:../uvc.c      **** 
1454:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1455:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1456:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1457:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1458:../uvc.c      ****                     CyU3PBusyWait (100);
1459:../uvc.c      **** 
1460:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1461:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1462:../uvc.c      ****                     uvcHandleReq = CyTrue;
1463:../uvc.c      ****                     /* Complete Control request handshake */
1464:../uvc.c      ****                     CyU3PUsbAckSetup ();
1465:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1466:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1467:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1468:../uvc.c      **** 
1469:../uvc.c      ****                 }
1470:../uvc.c      ****             }
1471:../uvc.c      ****             break;
1472:../uvc.c      **** 
1473:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1474:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1475:../uvc.c      ****             {
1476:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1477:../uvc.c      ****                 {
1478:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1479:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1480:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1481:../uvc.c      ****                 	 * has started. */
1482:../uvc.c      ****                     if (streamingStarted == CyTrue)
1483:../uvc.c      ****                     {
1484:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1485:../uvc.c      **** 
1486:../uvc.c      ****                         /* Disable the GPIF state machine. */
1487:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1488:../uvc.c      ****                         gpif_initialized = 0;
1489:../uvc.c      ****                         streamingStarted = CyFalse;
1490:../uvc.c      **** 
1491:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1492:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1493:../uvc.c      ****                         CyU3PBusyWait (100);
1494:../uvc.c      **** 
1495:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1496:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1497:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1498:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1499:../uvc.c      ****                         CyU3PBusyWait (100);
1500:../uvc.c      **** 
1501:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1502:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1503:../uvc.c      **** 
1504:../uvc.c      ****                         uvcHandleReq = CyTrue;
1505:../uvc.c      ****                         /* Complete Control request handshake */
1506:../uvc.c      ****                         CyU3PUsbAckSetup ();
1507:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1508:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1509:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1510:../uvc.c      ****                     }
1511:../uvc.c      ****                     else
1512:../uvc.c      ****                     {
1513:../uvc.c      ****                         uvcHandleReq = CyTrue;
1514:../uvc.c      ****                         CyU3PUsbAckSetup ();
1515:../uvc.c      ****                     }
1516:../uvc.c      ****                 }
1517:../uvc.c      ****             }
1518:../uvc.c      ****             break;
1519:../uvc.c      **** 
1520:../uvc.c      ****         default:
1521:../uvc.c      ****             break;
1522:../uvc.c      ****     }
1523:../uvc.c      **** 
1524:../uvc.c      ****     /* Return status of request handling to the USB driver */
1525:../uvc.c      ****     return uvcHandleReq;
1526:../uvc.c      **** }
1527:../uvc.c      **** 
1528:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1529:../uvc.c      **** 
1530:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1531:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1532:../uvc.c      ****  */
1533:../uvc.c      **** void
1534:../uvc.c      **** CyFxUvcApplnDmaCallback (
1535:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1536:../uvc.c      ****         CyU3PDmaCbType_t      type,
1537:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1538:../uvc.c      ****         )
1539:../uvc.c      **** {
1540:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1541:../uvc.c      **** #if 1
1542:../uvc.c      ****     CyU3PReturnStatus_t status;
1543:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1544:../uvc.c      ****     {
1545:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1546:../uvc.c      ****             {
1547:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1548:../uvc.c      ****                 fb++;
1549:../uvc.c      ****             }
1550:../uvc.c      ****             else
1551:../uvc.c      ****             {
1552:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1553:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1554:../uvc.c      ****                 pb++;
1555:../uvc.c      ****                 pbc = input->buffer_p.count;
1556:../uvc.c      ****                // hitFV = CyTrue;
1557:../uvc.c      **** #if 1   //remove the still flag clearing here
1558:../uvc.c      ****                 if(stiflag == 0x0F){
1559:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1560:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1561:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1562:../uvc.c      ****                 	//stiflag = 0xAA;
1563:../uvc.c      ****                 	stiflag = 0x0;//set back to video
1564:../uvc.c      ****                 }
1565:../uvc.c      **** #endif
1566:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1567:../uvc.c      ****             }
1568:../uvc.c      **** 
1569:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1570:../uvc.c      ****             prodCount++;
1571:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1572:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1573:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1574:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1575:../uvc.c      ****             {
1576:../uvc.c      ****                 prodCount--;
1577:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1578:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1579:../uvc.c      ****             }
1580:../uvc.c      ****     }
1581:../uvc.c      **** #endif
1582:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1583:../uvc.c      ****     {
1584:../uvc.c      ****         consCount++;
1585:../uvc.c      ****         streamingStarted = CyTrue;
1586:../uvc.c      ****     }
1587:../uvc.c      **** }
1588:../uvc.c      **** 
1589:../uvc.c      **** /*
1590:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1591:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1592:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1593:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1594:../uvc.c      ****  * to commit the buffer.
1595:../uvc.c      ****  */
1596:../uvc.c      **** static uint8_t
1597:../uvc.c      **** CyFxUvcAppCommitEOF (
1598:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1599:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1600:../uvc.c      ****         )
1601:../uvc.c      **** {
1602:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1603:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1604:../uvc.c      **** 
1605:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1606:../uvc.c      **** 
1607:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1608:../uvc.c      ****     {
1609:../uvc.c      ****         switch (stateId)
1610:../uvc.c      ****         {
1611:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1612:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1613:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1614:../uvc.c      ****                 break;
1615:../uvc.c      **** 
1616:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1617:../uvc.c      ****                 socket = 0;
1618:../uvc.c      ****                 break;
1619:../uvc.c      **** 
1620:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1621:../uvc.c      ****                 socket = 1;
1622:../uvc.c      ****                 break;
1623:../uvc.c      **** 
1624:../uvc.c      ****             default:
1625:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1626:../uvc.c      ****                 /* Unexpected current state. Return error. */
1627:../uvc.c      ****                 return 1;
1628:../uvc.c      ****         }
1629:../uvc.c      ****     }
1630:../uvc.c      **** 
1631:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1632:../uvc.c      ****     {
1633:../uvc.c      ****         switch (stateId)
1634:../uvc.c      ****         {
1635:../uvc.c      **** #ifndef CAM720
1636:../uvc.c      **** #ifdef GPIFIIM
1637:../uvc.c      ****             case 13:
1638:../uvc.c      ****             case 24:
1639:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1640:../uvc.c      ****                 break;
1641:../uvc.c      **** 
1642:../uvc.c      ****             case 8:
1643:../uvc.c      ****                 socket = 0;
1644:../uvc.c      ****                 break;
1645:../uvc.c      **** 
1646:../uvc.c      ****             case 20:
1647:../uvc.c      ****                 socket = 1;
1648:../uvc.c      ****                 break;
1649:../uvc.c      **** #else
1650:../uvc.c      ****             case 11:
1651:../uvc.c      ****             case 18:
1652:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1653:../uvc.c      ****                 break;
1654:../uvc.c      **** 
1655:../uvc.c      ****             case 8:
1656:../uvc.c      ****                 socket = 0;
1657:../uvc.c      ****                 break;
1658:../uvc.c      **** 
1659:../uvc.c      ****             case 15:
1660:../uvc.c      ****                 socket = 1;
1661:../uvc.c      ****                 break;
1662:../uvc.c      **** #endif
1663:../uvc.c      **** #else
1664:../uvc.c      ****             case 11:
1665:../uvc.c      ****             case 18:
1666:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1667:../uvc.c      ****                 break;
1668:../uvc.c      **** 
1669:../uvc.c      ****             case 8:
1670:../uvc.c      ****                 socket = 0;
1671:../uvc.c      ****                 break;
1672:../uvc.c      **** 
1673:../uvc.c      ****             case 15:
1674:../uvc.c      ****                 socket = 1;
1675:../uvc.c      ****                 break;
1676:../uvc.c      **** 
1677:../uvc.c      **** #endif
1678:../uvc.c      ****              default:
1679:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1680:../uvc.c      ****                 /* Unexpected current state. Return error. */
1681:../uvc.c      ****                return 1;
1682:../uvc.c      ****         }
1683:../uvc.c      ****     }
1684:../uvc.c      **** 
1685:../uvc.c      ****     if (socket != 0xFF)
1686:../uvc.c      ****     {
1687:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1688:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1689:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1690:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1691:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1692:../uvc.c      ****         {
1693:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1694:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1695:../uvc.c      ****         }
1696:../uvc.c      ****     }
1697:../uvc.c      **** 
1698:../uvc.c      ****     return 0;
1699:../uvc.c      **** }
1700:../uvc.c      **** 
1701:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1702:../uvc.c      **** void
1703:../uvc.c      **** CyFxGpifCB (
1704:../uvc.c      ****         CyU3PGpifEventType event,
1705:../uvc.c      ****         uint8_t currentState
1706:../uvc.c      ****         )
1707:../uvc.c      **** {
1708:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1709:../uvc.c      ****     {
1710:../uvc.c      ****         //hitFV = CyTrue;
1711:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1712:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1713:../uvc.c      ****     }
1714:../uvc.c      **** }
1715:../uvc.c      **** 
1716:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1717:../uvc.c      **** static void
1718:../uvc.c      **** CyFxUVCApplnDebugInit (
1719:../uvc.c      ****         void)
1720:../uvc.c      **** {
1721:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1722:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1723:../uvc.c      **** 
1724:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1725:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1726:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1727:../uvc.c      ****     {
1728:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1729:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1730:../uvc.c      ****     }
1731:../uvc.c      **** 
1732:../uvc.c      ****     /* Set UART Configuration */
1733:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1734:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1735:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1736:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1737:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1738:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1739:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1740:../uvc.c      **** 
1741:../uvc.c      ****     /* Set the UART configuration */
1742:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1743:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1744:../uvc.c      ****     {
1745:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1746:../uvc.c      ****     }
1747:../uvc.c      **** 
1748:../uvc.c      ****     /* Set the UART transfer */
1749:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1750:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1751:../uvc.c      ****     {
1752:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1753:../uvc.c      ****     }
1754:../uvc.c      **** 
1755:../uvc.c      ****     /* Initialize the Debug logger module. */
1756:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1757:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1758:../uvc.c      ****     {
1759:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1760:../uvc.c      ****     }
1761:../uvc.c      **** 
1762:../uvc.c      ****     /* Disable log message headers. */
1763:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1764:../uvc.c      **** }
1765:../uvc.c      **** 
1766:../uvc.c      **** /* I2C initialization. */
1767:../uvc.c      **** //static void
1768:../uvc.c      **** void
1769:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1770:../uvc.c      **** {
1771:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1772:../uvc.c      ****     CyU3PReturnStatus_t status;
1773:../uvc.c      **** 
1774:../uvc.c      ****     status = CyU3PI2cInit ();
1775:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1776:../uvc.c      ****     {
1777:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1778:../uvc.c      ****         CyFxAppErrorHandler (status);
1779:../uvc.c      ****     }
1780:../uvc.c      **** 
1781:../uvc.c      ****     /*  Set I2C Configuration */
1782:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1783:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1784:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1785:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1786:../uvc.c      **** 
1787:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1788:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1789:../uvc.c      ****     {
1790:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1791:../uvc.c      ****         CyFxAppErrorHandler (status);
1792:../uvc.c      ****     }
1793:../uvc.c      **** }
1794:../uvc.c      **** 
1795:../uvc.c      **** #ifdef BACKFLOW_DETECT
1796:../uvc.c      **** static void CyFxUvcAppPibCallback (
1797:../uvc.c      ****         CyU3PPibIntrType cbType,
1798:../uvc.c      ****         uint16_t cbArg)
1799:../uvc.c      **** {
1800:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1801:../uvc.c      ****     {
1802:../uvc.c      ****         if (!back_flow_detected)
1803:../uvc.c      ****         {
1804:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1805:../uvc.c      ****             back_flow_detected = 1;
1806:../uvc.c      ****         }
1807:../uvc.c      ****     }
1808:../uvc.c      **** }
1809:../uvc.c      **** #endif
1810:../uvc.c      **** 
1811:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1812:../uvc.c      **** static void
1813:../uvc.c      **** CyFxUvcAppDebugCallback (
1814:../uvc.c      ****         CyU3PDmaChannel   *handle,
1815:../uvc.c      ****         CyU3PDmaCbType_t   type,
1816:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1817:../uvc.c      **** {
1818:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1819:../uvc.c      ****     {
1820:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1821:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1822:../uvc.c      ****     }
1823:../uvc.c      **** }
1824:../uvc.c      **** #endif
1825:../uvc.c      **** 
1826:../uvc.c      **** #if 0
1827:../uvc.c      **** static void CyFxAppIntEpCb(
1828:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1829:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1830:../uvc.c      **** 		uint8_t  ebNum)
1831:../uvc.c      **** 		{
1832:../uvc.c      **** 			//CyBool_t value;
1833:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1834:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1835:../uvc.c      **** 
1836:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1837:../uvc.c      **** 		}
1838:../uvc.c      **** #endif
1839:../uvc.c      **** 
1840:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1841:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1842:../uvc.c      ****    configures the DMA module for the UVC Application */
1843:../uvc.c      **** static void
1844:../uvc.c      **** CyFxUVCApplnInit (void)
1845:../uvc.c      **** {
1846:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1847:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1848:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1849:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1850:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1851:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1852:../uvc.c      **** 
1853:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1854:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1855:../uvc.c      **** 
1856:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1857:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1858:../uvc.c      **** #endif
1859:../uvc.c      **** 
1860:../uvc.c      ****     /* Create UVC event group */
1861:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1862:../uvc.c      ****     if (apiRetStatus != 0)
1863:../uvc.c      ****     {
1864:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1865:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1866:../uvc.c      ****     }
1867:../uvc.c      **** 
1868:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1869:../uvc.c      ****     CyFxUvcAppPTZInit ();
1870:../uvc.c      **** #endif
1871:../uvc.c      **** 
1872:../uvc.c      ****     isUsbConnected = CyFalse;
1873:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1874:../uvc.c      **** 
1875:../uvc.c      ****     /* Init the GPIO module */
1876:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1877:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1878:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1879:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1880:../uvc.c      ****     gpioClock.halfDiv    = 0;
1881:../uvc.c      **** 
1882:../uvc.c      ****     /* Initialize Gpio interface */
1883:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1884:../uvc.c      ****     if (apiRetStatus != 0)
1885:../uvc.c      ****     {
1886:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1887:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1888:../uvc.c      ****     }
1889:../uvc.c      **** 
1890:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1891:../uvc.c      ****      * must use GpioOverride to configure it */
1892:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1893:../uvc.c      ****     if (apiRetStatus != 0)
1894:../uvc.c      ****     {
1895:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1896:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1897:../uvc.c      ****     }
1898:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1899:../uvc.c      ****     if (apiRetStatus != 0)
1900:../uvc.c      ****     {
1901:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1902:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1903:../uvc.c      ****     }
1904:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1905:../uvc.c      ****     if (apiRetStatus != 0)
1906:../uvc.c      ****     {
1907:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1908:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1909:../uvc.c      ****     }
1910:../uvc.c      **** 
1911:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1912:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1913:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1914:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1915:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1916:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1917:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1918:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1919:../uvc.c      ****     {
1920:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1921:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1922:../uvc.c      ****     }
1923:../uvc.c      **** 
1924:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1925:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1926:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1927:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1928:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1929:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1930:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1931:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1932:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1933:../uvc.c      ****     {
1934:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1935:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1936:../uvc.c      ****     }
1937:../uvc.c      **** 
1938:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1939:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1940:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1941:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1942:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1943:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1944:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1945:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1947:../uvc.c      ****     {
1948:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1949:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1950:../uvc.c      ****     }
1951:../uvc.c      **** 
1952:../uvc.c      ****     /* Initialize the P-port. */
1953:../uvc.c      ****     pibclock.clkDiv      = 2;
1954:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1955:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1956:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1957:../uvc.c      **** 
1958:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1959:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1960:../uvc.c      ****     {
1961:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1962:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1963:../uvc.c      ****     }
1964:../uvc.c      **** 
1965:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1966:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1967:../uvc.c      **** 
1968:../uvc.c      **** #ifdef BACKFLOW_DETECT
1969:../uvc.c      ****     back_flow_detected = 0;
1970:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1971:../uvc.c      **** #endif
1972:../uvc.c      **** 
1973:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1974:../uvc.c      ****     SensorReset ();
1975:../uvc.c      ****     SensorInit ();
1976:../uvc.c      **** 
1977:../uvc.c      ****     /* USB initialization. */
1978:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1979:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1980:../uvc.c      ****     {
1981:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1982:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1983:../uvc.c      ****     }
1984:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1985:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1986:../uvc.c      **** 
1987:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1988:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1989:../uvc.c      **** 
1990:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1991:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1992:../uvc.c      **** 
1993:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1994:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1995:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1996:../uvc.c      **** 
1997:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1998:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1999:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2000:../uvc.c      **** 
2001:../uvc.c      ****     /* Configuration descriptors. */
2002:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2003:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2004:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2005:../uvc.c      **** 
2006:../uvc.c      ****     /* String Descriptors */
2007:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2008:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2009:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2010:../uvc.c      **** 
2011:../uvc.c      ****     /* Configure the status interrupt endpoint.
2012:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2013:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2014:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2015:../uvc.c      ****      */
2016:../uvc.c      ****     endPointConfig.enable   = 1;
2017:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2018:../uvc.c      ****     endPointConfig.pcktSize = 64;
2019:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2020:../uvc.c      ****     endPointConfig.streams  = 0;
2021:../uvc.c      ****     endPointConfig.burstLen = 1;
2022:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2023:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2024:../uvc.c      ****     {
2025:../uvc.c      ****         /* Error Handling */
2026:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2027:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2028:../uvc.c      ****     }
2029:../uvc.c      **** 
2030:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2031:../uvc.c      ****     dmaInterConfig.size           = 1024;
2032:../uvc.c      ****     dmaInterConfig.count          = 1;
2033:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2034:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2035:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2036:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2037:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2038:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2039:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2040:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2041:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2042:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2043:../uvc.c      ****             &dmaInterConfig);
2044:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2045:../uvc.c      ****     {
2046:../uvc.c      ****         /* Error handling */
2047:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2048:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2049:../uvc.c      ****     }
2050:../uvc.c      **** 
2051:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2052:../uvc.c      ****     if (glInterStaBuffer == 0)
2053:../uvc.c      ****     {
2054:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2055:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2056:../uvc.c      ****     }
2057:../uvc.c      **** 
2058:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2059:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2060:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2061:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2062:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2063:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2064:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2065:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2066:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2067:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2068:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2069:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2070:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2071:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2072:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2073:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2074:../uvc.c      ****             &dmaMultiConfig);
2075:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2076:../uvc.c      ****     {
2077:../uvc.c      ****         /* Error handling */
2078:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2079:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2080:../uvc.c      ****     }
2081:../uvc.c      **** 
2082:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2083:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2084:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2085:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2086:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2087:../uvc.c      ****      */
2088:../uvc.c      **** 
2089:../uvc.c      ****     endPointConfig.enable   = 1;
2090:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2091:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2092:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2093:../uvc.c      ****     endPointConfig.streams  = 0;
2094:../uvc.c      ****     endPointConfig.burstLen = 1;
2095:../uvc.c      **** 
2096:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2097:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2098:../uvc.c      ****     {
2099:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2100:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2101:../uvc.c      ****     }
2102:../uvc.c      **** 
2103:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2104:../uvc.c      **** 
2105:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2106:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2107:../uvc.c      ****     {
2108:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2109:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2110:../uvc.c      ****     }
2111:../uvc.c      **** 
2112:../uvc.c      ****     channelConfig.size           = 1024;
2113:../uvc.c      ****     channelConfig.count          = 1;
2114:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2115:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2116:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2117:../uvc.c      ****     channelConfig.prodHeader     = 0;
2118:../uvc.c      ****     channelConfig.prodFooter     = 0;
2119:../uvc.c      ****     channelConfig.consHeader     = 0;
2120:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2121:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2122:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2123:../uvc.c      **** 
2124:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2125:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2126:../uvc.c      ****     {
2127:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2128:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2129:../uvc.c      ****     }
2130:../uvc.c      **** 
2131:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2132:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2133:../uvc.c      ****     {
2134:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2135:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2136:../uvc.c      ****     }
2137:../uvc.c      **** 
2138:../uvc.c      ****     channelConfig.size           = 1024;
2139:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2140:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2141:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2142:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2143:../uvc.c      ****     channelConfig.prodHeader     = 0;
2144:../uvc.c      ****     channelConfig.prodFooter     = 0;
2145:../uvc.c      ****     channelConfig.consHeader     = 0;
2146:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2147:../uvc.c      ****     channelConfig.notification   = 0;
2148:../uvc.c      ****     channelConfig.cb             = 0;
2149:../uvc.c      **** 
2150:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2152:../uvc.c      ****     {
2153:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2154:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2155:../uvc.c      ****     }
2156:../uvc.c      **** 
2157:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2158:../uvc.c      ****     if (glDebugRspBuffer == 0)
2159:../uvc.c      ****     {
2160:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2161:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2162:../uvc.c      ****     }
2163:../uvc.c      **** #endif
2164:../uvc.c      **** 
2165:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2166:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2168:../uvc.c      ****     {
2169:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2170:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2171:../uvc.c      ****     }
2172:../uvc.c      **** 
2173:../uvc.c      ****     CyU3PBusyWait(100);
2174:../uvc.c      **** 
2175:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2176:../uvc.c      **** 
2177:../uvc.c      ****     endPointConfig.enable   = 1;
2178:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2179:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2180:../uvc.c      ****     {
2181:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2182:../uvc.c      ****     	endPointConfig.burstLen = 16;
2183:../uvc.c      ****     }
2184:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2185:../uvc.c      ****     {
2186:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2187:../uvc.c      ****     	endPointConfig.burstLen = 1;
2188:../uvc.c      ****     }
2189:../uvc.c      ****     endPointConfig.streams  = 0;
2190:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2191:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2192:../uvc.c      ****     {
2193:../uvc.c      ****         /* Error Handling */
2194:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2195:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2196:../uvc.c      ****     }
2197:../uvc.c      **** #if 0    //for still image method 3 using
2198:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2199:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2200:../uvc.c      ****     {
2201:../uvc.c      ****         /* Error Handling */
2202:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2203:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2204:../uvc.c      ****     }
2205:../uvc.c      **** #endif
2206:../uvc.c      **** 
2207:../uvc.c      **** }
2208:../uvc.c      **** 
2209:../uvc.c      **** /*
2210:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2211:../uvc.c      ****  * streaming session is started.
2212:../uvc.c      ****  */
2213:../uvc.c      **** static void
2214:../uvc.c      **** CyFxUvcAppGpifInit (
2215:../uvc.c      ****         void)
2216:../uvc.c      **** {
2217:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2218:../uvc.c      **** 
2219:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2220:../uvc.c      ****     {
2221:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2222:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2223:../uvc.c      ****     }
2224:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2225:../uvc.c      ****     {
2226:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2227:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2228:../uvc.c      ****     }
2229:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2230:../uvc.c      ****     {
2231:../uvc.c      ****         /* Error Handling */
2232:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2233:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2234:../uvc.c      ****     }
2235:../uvc.c      **** 
2236:../uvc.c      ****     /* Start the state machine from the designated start state. */
2237:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2238:../uvc.c      ****     {
2239:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2240:../uvc.c      ****     }
2241:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2242:../uvc.c      ****     {
2243:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2244:../uvc.c      ****     }
2245:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2246:../uvc.c      ****     {
2247:../uvc.c      ****         /* Error Handling */
2248:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2249:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2250:../uvc.c      ****     }
2251:../uvc.c      **** }
2252:../uvc.c      **** 
2253:../uvc.c      **** /*
2254:../uvc.c      ****  * Entry function for the UVC Application Thread
2255:../uvc.c      ****  */
2256:../uvc.c      **** 
2257:../uvc.c      **** uint32_t posTick;
2258:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2259:../uvc.c      **** 
2260:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 2260 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              		@ link register save eliminated.
  27              	.LVL0:
2261:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2262:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  28              		.loc 1 2262 0
  29 0000 08009FE5 		ldr	r0, .L2
  30              	.LVL1:
  31 0004 2010A0E3 		mov	r1, #32
  32 0008 0020A0E3 		mov	r2, #0
  33 000c FEFFFFEA 		b	_txe_event_flags_set
  34              	.LVL2:
  35              	.L3:
  36              		.align	2
  37              	.L2:
  38 0010 00000000 		.word	.LANCHOR0
  39              		.cfi_endproc
  40              	.LFE17:
  42              		.align	2
  43              		.global	I2cAppThread_Entry
  45              	I2cAppThread_Entry:
  46              	.LFB25:
2263:../uvc.c      **** }
2264:../uvc.c      **** 
2265:../uvc.c      **** 
2266:../uvc.c      **** void
2267:../uvc.c      **** UVCAppThread_Entry (
2268:../uvc.c      ****         uint32_t input)
2269:../uvc.c      **** {
2270:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2271:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2272:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2273:../uvc.c      ****     uint8_t i = 0;
2274:../uvc.c      ****     uint32_t flag;
2275:../uvc.c      ****     uint32_t prinflag = 0;
2276:../uvc.c      **** static uint8_t IMcount = 0;
2277:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2278:../uvc.c      ****     uint32_t frameCnt = 0;
2279:../uvc.c      **** #endif
2280:../uvc.c      ****     /* Initialize the Uart Debug Module */
2281:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2282:../uvc.c      **** 
2283:../uvc.c      ****     /* Initialize the I2C interface */
2284:../uvc.c      **** 	while (i++ < 6){
2285:../uvc.c      **** 		CyU3PThreadSleep(500);
2286:../uvc.c      **** 	}
2287:../uvc.c      **** 
2288:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2289:../uvc.c      **** 
2290:../uvc.c      ****     /* Initialize the UVC Application */
2291:../uvc.c      ****     CyFxUVCApplnInit ();
2292:../uvc.c      **** 
2293:../uvc.c      ****     /*
2294:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2295:../uvc.c      **** 
2296:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2297:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2298:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2299:../uvc.c      **** 
2300:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2301:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2302:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2303:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2304:../uvc.c      **** 
2305:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2306:../uvc.c      ****        of handling the abort request.
2307:../uvc.c      ****      */
2308:../uvc.c      **** 
2309:../uvc.c      ****     for (;;)
2310:../uvc.c      ****     {
2311:../uvc.c      ****         /* Waiting for the Video Stream Event */
2312:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2313:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2314:../uvc.c      ****         {
2315:../uvc.c      **** #if 0 //test for new firmware no video bring up
2316:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2317:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2318:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2319:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2320:../uvc.c      ****             {
2321:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2322:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2323:../uvc.c      ****                 {
2324:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2325:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2326:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2327:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2328:../uvc.c      **** #endif
2329:../uvc.c      **** #endif
2330:../uvc.c      ****                     }
2331:../uvc.c      ****                 else
2332:../uvc.c      ****                 {
2333:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2334:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2335:../uvc.c      **** #ifdef USB_LOWRES_IMG
2336:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2337:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2338:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2339:../uvc.c      **** #endif
2340:../uvc.c      **** #endif
2341:../uvc.c      ****                 }
2342:../uvc.c      **** 
2343:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2344:../uvc.c      ****                 prodCount++;
2345:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2346:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2347:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2348:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2349:../uvc.c      ****                 {
2350:../uvc.c      ****                     prodCount--;
2351:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2352:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2353:../uvc.c      ****                 }
2354:../uvc.c      ****             }
2355:../uvc.c      **** #endif
2356:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2357:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2358:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2359:../uvc.c      ****             {
2360:../uvc.c      ****             	if(0&&(prinflag == 0)){
2361:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2362:../uvc.c      ****             		prinflag = 1;
2363:../uvc.c      ****             	}
2364:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2365:../uvc.c      ****             	fb=0;
2366:../uvc.c      ****             	pb=0;
2367:../uvc.c      ****             	pbc=0;
2368:../uvc.c      ****                 prodCount = 0;
2369:../uvc.c      ****                 consCount = 0;
2370:../uvc.c      ****                 hitFV     = CyFalse;
2371:../uvc.c      **** 
2372:../uvc.c      **** #ifdef BACKFLOW_DETECT
2373:../uvc.c      ****                 back_flow_detected = 0;
2374:../uvc.c      **** #endif
2375:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2376:../uvc.c      ****                 frameCnt++;
2377:../uvc.c      **** #endif
2378:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2379:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2380:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2381:../uvc.c      ****                 //}
2382:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2383:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2384:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2385:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2386:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2387:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2388:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2389:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2390:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2391:../uvc.c      ****                 		stiflag = 0xFF;
2392:../uvc.c      ****                 		IMcount = 0;
2393:../uvc.c      ****                 	}
2394:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2395:../uvc.c      **** 
2396:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2397:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2398:../uvc.c      ****                 		stiflag = 0x0F;
2399:../uvc.c      ****                 		IMcount = 0;
2400:../uvc.c      ****                 		}
2401:../uvc.c      ****                  		/*if(IMcount > 0x4){
2402:../uvc.c      ****                 			stiflag = 0x0F;
2403:../uvc.c      ****                 			IMcount = 0;
2404:../uvc.c      ****                 		}*/
2405:../uvc.c      **** 
2406:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2407:../uvc.c      ****                     //CyU3PThreadSleep(400);
2408:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2409:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2410:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2411:../uvc.c      **** 
2412:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2413:../uvc.c      ****                 	{
2414:../uvc.c      ****                     switch (setRes)
2415:../uvc.c      ****                      {
2416:../uvc.c      ****                  	case 1: //720
2417:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2418:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2419:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0xb, 0x0);
2420:../uvc.c      ****                  		break;
2421:../uvc.c      ****                  	case 2: //960
2422:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2423:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2424:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0x0b, 0x1);
2425:../uvc.c      ****                  		break;
2426:../uvc.c      ****                  	default:
2427:../uvc.c      ****                  		break;
2428:../uvc.c      ****                      }
2429:../uvc.c      ****                     IMcount = 0;
2430:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2431:../uvc.c      ****                 	stiflag = 0x0;
2432:../uvc.c      ****                 	}
2433:../uvc.c      ****                 }
2434:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2435:../uvc.c      ****                 /* Reset the DMA channel. */
2436:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2437:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2438:../uvc.c      ****                 {
2439:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2440:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2441:../uvc.c      ****                 }
2442:../uvc.c      **** 
2443:../uvc.c      ****                 /* Start Channel Immediately */
2444:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2445:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2446:../uvc.c      ****                 {
2447:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2448:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2449:../uvc.c      ****                 }
2450:../uvc.c      **** 
2451:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2452:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2453:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2454:../uvc.c      ****                 }
2455:../uvc.c      ****         }
2456:../uvc.c      ****         else
2457:../uvc.c      ****         {
2458:../uvc.c      ****             /* If we have a stream abort request pending. */
2459:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2460:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2461:../uvc.c      ****             {
2462:../uvc.c      ****                 hitFV     = CyFalse;
2463:../uvc.c      ****                 prodCount = 0;
2464:../uvc.c      ****                 consCount = 0;
2465:../uvc.c      ****                 if(0&&(prinflag == 0)){
2466:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2467:../uvc.c      ****                 	prinflag = 1;
2468:../uvc.c      ****                 }
2469:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2470:../uvc.c      ****                 fb=0;
2471:../uvc.c      ****                 pb=0;
2472:../uvc.c      ****                 pbc=0;
2473:../uvc.c      **** 
2474:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2475:../uvc.c      ****                 {
2476:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2477:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2478:../uvc.c      ****                     {
2479:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2480:../uvc.c      ****                     }
2481:../uvc.c      **** 
2482:../uvc.c      ****                     /* Flush the Endpoint memory */
2483:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2484:../uvc.c      ****                 }
2485:../uvc.c      **** 
2486:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2487:../uvc.c      ****             }
2488:../uvc.c      ****             else
2489:../uvc.c      ****             {
2490:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2491:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2492:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2493:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2494:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2495:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2496:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2497:../uvc.c      ****                 {
2498:../uvc.c      ****                     /* Error handling */
2499:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2500:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2501:../uvc.c      ****                 }
2502:../uvc.c      **** 
2503:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2504:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2505:../uvc.c      ****                 {
2506:../uvc.c      **** #if 0
2507:../uvc.c      ****                 	//for start up of the AF Lens
2508:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2509:../uvc.c      ****                     CyU3PThreadSleep(500);
2510:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2511:../uvc.c      ****                     CyU3PThreadSleep(500);
2512:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2513:../uvc.c      ****                    	CyU3PThreadSleep(300);
2514:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2515:../uvc.c      ****                     CyU3PThreadSleep(500);
2516:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2517:../uvc.c      ****                     CyU3PThreadSleep(500);
2518:../uvc.c      **** #endif
2519:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2520:../uvc.c      ****                     gpif_initialized = CyTrue;
2521:../uvc.c      ****                     CyU3PThreadSleep(200);
2522:../uvc.c      ****                     
2523:../uvc.c      ****                 }
2524:../uvc.c      ****                 else
2525:../uvc.c      ****                 {
2526:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2527:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2528:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2529:../uvc.c      ****                 }
2530:../uvc.c      ****             }
2531:../uvc.c      ****         }
2532:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2533:../uvc.c      **** 
2534:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2535:../uvc.c      ****         CyU3PThreadRelinquish ();
2536:../uvc.c      ****     }
2537:../uvc.c      **** }
2538:../uvc.c      **** 
2539:../uvc.c      **** /*
2540:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2541:../uvc.c      ****  */
2542:../uvc.c      **** 
2543:../uvc.c      **** static void
2544:../uvc.c      **** UVCHandleProcessingUnitRqts (
2545:../uvc.c      ****         void)
2546:../uvc.c      **** {
2547:../uvc.c      ****     uint8_t CtrlAdd;
2548:../uvc.c      **** #ifdef DbgInfo
2549:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2550:../uvc.c      **** #endif
2551:../uvc.c      ****     switch (wValue)
2552:../uvc.c      ****     {
2553:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2554:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2555:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2556:../uvc.c      ****     		break;
2557:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2558:../uvc.c      ****         	CtrlAdd = CtrlParArry[ExtExRefCtlID10/*BrgtCtlID1*/][0]; //Exreference places brightness.
2559:../uvc.c      ****    			ControlHandle(ExtExRefCtlID10/*BrgtCtlID1*/);
2560:../uvc.c      ****     		break;
2561:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2562:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2563:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2564:../uvc.c      **** 			break;
2565:../uvc.c      **** 
2566:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2567:../uvc.c      **** 
2568:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2569:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2570:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2571:../uvc.c      ****       		break;
2572:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2573:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2574:../uvc.c      ****      		ControlHandle(HueCtlID5);
2575:../uvc.c      ****      		break;
2576:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2577:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2578:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2579:../uvc.c      ****           		break;
2580:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2581:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2582:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2583:../uvc.c      ****           		break;
2584:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2585:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2586:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2587:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2588:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2589:../uvc.c      ****     		break;
2590:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2591:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2592:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2593:../uvc.c      ****     		break;
2594:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2595:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2596:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2597:../uvc.c      ****     		break;
2598:../uvc.c      **** 
2599:../uvc.c      ****         default:
2600:../uvc.c      ****             /*
2601:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2602:../uvc.c      ****              * other controls.
2603:../uvc.c      ****              */
2604:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2605:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2606:../uvc.c      ****             break;
2607:../uvc.c      ****     }
2608:../uvc.c      **** }
2609:../uvc.c      **** 
2610:../uvc.c      **** /*
2611:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2612:../uvc.c      ****  */
2613:../uvc.c      **** static void
2614:../uvc.c      **** UVCHandleCameraTerminalRqts (
2615:../uvc.c      ****         void)
2616:../uvc.c      **** {
2617:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2618:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2619:../uvc.c      ****     uint16_t readCount;
2620:../uvc.c      ****     uint16_t zoomVal;
2621:../uvc.c      ****     int32_t  panVal, tiltVal;
2622:../uvc.c      ****     CyBool_t sendData = CyFalse;
2623:../uvc.c      **** #endif
2624:../uvc.c      ****     uint8_t CtrlAdd;
2625:../uvc.c      **** 
2626:../uvc.c      ****     switch (wValue)
2627:../uvc.c      ****     {
2628:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2629:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2630:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2631:../uvc.c      ****     		break;
2632:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2633:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2634:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2635:../uvc.c      ****     		break;
2636:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2637:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2638:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2639:../uvc.c      **** 			break;
2640:../uvc.c      **** 
2641:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2642:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2643:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2644:../uvc.c      **** 			break;
2645:../uvc.c      **** 
2646:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2647:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2648:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2649:../uvc.c      ****       		break;
2650:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2651:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2652:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2653:../uvc.c      ****      		break;
2654:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2655:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2656:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2657:../uvc.c      ****           		break;
2658:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2659:../uvc.c      ****           		break;
2660:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2661:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2662:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2663:../uvc.c      ****      		break;
2664:../uvc.c      **** 
2665:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2666:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2667:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2668:../uvc.c      ****     		break;
2669:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2670:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2671:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2672:../uvc.c      ****     		break;
2673:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2674:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2675:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2676:../uvc.c      ****     		break;
2677:../uvc.c      **** 
2678:../uvc.c      ****         default:
2679:../uvc.c      ****             /*
2680:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2681:../uvc.c      ****              * other controls.
2682:../uvc.c      ****              */
2683:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2684:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2685:../uvc.c      ****             break;
2686:../uvc.c      ****     }
2687:../uvc.c      **** 
2688:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2689:../uvc.c      ****     switch (wValue)
2690:../uvc.c      ****     {
2691:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2692:../uvc.c      ****             switch (bRequest)
2693:../uvc.c      ****             {
2694:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2695:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2696:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2697:../uvc.c      ****                     break;
2698:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2699:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2700:../uvc.c      ****                     sendData = CyTrue;
2701:../uvc.c      ****                     break;
2702:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2703:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2704:../uvc.c      ****                     sendData = CyTrue;
2705:../uvc.c      ****                     break;
2706:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2707:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2708:../uvc.c      ****                     sendData = CyTrue;
2709:../uvc.c      ****                     break;
2710:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2711:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2712:../uvc.c      ****                     sendData = CyTrue;
2713:../uvc.c      ****                     break;
2714:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2715:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2716:../uvc.c      ****                     sendData = CyTrue;
2717:../uvc.c      ****                     break;
2718:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2719:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2720:../uvc.c      ****                             glEp0Buffer, &readCount);
2721:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2722:../uvc.c      ****                     {
2723:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2724:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2725:../uvc.c      ****                     }
2726:../uvc.c      ****                     break;
2727:../uvc.c      ****                 default:
2728:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2729:../uvc.c      ****                     break;
2730:../uvc.c      ****             }
2731:../uvc.c      **** 
2732:../uvc.c      ****             if (sendData)
2733:../uvc.c      ****             {
2734:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2735:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2736:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2737:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2738:../uvc.c      ****             }
2739:../uvc.c      ****             break;
2740:../uvc.c      **** 
2741:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2742:../uvc.c      ****             switch (bRequest)
2743:../uvc.c      ****             {
2744:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2745:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2746:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2747:../uvc.c      ****                     break;
2748:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2749:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2750:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2751:../uvc.c      ****                     sendData = CyTrue;
2752:../uvc.c      ****                     break;
2753:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2754:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2755:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2756:../uvc.c      ****                     sendData = CyTrue;
2757:../uvc.c      ****                     break;
2758:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2759:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2760:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2761:../uvc.c      ****                     sendData = CyTrue;
2762:../uvc.c      ****                     break;
2763:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2764:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2765:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2766:../uvc.c      ****                     sendData = CyTrue;
2767:../uvc.c      ****                     break;
2768:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2769:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2770:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2771:../uvc.c      ****                     sendData = CyTrue;
2772:../uvc.c      ****                     break;
2773:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2774:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2775:../uvc.c      ****                             glEp0Buffer, &readCount);
2776:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2777:../uvc.c      ****                     {
2778:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2779:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2780:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2781:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2782:../uvc.c      **** 
2783:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2784:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2785:../uvc.c      ****                     }
2786:../uvc.c      ****                     break;
2787:../uvc.c      ****                 default:
2788:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2789:../uvc.c      ****                     break;
2790:../uvc.c      ****             }
2791:../uvc.c      **** 
2792:../uvc.c      ****             if (sendData)
2793:../uvc.c      ****             {
2794:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2795:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2796:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2797:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2798:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2799:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2800:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2801:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2802:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2803:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2804:../uvc.c      ****             }
2805:../uvc.c      ****             break;
2806:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2807:../uvc.c      ****         default:
2808:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2809:../uvc.c      ****             break;
2810:../uvc.c      ****     }
2811:../uvc.c      **** #endif
2812:../uvc.c      **** }
2813:../uvc.c      **** 
2814:../uvc.c      **** /*
2815:../uvc.c      ****  * Handler for UVC Interface control requests.
2816:../uvc.c      ****  */
2817:../uvc.c      **** static void
2818:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2819:../uvc.c      ****         void)
2820:../uvc.c      **** {
2821:../uvc.c      **** 
2822:../uvc.c      ****     switch (wValue)
2823:../uvc.c      ****     {
2824:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2825:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2826:../uvc.c      ****     		break;
2827:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2828:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2829:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2830:../uvc.c      ****     		break;
2831:../uvc.c      ****     	default:
2832:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2833:../uvc.c      ****      		break;
2834:../uvc.c      ****     }
2835:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2836:../uvc.c      **** 
2837:../uvc.c      **** }
2838:../uvc.c      **** 
2839:../uvc.c      **** /*
2840:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2841:../uvc.c      ****  */
2842:../uvc.c      **** static void
2843:../uvc.c      **** UVCHandleExtensionUnitRqts (
2844:../uvc.c      ****         void)
2845:../uvc.c      **** {
2846:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2847:../uvc.c      **** 
2848:../uvc.c      **** #ifdef DbgInfo
2849:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2850:../uvc.c      **** #endif
2851:../uvc.c      ****     switch (wValue)
2852:../uvc.c      ****     {
2853:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2854:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2855:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2856:../uvc.c      ****     		break;
2857:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2858:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2859:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2860:../uvc.c      ****     		break;
2861:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2862:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2863:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2864:../uvc.c      ****      		break;
2865:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2866:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2867:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2868:../uvc.c      ****     		break;
2869:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2870:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2871:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2872:../uvc.c      ****     		break;
2873:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2874:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2875:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2876:../uvc.c      ****      		break;
2877:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2878:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2879:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2880:../uvc.c      ****     		break;
2881:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2882:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2883:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2884:../uvc.c      ****     		break;
2885:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2886:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2887:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2888:../uvc.c      ****      		break;
2889:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2890:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2891:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2892:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2893:../uvc.c      ****     		}else/* no support for 1080p camera */
2894:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2895:../uvc.c      ****     		break;
2896:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2897:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2898:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2899:../uvc.c      ****     		break;
2900:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2901:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2902:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2903:../uvc.c      ****     		break;
2904:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2905:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2906:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2907:../uvc.c      ****     		//break;
2908:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2909:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2910:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2911:../uvc.c      ****     		break;
2912:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2913:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2914:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2915:../uvc.c      ****     		break;
2916:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2917:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2918:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2919:../uvc.c      ****     		break;
2920:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2921:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2922:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2923:../uvc.c      ****     		break;
2924:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2925:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2926:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2927:../uvc.c      ****     		break;
2928:../uvc.c      ****    	default:
2929:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2930:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2931:../uvc.c      ****     		break;
2932:../uvc.c      ****     }
2933:../uvc.c      **** 
2934:../uvc.c      **** }
2935:../uvc.c      **** 
2936:../uvc.c      **** /*
2937:../uvc.c      ****  * Handler for the video streaming control requests.
2938:../uvc.c      ****  */
2939:../uvc.c      **** static void
2940:../uvc.c      **** UVCHandleVideoStreamingRqts (
2941:../uvc.c      ****         void)
2942:../uvc.c      **** {
2943:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2944:../uvc.c      ****     uint16_t readCount;
2945:../uvc.c      **** 
2946:../uvc.c      ****     switch (wValue)
2947:../uvc.c      ****     {
2948:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2949:../uvc.c      ****             switch (bRequest)
2950:../uvc.c      ****             {
2951:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2952:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2953:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2954:../uvc.c      ****                     break;
2955:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2956:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2957:../uvc.c      ****                     glEp0Buffer[1] = 0;
2958:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2959:../uvc.c      ****                     break;
2960:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2961:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2962:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2963:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2964:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED)//supports both SS and HS
2965:../uvc.c      ****                     {
2966:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2967:../uvc.c      ****                     }
2968:../uvc.c      ****                     else
2969:../uvc.c      ****                     {
2970:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2971:../uvc.c      ****                     }
2972:../uvc.c      ****                     break;
2973:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2974:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2975:../uvc.c      ****                             glCommitCtrl, &readCount);
2976:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2977:../uvc.c      ****                     {
2978:../uvc.c      ****                         //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
2979:../uvc.c      ****                         {
2980:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2981:../uvc.c      ****                                active data structure. */
2982:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2983:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2984:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2985:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2986:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2987:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2988:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
2989:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
2990:../uvc.c      ****                         }
2991:../uvc.c      ****                     }
2992:../uvc.c      ****                     break;
2993:../uvc.c      ****                 default:
2994:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2995:../uvc.c      ****                     break;
2996:../uvc.c      ****             }
2997:../uvc.c      ****             break;
2998:../uvc.c      **** 
2999:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3000:../uvc.c      ****             switch (bRequest)
3001:../uvc.c      ****             {
3002:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3003:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3004:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3005:../uvc.c      ****                     break;
3006:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3007:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3008:../uvc.c      ****                     glEp0Buffer[1] = 0;
3009:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3010:../uvc.c      ****                     break;
3011:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3012:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED) //support both SS and HS
3013:../uvc.c      ****                     {
3014:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3015:../uvc.c      ****                     }
3016:../uvc.c      ****                     else
3017:../uvc.c      ****                     {
3018:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3019:../uvc.c      ****                     }
3020:../uvc.c      ****                     break;
3021:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3022:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3023:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3024:../uvc.c      ****                        */
3025:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3026:../uvc.c      ****                             glCommitCtrl, &readCount);
3027:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)//supports both SS and HS
3028:../uvc.c      ****                     {
3029:../uvc.c      ****                         if(setRes != glCommitCtrl[3])
3030:../uvc.c      ****                         {
3031:../uvc.c      ****                         switch (glCommitCtrl[3])
3032:../uvc.c      ****                          {
3033:../uvc.c      ****                          	case 1: //720 or 360
3034:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
3035:../uvc.c      ****                          		CyU3PThreadSleep(500);
3036:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
3037:../uvc.c      ****                          		break;
3038:../uvc.c      ****                          	case 2: //960 or 480
3039:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
3040:../uvc.c      ****                          		CyU3PThreadSleep(500);
3041:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
3042:../uvc.c      ****                          		break;
3043:../uvc.c      ****                          	default:
3044:../uvc.c      ****                          		break;
3045:../uvc.c      ****                          }                         
3046:../uvc.c      ****                         setRes = glCommitCtrl[3];
3047:../uvc.c      ****                         }
3048:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3049:../uvc.c      **** 
3050:../uvc.c      **** #if 0
3051:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3052:../uvc.c      ****                         {
3053:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3054:../uvc.c      ****                         }
3055:../uvc.c      ****                         else
3056:../uvc.c      ****                         {
3057:../uvc.c      ****                             SensorScaling_VGA ();
3058:../uvc.c      ****                         }
3059:../uvc.c      **** #endif
3060:../uvc.c      ****                         /* We can start streaming video now. */
3061:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3062:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3063:../uvc.c      ****                         {
3064:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3065:../uvc.c      ****                         }
3066:../uvc.c      ****                     }
3067:../uvc.c      ****                     break;
3068:../uvc.c      **** 
3069:../uvc.c      ****                 default:
3070:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3071:../uvc.c      ****                     break;
3072:../uvc.c      ****             }
3073:../uvc.c      ****             break;
3074:../uvc.c      **** 
3075:../uvc.c      **** /* still image streaming handler */
3076:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3077:../uvc.c      ****                 switch (bRequest)
3078:../uvc.c      ****                 {
3079:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3080:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3081:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3082:../uvc.c      ****                         break;
3083:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3084:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3085:../uvc.c      ****                         glEp0Buffer[1] = 0;
3086:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3087:../uvc.c      ****                         break;
3088:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3089:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3090:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3091:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3092:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3093:../uvc.c      ****                         {
3094:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3095:../uvc.c      ****                         }
3096:../uvc.c      ****                         else
3097:../uvc.c      ****                         {
3098:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3099:../uvc.c      ****                         }
3100:../uvc.c      ****                         break;
3101:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3102:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3103:../uvc.c      ****                                 glCommitCtrl, &readCount);
3104:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3105:../uvc.c      ****                         {
3106:../uvc.c      ****                             //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
3107:../uvc.c      ****                             {
3108:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3109:../uvc.c      ****                                    active data structure. */
3110:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3111:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3112:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3113:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3114:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3115:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3116:../uvc.c      ****                             }
3117:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3118:../uvc.c      ****                         }
3119:../uvc.c      ****                         break;
3120:../uvc.c      ****                     default:
3121:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3122:../uvc.c      ****                         break;
3123:../uvc.c      ****                 }
3124:../uvc.c      ****                 break;
3125:../uvc.c      **** 
3126:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3127:../uvc.c      ****                 switch (bRequest)
3128:../uvc.c      ****                 {
3129:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3130:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3131:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3132:../uvc.c      ****                         break;
3133:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3134:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3135:../uvc.c      ****                         glEp0Buffer[1] = 0;
3136:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3137:../uvc.c      ****                         break;
3138:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3139:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3140:../uvc.c      ****                         {
3141:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3142:../uvc.c      ****                         }
3143:../uvc.c      ****                         else
3144:../uvc.c      ****                         {
3145:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3146:../uvc.c      ****                         }
3147:../uvc.c      ****                         break;
3148:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3149:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3150:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3151:../uvc.c      ****                            */
3152:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3153:../uvc.c      ****                                 glCommitCtrl, &readCount);
3154:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3155:../uvc.c      ****                         {
3156:../uvc.c      ****     #if 0
3157:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3158:../uvc.c      ****                             {
3159:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3160:../uvc.c      ****                             }
3161:../uvc.c      ****                             else
3162:../uvc.c      ****                             {
3163:../uvc.c      ****                                 SensorScaling_VGA ();
3164:../uvc.c      ****                             }
3165:../uvc.c      ****                             /* We can start streaming video now. */
3166:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3167:../uvc.c      **** 
3168:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3169:../uvc.c      ****                             {
3170:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3171:../uvc.c      ****                             }
3172:../uvc.c      **** 	#endif
3173:../uvc.c      **** #if 0 //remove the still resolution set for invendo because the still res. is always the same as th
3174:../uvc.c      ****                            switch (glCommitCtrl[1])
3175:../uvc.c      ****                              {
3176:../uvc.c      ****                              	case 1: //720
3177:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*
3178:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3179:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3180:../uvc.c      ****                              		break;
3181:../uvc.c      ****                             	case 2: //960
3182:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*
3183:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3184:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
3185:../uvc.c      ****                              		break;
3186:../uvc.c      ****                               	default:
3187:../uvc.c      ****                              		break;
3188:../uvc.c      ****                              }
3189:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3190:../uvc.c      **** 
3191:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3192:../uvc.c      **** #endif
3193:../uvc.c      ****                         }
3194:../uvc.c      ****                         break;
3195:../uvc.c      **** 
3196:../uvc.c      ****                     default:
3197:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3198:../uvc.c      ****                         break;
3199:../uvc.c      ****                 }
3200:../uvc.c      ****                 break;
3201:../uvc.c      **** 
3202:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3203:../uvc.c      ****                 switch (bRequest)
3204:../uvc.c      ****                 {
3205:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3206:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3207:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3208:../uvc.c      ****                         break;
3209:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3210:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3211:../uvc.c      ****                         glEp0Buffer[1] = 0;
3212:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3213:../uvc.c      ****                         break;
3214:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3215:../uvc.c      ****                         if (1 || usbSpeed == CY_U3P_SUPER_SPEED)// support both SS and HS
3216:../uvc.c      ****                         {
3217:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3218:../uvc.c      ****                         }
3219:../uvc.c      ****                         else
3220:../uvc.c      ****                         {
3221:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3222:../uvc.c      ****                         }
3223:../uvc.c      ****                         break;
3224:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3225:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3226:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3227:../uvc.c      ****                            */
3228:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3229:../uvc.c      ****                                 glCommitCtrl, &readCount);
3230:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3231:../uvc.c      ****                         {
3232:../uvc.c      ****     #if 1
3233:../uvc.c      ****                             /* We can start still streaming video now. */
3234:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3235:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3236:../uvc.c      ****                             {
3237:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3238:../uvc.c      ****                             }
3239:../uvc.c      ****     #endif
3240:../uvc.c      ****                             else{
3241:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3242:../uvc.c      ****                             //stillcont = 0;
3243:../uvc.c      ****                             }
3244:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3245:../uvc.c      ****                         }else{
3246:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3247:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3248:../uvc.c      ****                         }
3249:../uvc.c      ****                         break;
3250:../uvc.c      **** 
3251:../uvc.c      ****                     default:
3252:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3253:../uvc.c      ****                         break;
3254:../uvc.c      ****                 }
3255:../uvc.c      ****                 break;
3256:../uvc.c      **** 
3257:../uvc.c      ****         default:
3258:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3259:../uvc.c      ****             break;
3260:../uvc.c      ****     }
3261:../uvc.c      **** }
3262:../uvc.c      **** 
3263:../uvc.c      **** /*
3264:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3265:../uvc.c      ****  */
3266:../uvc.c      **** void
3267:../uvc.c      **** UVCAppEP0Thread_Entry (
3268:../uvc.c      ****         uint32_t input)
3269:../uvc.c      **** {
3270:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3271:../uvc.c      ****     uint32_t eventFlag;
3272:../uvc.c      **** 	CyBool_t value;
3273:../uvc.c      **** 	CyBool_t *valueptr = &value;
3274:../uvc.c      **** 
3275:../uvc.c      **** 
3276:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3277:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3278:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3279:../uvc.c      **** 
3280:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3281:../uvc.c      **** #endif
3282:../uvc.c      **** 
3283:../uvc.c      ****     /* for interrupt status test */
3284:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3285:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3286:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3287:../uvc.c      **** 
3288:../uvc.c      ****     for (;;)
3289:../uvc.c      ****     {
3290:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3291:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3292:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3293:../uvc.c      ****         {
3294:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3295:../uvc.c      ****             if (!isUsbConnected)
3296:../uvc.c      ****             {
3297:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3298:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3299:../uvc.c      ****                 {
3300:../uvc.c      ****                     isUsbConnected = CyTrue;
3301:../uvc.c      ****                 }
3302:../uvc.c      ****             }
3303:../uvc.c      **** //#ifdef DbgInfo
3304:../uvc.c      **** #if 0
3305:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3306:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3307:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3308:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3309:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3310:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3311:../uvc.c      **** #endif
3312:../uvc.c      **** //#endif
3313:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3314:../uvc.c      ****             {
3315:../uvc.c      ****             	switch ((wIndex >> 8))
3316:../uvc.c      ****                 {
3317:../uvc.c      **** 
3318:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3319:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3320:../uvc.c      ****                         break;
3321:../uvc.c      **** 
3322:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3323:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3324:../uvc.c      ****                         break;
3325:../uvc.c      **** 
3326:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3327:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3328:../uvc.c      ****                         break;
3329:../uvc.c      **** 
3330:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3331:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3332:../uvc.c      ****                         break;
3333:../uvc.c      **** 
3334:../uvc.c      ****                     default:
3335:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3336:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3337:../uvc.c      ****                         break;
3338:../uvc.c      ****                 }
3339:../uvc.c      ****             }
3340:../uvc.c      **** 
3341:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3342:../uvc.c      ****             {
3343:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3344:../uvc.c      **** 
3345:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3346:../uvc.c      ****                 {
3347:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3348:../uvc.c      ****                 }
3349:../uvc.c      ****                 else
3350:../uvc.c      ****                 {
3351:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3352:../uvc.c      ****                 }
3353:../uvc.c      ****             }
3354:../uvc.c      **** 
3355:../uvc.c      ****             /* handle interrupt status event */
3356:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3357:../uvc.c      ****             {
3358:../uvc.c      **** 
3359:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3360:../uvc.c      ****             	/** preparing interrupt status data **/
3361:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3362:../uvc.c      **** 
3363:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3364:../uvc.c      **** 
3365:../uvc.c      **** #if 1 //for real button
3366:../uvc.c      **** 				if(value&&(!snapButFlag)){
3367:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3368:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3369:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3370:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3371:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3372:../uvc.c      **** 
3373:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3374:../uvc.c      **** 					interStabuf.size   = 1024;
3375:../uvc.c      **** 					interStabuf.status = 0;
3376:../uvc.c      **** 
3377:../uvc.c      **** 					interStabuf.count = 4;
3378:../uvc.c      **** 
3379:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3380:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3381:../uvc.c      **** 
3382:../uvc.c      **** 					/** send a interrupt status data **/
3383:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3384:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3385:../uvc.c      **** 					{
3386:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3387:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3388:../uvc.c      **** 					}
3389:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3390:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3391:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3392:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3393:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3394:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3395:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3396:../uvc.c      **** 
3397:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3398:../uvc.c      **** 					interStabuf.size   = 1024;
3399:../uvc.c      **** 					interStabuf.status = 0;
3400:../uvc.c      **** 
3401:../uvc.c      **** 					interStabuf.count = 4;
3402:../uvc.c      **** 
3403:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3404:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3405:../uvc.c      **** 
3406:../uvc.c      **** 					/** send a interrupt status data **/
3407:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3408:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3409:../uvc.c      **** 					{
3410:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3411:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3412:../uvc.c      **** 					}
3413:../uvc.c      **** 
3414:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3415:../uvc.c      **** 					stiflag = 0xFF;
3416:../uvc.c      **** 				}
3417:../uvc.c      **** #else			//for botton simulation
3418:../uvc.c      **** 				if(snapButFlag == 0x0f){
3419:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3420:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3421:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3422:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3423:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3424:../uvc.c      **** 
3425:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3426:../uvc.c      **** 					interStabuf.size   = 1024;
3427:../uvc.c      **** 					interStabuf.status = 0;
3428:../uvc.c      **** 
3429:../uvc.c      **** 					interStabuf.count = 4;
3430:../uvc.c      **** 
3431:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3432:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3433:../uvc.c      **** 
3434:../uvc.c      **** 					/** send a interrupt status data **/
3435:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3436:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3437:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3438:../uvc.c      **** 					{
3439:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3440:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3441:../uvc.c      **** 					}
3442:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3443:../uvc.c      **** 
3444:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3445:../uvc.c      **** 				}else if(!snapButFlag){
3446:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3447:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3448:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3449:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3450:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3451:../uvc.c      **** 
3452:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3453:../uvc.c      **** 					interStabuf.size   = 1024;
3454:../uvc.c      **** 					interStabuf.status = 0;
3455:../uvc.c      **** 
3456:../uvc.c      **** 					interStabuf.count = 4;
3457:../uvc.c      **** 
3458:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3459:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3460:../uvc.c      **** 
3461:../uvc.c      **** 					/** send a interrupt status data **/
3462:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3463:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3464:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3465:../uvc.c      **** 					{
3466:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3467:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3468:../uvc.c      **** 					}
3469:../uvc.c      **** 
3470:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3471:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3472:../uvc.c      **** 				}
3473:../uvc.c      **** #endif
3474:../uvc.c      **** 
3475:../uvc.c      ****             }
3476:../uvc.c      **** 
3477:../uvc.c      **** 
3478:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3479:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3480:../uvc.c      ****             {
3481:../uvc.c      ****                 /* Get the command buffer */
3482:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3483:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3484:../uvc.c      ****                 {
3485:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3486:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3487:../uvc.c      ****                 }
3488:../uvc.c      **** 
3489:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3490:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3491:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3492:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3493:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3494:../uvc.c      ****                  * register value high byte and register value low byte.
3495:../uvc.c      ****                  */
3496:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3497:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3498:../uvc.c      ****                 {
3499:../uvc.c      ****                     if (dmaInfo.count == 3)
3500:../uvc.c      ****                     {
3501:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3502:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3503:../uvc.c      ****                         dmaInfo.count = 3;
3504:../uvc.c      ****                     }
3505:../uvc.c      ****                     else if (dmaInfo.count == 4)
3506:../uvc.c      ****                     {
3507:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3508:../uvc.c      ****                         {
3509:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3510:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3511:../uvc.c      ****                         }
3512:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3513:../uvc.c      ****                     }
3514:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3515:../uvc.c      ****                 }
3516:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3517:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3518:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3519:../uvc.c      ****                  */
3520:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3521:../uvc.c      ****                 {
3522:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3523:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3524:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3525:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3526:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3527:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3528:../uvc.c      ****                         	break;
3529:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3530:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3531:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3532:../uvc.c      ****                         	break;*/
3533:../uvc.c      ****                     dmaInfo.count -= 2;
3534:../uvc.c      ****                 }
3535:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3536:../uvc.c      ****                 else
3537:../uvc.c      ****                 {
3538:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3539:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3540:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3541:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3542:../uvc.c      ****                 }
3543:../uvc.c      **** 
3544:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3545:../uvc.c      ****                 dmaInfo.size   = 1024;
3546:../uvc.c      ****                 dmaInfo.status = 0;
3547:../uvc.c      **** 
3548:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3549:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3550:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3551:../uvc.c      ****                 {
3552:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3553:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3554:../uvc.c      ****                 }
3555:../uvc.c      **** 
3556:../uvc.c      ****                 /* Wait until the response has gone out. */
3557:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3558:../uvc.c      **** 
3559:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3560:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3561:../uvc.c      ****                 {
3562:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3563:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3564:../uvc.c      ****                 }
3565:../uvc.c      ****             }
3566:../uvc.c      **** #endif
3567:../uvc.c      ****         }
3568:../uvc.c      ****         /* Allow other ready threads to run. */
3569:../uvc.c      ****         CyU3PThreadRelinquish ();
3570:../uvc.c      ****     }
3571:../uvc.c      **** }
3572:../uvc.c      **** 
3573:../uvc.c      **** /*
3574:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3575:../uvc.c      ****  * added 10/2013
3576:../uvc.c      ****  */
3577:../uvc.c      **** /*
3578:../uvc.c      **** static uint8_t timeDelay[64] = {
3579:../uvc.c      **** 
3580:../uvc.c      **** };
3581:../uvc.c      **** */
3582:../uvc.c      **** 
3583:../uvc.c      **** static uint8_t timercount = 0;
3584:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  47              		.loc 1 3584 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 8
  50              		@ frame_needed = 0, uses_anonymous_args = 0
  51              	.LVL3:
  52 0014 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
  53              	.LCFI0:
  54              		.cfi_def_cfa_offset 36
  55              		.cfi_offset 4, -36
  56              		.cfi_offset 5, -32
  57              		.cfi_offset 6, -28
  58              		.cfi_offset 7, -24
  59              		.cfi_offset 8, -20
  60              		.cfi_offset 9, -16
  61              		.cfi_offset 10, -12
  62              		.cfi_offset 11, -8
  63              		.cfi_offset 14, -4
3585:../uvc.c      **** 
3586:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3587:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3588:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3589:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3590:../uvc.c      **** 	VdstateDes *lcStaDes;
3591:../uvc.c      **** 	uint32_t flag = 0;
3592:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3593:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3594:../uvc.c      **** 	uint8_t i, curFlagIdx;
3595:../uvc.c      **** 	uint16_t delaytime;
3596:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3597:../uvc.c      **** 
3598:../uvc.c      **** #if 0 //for test the command queue
3599:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3600:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3601:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3602:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3603:../uvc.c      **** 		lcCmdDes += 1;
3604:../uvc.c      **** 	}
3605:../uvc.c      **** #endif
3606:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3607:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  64              		.loc 1 3607 0
  65 0018 38029FE5 		ldr	r0, .L27
  66              	.LVL4:
3584:../uvc.c      **** 
  67              		.loc 1 3584 0
  68 001c 1CD04DE2 		sub	sp, sp, #28
  69              	.LCFI1:
  70              		.cfi_def_cfa_offset 64
3591:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  71              		.loc 1 3591 0
  72 0020 00C0A0E3 		mov	ip, #0
  73              		.loc 1 3607 0
  74 0024 FA2FA0E3 		mov	r2, #1000
  75 0028 2C30A0E3 		mov	r3, #44
  76 002c 0C10A0E1 		mov	r1, ip
  77 0030 04C08DE5 		str	ip, [sp, #4]
  78 0034 08C08DE5 		str	ip, [sp, #8]
  79 0038 00208DE5 		str	r2, [sp]
  80 003c 0C308DE5 		str	r3, [sp, #12]
  81 0040 14229FE5 		ldr	r2, .L27+4
  82 0044 0B30A0E3 		mov	r3, #11
3591:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  83              		.loc 1 3591 0
  84 0048 14C08DE5 		str	ip, [sp, #20]
  85              	.LVL5:
  86              		.loc 1 3607 0
  87 004c FEFFFFEB 		bl	_txe_timer_create
  88              	.LVL6:
3608:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  89              		.loc 1 3608 0
  90 0050 FEFFFFEB 		bl	_tx_time_get
  91              	.LVL7:
3609:../uvc.c      **** 	CyU3PThreadSleep(50);
3610:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
3611:../uvc.c      **** 
3612:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  92              		.loc 1 3612 0
  93 0054 04529FE5 		ldr	r5, .L27+8
3608:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  94              		.loc 1 3608 0
  95 0058 04129FE5 		ldr	r1, .L27+12
  96 005c 0020A0E1 		mov	r2, r0
  97 0060 0400A0E3 		mov	r0, #4
  98 0064 FEFFFFEB 		bl	CyU3PDebugPrint
  99              	.LVL8:
3609:../uvc.c      **** 	CyU3PThreadSleep(50);
 100              		.loc 1 3609 0
 101 0068 3200A0E3 		mov	r0, #50
 102 006c FEFFFFEB 		bl	_tx_thread_sleep
 103              	.LVL9:
3610:../uvc.c      **** 
 104              		.loc 1 3610 0
 105 0070 E0019FE5 		ldr	r0, .L27
 106 0074 FEFFFFEB 		bl	_txe_timer_activate
 107              	.LVL10:
 108              		.loc 1 3612 0
 109 0078 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 110 007c 000052E3 		cmp	r2, #0
 111 0080 0300001A 		bne	.L5
 112              	.L6:
3613:../uvc.c      ****         /* Allow other ready threads to run. */
3614:../uvc.c      **** 
3615:../uvc.c      ****         CyU3PThreadRelinquish ();
 113              		.loc 1 3615 0
 114 0084 FEFFFFEB 		bl	_txe_thread_relinquish
 115              	.LVL11:
3612:../uvc.c      ****         /* Allow other ready threads to run. */
 116              		.loc 1 3612 0
 117 0088 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 118 008c 000052E3 		cmp	r2, #0
 119 0090 FBFFFF0A 		beq	.L6
 120              	.L5:
3616:../uvc.c      **** 	}
3617:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 121              		.loc 1 3617 0
 122 0094 103095E5 		ldr	r3, [r5, #16]
 123 0098 0400A0E3 		mov	r0, #4
 124 009c 3C3093E5 		ldr	r3, [r3, #60]
 125 00a0 C0119FE5 		ldr	r1, .L27+16
 126 00a4 FEFFFFEB 		bl	CyU3PDebugPrint
 127              	.LVL12:
 128 00a8 BC819FE5 		ldr	r8, .L27+20
 129 00ac BC619FE5 		ldr	r6, .L27+24
 130 00b0 BCA19FE5 		ldr	r10, .L27+28
3618:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3619:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3620:../uvc.c      **** 	//CyU3PThreadSleep(100);
3621:../uvc.c      **** 	//SetCurCmd();
3622:../uvc.c      **** 	/*********** the loop of the thread ***********/
3623:../uvc.c      **** 	for(;;){
3624:../uvc.c      **** 
3625:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 131              		.loc 1 3625 0
 132 00b4 0890A0E1 		mov	r9, r8
 133 00b8 0070E0E3 		mvn	r7, #0
 134              	.L21:
 135 00bc 14308DE2 		add	r3, sp, #20
 136 00c0 0320A0E3 		mov	r2, #3
 137 00c4 2010A0E3 		mov	r1, #32
 138 00c8 00708DE5 		str	r7, [sp]
 139 00cc 98019FE5 		ldr	r0, .L27+20
 140 00d0 FEFFFFEB 		bl	_txe_event_flags_get
 141              	.LVL13:
3626:../uvc.c      **** 		//CyU3PDebugPrint (4, "In I2C loop timercounter %d cmdFlag 0x%x\r\n", timercount, cmdFlag);
3627:../uvc.c      **** /*  // for test GPIO output
3628:../uvc.c      **** 		if(trigger)
3629:../uvc.c      **** 		{
3630:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3631:../uvc.c      **** 			{
3632:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3633:../uvc.c      **** 			}
3634:../uvc.c      **** 
3635:../uvc.c      **** 		}else{
3636:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3637:../uvc.c      **** 			{
3638:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3639:../uvc.c      **** 			}
3640:../uvc.c      **** 
3641:../uvc.c      **** 		}
3642:../uvc.c      **** */
3643:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 142              		.loc 1 3643 0
 143 00d4 0010E0E3 		mvn	r1, #0
 144 00d8 1C0096E5 		ldr	r0, [r6, #28]
 145 00dc FEFFFFEB 		bl	_txe_mutex_get
 146              	.LVL14:
3644:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3645:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3646:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3647:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3648:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3649:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3650:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3651:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3652:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3653:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3654:../uvc.c      **** #endif
3655:../uvc.c      **** 				}
3656:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3657:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3658:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3659:../uvc.c      **** 			}
3660:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 147              		.loc 1 3660 0
 148 00e0 1C0096E5 		ldr	r0, [r6, #28]
 149 00e4 FEFFFFEB 		bl	_txe_mutex_put
 150              	.LVL15:
3661:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3662:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 151              		.loc 1 3662 0
 152 00e8 1C0095E5 		ldr	r0, [r5, #28]
 153 00ec 0010E0E3 		mvn	r1, #0
 154 00f0 FEFFFFEB 		bl	_txe_mutex_get
 155              	.LVL16:
3663:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 156              		.loc 1 3663 0
 157 00f4 104095E5 		ldr	r4, [r5, #16]
 158              	.LVL17:
3664:../uvc.c      **** 
3665:../uvc.c      **** 				/*
3666:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3667:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3668:../uvc.c      **** 				*/
3669:../uvc.c      **** 
3670:../uvc.c      **** 				/* find a available command */
3671:../uvc.c      **** 				i = 0;
3672:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 159              		.loc 1 3672 0
 160 00f8 3C3094E5 		ldr	r3, [r4, #60]
 161 00fc 000053E3 		cmp	r3, #0
 162 0100 0900001A 		bne	.L7
 163 0104 40B0A0E3 		mov	fp, #64
 164 0108 010000EA 		b	.L10
 165              	.LVL18:
 166              	.L8:
 167              		.loc 1 3672 0 is_stmt 0 discriminator 2
 168 010c FFB013E2 		ands	fp, r3, #255
 169 0110 2D00000A 		beq	.L25
 170              	.L10:
3673:../uvc.c      **** 					i++;
3674:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 171              		.loc 1 3674 0 is_stmt 1
 172 0114 344094E5 		ldr	r4, [r4, #52]
 173              	.LVL19:
 174 0118 01304BE2 		sub	r3, fp, #1
3672:../uvc.c      **** 					i++;
 175              		.loc 1 3672 0
 176 011c 3C2094E5 		ldr	r2, [r4, #60]
 177 0120 000052E3 		cmp	r2, #0
 178 0124 F8FFFF0A 		beq	.L8
 179 0128 104085E5 		str	r4, [r5, #16]
 180              	.L7:
 181              	.LVL20:
 182 012c 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3675:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3676:../uvc.c      **** 				}
3677:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3678:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3679:../uvc.c      **** 					i = lcCmdDes->curNum;
3680:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3681:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3682:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3683:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3684:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 183              		.loc 1 3684 0
 184 0130 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 185 0134 833083E0 		add	r3, r3, r3, asl #1
 186 0138 833084E0 		add	r3, r4, r3, asl #1
 187 013c 20C04CE2 		sub	ip, ip, #32
3680:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 188              		.loc 1 3680 0
 189 0140 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 190              	.LVL21:
3681:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 191              		.loc 1 3681 0
 192 0144 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 193              	.LVL22:
3682:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 194              		.loc 1 3682 0
 195 0148 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 196              	.LVL23:
3683:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 197              		.loc 1 3683 0
 198 014c B8B0D3E1 		ldrh	fp, [r3, #8]
 199              	.LVL24:
 200              		.loc 1 3684 0
 201 0150 03005CE3 		cmp	ip, #3
 202 0154 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 203 0158 3B0000EA 		b	.L16
 204              	.L23:
 205 015c 6C010000 		.word	.L13
 206 0160 6C010000 		.word	.L13
 207 0164 BC010000 		.word	.L15
 208 0168 BC010000 		.word	.L15
 209              	.L13:
3685:../uvc.c      **** 						case 0x20:
3686:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3687:../uvc.c      **** 							delaytime = 500;
3688:../uvc.c      **** 							break;
3689:../uvc.c      **** 						case 0x21:
3690:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 210              		.loc 1 3690 0
 211 016c 5230A0E3 		mov	r3, #82
 212              	.LVL25:
 213 0170 FEFFFFEB 		bl	SensorSetIrisControl
 214              	.LVL26:
3691:../uvc.c      **** 							delaytime = 500;
3692:../uvc.c      **** 							break;
 215              		.loc 1 3692 0
 216 0174 7D1FA0E3 		mov	r1, #500
 217              	.LVL27:
 218              	.L12:
3693:../uvc.c      **** 						case 0x22:
3694:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3695:../uvc.c      **** 							delaytime = 300;
3696:../uvc.c      **** 							break;
3697:../uvc.c      **** 						case 0x23:
3698:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3699:../uvc.c      **** 							delaytime = 300;
3700:../uvc.c      **** 							break;
3701:../uvc.c      **** 						default:
3702:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3703:../uvc.c      **** 							break;
3704:../uvc.c      **** 					}
3705:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3706:../uvc.c      **** 					/** timer's ticket modify **/
3707:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 219              		.loc 1 3707 0
 220 0178 0020A0E3 		mov	r2, #0
 221 017c D4009FE5 		ldr	r0, .L27
 222 0180 FEFFFFEB 		bl	_txe_timer_change
 223              	.LVL28:
3708:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 224              		.loc 1 3708 0
 225 0184 CC009FE5 		ldr	r0, .L27
 226 0188 FEFFFFEB 		bl	_txe_timer_activate
 227              	.LVL29:
3709:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3710:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3711:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3712:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3713:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3714:../uvc.c      **** #endif
3715:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 228              		.loc 1 3715 0
 229 018c 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 230 0190 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 231 0194 030052E1 		cmp	r2, r3
 232 0198 1D00000A 		beq	.L26
3716:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3717:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3718:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3719:../uvc.c      **** 						}else{
3720:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3721:../uvc.c      **** 						}
3722:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3723:../uvc.c      **** 					}else{
3724:../uvc.c      **** 						lcCmdDes->curNum ++;
 233              		.loc 1 3724 0
 234 019c 013083E2 		add	r3, r3, #1
3725:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 235              		.loc 1 3725 0
 236 01a0 0F20A0E3 		mov	r2, #15
3724:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 237              		.loc 1 3724 0
 238 01a4 0130C4E5 		strb	r3, [r4, #1]
 239              		.loc 1 3725 0
 240 01a8 3C2084E5 		str	r2, [r4, #60]
 241              	.LVL30:
 242              	.L20:
3726:../uvc.c      **** 					}
3727:../uvc.c      **** 				}else{
3728:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0); //the free I2C commands timer pace (no setting comman
3729:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3730:../uvc.c      **** 					//CyU3PDebugPrint (4, "I2Ctimer counter %d", timercount);
3731:../uvc.c      **** 					if(timercount >= 3){
3732:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
3733:../uvc.c      **** 							curFlag[curFlagIdx] = 0;
3734:../uvc.c      **** 						}
3735:../uvc.c      **** 							timercount = 0;
3736:../uvc.c      **** 
3737:../uvc.c      **** 					}else{
3738:../uvc.c      **** 							timercount++;
3739:../uvc.c      **** 					}
3740:../uvc.c      **** 				}
3741:../uvc.c      **** 			}
3742:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 243              		.loc 1 3742 0
 244 01ac 1C0095E5 		ldr	r0, [r5, #28]
 245 01b0 FEFFFFEB 		bl	_txe_mutex_put
 246              	.LVL31:
3743:../uvc.c      **** /*
3744:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3745:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3746:../uvc.c      **** */
3747:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3748:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3749:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3750:../uvc.c      **** #endif
3751:../uvc.c      **** 
3752:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3753:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3754:../uvc.c      **** #if 0
3755:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3756:../uvc.c      **** 
3757:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3758:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3759:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3760:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3761:../uvc.c      **** 			    i = 0;
3762:../uvc.c      **** 				 switch(cmdCopyIdx)
3763:../uvc.c      **** 				 {
3764:../uvc.c      **** 					 case BrgtCtlID1:
3765:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3766:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3767:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3768:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3769:../uvc.c      **** 							 i++;
3770:../uvc.c      **** 						 }
3771:../uvc.c      **** 						 else{
3772:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3773:../uvc.c      **** 						 }
3774:../uvc.c      **** 
3775:../uvc.c      **** 						 CyU3PBusyWait(500);
3776:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3777:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3778:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3779:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3780:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3781:../uvc.c      **** 						 }
3782:../uvc.c      **** 						 else{
3783:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3784:../uvc.c      **** 						 }
3785:../uvc.c      **** 						 break;
3786:../uvc.c      **** 					 case HueCtlID5:
3787:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3788:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3789:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3790:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3791:../uvc.c      **** 						 }
3792:../uvc.c      **** 						 else{
3793:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3794:../uvc.c      **** 						 }
3795:../uvc.c      **** 						 break;
3796:../uvc.c      **** 					 case SaturCtlID6:
3797:../uvc.c      **** 					 case WBTLevCtlID10:
3798:../uvc.c      **** 					 default:
3799:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3800:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3801:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3802:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3803:../uvc.c      **** 						 }
3804:../uvc.c      **** 						 else{
3805:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3806:../uvc.c      **** 						 }
3807:../uvc.c      **** 						 break;
3808:../uvc.c      **** 				 }
3809:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3810:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3811:../uvc.c      **** 			}
3812:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3813:../uvc.c      **** #endif
3814:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3815:../uvc.c      **** 		/* Allow other ready threads to run. */
3816:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3817:../uvc.c      **** 			CyU3PThreadRelinquish ();
 247              		.loc 1 3817 0
 248 01b4 FEFFFFEB 		bl	_txe_thread_relinquish
 249              	.LVL32:
3818:../uvc.c      **** 		}
 250              		.loc 1 3818 0
 251 01b8 BFFFFFEA 		b	.L21
 252              	.LVL33:
 253              	.L15:
3698:../uvc.c      **** 							delaytime = 300;
 254              		.loc 1 3698 0
 255 01bc 8230A0E3 		mov	r3, #130
 256              	.LVL34:
 257 01c0 FEFFFFEB 		bl	SensorSetIrisControl
 258              	.LVL35:
3700:../uvc.c      **** 						default:
 259              		.loc 1 3700 0
 260 01c4 4B1FA0E3 		mov	r1, #300
 261 01c8 EAFFFFEA 		b	.L12
 262              	.LVL36:
 263              	.L25:
3728:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 264              		.loc 1 3728 0
 265 01cc 0B20A0E1 		mov	r2, fp
 266 01d0 FA1FA0E3 		mov	r1, #1000
 267 01d4 7C009FE5 		ldr	r0, .L27
 268 01d8 104085E5 		str	r4, [r5, #16]
 269 01dc FEFFFFEB 		bl	_txe_timer_change
 270              	.LVL37:
3729:../uvc.c      **** 					//CyU3PDebugPrint (4, "I2Ctimer counter %d", timercount);
 271              		.loc 1 3729 0
 272 01e0 70009FE5 		ldr	r0, .L27
 273 01e4 FEFFFFEB 		bl	_txe_timer_activate
 274              	.LVL38:
3731:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
 275              		.loc 1 3731 0
 276 01e8 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 277 01ec 020052E3 		cmp	r2, #2
3738:../uvc.c      **** 					}
 278              		.loc 1 3738 0
 279 01f0 01208292 		addls	r2, r2, #1
 280 01f4 2820C995 		strlsb	r2, [r9, #40]
3731:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
 281              		.loc 1 3731 0
 282 01f8 EBFFFF9A 		bls	.L20
 283 01fc 74009FE5 		ldr	r0, .L27+32
 284 0200 0B10A0E1 		mov	r1, fp
 285 0204 4020A0E3 		mov	r2, #64
 286 0208 FEFFFFEB 		bl	memset
 287              	.LVL39:
3735:../uvc.c      **** 
 288              		.loc 1 3735 0
 289 020c 28B0C9E5 		strb	fp, [r9, #40]
 290 0210 E5FFFFEA 		b	.L20
 291              	.LVL40:
 292              	.L26:
3717:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 293              		.loc 1 3717 0
 294 0214 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
3716:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 295              		.loc 1 3716 0
 296 0218 0020A0E3 		mov	r2, #0
3717:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 297              		.loc 1 3717 0
 298 021c 230053E3 		cmp	r3, #35
3718:../uvc.c      **** 						}else{
 299              		.loc 1 3718 0
 300 0220 20304382 		subhi	r3, r3, #32
 301 0224 83308380 		addhi	r3, r3, r3, asl #1
3720:../uvc.c      **** 						}
 302              		.loc 1 3720 0
 303 0228 83308390 		addls	r3, r3, r3, asl #1
3718:../uvc.c      **** 						}else{
 304              		.loc 1 3718 0
 305 022c 83318A80 		addhi	r3, r10, r3, asl #3
3720:../uvc.c      **** 						}
 306              		.loc 1 3720 0
 307 0230 83318A90 		addls	r3, r10, r3, asl #3
3718:../uvc.c      **** 						}else{
 308              		.loc 1 3718 0
 309 0234 1020C385 		strhib	r2, [r3, #16]
3720:../uvc.c      **** 						}
 310              		.loc 1 3720 0
 311 0238 9021C395 		strlsb	r2, [r3, #400]
3722:../uvc.c      **** 					}else{
 312              		.loc 1 3722 0
 313 023c 343094E5 		ldr	r3, [r4, #52]
3716:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 314              		.loc 1 3716 0
 315 0240 3C2084E5 		str	r2, [r4, #60]
3722:../uvc.c      **** 					}else{
 316              		.loc 1 3722 0
 317 0244 103085E5 		str	r3, [r5, #16]
 318 0248 D7FFFFEA 		b	.L20
 319              	.LVL41:
 320              	.L16:
3702:../uvc.c      **** 							break;
 321              		.loc 1 3702 0
 322 024c FEFFFFEB 		bl	SensorSetControl
 323              	.LVL42:
 324 0250 0B10A0E1 		mov	r1, fp
3703:../uvc.c      **** 					}
 325              		.loc 1 3703 0
 326 0254 C7FFFFEA 		b	.L12
 327              	.L28:
 328              		.align	2
 329              	.L27:
 330 0258 00000000 		.word	I2CCmdTimer
 331 025c 00000000 		.word	I2CCmdCb
 332 0260 00000000 		.word	cmdQu
 333 0264 00000000 		.word	.LC0
 334 0268 14000000 		.word	.LC1
 335 026c 00000000 		.word	.LANCHOR0
 336 0270 00000000 		.word	statQu
 337 0274 00000000 		.word	.LANCHOR1
 338 0278 2C000000 		.word	.LANCHOR0+44
 339              		.cfi_endproc
 340              	.LFE25:
 342              		.align	2
 343              		.global	CyFxUvcApplnDmaCallback
 345              	CyFxUvcApplnDmaCallback:
 346              	.LFB10:
1539:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 347              		.loc 1 1539 0
 348              		.cfi_startproc
 349              		@ args = 0, pretend = 0, frame = 0
 350              		@ frame_needed = 0, uses_anonymous_args = 0
 351              	.LVL43:
1543:../uvc.c      ****     {
 352              		.loc 1 1543 0
 353 027c 080051E3 		cmp	r1, #8
1539:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 354              		.loc 1 1539 0
 355 0280 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 356              	.LCFI2:
 357              		.cfi_def_cfa_offset 20
 358              		.cfi_offset 4, -20
 359              		.cfi_offset 5, -16
 360              		.cfi_offset 6, -12
 361              		.cfi_offset 7, -8
 362              		.cfi_offset 14, -4
 363 0284 0250A0E1 		mov	r5, r2
 364 0288 0CD04DE2 		sub	sp, sp, #12
 365              	.LCFI3:
 366              		.cfi_def_cfa_offset 32
1543:../uvc.c      ****     {
 367              		.loc 1 1543 0
 368 028c 0B00000A 		beq	.L40
1582:../uvc.c      ****     {
 369              		.loc 1 1582 0
 370 0290 100051E3 		cmp	r1, #16
 371 0294 0700001A 		bne	.L29
1584:../uvc.c      ****         streamingStarted = CyTrue;
 372              		.loc 1 1584 0
 373 0298 74319FE5 		ldr	r3, .L43
1585:../uvc.c      ****     }
 374              		.loc 1 1585 0
 375 029c 0110A0E3 		mov	r1, #1
 376              	.LVL44:
1584:../uvc.c      ****         streamingStarted = CyTrue;
 377              		.loc 1 1584 0
 378 02a0 BE27D3E1 		ldrh	r2, [r3, #126]
 379              	.LVL45:
1585:../uvc.c      ****     }
 380              		.loc 1 1585 0
 381 02a4 801083E5 		str	r1, [r3, #128]
1584:../uvc.c      ****         streamingStarted = CyTrue;
 382              		.loc 1 1584 0
 383 02a8 012082E0 		add	r2, r2, r1
 384 02ac 0228A0E1 		mov	r2, r2, asl #16
 385 02b0 2228A0E1 		mov	r2, r2, lsr #16
 386 02b4 BE27C3E1 		strh	r2, [r3, #126]	@ movhi
 387              	.LVL46:
 388              	.L29:
1587:../uvc.c      **** 
 389              		.loc 1 1587 0
 390 02b8 0CD08DE2 		add	sp, sp, #12
 391              		@ sp needed
 392 02bc F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 393              	.LVL47:
 394              	.L40:
1545:../uvc.c      ****             {
 395              		.loc 1 1545 0
 396 02c0 50319FE5 		ldr	r3, .L43+4
 397 02c4 B420D2E1 		ldrh	r2, [r2, #4]
 398              	.LVL48:
1547:../uvc.c      ****                 fb++;
 399              		.loc 1 1547 0
 400 02c8 006095E5 		ldr	r6, [r5]
1545:../uvc.c      ****             {
 401              		.loc 1 1545 0
 402 02cc 030052E1 		cmp	r2, r3
 403 02d0 3300000A 		beq	.L41
 404              	.LVL49:
 405              	.LBB6:
 406              	.LBB7:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 407              		.loc 1 1283 0
 408 02d4 40719FE5 		ldr	r7, .L43+8
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 409              		.loc 1 1282 0
 410 02d8 0010E0E3 		mvn	r1, #0
 411              	.LVL50:
 412 02dc 3C019FE5 		ldr	r0, .L43+12
 413              	.LVL51:
 414 02e0 FEFFFFEB 		bl	_txe_mutex_get
 415              	.LVL52:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 416              		.loc 1 1283 0
 417 02e4 121D87E2 		add	r1, r7, #1152
 418 02e8 0C20A0E3 		mov	r2, #12
 419 02ec 0C0046E2 		sub	r0, r6, #12
 420              	.LVL53:
 421 02f0 FEFFFFEB 		bl	CyU3PMemCopy
 422              	.LVL54:
1284:../uvc.c      **** 
 423              		.loc 1 1284 0
 424 02f4 24019FE5 		ldr	r0, .L43+12
 425 02f8 FEFFFFEB 		bl	_txe_mutex_put
 426              	.LVL55:
1289:../uvc.c      ****     }
 427              		.loc 1 1289 0
 428 02fc 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 429              	.LBE7:
 430              	.LBE6:
1554:../uvc.c      ****                 pbc = input->buffer_p.count;
 431              		.loc 1 1554 0
 432 0300 0C419FE5 		ldr	r4, .L43
 433              	.LBB9:
 434              	.LBB8:
1289:../uvc.c      ****     }
 435              		.loc 1 1289 0
 436 0304 023083E3 		orr	r3, r3, #2
 437 0308 0B3046E5 		strb	r3, [r6, #-11]
 438              	.LBE8:
 439              	.LBE9:
1558:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 440              		.loc 1 1558 0
 441 030c 741094E5 		ldr	r1, [r4, #116]
1554:../uvc.c      ****                 pbc = input->buffer_p.count;
 442              		.loc 1 1554 0
 443 0310 BE26D4E1 		ldrh	r2, [r4, #110]
1555:../uvc.c      ****                // hitFV = CyTrue;
 444              		.loc 1 1555 0
 445 0314 B430D5E1 		ldrh	r3, [r5, #4]
1554:../uvc.c      ****                 pbc = input->buffer_p.count;
 446              		.loc 1 1554 0
 447 0318 012082E2 		add	r2, r2, #1
1558:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 448              		.loc 1 1558 0
 449 031c 0F0051E3 		cmp	r1, #15
1554:../uvc.c      ****                 pbc = input->buffer_p.count;
 450              		.loc 1 1554 0
 451 0320 BE26C4E1 		strh	r2, [r4, #110]	@ movhi
1555:../uvc.c      ****                // hitFV = CyTrue;
 452              		.loc 1 1555 0
 453 0324 B037C4E1 		strh	r3, [r4, #112]	@ movhi
1558:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 454              		.loc 1 1558 0
 455 0328 2D00000A 		beq	.L42
 456              	.L33:
1566:../uvc.c      ****             }
 457              		.loc 1 1566 0
 458 032c 0120A0E3 		mov	r2, #1
 459 0330 782084E5 		str	r2, [r4, #120]
 460              	.LVL56:
 461              	.L32:
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 462              		.loc 1 1570 0
 463 0334 BC27D4E1 		ldrh	r2, [r4, #124]
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 464              		.loc 1 1571 0
 465 0338 0C1083E2 		add	r1, r3, #12
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 466              		.loc 1 1570 0
 467 033c 013082E2 		add	r3, r2, #1
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 468              		.loc 1 1571 0
 469 0340 0118A0E1 		mov	r1, r1, asl #16
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 470              		.loc 1 1570 0
 471 0344 0338A0E1 		mov	r3, r3, asl #16
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 472              		.loc 1 1571 0
 473 0348 2118A0E1 		mov	r1, r1, lsr #16
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 474              		.loc 1 1570 0
 475 034c 2338A0E1 		mov	r3, r3, lsr #16
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 476              		.loc 1 1571 0
 477 0350 0020A0E3 		mov	r2, #0
 478 0354 C8009FE5 		ldr	r0, .L43+16
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 479              		.loc 1 1570 0
 480 0358 BC37C4E1 		strh	r3, [r4, #124]	@ movhi
1571:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 481              		.loc 1 1571 0
 482 035c FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 483              	.LVL57:
1570:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 484              		.loc 1 1570 0
 485 0360 AC109FE5 		ldr	r1, .L43
1574:../uvc.c      ****             {
 486              		.loc 1 1574 0
 487 0364 002050E2 		subs	r2, r0, #0
 488 0368 D2FFFF0A 		beq	.L29
1576:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 489              		.loc 1 1576 0
 490 036c BC07D1E1 		ldrh	r0, [r1, #124]
 491              	.LVL58:
1577:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 492              		.loc 1 1577 0
 493 0370 B430D5E1 		ldrh	r3, [r5, #4]
1576:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 494              		.loc 1 1576 0
 495 0374 010040E2 		sub	r0, r0, #1
 496 0378 0008A0E1 		mov	r0, r0, asl #16
 497 037c 2008A0E1 		mov	r0, r0, lsr #16
 498 0380 BC07C1E1 		strh	r0, [r1, #124]	@ movhi
1577:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 499              		.loc 1 1577 0
 500 0384 BC07D1E1 		ldrh	r0, [r1, #124]
 501 0388 BE17D1E1 		ldrh	r1, [r1, #126]
 502 038c 001061E0 		rsb	r1, r1, r0
 503 0390 00108DE5 		str	r1, [sp]
 504 0394 0400A0E3 		mov	r0, #4
 505 0398 88109FE5 		ldr	r1, .L43+20
 506 039c FEFFFFEB 		bl	CyU3PDebugPrint
 507              	.LVL59:
 508 03a0 C4FFFFEA 		b	.L29
 509              	.LVL60:
 510              	.L41:
 511              	.LBB10:
 512              	.LBB11:
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 513              		.loc 1 1282 0
 514 03a4 0010E0E3 		mvn	r1, #0
 515              	.LVL61:
 516              	.LBE11:
 517              	.LBE10:
1548:../uvc.c      ****             }
 518              		.loc 1 1548 0
 519 03a8 64409FE5 		ldr	r4, .L43
 520              	.LBB14:
 521              	.LBB12:
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 522              		.loc 1 1282 0
 523 03ac 6C009FE5 		ldr	r0, .L43+12
 524              	.LVL62:
 525 03b0 FEFFFFEB 		bl	_txe_mutex_get
 526              	.LVL63:
 527              	.LBE12:
 528              	.LBE14:
1547:../uvc.c      ****                 fb++;
 529              		.loc 1 1547 0
 530 03b4 0C6046E2 		sub	r6, r6, #12
 531              	.LVL64:
 532              	.LBB15:
 533              	.LBB13:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 534              		.loc 1 1283 0
 535 03b8 0C20A0E3 		mov	r2, #12
 536 03bc 0600A0E1 		mov	r0, r6
 537 03c0 64109FE5 		ldr	r1, .L43+24
 538 03c4 FEFFFFEB 		bl	CyU3PMemCopy
 539              	.LVL65:
1284:../uvc.c      **** 
 540              		.loc 1 1284 0
 541 03c8 50009FE5 		ldr	r0, .L43+12
 542 03cc FEFFFFEB 		bl	_txe_mutex_put
 543              	.LVL66:
 544              	.LBE13:
 545              	.LBE15:
1548:../uvc.c      ****             }
 546              		.loc 1 1548 0
 547 03d0 BC26D4E1 		ldrh	r2, [r4, #108]
 548 03d4 B430D5E1 		ldrh	r3, [r5, #4]
 549 03d8 012082E2 		add	r2, r2, #1
 550 03dc BC26C4E1 		strh	r2, [r4, #108]	@ movhi
 551 03e0 D3FFFFEA 		b	.L32
 552              	.LVL67:
 553              	.L42:
1559:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 554              		.loc 1 1559 0
 555 03e4 0010E0E3 		mvn	r1, #0
 556 03e8 30009FE5 		ldr	r0, .L43+12
 557 03ec FEFFFFEB 		bl	_txe_mutex_get
 558              	.LVL68:
1560:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 559              		.loc 1 1560 0
 560 03f0 8134D7E5 		ldrb	r3, [r7, #1153]	@ zero_extendqisi2
1561:../uvc.c      ****                 	//stiflag = 0xAA;
 561              		.loc 1 1561 0
 562 03f4 24009FE5 		ldr	r0, .L43+12
1560:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 563              		.loc 1 1560 0
 564 03f8 DF3003E2 		and	r3, r3, #223
 565 03fc 8134C7E5 		strb	r3, [r7, #1153]
1561:../uvc.c      ****                 	//stiflag = 0xAA;
 566              		.loc 1 1561 0
 567 0400 FEFFFFEB 		bl	_txe_mutex_put
 568              	.LVL69:
1563:../uvc.c      ****                 }
 569              		.loc 1 1563 0
 570 0404 0030A0E3 		mov	r3, #0
 571 0408 743084E5 		str	r3, [r4, #116]
 572 040c B430D5E1 		ldrh	r3, [r5, #4]
 573 0410 C5FFFFEA 		b	.L33
 574              	.L44:
 575              		.align	2
 576              	.L43:
 577 0414 00000000 		.word	.LANCHOR0
 578 0418 F03F0000 		.word	16368
 579 041c 00000000 		.word	.LANCHOR1
 580 0420 00000000 		.word	imgHdMux
 581 0424 00000000 		.word	glChHandleUVCStream
 582 0428 38000000 		.word	.LC2
 583 042c 80040000 		.word	.LANCHOR1+1152
 584              		.cfi_endproc
 585              	.LFE10:
 587              		.align	2
 589              	CyFxUVCApplnUSBEventCB:
 590              	.LFB8:
1338:../uvc.c      ****     switch (evtype)
 591              		.loc 1 1338 0
 592              		.cfi_startproc
 593              		@ args = 0, pretend = 0, frame = 8
 594              		@ frame_needed = 0, uses_anonymous_args = 0
 595              	.LVL70:
1339:../uvc.c      ****     {
 596              		.loc 1 1339 0
 597 0430 020050E3 		cmp	r0, #2
1338:../uvc.c      ****     switch (evtype)
 598              		.loc 1 1338 0
 599 0434 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 600              	.LCFI4:
 601              		.cfi_def_cfa_offset 16
 602              		.cfi_offset 4, -16
 603              		.cfi_offset 5, -12
 604              		.cfi_offset 6, -8
 605              		.cfi_offset 14, -4
 606 0438 0040A0E1 		mov	r4, r0
 607 043c 10D04DE2 		sub	sp, sp, #16
 608              	.LCFI5:
 609              		.cfi_def_cfa_offset 32
1339:../uvc.c      ****     {
 610              		.loc 1 1339 0
 611 0440 3D00000A 		beq	.L47
 612 0444 040050E3 		cmp	r0, #4
 613 0448 2000000A 		beq	.L48
 614 044c 010050E3 		cmp	r0, #1
 615 0450 0100000A 		beq	.L53
 616              	.LVL71:
 617              	.L45:
1375:../uvc.c      **** 
 618              		.loc 1 1375 0
 619 0454 10D08DE2 		add	sp, sp, #16
 620              		@ sp needed
 621 0458 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 622              	.LVL72:
 623              	.L53:
 624              	.LBB30:
 625              	.LBB31:
1358:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 626              		.loc 1 1358 0
 627 045c 0130A0E1 		mov	r3, r1
 628 0460 0420A0E1 		mov	r2, r4
1360:../uvc.c      ****             isUsbConnected = CyFalse;
 629              		.loc 1 1360 0
 630 0464 40519FE5 		ldr	r5, .L54
1358:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 631              		.loc 1 1358 0
 632 0468 40119FE5 		ldr	r1, .L54+4
 633              	.LVL73:
 634 046c 0400A0E3 		mov	r0, #4
 635              	.LVL74:
 636 0470 FEFFFFEB 		bl	CyU3PDebugPrint
 637              	.LVL75:
1359:../uvc.c      ****             gpif_initialized = 0;
 638              		.loc 1 1359 0
 639 0474 0400A0E1 		mov	r0, r4
 640 0478 FEFFFFEB 		bl	CyU3PGpifDisable
 641              	.LVL76:
1360:../uvc.c      ****             isUsbConnected = CyFalse;
 642              		.loc 1 1360 0
 643 047c 00C0A0E3 		mov	ip, #0
 644              	.LBB32:
 645              	.LBB33:
1322:../uvc.c      **** 	{
 646              		.loc 1 1322 0
 647 0480 00C08DE5 		str	ip, [sp]
 648 0484 0410A0E1 		mov	r1, r4
 649 0488 0500A0E1 		mov	r0, r5
 650 048c 0220A0E3 		mov	r2, #2
 651 0490 0C308DE2 		add	r3, sp, #12
 652              	.LBE33:
 653              	.LBE32:
1360:../uvc.c      ****             isUsbConnected = CyFalse;
 654              		.loc 1 1360 0
 655 0494 84C085E5 		str	ip, [r5, #132]
1361:../uvc.c      ****             streamingStarted = CyFalse;
 656              		.loc 1 1361 0
 657 0498 88C085E5 		str	ip, [r5, #136]
1362:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 658              		.loc 1 1362 0
 659 049c 80C085E5 		str	ip, [r5, #128]
 660              	.LBB37:
 661              	.LBB36:
1322:../uvc.c      **** 	{
 662              		.loc 1 1322 0
 663 04a0 FEFFFFEB 		bl	_txe_event_flags_get
 664              	.LVL77:
 665 04a4 004050E2 		subs	r4, r0, #0
 666 04a8 E9FFFF1A 		bne	.L45
 667              	.LBB34:
 668              	.LBB35:
1325:../uvc.c      **** 
 669              		.loc 1 1325 0
 670 04ac 0500A0E1 		mov	r0, r5
 671 04b0 0110E0E3 		mvn	r1, #1
 672 04b4 0220A0E3 		mov	r2, #2
 673 04b8 FEFFFFEB 		bl	_txe_event_flags_set
 674              	.LVL78:
1328:../uvc.c      **** 	}
 675              		.loc 1 1328 0
 676 04bc 0500A0E1 		mov	r0, r5
 677 04c0 0420A0E1 		mov	r2, r4
 678 04c4 0210A0E3 		mov	r1, #2
 679 04c8 FEFFFFEB 		bl	_txe_event_flags_set
 680              	.LVL79:
 681 04cc E0FFFFEA 		b	.L45
 682              	.LVL80:
 683              	.L48:
 684              	.LBE35:
 685              	.LBE34:
 686              	.LBE36:
 687              	.LBE37:
 688              	.LBE31:
 689              	.LBE30:
1342:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 690              		.loc 1 1342 0
 691 04d0 0130A0E1 		mov	r3, r1
 692 04d4 0020A0E1 		mov	r2, r0
 693 04d8 D4109FE5 		ldr	r1, .L54+8
 694              	.LVL81:
 695 04dc FEFFFFEB 		bl	CyU3PDebugPrint
 696              	.LVL82:
1344:../uvc.c      ****             streamingStarted = CyFalse;
 697              		.loc 1 1344 0
 698 04e0 C4409FE5 		ldr	r4, .L54
1343:../uvc.c      ****             gpif_initialized = 0;
 699              		.loc 1 1343 0
 700 04e4 0100A0E3 		mov	r0, #1
 701 04e8 FEFFFFEB 		bl	CyU3PGpifDisable
 702              	.LVL83:
1344:../uvc.c      ****             streamingStarted = CyFalse;
 703              		.loc 1 1344 0
 704 04ec 00C0A0E3 		mov	ip, #0
 705              	.LBB38:
 706              	.LBB39:
1322:../uvc.c      **** 	{
 707              		.loc 1 1322 0
 708 04f0 00C08DE5 		str	ip, [sp]
 709 04f4 0400A0E1 		mov	r0, r4
 710 04f8 0110A0E3 		mov	r1, #1
 711 04fc 0220A0E3 		mov	r2, #2
 712 0500 0C308DE2 		add	r3, sp, #12
 713              	.LBE39:
 714              	.LBE38:
1344:../uvc.c      ****             streamingStarted = CyFalse;
 715              		.loc 1 1344 0
 716 0504 84C084E5 		str	ip, [r4, #132]
1345:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 717              		.loc 1 1345 0
 718 0508 80C084E5 		str	ip, [r4, #128]
 719              	.LBB43:
 720              	.LBB42:
1322:../uvc.c      **** 	{
 721              		.loc 1 1322 0
 722 050c FEFFFFEB 		bl	_txe_event_flags_get
 723              	.LVL84:
 724 0510 005050E2 		subs	r5, r0, #0
 725 0514 CEFFFF1A 		bne	.L45
 726              	.LBB40:
 727              	.LBB41:
1325:../uvc.c      **** 
 728              		.loc 1 1325 0
 729 0518 0400A0E1 		mov	r0, r4
 730 051c 0110E0E3 		mvn	r1, #1
 731 0520 0220A0E3 		mov	r2, #2
 732 0524 FEFFFFEB 		bl	_txe_event_flags_set
 733              	.LVL85:
1328:../uvc.c      **** 	}
 734              		.loc 1 1328 0
 735 0528 0400A0E1 		mov	r0, r4
 736 052c 0520A0E1 		mov	r2, r5
 737 0530 0210A0E3 		mov	r1, #2
 738 0534 FEFFFFEB 		bl	_txe_event_flags_set
 739              	.LVL86:
 740 0538 C5FFFFEA 		b	.L45
 741              	.LVL87:
 742              	.L47:
 743              	.LBE41:
 744              	.LBE40:
 745              	.LBE42:
 746              	.LBE43:
1350:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 747              		.loc 1 1350 0
 748 053c 0130A0E1 		mov	r3, r1
 749 0540 0420A0E1 		mov	r2, r4
 750 0544 6C109FE5 		ldr	r1, .L54+12
 751              	.LVL88:
1352:../uvc.c      ****             streamingStarted = CyFalse;
 752              		.loc 1 1352 0
 753 0548 5C509FE5 		ldr	r5, .L54
1350:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 754              		.loc 1 1350 0
 755 054c 0400A0E3 		mov	r0, #4
 756              	.LVL89:
 757 0550 FEFFFFEB 		bl	CyU3PDebugPrint
 758              	.LVL90:
1351:../uvc.c      ****             gpif_initialized = 0;
 759              		.loc 1 1351 0
 760 0554 0100A0E3 		mov	r0, #1
 761 0558 FEFFFFEB 		bl	CyU3PGpifDisable
 762              	.LVL91:
1352:../uvc.c      ****             streamingStarted = CyFalse;
 763              		.loc 1 1352 0
 764 055c 00C0A0E3 		mov	ip, #0
 765              	.LBB44:
 766              	.LBB45:
1322:../uvc.c      **** 	{
 767              		.loc 1 1322 0
 768 0560 00C08DE5 		str	ip, [sp]
 769 0564 0500A0E1 		mov	r0, r5
 770 0568 0110A0E3 		mov	r1, #1
 771 056c 0420A0E1 		mov	r2, r4
 772 0570 0C308DE2 		add	r3, sp, #12
 773              	.LBE45:
 774              	.LBE44:
1352:../uvc.c      ****             streamingStarted = CyFalse;
 775              		.loc 1 1352 0
 776 0574 84C085E5 		str	ip, [r5, #132]
1353:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 777              		.loc 1 1353 0
 778 0578 80C085E5 		str	ip, [r5, #128]
 779              	.LBB49:
 780              	.LBB48:
1322:../uvc.c      **** 	{
 781              		.loc 1 1322 0
 782 057c FEFFFFEB 		bl	_txe_event_flags_get
 783              	.LVL92:
 784 0580 006050E2 		subs	r6, r0, #0
 785 0584 B2FFFF1A 		bne	.L45
 786              	.LBB46:
 787              	.LBB47:
1325:../uvc.c      **** 
 788              		.loc 1 1325 0
 789 0588 0420A0E1 		mov	r2, r4
 790 058c 0500A0E1 		mov	r0, r5
 791 0590 0110E0E3 		mvn	r1, #1
 792 0594 FEFFFFEB 		bl	_txe_event_flags_set
 793              	.LVL93:
1328:../uvc.c      **** 	}
 794              		.loc 1 1328 0
 795 0598 0500A0E1 		mov	r0, r5
 796 059c 0410A0E1 		mov	r1, r4
 797 05a0 0620A0E1 		mov	r2, r6
 798 05a4 FEFFFFEB 		bl	_txe_event_flags_set
 799              	.LVL94:
 800 05a8 A9FFFFEA 		b	.L45
 801              	.L55:
 802              		.align	2
 803              	.L54:
 804 05ac 00000000 		.word	.LANCHOR0
 805 05b0 C4000000 		.word	.LC5
 806 05b4 80000000 		.word	.LC3
 807 05b8 A0000000 		.word	.LC4
 808              	.LBE47:
 809              	.LBE46:
 810              	.LBE48:
 811              	.LBE49:
 812              		.cfi_endproc
 813              	.LFE8:
 815              		.align	2
 817              	CyFxUVCApplnUSBSetupCB:
 818              	.LFB9:
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 819              		.loc 1 1383 0
 820              		.cfi_startproc
 821              		@ args = 0, pretend = 0, frame = 8
 822              		@ frame_needed = 0, uses_anonymous_args = 0
 823              	.LVL95:
 824 05bc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 825              	.LCFI6:
 826              		.cfi_def_cfa_offset 36
 827              		.cfi_offset 4, -36
 828              		.cfi_offset 5, -32
 829              		.cfi_offset 6, -28
 830              		.cfi_offset 7, -24
 831              		.cfi_offset 8, -20
 832              		.cfi_offset 9, -16
 833              		.cfi_offset 10, -12
 834              		.cfi_offset 11, -8
 835              		.cfi_offset 14, -4
1388:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 836              		.loc 1 1388 0
 837 05c0 EC429FE5 		ldr	r4, .L90
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 838              		.loc 1 1389 0
 839 05c4 EC729FE5 		ldr	r7, .L90+4
1392:../uvc.c      **** 
 840              		.loc 1 1392 0
 841 05c8 ECB29FE5 		ldr	fp, .L90+8
1391:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 842              		.loc 1 1391 0
 843 05cc EC829FE5 		ldr	r8, .L90+12
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 844              		.loc 1 1383 0
 845 05d0 01E0A0E1 		mov	lr, r1
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 846              		.loc 1 1389 0
 847 05d4 FFAC00E2 		and	r10, r0, #65280
 848 05d8 0118A0E1 		mov	r1, r1, asl #16
 849              	.LVL96:
1390:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 850              		.loc 1 1390 0
 851 05dc E0929FE5 		ldr	r9, .L90+16
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 852              		.loc 1 1383 0
 853 05e0 1CD04DE2 		sub	sp, sp, #28
 854              	.LCFI7:
 855              		.cfi_def_cfa_offset 64
1383:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 856              		.loc 1 1383 0
 857 05e4 00C0A0E1 		mov	ip, r0
1390:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 858              		.loc 1 1390 0
 859 05e8 2068A0E1 		mov	r6, r0, lsr #16
1392:../uvc.c      **** 
 860              		.loc 1 1392 0
 861 05ec 2E58A0E1 		mov	r5, lr, lsr #16
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 862              		.loc 1 1389 0
 863 05f0 2AA4A0E1 		mov	r10, r10, lsr #8
 864 05f4 2118A0E1 		mov	r1, r1, lsr #16
1395:../uvc.c      **** #endif
 865              		.loc 1 1395 0
 866 05f8 04108DE5 		str	r1, [sp, #4]
 867 05fc 00608DE5 		str	r6, [sp]
 868 0600 08508DE5 		str	r5, [sp, #8]
 869 0604 FF2000E2 		and	r2, r0, #255
1388:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 870              		.loc 1 1388 0
 871 0608 00C0C4E5 		strb	ip, [r4]
1395:../uvc.c      **** #endif
 872              		.loc 1 1395 0
 873 060c 0A30A0E1 		mov	r3, r10
 874 0610 0400A0E3 		mov	r0, #4
 875              	.LVL97:
 876 0614 AC129FE5 		ldr	r1, .L90+20
1389:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 877              		.loc 1 1389 0
 878 0618 00A0C7E5 		strb	r10, [r7]
1392:../uvc.c      **** 
 879              		.loc 1 1392 0
 880 061c B050CBE1 		strh	r5, [fp]	@ movhi
1391:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 881              		.loc 1 1391 0
 882 0620 B0E0C8E1 		strh	lr, [r8]	@ movhi
1390:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 883              		.loc 1 1390 0
 884 0624 B060C9E1 		strh	r6, [r9]	@ movhi
1395:../uvc.c      **** #endif
 885              		.loc 1 1395 0
 886 0628 FEFFFFEB 		bl	CyU3PDebugPrint
 887              	.LVL98:
1399:../uvc.c      ****     {
 888              		.loc 1 1399 0
 889 062c 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 890 0630 020054E3 		cmp	r4, #2
 891 0634 4D00000A 		beq	.L58
 892 0638 0600009A 		bls	.L87
 893 063c 210054E3 		cmp	r4, #33
 894 0640 3C00000A 		beq	.L61
 895 0644 A10054E3 		cmp	r4, #161
 896 0648 3A00000A 		beq	.L61
 897              	.L75:
1384:../uvc.c      ****     uint32_t status;
 898              		.loc 1 1384 0
 899 064c 0000A0E3 		mov	r0, #0
 900              	.LVL99:
 901              	.L57:
1526:../uvc.c      **** 
 902              		.loc 1 1526 0
 903 0650 1CD08DE2 		add	sp, sp, #28
 904              		@ sp needed
 905 0654 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 906              	.LVL100:
 907              	.L87:
1399:../uvc.c      ****     {
 908              		.loc 1 1399 0
 909 0658 010054E3 		cmp	r4, #1
 910 065c FAFFFF1A 		bne	.L75
1439:../uvc.c      ****             {
 911              		.loc 1 1439 0
 912 0660 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 913 0664 0B0053E3 		cmp	r3, #11
 914 0668 F7FFFF1A 		bne	.L75
1443:../uvc.c      ****                 {
 915              		.loc 1 1443 0
 916 066c B040D8E1 		ldrh	r4, [r8]
 917 0670 010054E3 		cmp	r4, #1
 918 0674 F4FFFF1A 		bne	.L75
1443:../uvc.c      ****                 {
 919              		.loc 1 1443 0 is_stmt 0 discriminator 1
 920 0678 B050D9E1 		ldrh	r5, [r9]
 921 067c 000055E3 		cmp	r5, #0
 922 0680 F1FFFF1A 		bne	.L75
1448:../uvc.c      ****                     streamingStarted = CyFalse;
 923              		.loc 1 1448 0 is_stmt 1
 924 0684 40629FE5 		ldr	r6, .L90+24
1446:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 925              		.loc 1 1446 0
 926 0688 40129FE5 		ldr	r1, .L90+28
 927 068c 0400A0E3 		mov	r0, #4
 928 0690 FEFFFFEB 		bl	CyU3PDebugPrint
 929              	.LVL101:
1447:../uvc.c      ****                     gpif_initialized = 0;
 930              		.loc 1 1447 0
 931 0694 0400A0E1 		mov	r0, r4
 932 0698 FEFFFFEB 		bl	CyU3PGpifDisable
 933              	.LVL102:
1451:../uvc.c      ****                     CyU3PBusyWait (100);
 934              		.loc 1 1451 0
 935 069c 0410A0E1 		mov	r1, r4
 936 06a0 8300A0E3 		mov	r0, #131
1448:../uvc.c      ****                     streamingStarted = CyFalse;
 937              		.loc 1 1448 0
 938 06a4 845086E5 		str	r5, [r6, #132]
1449:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 939              		.loc 1 1449 0
 940 06a8 805086E5 		str	r5, [r6, #128]
1451:../uvc.c      ****                     CyU3PBusyWait (100);
 941              		.loc 1 1451 0
 942 06ac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 943              	.LVL103:
1452:../uvc.c      **** 
 944              		.loc 1 1452 0
 945 06b0 6400A0E3 		mov	r0, #100
 946 06b4 FEFFFFEB 		bl	CyFx3BusyWait
 947              	.LVL104:
1455:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 948              		.loc 1 1455 0
 949 06b8 14029FE5 		ldr	r0, .L90+32
 950 06bc FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 951              	.LVL105:
1456:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 952              		.loc 1 1456 0
 953 06c0 8300A0E3 		mov	r0, #131
 954 06c4 FEFFFFEB 		bl	CyU3PUsbFlushEp
 955              	.LVL106:
1457:../uvc.c      ****                     CyU3PBusyWait (100);
 956              		.loc 1 1457 0
 957 06c8 0510A0E1 		mov	r1, r5
 958 06cc 8300A0E3 		mov	r0, #131
 959 06d0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 960              	.LVL107:
1458:../uvc.c      **** 
 961              		.loc 1 1458 0
 962 06d4 6400A0E3 		mov	r0, #100
 963 06d8 FEFFFFEB 		bl	CyFx3BusyWait
 964              	.LVL108:
1461:../uvc.c      ****                     uvcHandleReq = CyTrue;
 965              		.loc 1 1461 0
 966 06dc 0420A0E1 		mov	r2, r4
 967 06e0 0510A0E1 		mov	r1, r5
 968 06e4 8300A0E3 		mov	r0, #131
 969 06e8 FEFFFFEB 		bl	CyU3PUsbStall
 970              	.LVL109:
1464:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 971              		.loc 1 1464 0
 972 06ec FEFFFFEB 		bl	CyU3PUsbAckSetup
 973              	.LVL110:
 974              	.LBB58:
 975              	.LBB59:
1322:../uvc.c      **** 	{
 976              		.loc 1 1322 0
 977 06f0 00508DE5 		str	r5, [sp]
 978 06f4 0410A0E1 		mov	r1, r4
 979              	.LBE59:
 980              	.LBE58:
1466:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 981              		.loc 1 1466 0
 982 06f8 8C4086E5 		str	r4, [r6, #140]
 983              	.LBB63:
 984              	.LBB62:
1322:../uvc.c      **** 	{
 985              		.loc 1 1322 0
 986 06fc 0600A0E1 		mov	r0, r6
 987 0700 0220A0E3 		mov	r2, #2
 988 0704 14308DE2 		add	r3, sp, #20
 989 0708 FEFFFFEB 		bl	_txe_event_flags_get
 990              	.LVL111:
 991 070c 004050E2 		subs	r4, r0, #0
 992 0710 1300001A 		bne	.L86
 993              	.LBB60:
 994              	.LBB61:
1325:../uvc.c      **** 
 995              		.loc 1 1325 0
 996 0714 0600A0E1 		mov	r0, r6
 997 0718 0110E0E3 		mvn	r1, #1
 998 071c 0220A0E3 		mov	r2, #2
 999 0720 FEFFFFEB 		bl	_txe_event_flags_set
 1000              	.LVL112:
1328:../uvc.c      **** 	}
 1001              		.loc 1 1328 0
 1002 0724 0600A0E1 		mov	r0, r6
 1003 0728 0420A0E1 		mov	r2, r4
 1004 072c 0210A0E3 		mov	r1, #2
 1005 0730 FEFFFFEB 		bl	_txe_event_flags_set
 1006              	.LVL113:
 1007 0734 0A0000EA 		b	.L86
 1008              	.LVL114:
 1009              	.L61:
 1010              	.LBE61:
 1011              	.LBE60:
 1012              	.LBE62:
 1013              	.LBE63:
1404:../uvc.c      ****             {
 1014              		.loc 1 1404 0
 1015 0738 0040D8E5 		ldrb	r4, [r8]	@ zero_extendqisi2
 1016 073c 000054E3 		cmp	r4, #0
 1017 0740 1700000A 		beq	.L62
 1018 0744 010054E3 		cmp	r4, #1
 1019 0748 BFFFFF1A 		bne	.L75
 1020              	.LVL115:
1422:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1021              		.loc 1 1422 0
 1022 074c 0020A0E3 		mov	r2, #0
 1023 0750 74019FE5 		ldr	r0, .L90+24
 1024 0754 0810A0E3 		mov	r1, #8
 1025 0758 FEFFFFEB 		bl	_txe_event_flags_set
 1026              	.LVL116:
1424:../uvc.c      ****                         {
 1027              		.loc 1 1424 0
 1028 075c 002050E2 		subs	r2, r0, #0
 1029 0760 1D00001A 		bne	.L88
 1030              	.LVL117:
 1031              	.L86:
1408:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1032              		.loc 1 1408 0
 1033 0764 0100A0E3 		mov	r0, #1
 1034              	.LVL118:
1526:../uvc.c      **** 
 1035              		.loc 1 1526 0
 1036 0768 1CD08DE2 		add	sp, sp, #28
 1037              		@ sp needed
 1038 076c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1039              	.LVL119:
 1040              	.L58:
1474:../uvc.c      ****             {
 1041              		.loc 1 1474 0
 1042 0770 0050D7E5 		ldrb	r5, [r7]	@ zero_extendqisi2
 1043 0774 010055E3 		cmp	r5, #1
 1044 0778 B3FFFF1A 		bne	.L75
1476:../uvc.c      ****                 {
 1045              		.loc 1 1476 0
 1046 077c B060D8E1 		ldrh	r6, [r8]
 1047 0780 830056E3 		cmp	r6, #131
 1048 0784 B0FFFF1A 		bne	.L75
1482:../uvc.c      ****                     {
 1049              		.loc 1 1482 0
 1050 0788 3C819FE5 		ldr	r8, .L90+24
 1051 078c 807098E5 		ldr	r7, [r8, #128]
 1052 0790 010057E3 		cmp	r7, #1
 1053 0794 1900000A 		beq	.L89
 1054              	.LVL120:
1514:../uvc.c      ****                     }
 1055              		.loc 1 1514 0
 1056 0798 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1057              	.LVL121:
1513:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1058              		.loc 1 1513 0
 1059 079c 0500A0E1 		mov	r0, r5
 1060 07a0 AAFFFFEA 		b	.L57
 1061              	.LVL122:
 1062              	.L62:
1409:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1063              		.loc 1 1409 0
 1064 07a4 0420A0E1 		mov	r2, r4
 1065 07a8 1C019FE5 		ldr	r0, .L90+24
 1066 07ac 0410A0E3 		mov	r1, #4
 1067 07b0 FEFFFFEB 		bl	_txe_event_flags_set
 1068              	.LVL123:
1411:../uvc.c      ****                         {
 1069              		.loc 1 1411 0
 1070 07b4 002050E2 		subs	r2, r0, #0
 1071 07b8 E9FFFF0A 		beq	.L86
1413:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1072              		.loc 1 1413 0
 1073 07bc 14119FE5 		ldr	r1, .L90+36
 1074 07c0 0400A0E3 		mov	r0, #4
 1075              	.LVL124:
 1076 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 1077              	.LVL125:
1414:../uvc.c      ****                         }
 1078              		.loc 1 1414 0
 1079 07c8 0400A0E1 		mov	r0, r4
 1080 07cc 0420A0E1 		mov	r2, r4
 1081 07d0 0110A0E3 		mov	r1, #1
 1082 07d4 FEFFFFEB 		bl	CyU3PUsbStall
 1083              	.LVL126:
 1084 07d8 E1FFFFEA 		b	.L86
 1085              	.LVL127:
 1086              	.L88:
1427:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1087              		.loc 1 1427 0
 1088 07dc F8109FE5 		ldr	r1, .L90+40
 1089 07e0 0400A0E3 		mov	r0, #4
 1090              	.LVL128:
 1091 07e4 FEFFFFEB 		bl	CyU3PDebugPrint
 1092              	.LVL129:
1428:../uvc.c      ****                         }
 1093              		.loc 1 1428 0
 1094 07e8 0000A0E3 		mov	r0, #0
 1095 07ec 0020A0E1 		mov	r2, r0
 1096 07f0 0410A0E1 		mov	r1, r4
 1097 07f4 FEFFFFEB 		bl	CyU3PUsbStall
 1098              	.LVL130:
1421:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1099              		.loc 1 1421 0
 1100 07f8 0400A0E1 		mov	r0, r4
 1101 07fc 93FFFFEA 		b	.L57
 1102              	.LVL131:
 1103              	.L89:
1484:../uvc.c      **** 
 1104              		.loc 1 1484 0
 1105 0800 D8109FE5 		ldr	r1, .L90+44
 1106 0804 0400A0E3 		mov	r0, #4
 1107 0808 FEFFFFEB 		bl	CyU3PDebugPrint
 1108              	.LVL132:
1487:../uvc.c      ****                         gpif_initialized = 0;
 1109              		.loc 1 1487 0
 1110 080c 0700A0E1 		mov	r0, r7
 1111 0810 FEFFFFEB 		bl	CyU3PGpifDisable
 1112              	.LVL133:
1488:../uvc.c      ****                         streamingStarted = CyFalse;
 1113              		.loc 1 1488 0
 1114 0814 0050A0E3 		mov	r5, #0
1492:../uvc.c      ****                         CyU3PBusyWait (100);
 1115              		.loc 1 1492 0
 1116 0818 0710A0E1 		mov	r1, r7
 1117 081c 0600A0E1 		mov	r0, r6
1488:../uvc.c      ****                         streamingStarted = CyFalse;
 1118              		.loc 1 1488 0
 1119 0820 845088E5 		str	r5, [r8, #132]
1489:../uvc.c      **** 
 1120              		.loc 1 1489 0
 1121 0824 805088E5 		str	r5, [r8, #128]
1492:../uvc.c      ****                         CyU3PBusyWait (100);
 1122              		.loc 1 1492 0
 1123 0828 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1124              	.LVL134:
1493:../uvc.c      **** 
 1125              		.loc 1 1493 0
 1126 082c 6400A0E3 		mov	r0, #100
 1127 0830 FEFFFFEB 		bl	CyFx3BusyWait
 1128              	.LVL135:
1496:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1129              		.loc 1 1496 0
 1130 0834 98009FE5 		ldr	r0, .L90+32
 1131 0838 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1132              	.LVL136:
1497:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1133              		.loc 1 1497 0
 1134 083c 0600A0E1 		mov	r0, r6
 1135 0840 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1136              	.LVL137:
1498:../uvc.c      ****                         CyU3PBusyWait (100);
 1137              		.loc 1 1498 0
 1138 0844 0510A0E1 		mov	r1, r5
 1139 0848 0600A0E1 		mov	r0, r6
 1140 084c FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1141              	.LVL138:
1499:../uvc.c      **** 
 1142              		.loc 1 1499 0
 1143 0850 6400A0E3 		mov	r0, #100
 1144 0854 FEFFFFEB 		bl	CyFx3BusyWait
 1145              	.LVL139:
1502:../uvc.c      **** 
 1146              		.loc 1 1502 0
 1147 0858 0510A0E1 		mov	r1, r5
 1148 085c 0720A0E1 		mov	r2, r7
 1149 0860 0600A0E1 		mov	r0, r6
 1150 0864 FEFFFFEB 		bl	CyU3PUsbStall
 1151              	.LVL140:
1506:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1152              		.loc 1 1506 0
 1153 0868 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1154              	.LVL141:
 1155              	.LBB64:
 1156              	.LBB65:
1322:../uvc.c      **** 	{
 1157              		.loc 1 1322 0
 1158 086c 00508DE5 		str	r5, [sp]
 1159 0870 0710A0E1 		mov	r1, r7
 1160 0874 0800A0E1 		mov	r0, r8
 1161 0878 0420A0E1 		mov	r2, r4
 1162 087c 14308DE2 		add	r3, sp, #20
 1163              	.LBE65:
 1164              	.LBE64:
1508:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1165              		.loc 1 1508 0
 1166 0880 8C7088E5 		str	r7, [r8, #140]
 1167              	.LBB69:
 1168              	.LBB68:
1322:../uvc.c      **** 	{
 1169              		.loc 1 1322 0
 1170 0884 FEFFFFEB 		bl	_txe_event_flags_get
 1171              	.LVL142:
 1172 0888 005050E2 		subs	r5, r0, #0
 1173 088c B4FFFF1A 		bne	.L86
 1174              	.LBB66:
 1175              	.LBB67:
1325:../uvc.c      **** 
 1176              		.loc 1 1325 0
 1177 0890 0420A0E1 		mov	r2, r4
 1178 0894 0800A0E1 		mov	r0, r8
 1179 0898 0110E0E3 		mvn	r1, #1
 1180 089c FEFFFFEB 		bl	_txe_event_flags_set
 1181              	.LVL143:
1328:../uvc.c      **** 	}
 1182              		.loc 1 1328 0
 1183 08a0 0800A0E1 		mov	r0, r8
 1184 08a4 0410A0E1 		mov	r1, r4
 1185 08a8 0520A0E1 		mov	r2, r5
 1186 08ac FEFFFFEB 		bl	_txe_event_flags_set
 1187              	.LVL144:
 1188 08b0 ABFFFFEA 		b	.L86
 1189              	.L91:
 1190              		.align	2
 1191              	.L90:
 1192 08b4 00000000 		.word	bmReqType
 1193 08b8 00000000 		.word	bRequest
 1194 08bc 00000000 		.word	wLength
 1195 08c0 00000000 		.word	wIndex
 1196 08c4 00000000 		.word	wValue
 1197 08c8 E4000000 		.word	.LC6
 1198 08cc 00000000 		.word	.LANCHOR0
 1199 08d0 A0010000 		.word	.LC9
 1200 08d4 00000000 		.word	glChHandleUVCStream
 1201 08d8 34010000 		.word	.LC7
 1202 08dc 6C010000 		.word	.LC8
 1203 08e0 B8010000 		.word	.LC10
 1204              	.LBE67:
 1205              	.LBE66:
 1206              	.LBE68:
 1207              	.LBE69:
 1208              		.cfi_endproc
 1209              	.LFE9:
 1211              		.align	2
 1212              		.global	I2CCmdHandler
 1214              	I2CCmdHandler:
 1215              	.LFB0:
 329:../uvc.c      **** 	uint8_t buf[2];
 1216              		.loc 1 329 0
 1217              		.cfi_startproc
 1218              		@ args = 0, pretend = 0, frame = 8
 1219              		@ frame_needed = 0, uses_anonymous_args = 0
 1220 08e4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1221              	.LCFI8:
 1222              		.cfi_def_cfa_offset 36
 1223              		.cfi_offset 4, -36
 1224              		.cfi_offset 5, -32
 1225              		.cfi_offset 6, -28
 1226              		.cfi_offset 7, -24
 1227              		.cfi_offset 8, -20
 1228              		.cfi_offset 9, -16
 1229              		.cfi_offset 10, -12
 1230              		.cfi_offset 11, -8
 1231              		.cfi_offset 14, -4
 332:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1232              		.loc 1 332 0
 1233 08e8 14419FE5 		ldr	r4, .L98
 329:../uvc.c      **** 	uint8_t buf[2];
 1234              		.loc 1 329 0
 1235 08ec 34D04DE2 		sub	sp, sp, #52
 1236              	.LCFI9:
 1237              		.cfi_def_cfa_offset 88
 332:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1238              		.loc 1 332 0
 1239 08f0 9050D4E5 		ldrb	r5, [r4, #144]	@ zero_extendqisi2
 1240              	.LVL145:
 337:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1241              		.loc 1 337 0
 1242 08f4 9A10D4E5 		ldrb	r1, [r4, #154]	@ zero_extendqisi2
 334:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1243              		.loc 1 334 0
 1244 08f8 9860D4E5 		ldrb	r6, [r4, #152]	@ zero_extendqisi2
 1245              	.LVL146:
 337:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1246              		.loc 1 337 0
 1247 08fc 92B0D4E5 		ldrb	fp, [r4, #146]	@ zero_extendqisi2
 1248 0900 93A0D4E5 		ldrb	r10, [r4, #147]	@ zero_extendqisi2
 1249 0904 9490D4E5 		ldrb	r9, [r4, #148]	@ zero_extendqisi2
 1250 0908 9580D4E5 		ldrb	r8, [r4, #149]	@ zero_extendqisi2
 1251 090c 9670D4E5 		ldrb	r7, [r4, #150]	@ zero_extendqisi2
 1252 0910 97E0D4E5 		ldrb	lr, [r4, #151]	@ zero_extendqisi2
 1253 0914 99C0D4E5 		ldrb	ip, [r4, #153]	@ zero_extendqisi2
 1254 0918 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
 1255 091c 0400A0E3 		mov	r0, #4
 1256 0920 20108DE5 		str	r1, [sp, #32]
 1257 0924 0520A0E1 		mov	r2, r5
 1258 0928 18608DE5 		str	r6, [sp, #24]
 1259 092c 00B08DE5 		str	fp, [sp]
 1260 0930 04A08DE5 		str	r10, [sp, #4]
 1261 0934 08908DE5 		str	r9, [sp, #8]
 1262 0938 0C808DE5 		str	r8, [sp, #12]
 1263 093c 10708DE5 		str	r7, [sp, #16]
 1264 0940 14E08DE5 		str	lr, [sp, #20]
 1265 0944 1CC08DE5 		str	ip, [sp, #28]
 1266 0948 B8109FE5 		ldr	r1, .L98+4
 1267 094c FEFFFFEB 		bl	CyU3PDebugPrint
 1268              	.LVL147:
 341:../uvc.c      **** 	{
 1269              		.loc 1 341 0
 1270 0950 000055E3 		cmp	r5, #0
 1271 0954 0300000A 		beq	.L96
 366:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1272              		.loc 1 366 0
 1273 0958 010055E3 		cmp	r5, #1
 1274 095c 1700000A 		beq	.L97
 381:../uvc.c      **** 
 1275              		.loc 1 381 0
 1276 0960 34D08DE2 		add	sp, sp, #52
 1277              		@ sp needed
 1278 0964 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1279              	.LVL148:
 1280              	.L96:
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1281              		.loc 1 357 0
 1282 0968 9200D4E5 		ldrb	r0, [r4, #146]	@ zero_extendqisi2
 1283 096c 9310D4E5 		ldrb	r1, [r4, #147]	@ zero_extendqisi2
 1284 0970 98E0D4E5 		ldrb	lr, [r4, #152]	@ zero_extendqisi2
 1285 0974 28C08DE2 		add	ip, sp, #40
 1286 0978 9530D4E5 		ldrb	r3, [r4, #149]	@ zero_extendqisi2
 1287 097c 9420D4E5 		ldrb	r2, [r4, #148]	@ zero_extendqisi2
 1288 0980 04C08DE5 		str	ip, [sp, #4]
 343:../uvc.c      **** #if 0 //for debugging
 1289              		.loc 1 343 0
 1290 0984 0FC0A0E3 		mov	ip, #15
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1291              		.loc 1 357 0
 1292 0988 00E08DE5 		str	lr, [sp]
 1293 098c 011081E3 		orr	r1, r1, #1
 343:../uvc.c      **** #if 0 //for debugging
 1294              		.loc 1 343 0
 1295 0990 9BC0C4E5 		strb	ip, [r4, #155]
 357:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1296              		.loc 1 357 0
 1297 0994 010080E3 		orr	r0, r0, #1
 1298 0998 FEFFFFEB 		bl	SensorRead2B
 1299              	.LVL149:
 358:../uvc.c      **** 			if(CmdDataLen == 2){
 1300              		.loc 1 358 0
 1301 099c 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
 359:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1302              		.loc 1 359 0
 1303 09a0 020056E3 		cmp	r6, #2
 358:../uvc.c      **** 			if(CmdDataLen == 2){
 1304              		.loc 1 358 0
 1305 09a4 9930C4E5 		strb	r3, [r4, #153]
 360:../uvc.c      **** 			}
 1306              		.loc 1 360 0
 1307 09a8 2930DD05 		ldreqb	r3, [sp, #41]	@ zero_extendqisi2
 1308 09ac 9A30C405 		streqb	r3, [r4, #154]
 362:../uvc.c      **** 		}else{//not support currently
 1309              		.loc 1 362 0
 1310 09b0 0030E0E3 		mvn	r3, #0
 1311 09b4 9B30C4E5 		strb	r3, [r4, #155]
 381:../uvc.c      **** 
 1312              		.loc 1 381 0
 1313 09b8 34D08DE2 		add	sp, sp, #52
 1314              		@ sp needed
 1315 09bc F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1316              	.LVL150:
 1317              	.L97:
 375:../uvc.c      **** 		}else{//not support currently
 1318              		.loc 1 375 0
 1319 09c0 9200D4E5 		ldrb	r0, [r4, #146]	@ zero_extendqisi2
 1320 09c4 9310D4E5 		ldrb	r1, [r4, #147]	@ zero_extendqisi2
 1321 09c8 9850D4E5 		ldrb	r5, [r4, #152]	@ zero_extendqisi2
 1322              	.LVL151:
 368:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1323              		.loc 1 368 0
 1324 09cc 99E0D4E5 		ldrb	lr, [r4, #153]	@ zero_extendqisi2
 369:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1325              		.loc 1 369 0
 1326 09d0 9AC0D4E5 		ldrb	ip, [r4, #154]	@ zero_extendqisi2
 375:../uvc.c      **** 		}else{//not support currently
 1327              		.loc 1 375 0
 1328 09d4 9420D4E5 		ldrb	r2, [r4, #148]	@ zero_extendqisi2
 1329 09d8 9530D4E5 		ldrb	r3, [r4, #149]	@ zero_extendqisi2
 1330 09dc 28408DE2 		add	r4, sp, #40
 1331 09e0 FE1001E2 		and	r1, r1, #254
 1332 09e4 00508DE5 		str	r5, [sp]
 1333 09e8 04408DE5 		str	r4, [sp, #4]
 1334 09ec FE0000E2 		and	r0, r0, #254
 368:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1335              		.loc 1 368 0
 1336 09f0 28E0CDE5 		strb	lr, [sp, #40]
 369:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1337              		.loc 1 369 0
 1338 09f4 29C0CDE5 		strb	ip, [sp, #41]
 375:../uvc.c      **** 		}else{//not support currently
 1339              		.loc 1 375 0
 1340 09f8 FEFFFFEB 		bl	SensorWrite2B
 1341              	.LVL152:
 381:../uvc.c      **** 
 1342              		.loc 1 381 0
 1343 09fc 34D08DE2 		add	sp, sp, #52
 1344              		@ sp needed
 1345 0a00 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1346              	.LVL153:
 1347              	.L99:
 1348              		.align	2
 1349              	.L98:
 1350 0a04 00000000 		.word	.LANCHOR0
 1351 0a08 DC010000 		.word	.LC11
 1352              		.cfi_endproc
 1353              	.LFE0:
 1355              		.align	2
 1356              		.global	setIrisauto
 1358              	setIrisauto:
 1359              	.LFB1:
 387:../uvc.c      **** 	uint8_t dataIdx;
 1360              		.loc 1 387 0
 1361              		.cfi_startproc
 1362              		@ args = 0, pretend = 0, frame = 0
 1363              		@ frame_needed = 0, uses_anonymous_args = 0
 1364              	.LVL154:
 1365 0a0c 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1366              	.LCFI10:
 1367              		.cfi_def_cfa_offset 16
 1368              		.cfi_offset 4, -16
 1369              		.cfi_offset 5, -12
 1370              		.cfi_offset 6, -8
 1371              		.cfi_offset 14, -4
 1372 0a10 0150A0E1 		mov	r5, r1
 1373 0a14 08D04DE2 		sub	sp, sp, #8
 1374              	.LCFI11:
 1375              		.cfi_def_cfa_offset 24
 387:../uvc.c      **** 	uint8_t dataIdx;
 1376              		.loc 1 387 0
 1377 0a18 0040A0E1 		mov	r4, r0
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1378              		.loc 1 391 0
 1379 0a1c 0060A0E3 		mov	r6, #0
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1380              		.loc 1 390 0
 1381 0a20 0010E0E3 		mvn	r1, #0
 1382              	.LVL155:
 1383 0a24 1C0090E5 		ldr	r0, [r0, #28]
 1384              	.LVL156:
 1385 0a28 FEFFFFEB 		bl	_txe_mutex_get
 1386              	.LVL157:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1387              		.loc 1 391 0
 1388 0a2c 062055E0 		subs	r2, r5, r6
 1389 0a30 003072E2 		rsbs	r3, r2, #0
 1390 0a34 0230B3E0 		adcs	r3, r3, r2
 1391 0a38 00308DE5 		str	r3, [sp]
 1392 0a3c 0400A0E1 		mov	r0, r4
 1393 0a40 04608DE5 		str	r6, [sp, #4]
 1394 0a44 2010A0E3 		mov	r1, #32
 1395 0a48 2720A0E3 		mov	r2, #39
 1396 0a4c 3030A0E3 		mov	r3, #48
 1397 0a50 FEFFFFEB 		bl	cmdSet
 1398              	.LVL158:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1399              		.loc 1 392 0
 1400 0a54 060055E1 		cmp	r5, r6
 1401 0a58 0250A003 		moveq	r5, #2
 1402 0a5c 0150A013 		movne	r5, #1
 1403 0a60 60008DE8 		stmia	sp, {r5, r6}
 1404 0a64 0400A0E1 		mov	r0, r4
 1405 0a68 2110A0E3 		mov	r1, #33
 1406 0a6c 2520A0E3 		mov	r2, #37
 1407 0a70 3030A0E3 		mov	r3, #48
 1408 0a74 FEFFFFEB 		bl	cmdSet
 1409              	.LVL159:
 393:../uvc.c      **** }
 1410              		.loc 1 393 0
 1411 0a78 1C0094E5 		ldr	r0, [r4, #28]
 394:../uvc.c      **** 
 1412              		.loc 1 394 0
 1413 0a7c 08D08DE2 		add	sp, sp, #8
 1414              		@ sp needed
 1415 0a80 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1416              	.LVL160:
 393:../uvc.c      **** }
 1417              		.loc 1 393 0
 1418 0a84 FEFFFFEA 		b	_txe_mutex_put
 1419              	.LVL161:
 1420              		.cfi_endproc
 1421              	.LFE1:
 1423              		.align	2
 1424              		.global	ControlHandle
 1426              	ControlHandle:
 1427              	.LFB2:
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1428              		.loc 1 396 0
 1429              		.cfi_startproc
 1430              		@ args = 0, pretend = 0, frame = 24
 1431              		@ frame_needed = 0, uses_anonymous_args = 0
 1432              	.LVL162:
 1433 0a88 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1434              	.LCFI12:
 1435              		.cfi_def_cfa_offset 36
 1436              		.cfi_offset 4, -36
 1437              		.cfi_offset 5, -32
 1438              		.cfi_offset 6, -28
 1439              		.cfi_offset 7, -24
 1440              		.cfi_offset 8, -20
 1441              		.cfi_offset 9, -16
 1442              		.cfi_offset 10, -12
 1443              		.cfi_offset 11, -8
 1444              		.cfi_offset 14, -4
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1445              		.loc 1 404 0
 1446 0a8c 9C6E9FE5 		ldr	r6, .L195
 402:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1447              		.loc 1 402 0
 1448 0a90 208040E2 		sub	r8, r0, #32
 403:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1449              		.loc 1 403 0
 1450 0a94 230050E3 		cmp	r0, #35
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1451              		.loc 1 396 0
 1452 0a98 2CD04DE2 		sub	sp, sp, #44
 1453              	.LCFI13:
 1454              		.cfi_def_cfa_offset 80
 396:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1455              		.loc 1 396 0
 1456 0a9c 0040A0E1 		mov	r4, r0
 402:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1457              		.loc 1 402 0
 1458 0aa0 FF8008E2 		and	r8, r8, #255
 1459              	.LVL163:
 403:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1460              		.loc 1 403 0
 1461 0aa4 2A00009A 		bls	.L104
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1462              		.loc 1 404 0
 1463 0aa8 882088E0 		add	r2, r8, r8, asl #1
 1464 0aac 8221A0E1 		mov	r2, r2, asl #3
 1465 0ab0 023086E0 		add	r3, r6, r2
 405:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1466              		.loc 1 405 0
 1467 0ab4 01C0D3E5 		ldrb	ip, [r3, #1]	@ zero_extendqisi2
 406:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1468              		.loc 1 406 0
 1469 0ab8 0FA0D3E5 		ldrb	r10, [r3, #15]	@ zero_extendqisi2
 407:../uvc.c      ****     }else{
 1470              		.loc 1 407 0
 1471 0abc 0290D3E5 		ldrb	r9, [r3, #2]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 1472              		.loc 1 418 0
 1473 0ac0 6C3E9FE5 		ldr	r3, .L195+4
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1474              		.loc 1 404 0
 1475 0ac4 02B0D6E7 		ldrb	fp, [r6, r2]	@ zero_extendqisi2
 1476              	.LVL164:
 418:../uvc.c      ****     /*
 1477              		.loc 1 418 0
 1478 0ac8 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 1479              	.LVL165:
 426:../uvc.c      **** 		 {
 1480              		.loc 1 426 0
 1481 0acc 830055E3 		cmp	r5, #131
 1482 0ad0 2900000A 		beq	.L107
 1483              	.LVL166:
 1484              	.L193:
 1485 0ad4 3200009A 		bls	.L192
 1486 0ad8 850055E3 		cmp	r5, #133
 1487 0adc B800000A 		beq	.L112
 1488 0ae0 C300003A 		bcc	.L113
 1489 0ae4 860055E3 		cmp	r5, #134
 1490 0ae8 7500000A 		beq	.L114
 1491 0aec 870055E3 		cmp	r5, #135
 1492 0af0 AA00001A 		bne	.L106
 646:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1493              		.loc 1 646 0
 1494 0af4 230054E3 		cmp	r4, #35
 1495 0af8 CD00009A 		bls	.L148
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1496              		.loc 1 647 0
 1497 0afc 888088E0 		add	r8, r8, r8, asl #1
 1498              	.LVL167:
 1499 0b00 886186E0 		add	r6, r6, r8, asl #3
 1500 0b04 2C7E9FE5 		ldr	r7, .L195+8
 1501 0b08 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 648:../uvc.c      **** 		 	 }
 1502              		.loc 1 648 0
 1503 0b0c 0C30D6E5 		ldrb	r3, [r6, #12]	@ zero_extendqisi2
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1504              		.loc 1 647 0
 1505 0b10 9C20C7E5 		strb	r2, [r7, #156]
 648:../uvc.c      **** 		 	 }
 1506              		.loc 1 648 0
 1507 0b14 9D30C7E5 		strb	r3, [r7, #157]
 1508              	.L149:
 660:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1509              		.loc 1 660 0
 1510 0b18 0900A0E1 		mov	r0, r9
 1511              	.LVL168:
 1512 0b1c 181E9FE5 		ldr	r1, .L195+12
 1513 0b20 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1514              	.LVL169:
 1515 0b24 9C60D7E5 		ldrb	r6, [r7, #156]	@ zero_extendqisi2
 662:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 1516              		.loc 1 662 0
 1517 0b28 FF80A0E3 		mov	r8, #255
 1518 0b2c 0830A0E1 		mov	r3, r8
 1519 0b30 0840A0E1 		mov	r4, r8
 1520              	.LVL170:
 1521              	.L116:
 960:../uvc.c      **** }
 1522              		.loc 1 960 0
 1523 0b34 48018DE8 		stmia	sp, {r3, r6, r8}
 1524 0b38 001E9FE5 		ldr	r1, .L195+16
 1525 0b3c 0520A0E1 		mov	r2, r5
 1526 0b40 0430A0E1 		mov	r3, r4
 1527 0b44 0400A0E3 		mov	r0, #4
 1528 0b48 FEFFFFEB 		bl	CyU3PDebugPrint
 1529              	.LVL171:
 961:../uvc.c      **** /************** CT control requests handler *************************/
 1530              		.loc 1 961 0
 1531 0b4c 2CD08DE2 		add	sp, sp, #44
 1532              		@ sp needed
 1533 0b50 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1534              	.LVL172:
 1535              	.L104:
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1536              		.loc 1 409 0
 1537 0b54 803080E0 		add	r3, r0, r0, asl #1
 1538 0b58 833186E0 		add	r3, r6, r3, asl #3
 1539 0b5c 80B1D3E5 		ldrb	fp, [r3, #384]	@ zero_extendqisi2
 1540              	.LVL173:
 410:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1541              		.loc 1 410 0
 1542 0b60 81C1D3E5 		ldrb	ip, [r3, #385]	@ zero_extendqisi2
 1543              	.LVL174:
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1544              		.loc 1 411 0
 1545 0b64 8FA1D3E5 		ldrb	r10, [r3, #399]	@ zero_extendqisi2
 1546              	.LVL175:
 412:../uvc.c      ****     }
 1547              		.loc 1 412 0
 1548 0b68 8291D3E5 		ldrb	r9, [r3, #386]	@ zero_extendqisi2
 1549              	.LVL176:
 418:../uvc.c      ****     /*
 1550              		.loc 1 418 0
 1551 0b6c C03D9FE5 		ldr	r3, .L195+4
 1552              	.LVL177:
 1553 0b70 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 1554              	.LVL178:
 426:../uvc.c      **** 		 {
 1555              		.loc 1 426 0
 1556 0b74 830055E3 		cmp	r5, #131
 1557 0b78 D5FFFF1A 		bne	.L193
 1558              	.LVL179:
 1559              	.L107:
 601:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1560              		.loc 1 601 0
 1561 0b7c 230054E3 		cmp	r4, #35
 1562 0b80 C100009A 		bls	.L141
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1563              		.loc 1 602 0
 1564 0b84 888088E0 		add	r8, r8, r8, asl #1
 1565              	.LVL180:
 1566 0b88 886186E0 		add	r6, r6, r8, asl #3
 1567 0b8c A47D9FE5 		ldr	r7, .L195+8
 1568 0b90 0520D6E5 		ldrb	r2, [r6, #5]	@ zero_extendqisi2
 603:../uvc.c      **** 		 	 }
 1569              		.loc 1 603 0
 1570 0b94 0630D6E5 		ldrb	r3, [r6, #6]	@ zero_extendqisi2
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1571              		.loc 1 602 0
 1572 0b98 9C20C7E5 		strb	r2, [r7, #156]
 603:../uvc.c      **** 		 	 }
 1573              		.loc 1 603 0
 1574 0b9c 9D30C7E5 		strb	r3, [r7, #157]
 1575 0ba0 DCFFFFEA 		b	.L149
 1576              	.LVL181:
 1577              	.L192:
 426:../uvc.c      **** 		 {
 1578              		.loc 1 426 0
 1579 0ba4 810055E3 		cmp	r5, #129
 1580 0ba8 5600000A 		beq	.L109
 1581 0bac 3A00008A 		bhi	.L110
 1582 0bb0 010055E3 		cmp	r5, #1
 1583 0bb4 7900001A 		bne	.L106
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 1584              		.loc 1 664 0
 1585 0bb8 787D9FE5 		ldr	r7, .L195+8
 1586 0bbc 26208DE2 		add	r2, sp, #38
 1587 0bc0 2000A0E3 		mov	r0, #32
 1588              	.LVL182:
 1589 0bc4 9C1087E2 		add	r1, r7, #156
 1590 0bc8 10C08DE5 		str	ip, [sp, #16]
 1591 0bcc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1592              	.LVL183:
 666:../uvc.c      **** 			   {
 1593              		.loc 1 666 0
 1594 0bd0 10C09DE5 		ldr	ip, [sp, #16]
 1595 0bd4 002050E2 		subs	r2, r0, #0
 1596 0bd8 0C03001A 		bne	.L151
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1597              		.loc 1 668 0
 1598 0bdc 9C00D7E5 		ldrb	r0, [r7, #156]	@ zero_extendqisi2
 1599              	.LVL184:
 669:../uvc.c      **** 				  getData = glEp0Buffer[0];
 1600              		.loc 1 669 0
 1601 0be0 9D20D7E5 		ldrb	r2, [r7, #157]	@ zero_extendqisi2
 1602              	.LVL185:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1603              		.loc 1 671 0
 1604 0be4 9E30D7E5 		ldrb	r3, [r7, #158]	@ zero_extendqisi2
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1605              		.loc 1 668 0
 1606 0be8 14008DE5 		str	r0, [sp, #20]
 1607              	.LVL186:
 669:../uvc.c      **** 				  getData = glEp0Buffer[0];
 1608              		.loc 1 669 0
 1609 0bec 1C208DE5 		str	r2, [sp, #28]
 1610              	.LVL187:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1611              		.loc 1 671 0
 1612 0bf0 18308DE5 		str	r3, [sp, #24]
 1613              	.LVL188:
 675:../uvc.c      **** 					 {
 1614              		.loc 1 675 0
 1615 0bf4 260054E3 		cmp	r4, #38
 1616 0bf8 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1617 0bfc E90200EA 		b	.L152
 1618              	.L154:
 1619 0c00 0C140000 		.word	.L153
 1620 0c04 A8170000 		.word	.L152
 1621 0c08 A8170000 		.word	.L152
 1622 0c0c A8170000 		.word	.L152
 1623 0c10 C4130000 		.word	.L155
 1624 0c14 7C120000 		.word	.L156
 1625 0c18 F8110000 		.word	.L157
 1626 0c1c A8170000 		.word	.L152
 1627 0c20 A8170000 		.word	.L152
 1628 0c24 A8170000 		.word	.L152
 1629 0c28 A8170000 		.word	.L152
 1630 0c2c 6C110000 		.word	.L158
 1631 0c30 A8170000 		.word	.L152
 1632 0c34 A8170000 		.word	.L152
 1633 0c38 A8170000 		.word	.L152
 1634 0c3c A8170000 		.word	.L152
 1635 0c40 E4100000 		.word	.L159
 1636 0c44 A8170000 		.word	.L152
 1637 0c48 A8170000 		.word	.L152
 1638 0c4c A8170000 		.word	.L152
 1639 0c50 A8170000 		.word	.L152
 1640 0c54 A8170000 		.word	.L152
 1641 0c58 A8170000 		.word	.L152
 1642 0c5c A8170000 		.word	.L152
 1643 0c60 A8170000 		.word	.L152
 1644 0c64 E8150000 		.word	.L160
 1645 0c68 48150000 		.word	.L161
 1646 0c6c A8170000 		.word	.L152
 1647 0c70 38150000 		.word	.L162
 1648 0c74 A8170000 		.word	.L152
 1649 0c78 D8140000 		.word	.L163
 1650 0c7c 10170000 		.word	.L164
 1651 0c80 A8170000 		.word	.L152
 1652 0c84 A8170000 		.word	.L152
 1653 0c88 A8170000 		.word	.L152
 1654 0c8c A8170000 		.word	.L152
 1655 0c90 78160000 		.word	.L165
 1656 0c94 40170000 		.word	.L166
 1657 0c98 7C100000 		.word	.L167
 1658              	.LVL189:
 1659              	.L110:
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1660              		.loc 1 582 0
 1661 0c9c 230054E3 		cmp	r4, #35
 1662 0ca0 6D00009A 		bls	.L138
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1663              		.loc 1 583 0
 1664 0ca4 888088E0 		add	r8, r8, r8, asl #1
 1665              	.LVL190:
 1666 0ca8 886186E0 		add	r6, r6, r8, asl #3
 1667 0cac 847C9FE5 		ldr	r7, .L195+8
 1668 0cb0 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 584:../uvc.c      **** 		 	 }
 1669              		.loc 1 584 0
 1670 0cb4 0430D6E5 		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1671              		.loc 1 583 0
 1672 0cb8 9C20C7E5 		strb	r2, [r7, #156]
 584:../uvc.c      **** 		 	 }
 1673              		.loc 1 584 0
 1674 0cbc 9D30C7E5 		strb	r3, [r7, #157]
 1675 0cc0 94FFFFEA 		b	.L149
 1676              	.LVL191:
 1677              	.L114:
 635:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1678              		.loc 1 635 0
 1679 0cc4 230054E3 		cmp	r4, #35
 636:../uvc.c      **** 		 	 }
 1680              		.loc 1 636 0
 1681 0cc8 88808880 		addhi	r8, r8, r8, asl #1
 1682              	.LVL192:
 639:../uvc.c      **** 		 	 }
 1683              		.loc 1 639 0
 1684 0ccc 84408490 		addls	r4, r4, r4, asl #1
 636:../uvc.c      **** 		 	 }
 1685              		.loc 1 636 0
 1686 0cd0 88618680 		addhi	r6, r6, r8, asl #3
 639:../uvc.c      **** 		 	 }
 1687              		.loc 1 639 0
 1688 0cd4 84618690 		addls	r6, r6, r4, asl #3
 636:../uvc.c      **** 		 	 }
 1689              		.loc 1 636 0
 1690 0cd8 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 639:../uvc.c      **** 		 	 }
 1691              		.loc 1 639 0
 1692 0cdc 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 1693 0ce0 506C9FE5 		ldr	r6, .L195+8
 644:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 1694              		.loc 1 644 0
 1695 0ce4 FF80A0E3 		mov	r8, #255
 1696 0ce8 0610A0E1 		mov	r1, r6
 1697 0cec 9C30E1E5 		strb	r3, [r1, #156]!
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1698              		.loc 1 641 0
 1699 0cf0 0100A0E3 		mov	r0, #1
 1700              	.LVL193:
 1701 0cf4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1702              	.LVL194:
 644:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 1703              		.loc 1 644 0
 1704 0cf8 0840A0E1 		mov	r4, r8
 1705 0cfc 9C60D6E5 		ldrb	r6, [r6, #156]	@ zero_extendqisi2
 1706 0d00 0830A0E1 		mov	r3, r8
 1707 0d04 8AFFFFEA 		b	.L116
 1708              	.LVL195:
 1709              	.L109:
 437:../uvc.c      **** 			 {
 1710              		.loc 1 437 0
 1711 0d08 053044E2 		sub	r3, r4, #5
 1712 0d0c 210053E3 		cmp	r3, #33
 1713 0d10 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1714 0d14 CA0000EA 		b	.L117
 1715              	.L119:
 1716 0d18 C40F0000 		.word	.L118
 1717 0d1c 44100000 		.word	.L117
 1718 0d20 44100000 		.word	.L117
 1719 0d24 44100000 		.word	.L117
 1720 0d28 44100000 		.word	.L117
 1721 0d2c 44100000 		.word	.L117
 1722 0d30 E80F0000 		.word	.L120
 1723 0d34 44100000 		.word	.L117
 1724 0d38 44100000 		.word	.L117
 1725 0d3c 44100000 		.word	.L117
 1726 0d40 44100000 		.word	.L117
 1727 0d44 44100000 		.word	.L117
 1728 0d48 44100000 		.word	.L117
 1729 0d4c 44100000 		.word	.L117
 1730 0d50 44100000 		.word	.L117
 1731 0d54 44100000 		.word	.L117
 1732 0d58 44100000 		.word	.L117
 1733 0d5c 44100000 		.word	.L117
 1734 0d60 44100000 		.word	.L117
 1735 0d64 44100000 		.word	.L117
 1736 0d68 700F0000 		.word	.L121
 1737 0d6c 44100000 		.word	.L117
 1738 0d70 44100000 		.word	.L117
 1739 0d74 3C0F0000 		.word	.L122
 1740 0d78 44100000 		.word	.L117
 1741 0d7c 44100000 		.word	.L117
 1742 0d80 F40E0000 		.word	.L123
 1743 0d84 44100000 		.word	.L117
 1744 0d88 44100000 		.word	.L117
 1745 0d8c 44100000 		.word	.L117
 1746 0d90 44100000 		.word	.L117
 1747 0d94 BC0E0000 		.word	.L124
 1748 0d98 BC0E0000 		.word	.L124
 1749 0d9c BC0E0000 		.word	.L124
 1750              	.L106:
 957:../uvc.c      **** 			  break;
 1751              		.loc 1 957 0
 1752 0da0 0000A0E3 		mov	r0, #0
 1753              	.LVL196:
 958:../uvc.c      **** 		 }
 1754              		.loc 1 958 0
 1755 0da4 FF80A0E3 		mov	r8, #255
 1756              	.LVL197:
 957:../uvc.c      **** 			  break;
 1757              		.loc 1 957 0
 1758 0da8 0020A0E1 		mov	r2, r0
 1759 0dac 0110A0E3 		mov	r1, #1
 1760 0db0 FEFFFFEB 		bl	CyU3PUsbStall
 1761              	.LVL198:
 958:../uvc.c      **** 		 }
 1762              		.loc 1 958 0
 1763 0db4 0860A0E1 		mov	r6, r8
 1764 0db8 0830A0E1 		mov	r3, r8
 1765 0dbc 0840A0E1 		mov	r4, r8
 1766              	.LVL199:
 1767 0dc0 5BFFFFEA 		b	.L116
 1768              	.LVL200:
 1769              	.L112:
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1770              		.loc 1 430 0
 1771 0dc4 6C6B9FE5 		ldr	r6, .L195+8
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1772              		.loc 1 431 0
 1773 0dc8 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1774              		.loc 1 432 0
 1775 0dcc 9C1086E2 		add	r1, r6, #156
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1776              		.loc 1 434 0
 1777 0dd0 FF80A0E3 		mov	r8, #255
 1778              	.LVL201:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1779              		.loc 1 432 0
 1780 0dd4 0200A0E3 		mov	r0, #2
 1781              	.LVL202:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1782              		.loc 1 431 0
 1783 0dd8 9D30C6E5 		strb	r3, [r6, #157]
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1784              		.loc 1 430 0
 1785 0ddc 9C90C6E5 		strb	r9, [r6, #156]
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1786              		.loc 1 434 0
 1787 0de0 0840A0E1 		mov	r4, r8
 1788              	.LVL203:
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1789              		.loc 1 432 0
 1790 0de4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1791              	.LVL204:
 1792 0de8 9C60D6E5 		ldrb	r6, [r6, #156]	@ zero_extendqisi2
 434:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1793              		.loc 1 434 0
 1794 0dec 0830A0E1 		mov	r3, r8
 1795 0df0 4FFFFFEA 		b	.L116
 1796              	.LVL205:
 1797              	.L113:
 619:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1798              		.loc 1 619 0
 1799 0df4 230054E3 		cmp	r4, #35
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1800              		.loc 1 620 0
 1801 0df8 88808880 		addhi	r8, r8, r8, asl #1
 1802              	.LVL206:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1803              		.loc 1 626 0
 1804 0dfc 84408490 		addls	r4, r4, r4, asl #1
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1805              		.loc 1 620 0
 1806 0e00 88618680 		addhi	r6, r6, r8, asl #3
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1807              		.loc 1 626 0
 1808 0e04 84618690 		addls	r6, r6, r4, asl #3
 1809 0e08 287B9FE5 		ldr	r7, .L195+8
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1810              		.loc 1 620 0
 1811 0e0c 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 1812              		.loc 1 621 0
 1813 0e10 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1814              		.loc 1 626 0
 1815 0e14 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1816              		.loc 1 627 0
 1817 0e18 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1818              		.loc 1 628 0
 1819 0e1c 0030A0E3 		mov	r3, #0
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1820              		.loc 1 626 0
 1821 0e20 9C10C7E5 		strb	r1, [r7, #156]
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1822              		.loc 1 627 0
 1823 0e24 9D20C7E5 		strb	r2, [r7, #157]
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1824              		.loc 1 628 0
 1825 0e28 9E30C7E5 		strb	r3, [r7, #158]
 629:../uvc.c      **** 		 	 }
 1826              		.loc 1 629 0
 1827 0e2c 9F30C7E5 		strb	r3, [r7, #159]
 1828 0e30 38FFFFEA 		b	.L149
 1829              	.LVL207:
 1830              	.L148:
 651:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1831              		.loc 1 651 0
 1832 0e34 0B0054E3 		cmp	r4, #11
 1833 0e38 7800000A 		beq	.L194
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1834              		.loc 1 657 0
 1835 0e3c 844084E0 		add	r4, r4, r4, asl #1
 1836 0e40 846186E0 		add	r6, r6, r4, asl #3
 1837 0e44 EC7A9FE5 		ldr	r7, .L195+8
 1838 0e48 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 1839              		.loc 1 658 0
 1840 0e4c 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1841              		.loc 1 657 0
 1842 0e50 9C20C7E5 		strb	r2, [r7, #156]
 658:../uvc.c      **** 			 }
 1843              		.loc 1 658 0
 1844 0e54 9D30C7E5 		strb	r3, [r7, #157]
 1845 0e58 2EFFFFEA 		b	.L149
 1846              	.L138:
 587:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1847              		.loc 1 587 0
 1848 0e5c 0B0054E3 		cmp	r4, #11
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1849              		.loc 1 594 0
 1850 0e60 84408410 		addne	r4, r4, r4, asl #1
 1851 0e64 84618610 		addne	r6, r6, r4, asl #3
 1852 0e68 C87A9F15 		ldrne	r7, .L195+8
 588:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1853              		.loc 1 588 0
 1854 0e6c C47A9F05 		ldreq	r7, .L195+8
 1855 0e70 CC3A9F05 		ldreq	r3, .L195+20
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1856              		.loc 1 594 0
 1857 0e74 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 1858              		.loc 1 595 0
 1859 0e78 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 588:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1860              		.loc 1 588 0
 1861 0e7c 9C308705 		streq	r3, [r7, #156]
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1862              		.loc 1 594 0
 1863 0e80 9C20C715 		strneb	r2, [r7, #156]
 595:../uvc.c      **** 			 }
 1864              		.loc 1 595 0
 1865 0e84 9D30C715 		strneb	r3, [r7, #157]
 1866 0e88 22FFFFEA 		b	.L149
 1867              	.L141:
 605:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1868              		.loc 1 605 0
 1869 0e8c 0B0054E3 		cmp	r4, #11
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1870              		.loc 1 612 0
 1871 0e90 84408410 		addne	r4, r4, r4, asl #1
 1872 0e94 84618610 		addne	r6, r6, r4, asl #3
 1873 0e98 987A9F15 		ldrne	r7, .L195+8
 606:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1874              		.loc 1 606 0
 1875 0e9c 947A9F05 		ldreq	r7, .L195+8
 1876 0ea0 A03A9F05 		ldreq	r3, .L195+24
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1877              		.loc 1 612 0
 1878 0ea4 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 1879              		.loc 1 613 0
 1880 0ea8 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 606:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 1881              		.loc 1 606 0
 1882 0eac 9C308705 		streq	r3, [r7, #156]
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1883              		.loc 1 612 0
 1884 0eb0 9C20C715 		strneb	r2, [r7, #156]
 613:../uvc.c      **** 			 }
 1885              		.loc 1 613 0
 1886 0eb4 9D30C715 		strneb	r3, [r7, #157]
 1887 0eb8 16FFFFEA 		b	.L149
 1888              	.L124:
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1889              		.loc 1 443 0
 1890 0ebc 888088E0 		add	r8, r8, r8, asl #1
 1891              	.LVL208:
 1892 0ec0 886186E0 		add	r6, r6, r8, asl #3
 1893 0ec4 0D20D6E5 		ldrb	r2, [r6, #13]	@ zero_extendqisi2
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 1894              		.loc 1 444 0
 1895 0ec8 0E80D6E5 		ldrb	r8, [r6, #14]	@ zero_extendqisi2
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1896              		.loc 1 443 0
 1897 0ecc 643A9FE5 		ldr	r3, .L195+8
 1898 0ed0 0260A0E1 		mov	r6, r2
 1899 0ed4 9C20C3E5 		strb	r2, [r3, #156]
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 1900              		.loc 1 444 0
 1901 0ed8 9D80C3E5 		strb	r8, [r3, #157]
 1902              	.LVL209:
 1903              	.L128:
 575:../uvc.c      **** 
 1904              		.loc 1 575 0
 1905 0edc 0900A0E1 		mov	r0, r9
 1906 0ee0 541A9FE5 		ldr	r1, .L195+12
 1907 0ee4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1908              	.LVL210:
 580:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 1909              		.loc 1 580 0
 1910 0ee8 FF30A0E3 		mov	r3, #255
 1911 0eec 0340A0E1 		mov	r4, r3
 1912 0ef0 0FFFFFEA 		b	.L116
 1913              	.LVL211:
 1914              	.L123:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1915              		.loc 1 464 0 discriminator 1
 1916 0ef4 000059E3 		cmp	r9, #0
 1917 0ef8 0300000A 		beq	.L131
 1918 0efc 380A9FE5 		ldr	r0, .L195+12
 1919              	.LVL212:
 1920 0f00 0920A0E1 		mov	r2, r9
 1921 0f04 0C1040E2 		sub	r1, r0, #12
 1922 0f08 FEFFFFEB 		bl	memcpy
 1923              	.LVL213:
 1924              	.L131:
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1925              		.loc 1 467 0
 1926 0f0c 243A9FE5 		ldr	r3, .L195+8
 474:../uvc.c      **** 			 		 {
 1927              		.loc 1 474 0
 1928 0f10 9B20D3E5 		ldrb	r2, [r3, #155]	@ zero_extendqisi2
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1929              		.loc 1 467 0
 1930 0f14 A560D3E5 		ldrb	r6, [r3, #165]	@ zero_extendqisi2
 1931              	.LVL214:
 474:../uvc.c      **** 			 		 {
 1932              		.loc 1 474 0
 1933 0f18 FF0052E3 		cmp	r2, #255
 468:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1934              		.loc 1 468 0
 1935 0f1c A680D3E5 		ldrb	r8, [r3, #166]	@ zero_extendqisi2
 1936              	.LVL215:
 474:../uvc.c      **** 			 		 {
 1937              		.loc 1 474 0
 1938 0f20 EDFFFF0A 		beq	.L128
 476:../uvc.c      **** 			 		 }
 1939              		.loc 1 476 0
 1940 0f24 9920D3E5 		ldrb	r2, [r3, #153]	@ zero_extendqisi2
 1941 0f28 1C1A9FE5 		ldr	r1, .L195+28
 1942 0f2c 9A30D3E5 		ldrb	r3, [r3, #154]	@ zero_extendqisi2
 1943 0f30 0400A0E3 		mov	r0, #4
 1944 0f34 FEFFFFEB 		bl	CyU3PDebugPrint
 1945              	.LVL216:
 1946 0f38 E7FFFFEA 		b	.L128
 1947              	.LVL217:
 1948              	.L122:
 450:../uvc.c      **** 					 if(CamMode == 1){//720p or invendo
 1949              		.loc 1 450 0
 1950 0f3c 2D34D6E5 		ldrb	r3, [r6, #1069]	@ zero_extendqisi2
 1951              	.LVL218:
 1952 0f40 E8499FE5 		ldr	r4, .L195
 452:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 1953              		.loc 1 452 0
 1954 0f44 020053E3 		cmp	r3, #2
 1955 0f48 6F02008A 		bhi	.L129
 1956 0f4c 043083E2 		add	r3, r3, #4
 1957 0f50 FF3003E2 		and	r3, r3, #255
 1958 0f54 0360A0E1 		mov	r6, r3
 1959              	.LVL219:
 1960              	.L130:
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1961              		.loc 1 460 0
 1962 0f58 D8299FE5 		ldr	r2, .L195+8
 461:../uvc.c      **** 					 break;
 1963              		.loc 1 461 0
 1964 0f5c 0010A0E3 		mov	r1, #0
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1965              		.loc 1 460 0
 1966 0f60 9C30C2E5 		strb	r3, [r2, #156]
 461:../uvc.c      **** 					 break;
 1967              		.loc 1 461 0
 1968 0f64 9D10C2E5 		strb	r1, [r2, #157]
 462:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 1969              		.loc 1 462 0
 1970 0f68 FF80A0E3 		mov	r8, #255
 1971              	.LVL220:
 1972 0f6c DAFFFFEA 		b	.L128
 1973              	.LVL221:
 1974              	.L121:
 481:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1975              		.loc 1 481 0
 1976 0f70 C0799FE5 		ldr	r7, .L195+8
 1977 0f74 4530D7E5 		ldrb	r3, [r7, #69]	@ zero_extendqisi2
 1978 0f78 000053E3 		cmp	r3, #0
 1979 0f7c 4502000A 		beq	.L132
 1980 0f80 E6E3D6E5 		ldrb	lr, [r6, #998]	@ zero_extendqisi2
 1981              	.LVL222:
 1982              	.L133:
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1983              		.loc 1 495 0
 1984 0f84 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 496:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1985              		.loc 1 496 0
 1986 0f88 00C0A0E3 		mov	ip, #0
 501:../uvc.c      **** 					 break;
 1987              		.loc 1 501 0
 1988 0f8c 00E08DE5 		str	lr, [sp]
 1989 0f90 04C08DE5 		str	ip, [sp, #4]
 1990 0f94 0420A0E1 		mov	r2, r4
 1991 0f98 0C30A0E1 		mov	r3, ip
 1992 0f9c AC199FE5 		ldr	r1, .L195+32
 495:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1993              		.loc 1 495 0
 1994 0fa0 9C40C7E5 		strb	r4, [r7, #156]
 497:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1995              		.loc 1 497 0
 1996 0fa4 9EE0C7E5 		strb	lr, [r7, #158]
 496:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1997              		.loc 1 496 0
 1998 0fa8 9DC0C7E5 		strb	ip, [r7, #157]
 498:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 1999              		.loc 1 498 0
 2000 0fac 9FC0C7E5 		strb	ip, [r7, #159]
 2001              	.LVL223:
 501:../uvc.c      **** 					 break;
 2002              		.loc 1 501 0
 2003 0fb0 0400A0E3 		mov	r0, #4
 2004 0fb4 0E80A0E1 		mov	r8, lr
 2005              	.LVL224:
 2006 0fb8 0460A0E1 		mov	r6, r4
 2007 0fbc FEFFFFEB 		bl	CyU3PDebugPrint
 2008              	.LVL225:
 502:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2009              		.loc 1 502 0
 2010 0fc0 C5FFFFEA 		b	.L128
 2011              	.LVL226:
 2012              	.L118:
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2013              		.loc 1 532 0
 2014 0fc4 0562D6E5 		ldrb	r6, [r6, #517]	@ zero_extendqisi2
 2015 0fc8 68399FE5 		ldr	r3, .L195+8
 2016 0fcc 806046E2 		sub	r6, r6, #128
 2017 0fd0 FF6006E2 		and	r6, r6, #255
 533:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2018              		.loc 1 533 0
 2019 0fd4 0020A0E3 		mov	r2, #0
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2020              		.loc 1 532 0
 2021 0fd8 9C60C3E5 		strb	r6, [r3, #156]
 533:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2022              		.loc 1 533 0
 2023 0fdc 9D20C3E5 		strb	r2, [r3, #157]
 2024              	.LVL227:
 535:../uvc.c      **** 				 case WBTLevCtlID11:
 2025              		.loc 1 535 0
 2026 0fe0 FF80A0E3 		mov	r8, #255
 2027              	.LVL228:
 2028 0fe4 BCFFFFEA 		b	.L128
 2029              	.LVL229:
 2030              	.L120:
 538:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2031              		.loc 1 538 0
 2032 0fe8 48799FE5 		ldr	r7, .L195+8
 2033 0fec 3730D7E5 		ldrb	r3, [r7, #55]	@ zero_extendqisi2
 2034 0ff0 000053E3 		cmp	r3, #0
 2035 0ff4 1702000A 		beq	.L134
 539:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2036              		.loc 1 539 0
 2037 0ff8 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 540:../uvc.c      **** 		 	 		 }else{
 2038              		.loc 1 540 0
 2039 0ffc 8E84D6E5 		ldrb	r8, [r6, #1166]	@ zero_extendqisi2
 2040              	.LVL230:
 2041 1000 0320A0E1 		mov	r2, r3
 539:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2042              		.loc 1 539 0
 2043 1004 9C30C7E5 		strb	r3, [r7, #156]
 540:../uvc.c      **** 		 	 		 }else{
 2044              		.loc 1 540 0
 2045 1008 9E80C7E5 		strb	r8, [r7, #158]
 2046              	.LVL231:
 2047              	.L135:
 551:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2048              		.loc 1 551 0
 2049 100c 0030A0E3 		mov	r3, #0
 2050 1010 0260A0E1 		mov	r6, r2
 2051 1014 9D30C7E5 		strb	r3, [r7, #157]
 552:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2052              		.loc 1 552 0
 2053 1018 9F30C7E5 		strb	r3, [r7, #159]
 2054              	.LVL232:
 555:../uvc.c      **** 				 case SaturCtlID6://TODO check sensor register
 2055              		.loc 1 555 0
 2056 101c AEFFFFEA 		b	.L128
 2057              	.LVL233:
 2058              	.L194:
 652:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2059              		.loc 1 652 0
 2060 1020 10799FE5 		ldr	r7, .L195+8
 2061 1024 9312D6E5 		ldrb	r1, [r6, #659]	@ zero_extendqisi2
 654:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2062              		.loc 1 654 0
 2063 1028 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 653:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2064              		.loc 1 653 0
 2065 102c 0030A0E3 		mov	r3, #0
 652:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2066              		.loc 1 652 0
 2067 1030 9C10C7E5 		strb	r1, [r7, #156]
 654:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2068              		.loc 1 654 0
 2069 1034 9E20C7E5 		strb	r2, [r7, #158]
 653:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2070              		.loc 1 653 0
 2071 1038 9D30C7E5 		strb	r3, [r7, #157]
 655:../uvc.c      **** 			 }else{
 2072              		.loc 1 655 0
 2073 103c 9F30C7E5 		strb	r3, [r7, #159]
 2074 1040 B4FEFFEA 		b	.L149
 2075              	.L117:
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2076              		.loc 1 559 0
 2077 1044 EC789FE5 		ldr	r7, .L195+8
 2078 1048 048087E0 		add	r8, r7, r4
 2079              	.LVL234:
 2080 104c 2C30D8E5 		ldrb	r3, [r8, #44]	@ zero_extendqisi2
 2081 1050 000053E3 		cmp	r3, #0
 2082 1054 F501000A 		beq	.L136
 2083 1058 844084E0 		add	r4, r4, r4, asl #1
 2084 105c 846186E0 		add	r6, r6, r4, asl #3
 2085 1060 8D31D6E5 		ldrb	r3, [r6, #397]	@ zero_extendqisi2
 2086              	.LVL235:
 2087              	.L137:
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2088              		.loc 1 570 0
 2089 1064 0020A0E3 		mov	r2, #0
 2090 1068 0360A0E1 		mov	r6, r3
 572:../uvc.c      **** 			 }
 2091              		.loc 1 572 0
 2092 106c FF80A0E3 		mov	r8, #255
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2093              		.loc 1 569 0
 2094 1070 9C30C7E5 		strb	r3, [r7, #156]
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2095              		.loc 1 570 0
 2096 1074 9D20C7E5 		strb	r2, [r7, #157]
 2097              	.LVL236:
 572:../uvc.c      **** 			 }
 2098              		.loc 1 572 0
 2099 1078 97FFFFEA 		b	.L128
 2100              	.LVL237:
 2101              	.L167:
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2102              		.loc 1 819 0
 2103 107c D0489FE5 		ldr	r4, .L195+36
 2104 1080 0010E0E3 		mvn	r1, #0
 2105 1084 1C0094E5 		ldr	r0, [r4, #28]
 2106 1088 FEFFFFEB 		bl	_txe_mutex_get
 2107              	.LVL238:
 820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2108              		.loc 1 820 0
 2109 108c 14209DE5 		ldr	r2, [sp, #20]
 2110 1090 0010A0E3 		mov	r1, #0
 2111 1094 0A30A0E1 		mov	r3, r10
 2112 1098 00208DE5 		str	r2, [sp]
 2113 109c 0400A0E1 		mov	r0, r4
 2114 10a0 0B20A0E1 		mov	r2, fp
 2115 10a4 04108DE5 		str	r1, [sp, #4]
 2116 10a8 2610A0E3 		mov	r1, #38
 2117 10ac FEFFFFEB 		bl	cmdSet
 2118              	.LVL239:
 821:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2119              		.loc 1 821 0
 2120 10b0 1C0094E5 		ldr	r0, [r4, #28]
 2121 10b4 FEFFFFEB 		bl	_txe_mutex_put
 2122              	.LVL240:
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2123              		.loc 1 822 0
 2124 10b8 14309DE5 		ldr	r3, [sp, #20]
 2125 10bc 888088E0 		add	r8, r8, r8, asl #1
 2126              	.LVL241:
 2127 10c0 886186E0 		add	r6, r6, r8, asl #3
 823:../uvc.c      **** 							 break;
 2128              		.loc 1 823 0
 2129 10c4 0120A0E3 		mov	r2, #1
 824:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2130              		.loc 1 824 0
 2131 10c8 FF80A0E3 		mov	r8, #255
 822:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2132              		.loc 1 822 0
 2133 10cc 0D30C6E5 		strb	r3, [r6, #13]
 2134 10d0 0340A0E1 		mov	r4, r3
 823:../uvc.c      **** 							 break;
 2135              		.loc 1 823 0
 2136 10d4 1020C6E5 		strb	r2, [r6, #16]
 2137 10d8 18309DE5 		ldr	r3, [sp, #24]
 824:../uvc.c      **** #if 0	//the brightness is placed by Axreference for invendo camera
 2138              		.loc 1 824 0
 2139 10dc 0860A0E1 		mov	r6, r8
 2140 10e0 93FEFFEA 		b	.L116
 2141              	.LVL242:
 2142              	.L159:
 678:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2143              		.loc 1 678 0
 2144 10e4 44389FE5 		ldr	r3, .L195
 679:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2145              		.loc 1 679 0
 2146 10e8 000050E3 		cmp	r0, #0
 678:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2147              		.loc 1 678 0
 2148 10ec 0D03C6E5 		strb	r0, [r6, #781]
 680:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2149              		.loc 1 680 0
 2150 10f0 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 679:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2151              		.loc 1 679 0
 2152 10f4 EF01001A 		bne	.L169
 680:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2153              		.loc 1 680 0
 2154 10f8 020052E3 		cmp	r2, #2
 2155 10fc 08005213 		cmpne	r2, #8
 2156 1100 0300000A 		beq	.L170
 681:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2157              		.loc 1 681 0
 2158 1104 010052E3 		cmp	r2, #1
 682:../uvc.c      **** 									 }else{
 2159              		.loc 1 682 0
 2160 1108 0820A003 		moveq	r2, #8
 684:../uvc.c      **** 									 }
 2161              		.loc 1 684 0
 2162 110c 0220A013 		movne	r2, #2
 2163 1110 B524C3E5 		strb	r2, [r3, #1205]
 2164              	.LVL243:
 2165              	.L170:
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2166              		.loc 1 706 0
 2167 1114 38489FE5 		ldr	r4, .L195+36
 704:../uvc.c      **** 							 dataIdx = 0;
 2168              		.loc 1 704 0
 2169 1118 0130A0E3 		mov	r3, #1
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2170              		.loc 1 706 0
 2171 111c 1C0094E5 		ldr	r0, [r4, #28]
 2172 1120 0010E0E3 		mvn	r1, #0
 704:../uvc.c      **** 							 dataIdx = 0;
 2173              		.loc 1 704 0
 2174 1124 1033C6E5 		strb	r3, [r6, #784]
 2175              	.LVL244:
 706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2176              		.loc 1 706 0
 2177 1128 FEFFFFEB 		bl	_txe_mutex_get
 2178              	.LVL245:
 707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2179              		.loc 1 707 0
 2180 112c 14209DE5 		ldr	r2, [sp, #20]
 2181 1130 0010A0E3 		mov	r1, #0
 2182 1134 0A30A0E1 		mov	r3, r10
 2183 1138 00208DE5 		str	r2, [sp]
 2184 113c 0400A0E1 		mov	r0, r4
 2185 1140 0B20A0E1 		mov	r2, fp
 2186 1144 04108DE5 		str	r1, [sp, #4]
 2187 1148 1010A0E3 		mov	r1, #16
 2188 114c FEFFFFEB 		bl	cmdSet
 2189              	.LVL246:
 710:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 2190              		.loc 1 710 0
 2191 1150 FF80A0E3 		mov	r8, #255
 2192              	.LVL247:
 708:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 2193              		.loc 1 708 0
 2194 1154 1C0094E5 		ldr	r0, [r4, #28]
 2195 1158 FEFFFFEB 		bl	_txe_mutex_put
 2196              	.LVL248:
 710:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 2197              		.loc 1 710 0
 2198 115c 0860A0E1 		mov	r6, r8
 2199 1160 14409DE5 		ldr	r4, [sp, #20]
 2200 1164 18309DE5 		ldr	r3, [sp, #24]
 2201 1168 71FEFFEA 		b	.L116
 2202              	.LVL249:
 2203              	.L158:
 887:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2204              		.loc 1 887 0
 2205 116c E0479FE5 		ldr	r4, .L195+36
 2206 1170 0010E0E3 		mvn	r1, #0
 2207 1174 1C0094E5 		ldr	r0, [r4, #28]
 2208 1178 10C08DE5 		str	ip, [sp, #16]
 2209 117c FEFFFFEB 		bl	_txe_mutex_get
 2210              	.LVL250:
 888:../uvc.c      **** 							 dataIdx++;
 2211              		.loc 1 888 0
 2212 1180 10C09DE5 		ldr	ip, [sp, #16]
 2213 1184 14009DE5 		ldr	r0, [sp, #20]
 2214 1188 0030A0E3 		mov	r3, #0
 2215 118c 0C20A0E1 		mov	r2, ip
 2216 1190 00008DE5 		str	r0, [sp]
 2217 1194 04308DE5 		str	r3, [sp, #4]
 2218 1198 0400A0E1 		mov	r0, r4
 2219 119c 0B10A0E3 		mov	r1, #11
 2220 11a0 0A30A0E1 		mov	r3, r10
 2221 11a4 FEFFFFEB 		bl	cmdSet
 2222              	.LVL251:
 890:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2223              		.loc 1 890 0
 2224 11a8 18209DE5 		ldr	r2, [sp, #24]
 2225 11ac 0170A0E3 		mov	r7, #1
 2226 11b0 0A30A0E1 		mov	r3, r10
 2227 11b4 00208DE5 		str	r2, [sp]
 2228 11b8 0400A0E1 		mov	r0, r4
 2229 11bc 0B20A0E1 		mov	r2, fp
 2230 11c0 0B10A0E3 		mov	r1, #11
 2231 11c4 04708DE5 		str	r7, [sp, #4]
 2232 11c8 FEFFFFEB 		bl	cmdSet
 2233              	.LVL252:
 891:../uvc.c      **** 
 2234              		.loc 1 891 0
 2235 11cc 1C0094E5 		ldr	r0, [r4, #28]
 2236 11d0 FEFFFFEB 		bl	_txe_mutex_put
 2237              	.LVL253:
 894:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2238              		.loc 1 894 0
 2239 11d4 18009DE5 		ldr	r0, [sp, #24]
 2240 11d8 14409DE5 		ldr	r4, [sp, #20]
 896:../uvc.c      **** 						 case MFreqCtlID4:
 2241              		.loc 1 896 0
 2242 11dc FF80A0E3 		mov	r8, #255
 2243              	.LVL254:
 895:../uvc.c      **** 							 break;
 2244              		.loc 1 895 0
 2245 11e0 9872C6E5 		strb	r7, [r6, #664]
 893:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2246              		.loc 1 893 0
 2247 11e4 8C44C6E5 		strb	r4, [r6, #1164]
 894:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2248              		.loc 1 894 0
 2249 11e8 8E04C6E5 		strb	r0, [r6, #1166]
 2250 11ec 0030A0E1 		mov	r3, r0
 896:../uvc.c      **** 						 case MFreqCtlID4:
 2251              		.loc 1 896 0
 2252 11f0 0860A0E1 		mov	r6, r8
 2253 11f4 4EFEFFEA 		b	.L116
 2254              	.LVL255:
 2255              	.L157:
 873:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2256              		.loc 1 873 0
 2257 11f8 54479FE5 		ldr	r4, .L195+36
 2258 11fc 0010E0E3 		mvn	r1, #0
 2259 1200 1C0094E5 		ldr	r0, [r4, #28]
 2260 1204 10C08DE5 		str	ip, [sp, #16]
 2261 1208 FEFFFFEB 		bl	_txe_mutex_get
 2262              	.LVL256:
 874:../uvc.c      **** 							 dataIdx++;
 2263              		.loc 1 874 0
 2264 120c 14009DE5 		ldr	r0, [sp, #20]
 2265 1210 0030A0E3 		mov	r3, #0
 2266 1214 00008DE5 		str	r0, [sp]
 2267 1218 0B20A0E1 		mov	r2, fp
 2268 121c 0400A0E1 		mov	r0, r4
 2269 1220 04308DE5 		str	r3, [sp, #4]
 2270 1224 0610A0E3 		mov	r1, #6
 2271 1228 0A30A0E1 		mov	r3, r10
 2272 122c FEFFFFEB 		bl	cmdSet
 2273              	.LVL257:
 876:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2274              		.loc 1 876 0
 2275 1230 14209DE5 		ldr	r2, [sp, #20]
 2276 1234 10C09DE5 		ldr	ip, [sp, #16]
 2277 1238 0170A0E3 		mov	r7, #1
 2278 123c 0A30A0E1 		mov	r3, r10
 2279 1240 00208DE5 		str	r2, [sp]
 2280 1244 0400A0E1 		mov	r0, r4
 2281 1248 0C20A0E1 		mov	r2, ip
 2282 124c 0610A0E3 		mov	r1, #6
 2283 1250 04708DE5 		str	r7, [sp, #4]
 2284 1254 FEFFFFEB 		bl	cmdSet
 2285              	.LVL258:
 877:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2286              		.loc 1 877 0
 2287 1258 1C0094E5 		ldr	r0, [r4, #28]
 2288 125c FEFFFFEB 		bl	_txe_mutex_put
 2289              	.LVL259:
 2290 1260 14409DE5 		ldr	r4, [sp, #20]
 880:../uvc.c      **** 
 2291              		.loc 1 880 0
 2292 1264 FF80A0E3 		mov	r8, #255
 2293              	.LVL260:
 879:../uvc.c      **** 							 break;
 2294              		.loc 1 879 0
 2295 1268 2072C6E5 		strb	r7, [r6, #544]
 878:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2296              		.loc 1 878 0
 2297 126c 1D42C6E5 		strb	r4, [r6, #541]
 2298 1270 18309DE5 		ldr	r3, [sp, #24]
 880:../uvc.c      **** 
 2299              		.loc 1 880 0
 2300 1274 0860A0E1 		mov	r6, r8
 2301 1278 2DFEFFEA 		b	.L116
 2302              	.LVL261:
 2303              	.L156:
 853:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2304              		.loc 1 853 0
 2305 127c D0469FE5 		ldr	r4, .L195+36
 2306 1280 0010E0E3 		mvn	r1, #0
 2307 1284 1C0094E5 		ldr	r0, [r4, #28]
 2308 1288 10C08DE5 		str	ip, [sp, #16]
 2309 128c FEFFFFEB 		bl	_txe_mutex_get
 2310              	.LVL262:
 854:../uvc.c      **** 							 dataIdx++;
 2311              		.loc 1 854 0
 2312 1290 14009DE5 		ldr	r0, [sp, #20]
 2313 1294 0030A0E3 		mov	r3, #0
 2314 1298 801040E2 		sub	r1, r0, #128
 2315 129c FF1001E2 		and	r1, r1, #255
 2316 12a0 0B20A0E1 		mov	r2, fp
 2317 12a4 00108DE5 		str	r1, [sp]
 2318 12a8 0400A0E1 		mov	r0, r4
 2319 12ac 04308DE5 		str	r3, [sp, #4]
 2320 12b0 0510A0E3 		mov	r1, #5
 2321 12b4 0A30A0E1 		mov	r3, r10
 2322 12b8 FEFFFFEB 		bl	cmdSet
 2323              	.LVL263:
 856:../uvc.c      **** 							 dataIdx++;
 2324              		.loc 1 856 0
 2325 12bc 14209DE5 		ldr	r2, [sp, #20]
 2326 12c0 0190A0E3 		mov	r9, #1
 2327 12c4 763042E2 		sub	r3, r2, #118
 2328 12c8 FF3003E2 		and	r3, r3, #255
 2329 12cc 00308DE5 		str	r3, [sp]
 2330 12d0 0400A0E1 		mov	r0, r4
 2331 12d4 0510A0E3 		mov	r1, #5
 2332 12d8 DC20A0E3 		mov	r2, #220
 2333 12dc 0A30A0E1 		mov	r3, r10
 2334 12e0 04908DE5 		str	r9, [sp, #4]
 2335 12e4 FEFFFFEB 		bl	cmdSet
 2336              	.LVL264:
 858:../uvc.c      **** 							 dataIdx++;
 2337              		.loc 1 858 0
 2338 12e8 14309DE5 		ldr	r3, [sp, #20]
 2339 12ec 0400A0E1 		mov	r0, r4
 2340 12f0 7E2083E2 		add	r2, r3, #126
 2341 12f4 FF2002E2 		and	r2, r2, #255
 2342 12f8 0230A0E3 		mov	r3, #2
 2343 12fc 00208DE5 		str	r2, [sp]
 2344 1300 04308DE5 		str	r3, [sp, #4]
 2345 1304 0510A0E3 		mov	r1, #5
 2346 1308 DE20A0E3 		mov	r2, #222
 2347 130c 0A30A0E1 		mov	r3, r10
 2348 1310 FEFFFFEB 		bl	cmdSet
 2349              	.LVL265:
 860:../uvc.c      **** 							 dataIdx++;
 2350              		.loc 1 860 0
 2351 1314 14009DE5 		ldr	r0, [sp, #20]
 2352 1318 0330A0E3 		mov	r3, #3
 2353 131c 722080E2 		add	r2, r0, #114
 2354 1320 FF2002E2 		and	r2, r2, #255
 2355 1324 00208DE5 		str	r2, [sp]
 2356 1328 0400A0E1 		mov	r0, r4
 2357 132c 04308DE5 		str	r3, [sp, #4]
 2358 1330 0510A0E3 		mov	r1, #5
 2359 1334 E020A0E3 		mov	r2, #224
 2360 1338 0A30A0E1 		mov	r3, r10
 2361 133c FEFFFFEB 		bl	cmdSet
 2362              	.LVL266:
 862:../uvc.c      **** 							 dataIdx++;
 2363              		.loc 1 862 0
 2364 1340 14309DE5 		ldr	r3, [sp, #20]
 2365 1344 0400A0E1 		mov	r0, r4
 2366 1348 6F2043E2 		sub	r2, r3, #111
 2367 134c FF2002E2 		and	r2, r2, #255
 2368 1350 0430A0E3 		mov	r3, #4
 2369 1354 00208DE5 		str	r2, [sp]
 2370 1358 04308DE5 		str	r3, [sp, #4]
 2371 135c 0510A0E3 		mov	r1, #5
 2372 1360 DD20A0E3 		mov	r2, #221
 2373 1364 0A30A0E1 		mov	r3, r10
 2374 1368 FEFFFFEB 		bl	cmdSet
 2375              	.LVL267:
 864:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2376              		.loc 1 864 0
 2377 136c 9C00D7E5 		ldrb	r0, [r7, #156]	@ zero_extendqisi2
 2378 1370 10C09DE5 		ldr	ip, [sp, #16]
 2379 1374 7F0080E2 		add	r0, r0, #127
 2380 1378 0510A0E3 		mov	r1, #5
 2381 137c FF0000E2 		and	r0, r0, #255
 2382 1380 0A30A0E1 		mov	r3, r10
 2383 1384 0C20A0E1 		mov	r2, ip
 2384 1388 00008DE5 		str	r0, [sp]
 2385 138c 04108DE5 		str	r1, [sp, #4]
 2386 1390 0400A0E1 		mov	r0, r4
 2387 1394 FEFFFFEB 		bl	cmdSet
 2388              	.LVL268:
 865:../uvc.c      **** 
 2389              		.loc 1 865 0
 2390 1398 1C0094E5 		ldr	r0, [r4, #28]
 2391 139c FEFFFFEB 		bl	_txe_mutex_put
 2392              	.LVL269:
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2393              		.loc 1 867 0
 2394 13a0 9C30D7E5 		ldrb	r3, [r7, #156]	@ zero_extendqisi2
 869:../uvc.c      **** 						 case SaturCtlID6:
 2395              		.loc 1 869 0
 2396 13a4 FF80A0E3 		mov	r8, #255
 2397              	.LVL270:
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2398              		.loc 1 867 0
 2399 13a8 803043E2 		sub	r3, r3, #128
 2400 13ac 0532C6E5 		strb	r3, [r6, #517]
 868:../uvc.c      **** 							 break;
 2401              		.loc 1 868 0
 2402 13b0 0892C6E5 		strb	r9, [r6, #520]
 2403 13b4 14409DE5 		ldr	r4, [sp, #20]
 2404 13b8 18309DE5 		ldr	r3, [sp, #24]
 869:../uvc.c      **** 						 case SaturCtlID6:
 2405              		.loc 1 869 0
 2406 13bc 0860A0E1 		mov	r6, r8
 2407 13c0 DBFDFFEA 		b	.L116
 2408              	.LVL271:
 2409              	.L155:
 905:../uvc.c      **** 							 //remove for Invendo
 2410              		.loc 1 905 0
 2411 13c4 88459FE5 		ldr	r4, .L195+36
 899:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 2412              		.loc 1 899 0
 2413 13c8 017040E2 		sub	r7, r0, #1
 905:../uvc.c      **** 							 //remove for Invendo
 2414              		.loc 1 905 0
 2415 13cc 0010E0E3 		mvn	r1, #0
 2416 13d0 1C0094E5 		ldr	r0, [r4, #28]
 2417 13d4 FEFFFFEB 		bl	_txe_mutex_get
 2418              	.LVL272:
 899:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 2419              		.loc 1 899 0
 2420 13d8 FF7007E2 		and	r7, r7, #255
 2421              	.LVL273:
 908:../uvc.c      **** 
 2422              		.loc 1 908 0
 2423 13dc 1C0094E5 		ldr	r0, [r4, #28]
 2424 13e0 FEFFFFEB 		bl	_txe_mutex_put
 2425              	.LVL274:
 903:../uvc.c      **** 
 2426              		.loc 1 903 0
 2427 13e4 020057E3 		cmp	r7, #2
 2428 13e8 0170A083 		movhi	r7, #1
 2429              	.LVL275:
 911:../uvc.c      **** 							 break;
 2430              		.loc 1 911 0
 2431 13ec 0120A0E3 		mov	r2, #1
 912:../uvc.c      **** 					 	 case BLCCtlID0:
 2432              		.loc 1 912 0
 2433 13f0 FF80A0E3 		mov	r8, #255
 2434              	.LVL276:
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2435              		.loc 1 910 0
 2436 13f4 ED71C6E5 		strb	r7, [r6, #493]
 911:../uvc.c      **** 							 break;
 2437              		.loc 1 911 0
 2438 13f8 F021C6E5 		strb	r2, [r6, #496]
 2439 13fc 14409DE5 		ldr	r4, [sp, #20]
 2440 1400 18309DE5 		ldr	r3, [sp, #24]
 912:../uvc.c      **** 					 	 case BLCCtlID0:
 2441              		.loc 1 912 0
 2442 1404 0860A0E1 		mov	r6, r8
 2443 1408 C9FDFFEA 		b	.L116
 2444              	.LVL277:
 2445              	.L153:
 914:../uvc.c      **** 							 if(Data0 == 3)
 2446              		.loc 1 914 0
 2447 140c 1C359FE5 		ldr	r3, .L195
 915:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2448              		.loc 1 915 0
 2449 1410 030050E3 		cmp	r0, #3
 916:../uvc.c      **** 							 else
 2450              		.loc 1 916 0
 2451 1414 0120A003 		moveq	r2, #1
 914:../uvc.c      **** 							 if(Data0 == 3)
 2452              		.loc 1 914 0
 2453 1418 8D01C6E5 		strb	r0, [r6, #397]
 916:../uvc.c      **** 							 else
 2454              		.loc 1 916 0
 2455 141c BC208705 		streq	r2, [r7, #188]
 919:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2456              		.loc 1 919 0
 2457 1420 9021C305 		streqb	r2, [r3, #400]
 915:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2458              		.loc 1 915 0
 2459 1424 0800000A 		beq	.L180
 922:../uvc.c      **** 					 				 ;//Data0 += 4;
 2460              		.loc 1 922 0
 2461 1428 14009DE5 		ldr	r0, [sp, #20]
 918:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2462              		.loc 1 918 0
 2463 142c 0010A0E3 		mov	r1, #0
 922:../uvc.c      **** 					 				 ;//Data0 += 4;
 2464              		.loc 1 922 0
 2465 1430 010050E3 		cmp	r0, #1
 919:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2466              		.loc 1 919 0
 2467 1434 0120A0E3 		mov	r2, #1
 2468 1438 0040A091 		movls	r4, r0
 918:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2469              		.loc 1 918 0
 2470 143c BC1087E5 		str	r1, [r7, #188]
 919:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2471              		.loc 1 919 0
 2472 1440 9021C3E5 		strb	r2, [r3, #400]
 922:../uvc.c      **** 					 				 ;//Data0 += 4;
 2473              		.loc 1 922 0
 2474 1444 0460A091 		movls	r6, r4
 2475 1448 0800009A 		bls	.L181
 2476              	.L180:
 925:../uvc.c      **** 									Data0 = 0; //set to default.
 2477              		.loc 1 925 0
 2478 144c 14409DE5 		ldr	r4, [sp, #20]
 2479 1450 0120A0E3 		mov	r2, #1
 2480 1454 0430A0E1 		mov	r3, r4
 2481 1458 0400A0E3 		mov	r0, #4
 2482 145c F4149FE5 		ldr	r1, .L195+40
 2483 1460 FEFFFFEB 		bl	CyU3PDebugPrint
 2484              	.LVL278:
 2485 1464 0020A0E3 		mov	r2, #0
 926:../uvc.c      **** 					 			 }
 2486              		.loc 1 926 0
 2487 1468 0260A0E1 		mov	r6, r2
 925:../uvc.c      **** 									Data0 = 0; //set to default.
 2488              		.loc 1 925 0
 2489 146c 14208DE5 		str	r2, [sp, #20]
 2490              	.LVL279:
 2491              	.L181:
 931:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2492              		.loc 1 931 0
 2493 1470 DC849FE5 		ldr	r8, .L195+36
 2494              	.LVL280:
 2495 1474 0010E0E3 		mvn	r1, #0
 2496 1478 1C0098E5 		ldr	r0, [r8, #28]
 2497 147c FEFFFFEB 		bl	_txe_mutex_get
 2498              	.LVL281:
 932:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2499              		.loc 1 932 0
 2500 1480 14309DE5 		ldr	r3, [sp, #20]
 2501 1484 0010A0E3 		mov	r1, #0
 2502 1488 0B20A0E1 		mov	r2, fp
 2503 148c 04108DE5 		str	r1, [sp, #4]
 2504 1490 00308DE5 		str	r3, [sp]
 2505 1494 0800A0E1 		mov	r0, r8
 2506 1498 0A30A0E1 		mov	r3, r10
 2507 149c FEFFFFEB 		bl	cmdSet
 2508              	.LVL282:
 933:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2509              		.loc 1 933 0
 2510 14a0 1C0098E5 		ldr	r0, [r8, #28]
 2511 14a4 FEFFFFEB 		bl	_txe_mutex_put
 2512              	.LVL283:
 934:../uvc.c      **** 
 2513              		.loc 1 934 0
 2514 14a8 9E00D7E5 		ldrb	r0, [r7, #158]	@ zero_extendqisi2
 2515 14ac 9F10D7E5 		ldrb	r1, [r7, #159]	@ zero_extendqisi2
 2516 14b0 BC3097E5 		ldr	r3, [r7, #188]
 2517 14b4 0620A0E1 		mov	r2, r6
 2518 14b8 03008DE8 		stmia	sp, {r0, r1}
 2519 14bc 98149FE5 		ldr	r1, .L195+44
 2520 14c0 0400A0E3 		mov	r0, #4
 936:../uvc.c      **** 						 default:
 2521              		.loc 1 936 0
 2522 14c4 FF80A0E3 		mov	r8, #255
 934:../uvc.c      **** 
 2523              		.loc 1 934 0
 2524 14c8 FEFFFFEB 		bl	CyU3PDebugPrint
 2525              	.LVL284:
 936:../uvc.c      **** 						 default:
 2526              		.loc 1 936 0
 2527 14cc 0860A0E1 		mov	r6, r8
 2528 14d0 18309DE5 		ldr	r3, [sp, #24]
 2529 14d4 96FDFFEA 		b	.L116
 2530              	.LVL285:
 2531              	.L163:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2532              		.loc 1 762 0
 2533 14d8 74449FE5 		ldr	r4, .L195+36
 2534 14dc 0010E0E3 		mvn	r1, #0
 2535 14e0 1C0094E5 		ldr	r0, [r4, #28]
 2536 14e4 FEFFFFEB 		bl	_txe_mutex_get
 2537              	.LVL286:
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2538              		.loc 1 763 0
 2539 14e8 14209DE5 		ldr	r2, [sp, #20]
 2540 14ec 0010A0E3 		mov	r1, #0
 2541 14f0 01C072E2 		rsbs	ip, r2, #1
 2542 14f4 00C0A033 		movcc	ip, #0
 2543 14f8 0B20A0E1 		mov	r2, fp
 2544 14fc 0A30A0E1 		mov	r3, r10
 2545 1500 0400A0E1 		mov	r0, r4
 2546 1504 00C08DE5 		str	ip, [sp]
 2547 1508 04108DE5 		str	r1, [sp, #4]
 2548 150c 1E10A0E3 		mov	r1, #30
 2549 1510 FEFFFFEB 		bl	cmdSet
 2550              	.LVL287:
 764:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2551              		.loc 1 764 0
 2552 1514 1C0094E5 		ldr	r0, [r4, #28]
 2553 1518 FEFFFFEB 		bl	_txe_mutex_put
 2554              	.LVL288:
 766:../uvc.c      **** 						 case ExtI2CCtlID15:
 2555              		.loc 1 766 0
 2556 151c FF80A0E3 		mov	r8, #255
 2557              	.LVL289:
 765:../uvc.c      **** 							 break;
 2558              		.loc 1 765 0
 2559 1520 0120A0E3 		mov	r2, #1
 2560 1524 6024C6E5 		strb	r2, [r6, #1120]
 2561 1528 14409DE5 		ldr	r4, [sp, #20]
 2562 152c 18309DE5 		ldr	r3, [sp, #24]
 766:../uvc.c      **** 						 case ExtI2CCtlID15:
 2563              		.loc 1 766 0
 2564 1530 0860A0E1 		mov	r6, r8
 2565 1534 7EFDFFEA 		b	.L116
 2566              	.LVL290:
 2567              	.L162:
 675:../uvc.c      **** 					 {
 2568              		.loc 1 675 0
 2569 1538 FF80A0E3 		mov	r8, #255
 2570              	.LVL291:
 2571 153c 0040A0E1 		mov	r4, r0
 2572              	.LVL292:
 2573 1540 0860A0E1 		mov	r6, r8
 2574 1544 7AFDFFEA 		b	.L116
 2575              	.LVL293:
 2576              	.L161:
 729:../uvc.c      **** 							 if(WDRflag)
 2577              		.loc 1 729 0
 2578 1548 04449FE5 		ldr	r4, .L195+36
 2579 154c 0020A0E1 		mov	r2, r0
 2580 1550 0010E0E3 		mvn	r1, #0
 728:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2581              		.loc 1 728 0
 2582 1554 0130A0E3 		mov	r3, #1
 729:../uvc.c      **** 							 if(WDRflag)
 2583              		.loc 1 729 0
 2584 1558 1C0094E5 		ldr	r0, [r4, #28]
 727:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2585              		.loc 1 727 0
 2586 155c FD23C6E5 		strb	r2, [r6, #1021]
 728:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2587              		.loc 1 728 0
 2588 1560 0034C6E5 		strb	r3, [r6, #1024]
 729:../uvc.c      **** 							 if(WDRflag)
 2589              		.loc 1 729 0
 2590 1564 10C08DE5 		str	ip, [sp, #16]
 2591 1568 FEFFFFEB 		bl	_txe_mutex_get
 2592              	.LVL294:
 730:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2593              		.loc 1 730 0
 2594 156c BC3097E5 		ldr	r3, [r7, #188]
 2595 1570 10C09DE5 		ldr	ip, [sp, #16]
 2596 1574 000053E3 		cmp	r3, #0
 731:../uvc.c      **** 							 else
 2597              		.loc 1 731 0
 2598 1578 14309D15 		ldrne	r3, [sp, #20]
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2599              		.loc 1 733 0
 2600 157c 14009D05 		ldreq	r0, [sp, #20]
 731:../uvc.c      **** 							 else
 2601              		.loc 1 731 0
 2602 1580 0010A013 		movne	r1, #0
 2603 1584 00308D15 		strne	r3, [sp]
 2604 1588 0C20A011 		movne	r2, ip
 2605 158c 0A30A011 		movne	r3, r10
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2606              		.loc 1 733 0
 2607 1590 0B20A001 		moveq	r2, fp
 735:../uvc.c      **** 						 case ExtCamMCtlID12:
 2608              		.loc 1 735 0
 2609 1594 FF80A0E3 		mov	r8, #255
 2610              	.LVL295:
 2611 1598 0860A0E1 		mov	r6, r8
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2612              		.loc 1 733 0
 2613 159c 09008D08 		stmeqia	sp, {r0, r3}
 731:../uvc.c      **** 							 else
 2614              		.loc 1 731 0
 2615 15a0 04108D15 		strne	r1, [sp, #4]
 733:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2616              		.loc 1 733 0
 2617 15a4 0A30A001 		moveq	r3, r10
 2618 15a8 1A10A0E3 		mov	r1, #26
 2619 15ac 0400A0E1 		mov	r0, r4
 2620 15b0 FEFFFFEB 		bl	cmdSet
 2621              	.LVL296:
 734:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2622              		.loc 1 734 0
 2623 15b4 1C0094E5 		ldr	r0, [r4, #28]
 2624 15b8 FEFFFFEB 		bl	_txe_mutex_put
 2625              	.LVL297:
 735:../uvc.c      **** 						 case ExtCamMCtlID12:
 2626              		.loc 1 735 0
 2627 15bc 9E00D7E5 		ldrb	r0, [r7, #158]	@ zero_extendqisi2
 2628 15c0 9F10D7E5 		ldrb	r1, [r7, #159]	@ zero_extendqisi2
 2629 15c4 14409DE5 		ldr	r4, [sp, #20]
 2630 15c8 BC3097E5 		ldr	r3, [r7, #188]
 2631 15cc 0420A0E1 		mov	r2, r4
 2632 15d0 03008DE8 		stmia	sp, {r0, r1}
 2633 15d4 84139FE5 		ldr	r1, .L195+48
 2634 15d8 0400A0E3 		mov	r0, #4
 2635 15dc FEFFFFEB 		bl	CyU3PDebugPrint
 2636              	.LVL298:
 2637 15e0 18309DE5 		ldr	r3, [sp, #24]
 2638 15e4 52FDFFEA 		b	.L116
 2639              	.LVL299:
 2640              	.L160:
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2641              		.loc 1 716 0
 2642 15e8 64439FE5 		ldr	r4, .L195+36
 2643 15ec 0020A0E1 		mov	r2, r0
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2644              		.loc 1 712 0
 2645 15f0 E523C6E5 		strb	r2, [r6, #997]
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2646              		.loc 1 713 0
 2647 15f4 18209DE5 		ldr	r2, [sp, #24]
 714:../uvc.c      **** 							 dataIdx = 0;
 2648              		.loc 1 714 0
 2649 15f8 0130A0E3 		mov	r3, #1
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2650              		.loc 1 716 0
 2651 15fc 1C0094E5 		ldr	r0, [r4, #28]
 2652 1600 0010E0E3 		mvn	r1, #0
 713:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2653              		.loc 1 713 0
 2654 1604 E623C6E5 		strb	r2, [r6, #998]
 714:../uvc.c      **** 							 dataIdx = 0;
 2655              		.loc 1 714 0
 2656 1608 E833C6E5 		strb	r3, [r6, #1000]
 2657              	.LVL300:
 716:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2658              		.loc 1 716 0
 2659 160c 10C08DE5 		str	ip, [sp, #16]
 2660 1610 FEFFFFEB 		bl	_txe_mutex_get
 2661              	.LVL301:
 720:../uvc.c      **** 							 }
 2662              		.loc 1 720 0
 2663 1614 10C09DE5 		ldr	ip, [sp, #16]
 2664 1618 18309DE5 		ldr	r3, [sp, #24]
 2665 161c 0010A0E3 		mov	r1, #0
 2666 1620 0C20A0E1 		mov	r2, ip
 2667 1624 00308DE5 		str	r3, [sp]
 2668 1628 0400A0E1 		mov	r0, r4
 2669 162c 0A30A0E1 		mov	r3, r10
 2670 1630 04108DE5 		str	r1, [sp, #4]
 2671 1634 1910A0E3 		mov	r1, #25
 2672 1638 FEFFFFEB 		bl	cmdSet
 2673              	.LVL302:
 722:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2674              		.loc 1 722 0
 2675 163c 1C0094E5 		ldr	r0, [r4, #28]
 2676 1640 FEFFFFEB 		bl	_txe_mutex_put
 2677              	.LVL303:
 723:../uvc.c      **** 							 break;
 2678              		.loc 1 723 0
 2679 1644 9E00D7E5 		ldrb	r0, [r7, #158]	@ zero_extendqisi2
 2680 1648 9F10D7E5 		ldrb	r1, [r7, #159]	@ zero_extendqisi2
 2681 164c 9D30D7E5 		ldrb	r3, [r7, #157]	@ zero_extendqisi2
 2682 1650 9C20D7E5 		ldrb	r2, [r7, #156]	@ zero_extendqisi2
 724:../uvc.c      **** 						 case ExtExRefCtlID10:
 2683              		.loc 1 724 0
 2684 1654 FF80A0E3 		mov	r8, #255
 2685              	.LVL304:
 723:../uvc.c      **** 							 break;
 2686              		.loc 1 723 0
 2687 1658 03008DE8 		stmia	sp, {r0, r1}
 2688 165c 00139FE5 		ldr	r1, .L195+52
 2689 1660 0400A0E3 		mov	r0, #4
 2690 1664 FEFFFFEB 		bl	CyU3PDebugPrint
 2691              	.LVL305:
 724:../uvc.c      **** 						 case ExtExRefCtlID10:
 2692              		.loc 1 724 0
 2693 1668 0860A0E1 		mov	r6, r8
 2694 166c 14409DE5 		ldr	r4, [sp, #20]
 2695 1670 18309DE5 		ldr	r3, [sp, #24]
 2696 1674 2EFDFFEA 		b	.L116
 2697              	.LVL306:
 2698              	.L165:
 797:../uvc.c      **** 						     /* end test */
 2699              		.loc 1 797 0
 2700 1678 D4429FE5 		ldr	r4, .L195+36
 2701 167c 0010E0E3 		mvn	r1, #0
 2702 1680 1C0094E5 		ldr	r0, [r4, #28]
 2703 1684 10C08DE5 		str	ip, [sp, #16]
 2704 1688 FEFFFFEB 		bl	_txe_mutex_get
 2705              	.LVL307:
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2706              		.loc 1 796 0
 2707 168c 14309DE5 		ldr	r3, [sp, #20]
 799:../uvc.c      **** 							 dataIdx++;
 2708              		.loc 1 799 0
 2709 1690 0B20A0E1 		mov	r2, fp
 796:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2710              		.loc 1 796 0
 2711 1694 7F7003E2 		and	r7, r3, #127
 2712              	.LVL308:
 799:../uvc.c      **** 							 dataIdx++;
 2713              		.loc 1 799 0
 2714 1698 0030A0E3 		mov	r3, #0
 2715 169c 0400A0E1 		mov	r0, r4
 2716 16a0 04308DE5 		str	r3, [sp, #4]
 2717 16a4 2410A0E3 		mov	r1, #36
 2718 16a8 0A30A0E1 		mov	r3, r10
 2719 16ac 00708DE5 		str	r7, [sp]
 2720 16b0 FEFFFFEB 		bl	cmdSet
 2721              	.LVL309:
 801:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2722              		.loc 1 801 0
 2723 16b4 1C009DE5 		ldr	r0, [sp, #28]
 2724 16b8 10C09DE5 		ldr	ip, [sp, #16]
 2725 16bc 0190A0E3 		mov	r9, #1
 2726 16c0 0C20A0E1 		mov	r2, ip
 2727 16c4 0A30A0E1 		mov	r3, r10
 2728 16c8 00008DE5 		str	r0, [sp]
 2729 16cc 2410A0E3 		mov	r1, #36
 2730 16d0 0400A0E1 		mov	r0, r4
 2731 16d4 04908DE5 		str	r9, [sp, #4]
 2732 16d8 FEFFFFEB 		bl	cmdSet
 2733              	.LVL310:
 802:../uvc.c      **** 							 getData1 = Data1;
 2734              		.loc 1 802 0
 2735 16dc 1C0094E5 		ldr	r0, [r4, #28]
 2736 16e0 FEFFFFEB 		bl	_txe_mutex_put
 2737              	.LVL311:
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2738              		.loc 1 806 0
 2739 16e4 1C209DE5 		ldr	r2, [sp, #28]
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2740              		.loc 1 805 0
 2741 16e8 888088E0 		add	r8, r8, r8, asl #1
 2742              	.LVL312:
 2743 16ec 886186E0 		add	r6, r6, r8, asl #3
 808:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 2744              		.loc 1 808 0
 2745 16f0 FF80A0E3 		mov	r8, #255
 805:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2746              		.loc 1 805 0
 2747 16f4 0D70C6E5 		strb	r7, [r6, #13]
 806:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2748              		.loc 1 806 0
 2749 16f8 0E20C6E5 		strb	r2, [r6, #14]
 807:../uvc.c      **** 							 break;
 2750              		.loc 1 807 0
 2751 16fc 1090C6E5 		strb	r9, [r6, #16]
 2752 1700 14409DE5 		ldr	r4, [sp, #20]
 2753 1704 0230A0E1 		mov	r3, r2
 808:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 2754              		.loc 1 808 0
 2755 1708 0860A0E1 		mov	r6, r8
 2756 170c 08FDFFEA 		b	.L116
 2757              	.LVL313:
 2758              	.L164:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2759              		.loc 1 768 0 discriminator 1
 2760 1710 000059E3 		cmp	r9, #0
 2761 1714 0300000A 		beq	.L177
 2762 1718 48029FE5 		ldr	r0, .L195+56
 2763 171c 0920A0E1 		mov	r2, r9
 2764 1720 0C1080E2 		add	r1, r0, #12
 2765 1724 FEFFFFEB 		bl	memcpy
 2766              	.LVL314:
 2767              	.L177:
 772:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 2768              		.loc 1 772 0
 2769 1728 FF80A0E3 		mov	r8, #255
 2770              	.LVL315:
 771:../uvc.c      **** 							 break;
 2771              		.loc 1 771 0
 2772 172c FEFFFFEB 		bl	I2CCmdHandler
 2773              	.LVL316:
 772:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 2774              		.loc 1 772 0
 2775 1730 0860A0E1 		mov	r6, r8
 2776 1734 14409DE5 		ldr	r4, [sp, #20]
 2777              	.LVL317:
 2778 1738 18309DE5 		ldr	r3, [sp, #24]
 2779 173c FCFCFFEA 		b	.L116
 2780              	.LVL318:
 2781              	.L166:
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2782              		.loc 1 811 0
 2783 1740 0C429FE5 		ldr	r4, .L195+36
 2784 1744 0010E0E3 		mvn	r1, #0
 2785 1748 1C0094E5 		ldr	r0, [r4, #28]
 2786 174c FEFFFFEB 		bl	_txe_mutex_get
 2787              	.LVL319:
 812:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2788              		.loc 1 812 0
 2789 1750 14309DE5 		ldr	r3, [sp, #20]
 2790 1754 0010A0E3 		mov	r1, #0
 2791 1758 0B20A0E1 		mov	r2, fp
 2792 175c 00308DE5 		str	r3, [sp]
 2793 1760 0400A0E1 		mov	r0, r4
 2794 1764 0A30A0E1 		mov	r3, r10
 2795 1768 04108DE5 		str	r1, [sp, #4]
 2796 176c 2510A0E3 		mov	r1, #37
 2797 1770 FEFFFFEB 		bl	cmdSet
 2798              	.LVL320:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2799              		.loc 1 813 0
 2800 1774 1C0094E5 		ldr	r0, [r4, #28]
 2801 1778 FEFFFFEB 		bl	_txe_mutex_put
 2802              	.LVL321:
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2803              		.loc 1 814 0
 2804 177c 14009DE5 		ldr	r0, [sp, #20]
 2805 1780 888088E0 		add	r8, r8, r8, asl #1
 2806              	.LVL322:
 2807 1784 886186E0 		add	r6, r6, r8, asl #3
 815:../uvc.c      **** 							 break;
 2808              		.loc 1 815 0
 2809 1788 0120A0E3 		mov	r2, #1
 816:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 2810              		.loc 1 816 0
 2811 178c FF80A0E3 		mov	r8, #255
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2812              		.loc 1 814 0
 2813 1790 0D00C6E5 		strb	r0, [r6, #13]
 815:../uvc.c      **** 							 break;
 2814              		.loc 1 815 0
 2815 1794 1020C6E5 		strb	r2, [r6, #16]
 2816 1798 0040A0E1 		mov	r4, r0
 2817 179c 18309DE5 		ldr	r3, [sp, #24]
 816:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 2818              		.loc 1 816 0
 2819 17a0 0860A0E1 		mov	r6, r8
 2820 17a4 E2FCFFEA 		b	.L116
 2821              	.LVL323:
 2822              	.L152:
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2823              		.loc 1 940 0
 2824 17a8 A4719FE5 		ldr	r7, .L195+36
 2825 17ac 0010E0E3 		mvn	r1, #0
 2826 17b0 1C0097E5 		ldr	r0, [r7, #28]
 2827 17b4 FEFFFFEB 		bl	_txe_mutex_get
 2828              	.LVL324:
 941:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2829              		.loc 1 941 0
 2830 17b8 14009DE5 		ldr	r0, [sp, #20]
 2831 17bc 0010A0E3 		mov	r1, #0
 2832 17c0 0B20A0E1 		mov	r2, fp
 2833 17c4 0A30A0E1 		mov	r3, r10
 2834 17c8 00008DE5 		str	r0, [sp]
 2835 17cc 04108DE5 		str	r1, [sp, #4]
 2836 17d0 0700A0E1 		mov	r0, r7
 2837 17d4 0410A0E1 		mov	r1, r4
 2838 17d8 FEFFFFEB 		bl	cmdSet
 2839              	.LVL325:
 942:../uvc.c      **** 
 2840              		.loc 1 942 0
 2841 17dc 1C0097E5 		ldr	r0, [r7, #28]
 2842 17e0 FEFFFFEB 		bl	_txe_mutex_put
 2843              	.LVL326:
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2844              		.loc 1 944 0
 2845 17e4 14309DE5 		ldr	r3, [sp, #20]
 2846 17e8 844084E0 		add	r4, r4, r4, asl #1
 2847 17ec 846186E0 		add	r6, r6, r4, asl #3
 945:../uvc.c      **** 							 break;
 2848              		.loc 1 945 0
 2849 17f0 0120A0E3 		mov	r2, #1
 946:../uvc.c      **** 					 }
 2850              		.loc 1 946 0
 2851 17f4 FF80A0E3 		mov	r8, #255
 2852              	.LVL327:
 944:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2853              		.loc 1 944 0
 2854 17f8 8D31C6E5 		strb	r3, [r6, #397]
 2855 17fc 0340A0E1 		mov	r4, r3
 945:../uvc.c      **** 							 break;
 2856              		.loc 1 945 0
 2857 1800 9021C6E5 		strb	r2, [r6, #400]
 2858 1804 18309DE5 		ldr	r3, [sp, #24]
 946:../uvc.c      **** 					 }
 2859              		.loc 1 946 0
 2860 1808 0860A0E1 		mov	r6, r8
 2861 180c C8FCFFEA 		b	.L116
 2862              	.LVL328:
 2863              	.L151:
 949:../uvc.c      **** 			   }
 2864              		.loc 1 949 0
 2865 1810 FF80A0E3 		mov	r8, #255
 2866              	.LVL329:
 2867 1814 0400A0E3 		mov	r0, #4
 2868              	.LVL330:
 2869 1818 4C119FE5 		ldr	r1, .L195+60
 2870 181c FEFFFFEB 		bl	CyU3PDebugPrint
 2871              	.LVL331:
 2872 1820 0860A0E1 		mov	r6, r8
 2873 1824 0830A0E1 		mov	r3, r8
 2874 1828 0840A0E1 		mov	r4, r8
 2875              	.LVL332:
 2876 182c C0FCFFEA 		b	.L116
 2877              	.LVL333:
 2878              	.L136:
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 2879              		.loc 1 563 0
 2880 1830 0B00A0E1 		mov	r0, fp
 2881              	.LVL334:
 2882 1834 0A10A0E1 		mov	r1, r10
 2883 1838 FEFFFFEB 		bl	SensorGetControl
 2884              	.LVL335:
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2885              		.loc 1 564 0
 2886 183c 844084E0 		add	r4, r4, r4, asl #1
 2887              	.LVL336:
 2888 1840 846186E0 		add	r6, r6, r4, asl #3
 566:../uvc.c      **** 		 	 		 }
 2889              		.loc 1 566 0
 2890 1844 0120A0E3 		mov	r2, #1
 2891 1848 2C20C8E5 		strb	r2, [r8, #44]
 2892 184c 0030A0E1 		mov	r3, r0
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2893              		.loc 1 564 0
 2894 1850 8D01C6E5 		strb	r0, [r6, #397]
 2895 1854 02FEFFEA 		b	.L137
 2896              	.LVL337:
 2897              	.L134:
 542:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 2898              		.loc 1 542 0
 2899 1858 0C00A0E1 		mov	r0, ip
 2900              	.LVL338:
 2901 185c 0A10A0E1 		mov	r1, r10
 2902 1860 FEFFFFEB 		bl	SensorGetControl
 2903              	.LVL339:
 543:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 2904              		.loc 1 543 0
 2905 1864 0A10A0E1 		mov	r1, r10
 542:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd0, devAdd);
 2906              		.loc 1 542 0
 2907 1868 0040A0E1 		mov	r4, r0
 2908              	.LVL340:
 543:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 2909              		.loc 1 543 0
 2910 186c 0B00A0E1 		mov	r0, fp
 2911              	.LVL341:
 2912 1870 FEFFFFEB 		bl	SensorGetControl
 2913              	.LVL342:
 548:../uvc.c      **** 		 	 		 }
 2914              		.loc 1 548 0
 2915 1874 0130A0E3 		mov	r3, #1
 2916 1878 0420A0E1 		mov	r2, r4
 544:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2917              		.loc 1 544 0
 2918 187c 9C40C7E5 		strb	r4, [r7, #156]
 545:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 2919              		.loc 1 545 0
 2920 1880 8C44C6E5 		strb	r4, [r6, #1164]
 548:../uvc.c      **** 		 	 		 }
 2921              		.loc 1 548 0
 2922 1884 3730C7E5 		strb	r3, [r7, #55]
 2923 1888 0080A0E1 		mov	r8, r0
 2924              	.LVL343:
 546:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 2925              		.loc 1 546 0
 2926 188c 9E00C7E5 		strb	r0, [r7, #158]
 547:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 2927              		.loc 1 547 0
 2928 1890 8E04C6E5 		strb	r0, [r6, #1166]
 2929 1894 DCFDFFEA 		b	.L135
 2930              	.LVL344:
 2931              	.L132:
 490:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][14] = glEp0Buffer[2];
 2932              		.loc 1 490 0
 2933 1898 0C00A0E1 		mov	r0, ip
 2934              	.LVL345:
 2935 189c 0A10A0E1 		mov	r1, r10
 2936 18a0 FEFFFFEB 		bl	SensorGetControl
 2937              	.LVL346:
 492:../uvc.c      **** 		 	 		 }
 2938              		.loc 1 492 0
 2939 18a4 0130A0E3 		mov	r3, #1
 2940 18a8 4530C7E5 		strb	r3, [r7, #69]
 2941 18ac 00E0A0E1 		mov	lr, r0
 491:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 2942              		.loc 1 491 0
 2943 18b0 E603C6E5 		strb	r0, [r6, #998]
 2944 18b4 B2FDFFEA 		b	.L133
 2945              	.LVL347:
 2946              	.L169:
 688:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2947              		.loc 1 688 0
 2948 18b8 011040E2 		sub	r1, r0, #1
 689:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2949              		.loc 1 689 0
 2950 18bc 040052E3 		cmp	r2, #4
 2951 18c0 01005213 		cmpne	r2, #1
 688:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2952              		.loc 1 688 0
 2953 18c4 FF1001E2 		and	r1, r1, #255
 2954              	.LVL348:
 689:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2955              		.loc 1 689 0
 2956 18c8 0300000A 		beq	.L172
 690:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2957              		.loc 1 690 0
 2958 18cc 080052E3 		cmp	r2, #8
 691:../uvc.c      **** 									 }else{
 2959              		.loc 1 691 0
 2960 18d0 0120A003 		moveq	r2, #1
 693:../uvc.c      **** 									 }
 2961              		.loc 1 693 0
 2962 18d4 0420A013 		movne	r2, #4
 2963 18d8 B524C3E5 		strb	r2, [r3, #1205]
 2964              	.L172:
 696:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2965              		.loc 1 696 0
 2966 18dc 070051E3 		cmp	r1, #7
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2967              		.loc 1 697 0
 2968 18e0 88309F95 		ldrls	r3, .L195+64
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2969              		.loc 1 700 0
 2970 18e4 0120A083 		movhi	r2, #1
 698:../uvc.c      **** 								 }else{
 2971              		.loc 1 698 0
 2972 18e8 81208390 		addls	r2, r3, r1, asl #1
 2973 18ec 0120D295 		ldrlsb	r2, [r2, #1]	@ zero_extendqisi2
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2974              		.loc 1 697 0
 2975 18f0 8130D397 		ldrlsb	r3, [r3, r1, asl #1]	@ zero_extendqisi2
 701:../uvc.c      **** 								 }
 2976              		.loc 1 701 0
 2977 18f4 0030A083 		movhi	r3, #0
 698:../uvc.c      **** 								 }else{
 2978              		.loc 1 698 0
 2979 18f8 E624C695 		strlsb	r2, [r6, #1254]
 697:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2980              		.loc 1 697 0
 2981 18fc E534C695 		strlsb	r3, [r6, #1253]
 700:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2982              		.loc 1 700 0
 2983 1900 E524C685 		strhib	r2, [r6, #1253]
 701:../uvc.c      **** 								 }
 2984              		.loc 1 701 0
 2985 1904 E634C685 		strhib	r3, [r6, #1254]
 2986 1908 01FEFFEA 		b	.L170
 2987              	.LVL349:
 2988              	.L129:
 453:../uvc.c      **** 							sendData = 0; //set back to default
 2989              		.loc 1 453 0
 2990 190c 0400A0E3 		mov	r0, #4
 2991              	.LVL350:
 2992 1910 0120A0E3 		mov	r2, #1
 2993 1914 3C109FE5 		ldr	r1, .L195+40
 455:../uvc.c      **** 						}
 2994              		.loc 1 455 0
 2995 1918 0060A0E1 		mov	r6, r0
 453:../uvc.c      **** 							sendData = 0; //set back to default
 2996              		.loc 1 453 0
 2997 191c FEFFFFEB 		bl	CyU3PDebugPrint
 2998              	.LVL351:
 455:../uvc.c      **** 						}
 2999              		.loc 1 455 0
 3000 1920 0020A0E3 		mov	r2, #0
 3001 1924 0630A0E1 		mov	r3, r6
 3002 1928 2D24C4E5 		strb	r2, [r4, #1069]
 3003 192c 89FDFFEA 		b	.L130
 3004              	.L196:
 3005              		.align	2
 3006              	.L195:
 3007 1930 00000000 		.word	.LANCHOR1
 3008 1934 00000000 		.word	bRequest
 3009 1938 00000000 		.word	.LANCHOR0
 3010 193c 9C000000 		.word	.LANCHOR0+156
 3011 1940 54030000 		.word	.LC19
 3012 1944 01000100 		.word	65537
 3013 1948 FF00FF00 		.word	16711935
 3014 194c 60020000 		.word	.LC13
 3015 1950 9C020000 		.word	.LC14
 3016 1954 00000000 		.word	cmdQu
 3017 1958 28020000 		.word	.LC12
 3018 195c 0C030000 		.word	.LC17
 3019 1960 F0020000 		.word	.LC16
 3020 1964 C4020000 		.word	.LC15
 3021 1968 90000000 		.word	.LANCHOR0+144
 3022 196c 24030000 		.word	.LC18
 3023 1970 00000000 		.word	.LANCHOR2
 3024              		.cfi_endproc
 3025              	.LFE2:
 3027              		.align	2
 3028              		.global	CTControlHandle
 3030              	CTControlHandle:
 3031              	.LFB3:
 965:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3032              		.loc 1 965 0
 3033              		.cfi_startproc
 3034              		@ args = 0, pretend = 0, frame = 24
 3035              		@ frame_needed = 0, uses_anonymous_args = 0
 3036              	.LVL352:
 3037 1974 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3038              	.LCFI14:
 3039              		.cfi_def_cfa_offset 36
 3040              		.cfi_offset 4, -36
 3041              		.cfi_offset 5, -32
 3042              		.cfi_offset 6, -28
 3043              		.cfi_offset 7, -24
 3044              		.cfi_offset 8, -20
 3045              		.cfi_offset 9, -16
 3046              		.cfi_offset 10, -12
 3047              		.cfi_offset 11, -8
 3048              		.cfi_offset 14, -4
 984:../uvc.c      **** 
 3049              		.loc 1 984 0
 3050 1978 28B89FE5 		ldr	fp, .L235
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3051              		.loc 1 976 0
 3052 197c 28389FE5 		ldr	r3, .L235+4
 984:../uvc.c      **** 
 3053              		.loc 1 984 0
 3054 1980 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3055              		.loc 1 976 0
 3056 1984 8080A0E1 		mov	r8, r0, asl #1
 3057 1988 002088E0 		add	r2, r8, r0
 3058 198c 822183E0 		add	r2, r3, r2, asl #3
 986:../uvc.c      **** 		 {
 3059              		.loc 1 986 0
 3060 1990 830055E3 		cmp	r5, #131
 965:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3061              		.loc 1 965 0
 3062 1994 34D04DE2 		sub	sp, sp, #52
 3063              	.LCFI15:
 3064              		.cfi_def_cfa_offset 88
 965:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 3065              		.loc 1 965 0
 3066 1998 0060A0E1 		mov	r6, r0
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3067              		.loc 1 976 0
 3068 199c 9F94D2E5 		ldrb	r9, [r2, #1183]	@ zero_extendqisi2
 3069              	.LVL353:
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 3070              		.loc 1 977 0
 3071 19a0 90A4D2E5 		ldrb	r10, [r2, #1168]	@ zero_extendqisi2
 3072              	.LVL354:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 3073              		.loc 1 979 0
 3074 19a4 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3075              	.LVL355:
 986:../uvc.c      **** 		 {
 3076              		.loc 1 986 0
 3077 19a8 8000000A 		beq	.L199
 3078 19ac 2600009A 		bls	.L233
 3079 19b0 850055E3 		cmp	r5, #133
 3080 19b4 7200000A 		beq	.L204
 3081 19b8 5000003A 		bcc	.L205
 3082 19bc 860055E3 		cmp	r5, #134
 3083 19c0 4300000A 		beq	.L206
 3084 19c4 870055E3 		cmp	r5, #135
 3085 19c8 5F00001A 		bne	.L198
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3086              		.loc 1 1048 0
 3087 19cc 9BC4D2E5 		ldrb	ip, [r2, #1179]	@ zero_extendqisi2
 3088 19d0 D8479FE5 		ldr	r4, .L235+8
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3089              		.loc 1 1049 0
 3090 19d4 9C24D2E5 		ldrb	r2, [r2, #1180]	@ zero_extendqisi2
 3091              	.LVL356:
 3092              	.L232:
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3093              		.loc 1 1026 0
 3094 19d8 0A1056E2 		subs	r1, r6, #10
 3095 19dc 006071E2 		rsbs	r6, r1, #0
 3096 19e0 0160B6E0 		adcs	r6, r6, r1
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3097              		.loc 1 1028 0
 3098 19e4 0030A0E3 		mov	r3, #0
 3099              	.LVL357:
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3100              		.loc 1 1029 0
 3101 19e8 9C1084E2 		add	r1, r4, #156
 3102 19ec 0700A0E1 		mov	r0, r7
 3103              	.LVL358:
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3104              		.loc 1 1026 0
 3105 19f0 9E60C4E5 		strb	r6, [r4, #158]
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3106              		.loc 1 1024 0
 3107 19f4 9CC0C4E5 		strb	ip, [r4, #156]
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3108              		.loc 1 1025 0
 3109 19f8 9D20C4E5 		strb	r2, [r4, #157]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3110              		.loc 1 1028 0
 3111 19fc 9F30C4E5 		strb	r3, [r4, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3112              		.loc 1 1029 0
 3113 1a00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3114              	.LVL359:
 3115 1a04 9C00D4E5 		ldrb	r0, [r4, #156]	@ zero_extendqisi2
1031:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 3116              		.loc 1 1031 0
 3117 1a08 FF80A0E3 		mov	r8, #255
 3118 1a0c 0860A0E1 		mov	r6, r8
 3119              	.LVL360:
 3120              	.L208:
1199:../uvc.c      **** }
 3121              		.loc 1 1199 0
 3122 1a10 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 3123 1a14 FFC0A0E3 		mov	ip, #255
 3124 1a18 04108DE5 		str	r1, [sp, #4]
 3125 1a1c 10108DE5 		str	r1, [sp, #16]
 3126 1a20 08008DE5 		str	r0, [sp, #8]
 3127 1a24 00808DE5 		str	r8, [sp]
 3128 1a28 14708DE5 		str	r7, [sp, #20]
 3129 1a2c 0520A0E1 		mov	r2, r5
 3130 1a30 0630A0E1 		mov	r3, r6
 3131 1a34 0CC08DE5 		str	ip, [sp, #12]
 3132 1a38 74179FE5 		ldr	r1, .L235+12
 3133 1a3c 0400A0E3 		mov	r0, #4
 3134 1a40 FEFFFFEB 		bl	CyU3PDebugPrint
 3135              	.LVL361:
1200:../uvc.c      **** 
 3136              		.loc 1 1200 0
 3137 1a44 34D08DE2 		add	sp, sp, #52
 3138              		@ sp needed
 3139 1a48 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 3140              	.LVL362:
 3141              	.L233:
 986:../uvc.c      **** 		 {
 3142              		.loc 1 986 0
 3143 1a4c 810055E3 		cmp	r5, #129
 3144 1a50 2E00000A 		beq	.L201
 3145 1a54 1A00008A 		bhi	.L202
 3146 1a58 010055E3 		cmp	r5, #1
 3147 1a5c 3A00001A 		bne	.L198
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 3148              		.loc 1 1057 0
 3149 1a60 48479FE5 		ldr	r4, .L235+8
 3150 1a64 2E208DE2 		add	r2, sp, #46
 3151              	.LVL363:
 3152 1a68 2000A0E3 		mov	r0, #32
 3153              	.LVL364:
 3154 1a6c 9C1084E2 		add	r1, r4, #156
 3155 1a70 18308DE5 		str	r3, [sp, #24]
 3156 1a74 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3157              	.LVL365:
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3158              		.loc 1 1059 0
 3159 1a78 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
1063:../uvc.c      **** 			  {
 3160              		.loc 1 1063 0
 3161 1a7c 012046E2 		sub	r2, r6, #1
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3162              		.loc 1 1059 0
 3163 1a80 1CC08DE5 		str	ip, [sp, #28]
 3164              	.LVL366:
1060:../uvc.c      **** 			  value = Data1;
 3165              		.loc 1 1060 0
 3166 1a84 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
1063:../uvc.c      **** 			  {
 3167              		.loc 1 1063 0
 3168 1a88 18309DE5 		ldr	r3, [sp, #24]
1060:../uvc.c      **** 			  value = Data1;
 3169              		.loc 1 1060 0
 3170 1a8c 20C08DE5 		str	ip, [sp, #32]
 3171              	.LVL367:
1063:../uvc.c      **** 			  {
 3172              		.loc 1 1063 0
 3173 1a90 090052E3 		cmp	r2, #9
 3174 1a94 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3175 1a98 1D0100EA 		b	.L209
 3176              	.L211:
 3177 1a9c CC1E0000 		.word	.L210
 3178 1aa0 141F0000 		.word	.L209
 3179 1aa4 CC1C0000 		.word	.L212
 3180 1aa8 141F0000 		.word	.L209
 3181 1aac 141F0000 		.word	.L209
 3182 1ab0 141F0000 		.word	.L209
 3183 1ab4 3C1C0000 		.word	.L213
 3184 1ab8 141F0000 		.word	.L209
 3185 1abc 141F0000 		.word	.L209
 3186 1ac0 C01B0000 		.word	.L214
 3187              	.LVL368:
 3188              	.L202:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3189              		.loc 1 1015 0
 3190 1ac4 93C4D2E5 		ldrb	ip, [r2, #1171]	@ zero_extendqisi2
 3191 1ac8 E0469FE5 		ldr	r4, .L235+8
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3192              		.loc 1 1016 0
 3193 1acc 9424D2E5 		ldrb	r2, [r2, #1172]	@ zero_extendqisi2
 3194              	.LVL369:
 3195 1ad0 C0FFFFEA 		b	.L232
 3196              	.LVL370:
 3197              	.L206:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3198              		.loc 1 1042 0
 3199 1ad4 D4469FE5 		ldr	r4, .L235+8
 3200 1ad8 9934D2E5 		ldrb	r3, [r2, #1177]	@ zero_extendqisi2
 3201 1adc 0410A0E1 		mov	r1, r4
 3202 1ae0 9C30E1E5 		strb	r3, [r1, #156]!
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3203              		.loc 1 1043 0
 3204 1ae4 0100A0E3 		mov	r0, #1
 3205              	.LVL371:
1046:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3206              		.loc 1 1046 0
 3207 1ae8 FF80A0E3 		mov	r8, #255
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3208              		.loc 1 1043 0
 3209 1aec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3210              	.LVL372:
1046:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3211              		.loc 1 1046 0
 3212 1af0 0860A0E1 		mov	r6, r8
 3213 1af4 9C00D4E5 		ldrb	r0, [r4, #156]	@ zero_extendqisi2
 3214 1af8 0170A0E3 		mov	r7, #1
 3215 1afc C3FFFFEA 		b	.L208
 3216              	.LVL373:
 3217              	.L205:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3218              		.loc 1 1033 0
 3219 1b00 97C4D2E5 		ldrb	ip, [r2, #1175]	@ zero_extendqisi2
 3220 1b04 A4469FE5 		ldr	r4, .L235+8
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3221              		.loc 1 1034 0
 3222 1b08 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 3223              	.LVL374:
 3224 1b0c B1FFFFEA 		b	.L232
 3225              	.LVL375:
 3226              	.L201:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3227              		.loc 1 1000 0
 3228 1b10 98469FE5 		ldr	r4, .L235+8
 3229 1b14 9D94D2E5 		ldrb	r9, [r2, #1181]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3230              		.loc 1 1001 0
 3231 1b18 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3232              		.loc 1 1002 0
 3233 1b1c 0030A0E3 		mov	r3, #0
1008:../uvc.c      **** 
 3234              		.loc 1 1008 0
 3235 1b20 9C1084E2 		add	r1, r4, #156
 3236 1b24 0700A0E1 		mov	r0, r7
 3237              	.LVL376:
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3238              		.loc 1 1013 0
 3239 1b28 FF80A0E3 		mov	r8, #255
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3240              		.loc 1 1001 0
 3241 1b2c 9DC0C4E5 		strb	ip, [r4, #157]
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3242              		.loc 1 1000 0
 3243 1b30 9C90C4E5 		strb	r9, [r4, #156]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3244              		.loc 1 1002 0
 3245 1b34 9E30C4E5 		strb	r3, [r4, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3246              		.loc 1 1003 0
 3247 1b38 9F30C4E5 		strb	r3, [r4, #159]
 3248              	.LVL377:
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3249              		.loc 1 1013 0
 3250 1b3c 0860A0E1 		mov	r6, r8
 3251              	.LVL378:
1008:../uvc.c      **** 
 3252              		.loc 1 1008 0
 3253 1b40 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3254              	.LVL379:
 3255 1b44 0900A0E1 		mov	r0, r9
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 3256              		.loc 1 1013 0
 3257 1b48 B0FFFFEA 		b	.L208
 3258              	.LVL380:
 3259              	.L198:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3260              		.loc 1 1193 0
 3261 1b4c 0000A0E3 		mov	r0, #0
 3262              	.LVL381:
 3263 1b50 0020A0E1 		mov	r2, r0
 3264              	.LVL382:
 3265 1b54 0110A0E3 		mov	r1, #1
 3266 1b58 FEFFFFEB 		bl	CyU3PUsbStall
 3267              	.LVL383:
1194:../uvc.c      **** 			  break;
 3268              		.loc 1 1194 0
 3269 1b5c 0620A0E1 		mov	r2, r6
 3270 1b60 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 3271 1b64 0400A0E3 		mov	r0, #4
 3272 1b68 48169FE5 		ldr	r1, .L235+16
 3273 1b6c FEFFFFEB 		bl	CyU3PDebugPrint
 3274              	.LVL384:
1195:../uvc.c      **** 		 }
 3275              		.loc 1 1195 0
 3276 1b70 FF00A0E3 		mov	r0, #255
 3277 1b74 34469FE5 		ldr	r4, .L235+8
 3278 1b78 0080A0E1 		mov	r8, r0
 3279 1b7c 0060A0E1 		mov	r6, r0
 3280 1b80 A2FFFFEA 		b	.L208
 3281              	.LVL385:
 3282              	.L204:
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3283              		.loc 1 990 0
 3284 1b84 24469FE5 		ldr	r4, .L235+8
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3285              		.loc 1 991 0
 3286 1b88 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3287              		.loc 1 992 0
 3288 1b8c 9C1084E2 		add	r1, r4, #156
 3289 1b90 0200A0E3 		mov	r0, #2
 3290              	.LVL386:
 994:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3291              		.loc 1 994 0
 3292 1b94 FF80A0E3 		mov	r8, #255
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3293              		.loc 1 990 0
 3294 1b98 9C70C4E5 		strb	r7, [r4, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3295              		.loc 1 991 0
 3296 1b9c 9D30C4E5 		strb	r3, [r4, #157]
 994:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3297              		.loc 1 994 0
 3298 1ba0 0860A0E1 		mov	r6, r8
 3299              	.LVL387:
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3300              		.loc 1 992 0
 3301 1ba4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3302              	.LVL388:
 3303 1ba8 9C00D4E5 		ldrb	r0, [r4, #156]	@ zero_extendqisi2
 994:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3304              		.loc 1 994 0
 3305 1bac 97FFFFEA 		b	.L208
 3306              	.LVL389:
 3307              	.L199:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3308              		.loc 1 1024 0
 3309 1bb0 95C4D2E5 		ldrb	ip, [r2, #1173]	@ zero_extendqisi2
 3310 1bb4 F4459FE5 		ldr	r4, .L235+8
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3311              		.loc 1 1025 0
 3312 1bb8 9624D2E5 		ldrb	r2, [r2, #1174]	@ zero_extendqisi2
 3313              	.LVL390:
 3314 1bbc 85FFFFEA 		b	.L232
 3315              	.LVL391:
 3316              	.L214:
1172:../uvc.c      **** 					  if(getData == 1)
 3317              		.loc 1 1172 0
 3318 1bc0 F4659FE5 		ldr	r6, .L235+20
 3319 1bc4 0010E0E3 		mvn	r1, #0
 3320 1bc8 1C0096E5 		ldr	r0, [r6, #28]
 3321 1bcc FEFFFFEB 		bl	_txe_mutex_get
 3322              	.LVL392:
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3323              		.loc 1 1173 0
 3324 1bd0 1CC09DE5 		ldr	ip, [sp, #28]
 3325 1bd4 01005CE3 		cmp	ip, #1
1174:../uvc.c      **** 					  else if(getData == 0xff)
 3326              		.loc 1 1174 0
 3327 1bd8 0400A003 		moveq	r0, #4
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3328              		.loc 1 1173 0
 3329 1bdc 6901000A 		beq	.L231
1175:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3330              		.loc 1 1175 0
 3331 1be0 FF005CE3 		cmp	ip, #255
 3332 1be4 6601000A 		beq	.L234
1178:../uvc.c      **** 					  //dataIdx++;
 3333              		.loc 1 1178 0
 3334 1be8 0010A0E3 		mov	r1, #0
 3335 1bec 00108DE5 		str	r1, [sp]
 3336 1bf0 04108DE5 		str	r1, [sp, #4]
 3337 1bf4 0A20A0E1 		mov	r2, r10
 3338 1bf8 0930A0E1 		mov	r3, r9
 3339 1bfc 0600A0E1 		mov	r0, r6
 3340 1c00 2310A0E3 		mov	r1, #35
 3341 1c04 FEFFFFEB 		bl	cmdSet
 3342              	.LVL393:
 3343              	.L226:
1181:../uvc.c      **** #endif
 3344              		.loc 1 1181 0
 3345 1c08 1C0096E5 		ldr	r0, [r6, #28]
 3346 1c0c FEFFFFEB 		bl	_txe_mutex_put
 3347              	.LVL394:
1183:../uvc.c      **** 					  break;
 3348              		.loc 1 1183 0
 3349 1c10 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 3350 1c14 1C609DE5 		ldr	r6, [sp, #28]
 3351 1c18 20809DE5 		ldr	r8, [sp, #32]
 3352 1c1c 00108DE5 		str	r1, [sp]
 3353 1c20 0620A0E1 		mov	r2, r6
 3354 1c24 0830A0E1 		mov	r3, r8
 3355 1c28 0400A0E3 		mov	r0, #4
 3356 1c2c 8C159FE5 		ldr	r1, .L235+24
 3357 1c30 FEFFFFEB 		bl	CyU3PDebugPrint
 3358              	.LVL395:
1184:../uvc.c      **** 
 3359              		.loc 1 1184 0
 3360 1c34 FF00A0E3 		mov	r0, #255
 3361 1c38 74FFFFEA 		b	.L208
 3362              	.LVL396:
 3363              	.L213:
1149:../uvc.c      **** 					  {
 3364              		.loc 1 1149 0
 3365 1c3c B504D3E5 		ldrb	r0, [r3, #1205]	@ zero_extendqisi2
 3366 1c40 64C59FE5 		ldr	ip, .L235+4
 3367 1c44 010050E3 		cmp	r0, #1
 3368 1c48 08005013 		cmpne	r0, #8
 3369 1c4c 0000A013 		movne	r0, #0
 3370 1c50 0100A003 		moveq	r0, #1
 3371 1c54 4601001A 		bne	.L223
 3372              	.LVL397:
1152:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3373              		.loc 1 1152 0
 3374 1c58 5CB59FE5 		ldr	fp, .L235+20
 3375 1c5c 0010E0E3 		mvn	r1, #0
 3376 1c60 1C009BE5 		ldr	r0, [fp, #28]
 3377 1c64 18C08DE5 		str	ip, [sp, #24]
 3378 1c68 FEFFFFEB 		bl	_txe_mutex_get
 3379              	.LVL398:
1153:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3380              		.loc 1 1153 0
 3381 1c6c 1C009DE5 		ldr	r0, [sp, #28]
 3382 1c70 0010A0E3 		mov	r1, #0
 3383 1c74 0A20A0E1 		mov	r2, r10
 3384 1c78 0930A0E1 		mov	r3, r9
 3385 1c7c 00008DE5 		str	r0, [sp]
 3386 1c80 04108DE5 		str	r1, [sp, #4]
 3387 1c84 0B00A0E1 		mov	r0, fp
 3388 1c88 2210A0E3 		mov	r1, #34
 3389 1c8c FEFFFFEB 		bl	cmdSet
 3390              	.LVL399:
1154:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 3391              		.loc 1 1154 0
 3392 1c90 1C009BE5 		ldr	r0, [fp, #28]
 3393 1c94 FEFFFFEB 		bl	_txe_mutex_put
 3394              	.LVL400:
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3395              		.loc 1 1157 0
 3396 1c98 18C09DE5 		ldr	ip, [sp, #24]
 3397 1c9c 1C109DE5 		ldr	r1, [sp, #28]
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3398              		.loc 1 1158 0
 3399 1ca0 20209DE5 		ldr	r2, [sp, #32]
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3400              		.loc 1 1157 0
 3401 1ca4 066088E0 		add	r6, r8, r6
 3402 1ca8 86C18CE0 		add	ip, ip, r6, asl #3
1159:../uvc.c      **** 					  }else{
 3403              		.loc 1 1159 0
 3404 1cac 0130A0E3 		mov	r3, #1
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3405              		.loc 1 1157 0
 3406 1cb0 9D14CCE5 		strb	r1, [ip, #1181]
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3407              		.loc 1 1158 0
 3408 1cb4 9E24CCE5 		strb	r2, [ip, #1182]
1159:../uvc.c      **** 					  }else{
 3409              		.loc 1 1159 0
 3410 1cb8 A034CCE5 		strb	r3, [ip, #1184]
 3411              	.LVL401:
 3412              	.L224:
 3413 1cbc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 3414 1cc0 9D80D4E5 		ldrb	r8, [r4, #157]	@ zero_extendqisi2
1166:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 3415              		.loc 1 1166 0
 3416 1cc4 FF00A0E3 		mov	r0, #255
 3417 1cc8 50FFFFEA 		b	.L208
 3418              	.LVL402:
 3419              	.L212:
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3420              		.loc 1 1115 0
 3421 1ccc B534D3E5 		ldrb	r3, [r3, #1205]	@ zero_extendqisi2
 3422 1cd0 010053E3 		cmp	r3, #1
 3423 1cd4 04005313 		cmpne	r3, #4
 3424 1cd8 2001001A 		bne	.L221
1114:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3425              		.loc 1 1114 0
 3426 1cdc 1CC09DE5 		ldr	ip, [sp, #28]
 3427 1ce0 20009DE5 		ldr	r0, [sp, #32]
 3428 1ce4 00348CE1 		orr	r3, ip, r0, asl #8
1116:../uvc.c      **** 					  {
 3429              		.loc 1 1116 0
 3430 1ce8 F90053E3 		cmp	r3, #249
 3431 1cec 1B01008A 		bhi	.L221
 3432              	.LVL403:
1121:../uvc.c      **** 							}else{
 3433              		.loc 1 1121 0
 3434 1cf0 C80043E2 		sub	r0, r3, #200
 3435 1cf4 C80053E3 		cmp	r3, #200
1123:../uvc.c      **** 							}
 3436              		.loc 1 1123 0
 3437 1cf8 C82063E2 		rsb	r2, r3, #200
 3438 1cfc C0149FE5 		ldr	r1, .L235+28
 3439 1d00 0208A091 		movls	r0, r2, asl #16
 3440 1d04 0008A081 		movhi	r0, r0, asl #16
 3441 1d08 642063E2 		rsb	r2, r3, #100
 3442 1d0c 640053E3 		cmp	r3, #100
1121:../uvc.c      **** 							}else{
 3443              		.loc 1 1121 0
 3444 1d10 64C043E2 		sub	ip, r3, #100
 3445 1d14 2008A0E1 		mov	r0, r0, lsr #16
 3446 1d18 0C28A081 		movhi	r2, ip, asl #16
 3447 1d1c 0228A091 		movls	r2, r2, asl #16
 3448 1d20 010050E1 		cmp	r0, r1
 3449 1d24 00E0A031 		movcc	lr, r0
 3450 1d28 01E0A021 		movcs	lr, r1
 3451 1d2c 010050E1 		cmp	r0, r1
 3452 1d30 27C043E2 		sub	ip, r3, #39
1123:../uvc.c      **** 							}
 3453              		.loc 1 1123 0
 3454 1d34 271063E2 		rsb	r1, r3, #39
 3455 1d38 00B0A033 		movcc	fp, #0
 3456 1d3c 01B0A023 		movcs	fp, #1
 3457 1d40 270053E3 		cmp	r3, #39
1121:../uvc.c      **** 							}else{
 3458              		.loc 1 1121 0
 3459 1d44 140043E2 		sub	r0, r3, #20
 3460 1d48 01C8A091 		movls	ip, r1, asl #16
 3461 1d4c 2228A0E1 		mov	r2, r2, lsr #16
1123:../uvc.c      **** 							}
 3462              		.loc 1 1123 0
 3463 1d50 141063E2 		rsb	r1, r3, #20
 3464 1d54 0CC8A081 		movhi	ip, ip, asl #16
 3465 1d58 140053E3 		cmp	r3, #20
 3466 1d5c 0018A081 		movhi	r1, r0, asl #16
 3467 1d60 0118A091 		movls	r1, r1, asl #16
 3468 1d64 0E0052E1 		cmp	r2, lr
1121:../uvc.c      **** 							}else{
 3469              		.loc 1 1121 0
 3470 1d68 0A0043E2 		sub	r0, r3, #10
 3471 1d6c 01B0A033 		movcc	fp, #1
 3472 1d70 2CC8A0E1 		mov	ip, ip, lsr #16
 3473 1d74 02005EE1 		cmp	lr, r2
 3474 1d78 0E20A031 		movcc	r2, lr
 3475 1d7c 0A0053E3 		cmp	r3, #10
 3476 1d80 21E8A0E1 		mov	lr, r1, lsr #16
1123:../uvc.c      **** 							}
 3477              		.loc 1 1123 0
 3478 1d84 0A1063E2 		rsb	r1, r3, #10
 3479 1d88 0118A091 		movls	r1, r1, asl #16
 3480 1d8c 0018A081 		movhi	r1, r0, asl #16
 3481 1d90 0C0052E1 		cmp	r2, ip
 3482 1d94 02B0A083 		movhi	fp, #2
 3483 1d98 24B08DE5 		str	fp, [sp, #36]
1121:../uvc.c      **** 							}else{
 3484              		.loc 1 1121 0
 3485 1d9c 050043E2 		sub	r0, r3, #5
 3486 1da0 02005CE1 		cmp	ip, r2
 3487 1da4 0C20A031 		movcc	r2, ip
 3488 1da8 21B8A0E1 		mov	fp, r1, lsr #16
1123:../uvc.c      **** 							}
 3489              		.loc 1 1123 0
 3490 1dac 05C063E2 		rsb	ip, r3, #5
 3491 1db0 050053E3 		cmp	r3, #5
 3492 1db4 24109DE5 		ldr	r1, [sp, #36]
 3493 1db8 00C8A081 		movhi	ip, r0, asl #16
 3494 1dbc 0CC8A091 		movls	ip, ip, asl #16
 3495 1dc0 0E0052E1 		cmp	r2, lr
 3496 1dc4 0310A083 		movhi	r1, #3
 3497 1dc8 24108DE5 		str	r1, [sp, #36]
 3498 1dcc 02005EE1 		cmp	lr, r2
 3499 1dd0 0E00A031 		movcc	r0, lr
 3500 1dd4 0200A021 		movcs	r0, r2
 3501 1dd8 021063E2 		rsb	r1, r3, #2
1121:../uvc.c      **** 							}else{
 3502              		.loc 1 1121 0
 3503 1ddc 022043E2 		sub	r2, r3, #2
 3504 1de0 020053E3 		cmp	r3, #2
 3505 1de4 0128A091 		movls	r2, r1, asl #16
 3506 1de8 0228A081 		movhi	r2, r2, asl #16
 3507 1dec 0B0050E1 		cmp	r0, fp
 3508 1df0 24E09DE5 		ldr	lr, [sp, #36]
 3509 1df4 2CC8A0E1 		mov	ip, ip, lsr #16
 3510 1df8 04E0A083 		movhi	lr, #4
 3511 1dfc 00005BE1 		cmp	fp, r0
 3512 1e00 0B00A031 		movcc	r0, fp
 3513 1e04 00005CE1 		cmp	ip, r0
 3514 1e08 0C10A031 		movcc	r1, ip
 3515 1e0c 0010A021 		movcs	r1, r0
 3516 1e10 0C0050E1 		cmp	r0, ip
 3517 1e14 05E0A083 		movhi	lr, #5
 3518 1e18 01C043E2 		sub	ip, r3, #1
 3519 1e1c 010053E3 		cmp	r3, #1
1123:../uvc.c      **** 							}
 3520              		.loc 1 1123 0
 3521 1e20 010063E2 		rsb	r0, r3, #1
 3522 1e24 0C38A081 		movhi	r3, ip, asl #16
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3523              		.loc 1 1133 0
 3524 1e28 8CC39FE5 		ldr	ip, .L235+20
 3525 1e2c 2228A0E1 		mov	r2, r2, lsr #16
 3526 1e30 0038A091 		movls	r3, r0, asl #16
 3527 1e34 010052E1 		cmp	r2, r1
 3528 1e38 0200A031 		movcc	r0, r2
 3529 1e3c 0100A021 		movcs	r0, r1
 3530 1e40 020051E1 		cmp	r1, r2
 3531 1e44 0E20A091 		movls	r2, lr
 3532 1e48 0620A083 		movhi	r2, #6
 3533              	.LVL404:
 3534 1e4c 0010E0E3 		mvn	r1, #0
 3535              	.LVL405:
 3536 1e50 230850E1 		cmp	r0, r3, lsr #16
 3537 1e54 1C009CE5 		ldr	r0, [ip, #28]
 3538 1e58 02B0A091 		movls	fp, r2
 3539 1e5c 07B0A083 		movhi	fp, #7
 3540              	.LVL406:
 3541 1e60 18C08DE5 		str	ip, [sp, #24]
 3542 1e64 FEFFFFEB 		bl	_txe_mutex_get
 3543              	.LVL407:
1134:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3544              		.loc 1 1134 0
 3545 1e68 18C09DE5 		ldr	ip, [sp, #24]
1130:../uvc.c      **** 
 3546              		.loc 1 1130 0
 3547 1e6c 01B08BE2 		add	fp, fp, #1
 3548              	.LVL408:
1134:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3549              		.loc 1 1134 0
 3550 1e70 0010A0E3 		mov	r1, #0
 3551 1e74 0A20A0E1 		mov	r2, r10
 3552 1e78 0930A0E1 		mov	r3, r9
 3553 1e7c 0C00A0E1 		mov	r0, ip
 3554 1e80 04108DE5 		str	r1, [sp, #4]
 3555 1e84 00B08DE5 		str	fp, [sp]
 3556 1e88 0310A0E3 		mov	r1, #3
 3557 1e8c FEFFFFEB 		bl	cmdSet
 3558              	.LVL409:
1135:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 3559              		.loc 1 1135 0
 3560 1e90 18C09DE5 		ldr	ip, [sp, #24]
 3561 1e94 1C009CE5 		ldr	r0, [ip, #28]
 3562 1e98 FEFFFFEB 		bl	_txe_mutex_put
 3563              	.LVL410:
1141:../uvc.c      **** 					  }else{
 3564              		.loc 1 1141 0
 3565 1e9c 08C39FE5 		ldr	ip, .L235+4
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3566              		.loc 1 1138 0
 3567 1ea0 04239FE5 		ldr	r2, .L235+4
1141:../uvc.c      **** 					  }else{
 3568              		.loc 1 1141 0
 3569 1ea4 0DB3CCE5 		strb	fp, [ip, #781]
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3570              		.loc 1 1138 0
 3571 1ea8 1CC09DE5 		ldr	ip, [sp, #28]
 3572 1eac 063088E0 		add	r3, r8, r6
 3573 1eb0 833182E0 		add	r3, r2, r3, asl #3
 3574 1eb4 9DC4C3E5 		strb	ip, [r3, #1181]
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3575              		.loc 1 1139 0
 3576 1eb8 20C09DE5 		ldr	ip, [sp, #32]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3577              		.loc 1 1140 0
 3578 1ebc 0120A0E3 		mov	r2, #1
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3579              		.loc 1 1139 0
 3580 1ec0 9EC4C3E5 		strb	ip, [r3, #1182]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3581              		.loc 1 1140 0
 3582 1ec4 A024C3E5 		strb	r2, [r3, #1184]
1141:../uvc.c      **** 					  }else{
 3583              		.loc 1 1141 0
 3584 1ec8 7BFFFFEA 		b	.L224
 3585              	.LVL411:
 3586              	.L210:
1072:../uvc.c      **** 						case 1:
 3587              		.loc 1 1072 0
 3588 1ecc 1CC09DE5 		ldr	ip, [sp, #28]
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3589              		.loc 1 1068 0
 3590 1ed0 066088E0 		add	r6, r8, r6
 3591 1ed4 866183E0 		add	r6, r3, r6, asl #3
1069:../uvc.c      **** 				    getData = glEp0Buffer[0];
 3592              		.loc 1 1069 0
 3593 1ed8 0110A0E3 		mov	r1, #1
1072:../uvc.c      **** 						case 1:
 3594              		.loc 1 1072 0
 3595 1edc 01204CE2 		sub	r2, ip, #1
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3596              		.loc 1 1068 0
 3597 1ee0 9DC4C6E5 		strb	ip, [r6, #1181]
1069:../uvc.c      **** 				    getData = glEp0Buffer[0];
 3598              		.loc 1 1069 0
 3599 1ee4 A014C6E5 		strb	r1, [r6, #1184]
 3600              	.LVL412:
1072:../uvc.c      **** 						case 1:
 3601              		.loc 1 1072 0
 3602 1ee8 070052E3 		cmp	r2, #7
 3603 1eec 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3604 1ef0 960000EA 		b	.L215
 3605              	.L217:
 3606 1ef4 EC200000 		.word	.L216
 3607 1ef8 50200000 		.word	.L218
 3608 1efc 50210000 		.word	.L215
 3609 1f00 E81F0000 		.word	.L219
 3610 1f04 50210000 		.word	.L215
 3611 1f08 50210000 		.word	.L215
 3612 1f0c 50210000 		.word	.L215
 3613 1f10 481F0000 		.word	.L220
 3614              	.LVL413:
 3615              	.L209:
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3616              		.loc 1 1187 0
 3617 1f14 1CC09DE5 		ldr	ip, [sp, #28]
 3618 1f18 068088E0 		add	r8, r8, r6
 3619 1f1c 888183E0 		add	r8, r3, r8, asl #3
1188:../uvc.c      **** 			  		 break;
 3620              		.loc 1 1188 0
 3621 1f20 0620A0E1 		mov	r2, r6
 3622 1f24 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 3623 1f28 0400A0E3 		mov	r0, #4
 3624 1f2c 94129FE5 		ldr	r1, .L235+32
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3625              		.loc 1 1187 0
 3626 1f30 9DC4C8E5 		strb	ip, [r8, #1181]
1188:../uvc.c      **** 			  		 break;
 3627              		.loc 1 1188 0
 3628 1f34 FEFFFFEB 		bl	CyU3PDebugPrint
 3629              	.LVL414:
1189:../uvc.c      **** 			  }
 3630              		.loc 1 1189 0
 3631 1f38 FF00A0E3 		mov	r0, #255
 3632 1f3c 0080A0E1 		mov	r8, r0
 3633 1f40 0060A0E1 		mov	r6, r0
 3634 1f44 B1FEFFEA 		b	.L208
 3635              	.LVL415:
 3636              	.L220:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3637              		.loc 1 1091 0
 3638 1f48 6C629FE5 		ldr	r6, .L235+20
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 3639              		.loc 1 1089 0
 3640 1f4c 0080A0E3 		mov	r8, #0
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3641              		.loc 1 1091 0
 3642 1f50 1C0096E5 		ldr	r0, [r6, #28]
 3643 1f54 0010E0E3 		mvn	r1, #0
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 3644              		.loc 1 1089 0
 3645 1f58 0D83C3E5 		strb	r8, [r3, #781]
 3646              	.LVL416:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3647              		.loc 1 1091 0
 3648 1f5c FEFFFFEB 		bl	_txe_mutex_get
 3649              	.LVL417:
1092:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3650              		.loc 1 1092 0
 3651 1f60 0A20A0E1 		mov	r2, r10
 3652 1f64 0930A0E1 		mov	r3, r9
 3653 1f68 1010A0E3 		mov	r1, #16
 3654 1f6c 00808DE5 		str	r8, [sp]
 3655 1f70 04808DE5 		str	r8, [sp, #4]
 3656 1f74 0600A0E1 		mov	r0, r6
 3657 1f78 FEFFFFEB 		bl	cmdSet
 3658              	.LVL418:
1093:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 3659              		.loc 1 1093 0
 3660 1f7c 1C0096E5 		ldr	r0, [r6, #28]
 3661 1f80 FEFFFFEB 		bl	_txe_mutex_put
 3662              	.LVL419:
 3663              	.LBB78:
 3664              	.LBB79:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3665              		.loc 1 390 0
 3666 1f84 1C0096E5 		ldr	r0, [r6, #28]
 3667 1f88 0010E0E3 		mvn	r1, #0
 3668 1f8c FEFFFFEB 		bl	_txe_mutex_get
 3669              	.LVL420:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3670              		.loc 1 391 0
 3671 1f90 0130A0E3 		mov	r3, #1
 3672 1f94 04808DE5 		str	r8, [sp, #4]
 3673 1f98 0600A0E1 		mov	r0, r6
 3674 1f9c 00308DE5 		str	r3, [sp]
 3675 1fa0 2010A0E3 		mov	r1, #32
 3676 1fa4 2720A0E3 		mov	r2, #39
 3677 1fa8 3030A0E3 		mov	r3, #48
 3678 1fac FEFFFFEB 		bl	cmdSet
 3679              	.LVL421:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3680              		.loc 1 392 0
 3681 1fb0 0230A0E3 		mov	r3, #2
 3682 1fb4 04808DE5 		str	r8, [sp, #4]
 3683 1fb8 0600A0E1 		mov	r0, r6
 3684 1fbc 00308DE5 		str	r3, [sp]
 3685 1fc0 2110A0E3 		mov	r1, #33
 3686 1fc4 2520A0E3 		mov	r2, #37
 3687 1fc8 3030A0E3 		mov	r3, #48
 3688 1fcc FEFFFFEB 		bl	cmdSet
 3689              	.LVL422:
 393:../uvc.c      **** }
 3690              		.loc 1 393 0
 3691 1fd0 1C0096E5 		ldr	r0, [r6, #28]
 3692 1fd4 FEFFFFEB 		bl	_txe_mutex_put
 3693              	.LVL423:
 3694 1fd8 FF00A0E3 		mov	r0, #255
 3695 1fdc 0080A0E1 		mov	r8, r0
 3696 1fe0 0860A0E3 		mov	r6, #8
 3697 1fe4 89FEFFEA 		b	.L208
 3698              	.LVL424:
 3699              	.L219:
 3700              	.LBE79:
 3701              	.LBE78:
 3702              	.LBB80:
 3703              	.LBB81:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3704              		.loc 1 390 0
 3705 1fe8 CC619FE5 		ldr	r6, .L235+20
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3706              		.loc 1 391 0
 3707 1fec 0080A0E3 		mov	r8, #0
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3708              		.loc 1 390 0
 3709 1ff0 0010E0E3 		mvn	r1, #0
 3710 1ff4 1C0096E5 		ldr	r0, [r6, #28]
 3711 1ff8 FEFFFFEB 		bl	_txe_mutex_get
 3712              	.LVL425:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3713              		.loc 1 391 0
 3714 1ffc 0600A0E1 		mov	r0, r6
 3715 2000 00808DE5 		str	r8, [sp]
 3716 2004 04808DE5 		str	r8, [sp, #4]
 3717 2008 2010A0E3 		mov	r1, #32
 3718 200c 2720A0E3 		mov	r2, #39
 3719 2010 3030A0E3 		mov	r3, #48
 3720 2014 FEFFFFEB 		bl	cmdSet
 3721              	.LVL426:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3722              		.loc 1 392 0
 3723 2018 0130A0E3 		mov	r3, #1
 3724 201c 04808DE5 		str	r8, [sp, #4]
 3725 2020 0600A0E1 		mov	r0, r6
 3726 2024 00308DE5 		str	r3, [sp]
 3727 2028 2110A0E3 		mov	r1, #33
 3728 202c 2520A0E3 		mov	r2, #37
 3729 2030 3030A0E3 		mov	r3, #48
 3730 2034 FEFFFFEB 		bl	cmdSet
 3731              	.LVL427:
 393:../uvc.c      **** }
 3732              		.loc 1 393 0
 3733 2038 1C0096E5 		ldr	r0, [r6, #28]
 3734 203c FEFFFFEB 		bl	_txe_mutex_put
 3735              	.LVL428:
 3736 2040 FF00A0E3 		mov	r0, #255
 3737 2044 0080A0E1 		mov	r8, r0
 3738 2048 0460A0E3 		mov	r6, #4
 3739 204c 6FFEFFEA 		b	.L208
 3740              	.LVL429:
 3741              	.L218:
 3742              	.LBE81:
 3743              	.LBE80:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3744              		.loc 1 1079 0
 3745 2050 64619FE5 		ldr	r6, .L235+20
1077:../uvc.c      **** 							dataIdx = 0;
 3746              		.loc 1 1077 0
 3747 2054 0080A0E3 		mov	r8, #0
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3748              		.loc 1 1079 0
 3749 2058 1C0096E5 		ldr	r0, [r6, #28]
 3750 205c 0010E0E3 		mvn	r1, #0
1077:../uvc.c      **** 							dataIdx = 0;
 3751              		.loc 1 1077 0
 3752 2060 0D83C3E5 		strb	r8, [r3, #781]
 3753              	.LVL430:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3754              		.loc 1 1079 0
 3755 2064 FEFFFFEB 		bl	_txe_mutex_get
 3756              	.LVL431:
1080:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3757              		.loc 1 1080 0
 3758 2068 0A20A0E1 		mov	r2, r10
 3759 206c 0930A0E1 		mov	r3, r9
 3760 2070 1010A0E3 		mov	r1, #16
 3761 2074 00808DE5 		str	r8, [sp]
 3762 2078 04808DE5 		str	r8, [sp, #4]
 3763 207c 0600A0E1 		mov	r0, r6
 3764 2080 FEFFFFEB 		bl	cmdSet
 3765              	.LVL432:
1081:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 3766              		.loc 1 1081 0
 3767 2084 1C0096E5 		ldr	r0, [r6, #28]
 3768 2088 FEFFFFEB 		bl	_txe_mutex_put
 3769              	.LVL433:
 3770              	.LBB82:
 3771              	.LBB83:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3772              		.loc 1 390 0
 3773 208c 1C0096E5 		ldr	r0, [r6, #28]
 3774 2090 0010E0E3 		mvn	r1, #0
 3775 2094 FEFFFFEB 		bl	_txe_mutex_get
 3776              	.LVL434:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3777              		.loc 1 391 0
 3778 2098 00808DE5 		str	r8, [sp]
 3779 209c 04808DE5 		str	r8, [sp, #4]
 3780 20a0 0600A0E1 		mov	r0, r6
 3781 20a4 2010A0E3 		mov	r1, #32
 3782 20a8 2720A0E3 		mov	r2, #39
 3783 20ac 3030A0E3 		mov	r3, #48
 3784 20b0 FEFFFFEB 		bl	cmdSet
 3785              	.LVL435:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3786              		.loc 1 392 0
 3787 20b4 0130A0E3 		mov	r3, #1
 3788 20b8 04808DE5 		str	r8, [sp, #4]
 3789 20bc 0600A0E1 		mov	r0, r6
 3790 20c0 00308DE5 		str	r3, [sp]
 3791 20c4 2110A0E3 		mov	r1, #33
 3792 20c8 2520A0E3 		mov	r2, #37
 3793 20cc 3030A0E3 		mov	r3, #48
 3794 20d0 FEFFFFEB 		bl	cmdSet
 3795              	.LVL436:
 393:../uvc.c      **** }
 3796              		.loc 1 393 0
 3797 20d4 1C0096E5 		ldr	r0, [r6, #28]
 3798 20d8 FEFFFFEB 		bl	_txe_mutex_put
 3799              	.LVL437:
 3800 20dc FF00A0E3 		mov	r0, #255
 3801 20e0 0080A0E1 		mov	r8, r0
 3802 20e4 0260A0E3 		mov	r6, #2
 3803 20e8 48FEFFEA 		b	.L208
 3804              	.LVL438:
 3805              	.L216:
 3806              	.LBE83:
 3807              	.LBE82:
 3808              	.LBB84:
 3809              	.LBB85:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3810              		.loc 1 390 0
 3811 20ec C8809FE5 		ldr	r8, .L235+20
 3812 20f0 0010E0E3 		mvn	r1, #0
 3813 20f4 1C0098E5 		ldr	r0, [r8, #28]
 3814 20f8 FEFFFFEB 		bl	_txe_mutex_get
 3815              	.LVL439:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3816              		.loc 1 391 0
 3817 20fc 0090A0E3 		mov	r9, #0
 3818              	.LVL440:
 3819 2100 0160A0E3 		mov	r6, #1
 3820 2104 0800A0E1 		mov	r0, r8
 3821 2108 2010A0E3 		mov	r1, #32
 3822 210c 2720A0E3 		mov	r2, #39
 3823 2110 3030A0E3 		mov	r3, #48
 3824 2114 40028DE8 		stmia	sp, {r6, r9}
 3825 2118 FEFFFFEB 		bl	cmdSet
 3826              	.LVL441:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3827              		.loc 1 392 0
 3828 211c 0230A0E3 		mov	r3, #2
 3829 2120 0800A0E1 		mov	r0, r8
 3830 2124 00308DE5 		str	r3, [sp]
 3831 2128 2110A0E3 		mov	r1, #33
 3832 212c 2520A0E3 		mov	r2, #37
 3833 2130 3030A0E3 		mov	r3, #48
 3834 2134 04908DE5 		str	r9, [sp, #4]
 3835 2138 FEFFFFEB 		bl	cmdSet
 3836              	.LVL442:
 393:../uvc.c      **** }
 3837              		.loc 1 393 0
 3838 213c 1C0098E5 		ldr	r0, [r8, #28]
 3839 2140 FEFFFFEB 		bl	_txe_mutex_put
 3840              	.LVL443:
 3841 2144 FF00A0E3 		mov	r0, #255
 3842 2148 0080A0E1 		mov	r8, r0
 3843 214c 2FFEFFEA 		b	.L208
 3844              	.LVL444:
 3845              	.L215:
 3846              	.LBE85:
 3847              	.LBE84:
1072:../uvc.c      **** 						case 1:
 3848              		.loc 1 1072 0
 3849 2150 FF00A0E3 		mov	r0, #255
 3850 2154 0C60A0E1 		mov	r6, ip
 3851 2158 0080A0E1 		mov	r8, r0
 3852 215c 2BFEFFEA 		b	.L208
 3853              	.LVL445:
 3854              	.L221:
1143:../uvc.c      **** 					  }
 3855              		.loc 1 1143 0
 3856 2160 0000A0E3 		mov	r0, #0
 3857 2164 0020A0E1 		mov	r2, r0
 3858 2168 0110A0E3 		mov	r1, #1
 3859 216c FEFFFFEB 		bl	CyU3PUsbStall
 3860              	.LVL446:
 3861 2170 D1FEFFEA 		b	.L224
 3862              	.LVL447:
 3863              	.L223:
1161:../uvc.c      **** 					  }
 3864              		.loc 1 1161 0
 3865 2174 0020A0E1 		mov	r2, r0
 3866 2178 0110A0E3 		mov	r1, #1
 3867 217c FEFFFFEB 		bl	CyU3PUsbStall
 3868              	.LVL448:
 3869 2180 CDFEFFEA 		b	.L224
 3870              	.LVL449:
 3871              	.L234:
1176:../uvc.c      **** 					  else
 3872              		.loc 1 1176 0
 3873 2184 0800A0E3 		mov	r0, #8
 3874              	.L231:
 3875 2188 0010A0E3 		mov	r1, #0
 3876 218c 03008DE8 		stmia	sp, {r0, r1}
 3877 2190 0A20A0E1 		mov	r2, r10
 3878 2194 0930A0E1 		mov	r3, r9
 3879 2198 0600A0E1 		mov	r0, r6
 3880 219c 2310A0E3 		mov	r1, #35
 3881 21a0 FEFFFFEB 		bl	cmdSet
 3882              	.LVL450:
 3883 21a4 97FEFFEA 		b	.L226
 3884              	.L236:
 3885              		.align	2
 3886              	.L235:
 3887 21a8 00000000 		.word	bRequest
 3888 21ac 00000000 		.word	.LANCHOR1
 3889 21b0 00000000 		.word	.LANCHOR0
 3890 21b4 14040000 		.word	.LC23
 3891 21b8 F0030000 		.word	.LC22
 3892 21bc 00000000 		.word	cmdQu
 3893 21c0 A4030000 		.word	.LC20
 3894 21c4 FFFF0000 		.word	65535
 3895 21c8 CC030000 		.word	.LC21
 3896              		.cfi_endproc
 3897              	.LFE3:
 3899              		.align	2
 3900              		.global	CamDefSet
 3902              	CamDefSet:
 3903              	.LFB4:
1204:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 3904              		.loc 1 1204 0
 3905              		.cfi_startproc
 3906              		@ args = 0, pretend = 0, frame = 24
 3907              		@ frame_needed = 0, uses_anonymous_args = 0
 3908              	.LVL451:
 3909 21cc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3910              	.LCFI16:
 3911              		.cfi_def_cfa_offset 36
 3912              		.cfi_offset 4, -36
 3913              		.cfi_offset 5, -32
 3914              		.cfi_offset 6, -28
 3915              		.cfi_offset 7, -24
 3916              		.cfi_offset 8, -20
 3917              		.cfi_offset 9, -16
 3918              		.cfi_offset 10, -12
 3919              		.cfi_offset 11, -8
 3920              		.cfi_offset 14, -4
1210:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 3921              		.loc 1 1210 0
 3922 21d0 AC429FE5 		ldr	r4, .L240
1215:../uvc.c      ****     if(Data1&0x80){
 3923              		.loc 1 1215 0
 3924 21d4 AC229FE5 		ldr	r2, .L240+4
1212:../uvc.c      ****     Data1 = Data0;
 3925              		.loc 1 1212 0
 3926 21d8 A351D4E5 		ldrb	r5, [r4, #419]	@ zero_extendqisi2
1204:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 3927              		.loc 1 1204 0
 3928 21dc 2CD04DE2 		sub	sp, sp, #44
 3929              	.LCFI17:
 3930              		.cfi_def_cfa_offset 80
1215:../uvc.c      ****     if(Data1&0x80){
 3931              		.loc 1 1215 0
 3932 21e0 1C0092E5 		ldr	r0, [r2, #28]
 3933 21e4 0010E0E3 		mvn	r1, #0
1217:../uvc.c      ****     }else{
 3934              		.loc 1 1217 0
 3935 21e8 2563A0E1 		mov	r6, r5, lsr #6
1211:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 3936              		.loc 1 1211 0
 3937 21ec A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1210:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 3938              		.loc 1 1210 0
 3939 21f0 9991D4E5 		ldrb	r9, [r4, #409]	@ zero_extendqisi2
 3940              	.LVL452:
1215:../uvc.c      ****     if(Data1&0x80){
 3941              		.loc 1 1215 0
 3942 21f4 FEFFFFEB 		bl	_txe_mutex_get
 3943              	.LVL453:
1216:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 3944              		.loc 1 1216 0
 3945 21f8 800015E3 		tst	r5, #128
1217:../uvc.c      ****     }else{
 3946              		.loc 1 1217 0
 3947 21fc 01600612 		andne	r6, r6, #1
 3948 2200 0660E011 		mvnne	r6, r6
 3949 2204 3B600612 		andne	r6, r6, #59
 3950 2208 0660E011 		mvnne	r6, r6
 3951 220c FF600612 		andne	r6, r6, #255
 3952              	.LVL454:
1219:../uvc.c      ****     }
 3953              		.loc 1 1219 0
 3954 2210 C6608603 		orreq	r6, r6, #198
 3955              	.LVL455:
1223:../uvc.c      **** 
 3956              		.loc 1 1223 0
 3957 2214 0080A0E3 		mov	r8, #0
1221:../uvc.c      **** 
 3958              		.loc 1 1221 0
 3959 2218 0551A0E1 		mov	r5, r5, asl #2
 3960              	.LVL456:
 3961 221c FF5005E2 		and	r5, r5, #255
 3962              	.LVL457:
1226:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3963              		.loc 1 1226 0
 3964 2220 01A0A0E3 		mov	r10, #1
1223:../uvc.c      **** 
 3965              		.loc 1 1223 0
 3966 2224 00608DE5 		str	r6, [sp]
 3967 2228 0920A0E1 		mov	r2, r9
 3968 222c 0730A0E1 		mov	r3, r7
 3969 2230 04808DE5 		str	r8, [sp, #4]
 3970 2234 0110A0E3 		mov	r1, #1
 3971 2238 48029FE5 		ldr	r0, .L240+4
 3972 223c FEFFFFEB 		bl	cmdSet
 3973              	.LVL458:
1226:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3974              		.loc 1 1226 0
 3975 2240 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 3976 2244 0730A0E1 		mov	r3, r7
 3977 2248 0A10A0E1 		mov	r1, r10
 3978 224c 00508DE5 		str	r5, [sp]
 3979 2250 04A08DE5 		str	r10, [sp, #4]
 3980 2254 2C029FE5 		ldr	r0, .L240+4
 3981 2258 FEFFFFEB 		bl	cmdSet
 3982              	.LVL459:
1229:../uvc.c      **** 
 3983              		.loc 1 1229 0
 3984 225c 0620A0E1 		mov	r2, r6
 3985 2260 0530A0E1 		mov	r3, r5
 3986 2264 20129FE5 		ldr	r1, .L240+8
 3987 2268 0400A0E3 		mov	r0, #4
1228:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 3988              		.loc 1 1228 0
 3989 226c A661C4E5 		strb	r6, [r4, #422]
1227:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 3990              		.loc 1 1227 0
 3991 2270 A551C4E5 		strb	r5, [r4, #421]
1229:../uvc.c      **** 
 3992              		.loc 1 1229 0
 3993 2274 FEFFFFEB 		bl	CyU3PDebugPrint
 3994              	.LVL460:
1234:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 3995              		.loc 1 1234 0
 3996 2278 BB61D4E5 		ldrb	r6, [r4, #443]	@ zero_extendqisi2
 3997              	.LVL461:
1235:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 3998              		.loc 1 1235 0
 3999 227c B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 4000 2280 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 4001 2284 40018DE8 		stmia	sp, {r6, r8}
 4002 2288 F8019FE5 		ldr	r0, .L240+4
 4003 228c 0210A0E3 		mov	r1, #2
 4004 2290 FEFFFFEB 		bl	cmdSet
 4005              	.LVL462:
1237:../uvc.c      **** 
 4006              		.loc 1 1237 0
 4007 2294 0620A0E1 		mov	r2, r6
 4008 2298 0530A0E1 		mov	r3, r5
 4009 229c E8119FE5 		ldr	r1, .L240+8
 4010 22a0 0400A0E3 		mov	r0, #4
1236:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4011              		.loc 1 1236 0
 4012 22a4 BD51C4E5 		strb	r5, [r4, #445]
1237:../uvc.c      **** 
 4013              		.loc 1 1237 0
 4014 22a8 FEFFFFEB 		bl	CyU3PDebugPrint
 4015              	.LVL463:
1242:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 4016              		.loc 1 1242 0
 4017 22ac 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1241:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 4018              		.loc 1 1241 0
 4019 22b0 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 4020              	.LVL464:
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4021              		.loc 1 1243 0
 4022 22b4 80C047E2 		sub	ip, r7, #128
 4023 22b8 FF300CE2 		and	r3, ip, #255
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4024              		.loc 1 1244 0
 4025 22bc 76E047E2 		sub	lr, r7, #118
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4026              		.loc 1 1243 0
 4027 22c0 18308DE5 		str	r3, [sp, #24]
 4028 22c4 08018DE8 		stmia	sp, {r3, r8}
 4029 22c8 B8019FE5 		ldr	r0, .L240+4
 4030 22cc 0630A0E1 		mov	r3, r6
 4031 22d0 0510A0E3 		mov	r1, #5
 4032 22d4 DF20A0E3 		mov	r2, #223
 4033 22d8 14C08DE5 		str	ip, [sp, #20]
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4034              		.loc 1 1244 0
 4035 22dc 1CE08DE5 		str	lr, [sp, #28]
1243:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 4036              		.loc 1 1243 0
 4037 22e0 FEFFFFEB 		bl	cmdSet
 4038              	.LVL465:
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4039              		.loc 1 1244 0
 4040 22e4 1C209DE5 		ldr	r2, [sp, #28]
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4041              		.loc 1 1245 0
 4042 22e8 7EE087E2 		add	lr, r7, #126
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4043              		.loc 1 1244 0
 4044 22ec FF3002E2 		and	r3, r2, #255
 4045 22f0 08048DE8 		stmia	sp, {r3, r10}
 4046 22f4 8C019FE5 		ldr	r0, .L240+4
 4047 22f8 0630A0E1 		mov	r3, r6
 4048 22fc 0510A0E3 		mov	r1, #5
 4049 2300 DC20A0E3 		mov	r2, #220
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4050              		.loc 1 1245 0
 4051 2304 20E08DE5 		str	lr, [sp, #32]
1244:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 4052              		.loc 1 1244 0
 4053 2308 FEFFFFEB 		bl	cmdSet
 4054              	.LVL466:
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4055              		.loc 1 1245 0
 4056 230c 20209DE5 		ldr	r2, [sp, #32]
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4057              		.loc 1 1246 0
 4058 2310 72E087E2 		add	lr, r7, #114
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4059              		.loc 1 1245 0
 4060 2314 FF3002E2 		and	r3, r2, #255
 4061 2318 0220A0E3 		mov	r2, #2
 4062 231c 00308DE5 		str	r3, [sp]
 4063 2320 04208DE5 		str	r2, [sp, #4]
 4064 2324 0630A0E1 		mov	r3, r6
 4065 2328 0510A0E3 		mov	r1, #5
 4066 232c DE20A0E3 		mov	r2, #222
 4067 2330 50019FE5 		ldr	r0, .L240+4
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4068              		.loc 1 1246 0
 4069 2334 24E08DE5 		str	lr, [sp, #36]
1245:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 4070              		.loc 1 1245 0
 4071 2338 FEFFFFEB 		bl	cmdSet
 4072              	.LVL467:
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4073              		.loc 1 1246 0
 4074 233c 24209DE5 		ldr	r2, [sp, #36]
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4075              		.loc 1 1247 0
 4076 2340 6FB047E2 		sub	fp, r7, #111
1246:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 4077              		.loc 1 1246 0
 4078 2344 FF3002E2 		and	r3, r2, #255
 4079 2348 0320A0E3 		mov	r2, #3
 4080 234c 00308DE5 		str	r3, [sp]
 4081 2350 04208DE5 		str	r2, [sp, #4]
 4082 2354 0630A0E1 		mov	r3, r6
 4083 2358 0510A0E3 		mov	r1, #5
 4084 235c E020A0E3 		mov	r2, #224
 4085 2360 20019FE5 		ldr	r0, .L240+4
 4086 2364 FEFFFFEB 		bl	cmdSet
 4087              	.LVL468:
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4088              		.loc 1 1247 0
 4089 2368 0490A0E3 		mov	r9, #4
 4090 236c FF300BE2 		and	r3, fp, #255
1248:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 4091              		.loc 1 1248 0
 4092 2370 7F7087E2 		add	r7, r7, #127
 4093              	.LVL469:
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 4094              		.loc 1 1247 0
 4095 2374 00308DE5 		str	r3, [sp]
 4096 2378 04908DE5 		str	r9, [sp, #4]
 4097 237c 0630A0E1 		mov	r3, r6
 4098 2380 0510A0E3 		mov	r1, #5
 4099 2384 DD20A0E3 		mov	r2, #221
 4100 2388 F8009FE5 		ldr	r0, .L240+4
 4101 238c FEFFFFEB 		bl	cmdSet
 4102              	.LVL470:
1248:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 4103              		.loc 1 1248 0
 4104 2390 FF2007E2 		and	r2, r7, #255
 4105 2394 0510A0E3 		mov	r1, #5
 4106 2398 0630A0E1 		mov	r3, r6
 4107 239c 00208DE5 		str	r2, [sp]
 4108 23a0 04108DE5 		str	r1, [sp, #4]
 4109 23a4 E120A0E3 		mov	r2, #225
 4110 23a8 D8009FE5 		ldr	r0, .L240+4
 4111 23ac FEFFFFEB 		bl	cmdSet
 4112              	.LVL471:
1250:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4113              		.loc 1 1250 0
 4114 23b0 14C09DE5 		ldr	ip, [sp, #20]
 4115 23b4 24E09DE5 		ldr	lr, [sp, #36]
 4116 23b8 20309DE5 		ldr	r3, [sp, #32]
 4117 23bc 0C20A0E1 		mov	r2, ip
1249:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 4118              		.loc 1 1249 0
 4119 23c0 18C09DE5 		ldr	ip, [sp, #24]
1250:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4120              		.loc 1 1250 0
 4121 23c4 04E08DE5 		str	lr, [sp, #4]
 4122 23c8 00308DE5 		str	r3, [sp]
 4123 23cc 0C708DE5 		str	r7, [sp, #12]
 4124 23d0 1C309DE5 		ldr	r3, [sp, #28]
 4125 23d4 08B08DE5 		str	fp, [sp, #8]
 4126 23d8 0900A0E1 		mov	r0, r9
 4127 23dc AC109FE5 		ldr	r1, .L240+12
1249:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 4128              		.loc 1 1249 0
 4129 23e0 05C2C4E5 		strb	ip, [r4, #517]
1250:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 4130              		.loc 1 1250 0
 4131 23e4 FEFFFFEB 		bl	CyU3PDebugPrint
 4132              	.LVL472:
1255:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 4133              		.loc 1 1255 0
 4134 23e8 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 4135              	.LVL473:
1254:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 4136              		.loc 1 1254 0
 4137 23ec 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 4138              	.LVL474:
1256:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 4139              		.loc 1 1256 0
 4140 23f0 00608DE5 		str	r6, [sp]
 4141 23f4 0730A0E1 		mov	r3, r7
 4142 23f8 04808DE5 		str	r8, [sp, #4]
 4143 23fc 0610A0E3 		mov	r1, #6
 4144 2400 8520A0E3 		mov	r2, #133
 4145 2404 7C009FE5 		ldr	r0, .L240+4
 4146 2408 FEFFFFEB 		bl	cmdSet
 4147              	.LVL475:
1257:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 4148              		.loc 1 1257 0
 4149 240c 40048DE8 		stmia	sp, {r6, r10}
 4150 2410 70009FE5 		ldr	r0, .L240+4
 4151 2414 0730A0E1 		mov	r3, r7
 4152 2418 0610A0E3 		mov	r1, #6
 4153 241c 8620A0E3 		mov	r2, #134
 4154 2420 FEFFFFEB 		bl	cmdSet
 4155              	.LVL476:
1259:../uvc.c      **** 
 4156              		.loc 1 1259 0
 4157 2424 0620A0E1 		mov	r2, r6
 4158 2428 0530A0E1 		mov	r3, r5
 4159 242c 0900A0E1 		mov	r0, r9
 4160 2430 54109FE5 		ldr	r1, .L240+8
1258:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4161              		.loc 1 1258 0
 4162 2434 1D62C4E5 		strb	r6, [r4, #541]
1259:../uvc.c      **** 
 4163              		.loc 1 1259 0
 4164 2438 FEFFFFEB 		bl	CyU3PDebugPrint
 4165              	.LVL477:
1264:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 4166              		.loc 1 1264 0
 4167 243c 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 4168              	.LVL478:
1265:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 4169              		.loc 1 1265 0
 4170 2440 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 4171 2444 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 4172 2448 40018DE8 		stmia	sp, {r6, r8}
 4173 244c 34009FE5 		ldr	r0, .L240+4
 4174 2450 0710A0E3 		mov	r1, #7
 4175 2454 FEFFFFEB 		bl	cmdSet
 4176              	.LVL479:
1267:../uvc.c      **** 
 4177              		.loc 1 1267 0
 4178 2458 0620A0E1 		mov	r2, r6
 4179 245c 0530A0E1 		mov	r3, r5
 4180 2460 0900A0E1 		mov	r0, r9
 4181 2464 20109FE5 		ldr	r1, .L240+8
1266:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 4182              		.loc 1 1266 0
 4183 2468 3552C4E5 		strb	r5, [r4, #565]
1267:../uvc.c      **** 
 4184              		.loc 1 1267 0
 4185 246c FEFFFFEB 		bl	CyU3PDebugPrint
 4186              	.LVL480:
1269:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 4187              		.loc 1 1269 0
 4188 2470 10209FE5 		ldr	r2, .L240+4
 4189 2474 1C0092E5 		ldr	r0, [r2, #28]
1272:../uvc.c      **** 
 4190              		.loc 1 1272 0
 4191 2478 2CD08DE2 		add	sp, sp, #44
 4192              		@ sp needed
 4193 247c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4194              	.LVL481:
1269:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 4195              		.loc 1 1269 0
 4196 2480 FEFFFFEA 		b	_txe_mutex_put
 4197              	.LVL482:
 4198              	.L241:
 4199              		.align	2
 4200              	.L240:
 4201 2484 00000000 		.word	.LANCHOR1
 4202 2488 00000000 		.word	cmdQu
 4203 248c 78040000 		.word	.LC24
 4204 2490 98040000 		.word	.LC25
 4205              		.cfi_endproc
 4206              	.LFE4:
 4208              		.align	2
 4209              		.global	CyFxUVCAddHeader
 4211              	CyFxUVCAddHeader:
 4212              	.LFB5:
1280:../uvc.c      ****     /* Copy header to buffer */
 4213              		.loc 1 1280 0
 4214              		.cfi_startproc
 4215              		@ args = 0, pretend = 0, frame = 0
 4216              		@ frame_needed = 0, uses_anonymous_args = 0
 4217              	.LVL483:
 4218 2494 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 4219              	.LCFI18:
 4220              		.cfi_def_cfa_offset 16
 4221              		.cfi_offset 3, -16
 4222              		.cfi_offset 4, -12
 4223              		.cfi_offset 5, -8
 4224              		.cfi_offset 14, -4
1280:../uvc.c      ****     /* Copy header to buffer */
 4225              		.loc 1 1280 0
 4226 2498 0040A0E1 		mov	r4, r0
 4227 249c 0150A0E1 		mov	r5, r1
1282:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 4228              		.loc 1 1282 0
 4229 24a0 30009FE5 		ldr	r0, .L247
 4230              	.LVL484:
 4231 24a4 0010E0E3 		mvn	r1, #0
 4232              	.LVL485:
 4233 24a8 FEFFFFEB 		bl	_txe_mutex_get
 4234              	.LVL486:
1283:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 4235              		.loc 1 1283 0
 4236 24ac 0400A0E1 		mov	r0, r4
 4237 24b0 24109FE5 		ldr	r1, .L247+4
 4238 24b4 0C20A0E3 		mov	r2, #12
 4239 24b8 FEFFFFEB 		bl	CyU3PMemCopy
 4240              	.LVL487:
1284:../uvc.c      **** 
 4241              		.loc 1 1284 0
 4242 24bc 14009FE5 		ldr	r0, .L247
 4243 24c0 FEFFFFEB 		bl	_txe_mutex_put
 4244              	.LVL488:
1287:../uvc.c      ****     {
 4245              		.loc 1 1287 0
 4246 24c4 020015E3 		tst	r5, #2
1289:../uvc.c      ****     }
 4247              		.loc 1 1289 0
 4248 24c8 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 4249 24cc 02308313 		orrne	r3, r3, #2
 4250 24d0 0130C415 		strneb	r3, [r4, #1]
 4251 24d4 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 4252              	.L248:
 4253              		.align	2
 4254              	.L247:
 4255 24d8 00000000 		.word	imgHdMux
 4256 24dc 80040000 		.word	.LANCHOR1+1152
 4257              		.cfi_endproc
 4258              	.LFE5:
 4260              		.align	2
 4261              		.global	CyFxAppErrorHandler
 4263              	CyFxAppErrorHandler:
 4264              	.LFB6:
1299:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 4265              		.loc 1 1299 0
 4266              		.cfi_startproc
 4267              		@ Volatile: function does not return.
 4268              		@ args = 0, pretend = 0, frame = 0
 4269              		@ frame_needed = 0, uses_anonymous_args = 0
 4270              	.LVL489:
 4271 24e0 08402DE9 		stmfd	sp!, {r3, lr}
 4272              	.LCFI19:
 4273              		.cfi_def_cfa_offset 8
 4274              		.cfi_offset 3, -8
 4275              		.cfi_offset 14, -4
 4276              	.LVL490:
 4277              	.L250:
1309:../uvc.c      ****         CyU3PThreadSleep (1000);
 4278              		.loc 1 1309 0 discriminator 1
 4279 24e4 10109FE5 		ldr	r1, .L251
 4280 24e8 0400A0E3 		mov	r0, #4
 4281 24ec FEFFFFEB 		bl	CyU3PDebugPrint
 4282              	.LVL491:
1310:../uvc.c      ****     }
 4283              		.loc 1 1310 0 discriminator 1
 4284 24f0 FA0FA0E3 		mov	r0, #1000
 4285 24f4 FEFFFFEB 		bl	_tx_thread_sleep
 4286              	.LVL492:
 4287 24f8 F9FFFFEA 		b	.L250
 4288              	.L252:
 4289              		.align	2
 4290              	.L251:
 4291 24fc D0040000 		.word	.LC26
 4292              		.cfi_endproc
 4293              	.LFE6:
 4295              		.align	2
 4296              		.global	UVCAppEP0Thread_Entry
 4298              	UVCAppEP0Thread_Entry:
 4299              	.LFB24:
3269:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 4300              		.loc 1 3269 0
 4301              		.cfi_startproc
 4302              		@ args = 0, pretend = 0, frame = 80
 4303              		@ frame_needed = 0, uses_anonymous_args = 0
 4304              	.LVL493:
 4305 2500 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4306              	.LCFI20:
 4307              		.cfi_def_cfa_offset 36
 4308              		.cfi_offset 4, -36
 4309              		.cfi_offset 5, -32
 4310              		.cfi_offset 6, -28
 4311              		.cfi_offset 7, -24
 4312              		.cfi_offset 8, -20
 4313              		.cfi_offset 9, -16
 4314              		.cfi_offset 10, -12
 4315              		.cfi_offset 11, -8
 4316              		.cfi_offset 14, -4
 4317 2504 C09F9FE5 		ldr	r9, .L720
 4318 2508 C0AF9FE5 		ldr	r10, .L720+4
 4319 250c C05F9FE5 		ldr	r5, .L720+8
3345:../uvc.c      ****                 {
 4320              		.loc 1 3345 0
 4321 2510 C08F9FE5 		ldr	r8, .L720+12
 4322              	.LBB132:
 4323              	.LBB133:
2946:../uvc.c      ****     {
 4324              		.loc 1 2946 0
 4325 2514 C0BF9FE5 		ldr	fp, .L720+16
 4326              	.LBE133:
 4327              	.LBE132:
3269:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 4328              		.loc 1 3269 0
 4329 2518 6CD04DE2 		sub	sp, sp, #108
 4330              	.LCFI21:
 4331              		.cfi_def_cfa_offset 144
 4332              	.LVL494:
3291:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 4333              		.loc 1 3291 0
 4334 251c 0940A0E1 		mov	r4, r9
 4335              	.LVL495:
 4336              	.L555:
 4337 2520 0030E0E3 		mvn	r3, #0
 4338 2524 00308DE5 		str	r3, [sp]
 4339 2528 9C0F9FE5 		ldr	r0, .L720
 4340 252c 4C10A0E3 		mov	r1, #76
 4341 2530 0120A0E3 		mov	r2, #1
 4342 2534 50308DE2 		add	r3, sp, #80
 4343              	.LVL496:
 4344 2538 FEFFFFEB 		bl	_txe_event_flags_get
 4345              	.LVL497:
 4346 253c 000050E3 		cmp	r0, #0
 4347 2540 5700001A 		bne	.L255
3295:../uvc.c      ****             {
 4348              		.loc 1 3295 0
 4349 2544 883094E5 		ldr	r3, [r4, #136]
 4350 2548 000053E3 		cmp	r3, #0
 4351 254c 7700000A 		beq	.L686
 4352              	.L257:
3313:../uvc.c      ****             {
 4353              		.loc 1 3313 0
 4354 2550 50309DE5 		ldr	r3, [sp, #80]
 4355 2554 040013E3 		tst	r3, #4
 4356 2558 1F00000A 		beq	.L259
3315:../uvc.c      ****                 {
 4357              		.loc 1 3315 0
 4358 255c B020D8E1 		ldrh	r2, [r8]
 4359 2560 2224A0E1 		mov	r2, r2, lsr #8
 4360 2564 030052E3 		cmp	r2, #3
 4361 2568 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4362 256c 150000EA 		b	.L260
 4363              	.L262:
 4364 2570 C8250000 		.word	.L260
 4365 2574 80250000 		.word	.L263
 4366 2578 AC260000 		.word	.L264
 4367 257c E8260000 		.word	.L265
 4368              	.L263:
 4369              	.LBB144:
 4370              	.LBB145:
2626:../uvc.c      ****     {
 4371              		.loc 1 2626 0
 4372 2580 B020DBE1 		ldrh	r2, [fp]
 4373 2584 060C52E3 		cmp	r2, #1536
 4374 2588 3802000A 		beq	.L281
 4375 258c CD00009A 		bls	.L687
 4376 2590 090C52E3 		cmp	r2, #2304
 4377 2594 8602000A 		beq	.L289
 4378 2598 4F01009A 		bls	.L688
 4379 259c 0B0C52E3 		cmp	r2, #2816
 4380 25a0 1602000A 		beq	.L292
 4381 25a4 030B52E3 		cmp	r2, #3072
 4382 25a8 E501000A 		beq	.L293
 4383 25ac 0A0C52E3 		cmp	r2, #2560
 4384 25b0 C701000A 		beq	.L689
 4385              	.L280:
2683:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4386              		.loc 1 2683 0
 4387 25b4 243F9FE5 		ldr	r3, .L720+20
 4388 25b8 0400A0E3 		mov	r0, #4
 4389 25bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 4390 25c0 1C1F9FE5 		ldr	r1, .L720+24
 4391 25c4 FEFFFFEB 		bl	CyU3PDebugPrint
 4392              	.LVL498:
 4393              	.L260:
 4394              	.LBE145:
 4395              	.LBE144:
3336:../uvc.c      ****                         break;
 4396              		.loc 1 3336 0
 4397 25c8 0000A0E3 		mov	r0, #0
 4398 25cc 0020A0E1 		mov	r2, r0
 4399 25d0 0110A0E3 		mov	r1, #1
 4400 25d4 FEFFFFEB 		bl	CyU3PUsbStall
 4401              	.LVL499:
 4402 25d8 50309DE5 		ldr	r3, [sp, #80]
 4403              	.L259:
3341:../uvc.c      ****             {
 4404              		.loc 1 3341 0
 4405 25dc 080013E3 		tst	r3, #8
 4406 25e0 0700000A 		beq	.L500
3345:../uvc.c      ****                 {
 4407              		.loc 1 3345 0
 4408 25e4 B030D8E1 		ldrh	r3, [r8]
 4409 25e8 010053E3 		cmp	r3, #1
 4410 25ec 7500000A 		beq	.L501
 4411              	.L502:
 4412              	.LBB350:
 4413              	.LBB134:
3258:../uvc.c      ****             break;
 4414              		.loc 1 3258 0
 4415 25f0 0000A0E3 		mov	r0, #0
 4416 25f4 0020A0E1 		mov	r2, r0
 4417 25f8 0110A0E3 		mov	r1, #1
 4418 25fc FEFFFFEB 		bl	CyU3PUsbStall
 4419              	.LVL500:
 4420              	.L515:
 4421 2600 50309DE5 		ldr	r3, [sp, #80]
 4422              	.L500:
 4423              	.LBE134:
 4424              	.LBE350:
3356:../uvc.c      ****             {
 4425              		.loc 1 3356 0
 4426 2604 400013E3 		tst	r3, #64
 4427 2608 2500000A 		beq	.L255
3361:../uvc.c      **** 
 4428              		.loc 1 3361 0
 4429 260c 1800A0E3 		mov	r0, #24
 4430 2610 58108DE2 		add	r1, sp, #88
 4431 2614 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 4432              	.LVL501:
3366:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4433              		.loc 1 3366 0
 4434 2618 58309DE5 		ldr	r3, [sp, #88]
 4435 261c 000053E3 		cmp	r3, #0
 4436 2620 4800001A 		bne	.L690
3390:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4437              		.loc 1 3390 0
 4438 2624 4326DAE5 		ldrb	r2, [r10, #1603]	@ zero_extendqisi2
 4439 2628 000052E3 		cmp	r2, #0
 4440 262c 1C00000A 		beq	.L255
3392:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4441              		.loc 1 3392 0
 4442 2630 002095E5 		ldr	r2, [r5]
 4443 2634 0210A0E3 		mov	r1, #2
 4444 2638 0010C2E5 		strb	r1, [r2]
3393:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4445              		.loc 1 3393 0
 4446 263c 001095E5 		ldr	r1, [r5]
 4447 2640 0120A0E3 		mov	r2, #1
 4448 2644 0120C1E5 		strb	r2, [r1, #1]
3394:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4449              		.loc 1 3394 0
 4450 2648 001095E5 		ldr	r1, [r5]
3398:../uvc.c      **** 					interStabuf.status = 0;
 4451              		.loc 1 3398 0
 4452 264c 01CBA0E3 		mov	ip, #1024
3394:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4453              		.loc 1 3394 0
 4454 2650 0230C1E5 		strb	r3, [r1, #2]
3395:../uvc.c      **** 
 4455              		.loc 1 3395 0
 4456 2654 001095E5 		ldr	r1, [r5]
3401:../uvc.c      **** 
 4457              		.loc 1 3401 0
 4458 2658 0470A0E3 		mov	r7, #4
3395:../uvc.c      **** 
 4459              		.loc 1 3395 0
 4460 265c 0320C1E5 		strb	r2, [r1, #3]
3397:../uvc.c      **** 					interStabuf.size   = 1024;
 4461              		.loc 1 3397 0
 4462 2660 002095E5 		ldr	r2, [r5]
3404:../uvc.c      **** 
 4463              		.loc 1 3404 0
 4464 2664 0010E0E3 		mvn	r1, #0
 4465 2668 780E9FE5 		ldr	r0, .L720+28
3399:../uvc.c      **** 
 4466              		.loc 1 3399 0
 4467 266c B436CDE1 		strh	r3, [sp, #100]	@ movhi
3397:../uvc.c      **** 					interStabuf.size   = 1024;
 4468              		.loc 1 3397 0
 4469 2670 5C208DE5 		str	r2, [sp, #92]
3398:../uvc.c      **** 					interStabuf.status = 0;
 4470              		.loc 1 3398 0
 4471 2674 B2C6CDE1 		strh	ip, [sp, #98]	@ movhi
3401:../uvc.c      **** 
 4472              		.loc 1 3401 0
 4473 2678 B076CDE1 		strh	r7, [sp, #96]	@ movhi
3404:../uvc.c      **** 
 4474              		.loc 1 3404 0
 4475 267c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 4476              	.LVL502:
3407:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4477              		.loc 1 3407 0
 4478 2680 600E9FE5 		ldr	r0, .L720+28
 4479 2684 5C108DE2 		add	r1, sp, #92
 4480 2688 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4481              	.LVL503:
3408:../uvc.c      **** 					{
 4482              		.loc 1 3408 0
 4483 268c 000050E3 		cmp	r0, #0
 4484 2690 AD05001A 		bne	.L691
3414:../uvc.c      **** 					stiflag = 0xFF;
 4485              		.loc 1 3414 0
 4486 2694 34EE9FE5 		ldr	lr, .L720+4
3415:../uvc.c      **** 				}
 4487              		.loc 1 3415 0
 4488 2698 FF30A0E3 		mov	r3, #255
3414:../uvc.c      **** 					stiflag = 0xFF;
 4489              		.loc 1 3414 0
 4490 269c 4306CEE5 		strb	r0, [lr, #1603]
3415:../uvc.c      **** 				}
 4491              		.loc 1 3415 0
 4492 26a0 743089E5 		str	r3, [r9, #116]
 4493              	.LVL504:
 4494              	.L255:
3569:../uvc.c      ****     }
 4495              		.loc 1 3569 0
 4496 26a4 FEFFFFEB 		bl	_txe_thread_relinquish
 4497              	.LVL505:
3570:../uvc.c      **** }
 4498              		.loc 1 3570 0
 4499 26a8 9CFFFFEA 		b	.L555
 4500              	.L264:
 4501              	.LBB351:
 4502              	.LBB352:
2551:../uvc.c      ****     {
 4503              		.loc 1 2551 0
 4504 26ac B020DBE1 		ldrh	r2, [fp]
 4505 26b0 060C52E3 		cmp	r2, #1536
 4506 26b4 6E01000A 		beq	.L267
 4507 26b8 7500008A 		bhi	.L268
 4508 26bc 030C52E3 		cmp	r2, #768
 4509 26c0 7301000A 		beq	.L269
 4510 26c4 E000008A 		bhi	.L270
 4511 26c8 010C52E3 		cmp	r2, #256
 4512 26cc 6C01000A 		beq	.L271
 4513 26d0 020C52E3 		cmp	r2, #512
 4514 26d4 B6FFFF1A 		bne	.L280
 4515              	.L448:
 4516              	.LVL506:
 4517              	.LBE352:
 4518              	.LBE351:
 4519              	.LBB356:
 4520              	.LBB357:
2898:../uvc.c      ****     		break;
 4521              		.loc 1 2898 0
 4522 26d8 1A00A0E3 		mov	r0, #26
 4523 26dc FEFFFFEB 		bl	ControlHandle
 4524              	.LVL507:
 4525 26e0 50309DE5 		ldr	r3, [sp, #80]
 4526 26e4 BCFFFFEA 		b	.L259
 4527              	.L265:
2851:../uvc.c      ****     {
 4528              		.loc 1 2851 0
 4529 26e8 B030DBE1 		ldrh	r3, [fp]
 4530 26ec 090C53E3 		cmp	r3, #2304
 4531 26f0 4103000A 		beq	.L434
 4532 26f4 5800008A 		bhi	.L435
 4533 26f8 010B53E3 		cmp	r3, #1024
 4534 26fc 1203000A 		beq	.L436
 4535 2700 EB00009A 		bls	.L692
 4536 2704 060C53E3 		cmp	r3, #1536
 4537 2708 4303000A 		beq	.L441
 4538 270c B902009A 		bls	.L693
 4539 2710 070C53E3 		cmp	r3, #1792
 4540 2714 3C03000A 		beq	.L444
 4541 2718 020B53E3 		cmp	r3, #2048
 4542 271c A9FFFF1A 		bne	.L260
 4543              	.LVL508:
2883:../uvc.c      ****     		break;
 4544              		.loc 1 2883 0
 4545 2720 1700A0E3 		mov	r0, #23
 4546 2724 FEFFFFEB 		bl	ControlHandle
 4547              	.LVL509:
 4548 2728 50309DE5 		ldr	r3, [sp, #80]
 4549 272c AAFFFFEA 		b	.L259
 4550              	.L686:
 4551              	.LBE357:
 4552              	.LBE356:
3297:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4553              		.loc 1 3297 0
 4554 2730 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 4555              	.LVL510:
3298:../uvc.c      ****                 {
 4556              		.loc 1 3298 0
 4557 2734 000050E3 		cmp	r0, #0
3300:../uvc.c      ****                 }
 4558              		.loc 1 3300 0
 4559 2738 0130A013 		movne	r3, #1
3297:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4560              		.loc 1 3297 0
 4561 273c C000C4E5 		strb	r0, [r4, #192]
3300:../uvc.c      ****                 }
 4562              		.loc 1 3300 0
 4563 2740 88308415 		strne	r3, [r4, #136]
 4564 2744 81FFFFEA 		b	.L257
 4565              	.L690:
3366:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 4566              		.loc 1 3366 0 discriminator 1
 4567 2748 4336DAE5 		ldrb	r3, [r10, #1603]	@ zero_extendqisi2
 4568 274c 000053E3 		cmp	r3, #0
 4569 2750 D3FFFF1A 		bne	.L255
3368:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4570              		.loc 1 3368 0
 4571 2754 002095E5 		ldr	r2, [r5]
 4572 2758 0210A0E3 		mov	r1, #2
 4573 275c 0010C2E5 		strb	r1, [r2]
3369:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4574              		.loc 1 3369 0
 4575 2760 002095E5 		ldr	r2, [r5]
 4576 2764 0160A0E3 		mov	r6, #1
 4577 2768 0160C2E5 		strb	r6, [r2, #1]
3370:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4578              		.loc 1 3370 0
 4579 276c 001095E5 		ldr	r1, [r5]
3374:../uvc.c      **** 					interStabuf.status = 0;
 4580              		.loc 1 3374 0
 4581 2770 012BA0E3 		mov	r2, #1024
3370:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4582              		.loc 1 3370 0
 4583 2774 0230C1E5 		strb	r3, [r1, #2]
3371:../uvc.c      **** 
 4584              		.loc 1 3371 0
 4585 2778 001095E5 		ldr	r1, [r5]
3377:../uvc.c      **** 
 4586              		.loc 1 3377 0
 4587 277c 0470A0E3 		mov	r7, #4
3371:../uvc.c      **** 
 4588              		.loc 1 3371 0
 4589 2780 0330C1E5 		strb	r3, [r1, #3]
3373:../uvc.c      **** 					interStabuf.size   = 1024;
 4590              		.loc 1 3373 0
 4591 2784 001095E5 		ldr	r1, [r5]
3380:../uvc.c      **** 
 4592              		.loc 1 3380 0
 4593 2788 580D9FE5 		ldr	r0, .L720+28
3373:../uvc.c      **** 					interStabuf.size   = 1024;
 4594              		.loc 1 3373 0
 4595 278c 5C108DE5 		str	r1, [sp, #92]
3380:../uvc.c      **** 
 4596              		.loc 1 3380 0
 4597 2790 0010E0E3 		mvn	r1, #0
3375:../uvc.c      **** 
 4598              		.loc 1 3375 0
 4599 2794 B436CDE1 		strh	r3, [sp, #100]	@ movhi
3374:../uvc.c      **** 					interStabuf.status = 0;
 4600              		.loc 1 3374 0
 4601 2798 B226CDE1 		strh	r2, [sp, #98]	@ movhi
3377:../uvc.c      **** 
 4602              		.loc 1 3377 0
 4603 279c B076CDE1 		strh	r7, [sp, #96]	@ movhi
3380:../uvc.c      **** 
 4604              		.loc 1 3380 0
 4605 27a0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 4606              	.LVL511:
3383:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4607              		.loc 1 3383 0
 4608 27a4 3C0D9FE5 		ldr	r0, .L720+28
 4609 27a8 5C108DE2 		add	r1, sp, #92
 4610 27ac FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4611              	.LVL512:
3384:../uvc.c      **** 					{
 4612              		.loc 1 3384 0
 4613 27b0 000050E3 		cmp	r0, #0
 4614 27b4 2703001A 		bne	.L694
3389:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4615              		.loc 1 3389 0
 4616 27b8 10CD9FE5 		ldr	ip, .L720+4
 4617 27bc 4366CCE5 		strb	r6, [ip, #1603]
3569:../uvc.c      ****     }
 4618              		.loc 1 3569 0
 4619 27c0 FEFFFFEB 		bl	_txe_thread_relinquish
 4620              	.LVL513:
 4621 27c4 55FFFFEA 		b	.L555
 4622              	.L501:
 4623              	.LVL514:
 4624              	.LBB416:
 4625              	.LBB135:
2946:../uvc.c      ****     {
 4626              		.loc 1 2946 0
 4627 27c8 B020DBE1 		ldrh	r2, [fp]
 4628 27cc 030C52E3 		cmp	r2, #768
 4629 27d0 7000000A 		beq	.L503
 4630 27d4 1200008A 		bhi	.L504
 4631 27d8 010C52E3 		cmp	r2, #256
 4632 27dc 7F00000A 		beq	.L505
 4633 27e0 020C52E3 		cmp	r2, #512
 4634 27e4 81FFFF1A 		bne	.L502
3000:../uvc.c      ****             {
 4635              		.loc 1 3000 0
 4636 27e8 F03C9FE5 		ldr	r3, .L720+20
 4637 27ec 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 4638 27f0 810053E3 		cmp	r3, #129
 4639 27f4 8100000A 		beq	.L543
 4640 27f8 5702009A 		bls	.L695
 4641 27fc 850053E3 		cmp	r3, #133
 4642 2800 6E00000A 		beq	.L539
 4643 2804 860053E3 		cmp	r3, #134
 4644 2808 78FFFF1A 		bne	.L502
 4645              	.L681:
3206:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4646              		.loc 1 3206 0
 4647 280c 0330A0E3 		mov	r3, #3
3207:../uvc.c      ****                         break;
 4648              		.loc 1 3207 0
 4649 2810 281D9FE5 		ldr	r1, .L720+116
 4650 2814 0100A0E3 		mov	r0, #1
3206:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4651              		.loc 1 3206 0
 4652 2818 9C30C9E5 		strb	r3, [r9, #156]
3207:../uvc.c      ****                         break;
 4653              		.loc 1 3207 0
 4654 281c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4655              	.LVL515:
 4656 2820 76FFFFEA 		b	.L515
 4657              	.L504:
2946:../uvc.c      ****     {
 4658              		.loc 1 2946 0
 4659 2824 010B52E3 		cmp	r2, #1024
 4660 2828 7800000A 		beq	.L507
 4661 282c 050C52E3 		cmp	r2, #1280
 4662 2830 6EFFFF1A 		bne	.L502
3203:../uvc.c      ****                 {
 4663              		.loc 1 3203 0
 4664 2834 A42C9FE5 		ldr	r2, .L720+20
 4665 2838 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4666 283c 810052E3 		cmp	r2, #129
 4667 2840 6E00000A 		beq	.L543
 4668 2844 2C02009A 		bls	.L696
 4669 2848 850052E3 		cmp	r2, #133
 4670 284c FA02000A 		beq	.L546
 4671 2850 860052E3 		cmp	r2, #134
 4672 2854 ECFFFF0A 		beq	.L681
 4673 2858 64FFFFEA 		b	.L502
 4674              	.LVL516:
 4675              	.L435:
 4676              	.LBE135:
 4677              	.LBE416:
 4678              	.LBB417:
 4679              	.LBB408:
2851:../uvc.c      ****     {
 4680              		.loc 1 2851 0
 4681 285c 0F0C53E3 		cmp	r3, #3840
 4682 2860 C902000A 		beq	.L446
 4683 2864 8800009A 		bls	.L697
 4684 2868 110C53E3 		cmp	r3, #4352
 4685 286c EE02000A 		beq	.L451
 4686 2870 6602009A 		bls	.L698
 4687 2874 120C53E3 		cmp	r3, #4608
 4688 2878 9702000A 		beq	.L454
 4689 287c 130C53E3 		cmp	r3, #4864
 4690 2880 50FFFF1A 		bne	.L260
 4691              	.LVL517:
2926:../uvc.c      ****     		break;
 4692              		.loc 1 2926 0
 4693 2884 2600A0E3 		mov	r0, #38
 4694 2888 FEFFFFEB 		bl	ControlHandle
 4695              	.LVL518:
 4696 288c 50309DE5 		ldr	r3, [sp, #80]
 4697 2890 51FFFFEA 		b	.L259
 4698              	.L268:
 4699              	.LBE408:
 4700              	.LBE417:
 4701              	.LBB418:
 4702              	.LBB353:
2551:../uvc.c      ****     {
 4703              		.loc 1 2551 0
 4704 2894 0A0C52E3 		cmp	r2, #2560
 4705 2898 0101000A 		beq	.L274
 4706 289c 7200009A 		bls	.L699
 4707 28a0 0D0C52E3 		cmp	r2, #3328
 4708 28a4 FE00000A 		beq	.L274
 4709 28a8 0E0C52E3 		cmp	r2, #3584
 4710 28ac 0001000A 		beq	.L278
 4711 28b0 030B52E3 		cmp	r2, #3072
 4712 28b4 3EFFFF1A 		bne	.L280
 4713              	.LVL519:
2592:../uvc.c      ****     		break;
 4714              		.loc 1 2592 0
 4715 28b8 0B00A0E3 		mov	r0, #11
 4716 28bc FEFFFFEB 		bl	ControlHandle
 4717              	.LVL520:
 4718 28c0 50309DE5 		ldr	r3, [sp, #80]
 4719 28c4 44FFFFEA 		b	.L259
 4720              	.L687:
 4721              	.LBE353:
 4722              	.LBE418:
 4723              	.LBB419:
 4724              	.LBB340:
2626:../uvc.c      ****     {
 4725              		.loc 1 2626 0
 4726 28c8 030C52E3 		cmp	r2, #768
 4727 28cc DD01000A 		beq	.L283
 4728 28d0 8600008A 		bhi	.L284
 4729 28d4 010C52E3 		cmp	r2, #256
 4730 28d8 9901000A 		beq	.L285
 4731 28dc 020C52E3 		cmp	r2, #512
 4732 28e0 33FFFF1A 		bne	.L280
 4733              	.LVL521:
 4734              	.LBB146:
 4735              	.LBB147:
 984:../uvc.c      **** 
 4736              		.loc 1 984 0
 4737 28e4 F4CB9FE5 		ldr	ip, .L720+20
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4738              		.loc 1 977 0
 4739 28e8 A8E4DAE5 		ldrb	lr, [r10, #1192]	@ zero_extendqisi2
 984:../uvc.c      **** 
 4740              		.loc 1 984 0
 4741 28ec 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4742              		.loc 1 979 0
 4743 28f0 AA14DAE5 		ldrb	r1, [r10, #1194]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 4744              		.loc 1 986 0
 4745 28f4 830056E3 		cmp	r6, #131
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4746              		.loc 1 976 0
 4747 28f8 B734DAE5 		ldrb	r3, [r10, #1207]	@ zero_extendqisi2
 4748              	.LVL522:
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4749              		.loc 1 977 0
 4750 28fc 34E08DE5 		str	lr, [sp, #52]
 4751              	.LVL523:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4752              		.loc 1 979 0
 4753 2900 30108DE5 		str	r1, [sp, #48]
 4754              	.LVL524:
 986:../uvc.c      **** 		 {
 4755              		.loc 1 986 0
 4756 2904 BD06000A 		beq	.L307
 4757 2908 A703009A 		bls	.L700
 4758 290c 850056E3 		cmp	r6, #133
 4759 2910 BE06000A 		beq	.L312
 4760 2914 8605003A 		bcc	.L313
 4761 2918 860056E3 		cmp	r6, #134
 4762 291c 8806000A 		beq	.L314
 4763 2920 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4764              		.loc 1 1048 0
 4765 2924 B314DA05 		ldreqb	r1, [r10, #1203]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4766              		.loc 1 1049 0
 4767 2928 B424DA05 		ldreqb	r2, [r10, #1204]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 4768              		.loc 1 986 0
 4769 292c D705001A 		bne	.L306
 4770              	.L657:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4771              		.loc 1 1027 0
 4772 2930 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4773              		.loc 1 1024 0
 4774 2934 9C10C9E5 		strb	r1, [r9, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4775              		.loc 1 1029 0
 4776 2938 30009DE5 		ldr	r0, [sp, #48]
 4777 293c FC1B9FE5 		ldr	r1, .L720+116
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4778              		.loc 1 1027 0
 4779 2940 9E30C9E5 		strb	r3, [r9, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4780              		.loc 1 1028 0
 4781 2944 9F30C9E5 		strb	r3, [r9, #159]
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4782              		.loc 1 1025 0
 4783 2948 9D20C9E5 		strb	r2, [r9, #157]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4784              		.loc 1 1029 0
 4785 294c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4786              	.LVL525:
1030:../uvc.c      **** 			  break;
 4787              		.loc 1 1030 0
 4788 2950 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 4789              	.LVL526:
 4790 2954 30309DE5 		ldr	r3, [sp, #48]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 4791              		.loc 1 980 0
 4792 2958 FFC0A0E3 		mov	ip, #255
 4793              	.LVL527:
 4794              	.L316:
1199:../uvc.c      **** }
 4795              		.loc 1 1199 0
 4796 295c 9E00D9E5 		ldrb	r0, [r9, #158]	@ zero_extendqisi2
 4797 2960 FF10A0E3 		mov	r1, #255
 4798 2964 14308DE5 		str	r3, [sp, #20]
 4799 2968 04008DE5 		str	r0, [sp, #4]
 4800 296c 0C30A0E1 		mov	r3, ip
 4801 2970 10008DE5 		str	r0, [sp, #16]
 4802 2974 00108DE5 		str	r1, [sp]
 4803 2978 0C108DE5 		str	r1, [sp, #12]
 4804 297c 08708DE5 		str	r7, [sp, #8]
 4805 2980 0620A0E1 		mov	r2, r6
 4806 2984 0400A0E3 		mov	r0, #4
 4807 2988 5C1B9FE5 		ldr	r1, .L720+32
 4808 298c FEFFFFEB 		bl	CyU3PDebugPrint
 4809              	.LVL528:
 4810 2990 50309DE5 		ldr	r3, [sp, #80]
 4811 2994 10FFFFEA 		b	.L259
 4812              	.LVL529:
 4813              	.L503:
 4814              	.LBE147:
 4815              	.LBE146:
 4816              	.LBE340:
 4817              	.LBE419:
 4818              	.LBB420:
 4819              	.LBB136:
3077:../uvc.c      ****                 {
 4820              		.loc 1 3077 0
 4821 2998 402B9FE5 		ldr	r2, .L720+20
 4822 299c 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4823 29a0 830052E3 		cmp	r2, #131
 4824 29a4 7500009A 		bls	.L701
 4825 29a8 860052E3 		cmp	r2, #134
 4826 29ac 2000000A 		beq	.L682
 4827 29b0 870052E3 		cmp	r2, #135
 4828 29b4 6A00000A 		beq	.L530
 4829              	.L685:
 4830 29b8 850052E3 		cmp	r2, #133
 4831 29bc 0BFFFF1A 		bne	.L502
 4832              	.L539:
3134:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4833              		.loc 1 3134 0
 4834 29c0 1A20A0E3 		mov	r2, #26
3135:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4835              		.loc 1 3135 0
 4836 29c4 0030A0E3 		mov	r3, #0
3136:../uvc.c      ****                         break;
 4837              		.loc 1 3136 0
 4838 29c8 701B9FE5 		ldr	r1, .L720+116
 4839 29cc 0200A0E3 		mov	r0, #2
3134:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4840              		.loc 1 3134 0
 4841 29d0 9C20C9E5 		strb	r2, [r9, #156]
3135:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4842              		.loc 1 3135 0
 4843 29d4 9D30C9E5 		strb	r3, [r9, #157]
3136:../uvc.c      ****                         break;
 4844              		.loc 1 3136 0
 4845 29d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4846              	.LVL530:
 4847 29dc 07FFFFEA 		b	.L515
 4848              	.L505:
2949:../uvc.c      ****             {
 4849              		.loc 1 2949 0
 4850 29e0 F82A9FE5 		ldr	r2, .L720+20
 4851 29e4 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4852 29e8 830052E3 		cmp	r2, #131
 4853 29ec 8000009A 		bls	.L702
 4854 29f0 860052E3 		cmp	r2, #134
 4855 29f4 0E00000A 		beq	.L682
 4856 29f8 870052E3 		cmp	r2, #135
 4857 29fc EDFFFF1A 		bne	.L685
 4858              	.L543:
3217:../uvc.c      ****                         }
 4859              		.loc 1 3217 0
 4860 2a00 E81A9FE5 		ldr	r1, .L720+36
 4861 2a04 1A00A0E3 		mov	r0, #26
 4862 2a08 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4863              	.LVL531:
 4864 2a0c FBFEFFEA 		b	.L515
 4865              	.L507:
3127:../uvc.c      ****                 {
 4866              		.loc 1 3127 0
 4867 2a10 C82A9FE5 		ldr	r2, .L720+20
 4868 2a14 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 4869 2a18 810052E3 		cmp	r2, #129
 4870 2a1c 5000000A 		beq	.L530
 4871 2a20 ED01009A 		bls	.L703
 4872 2a24 850052E3 		cmp	r2, #133
 4873 2a28 E4FFFF0A 		beq	.L539
 4874 2a2c 860052E3 		cmp	r2, #134
 4875 2a30 EEFEFF1A 		bne	.L502
 4876              	.L682:
3131:../uvc.c      ****                         break;
 4877              		.loc 1 3131 0
 4878 2a34 0300A0E1 		mov	r0, r3
 4879 2a38 001B9FE5 		ldr	r1, .L720+116
3130:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4880              		.loc 1 3130 0
 4881 2a3c 0330A0E3 		mov	r3, #3
 4882 2a40 9C30C9E5 		strb	r3, [r9, #156]
3131:../uvc.c      ****                         break;
 4883              		.loc 1 3131 0
 4884 2a44 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4885              	.LVL532:
 4886 2a48 ECFEFFEA 		b	.L515
 4887              	.LVL533:
 4888              	.L270:
 4889              	.LBE136:
 4890              	.LBE420:
 4891              	.LBB421:
 4892              	.LBB354:
2551:../uvc.c      ****     {
 4893              		.loc 1 2551 0
 4894 2a4c 010B52E3 		cmp	r2, #1024
 4895 2a50 E1FEFF0A 		beq	.L259
 4896 2a54 050C52E3 		cmp	r2, #1280
 4897 2a58 D5FEFF1A 		bne	.L280
 4898              	.LVL534:
2570:../uvc.c      ****       		break;
 4899              		.loc 1 2570 0
 4900 2a5c 0400A0E3 		mov	r0, #4
 4901 2a60 FEFFFFEB 		bl	ControlHandle
 4902              	.LVL535:
 4903 2a64 50309DE5 		ldr	r3, [sp, #80]
 4904 2a68 DBFEFFEA 		b	.L259
 4905              	.L699:
2551:../uvc.c      ****     {
 4906              		.loc 1 2551 0
 4907 2a6c 070C52E3 		cmp	r2, #1792
 4908 2a70 9300000A 		beq	.L276
 4909 2a74 020B52E3 		cmp	r2, #2048
 4910 2a78 CDFEFF1A 		bne	.L280
 4911              	.LVL536:
2582:../uvc.c      ****           		break;
 4912              		.loc 1 2582 0
 4913 2a7c 0700A0E3 		mov	r0, #7
 4914 2a80 FEFFFFEB 		bl	ControlHandle
 4915              	.LVL537:
 4916 2a84 50309DE5 		ldr	r3, [sp, #80]
 4917 2a88 D3FEFFEA 		b	.L259
 4918              	.L697:
 4919              	.LBE354:
 4920              	.LBE421:
 4921              	.LBB422:
 4922              	.LBB409:
2851:../uvc.c      ****     {
 4923              		.loc 1 2851 0
 4924 2a8c 0B0C53E3 		cmp	r3, #2816
 4925 2a90 10FFFF0A 		beq	.L448
 4926 2a94 0D0C53E3 		cmp	r3, #3328
 4927 2a98 2F02000A 		beq	.L449
 4928 2a9c 0A0C53E3 		cmp	r3, #2560
 4929 2aa0 C8FEFF1A 		bne	.L260
 4930              	.LVL538:
2892:../uvc.c      ****     		}else/* no support for 1080p camera */
 4931              		.loc 1 2892 0
 4932 2aa4 1900A0E3 		mov	r0, #25
 4933 2aa8 FEFFFFEB 		bl	ControlHandle
 4934              	.LVL539:
 4935 2aac 50309DE5 		ldr	r3, [sp, #80]
 4936 2ab0 C9FEFFEA 		b	.L259
 4937              	.L692:
2851:../uvc.c      ****     {
 4938              		.loc 1 2851 0
 4939 2ab4 020C53E3 		cmp	r3, #512
 4940 2ab8 2F02000A 		beq	.L438
 4941 2abc 030C53E3 		cmp	r3, #768
 4942 2ac0 2902000A 		beq	.L439
 4943 2ac4 010C53E3 		cmp	r3, #256
 4944 2ac8 BEFEFF1A 		bne	.L260
 4945              	.LVL540:
2855:../uvc.c      ****     		break;
 4946              		.loc 1 2855 0
 4947 2acc 1000A0E3 		mov	r0, #16
 4948 2ad0 FEFFFFEB 		bl	ControlHandle
 4949              	.LVL541:
 4950 2ad4 50309DE5 		ldr	r3, [sp, #80]
 4951 2ad8 BFFEFFEA 		b	.L259
 4952              	.L688:
 4953              	.LBE409:
 4954              	.LBE422:
 4955              	.LBB423:
 4956              	.LBB341:
2626:../uvc.c      ****     {
 4957              		.loc 1 2626 0
 4958 2adc 070C52E3 		cmp	r2, #1792
 4959 2ae0 6901000A 		beq	.L291
 4960 2ae4 020B52E3 		cmp	r2, #2048
 4961 2ae8 BBFEFF0A 		beq	.L259
 4962 2aec B0FEFFEA 		b	.L280
 4963              	.L284:
 4964 2af0 010B52E3 		cmp	r2, #1024
 4965 2af4 EE00000A 		beq	.L287
 4966 2af8 050C52E3 		cmp	r2, #1280
 4967 2afc ACFEFF1A 		bne	.L280
 4968              	.LVL542:
 4969              	.LBB164:
 4970              	.LBB165:
 984:../uvc.c      **** 
 4971              		.loc 1 984 0
 4972 2b00 D8C99FE5 		ldr	ip, .L720+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4973              		.loc 1 979 0
 4974 2b04 F274DAE5 		ldrb	r7, [r10, #1266]	@ zero_extendqisi2
 4975              	.LVL543:
 984:../uvc.c      **** 
 4976              		.loc 1 984 0
 4977 2b08 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 4978              	.LVL544:
 986:../uvc.c      **** 		 {
 4979              		.loc 1 986 0
 4980 2b0c 830056E3 		cmp	r6, #131
 4981 2b10 3606000A 		beq	.L349
 4982 2b14 B302009A 		bls	.L704
 4983 2b18 850056E3 		cmp	r6, #133
 4984 2b1c D901000A 		beq	.L411
 4985 2b20 1505003A 		bcc	.L355
 4986 2b24 860056E3 		cmp	r6, #134
 4987 2b28 EC05000A 		beq	.L356
 4988 2b2c 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4989              		.loc 1 1048 0
 4990 2b30 FB14DA05 		ldreqb	r1, [r10, #1275]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4991              		.loc 1 1049 0
 4992 2b34 FC24DA05 		ldreqb	r2, [r10, #1276]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 4993              		.loc 1 986 0
 4994 2b38 9E05001A 		bne	.L348
 4995              	.LVL545:
 4996              	.L667:
 4997              	.LBE165:
 4998              	.LBE164:
 4999              	.LBB173:
 5000              	.LBB174:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5001              		.loc 1 1027 0
 5002 2b3c 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5003              		.loc 1 1024 0
 5004 2b40 9C10C9E5 		strb	r1, [r9, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5005              		.loc 1 1029 0
 5006 2b44 0700A0E1 		mov	r0, r7
 5007 2b48 F0199FE5 		ldr	r1, .L720+116
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5008              		.loc 1 1025 0
 5009 2b4c 9D20C9E5 		strb	r2, [r9, #157]
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5010              		.loc 1 1027 0
 5011 2b50 9E30C9E5 		strb	r3, [r9, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5012              		.loc 1 1028 0
 5013 2b54 9F30C9E5 		strb	r3, [r9, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5014              		.loc 1 1029 0
 5015 2b58 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5016              	.LVL546:
1030:../uvc.c      **** 			  break;
 5017              		.loc 1 1030 0
 5018 2b5c 9C20D9E5 		ldrb	r2, [r9, #156]	@ zero_extendqisi2
 5019              	.LVL547:
 5020 2b60 CF0100EA 		b	.L415
 5021              	.LVL548:
 5022              	.L530:
 5023              	.LBE174:
 5024              	.LBE173:
 5025              	.LBE341:
 5026              	.LBE423:
 5027              	.LBB424:
 5028              	.LBB137:
3092:../uvc.c      ****                         {
 5029              		.loc 1 3092 0
 5030 2b64 C030D9E5 		ldrb	r3, [r9, #192]	@ zero_extendqisi2
3094:../uvc.c      ****                         }
 5031              		.loc 1 3094 0
 5032 2b68 0B00A0E3 		mov	r0, #11
3092:../uvc.c      ****                         {
 5033              		.loc 1 3092 0
 5034 2b6c 030053E3 		cmp	r3, #3
3094:../uvc.c      ****                         }
 5035              		.loc 1 3094 0
 5036 2b70 7C199F05 		ldreq	r1, .L720+40
3098:../uvc.c      ****                         }
 5037              		.loc 1 3098 0
 5038 2b74 7C199F15 		ldrne	r1, .L720+44
 5039 2b78 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5040              	.LVL549:
 5041 2b7c 9FFEFFEA 		b	.L515
 5042              	.L701:
3077:../uvc.c      ****                 {
 5043              		.loc 1 3077 0
 5044 2b80 810052E3 		cmp	r2, #129
 5045 2b84 F6FFFF2A 		bcs	.L530
 5046 2b88 010052E3 		cmp	r2, #1
 5047 2b8c 97FEFF1A 		bne	.L502
3102:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5048              		.loc 1 3102 0
 5049 2b90 2000A0E3 		mov	r0, #32
 5050 2b94 60199FE5 		ldr	r1, .L720+48
 5051 2b98 48208DE2 		add	r2, sp, #72
 5052 2b9c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5053              	.LVL550:
3104:../uvc.c      ****                         {
 5054              		.loc 1 3104 0
 5055 2ba0 000050E3 		cmp	r0, #0
 5056 2ba4 95FEFF1A 		bne	.L515
3110:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5057              		.loc 1 3110 0
 5058 2ba8 C510D4E5 		ldrb	r1, [r4, #197]	@ zero_extendqisi2
3111:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5059              		.loc 1 3111 0
 5060 2bac C6C0D4E5 		ldrb	ip, [r4, #198]	@ zero_extendqisi2
3113:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5061              		.loc 1 3113 0
 5062 2bb0 C800D4E5 		ldrb	r0, [r4, #200]	@ zero_extendqisi2
 5063              	.LVL551:
3112:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5064              		.loc 1 3112 0
 5065 2bb4 C7E0D4E5 		ldrb	lr, [r4, #199]	@ zero_extendqisi2
3117:../uvc.c      ****                         }
 5066              		.loc 1 3117 0
 5067 2bb8 C430D4E5 		ldrb	r3, [r4, #196]	@ zero_extendqisi2
3110:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5068              		.loc 1 3110 0
 5069 2bbc 2D16CAE5 		strb	r1, [r10, #1581]
3117:../uvc.c      ****                         }
 5070              		.loc 1 3117 0
 5071 2bc0 00108DE5 		str	r1, [sp]
3114:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5072              		.loc 1 3114 0
 5073 2bc4 C910D4E5 		ldrb	r1, [r4, #201]	@ zero_extendqisi2
3111:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5074              		.loc 1 3111 0
 5075 2bc8 2EC6CAE5 		strb	ip, [r10, #1582]
3115:../uvc.c      ****                             }
 5076              		.loc 1 3115 0
 5077 2bcc CAC0D4E5 		ldrb	ip, [r4, #202]	@ zero_extendqisi2
3113:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5078              		.loc 1 3113 0
 5079 2bd0 3006CAE5 		strb	r0, [r10, #1584]
3114:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5080              		.loc 1 3114 0
 5081 2bd4 3116CAE5 		strb	r1, [r10, #1585]
3117:../uvc.c      ****                         }
 5082              		.loc 1 3117 0
 5083 2bd8 B824DDE1 		ldrh	r2, [sp, #72]
 5084 2bdc 1C199FE5 		ldr	r1, .L720+52
 5085 2be0 0400A0E3 		mov	r0, #4
3112:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5086              		.loc 1 3112 0
 5087 2be4 2FE6CAE5 		strb	lr, [r10, #1583]
3115:../uvc.c      ****                             }
 5088              		.loc 1 3115 0
 5089 2be8 32C6CAE5 		strb	ip, [r10, #1586]
3117:../uvc.c      ****                         }
 5090              		.loc 1 3117 0
 5091 2bec FEFFFFEB 		bl	CyU3PDebugPrint
 5092              	.LVL552:
 5093 2bf0 82FEFFEA 		b	.L515
 5094              	.LVL553:
 5095              	.L702:
2949:../uvc.c      ****             {
 5096              		.loc 1 2949 0
 5097 2bf4 810052E3 		cmp	r2, #129
 5098 2bf8 80FFFF2A 		bcs	.L543
 5099 2bfc 010052E3 		cmp	r2, #1
 5100 2c00 7AFEFF1A 		bne	.L502
2974:../uvc.c      ****                             glCommitCtrl, &readCount);
 5101              		.loc 1 2974 0
 5102 2c04 2000A0E3 		mov	r0, #32
 5103 2c08 EC189FE5 		ldr	r1, .L720+48
 5104 2c0c 48208DE2 		add	r2, sp, #72
 5105 2c10 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5106              	.LVL554:
2976:../uvc.c      ****                     {
 5107              		.loc 1 2976 0
 5108 2c14 000050E3 		cmp	r0, #0
 5109 2c18 78FEFF1A 		bne	.L515
2984:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 5110              		.loc 1 2984 0
 5111 2c1c C8E0D4E5 		ldrb	lr, [r4, #200]	@ zero_extendqisi2
2986:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 5112              		.loc 1 2986 0
 5113 2c20 CA00D4E5 		ldrb	r0, [r4, #202]	@ zero_extendqisi2
 5114              	.LVL555:
2987:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
 5115              		.loc 1 2987 0
 5116 2c24 CB10D4E5 		ldrb	r1, [r4, #203]	@ zero_extendqisi2
2983:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 5117              		.loc 1 2983 0
 5118 2c28 C760D4E5 		ldrb	r6, [r4, #199]	@ zero_extendqisi2
2985:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 5119              		.loc 1 2985 0
 5120 2c2c C9C0D4E5 		ldrb	ip, [r4, #201]	@ zero_extendqisi2
2988:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5121              		.loc 1 2988 0
 5122 2c30 C430D4E5 		ldrb	r3, [r4, #196]	@ zero_extendqisi2
2984:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 5123              		.loc 1 2984 0
 5124 2c34 14E6CAE5 		strb	lr, [r10, #1556]
2988:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5125              		.loc 1 2988 0
 5126 2c38 0C008DE5 		str	r0, [sp, #12]
 5127 2c3c 10108DE5 		str	r1, [sp, #16]
 5128 2c40 40408DE8 		stmia	sp, {r6, lr}
 5129 2c44 B824DDE1 		ldrh	r2, [sp, #72]
 5130 2c48 08C08DE5 		str	ip, [sp, #8]
2982:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 5131              		.loc 1 2982 0
 5132 2c4c C6E0D4E5 		ldrb	lr, [r4, #198]	@ zero_extendqisi2
2986:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 5133              		.loc 1 2986 0
 5134 2c50 1606CAE5 		strb	r0, [r10, #1558]
2987:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
 5135              		.loc 1 2987 0
 5136 2c54 1716CAE5 		strb	r1, [r10, #1559]
2988:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5137              		.loc 1 2988 0
 5138 2c58 0400A0E3 		mov	r0, #4
 5139 2c5c A0189FE5 		ldr	r1, .L720+56
2983:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 5140              		.loc 1 2983 0
 5141 2c60 1366CAE5 		strb	r6, [r10, #1555]
2985:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 5142              		.loc 1 2985 0
 5143 2c64 15C6CAE5 		strb	ip, [r10, #1557]
2982:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 5144              		.loc 1 2982 0
 5145 2c68 12E6CAE5 		strb	lr, [r10, #1554]
2988:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 5146              		.loc 1 2988 0
 5147 2c6c FEFFFFEB 		bl	CyU3PDebugPrint
 5148              	.LVL556:
 5149 2c70 62FEFFEA 		b	.L515
 5150              	.L267:
 5151              	.LVL557:
 5152              	.LBE137:
 5153              	.LBE424:
 5154              	.LBB425:
 5155              	.LBB355:
2574:../uvc.c      ****      		break;
 5156              		.loc 1 2574 0
 5157 2c74 0500A0E3 		mov	r0, #5
 5158 2c78 FEFFFFEB 		bl	ControlHandle
 5159              	.LVL558:
 5160 2c7c 50309DE5 		ldr	r3, [sp, #80]
 5161 2c80 55FEFFEA 		b	.L259
 5162              	.L271:
 5163              	.LVL559:
2555:../uvc.c      ****     		break;
 5164              		.loc 1 2555 0
 5165 2c84 0000A0E3 		mov	r0, #0
 5166 2c88 FEFFFFEB 		bl	ControlHandle
 5167              	.LVL560:
 5168 2c8c 50309DE5 		ldr	r3, [sp, #80]
 5169 2c90 51FEFFEA 		b	.L259
 5170              	.L269:
 5171              	.LVL561:
2563:../uvc.c      **** 			break;
 5172              		.loc 1 2563 0
 5173 2c94 0200A0E3 		mov	r0, #2
 5174 2c98 FEFFFFEB 		bl	ControlHandle
 5175              	.LVL562:
 5176 2c9c 50309DE5 		ldr	r3, [sp, #80]
 5177 2ca0 4DFEFFEA 		b	.L259
 5178              	.L274:
 5179              	.LVL563:
2588:../uvc.c      ****     		break;
 5180              		.loc 1 2588 0
 5181 2ca4 0900A0E3 		mov	r0, #9
 5182 2ca8 FEFFFFEB 		bl	ControlHandle
 5183              	.LVL564:
 5184 2cac 50309DE5 		ldr	r3, [sp, #80]
 5185 2cb0 49FEFFEA 		b	.L259
 5186              	.L278:
 5187              	.LVL565:
2596:../uvc.c      ****     		break;
 5188              		.loc 1 2596 0
 5189 2cb4 0E00A0E3 		mov	r0, #14
 5190 2cb8 FEFFFFEB 		bl	ControlHandle
 5191              	.LVL566:
 5192 2cbc 50309DE5 		ldr	r3, [sp, #80]
 5193 2cc0 45FEFFEA 		b	.L259
 5194              	.L276:
 5195              	.LVL567:
2578:../uvc.c      ****           		break;
 5196              		.loc 1 2578 0
 5197 2cc4 0600A0E3 		mov	r0, #6
 5198 2cc8 FEFFFFEB 		bl	ControlHandle
 5199              	.LVL568:
 5200 2ccc 50309DE5 		ldr	r3, [sp, #80]
 5201 2cd0 41FEFFEA 		b	.L259
 5202              	.L689:
 5203              	.LVL569:
 5204              	.LBE355:
 5205              	.LBE425:
 5206              	.LBB426:
 5207              	.LBB342:
 5208              	.LBB185:
 5209              	.LBB186:
 984:../uvc.c      **** 
 5210              		.loc 1 984 0
 5211 2cd4 04C89FE5 		ldr	ip, .L720+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5212              		.loc 1 979 0
 5213 2cd8 5275DAE5 		ldrb	r7, [r10, #1362]	@ zero_extendqisi2
 5214              	.LVL570:
 984:../uvc.c      **** 
 5215              		.loc 1 984 0
 5216 2cdc 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 5217              	.LVL571:
 986:../uvc.c      **** 		 {
 5218              		.loc 1 986 0
 5219 2ce0 830056E3 		cmp	r6, #131
 5220 2ce4 B305000A 		beq	.L395
 5221 2ce8 E301009A 		bls	.L705
 5222 2cec 850056E3 		cmp	r6, #133
 5223 2cf0 6401000A 		beq	.L411
 5224 2cf4 8B04003A 		bcc	.L401
 5225 2cf8 860056E3 		cmp	r6, #134
 5226 2cfc 9C05000A 		beq	.L402
 5227 2d00 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5228              		.loc 1 1048 0
 5229 2d04 5B15DA05 		ldreqb	r1, [r10, #1371]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5230              		.loc 1 1049 0
 5231 2d08 5C25DA05 		ldreqb	r2, [r10, #1372]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5232              		.loc 1 986 0
 5233 2d0c 8AFFFF0A 		beq	.L667
 5234              	.L394:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5235              		.loc 1 1193 0
 5236 2d10 0000A0E3 		mov	r0, #0
 5237 2d14 0020A0E1 		mov	r2, r0
 5238 2d18 0110A0E3 		mov	r1, #1
 5239 2d1c 24C08DE5 		str	ip, [sp, #36]
 5240 2d20 FEFFFFEB 		bl	CyU3PUsbStall
 5241              	.LVL572:
1194:../uvc.c      **** 			  break;
 5242              		.loc 1 1194 0
 5243 2d24 24C09DE5 		ldr	ip, [sp, #36]
 5244 2d28 0820A0E3 		mov	r2, #8
 5245 2d2c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5246 2d30 0400A0E3 		mov	r0, #4
 5247 2d34 F8179FE5 		ldr	r1, .L720+104
 5248 2d38 FEFFFFEB 		bl	CyU3PDebugPrint
 5249              	.LVL573:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5250              		.loc 1 980 0
 5251 2d3c FF20A0E3 		mov	r2, #255
 5252              	.LVL574:
 5253 2d40 570100EA 		b	.L415
 5254              	.LVL575:
 5255              	.L293:
 5256              	.LBE186:
 5257              	.LBE185:
 5258              	.LBB193:
 5259              	.LBB194:
 984:../uvc.c      **** 
 5260              		.loc 1 984 0
 5261 2d44 94C79FE5 		ldr	ip, .L720+20
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5262              		.loc 1 977 0
 5263 2d48 80E5DAE5 		ldrb	lr, [r10, #1408]	@ zero_extendqisi2
 984:../uvc.c      **** 
 5264              		.loc 1 984 0
 5265 2d4c 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5266              		.loc 1 979 0
 5267 2d50 8215DAE5 		ldrb	r1, [r10, #1410]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5268              		.loc 1 986 0
 5269 2d54 830056E3 		cmp	r6, #131
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5270              		.loc 1 976 0
 5271 2d58 8F35DAE5 		ldrb	r3, [r10, #1423]	@ zero_extendqisi2
 5272              	.LVL576:
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5273              		.loc 1 977 0
 5274 2d5c 34E08DE5 		str	lr, [sp, #52]
 5275              	.LVL577:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5276              		.loc 1 979 0
 5277 2d60 30108DE5 		str	r1, [sp, #48]
 5278              	.LVL578:
 986:../uvc.c      **** 		 {
 5279              		.loc 1 986 0
 5280 2d64 C005000A 		beq	.L417
 5281 2d68 4702009A 		bls	.L706
 5282 2d6c 850056E3 		cmp	r6, #133
 5283 2d70 C105000A 		beq	.L422
 5284 2d74 7104003A 		bcc	.L423
 5285 2d78 860056E3 		cmp	r6, #134
 5286 2d7c 2A05000A 		beq	.L424
 5287 2d80 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5288              		.loc 1 1048 0
 5289 2d84 8B05DA05 		ldreqb	r0, [r10, #1419]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5290              		.loc 1 1049 0
 5291 2d88 8C15DA05 		ldreqb	r1, [r10, #1420]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5292              		.loc 1 986 0
 5293 2d8c CE04001A 		bne	.L416
 5294              	.L669:
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5295              		.loc 1 1026 0
 5296 2d90 0120A0E3 		mov	r2, #1
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5297              		.loc 1 1028 0
 5298 2d94 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5299              		.loc 1 1024 0
 5300 2d98 9C00C9E5 		strb	r0, [r9, #156]
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5301              		.loc 1 1025 0
 5302 2d9c 9D10C9E5 		strb	r1, [r9, #157]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5303              		.loc 1 1029 0
 5304 2da0 30009DE5 		ldr	r0, [sp, #48]
 5305 2da4 94179FE5 		ldr	r1, .L720+116
1026:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5306              		.loc 1 1026 0
 5307 2da8 9E20C9E5 		strb	r2, [r9, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5308              		.loc 1 1028 0
 5309 2dac 9F30C9E5 		strb	r3, [r9, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5310              		.loc 1 1029 0
 5311 2db0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5312              	.LVL579:
1030:../uvc.c      **** 			  break;
 5313              		.loc 1 1030 0
 5314 2db4 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 5315              	.LVL580:
 5316 2db8 30209DE5 		ldr	r2, [sp, #48]
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5317              		.loc 1 980 0
 5318 2dbc FF70A0E3 		mov	r7, #255
 5319 2dc0 07C0A0E1 		mov	ip, r7
 5320              	.LVL581:
 5321              	.L426:
1199:../uvc.c      **** }
 5322              		.loc 1 1199 0
 5323 2dc4 9E10D9E5 		ldrb	r1, [r9, #158]	@ zero_extendqisi2
 5324 2dc8 08308DE5 		str	r3, [sp, #8]
 5325 2dcc 14208DE5 		str	r2, [sp, #20]
 5326 2dd0 FF00A0E3 		mov	r0, #255
 5327 2dd4 0620A0E1 		mov	r2, r6
 5328 2dd8 0C30A0E1 		mov	r3, ip
 5329              	.LVL582:
 5330 2ddc 00708DE5 		str	r7, [sp]
 5331              	.LVL583:
 5332              	.L679:
 5333 2de0 04108DE5 		str	r1, [sp, #4]
 5334 2de4 10108DE5 		str	r1, [sp, #16]
 5335 2de8 0C008DE5 		str	r0, [sp, #12]
 5336 2dec F8169FE5 		ldr	r1, .L720+32
 5337 2df0 0400A0E3 		mov	r0, #4
 5338 2df4 FEFFFFEB 		bl	CyU3PDebugPrint
 5339              	.LVL584:
 5340 2df8 50309DE5 		ldr	r3, [sp, #80]
 5341 2dfc F6FDFFEA 		b	.L259
 5342              	.L292:
 5343              	.LVL585:
 5344              	.LBE194:
 5345              	.LBE193:
 5346              	.LBB203:
 5347              	.LBB175:
 984:../uvc.c      **** 
 5348              		.loc 1 984 0
 5349 2e00 D8C69FE5 		ldr	ip, .L720+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5350              		.loc 1 979 0
 5351 2e04 6A75DAE5 		ldrb	r7, [r10, #1386]	@ zero_extendqisi2
 5352              	.LVL586:
 984:../uvc.c      **** 
 5353              		.loc 1 984 0
 5354 2e08 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 5355              	.LVL587:
 986:../uvc.c      **** 		 {
 5356              		.loc 1 986 0
 5357 2e0c 830056E3 		cmp	r6, #131
 5358 2e10 A905000A 		beq	.L406
 5359 2e14 CB01009A 		bls	.L707
 5360 2e18 850056E3 		cmp	r6, #133
 5361 2e1c 1901000A 		beq	.L411
 5362 2e20 3104003A 		bcc	.L412
 5363 2e24 860056E3 		cmp	r6, #134
 5364 2e28 2A05000A 		beq	.L413
 5365 2e2c 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5366              		.loc 1 1048 0
 5367 2e30 7315DA05 		ldreqb	r1, [r10, #1395]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5368              		.loc 1 1049 0
 5369 2e34 7425DA05 		ldreqb	r2, [r10, #1396]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5370              		.loc 1 986 0
 5371 2e38 3FFFFF0A 		beq	.L667
 5372              	.L405:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5373              		.loc 1 1193 0
 5374 2e3c 0000A0E3 		mov	r0, #0
 5375 2e40 0020A0E1 		mov	r2, r0
 5376 2e44 0110A0E3 		mov	r1, #1
 5377 2e48 24C08DE5 		str	ip, [sp, #36]
 5378 2e4c FEFFFFEB 		bl	CyU3PUsbStall
 5379              	.LVL588:
1194:../uvc.c      **** 			  break;
 5380              		.loc 1 1194 0
 5381 2e50 24C09DE5 		ldr	ip, [sp, #36]
 5382 2e54 0920A0E3 		mov	r2, #9
 5383 2e58 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5384 2e5c 0400A0E3 		mov	r0, #4
 5385 2e60 CC169FE5 		ldr	r1, .L720+104
 5386 2e64 FEFFFFEB 		bl	CyU3PDebugPrint
 5387              	.LVL589:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5388              		.loc 1 980 0
 5389 2e68 FF20A0E3 		mov	r2, #255
 5390 2e6c 0C0100EA 		b	.L415
 5391              	.LVL590:
 5392              	.L281:
 5393              	.LBE175:
 5394              	.LBE203:
 5395              	.LBB204:
 5396              	.LBB205:
 984:../uvc.c      **** 
 5397              		.loc 1 984 0
 5398 2e70 68C69FE5 		ldr	ip, .L720+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5399              		.loc 1 979 0
 5400 2e74 0A75DAE5 		ldrb	r7, [r10, #1290]	@ zero_extendqisi2
 5401              	.LVL591:
 984:../uvc.c      **** 
 5402              		.loc 1 984 0
 5403 2e78 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 5404              	.LVL592:
 986:../uvc.c      **** 		 {
 5405              		.loc 1 986 0
 5406 2e7c 830056E3 		cmp	r6, #131
 5407 2e80 7505000A 		beq	.L360
 5408 2e84 EB01009A 		bls	.L708
 5409 2e88 850056E3 		cmp	r6, #133
 5410 2e8c FD00000A 		beq	.L411
 5411 2e90 1904003A 		bcc	.L366
 5412 2e94 860056E3 		cmp	r6, #134
 5413 2e98 0B05000A 		beq	.L367
 5414 2e9c 870056E3 		cmp	r6, #135
 5415 2ea0 B704001A 		bne	.L359
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5416              		.loc 1 1048 0
 5417 2ea4 24E69FE5 		ldr	lr, .L720+4
 5418 2ea8 1315DEE5 		ldrb	r1, [lr, #1299]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5419              		.loc 1 1049 0
 5420 2eac 1425DEE5 		ldrb	r2, [lr, #1300]	@ zero_extendqisi2
 5421 2eb0 21FFFFEA 		b	.L667
 5422              	.LVL593:
 5423              	.L287:
 5424              	.LBE205:
 5425              	.LBE204:
 5426              	.LBB213:
 5427              	.LBB214:
 984:../uvc.c      **** 
 5428              		.loc 1 984 0
 5429 2eb4 24C69FE5 		ldr	ip, .L720+20
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5430              		.loc 1 977 0
 5431 2eb8 D864DAE5 		ldrb	r6, [r10, #1240]	@ zero_extendqisi2
 984:../uvc.c      **** 
 5432              		.loc 1 984 0
 5433 2ebc 0070DCE5 		ldrb	r7, [ip]	@ zero_extendqisi2
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5434              		.loc 1 977 0
 5435 2ec0 30608DE5 		str	r6, [sp, #48]
 986:../uvc.c      **** 		 {
 5436              		.loc 1 986 0
 5437 2ec4 830057E3 		cmp	r7, #131
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5438              		.loc 1 976 0
 5439 2ec8 E734DAE5 		ldrb	r3, [r10, #1255]	@ zero_extendqisi2
 5440              	.LVL594:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5441              		.loc 1 979 0
 5442 2ecc DA64DAE5 		ldrb	r6, [r10, #1242]	@ zero_extendqisi2
 5443              	.LVL595:
 986:../uvc.c      **** 		 {
 5444              		.loc 1 986 0
 5445 2ed0 7D05000A 		beq	.L334
 5446 2ed4 4E02009A 		bls	.L709
 5447 2ed8 850057E3 		cmp	r7, #133
 5448 2edc 7E05000A 		beq	.L339
 5449 2ee0 2804003A 		bcc	.L340
 5450 2ee4 860057E3 		cmp	r7, #134
 5451 2ee8 0905000A 		beq	.L341
 5452 2eec 870057E3 		cmp	r7, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5453              		.loc 1 1048 0
 5454 2ef0 E314DA05 		ldreqb	r1, [r10, #1251]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5455              		.loc 1 1049 0
 5456 2ef4 E424DA05 		ldreqb	r2, [r10, #1252]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5457              		.loc 1 986 0
 5458 2ef8 8304001A 		bne	.L333
 5459              	.L661:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5460              		.loc 1 1027 0
 5461 2efc 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5462              		.loc 1 1024 0
 5463 2f00 9C10C9E5 		strb	r1, [r9, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5464              		.loc 1 1029 0
 5465 2f04 0600A0E1 		mov	r0, r6
 5466 2f08 30169FE5 		ldr	r1, .L720+116
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5467              		.loc 1 1025 0
 5468 2f0c 9D20C9E5 		strb	r2, [r9, #157]
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5469              		.loc 1 1027 0
 5470 2f10 9E30C9E5 		strb	r3, [r9, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5471              		.loc 1 1028 0
 5472 2f14 9F30C9E5 		strb	r3, [r9, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5473              		.loc 1 1029 0
 5474 2f18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5475              	.LVL596:
1030:../uvc.c      **** 			  break;
 5476              		.loc 1 1030 0
 5477 2f1c 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 5478              	.LVL597:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5479              		.loc 1 980 0
 5480 2f20 FF20A0E3 		mov	r2, #255
 5481 2f24 0230A0E1 		mov	r3, r2
 5482              	.LVL598:
 5483              	.L343:
1199:../uvc.c      **** }
 5484              		.loc 1 1199 0
 5485 2f28 00208DE5 		str	r2, [sp]
 5486 2f2c 9E10D9E5 		ldrb	r1, [r9, #158]	@ zero_extendqisi2
 5487 2f30 FF00A0E3 		mov	r0, #255
 5488 2f34 08C08DE5 		str	ip, [sp, #8]
 5489 2f38 14608DE5 		str	r6, [sp, #20]
 5490 2f3c 0720A0E1 		mov	r2, r7
 5491              	.LVL599:
 5492 2f40 A6FFFFEA 		b	.L679
 5493              	.LVL600:
 5494              	.L285:
 5495              	.LBE214:
 5496              	.LBE213:
 5497              	.LBB223:
 5498              	.LBB224:
 984:../uvc.c      **** 
 5499              		.loc 1 984 0
 5500 2f44 94C59FE5 		ldr	ip, .L720+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5501              		.loc 1 979 0
 5502 2f48 9274DAE5 		ldrb	r7, [r10, #1170]	@ zero_extendqisi2
 5503              	.LVL601:
 984:../uvc.c      **** 
 5504              		.loc 1 984 0
 5505 2f4c 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 5506              	.LVL602:
 986:../uvc.c      **** 		 {
 5507              		.loc 1 986 0
 5508 2f50 830056E3 		cmp	r6, #131
 5509 2f54 3805000A 		beq	.L296
 5510 2f58 8E01009A 		bls	.L710
 5511 2f5c 850056E3 		cmp	r6, #133
 5512 2f60 C800000A 		beq	.L411
 5513 2f64 F803003A 		bcc	.L302
 5514 2f68 860056E3 		cmp	r6, #134
 5515 2f6c F204000A 		beq	.L303
 5516 2f70 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5517              		.loc 1 1048 0
 5518 2f74 9B14DA05 		ldreqb	r1, [r10, #1179]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5519              		.loc 1 1049 0
 5520 2f78 9C24DA05 		ldreqb	r2, [r10, #1180]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5521              		.loc 1 986 0
 5522 2f7c EEFEFF0A 		beq	.L667
 5523              	.L295:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5524              		.loc 1 1193 0
 5525 2f80 0000A0E3 		mov	r0, #0
 5526 2f84 0020A0E1 		mov	r2, r0
 5527 2f88 0110A0E3 		mov	r1, #1
 5528 2f8c 24C08DE5 		str	ip, [sp, #36]
 5529 2f90 FEFFFFEB 		bl	CyU3PUsbStall
 5530              	.LVL603:
1194:../uvc.c      **** 			  break;
 5531              		.loc 1 1194 0
 5532 2f94 24C09DE5 		ldr	ip, [sp, #36]
 5533 2f98 0020A0E3 		mov	r2, #0
 5534 2f9c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5535 2fa0 0400A0E3 		mov	r0, #4
 5536 2fa4 88159FE5 		ldr	r1, .L720+104
 5537 2fa8 FEFFFFEB 		bl	CyU3PDebugPrint
 5538              	.LVL604:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5539              		.loc 1 980 0
 5540 2fac FF20A0E3 		mov	r2, #255
 5541              	.LVL605:
 5542 2fb0 BB0000EA 		b	.L415
 5543              	.LVL606:
 5544              	.L289:
 5545              	.LBE224:
 5546              	.LBE223:
 5547              	.LBB231:
 5548              	.LBB232:
 984:../uvc.c      **** 
 5549              		.loc 1 984 0
 5550 2fb4 24C59FE5 		ldr	ip, .L720+20
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5551              		.loc 1 977 0
 5552 2fb8 38E5DAE5 		ldrb	lr, [r10, #1336]	@ zero_extendqisi2
 984:../uvc.c      **** 
 5553              		.loc 1 984 0
 5554 2fbc 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 976:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5555              		.loc 1 976 0
 5556 2fc0 4735DAE5 		ldrb	r3, [r10, #1351]	@ zero_extendqisi2
 5557              	.LVL607:
 986:../uvc.c      **** 		 {
 5558              		.loc 1 986 0
 5559 2fc4 830056E3 		cmp	r6, #131
 977:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5560              		.loc 1 977 0
 5561 2fc8 30E08DE5 		str	lr, [sp, #48]
 5562              	.LVL608:
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5563              		.loc 1 979 0
 5564 2fcc 3A75DAE5 		ldrb	r7, [r10, #1338]	@ zero_extendqisi2
 5565              	.LVL609:
 986:../uvc.c      **** 		 {
 5566              		.loc 1 986 0
 5567 2fd0 F004000A 		beq	.L382
 5568 2fd4 6102009A 		bls	.L711
 5569 2fd8 850056E3 		cmp	r6, #133
 5570 2fdc F904000A 		beq	.L387
 5571 2fe0 E103003A 		bcc	.L388
 5572 2fe4 860056E3 		cmp	r6, #134
 5573 2fe8 BE04000A 		beq	.L389
 5574 2fec 870056E3 		cmp	r6, #135
 5575 2ff0 1504001A 		bne	.L381
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5576              		.loc 1 1048 0
 5577 2ff4 D4249FE5 		ldr	r2, .L720+4
 5578 2ff8 4315D2E5 		ldrb	r1, [r2, #1347]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5579              		.loc 1 1049 0
 5580 2ffc 4425D2E5 		ldrb	r2, [r2, #1348]	@ zero_extendqisi2
 5581              	.L665:
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5582              		.loc 1 1027 0
 5583 3000 0030A0E3 		mov	r3, #0
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5584              		.loc 1 1024 0
 5585 3004 9C10C9E5 		strb	r1, [r9, #156]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5586              		.loc 1 1029 0
 5587 3008 0700A0E1 		mov	r0, r7
 5588 300c 2C159FE5 		ldr	r1, .L720+116
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5589              		.loc 1 1025 0
 5590 3010 9D20C9E5 		strb	r2, [r9, #157]
1027:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 5591              		.loc 1 1027 0
 5592 3014 9E30C9E5 		strb	r3, [r9, #158]
1028:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5593              		.loc 1 1028 0
 5594 3018 9F30C9E5 		strb	r3, [r9, #159]
1029:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5595              		.loc 1 1029 0
 5596 301c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5597              	.LVL610:
1030:../uvc.c      **** 			  break;
 5598              		.loc 1 1030 0
 5599 3020 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 5600              	.LVL611:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5601              		.loc 1 980 0
 5602 3024 FF20A0E3 		mov	r2, #255
 5603 3028 0230A0E1 		mov	r3, r2
 5604              	.LVL612:
 5605              	.L391:
1199:../uvc.c      **** }
 5606              		.loc 1 1199 0
 5607 302c 00208DE5 		str	r2, [sp]
 5608 3030 9E10D9E5 		ldrb	r1, [r9, #158]	@ zero_extendqisi2
 5609 3034 FF00A0E3 		mov	r0, #255
 5610 3038 08C08DE5 		str	ip, [sp, #8]
 5611 303c 14708DE5 		str	r7, [sp, #20]
 5612 3040 0620A0E1 		mov	r2, r6
 5613              	.LVL613:
 5614 3044 65FFFFEA 		b	.L679
 5615              	.LVL614:
 5616              	.L283:
 5617              	.LBE232:
 5618              	.LBE231:
 5619              	.LBB242:
 5620              	.LBB243:
 984:../uvc.c      **** 
 5621              		.loc 1 984 0
 5622 3048 90C49FE5 		ldr	ip, .L720+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5623              		.loc 1 979 0
 5624 304c C274DAE5 		ldrb	r7, [r10, #1218]	@ zero_extendqisi2
 5625              	.LVL615:
 984:../uvc.c      **** 
 5626              		.loc 1 984 0
 5627 3050 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 5628              	.LVL616:
 986:../uvc.c      **** 		 {
 5629              		.loc 1 986 0
 5630 3054 830056E3 		cmp	r6, #131
 5631 3058 1305000A 		beq	.L323
 5632 305c 7002009A 		bls	.L712
 5633 3060 850056E3 		cmp	r6, #133
 5634 3064 8700000A 		beq	.L411
 5635 3068 4203003A 		bcc	.L329
 5636 306c 860056E3 		cmp	r6, #134
 5637 3070 7904000A 		beq	.L330
 5638 3074 870056E3 		cmp	r6, #135
 5639 3078 3404001A 		bne	.L322
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5640              		.loc 1 1048 0
 5641 307c 4CE49FE5 		ldr	lr, .L720+4
 5642 3080 CB14DEE5 		ldrb	r1, [lr, #1227]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5643              		.loc 1 1049 0
 5644 3084 CC24DEE5 		ldrb	r2, [lr, #1228]	@ zero_extendqisi2
 5645 3088 ABFEFFEA 		b	.L667
 5646              	.LVL617:
 5647              	.L291:
 5648              	.LBE243:
 5649              	.LBE242:
 5650              	.LBB251:
 5651              	.LBB252:
 984:../uvc.c      **** 
 5652              		.loc 1 984 0
 5653 308c 4CC49FE5 		ldr	ip, .L720+20
 979:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5654              		.loc 1 979 0
 5655 3090 2275DAE5 		ldrb	r7, [r10, #1314]	@ zero_extendqisi2
 5656              	.LVL618:
 984:../uvc.c      **** 
 5657              		.loc 1 984 0
 5658 3094 0060DCE5 		ldrb	r6, [ip]	@ zero_extendqisi2
 5659              	.LVL619:
 986:../uvc.c      **** 		 {
 5660              		.loc 1 986 0
 5661 3098 830056E3 		cmp	r6, #131
 5662 309c EA04000A 		beq	.L371
 5663 30a0 AD01009A 		bls	.L713
 5664 30a4 850056E3 		cmp	r6, #133
 5665 30a8 7600000A 		beq	.L411
 5666 30ac 2D03003A 		bcc	.L377
 5667 30b0 860056E3 		cmp	r6, #134
 5668 30b4 5004000A 		beq	.L378
 5669 30b8 870056E3 		cmp	r6, #135
1048:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5670              		.loc 1 1048 0
 5671 30bc 2B15DA05 		ldreqb	r1, [r10, #1323]	@ zero_extendqisi2
1049:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5672              		.loc 1 1049 0
 5673 30c0 2C25DA05 		ldreqb	r2, [r10, #1324]	@ zero_extendqisi2
 986:../uvc.c      **** 		 {
 5674              		.loc 1 986 0
 5675 30c4 9CFEFF0A 		beq	.L667
 5676              	.L370:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5677              		.loc 1 1193 0
 5678 30c8 0000A0E3 		mov	r0, #0
 5679 30cc 0020A0E1 		mov	r2, r0
 5680 30d0 0110A0E3 		mov	r1, #1
 5681 30d4 24C08DE5 		str	ip, [sp, #36]
 5682 30d8 FEFFFFEB 		bl	CyU3PUsbStall
 5683              	.LVL620:
1194:../uvc.c      **** 			  break;
 5684              		.loc 1 1194 0
 5685 30dc 24C09DE5 		ldr	ip, [sp, #36]
 5686 30e0 0620A0E3 		mov	r2, #6
 5687 30e4 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 5688 30e8 0400A0E3 		mov	r0, #4
 5689 30ec 40149FE5 		ldr	r1, .L720+104
 5690 30f0 FEFFFFEB 		bl	CyU3PDebugPrint
 5691              	.LVL621:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5692              		.loc 1 980 0
 5693 30f4 FF20A0E3 		mov	r2, #255
 5694              	.LVL622:
 5695 30f8 690000EA 		b	.L415
 5696              	.LVL623:
 5697              	.L696:
 5698              	.LBE252:
 5699              	.LBE251:
 5700              	.LBE342:
 5701              	.LBE426:
 5702              	.LBB427:
 5703              	.LBB138:
3203:../uvc.c      ****                 {
 5704              		.loc 1 3203 0
 5705 30fc 010052E3 		cmp	r2, #1
 5706 3100 3AFDFF1A 		bne	.L502
3228:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5707              		.loc 1 3228 0
 5708 3104 2000A0E3 		mov	r0, #32
 5709 3108 EC139FE5 		ldr	r1, .L720+48
 5710 310c 48208DE2 		add	r2, sp, #72
 5711 3110 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5712              	.LVL624:
3230:../uvc.c      ****                         {
 5713              		.loc 1 3230 0
 5714 3114 000050E3 		cmp	r0, #0
 5715 3118 0103001A 		bne	.L548
3234:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5716              		.loc 1 3234 0
 5717 311c 0020A0E3 		mov	r2, #0
 5718 3120 A4039FE5 		ldr	r0, .L720
 5719              	.LVL625:
 5720 3124 8010A0E3 		mov	r1, #128
 5721 3128 FEFFFFEB 		bl	_txe_event_flags_set
 5722              	.LVL626:
3235:../uvc.c      ****                             {
 5723              		.loc 1 3235 0
 5724 312c 002050E2 		subs	r2, r0, #0
3241:../uvc.c      ****                             //stillcont = 0;
 5725              		.loc 1 3241 0
 5726 3130 F030A003 		moveq	r3, #240
 5727 3134 74308405 		streq	r3, [r4, #116]
3235:../uvc.c      ****                             {
 5728              		.loc 1 3235 0
 5729 3138 9A04001A 		bne	.L714
 5730              	.LVL627:
 5731              	.L550:
3244:../uvc.c      ****                         }else{
 5732              		.loc 1 3244 0
 5733 313c C510D9E5 		ldrb	r1, [r9, #197]	@ zero_extendqisi2
 5734 3140 B824DDE1 		ldrh	r2, [sp, #72]
 5735 3144 00108DE5 		str	r1, [sp]
 5736 3148 C430D9E5 		ldrb	r3, [r9, #196]	@ zero_extendqisi2
 5737 314c B4139FE5 		ldr	r1, .L720+60
 5738 3150 0400A0E3 		mov	r0, #4
 5739 3154 FEFFFFEB 		bl	CyU3PDebugPrint
 5740              	.LVL628:
 5741 3158 28FDFFEA 		b	.L515
 5742              	.LVL629:
 5743              	.L695:
3000:../uvc.c      ****             {
 5744              		.loc 1 3000 0
 5745 315c 010053E3 		cmp	r3, #1
 5746 3160 22FDFF1A 		bne	.L502
3025:../uvc.c      ****                             glCommitCtrl, &readCount);
 5747              		.loc 1 3025 0
 5748 3164 2000A0E3 		mov	r0, #32
 5749 3168 8C139FE5 		ldr	r1, .L720+48
 5750 316c 48208DE2 		add	r2, sp, #72
 5751 3170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5752              	.LVL630:
3027:../uvc.c      ****                     {
 5753              		.loc 1 3027 0
 5754 3174 000050E3 		cmp	r0, #0
 5755 3178 20FDFF1A 		bne	.L515
3029:../uvc.c      ****                         {
 5756              		.loc 1 3029 0
 5757 317c C760D9E5 		ldrb	r6, [r9, #199]	@ zero_extendqisi2
 5758 3180 E430D9E5 		ldrb	r3, [r9, #228]	@ zero_extendqisi2
 5759 3184 060053E1 		cmp	r3, r6
 5760 3188 0500000A 		beq	.L524
3031:../uvc.c      ****                          {
 5761              		.loc 1 3031 0
 5762 318c 010056E3 		cmp	r6, #1
 5763 3190 DB04000A 		beq	.L526
 5764 3194 020056E3 		cmp	r6, #2
 5765 3198 7E03000A 		beq	.L527
 5766              	.LVL631:
 5767              	.L525:
3046:../uvc.c      ****                         }
 5768              		.loc 1 3046 0
 5769 319c C730D9E5 		ldrb	r3, [r9, #199]	@ zero_extendqisi2
 5770 31a0 E430C9E5 		strb	r3, [r9, #228]
 5771              	.L524:
3048:../uvc.c      **** 
 5772              		.loc 1 3048 0
 5773 31a4 60139FE5 		ldr	r1, .L720+64
 5774 31a8 E420D9E5 		ldrb	r2, [r9, #228]	@ zero_extendqisi2
 5775 31ac 0400A0E3 		mov	r0, #4
 5776 31b0 FEFFFFEB 		bl	CyU3PDebugPrint
 5777              	.LVL632:
3061:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5778              		.loc 1 3061 0
 5779 31b4 0020A0E3 		mov	r2, #0
 5780 31b8 0C039FE5 		ldr	r0, .L720
 5781 31bc 0110A0E3 		mov	r1, #1
 5782 31c0 FEFFFFEB 		bl	_txe_event_flags_set
 5783              	.LVL633:
3062:../uvc.c      ****                         {
 5784              		.loc 1 3062 0
 5785 31c4 002050E2 		subs	r2, r0, #0
 5786 31c8 0CFDFF0A 		beq	.L515
3064:../uvc.c      ****                         }
 5787              		.loc 1 3064 0
 5788 31cc 3C139FE5 		ldr	r1, .L720+68
 5789 31d0 0400A0E3 		mov	r0, #4
 5790              	.LVL634:
 5791 31d4 FEFFFFEB 		bl	CyU3PDebugPrint
 5792              	.LVL635:
 5793 31d8 08FDFFEA 		b	.L515
 5794              	.LVL636:
 5795              	.L703:
3127:../uvc.c      ****                 {
 5796              		.loc 1 3127 0
 5797 31dc 010052E3 		cmp	r2, #1
 5798 31e0 02FDFF1A 		bne	.L502
3152:../uvc.c      ****                                 glCommitCtrl, &readCount);
 5799              		.loc 1 3152 0
 5800 31e4 10139FE5 		ldr	r1, .L720+48
 5801 31e8 48208DE2 		add	r2, sp, #72
 5802 31ec 2000A0E3 		mov	r0, #32
 5803 31f0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5804              	.LVL637:
 5805 31f4 01FDFFEA 		b	.L515
 5806              	.L693:
 5807              	.LBE138:
 5808              	.LBE427:
 5809              	.LBB428:
 5810              	.LBB410:
2851:../uvc.c      ****     {
 5811              		.loc 1 2851 0
 5812 31f8 050C53E3 		cmp	r3, #1280
 5813 31fc F1FCFF1A 		bne	.L260
 5814              	.LVL638:
2871:../uvc.c      ****     		break;
 5815              		.loc 1 2871 0
 5816 3200 1400A0E3 		mov	r0, #20
 5817 3204 FEFFFFEB 		bl	ControlHandle
 5818              	.LVL639:
 5819 3208 50309DE5 		ldr	r3, [sp, #80]
 5820 320c F2FCFFEA 		b	.L259
 5821              	.L698:
2851:../uvc.c      ****     {
 5822              		.loc 1 2851 0
 5823 3210 010A53E3 		cmp	r3, #4096
 5824 3214 EBFCFF1A 		bne	.L260
 5825              	.LVL640:
 5826              	.LBB358:
 5827              	.LBB359:
 418:../uvc.c      ****     /*
 5828              		.loc 1 418 0
 5829 3218 C0329FE5 		ldr	r3, .L720+20
 412:../uvc.c      ****     }
 5830              		.loc 1 412 0
 5831 321c 6A64DAE5 		ldrb	r6, [r10, #1130]	@ zero_extendqisi2
 5832              	.LVL641:
 418:../uvc.c      ****     /*
 5833              		.loc 1 418 0
 5834 3220 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 5835              		.loc 1 426 0
 5836 3224 830053E3 		cmp	r3, #131
 418:../uvc.c      ****     /*
 5837              		.loc 1 418 0
 5838 3228 30308DE5 		str	r3, [sp, #48]
 5839              	.LVL642:
 426:../uvc.c      **** 		 {
 5840              		.loc 1 426 0
 5841 322c CF04000A 		beq	.L470
 5842 3230 4102009A 		bls	.L715
 5843 3234 30C09DE5 		ldr	ip, [sp, #48]
 5844 3238 85005CE3 		cmp	ip, #133
 5845 323c DD04000A 		beq	.L475
 5846 3240 F104003A 		bcc	.L476
 5847 3244 86005CE3 		cmp	ip, #134
 5848 3248 5F03000A 		beq	.L477
 5849 324c 87005CE3 		cmp	ip, #135
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 5850              		.loc 1 657 0
 5851 3250 7324DA05 		ldreqb	r2, [r10, #1139]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 5852              		.loc 1 658 0
 5853 3254 7434DA05 		ldreqb	r3, [r10, #1140]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 5854              		.loc 1 426 0
 5855 3258 1F05001A 		bne	.L469
 5856              	.L673:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5857              		.loc 1 597 0
 5858 325c DC129FE5 		ldr	r1, .L720+116
 5859 3260 0600A0E1 		mov	r0, r6
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5860              		.loc 1 414 0
 5861 3264 FF70A0E3 		mov	r7, #255
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 5862              		.loc 1 594 0
 5863 3268 9C20C9E5 		strb	r2, [r9, #156]
 5864              	.L672:
 595:../uvc.c      **** 			 }
 5865              		.loc 1 595 0
 5866 326c 9D30C9E5 		strb	r3, [r9, #157]
 5867              	.L674:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5868              		.loc 1 597 0
 5869 3270 2C708DE5 		str	r7, [sp, #44]
 5870 3274 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5871              	.LVL643:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5872              		.loc 1 414 0
 5873 3278 0730A0E1 		mov	r3, r7
 598:../uvc.c      **** 			  break;
 5874              		.loc 1 598 0
 5875 327c 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 5876              	.LVL644:
 5877 3280 2C209DE5 		ldr	r2, [sp, #44]
 5878 3284 6D0200EA 		b	.L479
 5879              	.LVL645:
 5880              	.L411:
 5881              	.LBE359:
 5882              	.LBE358:
 5883              	.LBE410:
 5884              	.LBE428:
 5885              	.LBB429:
 5886              	.LBB343:
 5887              	.LBB259:
 5888              	.LBB176:
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5889              		.loc 1 991 0
 5890 3288 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5891              		.loc 1 992 0
 5892 328c 0200A0E3 		mov	r0, #2
 5893 3290 A8129FE5 		ldr	r1, .L720+116
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5894              		.loc 1 990 0
 5895 3294 9C70C9E5 		strb	r7, [r9, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5896              		.loc 1 991 0
 5897 3298 9D30C9E5 		strb	r3, [r9, #157]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5898              		.loc 1 992 0
 5899 329c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5900              	.LVL646:
 993:../uvc.c      **** 			  break;
 5901              		.loc 1 993 0
 5902 32a0 9C20D9E5 		ldrb	r2, [r9, #156]	@ zero_extendqisi2
 5903              	.LVL647:
 5904              	.L415:
1199:../uvc.c      **** }
 5905              		.loc 1 1199 0
 5906 32a4 9E10D9E5 		ldrb	r1, [r9, #158]	@ zero_extendqisi2
 5907 32a8 FF30A0E3 		mov	r3, #255
 5908 32ac 08208DE5 		str	r2, [sp, #8]
 5909 32b0 04108DE5 		str	r1, [sp, #4]
 5910 32b4 10108DE5 		str	r1, [sp, #16]
 5911 32b8 00308DE5 		str	r3, [sp]
 5912 32bc 0C308DE5 		str	r3, [sp, #12]
 5913 32c0 14708DE5 		str	r7, [sp, #20]
 5914 32c4 0620A0E1 		mov	r2, r6
 5915              	.LVL648:
 5916 32c8 0400A0E3 		mov	r0, #4
 5917 32cc 18129FE5 		ldr	r1, .L720+32
 5918 32d0 FEFFFFEB 		bl	CyU3PDebugPrint
 5919              	.LVL649:
 5920 32d4 50309DE5 		ldr	r3, [sp, #80]
 5921 32d8 BFFCFFEA 		b	.L259
 5922              	.LVL650:
 5923              	.L454:
 5924              	.LBE176:
 5925              	.LBE259:
 5926              	.LBE343:
 5927              	.LBE429:
 5928              	.LBB430:
 5929              	.LBB411:
 5930              	.LBB368:
 5931              	.LBB369:
 418:../uvc.c      ****     /*
 5932              		.loc 1 418 0
 5933 32dc FC219FE5 		ldr	r2, .L720+20
 404:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 5934              		.loc 1 404 0
 5935 32e0 7830DAE5 		ldrb	r3, [r10, #120]	@ zero_extendqisi2
 5936              	.LVL651:
 418:../uvc.c      ****     /*
 5937              		.loc 1 418 0
 5938 32e4 0060D2E5 		ldrb	r6, [r2]	@ zero_extendqisi2
 406:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 5939              		.loc 1 406 0
 5940 32e8 8770DAE5 		ldrb	r7, [r10, #135]	@ zero_extendqisi2
 5941              	.LVL652:
 426:../uvc.c      **** 		 {
 5942              		.loc 1 426 0
 5943 32ec 830056E3 		cmp	r6, #131
 407:../uvc.c      ****     }else{
 5944              		.loc 1 407 0
 5945 32f0 7AC0DAE5 		ldrb	ip, [r10, #122]	@ zero_extendqisi2
 5946              	.LVL653:
 426:../uvc.c      **** 		 {
 5947              		.loc 1 426 0
 5948 32f4 F404000A 		beq	.L489
 5949 32f8 DE01009A 		bls	.L716
 5950 32fc 850056E3 		cmp	r6, #133
 5951 3300 CC04000A 		beq	.L494
 5952 3304 D104003A 		bcc	.L495
 5953 3308 860056E3 		cmp	r6, #134
 5954 330c 3703000A 		beq	.L496
 5955 3310 870056E3 		cmp	r6, #135
 647:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 5956              		.loc 1 647 0
 5957 3314 83E0DA05 		ldreqb	lr, [r10, #131]	@ zero_extendqisi2
 648:../uvc.c      **** 		 	 }
 5958              		.loc 1 648 0
 5959 3318 8420DA05 		ldreqb	r2, [r10, #132]	@ zero_extendqisi2
 426:../uvc.c      **** 		 {
 5960              		.loc 1 426 0
 5961 331c 8504001A 		bne	.L488
 5962              	.L677:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5963              		.loc 1 597 0
 5964 3320 18129FE5 		ldr	r1, .L720+116
 5965 3324 0C00A0E1 		mov	r0, ip
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5966              		.loc 1 414 0
 5967 3328 FF70A0E3 		mov	r7, #255
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 5968              		.loc 1 583 0
 5969 332c 9CE0C9E5 		strb	lr, [r9, #156]
 5970              	.L675:
 584:../uvc.c      **** 		 	 }
 5971              		.loc 1 584 0
 5972 3330 9D20C9E5 		strb	r2, [r9, #157]
 5973              	.L678:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5974              		.loc 1 414 0
 5975 3334 30708DE5 		str	r7, [sp, #48]
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5976              		.loc 1 597 0
 5977 3338 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5978              	.LVL654:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 5979              		.loc 1 414 0
 5980 333c 07C0A0E1 		mov	ip, r7
 598:../uvc.c      **** 			  break;
 5981              		.loc 1 598 0
 5982 3340 9C20D9E5 		ldrb	r2, [r9, #156]	@ zero_extendqisi2
 5983              	.LVL655:
 5984 3344 30309DE5 		ldr	r3, [sp, #48]
 5985 3348 F20100EA 		b	.L498
 5986              	.LVL656:
 5987              	.L436:
 5988              	.LBE369:
 5989              	.LBE368:
2867:../uvc.c      ****     		break;
 5990              		.loc 1 2867 0
 5991 334c 1300A0E3 		mov	r0, #19
 5992 3350 FEFFFFEB 		bl	ControlHandle
 5993              	.LVL657:
 5994 3354 50309DE5 		ldr	r3, [sp, #80]
 5995 3358 9FFCFFEA 		b	.L259
 5996              	.L449:
 5997              	.LVL658:
2902:../uvc.c      ****     		break;
 5998              		.loc 1 2902 0
 5999 335c 1C00A0E3 		mov	r0, #28
 6000 3360 FEFFFFEB 		bl	ControlHandle
 6001              	.LVL659:
 6002 3364 50309DE5 		ldr	r3, [sp, #80]
 6003 3368 9BFCFFEA 		b	.L259
 6004              	.L439:
 6005              	.LVL660:
2863:../uvc.c      ****      		break;
 6006              		.loc 1 2863 0
 6007 336c 1200A0E3 		mov	r0, #18
 6008 3370 FEFFFFEB 		bl	ControlHandle
 6009              	.LVL661:
 6010 3374 50309DE5 		ldr	r3, [sp, #80]
 6011 3378 97FCFFEA 		b	.L259
 6012              	.L438:
 6013              	.LVL662:
2859:../uvc.c      ****     		break;
 6014              		.loc 1 2859 0
 6015 337c 1100A0E3 		mov	r0, #17
 6016 3380 FEFFFFEB 		bl	ControlHandle
 6017              	.LVL663:
 6018 3384 50309DE5 		ldr	r3, [sp, #80]
 6019 3388 93FCFFEA 		b	.L259
 6020              	.L446:
 6021              	.LVL664:
 6022              	.LBB377:
 6023              	.LBB378:
 418:../uvc.c      ****     /*
 6024              		.loc 1 418 0
 6025 338c 4C219FE5 		ldr	r2, .L720+20
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6026              		.loc 1 409 0
 6027 3390 5034DAE5 		ldrb	r3, [r10, #1104]	@ zero_extendqisi2
 418:../uvc.c      ****     /*
 6028              		.loc 1 418 0
 6029 3394 0070D2E5 		ldrb	r7, [r2]	@ zero_extendqisi2
 409:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 6030              		.loc 1 409 0
 6031 3398 30308DE5 		str	r3, [sp, #48]
 6032              	.LVL665:
 426:../uvc.c      **** 		 {
 6033              		.loc 1 426 0
 6034 339c 830057E3 		cmp	r7, #131
 411:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 6035              		.loc 1 411 0
 6036 33a0 5F34DAE5 		ldrb	r3, [r10, #1119]	@ zero_extendqisi2
 6037              	.LVL666:
 412:../uvc.c      ****     }
 6038              		.loc 1 412 0
 6039 33a4 5264DAE5 		ldrb	r6, [r10, #1106]	@ zero_extendqisi2
 6040              	.LVL667:
 426:../uvc.c      **** 		 {
 6041              		.loc 1 426 0
 6042 33a8 6C04000A 		beq	.L457
 6043 33ac 2B02009A 		bls	.L717
 6044 33b0 850057E3 		cmp	r7, #133
 6045 33b4 BF04000A 		beq	.L462
 6046 33b8 AF04003A 		bcc	.L463
 6047 33bc 860057E3 		cmp	r7, #134
 6048 33c0 1003000A 		beq	.L464
 6049 33c4 870057E3 		cmp	r7, #135
 6050 33c8 0F05001A 		bne	.L456
 657:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 6051              		.loc 1 657 0
 6052 33cc FCC09FE5 		ldr	ip, .L720+4
 6053 33d0 5B24DCE5 		ldrb	r2, [ip, #1115]	@ zero_extendqisi2
 658:../uvc.c      **** 			 }
 6054              		.loc 1 658 0
 6055 33d4 5C34DCE5 		ldrb	r3, [ip, #1116]	@ zero_extendqisi2
 6056              	.L671:
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6057              		.loc 1 597 0
 6058 33d8 60119FE5 		ldr	r1, .L720+116
 6059 33dc 0600A0E1 		mov	r0, r6
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 6060              		.loc 1 594 0
 6061 33e0 9C20C9E5 		strb	r2, [r9, #156]
 6062              	.L670:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6063              		.loc 1 414 0
 6064 33e4 FF60A0E3 		mov	r6, #255
 595:../uvc.c      **** 			 }
 6065              		.loc 1 595 0
 6066 33e8 9D30C9E5 		strb	r3, [r9, #157]
 597:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 6067              		.loc 1 597 0
 6068 33ec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6069              	.LVL668:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6070              		.loc 1 414 0
 6071 33f0 06C0A0E1 		mov	ip, r6
 598:../uvc.c      **** 			  break;
 6072              		.loc 1 598 0
 6073 33f4 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 6074              	.LVL669:
 6075 33f8 3E0200EA 		b	.L466
 6076              	.LVL670:
 6077              	.L434:
 6078              	.LBE378:
 6079              	.LBE377:
2887:../uvc.c      ****      		break;
 6080              		.loc 1 2887 0
 6081 33fc 1800A0E3 		mov	r0, #24
 6082 3400 FEFFFFEB 		bl	ControlHandle
 6083              	.LVL671:
 6084 3404 50309DE5 		ldr	r3, [sp, #80]
 6085 3408 73FCFFEA 		b	.L259
 6086              	.L444:
 6087              	.LVL672:
2879:../uvc.c      ****     		break;
 6088              		.loc 1 2879 0
 6089 340c 1600A0E3 		mov	r0, #22
 6090 3410 FEFFFFEB 		bl	ControlHandle
 6091              	.LVL673:
 6092 3414 50309DE5 		ldr	r3, [sp, #80]
 6093 3418 6FFCFFEA 		b	.L259
 6094              	.L441:
 6095              	.LVL674:
2875:../uvc.c      ****      		break;
 6096              		.loc 1 2875 0
 6097 341c 1500A0E3 		mov	r0, #21
 6098 3420 FEFFFFEB 		bl	ControlHandle
 6099              	.LVL675:
 6100 3424 50309DE5 		ldr	r3, [sp, #80]
 6101 3428 6BFCFFEA 		b	.L259
 6102              	.L451:
 6103              	.LVL676:
2918:../uvc.c      ****     		break;
 6104              		.loc 1 2918 0
 6105 342c 2400A0E3 		mov	r0, #36
 6106 3430 FEFFFFEB 		bl	ControlHandle
 6107              	.LVL677:
 6108 3434 50309DE5 		ldr	r3, [sp, #80]
 6109 3438 67FCFFEA 		b	.L259
 6110              	.LVL678:
 6111              	.L546:
 6112              	.LBE411:
 6113              	.LBE430:
 6114              	.LBB431:
 6115              	.LBB139:
3211:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6116              		.loc 1 3211 0
 6117 343c 0020A0E3 		mov	r2, #0
3212:../uvc.c      ****                         break;
 6118              		.loc 1 3212 0
 6119 3440 F8109FE5 		ldr	r1, .L720+116
 6120 3444 0200A0E3 		mov	r0, #2
3210:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6121              		.loc 1 3210 0
 6122 3448 9C30C9E5 		strb	r3, [r9, #156]
3211:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6123              		.loc 1 3211 0
 6124 344c 9D20C9E5 		strb	r2, [r9, #157]
3212:../uvc.c      ****                         break;
 6125              		.loc 1 3212 0
 6126 3450 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6127              	.LVL679:
 6128 3454 69FCFFEA 		b	.L515
 6129              	.LVL680:
 6130              	.L694:
 6131 3458 0030A0E1 		mov	r3, r0
 6132              	.LBE139:
 6133              	.LBE431:
3386:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 6134              		.loc 1 3386 0
 6135 345c 0320A0E1 		mov	r2, r3
 6136 3460 0700A0E1 		mov	r0, r7
 6137              	.LVL681:
 6138 3464 C4109FE5 		ldr	r1, .L720+100
 6139 3468 28308DE5 		str	r3, [sp, #40]
 6140 346c FEFFFFEB 		bl	CyU3PDebugPrint
 6141              	.LVL682:
3387:../uvc.c      **** 					}
 6142              		.loc 1 3387 0
 6143 3470 28309DE5 		ldr	r3, [sp, #40]
 6144 3474 0300A0E1 		mov	r0, r3
 6145 3478 FEFFFFEB 		bl	CyFxAppErrorHandler
 6146              	.LVL683:
 6147              	.L705:
 6148              	.LBB432:
 6149              	.LBB344:
 6150              	.LBB260:
 6151              	.LBB187:
 986:../uvc.c      **** 		 {
 6152              		.loc 1 986 0
 6153 347c 810056E3 		cmp	r6, #129
 6154 3480 A102000A 		beq	.L397
 6155 3484 8903008A 		bhi	.L398
 6156 3488 010056E3 		cmp	r6, #1
 6157 348c 1FFEFF1A 		bne	.L394
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6158              		.loc 1 1057 0
 6159 3490 A8109FE5 		ldr	r1, .L720+116
 6160 3494 48208DE2 		add	r2, sp, #72
 6161 3498 2000A0E3 		mov	r0, #32
 6162 349c 24C08DE5 		str	ip, [sp, #36]
 6163 34a0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6164              	.LVL684:
1188:../uvc.c      **** 			  		 break;
 6165              		.loc 1 1188 0
 6166 34a4 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6167              		.loc 1 1187 0
 6168 34a8 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6169              		.loc 1 1188 0
 6170 34ac 0820A0E3 		mov	r2, #8
 6171 34b0 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6172 34b4 0400A0E3 		mov	r0, #4
 6173 34b8 60109FE5 		ldr	r1, .L720+84
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6174              		.loc 1 1187 0
 6175 34bc 5DE5CAE5 		strb	lr, [r10, #1373]
1188:../uvc.c      **** 			  		 break;
 6176              		.loc 1 1188 0
 6177 34c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6178              	.LVL685:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6179              		.loc 1 980 0
 6180 34c4 FF20A0E3 		mov	r2, #255
 6181 34c8 75FFFFEA 		b	.L415
 6182              	.L721:
 6183              		.align	2
 6184              	.L720:
 6185 34cc 00000000 		.word	.LANCHOR0
 6186 34d0 00000000 		.word	.LANCHOR1
 6187 34d4 00000000 		.word	glInterStaBuffer
 6188 34d8 00000000 		.word	wIndex
 6189 34dc 00000000 		.word	wValue
 6190 34e0 00000000 		.word	bRequest
 6191 34e4 E4040000 		.word	.LC27
 6192 34e8 00000000 		.word	glChHandleInterStat
 6193 34ec 14040000 		.word	.LC23
 6194 34f0 10060000 		.word	.LANCHOR1+1552
 6195 34f4 2C060000 		.word	.LANCHOR1+1580
 6196 34f8 38060000 		.word	.LANCHOR1+1592
 6197 34fc C4000000 		.word	.LANCHOR0+196
 6198 3500 B8050000 		.word	.LC32
 6199 3504 10050000 		.word	.LC28
 6200 3508 08060000 		.word	.LC34
 6201 350c 68050000 		.word	.LC30
 6202 3510 90050000 		.word	.LC31
 6203 3514 A4030000 		.word	.LC20
 6204 3518 FFFF0000 		.word	65535
 6205 351c 10000000 		.word	.LANCHOR2+16
 6206 3520 CC030000 		.word	.LC21
 6207 3524 00000000 		.word	cmdQu
 6208 3528 54030000 		.word	.LC19
 6209 352c 34060000 		.word	.LC35
 6210 3530 5C060000 		.word	.LC36
 6211 3534 F0030000 		.word	.LC22
 6212 3538 E4050000 		.word	.LC33
 6213 353c 00000000 		.word	.LANCHOR1
 6214 3540 9C000000 		.word	.LANCHOR0+156
 6215 3544 44050000 		.word	.LC29
 6216              	.LVL686:
 6217              	.L707:
 6218              	.LBE187:
 6219              	.LBE260:
 6220              	.LBB261:
 6221              	.LBB177:
 986:../uvc.c      **** 		 {
 6222              		.loc 1 986 0
 6223 3548 810056E3 		cmp	r6, #129
 6224 354c 7102000A 		beq	.L408
 6225 3550 5903008A 		bhi	.L409
 6226 3554 010056E3 		cmp	r6, #1
 6227 3558 37FEFF1A 		bne	.L405
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6228              		.loc 1 1057 0
 6229 355c 24101FE5 		ldr	r1, .L720+116
 6230 3560 48208DE2 		add	r2, sp, #72
 6231 3564 2000A0E3 		mov	r0, #32
 6232 3568 24C08DE5 		str	ip, [sp, #36]
 6233 356c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6234              	.LVL687:
1188:../uvc.c      **** 			  		 break;
 6235              		.loc 1 1188 0
 6236 3570 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6237              		.loc 1 1187 0
 6238 3574 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6239              		.loc 1 1188 0
 6240 3578 0920A0E3 		mov	r2, #9
 6241 357c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6242 3580 0400A0E3 		mov	r0, #4
 6243 3584 6C101FE5 		ldr	r1, .L720+84
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6244              		.loc 1 1187 0
 6245 3588 75E5CAE5 		strb	lr, [r10, #1397]
1188:../uvc.c      **** 			  		 break;
 6246              		.loc 1 1188 0
 6247 358c FEFFFFEB 		bl	CyU3PDebugPrint
 6248              	.LVL688:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6249              		.loc 1 980 0
 6250 3590 FF20A0E3 		mov	r2, #255
 6251 3594 42FFFFEA 		b	.L415
 6252              	.LVL689:
 6253              	.L710:
 6254              	.LBE177:
 6255              	.LBE261:
 6256              	.LBB262:
 6257              	.LBB225:
 986:../uvc.c      **** 		 {
 6258              		.loc 1 986 0
 6259 3598 810056E3 		cmp	r6, #129
 6260 359c 1802000A 		beq	.L298
 6261 35a0 3B03008A 		bhi	.L299
 6262 35a4 010056E3 		cmp	r6, #1
 6263 35a8 74FEFF1A 		bne	.L295
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6264              		.loc 1 1057 0
 6265 35ac 74101FE5 		ldr	r1, .L720+116
 6266 35b0 48208DE2 		add	r2, sp, #72
 6267 35b4 2000A0E3 		mov	r0, #32
 6268 35b8 24C08DE5 		str	ip, [sp, #36]
 6269 35bc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6270              	.LVL690:
1188:../uvc.c      **** 			  		 break;
 6271              		.loc 1 1188 0
 6272 35c0 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6273              		.loc 1 1187 0
 6274 35c4 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6275              		.loc 1 1188 0
 6276 35c8 0020A0E3 		mov	r2, #0
 6277 35cc 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6278 35d0 0400A0E3 		mov	r0, #4
 6279 35d4 BC101FE5 		ldr	r1, .L720+84
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6280              		.loc 1 1187 0
 6281 35d8 9DE4CAE5 		strb	lr, [r10, #1181]
1188:../uvc.c      **** 			  		 break;
 6282              		.loc 1 1188 0
 6283 35dc FEFFFFEB 		bl	CyU3PDebugPrint
 6284              	.LVL691:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6285              		.loc 1 980 0
 6286 35e0 FF20A0E3 		mov	r2, #255
 6287 35e4 2EFFFFEA 		b	.L415
 6288              	.LVL692:
 6289              	.L704:
 6290              	.LBE225:
 6291              	.LBE262:
 6292              	.LBB263:
 6293              	.LBB166:
 986:../uvc.c      **** 		 {
 6294              		.loc 1 986 0
 6295 35e8 810056E3 		cmp	r6, #129
 6296 35ec 0802000A 		beq	.L351
 6297 35f0 2B03008A 		bhi	.L352
 6298 35f4 010056E3 		cmp	r6, #1
 6299 35f8 EE02001A 		bne	.L348
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6300              		.loc 1 1057 0
 6301 35fc C4101FE5 		ldr	r1, .L720+116
 6302 3600 48208DE2 		add	r2, sp, #72
 6303 3604 2000A0E3 		mov	r0, #32
 6304 3608 24C08DE5 		str	ip, [sp, #36]
 6305 360c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6306              	.LVL693:
1188:../uvc.c      **** 			  		 break;
 6307              		.loc 1 1188 0
 6308 3610 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6309              		.loc 1 1187 0
 6310 3614 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6311              		.loc 1 1188 0
 6312 3618 0400A0E3 		mov	r0, #4
 6313 361c 0020A0E1 		mov	r2, r0
 6314 3620 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6315 3624 0C111FE5 		ldr	r1, .L720+84
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6316              		.loc 1 1187 0
 6317 3628 FDE4CAE5 		strb	lr, [r10, #1277]
1188:../uvc.c      **** 			  		 break;
 6318              		.loc 1 1188 0
 6319 362c FEFFFFEB 		bl	CyU3PDebugPrint
 6320              	.LVL694:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6321              		.loc 1 980 0
 6322 3630 FF20A0E3 		mov	r2, #255
 6323 3634 1AFFFFEA 		b	.L415
 6324              	.LVL695:
 6325              	.L708:
 6326              	.LBE166:
 6327              	.LBE263:
 6328              	.LBB264:
 6329              	.LBB206:
 986:../uvc.c      **** 		 {
 6330              		.loc 1 986 0
 6331 3638 810056E3 		cmp	r6, #129
 6332 363c D101000A 		beq	.L362
 6333 3640 4D03008A 		bhi	.L363
 6334 3644 010056E3 		cmp	r6, #1
 6335 3648 CD02001A 		bne	.L359
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6336              		.loc 1 1057 0
 6337 364c 14111FE5 		ldr	r1, .L720+116
 6338 3650 48208DE2 		add	r2, sp, #72
 6339 3654 2000A0E3 		mov	r0, #32
 6340 3658 24C08DE5 		str	ip, [sp, #36]
 6341 365c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6342              	.LVL696:
1188:../uvc.c      **** 			  		 break;
 6343              		.loc 1 1188 0
 6344 3660 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6345              		.loc 1 1187 0
 6346 3664 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6347              		.loc 1 1188 0
 6348 3668 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6349              		.loc 1 1187 0
 6350 366c 38C11FE5 		ldr	ip, .L720+112
1188:../uvc.c      **** 			  		 break;
 6351              		.loc 1 1188 0
 6352 3670 0520A0E3 		mov	r2, #5
 6353 3674 0400A0E3 		mov	r0, #4
 6354 3678 60111FE5 		ldr	r1, .L720+84
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6355              		.loc 1 1187 0
 6356 367c 15E5CCE5 		strb	lr, [ip, #1301]
1188:../uvc.c      **** 			  		 break;
 6357              		.loc 1 1188 0
 6358 3680 FEFFFFEB 		bl	CyU3PDebugPrint
 6359              	.LVL697:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6360              		.loc 1 980 0
 6361 3684 FF20A0E3 		mov	r2, #255
 6362 3688 05FFFFEA 		b	.L415
 6363              	.LVL698:
 6364              	.L706:
 6365              	.LBE206:
 6366              	.LBE264:
 6367              	.LBB265:
 6368              	.LBB195:
 986:../uvc.c      **** 		 {
 6369              		.loc 1 986 0
 6370 368c 810056E3 		cmp	r6, #129
 6371 3690 CA01000A 		beq	.L419
 6372 3694 3C03008A 		bhi	.L420
 6373 3698 010056E3 		cmp	r6, #1
 6374 369c 8A02001A 		bne	.L416
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6375              		.loc 1 1057 0
 6376 36a0 68111FE5 		ldr	r1, .L720+116
 6377 36a4 48208DE2 		add	r2, sp, #72
 6378 36a8 2000A0E3 		mov	r0, #32
 6379 36ac 28308DE5 		str	r3, [sp, #40]
 6380 36b0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6381              	.LVL699:
1172:../uvc.c      **** 					  if(getData == 1)
 6382              		.loc 1 1172 0
 6383 36b4 98E11FE5 		ldr	lr, .L720+88
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6384              		.loc 1 1059 0
 6385 36b8 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 6386              	.LVL700:
1172:../uvc.c      **** 					  if(getData == 1)
 6387              		.loc 1 1172 0
 6388 36bc 1C009EE5 		ldr	r0, [lr, #28]
 6389 36c0 0010E0E3 		mvn	r1, #0
 6390 36c4 24C08DE5 		str	ip, [sp, #36]
1060:../uvc.c      **** 			  value = Data1;
 6391              		.loc 1 1060 0
 6392 36c8 9D70D9E5 		ldrb	r7, [r9, #157]	@ zero_extendqisi2
 6393              	.LVL701:
1172:../uvc.c      **** 					  if(getData == 1)
 6394              		.loc 1 1172 0
 6395 36cc FEFFFFEB 		bl	_txe_mutex_get
 6396              	.LVL702:
1173:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 6397              		.loc 1 1173 0
 6398 36d0 24C09DE5 		ldr	ip, [sp, #36]
 6399 36d4 28309DE5 		ldr	r3, [sp, #40]
 6400 36d8 01005CE3 		cmp	ip, #1
 6401 36dc E804000A 		beq	.L718
1175:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 6402              		.loc 1 1175 0
 6403 36e0 FF005CE3 		cmp	ip, #255
1178:../uvc.c      **** 					  //dataIdx++;
 6404              		.loc 1 1178 0
 6405 36e4 0010A013 		movne	r1, #0
1176:../uvc.c      **** 					  else
 6406              		.loc 1 1176 0
 6407 36e8 0810A003 		moveq	r1, #8
 6408 36ec 0000A003 		moveq	r0, #0
 6409 36f0 00108D05 		streq	r1, [sp]
 6410 36f4 04008D05 		streq	r0, [sp, #4]
1178:../uvc.c      **** 					  //dataIdx++;
 6411              		.loc 1 1178 0
 6412 36f8 00108D15 		strne	r1, [sp]
 6413 36fc 04108D15 		strne	r1, [sp, #4]
1176:../uvc.c      **** 					  else
 6414              		.loc 1 1176 0
 6415 3700 34209D05 		ldreq	r2, [sp, #52]
1178:../uvc.c      **** 					  //dataIdx++;
 6416              		.loc 1 1178 0
 6417 3704 34209D15 		ldrne	r2, [sp, #52]
 6418 3708 EC011FE5 		ldr	r0, .L720+88
 6419 370c 2310A0E3 		mov	r1, #35
 6420 3710 24C08DE5 		str	ip, [sp, #36]
 6421 3714 FEFFFFEB 		bl	cmdSet
 6422              	.LVL703:
 6423 3718 24C09DE5 		ldr	ip, [sp, #36]
 6424              	.L428:
1181:../uvc.c      **** #endif
 6425              		.loc 1 1181 0
 6426 371c 00121FE5 		ldr	r1, .L720+88
 6427 3720 1C0091E5 		ldr	r0, [r1, #28]
 6428 3724 24C08DE5 		str	ip, [sp, #36]
 6429 3728 FEFFFFEB 		bl	_txe_mutex_put
 6430              	.LVL704:
1183:../uvc.c      **** 					  break;
 6431              		.loc 1 1183 0
 6432 372c 9E30D9E5 		ldrb	r3, [r9, #158]	@ zero_extendqisi2
 6433 3730 24C09DE5 		ldr	ip, [sp, #36]
 6434 3734 00308DE5 		str	r3, [sp]
 6435 3738 0C20A0E1 		mov	r2, ip
 6436 373c 0730A0E1 		mov	r3, r7
 6437 3740 0400A0E3 		mov	r0, #4
 6438 3744 38121FE5 		ldr	r1, .L720+72
 6439 3748 FEFFFFEB 		bl	CyU3PDebugPrint
 6440              	.LVL705:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6441              		.loc 1 980 0
 6442 374c FF30A0E3 		mov	r3, #255
 6443 3750 24C09DE5 		ldr	ip, [sp, #36]
 6444 3754 30209DE5 		ldr	r2, [sp, #48]
 6445 3758 99FDFFEA 		b	.L426
 6446              	.LVL706:
 6447              	.L713:
 6448              	.LBE195:
 6449              	.LBE265:
 6450              	.LBB266:
 6451              	.LBB253:
 986:../uvc.c      **** 		 {
 6452              		.loc 1 986 0
 6453 375c 810056E3 		cmp	r6, #129
 6454 3760 CF01000A 		beq	.L373
 6455 3764 BF02008A 		bhi	.L374
 6456 3768 010056E3 		cmp	r6, #1
 6457 376c 55FEFF1A 		bne	.L370
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6458              		.loc 1 1057 0
 6459 3770 38121FE5 		ldr	r1, .L720+116
 6460 3774 48208DE2 		add	r2, sp, #72
 6461 3778 2000A0E3 		mov	r0, #32
 6462 377c 24C08DE5 		str	ip, [sp, #36]
 6463 3780 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6464              	.LVL707:
1188:../uvc.c      **** 			  		 break;
 6465              		.loc 1 1188 0
 6466 3784 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6467              		.loc 1 1187 0
 6468 3788 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6469              		.loc 1 1188 0
 6470 378c 0620A0E3 		mov	r2, #6
 6471 3790 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 6472 3794 0400A0E3 		mov	r0, #4
 6473 3798 80121FE5 		ldr	r1, .L720+84
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6474              		.loc 1 1187 0
 6475 379c 2DE5CAE5 		strb	lr, [r10, #1325]
1188:../uvc.c      **** 			  		 break;
 6476              		.loc 1 1188 0
 6477 37a0 FEFFFFEB 		bl	CyU3PDebugPrint
 6478              	.LVL708:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6479              		.loc 1 980 0
 6480 37a4 FF20A0E3 		mov	r2, #255
 6481 37a8 BDFEFFEA 		b	.L415
 6482              	.LVL709:
 6483              	.L700:
 6484              	.LBE253:
 6485              	.LBE266:
 6486              	.LBB267:
 6487              	.LBB156:
 986:../uvc.c      **** 		 {
 6488              		.loc 1 986 0
 6489 37ac 810056E3 		cmp	r6, #129
 6490 37b0 BF01000A 		beq	.L309
 6491 37b4 AF02008A 		bhi	.L310
 6492 37b8 010056E3 		cmp	r6, #1
 6493 37bc 3302001A 		bne	.L306
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6494              		.loc 1 1057 0
 6495 37c0 48208DE2 		add	r2, sp, #72
 6496 37c4 2000A0E3 		mov	r0, #32
 6497 37c8 90121FE5 		ldr	r1, .L720+116
 6498 37cc 28308DE5 		str	r3, [sp, #40]
 6499 37d0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6500              	.LVL710:
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6501              		.loc 1 1059 0
 6502 37d4 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 6503              	.LVL711:
1069:../uvc.c      **** 				    getData = glEp0Buffer[0];
 6504              		.loc 1 1069 0
 6505 37d8 B864CAE5 		strb	r6, [r10, #1208]
 6506              	.LVL712:
1072:../uvc.c      **** 						case 1:
 6507              		.loc 1 1072 0
 6508 37dc 01204CE2 		sub	r2, ip, #1
1068:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 6509              		.loc 1 1068 0
 6510 37e0 B5C4CAE5 		strb	ip, [r10, #1205]
1072:../uvc.c      **** 						case 1:
 6511              		.loc 1 1072 0
 6512 37e4 28309DE5 		ldr	r3, [sp, #40]
 6513 37e8 070052E3 		cmp	r2, #7
 6514 37ec 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 6515 37f0 850400EA 		b	.L560
 6516              	.L318:
 6517 37f4 C4490000 		.word	.L317
 6518 37f8 48490000 		.word	.L319
 6519 37fc 0C4A0000 		.word	.L560
 6520 3800 04490000 		.word	.L320
 6521 3804 0C4A0000 		.word	.L560
 6522 3808 0C4A0000 		.word	.L560
 6523 380c 0C4A0000 		.word	.L560
 6524 3810 50480000 		.word	.L321
 6525              	.LVL713:
 6526              	.L709:
 6527              	.LBE156:
 6528              	.LBE267:
 6529              	.LBB268:
 6530              	.LBB215:
 986:../uvc.c      **** 		 {
 6531              		.loc 1 986 0
 6532 3814 810057E3 		cmp	r7, #129
 6533 3818 8101000A 		beq	.L336
 6534 381c 9802008A 		bhi	.L337
 6535 3820 010057E3 		cmp	r7, #1
 6536 3824 3802001A 		bne	.L333
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6537              		.loc 1 1057 0
 6538 3828 48208DE2 		add	r2, sp, #72
 6539 382c 2000A0E3 		mov	r0, #32
 6540 3830 F8121FE5 		ldr	r1, .L720+116
 6541 3834 28308DE5 		str	r3, [sp, #40]
 6542 3838 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6543              	.LVL714:
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6544              		.loc 1 1059 0
 6545 383c 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6546              		.loc 1 1115 0
 6547 3840 B524DAE5 		ldrb	r2, [r10, #1205]	@ zero_extendqisi2
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6548              		.loc 1 1059 0
 6549 3844 34C08DE5 		str	ip, [sp, #52]
 6550              	.LVL715:
1060:../uvc.c      **** 			  value = Data1;
 6551              		.loc 1 1060 0
 6552 3848 9DC0D9E5 		ldrb	ip, [r9, #157]	@ zero_extendqisi2
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6553              		.loc 1 1115 0
 6554 384c 010052E3 		cmp	r2, #1
 6555 3850 04005213 		cmpne	r2, #4
1060:../uvc.c      **** 			  value = Data1;
 6556              		.loc 1 1060 0
 6557 3854 38C08DE5 		str	ip, [sp, #56]
 6558              	.LVL716:
1115:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6559              		.loc 1 1115 0
 6560 3858 28309DE5 		ldr	r3, [sp, #40]
 6561 385c F203001A 		bne	.L344
1114:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 6562              		.loc 1 1114 0
 6563 3860 34109DE5 		ldr	r1, [sp, #52]
 6564 3864 0CE481E1 		orr	lr, r1, ip, asl #8
1116:../uvc.c      **** 					  {
 6565              		.loc 1 1116 0
 6566 3868 F9005EE3 		cmp	lr, #249
 6567 386c EE03008A 		bhi	.L344
 6568 3870 60C31FE5 		ldr	ip, .L720+76
 6569 3874 0020A0E3 		mov	r2, #0
 6570 3878 0100A0E3 		mov	r0, #1
 6571 387c 20308DE5 		str	r3, [sp, #32]
 6572 3880 1C608DE5 		str	r6, [sp, #28]
 6573              	.LVL717:
 6574              	.L346:
1120:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 6575              		.loc 1 1120 0
 6576 3884 70631FE5 		ldr	r6, .L720+80
 6577 3888 8230A0E1 		mov	r3, r2, asl #1
 6578 388c B33096E1 		ldrh	r3, [r6, r3]
 6579 3890 FF1002E2 		and	r1, r2, #255
1121:../uvc.c      **** 							}else{
 6580              		.loc 1 1121 0
 6581 3894 0E6063E0 		rsb	r6, r3, lr
 6582 3898 03005EE1 		cmp	lr, r3
 6583 389c 3C108DE5 		str	r1, [sp, #60]
1123:../uvc.c      **** 							}
 6584              		.loc 1 1123 0
 6585 38a0 03106EE0 		rsb	r1, lr, r3
 6586 38a4 0138A091 		movls	r3, r1, asl #16
 6587 38a8 0638A081 		movhi	r3, r6, asl #16
 6588 38ac 3C609DE5 		ldr	r6, [sp, #60]
 6589 38b0 2338A0E1 		mov	r3, r3, lsr #16
 6590 38b4 0C0053E1 		cmp	r3, ip
 6591 38b8 012082E2 		add	r2, r2, #1
 6592 38bc 0600A031 		movcc	r0, r6
 6593              	.LVL718:
 6594 38c0 0C0053E1 		cmp	r3, ip
 6595 38c4 03C0A031 		movcc	ip, r3
 6596              	.LVL719:
1118:../uvc.c      **** 						  {
 6597              		.loc 1 1118 0
 6598 38c8 080052E3 		cmp	r2, #8
 6599 38cc ECFFFF1A 		bne	.L346
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6600              		.loc 1 1133 0
 6601 38d0 B4C31FE5 		ldr	ip, .L720+88
 6602              	.LVL720:
 6603 38d4 20309DE5 		ldr	r3, [sp, #32]
1130:../uvc.c      **** 
 6604              		.loc 1 1130 0
 6605 38d8 012080E2 		add	r2, r0, #1
 6606 38dc FF2002E2 		and	r2, r2, #255
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6607              		.loc 1 1133 0
 6608 38e0 1C009CE5 		ldr	r0, [ip, #28]
 6609              	.LVL721:
 6610 38e4 0010E0E3 		mvn	r1, #0
1130:../uvc.c      **** 
 6611              		.loc 1 1130 0
 6612 38e8 3C208DE5 		str	r2, [sp, #60]
 6613              	.LVL722:
1133:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6614              		.loc 1 1133 0
 6615 38ec 28308DE5 		str	r3, [sp, #40]
 6616 38f0 24C08DE5 		str	ip, [sp, #36]
 6617 38f4 1C609DE5 		ldr	r6, [sp, #28]
 6618 38f8 FEFFFFEB 		bl	_txe_mutex_get
 6619              	.LVL723:
1134:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6620              		.loc 1 1134 0
 6621 38fc 3CE09DE5 		ldr	lr, [sp, #60]
 6622 3900 24C09DE5 		ldr	ip, [sp, #36]
 6623 3904 0010A0E3 		mov	r1, #0
 6624 3908 28309DE5 		ldr	r3, [sp, #40]
 6625 390c 00E08DE5 		str	lr, [sp]
 6626 3910 30209DE5 		ldr	r2, [sp, #48]
 6627 3914 0C00A0E1 		mov	r0, ip
 6628 3918 04108DE5 		str	r1, [sp, #4]
 6629 391c 0310A0E3 		mov	r1, #3
 6630 3920 FEFFFFEB 		bl	cmdSet
 6631              	.LVL724:
1135:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 6632              		.loc 1 1135 0
 6633 3924 24C09DE5 		ldr	ip, [sp, #36]
 6634 3928 1C009CE5 		ldr	r0, [ip, #28]
 6635 392c FEFFFFEB 		bl	_txe_mutex_put
 6636              	.LVL725:
1141:../uvc.c      **** 					  }else{
 6637              		.loc 1 1141 0
 6638 3930 3CC09DE5 		ldr	ip, [sp, #60]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6639              		.loc 1 1140 0
 6640 3934 0130A0E3 		mov	r3, #1
1141:../uvc.c      **** 					  }else{
 6641              		.loc 1 1141 0
 6642 3938 0DC3CAE5 		strb	ip, [r10, #781]
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6643              		.loc 1 1138 0
 6644 393c 34C09DE5 		ldr	ip, [sp, #52]
1140:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6645              		.loc 1 1140 0
 6646 3940 E834CAE5 		strb	r3, [r10, #1256]
1138:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6647              		.loc 1 1138 0
 6648 3944 E5C4CAE5 		strb	ip, [r10, #1253]
1139:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 6649              		.loc 1 1139 0
 6650 3948 38C09DE5 		ldr	ip, [sp, #56]
 6651 394c E6C4CAE5 		strb	ip, [r10, #1254]
 6652              	.LVL726:
 6653              	.L347:
1145:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 6654              		.loc 1 1145 0
 6655 3950 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 6656              	.LVL727:
1146:../uvc.c      **** 					  break;
 6657              		.loc 1 1146 0
 6658 3954 9D20D9E5 		ldrb	r2, [r9, #157]	@ zero_extendqisi2
 6659              	.LVL728:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6660              		.loc 1 980 0
 6661 3958 FFC0A0E3 		mov	ip, #255
 6662 395c 71FDFFEA 		b	.L343
 6663              	.LVL729:
 6664              	.L711:
 6665              	.LBE215:
 6666              	.LBE268:
 6667              	.LBB269:
 6668              	.LBB233:
 986:../uvc.c      **** 		 {
 6669              		.loc 1 986 0
 6670 3960 810056E3 		cmp	r6, #129
 6671 3964 3E01000A 		beq	.L384
 6672 3968 2B02008A 		bhi	.L385
 6673 396c 010056E3 		cmp	r6, #1
 6674 3970 B501001A 		bne	.L381
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6675              		.loc 1 1057 0
 6676 3974 2000A0E3 		mov	r0, #32
 6677 3978 40141FE5 		ldr	r1, .L720+116
 6678 397c 48208DE2 		add	r2, sp, #72
 6679 3980 28308DE5 		str	r3, [sp, #40]
 6680 3984 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6681              	.LVL730:
1149:../uvc.c      **** 					  {
 6682              		.loc 1 1149 0
 6683 3988 54C41FE5 		ldr	ip, .L720+112
 6684 398c B504DCE5 		ldrb	r0, [ip, #1205]	@ zero_extendqisi2
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6685              		.loc 1 1059 0
 6686 3990 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
1149:../uvc.c      **** 					  {
 6687              		.loc 1 1149 0
 6688 3994 010050E3 		cmp	r0, #1
 6689 3998 08005013 		cmpne	r0, #8
1059:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 6690              		.loc 1 1059 0
 6691 399c 34C08DE5 		str	ip, [sp, #52]
 6692              	.LVL731:
1060:../uvc.c      **** 			  value = Data1;
 6693              		.loc 1 1060 0
 6694 39a0 9DC0D9E5 		ldrb	ip, [r9, #157]	@ zero_extendqisi2
1149:../uvc.c      **** 					  {
 6695              		.loc 1 1149 0
 6696 39a4 0000A013 		movne	r0, #0
 6697 39a8 0100A003 		moveq	r0, #1
1060:../uvc.c      **** 			  value = Data1;
 6698              		.loc 1 1060 0
 6699 39ac 38C08DE5 		str	ip, [sp, #56]
 6700              	.LVL732:
1149:../uvc.c      **** 					  {
 6701              		.loc 1 1149 0
 6702 39b0 A203001A 		bne	.L392
 6703              	.LVL733:
1152:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 6704              		.loc 1 1152 0
 6705 39b4 98C41FE5 		ldr	ip, .L720+88
 6706 39b8 0010E0E3 		mvn	r1, #0
 6707 39bc 1C009CE5 		ldr	r0, [ip, #28]
 6708 39c0 24C08DE5 		str	ip, [sp, #36]
 6709 39c4 FEFFFFEB 		bl	_txe_mutex_get
 6710              	.LVL734:
1153:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6711              		.loc 1 1153 0
 6712 39c8 34E09DE5 		ldr	lr, [sp, #52]
 6713 39cc 24C09DE5 		ldr	ip, [sp, #36]
 6714 39d0 0010A0E3 		mov	r1, #0
 6715 39d4 00E08DE5 		str	lr, [sp]
 6716 39d8 30209DE5 		ldr	r2, [sp, #48]
 6717 39dc 28309DE5 		ldr	r3, [sp, #40]
 6718 39e0 0C00A0E1 		mov	r0, ip
 6719 39e4 04108DE5 		str	r1, [sp, #4]
 6720 39e8 2210A0E3 		mov	r1, #34
 6721 39ec FEFFFFEB 		bl	cmdSet
 6722              	.LVL735:
1154:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 6723              		.loc 1 1154 0
 6724 39f0 24C09DE5 		ldr	ip, [sp, #36]
 6725 39f4 1C009CE5 		ldr	r0, [ip, #28]
 6726 39f8 FEFFFFEB 		bl	_txe_mutex_put
 6727              	.LVL736:
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6728              		.loc 1 1157 0
 6729 39fc C8E41FE5 		ldr	lr, .L720+112
 6730 3a00 34C09DE5 		ldr	ip, [sp, #52]
1159:../uvc.c      **** 					  }else{
 6731              		.loc 1 1159 0
 6732 3a04 4865CEE5 		strb	r6, [lr, #1352]
1157:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6733              		.loc 1 1157 0
 6734 3a08 45C5CEE5 		strb	ip, [lr, #1349]
1158:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 6735              		.loc 1 1158 0
 6736 3a0c 38C09DE5 		ldr	ip, [sp, #56]
 6737 3a10 46C5CEE5 		strb	ip, [lr, #1350]
 6738              	.LVL737:
 6739              	.L393:
1163:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 6740              		.loc 1 1163 0
 6741 3a14 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 6742              	.LVL738:
1164:../uvc.c      **** 
 6743              		.loc 1 1164 0
 6744 3a18 9D20D9E5 		ldrb	r2, [r9, #157]	@ zero_extendqisi2
 6745              	.LVL739:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6746              		.loc 1 980 0
 6747 3a1c FFC0A0E3 		mov	ip, #255
 6748 3a20 81FDFFEA 		b	.L391
 6749              	.LVL740:
 6750              	.L712:
 6751              	.LBE233:
 6752              	.LBE269:
 6753              	.LBB270:
 6754              	.LBB244:
 986:../uvc.c      **** 		 {
 6755              		.loc 1 986 0
 6756 3a24 810056E3 		cmp	r6, #129
 6757 3a28 4B01000A 		beq	.L325
 6758 3a2c EE01008A 		bhi	.L326
 6759 3a30 010056E3 		cmp	r6, #1
 6760 3a34 C501001A 		bne	.L322
1057:../uvc.c      **** 			  glEp0Buffer, &readCount);
 6761              		.loc 1 1057 0
 6762 3a38 00151FE5 		ldr	r1, .L720+116
 6763 3a3c 48208DE2 		add	r2, sp, #72
 6764 3a40 2000A0E3 		mov	r0, #32
 6765 3a44 24C08DE5 		str	ip, [sp, #36]
 6766 3a48 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6767              	.LVL741:
1188:../uvc.c      **** 			  		 break;
 6768              		.loc 1 1188 0
 6769 3a4c 24C09DE5 		ldr	ip, [sp, #36]
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6770              		.loc 1 1187 0
 6771 3a50 9CE0D9E5 		ldrb	lr, [r9, #156]	@ zero_extendqisi2
1188:../uvc.c      **** 			  		 break;
 6772              		.loc 1 1188 0
 6773 3a54 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6774              		.loc 1 1187 0
 6775 3a58 24C51FE5 		ldr	ip, .L720+112
1188:../uvc.c      **** 			  		 break;
 6776              		.loc 1 1188 0
 6777 3a5c 0220A0E3 		mov	r2, #2
 6778 3a60 0400A0E3 		mov	r0, #4
 6779 3a64 4C151FE5 		ldr	r1, .L720+84
1187:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6780              		.loc 1 1187 0
 6781 3a68 CDE4CCE5 		strb	lr, [ip, #1229]
1188:../uvc.c      **** 			  		 break;
 6782              		.loc 1 1188 0
 6783 3a6c FEFFFFEB 		bl	CyU3PDebugPrint
 6784              	.LVL742:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6785              		.loc 1 980 0
 6786 3a70 FF20A0E3 		mov	r2, #255
 6787 3a74 0AFEFFEA 		b	.L415
 6788              	.LVL743:
 6789              	.L716:
 6790              	.LBE244:
 6791              	.LBE270:
 6792              	.LBE344:
 6793              	.LBE432:
 6794              	.LBB433:
 6795              	.LBB412:
 6796              	.LBB386:
 6797              	.LBB370:
 426:../uvc.c      **** 		 {
 6798              		.loc 1 426 0
 6799 3a78 810056E3 		cmp	r6, #129
 6800 3a7c BF02000A 		beq	.L491
 6801 3a80 5701008A 		bhi	.L492
 6802 3a84 010056E3 		cmp	r6, #1
 6803 3a88 AA02001A 		bne	.L488
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6804              		.loc 1 664 0
 6805 3a8c 48208DE2 		add	r2, sp, #72
 6806 3a90 2000A0E3 		mov	r0, #32
 6807 3a94 5C151FE5 		ldr	r1, .L720+116
 6808 3a98 28308DE5 		str	r3, [sp, #40]
 6809 3a9c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6810              	.LVL744:
 666:../uvc.c      **** 			   {
 6811              		.loc 1 666 0
 6812 3aa0 002050E2 		subs	r2, r0, #0
 6813 3aa4 DB03001A 		bne	.L499
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6814              		.loc 1 811 0
 6815 3aa8 8CE51FE5 		ldr	lr, .L720+88
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6816              		.loc 1 668 0
 6817 3aac 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
 6818              	.LVL745:
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6819              		.loc 1 811 0
 6820 3ab0 1C009EE5 		ldr	r0, [lr, #28]
 6821              	.LVL746:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6822              		.loc 1 671 0
 6823 3ab4 9EE0D4E5 		ldrb	lr, [r4, #158]	@ zero_extendqisi2
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6824              		.loc 1 811 0
 6825 3ab8 0010E0E3 		mvn	r1, #0
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6826              		.loc 1 671 0
 6827 3abc 30E08DE5 		str	lr, [sp, #48]
 6828              	.LVL747:
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 6829              		.loc 1 811 0
 6830 3ac0 2C208DE5 		str	r2, [sp, #44]
 6831 3ac4 24C08DE5 		str	ip, [sp, #36]
 6832 3ac8 FEFFFFEB 		bl	_txe_mutex_get
 6833              	.LVL748:
 812:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6834              		.loc 1 812 0
 6835 3acc 24C09DE5 		ldr	ip, [sp, #36]
 6836 3ad0 2C209DE5 		ldr	r2, [sp, #44]
 6837 3ad4 28309DE5 		ldr	r3, [sp, #40]
 6838 3ad8 00C08DE5 		str	ip, [sp]
 6839 3adc 04208DE5 		str	r2, [sp, #4]
 6840 3ae0 2510A0E3 		mov	r1, #37
 6841 3ae4 0320A0E1 		mov	r2, r3
 6842 3ae8 CC051FE5 		ldr	r0, .L720+88
 6843 3aec 0730A0E1 		mov	r3, r7
 6844 3af0 FEFFFFEB 		bl	cmdSet
 6845              	.LVL749:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 6846              		.loc 1 813 0
 6847 3af4 D8151FE5 		ldr	r1, .L720+88
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6848              		.loc 1 414 0
 6849 3af8 FF70A0E3 		mov	r7, #255
 6850              	.LVL750:
 813:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 6851              		.loc 1 813 0
 6852 3afc 1C0091E5 		ldr	r0, [r1, #28]
 6853 3b00 FEFFFFEB 		bl	_txe_mutex_put
 6854              	.LVL751:
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 6855              		.loc 1 814 0
 6856 3b04 24C09DE5 		ldr	ip, [sp, #36]
 6857 3b08 30309DE5 		ldr	r3, [sp, #48]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6858              		.loc 1 414 0
 6859 3b0c 0720A0E1 		mov	r2, r7
 814:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 6860              		.loc 1 814 0
 6861 3b10 85C0CAE5 		strb	ip, [r10, #133]
 815:../uvc.c      **** 							 break;
 6862              		.loc 1 815 0
 6863 3b14 8860CAE5 		strb	r6, [r10, #136]
 6864              	.LVL752:
 6865              	.L498:
 960:../uvc.c      **** }
 6866              		.loc 1 960 0
 6867 3b18 00308DE5 		str	r3, [sp]
 6868 3b1c 84008DE9 		stmib	sp, {r2, r7}
 6869 3b20 00161FE5 		ldr	r1, .L720+92
 6870 3b24 0C30A0E1 		mov	r3, ip
 6871 3b28 0620A0E1 		mov	r2, r6
 6872              	.LVL753:
 6873 3b2c 0400A0E3 		mov	r0, #4
 6874 3b30 FEFFFFEB 		bl	CyU3PDebugPrint
 6875              	.LVL754:
 6876 3b34 50309DE5 		ldr	r3, [sp, #80]
 6877 3b38 A7FAFFEA 		b	.L259
 6878              	.LVL755:
 6879              	.L715:
 6880              	.LBE370:
 6881              	.LBE386:
 6882              	.LBB387:
 6883              	.LBB360:
 426:../uvc.c      **** 		 {
 6884              		.loc 1 426 0
 6885 3b3c 810053E3 		cmp	r3, #129
 6886 3b40 EE02000A 		beq	.L472
 6887 3b44 3D01008A 		bhi	.L473
 6888 3b48 010053E3 		cmp	r3, #1
 6889 3b4c E202001A 		bne	.L469
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 6890              		.loc 1 664 0
 6891 3b50 48208DE2 		add	r2, sp, #72
 6892 3b54 2000A0E3 		mov	r0, #32
 6893 3b58 20161FE5 		ldr	r1, .L720+116
 6894 3b5c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6895              	.LVL756:
 666:../uvc.c      **** 			   {
 6896              		.loc 1 666 0
 6897 3b60 002050E2 		subs	r2, r0, #0
 6898 3b64 AF03001A 		bne	.L484
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6899              		.loc 1 768 0
 6900 3b68 000056E3 		cmp	r6, #0
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 6901              		.loc 1 668 0
 6902 3b6c 9C30D4E5 		ldrb	r3, [r4, #156]	@ zero_extendqisi2
 6903              	.LVL757:
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 6904              		.loc 1 671 0
 6905 3b70 9E20D4E5 		ldrb	r2, [r4, #158]	@ zero_extendqisi2
 6906              	.LVL758:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6907              		.loc 1 768 0
 6908 3b74 2A00000A 		beq	.L486
 6909 3b78 010056E3 		cmp	r6, #1
 769:../uvc.c      **** 					 		 }
 6910              		.loc 1 769 0
 6911 3b7c 9030C4E5 		strb	r3, [r4, #144]
 6912              	.LVL759:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6913              		.loc 1 768 0
 6914 3b80 2700009A 		bls	.L486
 769:../uvc.c      **** 					 		 }
 6915              		.loc 1 769 0
 6916 3b84 9D10D4E5 		ldrb	r1, [r4, #157]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6917              		.loc 1 768 0
 6918 3b88 020056E3 		cmp	r6, #2
 769:../uvc.c      **** 					 		 }
 6919              		.loc 1 769 0
 6920 3b8c 9110C4E5 		strb	r1, [r4, #145]
 6921              	.LVL760:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6922              		.loc 1 768 0
 6923 3b90 2300000A 		beq	.L486
 6924 3b94 030056E3 		cmp	r6, #3
 769:../uvc.c      **** 					 		 }
 6925              		.loc 1 769 0
 6926 3b98 9220C4E5 		strb	r2, [r4, #146]
 6927              	.LVL761:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6928              		.loc 1 768 0
 6929 3b9c 2000000A 		beq	.L486
 769:../uvc.c      **** 					 		 }
 6930              		.loc 1 769 0
 6931 3ba0 9F10D4E5 		ldrb	r1, [r4, #159]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6932              		.loc 1 768 0
 6933 3ba4 040056E3 		cmp	r6, #4
 769:../uvc.c      **** 					 		 }
 6934              		.loc 1 769 0
 6935 3ba8 9310C4E5 		strb	r1, [r4, #147]
 6936              	.LVL762:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6937              		.loc 1 768 0
 6938 3bac 1C00000A 		beq	.L486
 769:../uvc.c      **** 					 		 }
 6939              		.loc 1 769 0
 6940 3bb0 A010D4E5 		ldrb	r1, [r4, #160]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6941              		.loc 1 768 0
 6942 3bb4 050056E3 		cmp	r6, #5
 769:../uvc.c      **** 					 		 }
 6943              		.loc 1 769 0
 6944 3bb8 9410C4E5 		strb	r1, [r4, #148]
 6945              	.LVL763:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6946              		.loc 1 768 0
 6947 3bbc 1800000A 		beq	.L486
 769:../uvc.c      **** 					 		 }
 6948              		.loc 1 769 0
 6949 3bc0 A110D4E5 		ldrb	r1, [r4, #161]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6950              		.loc 1 768 0
 6951 3bc4 060056E3 		cmp	r6, #6
 769:../uvc.c      **** 					 		 }
 6952              		.loc 1 769 0
 6953 3bc8 9510C4E5 		strb	r1, [r4, #149]
 6954              	.LVL764:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6955              		.loc 1 768 0
 6956 3bcc 1400000A 		beq	.L486
 769:../uvc.c      **** 					 		 }
 6957              		.loc 1 769 0
 6958 3bd0 A210D9E5 		ldrb	r1, [r9, #162]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6959              		.loc 1 768 0
 6960 3bd4 070056E3 		cmp	r6, #7
 769:../uvc.c      **** 					 		 }
 6961              		.loc 1 769 0
 6962 3bd8 9610C9E5 		strb	r1, [r9, #150]
 6963              	.LVL765:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6964              		.loc 1 768 0
 6965 3bdc 1000000A 		beq	.L486
 769:../uvc.c      **** 					 		 }
 6966              		.loc 1 769 0
 6967 3be0 A310D4E5 		ldrb	r1, [r4, #163]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6968              		.loc 1 768 0
 6969 3be4 080056E3 		cmp	r6, #8
 769:../uvc.c      **** 					 		 }
 6970              		.loc 1 769 0
 6971 3be8 9710C4E5 		strb	r1, [r4, #151]
 6972              	.LVL766:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6973              		.loc 1 768 0
 6974 3bec 0C00000A 		beq	.L486
 769:../uvc.c      **** 					 		 }
 6975              		.loc 1 769 0
 6976 3bf0 A410D4E5 		ldrb	r1, [r4, #164]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6977              		.loc 1 768 0
 6978 3bf4 090056E3 		cmp	r6, #9
 769:../uvc.c      **** 					 		 }
 6979              		.loc 1 769 0
 6980 3bf8 9810C4E5 		strb	r1, [r4, #152]
 6981              	.LVL767:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6982              		.loc 1 768 0
 6983 3bfc 0800000A 		beq	.L486
 769:../uvc.c      **** 					 		 }
 6984              		.loc 1 769 0
 6985 3c00 A510D4E5 		ldrb	r1, [r4, #165]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6986              		.loc 1 768 0
 6987 3c04 0A0056E3 		cmp	r6, #10
 769:../uvc.c      **** 					 		 }
 6988              		.loc 1 769 0
 6989 3c08 9910C4E5 		strb	r1, [r4, #153]
 6990              	.LVL768:
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6991              		.loc 1 768 0
 6992 3c0c 0400000A 		beq	.L486
 769:../uvc.c      **** 					 		 }
 6993              		.loc 1 769 0
 6994 3c10 A610D4E5 		ldrb	r1, [r4, #166]	@ zero_extendqisi2
 768:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 6995              		.loc 1 768 0
 6996 3c14 0B0056E3 		cmp	r6, #11
 769:../uvc.c      **** 					 		 }
 6997              		.loc 1 769 0
 6998 3c18 9A10C4E5 		strb	r1, [r4, #154]
 6999              	.LVL769:
 7000 3c1c A710D415 		ldrneb	r1, [r4, #167]	@ zero_extendqisi2
 7001 3c20 9B10C415 		strneb	r1, [r4, #155]
 7002              	.LVL770:
 7003              	.L486:
 771:../uvc.c      **** 							 break;
 7004              		.loc 1 771 0
 7005 3c24 2C208DE5 		str	r2, [sp, #44]
 7006 3c28 28308DE5 		str	r3, [sp, #40]
 7007 3c2c FEFFFFEB 		bl	I2CCmdHandler
 7008              	.LVL771:
 7009 3c30 2C209DE5 		ldr	r2, [sp, #44]
 7010 3c34 28309DE5 		ldr	r3, [sp, #40]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7011              		.loc 1 414 0
 7012 3c38 FF70A0E3 		mov	r7, #255
 7013 3c3c 07C0A0E1 		mov	ip, r7
 7014              	.LVL772:
 7015              	.L479:
 960:../uvc.c      **** }
 7016              		.loc 1 960 0
 7017 3c40 04108DE8 		stmia	sp, {r2, ip}
 7018 3c44 24171FE5 		ldr	r1, .L720+92
 7019 3c48 08708DE5 		str	r7, [sp, #8]
 7020 3c4c 30209DE5 		ldr	r2, [sp, #48]
 7021              	.LVL773:
 7022 3c50 0400A0E3 		mov	r0, #4
 7023 3c54 FEFFFFEB 		bl	CyU3PDebugPrint
 7024              	.LVL774:
 7025 3c58 50309DE5 		ldr	r3, [sp, #80]
 7026 3c5c 5EFAFFEA 		b	.L259
 7027              	.LVL775:
 7028              	.L717:
 7029              	.LBE360:
 7030              	.LBE387:
 7031              	.LBB388:
 7032              	.LBB379:
 426:../uvc.c      **** 		 {
 7033              		.loc 1 426 0
 7034 3c60 810057E3 		cmp	r7, #129
 7035 3c64 5902000A 		beq	.L459
 7036 3c68 F000008A 		bhi	.L460
 7037 3c6c 010057E3 		cmp	r7, #1
 7038 3c70 E502001A 		bne	.L456
 664:../uvc.c      **** 				  glEp0Buffer, &readCount);
 7039              		.loc 1 664 0
 7040 3c74 48208DE2 		add	r2, sp, #72
 7041 3c78 2000A0E3 		mov	r0, #32
 7042 3c7c 44171FE5 		ldr	r1, .L720+116
 7043 3c80 28308DE5 		str	r3, [sp, #40]
 7044 3c84 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 7045              	.LVL776:
 666:../uvc.c      **** 			   {
 7046              		.loc 1 666 0
 7047 3c88 002050E2 		subs	r2, r0, #0
 7048 3c8c 6D03001A 		bne	.L468
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7049              		.loc 1 762 0
 7050 3c90 74E71FE5 		ldr	lr, .L720+88
 668:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 7051              		.loc 1 668 0
 7052 3c94 9CC0D4E5 		ldrb	ip, [r4, #156]	@ zero_extendqisi2
 7053              	.LVL777:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7054              		.loc 1 762 0
 7055 3c98 1C009EE5 		ldr	r0, [lr, #28]
 7056              	.LVL778:
 7057 3c9c 0010E0E3 		mvn	r1, #0
 671:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7058              		.loc 1 671 0
 7059 3ca0 9E60D4E5 		ldrb	r6, [r4, #158]	@ zero_extendqisi2
 7060              	.LVL779:
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 7061              		.loc 1 762 0
 7062 3ca4 2C208DE5 		str	r2, [sp, #44]
 7063 3ca8 24C08DE5 		str	ip, [sp, #36]
 7064 3cac FEFFFFEB 		bl	_txe_mutex_get
 7065              	.LVL780:
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 7066              		.loc 1 763 0
 7067 3cb0 24C09DE5 		ldr	ip, [sp, #36]
 7068 3cb4 2C209DE5 		ldr	r2, [sp, #44]
 7069 3cb8 01107CE2 		rsbs	r1, ip, #1
 7070 3cbc 0010A033 		movcc	r1, #0
 7071 3cc0 28309DE5 		ldr	r3, [sp, #40]
 7072 3cc4 04208DE5 		str	r2, [sp, #4]
 7073 3cc8 00108DE5 		str	r1, [sp]
 7074 3ccc 30209DE5 		ldr	r2, [sp, #48]
 7075 3cd0 1E10A0E3 		mov	r1, #30
 7076 3cd4 B8071FE5 		ldr	r0, .L720+88
 7077 3cd8 FEFFFFEB 		bl	cmdSet
 7078              	.LVL781:
 764:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 7079              		.loc 1 764 0
 7080 3cdc C0171FE5 		ldr	r1, .L720+88
 7081 3ce0 1C0091E5 		ldr	r0, [r1, #28]
 7082 3ce4 FEFFFFEB 		bl	_txe_mutex_put
 7083              	.LVL782:
 765:../uvc.c      **** 							 break;
 7084              		.loc 1 765 0
 7085 3ce8 B4271FE5 		ldr	r2, .L720+112
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7086              		.loc 1 414 0
 7087 3cec FF30A0E3 		mov	r3, #255
 765:../uvc.c      **** 							 break;
 7088              		.loc 1 765 0
 7089 3cf0 6074C2E5 		strb	r7, [r2, #1120]
 7090 3cf4 24C09DE5 		ldr	ip, [sp, #36]
 7091              	.LVL783:
 7092              	.L466:
 960:../uvc.c      **** }
 7093              		.loc 1 960 0
 7094 3cf8 FF10A0E3 		mov	r1, #255
 7095 3cfc 04308DE5 		str	r3, [sp, #4]
 7096 3d00 08108DE5 		str	r1, [sp, #8]
 7097 3d04 0C30A0E1 		mov	r3, ip
 7098              	.LVL784:
 7099 3d08 00608DE5 		str	r6, [sp]
 7100 3d0c 0720A0E1 		mov	r2, r7
 7101 3d10 0400A0E3 		mov	r0, #4
 7102 3d14 F4171FE5 		ldr	r1, .L720+92
 7103 3d18 FEFFFFEB 		bl	CyU3PDebugPrint
 7104              	.LVL785:
 7105 3d1c 50309DE5 		ldr	r3, [sp, #80]
 7106 3d20 2DFAFFEA 		b	.L259
 7107              	.LVL786:
 7108              	.L548:
 7109              	.LBE379:
 7110              	.LBE388:
 7111              	.LBE412:
 7112              	.LBE433:
 7113              	.LBB434:
 7114              	.LBB140:
3246:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 7115              		.loc 1 3246 0
 7116 3d24 B824DDE1 		ldrh	r2, [sp, #72]
 7117 3d28 04181FE5 		ldr	r1, .L720+96
 7118 3d2c C430D9E5 		ldrb	r3, [r9, #196]	@ zero_extendqisi2
 7119 3d30 0400A0E3 		mov	r0, #4
 7120              	.LVL787:
 7121 3d34 FEFFFFEB 		bl	CyU3PDebugPrint
 7122              	.LVL788:
3247:../uvc.c      ****                         }
 7123              		.loc 1 3247 0
 7124 3d38 0000A0E3 		mov	r0, #0
 7125 3d3c 0020A0E1 		mov	r2, r0
 7126 3d40 0110A0E3 		mov	r1, #1
 7127 3d44 FEFFFFEB 		bl	CyU3PUsbStall
 7128              	.LVL789:
 7129 3d48 2CFAFFEA 		b	.L515
 7130              	.LVL790:
 7131              	.L691:
 7132 3d4c 0060A0E1 		mov	r6, r0
 7133              	.LBE140:
 7134              	.LBE434:
3410:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 7135              		.loc 1 3410 0
 7136 3d50 28181FE5 		ldr	r1, .L720+100
 7137 3d54 0700A0E1 		mov	r0, r7
 7138              	.LVL791:
 7139 3d58 0620A0E1 		mov	r2, r6
 7140 3d5c FEFFFFEB 		bl	CyU3PDebugPrint
 7141              	.LVL792:
3411:../uvc.c      **** 					}
 7142              		.loc 1 3411 0
 7143 3d60 0600A0E1 		mov	r0, r6
 7144 3d64 FEFFFFEB 		bl	CyFxAppErrorHandler
 7145              	.LVL793:
 7146              	.L377:
 7147              	.LBB435:
 7148              	.LBB345:
 7149              	.LBB271:
 7150              	.LBB254:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7151              		.loc 1 1033 0
 7152 3d68 34C81FE5 		ldr	ip, .L720+112
 7153 3d6c 2715DCE5 		ldrb	r1, [ip, #1319]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7154              		.loc 1 1034 0
 7155 3d70 2825DCE5 		ldrb	r2, [ip, #1320]	@ zero_extendqisi2
 7156 3d74 70FBFFEA 		b	.L667
 7157              	.LVL794:
 7158              	.L329:
 7159              	.LBE254:
 7160              	.LBE271:
 7161              	.LBB272:
 7162              	.LBB245:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7163              		.loc 1 1033 0
 7164 3d78 44381FE5 		ldr	r3, .L720+112
 7165 3d7c C714D3E5 		ldrb	r1, [r3, #1223]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7166              		.loc 1 1034 0
 7167 3d80 C824D3E5 		ldrb	r2, [r3, #1224]	@ zero_extendqisi2
 7168 3d84 6CFBFFEA 		b	.L667
 7169              	.LVL795:
 7170              	.L362:
 7171              	.LBE245:
 7172              	.LBE272:
 7173              	.LBB273:
 7174              	.LBB207:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7175              		.loc 1 1000 0
 7176 3d88 54381FE5 		ldr	r3, .L720+112
 7177 3d8c 1525D3E5 		ldrb	r2, [r3, #1301]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7178              		.loc 1 1001 0
 7179 3d90 1615D3E5 		ldrb	r1, [r3, #1302]	@ zero_extendqisi2
 7180              	.LVL796:
 7181              	.L683:
 7182              	.LBE207:
 7183              	.LBE273:
 7184              	.LBB274:
 7185              	.LBB178:
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7186              		.loc 1 1002 0
 7187 3d94 0030A0E3 		mov	r3, #0
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7188              		.loc 1 1001 0
 7189 3d98 9D10C9E5 		strb	r1, [r9, #157]
1008:../uvc.c      **** 
 7190              		.loc 1 1008 0
 7191 3d9c 0700A0E1 		mov	r0, r7
 7192 3da0 68181FE5 		ldr	r1, .L720+116
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7193              		.loc 1 1000 0
 7194 3da4 9C20C9E5 		strb	r2, [r9, #156]
1008:../uvc.c      **** 
 7195              		.loc 1 1008 0
 7196 3da8 2C208DE5 		str	r2, [sp, #44]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7197              		.loc 1 1002 0
 7198 3dac 9E30C9E5 		strb	r3, [r9, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7199              		.loc 1 1003 0
 7200 3db0 9F30C9E5 		strb	r3, [r9, #159]
 7201              	.LVL797:
1008:../uvc.c      **** 
 7202              		.loc 1 1008 0
 7203 3db4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7204              	.LVL798:
 7205 3db8 2C209DE5 		ldr	r2, [sp, #44]
 7206 3dbc 38FDFFEA 		b	.L415
 7207              	.LVL799:
 7208              	.L419:
 7209              	.LBE178:
 7210              	.LBE274:
 7211              	.LBB275:
 7212              	.LBB196:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7213              		.loc 1 1000 0
 7214 3dc0 8CE81FE5 		ldr	lr, .L720+112
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7215              		.loc 1 1002 0
 7216 3dc4 0020A0E3 		mov	r2, #0
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7217              		.loc 1 1001 0
 7218 3dc8 8E15DEE5 		ldrb	r1, [lr, #1422]	@ zero_extendqisi2
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7219              		.loc 1 1000 0
 7220 3dcc 8D35DEE5 		ldrb	r3, [lr, #1421]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7221              		.loc 1 1001 0
 7222 3dd0 9D10C9E5 		strb	r1, [r9, #157]
1008:../uvc.c      **** 
 7223              		.loc 1 1008 0
 7224 3dd4 30009DE5 		ldr	r0, [sp, #48]
 7225 3dd8 A0181FE5 		ldr	r1, .L720+116
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7226              		.loc 1 980 0
 7227 3ddc FF70A0E3 		mov	r7, #255
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7228              		.loc 1 1000 0
 7229 3de0 9C30C9E5 		strb	r3, [r9, #156]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7230              		.loc 1 1002 0
 7231 3de4 9E20C9E5 		strb	r2, [r9, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7232              		.loc 1 1003 0
 7233 3de8 9F20C9E5 		strb	r2, [r9, #159]
 7234              	.LVL800:
1008:../uvc.c      **** 
 7235              		.loc 1 1008 0
 7236 3dec 28308DE5 		str	r3, [sp, #40]
 7237 3df0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7238              	.LVL801:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7239              		.loc 1 980 0
 7240 3df4 07C0A0E1 		mov	ip, r7
 7241 3df8 28309DE5 		ldr	r3, [sp, #40]
 7242 3dfc 30209DE5 		ldr	r2, [sp, #48]
 7243 3e00 EFFBFFEA 		b	.L426
 7244              	.LVL802:
 7245              	.L298:
 7246              	.LBE196:
 7247              	.LBE275:
 7248              	.LBB276:
 7249              	.LBB226:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7250              		.loc 1 1000 0
 7251 3e04 D0181FE5 		ldr	r1, .L720+112
 7252 3e08 9D24D1E5 		ldrb	r2, [r1, #1181]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7253              		.loc 1 1001 0
 7254 3e0c 9E14D1E5 		ldrb	r1, [r1, #1182]	@ zero_extendqisi2
 7255 3e10 DFFFFFEA 		b	.L683
 7256              	.LVL803:
 7257              	.L351:
 7258              	.LBE226:
 7259              	.LBE276:
 7260              	.LBB277:
 7261              	.LBB167:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7262              		.loc 1 1000 0
 7263 3e14 E0E81FE5 		ldr	lr, .L720+112
 7264 3e18 FD24DEE5 		ldrb	r2, [lr, #1277]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7265              		.loc 1 1001 0
 7266 3e1c FE14DEE5 		ldrb	r1, [lr, #1278]	@ zero_extendqisi2
 7267 3e20 DBFFFFEA 		b	.L683
 7268              	.LVL804:
 7269              	.L336:
 7270              	.LBE167:
 7271              	.LBE277:
 7272              	.LBB278:
 7273              	.LBB216:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7274              		.loc 1 1000 0
 7275 3e24 F0E81FE5 		ldr	lr, .L720+112
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7276              		.loc 1 1002 0
 7277 3e28 0030A0E3 		mov	r3, #0
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7278              		.loc 1 1000 0
 7279 3e2c E5C4DEE5 		ldrb	ip, [lr, #1253]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7280              		.loc 1 1001 0
 7281 3e30 E624DEE5 		ldrb	r2, [lr, #1254]	@ zero_extendqisi2
1008:../uvc.c      **** 
 7282              		.loc 1 1008 0
 7283 3e34 0600A0E1 		mov	r0, r6
 7284 3e38 00191FE5 		ldr	r1, .L720+116
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7285              		.loc 1 1000 0
 7286 3e3c 9CC0C9E5 		strb	ip, [r9, #156]
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7287              		.loc 1 1001 0
 7288 3e40 9D20C9E5 		strb	r2, [r9, #157]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7289              		.loc 1 1002 0
 7290 3e44 9E30C9E5 		strb	r3, [r9, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7291              		.loc 1 1003 0
 7292 3e48 9F30C9E5 		strb	r3, [r9, #159]
 7293              	.LVL805:
1008:../uvc.c      **** 
 7294              		.loc 1 1008 0
 7295 3e4c 24C08DE5 		str	ip, [sp, #36]
 7296 3e50 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7297              	.LVL806:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7298              		.loc 1 980 0
 7299 3e54 FF20A0E3 		mov	r2, #255
 7300 3e58 0230A0E1 		mov	r3, r2
 7301 3e5c 24C09DE5 		ldr	ip, [sp, #36]
 7302 3e60 30FCFFEA 		b	.L343
 7303              	.LVL807:
 7304              	.L384:
 7305              	.LBE216:
 7306              	.LBE278:
 7307              	.LBB279:
 7308              	.LBB234:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7309              		.loc 1 1000 0
 7310 3e64 30191FE5 		ldr	r1, .L720+112
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7311              		.loc 1 1002 0
 7312 3e68 0030A0E3 		mov	r3, #0
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7313              		.loc 1 1000 0
 7314 3e6c 45C5D1E5 		ldrb	ip, [r1, #1349]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7315              		.loc 1 1001 0
 7316 3e70 4625D1E5 		ldrb	r2, [r1, #1350]	@ zero_extendqisi2
1008:../uvc.c      **** 
 7317              		.loc 1 1008 0
 7318 3e74 0700A0E1 		mov	r0, r7
 7319 3e78 40191FE5 		ldr	r1, .L720+116
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7320              		.loc 1 1000 0
 7321 3e7c 9CC0C9E5 		strb	ip, [r9, #156]
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7322              		.loc 1 1001 0
 7323 3e80 9D20C9E5 		strb	r2, [r9, #157]
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7324              		.loc 1 1002 0
 7325 3e84 9E30C9E5 		strb	r3, [r9, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7326              		.loc 1 1003 0
 7327 3e88 9F30C9E5 		strb	r3, [r9, #159]
 7328              	.LVL808:
1008:../uvc.c      **** 
 7329              		.loc 1 1008 0
 7330 3e8c 24C08DE5 		str	ip, [sp, #36]
 7331 3e90 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7332              	.LVL809:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7333              		.loc 1 980 0
 7334 3e94 FF20A0E3 		mov	r2, #255
 7335 3e98 0230A0E1 		mov	r3, r2
 7336 3e9c 24C09DE5 		ldr	ip, [sp, #36]
 7337 3ea0 61FCFFEA 		b	.L391
 7338              	.LVL810:
 7339              	.L373:
 7340              	.LBE234:
 7341              	.LBE279:
 7342              	.LBB280:
 7343              	.LBB255:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7344              		.loc 1 1000 0
 7345 3ea4 70E91FE5 		ldr	lr, .L720+112
 7346 3ea8 2D25DEE5 		ldrb	r2, [lr, #1325]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7347              		.loc 1 1001 0
 7348 3eac 2E15DEE5 		ldrb	r1, [lr, #1326]	@ zero_extendqisi2
 7349 3eb0 B7FFFFEA 		b	.L683
 7350              	.LVL811:
 7351              	.L309:
 7352              	.LBE255:
 7353              	.LBE280:
 7354              	.LBB281:
 7355              	.LBB157:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7356              		.loc 1 1000 0
 7357 3eb4 80E91FE5 		ldr	lr, .L720+112
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7358              		.loc 1 1002 0
 7359 3eb8 0030A0E3 		mov	r3, #0
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7360              		.loc 1 1000 0
 7361 3ebc B574DEE5 		ldrb	r7, [lr, #1205]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7362              		.loc 1 1001 0
 7363 3ec0 B624DEE5 		ldrb	r2, [lr, #1206]	@ zero_extendqisi2
1008:../uvc.c      **** 
 7364              		.loc 1 1008 0
 7365 3ec4 30009DE5 		ldr	r0, [sp, #48]
 7366 3ec8 90191FE5 		ldr	r1, .L720+116
1002:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7367              		.loc 1 1002 0
 7368 3ecc 9E30C9E5 		strb	r3, [r9, #158]
1003:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 7369              		.loc 1 1003 0
 7370 3ed0 9F30C9E5 		strb	r3, [r9, #159]
 7371              	.LVL812:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7372              		.loc 1 1000 0
 7373 3ed4 9C70C9E5 		strb	r7, [r9, #156]
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7374              		.loc 1 1001 0
 7375 3ed8 9D20C9E5 		strb	r2, [r9, #157]
1008:../uvc.c      **** 
 7376              		.loc 1 1008 0
 7377 3edc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7378              	.LVL813:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7379              		.loc 1 980 0
 7380 3ee0 FFC0A0E3 		mov	ip, #255
 7381 3ee4 30309DE5 		ldr	r3, [sp, #48]
 7382 3ee8 9BFAFFEA 		b	.L316
 7383              	.LVL814:
 7384              	.L412:
 7385              	.LBE157:
 7386              	.LBE281:
 7387              	.LBB282:
 7388              	.LBB179:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7389              		.loc 1 1033 0
 7390 3eec B8C91FE5 		ldr	ip, .L720+112
 7391 3ef0 6F15DCE5 		ldrb	r1, [ip, #1391]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7392              		.loc 1 1034 0
 7393 3ef4 7025DCE5 		ldrb	r2, [ip, #1392]	@ zero_extendqisi2
 7394 3ef8 0FFBFFEA 		b	.L667
 7395              	.LVL815:
 7396              	.L366:
 7397              	.LBE179:
 7398              	.LBE282:
 7399              	.LBB283:
 7400              	.LBB208:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7401              		.loc 1 1033 0
 7402 3efc C8291FE5 		ldr	r2, .L720+112
 7403 3f00 0F15D2E5 		ldrb	r1, [r2, #1295]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7404              		.loc 1 1034 0
 7405 3f04 1025D2E5 		ldrb	r2, [r2, #1296]	@ zero_extendqisi2
 7406 3f08 0BFBFFEA 		b	.L667
 7407              	.LVL816:
 7408              	.L397:
 7409              	.LBE208:
 7410              	.LBE283:
 7411              	.LBB284:
 7412              	.LBB188:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7413              		.loc 1 1000 0
 7414 3f0c 5D25DAE5 		ldrb	r2, [r10, #1373]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7415              		.loc 1 1001 0
 7416 3f10 5E15DAE5 		ldrb	r1, [r10, #1374]	@ zero_extendqisi2
 7417 3f14 9EFFFFEA 		b	.L683
 7418              	.LVL817:
 7419              	.L408:
 7420              	.LBE188:
 7421              	.LBE284:
 7422              	.LBB285:
 7423              	.LBB180:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7424              		.loc 1 1000 0
 7425 3f18 E4191FE5 		ldr	r1, .L720+112
 7426 3f1c 7525D1E5 		ldrb	r2, [r1, #1397]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7427              		.loc 1 1001 0
 7428 3f20 7615D1E5 		ldrb	r1, [r1, #1398]	@ zero_extendqisi2
 7429 3f24 9AFFFFEA 		b	.L683
 7430              	.LVL818:
 7431              	.L401:
 7432              	.LBE180:
 7433              	.LBE285:
 7434              	.LBB286:
 7435              	.LBB189:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7436              		.loc 1 1033 0
 7437 3f28 5715DAE5 		ldrb	r1, [r10, #1367]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7438              		.loc 1 1034 0
 7439 3f2c 5825DAE5 		ldrb	r2, [r10, #1368]	@ zero_extendqisi2
 7440 3f30 01FBFFEA 		b	.L667
 7441              	.LVL819:
 7442              	.L313:
 7443              	.LBE189:
 7444              	.LBE286:
 7445              	.LBB287:
 7446              	.LBB158:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7447              		.loc 1 1033 0
 7448 3f34 AF14DAE5 		ldrb	r1, [r10, #1199]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7449              		.loc 1 1034 0
 7450 3f38 B024DAE5 		ldrb	r2, [r10, #1200]	@ zero_extendqisi2
 7451 3f3c 7BFAFFEA 		b	.L657
 7452              	.LVL820:
 7453              	.L423:
 7454              	.LBE158:
 7455              	.LBE287:
 7456              	.LBB288:
 7457              	.LBB197:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7458              		.loc 1 1033 0
 7459 3f40 8705DAE5 		ldrb	r0, [r10, #1415]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7460              		.loc 1 1034 0
 7461 3f44 8815DAE5 		ldrb	r1, [r10, #1416]	@ zero_extendqisi2
 7462 3f48 90FBFFEA 		b	.L669
 7463              	.LVL821:
 7464              	.L302:
 7465              	.LBE197:
 7466              	.LBE288:
 7467              	.LBB289:
 7468              	.LBB227:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7469              		.loc 1 1033 0
 7470 3f4c 18CA1FE5 		ldr	ip, .L720+112
 7471 3f50 9714DCE5 		ldrb	r1, [ip, #1175]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7472              		.loc 1 1034 0
 7473 3f54 9824DCE5 		ldrb	r2, [ip, #1176]	@ zero_extendqisi2
 7474 3f58 F7FAFFEA 		b	.L667
 7475              	.LVL822:
 7476              	.L325:
 7477              	.LBE227:
 7478              	.LBE289:
 7479              	.LBB290:
 7480              	.LBB246:
1000:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 7481              		.loc 1 1000 0
 7482 3f5c 28CA1FE5 		ldr	ip, .L720+112
 7483 3f60 CD24DCE5 		ldrb	r2, [ip, #1229]	@ zero_extendqisi2
1001:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 7484              		.loc 1 1001 0
 7485 3f64 CE14DCE5 		ldrb	r1, [ip, #1230]	@ zero_extendqisi2
 7486 3f68 89FFFFEA 		b	.L683
 7487              	.LVL823:
 7488              	.L388:
 7489              	.LBE246:
 7490              	.LBE290:
 7491              	.LBB291:
 7492              	.LBB235:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7493              		.loc 1 1033 0
 7494 3f6c 38CA1FE5 		ldr	ip, .L720+112
 7495 3f70 3F15DCE5 		ldrb	r1, [ip, #1343]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7496              		.loc 1 1034 0
 7497 3f74 4025DCE5 		ldrb	r2, [ip, #1344]	@ zero_extendqisi2
 7498 3f78 20FCFFEA 		b	.L665
 7499              	.LVL824:
 7500              	.L355:
 7501              	.LBE235:
 7502              	.LBE291:
 7503              	.LBB292:
 7504              	.LBB168:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7505              		.loc 1 1033 0
 7506 3f7c F714DAE5 		ldrb	r1, [r10, #1271]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7507              		.loc 1 1034 0
 7508 3f80 F824DAE5 		ldrb	r2, [r10, #1272]	@ zero_extendqisi2
 7509 3f84 ECFAFFEA 		b	.L667
 7510              	.LVL825:
 7511              	.L340:
 7512              	.LBE168:
 7513              	.LBE292:
 7514              	.LBB293:
 7515              	.LBB217:
1033:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 7516              		.loc 1 1033 0
 7517 3f88 54CA1FE5 		ldr	ip, .L720+112
 7518 3f8c DF14DCE5 		ldrb	r1, [ip, #1247]	@ zero_extendqisi2
1034:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7519              		.loc 1 1034 0
 7520 3f90 E024DCE5 		ldrb	r2, [ip, #1248]	@ zero_extendqisi2
 7521 3f94 D8FBFFEA 		b	.L661
 7522              	.LVL826:
 7523              	.L527:
 7524              	.LBE217:
 7525              	.LBE293:
 7526              	.LBE345:
 7527              	.LBE435:
 7528              	.LBB436:
 7529              	.LBB141:
3039:../uvc.c      ****                          		CyU3PThreadSleep(500);
 7530              		.loc 1 3039 0
 7531 3f98 3010A0E3 		mov	r1, #48
 7532 3f9c 0020A0E3 		mov	r2, #0
 7533 3fa0 5230A0E3 		mov	r3, #82
 7534 3fa4 0B00A0E3 		mov	r0, #11
 7535              	.LVL827:
 7536 3fa8 FEFFFFEB 		bl	SensorSetIrisControl
 7537              	.LVL828:
3040:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
 7538              		.loc 1 3040 0
 7539 3fac 7D0FA0E3 		mov	r0, #500
 7540 3fb0 FEFFFFEB 		bl	_tx_thread_sleep
 7541              	.LVL829:
3041:../uvc.c      ****                          		break;
 7542              		.loc 1 3041 0
 7543 3fb4 781A1FE5 		ldr	r1, .L720+120
 7544 3fb8 0020A0E3 		mov	r2, #0
 7545 3fbc 0B30A0E3 		mov	r3, #11
 7546 3fc0 0400A0E3 		mov	r0, #4
 7547 3fc4 FEFFFFEB 		bl	CyU3PDebugPrint
 7548              	.LVL830:
 7549 3fc8 73FCFFEA 		b	.L525
 7550              	.LVL831:
 7551              	.L477:
 7552              	.LBE141:
 7553              	.LBE436:
 7554              	.LBB437:
 7555              	.LBB413:
 7556              	.LBB389:
 7557              	.LBB361:
 639:../uvc.c      **** 		 	 }
 7558              		.loc 1 639 0
 7559 3fcc 7134DAE5 		ldrb	r3, [r10, #1137]	@ zero_extendqisi2
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7560              		.loc 1 641 0
 7561 3fd0 0100A0E3 		mov	r0, #1
 7562 3fd4 9C1A1FE5 		ldr	r1, .L720+116
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7563              		.loc 1 414 0
 7564 3fd8 FF70A0E3 		mov	r7, #255
 639:../uvc.c      **** 		 	 }
 7565              		.loc 1 639 0
 7566 3fdc 9C30C9E5 		strb	r3, [r9, #156]
 7567 3fe0 A2FCFFEA 		b	.L674
 7568              	.LVL832:
 7569              	.L492:
 7570              	.LBE361:
 7571              	.LBE389:
 7572              	.LBB390:
 7573              	.LBB371:
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 7574              		.loc 1 583 0
 7575 3fe4 7BE0DAE5 		ldrb	lr, [r10, #123]	@ zero_extendqisi2
 584:../uvc.c      **** 		 	 }
 7576              		.loc 1 584 0
 7577 3fe8 7C20DAE5 		ldrb	r2, [r10, #124]	@ zero_extendqisi2
 7578 3fec CBFCFFEA 		b	.L677
 7579              	.L496:
 636:../uvc.c      **** 		 	 }
 7580              		.loc 1 636 0
 7581 3ff0 8120DAE5 		ldrb	r2, [r10, #129]	@ zero_extendqisi2
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7582              		.loc 1 641 0
 7583 3ff4 0100A0E3 		mov	r0, #1
 7584 3ff8 C01A1FE5 		ldr	r1, .L720+116
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7585              		.loc 1 414 0
 7586 3ffc FF70A0E3 		mov	r7, #255
 636:../uvc.c      **** 		 	 }
 7587              		.loc 1 636 0
 7588 4000 9C20C9E5 		strb	r2, [r9, #156]
 7589 4004 CAFCFFEA 		b	.L678
 7590              	.LVL833:
 7591              	.L464:
 7592              	.LBE371:
 7593              	.LBE390:
 7594              	.LBB391:
 7595              	.LBB380:
 639:../uvc.c      **** 		 	 }
 7596              		.loc 1 639 0
 7597 4008 D46A1FE5 		ldr	r6, .L720+112
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7598              		.loc 1 641 0
 7599 400c 0100A0E3 		mov	r0, #1
 639:../uvc.c      **** 		 	 }
 7600              		.loc 1 639 0
 7601 4010 5934D6E5 		ldrb	r3, [r6, #1113]	@ zero_extendqisi2
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7602              		.loc 1 641 0
 7603 4014 DC1A1FE5 		ldr	r1, .L720+116
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7604              		.loc 1 414 0
 7605 4018 FF60A0E3 		mov	r6, #255
 639:../uvc.c      **** 		 	 }
 7606              		.loc 1 639 0
 7607 401c 9C30C9E5 		strb	r3, [r9, #156]
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7608              		.loc 1 641 0
 7609 4020 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7610              	.LVL834:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7611              		.loc 1 414 0
 7612 4024 06C0A0E1 		mov	ip, r6
 642:../uvc.c      **** 			  Len = 1;
 7613              		.loc 1 642 0
 7614 4028 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 7615              	.LVL835:
 7616 402c 31FFFFEA 		b	.L466
 7617              	.LVL836:
 7618              	.L460:
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7619              		.loc 1 594 0
 7620 4030 FCEA1FE5 		ldr	lr, .L720+112
 7621 4034 5324DEE5 		ldrb	r2, [lr, #1107]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 7622              		.loc 1 595 0
 7623 4038 5434DEE5 		ldrb	r3, [lr, #1108]	@ zero_extendqisi2
 7624 403c E5FCFFEA 		b	.L671
 7625              	.LVL837:
 7626              	.L473:
 7627              	.LBE380:
 7628              	.LBE391:
 7629              	.LBB392:
 7630              	.LBB362:
 594:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7631              		.loc 1 594 0
 7632 4040 6B24DAE5 		ldrb	r2, [r10, #1131]	@ zero_extendqisi2
 595:../uvc.c      **** 			 }
 7633              		.loc 1 595 0
 7634 4044 6C34DAE5 		ldrb	r3, [r10, #1132]	@ zero_extendqisi2
 7635 4048 83FCFFEA 		b	.L673
 7636              	.LVL838:
 7637              	.L381:
 7638              	.LBE362:
 7639              	.LBE392:
 7640              	.LBE413:
 7641              	.LBE437:
 7642              	.LBB438:
 7643              	.LBB346:
 7644              	.LBB294:
 7645              	.LBB236:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7646              		.loc 1 1193 0
 7647 404c 0000A0E3 		mov	r0, #0
 7648 4050 0020A0E1 		mov	r2, r0
 7649 4054 0110A0E3 		mov	r1, #1
 7650 4058 24C08DE5 		str	ip, [sp, #36]
 7651 405c FEFFFFEB 		bl	CyU3PUsbStall
 7652              	.LVL839:
1194:../uvc.c      **** 			  break;
 7653              		.loc 1 1194 0
 7654 4060 24C09DE5 		ldr	ip, [sp, #36]
 7655 4064 0720A0E3 		mov	r2, #7
 7656 4068 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7657 406c 0400A0E3 		mov	r0, #4
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7658              		.loc 1 980 0
 7659 4070 FFC0A0E3 		mov	ip, #255
1194:../uvc.c      **** 			  break;
 7660              		.loc 1 1194 0
 7661 4074 481B1FE5 		ldr	r1, .L720+104
 7662 4078 24C08DE5 		str	ip, [sp, #36]
 7663 407c FEFFFFEB 		bl	CyU3PDebugPrint
 7664              	.LVL840:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7665              		.loc 1 980 0
 7666 4080 24C09DE5 		ldr	ip, [sp, #36]
 7667 4084 0C20A0E1 		mov	r2, ip
 7668 4088 0C30A0E1 		mov	r3, ip
 7669 408c E6FBFFEA 		b	.L391
 7670              	.LVL841:
 7671              	.L306:
 7672              	.LBE236:
 7673              	.LBE294:
 7674              	.LBB295:
 7675              	.LBB159:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7676              		.loc 1 1193 0
 7677 4090 0000A0E3 		mov	r0, #0
 7678 4094 0020A0E1 		mov	r2, r0
 7679 4098 0110A0E3 		mov	r1, #1
 7680 409c 24C08DE5 		str	ip, [sp, #36]
 7681 40a0 FEFFFFEB 		bl	CyU3PUsbStall
 7682              	.LVL842:
1194:../uvc.c      **** 			  break;
 7683              		.loc 1 1194 0
 7684 40a4 24C09DE5 		ldr	ip, [sp, #36]
 7685 40a8 0400A0E3 		mov	r0, #4
 7686 40ac 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7687 40b0 841B1FE5 		ldr	r1, .L720+104
 7688 40b4 0120A0E3 		mov	r2, #1
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7689              		.loc 1 980 0
 7690 40b8 FF70A0E3 		mov	r7, #255
1194:../uvc.c      **** 			  break;
 7691              		.loc 1 1194 0
 7692 40bc FEFFFFEB 		bl	CyU3PDebugPrint
 7693              	.LVL843:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7694              		.loc 1 980 0
 7695 40c0 07C0A0E1 		mov	ip, r7
 7696 40c4 30309DE5 		ldr	r3, [sp, #48]
 7697 40c8 23FAFFEA 		b	.L316
 7698              	.LVL844:
 7699              	.L416:
 7700              	.LBE159:
 7701              	.LBE295:
 7702              	.LBB296:
 7703              	.LBB198:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7704              		.loc 1 1193 0
 7705 40cc 0000A0E3 		mov	r0, #0
 7706 40d0 0020A0E1 		mov	r2, r0
 7707 40d4 0110A0E3 		mov	r1, #1
 7708 40d8 24C08DE5 		str	ip, [sp, #36]
 7709 40dc FEFFFFEB 		bl	CyU3PUsbStall
 7710              	.LVL845:
1194:../uvc.c      **** 			  break;
 7711              		.loc 1 1194 0
 7712 40e0 24C09DE5 		ldr	ip, [sp, #36]
 7713 40e4 0A20A0E3 		mov	r2, #10
 7714 40e8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7715 40ec 0400A0E3 		mov	r0, #4
 7716 40f0 C41B1FE5 		ldr	r1, .L720+104
 7717 40f4 FEFFFFEB 		bl	CyU3PDebugPrint
 7718              	.LVL846:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7719              		.loc 1 980 0
 7720 40f8 FF30A0E3 		mov	r3, #255
 7721 40fc 0370A0E1 		mov	r7, r3
 7722 4100 03C0A0E1 		mov	ip, r3
 7723 4104 30209DE5 		ldr	r2, [sp, #48]
 7724 4108 2DFBFFEA 		b	.L426
 7725              	.LVL847:
 7726              	.L333:
 7727              	.LBE198:
 7728              	.LBE296:
 7729              	.LBB297:
 7730              	.LBB218:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7731              		.loc 1 1193 0
 7732 410c 0000A0E3 		mov	r0, #0
 7733 4110 0020A0E1 		mov	r2, r0
 7734 4114 0110A0E3 		mov	r1, #1
 7735 4118 24C08DE5 		str	ip, [sp, #36]
 7736 411c FEFFFFEB 		bl	CyU3PUsbStall
 7737              	.LVL848:
1194:../uvc.c      **** 			  break;
 7738              		.loc 1 1194 0
 7739 4120 24C09DE5 		ldr	ip, [sp, #36]
 7740 4124 0320A0E3 		mov	r2, #3
 7741 4128 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7742 412c 0400A0E3 		mov	r0, #4
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7743              		.loc 1 980 0
 7744 4130 FFC0A0E3 		mov	ip, #255
1194:../uvc.c      **** 			  break;
 7745              		.loc 1 1194 0
 7746 4134 081C1FE5 		ldr	r1, .L720+104
 7747 4138 24C08DE5 		str	ip, [sp, #36]
 7748 413c FEFFFFEB 		bl	CyU3PDebugPrint
 7749              	.LVL849:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7750              		.loc 1 980 0
 7751 4140 24C09DE5 		ldr	ip, [sp, #36]
 7752 4144 0C20A0E1 		mov	r2, ip
 7753 4148 0C30A0E1 		mov	r3, ip
 7754 414c 75FBFFEA 		b	.L343
 7755              	.LVL850:
 7756              	.L322:
 7757              	.LBE218:
 7758              	.LBE297:
 7759              	.LBB298:
 7760              	.LBB247:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7761              		.loc 1 1193 0
 7762 4150 0000A0E3 		mov	r0, #0
 7763 4154 0020A0E1 		mov	r2, r0
 7764 4158 0110A0E3 		mov	r1, #1
 7765 415c 24C08DE5 		str	ip, [sp, #36]
 7766 4160 FEFFFFEB 		bl	CyU3PUsbStall
 7767              	.LVL851:
1194:../uvc.c      **** 			  break;
 7768              		.loc 1 1194 0
 7769 4164 24C09DE5 		ldr	ip, [sp, #36]
 7770 4168 0220A0E3 		mov	r2, #2
 7771 416c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7772 4170 0400A0E3 		mov	r0, #4
 7773 4174 481C1FE5 		ldr	r1, .L720+104
 7774 4178 FEFFFFEB 		bl	CyU3PDebugPrint
 7775              	.LVL852:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7776              		.loc 1 980 0
 7777 417c FF20A0E3 		mov	r2, #255
 7778              	.LVL853:
 7779 4180 47FCFFEA 		b	.L415
 7780              	.LVL854:
 7781              	.L359:
 7782              	.LBE247:
 7783              	.LBE298:
 7784              	.LBB299:
 7785              	.LBB209:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7786              		.loc 1 1193 0
 7787 4184 0000A0E3 		mov	r0, #0
 7788 4188 0020A0E1 		mov	r2, r0
 7789 418c 0110A0E3 		mov	r1, #1
 7790 4190 24C08DE5 		str	ip, [sp, #36]
 7791 4194 FEFFFFEB 		bl	CyU3PUsbStall
 7792              	.LVL855:
1194:../uvc.c      **** 			  break;
 7793              		.loc 1 1194 0
 7794 4198 24C09DE5 		ldr	ip, [sp, #36]
 7795 419c 0520A0E3 		mov	r2, #5
 7796 41a0 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7797 41a4 0400A0E3 		mov	r0, #4
 7798 41a8 7C1C1FE5 		ldr	r1, .L720+104
 7799 41ac FEFFFFEB 		bl	CyU3PDebugPrint
 7800              	.LVL856:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7801              		.loc 1 980 0
 7802 41b0 FF20A0E3 		mov	r2, #255
 7803              	.LVL857:
 7804 41b4 3AFCFFEA 		b	.L415
 7805              	.LVL858:
 7806              	.L348:
 7807              	.LBE209:
 7808              	.LBE299:
 7809              	.LBB300:
 7810              	.LBB169:
1193:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7811              		.loc 1 1193 0
 7812 41b8 0000A0E3 		mov	r0, #0
 7813 41bc 0020A0E1 		mov	r2, r0
 7814 41c0 0110A0E3 		mov	r1, #1
 7815 41c4 24C08DE5 		str	ip, [sp, #36]
 7816 41c8 FEFFFFEB 		bl	CyU3PUsbStall
 7817              	.LVL859:
1194:../uvc.c      **** 			  break;
 7818              		.loc 1 1194 0
 7819 41cc 24C09DE5 		ldr	ip, [sp, #36]
 7820 41d0 0400A0E3 		mov	r0, #4
 7821 41d4 0020A0E1 		mov	r2, r0
 7822 41d8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7823 41dc B01C1FE5 		ldr	r1, .L720+104
 7824 41e0 FEFFFFEB 		bl	CyU3PDebugPrint
 7825              	.LVL860:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7826              		.loc 1 980 0
 7827 41e4 FF20A0E3 		mov	r2, #255
 7828              	.LVL861:
 7829 41e8 2DFCFFEA 		b	.L415
 7830              	.LVL862:
 7831              	.L326:
 7832              	.LBE169:
 7833              	.LBE300:
 7834              	.LBB301:
 7835              	.LBB248:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 7836              		.loc 1 1015 0
 7837 41ec B8EC1FE5 		ldr	lr, .L720+112
 7838 41f0 C314DEE5 		ldrb	r1, [lr, #1219]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 7839              		.loc 1 1016 0
 7840 41f4 C424DEE5 		ldrb	r2, [lr, #1220]	@ zero_extendqisi2
 7841 41f8 4FFAFFEA 		b	.L667
 7842              	.LVL863:
 7843              	.L378:
 7844              	.LBE248:
 7845              	.LBE301:
 7846              	.LBB302:
 7847              	.LBB256:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7848              		.loc 1 1042 0
 7849 41fc 2935DAE5 		ldrb	r3, [r10, #1321]	@ zero_extendqisi2
 7850              	.LVL864:
 7851              	.L684:
 7852              	.LBE256:
 7853              	.LBE302:
 7854              	.LBB303:
 7855              	.LBB181:
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7856              		.loc 1 1043 0
 7857 4200 0100A0E3 		mov	r0, #1
 7858 4204 CC1C1FE5 		ldr	r1, .L720+116
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7859              		.loc 1 1042 0
 7860 4208 9C30C9E5 		strb	r3, [r9, #156]
1045:../uvc.c      **** 			  break;
 7861              		.loc 1 1045 0
 7862 420c 0170A0E3 		mov	r7, #1
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7863              		.loc 1 1043 0
 7864 4210 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7865              	.LVL865:
1044:../uvc.c      **** 			  Len = 1;
 7866              		.loc 1 1044 0
 7867 4214 9C20D9E5 		ldrb	r2, [r9, #156]	@ zero_extendqisi2
 7868              	.LVL866:
 7869 4218 21FCFFEA 		b	.L415
 7870              	.LVL867:
 7871              	.L385:
 7872              	.LBE181:
 7873              	.LBE303:
 7874              	.LBB304:
 7875              	.LBB237:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 7876              		.loc 1 1015 0
 7877 421c E82C1FE5 		ldr	r2, .L720+112
 7878 4220 3B15D2E5 		ldrb	r1, [r2, #1339]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 7879              		.loc 1 1016 0
 7880 4224 3C25D2E5 		ldrb	r2, [r2, #1340]	@ zero_extendqisi2
 7881 4228 74FBFFEA 		b	.L665
 7882              	.LVL868:
 7883              	.L424:
 7884              	.LBE237:
 7885              	.LBE304:
 7886              	.LBB305:
 7887              	.LBB199:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7888              		.loc 1 1042 0
 7889 422c 8935DAE5 		ldrb	r3, [r10, #1417]	@ zero_extendqisi2
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7890              		.loc 1 1043 0
 7891 4230 0100A0E3 		mov	r0, #1
 7892 4234 FC1C1FE5 		ldr	r1, .L720+116
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7893              		.loc 1 980 0
 7894 4238 FF70A0E3 		mov	r7, #255
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7895              		.loc 1 1042 0
 7896 423c 9C30C9E5 		strb	r3, [r9, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7897              		.loc 1 1043 0
 7898 4240 24708DE5 		str	r7, [sp, #36]
 7899 4244 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7900              	.LVL869:
1045:../uvc.c      **** 			  break;
 7901              		.loc 1 1045 0
 7902 4248 0120A0E3 		mov	r2, #1
 7903 424c 30208DE5 		str	r2, [sp, #48]
 7904              	.LVL870:
1044:../uvc.c      **** 			  Len = 1;
 7905              		.loc 1 1044 0
 7906 4250 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 7907              	.LVL871:
 7908 4254 24C09DE5 		ldr	ip, [sp, #36]
 7909 4258 D9FAFFEA 		b	.L426
 7910              	.LVL872:
 7911              	.L330:
 7912              	.LBE199:
 7913              	.LBE305:
 7914              	.LBB306:
 7915              	.LBB249:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 7916              		.loc 1 1042 0
 7917 425c 28CD1FE5 		ldr	ip, .L720+112
 7918 4260 C934DCE5 		ldrb	r3, [ip, #1225]	@ zero_extendqisi2
 7919 4264 E5FFFFEA 		b	.L684
 7920              	.LVL873:
 7921              	.L374:
 7922              	.LBE249:
 7923              	.LBE306:
 7924              	.LBB307:
 7925              	.LBB257:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 7926              		.loc 1 1015 0
 7927 4268 342D1FE5 		ldr	r2, .L720+112
 7928 426c 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 7929              		.loc 1 1016 0
 7930 4270 2425D2E5 		ldrb	r2, [r2, #1316]	@ zero_extendqisi2
 7931 4274 30FAFFEA 		b	.L667
 7932              	.LVL874:
 7933              	.L310:
 7934              	.LBE257:
 7935              	.LBE307:
 7936              	.LBB308:
 7937              	.LBB160:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 7938              		.loc 1 1015 0
 7939 4278 AB14DAE5 		ldrb	r1, [r10, #1195]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 7940              		.loc 1 1016 0
 7941 427c AC24DAE5 		ldrb	r2, [r10, #1196]	@ zero_extendqisi2
 7942 4280 AAF9FFEA 		b	.L657
 7943              	.LVL875:
 7944              	.L337:
 7945              	.LBE160:
 7946              	.LBE308:
 7947              	.LBB309:
 7948              	.LBB219:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 7949              		.loc 1 1015 0
 7950 4284 502D1FE5 		ldr	r2, .L720+112
 7951 4288 DB14D2E5 		ldrb	r1, [r2, #1243]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 7952              		.loc 1 1016 0
 7953 428c DC24D2E5 		ldrb	r2, [r2, #1244]	@ zero_extendqisi2
 7954 4290 19FBFFEA 		b	.L661
 7955              	.LVL876:
 7956              	.L299:
 7957              	.LBE219:
 7958              	.LBE309:
 7959              	.LBB310:
 7960              	.LBB228:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 7961              		.loc 1 1015 0
 7962 4294 602D1FE5 		ldr	r2, .L720+112
 7963 4298 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 7964              		.loc 1 1016 0
 7965 429c 9424D2E5 		ldrb	r2, [r2, #1172]	@ zero_extendqisi2
 7966 42a0 25FAFFEA 		b	.L667
 7967              	.LVL877:
 7968              	.L352:
 7969              	.LBE228:
 7970              	.LBE310:
 7971              	.LBB311:
 7972              	.LBB170:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 7973              		.loc 1 1015 0
 7974 42a4 F314DAE5 		ldrb	r1, [r10, #1267]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 7975              		.loc 1 1016 0
 7976 42a8 F424DAE5 		ldrb	r2, [r10, #1268]	@ zero_extendqisi2
 7977 42ac 22FAFFEA 		b	.L667
 7978              	.LVL878:
 7979              	.L398:
 7980              	.LBE170:
 7981              	.LBE311:
 7982              	.LBB312:
 7983              	.LBB190:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 7984              		.loc 1 1015 0
 7985 42b0 5315DAE5 		ldrb	r1, [r10, #1363]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 7986              		.loc 1 1016 0
 7987 42b4 5425DAE5 		ldrb	r2, [r10, #1364]	@ zero_extendqisi2
 7988 42b8 1FFAFFEA 		b	.L667
 7989              	.LVL879:
 7990              	.L409:
 7991              	.LBE190:
 7992              	.LBE312:
 7993              	.LBB313:
 7994              	.LBB182:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 7995              		.loc 1 1015 0
 7996 42bc 882D1FE5 		ldr	r2, .L720+112
 7997 42c0 6B15D2E5 		ldrb	r1, [r2, #1387]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 7998              		.loc 1 1016 0
 7999 42c4 6C25D2E5 		ldrb	r2, [r2, #1388]	@ zero_extendqisi2
 8000 42c8 1BFAFFEA 		b	.L667
 8001              	.LVL880:
 8002              	.L367:
 8003              	.LBE182:
 8004              	.LBE313:
 8005              	.LBB314:
 8006              	.LBB210:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8007              		.loc 1 1042 0
 8008 42cc 98CD1FE5 		ldr	ip, .L720+112
 8009 42d0 1135DCE5 		ldrb	r3, [ip, #1297]	@ zero_extendqisi2
 8010 42d4 C9FFFFEA 		b	.L684
 8011              	.LVL881:
 8012              	.L413:
 8013              	.LBE210:
 8014              	.LBE314:
 8015              	.LBB315:
 8016              	.LBB183:
 8017 42d8 7135DAE5 		ldrb	r3, [r10, #1393]	@ zero_extendqisi2
 8018 42dc C7FFFFEA 		b	.L684
 8019              	.LVL882:
 8020              	.L356:
 8021              	.LBE183:
 8022              	.LBE315:
 8023              	.LBB316:
 8024              	.LBB171:
 8025 42e0 F934DAE5 		ldrb	r3, [r10, #1273]	@ zero_extendqisi2
 8026 42e4 C5FFFFEA 		b	.L684
 8027              	.LVL883:
 8028              	.L389:
 8029              	.LBE171:
 8030              	.LBE316:
 8031              	.LBB317:
 8032              	.LBB238:
 8033 42e8 B4ED1FE5 		ldr	lr, .L720+112
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8034              		.loc 1 1043 0
 8035 42ec 0100A0E3 		mov	r0, #1
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8036              		.loc 1 1042 0
 8037 42f0 4135DEE5 		ldrb	r3, [lr, #1345]	@ zero_extendqisi2
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8038              		.loc 1 1043 0
 8039 42f4 BC1D1FE5 		ldr	r1, .L720+116
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8040              		.loc 1 1042 0
 8041 42f8 9C30C9E5 		strb	r3, [r9, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8042              		.loc 1 1043 0
 8043 42fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8044              	.LVL884:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8045              		.loc 1 980 0
 8046 4300 FF20A0E3 		mov	r2, #255
 8047 4304 0230A0E1 		mov	r3, r2
1044:../uvc.c      **** 			  Len = 1;
 8048              		.loc 1 1044 0
 8049 4308 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 8050              	.LVL885:
1045:../uvc.c      **** 			  break;
 8051              		.loc 1 1045 0
 8052 430c 0170A0E3 		mov	r7, #1
 8053 4310 45FBFFEA 		b	.L391
 8054              	.LVL886:
 8055              	.L341:
 8056              	.LBE238:
 8057              	.LBE317:
 8058              	.LBB318:
 8059              	.LBB220:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8060              		.loc 1 1042 0
 8061 4314 E134DAE5 		ldrb	r3, [r10, #1249]	@ zero_extendqisi2
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8062              		.loc 1 1043 0
 8063 4318 0100A0E3 		mov	r0, #1
 8064 431c E41D1FE5 		ldr	r1, .L720+116
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8065              		.loc 1 1042 0
 8066 4320 9C30C9E5 		strb	r3, [r9, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8067              		.loc 1 1043 0
 8068 4324 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8069              	.LVL887:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8070              		.loc 1 980 0
 8071 4328 FF20A0E3 		mov	r2, #255
 8072 432c 0230A0E1 		mov	r3, r2
1044:../uvc.c      **** 			  Len = 1;
 8073              		.loc 1 1044 0
 8074 4330 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 8075              	.LVL888:
1045:../uvc.c      **** 			  break;
 8076              		.loc 1 1045 0
 8077 4334 0160A0E3 		mov	r6, #1
 8078 4338 FAFAFFEA 		b	.L343
 8079              	.LVL889:
 8080              	.L303:
 8081              	.LBE220:
 8082              	.LBE318:
 8083              	.LBB319:
 8084              	.LBB229:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8085              		.loc 1 1042 0
 8086 433c 9934DAE5 		ldrb	r3, [r10, #1177]	@ zero_extendqisi2
 8087 4340 AEFFFFEA 		b	.L684
 8088              	.LVL890:
 8089              	.L314:
 8090              	.LBE229:
 8091              	.LBE319:
 8092              	.LBB320:
 8093              	.LBB161:
 8094 4344 B134DAE5 		ldrb	r3, [r10, #1201]	@ zero_extendqisi2
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8095              		.loc 1 980 0
 8096 4348 FFC0A0E3 		mov	ip, #255
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8097              		.loc 1 1043 0
 8098 434c 0100A0E3 		mov	r0, #1
 8099 4350 181E1FE5 		ldr	r1, .L720+116
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8100              		.loc 1 1042 0
 8101 4354 9C30C9E5 		strb	r3, [r9, #156]
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8102              		.loc 1 1043 0
 8103 4358 24C08DE5 		str	ip, [sp, #36]
 8104 435c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8105              	.LVL891:
1045:../uvc.c      **** 			  break;
 8106              		.loc 1 1045 0
 8107 4360 0130A0E3 		mov	r3, #1
 8108 4364 30308DE5 		str	r3, [sp, #48]
 8109              	.LVL892:
1044:../uvc.c      **** 			  Len = 1;
 8110              		.loc 1 1044 0
 8111 4368 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 8112              	.LVL893:
 8113 436c 24C09DE5 		ldr	ip, [sp, #36]
 8114 4370 79F9FFEA 		b	.L316
 8115              	.LVL894:
 8116              	.L402:
 8117              	.LBE161:
 8118              	.LBE320:
 8119              	.LBB321:
 8120              	.LBB191:
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 8121              		.loc 1 1042 0
 8122 4374 5935DAE5 		ldrb	r3, [r10, #1369]	@ zero_extendqisi2
 8123 4378 A0FFFFEA 		b	.L684
 8124              	.LVL895:
 8125              	.L363:
 8126              	.LBE191:
 8127              	.LBE321:
 8128              	.LBB322:
 8129              	.LBB211:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8130              		.loc 1 1015 0
 8131 437c 48CE1FE5 		ldr	ip, .L720+112
 8132 4380 0B15DCE5 		ldrb	r1, [ip, #1291]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8133              		.loc 1 1016 0
 8134 4384 0C25DCE5 		ldrb	r2, [ip, #1292]	@ zero_extendqisi2
 8135 4388 EBF9FFEA 		b	.L667
 8136              	.LVL896:
 8137              	.L420:
 8138              	.LBE211:
 8139              	.LBE322:
 8140              	.LBB323:
 8141              	.LBB200:
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 8142              		.loc 1 1015 0
 8143 438c 8305DAE5 		ldrb	r0, [r10, #1411]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 8144              		.loc 1 1016 0
 8145 4390 8415DAE5 		ldrb	r1, [r10, #1412]	@ zero_extendqisi2
 8146 4394 7DFAFFEA 		b	.L669
 8147              	.LVL897:
 8148              	.L382:
 8149              	.LBE200:
 8150              	.LBE323:
 8151              	.LBB324:
 8152              	.LBB239:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8153              		.loc 1 1024 0
 8154 4398 643E1FE5 		ldr	r3, .L720+112
 8155 439c 3D15D3E5 		ldrb	r1, [r3, #1341]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8156              		.loc 1 1025 0
 8157 43a0 3E25D3E5 		ldrb	r2, [r3, #1342]	@ zero_extendqisi2
 8158 43a4 15FBFFEA 		b	.L665
 8159              	.LVL898:
 8160              	.L714:
 8161              	.LBE239:
 8162              	.LBE324:
 8163              	.LBE346:
 8164              	.LBE438:
 8165              	.LBB439:
 8166              	.LBB142:
3237:../uvc.c      ****                             }
 8167              		.loc 1 3237 0
 8168 43a8 781E1FE5 		ldr	r1, .L720+108
 8169 43ac 0400A0E3 		mov	r0, #4
 8170              	.LVL899:
 8171 43b0 FEFFFFEB 		bl	CyU3PDebugPrint
 8172              	.LVL900:
 8173 43b4 60FBFFEA 		b	.L550
 8174              	.LVL901:
 8175              	.L395:
 8176              	.LBE142:
 8177              	.LBE439:
 8178              	.LBB440:
 8179              	.LBB347:
 8180              	.LBB325:
 8181              	.LBB192:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8182              		.loc 1 1024 0
 8183 43b8 84EE1FE5 		ldr	lr, .L720+112
 8184 43bc 5515DEE5 		ldrb	r1, [lr, #1365]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8185              		.loc 1 1025 0
 8186 43c0 5625DEE5 		ldrb	r2, [lr, #1366]	@ zero_extendqisi2
 8187 43c4 DCF9FFEA 		b	.L667
 8188              	.LVL902:
 8189              	.L387:
 8190              	.LBE192:
 8191              	.LBE325:
 8192              	.LBB326:
 8193              	.LBB240:
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8194              		.loc 1 991 0
 8195 43c8 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8196              		.loc 1 992 0
 8197 43cc 0200A0E3 		mov	r0, #2
 8198 43d0 981E1FE5 		ldr	r1, .L720+116
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8199              		.loc 1 991 0
 8200 43d4 9D30C9E5 		strb	r3, [r9, #157]
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8201              		.loc 1 990 0
 8202 43d8 9C70C9E5 		strb	r7, [r9, #156]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8203              		.loc 1 992 0
 8204 43dc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8205              	.LVL903:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8206              		.loc 1 980 0
 8207 43e0 FF20A0E3 		mov	r2, #255
 8208 43e4 0230A0E1 		mov	r3, r2
 993:../uvc.c      **** 			  break;
 8209              		.loc 1 993 0
 8210 43e8 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 8211              	.LVL904:
 8212 43ec 0EFBFFEA 		b	.L391
 8213              	.LVL905:
 8214              	.L349:
 8215              	.LBE240:
 8216              	.LBE326:
 8217              	.LBB327:
 8218              	.LBB172:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8219              		.loc 1 1024 0
 8220 43f0 BC2E1FE5 		ldr	r2, .L720+112
 8221 43f4 F514D2E5 		ldrb	r1, [r2, #1269]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8222              		.loc 1 1025 0
 8223 43f8 F624D2E5 		ldrb	r2, [r2, #1270]	@ zero_extendqisi2
 8224 43fc CEF9FFEA 		b	.L667
 8225              	.LVL906:
 8226              	.L307:
 8227              	.LBE172:
 8228              	.LBE327:
 8229              	.LBB328:
 8230              	.LBB162:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8231              		.loc 1 1024 0
 8232 4400 CC2E1FE5 		ldr	r2, .L720+112
 8233 4404 AD14D2E5 		ldrb	r1, [r2, #1197]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8234              		.loc 1 1025 0
 8235 4408 AE24D2E5 		ldrb	r2, [r2, #1198]	@ zero_extendqisi2
 8236 440c 47F9FFEA 		b	.L657
 8237              	.L312:
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8238              		.loc 1 990 0
 8239 4410 30C09DE5 		ldr	ip, [sp, #48]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8240              		.loc 1 991 0
 8241 4414 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8242              		.loc 1 992 0
 8243 4418 0200A0E3 		mov	r0, #2
 8244 441c E41E1FE5 		ldr	r1, .L720+116
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8245              		.loc 1 990 0
 8246 4420 9CC0C9E5 		strb	ip, [r9, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8247              		.loc 1 991 0
 8248 4424 9D30C9E5 		strb	r3, [r9, #157]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8249              		.loc 1 992 0
 8250 4428 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8251              	.LVL907:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8252              		.loc 1 980 0
 8253 442c FFC0A0E3 		mov	ip, #255
 993:../uvc.c      **** 			  break;
 8254              		.loc 1 993 0
 8255 4430 9C70D9E5 		ldrb	r7, [r9, #156]	@ zero_extendqisi2
 8256              	.LVL908:
 8257 4434 30309DE5 		ldr	r3, [sp, #48]
 8258 4438 47F9FFEA 		b	.L316
 8259              	.LVL909:
 8260              	.L296:
 8261              	.LBE162:
 8262              	.LBE328:
 8263              	.LBB329:
 8264              	.LBB230:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8265              		.loc 1 1024 0
 8266 443c 083F1FE5 		ldr	r3, .L720+112
 8267 4440 9514D3E5 		ldrb	r1, [r3, #1173]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8268              		.loc 1 1025 0
 8269 4444 9624D3E5 		ldrb	r2, [r3, #1174]	@ zero_extendqisi2
 8270 4448 BBF9FFEA 		b	.L667
 8271              	.LVL910:
 8272              	.L371:
 8273              	.LBE230:
 8274              	.LBE329:
 8275              	.LBB330:
 8276              	.LBB258:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8277              		.loc 1 1024 0
 8278 444c 183F1FE5 		ldr	r3, .L720+112
 8279 4450 2515D3E5 		ldrb	r1, [r3, #1317]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8280              		.loc 1 1025 0
 8281 4454 2625D3E5 		ldrb	r2, [r3, #1318]	@ zero_extendqisi2
 8282 4458 B7F9FFEA 		b	.L667
 8283              	.LVL911:
 8284              	.L360:
 8285              	.LBE258:
 8286              	.LBE330:
 8287              	.LBB331:
 8288              	.LBB212:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8289              		.loc 1 1024 0
 8290 445c 28EF1FE5 		ldr	lr, .L720+112
 8291 4460 0D15DEE5 		ldrb	r1, [lr, #1293]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8292              		.loc 1 1025 0
 8293 4464 0E25DEE5 		ldrb	r2, [lr, #1294]	@ zero_extendqisi2
 8294 4468 B3F9FFEA 		b	.L667
 8295              	.LVL912:
 8296              	.L417:
 8297              	.LBE212:
 8298              	.LBE331:
 8299              	.LBB332:
 8300              	.LBB201:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8301              		.loc 1 1024 0
 8302 446c 381F1FE5 		ldr	r1, .L720+112
 8303 4470 8505D1E5 		ldrb	r0, [r1, #1413]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8304              		.loc 1 1025 0
 8305 4474 8615D1E5 		ldrb	r1, [r1, #1414]	@ zero_extendqisi2
 8306 4478 44FAFFEA 		b	.L669
 8307              	.L422:
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8308              		.loc 1 990 0
 8309 447c 30C09DE5 		ldr	ip, [sp, #48]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8310              		.loc 1 991 0
 8311 4480 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8312              		.loc 1 992 0
 8313 4484 0200A0E3 		mov	r0, #2
 8314 4488 501F1FE5 		ldr	r1, .L720+116
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8315              		.loc 1 980 0
 8316 448c FF70A0E3 		mov	r7, #255
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8317              		.loc 1 990 0
 8318 4490 9CC0C9E5 		strb	ip, [r9, #156]
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8319              		.loc 1 991 0
 8320 4494 9D30C9E5 		strb	r3, [r9, #157]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8321              		.loc 1 992 0
 8322 4498 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8323              	.LVL913:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8324              		.loc 1 980 0
 8325 449c 07C0A0E1 		mov	ip, r7
 993:../uvc.c      **** 			  break;
 8326              		.loc 1 993 0
 8327 44a0 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 8328              	.LVL914:
 8329 44a4 30209DE5 		ldr	r2, [sp, #48]
 8330 44a8 45FAFFEA 		b	.L426
 8331              	.LVL915:
 8332              	.L323:
 8333              	.LBE201:
 8334              	.LBE332:
 8335              	.LBB333:
 8336              	.LBB250:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8337              		.loc 1 1024 0
 8338 44ac 782F1FE5 		ldr	r2, .L720+112
 8339 44b0 C514D2E5 		ldrb	r1, [r2, #1221]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8340              		.loc 1 1025 0
 8341 44b4 C624D2E5 		ldrb	r2, [r2, #1222]	@ zero_extendqisi2
 8342 44b8 9FF9FFEA 		b	.L667
 8343              	.LVL916:
 8344              	.L406:
 8345              	.LBE250:
 8346              	.LBE333:
 8347              	.LBB334:
 8348              	.LBB184:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8349              		.loc 1 1024 0
 8350 44bc 883F1FE5 		ldr	r3, .L720+112
 8351 44c0 6D15D3E5 		ldrb	r1, [r3, #1389]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8352              		.loc 1 1025 0
 8353 44c4 6E25D3E5 		ldrb	r2, [r3, #1390]	@ zero_extendqisi2
 8354 44c8 9BF9FFEA 		b	.L667
 8355              	.LVL917:
 8356              	.L334:
 8357              	.LBE184:
 8358              	.LBE334:
 8359              	.LBB335:
 8360              	.LBB221:
1024:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8361              		.loc 1 1024 0
 8362 44cc 983F1FE5 		ldr	r3, .L720+112
 8363 44d0 DD14D3E5 		ldrb	r1, [r3, #1245]	@ zero_extendqisi2
1025:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8364              		.loc 1 1025 0
 8365 44d4 DE24D3E5 		ldrb	r2, [r3, #1246]	@ zero_extendqisi2
 8366 44d8 87FAFFEA 		b	.L661
 8367              	.L339:
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8368              		.loc 1 991 0
 8369 44dc 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8370              		.loc 1 992 0
 8371 44e0 0200A0E3 		mov	r0, #2
 8372 44e4 AC1F1FE5 		ldr	r1, .L720+116
 991:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8373              		.loc 1 991 0
 8374 44e8 9D30C9E5 		strb	r3, [r9, #157]
 990:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8375              		.loc 1 990 0
 8376 44ec 9C60C9E5 		strb	r6, [r9, #156]
 992:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8377              		.loc 1 992 0
 8378 44f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8379              	.LVL918:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8380              		.loc 1 980 0
 8381 44f4 FF20A0E3 		mov	r2, #255
 8382 44f8 0230A0E1 		mov	r3, r2
 993:../uvc.c      **** 			  break;
 8383              		.loc 1 993 0
 8384 44fc 9CC0D9E5 		ldrb	ip, [r9, #156]	@ zero_extendqisi2
 8385              	.LVL919:
 8386 4500 88FAFFEA 		b	.L343
 8387              	.LVL920:
 8388              	.L526:
 8389              	.LBE221:
 8390              	.LBE335:
 8391              	.LBE347:
 8392              	.LBE440:
 8393              	.LBB441:
 8394              	.LBB143:
3034:../uvc.c      ****                          		CyU3PThreadSleep(500);
 8395              		.loc 1 3034 0
 8396 4504 0620A0E1 		mov	r2, r6
 8397 4508 3010A0E3 		mov	r1, #48
 8398 450c 5230A0E3 		mov	r3, #82
 8399 4510 0B00A0E3 		mov	r0, #11
 8400              	.LVL921:
 8401 4514 FEFFFFEB 		bl	SensorSetIrisControl
 8402              	.LVL922:
3035:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
 8403              		.loc 1 3035 0
 8404 4518 7D0FA0E3 		mov	r0, #500
 8405 451c FEFFFFEB 		bl	_tx_thread_sleep
 8406              	.LVL923:
3036:../uvc.c      ****                          		break;
 8407              		.loc 1 3036 0
 8408 4520 0620A0E1 		mov	r2, r6
 8409 4524 E81F1FE5 		ldr	r1, .L720+120
 8410 4528 0B30A0E3 		mov	r3, #11
 8411 452c 0400A0E3 		mov	r0, #4
 8412 4530 FEFFFFEB 		bl	CyU3PDebugPrint
 8413              	.LVL924:
 8414 4534 18FBFFEA 		b	.L525
 8415              	.LVL925:
 8416              	.L488:
 8417              	.LBE143:
 8418              	.LBE441:
 8419              	.LBB442:
 8420              	.LBB414:
 8421              	.LBB393:
 8422              	.LBB372:
 957:../uvc.c      **** 			  break;
 8423              		.loc 1 957 0
 8424 4538 0000A0E3 		mov	r0, #0
 8425 453c 0020A0E1 		mov	r2, r0
 8426 4540 0110A0E3 		mov	r1, #1
 8427 4544 FEFFFFEB 		bl	CyU3PUsbStall
 8428              	.LVL926:
 8429              	.L676:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8430              		.loc 1 414 0
 8431 4548 FF70A0E3 		mov	r7, #255
 8432              	.LVL927:
 8433 454c 0720A0E1 		mov	r2, r7
 8434 4550 30708DE5 		str	r7, [sp, #48]
 8435 4554 07C0A0E1 		mov	ip, r7
 8436 4558 0730A0E1 		mov	r3, r7
 8437 455c 6DFDFFEA 		b	.L498
 8438              	.LVL928:
 8439              	.L457:
 8440              	.LBE372:
 8441              	.LBE393:
 8442              	.LBB394:
 8443              	.LBB381:
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8444              		.loc 1 612 0
 8445 4560 44159FE5 		ldr	r1, .L722
 8446 4564 5524D1E5 		ldrb	r2, [r1, #1109]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 8447              		.loc 1 613 0
 8448 4568 5634D1E5 		ldrb	r3, [r1, #1110]	@ zero_extendqisi2
 8449 456c 99FBFFEA 		b	.L671
 8450              	.LVL929:
 8451              	.L470:
 8452              	.LBE381:
 8453              	.LBE394:
 8454              	.LBB395:
 8455              	.LBB363:
 612:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 8456              		.loc 1 612 0
 8457 4570 34E59FE5 		ldr	lr, .L722
 8458 4574 6D24DEE5 		ldrb	r2, [lr, #1133]	@ zero_extendqisi2
 613:../uvc.c      **** 			 }
 8459              		.loc 1 613 0
 8460 4578 6E34DEE5 		ldrb	r3, [lr, #1134]	@ zero_extendqisi2
 8461 457c 36FBFFEA 		b	.L673
 8462              	.LVL930:
 8463              	.L491:
 8464              	.LBE363:
 8465              	.LBE395:
 8466              	.LBB396:
 8467              	.LBB373:
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 8468              		.loc 1 443 0
 8469 4580 8520DAE5 		ldrb	r2, [r10, #133]	@ zero_extendqisi2
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 8470              		.loc 1 444 0
 8471 4584 8670DAE5 		ldrb	r7, [r10, #134]	@ zero_extendqisi2
 575:../uvc.c      **** 
 8472              		.loc 1 575 0
 8473 4588 0C00A0E1 		mov	r0, ip
 8474 458c 1C159FE5 		ldr	r1, .L722+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8475              		.loc 1 414 0
 8476 4590 FFC0A0E3 		mov	ip, #255
 8477 4594 30C08DE5 		str	ip, [sp, #48]
 443:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 8478              		.loc 1 443 0
 8479 4598 9C20C9E5 		strb	r2, [r9, #156]
 575:../uvc.c      **** 
 8480              		.loc 1 575 0
 8481 459c 2C208DE5 		str	r2, [sp, #44]
 444:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 8482              		.loc 1 444 0
 8483 45a0 9D70C9E5 		strb	r7, [r9, #157]
 8484              	.LVL931:
 575:../uvc.c      **** 
 8485              		.loc 1 575 0
 8486 45a4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8487              	.LVL932:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8488              		.loc 1 414 0
 8489 45a8 30C09DE5 		ldr	ip, [sp, #48]
 8490 45ac 2C209DE5 		ldr	r2, [sp, #44]
 8491 45b0 0C30A0E1 		mov	r3, ip
 8492 45b4 57FDFFEA 		b	.L498
 8493              	.LVL933:
 8494              	.L475:
 8495              	.LBE373:
 8496              	.LBE396:
 8497              	.LBB397:
 8498              	.LBB364:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8499              		.loc 1 431 0
 8500 45b8 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8501              		.loc 1 432 0
 8502 45bc 0200A0E3 		mov	r0, #2
 8503 45c0 E8149FE5 		ldr	r1, .L722+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8504              		.loc 1 414 0
 8505 45c4 FF70A0E3 		mov	r7, #255
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8506              		.loc 1 430 0
 8507 45c8 9C60C9E5 		strb	r6, [r9, #156]
 8508 45cc 26FBFFEA 		b	.L672
 8509              	.LVL934:
 8510              	.L459:
 8511              	.LBE364:
 8512              	.LBE397:
 8513              	.LBB398:
 8514              	.LBB382:
 559:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 8515              		.loc 1 559 0
 8516 45d0 4A20D9E5 		ldrb	r2, [r9, #74]	@ zero_extendqisi2
 8517 45d4 000052E3 		cmp	r2, #0
 8518 45d8 2101000A 		beq	.L719
 8519              	.LVL935:
 8520              	.L467:
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8521              		.loc 1 569 0
 8522 45dc 5D34DAE5 		ldrb	r3, [r10, #1117]	@ zero_extendqisi2
 575:../uvc.c      **** 
 8523              		.loc 1 575 0
 8524 45e0 0600A0E1 		mov	r0, r6
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 8525              		.loc 1 570 0
 8526 45e4 0020A0E3 		mov	r2, #0
 575:../uvc.c      **** 
 8527              		.loc 1 575 0
 8528 45e8 C0149FE5 		ldr	r1, .L722+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8529              		.loc 1 414 0
 8530 45ec FF60A0E3 		mov	r6, #255
 8531              	.LVL936:
 569:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8532              		.loc 1 569 0
 8533 45f0 9C30C9E5 		strb	r3, [r9, #156]
 575:../uvc.c      **** 
 8534              		.loc 1 575 0
 8535 45f4 28308DE5 		str	r3, [sp, #40]
 570:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 8536              		.loc 1 570 0
 8537 45f8 9D20C9E5 		strb	r2, [r9, #157]
 8538              	.LVL937:
 575:../uvc.c      **** 
 8539              		.loc 1 575 0
 8540 45fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8541              	.LVL938:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8542              		.loc 1 414 0
 8543 4600 06C0A0E1 		mov	ip, r6
 8544 4604 28309DE5 		ldr	r3, [sp, #40]
 8545 4608 BAFDFFEA 		b	.L466
 8546              	.LVL939:
 8547              	.L476:
 8548              	.LBE382:
 8549              	.LBE398:
 8550              	.LBB399:
 8551              	.LBB365:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8552              		.loc 1 626 0
 8553 460c 6FC4DAE5 		ldrb	ip, [r10, #1135]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8554              		.loc 1 627 0
 8555 4610 7024DAE5 		ldrb	r2, [r10, #1136]	@ zero_extendqisi2
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8556              		.loc 1 628 0
 8557 4614 0030A0E3 		mov	r3, #0
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8558              		.loc 1 631 0
 8559 4618 0600A0E1 		mov	r0, r6
 8560 461c 8C149FE5 		ldr	r1, .L722+4
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8561              		.loc 1 626 0
 8562 4620 9CC0C9E5 		strb	ip, [r9, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8563              		.loc 1 414 0
 8564 4624 FF70A0E3 		mov	r7, #255
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8565              		.loc 1 627 0
 8566 4628 9D20C9E5 		strb	r2, [r9, #157]
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8567              		.loc 1 628 0
 8568 462c 9E30C9E5 		strb	r3, [r9, #158]
 629:../uvc.c      **** 		 	 }
 8569              		.loc 1 629 0
 8570 4630 9F30C9E5 		strb	r3, [r9, #159]
 8571 4634 0DFBFFEA 		b	.L674
 8572              	.LVL940:
 8573              	.L494:
 8574              	.LBE365:
 8575              	.LBE399:
 8576              	.LBB400:
 8577              	.LBB374:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8578              		.loc 1 431 0
 8579 4638 0020A0E3 		mov	r2, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8580              		.loc 1 432 0
 8581 463c 0200A0E3 		mov	r0, #2
 8582 4640 68149FE5 		ldr	r1, .L722+4
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8583              		.loc 1 414 0
 8584 4644 FF70A0E3 		mov	r7, #255
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8585              		.loc 1 430 0
 8586 4648 9CC0C9E5 		strb	ip, [r9, #156]
 8587 464c 37FBFFEA 		b	.L675
 8588              	.L495:
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 8589              		.loc 1 620 0
 8590 4650 7F30DAE5 		ldrb	r3, [r10, #127]	@ zero_extendqisi2
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 8591              		.loc 1 621 0
 8592 4654 80E0DAE5 		ldrb	lr, [r10, #128]	@ zero_extendqisi2
 622:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 8593              		.loc 1 622 0
 8594 4658 0020A0E3 		mov	r2, #0
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8595              		.loc 1 631 0
 8596 465c 0C00A0E1 		mov	r0, ip
 8597 4660 48149FE5 		ldr	r1, .L722+4
 620:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 8598              		.loc 1 620 0
 8599 4664 9C30C9E5 		strb	r3, [r9, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8600              		.loc 1 414 0
 8601 4668 FF70A0E3 		mov	r7, #255
 621:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 8602              		.loc 1 621 0
 8603 466c 9DE0C9E5 		strb	lr, [r9, #157]
 622:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 8604              		.loc 1 622 0
 8605 4670 9E20C9E5 		strb	r2, [r9, #158]
 623:../uvc.c      **** 		 	 }
 8606              		.loc 1 623 0
 8607 4674 9F20C9E5 		strb	r2, [r9, #159]
 8608 4678 2DFBFFEA 		b	.L678
 8609              	.LVL941:
 8610              	.L463:
 8611              	.LBE374:
 8612              	.LBE400:
 8613              	.LBB401:
 8614              	.LBB383:
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8615              		.loc 1 626 0
 8616 467c 28249FE5 		ldr	r2, .L722
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8617              		.loc 1 628 0
 8618 4680 0030A0E3 		mov	r3, #0
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8619              		.loc 1 626 0
 8620 4684 5714D2E5 		ldrb	r1, [r2, #1111]	@ zero_extendqisi2
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8621              		.loc 1 627 0
 8622 4688 5824D2E5 		ldrb	r2, [r2, #1112]	@ zero_extendqisi2
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8623              		.loc 1 631 0
 8624 468c 0600A0E1 		mov	r0, r6
 626:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 8625              		.loc 1 626 0
 8626 4690 9C10C9E5 		strb	r1, [r9, #156]
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8627              		.loc 1 414 0
 8628 4694 FF60A0E3 		mov	r6, #255
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8629              		.loc 1 631 0
 8630 4698 10149FE5 		ldr	r1, .L722+4
 628:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8631              		.loc 1 628 0
 8632 469c 9E30C9E5 		strb	r3, [r9, #158]
 629:../uvc.c      **** 		 	 }
 8633              		.loc 1 629 0
 8634 46a0 9F30C9E5 		strb	r3, [r9, #159]
 627:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 8635              		.loc 1 627 0
 8636 46a4 9D20C9E5 		strb	r2, [r9, #157]
 631:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8637              		.loc 1 631 0
 8638 46a8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8639              	.LVL942:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8640              		.loc 1 414 0
 8641 46ac 06C0A0E1 		mov	ip, r6
 632:../uvc.c      **** 			  break;
 8642              		.loc 1 632 0
 8643 46b0 9C30D9E5 		ldrb	r3, [r9, #156]	@ zero_extendqisi2
 8644              	.LVL943:
 8645 46b4 8FFDFFEA 		b	.L466
 8646              	.LVL944:
 8647              	.L462:
 431:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 8648              		.loc 1 431 0
 8649 46b8 0030A0E3 		mov	r3, #0
 432:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8650              		.loc 1 432 0
 8651 46bc 0200A0E3 		mov	r0, #2
 8652 46c0 E8139FE5 		ldr	r1, .L722+4
 430:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 8653              		.loc 1 430 0
 8654 46c4 9C60C9E5 		strb	r6, [r9, #156]
 8655 46c8 45FBFFEA 		b	.L670
 8656              	.LVL945:
 8657              	.L489:
 8658              	.LBE383:
 8659              	.LBE401:
 8660              	.LBB402:
 8661              	.LBB375:
 602:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 8662              		.loc 1 602 0
 8663 46cc D8139FE5 		ldr	r1, .L722
 8664 46d0 7DE0D1E5 		ldrb	lr, [r1, #125]	@ zero_extendqisi2
 603:../uvc.c      **** 		 	 }
 8665              		.loc 1 603 0
 8666 46d4 7E20D1E5 		ldrb	r2, [r1, #126]	@ zero_extendqisi2
 8667 46d8 10FBFFEA 		b	.L677
 8668              	.LVL946:
 8669              	.L469:
 8670              	.LBE375:
 8671              	.LBE402:
 8672              	.LBB403:
 8673              	.LBB366:
 957:../uvc.c      **** 			  break;
 8674              		.loc 1 957 0
 8675 46dc 0000A0E3 		mov	r0, #0
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8676              		.loc 1 414 0
 8677 46e0 FF70A0E3 		mov	r7, #255
 957:../uvc.c      **** 			  break;
 8678              		.loc 1 957 0
 8679 46e4 0020A0E1 		mov	r2, r0
 8680 46e8 0110A0E3 		mov	r1, #1
 8681 46ec FEFFFFEB 		bl	CyU3PUsbStall
 8682              	.LVL947:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8683              		.loc 1 414 0
 8684 46f0 07C0A0E1 		mov	ip, r7
 8685 46f4 0720A0E1 		mov	r2, r7
 8686 46f8 0730A0E1 		mov	r3, r7
 8687 46fc 4FFDFFEA 		b	.L479
 8688              	.LVL948:
 8689              	.L472:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8690              		.loc 1 464 0
 8691 4700 000056E3 		cmp	r6, #0
 8692 4704 2C00000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8693              		.loc 1 465 0
 8694 4708 9030D9E5 		ldrb	r3, [r9, #144]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8695              		.loc 1 464 0
 8696 470c 010056E3 		cmp	r6, #1
 465:../uvc.c      **** 			 		 }
 8697              		.loc 1 465 0
 8698 4710 9C30C9E5 		strb	r3, [r9, #156]
 8699              	.LVL949:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8700              		.loc 1 464 0
 8701 4714 2800009A 		bls	.L481
 465:../uvc.c      **** 			 		 }
 8702              		.loc 1 465 0
 8703 4718 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8704              		.loc 1 464 0
 8705 471c 020056E3 		cmp	r6, #2
 465:../uvc.c      **** 			 		 }
 8706              		.loc 1 465 0
 8707 4720 9D30C4E5 		strb	r3, [r4, #157]
 8708              	.LVL950:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8709              		.loc 1 464 0
 8710 4724 2400000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8711              		.loc 1 465 0
 8712 4728 9230D4E5 		ldrb	r3, [r4, #146]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8713              		.loc 1 464 0
 8714 472c 030056E3 		cmp	r6, #3
 465:../uvc.c      **** 			 		 }
 8715              		.loc 1 465 0
 8716 4730 9E30C4E5 		strb	r3, [r4, #158]
 8717              	.LVL951:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8718              		.loc 1 464 0
 8719 4734 2000000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8720              		.loc 1 465 0
 8721 4738 9330D4E5 		ldrb	r3, [r4, #147]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8722              		.loc 1 464 0
 8723 473c 040056E3 		cmp	r6, #4
 465:../uvc.c      **** 			 		 }
 8724              		.loc 1 465 0
 8725 4740 9F30C4E5 		strb	r3, [r4, #159]
 8726              	.LVL952:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8727              		.loc 1 464 0
 8728 4744 1C00000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8729              		.loc 1 465 0
 8730 4748 9430D4E5 		ldrb	r3, [r4, #148]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8731              		.loc 1 464 0
 8732 474c 050056E3 		cmp	r6, #5
 465:../uvc.c      **** 			 		 }
 8733              		.loc 1 465 0
 8734 4750 A030C4E5 		strb	r3, [r4, #160]
 8735              	.LVL953:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8736              		.loc 1 464 0
 8737 4754 1800000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8738              		.loc 1 465 0
 8739 4758 9530D4E5 		ldrb	r3, [r4, #149]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8740              		.loc 1 464 0
 8741 475c 060056E3 		cmp	r6, #6
 465:../uvc.c      **** 			 		 }
 8742              		.loc 1 465 0
 8743 4760 A130C4E5 		strb	r3, [r4, #161]
 8744              	.LVL954:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8745              		.loc 1 464 0
 8746 4764 1400000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8747              		.loc 1 465 0
 8748 4768 9630D4E5 		ldrb	r3, [r4, #150]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8749              		.loc 1 464 0
 8750 476c 070056E3 		cmp	r6, #7
 465:../uvc.c      **** 			 		 }
 8751              		.loc 1 465 0
 8752 4770 A230C4E5 		strb	r3, [r4, #162]
 8753              	.LVL955:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8754              		.loc 1 464 0
 8755 4774 1000000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8756              		.loc 1 465 0
 8757 4778 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8758              		.loc 1 464 0
 8759 477c 080056E3 		cmp	r6, #8
 465:../uvc.c      **** 			 		 }
 8760              		.loc 1 465 0
 8761 4780 A330C4E5 		strb	r3, [r4, #163]
 8762              	.LVL956:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8763              		.loc 1 464 0
 8764 4784 0C00000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8765              		.loc 1 465 0
 8766 4788 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8767              		.loc 1 464 0
 8768 478c 090056E3 		cmp	r6, #9
 465:../uvc.c      **** 			 		 }
 8769              		.loc 1 465 0
 8770 4790 A430C4E5 		strb	r3, [r4, #164]
 8771              	.LVL957:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8772              		.loc 1 464 0
 8773 4794 0800000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8774              		.loc 1 465 0
 8775 4798 9930D9E5 		ldrb	r3, [r9, #153]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8776              		.loc 1 464 0
 8777 479c 0A0056E3 		cmp	r6, #10
 465:../uvc.c      **** 			 		 }
 8778              		.loc 1 465 0
 8779 47a0 A530C9E5 		strb	r3, [r9, #165]
 8780              	.LVL958:
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8781              		.loc 1 464 0
 8782 47a4 0400000A 		beq	.L481
 465:../uvc.c      **** 			 		 }
 8783              		.loc 1 465 0
 8784 47a8 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
 464:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 8785              		.loc 1 464 0
 8786 47ac 0B0056E3 		cmp	r6, #11
 465:../uvc.c      **** 			 		 }
 8787              		.loc 1 465 0
 8788 47b0 A630C4E5 		strb	r3, [r4, #166]
 8789              	.LVL959:
 8790 47b4 9B30D415 		ldrneb	r3, [r4, #155]	@ zero_extendqisi2
 8791 47b8 A730C415 		strneb	r3, [r4, #167]
 8792              	.LVL960:
 8793              	.L481:
 474:../uvc.c      **** 			 		 {
 8794              		.loc 1 474 0
 8795 47bc 9B30D9E5 		ldrb	r3, [r9, #155]	@ zero_extendqisi2
 467:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 8796              		.loc 1 467 0
 8797 47c0 A5C0D9E5 		ldrb	ip, [r9, #165]	@ zero_extendqisi2
 8798              	.LVL961:
 474:../uvc.c      **** 			 		 {
 8799              		.loc 1 474 0
 8800 47c4 FF0053E3 		cmp	r3, #255
 468:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8801              		.loc 1 468 0
 8802 47c8 A670D9E5 		ldrb	r7, [r9, #166]	@ zero_extendqisi2
 8803              	.LVL962:
 474:../uvc.c      **** 			 		 {
 8804              		.loc 1 474 0
 8805 47cc 0600000A 		beq	.L483
 476:../uvc.c      **** 			 		 }
 8806              		.loc 1 476 0
 8807 47d0 9920D4E5 		ldrb	r2, [r4, #153]	@ zero_extendqisi2
 8808 47d4 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
 8809 47d8 0400A0E3 		mov	r0, #4
 8810 47dc D0129FE5 		ldr	r1, .L722+8
 8811 47e0 24C08DE5 		str	ip, [sp, #36]
 8812 47e4 FEFFFFEB 		bl	CyU3PDebugPrint
 8813              	.LVL963:
 8814 47e8 24C09DE5 		ldr	ip, [sp, #36]
 8815              	.L483:
 8816              	.LVL964:
 575:../uvc.c      **** 
 8817              		.loc 1 575 0
 8818 47ec 0600A0E1 		mov	r0, r6
 8819 47f0 B8129FE5 		ldr	r1, .L722+4
 8820 47f4 24C08DE5 		str	ip, [sp, #36]
 8821 47f8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8822              	.LVL965:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8823              		.loc 1 414 0
 8824 47fc FF20A0E3 		mov	r2, #255
 8825 4800 0230A0E1 		mov	r3, r2
 8826 4804 24C09DE5 		ldr	ip, [sp, #36]
 8827 4808 0CFDFFEA 		b	.L479
 8828              	.LVL966:
 8829              	.L456:
 8830              	.LBE366:
 8831              	.LBE403:
 8832              	.LBB404:
 8833              	.LBB384:
 957:../uvc.c      **** 			  break;
 8834              		.loc 1 957 0
 8835 480c 0000A0E3 		mov	r0, #0
 8836 4810 0020A0E1 		mov	r2, r0
 8837 4814 0110A0E3 		mov	r1, #1
 8838 4818 FEFFFFEB 		bl	CyU3PUsbStall
 8839              	.LVL967:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8840              		.loc 1 414 0
 8841 481c FF30A0E3 		mov	r3, #255
 8842 4820 0360A0E1 		mov	r6, r3
 8843              	.LVL968:
 8844 4824 03C0A0E1 		mov	ip, r3
 8845 4828 32FDFFEA 		b	.L466
 8846              	.LVL969:
 8847              	.L344:
 8848              	.LBE384:
 8849              	.LBE404:
 8850              	.LBE414:
 8851              	.LBE442:
 8852              	.LBB443:
 8853              	.LBB348:
 8854              	.LBB336:
 8855              	.LBB222:
1143:../uvc.c      **** 					  }
 8856              		.loc 1 1143 0
 8857 482c 0000A0E3 		mov	r0, #0
 8858 4830 0020A0E1 		mov	r2, r0
 8859 4834 0110A0E3 		mov	r1, #1
 8860 4838 FEFFFFEB 		bl	CyU3PUsbStall
 8861              	.LVL970:
 8862 483c 43FCFFEA 		b	.L347
 8863              	.LVL971:
 8864              	.L392:
 8865              	.LBE222:
 8866              	.LBE336:
 8867              	.LBB337:
 8868              	.LBB241:
1161:../uvc.c      **** 					  }
 8869              		.loc 1 1161 0
 8870 4840 0020A0E1 		mov	r2, r0
 8871 4844 0610A0E1 		mov	r1, r6
 8872 4848 FEFFFFEB 		bl	CyU3PUsbStall
 8873              	.LVL972:
 8874 484c 70FCFFEA 		b	.L393
 8875              	.LVL973:
 8876              	.L321:
 8877              	.LBE241:
 8878              	.LBE337:
 8879              	.LBB338:
 8880              	.LBB163:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 8881              		.loc 1 1091 0
 8882 4850 60729FE5 		ldr	r7, .L722+12
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 8883              		.loc 1 1089 0
 8884 4854 0020A0E3 		mov	r2, #0
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 8885              		.loc 1 1091 0
 8886 4858 1C0097E5 		ldr	r0, [r7, #28]
 8887 485c 0010E0E3 		mvn	r1, #0
 8888 4860 24C08DE5 		str	ip, [sp, #36]
1089:../uvc.c      **** 			  		    	dataIdx = 0;
 8889              		.loc 1 1089 0
 8890 4864 0D23CAE5 		strb	r2, [r10, #781]
 8891              	.LVL974:
1091:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 8892              		.loc 1 1091 0
 8893 4868 28308DE5 		str	r3, [sp, #40]
 8894 486c FEFFFFEB 		bl	_txe_mutex_get
 8895              	.LVL975:
1092:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8896              		.loc 1 1092 0
 8897 4870 00E0A0E3 		mov	lr, #0
 8898 4874 00E08DE5 		str	lr, [sp]
 8899 4878 04E08DE5 		str	lr, [sp, #4]
 8900 487c 34209DE5 		ldr	r2, [sp, #52]
 8901 4880 28309DE5 		ldr	r3, [sp, #40]
 8902 4884 1010A0E3 		mov	r1, #16
 8903 4888 0700A0E1 		mov	r0, r7
 8904 488c FEFFFFEB 		bl	cmdSet
 8905              	.LVL976:
1093:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 8906              		.loc 1 1093 0
 8907 4890 1C0097E5 		ldr	r0, [r7, #28]
 8908 4894 FEFFFFEB 		bl	_txe_mutex_put
 8909              	.LVL977:
 8910              	.LBB148:
 8911              	.LBB149:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 8912              		.loc 1 390 0
 8913 4898 0010E0E3 		mvn	r1, #0
 8914 489c 1C0097E5 		ldr	r0, [r7, #28]
 8915 48a0 FEFFFFEB 		bl	_txe_mutex_get
 8916              	.LVL978:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 8917              		.loc 1 391 0
 8918 48a4 0130A0E3 		mov	r3, #1
 8919 48a8 0010A0E3 		mov	r1, #0
 8920 48ac 04108DE5 		str	r1, [sp, #4]
 8921 48b0 00308DE5 		str	r3, [sp]
 8922 48b4 0700A0E1 		mov	r0, r7
 8923 48b8 3030A0E3 		mov	r3, #48
 8924 48bc 2010A0E3 		mov	r1, #32
 8925 48c0 2720A0E3 		mov	r2, #39
 8926 48c4 FEFFFFEB 		bl	cmdSet
 8927              	.LVL979:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8928              		.loc 1 392 0
 8929 48c8 0230A0E3 		mov	r3, #2
 8930              	.LVL980:
 8931              	.L659:
 8932 48cc 0020A0E3 		mov	r2, #0
 8933 48d0 04208DE5 		str	r2, [sp, #4]
 8934              	.LVL981:
 8935              	.L658:
 8936 48d4 0700A0E1 		mov	r0, r7
 8937 48d8 00308DE5 		str	r3, [sp]
 8938 48dc 2110A0E3 		mov	r1, #33
 8939 48e0 3030A0E3 		mov	r3, #48
 8940 48e4 2520A0E3 		mov	r2, #37
 8941 48e8 FEFFFFEB 		bl	cmdSet
 8942              	.LVL982:
 393:../uvc.c      **** }
 8943              		.loc 1 393 0
 8944 48ec 1C0097E5 		ldr	r0, [r7, #28]
 8945 48f0 FEFFFFEB 		bl	_txe_mutex_put
 8946              	.LVL983:
 8947              	.LBE149:
 8948              	.LBE148:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8949              		.loc 1 980 0
 8950 48f4 FF70A0E3 		mov	r7, #255
 8951 48f8 24C09DE5 		ldr	ip, [sp, #36]
 8952 48fc 30309DE5 		ldr	r3, [sp, #48]
 8953 4900 15F8FFEA 		b	.L316
 8954              	.LVL984:
 8955              	.L320:
 8956              	.LBB150:
 8957              	.LBB151:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 8958              		.loc 1 390 0
 8959 4904 AC719FE5 		ldr	r7, .L722+12
 8960 4908 0010E0E3 		mvn	r1, #0
 8961 490c 1C0097E5 		ldr	r0, [r7, #28]
 8962 4910 24C08DE5 		str	ip, [sp, #36]
 8963 4914 FEFFFFEB 		bl	_txe_mutex_get
 8964              	.LVL985:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 8965              		.loc 1 391 0
 8966 4918 0030A0E3 		mov	r3, #0
 8967 491c 00308DE5 		str	r3, [sp]
 8968 4920 04308DE5 		str	r3, [sp, #4]
 8969 4924 0700A0E1 		mov	r0, r7
 8970 4928 3030A0E3 		mov	r3, #48
 8971 492c 2010A0E3 		mov	r1, #32
 8972 4930 2720A0E3 		mov	r2, #39
 8973 4934 FEFFFFEB 		bl	cmdSet
 8974              	.LVL986:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8975              		.loc 1 392 0
 8976 4938 00E0A0E3 		mov	lr, #0
 8977 493c 0130A0E3 		mov	r3, #1
 8978 4940 04E08DE5 		str	lr, [sp, #4]
 8979 4944 E2FFFFEA 		b	.L658
 8980              	.LVL987:
 8981              	.L319:
 8982              	.LBE151:
 8983              	.LBE150:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 8984              		.loc 1 1079 0
 8985 4948 68719FE5 		ldr	r7, .L722+12
1077:../uvc.c      **** 							dataIdx = 0;
 8986              		.loc 1 1077 0
 8987 494c 0020A0E3 		mov	r2, #0
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 8988              		.loc 1 1079 0
 8989 4950 1C0097E5 		ldr	r0, [r7, #28]
 8990 4954 0010E0E3 		mvn	r1, #0
 8991 4958 24C08DE5 		str	ip, [sp, #36]
1077:../uvc.c      **** 							dataIdx = 0;
 8992              		.loc 1 1077 0
 8993 495c 0D23CAE5 		strb	r2, [r10, #781]
 8994              	.LVL988:
1079:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 8995              		.loc 1 1079 0
 8996 4960 28308DE5 		str	r3, [sp, #40]
 8997 4964 FEFFFFEB 		bl	_txe_mutex_get
 8998              	.LVL989:
1080:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8999              		.loc 1 1080 0
 9000 4968 00E0A0E3 		mov	lr, #0
 9001 496c 00E08DE5 		str	lr, [sp]
 9002 4970 04E08DE5 		str	lr, [sp, #4]
 9003 4974 34209DE5 		ldr	r2, [sp, #52]
 9004 4978 28309DE5 		ldr	r3, [sp, #40]
 9005 497c 1010A0E3 		mov	r1, #16
 9006 4980 0700A0E1 		mov	r0, r7
 9007 4984 FEFFFFEB 		bl	cmdSet
 9008              	.LVL990:
1081:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 9009              		.loc 1 1081 0
 9010 4988 1C0097E5 		ldr	r0, [r7, #28]
 9011 498c FEFFFFEB 		bl	_txe_mutex_put
 9012              	.LVL991:
 9013              	.LBB152:
 9014              	.LBB153:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 9015              		.loc 1 390 0
 9016 4990 0010E0E3 		mvn	r1, #0
 9017 4994 1C0097E5 		ldr	r0, [r7, #28]
 9018 4998 FEFFFFEB 		bl	_txe_mutex_get
 9019              	.LVL992:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 9020              		.loc 1 391 0
 9021 499c 0010A0E3 		mov	r1, #0
 9022 49a0 00108DE5 		str	r1, [sp]
 9023 49a4 04108DE5 		str	r1, [sp, #4]
 9024 49a8 3030A0E3 		mov	r3, #48
 9025 49ac 0700A0E1 		mov	r0, r7
 9026 49b0 2010A0E3 		mov	r1, #32
 9027 49b4 2720A0E3 		mov	r2, #39
 9028 49b8 FEFFFFEB 		bl	cmdSet
 9029              	.LVL993:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9030              		.loc 1 392 0
 9031 49bc 0130A0E3 		mov	r3, #1
 9032 49c0 C1FFFFEA 		b	.L659
 9033              	.LVL994:
 9034              	.L317:
 9035              	.LBE153:
 9036              	.LBE152:
 9037              	.LBB154:
 9038              	.LBB155:
 390:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 9039              		.loc 1 390 0
 9040 49c4 EC709FE5 		ldr	r7, .L722+12
 9041 49c8 0010E0E3 		mvn	r1, #0
 9042 49cc 1C0097E5 		ldr	r0, [r7, #28]
 9043 49d0 24C08DE5 		str	ip, [sp, #36]
 9044 49d4 FEFFFFEB 		bl	_txe_mutex_get
 9045              	.LVL995:
 391:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 9046              		.loc 1 391 0
 9047 49d8 0130A0E3 		mov	r3, #1
 9048 49dc 00E0A0E3 		mov	lr, #0
 9049 49e0 00308DE5 		str	r3, [sp]
 9050 49e4 2010A0E3 		mov	r1, #32
 9051 49e8 3030A0E3 		mov	r3, #48
 9052 49ec 0700A0E1 		mov	r0, r7
 9053 49f0 04E08DE5 		str	lr, [sp, #4]
 9054 49f4 2720A0E3 		mov	r2, #39
 9055 49f8 FEFFFFEB 		bl	cmdSet
 9056              	.LVL996:
 392:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9057              		.loc 1 392 0
 9058 49fc 0010A0E3 		mov	r1, #0
 9059 4a00 0230A0E3 		mov	r3, #2
 9060 4a04 04108DE5 		str	r1, [sp, #4]
 9061 4a08 B1FFFFEA 		b	.L658
 9062              	.LVL997:
 9063              	.L560:
 9064              	.LBE155:
 9065              	.LBE154:
 980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9066              		.loc 1 980 0
 9067 4a0c FF70A0E3 		mov	r7, #255
 9068 4a10 30309DE5 		ldr	r3, [sp, #48]
 9069 4a14 D0F7FFEA 		b	.L316
 9070              	.LVL998:
 9071              	.L499:
 9072              	.LBE163:
 9073              	.LBE338:
 9074              	.LBE348:
 9075              	.LBE443:
 9076              	.LBB444:
 9077              	.LBB415:
 9078              	.LBB405:
 9079              	.LBB376:
 949:../uvc.c      **** 			   }
 9080              		.loc 1 949 0
 9081 4a18 9C109FE5 		ldr	r1, .L722+16
 9082 4a1c 0400A0E3 		mov	r0, #4
 9083              	.LVL999:
 9084 4a20 FEFFFFEB 		bl	CyU3PDebugPrint
 9085              	.LVL1000:
 9086 4a24 C7FEFFEA 		b	.L676
 9087              	.LVL1001:
 9088              	.L484:
 9089              	.LBE376:
 9090              	.LBE405:
 9091              	.LBB406:
 9092              	.LBB367:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9093              		.loc 1 414 0
 9094 4a28 FF70A0E3 		mov	r7, #255
 949:../uvc.c      **** 			   }
 9095              		.loc 1 949 0
 9096 4a2c 0400A0E3 		mov	r0, #4
 9097              	.LVL1002:
 9098 4a30 84109FE5 		ldr	r1, .L722+16
 9099 4a34 FEFFFFEB 		bl	CyU3PDebugPrint
 9100              	.LVL1003:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9101              		.loc 1 414 0
 9102 4a38 07C0A0E1 		mov	ip, r7
 9103 4a3c 0720A0E1 		mov	r2, r7
 9104 4a40 0730A0E1 		mov	r3, r7
 9105 4a44 7DFCFFEA 		b	.L479
 9106              	.LVL1004:
 9107              	.L468:
 9108              	.LBE367:
 9109              	.LBE406:
 9110              	.LBB407:
 9111              	.LBB385:
 949:../uvc.c      **** 			   }
 9112              		.loc 1 949 0
 9113 4a48 0400A0E3 		mov	r0, #4
 9114              	.LVL1005:
 9115 4a4c 68109FE5 		ldr	r1, .L722+16
 9116 4a50 FEFFFFEB 		bl	CyU3PDebugPrint
 9117              	.LVL1006:
 414:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9118              		.loc 1 414 0
 9119 4a54 FF30A0E3 		mov	r3, #255
 9120 4a58 0360A0E1 		mov	r6, r3
 9121              	.LVL1007:
 9122 4a5c 03C0A0E1 		mov	ip, r3
 9123 4a60 A4FCFFEA 		b	.L466
 9124              	.LVL1008:
 9125              	.L719:
 563:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 9126              		.loc 1 563 0
 9127 4a64 0310A0E1 		mov	r1, r3
 9128 4a68 30009DE5 		ldr	r0, [sp, #48]
 9129 4a6c FEFFFFEB 		bl	SensorGetControl
 9130              	.LVL1009:
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9131              		.loc 1 564 0
 9132 4a70 34C09FE5 		ldr	ip, .L722
 566:../uvc.c      **** 		 	 		 }
 9133              		.loc 1 566 0
 9134 4a74 0130A0E3 		mov	r3, #1
 9135 4a78 4A30C4E5 		strb	r3, [r4, #74]
 564:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 9136              		.loc 1 564 0
 9137 4a7c 5D04CCE5 		strb	r0, [ip, #1117]
 9138 4a80 D5FEFFEA 		b	.L467
 9139              	.LVL1010:
 9140              	.L718:
 9141              	.LBE385:
 9142              	.LBE407:
 9143              	.LBE415:
 9144              	.LBE444:
 9145              	.LBB445:
 9146              	.LBB349:
 9147              	.LBB339:
 9148              	.LBB202:
1174:../uvc.c      **** 					  else if(getData == 0xff)
 9149              		.loc 1 1174 0
 9150 4a84 0410A0E3 		mov	r1, #4
 9151 4a88 0000A0E3 		mov	r0, #0
 9152 4a8c 00108DE5 		str	r1, [sp]
 9153 4a90 04008DE5 		str	r0, [sp, #4]
 9154 4a94 34209DE5 		ldr	r2, [sp, #52]
 9155 4a98 18009FE5 		ldr	r0, .L722+12
 9156 4a9c 2310A0E3 		mov	r1, #35
 9157 4aa0 FEFFFFEB 		bl	cmdSet
 9158              	.LVL1011:
 9159 4aa4 24C09DE5 		ldr	ip, [sp, #36]
 9160 4aa8 1BFBFFEA 		b	.L428
 9161              	.L723:
 9162              		.align	2
 9163              	.L722:
 9164 4aac 00000000 		.word	.LANCHOR1
 9165 4ab0 9C000000 		.word	.LANCHOR0+156
 9166 4ab4 60020000 		.word	.LC13
 9167 4ab8 00000000 		.word	cmdQu
 9168 4abc 24030000 		.word	.LC18
 9169              	.LBE202:
 9170              	.LBE339:
 9171              	.LBE349:
 9172              	.LBE445:
 9173              		.cfi_endproc
 9174              	.LFE24:
 9176              		.align	2
 9177              		.global	CyFxGpifCB
 9179              	CyFxGpifCB:
 9180              	.LFB12:
1707:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 9181              		.loc 1 1707 0
 9182              		.cfi_startproc
 9183              		@ args = 0, pretend = 0, frame = 0
 9184              		@ frame_needed = 0, uses_anonymous_args = 0
1708:../uvc.c      ****     {
 9185              		.loc 1 1708 0
 9186 4ac0 010050E3 		cmp	r0, #1
1707:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 9187              		.loc 1 1707 0
 9188 4ac4 10402DE9 		stmfd	sp!, {r4, lr}
 9189              	.LCFI22:
 9190              		.cfi_def_cfa_offset 8
 9191              		.cfi_offset 4, -8
 9192              		.cfi_offset 14, -4
1708:../uvc.c      ****     {
 9193              		.loc 1 1708 0
 9194 4ac8 1080BD18 		ldmnefd	sp!, {r4, pc}
 9195              	.LBB450:
 9196              	.LBB451:
1607:../uvc.c      ****     {
 9197              		.loc 1 1607 0
 9198 4acc C4309FE5 		ldr	r3, .L742
 9199 4ad0 C030D3E5 		ldrb	r3, [r3, #192]	@ zero_extendqisi2
 9200 4ad4 030053E3 		cmp	r3, #3
 9201 4ad8 1000000A 		beq	.L741
1631:../uvc.c      ****     {
 9202              		.loc 1 1631 0
 9203 4adc 020053E3 		cmp	r3, #2
 9204 4ae0 1080BD18 		ldmnefd	sp!, {r4, pc}
1633:../uvc.c      ****         {
 9205              		.loc 1 1633 0
 9206 4ae4 083041E2 		sub	r3, r1, #8
 9207 4ae8 0A0053E3 		cmp	r3, #10
 9208 4aec 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 9209 4af0 200000EA 		b	.L734
 9210              	.L736:
 9211 4af4 704B0000 		.word	.L728
 9212 4af8 784B0000 		.word	.L734
 9213 4afc 784B0000 		.word	.L734
 9214 4b00 404B0000 		.word	.L724
 9215 4b04 784B0000 		.word	.L734
 9216 4b08 784B0000 		.word	.L734
 9217 4b0c 784B0000 		.word	.L734
 9218 4b10 444B0000 		.word	.L740
 9219 4b14 784B0000 		.word	.L734
 9220 4b18 784B0000 		.word	.L734
 9221 4b1c 404B0000 		.word	.L724
 9222              	.L741:
1609:../uvc.c      ****         {
 9223              		.loc 1 1609 0
 9224 4b20 0B3041E2 		sub	r3, r1, #11
 9225 4b24 030053E3 		cmp	r3, #3
 9226 4b28 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 9227 4b2c 110000EA 		b	.L734
 9228              	.L729:
 9229 4b30 704B0000 		.word	.L728
 9230 4b34 444B0000 		.word	.L740
 9231 4b38 404B0000 		.word	.L724
 9232 4b3c 404B0000 		.word	.L724
 9233              	.L724:
 9234 4b40 1080BDE8 		ldmfd	sp!, {r4, pc}
 9235              	.L740:
1633:../uvc.c      ****         {
 9236              		.loc 1 1633 0
 9237 4b44 0110A0E3 		mov	r1, #1
 9238              	.L730:
1690:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 9239              		.loc 1 1690 0
 9240 4b48 4C009FE5 		ldr	r0, .L742+4
 9241 4b4c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
1691:../uvc.c      ****         {
 9242              		.loc 1 1691 0
 9243 4b50 004050E2 		subs	r4, r0, #0
 9244 4b54 1080BD08 		ldmeqfd	sp!, {r4, pc}
1693:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 9245              		.loc 1 1693 0
 9246 4b58 0400A0E3 		mov	r0, #4
 9247 4b5c 3C109FE5 		ldr	r1, .L742+8
 9248 4b60 0420A0E1 		mov	r2, r4
 9249 4b64 FEFFFFEB 		bl	CyU3PDebugPrint
1694:../uvc.c      ****         }
 9250              		.loc 1 1694 0
 9251 4b68 0400A0E1 		mov	r0, r4
 9252 4b6c FEFFFFEB 		bl	CyFxAppErrorHandler
 9253              	.L728:
1609:../uvc.c      ****         {
 9254              		.loc 1 1609 0
 9255 4b70 0010A0E3 		mov	r1, #0
 9256 4b74 F3FFFFEA 		b	.L730
 9257              	.L734:
1679:../uvc.c      ****                 /* Unexpected current state. Return error. */
 9258              		.loc 1 1679 0
 9259 4b78 0120A0E1 		mov	r2, r1
 9260 4b7c 0100A0E3 		mov	r0, #1
 9261 4b80 1C109FE5 		ldr	r1, .L742+12
 9262 4b84 FEFFFFEB 		bl	CyU3PDebugPrint
 9263              	.LBE451:
 9264              	.LBE450:
 9265              	.LBB452:
 9266              	.LBB453:
1712:../uvc.c      ****     }
 9267              		.loc 1 1712 0
 9268 4b88 0400A0E3 		mov	r0, #4
 9269 4b8c 14109FE5 		ldr	r1, .L742+16
 9270              	.LBE453:
 9271              	.LBE452:
1714:../uvc.c      **** 
 9272              		.loc 1 1714 0
 9273 4b90 1040BDE8 		ldmfd	sp!, {r4, lr}
 9274              	.LBB455:
 9275              	.LBB454:
1712:../uvc.c      ****     }
 9276              		.loc 1 1712 0
 9277 4b94 FEFFFFEA 		b	CyU3PDebugPrint
 9278              	.L743:
 9279              		.align	2
 9280              	.L742:
 9281 4b98 00000000 		.word	.LANCHOR0
 9282 4b9c 00000000 		.word	glChHandleUVCStream
 9283 4ba0 A8060000 		.word	.LC38
 9284 4ba4 90060000 		.word	.LC37
 9285 4ba8 D8060000 		.word	.LC39
 9286              	.LBE454:
 9287              	.LBE455:
 9288              		.cfi_endproc
 9289              	.LFE12:
 9291              		.align	2
 9292              		.global	CyFxUVCApplnI2CInit
 9294              	CyFxUVCApplnI2CInit:
 9295              	.LFB14:
1770:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
 9296              		.loc 1 1770 0
 9297              		.cfi_startproc
 9298              		@ args = 0, pretend = 0, frame = 16
 9299              		@ frame_needed = 0, uses_anonymous_args = 0
 9300 4bac 10402DE9 		stmfd	sp!, {r4, lr}
 9301              	.LCFI23:
 9302              		.cfi_def_cfa_offset 8
 9303              		.cfi_offset 4, -8
 9304              		.cfi_offset 14, -4
 9305 4bb0 10D04DE2 		sub	sp, sp, #16
 9306              	.LCFI24:
 9307              		.cfi_def_cfa_offset 24
1774:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 9308              		.loc 1 1774 0
 9309 4bb4 FEFFFFEB 		bl	CyU3PI2cInit
 9310              	.LVL1012:
1775:../uvc.c      ****     {
 9311              		.loc 1 1775 0
 9312 4bb8 004050E2 		subs	r4, r0, #0
 9313 4bbc 0B00001A 		bne	.L747
1782:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 9314              		.loc 1 1782 0
 9315 4bc0 50209FE5 		ldr	r2, .L749
1784:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 9316              		.loc 1 1784 0
 9317 4bc4 0030E0E3 		mvn	r3, #0
1787:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 9318              		.loc 1 1787 0
 9319 4bc8 0410A0E1 		mov	r1, r4
 9320 4bcc 0D00A0E1 		mov	r0, sp
 9321              	.LVL1013:
1782:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 9322              		.loc 1 1782 0
 9323 4bd0 14008DE8 		stmia	sp, {r2, r4}
1784:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 9324              		.loc 1 1784 0
 9325 4bd4 08308DE5 		str	r3, [sp, #8]
1785:../uvc.c      **** 
 9326              		.loc 1 1785 0
 9327 4bd8 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1787:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 9328              		.loc 1 1787 0
 9329 4bdc FEFFFFEB 		bl	CyU3PI2cSetConfig
 9330              	.LVL1014:
1788:../uvc.c      ****     {
 9331              		.loc 1 1788 0
 9332 4be0 004050E2 		subs	r4, r0, #0
 9333 4be4 0600001A 		bne	.L748
1793:../uvc.c      **** 
 9334              		.loc 1 1793 0
 9335 4be8 10D08DE2 		add	sp, sp, #16
 9336              		@ sp needed
 9337 4bec 1080BDE8 		ldmfd	sp!, {r4, pc}
 9338              	.L747:
1777:../uvc.c      ****         CyFxAppErrorHandler (status);
 9339              		.loc 1 1777 0
 9340 4bf0 0400A0E3 		mov	r0, #4
 9341              	.LVL1015:
 9342 4bf4 20109FE5 		ldr	r1, .L749+4
 9343 4bf8 FEFFFFEB 		bl	CyU3PDebugPrint
 9344              	.LVL1016:
1778:../uvc.c      ****     }
 9345              		.loc 1 1778 0
 9346 4bfc 0400A0E1 		mov	r0, r4
 9347 4c00 FEFFFFEB 		bl	CyFxAppErrorHandler
 9348              	.LVL1017:
 9349              	.L748:
1790:../uvc.c      ****         CyFxAppErrorHandler (status);
 9350              		.loc 1 1790 0
 9351 4c04 0400A0E3 		mov	r0, #4
 9352              	.LVL1018:
 9353 4c08 10109FE5 		ldr	r1, .L749+8
 9354 4c0c FEFFFFEB 		bl	CyU3PDebugPrint
 9355              	.LVL1019:
1791:../uvc.c      ****     }
 9356              		.loc 1 1791 0
 9357 4c10 0400A0E1 		mov	r0, r4
 9358 4c14 FEFFFFEB 		bl	CyFxAppErrorHandler
 9359              	.LVL1020:
 9360              	.L750:
 9361              		.align	2
 9362              	.L749:
 9363 4c18 A0860100 		.word	100000
 9364 4c1c EC060000 		.word	.LC40
 9365 4c20 08070000 		.word	.LC41
 9366              		.cfi_endproc
 9367              	.LFE14:
 9369              		.align	2
 9370              		.global	UVCAppThread_Entry
 9372              	UVCAppThread_Entry:
 9373              	.LFB18:
2269:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 9374              		.loc 1 2269 0
 9375              		.cfi_startproc
 9376              		@ args = 0, pretend = 0, frame = 128
 9377              		@ frame_needed = 0, uses_anonymous_args = 0
 9378              	.LVL1021:
 9379 4c24 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 9380              	.LCFI25:
 9381              		.cfi_def_cfa_offset 32
 9382              		.cfi_offset 4, -32
 9383              		.cfi_offset 5, -28
 9384              		.cfi_offset 6, -24
 9385              		.cfi_offset 7, -20
 9386              		.cfi_offset 8, -16
 9387              		.cfi_offset 9, -12
 9388              		.cfi_offset 10, -8
 9389              		.cfi_offset 14, -4
 9390 4c28 88D04DE2 		sub	sp, sp, #136
 9391              	.LCFI26:
 9392              		.cfi_def_cfa_offset 168
 9393              	.LBB462:
 9394              	.LBB463:
1725:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9395              		.loc 1 1725 0
 9396 4c2c FEFFFFEB 		bl	CyU3PUartInit
 9397              	.LVL1022:
1726:../uvc.c      ****     {
 9398              		.loc 1 1726 0
 9399 4c30 004050E2 		subs	r4, r0, #0
 9400 4c34 DF01001A 		bne	.L811
1733:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 9401              		.loc 1 1733 0
 9402 4c38 08299FE5 		ldr	r2, .L840
1734:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 9403              		.loc 1 1734 0
 9404 4c3c 0130A0E3 		mov	r3, #1
1742:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9405              		.loc 1 1742 0
 9406 4c40 0410A0E1 		mov	r1, r4
 9407 4c44 60008DE2 		add	r0, sp, #96
 9408              	.LVL1023:
1735:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 9409              		.loc 1 1735 0
 9410 4c48 7540CDE5 		strb	r4, [sp, #117]
1737:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 9411              		.loc 1 1737 0
 9412 4c4c 64408DE5 		str	r4, [sp, #100]
1738:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 9413              		.loc 1 1738 0
 9414 4c50 68408DE5 		str	r4, [sp, #104]
1733:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 9415              		.loc 1 1733 0
 9416 4c54 70208DE5 		str	r2, [sp, #112]
1734:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 9417              		.loc 1 1734 0
 9418 4c58 7430CDE5 		strb	r3, [sp, #116]
1736:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 9419              		.loc 1 1736 0
 9420 4c5c 60308DE5 		str	r3, [sp, #96]
1739:../uvc.c      **** 
 9421              		.loc 1 1739 0
 9422 4c60 6C308DE5 		str	r3, [sp, #108]
1742:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9423              		.loc 1 1742 0
 9424 4c64 FEFFFFEB 		bl	CyU3PUartSetConfig
 9425              	.LVL1024:
1743:../uvc.c      ****     {
 9426              		.loc 1 1743 0
 9427 4c68 000050E3 		cmp	r0, #0
 9428 4c6c AD01001A 		bne	.L810
1749:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9429              		.loc 1 1749 0
 9430 4c70 0000E0E3 		mvn	r0, #0
 9431              	.LVL1025:
 9432 4c74 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 9433              	.LVL1026:
1750:../uvc.c      ****     {
 9434              		.loc 1 1750 0
 9435 4c78 000050E3 		cmp	r0, #0
 9436 4c7c A901001A 		bne	.L810
1756:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9437              		.loc 1 1756 0
 9438 4c80 0300A0E3 		mov	r0, #3
 9439              	.LVL1027:
 9440 4c84 0410A0E3 		mov	r1, #4
 9441 4c88 FEFFFFEB 		bl	CyU3PDebugInit
 9442              	.LVL1028:
1757:../uvc.c      ****     {
 9443              		.loc 1 1757 0
 9444 4c8c 000050E3 		cmp	r0, #0
 9445 4c90 A401001A 		bne	.L810
1763:../uvc.c      **** }
 9446              		.loc 1 1763 0
 9447 4c94 FEFFFFEB 		bl	CyU3PDebugPreamble
 9448              	.LVL1029:
 9449 4c98 0640A0E3 		mov	r4, #6
 9450              	.LVL1030:
 9451              	.L757:
 9452              	.LBE463:
 9453              	.LBE462:
2285:../uvc.c      **** 	}
 9454              		.loc 1 2285 0
 9455 4c9c 7D0FA0E3 		mov	r0, #500
 9456 4ca0 014044E2 		sub	r4, r4, #1
 9457 4ca4 FEFFFFEB 		bl	_tx_thread_sleep
 9458              	.LVL1031:
2284:../uvc.c      **** 		CyU3PThreadSleep(500);
 9459              		.loc 1 2284 0
 9460 4ca8 FF4014E2 		ands	r4, r4, #255
 9461 4cac FAFFFF1A 		bne	.L757
 9462              	.LBB465:
 9463              	.LBB466:
1861:../uvc.c      ****     if (apiRetStatus != 0)
 9464              		.loc 1 1861 0
 9465 4cb0 94789FE5 		ldr	r7, .L840+4
 9466              	.LBE466:
 9467              	.LBE465:
2288:../uvc.c      **** 
 9468              		.loc 1 2288 0
 9469 4cb4 FEFFFFEB 		bl	CyFxUVCApplnI2CInit
 9470              	.LVL1032:
 9471              	.LBB470:
 9472              	.LBB467:
1861:../uvc.c      ****     if (apiRetStatus != 0)
 9473              		.loc 1 1861 0
 9474 4cb8 0410A0E1 		mov	r1, r4
 9475 4cbc 0700A0E1 		mov	r0, r7
 9476 4cc0 2820A0E3 		mov	r2, #40
 9477 4cc4 FEFFFFEB 		bl	_txe_event_flags_create
 9478              	.LVL1033:
1862:../uvc.c      ****     {
 9479              		.loc 1 1862 0
 9480 4cc8 005050E2 		subs	r5, r0, #0
 9481 4ccc FF01001A 		bne	.L812
1876:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 9482              		.loc 1 1876 0
 9483 4cd0 0260A0E3 		mov	r6, #2
1879:../uvc.c      ****     gpioClock.halfDiv    = 0;
 9484              		.loc 1 1879 0
 9485 4cd4 0380A0E3 		mov	r8, #3
1883:../uvc.c      ****     if (apiRetStatus != 0)
 9486              		.loc 1 1883 0
 9487 4cd8 14008DE2 		add	r0, sp, #20
 9488              	.LVL1034:
 9489 4cdc 0410A0E1 		mov	r1, r4
1872:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 9490              		.loc 1 1872 0
 9491 4ce0 884087E5 		str	r4, [r7, #136]
1873:../uvc.c      **** 
 9492              		.loc 1 1873 0
 9493 4ce4 8C4087E5 		str	r4, [r7, #140]
1878:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 9494              		.loc 1 1878 0
 9495 4ce8 1C40CDE5 		strb	r4, [sp, #28]
1880:../uvc.c      **** 
 9496              		.loc 1 1880 0
 9497 4cec 18408DE5 		str	r4, [sp, #24]
1876:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 9498              		.loc 1 1876 0
 9499 4cf0 1460CDE5 		strb	r6, [sp, #20]
1877:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 9500              		.loc 1 1877 0
 9501 4cf4 1560CDE5 		strb	r6, [sp, #21]
1879:../uvc.c      ****     gpioClock.halfDiv    = 0;
 9502              		.loc 1 1879 0
 9503 4cf8 1D80CDE5 		strb	r8, [sp, #29]
1883:../uvc.c      ****     if (apiRetStatus != 0)
 9504              		.loc 1 1883 0
 9505 4cfc FEFFFFEB 		bl	CyU3PGpioInit
 9506              	.LVL1035:
1884:../uvc.c      ****     {
 9507              		.loc 1 1884 0
 9508 4d00 005050E2 		subs	r5, r0, #0
 9509 4d04 EB01001A 		bne	.L813
1892:../uvc.c      ****     if (apiRetStatus != 0)
 9510              		.loc 1 1892 0
 9511 4d08 1600A0E3 		mov	r0, #22
 9512              	.LVL1036:
 9513 4d0c 0110A0E3 		mov	r1, #1
 9514 4d10 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9515              	.LVL1037:
1893:../uvc.c      ****     {
 9516              		.loc 1 1893 0
 9517 4d14 005050E2 		subs	r5, r0, #0
 9518 4d18 E001001A 		bne	.L814
1898:../uvc.c      ****     if (apiRetStatus != 0)
 9519              		.loc 1 1898 0
 9520 4d1c 1400A0E3 		mov	r0, #20
 9521              	.LVL1038:
 9522 4d20 0110A0E3 		mov	r1, #1
 9523 4d24 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9524              	.LVL1039:
1899:../uvc.c      ****     {
 9525              		.loc 1 1899 0
 9526 4d28 005050E2 		subs	r5, r0, #0
 9527 4d2c D501001A 		bne	.L815
1904:../uvc.c      ****     if (apiRetStatus != 0)
 9528              		.loc 1 1904 0
 9529 4d30 1800A0E3 		mov	r0, #24
 9530              	.LVL1040:
 9531 4d34 0110A0E3 		mov	r1, #1
 9532 4d38 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 9533              	.LVL1041:
1905:../uvc.c      ****     {
 9534              		.loc 1 1905 0
 9535 4d3c 005050E2 		subs	r5, r0, #0
 9536 4d40 FA01001A 		bne	.L816
1912:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9537              		.loc 1 1912 0
 9538 4d44 0150A0E3 		mov	r5, #1
1917:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9539              		.loc 1 1917 0
 9540 4d48 30108DE2 		add	r1, sp, #48
 9541 4d4c 1600A0E3 		mov	r0, #22
 9542              	.LVL1042:
1915:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9543              		.loc 1 1915 0
 9544 4d50 3C408DE5 		str	r4, [sp, #60]
1916:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 9545              		.loc 1 1916 0
 9546 4d54 4040CDE5 		strb	r4, [sp, #64]
1912:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9547              		.loc 1 1912 0
 9548 4d58 30508DE5 		str	r5, [sp, #48]
1913:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 9549              		.loc 1 1913 0
 9550 4d5c 34508DE5 		str	r5, [sp, #52]
1914:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 9551              		.loc 1 1914 0
 9552 4d60 38508DE5 		str	r5, [sp, #56]
1917:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9553              		.loc 1 1917 0
 9554 4d64 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9555              	.LVL1043:
1918:../uvc.c      ****     {
 9556              		.loc 1 1918 0
 9557 4d68 009050E2 		subs	r9, r0, #0
 9558 4d6c E901001A 		bne	.L817
1931:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9559              		.loc 1 1931 0
 9560 4d70 1400A0E3 		mov	r0, #20
 9561              	.LVL1044:
 9562 4d74 30108DE2 		add	r1, sp, #48
1926:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 9563              		.loc 1 1926 0
 9564 4d78 30508DE5 		str	r5, [sp, #48]
1927:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 9565              		.loc 1 1927 0
 9566 4d7c 34508DE5 		str	r5, [sp, #52]
1928:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 9567              		.loc 1 1928 0
 9568 4d80 38508DE5 		str	r5, [sp, #56]
1929:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9569              		.loc 1 1929 0
 9570 4d84 3C408DE5 		str	r4, [sp, #60]
1930:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 9571              		.loc 1 1930 0
 9572 4d88 4040CDE5 		strb	r4, [sp, #64]
1931:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9573              		.loc 1 1931 0
 9574 4d8c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9575              	.LVL1045:
1932:../uvc.c      ****     {
 9576              		.loc 1 1932 0
 9577 4d90 009050E2 		subs	r9, r0, #0
 9578 4d94 D901001A 		bne	.L818
1945:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9579              		.loc 1 1945 0
 9580 4d98 30108DE2 		add	r1, sp, #48
 9581 4d9c 1800A0E3 		mov	r0, #24
 9582              	.LVL1046:
1940:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 9583              		.loc 1 1940 0
 9584 4da0 30408DE5 		str	r4, [sp, #48]
1941:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 9585              		.loc 1 1941 0
 9586 4da4 34408DE5 		str	r4, [sp, #52]
1942:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 9587              		.loc 1 1942 0
 9588 4da8 38408DE5 		str	r4, [sp, #56]
1943:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 9589              		.loc 1 1943 0
 9590 4dac 3C508DE5 		str	r5, [sp, #60]
1944:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 9591              		.loc 1 1944 0
 9592 4db0 4040CDE5 		strb	r4, [sp, #64]
1945:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9593              		.loc 1 1945 0
 9594 4db4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 9595              	.LVL1047:
1946:../uvc.c      ****     {
 9596              		.loc 1 1946 0
 9597 4db8 009050E2 		subs	r9, r0, #0
 9598 4dbc C901001A 		bne	.L819
1958:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9599              		.loc 1 1958 0
 9600 4dc0 0500A0E1 		mov	r0, r5
 9601              	.LVL1048:
 9602 4dc4 20108DE2 		add	r1, sp, #32
1955:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 9603              		.loc 1 1955 0
 9604 4dc8 28408DE5 		str	r4, [sp, #40]
1956:../uvc.c      **** 
 9605              		.loc 1 1956 0
 9606 4dcc 24408DE5 		str	r4, [sp, #36]
1953:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 9607              		.loc 1 1953 0
 9608 4dd0 B062CDE1 		strh	r6, [sp, #32]	@ movhi
1954:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 9609              		.loc 1 1954 0
 9610 4dd4 2C80CDE5 		strb	r8, [sp, #44]
1958:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9611              		.loc 1 1958 0
 9612 4dd8 FEFFFFEB 		bl	CyU3PPibInit
 9613              	.LVL1049:
1959:../uvc.c      ****     {
 9614              		.loc 1 1959 0
 9615 4ddc 004050E2 		subs	r4, r0, #0
 9616 4de0 A201001A 		bne	.L820
1966:../uvc.c      **** 
 9617              		.loc 1 1966 0
 9618 4de4 64079FE5 		ldr	r0, .L840+8
 9619              	.LVL1050:
 9620 4de8 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 9621              	.LVL1051:
1974:../uvc.c      ****     SensorInit ();
 9622              		.loc 1 1974 0
 9623 4dec FEFFFFEB 		bl	SensorReset
 9624              	.LVL1052:
1975:../uvc.c      **** 
 9625              		.loc 1 1975 0
 9626 4df0 FEFFFFEB 		bl	SensorInit
 9627              	.LVL1053:
1978:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9628              		.loc 1 1978 0
 9629 4df4 FEFFFFEB 		bl	CyU3PUsbStart
 9630              	.LVL1054:
1979:../uvc.c      ****     {
 9631              		.loc 1 1979 0
 9632 4df8 004050E2 		subs	r4, r0, #0
 9633 4dfc 9501001A 		bne	.L821
1985:../uvc.c      **** 
 9634              		.loc 1 1985 0
 9635 4e00 0410A0E1 		mov	r1, r4
 9636 4e04 48079FE5 		ldr	r0, .L840+12
 9637              	.LVL1055:
 9638 4e08 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 9639              	.LVL1056:
1988:../uvc.c      **** 
 9640              		.loc 1 1988 0
 9641 4e0c 44079FE5 		ldr	r0, .L840+16
 9642 4e10 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 9643              	.LVL1057:
1994:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 9644              		.loc 1 1994 0
 9645 4e14 0410A0E1 		mov	r1, r4
 9646 4e18 3C279FE5 		ldr	r2, .L840+20
 9647 4e1c 0100A0E3 		mov	r0, #1
 9648 4e20 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9649              	.LVL1058:
1995:../uvc.c      **** 
 9650              		.loc 1 1995 0
 9651 4e24 0410A0E1 		mov	r1, r4
 9652 4e28 0400A0E1 		mov	r0, r4
 9653 4e2c 2C279FE5 		ldr	r2, .L840+24
 9654 4e30 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9655              	.LVL1059:
1998:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 9656              		.loc 1 1998 0
 9657 4e34 0410A0E1 		mov	r1, r4
 9658 4e38 24279FE5 		ldr	r2, .L840+28
 9659 4e3c 0200A0E3 		mov	r0, #2
 9660 4e40 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9661              	.LVL1060:
1999:../uvc.c      **** 
 9662              		.loc 1 1999 0
 9663 4e44 0410A0E1 		mov	r1, r4
 9664 4e48 18279FE5 		ldr	r2, .L840+32
 9665 4e4c 0700A0E3 		mov	r0, #7
 9666 4e50 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9667              	.LVL1061:
2002:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 9668              		.loc 1 2002 0
 9669 4e54 0410A0E1 		mov	r1, r4
 9670 4e58 0C279FE5 		ldr	r2, .L840+36
 9671 4e5c 0400A0E3 		mov	r0, #4
 9672 4e60 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9673              	.LVL1062:
2003:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 9674              		.loc 1 2003 0
 9675 4e64 0410A0E1 		mov	r1, r4
 9676 4e68 00279FE5 		ldr	r2, .L840+40
 9677 4e6c 0300A0E3 		mov	r0, #3
 9678 4e70 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9679              	.LVL1063:
2004:../uvc.c      **** 
 9680              		.loc 1 2004 0
 9681 4e74 0410A0E1 		mov	r1, r4
 9682 4e78 F4269FE5 		ldr	r2, .L840+44
 9683 4e7c 0600A0E3 		mov	r0, #6
 9684 4e80 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9685              	.LVL1064:
2007:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 9686              		.loc 1 2007 0
 9687 4e84 0410A0E1 		mov	r1, r4
 9688 4e88 E8269FE5 		ldr	r2, .L840+48
 9689 4e8c 0500A0E3 		mov	r0, #5
 9690 4e90 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9691              	.LVL1065:
2008:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 9692              		.loc 1 2008 0
 9693 4e94 0110A0E3 		mov	r1, #1
 9694 4e98 DC269FE5 		ldr	r2, .L840+52
 9695 4e9c 0500A0E3 		mov	r0, #5
 9696 4ea0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9697              	.LVL1066:
2009:../uvc.c      **** 
 9698              		.loc 1 2009 0
 9699 4ea4 0210A0E3 		mov	r1, #2
 9700 4ea8 D0269FE5 		ldr	r2, .L840+56
 9701 4eac 0500A0E3 		mov	r0, #5
 9702 4eb0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 9703              	.LVL1067:
2016:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 9704              		.loc 1 2016 0
 9705 4eb4 0150A0E3 		mov	r5, #1
2017:../uvc.c      ****     endPointConfig.pcktSize = 64;
 9706              		.loc 1 2017 0
 9707 4eb8 0320A0E3 		mov	r2, #3
2018:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 9708              		.loc 1 2018 0
 9709 4ebc 4030A0E3 		mov	r3, #64
2022:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9710              		.loc 1 2022 0
 9711 4ec0 08108DE2 		add	r1, sp, #8
 9712 4ec4 8200A0E3 		mov	r0, #130
2019:../uvc.c      ****     endPointConfig.streams  = 0;
 9713              		.loc 1 2019 0
 9714 4ec8 1340CDE5 		strb	r4, [sp, #19]
2020:../uvc.c      ****     endPointConfig.burstLen = 1;
 9715              		.loc 1 2020 0
 9716 4ecc BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2016:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 9717              		.loc 1 2016 0
 9718 4ed0 08508DE5 		str	r5, [sp, #8]
2021:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 9719              		.loc 1 2021 0
 9720 4ed4 1250CDE5 		strb	r5, [sp, #18]
2017:../uvc.c      ****     endPointConfig.pcktSize = 64;
 9721              		.loc 1 2017 0
 9722 4ed8 0C20CDE5 		strb	r2, [sp, #12]
2018:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 9723              		.loc 1 2018 0
 9724 4edc B031CDE1 		strh	r3, [sp, #16]	@ movhi
2022:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9725              		.loc 1 2022 0
 9726 4ee0 FEFFFFEB 		bl	CyU3PSetEpConfig
 9727              	.LVL1068:
2023:../uvc.c      ****     {
 9728              		.loc 1 2023 0
 9729 4ee4 004050E2 		subs	r4, r0, #0
2026:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 9730              		.loc 1 2026 0
 9731 4ee8 0400A013 		movne	r0, #4
 9732              	.LVL1069:
2023:../uvc.c      ****     {
 9733              		.loc 1 2023 0
 9734 4eec 3D01001A 		bne	.L808
2031:../uvc.c      ****     dmaInterConfig.count          = 1;
 9735              		.loc 1 2031 0
 9736 4ef0 8CC69FE5 		ldr	ip, .L840+60
 9737 4ef4 413BA0E3 		mov	r3, #66560
2040:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 9738              		.loc 1 2040 0
 9739 4ef8 1060A0E3 		mov	r6, #16
2042:../uvc.c      ****             &dmaInterConfig);
 9740              		.loc 1 2042 0
 9741 4efc 84069FE5 		ldr	r0, .L840+64
 9742 4f00 0410A0E3 		mov	r1, #4
 9743 4f04 44208DE2 		add	r2, sp, #68
2031:../uvc.c      ****     dmaInterConfig.count          = 1;
 9744              		.loc 1 2031 0
 9745 4f08 4C408DE5 		str	r4, [sp, #76]
 9746 4f0c 50408DE5 		str	r4, [sp, #80]
2039:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 9747              		.loc 1 2039 0
 9748 4f10 5440CDE5 		strb	r4, [sp, #84]
2041:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 9749              		.loc 1 2041 0
 9750 4f14 5C408DE5 		str	r4, [sp, #92]
2031:../uvc.c      ****     dmaInterConfig.count          = 1;
 9751              		.loc 1 2031 0
 9752 4f18 48C08DE5 		str	ip, [sp, #72]
 9753 4f1c 44308DE5 		str	r3, [sp, #68]
2040:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 9754              		.loc 1 2040 0
 9755 4f20 58608DE5 		str	r6, [sp, #88]
2042:../uvc.c      ****             &dmaInterConfig);
 9756              		.loc 1 2042 0
 9757 4f24 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 9758              	.LVL1070:
2044:../uvc.c      ****     {
 9759              		.loc 1 2044 0
 9760 4f28 004050E2 		subs	r4, r0, #0
 9761 4f2c 4301001A 		bne	.L822
2051:../uvc.c      ****     if (glInterStaBuffer == 0)
 9762              		.loc 1 2051 0
 9763 4f30 010BA0E3 		mov	r0, #1024
 9764              	.LVL1071:
 9765 4f34 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 9766              	.LVL1072:
 9767 4f38 4C369FE5 		ldr	r3, .L840+68
2052:../uvc.c      ****     {
 9768              		.loc 1 2052 0
 9769 4f3c 000050E3 		cmp	r0, #0
2051:../uvc.c      ****     if (glInterStaBuffer == 0)
 9770              		.loc 1 2051 0
 9771 4f40 000083E5 		str	r0, [r3]
2052:../uvc.c      ****     {
 9772              		.loc 1 2052 0
 9773 4f44 3801000A 		beq	.L823
2059:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 9774              		.loc 1 2059 0
 9775 4f48 0410A0E1 		mov	r1, r4
 9776 4f4c 0420A0E1 		mov	r2, r4
 9777 4f50 3830A0E3 		mov	r3, #56
 9778 4f54 34069FE5 		ldr	r0, .L840+72
 9779 4f58 FEFFFFEB 		bl	_txe_mutex_create
 9780              	.LVL1073:
2064:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 9781              		.loc 1 2064 0
 9782 4f5c 30169FE5 		ldr	r1, .L840+76
2065:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 9783              		.loc 1 2065 0
 9784 4f60 30269FE5 		ldr	r2, .L840+80
2072:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 9785              		.loc 1 2072 0
 9786 4f64 30A69FE5 		ldr	r10, .L840+84
2061:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 9787              		.loc 1 2061 0
 9788 4f68 0460A0E3 		mov	r6, #4
2063:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 9789              		.loc 1 2063 0
 9790 4f6c 01ECA0E3 		mov	lr, #256
2067:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 9791              		.loc 1 2067 0
 9792 4f70 0CC0A0E3 		mov	ip, #12
2071:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 9793              		.loc 1 2071 0
 9794 4f74 1830A0E3 		mov	r3, #24
2064:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 9795              		.loc 1 2064 0
 9796 4f78 B816CDE1 		strh	r1, [sp, #104]	@ movhi
2065:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 9797              		.loc 1 2065 0
 9798 4f7c BE26CDE1 		strh	r2, [sp, #110]	@ movhi
2060:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 9799              		.loc 1 2060 0
 9800 4f80 0199A0E3 		mov	r9, #16384
2062:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 9801              		.loc 1 2062 0
 9802 4f84 0280A0E3 		mov	r8, #2
2073:../uvc.c      ****             &dmaMultiConfig);
 9803              		.loc 1 2073 0
 9804 4f88 10069FE5 		ldr	r0, .L840+88
 9805 4f8c 0710A0E3 		mov	r1, #7
 9806 4f90 60208DE2 		add	r2, sp, #96
2066:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 9807              		.loc 1 2066 0
 9808 4f94 B647CDE1 		strh	r4, [sp, #118]	@ movhi
2069:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 9809              		.loc 1 2069 0
 9810 4f98 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
2070:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 9811              		.loc 1 2070 0
 9812 4f9c 7E40CDE5 		strb	r4, [sp, #126]
2072:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 9813              		.loc 1 2072 0
 9814 4fa0 84A08DE5 		str	r10, [sp, #132]
2060:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 9815              		.loc 1 2060 0
 9816 4fa4 B096CDE1 		strh	r9, [sp, #96]	@ movhi
2061:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 9817              		.loc 1 2061 0
 9818 4fa8 B266CDE1 		strh	r6, [sp, #98]	@ movhi
2068:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 9819              		.loc 1 2068 0
 9820 4fac BA67CDE1 		strh	r6, [sp, #122]	@ movhi
2062:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 9821              		.loc 1 2062 0
 9822 4fb0 B486CDE1 		strh	r8, [sp, #100]	@ movhi
2063:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 9823              		.loc 1 2063 0
 9824 4fb4 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
2067:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 9825              		.loc 1 2067 0
 9826 4fb8 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
2071:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 9827              		.loc 1 2071 0
 9828 4fbc 80308DE5 		str	r3, [sp, #128]
2073:../uvc.c      ****             &dmaMultiConfig);
 9829              		.loc 1 2073 0
 9830 4fc0 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 9831              	.LVL1074:
2075:../uvc.c      ****     {
 9832              		.loc 1 2075 0
 9833 4fc4 004050E2 		subs	r4, r0, #0
 9834 4fc8 1101001A 		bne	.L824
2166:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9835              		.loc 1 2166 0
 9836 4fcc 0500A0E1 		mov	r0, r5
 9837              	.LVL1075:
 9838 4fd0 0510A0E1 		mov	r1, r5
 9839 4fd4 FEFFFFEB 		bl	CyU3PConnectState
 9840              	.LVL1076:
2167:../uvc.c      ****     {
 9841              		.loc 1 2167 0
 9842 4fd8 004050E2 		subs	r4, r0, #0
 9843 4fdc 0601001A 		bne	.L825
2173:../uvc.c      **** 
 9844              		.loc 1 2173 0
 9845 4fe0 6400A0E3 		mov	r0, #100
 9846              	.LVL1077:
 9847 4fe4 FEFFFFEB 		bl	CyFx3BusyWait
 9848              	.LVL1078:
2175:../uvc.c      **** 
 9849              		.loc 1 2175 0
 9850 4fe8 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 9851              	.LVL1079:
2190:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9852              		.loc 1 2190 0
 9853 4fec 08108DE2 		add	r1, sp, #8
2189:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 9854              		.loc 1 2189 0
 9855 4ff0 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2177:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 9856              		.loc 1 2177 0
 9857 4ff4 08508DE5 		str	r5, [sp, #8]
2178:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 9858              		.loc 1 2178 0
 9859 4ff8 0C80CDE5 		strb	r8, [sp, #12]
2182:../uvc.c      ****     }
 9860              		.loc 1 2182 0
 9861 4ffc 030050E3 		cmp	r0, #3
2175:../uvc.c      **** 
 9862              		.loc 1 2175 0
 9863 5000 0030A0E1 		mov	r3, r0
2182:../uvc.c      ****     }
 9864              		.loc 1 2182 0
 9865 5004 01C0A013 		movne	ip, #1
 9866 5008 10C0A003 		moveq	ip, #16
 9867 500c 022CA013 		movne	r2, #512
 9868 5010 012BA003 		moveq	r2, #1024
2190:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9869              		.loc 1 2190 0
 9870 5014 8300A0E3 		mov	r0, #131
2175:../uvc.c      **** 
 9871              		.loc 1 2175 0
 9872 5018 C030C7E5 		strb	r3, [r7, #192]
 9873 501c 12C0CDE5 		strb	ip, [sp, #18]
 9874 5020 B021CDE1 		strh	r2, [sp, #16]	@ movhi
2190:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9875              		.loc 1 2190 0
 9876 5024 FEFFFFEB 		bl	CyU3PSetEpConfig
 9877              	.LVL1080:
2191:../uvc.c      ****     {
 9878              		.loc 1 2191 0
 9879 5028 004050E2 		subs	r4, r0, #0
 9880              	.LBE467:
 9881              	.LBE470:
2312:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9882              		.loc 1 2312 0
 9883 502c 18459F05 		ldreq	r4, .L840+4
 9884              	.LBB471:
 9885              	.LBB468:
2191:../uvc.c      ****     {
 9886              		.loc 1 2191 0
 9887 5030 0C00000A 		beq	.L795
 9888 5034 EA0000EA 		b	.L839
 9889              	.LVL1081:
 9890              	.L828:
 9891              	.LBE468:
 9892              	.LBE471:
2358:../uvc.c      ****             {
 9893              		.loc 1 2358 0
 9894 5038 783094E5 		ldr	r3, [r4, #120]
 9895 503c 050053E1 		cmp	r3, r5
 9896 5040 0300000A 		beq	.L776
2358:../uvc.c      ****             {
 9897              		.loc 1 2358 0 is_stmt 0 discriminator 1
 9898 5044 BC27D4E1 		ldrh	r2, [r4, #124]
 9899 5048 BE37D4E1 		ldrh	r3, [r4, #126]
 9900 504c 030052E1 		cmp	r2, r3
 9901 5050 3B00000A 		beq	.L827
 9902              	.L776:
2532:../uvc.c      **** 
 9903              		.loc 1 2532 0 is_stmt 1
 9904 5054 4010A0E3 		mov	r1, #64
 9905 5058 0020A0E3 		mov	r2, #0
 9906 505c E8049FE5 		ldr	r0, .L840+4
 9907 5060 FEFFFFEB 		bl	_txe_event_flags_set
 9908              	.LVL1082:
2535:../uvc.c      ****     }
 9909              		.loc 1 2535 0
 9910 5064 FEFFFFEB 		bl	_txe_thread_relinquish
 9911              	.LVL1083:
 9912              	.L795:
2312:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9913              		.loc 1 2312 0
 9914 5068 0050A0E3 		mov	r5, #0
 9915 506c 00508DE5 		str	r5, [sp]
 9916 5070 D4049FE5 		ldr	r0, .L840+4
 9917 5074 0110A0E3 		mov	r1, #1
 9918 5078 0220A0E3 		mov	r2, #2
 9919 507c 60308DE2 		add	r3, sp, #96
 9920 5080 FEFFFFEB 		bl	_txe_event_flags_get
 9921              	.LVL1084:
 9922 5084 006050E2 		subs	r6, r0, #0
 9923 5088 EAFFFF0A 		beq	.L828
2459:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 9924              		.loc 1 2459 0
 9925 508c 00508DE5 		str	r5, [sp]
 9926 5090 B4049FE5 		ldr	r0, .L840+4
 9927 5094 0210A0E3 		mov	r1, #2
 9928 5098 0320A0E3 		mov	r2, #3
 9929 509c 60308DE2 		add	r3, sp, #96
 9930 50a0 FEFFFFEB 		bl	_txe_event_flags_get
 9931              	.LVL1085:
 9932 50a4 000050E3 		cmp	r0, #0
 9933 50a8 0B00001A 		bne	.L787
2474:../uvc.c      ****                 {
 9934              		.loc 1 2474 0
 9935 50ac 8C3094E5 		ldr	r3, [r4, #140]
2462:../uvc.c      ****                 prodCount = 0;
 9936              		.loc 1 2462 0
 9937 50b0 780084E5 		str	r0, [r4, #120]
2474:../uvc.c      ****                 {
 9938              		.loc 1 2474 0
 9939 50b4 000053E3 		cmp	r3, #0
2463:../uvc.c      ****                 consCount = 0;
 9940              		.loc 1 2463 0
 9941 50b8 BC07C4E1 		strh	r0, [r4, #124]	@ movhi
2470:../uvc.c      ****                 pb=0;
 9942              		.loc 1 2470 0
 9943 50bc BC06C4E1 		strh	r0, [r4, #108]	@ movhi
2464:../uvc.c      ****                 if(0&&(prinflag == 0)){
 9944              		.loc 1 2464 0
 9945 50c0 BE07C4E1 		strh	r0, [r4, #126]	@ movhi
2471:../uvc.c      ****                 pbc=0;
 9946              		.loc 1 2471 0
 9947 50c4 BE06C4E1 		strh	r0, [r4, #110]	@ movhi
2472:../uvc.c      **** 
 9948              		.loc 1 2472 0
 9949 50c8 B007C4E1 		strh	r0, [r4, #112]	@ movhi
2474:../uvc.c      ****                 {
 9950              		.loc 1 2474 0
 9951 50cc 4600000A 		beq	.L829
 9952              	.L788:
2486:../uvc.c      ****             }
 9953              		.loc 1 2486 0
 9954 50d0 0030A0E3 		mov	r3, #0
 9955 50d4 8C3087E5 		str	r3, [r7, #140]
 9956 50d8 DDFFFFEA 		b	.L776
 9957              	.L787:
2491:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 9958              		.loc 1 2491 0
 9959 50dc 0030E0E3 		mvn	r3, #0
 9960 50e0 00308DE5 		str	r3, [sp]
 9961 50e4 0110A0E3 		mov	r1, #1
 9962 50e8 0220A0E3 		mov	r2, #2
 9963 50ec 60308DE2 		add	r3, sp, #96
 9964 50f0 54049FE5 		ldr	r0, .L840+4
 9965 50f4 FEFFFFEB 		bl	_txe_event_flags_get
 9966              	.LVL1086:
2495:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 9967              		.loc 1 2495 0
 9968 50f8 0510A0E1 		mov	r1, r5
 9969 50fc 0520A0E1 		mov	r2, r5
 9970 5100 98049FE5 		ldr	r0, .L840+88
 9971 5104 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 9972              	.LVL1087:
2496:../uvc.c      ****                 {
 9973              		.loc 1 2496 0
 9974 5108 005050E2 		subs	r5, r0, #0
 9975 510c 9300001A 		bne	.L830
2504:../uvc.c      ****                 {
 9976              		.loc 1 2504 0
 9977 5110 843094E5 		ldr	r3, [r4, #132]
 9978 5114 000053E3 		cmp	r3, #0
 9979 5118 2B00001A 		bne	.L786
 9980              	.LVL1088:
 9981              	.LBB472:
 9982              	.LBB473:
2219:../uvc.c      ****     {
 9983              		.loc 1 2219 0
 9984 511c C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 9985 5120 030053E3 		cmp	r3, #3
 9986 5124 6800000A 		beq	.L831
2224:../uvc.c      ****     {
 9987              		.loc 1 2224 0
 9988 5128 020053E3 		cmp	r3, #2
 9989 512c 7E00000A 		beq	.L832
 9990              	.LVL1089:
 9991              	.L793:
 9992              	.LBE473:
 9993              	.LBE472:
2520:../uvc.c      ****                     CyU3PThreadSleep(200);
 9994              		.loc 1 2520 0
 9995 5130 0130A0E3 		mov	r3, #1
2521:../uvc.c      ****                     
 9996              		.loc 1 2521 0
 9997 5134 C800A0E3 		mov	r0, #200
2520:../uvc.c      ****                     CyU3PThreadSleep(200);
 9998              		.loc 1 2520 0
 9999 5138 843087E5 		str	r3, [r7, #132]
2521:../uvc.c      ****                     
 10000              		.loc 1 2521 0
 10001 513c FEFFFFEB 		bl	_tx_thread_sleep
 10002              	.LVL1090:
 10003 5140 C3FFFFEA 		b	.L776
 10004              	.L827:
2384:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 10005              		.loc 1 2384 0
 10006 5144 58549FE5 		ldr	r5, .L840+92
2383:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 10007              		.loc 1 2383 0
 10008 5148 40049FE5 		ldr	r0, .L840+72
 10009 514c 0010E0E3 		mvn	r1, #0
2368:../uvc.c      ****                 consCount = 0;
 10010              		.loc 1 2368 0
 10011 5150 BC67C4E1 		strh	r6, [r4, #124]	@ movhi
2365:../uvc.c      ****             	pb=0;
 10012              		.loc 1 2365 0
 10013 5154 BC66C4E1 		strh	r6, [r4, #108]	@ movhi
2369:../uvc.c      ****                 hitFV     = CyFalse;
 10014              		.loc 1 2369 0
 10015 5158 BE67C4E1 		strh	r6, [r4, #126]	@ movhi
2366:../uvc.c      ****             	pbc=0;
 10016              		.loc 1 2366 0
 10017 515c BE66C4E1 		strh	r6, [r4, #110]	@ movhi
2367:../uvc.c      ****                 prodCount = 0;
 10018              		.loc 1 2367 0
 10019 5160 B067C4E1 		strh	r6, [r4, #112]	@ movhi
2370:../uvc.c      **** 
 10020              		.loc 1 2370 0
 10021 5164 786084E5 		str	r6, [r4, #120]
2383:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 10022              		.loc 1 2383 0
 10023 5168 FEFFFFEB 		bl	_txe_mutex_get
 10024              	.LVL1091:
2384:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 10025              		.loc 1 2384 0
 10026 516c 8134D5E5 		ldrb	r3, [r5, #1153]	@ zero_extendqisi2
 10027 5170 013023E2 		eor	r3, r3, #1
 10028 5174 8134C5E5 		strb	r3, [r5, #1153]
2386:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 10029              		.loc 1 2386 0
 10030 5178 743094E5 		ldr	r3, [r4, #116]
 10031 517c F00053E3 		cmp	r3, #240
 10032 5180 4500000A 		beq	.L833
 10033              	.L777:
2394:../uvc.c      **** 
 10034              		.loc 1 2394 0
 10035 5184 743097E5 		ldr	r3, [r7, #116]
 10036 5188 FF0053E3 		cmp	r3, #255
 10037 518c 1D00000A 		beq	.L834
2406:../uvc.c      ****                     //CyU3PThreadSleep(400);
 10038              		.loc 1 2406 0
 10039 5190 743094E5 		ldr	r3, [r4, #116]
 10040 5194 AA0053E3 		cmp	r3, #170
 10041 5198 2700000A 		beq	.L835
 10042              	.L778:
2434:../uvc.c      ****                 /* Reset the DMA channel. */
 10043              		.loc 1 2434 0
 10044 519c EC039FE5 		ldr	r0, .L840+72
 10045 51a0 FEFFFFEB 		bl	_txe_mutex_put
 10046              	.LVL1092:
2436:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 10047              		.loc 1 2436 0
 10048 51a4 F4039FE5 		ldr	r0, .L840+88
 10049 51a8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 10050              	.LVL1093:
2437:../uvc.c      ****                 {
 10051              		.loc 1 2437 0
 10052 51ac 005050E2 		subs	r5, r0, #0
 10053 51b0 7A00001A 		bne	.L836
2444:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 10054              		.loc 1 2444 0
 10055 51b4 0510A0E1 		mov	r1, r5
 10056 51b8 0520A0E1 		mov	r2, r5
 10057 51bc DC039FE5 		ldr	r0, .L840+88
 10058              	.LVL1094:
 10059 51c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 10060              	.LVL1095:
2445:../uvc.c      ****                 {
 10061              		.loc 1 2445 0
 10062 51c4 005050E2 		subs	r5, r0, #0
 10063 51c8 5E00001A 		bne	.L837
 10064              	.L786:
2453:../uvc.c      ****                 }
 10065              		.loc 1 2453 0
 10066 51cc C0039FE5 		ldr	r0, .L840+76
 10067              	.LVL1096:
 10068 51d0 0230A0E3 		mov	r3, #2
 10069 51d4 0010A0E3 		mov	r1, #0
 10070 51d8 00308DE5 		str	r3, [sp]
 10071 51dc 0020A0E1 		mov	r2, r0
 10072 51e0 0130A0E1 		mov	r3, r1
 10073 51e4 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 10074              	.LVL1097:
 10075 51e8 99FFFFEA 		b	.L776
 10076              	.LVL1098:
 10077              	.L829:
2476:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 10078              		.loc 1 2476 0
 10079 51ec AC039FE5 		ldr	r0, .L840+88
 10080 51f0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 10081              	.LVL1099:
2477:../uvc.c      ****                     {
 10082              		.loc 1 2477 0
 10083 51f4 000050E3 		cmp	r0, #0
 10084 51f8 4A00001A 		bne	.L810
2483:../uvc.c      ****                 }
 10085              		.loc 1 2483 0
 10086 51fc 8300A0E3 		mov	r0, #131
 10087              	.LVL1100:
 10088 5200 FEFFFFEB 		bl	CyU3PUsbFlushEp
 10089              	.LVL1101:
 10090 5204 B1FFFFEA 		b	.L788
 10091              	.L834:
2396:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 10092              		.loc 1 2396 0
 10093 5208 E530D4E5 		ldrb	r3, [r4, #229]	@ zero_extendqisi2
 10094 520c 020053E3 		cmp	r3, #2
 10095 5210 013083E2 		add	r3, r3, #1
 10096 5214 E530C4E5 		strb	r3, [r4, #229]
 10097 5218 DFFFFF9A 		bls	.L778
2397:../uvc.c      ****                 		stiflag = 0x0F;
 10098              		.loc 1 2397 0
 10099 521c 8114D5E5 		ldrb	r1, [r5, #1153]	@ zero_extendqisi2
2398:../uvc.c      ****                 		IMcount = 0;
 10100              		.loc 1 2398 0
 10101 5220 0F30A0E3 		mov	r3, #15
2397:../uvc.c      ****                 		stiflag = 0x0F;
 10102              		.loc 1 2397 0
 10103 5224 201081E3 		orr	r1, r1, #32
2399:../uvc.c      ****                 		}
 10104              		.loc 1 2399 0
 10105 5228 0020A0E3 		mov	r2, #0
2397:../uvc.c      ****                 		stiflag = 0x0F;
 10106              		.loc 1 2397 0
 10107 522c 8114C5E5 		strb	r1, [r5, #1153]
2399:../uvc.c      ****                 		}
 10108              		.loc 1 2399 0
 10109 5230 E520C4E5 		strb	r2, [r4, #229]
2398:../uvc.c      ****                 		IMcount = 0;
 10110              		.loc 1 2398 0
 10111 5234 743084E5 		str	r3, [r4, #116]
 10112 5238 D7FFFFEA 		b	.L778
 10113              	.L835:
2412:../uvc.c      ****                 	{
 10114              		.loc 1 2412 0
 10115 523c E530D4E5 		ldrb	r3, [r4, #229]	@ zero_extendqisi2
 10116 5240 020053E3 		cmp	r3, #2
 10117 5244 013083E2 		add	r3, r3, #1
 10118 5248 E530C4E5 		strb	r3, [r4, #229]
 10119 524c D2FFFF9A 		bls	.L778
2414:../uvc.c      ****                      {
 10120              		.loc 1 2414 0
 10121 5250 E420D4E5 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 10122 5254 010052E3 		cmp	r2, #1
 10123 5258 4600000A 		beq	.L783
 10124 525c 020052E3 		cmp	r2, #2
 10125 5260 0900001A 		bne	.L782
2422:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 10126              		.loc 1 2422 0
 10127 5264 3010A0E3 		mov	r1, #48
 10128 5268 0020A0E3 		mov	r2, #0
 10129 526c 5230A0E3 		mov	r3, #82
 10130 5270 0B00A0E3 		mov	r0, #11
 10131 5274 FEFFFFEB 		bl	SensorSetIrisControl
 10132              	.LVL1102:
2424:../uvc.c      ****                  		break;
 10133              		.loc 1 2424 0
 10134 5278 0400A0E3 		mov	r0, #4
 10135 527c 24139FE5 		ldr	r1, .L840+96
 10136 5280 0B20A0E3 		mov	r2, #11
 10137 5284 0130A0E3 		mov	r3, #1
 10138 5288 FEFFFFEB 		bl	CyU3PDebugPrint
 10139              	.LVL1103:
 10140              	.L782:
2429:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 10141              		.loc 1 2429 0
 10142 528c 0030A0E3 		mov	r3, #0
 10143 5290 E530C7E5 		strb	r3, [r7, #229]
2431:../uvc.c      ****                 	}
 10144              		.loc 1 2431 0
 10145 5294 743087E5 		str	r3, [r7, #116]
 10146 5298 BFFFFFEA 		b	.L778
 10147              	.L833:
2386:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 10148              		.loc 1 2386 0 discriminator 1
 10149 529c 00608DE5 		str	r6, [sp]
 10150 52a0 A4029FE5 		ldr	r0, .L840+4
 10151 52a4 8010A0E3 		mov	r1, #128
 10152 52a8 0320A0E3 		mov	r2, #3
 10153 52ac 60308DE2 		add	r3, sp, #96
 10154 52b0 FEFFFFEB 		bl	_txe_event_flags_get
 10155              	.LVL1104:
 10156 52b4 000050E3 		cmp	r0, #0
 10157 52b8 B1FFFF1A 		bne	.L777
2391:../uvc.c      ****                 		IMcount = 0;
 10158              		.loc 1 2391 0
 10159 52bc FF30A0E3 		mov	r3, #255
2392:../uvc.c      ****                 	}
 10160              		.loc 1 2392 0
 10161 52c0 E500C4E5 		strb	r0, [r4, #229]
2391:../uvc.c      ****                 		IMcount = 0;
 10162              		.loc 1 2391 0
 10163 52c4 743084E5 		str	r3, [r4, #116]
2392:../uvc.c      ****                 	}
 10164              		.loc 1 2392 0
 10165 52c8 B3FFFFEA 		b	.L778
 10166              	.LVL1105:
 10167              	.L831:
 10168              	.LBB476:
 10169              	.LBB474:
2221:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 10170              		.loc 1 2221 0
 10171 52cc D8129FE5 		ldr	r1, .L840+100
 10172 52d0 0100A0E3 		mov	r0, #1
 10173              	.LVL1106:
 10174 52d4 FEFFFFEB 		bl	CyU3PDebugPrint
 10175              	.LVL1107:
2222:../uvc.c      ****     }
 10176              		.loc 1 2222 0
 10177 52d8 D0029FE5 		ldr	r0, .L840+104
 10178 52dc FEFFFFEB 		bl	CyU3PGpifLoad
 10179              	.LVL1108:
 10180 52e0 0050A0E1 		mov	r5, r0
 10181              	.LVL1109:
 10182              	.L792:
2229:../uvc.c      ****     {
 10183              		.loc 1 2229 0
 10184 52e4 000055E3 		cmp	r5, #0
 10185 52e8 3700001A 		bne	.L838
 10186              	.LVL1110:
2241:../uvc.c      ****     {
 10187              		.loc 1 2241 0
 10188 52ec C030D7E5 		ldrb	r3, [r7, #192]	@ zero_extendqisi2
 10189 52f0 023043E2 		sub	r3, r3, #2
 10190 52f4 FF3003E2 		and	r3, r3, #255
 10191 52f8 010053E3 		cmp	r3, #1
 10192 52fc 8BFFFF8A 		bhi	.L793
2239:../uvc.c      ****     }
 10193              		.loc 1 2239 0
 10194 5300 0500A0E1 		mov	r0, r5
 10195 5304 0510A0E1 		mov	r1, r5
 10196 5308 FEFFFFEB 		bl	CyU3PGpifSMStart
 10197              	.LVL1111:
2245:../uvc.c      ****     {
 10198              		.loc 1 2245 0
 10199 530c 005050E2 		subs	r5, r0, #0
 10200 5310 86FFFF0A 		beq	.L793
2248:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10201              		.loc 1 2248 0
 10202 5314 0400A0E3 		mov	r0, #4
 10203              	.LVL1112:
 10204 5318 94129FE5 		ldr	r1, .L840+108
 10205 531c 0520A0E1 		mov	r2, r5
 10206 5320 FEFFFFEB 		bl	CyU3PDebugPrint
 10207              	.LVL1113:
2249:../uvc.c      ****     }
 10208              		.loc 1 2249 0
 10209 5324 0500A0E1 		mov	r0, r5
 10210              	.LVL1114:
 10211              	.L810:
2233:../uvc.c      ****     }
 10212              		.loc 1 2233 0
 10213 5328 FEFFFFEB 		bl	CyFxAppErrorHandler
 10214              	.LVL1115:
 10215              	.L832:
2226:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 10216              		.loc 1 2226 0
 10217 532c 84129FE5 		ldr	r1, .L840+112
 10218 5330 0100A0E3 		mov	r0, #1
 10219              	.LVL1116:
 10220 5334 FEFFFFEB 		bl	CyU3PDebugPrint
 10221              	.LVL1117:
2227:../uvc.c      ****     }
 10222              		.loc 1 2227 0
 10223 5338 7C029FE5 		ldr	r0, .L840+116
 10224 533c FEFFFFEB 		bl	CyU3PGpifLoad
 10225              	.LVL1118:
 10226 5340 0050A0E1 		mov	r5, r0
 10227              	.LVL1119:
 10228 5344 E6FFFFEA 		b	.L792
 10229              	.LVL1120:
 10230              	.L837:
 10231              	.LBE474:
 10232              	.LBE476:
2447:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10233              		.loc 1 2447 0
 10234 5348 0400A0E3 		mov	r0, #4
 10235              	.LVL1121:
 10236 534c 6C129FE5 		ldr	r1, .L840+120
 10237 5350 0520A0E1 		mov	r2, r5
 10238 5354 FEFFFFEB 		bl	CyU3PDebugPrint
 10239              	.LVL1122:
2448:../uvc.c      ****                 }
 10240              		.loc 1 2448 0
 10241 5358 0500A0E1 		mov	r0, r5
 10242 535c FEFFFFEB 		bl	CyFxAppErrorHandler
 10243              	.LVL1123:
 10244              	.L830:
2499:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10245              		.loc 1 2499 0
 10246 5360 0400A0E3 		mov	r0, #4
 10247              	.LVL1124:
 10248 5364 58129FE5 		ldr	r1, .L840+124
 10249 5368 0520A0E1 		mov	r2, r5
 10250 536c FEFFFFEB 		bl	CyU3PDebugPrint
 10251              	.LVL1125:
2500:../uvc.c      ****                 }
 10252              		.loc 1 2500 0
 10253 5370 0500A0E1 		mov	r0, r5
 10254 5374 FEFFFFEB 		bl	CyFxAppErrorHandler
 10255              	.LVL1126:
 10256              	.L783:
2417:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 10257              		.loc 1 2417 0
 10258 5378 3010A0E3 		mov	r1, #48
 10259 537c 5230A0E3 		mov	r3, #82
 10260 5380 0B00A0E3 		mov	r0, #11
 10261 5384 FEFFFFEB 		bl	SensorSetIrisControl
 10262              	.LVL1127:
2419:../uvc.c      ****                  		break;
 10263              		.loc 1 2419 0
 10264 5388 18129FE5 		ldr	r1, .L840+96
 10265 538c 0B20A0E3 		mov	r2, #11
 10266 5390 0030A0E3 		mov	r3, #0
 10267 5394 0400A0E3 		mov	r0, #4
 10268 5398 FEFFFFEB 		bl	CyU3PDebugPrint
 10269              	.LVL1128:
2420:../uvc.c      ****                  	case 2: //960
 10270              		.loc 1 2420 0
 10271 539c BAFFFFEA 		b	.L782
 10272              	.LVL1129:
 10273              	.L836:
2439:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 10274              		.loc 1 2439 0
 10275 53a0 0400A0E3 		mov	r0, #4
 10276              	.LVL1130:
 10277 53a4 1C129FE5 		ldr	r1, .L840+128
 10278 53a8 0520A0E1 		mov	r2, r5
 10279 53ac FEFFFFEB 		bl	CyU3PDebugPrint
 10280              	.LVL1131:
2440:../uvc.c      ****                 }
 10281              		.loc 1 2440 0
 10282 53b0 0500A0E1 		mov	r0, r5
 10283 53b4 FEFFFFEB 		bl	CyFxAppErrorHandler
 10284              	.LVL1132:
 10285              	.L811:
 10286              	.LBB477:
 10287              	.LBB464:
1728:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10288              		.loc 1 1728 0
 10289 53b8 0400A0E3 		mov	r0, #4
 10290              	.LVL1133:
 10291 53bc 08129FE5 		ldr	r1, .L840+132
 10292 53c0 FEFFFFEB 		bl	CyU3PDebugPrint
 10293              	.LVL1134:
1729:../uvc.c      ****     }
 10294              		.loc 1 1729 0
 10295 53c4 0400A0E1 		mov	r0, r4
 10296 53c8 FEFFFFEB 		bl	CyFxAppErrorHandler
 10297              	.LVL1135:
 10298              	.L838:
 10299              	.LBE464:
 10300              	.LBE477:
 10301              	.LBB478:
 10302              	.LBB475:
2232:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10303              		.loc 1 2232 0
 10304 53cc 0400A0E3 		mov	r0, #4
 10305              	.LVL1136:
 10306 53d0 F8119FE5 		ldr	r1, .L840+136
 10307 53d4 0520A0E1 		mov	r2, r5
 10308 53d8 FEFFFFEB 		bl	CyU3PDebugPrint
 10309              	.LVL1137:
2233:../uvc.c      ****     }
 10310              		.loc 1 2233 0
 10311 53dc 0500A0E1 		mov	r0, r5
 10312 53e0 D0FFFFEA 		b	.L810
 10313              	.LVL1138:
 10314              	.L839:
 10315              	.LBE475:
 10316              	.LBE478:
 10317              	.LBB479:
 10318              	.LBB469:
2194:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10319              		.loc 1 2194 0
 10320 53e4 0600A0E1 		mov	r0, r6
 10321              	.LVL1139:
 10322              	.L808:
 10323 53e8 E4119FE5 		ldr	r1, .L840+140
 10324 53ec 0420A0E1 		mov	r2, r4
 10325 53f0 FEFFFFEB 		bl	CyU3PDebugPrint
 10326              	.LVL1140:
2195:../uvc.c      ****     }
 10327              		.loc 1 2195 0
 10328 53f4 0400A0E1 		mov	r0, r4
 10329 53f8 CAFFFFEA 		b	.L810
 10330              	.LVL1141:
 10331              	.L825:
2169:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10332              		.loc 1 2169 0
 10333 53fc 0600A0E1 		mov	r0, r6
 10334              	.LVL1142:
 10335 5400 D0119FE5 		ldr	r1, .L840+144
 10336 5404 0420A0E1 		mov	r2, r4
 10337 5408 FEFFFFEB 		bl	CyU3PDebugPrint
 10338              	.LVL1143:
2170:../uvc.c      ****     }
 10339              		.loc 1 2170 0
 10340 540c 0400A0E1 		mov	r0, r4
 10341 5410 FEFFFFEB 		bl	CyFxAppErrorHandler
 10342              	.LVL1144:
 10343              	.L824:
2078:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10344              		.loc 1 2078 0
 10345 5414 0600A0E1 		mov	r0, r6
 10346              	.LVL1145:
 10347 5418 BC119FE5 		ldr	r1, .L840+148
 10348 541c 0420A0E1 		mov	r2, r4
 10349 5420 FEFFFFEB 		bl	CyU3PDebugPrint
 10350              	.LVL1146:
2079:../uvc.c      ****     }
 10351              		.loc 1 2079 0
 10352 5424 0400A0E1 		mov	r0, r4
 10353 5428 FEFFFFEB 		bl	CyFxAppErrorHandler
 10354              	.LVL1147:
 10355              	.L823:
2054:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 10356              		.loc 1 2054 0
 10357 542c 0400A0E3 		mov	r0, #4
 10358 5430 A8119FE5 		ldr	r1, .L840+152
 10359 5434 FEFFFFEB 		bl	CyU3PDebugPrint
 10360              	.LVL1148:
2055:../uvc.c      ****     }
 10361              		.loc 1 2055 0
 10362 5438 0600A0E1 		mov	r0, r6
 10363 543c FEFFFFEB 		bl	CyFxAppErrorHandler
 10364              	.LVL1149:
 10365              	.L822:
2047:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10366              		.loc 1 2047 0
 10367 5440 0400A0E3 		mov	r0, #4
 10368              	.LVL1150:
 10369 5444 98119FE5 		ldr	r1, .L840+156
 10370 5448 0420A0E1 		mov	r2, r4
 10371 544c FEFFFFEB 		bl	CyU3PDebugPrint
 10372              	.LVL1151:
2048:../uvc.c      ****     }
 10373              		.loc 1 2048 0
 10374 5450 0400A0E1 		mov	r0, r4
 10375 5454 FEFFFFEB 		bl	CyFxAppErrorHandler
 10376              	.LVL1152:
 10377              	.L821:
1981:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10378              		.loc 1 1981 0
 10379 5458 0400A0E3 		mov	r0, #4
 10380              	.LVL1153:
 10381 545c 84119FE5 		ldr	r1, .L840+160
 10382 5460 0420A0E1 		mov	r2, r4
 10383 5464 FEFFFFEB 		bl	CyU3PDebugPrint
 10384              	.LVL1154:
1982:../uvc.c      ****     }
 10385              		.loc 1 1982 0
 10386 5468 0400A0E1 		mov	r0, r4
 10387 546c FEFFFFEB 		bl	CyFxAppErrorHandler
 10388              	.LVL1155:
 10389              	.L820:
1961:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10390              		.loc 1 1961 0
 10391 5470 0400A0E3 		mov	r0, #4
 10392              	.LVL1156:
 10393 5474 70119FE5 		ldr	r1, .L840+164
 10394 5478 0420A0E1 		mov	r2, r4
 10395 547c FEFFFFEB 		bl	CyU3PDebugPrint
 10396              	.LVL1157:
1962:../uvc.c      ****     }
 10397              		.loc 1 1962 0
 10398 5480 0400A0E1 		mov	r0, r4
 10399 5484 FEFFFFEB 		bl	CyFxAppErrorHandler
 10400              	.LVL1158:
 10401              	.L815:
1901:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10402              		.loc 1 1901 0
 10403 5488 0400A0E3 		mov	r0, #4
 10404              	.LVL1159:
 10405 548c 5C119FE5 		ldr	r1, .L840+168
 10406 5490 0520A0E1 		mov	r2, r5
 10407 5494 FEFFFFEB 		bl	CyU3PDebugPrint
 10408              	.LVL1160:
1902:../uvc.c      ****     }
 10409              		.loc 1 1902 0
 10410 5498 0500A0E1 		mov	r0, r5
 10411 549c FEFFFFEB 		bl	CyFxAppErrorHandler
 10412              	.LVL1161:
 10413              	.L814:
1895:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10414              		.loc 1 1895 0
 10415 54a0 0400A0E3 		mov	r0, #4
 10416              	.LVL1162:
 10417 54a4 48119FE5 		ldr	r1, .L840+172
 10418 54a8 0520A0E1 		mov	r2, r5
 10419 54ac FEFFFFEB 		bl	CyU3PDebugPrint
 10420              	.LVL1163:
1896:../uvc.c      ****     }
 10421              		.loc 1 1896 0
 10422 54b0 0500A0E1 		mov	r0, r5
 10423 54b4 FEFFFFEB 		bl	CyFxAppErrorHandler
 10424              	.LVL1164:
 10425              	.L813:
1886:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10426              		.loc 1 1886 0
 10427 54b8 0400A0E3 		mov	r0, #4
 10428              	.LVL1165:
 10429 54bc 34119FE5 		ldr	r1, .L840+176
 10430 54c0 0520A0E1 		mov	r2, r5
 10431 54c4 FEFFFFEB 		bl	CyU3PDebugPrint
 10432              	.LVL1166:
1887:../uvc.c      ****     }
 10433              		.loc 1 1887 0
 10434 54c8 0500A0E1 		mov	r0, r5
 10435 54cc FEFFFFEB 		bl	CyFxAppErrorHandler
 10436              	.LVL1167:
 10437              	.L812:
1864:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10438              		.loc 1 1864 0
 10439 54d0 0400A0E3 		mov	r0, #4
 10440              	.LVL1168:
 10441 54d4 20119FE5 		ldr	r1, .L840+180
 10442 54d8 0520A0E1 		mov	r2, r5
 10443 54dc FEFFFFEB 		bl	CyU3PDebugPrint
 10444              	.LVL1169:
1865:../uvc.c      ****     }
 10445              		.loc 1 1865 0
 10446 54e0 0500A0E1 		mov	r0, r5
 10447 54e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 10448              	.LVL1170:
 10449              	.L819:
1948:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10450              		.loc 1 1948 0
 10451 54e8 0400A0E3 		mov	r0, #4
 10452              	.LVL1171:
 10453 54ec 0C119FE5 		ldr	r1, .L840+184
 10454 54f0 0920A0E1 		mov	r2, r9
 10455 54f4 FEFFFFEB 		bl	CyU3PDebugPrint
 10456              	.LVL1172:
1949:../uvc.c      ****     }
 10457              		.loc 1 1949 0
 10458 54f8 0900A0E1 		mov	r0, r9
 10459 54fc FEFFFFEB 		bl	CyFxAppErrorHandler
 10460              	.LVL1173:
 10461              	.L818:
1934:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10462              		.loc 1 1934 0
 10463 5500 0400A0E3 		mov	r0, #4
 10464              	.LVL1174:
 10465 5504 F8109FE5 		ldr	r1, .L840+188
 10466 5508 0920A0E1 		mov	r2, r9
 10467 550c FEFFFFEB 		bl	CyU3PDebugPrint
 10468              	.LVL1175:
1935:../uvc.c      ****     }
 10469              		.loc 1 1935 0
 10470 5510 0900A0E1 		mov	r0, r9
 10471 5514 FEFFFFEB 		bl	CyFxAppErrorHandler
 10472              	.LVL1176:
 10473              	.L817:
1920:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10474              		.loc 1 1920 0
 10475 5518 0400A0E3 		mov	r0, #4
 10476              	.LVL1177:
 10477 551c E4109FE5 		ldr	r1, .L840+192
 10478 5520 0920A0E1 		mov	r2, r9
 10479 5524 FEFFFFEB 		bl	CyU3PDebugPrint
 10480              	.LVL1178:
1921:../uvc.c      ****     }
 10481              		.loc 1 1921 0
 10482 5528 0900A0E1 		mov	r0, r9
 10483 552c FEFFFFEB 		bl	CyFxAppErrorHandler
 10484              	.LVL1179:
 10485              	.L816:
1907:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 10486              		.loc 1 1907 0
 10487 5530 0400A0E3 		mov	r0, #4
 10488              	.LVL1180:
 10489 5534 D0109FE5 		ldr	r1, .L840+196
 10490 5538 0520A0E1 		mov	r2, r5
 10491 553c FEFFFFEB 		bl	CyU3PDebugPrint
 10492              	.LVL1181:
1908:../uvc.c      ****     }
 10493              		.loc 1 1908 0
 10494 5540 0500A0E1 		mov	r0, r5
 10495 5544 FEFFFFEB 		bl	CyFxAppErrorHandler
 10496              	.LVL1182:
 10497              	.L841:
 10498              		.align	2
 10499              	.L840:
 10500 5548 00C20100 		.word	115200
 10501 554c 00000000 		.word	.LANCHOR0
 10502 5550 00000000 		.word	CyFxGpifCB
 10503 5554 00000000 		.word	CyFxUVCApplnUSBSetupCB
 10504 5558 00000000 		.word	CyFxUVCApplnUSBEventCB
 10505 555c 00000000 		.word	CyFxUSBDeviceDscr
 10506 5560 00000000 		.word	CyFxUSBDeviceDscrSS
 10507 5564 00000000 		.word	CyFxUSBDeviceQualDscr
 10508 5568 00000000 		.word	CyFxUSBBOSDscr
 10509 556c 00000000 		.word	CyFxUSBHSConfigDscr
 10510 5570 00000000 		.word	CyFxUSBFSConfigDscr
 10511 5574 00000000 		.word	CyFxUSBSSConfigDscr
 10512 5578 00000000 		.word	CyFxUSBStringLangIDDscr
 10513 557c 00000000 		.word	CyFxUSBManufactureDscr
 10514 5580 00000000 		.word	CyFxUSBProductDscr
 10515 5584 013F0203 		.word	50478849
 10516 5588 00000000 		.word	glChHandleInterStat
 10517 558c 00000000 		.word	glInterStaBuffer
 10518 5590 00000000 		.word	imgHdMux
 10519 5594 01010000 		.word	257
 10520 5598 03030000 		.word	771
 10521 559c 00000000 		.word	CyFxUvcApplnDmaCallback
 10522 55a0 00000000 		.word	glChHandleUVCStream
 10523 55a4 00000000 		.word	.LANCHOR1
 10524 55a8 180A0000 		.word	.LC58
 10525 55ac D00A0000 		.word	.LC62
 10526 55b0 20000000 		.word	.LANCHOR2+32
 10527 55b4 280B0000 		.word	.LC65
 10528 55b8 E00A0000 		.word	.LC63
 10529 55bc 3C000000 		.word	.LANCHOR2+60
 10530 55c0 680A0000 		.word	.LC60
 10531 55c4 9C0A0000 		.word	.LC61
 10532 55c8 3C0A0000 		.word	.LC59
 10533 55cc 24070000 		.word	.LC42
 10534 55d0 F00A0000 		.word	.LC64
 10535 55d4 14090000 		.word	.LC53
 10536 55d8 F0090000 		.word	.LC57
 10537 55dc C0090000 		.word	.LC56
 10538 55e0 88090000 		.word	.LC55
 10539 55e4 48090000 		.word	.LC54
 10540 55e8 E4080000 		.word	.LC52
 10541 55ec B4080000 		.word	.LC51
 10542 55f0 BC070000 		.word	.LC46
 10543 55f4 94070000 		.word	.LC45
 10544 55f8 70070000 		.word	.LC44
 10545 55fc 44070000 		.word	.LC43
 10546 5600 7C080000 		.word	.LC50
 10547 5604 48080000 		.word	.LC49
 10548 5608 14080000 		.word	.LC48
 10549 560c E8070000 		.word	.LC47
 10550              	.LBE469:
 10551              	.LBE479:
 10552              		.cfi_endproc
 10553              	.LFE18:
 10555              		.align	2
 10556              		.global	CyFxApplicationDefine
 10558              	CyFxApplicationDefine:
 10559              	.LFB26:
3819:../uvc.c      **** }
3820:../uvc.c      **** 
3821:../uvc.c      **** 
3822:../uvc.c      **** /*
3823:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3824:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3825:../uvc.c      ****  */
3826:../uvc.c      **** void
3827:../uvc.c      **** CyFxApplicationDefine (
3828:../uvc.c      ****         void)
3829:../uvc.c      **** {
 10560              		.loc 1 3829 0
 10561              		.cfi_startproc
 10562              		@ args = 0, pretend = 0, frame = 40
 10563              		@ frame_needed = 0, uses_anonymous_args = 0
 10564              	.LVL1183:
 10565 5610 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 10566              	.LCFI27:
 10567              		.cfi_def_cfa_offset 36
 10568              		.cfi_offset 4, -36
 10569              		.cfi_offset 5, -32
 10570              		.cfi_offset 6, -28
 10571              		.cfi_offset 7, -24
 10572              		.cfi_offset 8, -20
 10573              		.cfi_offset 9, -16
 10574              		.cfi_offset 10, -12
 10575              		.cfi_offset 11, -8
 10576              		.cfi_offset 14, -4
3830:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3831:../uvc.c      ****     uint32_t retThrdCreate;
3832:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3833:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3834:../uvc.c      **** 
3835:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3836:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10577              		.loc 1 3836 0
 10578 5614 010AA0E3 		mov	r0, #4096
3829:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 10579              		.loc 1 3829 0
 10580 5618 4CD04DE2 		sub	sp, sp, #76
 10581              	.LCFI28:
 10582              		.cfi_def_cfa_offset 112
 10583              		.loc 1 3836 0
 10584 561c FEFFFFEB 		bl	CyU3PMemAlloc
 10585              	.LVL1184:
 10586 5620 00A0A0E1 		mov	r10, r0
 10587              	.LVL1185:
3837:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10588              		.loc 1 3837 0
 10589 5624 010AA0E3 		mov	r0, #4096
 10590              	.LVL1186:
 10591 5628 FEFFFFEB 		bl	CyU3PMemAlloc
 10592              	.LVL1187:
 10593 562c 0090A0E1 		mov	r9, r0
 10594              	.LVL1188:
3838:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10595              		.loc 1 3838 0
 10596 5630 010AA0E3 		mov	r0, #4096
 10597              	.LVL1189:
 10598 5634 FEFFFFEB 		bl	CyU3PMemAlloc
 10599              	.LVL1190:
3839:../uvc.c      **** 
3840:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 10600              		.loc 1 3840 0
 10601 5638 000059E3 		cmp	r9, #0
 10602 563c 00005A13 		cmpne	r10, #0
 10603 5640 00C0A013 		movne	ip, #0
 10604 5644 01C0A003 		moveq	ip, #1
3838:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 10605              		.loc 1 3838 0
 10606 5648 00B0A0E1 		mov	fp, r0
 10607              	.LVL1191:
 10608              		.loc 1 3840 0
 10609 564c 0000001A 		bne	.L853
 10610              	.LVL1192:
 10611              	.L843:
 10612              	.L845:
 10613 5650 FEFFFFEA 		b	.L845
 10614              	.LVL1193:
 10615              	.L853:
 10616              		.loc 1 3840 0 is_stmt 0 discriminator 1
 10617 5654 000050E3 		cmp	r0, #0
 10618 5658 FCFFFF0A 		beq	.L843
3841:../uvc.c      ****         goto fatalErrorHandler;
3842:../uvc.c      **** 
3843:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3844:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 10619              		.loc 1 3844 0 is_stmt 1
 10620 565c 28008DE2 		add	r0, sp, #40
 10621              	.LVL1194:
 10622 5660 4010A0E3 		mov	r1, #64
 10623 5664 0C219FE5 		ldr	r2, .L854
 10624 5668 28708DE2 		add	r7, sp, #40
 10625 566c 24C08DE5 		str	ip, [sp, #36]
 10626 5670 FEFFFFEB 		bl	cmdbufCreate
 10627              	.LVL1195:
 10628 5674 0F00B7E8 		ldmia	r7!, {r0, r1, r2, r3}
 10629 5678 FC509FE5 		ldr	r5, .L854+4
3845:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10630              		.loc 1 3845 0
 10631 567c FC409FE5 		ldr	r4, .L854+8
3844:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10632              		.loc 1 3844 0
 10633 5680 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 10634 5684 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
3846:../uvc.c      **** 
3847:../uvc.c      **** 	/****** initialize command descriptor ***********/
3848:../uvc.c      **** 	cmdquInit(cmdQuptr);
3849:../uvc.c      **** 	cmdquInit(statQuptr);
3850:../uvc.c      **** 
3851:../uvc.c      ****     /* Create the UVC application thread. */
3852:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 10635              		.loc 1 3852 0
 10636 5688 0860A0E3 		mov	r6, #8
3844:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 10637              		.loc 1 3844 0
 10638 568c 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
3845:../uvc.c      **** 
 10639              		.loc 1 3845 0
 10640 5690 EC209FE5 		ldr	r2, .L854+12
 10641 5694 28008DE2 		add	r0, sp, #40
 10642 5698 2010A0E3 		mov	r1, #32
 10643 569c FEFFFFEB 		bl	cmdbufCreate
 10644              	.LVL1196:
 10645 56a0 28E08DE2 		add	lr, sp, #40
 10646 56a4 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 10647              		.loc 1 3852 0
 10648 56a8 0180A0E3 		mov	r8, #1
3845:../uvc.c      **** 
 10649              		.loc 1 3845 0
 10650 56ac 0F00A4E8 		stmia	r4!, {r0, r1, r2, r3}
 10651 56b0 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
 10652              		.loc 1 3852 0
 10653 56b4 A870A0E3 		mov	r7, #168
3845:../uvc.c      **** 
 10654              		.loc 1 3845 0
 10655 56b8 0F0084E8 		stmia	r4, {r0, r1, r2, r3}
3848:../uvc.c      **** 	cmdquInit(statQuptr);
 10656              		.loc 1 3848 0
 10657 56bc 100045E2 		sub	r0, r5, #16
 10658 56c0 FEFFFFEB 		bl	cmdquInit
 10659              	.LVL1197:
3849:../uvc.c      **** 
 10660              		.loc 1 3849 0
 10661 56c4 100044E2 		sub	r0, r4, #16
 10662 56c8 FEFFFFEB 		bl	cmdquInit
 10663              	.LVL1198:
 10664              		.loc 1 3852 0
 10665 56cc 24C09DE5 		ldr	ip, [sp, #36]
 10666 56d0 012AA0E3 		mov	r2, #4096
 10667 56d4 0C30A0E1 		mov	r3, ip
 10668 56d8 44008DE9 		stmib	sp, {r2, r6}
 10669 56dc A4009FE5 		ldr	r0, .L854+16
 10670 56e0 00A08DE5 		str	r10, [sp]
 10671 56e4 10C08DE5 		str	ip, [sp, #16]
 10672 56e8 0C608DE5 		str	r6, [sp, #12]
 10673 56ec 14808DE5 		str	r8, [sp, #20]
 10674 56f0 18708DE5 		str	r7, [sp, #24]
 10675 56f4 90109FE5 		ldr	r1, .L854+20
 10676 56f8 90209FE5 		ldr	r2, .L854+24
 10677 56fc FEFFFFEB 		bl	_txe_thread_create
 10678              	.LVL1199:
3853:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3854:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3855:../uvc.c      ****             0,                                          /* No input parameter to thread */
3856:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3857:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3858:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3859:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3860:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3861:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3862:../uvc.c      ****             );
3863:../uvc.c      ****     if (retThrdCreate != 0)
 10679              		.loc 1 3863 0
 10680 5700 003050E2 		subs	r3, r0, #0
 10681 5704 D1FFFF1A 		bne	.L843
3864:../uvc.c      ****     {
3865:../uvc.c      ****         goto fatalErrorHandler;
3866:../uvc.c      ****     }
3867:../uvc.c      **** 
3868:../uvc.c      ****     /* Create the control request handling thread. */
3869:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 10682              		.loc 1 3869 0
 10683 5708 024BA0E3 		mov	r4, #2048
 10684 570c 10308DE5 		str	r3, [sp, #16]
 10685 5710 00908DE5 		str	r9, [sp]
 10686 5714 08608DE5 		str	r6, [sp, #8]
 10687 5718 0C608DE5 		str	r6, [sp, #12]
 10688 571c 14808DE5 		str	r8, [sp, #20]
 10689 5720 18708DE5 		str	r7, [sp, #24]
 10690 5724 04408DE5 		str	r4, [sp, #4]
 10691 5728 64009FE5 		ldr	r0, .L854+28
 10692              	.LVL1200:
 10693 572c 64109FE5 		ldr	r1, .L854+32
 10694 5730 64209FE5 		ldr	r2, .L854+36
 10695 5734 FEFFFFEB 		bl	_txe_thread_create
 10696              	.LVL1201:
3870:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3871:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3872:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3873:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3874:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3875:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3876:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3877:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3878:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3879:../uvc.c      ****             );
3880:../uvc.c      ****     if (retThrdCreate != 0)
 10697              		.loc 1 3880 0
 10698 5738 003050E2 		subs	r3, r0, #0
 10699 573c C3FFFF1A 		bne	.L843
3881:../uvc.c      ****     {
3882:../uvc.c      ****         goto fatalErrorHandler;
3883:../uvc.c      ****     }
3884:../uvc.c      **** #if 1
3885:../uvc.c      ****     /* Create the I2C control command handling thread. */
3886:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 10700              		.loc 1 3886 0
 10701 5740 00B08DE5 		str	fp, [sp]
 10702 5744 50008DE9 		stmib	sp, {r4, r6}
 10703 5748 50009FE5 		ldr	r0, .L854+40
 10704              	.LVL1202:
 10705 574c 0C608DE5 		str	r6, [sp, #12]
 10706 5750 10308DE5 		str	r3, [sp, #16]
 10707 5754 14808DE5 		str	r8, [sp, #20]
 10708 5758 18708DE5 		str	r7, [sp, #24]
 10709 575c 40109FE5 		ldr	r1, .L854+44
 10710 5760 40209FE5 		ldr	r2, .L854+48
 10711 5764 FEFFFFEB 		bl	_txe_thread_create
 10712              	.LVL1203:
3887:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3888:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3889:../uvc.c      ****             0,                                          /* No input parameter to thread */
3890:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3891:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3892:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3893:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3894:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3895:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3896:../uvc.c      ****             );
3897:../uvc.c      ****     if (retThrdCreate != 0)
 10713              		.loc 1 3897 0
 10714 5768 000050E3 		cmp	r0, #0
 10715 576c B7FFFF1A 		bne	.L843
3898:../uvc.c      ****     {
3899:../uvc.c      ****         goto fatalErrorHandler;
3900:../uvc.c      ****     }
3901:../uvc.c      **** #endif
3902:../uvc.c      **** 
3903:../uvc.c      ****     return;
3904:../uvc.c      **** 
3905:../uvc.c      **** fatalErrorHandler:
3906:../uvc.c      ****     /* Add custom recovery or debug actions here */
3907:../uvc.c      ****     /* Loop indefinitely */
3908:../uvc.c      ****     while (1);
3909:../uvc.c      **** }
 10716              		.loc 1 3909 0
 10717 5770 4CD08DE2 		add	sp, sp, #76
 10718              		@ sp needed
 10719 5774 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 10720              	.LVL1204:
 10721              	.L855:
 10722              		.align	2
 10723              	.L854:
 10724 5778 00000000 		.word	cmdQuMux
 10725 577c 00000000 		.word	cmdQu
 10726 5780 00000000 		.word	statQu
 10727 5784 00000000 		.word	staQuMux
 10728 5788 E8000000 		.word	.LANCHOR0+232
 10729 578c 600B0000 		.word	.LC66
 10730 5790 00000000 		.word	UVCAppThread_Entry
 10731 5794 90010000 		.word	.LANCHOR0+400
 10732 5798 740B0000 		.word	.LC67
 10733 579c 00000000 		.word	UVCAppEP0Thread_Entry
 10734 57a0 38020000 		.word	.LANCHOR0+568
 10735 57a4 8C0B0000 		.word	.LC68
 10736 57a8 00000000 		.word	I2cAppThread_Entry
 10737              		.cfi_endproc
 10738              	.LFE26:
 10740              		.section	.text.startup,"ax",%progbits
 10741              		.align	2
 10742              		.global	main
 10744              	main:
 10745              	.LFB27:
3910:../uvc.c      **** 
3911:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3912:../uvc.c      ****  * the ThreadX RTOS here.
3913:../uvc.c      ****  */
3914:../uvc.c      **** int
3915:../uvc.c      **** main (
3916:../uvc.c      ****         void)
3917:../uvc.c      **** {
 10746              		.loc 1 3917 0
 10747              		.cfi_startproc
 10748              		@ args = 0, pretend = 0, frame = 56
 10749              		@ frame_needed = 0, uses_anonymous_args = 0
 10750 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 10751              	.LCFI29:
 10752              		.cfi_def_cfa_offset 12
 10753              		.cfi_offset 4, -12
 10754              		.cfi_offset 5, -8
 10755              		.cfi_offset 14, -4
 10756 0004 3CD04DE2 		sub	sp, sp, #60
 10757              	.LCFI30:
 10758              		.cfi_def_cfa_offset 72
3918:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3919:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3920:../uvc.c      **** 
3921:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3922:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3923:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10759              		.loc 1 3923 0
 10760 0008 0230A0E3 		mov	r3, #2
3924:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3925:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3926:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 10761              		.loc 1 3926 0
 10762 000c 0010A0E3 		mov	r1, #0
3927:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 10763              		.loc 1 3927 0
 10764 0010 0320A0E3 		mov	r2, #3
3922:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10765              		.loc 1 3922 0
 10766 0014 0150A0E3 		mov	r5, #1
3928:../uvc.c      **** 
3929:../uvc.c      ****     /* Initialize the device */
3930:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 10767              		.loc 1 3930 0
 10768 0018 0D00A0E1 		mov	r0, sp
3922:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 10769              		.loc 1 3922 0
 10770 001c 00508DE5 		str	r5, [sp]
3923:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 10771              		.loc 1 3923 0
 10772 0020 0430CDE5 		strb	r3, [sp, #4]
3924:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 10773              		.loc 1 3924 0
 10774 0024 0530CDE5 		strb	r3, [sp, #5]
3925:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 10775              		.loc 1 3925 0
 10776 0028 0630CDE5 		strb	r3, [sp, #6]
3926:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 10777              		.loc 1 3926 0
 10778 002c 08108DE5 		str	r1, [sp, #8]
3927:../uvc.c      **** 
 10779              		.loc 1 3927 0
 10780 0030 0C20CDE5 		strb	r2, [sp, #12]
 10781              		.loc 1 3930 0
 10782 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 10783              	.LVL1205:
3931:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10784              		.loc 1 3931 0
 10785 0038 004050E2 		subs	r4, r0, #0
 10786 003c 0000000A 		beq	.L861
 10787              	.L857:
 10788              	.L858:
 10789 0040 FEFFFFEA 		b	.L858
 10790              	.L861:
3932:../uvc.c      ****     {
3933:../uvc.c      ****         goto handle_fatal_error;
3934:../uvc.c      ****     }
3935:../uvc.c      **** 
3936:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3937:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 10791              		.loc 1 3937 0
 10792 0044 0410A0E1 		mov	r1, r4
 10793 0048 0420A0E1 		mov	r2, r4
 10794 004c 0500A0E1 		mov	r0, r5
 10795              	.LVL1206:
 10796 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 10797              	.LVL1207:
3938:../uvc.c      **** 
3939:../uvc.c      ****     /* Configure the IO matrix for the device. */
3940:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3941:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3942:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3943:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3944:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3945:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3946:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3947:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3948:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3949:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3950:../uvc.c      **** 
3951:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 10798              		.loc 1 3951 0
 10799 0054 10008DE2 		add	r0, sp, #16
3941:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 10800              		.loc 1 3941 0
 10801 0058 2640CDE5 		strb	r4, [sp, #38]
3942:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 10802              		.loc 1 3942 0
 10803 005c 28408DE5 		str	r4, [sp, #40]
3943:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 10804              		.loc 1 3943 0
 10805 0060 2C408DE5 		str	r4, [sp, #44]
3944:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 10806              		.loc 1 3944 0
 10807 0064 30408DE5 		str	r4, [sp, #48]
3945:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 10808              		.loc 1 3945 0
 10809 0068 34408DE5 		str	r4, [sp, #52]
3948:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 10810              		.loc 1 3948 0
 10811 006c 1C408DE5 		str	r4, [sp, #28]
3949:../uvc.c      **** 
 10812              		.loc 1 3949 0
 10813 0070 20408DE5 		str	r4, [sp, #32]
3940:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 10814              		.loc 1 3940 0
 10815 0074 10508DE5 		str	r5, [sp, #16]
3946:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 10816              		.loc 1 3946 0
 10817 0078 14508DE5 		str	r5, [sp, #20]
3947:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 10818              		.loc 1 3947 0
 10819 007c 18508DE5 		str	r5, [sp, #24]
 10820              		.loc 1 3951 0
 10821 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 10822              	.LVL1208:
3952:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10823              		.loc 1 3952 0
 10824 0084 004050E2 		subs	r4, r0, #0
 10825 0088 ECFFFF1A 		bne	.L857
3953:../uvc.c      ****     {
3954:../uvc.c      ****         goto handle_fatal_error;
3955:../uvc.c      ****     }
3956:../uvc.c      **** 
3957:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3958:../uvc.c      ****     CyU3PKernelEntry ();
 10826              		.loc 1 3958 0
 10827 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 10828              	.LVL1209:
3959:../uvc.c      **** 
3960:../uvc.c      ****     /* Dummy return to make the compiler happy */
3961:../uvc.c      ****     return 0;
3962:../uvc.c      **** 
3963:../uvc.c      **** handle_fatal_error:
3964:../uvc.c      ****     /* Cannot recover from this error. */
3965:../uvc.c      ****     while (1);
3966:../uvc.c      **** }
 10829              		.loc 1 3966 0
 10830 0090 0400A0E1 		mov	r0, r4
 10831 0094 3CD08DE2 		add	sp, sp, #60
 10832              		@ sp needed
 10833 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 10834              		.cfi_endproc
 10835              	.LFE27:
 10837              		.comm	I2CCmdTimer,44,4
 10838              		.comm	posTick,4,4
 10839              		.global	glUVCHeader
 10840              		.global	glProbeStilCtrl20
 10841              		.global	glProbeCtrl20
 10842              		.global	glProbeStilCtrl
 10843              		.global	glProbeCtrl
 10844              		.global	streamingStarted
 10845              		.global	clearFeatureRqtReceived
 10846              		.global	usbSpeed
 10847              		.global	isUsbConnected
 10848              		.global	pbcpbak
 10849              		.global	pbcbak
 10850              		.global	pbbak
 10851              		.global	fbbak
 10852              		.global	pbc
 10853              		.global	pb
 10854              		.global	fb
 10855              		.comm	wLength,2,2
 10856              		.comm	wIndex,2,2
 10857              		.comm	wValue,2,2
 10858              		.comm	bRequest,1,1
 10859              		.comm	bmReqType,1,1
 10860              		.comm	imgHdMux,56,4
 10861              		.comm	timMux,56,4
 10862              		.comm	staQuMux,56,4
 10863              		.comm	cmdQuMux,56,4
 10864              		.comm	statQu,32,4
 10865              		.comm	cmdQu,32,4
 10866              		.global	testSnap
 10867              		.global	snapButFlag
 10868              		.comm	glInterStaBuffer,4,4
 10869              		.comm	glChHandleInterStat,172,4
 10870              		.comm	glChHandleStillStream,232,4
 10871              		.comm	glChHandleUVCStream,232,4
 10872              		.global	CyFxGpifConfig_usb2
 10873              		.global	CyFxGpifRegValue_usb2
 10874              		.global	CyFxGpifWavedataPosition_usb2
 10875              		.global	CyFxGpifWavedata_usb2
 10876              		.global	CyFxGpifTransition_usb2
 10877              		.global	CyFxGpifConfig
 10878              		.global	CyFxGpifRegValue
 10879              		.global	CyFxGpifWavedataPosition
 10880              		.global	CyFxGpifWavedata
 10881              		.global	CyFxGpifTransition
 10882              		.section	.rodata
 10883              		.align	2
 10884              		.set	.LANCHOR2,. + 0
 10887              	ExTime:
 10888 0000 9C       		.byte	-100
 10889 0001 00       		.byte	0
 10890 0002 4E       		.byte	78
 10891 0003 00       		.byte	0
 10892 0004 27       		.byte	39
 10893 0005 00       		.byte	0
 10894 0006 14       		.byte	20
 10895 0007 00       		.byte	0
 10896 0008 0A       		.byte	10
 10897 0009 00       		.byte	0
 10898 000a 05       		.byte	5
 10899 000b 00       		.byte	0
 10900 000c 02       		.byte	2
 10901 000d 00       		.byte	0
 10902 000e 01       		.byte	1
 10903 000f 00       		.byte	0
 10906              	ShutValueArry:
 10907 0010 C800     		.short	200
 10908 0012 6400     		.short	100
 10909 0014 2700     		.short	39
 10910 0016 1400     		.short	20
 10911 0018 0A00     		.short	10
 10912 001a 0500     		.short	5
 10913 001c 0200     		.short	2
 10914 001e 0100     		.short	1
 10917              	CyFxGpifConfig:
 10918 0020 0F00     		.short	15
 10919 0022 0000     		.space	2
 10920 0024 00000000 		.word	CyFxGpifWavedata
 10921 0028 00000000 		.word	CyFxGpifWavedataPosition
 10922 002c 0500     		.short	5
 10923 002e 0000     		.space	2
 10924 0030 00000000 		.word	CyFxGpifTransition
 10925 0034 4C00     		.short	76
 10926 0036 0000     		.space	2
 10927 0038 00000000 		.word	CyFxGpifRegValue
 10930              	CyFxGpifConfig_usb2:
 10931 003c 9300     		.short	147
 10932 003e 0000     		.space	2
 10933 0040 00000000 		.word	CyFxGpifWavedata_usb2
 10934 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 10935 0048 0800     		.short	8
 10936 004a 0000     		.space	2
 10937 004c 00000000 		.word	CyFxGpifTransition_usb2
 10938 0050 4C00     		.short	76
 10939 0052 0000     		.space	2
 10940 0054 00000000 		.word	CyFxGpifRegValue_usb2
 10941              		.data
 10942              		.align	2
 10943              		.set	.LANCHOR1,. + 0
 10946              	ExUCtrlParArry:
 10947 0000 00       		.byte	0
 10948 0001 00       		.byte	0
 10949 0002 04       		.byte	4
 10950 0003 01       		.byte	1
 10951 0004 00       		.byte	0
 10952 0005 38       		.byte	56
 10953 0006 01       		.byte	1
 10954 0007 01       		.byte	1
 10955 0008 00       		.byte	0
 10956 0009 03       		.byte	3
 10957 000a 00       		.byte	0
 10958 000b 4E       		.byte	78
 10959 000c 00       		.byte	0
 10960 000d 4E       		.byte	78
 10961 000e 00       		.byte	0
 10962 000f 30       		.byte	48
 10963 0010 01       		.byte	1
 10964 0011 00       		.byte	0
 10965 0012 00       		.byte	0
 10966 0013 00000000 		.space	5
 10966      00
 10967 0018 00       		.byte	0
 10968 0019 00       		.byte	0
 10969 001a 01       		.byte	1
 10970 001b 00       		.byte	0
 10971 001c 00       		.byte	0
 10972 001d 00       		.byte	0
 10973 001e 00       		.byte	0
 10974 001f 01       		.byte	1
 10975 0020 00       		.byte	0
 10976 0021 03       		.byte	3
 10977 0022 00       		.byte	0
 10978 0023 00       		.byte	0
 10979 0024 00       		.byte	0
 10980 0025 00       		.byte	0
 10981 0026 00       		.byte	0
 10982 0027 30       		.byte	48
 10983 0028 01       		.byte	1
 10984 0029 00       		.byte	0
 10985 002a 00       		.byte	0
 10986 002b 00000000 		.space	5
 10986      00
 10987 0030 00       		.byte	0
 10988 0031 00       		.byte	0
 10989 0032 02       		.byte	2
 10990 0033 00       		.byte	0
 10991 0034 00       		.byte	0
 10992 0035 FF       		.byte	-1
 10993 0036 00       		.byte	0
 10994 0037 01       		.byte	1
 10995 0038 00       		.byte	0
 10996 0039 03       		.byte	3
 10997 003a 00       		.byte	0
 10998 003b 01       		.byte	1
 10999 003c 00       		.byte	0
 11000 003d 00       		.byte	0
 11001 003e 00       		.byte	0
 11002 003f 30       		.byte	48
 11003 0040 01       		.byte	1
 11004 0041 01       		.byte	1
 11005 0042 00       		.byte	0
 11006 0043 00000000 		.space	5
 11006      00
 11007 0048 00       		.byte	0
 11008 0049 00       		.byte	0
 11009 004a 02       		.byte	2
 11010 004b 00       		.byte	0
 11011 004c 00       		.byte	0
 11012 004d 00       		.byte	0
 11013 004e 00       		.byte	0
 11014 004f 00       		.byte	0
 11015 0050 00       		.byte	0
 11016 0051 03       		.byte	3
 11017 0052 00       		.byte	0
 11018 0053 00       		.byte	0
 11019 0054 00       		.byte	0
 11020 0055 00       		.byte	0
 11021 0056 00       		.byte	0
 11022 0057 30       		.byte	48
 11023 0058 01       		.byte	1
 11024 0059 01       		.byte	1
 11025 005a 00       		.byte	0
 11026 005b 00000000 		.space	5
 11026      00
 11027 0060 13       		.byte	19
 11028 0061 14       		.byte	20
 11029 0062 02       		.byte	2
 11030 0063 01       		.byte	1
 11031 0064 00       		.byte	0
 11032 0065 03       		.byte	3
 11033 0066 00       		.byte	0
 11034 0067 01       		.byte	1
 11035 0068 00       		.byte	0
 11036 0069 03       		.byte	3
 11037 006a 00       		.byte	0
 11038 006b 23       		.byte	35
 11039 006c 37       		.byte	55
 11040 006d 23       		.byte	35
 11041 006e 37       		.byte	55
 11042 006f 30       		.byte	48
 11043 0070 01       		.byte	1
 11044 0071 00       		.byte	0
 11045 0072 00       		.byte	0
 11046 0073 00000000 		.space	5
 11046      00
 11047 0078 11       		.byte	17
 11048 0079 00       		.byte	0
 11049 007a 02       		.byte	2
 11050 007b 01       		.byte	1
 11051 007c 00       		.byte	0
 11052 007d 03       		.byte	3
 11053 007e 00       		.byte	0
 11054 007f 01       		.byte	1
 11055 0080 00       		.byte	0
 11056 0081 03       		.byte	3
 11057 0082 00       		.byte	0
 11058 0083 01       		.byte	1
 11059 0084 00       		.byte	0
 11060 0085 01       		.byte	1
 11061 0086 00       		.byte	0
 11062 0087 30       		.byte	48
 11063 0088 01       		.byte	1
 11064 0089 01       		.byte	1
 11065 008a 00       		.byte	0
 11066 008b 00000000 		.space	5
 11066      00
 11067 0090 17       		.byte	23
 11068 0091 00       		.byte	0
 11069 0092 01       		.byte	1
 11070 0093 01       		.byte	1
 11071 0094 00       		.byte	0
 11072 0095 02       		.byte	2
 11073 0096 00       		.byte	0
 11074 0097 01       		.byte	1
 11075 0098 00       		.byte	0
 11076 0099 03       		.byte	3
 11077 009a 00       		.byte	0
 11078 009b 00       		.byte	0
 11079 009c 00       		.byte	0
 11080 009d 00       		.byte	0
 11081 009e 00       		.byte	0
 11082 009f 30       		.byte	48
 11083 00a0 01       		.byte	1
 11084 00a1 01       		.byte	1
 11085 00a2 00       		.byte	0
 11086 00a3 00000000 		.space	5
 11086      00
 11087 00a8 00       		.byte	0
 11088 00a9 00       		.byte	0
 11089 00aa 04       		.byte	4
 11090 00ab 01       		.byte	1
 11091 00ac 00       		.byte	0
 11092 00ad 38       		.byte	56
 11093 00ae 01       		.byte	1
 11094 00af 01       		.byte	1
 11095 00b0 00       		.byte	0
 11096 00b1 03       		.byte	3
 11097 00b2 00       		.byte	0
 11098 00b3 4E       		.byte	78
 11099 00b4 00       		.byte	0
 11100 00b5 4E       		.byte	78
 11101 00b6 00       		.byte	0
 11102 00b7 30       		.byte	48
 11103 00b8 01       		.byte	1
 11104 00b9 00       		.byte	0
 11105 00ba 00       		.byte	0
 11106 00bb 00000000 		.space	5
 11106      00
 11107 00c0 00       		.byte	0
 11108 00c1 00       		.byte	0
 11109 00c2 01       		.byte	1
 11110 00c3 00       		.byte	0
 11111 00c4 00       		.byte	0
 11112 00c5 00       		.byte	0
 11113 00c6 00       		.byte	0
 11114 00c7 01       		.byte	1
 11115 00c8 00       		.byte	0
 11116 00c9 03       		.byte	3
 11117 00ca 00       		.byte	0
 11118 00cb 00       		.byte	0
 11119 00cc 00       		.byte	0
 11120 00cd 00       		.byte	0
 11121 00ce 00       		.byte	0
 11122 00cf 30       		.byte	48
 11123 00d0 01       		.byte	1
 11124 00d1 00       		.byte	0
 11125 00d2 00       		.byte	0
 11126 00d3 00000000 		.space	5
 11126      00
 11127 00d8 00       		.byte	0
 11128 00d9 00       		.byte	0
 11129 00da 02       		.byte	2
 11130 00db 00       		.byte	0
 11131 00dc 00       		.byte	0
 11132 00dd 05       		.byte	5
 11133 00de 00       		.byte	0
 11134 00df 01       		.byte	1
 11135 00e0 00       		.byte	0
 11136 00e1 03       		.byte	3
 11137 00e2 00       		.byte	0
 11138 00e3 00       		.byte	0
 11139 00e4 00       		.byte	0
 11140 00e5 00       		.byte	0
 11141 00e6 00       		.byte	0
 11142 00e7 30       		.byte	48
 11143 00e8 01       		.byte	1
 11144 00e9 00       		.byte	0
 11145 00ea 00       		.byte	0
 11146 00eb 00000000 		.space	5
 11146      00
 11147 00f0 00       		.byte	0
 11148 00f1 00       		.byte	0
 11149 00f2 03       		.byte	3
 11150 00f3 00       		.byte	0
 11151 00f4 00       		.byte	0
 11152 00f5 0A       		.byte	10
 11153 00f6 00       		.byte	0
 11154 00f7 01       		.byte	1
 11155 00f8 00       		.byte	0
 11156 00f9 03       		.byte	3
 11157 00fa 00       		.byte	0
 11158 00fb 00       		.byte	0
 11159 00fc 00       		.byte	0
 11160 00fd 00       		.byte	0
 11161 00fe 00       		.byte	0
 11162 00ff 30       		.byte	48
 11163 0100 01       		.byte	1
 11164 0101 00       		.byte	0
 11165 0102 00       		.byte	0
 11166 0103 00000000 		.space	5
 11166      00
 11167 0108 00       		.byte	0
 11168 0109 00       		.byte	0
 11169 010a 02       		.byte	2
 11170 010b 00       		.byte	0
 11171 010c 00       		.byte	0
 11172 010d 40       		.byte	64
 11173 010e 00       		.byte	0
 11174 010f 01       		.byte	1
 11175 0110 00       		.byte	0
 11176 0111 03       		.byte	3
 11177 0112 00       		.byte	0
 11178 0113 0F       		.byte	15
 11179 0114 11       		.byte	17
 11180 0115 00       		.byte	0
 11181 0116 00       		.byte	0
 11182 0117 30       		.byte	48
 11183 0118 01       		.byte	1
 11184 0119 00       		.byte	0
 11185 011a 00       		.byte	0
 11186 011b 00000000 		.space	5
 11186      00
 11187 0120 00       		.byte	0
 11188 0121 00       		.byte	0
 11189 0122 02       		.byte	2
 11190 0123 00       		.byte	0
 11191 0124 00       		.byte	0
 11192 0125 64       		.byte	100
 11193 0126 00       		.byte	0
 11194 0127 01       		.byte	1
 11195 0128 00       		.byte	0
 11196 0129 03       		.byte	3
 11197 012a 00       		.byte	0
 11198 012b 00       		.byte	0
 11199 012c 00       		.byte	0
 11200 012d 00       		.byte	0
 11201 012e 00       		.byte	0
 11202 012f 30       		.byte	48
 11203 0130 01       		.byte	1
 11204 0131 00       		.byte	0
 11205 0132 00       		.byte	0
 11206 0133 00000000 		.space	5
 11206      00
 11207 0138 00       		.byte	0
 11208 0139 00       		.byte	0
 11209 013a 02       		.byte	2
 11210 013b 00       		.byte	0
 11211 013c 00       		.byte	0
 11212 013d 64       		.byte	100
 11213 013e 00       		.byte	0
 11214 013f 01       		.byte	1
 11215 0140 00       		.byte	0
 11216 0141 03       		.byte	3
 11217 0142 00       		.byte	0
 11218 0143 00       		.byte	0
 11219 0144 00       		.byte	0
 11220 0145 00       		.byte	0
 11221 0146 00       		.byte	0
 11222 0147 30       		.byte	48
 11223 0148 01       		.byte	1
 11224 0149 00       		.byte	0
 11225 014a 00       		.byte	0
 11226 014b 00000000 		.space	5
 11226      00
 11227 0150 00       		.byte	0
 11228 0151 00       		.byte	0
 11229 0152 02       		.byte	2
 11230 0153 00       		.byte	0
 11231 0154 00       		.byte	0
 11232 0155 64       		.byte	100
 11233 0156 00       		.byte	0
 11234 0157 01       		.byte	1
 11235 0158 00       		.byte	0
 11236 0159 03       		.byte	3
 11237 015a 00       		.byte	0
 11238 015b 00       		.byte	0
 11239 015c 00       		.byte	0
 11240 015d 00       		.byte	0
 11241 015e 00       		.byte	0
 11242 015f 30       		.byte	48
 11243 0160 01       		.byte	1
 11244 0161 00       		.byte	0
 11245 0162 00       		.byte	0
 11246 0163 00000000 		.space	5
 11246      00
 11247 0168 00       		.byte	0
 11248 0169 00       		.byte	0
 11249 016a 02       		.byte	2
 11250 016b 00       		.byte	0
 11251 016c 00       		.byte	0
 11252 016d 64       		.byte	100
 11253 016e 00       		.byte	0
 11254 016f 01       		.byte	1
 11255 0170 00       		.byte	0
 11256 0171 03       		.byte	3
 11257 0172 00       		.byte	0
 11258 0173 00       		.byte	0
 11259 0174 00       		.byte	0
 11260 0175 00       		.byte	0
 11261 0176 00       		.byte	0
 11262 0177 30       		.byte	48
 11263 0178 01       		.byte	1
 11264 0179 00       		.byte	0
 11265 017a 00       		.byte	0
 11266 017b 00000000 		.space	5
 11266      00
 11269              	CtrlParArry:
 11270 0180 10       		.byte	16
 11271 0181 10       		.byte	16
 11272 0182 02       		.byte	2
 11273 0183 00       		.byte	0
 11274 0184 00       		.byte	0
 11275 0185 03       		.byte	3
 11276 0186 00       		.byte	0
 11277 0187 01       		.byte	1
 11278 0188 00       		.byte	0
 11279 0189 03       		.byte	3
 11280 018a 00       		.byte	0
 11281 018b 00       		.byte	0
 11282 018c 00       		.byte	0
 11283 018d 00       		.byte	0
 11284 018e 00       		.byte	0
 11285 018f 30       		.byte	48
 11286 0190 01       		.byte	1
 11287 0191 00       		.byte	0
 11288 0192 00       		.byte	0
 11289 0193 00000000 		.space	5
 11289      00
 11290 0198 01       		.byte	1
 11291 0199 00       		.byte	0
 11292 019a 02       		.byte	2
 11293 019b 00       		.byte	0
 11294 019c 00       		.byte	0
 11295 019d 3F       		.byte	63
 11296 019e 00       		.byte	0
 11297 019f 01       		.byte	1
 11298 01a0 00       		.byte	0
 11299 01a1 03       		.byte	3
 11300 01a2 00       		.byte	0
 11301 01a3 1F       		.byte	31
 11302 01a4 00       		.byte	0
 11303 01a5 1F       		.byte	31
 11304 01a6 C7       		.byte	-57
 11305 01a7 30       		.byte	48
 11306 01a8 01       		.byte	1
 11307 01a9 01       		.byte	1
 11308 01aa 00       		.byte	0
 11309 01ab 00000000 		.space	5
 11309      00
 11310 01b0 07       		.byte	7
 11311 01b1 07       		.byte	7
 11312 01b2 02       		.byte	2
 11313 01b3 10       		.byte	16
 11314 01b4 00       		.byte	0
 11315 01b5 40       		.byte	64
 11316 01b6 00       		.byte	0
 11317 01b7 01       		.byte	1
 11318 01b8 00       		.byte	0
 11319 01b9 03       		.byte	3
 11320 01ba 00       		.byte	0
 11321 01bb 28       		.byte	40
 11322 01bc 00       		.byte	0
 11323 01bd 28       		.byte	40
 11324 01be 00       		.byte	0
 11325 01bf 30       		.byte	48
 11326 01c0 01       		.byte	1
 11327 01c1 01       		.byte	1
 11328 01c2 00       		.byte	0
 11329 01c3 00000000 		.space	5
 11329      00
 11330 01c8 00       		.byte	0
 11331 01c9 00       		.byte	0
 11332 01ca 02       		.byte	2
 11333 01cb 00       		.byte	0
 11334 01cc 00       		.byte	0
 11335 01cd 64       		.byte	100
 11336 01ce 00       		.byte	0
 11337 01cf 01       		.byte	1
 11338 01d0 00       		.byte	0
 11339 01d1 03       		.byte	3
 11340 01d2 00       		.byte	0
 11341 01d3 00       		.byte	0
 11342 01d4 00       		.byte	0
 11343 01d5 00       		.byte	0
 11344 01d6 00       		.byte	0
 11345 01d7 30       		.byte	48
 11346 01d8 01       		.byte	1
 11347 01d9 00       		.byte	0
 11348 01da 00       		.byte	0
 11349 01db 00000000 		.space	5
 11349      00
 11350 01e0 07       		.byte	7
 11351 01e1 07       		.byte	7
 11352 01e2 02       		.byte	2
 11353 01e3 00       		.byte	0
 11354 01e4 00       		.byte	0
 11355 01e5 01       		.byte	1
 11356 01e6 00       		.byte	0
 11357 01e7 01       		.byte	1
 11358 01e8 00       		.byte	0
 11359 01e9 03       		.byte	3
 11360 01ea 00       		.byte	0
 11361 01eb 01       		.byte	1
 11362 01ec 00       		.byte	0
 11363 01ed 01       		.byte	1
 11364 01ee 00       		.byte	0
 11365 01ef 30       		.byte	48
 11366 01f0 01       		.byte	1
 11367 01f1 00       		.byte	0
 11368 01f2 00       		.byte	0
 11369 01f3 00000000 		.space	5
 11369      00
 11370 01f8 DF       		.byte	-33
 11371 01f9 E1       		.byte	-31
 11372 01fa 02       		.byte	2
 11373 01fb 00       		.byte	0
 11374 01fc 00       		.byte	0
 11375 01fd FF       		.byte	-1
 11376 01fe 00       		.byte	0
 11377 01ff 01       		.byte	1
 11378 0200 00       		.byte	0
 11379 0201 03       		.byte	3
 11380 0202 00       		.byte	0
 11381 0203 80       		.byte	-128
 11382 0204 00       		.byte	0
 11383 0205 00       		.byte	0
 11384 0206 00       		.byte	0
 11385 0207 C6       		.byte	-58
 11386 0208 01       		.byte	1
 11387 0209 01       		.byte	1
 11388 020a 00       		.byte	0
 11389 020b 00000000 		.space	5
 11389      00
 11390 0210 85       		.byte	-123
 11391 0211 86       		.byte	-122
 11392 0212 02       		.byte	2
 11393 0213 00       		.byte	0
 11394 0214 00       		.byte	0
 11395 0215 64       		.byte	100
 11396 0216 00       		.byte	0
 11397 0217 01       		.byte	1
 11398 0218 00       		.byte	0
 11399 0219 03       		.byte	3
 11400 021a 00       		.byte	0
 11401 021b 32       		.byte	50
 11402 021c 00       		.byte	0
 11403 021d 32       		.byte	50
 11404 021e 00       		.byte	0
 11405 021f F2       		.byte	-14
 11406 0220 01       		.byte	1
 11407 0221 01       		.byte	1
 11408 0222 00       		.byte	0
 11409 0223 00000000 		.space	5
 11409      00
 11410 0228 06       		.byte	6
 11411 0229 06       		.byte	6
 11412 022a 02       		.byte	2
 11413 022b 00       		.byte	0
 11414 022c 00       		.byte	0
 11415 022d 0E       		.byte	14
 11416 022e 00       		.byte	0
 11417 022f 01       		.byte	1
 11418 0230 00       		.byte	0
 11419 0231 03       		.byte	3
 11420 0232 00       		.byte	0
 11421 0233 00       		.byte	0
 11422 0234 00       		.byte	0
 11423 0235 00       		.byte	0
 11424 0236 00       		.byte	0
 11425 0237 30       		.byte	48
 11426 0238 01       		.byte	1
 11427 0239 01       		.byte	1
 11428 023a 00       		.byte	0
 11429 023b 00000000 		.space	5
 11429      00
 11430 0240 00       		.byte	0
 11431 0241 00       		.byte	0
 11432 0242 02       		.byte	2
 11433 0243 00       		.byte	0
 11434 0244 00       		.byte	0
 11435 0245 64       		.byte	100
 11436 0246 00       		.byte	0
 11437 0247 01       		.byte	1
 11438 0248 00       		.byte	0
 11439 0249 03       		.byte	3
 11440 024a 00       		.byte	0
 11441 024b 00       		.byte	0
 11442 024c 00       		.byte	0
 11443 024d 00       		.byte	0
 11444 024e 00       		.byte	0
 11445 024f 30       		.byte	48
 11446 0250 01       		.byte	1
 11447 0251 00       		.byte	0
 11448 0252 00       		.byte	0
 11449 0253 00000000 		.space	5
 11449      00
 11450 0258 08       		.byte	8
 11451 0259 08       		.byte	8
 11452 025a 02       		.byte	2
 11453 025b 00       		.byte	0
 11454 025c 00       		.byte	0
 11455 025d 05       		.byte	5
 11456 025e 00       		.byte	0
 11457 025f 01       		.byte	1
 11458 0260 00       		.byte	0
 11459 0261 03       		.byte	3
 11460 0262 00       		.byte	0
 11461 0263 00       		.byte	0
 11462 0264 00       		.byte	0
 11463 0265 00       		.byte	0
 11464 0266 00       		.byte	0
 11465 0267 30       		.byte	48
 11466 0268 01       		.byte	1
 11467 0269 00       		.byte	0
 11468 026a 00       		.byte	0
 11469 026b 00000000 		.space	5
 11469      00
 11470 0270 00       		.byte	0
 11471 0271 00       		.byte	0
 11472 0272 02       		.byte	2
 11473 0273 00       		.byte	0
 11474 0274 00       		.byte	0
 11475 0275 40       		.byte	64
 11476 0276 00       		.byte	0
 11477 0277 01       		.byte	1
 11478 0278 00       		.byte	0
 11479 0279 03       		.byte	3
 11480 027a 00       		.byte	0
 11481 027b 00       		.byte	0
 11482 027c 00       		.byte	0
 11483 027d 00       		.byte	0
 11484 027e 00       		.byte	0
 11485 027f 30       		.byte	48
 11486 0280 01       		.byte	1
 11487 0281 00       		.byte	0
 11488 0282 00       		.byte	0
 11489 0283 00000000 		.space	5
 11489      00
 11490 0288 09       		.byte	9
 11491 0289 0A       		.byte	10
 11492 028a 04       		.byte	4
 11493 028b 00       		.byte	0
 11494 028c 00       		.byte	0
 11495 028d 40       		.byte	64
 11496 028e 00       		.byte	0
 11497 028f 01       		.byte	1
 11498 0290 00       		.byte	0
 11499 0291 03       		.byte	3
 11500 0292 00       		.byte	0
 11501 0293 20       		.byte	32
 11502 0294 38       		.byte	56
 11503 0295 20       		.byte	32
 11504 0296 38       		.byte	56
 11505 0297 30       		.byte	48
 11506 0298 01       		.byte	1
 11507 0299 00       		.byte	0
 11508 029a 00       		.byte	0
 11509 029b 00000000 		.space	5
 11509      00
 11510 02a0 00       		.byte	0
 11511 02a1 00       		.byte	0
 11512 02a2 02       		.byte	2
 11513 02a3 00       		.byte	0
 11514 02a4 00       		.byte	0
 11515 02a5 64       		.byte	100
 11516 02a6 00       		.byte	0
 11517 02a7 01       		.byte	1
 11518 02a8 00       		.byte	0
 11519 02a9 03       		.byte	3
 11520 02aa 00       		.byte	0
 11521 02ab 00       		.byte	0
 11522 02ac 00       		.byte	0
 11523 02ad 00       		.byte	0
 11524 02ae 00       		.byte	0
 11525 02af 30       		.byte	48
 11526 02b0 01       		.byte	1
 11527 02b1 00       		.byte	0
 11528 02b2 00       		.byte	0
 11529 02b3 00000000 		.space	5
 11529      00
 11530 02b8 00       		.byte	0
 11531 02b9 00       		.byte	0
 11532 02ba 02       		.byte	2
 11533 02bb 00       		.byte	0
 11534 02bc 00       		.byte	0
 11535 02bd 64       		.byte	100
 11536 02be 00       		.byte	0
 11537 02bf 01       		.byte	1
 11538 02c0 00       		.byte	0
 11539 02c1 03       		.byte	3
 11540 02c2 00       		.byte	0
 11541 02c3 00       		.byte	0
 11542 02c4 00       		.byte	0
 11543 02c5 00       		.byte	0
 11544 02c6 00       		.byte	0
 11545 02c7 30       		.byte	48
 11546 02c8 01       		.byte	1
 11547 02c9 00       		.byte	0
 11548 02ca 00       		.byte	0
 11549 02cb 00000000 		.space	5
 11549      00
 11550 02d0 2A       		.byte	42
 11551 02d1 2A       		.byte	42
 11552 02d2 02       		.byte	2
 11553 02d3 00       		.byte	0
 11554 02d4 00       		.byte	0
 11555 02d5 1B       		.byte	27
 11556 02d6 00       		.byte	0
 11557 02d7 01       		.byte	1
 11558 02d8 00       		.byte	0
 11559 02d9 03       		.byte	3
 11560 02da 00       		.byte	0
 11561 02db 00       		.byte	0
 11562 02dc 00       		.byte	0
 11563 02dd 00       		.byte	0
 11564 02de 00       		.byte	0
 11565 02df 30       		.byte	48
 11566 02e0 01       		.byte	1
 11567 02e1 00       		.byte	0
 11568 02e2 00       		.byte	0
 11569 02e3 00000000 		.space	5
 11569      00
 11570 02e8 00       		.byte	0
 11571 02e9 00       		.byte	0
 11572 02ea 02       		.byte	2
 11573 02eb 00       		.byte	0
 11574 02ec 00       		.byte	0
 11575 02ed 64       		.byte	100
 11576 02ee 00       		.byte	0
 11577 02ef 01       		.byte	1
 11578 02f0 00       		.byte	0
 11579 02f1 03       		.byte	3
 11580 02f2 00       		.byte	0
 11581 02f3 00       		.byte	0
 11582 02f4 00       		.byte	0
 11583 02f5 00       		.byte	0
 11584 02f6 00       		.byte	0
 11585 02f7 30       		.byte	48
 11586 02f8 01       		.byte	1
 11587 02f9 00       		.byte	0
 11588 02fa 00       		.byte	0
 11589 02fb 00000000 		.space	5
 11589      00
 11590 0300 00       		.byte	0
 11591 0301 00       		.byte	0
 11592 0302 02       		.byte	2
 11593 0303 00       		.byte	0
 11594 0304 00       		.byte	0
 11595 0305 12       		.byte	18
 11596 0306 00       		.byte	0
 11597 0307 01       		.byte	1
 11598 0308 00       		.byte	0
 11599 0309 03       		.byte	3
 11600 030a 00       		.byte	0
 11601 030b 00       		.byte	0
 11602 030c 00       		.byte	0
 11603 030d 00       		.byte	0
 11604 030e 00       		.byte	0
 11605 030f 30       		.byte	48
 11606 0310 01       		.byte	1
 11607 0311 00       		.byte	0
 11608 0312 00       		.byte	0
 11609 0313 00000000 		.space	5
 11609      00
 11610 0318 01       		.byte	1
 11611 0319 01       		.byte	1
 11612 031a 02       		.byte	2
 11613 031b 00       		.byte	0
 11614 031c 00       		.byte	0
 11615 031d 09       		.byte	9
 11616 031e 00       		.byte	0
 11617 031f 01       		.byte	1
 11618 0320 00       		.byte	0
 11619 0321 03       		.byte	3
 11620 0322 00       		.byte	0
 11621 0323 00       		.byte	0
 11622 0324 00       		.byte	0
 11623 0325 01       		.byte	1
 11624 0326 00       		.byte	0
 11625 0327 30       		.byte	48
 11626 0328 01       		.byte	1
 11627 0329 00       		.byte	0
 11628 032a 00       		.byte	0
 11629 032b 00000000 		.space	5
 11629      00
 11630 0330 05       		.byte	5
 11631 0331 05       		.byte	5
 11632 0332 02       		.byte	2
 11633 0333 00       		.byte	0
 11634 0334 00       		.byte	0
 11635 0335 03       		.byte	3
 11636 0336 00       		.byte	0
 11637 0337 01       		.byte	1
 11638 0338 00       		.byte	0
 11639 0339 03       		.byte	3
 11640 033a 00       		.byte	0
 11641 033b 00       		.byte	0
 11642 033c 00       		.byte	0
 11643 033d 00       		.byte	0
 11644 033e 00       		.byte	0
 11645 033f 30       		.byte	48
 11646 0340 01       		.byte	1
 11647 0341 00       		.byte	0
 11648 0342 00       		.byte	0
 11649 0343 00000000 		.space	5
 11649      00
 11650 0348 18       		.byte	24
 11651 0349 18       		.byte	24
 11652 034a 02       		.byte	2
 11653 034b 00       		.byte	0
 11654 034c 00       		.byte	0
 11655 034d 01       		.byte	1
 11656 034e 00       		.byte	0
 11657 034f 01       		.byte	1
 11658 0350 00       		.byte	0
 11659 0351 03       		.byte	3
 11660 0352 00       		.byte	0
 11661 0353 00       		.byte	0
 11662 0354 00       		.byte	0
 11663 0355 00       		.byte	0
 11664 0356 00       		.byte	0
 11665 0357 30       		.byte	48
 11666 0358 01       		.byte	1
 11667 0359 00       		.byte	0
 11668 035a 00       		.byte	0
 11669 035b 00000000 		.space	5
 11669      00
 11670 0360 19       		.byte	25
 11671 0361 19       		.byte	25
 11672 0362 01       		.byte	1
 11673 0363 00       		.byte	0
 11674 0364 00       		.byte	0
 11675 0365 40       		.byte	64
 11676 0366 00       		.byte	0
 11677 0367 01       		.byte	1
 11678 0368 00       		.byte	0
 11679 0369 03       		.byte	3
 11680 036a 00       		.byte	0
 11681 036b 20       		.byte	32
 11682 036c 00       		.byte	0
 11683 036d 20       		.byte	32
 11684 036e 00       		.byte	0
 11685 036f 30       		.byte	48
 11686 0370 01       		.byte	1
 11687 0371 00       		.byte	0
 11688 0372 00       		.byte	0
 11689 0373 00000000 		.space	5
 11689      00
 11690 0378 20       		.byte	32
 11691 0379 20       		.byte	32
 11692 037a 02       		.byte	2
 11693 037b 00       		.byte	0
 11694 037c 00       		.byte	0
 11695 037d 02       		.byte	2
 11696 037e 00       		.byte	0
 11697 037f 01       		.byte	1
 11698 0380 00       		.byte	0
 11699 0381 03       		.byte	3
 11700 0382 00       		.byte	0
 11701 0383 00       		.byte	0
 11702 0384 00       		.byte	0
 11703 0385 00       		.byte	0
 11704 0386 00       		.byte	0
 11705 0387 30       		.byte	48
 11706 0388 01       		.byte	1
 11707 0389 00       		.byte	0
 11708 038a 00       		.byte	0
 11709 038b 00000000 		.space	5
 11709      00
 11710 0390 22       		.byte	34
 11711 0391 22       		.byte	34
 11712 0392 02       		.byte	2
 11713 0393 00       		.byte	0
 11714 0394 00       		.byte	0
 11715 0395 3F       		.byte	63
 11716 0396 00       		.byte	0
 11717 0397 01       		.byte	1
 11718 0398 00       		.byte	0
 11719 0399 03       		.byte	3
 11720 039a 00       		.byte	0
 11721 039b 00       		.byte	0
 11722 039c 00       		.byte	0
 11723 039d 00       		.byte	0
 11724 039e 00       		.byte	0
 11725 039f 30       		.byte	48
 11726 03a0 01       		.byte	1
 11727 03a1 00       		.byte	0
 11728 03a2 00       		.byte	0
 11729 03a3 00000000 		.space	5
 11729      00
 11730 03a8 23       		.byte	35
 11731 03a9 23       		.byte	35
 11732 03aa 02       		.byte	2
 11733 03ab 00       		.byte	0
 11734 03ac 00       		.byte	0
 11735 03ad 64       		.byte	100
 11736 03ae 00       		.byte	0
 11737 03af 01       		.byte	1
 11738 03b0 00       		.byte	0
 11739 03b1 03       		.byte	3
 11740 03b2 00       		.byte	0
 11741 03b3 10       		.byte	16
 11742 03b4 00       		.byte	0
 11743 03b5 10       		.byte	16
 11744 03b6 00       		.byte	0
 11745 03b7 30       		.byte	48
 11746 03b8 01       		.byte	1
 11747 03b9 00       		.byte	0
 11748 03ba 00       		.byte	0
 11749 03bb 00000000 		.space	5
 11749      00
 11750 03c0 24       		.byte	36
 11751 03c1 24       		.byte	36
 11752 03c2 02       		.byte	2
 11753 03c3 00       		.byte	0
 11754 03c4 00       		.byte	0
 11755 03c5 64       		.byte	100
 11756 03c6 00       		.byte	0
 11757 03c7 01       		.byte	1
 11758 03c8 00       		.byte	0
 11759 03c9 03       		.byte	3
 11760 03ca 00       		.byte	0
 11761 03cb 10       		.byte	16
 11762 03cc 00       		.byte	0
 11763 03cd 10       		.byte	16
 11764 03ce 00       		.byte	0
 11765 03cf 30       		.byte	48
 11766 03d0 01       		.byte	1
 11767 03d1 00       		.byte	0
 11768 03d2 00       		.byte	0
 11769 03d3 00000000 		.space	5
 11769      00
 11770 03d8 02       		.byte	2
 11771 03d9 03       		.byte	3
 11772 03da 04       		.byte	4
 11773 03db 00       		.byte	0
 11774 03dc 00       		.byte	0
 11775 03dd FF       		.byte	-1
 11776 03de 00       		.byte	0
 11777 03df 01       		.byte	1
 11778 03e0 00       		.byte	0
 11779 03e1 03       		.byte	3
 11780 03e2 00       		.byte	0
 11781 03e3 00       		.byte	0
 11782 03e4 20       		.byte	32
 11783 03e5 00       		.byte	0
 11784 03e6 20       		.byte	32
 11785 03e7 30       		.byte	48
 11786 03e8 01       		.byte	1
 11787 03e9 00       		.byte	0
 11788 03ea 00       		.byte	0
 11789 03eb 00000000 		.space	5
 11789      00
 11790 03f0 04       		.byte	4
 11791 03f1 04       		.byte	4
 11792 03f2 02       		.byte	2
 11793 03f3 00       		.byte	0
 11794 03f4 00       		.byte	0
 11795 03f5 3F       		.byte	63
 11796 03f6 00       		.byte	0
 11797 03f7 01       		.byte	1
 11798 03f8 00       		.byte	0
 11799 03f9 03       		.byte	3
 11800 03fa 00       		.byte	0
 11801 03fb 20       		.byte	32
 11802 03fc 00       		.byte	0
 11803 03fd 20       		.byte	32
 11804 03fe 00       		.byte	0
 11805 03ff 30       		.byte	48
 11806 0400 01       		.byte	1
 11807 0401 00       		.byte	0
 11808 0402 00       		.byte	0
 11809 0403 00000000 		.space	5
 11809      00
 11810 0408 00       		.byte	0
 11811 0409 00       		.byte	0
 11812 040a 02       		.byte	2
 11813 040b 00       		.byte	0
 11814 040c 00       		.byte	0
 11815 040d 19       		.byte	25
 11816 040e 00       		.byte	0
 11817 040f 01       		.byte	1
 11818 0410 00       		.byte	0
 11819 0411 03       		.byte	3
 11820 0412 00       		.byte	0
 11821 0413 00       		.byte	0
 11822 0414 00       		.byte	0
 11823 0415 00       		.byte	0
 11824 0416 00       		.byte	0
 11825 0417 30       		.byte	48
 11826 0418 01       		.byte	1
 11827 0419 00       		.byte	0
 11828 041a 00       		.byte	0
 11829 041b 00000000 		.space	5
 11829      00
 11830 0420 10       		.byte	16
 11831 0421 10       		.byte	16
 11832 0422 02       		.byte	2
 11833 0423 00       		.byte	0
 11834 0424 00       		.byte	0
 11835 0425 06       		.byte	6
 11836 0426 00       		.byte	0
 11837 0427 01       		.byte	1
 11838 0428 00       		.byte	0
 11839 0429 03       		.byte	3
 11840 042a 00       		.byte	0
 11841 042b 00       		.byte	0
 11842 042c 00       		.byte	0
 11843 042d 00       		.byte	0
 11844 042e 00       		.byte	0
 11845 042f 30       		.byte	48
 11846 0430 01       		.byte	1
 11847 0431 00       		.byte	0
 11848 0432 00       		.byte	0
 11849 0433 00000000 		.space	5
 11849      00
 11850 0438 00       		.byte	0
 11851 0439 00       		.byte	0
 11852 043a 02       		.byte	2
 11853 043b 00       		.byte	0
 11854 043c 00       		.byte	0
 11855 043d 03       		.byte	3
 11856 043e 00       		.byte	0
 11857 043f 01       		.byte	1
 11858 0440 00       		.byte	0
 11859 0441 03       		.byte	3
 11860 0442 00       		.byte	0
 11861 0443 00       		.byte	0
 11862 0444 00       		.byte	0
 11863 0445 00       		.byte	0
 11864 0446 00       		.byte	0
 11865 0447 30       		.byte	48
 11866 0448 01       		.byte	1
 11867 0449 00       		.byte	0
 11868 044a 00       		.byte	0
 11869 044b 00000000 		.space	5
 11869      00
 11870 0450 50       		.byte	80
 11871 0451 50       		.byte	80
 11872 0452 01       		.byte	1
 11873 0453 00       		.byte	0
 11874 0454 00       		.byte	0
 11875 0455 03       		.byte	3
 11876 0456 00       		.byte	0
 11877 0457 01       		.byte	1
 11878 0458 00       		.byte	0
 11879 0459 03       		.byte	3
 11880 045a 00       		.byte	0
 11881 045b 00       		.byte	0
 11882 045c 00       		.byte	0
 11883 045d 00       		.byte	0
 11884 045e 00       		.byte	0
 11885 045f 30       		.byte	48
 11886 0460 01       		.byte	1
 11887 0461 00       		.byte	0
 11888 0462 00       		.byte	0
 11889 0463 00000000 		.space	5
 11889      00
 11890 0468 00       		.byte	0
 11891 0469 00       		.byte	0
 11892 046a 0B       		.byte	11
 11893 046b 00       		.byte	0
 11894 046c 00       		.byte	0
 11895 046d FF       		.byte	-1
 11896 046e FF       		.byte	-1
 11897 046f 01       		.byte	1
 11898 0470 00       		.byte	0
 11899 0471 03       		.byte	3
 11900 0472 00       		.byte	0
 11901 0473 00       		.byte	0
 11902 0474 00       		.byte	0
 11903 0475 00       		.byte	0
 11904 0476 00       		.byte	0
 11905 0477 00       		.byte	0
 11906 0478 01       		.byte	1
 11907 0479 00       		.byte	0
 11908 047a 00       		.byte	0
 11909 047b 00000000 		.space	5
 11909      00
 11912              	glUVCHeader:
 11913 0480 0C       		.byte	12
 11914 0481 8C       		.byte	-116
 11915 0482 00       		.byte	0
 11916 0483 00       		.byte	0
 11917 0484 00       		.byte	0
 11918 0485 00       		.byte	0
 11919 0486 00       		.byte	0
 11920 0487 00       		.byte	0
 11921 0488 00       		.byte	0
 11922 0489 00       		.byte	0
 11923 048a 00       		.byte	0
 11924 048b 00       		.byte	0
 11927              	WBMenuCmpArry:
 11928 048c A0       		.byte	-96
 11929 048d 0F       		.byte	15
 11930 048e 0F       		.byte	15
 11931 048f F0       		.byte	-16
 11934              	CTCtrlParArry:
 11935 0490 00       		.byte	0
 11936 0491 00       		.byte	0
 11937 0492 01       		.byte	1
 11938 0493 00       		.byte	0
 11939 0494 00       		.byte	0
 11940 0495 03       		.byte	3
 11941 0496 00       		.byte	0
 11942 0497 01       		.byte	1
 11943 0498 00       		.byte	0
 11944 0499 03       		.byte	3
 11945 049a 00       		.byte	0
 11946 049b 03       		.byte	3
 11947 049c 00       		.byte	0
 11948 049d 03       		.byte	3
 11949 049e 00       		.byte	0
 11950 049f 30       		.byte	48
 11951 04a0 01       		.byte	1
 11952 04a1 00       		.byte	0
 11953 04a2 00       		.byte	0
 11954 04a3 00000000 		.space	5
 11954      00
 11955 04a8 00       		.byte	0
 11956 04a9 00       		.byte	0
 11957 04aa 01       		.byte	1
 11958 04ab 01       		.byte	1
 11959 04ac 00       		.byte	0
 11960 04ad 0F       		.byte	15
 11961 04ae 00       		.byte	0
 11962 04af 0F       		.byte	15
 11963 04b0 00       		.byte	0
 11964 04b1 03       		.byte	3
 11965 04b2 00       		.byte	0
 11966 04b3 02       		.byte	2
 11967 04b4 00       		.byte	0
 11968 04b5 02       		.byte	2
 11969 04b6 00       		.byte	0
 11970 04b7 30       		.byte	48
 11971 04b8 01       		.byte	1
 11972 04b9 01       		.byte	1
 11973 04ba 00       		.byte	0
 11974 04bb 00000000 		.space	5
 11974      00
 11975 04c0 02       		.byte	2
 11976 04c1 00       		.byte	0
 11977 04c2 01       		.byte	1
 11978 04c3 00       		.byte	0
 11979 04c4 00       		.byte	0
 11980 04c5 01       		.byte	1
 11981 04c6 00       		.byte	0
 11982 04c7 01       		.byte	1
 11983 04c8 00       		.byte	0
 11984 04c9 03       		.byte	3
 11985 04ca 00       		.byte	0
 11986 04cb 00       		.byte	0
 11987 04cc 00       		.byte	0
 11988 04cd 00       		.byte	0
 11989 04ce 00       		.byte	0
 11990 04cf 30       		.byte	48
 11991 04d0 01       		.byte	1
 11992 04d1 01       		.byte	1
 11993 04d2 00       		.byte	0
 11994 04d3 00000000 		.space	5
 11994      00
 11995 04d8 00       		.byte	0
 11996 04d9 00       		.byte	0
 11997 04da 04       		.byte	4
 11998 04db 01       		.byte	1
 11999 04dc 00       		.byte	0
 12000 04dd 38       		.byte	56
 12001 04de 01       		.byte	1
 12002 04df 01       		.byte	1
 12003 04e0 00       		.byte	0
 12004 04e1 03       		.byte	3
 12005 04e2 00       		.byte	0
 12006 04e3 4E       		.byte	78
 12007 04e4 00       		.byte	0
 12008 04e5 4E       		.byte	78
 12009 04e6 00       		.byte	0
 12010 04e7 30       		.byte	48
 12011 04e8 01       		.byte	1
 12012 04e9 00       		.byte	0
 12013 04ea 00       		.byte	0
 12014 04eb 00000000 		.space	5
 12014      00
 12015 04f0 04       		.byte	4
 12016 04f1 00       		.byte	0
 12017 04f2 01       		.byte	1
 12018 04f3 00       		.byte	0
 12019 04f4 00       		.byte	0
 12020 04f5 00       		.byte	0
 12021 04f6 00       		.byte	0
 12022 04f7 01       		.byte	1
 12023 04f8 00       		.byte	0
 12024 04f9 03       		.byte	3
 12025 04fa 00       		.byte	0
 12026 04fb 00       		.byte	0
 12027 04fc 00       		.byte	0
 12028 04fd 00       		.byte	0
 12029 04fe 00       		.byte	0
 12030 04ff 30       		.byte	48
 12031 0500 01       		.byte	1
 12032 0501 00       		.byte	0
 12033 0502 00       		.byte	0
 12034 0503 00000000 		.space	5
 12034      00
 12035 0508 05       		.byte	5
 12036 0509 00       		.byte	0
 12037 050a 02       		.byte	2
 12038 050b 00       		.byte	0
 12039 050c 00       		.byte	0
 12040 050d FF       		.byte	-1
 12041 050e 00       		.byte	0
 12042 050f 01       		.byte	1
 12043 0510 00       		.byte	0
 12044 0511 03       		.byte	3
 12045 0512 00       		.byte	0
 12046 0513 01       		.byte	1
 12047 0514 00       		.byte	0
 12048 0515 00       		.byte	0
 12049 0516 00       		.byte	0
 12050 0517 30       		.byte	48
 12051 0518 01       		.byte	1
 12052 0519 01       		.byte	1
 12053 051a 00       		.byte	0
 12054 051b 00000000 		.space	5
 12054      00
 12055 0520 06       		.byte	6
 12056 0521 00       		.byte	0
 12057 0522 02       		.byte	2
 12058 0523 00       		.byte	0
 12059 0524 00       		.byte	0
 12060 0525 00       		.byte	0
 12061 0526 00       		.byte	0
 12062 0527 00       		.byte	0
 12063 0528 00       		.byte	0
 12064 0529 03       		.byte	3
 12065 052a 00       		.byte	0
 12066 052b 00       		.byte	0
 12067 052c 00       		.byte	0
 12068 052d 00       		.byte	0
 12069 052e 00       		.byte	0
 12070 052f 30       		.byte	48
 12071 0530 01       		.byte	1
 12072 0531 01       		.byte	1
 12073 0532 00       		.byte	0
 12074 0533 00000000 		.space	5
 12074      00
 12075 0538 23       		.byte	35
 12076 0539 00       		.byte	0
 12077 053a 02       		.byte	2
 12078 053b 00       		.byte	0
 12079 053c 00       		.byte	0
 12080 053d 30       		.byte	48
 12081 053e 00       		.byte	0
 12082 053f 01       		.byte	1
 12083 0540 00       		.byte	0
 12084 0541 03       		.byte	3
 12085 0542 0A       		.byte	10
 12086 0543 00       		.byte	0
 12087 0544 00       		.byte	0
 12088 0545 0A       		.byte	10
 12089 0546 00       		.byte	0
 12090 0547 30       		.byte	48
 12091 0548 01       		.byte	1
 12092 0549 01       		.byte	1
 12093 054a 00       		.byte	0
 12094 054b 00000000 		.space	5
 12094      00
 12095 0550 08       		.byte	8
 12096 0551 00       		.byte	0
 12097 0552 01       		.byte	1
 12098 0553 00       		.byte	0
 12099 0554 00       		.byte	0
 12100 0555 7F       		.byte	127
 12101 0556 00       		.byte	0
 12102 0557 01       		.byte	1
 12103 0558 00       		.byte	0
 12104 0559 03       		.byte	3
 12105 055a 00       		.byte	0
 12106 055b 00       		.byte	0
 12107 055c 00       		.byte	0
 12108 055d 00       		.byte	0
 12109 055e 00       		.byte	0
 12110 055f 30       		.byte	48
 12111 0560 01       		.byte	1
 12112 0561 00       		.byte	0
 12113 0562 00       		.byte	0
 12114 0563 00000000 		.space	5
 12114      00
 12115 0568 09       		.byte	9
 12116 0569 00       		.byte	0
 12117 056a 02       		.byte	2
 12118 056b 00       		.byte	0
 12119 056c 00       		.byte	0
 12120 056d 05       		.byte	5
 12121 056e 00       		.byte	0
 12122 056f 01       		.byte	1
 12123 0570 00       		.byte	0
 12124 0571 03       		.byte	3
 12125 0572 00       		.byte	0
 12126 0573 00       		.byte	0
 12127 0574 00       		.byte	0
 12128 0575 00       		.byte	0
 12129 0576 00       		.byte	0
 12130 0577 30       		.byte	48
 12131 0578 01       		.byte	1
 12132 0579 00       		.byte	0
 12133 057a 00       		.byte	0
 12134 057b 00000000 		.space	5
 12134      00
 12135 0580 10       		.byte	16
 12136 0581 00       		.byte	0
 12137 0582 03       		.byte	3
 12138 0583 00       		.byte	0
 12139 0584 00       		.byte	0
 12140 0585 00       		.byte	0
 12141 0586 00       		.byte	0
 12142 0587 00       		.byte	0
 12143 0588 00       		.byte	0
 12144 0589 03       		.byte	3
 12145 058a 00       		.byte	0
 12146 058b 00       		.byte	0
 12147 058c 00       		.byte	0
 12148 058d 00       		.byte	0
 12149 058e 00       		.byte	0
 12150 058f 30       		.byte	48
 12151 0590 01       		.byte	1
 12152 0591 00       		.byte	0
 12153 0592 00       		.byte	0
 12154 0593 00000000 		.space	5
 12154      00
 12155 0598 00       		.byte	0
 12156 0599 00       		.byte	0
 12157 059a 02       		.byte	2
 12158 059b 00       		.byte	0
 12159 059c 00       		.byte	0
 12160 059d 40       		.byte	64
 12161 059e 00       		.byte	0
 12162 059f 01       		.byte	1
 12163 05a0 00       		.byte	0
 12164 05a1 03       		.byte	3
 12165 05a2 00       		.byte	0
 12166 05a3 0F       		.byte	15
 12167 05a4 11       		.byte	17
 12168 05a5 00       		.byte	0
 12169 05a6 00       		.byte	0
 12170 05a7 30       		.byte	48
 12171 05a8 01       		.byte	1
 12172 05a9 00       		.byte	0
 12173 05aa 00       		.byte	0
 12174 05ab 00000000 		.space	5
 12174      00
 12175 05b0 00       		.byte	0
 12176 05b1 00       		.byte	0
 12177 05b2 02       		.byte	2
 12178 05b3 00       		.byte	0
 12179 05b4 00       		.byte	0
 12180 05b5 64       		.byte	100
 12181 05b6 00       		.byte	0
 12182 05b7 01       		.byte	1
 12183 05b8 00       		.byte	0
 12184 05b9 03       		.byte	3
 12185 05ba 00       		.byte	0
 12186 05bb 00       		.byte	0
 12187 05bc 00       		.byte	0
 12188 05bd 00       		.byte	0
 12189 05be 00       		.byte	0
 12190 05bf 30       		.byte	48
 12191 05c0 01       		.byte	1
 12192 05c1 00       		.byte	0
 12193 05c2 00       		.byte	0
 12194 05c3 00000000 		.space	5
 12194      00
 12195 05c8 00       		.byte	0
 12196 05c9 00       		.byte	0
 12197 05ca 02       		.byte	2
 12198 05cb 00       		.byte	0
 12199 05cc 00       		.byte	0
 12200 05cd 64       		.byte	100
 12201 05ce 00       		.byte	0
 12202 05cf 01       		.byte	1
 12203 05d0 00       		.byte	0
 12204 05d1 03       		.byte	3
 12205 05d2 00       		.byte	0
 12206 05d3 00       		.byte	0
 12207 05d4 00       		.byte	0
 12208 05d5 00       		.byte	0
 12209 05d6 00       		.byte	0
 12210 05d7 30       		.byte	48
 12211 05d8 01       		.byte	1
 12212 05d9 00       		.byte	0
 12213 05da 00       		.byte	0
 12214 05db 00000000 		.space	5
 12214      00
 12215 05e0 00       		.byte	0
 12216 05e1 00       		.byte	0
 12217 05e2 02       		.byte	2
 12218 05e3 00       		.byte	0
 12219 05e4 00       		.byte	0
 12220 05e5 64       		.byte	100
 12221 05e6 00       		.byte	0
 12222 05e7 01       		.byte	1
 12223 05e8 00       		.byte	0
 12224 05e9 03       		.byte	3
 12225 05ea 00       		.byte	0
 12226 05eb 00       		.byte	0
 12227 05ec 00       		.byte	0
 12228 05ed 00       		.byte	0
 12229 05ee 00       		.byte	0
 12230 05ef 30       		.byte	48
 12231 05f0 01       		.byte	1
 12232 05f1 00       		.byte	0
 12233 05f2 00       		.byte	0
 12234 05f3 00000000 		.space	5
 12234      00
 12235 05f8 00       		.byte	0
 12236 05f9 00       		.byte	0
 12237 05fa 02       		.byte	2
 12238 05fb 00       		.byte	0
 12239 05fc 00       		.byte	0
 12240 05fd 64       		.byte	100
 12241 05fe 00       		.byte	0
 12242 05ff 01       		.byte	1
 12243 0600 00       		.byte	0
 12244 0601 03       		.byte	3
 12245 0602 00       		.byte	0
 12246 0603 00       		.byte	0
 12247 0604 00       		.byte	0
 12248 0605 00       		.byte	0
 12249 0606 00       		.byte	0
 12250 0607 30       		.byte	48
 12251 0608 01       		.byte	1
 12252 0609 00       		.byte	0
 12253 060a 00       		.byte	0
 12254 060b 00000000 		.space	5
 12254      00
 12257              	glProbeCtrl:
 12258 0610 00       		.byte	0
 12259 0611 00       		.byte	0
 12260 0612 01       		.byte	1
 12261 0613 01       		.byte	1
 12262 0614 15       		.byte	21
 12263 0615 16       		.byte	22
 12264 0616 05       		.byte	5
 12265 0617 00       		.byte	0
 12266 0618 00       		.byte	0
 12267 0619 00       		.byte	0
 12268 061a 00       		.byte	0
 12269 061b 00       		.byte	0
 12270 061c 00       		.byte	0
 12271 061d 00       		.byte	0
 12272 061e 00       		.byte	0
 12273 061f 00       		.byte	0
 12274 0620 00       		.byte	0
 12275 0621 00       		.byte	0
 12276 0622 00       		.byte	0
 12277 0623 48       		.byte	72
 12278 0624 3F       		.byte	63
 12279 0625 00       		.byte	0
 12280 0626 00       		.byte	0
 12281 0627 40       		.byte	64
 12282 0628 00       		.byte	0
 12283 0629 00       		.byte	0
 12284 062a 0000     		.space	2
 12287              	glProbeStilCtrl:
 12288 062c 01       		.byte	1
 12289 062d 01       		.byte	1
 12290 062e 00       		.byte	0
 12291 062f 00       		.byte	0
 12292 0630 48       		.byte	72
 12293 0631 3F       		.byte	63
 12294 0632 00       		.byte	0
 12295 0633 00       		.byte	0
 12296 0634 40       		.byte	64
 12297 0635 00       		.byte	0
 12298 0636 00       		.byte	0
 12299 0637 00       		.space	1
 12302              	glProbeStilCtrl20:
 12303 0638 01       		.byte	1
 12304 0639 01       		.byte	1
 12305 063a 00       		.byte	0
 12306 063b 00       		.byte	0
 12307 063c D2       		.byte	-46
 12308 063d 0F       		.byte	15
 12309 063e 00       		.byte	0
 12310 063f 00       		.byte	0
 12311 0640 40       		.byte	64
 12312 0641 00       		.byte	0
 12313 0642 00       		.byte	0
 12316              	snapButFlag:
 12317 0643 01       		.byte	1
 12320              	glProbeCtrl20:
 12321 0644 00       		.byte	0
 12322 0645 00       		.byte	0
 12323 0646 01       		.byte	1
 12324 0647 01       		.byte	1
 12325 0648 80       		.byte	-128
 12326 0649 1A       		.byte	26
 12327 064a 06       		.byte	6
 12328 064b 00       		.byte	0
 12329 064c 00       		.byte	0
 12330 064d 00       		.byte	0
 12331 064e 00       		.byte	0
 12332 064f 00       		.byte	0
 12333 0650 00       		.byte	0
 12334 0651 00       		.byte	0
 12335 0652 00       		.byte	0
 12336 0653 00       		.byte	0
 12337 0654 00       		.byte	0
 12338 0655 00       		.byte	0
 12339 0656 00       		.byte	0
 12340 0657 D2       		.byte	-46
 12341 0658 0F       		.byte	15
 12342 0659 00       		.byte	0
 12343 065a 00       		.byte	0
 12344 065b 40       		.byte	64
 12345 065c 00       		.byte	0
 12346 065d 00       		.byte	0
 12347 065e 0000     		.space	2
 12350              	CyFxGpifRegValue_usb2:
 12351 0660 08830080 		.word	-2147450104
 12352 0664 67000000 		.word	103
 12353 0668 01000000 		.word	1
 12354 066c 46000000 		.word	70
 12355 0670 00000000 		.word	0
 12356 0674 00000000 		.word	0
 12357 0678 02000000 		.word	2
 12358 067c 82000000 		.word	130
 12359 0680 82070000 		.word	1922
 12360 0684 40040000 		.word	1088
 12361 0688 FCFF0000 		.word	65532
 12362 068c 28000000 		.word	40
 12363 0690 00000000 		.word	0
 12364 0694 00000000 		.word	0
 12365 0698 00000000 		.word	0
 12366 069c 00000000 		.word	0
 12367 06a0 01000000 		.word	1
 12368 06a4 00000000 		.word	0
 12369 06a8 00000000 		.word	0
 12370 06ac 00000000 		.word	0
 12371 06b0 00000000 		.word	0
 12372 06b4 00000000 		.word	0
 12373 06b8 00000000 		.word	0
 12374 06bc 00000000 		.word	0
 12375 06c0 00000000 		.word	0
 12376 06c4 00000000 		.word	0
 12377 06c8 00000000 		.word	0
 12378 06cc 00000000 		.word	0
 12379 06d0 00000000 		.word	0
 12380 06d4 06000000 		.word	6
 12381 06d8 00000000 		.word	0
 12382 06dc FFFF0000 		.word	65535
 12383 06e0 09010000 		.word	265
 12384 06e4 00000000 		.word	0
 12385 06e8 F71F0000 		.word	8183
 12386 06ec 00000000 		.word	0
 12387 06f0 FFFF0000 		.word	65535
 12388 06f4 09010000 		.word	265
 12389 06f8 00000000 		.word	0
 12390 06fc F71F0000 		.word	8183
 12391 0700 00000000 		.word	0
 12392 0704 00000000 		.word	0
 12393 0708 00000000 		.word	0
 12394 070c 00000000 		.word	0
 12395 0710 00000000 		.word	0
 12396 0714 00000000 		.word	0
 12397 0718 00000000 		.word	0
 12398 071c 00000000 		.word	0
 12399 0720 00000000 		.word	0
 12400 0724 00000000 		.word	0
 12401 0728 00000000 		.word	0
 12402 072c 00000000 		.word	0
 12403 0730 00000000 		.word	0
 12404 0734 00000000 		.word	0
 12405 0738 00000000 		.word	0
 12406 073c 00000000 		.word	0
 12407 0740 00000000 		.word	0
 12408 0744 00000000 		.word	0
 12409 0748 00000000 		.word	0
 12410 074c 00000000 		.word	0
 12411 0750 00000000 		.word	0
 12412 0754 00000000 		.word	0
 12413 0758 00000000 		.word	0
 12414 075c 00040180 		.word	-2147417088
 12415 0760 01040180 		.word	-2147417087
 12416 0764 02040180 		.word	-2147417086
 12417 0768 03040180 		.word	-2147417085
 12418 076c 00000000 		.word	0
 12419 0770 00000000 		.word	0
 12420 0774 00000000 		.word	0
 12421 0778 00000000 		.word	0
 12422 077c 00000000 		.word	0
 12423 0780 00000000 		.word	0
 12424 0784 00000000 		.word	0
 12425 0788 00000000 		.word	0
 12426 078c C1FFFFFF 		.word	-63
 12429              	CyFxGpifWavedataPosition_usb2:
 12430 0790 00       		.byte	0
 12431 0791 01       		.byte	1
 12432 0792 02       		.byte	2
 12433 0793 03       		.byte	3
 12434 0794 04       		.byte	4
 12435 0795 05       		.byte	5
 12436 0796 06       		.byte	6
 12437 0797 07       		.byte	7
 12438 0798 08       		.byte	8
 12439 0799 09       		.byte	9
 12440 079a 0A       		.byte	10
 12441 079b 08       		.byte	8
 12442 079c 0B       		.byte	11
 12443 079d 0C       		.byte	12
 12444 079e 0D       		.byte	13
 12445 079f 08       		.byte	8
 12446 07a0 0E       		.byte	14
 12447 07a1 0F       		.byte	15
 12448 07a2 08       		.byte	8
 12449 07a3 08       		.byte	8
 12450 07a4 08       		.byte	8
 12451 07a5 08       		.byte	8
 12452 07a6 08       		.byte	8
 12453 07a7 08       		.byte	8
 12454 07a8 08       		.byte	8
 12455 07a9 08       		.byte	8
 12456 07aa 08       		.byte	8
 12457 07ab 08       		.byte	8
 12458 07ac 08       		.byte	8
 12459 07ad 08       		.byte	8
 12460 07ae 08       		.byte	8
 12461 07af 08       		.byte	8
 12462 07b0 08       		.byte	8
 12463 07b1 08       		.byte	8
 12464 07b2 08       		.byte	8
 12465 07b3 08       		.byte	8
 12466 07b4 08       		.byte	8
 12467 07b5 08       		.byte	8
 12468 07b6 08       		.byte	8
 12469 07b7 08       		.byte	8
 12470 07b8 08       		.byte	8
 12471 07b9 08       		.byte	8
 12472 07ba 08       		.byte	8
 12473 07bb 08       		.byte	8
 12474 07bc 08       		.byte	8
 12475 07bd 08       		.byte	8
 12476 07be 08       		.byte	8
 12477 07bf 08       		.byte	8
 12478 07c0 08       		.byte	8
 12479 07c1 08       		.byte	8
 12480 07c2 08       		.byte	8
 12481 07c3 08       		.byte	8
 12482 07c4 08       		.byte	8
 12483 07c5 08       		.byte	8
 12484 07c6 08       		.byte	8
 12485 07c7 08       		.byte	8
 12486 07c8 08       		.byte	8
 12487 07c9 08       		.byte	8
 12488 07ca 08       		.byte	8
 12489 07cb 08       		.byte	8
 12490 07cc 08       		.byte	8
 12491 07cd 08       		.byte	8
 12492 07ce 08       		.byte	8
 12493 07cf 08       		.byte	8
 12494 07d0 08       		.byte	8
 12495 07d1 08       		.byte	8
 12496 07d2 08       		.byte	8
 12497 07d3 08       		.byte	8
 12498 07d4 08       		.byte	8
 12499 07d5 08       		.byte	8
 12500 07d6 08       		.byte	8
 12501 07d7 08       		.byte	8
 12502 07d8 08       		.byte	8
 12503 07d9 08       		.byte	8
 12504 07da 08       		.byte	8
 12505 07db 08       		.byte	8
 12506 07dc 08       		.byte	8
 12507 07dd 08       		.byte	8
 12508 07de 08       		.byte	8
 12509 07df 08       		.byte	8
 12510 07e0 08       		.byte	8
 12511 07e1 08       		.byte	8
 12512 07e2 08       		.byte	8
 12513 07e3 08       		.byte	8
 12514 07e4 08       		.byte	8
 12515 07e5 08       		.byte	8
 12516 07e6 08       		.byte	8
 12517 07e7 08       		.byte	8
 12518 07e8 08       		.byte	8
 12519 07e9 08       		.byte	8
 12520 07ea 08       		.byte	8
 12521 07eb 08       		.byte	8
 12522 07ec 08       		.byte	8
 12523 07ed 08       		.byte	8
 12524 07ee 08       		.byte	8
 12525 07ef 08       		.byte	8
 12526 07f0 08       		.byte	8
 12527 07f1 08       		.byte	8
 12528 07f2 08       		.byte	8
 12529 07f3 08       		.byte	8
 12530 07f4 08       		.byte	8
 12531 07f5 08       		.byte	8
 12532 07f6 08       		.byte	8
 12533 07f7 08       		.byte	8
 12534 07f8 08       		.byte	8
 12535 07f9 08       		.byte	8
 12536 07fa 08       		.byte	8
 12537 07fb 08       		.byte	8
 12538 07fc 08       		.byte	8
 12539 07fd 08       		.byte	8
 12540 07fe 08       		.byte	8
 12541 07ff 08       		.byte	8
 12542 0800 08       		.byte	8
 12543 0801 08       		.byte	8
 12544 0802 08       		.byte	8
 12545 0803 08       		.byte	8
 12546 0804 08       		.byte	8
 12547 0805 08       		.byte	8
 12548 0806 08       		.byte	8
 12549 0807 08       		.byte	8
 12550 0808 08       		.byte	8
 12551 0809 08       		.byte	8
 12552 080a 08       		.byte	8
 12553 080b 08       		.byte	8
 12554 080c 08       		.byte	8
 12555 080d 08       		.byte	8
 12556 080e 08       		.byte	8
 12557 080f 08       		.byte	8
 12558 0810 00       		.byte	0
 12559 0811 01       		.byte	1
 12560 0812 02       		.byte	2
 12561 0813 10       		.byte	16
 12562 0814 04       		.byte	4
 12563 0815 05       		.byte	5
 12564 0816 06       		.byte	6
 12565 0817 07       		.byte	7
 12566 0818 08       		.byte	8
 12567 0819 09       		.byte	9
 12568 081a 0A       		.byte	10
 12569 081b 08       		.byte	8
 12570 081c 11       		.byte	17
 12571 081d 0C       		.byte	12
 12572 081e 0D       		.byte	13
 12573 081f 08       		.byte	8
 12574 0820 0E       		.byte	14
 12575 0821 0F       		.byte	15
 12576 0822 08       		.byte	8
 12577 0823 00       		.space	1
 12580              	CyFxGpifWavedata_usb2:
 12581 0824 0181731E 		.word	510886145
 12582 0828 00000000 		.word	0
 12583 082c 00000080 		.word	-2147483648
 12584 0830 00000000 		.word	0
 12585 0834 00000000 		.word	0
 12586 0838 00000000 		.word	0
 12587 083c 0201703E 		.word	1047527682
 12588 0840 00010000 		.word	256
 12589 0844 A00000C0 		.word	-1073741664
 12590 0848 00000000 		.word	0
 12591 084c 00000000 		.word	0
 12592 0850 00000000 		.word	0
 12593 0854 0394731E 		.word	510891011
 12594 0858 04000020 		.word	536870916
 12595 085c 60004080 		.word	-2143289248
 12596 0860 00000000 		.word	0
 12597 0864 00000000 		.word	0
 12598 0868 00000000 		.word	0
 12599 086c 0620702E 		.word	779100166
 12600 0870 0C000000 		.word	12
 12601 0874 00000080 		.word	-2147483648
 12602 0878 0620702E 		.word	779100166
 12603 087c 0C000000 		.word	12
 12604 0880 00000080 		.word	-2147483648
 12605 0884 0394731E 		.word	510891011
 12606 0888 04000020 		.word	536870916
 12607 088c 60004080 		.word	-2143289248
 12608 0890 0620702E 		.word	779100166
 12609 0894 0C000000 		.word	12
 12610 0898 00000080 		.word	-2147483648
 12611 089c 0C93731E 		.word	510890764
 12612 08a0 04000024 		.word	603979780
 12613 08a4 90004080 		.word	-2143289200
 12614 08a8 0D20702E 		.word	779100173
 12615 08ac 0C000000 		.word	12
 12616 08b0 00000080 		.word	-2147483648
 12617 08b4 0780724E 		.word	1316126727
 12618 08b8 0A000000 		.word	10
 12619 08bc 00000080 		.word	-2147483648
 12620 08c0 08000000 		.word	8
 12621 08c4 00000000 		.word	0
 12622 08c8 00010080 		.word	-2147483392
 12623 08cc 0920702E 		.word	779100169
 12624 08d0 0C010000 		.word	268
 12625 08d4 00000080 		.word	-2147483648
 12626 08d8 0A01701E 		.word	510656778
 12627 08dc 0E000100 		.word	65550
 12628 08e0 00000080 		.word	-2147483648
 12629 08e4 00000000 		.word	0
 12630 08e8 00000000 		.word	0
 12631 08ec 00000000 		.word	0
 12632 08f0 00000000 		.word	0
 12633 08f4 00000000 		.word	0
 12634 08f8 00000000 		.word	0
 12635 08fc 0394731E 		.word	510891011
 12636 0900 04000020 		.word	536870916
 12637 0904 60004080 		.word	-2143289248
 12638 0908 08000000 		.word	8
 12639 090c 00000000 		.word	0
 12640 0910 00010080 		.word	-2147483392
 12641 0914 0B000000 		.word	11
 12642 0918 00000000 		.word	0
 12643 091c 00010080 		.word	-2147483392
 12644 0920 0C93731E 		.word	510890764
 12645 0924 04000024 		.word	603979780
 12646 0928 90004080 		.word	-2143289200
 12647 092c 0D20702E 		.word	779100173
 12648 0930 0C000000 		.word	12
 12649 0934 00000080 		.word	-2147483648
 12650 0938 0D20702E 		.word	779100173
 12651 093c 0C000000 		.word	12
 12652 0940 00000080 		.word	-2147483648
 12653 0944 0E60724E 		.word	1316118542
 12654 0948 0A000000 		.word	10
 12655 094c 00000080 		.word	-2147483648
 12656 0950 0F000000 		.word	15
 12657 0954 00000000 		.word	0
 12658 0958 00010080 		.word	-2147483392
 12659 095c 1020702E 		.word	779100176
 12660 0960 0C010000 		.word	268
 12661 0964 00000080 		.word	-2147483648
 12662 0968 1101701E 		.word	510656785
 12663 096c 0E000100 		.word	65550
 12664 0970 00000080 		.word	-2147483648
 12665 0974 0C93731E 		.word	510890764
 12666 0978 04000024 		.word	603979780
 12667 097c 90004080 		.word	-2143289200
 12668 0980 0F000000 		.word	15
 12669 0984 00000000 		.word	0
 12670 0988 00010080 		.word	-2147483392
 12671 098c 12000000 		.word	18
 12672 0990 00000000 		.word	0
 12673 0994 00010080 		.word	-2147483392
 12674 0998 0394731E 		.word	510891011
 12675 099c 04000020 		.word	536870916
 12676 09a0 60004080 		.word	-2143289248
 12677 09a4 0480732E 		.word	779321348
 12678 09a8 02010000 		.word	258
 12679 09ac 000040C0 		.word	-1069547520
 12680 09b0 0580732E 		.word	779321349
 12681 09b4 02010000 		.word	258
 12682 09b8 000040C0 		.word	-1069547520
 12683 09bc 0580732E 		.word	779321349
 12684 09c0 02010000 		.word	258
 12685 09c4 000040C0 		.word	-1069547520
 12686 09c8 0480732E 		.word	779321348
 12687 09cc 02010000 		.word	258
 12688 09d0 000040C0 		.word	-1069547520
 12691              	CyFxGpifTransition_usb2:
 12692 09d4 0000     		.short	0
 12693 09d6 5555     		.short	21845
 12694 09d8 AAAA     		.short	-21846
 12695 09da 8888     		.short	-30584
 12696 09dc 1111     		.short	4369
 12697 09de 4444     		.short	17476
 12698 09e0 3333     		.short	13107
 12699 09e2 CCCC     		.short	-13108
 12702              	CyFxGpifRegValue:
 12703 09e4 08830080 		.word	-2147450104
 12704 09e8 67000000 		.word	103
 12705 09ec 00000000 		.word	0
 12706 09f0 46000000 		.word	70
 12707 09f4 00000000 		.word	0
 12708 09f8 00000000 		.word	0
 12709 09fc 02000000 		.word	2
 12710 0a00 82000000 		.word	130
 12711 0a04 82070000 		.word	1922
 12712 0a08 40040000 		.word	1088
 12713 0a0c FCFF0000 		.word	65532
 12714 0a10 28000000 		.word	40
 12715 0a14 00000000 		.word	0
 12716 0a18 00000000 		.word	0
 12717 0a1c 00000000 		.word	0
 12718 0a20 00000000 		.word	0
 12719 0a24 01000000 		.word	1
 12720 0a28 00000000 		.word	0
 12721 0a2c 00000000 		.word	0
 12722 0a30 00000000 		.word	0
 12723 0a34 00000000 		.word	0
 12724 0a38 00000000 		.word	0
 12725 0a3c 00000000 		.word	0
 12726 0a40 00000000 		.word	0
 12727 0a44 00000000 		.word	0
 12728 0a48 00000000 		.word	0
 12729 0a4c 00000000 		.word	0
 12730 0a50 00000000 		.word	0
 12731 0a54 00000000 		.word	0
 12732 0a58 06000000 		.word	6
 12733 0a5c 00000000 		.word	0
 12734 0a60 FFFF0000 		.word	65535
 12735 0a64 09010000 		.word	265
 12736 0a68 00000000 		.word	0
 12737 0a6c F71F0000 		.word	8183
 12738 0a70 00000000 		.word	0
 12739 0a74 FFFF0000 		.word	65535
 12740 0a78 09010000 		.word	265
 12741 0a7c 00000000 		.word	0
 12742 0a80 F71F0000 		.word	8183
 12743 0a84 00000000 		.word	0
 12744 0a88 00000000 		.word	0
 12745 0a8c 00000000 		.word	0
 12746 0a90 00000000 		.word	0
 12747 0a94 00000000 		.word	0
 12748 0a98 00000000 		.word	0
 12749 0a9c 00000000 		.word	0
 12750 0aa0 00000000 		.word	0
 12751 0aa4 00000000 		.word	0
 12752 0aa8 00000000 		.word	0
 12753 0aac 00000000 		.word	0
 12754 0ab0 00000000 		.word	0
 12755 0ab4 00000000 		.word	0
 12756 0ab8 00000000 		.word	0
 12757 0abc 00000000 		.word	0
 12758 0ac0 00000000 		.word	0
 12759 0ac4 00000000 		.word	0
 12760 0ac8 00000000 		.word	0
 12761 0acc 00000000 		.word	0
 12762 0ad0 00000000 		.word	0
 12763 0ad4 00000000 		.word	0
 12764 0ad8 00000000 		.word	0
 12765 0adc 00000000 		.word	0
 12766 0ae0 00040180 		.word	-2147417088
 12767 0ae4 01040180 		.word	-2147417087
 12768 0ae8 02040180 		.word	-2147417086
 12769 0aec 03040180 		.word	-2147417085
 12770 0af0 00000000 		.word	0
 12771 0af4 00000000 		.word	0
 12772 0af8 00000000 		.word	0
 12773 0afc 00000000 		.word	0
 12774 0b00 00000000 		.word	0
 12775 0b04 00000000 		.word	0
 12776 0b08 00000000 		.word	0
 12777 0b0c 00000000 		.word	0
 12778 0b10 C1FFFFFF 		.word	-63
 12781              	CyFxGpifWavedataPosition:
 12782 0b14 00       		.byte	0
 12783 0b15 01       		.byte	1
 12784 0b16 02       		.byte	2
 12785 0b17 03       		.byte	3
 12786 0b18 04       		.byte	4
 12787 0b19 05       		.byte	5
 12788 0b1a 06       		.byte	6
 12789 0b1b 07       		.byte	7
 12790 0b1c 08       		.byte	8
 12791 0b1d 09       		.byte	9
 12792 0b1e 0A       		.byte	10
 12793 0b1f 0B       		.byte	11
 12794 0b20 0B       		.byte	11
 12795 0b21 0B       		.byte	11
 12796 0b22 0B       		.byte	11
 12797 0b23 00       		.space	1
 12800              	CyFxGpifWavedata:
 12801 0b24 0181731E 		.word	510886145
 12802 0b28 00000000 		.word	0
 12803 0b2c 00000080 		.word	-2147483648
 12804 0b30 00000000 		.word	0
 12805 0b34 00000000 		.word	0
 12806 0b38 00000000 		.word	0
 12807 0b3c 0201702E 		.word	779092226
 12808 0b40 00010000 		.word	256
 12809 0b44 A0000080 		.word	-2147483488
 12810 0b48 00000000 		.word	0
 12811 0b4c 00000000 		.word	0
 12812 0b50 00000000 		.word	0
 12813 0b54 0380722E 		.word	779255811
 12814 0b58 02010020 		.word	536871170
 12815 0b5c 60000080 		.word	-2147483552
 12816 0b60 00000000 		.word	0
 12817 0b64 00000000 		.word	0
 12818 0b68 00000000 		.word	0
 12819 0b6c 0460722E 		.word	779247620
 12820 0b70 02010024 		.word	603980034
 12821 0b74 90000080 		.word	-2147483504
 12822 0b78 0594731E 		.word	510891013
 12823 0b7c 06000000 		.word	6
 12824 0b80 00000080 		.word	-2147483648
 12825 0b84 0380722E 		.word	779255811
 12826 0b88 02010020 		.word	536871170
 12827 0b8c 60000080 		.word	-2147483552
 12828 0b90 0693731E 		.word	510890758
 12829 0b94 06000000 		.word	6
 12830 0b98 00000080 		.word	-2147483648
 12831 0b9c 0720703E 		.word	1047535623
 12832 0ba0 08010000 		.word	264
 12833 0ba4 00000080 		.word	-2147483648
 12834 0ba8 0820703E 		.word	1047535624
 12835 0bac 08010000 		.word	264
 12836 0bb0 00000080 		.word	-2147483648
 12837 0bb4 0920703E 		.word	1047535625
 12838 0bb8 08010000 		.word	264
 12839 0bbc 00000080 		.word	-2147483648
 12840 0bc0 0A20703E 		.word	1047535626
 12841 0bc4 08010000 		.word	264
 12842 0bc8 00000080 		.word	-2147483648
 12843 0bcc 0380722E 		.word	779255811
 12844 0bd0 02010020 		.word	536871170
 12845 0bd4 60000080 		.word	-2147483552
 12846 0bd8 0B000000 		.word	11
 12847 0bdc 00000000 		.word	0
 12848 0be0 00010080 		.word	-2147483392
 12849 0be4 0460722E 		.word	779247620
 12850 0be8 02010024 		.word	603980034
 12851 0bec 90000080 		.word	-2147483504
 12852 0bf0 0D000000 		.word	13
 12853 0bf4 00000000 		.word	0
 12854 0bf8 00010080 		.word	-2147483392
 12855 0bfc 0460722E 		.word	779247620
 12856 0c00 02010024 		.word	603980034
 12857 0c04 90000080 		.word	-2147483504
 12858 0c08 0C000000 		.word	12
 12859 0c0c 00000000 		.word	0
 12860 0c10 00010080 		.word	-2147483392
 12861 0c14 0380722E 		.word	779255811
 12862 0c18 02010020 		.word	536871170
 12863 0c1c 60000080 		.word	-2147483552
 12864 0c20 0E000000 		.word	14
 12865 0c24 00000000 		.word	0
 12866 0c28 00010080 		.word	-2147483392
 12867 0c2c 00000000 		.word	0
 12868 0c30 00000000 		.word	0
 12869 0c34 00000000 		.word	0
 12870 0c38 00000000 		.word	0
 12871 0c3c 00000000 		.word	0
 12872 0c40 00000000 		.word	0
 12875              	CyFxGpifTransition:
 12876 0c44 0000     		.short	0
 12877 0c46 5555     		.short	21845
 12878 0c48 8888     		.short	-30584
 12879 0c4a AAAA     		.short	-21846
 12880 0c4c 3333     		.short	13107
 12881 0c4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 12882              		.align	2
 12883              	.LC0:
 12884 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 12884      7065722D 
 12884      74696D65 
 12884      72202564 
 12884      0D0A00
 12885 0013 00       		.space	1
 12886              	.LC1:
 12887 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 12887      636F6D6D 
 12887      616E6420 
 12887      71756575 
 12887      65206973 
 12888 0037 00       		.space	1
 12889              	.LC2:
 12890 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 12890      7220696E 
 12890      206D756C 
 12890      74696368 
 12890      616E6E65 
 12891 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 12891      2C20646D 
 12891      61446F6E 
 12891      65202578 
 12891      0D0A00
 12892 007e 0000     		.space	2
 12893              	.LC3:
 12894 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 12894      5420656E 
 12894      636F756E 
 12894      74657265 
 12894      642E2E2E 
 12895              	.LC4:
 12896 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 12896      454E4420 
 12896      656E636F 
 12896      756E7465 
 12896      7265642E 
 12897 00c2 0000     		.space	2
 12898              	.LC5:
 12899 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 12899      64697363 
 12899      6F6E6E65 
 12899      63746564 
 12899      2E2E2E30 
 12900 00e3 00       		.space	1
 12901              	.LC6:
 12902 00e4 0A0D6252 		.ascii	"\012\015bRType = 0x%x, bRequest = 0x%x, wValue = 0x"
 12902      54797065 
 12902      203D2030 
 12902      7825782C 
 12902      20625265 
 12903 0111 25782C20 		.ascii	"%x, wIndex = 0x%x, wLength= 0x%x\000"
 12903      77496E64 
 12903      6578203D 
 12903      20307825 
 12903      782C2077 
 12904 0132 0000     		.space	2
 12905              	.LC7:
 12906 0134 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 12906      43595F46 
 12906      585F5556 
 12906      435F5649 
 12906      44454F5F 
 12907 0167 0A00     		.ascii	"\012\000"
 12908 0169 000000   		.space	3
 12909              	.LC8:
 12910 016c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 12910      43595F46 
 12910      585F5556 
 12910      435F5649 
 12910      44454F5F 
 12911 019f 00       		.ascii	"\000"
 12912              	.LC9:
 12913 01a0 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 12913      726E6174 
 12913      65207365 
 12913      7474696E 
 12913      6720302E 
 12914              	.LC10:
 12915 01b8 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 12915      72206665 
 12915      61747572 
 12915      65207265 
 12915      71756573 
 12916 01db 00       		.space	1
 12917              	.LC11:
 12918 01dc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 12918      49324320 
 12918      636F6D6D 
 12918      616E6420 
 12918      69732030 
 12919 020f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 12919      78257820 
 12919      30782578 
 12919      20307825 
 12919      78203078 
 12920              	.LC12:
 12921 0228 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 12921      206C6967 
 12921      68742063 
 12921      6F6D7065 
 12921      6E736174 
 12922 025b 25640D0A 		.ascii	"%d\015\012\000"
 12922      00
 12923              	.LC13:
 12924 0260 54686520 		.ascii	"The I2C current data is not available. try again. %"
 12924      49324320 
 12924      63757272 
 12924      656E7420 
 12924      64617461 
 12925 0293 64202564 		.ascii	"d %d\015\012\000"
 12925      0D0A00
 12926 029a 0000     		.space	2
 12927              	.LC14:
 12928 029c 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 12928      26414743 
 12928      2073656E 
 12928      7420746F 
 12928      20686F73 
 12929 02c2 0000     		.space	2
 12930              	.LC15:
 12931 02c4 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 12931      26414743 
 12931      20676F74 
 12931      74656E20 
 12931      66726F6D 
 12932 02ee 0000     		.space	2
 12933              	.LC16:
 12934 02f0 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 12934      6C657665 
 12934      6C2E2025 
 12934      64202564 
 12934      3B202564 
 12935 030a 0000     		.space	2
 12936              	.LC17:
 12937 030c 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 12937      7365742E 
 12937      20256420 
 12937      25643B20 
 12937      25642025 
 12938              	.LC18:
 12939 0324 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 12939      67657420 
 12939      64617461 
 12939      2066726F 
 12939      6D20686F 
 12940 0351 000000   		.space	3
 12941              	.LC19:
 12942 0354 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 12942      52657175 
 12942      65737420 
 12942      30782578 
 12942      20706172 
 12943 0387 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 12943      6E642074 
 12943      6F20686F 
 12943      73742030 
 12943      78257820 
 12944 03a2 0000     		.space	2
 12945              	.LC20:
 12946 03a4 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 12946      204F7020 
 12946      72656365 
 12946      69766573 
 12946      20284354 
 12947 03cb 00       		.space	1
 12948              	.LC21:
 12949 03cc 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 12949      756C7420 
 12949      73656C65 
 12949      63746F72 
 12949      20284354 
 12950 03ee 0000     		.space	2
 12951              	.LC22:
 12952 03f0 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 12952      756C7420 
 12952      72657175 
 12952      65737420 
 12952      28435429 
 12953 0411 000000   		.space	3
 12954              	.LC23:
 12955 0414 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 12955      52657175 
 12955      65737420 
 12955      30782578 
 12955      20706172 
 12956 0447 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 12956      20307825 
 12956      78202F20 
 12956      73656E64 
 12956      20746F20 
 12957 0474 00       		.ascii	"\000"
 12958 0475 000000   		.space	3
 12959              	.LC24:
 12960 0478 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 12960      73657420 
 12960      64656620 
 12960      64617461 
 12960      20307825 
 12961 0497 00       		.space	1
 12962              	.LC25:
 12963 0498 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 12963      73657420 
 12963      64656620 
 12963      64617461 
 12963      20307825 
 12964 04cb 2E0D0A00 		.ascii	".\015\012\000"
 12965 04cf 00       		.space	1
 12966              	.LC26:
 12967 04d0 4572726F 		.ascii	"Error handler...\015\012\000"
 12967      72206861 
 12967      6E646C65 
 12967      722E2E2E 
 12967      0D0A00
 12968 04e3 00       		.space	1
 12969              	.LC27:
 12970 04e4 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 12970      64656661 
 12970      756C7420 
 12970      73657475 
 12970      70207265 
 12971              	.LC28:
 12972 0510 47657420 		.ascii	"Get UVC Prob(set) control %d %d %d %d %d %d %d\015\012"
 12972      55564320 
 12972      50726F62 
 12972      28736574 
 12972      2920636F 
 12973 0540 00       		.ascii	"\000"
 12974 0541 000000   		.space	3
 12975              	.LC29:
 12976 0544 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 12976      74686520 
 12976      76696465 
 12976      6F206D6F 
 12976      64652066 
 12977 0565 000000   		.space	3
 12978              	.LC30:
 12979 0568 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 12979      74686520 
 12979      76696465 
 12979      6F206D6F 
 12979      64652066 
 12980 058d 000000   		.space	3
 12981              	.LC31:
 12982 0590 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 12982      43595F46 
 12982      585F5556 
 12982      435F5354 
 12982      5245414D 
 12983 05b6 0000     		.space	2
 12984              	.LC32:
 12985 05b8 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 12985      55564320 
 12985      7374696C 
 12985      6C205072 
 12985      6F622873 
 12986 05e3 00       		.space	1
 12987              	.LC33:
 12988 05e4 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 12988      43595F46 
 12988      585F5556 
 12988      435F5354 
 12988      494C5F45 
 12989              	.LC34:
 12990 0608 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 12990      55564320 
 12990      7374696C 
 12990      6C207472 
 12990      69676765 
 12991 0631 000000   		.space	3
 12992              	.LC35:
 12993 0634 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 12993      7374696C 
 12993      6C207472 
 12993      69676765 
 12993      7220636F 
 12994 065b 00       		.space	1
 12995              	.LC36:
 12996 065c 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 12996      65642074 
 12996      6F207365 
 12996      6E642069 
 12996      6E746572 
 12997 068d 0A00     		.ascii	"\012\000"
 12998 068f 00       		.space	1
 12999              	.LC37:
 13000 0690 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 13000      6F6D6D69 
 13000      74656F66 
 13000      20737461 
 13000      7465203D 
 13001              	.LC38:
 13002 06a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 13002      6E656C20 
 13002      53657420 
 13002      57726170 
 13002      55702066 
 13003 06d5 000000   		.space	3
 13004              	.LC39:
 13005 06d8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 13005      69742045 
 13005      4F462066 
 13005      61696C65 
 13005      64210A00 
 13006              	.LC40:
 13007 06ec 49324320 		.ascii	"I2C initialization failed!\012\000"
 13007      696E6974 
 13007      69616C69 
 13007      7A617469 
 13007      6F6E2066 
 13008              	.LC41:
 13009 0708 49324320 		.ascii	"I2C configuration failed!\012\000"
 13009      636F6E66 
 13009      69677572 
 13009      6174696F 
 13009      6E206661 
 13010 0723 00       		.space	1
 13011              	.LC42:
 13012 0724 55415254 		.ascii	"UART initialization failed!\012\000"
 13012      20696E69 
 13012      7469616C 
 13012      697A6174 
 13012      696F6E20 
 13013 0741 000000   		.space	3
 13014              	.LC43:
 13015 0744 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 13015      43726561 
 13015      74652045 
 13015      76656E74 
 13015      20666169 
 13016 076e 0000     		.space	2
 13017              	.LC44:
 13018 0770 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 13018      20496E69 
 13018      74206661 
 13018      696C6564 
 13018      2C204572 
 13019 0793 00       		.space	1
 13020              	.LC45:
 13021 0794 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 13021      204F7665 
 13021      72726964 
 13021      65206661 
 13021      696C6564 
 13022 07bb 00       		.space	1
 13023              	.LC46:
 13024 07bc 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 13024      28323029 
 13024      204F7665 
 13024      72726964 
 13024      65206661 
 13025 07e7 00       		.space	1
 13026              	.LC47:
 13027 07e8 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 13027      28323429 
 13027      204F7665 
 13027      72726964 
 13027      65206661 
 13028 0813 00       		.space	1
 13029              	.LC48:
 13030 0814 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 13030      20536574 
 13030      20287265 
 13030      73657420 
 13030      32322920 
 13031 0846 00       		.ascii	"\000"
 13032 0847 00       		.space	1
 13033              	.LC49:
 13034 0848 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 13034      20536574 
 13034      2028706F 
 13034      77657220 
 13034      32302920 
 13035 087a 00       		.ascii	"\000"
 13036 087b 00       		.space	1
 13037              	.LC50:
 13038 087c 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 13038      20536574 
 13038      2028736E 
 13038      61702073 
 13038      686F7420 
 13039 08af 25640A00 		.ascii	"%d\012\000"
 13040 08b3 00       		.space	1
 13041              	.LC51:
 13042 08b4 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 13042      46756E63 
 13042      74696F6E 
 13042      20466169 
 13042      6C656420 
 13043 08e3 00       		.space	1
 13044              	.LC52:
 13045 08e4 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 13045      46756E63 
 13045      74696F6E 
 13045      20466169 
 13045      6C656420 
 13046 0913 00       		.space	1
 13047              	.LC53:
 13048 0914 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 13048      53657420 
 13048      456E6470 
 13048      6F696E74 
 13048      20636F6E 
 13049 0944 00       		.ascii	"\000"
 13050 0945 000000   		.space	3
 13051              	.LC54:
 13052 0948 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 13052      496E7465 
 13052      72727570 
 13052      74205374 
 13052      61747573 
 13053 097b 20436F64 		.ascii	" Code = %d\012\000"
 13053      65203D20 
 13053      25640A00 
 13054 0987 00       		.space	1
 13055              	.LC55:
 13056 0988 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 13056      65642074 
 13056      6F20616C 
 13056      6C6F6361 
 13056      7465206D 
 13057 09bb 65720D0A 		.ascii	"er\015\012\000"
 13057      00
 13058              	.LC56:
 13059 09c0 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 13059      4368616E 
 13059      6E656C20 
 13059      43726561 
 13059      74696F6E 
 13060 09ee 0000     		.space	2
 13061              	.LC57:
 13062 09f0 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 13062      436F6E6E 
 13062      65637420 
 13062      6661696C 
 13062      65642C20 
 13063 0a15 000000   		.space	3
 13064              	.LC58:
 13065 0a18 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 13065      74686520 
 13065      76696465 
 13065      6F206D6F 
 13065      64652066 
 13066 0a3a 0000     		.space	2
 13067              	.LC59:
 13068 0a3c 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 13068      4368616E 
 13068      6E656C20 
 13068      52657365 
 13068      74204661 
 13069 0a67 00       		.space	1
 13070              	.LC60:
 13071 0a68 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 13071      4368616E 
 13071      6E656C20 
 13071      53657420 
 13071      5472616E 
 13072 0a99 00       		.ascii	"\000"
 13073 0a9a 0000     		.space	2
 13074              	.LC61:
 13075 0a9c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 13075      4368616E 
 13075      6E656C20 
 13075      53657420 
 13075      5472616E 
 13076 0acd 0A00     		.ascii	"\012\000"
 13077 0acf 00       		.space	1
 13078              	.LC62:
 13079 0ad0 0D0A2073 		.ascii	"\015\012 super gpif\000"
 13079      75706572 
 13079      20677069 
 13079      6600
 13080 0ade 0000     		.space	2
 13081              	.LC63:
 13082 0ae0 0D0A2068 		.ascii	"\015\012 high gpif\000"
 13082      69676820 
 13082      67706966 
 13082      00
 13083 0aed 000000   		.space	3
 13084              	.LC64:
 13085 0af0 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 13085      696E6720 
 13085      47504946 
 13085      20436F6E 
 13085      66696775 
 13086 0b23 0A00     		.ascii	"\012\000"
 13087 0b25 000000   		.space	3
 13088              	.LC65:
 13089 0b28 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 13089      74696E67 
 13089      20475049 
 13089      46207374 
 13089      61746520 
 13090 0b5b 0D0A00   		.ascii	"\015\012\000"
 13091 0b5e 0000     		.space	2
 13092              	.LC66:
 13093 0b60 33303A55 		.ascii	"30:UVC App Thread\000"
 13093      56432041 
 13093      70702054 
 13093      68726561 
 13093      6400
 13094 0b72 0000     		.space	2
 13095              	.LC67:
 13096 0b74 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 13096      56432041 
 13096      70702045 
 13096      50302054 
 13096      68726561 
 13097 0b8a 0000     		.space	2
 13098              	.LC68:
 13099 0b8c 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 13099      32432041 
 13099      70702043 
 13099      54524C20 
 13099      54687265 
 13100 0ba3 00       		.bss
 13101              		.align	2
 13102              		.set	.LANCHOR0,. + 0
 13105              	glFxUVCEvent:
 13106 0000 00000000 		.space	40
 13106      00000000 
 13106      00000000 
 13106      00000000 
 13106      00000000 
 13109              	timercount:
 13110 0028 00       		.space	1
 13111 0029 000000   		.space	3
 13114              	curFlag:
 13115 002c 00000000 		.space	64
 13115      00000000 
 13115      00000000 
 13115      00000000 
 13115      00000000 
 13118              	fb:
 13119 006c 0000     		.space	2
 13122              	pb:
 13123 006e 0000     		.space	2
 13126              	pbc:
 13127 0070 0000     		.space	2
 13128 0072 0000     		.space	2
 13131              	stiflag:
 13132 0074 00000000 		.space	4
 13135              	hitFV:
 13136 0078 00000000 		.space	4
 13139              	prodCount:
 13140 007c 0000     		.space	2
 13143              	consCount:
 13144 007e 0000     		.space	2
 13147              	streamingStarted:
 13148 0080 00000000 		.space	4
 13151              	gpif_initialized:
 13152 0084 00000000 		.space	4
 13155              	isUsbConnected:
 13156 0088 00000000 		.space	4
 13159              	clearFeatureRqtReceived:
 13160 008c 00000000 		.space	4
 13163              	I2CCMDArry:
 13164 0090 00000000 		.space	12
 13164      00000000 
 13164      00000000 
 13167              	glEp0Buffer:
 13168 009c 00000000 		.space	32
 13168      00000000 
 13168      00000000 
 13168      00000000 
 13168      00000000 
 13171              	WDRflag:
 13172 00bc 00000000 		.space	4
 13175              	usbSpeed:
 13176 00c0 00       		.space	1
 13177 00c1 000000   		.space	3
 13180              	glCommitCtrl:
 13181 00c4 00000000 		.space	32
 13181      00000000 
 13181      00000000 
 13181      00000000 
 13181      00000000 
 13184              	setRes:
 13185 00e4 00       		.space	1
 13188              	IMcount.8108:
 13189 00e5 00       		.space	1
 13190 00e6 0000     		.space	2
 13193              	uvcAppThread:
 13194 00e8 00000000 		.space	168
 13194      00000000 
 13194      00000000 
 13194      00000000 
 13194      00000000 
 13197              	uvcAppEP0Thread:
 13198 0190 00000000 		.space	168
 13198      00000000 
 13198      00000000 
 13198      00000000 
 13198      00000000 
 13201              	i2cAppThread:
 13202 0238 00000000 		.space	168
 13202      00000000 
 13202      00000000 
 13202      00000000 
 13202      00000000 
 13205              	pbcpbak:
 13206 02e0 0000     		.space	2
 13209              	pbcbak:
 13210 02e2 0000     		.space	2
 13213              	pbbak:
 13214 02e4 0000     		.space	2
 13217              	fbbak:
 13218 02e6 0000     		.space	2
 13221              	testSnap:
 13222 02e8 00       		.space	1
 13223 02e9 000000   		.text
 13224              	.Letext0:
 13225              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 13226              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13227              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 13228              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 13229              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 13230              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13231              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13232              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 13233              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13234              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13235              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13236              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13237              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13238              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13239              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13240              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 13241              		.file 18 "../cmdqu.h"
 13242              		.file 19 "../uvc.h"
 13243              		.file 20 "../cyfxgpif2config.h"
 13244              		.file 21 "../cyfxgpif2config_usb2_720.h"
 13245              		.file 22 "../sensor.h"
 13246              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:38     .text:00000010 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:42     .text:00000014 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:45     .text:00000014 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:205    .text:0000015c $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:211    .text:0000016c $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:330    .text:00000258 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:342    .text:0000027c $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:345    .text:0000027c CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:577    .text:00000414 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:587    .text:00000430 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:589    .text:00000430 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:804    .text:000005ac $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:815    .text:000005bc $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:817    .text:000005bc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1192   .text:000008b4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000002 wValue
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1211   .text:000008e4 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1214   .text:000008e4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1350   .text:00000a04 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1355   .text:00000a0c $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1358   .text:00000a0c setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1426   .text:00000a88 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1619   .text:00000c00 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1661   .text:00000c9c $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1716   .text:00000d18 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:1752   .text:00000da0 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3007   .text:00001930 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3027   .text:00001974 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3030   .text:00001974 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3177   .text:00001a9c $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3190   .text:00001ac4 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3606   .text:00001ef4 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3617   .text:00001f14 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3887   .text:000021a8 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3899   .text:000021cc $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:3902   .text:000021cc CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4201   .text:00002484 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4208   .text:00002494 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4211   .text:00002494 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4255   .text:000024d8 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4260   .text:000024e0 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4263   .text:000024e0 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4291   .text:000024fc $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4295   .text:00002500 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4298   .text:00002500 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4364   .text:00002570 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:4372   .text:00002580 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:6185   .text:000034cc $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000ac glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:6223   .text:00003548 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:6517   .text:000037f4 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:6532   .text:00003814 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9164   .text:00004aac $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9176   .text:00004ac0 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9179   .text:00004ac0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9211   .text:00004af4 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9224   .text:00004b20 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9229   .text:00004b30 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9234   .text:00004b40 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9281   .text:00004b98 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9291   .text:00004bac $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9294   .text:00004bac CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9363   .text:00004c18 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9369   .text:00004c24 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:9372   .text:00004c24 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10500  .text:00005548 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10555  .text:00005610 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10558  .text:00005610 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10724  .text:00005778 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10741  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10744  .text.startup:00000000 main
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:11912  .data:00000480 glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12302  .data:00000638 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12320  .data:00000644 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12287  .data:0000062c glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12257  .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13147  .bss:00000080 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13159  .bss:0000008c clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13175  .bss:000000c0 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13155  .bss:00000088 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13205  .bss:000002e0 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13209  .bss:000002e2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13213  .bss:000002e4 pbbak
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13217  .bss:000002e6 fbbak
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13126  .bss:00000070 pbc
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13122  .bss:0000006e pb
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13118  .bss:0000006c fb
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13221  .bss:000002e8 testSnap
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12316  .data:00000643 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10930  .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12350  .data:00000660 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12429  .data:00000790 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12580  .data:00000824 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12691  .data:000009d4 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10917  .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12702  .data:000009e4 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12781  .data:00000b14 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12800  .data:00000b24 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12875  .data:00000c44 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10883  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10887  .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10906  .rodata:00000010 ShutValueArry
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10942  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:10946  .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:11269  .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:11927  .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:11934  .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:12882  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13101  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13105  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13109  .bss:00000028 timercount
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13114  .bss:0000002c curFlag
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13131  .bss:00000074 stiflag
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13135  .bss:00000078 hitFV
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13139  .bss:0000007c prodCount
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13143  .bss:0000007e consCount
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13151  .bss:00000084 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13163  .bss:00000090 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13167  .bss:0000009c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13171  .bss:000000bc WDRflag
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13180  .bss:000000c4 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13184  .bss:000000e4 setRes
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13188  .bss:000000e5 IMcount.8108
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13193  .bss:000000e8 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13197  .bss:00000190 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cc6H9Hcd.s:13201  .bss:00000238 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_event_flags_set
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
memset
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
memcpy
SensorGetControl
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetWrapUp
CyU3PI2cInit
CyU3PI2cSetConfig
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
