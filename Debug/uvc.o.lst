   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** 
 105:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 106:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 107:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 108:../uvc.c      ****                                                            received. */
 109:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 110:../uvc.c      **** #ifdef BACKFLOW_DETECT
 111:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 112:../uvc.c      **** #endif
 113:../uvc.c      **** 
 114:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 115:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 116:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 117:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 118:../uvc.c      **** #endif
 119:../uvc.c      **** 
 120:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 121:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 122:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 123:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 125:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 126:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 127:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 128:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 129:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 131:../uvc.c      ****                                    with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 133:../uvc.c      ****                                    streaming with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 135:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 136:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 137:../uvc.c      **** };
 138:../uvc.c      **** 
 139:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 140:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 141:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 143:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 144:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 145:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 146:../uvc.c      **** };
 147:../uvc.c      **** 
 148:../uvc.c      **** 
 149:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 150:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 151:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 152:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 154:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 155:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 156:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 157:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 158:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 159:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 160:../uvc.c      ****                                    with adjustable compression parameters */
 161:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 162:../uvc.c      ****                                    streaming with adjustable compression parameters */
 163:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 164:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 169:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 170:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 171:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 172:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 173:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 174:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 175:../uvc.c      **** };
 176:../uvc.c      **** 
 177:../uvc.c      **** 
 178:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 179:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 180:../uvc.c      **** 
 181:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 182:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 183:../uvc.c      **** {
 184:../uvc.c      ****     0x0C,                               /* Header Length */
 185:../uvc.c      ****     0x8C,                               /* Bit field header field */
 186:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 188:../uvc.c      **** };
 189:../uvc.c      **** 
 190:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 191:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 192:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 193:../uvc.c      ****                                                            the current video frame. */
 194:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 195:../uvc.c      **** #ifndef CAM720
 196:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 197:../uvc.c      **** #else
 198:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 199:../uvc.c      **** #endif
 200:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 201:../uvc.c      **** 
 202:../uvc.c      **** /************ control parameters array ***********
 203:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 204:../uvc.c      ****  *    e.g.
 205:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 206:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 207:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 208:../uvc.c      ****  **************************************************/
 209:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 210:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 211:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 212:../uvc.c      **** #ifndef CAM720
 213:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 214:../uvc.c      **** #else
 215:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 216:../uvc.c      **** #endif
 217:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0,
 218:../uvc.c      **** 		{/*2*/ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0,
 219:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 220:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 221:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 222:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 223:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,
 224:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 225:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 226:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 227:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 228:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 229:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 232:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 233:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 234:../uvc.c      **** #ifndef CAM720
 235:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 236:../uvc.c      **** #else
 237:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 238:../uvc.c      **** #endif
 239:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 240:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 241:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 242:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 243:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 244:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 245:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 246:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg1     , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 247:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 248:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		/**********************************
 252:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 253:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 254:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 255:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 256:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 257:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 258:../uvc.c      **** 		 *
 259:../uvc.c      **** 		 *********************************/
 260:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 261:../uvc.c      **** };
 262:../uvc.c      **** 
 263:../uvc.c      **** #ifndef CAM720
 264:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 265:../uvc.c      **** #else
 266:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 267:../uvc.c      **** #endif
 268:../uvc.c      **** 
 269:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 270:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 271:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 272:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 273:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 274:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0
 275:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 276:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 277:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 278:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 279:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 280:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 281:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 282:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 283:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 284:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 285:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 286:../uvc.c      **** };
 287:../uvc.c      **** 
 288:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 289:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 290:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 291:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 292:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 293:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 294:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 295:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 296:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 297:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 298:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 299:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 300:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 301:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 302:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 303:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 304:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 305:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 306:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 307:../uvc.c      **** };
 308:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 309:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 310:../uvc.c      **** /*
 311:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 312:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 313:../uvc.c      ****  */
 314:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 315:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 316:../uvc.c      **** };
 317:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 318:../uvc.c      **** 		0
 319:../uvc.c      **** };
 320:../uvc.c      **** 
 321:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 322:../uvc.c      **** 
 323:../uvc.c      **** void I2CCmdHandler(){
 324:../uvc.c      **** 	uint8_t buf[2];
 325:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 327:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 329:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 330:../uvc.c      **** 
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 332:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 333:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 334:../uvc.c      **** 
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 336:../uvc.c      **** 	{
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 338:../uvc.c      **** #if 0 //for debugging
 339:../uvc.c      **** 		/* test still image operation */
 340:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 341:../uvc.c      **** 			snapButFlag = 0; //press
 342:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 343:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 344:../uvc.c      **** 			snapButFlag = 0xf; //release
 345:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 346:../uvc.c      **** 		}
 347:../uvc.c      **** 
 348:../uvc.c      **** 		/* end of the test */
 349:../uvc.c      **** #endif
 350:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 355:../uvc.c      **** 			}
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 357:../uvc.c      **** 		}else{//not support currently
 358:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 359:../uvc.c      **** 		}
 360:../uvc.c      **** 	}else if(CmdType == 1){
 361:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 362:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 363:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 364:../uvc.c      **** 			if(0 && (I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 365:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 366:../uvc.c      **** 				cmdSet(cmdQuptr, 0x23, 0x10, 0x30, STOP, 0);
 367:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 368:../uvc.c      **** 			}
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 370:../uvc.c      **** 		}else{//not support currently
 371:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 372:../uvc.c      **** 		}
 373:../uvc.c      **** 
 374:../uvc.c      **** 	}
 375:../uvc.c      **** }
 376:../uvc.c      **** 
 377:../uvc.c      **** /************************************
 378:../uvc.c      ****  * set Iris mode
 379:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 380:../uvc.c      ****  */
 381:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 382:../uvc.c      **** 	uint8_t dataIdx;
 383:../uvc.c      **** 	  dataIdx = 0;
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 388:../uvc.c      **** }
 389:../uvc.c      **** 
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 391:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 392:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 393:../uvc.c      ****     uint16_t readCount;
 394:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 395:../uvc.c      ****     uint8_t devAdd;
 396:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 397:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 398:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 399:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 400:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 401:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 402:../uvc.c      ****     }else{
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 404:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 405:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 406:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 407:../uvc.c      ****     }
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 409:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 410:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 411:../uvc.c      **** #endif
 412:../uvc.c      ****     reqData = bRequest;
 413:../uvc.c      ****     /*
 414:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 415:../uvc.c      ****      */
 416:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 417:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 418:../uvc.c      ****     	goto EndofSet;
 419:../uvc.c      ****     }
 420:../uvc.c      ****     switch (bRequest)
 421:../uvc.c      **** 		 {
 422:../uvc.c      **** 
 423:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 424:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 425:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 427:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 428:../uvc.c      **** 			  break;
 429:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 430:../uvc.c      **** 
 431:../uvc.c      **** 			 switch(CtrlID)
 432:../uvc.c      **** 			 {
 433:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 434:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 435:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 436:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 437:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 438:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 439:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 440:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 441:../uvc.c      **** 			 	 		 break;
 442:../uvc.c      **** 			 	 }
 443:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 444:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 445:../uvc.c      **** 					 if(CamMode == 1){//720p
 446:../uvc.c      **** 						if(sendData >= 3){
 447:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 448:../uvc.c      **** 							sendData = 0; //set back to default
 449:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 450:../uvc.c      **** 						}
 451:../uvc.c      **** 						sendData += 4;
 452:../uvc.c      **** 					 }
 453:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 454:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 455:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 456:../uvc.c      **** 					 break;
 457:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 460:../uvc.c      **** 			 		 }
 461:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 462:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 463:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 464:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 465:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 466:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 467:../uvc.c      **** #endif
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 469:../uvc.c      **** 			 		 {
 470:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 471:../uvc.c      **** 			 		 }
 472:../uvc.c      **** 			 		 break;
 473:../uvc.c      **** 				 case ExtAexModCtlID9:
 474:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 475:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 476:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 477:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 478:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 479:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 480:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 481:../uvc.c      **** 					 break;
 482:../uvc.c      **** 
 483:../uvc.c      **** 			 	 case BrgtCtlID1:
 484:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 485:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 486:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 488:../uvc.c      **** 					 }else{
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 490:../uvc.c      **** 					 }
 491:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 492:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 493:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 494:../uvc.c      **** 					 break;
 495:../uvc.c      **** 				 case HueCtlID5:
 496:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 499:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 500:../uvc.c      **** 					 break;
 501:../uvc.c      **** 				 case WBTLevCtlID11:
 502:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 503:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 504:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 505:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 506:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 507:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 508:../uvc.c      **** 					 break;
 509:../uvc.c      **** 				 case SaturCtlID6:
 510:../uvc.c      **** 				 default:
 511:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 512:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 513:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 514:../uvc.c      **** 					 break;
 515:../uvc.c      **** 			 }
 516:../uvc.c      **** 
 517:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 518:../uvc.c      **** 
 519:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 520:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 521:../uvc.c      **** #endif
 522:../uvc.c      **** 			  break;
 523:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 524:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 525:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 526:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 527:../uvc.c      **** 		 	 }
 528:../uvc.c      **** 
 529:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 530:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 531:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 532:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 533:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 534:../uvc.c      **** 			 }else
 535:../uvc.c      **** 			 {
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 537:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 538:../uvc.c      **** 			 }
 539:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 540:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 541:../uvc.c      **** 			  break;
 542:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 543:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 544:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 545:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 546:../uvc.c      **** 		 	 }
 547:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 548:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 549:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 550:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 551:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 552:../uvc.c      **** 			 }else
 553:../uvc.c      **** 			 {
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 555:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 556:../uvc.c      **** 			 }
 557:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 558:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 559:../uvc.c      **** 			  break;
 560:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 561:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 563:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 564:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 565:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 566:../uvc.c      **** 		 	 }
 567:../uvc.c      **** 		 	 else{
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 569:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 570:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 571:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 572:../uvc.c      **** 		 	 }
 573:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 574:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 575:../uvc.c      **** 			  break;
 576:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 577:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 579:../uvc.c      **** 		 	 }
 580:../uvc.c      **** 		 	 else{
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 582:../uvc.c      **** 		 	 }
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 584:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 585:../uvc.c      **** 			  Len = 1;
 586:../uvc.c      **** 			  break;
 587:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 588:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 589:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 590:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 591:../uvc.c      **** 		 	 }
 592:../uvc.c      **** 
 593:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 594:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 595:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 596:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 597:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 598:../uvc.c      **** 			 }else{
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 600:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 601:../uvc.c      **** 			 }
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 603:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 604:../uvc.c      **** 			  break;
 605:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 606:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 607:../uvc.c      **** 				  glEp0Buffer, &readCount);
 608:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 609:../uvc.c      **** 			   {
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 612:../uvc.c      **** 				  getData = glEp0Buffer[0];
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 614:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 615:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 616:../uvc.c      **** #endif
 617:../uvc.c      **** 				  switch(CtrlID)
 618:../uvc.c      **** 					 {
 619:../uvc.c      **** 						 case ExtShutCtlID0:
 620:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 621:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 622:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 623:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 625:../uvc.c      **** 									 }else{
 626:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 627:../uvc.c      **** 									 }
 628:../uvc.c      **** 								 }
 629:../uvc.c      **** 							 }else{
 630:../uvc.c      **** 								 Data1 = Data0 - 1;
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 632:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 634:../uvc.c      **** 									 }else{
 635:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 636:../uvc.c      **** 									 }
 637:../uvc.c      **** 								 }
 638:../uvc.c      **** 								 if(Data1 < 8){
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 641:../uvc.c      **** 								 }else{
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 644:../uvc.c      **** 								 }
 645:../uvc.c      **** 							 }
 646:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 647:../uvc.c      **** 							 dataIdx = 0;
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 649:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 651:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 652:../uvc.c      **** 							 break;
 653:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 655:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 656:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 657:../uvc.c      **** 							 dataIdx = 0;
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 659:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 660:../uvc.c      **** 							 if(getData != 0){
 661:../uvc.c      **** 								 dataIdx++;
 662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 663:../uvc.c      **** 							 }
 664:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 665:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 666:../uvc.c      **** 							 break;
 667:../uvc.c      **** 						 case ExtExRefCtlID10:
 668:../uvc.c      **** 							 dataIdx = 0;
 669:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 670:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 672:../uvc.c      **** 							 if(WDRflag)
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 674:../uvc.c      **** 							 else
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 676:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 677:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 678:../uvc.c      **** 						 case ExtCamMCtlID12:
 679:../uvc.c      **** 							 /*
 680:../uvc.c      **** 							 dataIdx = 0;
 681:../uvc.c      **** 							 if(Data0 <= 3){
 682:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 683:../uvc.c      **** 								 Data1 = Data0;
 684:../uvc.c      **** 							 }else{
 685:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 686:../uvc.c      **** 								 Data1 = Data0-4;
 687:../uvc.c      **** 							 }
 688:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 689:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 690:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 692:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 693:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 694:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 695:../uvc.c      **** 							 */
 696:../uvc.c      **** 							 break;
 697:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 698:../uvc.c      **** 							 dataIdx = 0;
 699:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 700:../uvc.c      **** 								 Data0 = 1;
 701:../uvc.c      **** 							 }else{ //save current sensor parameters.
 702:../uvc.c      **** 								 Data0 = 0;
 703:../uvc.c      **** 							 }
 704:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 706:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 708:../uvc.c      **** 							 break;
 709:../uvc.c      **** 						 case ExtI2CCtlID15:
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 712:../uvc.c      **** 					 		 }
 713:../uvc.c      **** 					 		I2CCmdHandler();
 714:../uvc.c      **** 							 break;
 715:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 716:../uvc.c      **** 							 dataIdx = 0;
 717:../uvc.c      **** #if 0 //seperate version
 718:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 719:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 720:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 721:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 722:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 723:../uvc.c      **** 							 }else{ //disable BLD window
 724:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 725:../uvc.c      **** 							 }
 726:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 727:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 728:../uvc.c      **** 							 dataIdx++;
 729:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 730:../uvc.c      **** 							 dataIdx++;
 731:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 732:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 733:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 734:../uvc.c      **** 							 dataIdx++;
 735:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 737:../uvc.c      **** #else //combination version
 738:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 739:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 740:../uvc.c      **** 						     /* end test */
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 742:../uvc.c      **** 							 dataIdx++;
 743:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 744:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 745:../uvc.c      **** 							 getData1 = Data1;
 746:../uvc.c      **** #endif
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 748:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 749:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 750:../uvc.c      **** 							 break;
 751:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 752:../uvc.c      **** 							 dataIdx = 0;
 753:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 755:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 756:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 757:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 758:../uvc.c      **** 							 break;
 759:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 760:../uvc.c      **** 							 dataIdx = 0;
 761:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 766:../uvc.c      **** 							 break;
 767:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 768:../uvc.c      **** 							 dataIdx = 0;
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 770:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 771:../uvc.c      **** 							  if(Data0&0x80){
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 773:../uvc.c      **** 							  }else{
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 775:../uvc.c      **** 							  }
 776:../uvc.c      **** 							 Data1 |= ~0x03;
 777:../uvc.c      **** 							 Data1 &= 0xC7;
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 779:../uvc.c      **** 						  	 dataIdx++;
 780:../uvc.c      **** 
 781:../uvc.c      **** 							 Data0 = (Data0 << 2);
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 783:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 784:../uvc.c      **** 
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 786:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 787:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 788:../uvc.c      **** 
 789:../uvc.c      **** 							 break;
 790:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 791:../uvc.c      **** 							 dataIdx = 0;
 792:../uvc.c      **** 
 793:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 795:../uvc.c      **** 							 dataIdx++;
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 797:../uvc.c      **** 							 dataIdx++;
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 799:../uvc.c      **** 							 dataIdx++;
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 801:../uvc.c      **** 							 dataIdx++;
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 803:../uvc.c      **** 							 dataIdx++;
 804:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 805:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 806:../uvc.c      **** 
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 809:../uvc.c      **** 							 break;
 810:../uvc.c      **** 						 case SaturCtlID6:
 811:../uvc.c      **** 							 dataIdx = 0;
 812:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 813:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 815:../uvc.c      **** 							 dataIdx++;
 816:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 817:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 820:../uvc.c      **** 							 break;
 821:../uvc.c      **** 
 822:../uvc.c      **** 						 case WBTLevCtlID11:
 823:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 824:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 825:../uvc.c      **** 							 dataIdx = 0;
 826:../uvc.c      **** 
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 829:../uvc.c      **** 							 dataIdx++;
 830:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 831:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 832:../uvc.c      **** 
 833:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 834:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 836:../uvc.c      **** 							 break;
 837:../uvc.c      **** 						 case MFreqCtlID4:
 838:../uvc.c      **** 							 dataIdx = 0;
 839:../uvc.c      **** 							 Data0 = Data0 - 1;
 840:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 841:../uvc.c      **** 								 Data0 = 0;
 842:../uvc.c      **** 							 else if(Data0 >2)
 843:../uvc.c      **** 								 Data0 = 1;
 844:../uvc.c      **** 
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 847:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 848:../uvc.c      **** 
 849:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 851:../uvc.c      **** 							 break;
 852:../uvc.c      **** 					 	 case BLCCtlID0:
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 854:../uvc.c      **** 							 if(Data0 == 3)
 855:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 856:../uvc.c      **** 							 else
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 859:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 860:../uvc.c      **** 							 {
 861:../uvc.c      **** 								 if(Data0 < 2){
 862:../uvc.c      **** 					 				 ;//Data0 += 4;
 863:../uvc.c      **** 					 			 }else{
 864:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 865:../uvc.c      **** 									Data0 = 0; //set to default.
 866:../uvc.c      **** 					 			 }
 867:../uvc.c      **** 					 		 }
 868:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0+4;
 869:../uvc.c      **** 							 dataIdx = 0;
 870:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 874:../uvc.c      **** 
 875:../uvc.c      **** 					 		 break;
 876:../uvc.c      **** 						 default:
 877:../uvc.c      **** 							 dataIdx = 0;
 878:../uvc.c      **** 
 879:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 880:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 881:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 882:../uvc.c      **** 
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 885:../uvc.c      **** 							 break;
 886:../uvc.c      **** 					 }
 887:../uvc.c      **** 			   }else{
 888:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 889:../uvc.c      **** 			   }
 890:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 891:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 892:../uvc.c      **** #endif
 893:../uvc.c      **** 
 894:../uvc.c      **** 			  break;
 895:../uvc.c      **** 		  default:
 896:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 897:../uvc.c      **** 			  break;
 898:../uvc.c      **** 		 }
 899:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 900:../uvc.c      **** }
 901:../uvc.c      **** /************** CT control requests handler *************************/
 902:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 903:../uvc.c      **** 
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 905:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 906:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 907:../uvc.c      ****     uint16_t readCount;
 908:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 909:../uvc.c      ****     uint16_t diff, value, diffRd;
 910:../uvc.c      ****     uint8_t i, shutter, index;
 911:../uvc.c      ****     diff = 0xffff;
 912:../uvc.c      ****     shutter = 1;
 913:../uvc.c      ****     index = 1;
 914:../uvc.c      **** 
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 916:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 917:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 918:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 919:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 920:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 921:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 922:../uvc.c      **** #endif
 923:../uvc.c      ****     reqData = bRequest;
 924:../uvc.c      **** 
 925:../uvc.c      ****     switch (bRequest)
 926:../uvc.c      **** 		 {
 927:../uvc.c      **** 
 928:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 932:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 933:../uvc.c      **** 			  break;
 934:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 935:../uvc.c      **** 
 936:../uvc.c      **** 			 switch(CtrlID)
 937:../uvc.c      **** 			 {
 938:../uvc.c      **** 				 default:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 942:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 943:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 944:../uvc.c      **** 					 break;
 945:../uvc.c      **** 			 }
 946:../uvc.c      **** 
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 948:../uvc.c      **** 
 949:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 950:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 951:../uvc.c      **** #endif
 952:../uvc.c      **** 			  break;
 953:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 957:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 958:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 960:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 961:../uvc.c      **** 			  break;
 962:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 966:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 967:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 968:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 969:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 970:../uvc.c      **** 			  break;
 971:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 975:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 976:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 977:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 978:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 979:../uvc.c      **** 			  break;
 980:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 983:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 984:../uvc.c      **** 			  Len = 1;
 985:../uvc.c      **** 			  break;
 986:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 990:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 993:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 994:../uvc.c      **** 			  break;
 995:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 996:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 997:../uvc.c      **** 			  glEp0Buffer, &readCount);
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1000:../uvc.c      **** 			  value = Data1;
1001:../uvc.c      **** 
1002:../uvc.c      **** 			  switch(CtrlID)
1003:../uvc.c      **** 			  {
1004:../uvc.c      **** 		  	      case AutoExMCtlID1:
1005:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1006:../uvc.c      **** 
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1009:../uvc.c      **** 				    getData = glEp0Buffer[0];
1010:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1011:../uvc.c      **** 		  		    switch (getData){
1012:../uvc.c      **** 						case 1:
1013:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1014:../uvc.c      **** 							break;
1015:../uvc.c      **** 						case 2:
1016:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1017:../uvc.c      **** 							dataIdx = 0;
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1019:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1020:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1021:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1022:../uvc.c      **** 
1023:../uvc.c      **** 							break;
1024:../uvc.c      **** 						case 4:
1025:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1026:../uvc.c      **** 							break;
1027:../uvc.c      **** 						case 8:
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1029:../uvc.c      **** 			  		    	dataIdx = 0;
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1031:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1032:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1033:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1034:../uvc.c      **** 							break;
1035:../uvc.c      **** 		  		    }
1036:../uvc.c      **** #if 0
1037:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1038:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1039:../uvc.c      **** 						  dataIdx = 0;
1040:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1041:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1042:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1043:../uvc.c      **** 		  		    }
1044:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1045:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1046:../uvc.c      **** 		  		    }
1047:../uvc.c      **** #endif
1048:../uvc.c      **** 				    break;
1049:../uvc.c      **** 
1050:../uvc.c      **** 			  	  case ExTmACtlID3:
1051:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1052:../uvc.c      **** 
1053:../uvc.c      **** 					  value = (value << 8)|Data0;
1054:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1055:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1056:../uvc.c      **** 					  {
1057:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1058:../uvc.c      **** 						  {
1059:../uvc.c      **** 							if(value > ShutValueArry[i]){
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1061:../uvc.c      **** 							}else{
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1063:../uvc.c      **** 							}
1064:../uvc.c      **** 							  if(diff > diffRd){
1065:../uvc.c      **** 								  diff = diffRd;
1066:../uvc.c      **** 								  index = i;
1067:../uvc.c      **** 							  }
1068:../uvc.c      **** 						  }
1069:../uvc.c      **** 						  shutter = shutter+index;
1070:../uvc.c      **** 
1071:../uvc.c      **** 						  dataIdx = 0;
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1073:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1074:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1075:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1076:../uvc.c      **** 
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1081:../uvc.c      **** 					  }else{
1082:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1083:../uvc.c      **** 					  }
1084:../uvc.c      **** 					  getData = glEp0Buffer[0];
1085:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1086:../uvc.c      **** 					  break;
1087:../uvc.c      **** 			  	  case IriACtlID7:
1088:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1089:../uvc.c      **** 					  {
1090:../uvc.c      **** 							 dataIdx = 0;
1091:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1092:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1094:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1095:../uvc.c      **** 
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1099:../uvc.c      **** 					  }else{
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1101:../uvc.c      **** 					  }
1102:../uvc.c      **** 					  getData = glEp0Buffer[0];
1103:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1104:../uvc.c      **** 
1105:../uvc.c      **** 					  break;
1106:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1107:../uvc.c      **** 					  getData = glEp0Buffer[0];
1108:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1109:../uvc.c      **** #if 1
1110:../uvc.c      **** 					  dataIdx = 0;
1111:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1112:../uvc.c      **** 					  if(getData == 1)
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1114:../uvc.c      **** 					  else if(getData == 0xff)
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1116:../uvc.c      **** 					  else
1117:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1118:../uvc.c      **** 					  //dataIdx++;
1119:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1120:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1121:../uvc.c      **** #endif
1122:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1123:../uvc.c      **** 					  break;
1124:../uvc.c      **** 
1125:../uvc.c      **** 			  	  default:
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1128:../uvc.c      **** 			  		 break;
1129:../uvc.c      **** 			  }
1130:../uvc.c      **** 			  break;
1131:../uvc.c      **** 		  default:
1132:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1133:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1134:../uvc.c      **** 			  break;
1135:../uvc.c      **** 		 }
1136:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1137:../uvc.c      **** 
1138:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1139:../uvc.c      **** }
1140:../uvc.c      **** 
1141:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1142:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1143:../uvc.c      **** {
1144:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1145:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1146:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1147:../uvc.c      **** 
1148:../uvc.c      ****     CtrlID = BrgtCtlID1;
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1150:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1151:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1152:../uvc.c      ****     Data1 = Data0;
1153:../uvc.c      **** 
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1155:../uvc.c      ****     if(Data1&0x80){
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1157:../uvc.c      ****     }else{
1158:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1159:../uvc.c      ****     }
1160:../uvc.c      ****     Data0 = (Data0 << 2);
1161:../uvc.c      **** 
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1163:../uvc.c      **** 
1164:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1166:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1167:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1169:../uvc.c      **** 
1170:../uvc.c      ****     CtrlID = ConsCtlID2;
1171:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1172:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1173:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1174:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1175:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1177:../uvc.c      **** 
1178:../uvc.c      ****     CtrlID = HueCtlID5;
1179:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1180:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1181:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1190:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1191:../uvc.c      **** 
1192:../uvc.c      ****     CtrlID = SaturCtlID6;
1193:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1194:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1195:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1196:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1199:../uvc.c      **** 
1200:../uvc.c      ****     CtrlID = ShapCtlID7;
1201:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1202:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1203:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1204:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1205:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1207:../uvc.c      **** 
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1209:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1210:../uvc.c      **** 	return;
1211:../uvc.c      **** }
1212:../uvc.c      **** 
1213:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1214:../uvc.c      **** void
1215:../uvc.c      **** CyFxUVCAddHeader (
1216:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1217:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1218:../uvc.c      ****         )
1219:../uvc.c      **** {
1220:../uvc.c      ****     /* Copy header to buffer */
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1222:../uvc.c      **** 
1223:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1224:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1225:../uvc.c      ****     {
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1227:../uvc.c      ****     }
1228:../uvc.c      **** }
1229:../uvc.c      **** 
1230:../uvc.c      **** 
1231:../uvc.c      **** /* Application Error Handler */
1232:../uvc.c      **** void
1233:../uvc.c      **** CyFxAppErrorHandler (
1234:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1235:../uvc.c      ****         )
1236:../uvc.c      **** {
1237:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1238:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1239:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1240:../uvc.c      **** 
1241:../uvc.c      ****        This function can be modified to take additional error handling actions such
1242:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1243:../uvc.c      ****      */
1244:../uvc.c      ****     for (;;)
1245:../uvc.c      ****     {
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
1248:../uvc.c      ****     }
1249:../uvc.c      **** }
1250:../uvc.c      **** 
1251:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1252:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1253:../uvc.c      ****  */
1254:../uvc.c      **** static void
1255:../uvc.c      **** CyFxUVCApplnAbortHandler (
1256:../uvc.c      ****         void)
1257:../uvc.c      **** {
1258:../uvc.c      **** 	uint32_t flag;
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1260:../uvc.c      **** 	{
1261:../uvc.c      ****         /* Clear the Video Stream Request Event */
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1263:../uvc.c      **** 
1264:../uvc.c      ****         /* Set Video Stream Abort Event */
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1266:../uvc.c      **** 	}
1267:../uvc.c      **** }
1268:../uvc.c      **** 
1269:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1270:../uvc.c      **** static void
1271:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1272:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1273:../uvc.c      ****         uint16_t             evdata  /* Event data */
1274:../uvc.c      ****         )
1275:../uvc.c      **** {
1276:../uvc.c      ****     switch (evtype)
1277:../uvc.c      ****     {
1278:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1279:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1280:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1281:../uvc.c      ****             gpif_initialized = 0;
1282:../uvc.c      ****             streamingStarted = CyFalse;
1283:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1284:../uvc.c      ****             break;
1285:../uvc.c      **** 
1286:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1287:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1288:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1289:../uvc.c      ****             gpif_initialized = 0;
1290:../uvc.c      ****             streamingStarted = CyFalse;
1291:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1292:../uvc.c      ****             break;
1293:../uvc.c      **** 
1294:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1295:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1296:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1297:../uvc.c      ****             gpif_initialized = 0;
1298:../uvc.c      ****             isUsbConnected = CyFalse;
1299:../uvc.c      ****             streamingStarted = CyFalse;
1300:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1301:../uvc.c      ****             break;
1302:../uvc.c      **** 
1303:../uvc.c      **** #ifdef BACKFLOW_DETECT
1304:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1305:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1306:../uvc.c      ****             break;
1307:../uvc.c      **** #endif
1308:../uvc.c      **** 
1309:../uvc.c      ****         default:
1310:../uvc.c      ****             break;
1311:../uvc.c      ****     }
1312:../uvc.c      **** }
1313:../uvc.c      **** 
1314:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1315:../uvc.c      **** static CyBool_t
1316:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1317:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1318:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1319:../uvc.c      ****         )
1320:../uvc.c      **** {
1321:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1322:../uvc.c      ****     uint32_t status;
1323:../uvc.c      **** 
1324:../uvc.c      ****     /* Obtain Request Type and Request */
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1330:../uvc.c      **** 
1331:../uvc.c      ****     /* Check for UVC Class Requests */
1332:../uvc.c      ****     switch (bmReqType)
1333:../uvc.c      ****     {
1334:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1335:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1336:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1337:../uvc.c      ****             switch (wIndex & 0xFF)
1338:../uvc.c      ****             {
1339:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1340:../uvc.c      ****                     {
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
1342:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1343:../uvc.c      ****                                 CYU3P_EVENT_OR);
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1345:../uvc.c      ****                         {
1346:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1347:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1348:../uvc.c      ****                         }
1349:../uvc.c      ****                     }
1350:../uvc.c      ****                     break;
1351:../uvc.c      **** 
1352:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1353:../uvc.c      ****                     {
1354:../uvc.c      ****                         uvcHandleReq = CyTrue;
1355:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1356:../uvc.c      ****                                 CYU3P_EVENT_OR);
1357:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1358:../uvc.c      ****                         {
1359:../uvc.c      ****                             /* Error handling */
1360:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1361:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1362:../uvc.c      ****                         }
1363:../uvc.c      ****                     }
1364:../uvc.c      ****                     break;
1365:../uvc.c      **** 
1366:../uvc.c      ****                 default:
1367:../uvc.c      ****                     break;
1368:../uvc.c      ****             }
1369:../uvc.c      ****             break;
1370:../uvc.c      **** 
1371:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1372:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1373:../uvc.c      ****             {
1374:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1375:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1377:../uvc.c      ****                 {
1378:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1379:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1380:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1381:../uvc.c      ****                     gpif_initialized = 0;
1382:../uvc.c      ****                     streamingStarted = CyFalse;
1383:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1385:../uvc.c      ****                     CyU3PBusyWait (100);
1386:../uvc.c      **** 
1387:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1388:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1389:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1390:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1391:../uvc.c      ****                     CyU3PBusyWait (100);
1392:../uvc.c      **** 
1393:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1394:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
1396:../uvc.c      ****                     /* Complete Control request handshake */
1397:../uvc.c      ****                     CyU3PUsbAckSetup ();
1398:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1399:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1400:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1401:../uvc.c      **** 
1402:../uvc.c      ****                 }
1403:../uvc.c      ****             }
1404:../uvc.c      ****             break;
1405:../uvc.c      **** 
1406:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1407:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1408:../uvc.c      ****             {
1409:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1410:../uvc.c      ****                 {
1411:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1412:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1413:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1414:../uvc.c      ****                 	 * has started. */
1415:../uvc.c      ****                     if (streamingStarted == CyTrue)
1416:../uvc.c      ****                     {
1417:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1418:../uvc.c      **** 
1419:../uvc.c      ****                         /* Disable the GPIF state machine. */
1420:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1421:../uvc.c      ****                         gpif_initialized = 0;
1422:../uvc.c      ****                         streamingStarted = CyFalse;
1423:../uvc.c      **** 
1424:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1426:../uvc.c      ****                         CyU3PBusyWait (100);
1427:../uvc.c      **** 
1428:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1429:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1430:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1431:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1432:../uvc.c      ****                         CyU3PBusyWait (100);
1433:../uvc.c      **** 
1434:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1435:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1436:../uvc.c      **** 
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
1438:../uvc.c      ****                         /* Complete Control request handshake */
1439:../uvc.c      ****                         CyU3PUsbAckSetup ();
1440:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1441:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1442:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1443:../uvc.c      ****                     }
1444:../uvc.c      ****                     else
1445:../uvc.c      ****                     {
1446:../uvc.c      ****                         uvcHandleReq = CyTrue;
1447:../uvc.c      ****                         CyU3PUsbAckSetup ();
1448:../uvc.c      ****                     }
1449:../uvc.c      ****                 }
1450:../uvc.c      ****             }
1451:../uvc.c      ****             break;
1452:../uvc.c      **** 
1453:../uvc.c      ****         default:
1454:../uvc.c      ****             break;
1455:../uvc.c      ****     }
1456:../uvc.c      **** 
1457:../uvc.c      ****     /* Return status of request handling to the USB driver */
1458:../uvc.c      ****     return uvcHandleReq;
1459:../uvc.c      **** }
1460:../uvc.c      **** 
1461:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1462:../uvc.c      **** 
1463:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1464:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1465:../uvc.c      ****  */
1466:../uvc.c      **** void
1467:../uvc.c      **** CyFxUvcApplnDmaCallback (
1468:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1469:../uvc.c      ****         CyU3PDmaCbType_t      type,
1470:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1471:../uvc.c      ****         )
1472:../uvc.c      **** {
1473:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1474:../uvc.c      **** #if 1
1475:../uvc.c      ****     CyU3PReturnStatus_t status;
1476:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1477:../uvc.c      ****     {
1478:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1479:../uvc.c      ****             {
1480:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1481:../uvc.c      ****                 fb++;
1482:../uvc.c      ****             }
1483:../uvc.c      ****             else
1484:../uvc.c      ****             {
1485:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1486:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1487:../uvc.c      ****                 pb++;
1488:../uvc.c      ****                 pbc = input->buffer_p.count;
1489:../uvc.c      ****                // hitFV = CyTrue;
1490:../uvc.c      ****             }
1491:../uvc.c      **** 
1492:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1493:../uvc.c      ****             prodCount++;
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1495:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1496:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1497:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1498:../uvc.c      ****             {
1499:../uvc.c      ****                 prodCount--;
1500:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1501:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1502:../uvc.c      ****             }
1503:../uvc.c      ****     }
1504:../uvc.c      **** #endif
1505:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1506:../uvc.c      ****     {
1507:../uvc.c      ****         consCount++;
1508:../uvc.c      ****         streamingStarted = CyTrue;
1509:../uvc.c      ****     }
1510:../uvc.c      **** }
1511:../uvc.c      **** 
1512:../uvc.c      **** /*
1513:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1514:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1515:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1516:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1517:../uvc.c      ****  * to commit the buffer.
1518:../uvc.c      ****  */
1519:../uvc.c      **** static uint8_t
1520:../uvc.c      **** CyFxUvcAppCommitEOF (
1521:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1522:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1523:../uvc.c      ****         )
1524:../uvc.c      **** {
1525:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1526:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1527:../uvc.c      **** 
1528:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1529:../uvc.c      **** 
1530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1531:../uvc.c      ****     {
1532:../uvc.c      ****         switch (stateId)
1533:../uvc.c      ****         {
1534:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1535:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1536:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1537:../uvc.c      ****                 break;
1538:../uvc.c      **** 
1539:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1540:../uvc.c      ****                 socket = 0;
1541:../uvc.c      ****                 break;
1542:../uvc.c      **** 
1543:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1544:../uvc.c      ****                 socket = 1;
1545:../uvc.c      ****                 break;
1546:../uvc.c      **** 
1547:../uvc.c      ****             default:
1548:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1549:../uvc.c      ****                 /* Unexpected current state. Return error. */
1550:../uvc.c      ****                 return 1;
1551:../uvc.c      ****         }
1552:../uvc.c      ****     }
1553:../uvc.c      **** 
1554:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1555:../uvc.c      ****     {
1556:../uvc.c      ****         switch (stateId)
1557:../uvc.c      ****         {
1558:../uvc.c      **** #ifndef CAM720
1559:../uvc.c      **** #ifdef GPIFIIM
1560:../uvc.c      ****             case 13:
1561:../uvc.c      ****             case 24:
1562:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1563:../uvc.c      ****                 break;
1564:../uvc.c      **** 
1565:../uvc.c      ****             case 8:
1566:../uvc.c      ****                 socket = 0;
1567:../uvc.c      ****                 break;
1568:../uvc.c      **** 
1569:../uvc.c      ****             case 20:
1570:../uvc.c      ****                 socket = 1;
1571:../uvc.c      ****                 break;
1572:../uvc.c      **** #else
1573:../uvc.c      ****             case 11:
1574:../uvc.c      ****             case 18:
1575:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1576:../uvc.c      ****                 break;
1577:../uvc.c      **** 
1578:../uvc.c      ****             case 8:
1579:../uvc.c      ****                 socket = 0;
1580:../uvc.c      ****                 break;
1581:../uvc.c      **** 
1582:../uvc.c      ****             case 15:
1583:../uvc.c      ****                 socket = 1;
1584:../uvc.c      ****                 break;
1585:../uvc.c      **** #endif
1586:../uvc.c      **** #else
1587:../uvc.c      ****             case 11:
1588:../uvc.c      ****             case 18:
1589:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1590:../uvc.c      ****                 break;
1591:../uvc.c      **** 
1592:../uvc.c      ****             case 8:
1593:../uvc.c      ****                 socket = 0;
1594:../uvc.c      ****                 break;
1595:../uvc.c      **** 
1596:../uvc.c      ****             case 15:
1597:../uvc.c      ****                 socket = 1;
1598:../uvc.c      ****                 break;
1599:../uvc.c      **** 
1600:../uvc.c      **** #endif
1601:../uvc.c      ****              default:
1602:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1603:../uvc.c      ****                 /* Unexpected current state. Return error. */
1604:../uvc.c      ****                return 1;
1605:../uvc.c      ****         }
1606:../uvc.c      ****     }
1607:../uvc.c      **** 
1608:../uvc.c      ****     if (socket != 0xFF)
1609:../uvc.c      ****     {
1610:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1611:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1612:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1613:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1614:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1615:../uvc.c      ****         {
1616:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1617:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1618:../uvc.c      ****         }
1619:../uvc.c      ****     }
1620:../uvc.c      **** 
1621:../uvc.c      ****     return 0;
1622:../uvc.c      **** }
1623:../uvc.c      **** 
1624:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1625:../uvc.c      **** void
1626:../uvc.c      **** CyFxGpifCB (
1627:../uvc.c      ****         CyU3PGpifEventType event,
1628:../uvc.c      ****         uint8_t currentState
1629:../uvc.c      ****         )
1630:../uvc.c      **** {
1631:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1632:../uvc.c      ****     {
1633:../uvc.c      ****         hitFV = CyTrue;
1634:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1635:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1636:../uvc.c      ****     }
1637:../uvc.c      **** }
1638:../uvc.c      **** 
1639:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1640:../uvc.c      **** static void
1641:../uvc.c      **** CyFxUVCApplnDebugInit (
1642:../uvc.c      ****         void)
1643:../uvc.c      **** {
1644:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1645:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1646:../uvc.c      **** 
1647:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1648:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1649:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1650:../uvc.c      ****     {
1651:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1652:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1653:../uvc.c      ****     }
1654:../uvc.c      **** 
1655:../uvc.c      ****     /* Set UART Configuration */
1656:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1657:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1658:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1659:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1660:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1661:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1662:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1663:../uvc.c      **** 
1664:../uvc.c      ****     /* Set the UART configuration */
1665:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1667:../uvc.c      ****     {
1668:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1669:../uvc.c      ****     }
1670:../uvc.c      **** 
1671:../uvc.c      ****     /* Set the UART transfer */
1672:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1673:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1674:../uvc.c      ****     {
1675:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1676:../uvc.c      ****     }
1677:../uvc.c      **** 
1678:../uvc.c      ****     /* Initialize the Debug logger module. */
1679:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1680:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1681:../uvc.c      ****     {
1682:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1683:../uvc.c      ****     }
1684:../uvc.c      **** 
1685:../uvc.c      ****     /* Disable log message headers. */
1686:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1687:../uvc.c      **** }
1688:../uvc.c      **** 
1689:../uvc.c      **** /* I2C initialization. */
1690:../uvc.c      **** //static void
1691:../uvc.c      **** void
1692:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1693:../uvc.c      **** {
1694:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1695:../uvc.c      ****     CyU3PReturnStatus_t status;
1696:../uvc.c      **** 
1697:../uvc.c      ****     status = CyU3PI2cInit ();
1698:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1699:../uvc.c      ****     {
1700:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1701:../uvc.c      ****         CyFxAppErrorHandler (status);
1702:../uvc.c      ****     }
1703:../uvc.c      **** 
1704:../uvc.c      ****     /*  Set I2C Configuration */
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1706:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1708:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1709:../uvc.c      **** 
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1711:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1712:../uvc.c      ****     {
1713:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1714:../uvc.c      ****         CyFxAppErrorHandler (status);
1715:../uvc.c      ****     }
1716:../uvc.c      **** }
1717:../uvc.c      **** 
1718:../uvc.c      **** #ifdef BACKFLOW_DETECT
1719:../uvc.c      **** static void CyFxUvcAppPibCallback (
1720:../uvc.c      ****         CyU3PPibIntrType cbType,
1721:../uvc.c      ****         uint16_t cbArg)
1722:../uvc.c      **** {
1723:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1724:../uvc.c      ****     {
1725:../uvc.c      ****         if (!back_flow_detected)
1726:../uvc.c      ****         {
1727:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1728:../uvc.c      ****             back_flow_detected = 1;
1729:../uvc.c      ****         }
1730:../uvc.c      ****     }
1731:../uvc.c      **** }
1732:../uvc.c      **** #endif
1733:../uvc.c      **** 
1734:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1735:../uvc.c      **** static void
1736:../uvc.c      **** CyFxUvcAppDebugCallback (
1737:../uvc.c      ****         CyU3PDmaChannel   *handle,
1738:../uvc.c      ****         CyU3PDmaCbType_t   type,
1739:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1740:../uvc.c      **** {
1741:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1742:../uvc.c      ****     {
1743:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1744:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1745:../uvc.c      ****     }
1746:../uvc.c      **** }
1747:../uvc.c      **** #endif
1748:../uvc.c      **** 
1749:../uvc.c      **** #if 0
1750:../uvc.c      **** static void CyFxAppIntEpCb(
1751:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1752:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1753:../uvc.c      **** 		uint8_t  ebNum)
1754:../uvc.c      **** 		{
1755:../uvc.c      **** 			//CyBool_t value;
1756:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1757:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1758:../uvc.c      **** 
1759:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1760:../uvc.c      **** 		}
1761:../uvc.c      **** #endif
1762:../uvc.c      **** 
1763:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1764:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1765:../uvc.c      ****    configures the DMA module for the UVC Application */
1766:../uvc.c      **** static void
1767:../uvc.c      **** CyFxUVCApplnInit (void)
1768:../uvc.c      **** {
1769:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1770:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1771:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1772:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1773:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1774:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1775:../uvc.c      **** 
1776:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1777:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1778:../uvc.c      **** 
1779:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1780:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1781:../uvc.c      **** #endif
1782:../uvc.c      **** 
1783:../uvc.c      ****     /* Create UVC event group */
1784:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1785:../uvc.c      ****     if (apiRetStatus != 0)
1786:../uvc.c      ****     {
1787:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1788:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1789:../uvc.c      ****     }
1790:../uvc.c      **** 
1791:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1792:../uvc.c      ****     CyFxUvcAppPTZInit ();
1793:../uvc.c      **** #endif
1794:../uvc.c      **** 
1795:../uvc.c      ****     isUsbConnected = CyFalse;
1796:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1797:../uvc.c      **** 
1798:../uvc.c      ****     /* Init the GPIO module */
1799:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1800:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1801:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1802:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1803:../uvc.c      ****     gpioClock.halfDiv    = 0;
1804:../uvc.c      **** 
1805:../uvc.c      ****     /* Initialize Gpio interface */
1806:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1807:../uvc.c      ****     if (apiRetStatus != 0)
1808:../uvc.c      ****     {
1809:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1810:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1811:../uvc.c      ****     }
1812:../uvc.c      **** 
1813:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1814:../uvc.c      ****      * must use GpioOverride to configure it */
1815:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1816:../uvc.c      ****     if (apiRetStatus != 0)
1817:../uvc.c      ****     {
1818:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1819:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1820:../uvc.c      ****     }
1821:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1822:../uvc.c      ****     if (apiRetStatus != 0)
1823:../uvc.c      ****     {
1824:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1825:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1826:../uvc.c      ****     }
1827:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1828:../uvc.c      ****     if (apiRetStatus != 0)
1829:../uvc.c      ****     {
1830:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1831:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1832:../uvc.c      ****     }
1833:../uvc.c      **** 
1834:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1836:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1837:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1838:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1839:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1841:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1842:../uvc.c      ****     {
1843:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1844:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1845:../uvc.c      ****     }
1846:../uvc.c      **** 
1847:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1848:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1849:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1852:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1856:../uvc.c      ****     {
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1858:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1859:../uvc.c      ****     }
1860:../uvc.c      **** 
1861:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1862:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1863:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1864:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1865:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1866:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1867:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1870:../uvc.c      ****     {
1871:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1872:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1873:../uvc.c      ****     }
1874:../uvc.c      **** 
1875:../uvc.c      ****     /* Initialize the P-port. */
1876:../uvc.c      ****     pibclock.clkDiv      = 2;
1877:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1878:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1879:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1880:../uvc.c      **** 
1881:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1882:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1883:../uvc.c      ****     {
1884:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1885:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1886:../uvc.c      ****     }
1887:../uvc.c      **** 
1888:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1889:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1890:../uvc.c      **** 
1891:../uvc.c      **** #ifdef BACKFLOW_DETECT
1892:../uvc.c      ****     back_flow_detected = 0;
1893:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1894:../uvc.c      **** #endif
1895:../uvc.c      **** 
1896:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1897:../uvc.c      ****     SensorReset ();
1898:../uvc.c      ****     SensorInit ();
1899:../uvc.c      **** 
1900:../uvc.c      ****     /* USB initialization. */
1901:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1902:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1903:../uvc.c      ****     {
1904:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1905:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1906:../uvc.c      ****     }
1907:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1908:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1909:../uvc.c      **** 
1910:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1911:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1912:../uvc.c      **** 
1913:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1914:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1915:../uvc.c      **** 
1916:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1917:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1918:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1919:../uvc.c      **** 
1920:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1921:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1922:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1923:../uvc.c      **** 
1924:../uvc.c      ****     /* Configuration descriptors. */
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1926:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1927:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1928:../uvc.c      **** 
1929:../uvc.c      ****     /* String Descriptors */
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1931:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1933:../uvc.c      **** 
1934:../uvc.c      ****     /* Configure the status interrupt endpoint.
1935:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1936:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1937:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1938:../uvc.c      ****      */
1939:../uvc.c      ****     endPointConfig.enable   = 1;
1940:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1941:../uvc.c      ****     endPointConfig.pcktSize = 64;
1942:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1943:../uvc.c      ****     endPointConfig.streams  = 0;
1944:../uvc.c      ****     endPointConfig.burstLen = 1;
1945:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1947:../uvc.c      ****     {
1948:../uvc.c      ****         /* Error Handling */
1949:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1950:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1951:../uvc.c      ****     }
1952:../uvc.c      **** 
1953:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1954:../uvc.c      ****     dmaInterConfig.size           = 1024;
1955:../uvc.c      ****     dmaInterConfig.count          = 1;
1956:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1957:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1958:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1959:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1960:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1961:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1962:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1963:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1964:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1965:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1966:../uvc.c      ****             &dmaInterConfig);
1967:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1968:../uvc.c      ****     {
1969:../uvc.c      ****         /* Error handling */
1970:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1971:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1972:../uvc.c      ****     }
1973:../uvc.c      **** 
1974:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1975:../uvc.c      ****     if (glInterStaBuffer == 0)
1976:../uvc.c      ****     {
1977:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1978:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1979:../uvc.c      ****     }
1980:../uvc.c      **** 
1981:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1982:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1983:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1984:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1985:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1986:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1987:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1988:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1989:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1990:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
1991:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1992:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1993:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1994:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
1996:../uvc.c      ****             &dmaMultiConfig);
1997:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1998:../uvc.c      ****     {
1999:../uvc.c      ****         /* Error handling */
2000:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2001:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2002:../uvc.c      ****     }
2003:../uvc.c      **** 
2004:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2005:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2006:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2007:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2008:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2009:../uvc.c      ****      */
2010:../uvc.c      **** 
2011:../uvc.c      ****     endPointConfig.enable   = 1;
2012:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2013:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2014:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2015:../uvc.c      ****     endPointConfig.streams  = 0;
2016:../uvc.c      ****     endPointConfig.burstLen = 1;
2017:../uvc.c      **** 
2018:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2019:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2020:../uvc.c      ****     {
2021:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2022:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2023:../uvc.c      ****     }
2024:../uvc.c      **** 
2025:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2026:../uvc.c      **** 
2027:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2029:../uvc.c      ****     {
2030:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2031:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2032:../uvc.c      ****     }
2033:../uvc.c      **** 
2034:../uvc.c      ****     channelConfig.size           = 1024;
2035:../uvc.c      ****     channelConfig.count          = 1;
2036:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2037:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2038:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2039:../uvc.c      ****     channelConfig.prodHeader     = 0;
2040:../uvc.c      ****     channelConfig.prodFooter     = 0;
2041:../uvc.c      ****     channelConfig.consHeader     = 0;
2042:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2043:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2044:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2045:../uvc.c      **** 
2046:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2047:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2048:../uvc.c      ****     {
2049:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2050:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2051:../uvc.c      ****     }
2052:../uvc.c      **** 
2053:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2054:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2055:../uvc.c      ****     {
2056:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2057:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2058:../uvc.c      ****     }
2059:../uvc.c      **** 
2060:../uvc.c      ****     channelConfig.size           = 1024;
2061:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2062:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2063:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2064:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2065:../uvc.c      ****     channelConfig.prodHeader     = 0;
2066:../uvc.c      ****     channelConfig.prodFooter     = 0;
2067:../uvc.c      ****     channelConfig.consHeader     = 0;
2068:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2069:../uvc.c      ****     channelConfig.notification   = 0;
2070:../uvc.c      ****     channelConfig.cb             = 0;
2071:../uvc.c      **** 
2072:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2073:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2074:../uvc.c      ****     {
2075:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2076:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2077:../uvc.c      ****     }
2078:../uvc.c      **** 
2079:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2080:../uvc.c      ****     if (glDebugRspBuffer == 0)
2081:../uvc.c      ****     {
2082:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2083:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2084:../uvc.c      ****     }
2085:../uvc.c      **** #endif
2086:../uvc.c      **** 
2087:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2088:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2089:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2090:../uvc.c      ****     {
2091:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2092:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2093:../uvc.c      ****     }
2094:../uvc.c      **** 
2095:../uvc.c      ****     CyU3PBusyWait(100);
2096:../uvc.c      **** 
2097:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2098:../uvc.c      **** 
2099:../uvc.c      ****     endPointConfig.enable   = 1;
2100:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2101:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2102:../uvc.c      ****     {
2103:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2104:../uvc.c      ****     	endPointConfig.burstLen = 16;
2105:../uvc.c      ****     }
2106:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2107:../uvc.c      ****     {
2108:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2109:../uvc.c      ****     	endPointConfig.burstLen = 1;
2110:../uvc.c      ****     }
2111:../uvc.c      ****     endPointConfig.streams  = 0;
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2113:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2114:../uvc.c      ****     {
2115:../uvc.c      ****         /* Error Handling */
2116:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2117:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2118:../uvc.c      ****     }
2119:../uvc.c      **** #if 0    //for still image method 3 using
2120:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2121:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2122:../uvc.c      ****     {
2123:../uvc.c      ****         /* Error Handling */
2124:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2125:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2126:../uvc.c      ****     }
2127:../uvc.c      **** #endif
2128:../uvc.c      **** 
2129:../uvc.c      **** }
2130:../uvc.c      **** 
2131:../uvc.c      **** /*
2132:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2133:../uvc.c      ****  * streaming session is started.
2134:../uvc.c      ****  */
2135:../uvc.c      **** static void
2136:../uvc.c      **** CyFxUvcAppGpifInit (
2137:../uvc.c      ****         void)
2138:../uvc.c      **** {
2139:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2140:../uvc.c      **** 
2141:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2142:../uvc.c      ****     {
2143:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2144:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2145:../uvc.c      ****     }
2146:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2147:../uvc.c      ****     {
2148:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2149:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2150:../uvc.c      ****     }
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2152:../uvc.c      ****     {
2153:../uvc.c      ****         /* Error Handling */
2154:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2155:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2156:../uvc.c      ****     }
2157:../uvc.c      **** 
2158:../uvc.c      ****     /* Start the state machine from the designated start state. */
2159:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2160:../uvc.c      ****     {
2161:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2162:../uvc.c      ****     }
2163:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2164:../uvc.c      ****     {
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2166:../uvc.c      ****     }
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2168:../uvc.c      ****     {
2169:../uvc.c      ****         /* Error Handling */
2170:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2171:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2172:../uvc.c      ****     }
2173:../uvc.c      **** }
2174:../uvc.c      **** 
2175:../uvc.c      **** /*
2176:../uvc.c      ****  * Entry function for the UVC Application Thread
2177:../uvc.c      ****  */
2178:../uvc.c      **** 
2179:../uvc.c      **** uint32_t posTick;
2180:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2181:../uvc.c      **** 
2182:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2183:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2184:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2185:../uvc.c      **** }
2186:../uvc.c      **** 
2187:../uvc.c      **** 
2188:../uvc.c      **** void
2189:../uvc.c      **** UVCAppThread_Entry (
2190:../uvc.c      ****         uint32_t input)
2191:../uvc.c      **** {
2192:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2193:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2194:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2195:../uvc.c      ****     uint8_t i = 0;
2196:../uvc.c      ****     uint32_t flag;
2197:../uvc.c      ****     uint32_t prinflag = 0;
2198:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2199:../uvc.c      ****     uint32_t frameCnt = 0;
2200:../uvc.c      **** #endif
2201:../uvc.c      ****     /* Initialize the Uart Debug Module */
2202:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2203:../uvc.c      **** 
2204:../uvc.c      ****     /* Initialize the I2C interface */
2205:../uvc.c      **** 	while (i++ < 6){
2206:../uvc.c      **** 		CyU3PThreadSleep(500);
2207:../uvc.c      **** 	}
2208:../uvc.c      **** 
2209:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2210:../uvc.c      **** 
2211:../uvc.c      ****     /* Initialize the UVC Application */
2212:../uvc.c      ****     CyFxUVCApplnInit ();
2213:../uvc.c      **** 
2214:../uvc.c      ****     /*
2215:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2216:../uvc.c      **** 
2217:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2218:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2219:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2220:../uvc.c      **** 
2221:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2222:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2223:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2224:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2225:../uvc.c      **** 
2226:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2227:../uvc.c      ****        of handling the abort request.
2228:../uvc.c      ****      */
2229:../uvc.c      **** 
2230:../uvc.c      ****     for (;;)
2231:../uvc.c      ****     {
2232:../uvc.c      ****         /* Waiting for the Video Stream Event */
2233:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2234:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2235:../uvc.c      ****         {
2236:../uvc.c      **** #if 0 //test for new firmware no video bring up
2237:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2238:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2239:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2240:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2241:../uvc.c      ****             {
2242:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2243:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2244:../uvc.c      ****                 {
2245:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2246:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2247:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2248:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2249:../uvc.c      **** #endif
2250:../uvc.c      **** #endif
2251:../uvc.c      ****                     }
2252:../uvc.c      ****                 else
2253:../uvc.c      ****                 {
2254:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2255:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2256:../uvc.c      **** #ifdef USB_LOWRES_IMG
2257:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2258:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2259:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2260:../uvc.c      **** #endif
2261:../uvc.c      **** #endif
2262:../uvc.c      ****                 }
2263:../uvc.c      **** 
2264:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2265:../uvc.c      ****                 prodCount++;
2266:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2267:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2268:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2269:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2270:../uvc.c      ****                 {
2271:../uvc.c      ****                     prodCount--;
2272:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2273:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2274:../uvc.c      ****                 }
2275:../uvc.c      ****             }
2276:../uvc.c      **** #endif
2277:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2278:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2279:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2280:../uvc.c      ****             {
2281:../uvc.c      ****             	if(0&&(prinflag == 0)){
2282:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2283:../uvc.c      ****             		prinflag = 1;
2284:../uvc.c      ****             	}
2285:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2286:../uvc.c      ****             	fb=0;
2287:../uvc.c      ****             	pb=0;
2288:../uvc.c      ****             	pbc=0;
2289:../uvc.c      ****                 prodCount = 0;
2290:../uvc.c      ****                 consCount = 0;
2291:../uvc.c      ****                 hitFV     = CyFalse;
2292:../uvc.c      **** 
2293:../uvc.c      **** #ifdef BACKFLOW_DETECT
2294:../uvc.c      ****                 back_flow_detected = 0;
2295:../uvc.c      **** #endif
2296:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2297:../uvc.c      ****                 frameCnt++;
2298:../uvc.c      **** #endif
2299:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2300:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2301:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2302:../uvc.c      ****                 //}
2303:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2305:../uvc.c      ****                 if(stiflag){
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
2307:../uvc.c      ****                 	stiflag = CyFalse;
2308:../uvc.c      ****                 }else{
2309:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2310:../uvc.c      ****                 }
2311:../uvc.c      ****                 /* Reset the DMA channel. */
2312:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2313:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2314:../uvc.c      ****                 {
2315:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2316:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2317:../uvc.c      ****                 }
2318:../uvc.c      **** 
2319:../uvc.c      ****                 /* Start Channel Immediately */
2320:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2321:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2322:../uvc.c      ****                 {
2323:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2324:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2325:../uvc.c      ****                 }
2326:../uvc.c      **** 
2327:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2328:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2329:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2330:../uvc.c      ****                 }
2331:../uvc.c      ****         }
2332:../uvc.c      ****         else
2333:../uvc.c      ****         {
2334:../uvc.c      ****             /* If we have a stream abort request pending. */
2335:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2336:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2337:../uvc.c      ****             {
2338:../uvc.c      ****                 hitFV     = CyFalse;
2339:../uvc.c      ****                 prodCount = 0;
2340:../uvc.c      ****                 consCount = 0;
2341:../uvc.c      ****                 if(0&&(prinflag == 0)){
2342:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2343:../uvc.c      ****                 	prinflag = 1;
2344:../uvc.c      ****                 }
2345:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2346:../uvc.c      ****                 fb=0;
2347:../uvc.c      ****                 pb=0;
2348:../uvc.c      ****                 pbc=0;
2349:../uvc.c      **** 
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2351:../uvc.c      ****                 {
2352:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2353:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2354:../uvc.c      ****                     {
2355:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2356:../uvc.c      ****                     }
2357:../uvc.c      **** 
2358:../uvc.c      ****                     /* Flush the Endpoint memory */
2359:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2360:../uvc.c      ****                 }
2361:../uvc.c      **** 
2362:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2363:../uvc.c      ****             }
2364:../uvc.c      ****             else
2365:../uvc.c      ****             {
2366:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2367:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2368:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2369:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2370:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2371:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2372:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2373:../uvc.c      ****                 {
2374:../uvc.c      ****                     /* Error handling */
2375:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2376:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2377:../uvc.c      ****                 }
2378:../uvc.c      **** 
2379:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2380:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2381:../uvc.c      ****                 {
2382:../uvc.c      ****                     //for start up of the AF Lens
2383:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
2385:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2386:../uvc.c      ****                     CyU3PThreadSleep(500);
2387:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2388:../uvc.c      ****                    	CyU3PThreadSleep(300);
2389:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
2391:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2392:../uvc.c      ****                     CyU3PThreadSleep(500);
2393:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2394:../uvc.c      ****                     gpif_initialized = CyTrue;
2395:../uvc.c      ****                     CyU3PThreadSleep(200);
2396:../uvc.c      ****                     
2397:../uvc.c      ****                 }
2398:../uvc.c      ****                 else
2399:../uvc.c      ****                 {
2400:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2401:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2402:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2403:../uvc.c      ****                 }
2404:../uvc.c      ****             }
2405:../uvc.c      ****         }
2406:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2407:../uvc.c      **** 
2408:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2409:../uvc.c      ****         CyU3PThreadRelinquish ();
2410:../uvc.c      ****     }
2411:../uvc.c      **** }
2412:../uvc.c      **** 
2413:../uvc.c      **** /*
2414:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2415:../uvc.c      ****  */
2416:../uvc.c      **** 
2417:../uvc.c      **** static void
2418:../uvc.c      **** UVCHandleProcessingUnitRqts (
2419:../uvc.c      ****         void)
2420:../uvc.c      **** {
2421:../uvc.c      ****     uint8_t CtrlAdd;
2422:../uvc.c      **** #ifdef DbgInfo
2423:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2424:../uvc.c      **** #endif
2425:../uvc.c      ****     switch (wValue)
2426:../uvc.c      ****     {
2427:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2428:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2429:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2430:../uvc.c      ****     		break;
2431:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2432:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2433:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2434:../uvc.c      ****     		break;
2435:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2436:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2437:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2438:../uvc.c      **** 			break;
2439:../uvc.c      **** 
2440:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2441:../uvc.c      **** 
2442:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2443:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2444:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2445:../uvc.c      ****       		break;
2446:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2447:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2448:../uvc.c      ****      		ControlHandle(HueCtlID5);
2449:../uvc.c      ****      		break;
2450:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2451:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2452:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2453:../uvc.c      ****           		break;
2454:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2455:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2456:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2457:../uvc.c      ****           		break;
2458:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2459:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2460:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2461:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2462:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2463:../uvc.c      ****     		break;
2464:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2465:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2466:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2467:../uvc.c      ****     		break;
2468:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2469:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2470:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2471:../uvc.c      ****     		break;
2472:../uvc.c      **** 
2473:../uvc.c      ****         default:
2474:../uvc.c      ****             /*
2475:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2476:../uvc.c      ****              * other controls.
2477:../uvc.c      ****              */
2478:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2479:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2480:../uvc.c      ****             break;
2481:../uvc.c      ****     }
2482:../uvc.c      **** }
2483:../uvc.c      **** 
2484:../uvc.c      **** /*
2485:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2486:../uvc.c      ****  */
2487:../uvc.c      **** static void
2488:../uvc.c      **** UVCHandleCameraTerminalRqts (
2489:../uvc.c      ****         void)
2490:../uvc.c      **** {
2491:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2492:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2493:../uvc.c      ****     uint16_t readCount;
2494:../uvc.c      ****     uint16_t zoomVal;
2495:../uvc.c      ****     int32_t  panVal, tiltVal;
2496:../uvc.c      ****     CyBool_t sendData = CyFalse;
2497:../uvc.c      **** #endif
2498:../uvc.c      ****     uint8_t CtrlAdd;
2499:../uvc.c      **** 
2500:../uvc.c      ****     switch (wValue)
2501:../uvc.c      ****     {
2502:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2503:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2504:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2505:../uvc.c      ****     		break;
2506:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2507:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2508:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2509:../uvc.c      ****     		break;
2510:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2511:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2512:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2513:../uvc.c      **** 			break;
2514:../uvc.c      **** 
2515:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2516:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2517:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2518:../uvc.c      **** 			break;
2519:../uvc.c      **** 
2520:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2521:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2522:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2523:../uvc.c      ****       		break;
2524:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2525:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2526:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2527:../uvc.c      ****      		break;
2528:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2529:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2530:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2531:../uvc.c      ****           		break;
2532:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2533:../uvc.c      ****           		break;
2534:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2535:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2536:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2537:../uvc.c      ****      		break;
2538:../uvc.c      **** 
2539:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2540:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2541:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2542:../uvc.c      ****     		break;
2543:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2544:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2545:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2546:../uvc.c      ****     		break;
2547:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2548:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2549:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2550:../uvc.c      ****     		break;
2551:../uvc.c      **** 
2552:../uvc.c      ****         default:
2553:../uvc.c      ****             /*
2554:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2555:../uvc.c      ****              * other controls.
2556:../uvc.c      ****              */
2557:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2558:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2559:../uvc.c      ****             break;
2560:../uvc.c      ****     }
2561:../uvc.c      **** 
2562:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2563:../uvc.c      ****     switch (wValue)
2564:../uvc.c      ****     {
2565:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2566:../uvc.c      ****             switch (bRequest)
2567:../uvc.c      ****             {
2568:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2569:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2570:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2571:../uvc.c      ****                     break;
2572:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2573:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2574:../uvc.c      ****                     sendData = CyTrue;
2575:../uvc.c      ****                     break;
2576:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2577:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2578:../uvc.c      ****                     sendData = CyTrue;
2579:../uvc.c      ****                     break;
2580:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2581:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2582:../uvc.c      ****                     sendData = CyTrue;
2583:../uvc.c      ****                     break;
2584:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2585:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2586:../uvc.c      ****                     sendData = CyTrue;
2587:../uvc.c      ****                     break;
2588:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2589:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2590:../uvc.c      ****                     sendData = CyTrue;
2591:../uvc.c      ****                     break;
2592:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2593:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2594:../uvc.c      ****                             glEp0Buffer, &readCount);
2595:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2596:../uvc.c      ****                     {
2597:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2598:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2599:../uvc.c      ****                     }
2600:../uvc.c      ****                     break;
2601:../uvc.c      ****                 default:
2602:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2603:../uvc.c      ****                     break;
2604:../uvc.c      ****             }
2605:../uvc.c      **** 
2606:../uvc.c      ****             if (sendData)
2607:../uvc.c      ****             {
2608:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2609:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2610:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2611:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2612:../uvc.c      ****             }
2613:../uvc.c      ****             break;
2614:../uvc.c      **** 
2615:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2616:../uvc.c      ****             switch (bRequest)
2617:../uvc.c      ****             {
2618:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2619:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2620:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2621:../uvc.c      ****                     break;
2622:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2623:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2624:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2625:../uvc.c      ****                     sendData = CyTrue;
2626:../uvc.c      ****                     break;
2627:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2628:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2629:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2630:../uvc.c      ****                     sendData = CyTrue;
2631:../uvc.c      ****                     break;
2632:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2633:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2634:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2635:../uvc.c      ****                     sendData = CyTrue;
2636:../uvc.c      ****                     break;
2637:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2638:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2639:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2640:../uvc.c      ****                     sendData = CyTrue;
2641:../uvc.c      ****                     break;
2642:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2643:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2644:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2645:../uvc.c      ****                     sendData = CyTrue;
2646:../uvc.c      ****                     break;
2647:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2648:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2649:../uvc.c      ****                             glEp0Buffer, &readCount);
2650:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2651:../uvc.c      ****                     {
2652:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2653:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2654:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2655:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2656:../uvc.c      **** 
2657:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2658:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2659:../uvc.c      ****                     }
2660:../uvc.c      ****                     break;
2661:../uvc.c      ****                 default:
2662:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2663:../uvc.c      ****                     break;
2664:../uvc.c      ****             }
2665:../uvc.c      **** 
2666:../uvc.c      ****             if (sendData)
2667:../uvc.c      ****             {
2668:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2669:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2670:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2671:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2672:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2673:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2674:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2675:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2676:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2677:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2678:../uvc.c      ****             }
2679:../uvc.c      ****             break;
2680:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2681:../uvc.c      ****         default:
2682:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2683:../uvc.c      ****             break;
2684:../uvc.c      ****     }
2685:../uvc.c      **** #endif
2686:../uvc.c      **** }
2687:../uvc.c      **** 
2688:../uvc.c      **** /*
2689:../uvc.c      ****  * Handler for UVC Interface control requests.
2690:../uvc.c      ****  */
2691:../uvc.c      **** static void
2692:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2693:../uvc.c      ****         void)
2694:../uvc.c      **** {
2695:../uvc.c      **** 
2696:../uvc.c      ****     switch (wValue)
2697:../uvc.c      ****     {
2698:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2699:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2700:../uvc.c      ****     		break;
2701:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2702:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2703:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2704:../uvc.c      ****     		break;
2705:../uvc.c      ****     	default:
2706:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2707:../uvc.c      ****      		break;
2708:../uvc.c      ****     }
2709:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2710:../uvc.c      **** 
2711:../uvc.c      **** }
2712:../uvc.c      **** 
2713:../uvc.c      **** /*
2714:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2715:../uvc.c      ****  */
2716:../uvc.c      **** static void
2717:../uvc.c      **** UVCHandleExtensionUnitRqts (
2718:../uvc.c      ****         void)
2719:../uvc.c      **** {
2720:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2721:../uvc.c      **** 
2722:../uvc.c      **** #ifdef DbgInfo
2723:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2724:../uvc.c      **** #endif
2725:../uvc.c      ****     switch (wValue)
2726:../uvc.c      ****     {
2727:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2728:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2729:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2730:../uvc.c      ****     		break;
2731:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2732:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2733:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2734:../uvc.c      ****     		break;
2735:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2736:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2737:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2738:../uvc.c      ****      		break;
2739:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2740:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2741:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2742:../uvc.c      ****     		break;
2743:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2744:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2745:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2746:../uvc.c      ****     		break;
2747:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2748:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2749:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2750:../uvc.c      ****      		break;
2751:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2752:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2753:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2754:../uvc.c      ****     		break;
2755:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2756:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2757:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2758:../uvc.c      ****     		break;
2759:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2760:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2761:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2762:../uvc.c      ****      		break;
2763:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2764:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
2765:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2766:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2767:../uvc.c      ****     		}else/* no support for 1080p camera */
2768:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x %d\r\n", wVa
2769:../uvc.c      ****     		break;
2770:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2771:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2772:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2773:../uvc.c      ****     		break;
2774:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2775:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2776:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2777:../uvc.c      ****     		break;
2778:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2779:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2780:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2781:../uvc.c      ****     		//break;
2782:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2783:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2784:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2785:../uvc.c      ****     		break;
2786:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2787:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2788:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2789:../uvc.c      ****     		break;
2790:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2791:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET+4][0];
2792:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
2793:../uvc.c      ****     		break;
2794:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2795:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET+4][0];
2796:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
2797:../uvc.c      ****     		break;
2798:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2799:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET+4][0];
2800:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
2801:../uvc.c      ****     		break;
2802:../uvc.c      ****    	default:
2803:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2804:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2805:../uvc.c      ****     		break;
2806:../uvc.c      ****     }
2807:../uvc.c      **** 
2808:../uvc.c      **** }
2809:../uvc.c      **** 
2810:../uvc.c      **** /*
2811:../uvc.c      ****  * Handler for the video streaming control requests.
2812:../uvc.c      ****  */
2813:../uvc.c      **** static void
2814:../uvc.c      **** UVCHandleVideoStreamingRqts (
2815:../uvc.c      ****         void)
2816:../uvc.c      **** {
2817:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2818:../uvc.c      ****     uint16_t readCount;
2819:../uvc.c      **** 
2820:../uvc.c      ****     switch (wValue)
2821:../uvc.c      ****     {
2822:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2823:../uvc.c      ****             switch (bRequest)
2824:../uvc.c      ****             {
2825:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2826:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2827:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2828:../uvc.c      ****                     break;
2829:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2830:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2831:../uvc.c      ****                     glEp0Buffer[1] = 0;
2832:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2833:../uvc.c      ****                     break;
2834:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2835:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2836:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2837:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2838:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2839:../uvc.c      ****                     {
2840:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2841:../uvc.c      ****                     }
2842:../uvc.c      ****                     else
2843:../uvc.c      ****                     {
2844:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2845:../uvc.c      ****                     }
2846:../uvc.c      ****                     break;
2847:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2848:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2849:../uvc.c      ****                             glCommitCtrl, &readCount);
2850:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2851:../uvc.c      ****                     {
2852:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2853:../uvc.c      ****                         {
2854:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2855:../uvc.c      ****                                active data structure. */
2856:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2857:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2858:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2859:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2860:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2861:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2862:../uvc.c      ****                         }
2863:../uvc.c      ****                     }
2864:../uvc.c      ****                     break;
2865:../uvc.c      ****                 default:
2866:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2867:../uvc.c      ****                     break;
2868:../uvc.c      ****             }
2869:../uvc.c      ****             break;
2870:../uvc.c      **** 
2871:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2872:../uvc.c      ****             switch (bRequest)
2873:../uvc.c      ****             {
2874:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2875:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2877:../uvc.c      ****                     break;
2878:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2879:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2880:../uvc.c      ****                     glEp0Buffer[1] = 0;
2881:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2882:../uvc.c      ****                     break;
2883:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2884:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2885:../uvc.c      ****                     {
2886:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2887:../uvc.c      ****                     }
2888:../uvc.c      ****                     else
2889:../uvc.c      ****                     {
2890:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2891:../uvc.c      ****                     }
2892:../uvc.c      ****                     break;
2893:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2894:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2895:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2896:../uvc.c      ****                        */
2897:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2898:../uvc.c      ****                             glCommitCtrl, &readCount);
2899:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2900:../uvc.c      ****                     {
2901:../uvc.c      **** #if 0
2902:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2903:../uvc.c      ****                         {
2904:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2905:../uvc.c      ****                         }
2906:../uvc.c      ****                         else
2907:../uvc.c      ****                         {
2908:../uvc.c      ****                             SensorScaling_VGA ();
2909:../uvc.c      ****                         }
2910:../uvc.c      **** #endif
2911:../uvc.c      ****                         /* We can start streaming video now. */
2912:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2913:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2914:../uvc.c      ****                         {
2915:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2916:../uvc.c      ****                         }
2917:../uvc.c      ****                     }
2918:../uvc.c      ****                     break;
2919:../uvc.c      **** 
2920:../uvc.c      ****                 default:
2921:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2922:../uvc.c      ****                     break;
2923:../uvc.c      ****             }
2924:../uvc.c      ****             break;
2925:../uvc.c      **** 
2926:../uvc.c      **** /* still image streaming handler */
2927:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2928:../uvc.c      ****                 switch (bRequest)
2929:../uvc.c      ****                 {
2930:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2931:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2932:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2933:../uvc.c      ****                         break;
2934:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2935:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2936:../uvc.c      ****                         glEp0Buffer[1] = 0;
2937:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2938:../uvc.c      ****                         break;
2939:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2940:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2941:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2942:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2943:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2944:../uvc.c      ****                         {
2945:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2946:../uvc.c      ****                         }
2947:../uvc.c      ****                         else
2948:../uvc.c      ****                         {
2949:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2950:../uvc.c      ****                         }
2951:../uvc.c      ****                         break;
2952:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2953:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2954:../uvc.c      ****                                 glCommitCtrl, &readCount);
2955:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2956:../uvc.c      ****                         {
2957:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
2958:../uvc.c      ****                             {
2959:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2960:../uvc.c      ****                                    active data structure. */
2961:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
2962:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
2963:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
2964:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
2965:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
2967:../uvc.c      ****                             }
2968:../uvc.c      ****                         }
2969:../uvc.c      ****                         break;
2970:../uvc.c      ****                     default:
2971:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2972:../uvc.c      ****                         break;
2973:../uvc.c      ****                 }
2974:../uvc.c      ****                 break;
2975:../uvc.c      **** 
2976:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
2977:../uvc.c      ****                 switch (bRequest)
2978:../uvc.c      ****                 {
2979:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2980:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2981:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2982:../uvc.c      ****                         break;
2983:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2984:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2985:../uvc.c      ****                         glEp0Buffer[1] = 0;
2986:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2987:../uvc.c      ****                         break;
2988:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2989:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2990:../uvc.c      ****                         {
2991:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2992:../uvc.c      ****                         }
2993:../uvc.c      ****                         else
2994:../uvc.c      ****                         {
2995:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2996:../uvc.c      ****                         }
2997:../uvc.c      ****                         break;
2998:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2999:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3000:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3001:../uvc.c      ****                            */
3002:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3003:../uvc.c      ****                                 glCommitCtrl, &readCount);
3004:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3005:../uvc.c      ****                         {
3006:../uvc.c      ****     #if 0
3007:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3008:../uvc.c      ****                             {
3009:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3010:../uvc.c      ****                             }
3011:../uvc.c      ****                             else
3012:../uvc.c      ****                             {
3013:../uvc.c      ****                                 SensorScaling_VGA ();
3014:../uvc.c      ****                             }
3015:../uvc.c      ****     #endif
3016:../uvc.c      ****                             /* We can start streaming video now. */
3017:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3018:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3019:../uvc.c      ****                             {
3020:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3021:../uvc.c      ****                             }
3022:../uvc.c      ****                         }
3023:../uvc.c      ****                         break;
3024:../uvc.c      **** 
3025:../uvc.c      ****                     default:
3026:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3027:../uvc.c      ****                         break;
3028:../uvc.c      ****                 }
3029:../uvc.c      ****                 break;
3030:../uvc.c      **** 
3031:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3032:../uvc.c      ****                 switch (bRequest)
3033:../uvc.c      ****                 {
3034:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3035:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3036:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3037:../uvc.c      ****                         break;
3038:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3039:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3040:../uvc.c      ****                         glEp0Buffer[1] = 0;
3041:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3042:../uvc.c      ****                         break;
3043:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3044:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3045:../uvc.c      ****                         {
3046:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3047:../uvc.c      ****                         }
3048:../uvc.c      ****                         else
3049:../uvc.c      ****                         {
3050:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3051:../uvc.c      ****                         }
3052:../uvc.c      ****                         break;
3053:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3054:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3055:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3056:../uvc.c      ****                            */
3057:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3058:../uvc.c      ****                                 glCommitCtrl, &readCount);
3059:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3060:../uvc.c      ****                         {
3061:../uvc.c      ****     #if 0
3062:../uvc.c      ****                             /* We can start still streaming video now. */
3063:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3064:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3065:../uvc.c      ****                             {
3066:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3067:../uvc.c      ****                             }
3068:../uvc.c      ****     #endif
3069:../uvc.c      ****                             //else{
3070:../uvc.c      ****                             stiflag = CyTrue;//set still trigger flag
3071:../uvc.c      ****                             //stillcont = 0;
3072:../uvc.c      ****                             //}
3073:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3074:../uvc.c      ****                         }else{
3075:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3076:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3077:../uvc.c      ****                         }
3078:../uvc.c      ****                         break;
3079:../uvc.c      **** 
3080:../uvc.c      ****                     default:
3081:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3082:../uvc.c      ****                         break;
3083:../uvc.c      ****                 }
3084:../uvc.c      ****                 break;
3085:../uvc.c      **** 
3086:../uvc.c      ****         default:
3087:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3088:../uvc.c      ****             break;
3089:../uvc.c      ****     }
3090:../uvc.c      **** }
3091:../uvc.c      **** 
3092:../uvc.c      **** /*
3093:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3094:../uvc.c      ****  */
3095:../uvc.c      **** void
3096:../uvc.c      **** UVCAppEP0Thread_Entry (
3097:../uvc.c      ****         uint32_t input)
3098:../uvc.c      **** {
3099:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3100:../uvc.c      ****     uint32_t eventFlag;
3101:../uvc.c      **** 	CyBool_t value;
3102:../uvc.c      **** 	CyBool_t *valueptr = &value;
3103:../uvc.c      **** 
3104:../uvc.c      **** 
3105:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3106:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3107:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3108:../uvc.c      **** 
3109:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3110:../uvc.c      **** #endif
3111:../uvc.c      **** 
3112:../uvc.c      ****     /* for interrupt status test */
3113:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3114:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3115:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3116:../uvc.c      **** 
3117:../uvc.c      ****     for (;;)
3118:../uvc.c      ****     {
3119:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3120:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3121:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3122:../uvc.c      ****         {
3123:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3124:../uvc.c      ****             if (!isUsbConnected)
3125:../uvc.c      ****             {
3126:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3127:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3128:../uvc.c      ****                 {
3129:../uvc.c      ****                     isUsbConnected = CyTrue;
3130:../uvc.c      ****                 }
3131:../uvc.c      ****             }
3132:../uvc.c      **** //#ifdef DbgInfo
3133:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3134:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3135:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3136:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3137:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3138:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3139:../uvc.c      **** //#endif
3140:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3141:../uvc.c      ****             {
3142:../uvc.c      ****             	switch ((wIndex >> 8))
3143:../uvc.c      ****                 {
3144:../uvc.c      **** 
3145:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3146:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3147:../uvc.c      ****                         break;
3148:../uvc.c      **** 
3149:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3150:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3151:../uvc.c      ****                         break;
3152:../uvc.c      **** 
3153:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3154:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3155:../uvc.c      ****                         break;
3156:../uvc.c      **** 
3157:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3158:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3159:../uvc.c      ****                         break;
3160:../uvc.c      **** 
3161:../uvc.c      ****                     default:
3162:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3163:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3164:../uvc.c      ****                         break;
3165:../uvc.c      ****                 }
3166:../uvc.c      ****             }
3167:../uvc.c      **** 
3168:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3169:../uvc.c      ****             {
3170:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3171:../uvc.c      **** 
3172:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3173:../uvc.c      ****                 {
3174:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3175:../uvc.c      ****                 }
3176:../uvc.c      ****                 else
3177:../uvc.c      ****                 {
3178:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3179:../uvc.c      ****                 }
3180:../uvc.c      ****             }
3181:../uvc.c      **** 
3182:../uvc.c      ****             /* handle interrupt status event */
3183:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3184:../uvc.c      ****             {
3185:../uvc.c      **** 
3186:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3187:../uvc.c      ****             	/** preparing interrupt status data **/
3188:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3189:../uvc.c      **** 
3190:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3191:../uvc.c      **** 
3192:../uvc.c      **** #if 1 //for real button
3193:../uvc.c      **** 				if(value&&(!snapButFlag)){
3194:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3195:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3196:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3197:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3198:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3199:../uvc.c      **** 
3200:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3201:../uvc.c      **** 					interStabuf.size   = 1024;
3202:../uvc.c      **** 					interStabuf.status = 0;
3203:../uvc.c      **** 
3204:../uvc.c      **** 					interStabuf.count = 4;
3205:../uvc.c      **** 
3206:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3207:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3208:../uvc.c      **** 
3209:../uvc.c      **** 					/** send a interrupt status data **/
3210:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3211:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3212:../uvc.c      **** 					{
3213:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3214:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3215:../uvc.c      **** 					}
3216:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3217:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3218:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3219:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3220:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3221:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3222:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3223:../uvc.c      **** 
3224:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3225:../uvc.c      **** 					interStabuf.size   = 1024;
3226:../uvc.c      **** 					interStabuf.status = 0;
3227:../uvc.c      **** 
3228:../uvc.c      **** 					interStabuf.count = 4;
3229:../uvc.c      **** 
3230:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3231:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3232:../uvc.c      **** 
3233:../uvc.c      **** 					/** send a interrupt status data **/
3234:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3235:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3236:../uvc.c      **** 					{
3237:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3238:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3239:../uvc.c      **** 					}
3240:../uvc.c      **** 
3241:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3242:../uvc.c      **** 					stiflag = CyTrue;
3243:../uvc.c      **** 				}
3244:../uvc.c      **** #else			//for botton simulation
3245:../uvc.c      **** 				if(snapButFlag == 0x0f){
3246:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3247:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3248:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3249:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3250:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3251:../uvc.c      **** 
3252:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3253:../uvc.c      **** 					interStabuf.size   = 1024;
3254:../uvc.c      **** 					interStabuf.status = 0;
3255:../uvc.c      **** 
3256:../uvc.c      **** 					interStabuf.count = 4;
3257:../uvc.c      **** 
3258:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3259:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3260:../uvc.c      **** 
3261:../uvc.c      **** 					/** send a interrupt status data **/
3262:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3263:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3264:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3265:../uvc.c      **** 					{
3266:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3267:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3268:../uvc.c      **** 					}
3269:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3270:../uvc.c      **** 
3271:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3272:../uvc.c      **** 				}else if(!snapButFlag){
3273:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3274:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3275:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3276:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3277:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3278:../uvc.c      **** 
3279:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3280:../uvc.c      **** 					interStabuf.size   = 1024;
3281:../uvc.c      **** 					interStabuf.status = 0;
3282:../uvc.c      **** 
3283:../uvc.c      **** 					interStabuf.count = 4;
3284:../uvc.c      **** 
3285:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3286:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3287:../uvc.c      **** 
3288:../uvc.c      **** 					/** send a interrupt status data **/
3289:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3290:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3291:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3292:../uvc.c      **** 					{
3293:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3294:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3295:../uvc.c      **** 					}
3296:../uvc.c      **** 
3297:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3298:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3299:../uvc.c      **** 				}
3300:../uvc.c      **** #endif
3301:../uvc.c      **** 
3302:../uvc.c      ****             }
3303:../uvc.c      **** 
3304:../uvc.c      **** 
3305:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3306:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3307:../uvc.c      ****             {
3308:../uvc.c      ****                 /* Get the command buffer */
3309:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3310:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3311:../uvc.c      ****                 {
3312:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3313:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3314:../uvc.c      ****                 }
3315:../uvc.c      **** 
3316:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3317:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3318:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3319:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3320:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3321:../uvc.c      ****                  * register value high byte and register value low byte.
3322:../uvc.c      ****                  */
3323:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3324:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3325:../uvc.c      ****                 {
3326:../uvc.c      ****                     if (dmaInfo.count == 3)
3327:../uvc.c      ****                     {
3328:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3329:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3330:../uvc.c      ****                         dmaInfo.count = 3;
3331:../uvc.c      ****                     }
3332:../uvc.c      ****                     else if (dmaInfo.count == 4)
3333:../uvc.c      ****                     {
3334:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3335:../uvc.c      ****                         {
3336:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3337:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3338:../uvc.c      ****                         }
3339:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3340:../uvc.c      ****                     }
3341:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3342:../uvc.c      ****                 }
3343:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3344:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3345:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3346:../uvc.c      ****                  */
3347:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3348:../uvc.c      ****                 {
3349:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3350:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3351:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3352:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3353:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3354:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3355:../uvc.c      ****                         	break;
3356:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3357:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3358:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3359:../uvc.c      ****                         	break;*/
3360:../uvc.c      ****                     dmaInfo.count -= 2;
3361:../uvc.c      ****                 }
3362:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3363:../uvc.c      ****                 else
3364:../uvc.c      ****                 {
3365:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3366:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3367:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3368:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3369:../uvc.c      ****                 }
3370:../uvc.c      **** 
3371:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3372:../uvc.c      ****                 dmaInfo.size   = 1024;
3373:../uvc.c      ****                 dmaInfo.status = 0;
3374:../uvc.c      **** 
3375:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3376:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3377:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3378:../uvc.c      ****                 {
3379:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3380:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3381:../uvc.c      ****                 }
3382:../uvc.c      **** 
3383:../uvc.c      ****                 /* Wait until the response has gone out. */
3384:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3385:../uvc.c      **** 
3386:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3387:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3388:../uvc.c      ****                 {
3389:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3390:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3391:../uvc.c      ****                 }
3392:../uvc.c      ****             }
3393:../uvc.c      **** #endif
3394:../uvc.c      ****         }
3395:../uvc.c      ****         /* Allow other ready threads to run. */
3396:../uvc.c      ****         CyU3PThreadRelinquish ();
3397:../uvc.c      ****     }
3398:../uvc.c      **** }
3399:../uvc.c      **** 
3400:../uvc.c      **** /*
3401:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3402:../uvc.c      ****  * added 10/2013
3403:../uvc.c      ****  */
3404:../uvc.c      **** /*
3405:../uvc.c      **** static uint8_t timeDelay[64] = {
3406:../uvc.c      **** 
3407:../uvc.c      **** };
3408:../uvc.c      **** */
3409:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3409 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3410:../uvc.c      **** 
3411:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3412:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3413:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3414:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3415:../uvc.c      **** 	VdstateDes *lcStaDes;
3416:../uvc.c      **** 	uint32_t flag = 0;
3417:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3418:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3419:../uvc.c      **** 	uint8_t i;
3420:../uvc.c      **** 	uint16_t delaytime;
3421:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3422:../uvc.c      **** 
3423:../uvc.c      **** #if 0 //for test the command queue
3424:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3425:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3426:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3427:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3428:../uvc.c      **** 		lcCmdDes += 1;
3429:../uvc.c      **** 	}
3430:../uvc.c      **** #endif
3431:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3432:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3432 0
  36 0004 00229FE5 		ldr	r2, .L22
3416:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3416 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3409:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3409 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3432 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 E8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3416:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3416 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3432 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3433:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3433 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 CC119FE5 		ldr	r1, .L22+8
  71 0044 CC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3434:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3434 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3435:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3435 0
  79 005c AC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3436:../uvc.c      **** 
3437:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3437 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3438:../uvc.c      ****         /* Allow other ready threads to run. */
3439:../uvc.c      **** 
3440:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3440 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3437:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3437 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3441:../uvc.c      **** 	}
3442:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3442 0
  92 0078 98019FE5 		ldr	r0, .L22+12
  93 007c 98119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 88719FE5 		ldr	r7, .L22+20
  99 0094 88B19FE5 		ldr	fp, .L22+24
3443:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3444:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3445:../uvc.c      **** 	//CyU3PThreadSleep(100);
3446:../uvc.c      **** 	//SetCurCmd();
3447:../uvc.c      **** 	/*********** the loop of the thread ***********/
3448:../uvc.c      **** 	for(;;){
3449:../uvc.c      **** 
3450:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3450 0
 101 0098 0060E0E3 		mvn	r6, #0
3451:../uvc.c      **** /*  // for test GPIO output
3452:../uvc.c      **** 		if(trigger)
3453:../uvc.c      **** 		{
3454:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3455:../uvc.c      **** 			{
3456:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3457:../uvc.c      **** 			}
3458:../uvc.c      **** 
3459:../uvc.c      **** 		}else{
3460:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3461:../uvc.c      **** 			{
3462:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3463:../uvc.c      **** 			}
3464:../uvc.c      **** 
3465:../uvc.c      **** 		}
3466:../uvc.c      **** */
3467:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3468:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3469:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3470:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3471:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3472:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3473:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3474:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3475:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3476:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3477:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3478:../uvc.c      **** #endif
3479:../uvc.c      **** 				}
3480:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3481:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3482:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3483:../uvc.c      **** 			}
3484:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3485:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3486:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3487:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3488:../uvc.c      **** 
3489:../uvc.c      **** 				/*
3490:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3491:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3492:../uvc.c      **** 				*/
3493:../uvc.c      **** 
3494:../uvc.c      **** 				/* find a available command */
3495:../uvc.c      **** 				i = 0;
3496:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3496 0
 103 009c 0090A0E3 		mov	r9, #0
3497:../uvc.c      **** 					i++;
3498:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3499:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3500:../uvc.c      **** 				}
3501:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3502:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3503:../uvc.c      **** 					i = lcCmdDes->curNum;
3504:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3505:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3506:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3507:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3508:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3509:../uvc.c      **** 						case 0x20:
3510:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3511:../uvc.c      **** 							delaytime = 500;
3512:../uvc.c      **** 							break;
3513:../uvc.c      **** 						case 0x21:
3514:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3515:../uvc.c      **** 							delaytime = 500;
3516:../uvc.c      **** 							break;
3517:../uvc.c      **** 						case 0x22:
3518:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3519:../uvc.c      **** 							delaytime = 300;
3520:../uvc.c      **** 							break;
3521:../uvc.c      **** 						case 0x23:
3522:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
3523:../uvc.c      **** 							delaytime = 300;
3524:../uvc.c      **** 							break;
3525:../uvc.c      **** 						default:
3526:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3527:../uvc.c      **** 							break;
3528:../uvc.c      **** 					}
3529:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3530:../uvc.c      **** 					/** timer's ticket modify **/
3531:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3532:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3533:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3534:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3535:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3536:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3537:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3538:../uvc.c      **** #endif
3539:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3540:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3541:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3542:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
3543:../uvc.c      **** 						}else{
3544:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3545:../uvc.c      **** 						}
3546:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3547:../uvc.c      **** 					}else{
3548:../uvc.c      **** 						lcCmdDes->curNum ++;
3549:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3549 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3450:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3450 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 70019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3467:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3467 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3484:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3484 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3486:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3486 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3487:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3487 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3496:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3496 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3498:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3498 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3497:../uvc.c      **** 					i++;
 140              		.loc 1 3497 0
 141 00f4 011083E2 		add	r1, r3, #1
3496:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3496 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3497:../uvc.c      **** 					i++;
 144              		.loc 1 3497 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3496:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3496 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3502:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3502 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2900000A 		beq	.L6
 157              	.LVL10:
3504:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3504 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3508:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3508 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3504:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3504 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3508:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3508 0
 166 0128 20C042E2 		sub	ip, r2, #32
3504:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3504 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3505:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3505 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3506:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3506 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3507:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3507 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3508:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3508 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 58010000 		.word	.L9
 185 014c 58010000 		.word	.L9
 186 0150 A4010000 		.word	.L11
 187 0154 A4010000 		.word	.L11
 188              	.L9:
3514:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 189              		.loc 1 3514 0
 190 0158 5230A0E3 		mov	r3, #82
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3516:../uvc.c      **** 							break;
 193              		.loc 1 3516 0
 194 0160 7D1FA0E3 		mov	r1, #500
 195              	.LVL16:
 196              	.L13:
3531:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3531 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 A0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3532:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3532 0
 202 0170 98009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3539:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3539 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3548:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3548 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3549 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3539:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3539 0
 215 0190 1000000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3550:../uvc.c      **** 					}
3551:../uvc.c      **** 				}else{
3552:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3553:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3554:../uvc.c      **** 				}
3555:../uvc.c      **** 			}
3556:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3556 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3557:../uvc.c      **** /*
3558:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3559:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3560:../uvc.c      **** */
3561:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3562:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3563:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3564:../uvc.c      **** #endif
3565:../uvc.c      **** 
3566:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3567:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3568:../uvc.c      **** #if 0
3569:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3570:../uvc.c      **** 
3571:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3572:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3573:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3574:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3575:../uvc.c      **** 			    i = 0;
3576:../uvc.c      **** 				 switch(cmdCopyIdx)
3577:../uvc.c      **** 				 {
3578:../uvc.c      **** 					 case BrgtCtlID1:
3579:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3580:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3581:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3582:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3583:../uvc.c      **** 							 i++;
3584:../uvc.c      **** 						 }
3585:../uvc.c      **** 						 else{
3586:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3587:../uvc.c      **** 						 }
3588:../uvc.c      **** 
3589:../uvc.c      **** 						 CyU3PBusyWait(500);
3590:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3591:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3592:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3593:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3594:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3595:../uvc.c      **** 						 }
3596:../uvc.c      **** 						 else{
3597:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3598:../uvc.c      **** 						 }
3599:../uvc.c      **** 						 break;
3600:../uvc.c      **** 					 case HueCtlID5:
3601:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3602:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3603:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3604:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3605:../uvc.c      **** 						 }
3606:../uvc.c      **** 						 else{
3607:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3608:../uvc.c      **** 						 }
3609:../uvc.c      **** 						 break;
3610:../uvc.c      **** 					 case SaturCtlID6:
3611:../uvc.c      **** 					 case WBTLevCtlID10:
3612:../uvc.c      **** 					 default:
3613:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3614:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3615:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3616:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3617:../uvc.c      **** 						 }
3618:../uvc.c      **** 						 else{
3619:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3620:../uvc.c      **** 						 }
3621:../uvc.c      **** 						 break;
3622:../uvc.c      **** 				 }
3623:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3624:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3625:../uvc.c      **** 			}
3626:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3627:../uvc.c      **** #endif
3628:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3629:../uvc.c      **** 		/* Allow other ready threads to run. */
3630:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3631:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3631 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3632:../uvc.c      **** 		}
 224              		.loc 1 3632 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L11:
3522:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
 228              		.loc 1 3522 0
 229 01a4 8230A0E3 		mov	r3, #130
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3524:../uvc.c      **** 							break;
 232              		.loc 1 3524 0
 233 01ac 4B1FA0E3 		mov	r1, #300
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3526:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3526 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3527:../uvc.c      **** 							break;
 241              		.loc 1 3527 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L6:
3552:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 245              		.loc 1 3552 0
 246 01c0 FA1FA0E3 		mov	r1, #1000
 247 01c4 44009FE5 		ldr	r0, .L22+4
 248 01c8 FEFFFFEB 		bl	_txe_timer_change
3553:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 249              		.loc 1 3553 0
 250 01cc 3C009FE5 		ldr	r0, .L22+4
 251 01d0 FEFFFFEB 		bl	_txe_timer_activate
 252 01d4 EEFFFFEA 		b	.L17
 253              	.LVL25:
 254              	.L21:
3541:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 255              		.loc 1 3541 0
 256 01d8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3540:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 257              		.loc 1 3540 0
 258 01dc 3C9084E5 		str	r9, [r4, #60]
3541:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 259              		.loc 1 3541 0
 260 01e0 23005CE3 		cmp	ip, #35
3542:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 261              		.loc 1 3542 0
 262 01e4 20C04C82 		subhi	ip, ip, #32
 263 01e8 8CC08C80 		addhi	ip, ip, ip, asl #1
3544:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 264              		.loc 1 3544 0
 265 01ec 8CC08C90 		addls	ip, ip, ip, asl #1
3542:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 266              		.loc 1 3542 0
 267 01f0 8CC18B80 		addhi	ip, fp, ip, asl #3
3544:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 268              		.loc 1 3544 0
 269 01f4 8CC18B90 		addls	ip, fp, ip, asl #3
3542:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
 270              		.loc 1 3542 0
 271 01f8 1090CC85 		strhib	r9, [ip, #16]
3544:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 272              		.loc 1 3544 0
 273 01fc 9091CC95 		strlsb	r9, [ip, #400]
3546:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 274              		.loc 1 3546 0
 275 0200 344094E5 		ldr	r4, [r4, #52]
 276              	.LVL26:
 277 0204 104085E5 		str	r4, [r5, #16]
 278 0208 E1FFFFEA 		b	.L17
 279              	.L23:
 280              		.align	2
 281              	.L22:
 282 020c 00000000 		.word	I2CCmdCb
 283 0210 00000000 		.word	I2CCmdTimer
 284 0214 00000000 		.word	.LC0
 285 0218 00000000 		.word	cmdQu
 286 021c 14000000 		.word	.LC1
 287 0220 00000000 		.word	statQu
 288 0224 00000000 		.word	.LANCHOR1
 289 0228 00000000 		.word	.LANCHOR0
 290              		.cfi_endproc
 291              	.LFE25:
 293              		.align	2
 294              		.global	I2CCmdCb
 296              	I2CCmdCb:
 297              	.LFB17:
2182:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 298              		.loc 1 2182 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 0
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302              		@ link register save eliminated.
 303              	.LVL27:
2184:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 304              		.loc 1 2184 0
 305 022c 08009FE5 		ldr	r0, .L25
 306              	.LVL28:
 307 0230 2010A0E3 		mov	r1, #32
 308 0234 0020A0E3 		mov	r2, #0
2185:../uvc.c      **** }
 309              		.loc 1 2185 0
2184:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 310              		.loc 1 2184 0
 311 0238 FEFFFFEA 		b	_txe_event_flags_set
 312              	.L26:
 313              		.align	2
 314              	.L25:
 315 023c 00000000 		.word	.LANCHOR0
 316              		.cfi_endproc
 317              	.LFE17:
 319              		.align	2
 320              		.global	CyFxUvcApplnDmaCallback
 322              	CyFxUvcApplnDmaCallback:
 323              	.LFB10:
1472:../uvc.c      **** {
 324              		.loc 1 1472 0
 325              		.cfi_startproc
 326              		@ args = 0, pretend = 0, frame = 0
 327              		@ frame_needed = 0, uses_anonymous_args = 0
 328              	.LVL29:
1476:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 329              		.loc 1 1476 0
 330 0240 080051E3 		cmp	r1, #8
1472:../uvc.c      **** {
 331              		.loc 1 1472 0
 332 0244 30402DE9 		stmfd	sp!, {r4, r5, lr}
 333              	.LCFI2:
 334              		.cfi_def_cfa_offset 12
 335 0248 0240A0E1 		mov	r4, r2
 336              		.cfi_offset 14, -4
 337              		.cfi_offset 5, -8
 338              		.cfi_offset 4, -12
 339 024c 0CD04DE2 		sub	sp, sp, #12
 340              	.LCFI3:
 341              		.cfi_def_cfa_offset 24
1476:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 342              		.loc 1 1476 0
 343 0250 0B00000A 		beq	.L32
1505:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 344              		.loc 1 1505 0
 345 0254 100051E3 		cmp	r1, #16
 346 0258 0700001A 		bne	.L27
1507:../uvc.c      ****         consCount++;
 347              		.loc 1 1507 0
 348 025c 04319FE5 		ldr	r3, .L34
1508:../uvc.c      ****         streamingStarted = CyTrue;
 349              		.loc 1 1508 0
 350 0260 0120A0E3 		mov	r2, #1
 351              	.LVL30:
1507:../uvc.c      ****         consCount++;
 352              		.loc 1 1507 0
 353 0264 B0C3D3E1 		ldrh	ip, [r3, #48]
1508:../uvc.c      ****         streamingStarted = CyTrue;
 354              		.loc 1 1508 0
 355 0268 342083E5 		str	r2, [r3, #52]
1507:../uvc.c      ****         consCount++;
 356              		.loc 1 1507 0
 357 026c 02008CE0 		add	r0, ip, r2
 358              	.LVL31:
 359 0270 0018A0E1 		mov	r1, r0, asl #16
 360              	.LVL32:
 361 0274 2128A0E1 		mov	r2, r1, lsr #16
 362 0278 B023C3E1 		strh	r2, [r3, #48]	@ movhi
 363              	.L27:
1510:../uvc.c      **** }
 364              		.loc 1 1510 0
 365 027c 0CD08DE2 		add	sp, sp, #12
 366 0280 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 367              	.LVL33:
 368              	.L32:
1478:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 369              		.loc 1 1478 0
 370 0284 B420D2E1 		ldrh	r2, [r2, #4]
 371 0288 DC309FE5 		ldr	r3, .L34+4
 372 028c 030052E1 		cmp	r2, r3
 373 0290 2900000A 		beq	.L33
1486:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 374              		.loc 1 1486 0
 375 0294 005094E5 		ldr	r5, [r4, #0]
 376              	.LVL34:
 377              	.LBB12:
 378              	.LBB13:
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 379              		.loc 1 1221 0
 380 0298 D0109FE5 		ldr	r1, .L34+8
 381              	.LVL35:
 382 029c 0C0045E2 		sub	r0, r5, #12
 383              	.LVL36:
 384 02a0 0C20A0E3 		mov	r2, #12
 385 02a4 FEFFFFEB 		bl	CyU3PMemCopy
 386              	.LVL37:
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 387              		.loc 1 1226 0
 388 02a8 0BC055E5 		ldrb	ip, [r5, #-11]	@ zero_extendqisi2
 389              	.LBE13:
 390              	.LBE12:
1487:../uvc.c      ****                 pb++;
 391              		.loc 1 1487 0
 392 02ac B4309FE5 		ldr	r3, .L34
 393              	.LBB15:
 394              	.LBB14:
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 395              		.loc 1 1226 0
 396 02b0 02108CE3 		orr	r1, ip, #2
 397 02b4 0B1045E5 		strb	r1, [r5, #-11]
 398              	.LBE14:
 399              	.LBE15:
1487:../uvc.c      ****                 pb++;
 400              		.loc 1 1487 0
 401 02b8 BA02D3E1 		ldrh	r0, [r3, #42]
1488:../uvc.c      ****                 pbc = input->buffer_p.count;
 402              		.loc 1 1488 0
 403 02bc B410D4E1 		ldrh	r1, [r4, #4]
1487:../uvc.c      ****                 pb++;
 404              		.loc 1 1487 0
 405 02c0 012080E2 		add	r2, r0, #1
 406 02c4 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
1488:../uvc.c      ****                 pbc = input->buffer_p.count;
 407              		.loc 1 1488 0
 408 02c8 BC12C3E1 		strh	r1, [r3, #44]	@ movhi
 409              	.LVL38:
 410              	.L30:
1493:../uvc.c      ****             prodCount++;
 411              		.loc 1 1493 0
 412 02cc BEE2D3E1 		ldrh	lr, [r3, #46]
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 413              		.loc 1 1494 0
 414 02d0 0C1081E2 		add	r1, r1, #12
1493:../uvc.c      ****             prodCount++;
 415              		.loc 1 1493 0
 416 02d4 01C08EE2 		add	ip, lr, #1
 417 02d8 0C08A0E1 		mov	r0, ip, asl #16
 418 02dc 20E8A0E1 		mov	lr, r0, lsr #16
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 419              		.loc 1 1494 0
 420 02e0 0128A0E1 		mov	r2, r1, asl #16
 421 02e4 2218A0E1 		mov	r1, r2, lsr #16
 422 02e8 84009FE5 		ldr	r0, .L34+12
 423 02ec 0020A0E3 		mov	r2, #0
1493:../uvc.c      ****             prodCount++;
 424              		.loc 1 1493 0
 425 02f0 BEE2C3E1 		strh	lr, [r3, #46]	@ movhi
1494:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 426              		.loc 1 1494 0
 427 02f4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 428              	.LVL39:
1493:../uvc.c      ****             prodCount++;
 429              		.loc 1 1493 0
 430 02f8 68109FE5 		ldr	r1, .L34
1497:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 431              		.loc 1 1497 0
 432 02fc 002050E2 		subs	r2, r0, #0
 433 0300 DDFFFF0A 		beq	.L27
1499:../uvc.c      ****                 prodCount--;
 434              		.loc 1 1499 0
 435 0304 BEC2D1E1 		ldrh	ip, [r1, #46]
1500:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 436              		.loc 1 1500 0
 437 0308 B430D4E1 		ldrh	r3, [r4, #4]
1499:../uvc.c      ****                 prodCount--;
 438              		.loc 1 1499 0
 439 030c 01004CE2 		sub	r0, ip, #1
 440              	.LVL40:
 441 0310 00E8A0E1 		mov	lr, r0, asl #16
 442 0314 2EC8A0E1 		mov	ip, lr, lsr #16
 443 0318 BEC2C1E1 		strh	ip, [r1, #46]	@ movhi
1500:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 444              		.loc 1 1500 0
 445 031c BEE2D1E1 		ldrh	lr, [r1, #46]
 446 0320 B003D1E1 		ldrh	r0, [r1, #48]
 447 0324 4C109FE5 		ldr	r1, .L34+16
 448 0328 0EC060E0 		rsb	ip, r0, lr
 449 032c 0400A0E3 		mov	r0, #4
 450 0330 00C08DE5 		str	ip, [sp, #0]
 451 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 452              	.LVL41:
 453 0338 CFFFFFEA 		b	.L27
 454              	.LVL42:
 455              	.L33:
1480:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 456              		.loc 1 1480 0
 457 033c 00E094E5 		ldr	lr, [r4, #0]
 458              	.LBB16:
 459              	.LBB17:
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 460              		.loc 1 1221 0
 461 0340 28109FE5 		ldr	r1, .L34+8
 462              	.LVL43:
 463 0344 0C004EE2 		sub	r0, lr, #12
 464              	.LVL44:
 465 0348 0C20A0E3 		mov	r2, #12
 466 034c FEFFFFEB 		bl	CyU3PMemCopy
 467              	.LVL45:
 468              	.LBE17:
 469              	.LBE16:
1481:../uvc.c      ****                 fb++;
 470              		.loc 1 1481 0
 471 0350 10309FE5 		ldr	r3, .L34
 472 0354 B410D4E1 		ldrh	r1, [r4, #4]
 473 0358 B8C2D3E1 		ldrh	ip, [r3, #40]
 474 035c 01008CE2 		add	r0, ip, #1
 475 0360 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 476 0364 D8FFFFEA 		b	.L30
 477              	.L35:
 478              		.align	2
 479              	.L34:
 480 0368 00000000 		.word	.LANCHOR0
 481 036c F03F0000 		.word	16368
 482 0370 80040000 		.word	.LANCHOR1+1152
 483 0374 00000000 		.word	glChHandleUVCStream
 484 0378 38000000 		.word	.LC2
 485              		.cfi_endproc
 486              	.LFE10:
 488              		.align	2
 490              	CyFxUVCApplnUSBEventCB:
 491              	.LFB8:
1275:../uvc.c      **** {
 492              		.loc 1 1275 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 8
 495              		@ frame_needed = 0, uses_anonymous_args = 0
 496              	.LVL46:
1276:../uvc.c      ****     switch (evtype)
 497              		.loc 1 1276 0
 498 037c 020050E3 		cmp	r0, #2
1275:../uvc.c      **** {
 499              		.loc 1 1275 0
 500 0380 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 501              	.LCFI4:
 502              		.cfi_def_cfa_offset 16
 503 0384 0130A0E1 		mov	r3, r1
 504 0388 10D04DE2 		sub	sp, sp, #16
 505              	.LCFI5:
 506              		.cfi_def_cfa_offset 32
1275:../uvc.c      **** {
 507              		.loc 1 1275 0
 508 038c 0040A0E1 		mov	r4, r0
 509              		.cfi_offset 14, -4
 510              		.cfi_offset 6, -8
 511              		.cfi_offset 5, -12
 512              		.cfi_offset 4, -16
1276:../uvc.c      ****     switch (evtype)
 513              		.loc 1 1276 0
 514 0390 3600000A 		beq	.L39
 515 0394 040050E3 		cmp	r0, #4
 516 0398 1F00000A 		beq	.L40
 517 039c 010050E3 		cmp	r0, #1
 518 03a0 0100000A 		beq	.L42
 519              	.LVL47:
 520              	.L36:
1312:../uvc.c      **** }
 521              		.loc 1 1312 0
 522 03a4 10D08DE2 		add	sp, sp, #16
 523 03a8 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 524              	.LVL48:
 525              	.L42:
1297:../uvc.c      ****             gpif_initialized = 0;
 526              		.loc 1 1297 0
 527 03ac 28519FE5 		ldr	r5, .L43
1295:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 528              		.loc 1 1295 0
 529 03b0 0020A0E1 		mov	r2, r0
 530 03b4 24119FE5 		ldr	r1, .L43+4
 531              	.LVL49:
 532 03b8 0400A0E3 		mov	r0, #4
 533              	.LVL50:
 534 03bc FEFFFFEB 		bl	CyU3PDebugPrint
1296:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 535              		.loc 1 1296 0
 536 03c0 0400A0E1 		mov	r0, r4
 537 03c4 FEFFFFEB 		bl	CyU3PGpifDisable
1297:../uvc.c      ****             gpif_initialized = 0;
 538              		.loc 1 1297 0
 539 03c8 00C0A0E3 		mov	ip, #0
 540              	.LBB24:
 541              	.LBB25:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 542              		.loc 1 1259 0
 543 03cc 0410A0E1 		mov	r1, r4
 544 03d0 0500A0E1 		mov	r0, r5
 545 03d4 0220A0E3 		mov	r2, #2
 546 03d8 0C308DE2 		add	r3, sp, #12
 547              	.LBE25:
 548              	.LBE24:
1297:../uvc.c      ****             gpif_initialized = 0;
 549              		.loc 1 1297 0
 550 03dc 38C085E5 		str	ip, [r5, #56]
1298:../uvc.c      ****             isUsbConnected = CyFalse;
 551              		.loc 1 1298 0
 552 03e0 3CC085E5 		str	ip, [r5, #60]
1299:../uvc.c      ****             streamingStarted = CyFalse;
 553              		.loc 1 1299 0
 554 03e4 34C085E5 		str	ip, [r5, #52]
 555              	.LBB27:
 556              	.LBB26:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 557              		.loc 1 1259 0
 558 03e8 00C08DE5 		str	ip, [sp, #0]
 559 03ec FEFFFFEB 		bl	_txe_event_flags_get
 560 03f0 004050E2 		subs	r4, r0, #0
 561 03f4 EAFFFF1A 		bne	.L36
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 562              		.loc 1 1262 0
 563 03f8 0110E0E3 		mvn	r1, #1
 564 03fc 0220A0E3 		mov	r2, #2
 565 0400 0500A0E1 		mov	r0, r5
 566              	.L41:
 567 0404 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 568              		.loc 1 1265 0
 569 0408 0500A0E1 		mov	r0, r5
 570 040c 0210A0E3 		mov	r1, #2
 571 0410 0420A0E1 		mov	r2, r4
 572 0414 FEFFFFEB 		bl	_txe_event_flags_set
 573 0418 E1FFFFEA 		b	.L36
 574              	.LVL51:
 575              	.L40:
 576              	.LBE26:
 577              	.LBE27:
1281:../uvc.c      ****             gpif_initialized = 0;
 578              		.loc 1 1281 0
 579 041c B8509FE5 		ldr	r5, .L43
1279:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 580              		.loc 1 1279 0
 581 0420 BC109FE5 		ldr	r1, .L43+8
 582              	.LVL52:
 583 0424 0020A0E1 		mov	r2, r0
 584 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 585              	.LVL53:
1280:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 586              		.loc 1 1280 0
 587 042c 0100A0E3 		mov	r0, #1
 588 0430 FEFFFFEB 		bl	CyU3PGpifDisable
1281:../uvc.c      ****             gpif_initialized = 0;
 589              		.loc 1 1281 0
 590 0434 00C0A0E3 		mov	ip, #0
 591              	.LBB28:
 592              	.LBB29:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 593              		.loc 1 1259 0
 594 0438 0110A0E3 		mov	r1, #1
 595 043c 0220A0E3 		mov	r2, #2
 596 0440 0500A0E1 		mov	r0, r5
 597 0444 0C308DE2 		add	r3, sp, #12
 598              	.LBE29:
 599              	.LBE28:
1281:../uvc.c      ****             gpif_initialized = 0;
 600              		.loc 1 1281 0
 601 0448 38C085E5 		str	ip, [r5, #56]
1282:../uvc.c      ****             streamingStarted = CyFalse;
 602              		.loc 1 1282 0
 603 044c 34C085E5 		str	ip, [r5, #52]
 604              	.LBB31:
 605              	.LBB30:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 606              		.loc 1 1259 0
 607 0450 00C08DE5 		str	ip, [sp, #0]
 608 0454 FEFFFFEB 		bl	_txe_event_flags_get
 609 0458 004050E2 		subs	r4, r0, #0
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 610              		.loc 1 1262 0
 611 045c 0500A001 		moveq	r0, r5
 612 0460 0110E003 		mvneq	r1, #1
 613 0464 0220A003 		moveq	r2, #2
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 614              		.loc 1 1259 0
 615 0468 CDFFFF1A 		bne	.L36
 616 046c E4FFFFEA 		b	.L41
 617              	.LVL54:
 618              	.L39:
 619              	.LBE30:
 620              	.LBE31:
1289:../uvc.c      ****             gpif_initialized = 0;
 621              		.loc 1 1289 0
 622 0470 64509FE5 		ldr	r5, .L43
1287:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 623              		.loc 1 1287 0
 624 0474 0020A0E1 		mov	r2, r0
 625 0478 68109FE5 		ldr	r1, .L43+12
 626              	.LVL55:
 627 047c 0400A0E3 		mov	r0, #4
 628              	.LVL56:
 629 0480 FEFFFFEB 		bl	CyU3PDebugPrint
1288:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 630              		.loc 1 1288 0
 631 0484 0100A0E3 		mov	r0, #1
 632 0488 FEFFFFEB 		bl	CyU3PGpifDisable
1289:../uvc.c      ****             gpif_initialized = 0;
 633              		.loc 1 1289 0
 634 048c 0060A0E3 		mov	r6, #0
 635              	.LBB32:
 636              	.LBB33:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 637              		.loc 1 1259 0
 638 0490 0500A0E1 		mov	r0, r5
 639 0494 0110A0E3 		mov	r1, #1
 640 0498 0420A0E1 		mov	r2, r4
 641 049c 0C308DE2 		add	r3, sp, #12
 642              	.LBE33:
 643              	.LBE32:
1289:../uvc.c      ****             gpif_initialized = 0;
 644              		.loc 1 1289 0
 645 04a0 386085E5 		str	r6, [r5, #56]
1290:../uvc.c      ****             streamingStarted = CyFalse;
 646              		.loc 1 1290 0
 647 04a4 346085E5 		str	r6, [r5, #52]
 648              	.LBB35:
 649              	.LBB34:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 650              		.loc 1 1259 0
 651 04a8 00608DE5 		str	r6, [sp, #0]
 652 04ac FEFFFFEB 		bl	_txe_event_flags_get
 653 04b0 006050E2 		subs	r6, r0, #0
 654 04b4 BAFFFF1A 		bne	.L36
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 655              		.loc 1 1262 0
 656 04b8 0420A0E1 		mov	r2, r4
 657 04bc 0500A0E1 		mov	r0, r5
 658 04c0 0110E0E3 		mvn	r1, #1
 659 04c4 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 660              		.loc 1 1265 0
 661 04c8 0500A0E1 		mov	r0, r5
 662 04cc 0410A0E1 		mov	r1, r4
 663 04d0 0620A0E1 		mov	r2, r6
 664 04d4 FEFFFFEB 		bl	_txe_event_flags_set
 665 04d8 B1FFFFEA 		b	.L36
 666              	.L44:
 667              		.align	2
 668              	.L43:
 669 04dc 00000000 		.word	.LANCHOR0
 670 04e0 C4000000 		.word	.LC5
 671 04e4 80000000 		.word	.LC3
 672 04e8 A0000000 		.word	.LC4
 673              	.LBE34:
 674              	.LBE35:
 675              		.cfi_endproc
 676              	.LFE8:
 678              		.align	2
 680              	CyFxUVCApplnUSBSetupCB:
 681              	.LFB9:
1320:../uvc.c      **** {
 682              		.loc 1 1320 0
 683              		.cfi_startproc
 684              		@ args = 0, pretend = 0, frame = 8
 685              		@ frame_needed = 0, uses_anonymous_args = 0
 686              	.LVL57:
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 687              		.loc 1 1325 0
 688 04ec C0329FE5 		ldr	r3, .L70
1320:../uvc.c      **** {
 689              		.loc 1 1320 0
 690 04f0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 691              	.LCFI6:
 692              		.cfi_def_cfa_offset 24
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 693              		.loc 1 1326 0
 694 04f4 BCC29FE5 		ldr	ip, .L70+4
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 695              		.loc 1 1325 0
 696 04f8 FF4000E2 		and	r4, r0, #255
 697              		.cfi_offset 14, -4
 698              		.cfi_offset 8, -8
 699              		.cfi_offset 7, -12
 700              		.cfi_offset 6, -16
 701              		.cfi_offset 5, -20
 702              		.cfi_offset 4, -24
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 703              		.loc 1 1326 0
 704 04fc FF8C00E2 		and	r8, r0, #65280
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 705              		.loc 1 1327 0
 706 0500 2078A0E1 		mov	r7, r0, lsr #16
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 707              		.loc 1 1325 0
 708 0504 0040C3E5 		strb	r4, [r3, #0]
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 709              		.loc 1 1327 0
 710 0508 AC229FE5 		ldr	r2, .L70+8
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 711              		.loc 1 1328 0
 712 050c AC029FE5 		ldr	r0, .L70+12
 713              	.LVL58:
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 714              		.loc 1 1329 0
 715 0510 AC329FE5 		ldr	r3, .L70+16
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 716              		.loc 1 1328 0
 717 0514 0158A0E1 		mov	r5, r1, asl #16
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 718              		.loc 1 1326 0
 719 0518 2884A0E1 		mov	r8, r8, lsr #8
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 720              		.loc 1 1328 0
 721 051c 2558A0E1 		mov	r5, r5, lsr #16
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 722              		.loc 1 1329 0
 723 0520 2118A0E1 		mov	r1, r1, lsr #16
 724              	.LVL59:
1332:../uvc.c      ****     switch (bmReqType)
 725              		.loc 1 1332 0
 726 0524 020054E3 		cmp	r4, #2
1320:../uvc.c      **** {
 727              		.loc 1 1320 0
 728 0528 10D04DE2 		sub	sp, sp, #16
 729              	.LCFI7:
 730              		.cfi_def_cfa_offset 40
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 731              		.loc 1 1326 0
 732 052c 0080CCE5 		strb	r8, [ip, #0]
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 733              		.loc 1 1327 0
 734 0530 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 735              		.loc 1 1328 0
 736 0534 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 737              		.loc 1 1329 0
 738 0538 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1332:../uvc.c      ****     switch (bmReqType)
 739              		.loc 1 1332 0
 740 053c 4F00000A 		beq	.L48
 741 0540 0600009A 		bls	.L66
 742 0544 210054E3 		cmp	r4, #33
 743 0548 3A00000A 		beq	.L49
 744 054c A10054E3 		cmp	r4, #161
 745 0550 3800000A 		beq	.L49
 746              	.L63:
1321:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 747              		.loc 1 1321 0
 748 0554 0000A0E3 		mov	r0, #0
 749              	.LVL60:
 750              	.L46:
1459:../uvc.c      **** }
 751              		.loc 1 1459 0
 752 0558 10D08DE2 		add	sp, sp, #16
 753 055c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 754              	.LVL61:
 755              	.L66:
1332:../uvc.c      ****     switch (bmReqType)
 756              		.loc 1 1332 0
 757 0560 010054E3 		cmp	r4, #1
 758 0564 FAFFFF1A 		bne	.L63
1372:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 759              		.loc 1 1372 0
 760 0568 0B0058E3 		cmp	r8, #11
 761 056c F8FFFF1A 		bne	.L63
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 762              		.loc 1 1376 0
 763 0570 010055E3 		cmp	r5, #1
 764 0574 F6FFFF1A 		bne	.L63
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 765              		.loc 1 1376 0 is_stmt 0 discriminator 1
 766 0578 000057E3 		cmp	r7, #0
 767 057c F4FFFF1A 		bne	.L63
1381:../uvc.c      ****                     gpif_initialized = 0;
 768              		.loc 1 1381 0 is_stmt 1
 769 0580 40429FE5 		ldr	r4, .L70+20
1379:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 770              		.loc 1 1379 0
 771 0584 40129FE5 		ldr	r1, .L70+24
 772 0588 0400A0E3 		mov	r0, #4
 773 058c FEFFFFEB 		bl	CyU3PDebugPrint
1380:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 774              		.loc 1 1380 0
 775 0590 0500A0E1 		mov	r0, r5
 776 0594 FEFFFFEB 		bl	CyU3PGpifDisable
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 777              		.loc 1 1384 0
 778 0598 0510A0E1 		mov	r1, r5
 779 059c 8300A0E3 		mov	r0, #131
1381:../uvc.c      ****                     gpif_initialized = 0;
 780              		.loc 1 1381 0
 781 05a0 387084E5 		str	r7, [r4, #56]
1382:../uvc.c      ****                     streamingStarted = CyFalse;
 782              		.loc 1 1382 0
 783 05a4 347084E5 		str	r7, [r4, #52]
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 784              		.loc 1 1384 0
 785 05a8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1385:../uvc.c      ****                     CyU3PBusyWait (100);
 786              		.loc 1 1385 0
 787 05ac 6400A0E3 		mov	r0, #100
 788 05b0 FEFFFFEB 		bl	CyU3PBusyWait
1388:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 789              		.loc 1 1388 0
 790 05b4 14029FE5 		ldr	r0, .L70+28
 791 05b8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1389:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 792              		.loc 1 1389 0
 793 05bc 8300A0E3 		mov	r0, #131
 794 05c0 FEFFFFEB 		bl	CyU3PUsbFlushEp
1390:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 795              		.loc 1 1390 0
 796 05c4 0710A0E1 		mov	r1, r7
 797 05c8 8300A0E3 		mov	r0, #131
 798 05cc FEFFFFEB 		bl	CyU3PUsbSetEpNak
1391:../uvc.c      ****                     CyU3PBusyWait (100);
 799              		.loc 1 1391 0
 800 05d0 6400A0E3 		mov	r0, #100
 801 05d4 FEFFFFEB 		bl	CyU3PBusyWait
1394:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 802              		.loc 1 1394 0
 803 05d8 0710A0E1 		mov	r1, r7
 804 05dc 0520A0E1 		mov	r2, r5
 805 05e0 8300A0E3 		mov	r0, #131
 806 05e4 FEFFFFEB 		bl	CyU3PUsbStall
 807              	.LVL62:
1397:../uvc.c      ****                     CyU3PUsbAckSetup ();
 808              		.loc 1 1397 0
 809 05e8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1399:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 810              		.loc 1 1399 0
 811 05ec 405084E5 		str	r5, [r4, #64]
 812              	.LBB40:
 813              	.LBB41:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 814              		.loc 1 1259 0
 815 05f0 0400A0E1 		mov	r0, r4
 816 05f4 0510A0E1 		mov	r1, r5
 817 05f8 0220A0E3 		mov	r2, #2
 818 05fc 0C308DE2 		add	r3, sp, #12
 819 0600 00708DE5 		str	r7, [sp, #0]
 820 0604 FEFFFFEB 		bl	_txe_event_flags_get
 821 0608 006050E2 		subs	r6, r0, #0
 822 060c 2E00001A 		bne	.L61
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 823              		.loc 1 1262 0
 824 0610 0110E0E3 		mvn	r1, #1
 825 0614 0220A0E3 		mov	r2, #2
 826 0618 0400A0E1 		mov	r0, r4
 827 061c FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 828              		.loc 1 1265 0
 829 0620 0400A0E1 		mov	r0, r4
 830 0624 0210A0E3 		mov	r1, #2
 831 0628 0620A0E1 		mov	r2, r6
 832 062c FEFFFFEB 		bl	_txe_event_flags_set
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
 833              		.loc 1 1395 0
 834 0630 0500A0E1 		mov	r0, r5
 835 0634 C7FFFFEA 		b	.L46
 836              	.LVL63:
 837              	.L49:
 838              	.LBE41:
 839              	.LBE40:
1337:../uvc.c      ****             switch (wIndex & 0xFF)
 840              		.loc 1 1337 0
 841 0638 FF5015E2 		ands	r5, r5, #255
 842 063c 1A00001A 		bne	.L67
 843              	.LVL64:
1342:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 844              		.loc 1 1342 0
 845 0640 0520A0E1 		mov	r2, r5
 846 0644 7C019FE5 		ldr	r0, .L70+20
 847 0648 0410A0E3 		mov	r1, #4
 848 064c FEFFFFEB 		bl	_txe_event_flags_set
 849              	.LVL65:
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 850              		.loc 1 1344 0
 851 0650 002050E2 		subs	r2, r0, #0
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
 852              		.loc 1 1341 0
 853 0654 0100A003 		moveq	r0, #1
 854              	.LVL66:
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 855              		.loc 1 1344 0
 856 0658 BEFFFF0A 		beq	.L46
1346:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 857              		.loc 1 1346 0
 858 065c 70119FE5 		ldr	r1, .L70+32
 859 0660 0400A0E3 		mov	r0, #4
 860 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 861              	.LVL67:
1347:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 862              		.loc 1 1347 0
 863 0668 0500A0E1 		mov	r0, r5
 864 066c 0110A0E3 		mov	r1, #1
 865 0670 0520A0E1 		mov	r2, r5
 866 0674 FEFFFFEB 		bl	CyU3PUsbStall
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
 867              		.loc 1 1341 0
 868 0678 0100A0E3 		mov	r0, #1
 869 067c B5FFFFEA 		b	.L46
 870              	.LVL68:
 871              	.L48:
1407:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 872              		.loc 1 1407 0
 873 0680 010058E3 		cmp	r8, #1
 874 0684 B2FFFF1A 		bne	.L63
1409:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 875              		.loc 1 1409 0
 876 0688 830055E3 		cmp	r5, #131
 877 068c B0FFFF1A 		bne	.L63
1415:../uvc.c      ****                     if (streamingStarted == CyTrue)
 878              		.loc 1 1415 0
 879 0690 30719FE5 		ldr	r7, .L70+20
 880 0694 346097E5 		ldr	r6, [r7, #52]
 881 0698 010056E3 		cmp	r6, #1
 882 069c 1500000A 		beq	.L68
 883              	.LVL69:
1447:../uvc.c      ****                         CyU3PUsbAckSetup ();
 884              		.loc 1 1447 0
 885 06a0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1446:../uvc.c      ****                         uvcHandleReq = CyTrue;
 886              		.loc 1 1446 0
 887 06a4 0800A0E1 		mov	r0, r8
 888 06a8 AAFFFFEA 		b	.L46
 889              	.LVL70:
 890              	.L67:
1337:../uvc.c      ****             switch (wIndex & 0xFF)
 891              		.loc 1 1337 0
 892 06ac 010055E3 		cmp	r5, #1
 893 06b0 A7FFFF1A 		bne	.L63
 894              	.LVL71:
1355:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 895              		.loc 1 1355 0
 896 06b4 0020A0E3 		mov	r2, #0
 897 06b8 08019FE5 		ldr	r0, .L70+20
 898 06bc 0810A0E3 		mov	r1, #8
 899 06c0 FEFFFFEB 		bl	_txe_event_flags_set
 900              	.LVL72:
1357:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 901              		.loc 1 1357 0
 902 06c4 002050E2 		subs	r2, r0, #0
 903 06c8 0100001A 		bne	.L69
 904              	.LVL73:
 905              	.L61:
 906              	.LBB43:
 907              	.LBB42:
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1395 0
 909 06cc 0500A0E1 		mov	r0, r5
 910 06d0 A0FFFFEA 		b	.L46
 911              	.LVL74:
 912              	.L69:
 913              	.LBE42:
 914              	.LBE43:
1360:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 915              		.loc 1 1360 0
 916 06d4 FC109FE5 		ldr	r1, .L70+36
 917 06d8 0400A0E3 		mov	r0, #4
 918              	.LVL75:
 919 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 920              	.LVL76:
1361:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 921              		.loc 1 1361 0
 922 06e0 0000A0E3 		mov	r0, #0
 923 06e4 0510A0E1 		mov	r1, r5
 924 06e8 0020A0E1 		mov	r2, r0
 925 06ec FEFFFFEB 		bl	CyU3PUsbStall
1354:../uvc.c      ****                         uvcHandleReq = CyTrue;
 926              		.loc 1 1354 0
 927 06f0 0500A0E1 		mov	r0, r5
 928 06f4 97FFFFEA 		b	.L46
 929              	.LVL77:
 930              	.L68:
1417:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 931              		.loc 1 1417 0
 932 06f8 DC109FE5 		ldr	r1, .L70+40
 933 06fc 0400A0E3 		mov	r0, #4
 934 0700 FEFFFFEB 		bl	CyU3PDebugPrint
1421:../uvc.c      ****                         gpif_initialized = 0;
 935              		.loc 1 1421 0
 936 0704 0080A0E3 		mov	r8, #0
1420:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 937              		.loc 1 1420 0
 938 0708 0600A0E1 		mov	r0, r6
 939 070c FEFFFFEB 		bl	CyU3PGpifDisable
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 940              		.loc 1 1425 0
 941 0710 0610A0E1 		mov	r1, r6
 942 0714 0500A0E1 		mov	r0, r5
1421:../uvc.c      ****                         gpif_initialized = 0;
 943              		.loc 1 1421 0
 944 0718 388087E5 		str	r8, [r7, #56]
1422:../uvc.c      ****                         streamingStarted = CyFalse;
 945              		.loc 1 1422 0
 946 071c 348087E5 		str	r8, [r7, #52]
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 947              		.loc 1 1425 0
 948 0720 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1426:../uvc.c      ****                         CyU3PBusyWait (100);
 949              		.loc 1 1426 0
 950 0724 6400A0E3 		mov	r0, #100
 951 0728 FEFFFFEB 		bl	CyU3PBusyWait
1429:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 952              		.loc 1 1429 0
 953 072c 9C009FE5 		ldr	r0, .L70+28
 954 0730 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1430:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 955              		.loc 1 1430 0
 956 0734 0500A0E1 		mov	r0, r5
 957 0738 FEFFFFEB 		bl	CyU3PUsbFlushEp
1431:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 958              		.loc 1 1431 0
 959 073c 0810A0E1 		mov	r1, r8
 960 0740 0500A0E1 		mov	r0, r5
 961 0744 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1432:../uvc.c      ****                         CyU3PBusyWait (100);
 962              		.loc 1 1432 0
 963 0748 6400A0E3 		mov	r0, #100
 964 074c FEFFFFEB 		bl	CyU3PBusyWait
1435:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 965              		.loc 1 1435 0
 966 0750 0810A0E1 		mov	r1, r8
 967 0754 0620A0E1 		mov	r2, r6
 968 0758 0500A0E1 		mov	r0, r5
 969 075c FEFFFFEB 		bl	CyU3PUsbStall
 970              	.LVL78:
1439:../uvc.c      ****                         CyU3PUsbAckSetup ();
 971              		.loc 1 1439 0
 972 0760 FEFFFFEB 		bl	CyU3PUsbAckSetup
1441:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 973              		.loc 1 1441 0
 974 0764 406087E5 		str	r6, [r7, #64]
 975              	.LBB44:
 976              	.LBB45:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 977              		.loc 1 1259 0
 978 0768 0700A0E1 		mov	r0, r7
 979 076c 0610A0E1 		mov	r1, r6
 980 0770 0420A0E1 		mov	r2, r4
 981 0774 0C308DE2 		add	r3, sp, #12
 982 0778 00808DE5 		str	r8, [sp, #0]
 983 077c FEFFFFEB 		bl	_txe_event_flags_get
 984 0780 005050E2 		subs	r5, r0, #0
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
 985              		.loc 1 1437 0
 986 0784 0600A011 		movne	r0, r6
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 987              		.loc 1 1259 0
 988 0788 72FFFF1A 		bne	.L46
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 989              		.loc 1 1262 0
 990 078c 0110E0E3 		mvn	r1, #1
 991 0790 0420A0E1 		mov	r2, r4
 992 0794 0700A0E1 		mov	r0, r7
 993 0798 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 994              		.loc 1 1265 0
 995 079c 0700A0E1 		mov	r0, r7
 996 07a0 0410A0E1 		mov	r1, r4
 997 07a4 0520A0E1 		mov	r2, r5
 998 07a8 FEFFFFEB 		bl	_txe_event_flags_set
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
 999              		.loc 1 1437 0
 1000 07ac 0600A0E1 		mov	r0, r6
 1001 07b0 68FFFFEA 		b	.L46
 1002              	.L71:
 1003              		.align	2
 1004              	.L70:
 1005 07b4 00000000 		.word	bmReqType
 1006 07b8 00000000 		.word	bRequest
 1007 07bc 00000000 		.word	wValue
 1008 07c0 00000000 		.word	wIndex
 1009 07c4 00000000 		.word	wLength
 1010 07c8 00000000 		.word	.LANCHOR0
 1011 07cc 50010000 		.word	.LC8
 1012 07d0 00000000 		.word	glChHandleUVCStream
 1013 07d4 E4000000 		.word	.LC6
 1014 07d8 1C010000 		.word	.LC7
 1015 07dc 68010000 		.word	.LC9
 1016              	.LBE45:
 1017              	.LBE44:
 1018              		.cfi_endproc
 1019              	.LFE9:
 1021              		.align	2
 1022              		.global	CyFxGpifCB
 1024              	CyFxGpifCB:
 1025              	.LFB12:
1630:../uvc.c      **** {
 1026              		.loc 1 1630 0
 1027              		.cfi_startproc
 1028              		@ args = 0, pretend = 0, frame = 0
 1029              		@ frame_needed = 0, uses_anonymous_args = 0
 1030              	.LVL79:
1631:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1031              		.loc 1 1631 0
 1032 07e0 010050E3 		cmp	r0, #1
1630:../uvc.c      **** {
 1033              		.loc 1 1630 0
 1034 07e4 10402DE9 		stmfd	sp!, {r4, lr}
 1035              	.LCFI8:
 1036              		.cfi_def_cfa_offset 8
1630:../uvc.c      **** {
 1037              		.loc 1 1630 0
 1038 07e8 0120A0E1 		mov	r2, r1
1631:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1039              		.loc 1 1631 0
 1040 07ec 1080BD18 		ldmnefd	sp!, {r4, pc}
 1041              		.cfi_offset 14, -4
 1042              		.cfi_offset 4, -8
1633:../uvc.c      ****         hitFV = CyTrue;
 1043              		.loc 1 1633 0
 1044 07f0 D0109FE5 		ldr	r1, .L88
 1045              	.LVL80:
 1046              	.LBB50:
 1047              	.LBB52:
1530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1048              		.loc 1 1530 0
 1049 07f4 4830D1E5 		ldrb	r3, [r1, #72]	@ zero_extendqisi2
 1050              	.LBE52:
 1051              	.LBE50:
1633:../uvc.c      ****         hitFV = CyTrue;
 1052              		.loc 1 1633 0
 1053 07f8 440081E5 		str	r0, [r1, #68]
 1054              	.LVL81:
 1055              	.LBB56:
 1056              	.LBB51:
1530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1057              		.loc 1 1530 0
 1058 07fc 030053E3 		cmp	r3, #3
 1059 0800 2800000A 		beq	.L87
1554:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1060              		.loc 1 1554 0
 1061 0804 020053E3 		cmp	r3, #2
 1062 0808 1080BD18 		ldmnefd	sp!, {r4, pc}
1556:../uvc.c      ****         switch (stateId)
 1063              		.loc 1 1556 0
 1064 080c 080042E2 		sub	r0, r2, #8
 1065              	.LVL82:
 1066 0810 0A0050E3 		cmp	r0, #10
 1067 0814 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1068 0818 1B0000EA 		b	.L80
 1069              	.L82:
 1070 081c 4C080000 		.word	.L76
 1071 0820 8C080000 		.word	.L80
 1072 0824 8C080000 		.word	.L80
 1073 0828 48080000 		.word	.L72
 1074 082c 8C080000 		.word	.L80
 1075 0830 8C080000 		.word	.L80
 1076 0834 8C080000 		.word	.L80
 1077 0838 84080000 		.word	.L86
 1078 083c 8C080000 		.word	.L80
 1079 0840 8C080000 		.word	.L80
 1080 0844 48080000 		.word	.L72
 1081              	.LVL83:
 1082              	.L72:
 1083 0848 1080BDE8 		ldmfd	sp!, {r4, pc}
 1084              	.LVL84:
 1085              	.L76:
1540:../uvc.c      ****                 socket = 0;
 1086              		.loc 1 1540 0
 1087 084c 0010A0E3 		mov	r1, #0
 1088              	.L77:
 1089              	.LVL85:
1613:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1090              		.loc 1 1613 0
 1091 0850 74009FE5 		ldr	r0, .L88+4
 1092 0854 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1093              	.LVL86:
1614:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1094              		.loc 1 1614 0
 1095 0858 002050E2 		subs	r2, r0, #0
 1096 085c F9FFFF0A 		beq	.L72
1616:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1097              		.loc 1 1616 0
 1098 0860 0400A0E3 		mov	r0, #4
 1099              	.LVL87:
 1100 0864 64109FE5 		ldr	r1, .L88+8
 1101 0868 FEFFFFEB 		bl	CyU3PDebugPrint
 1102              	.LVL88:
 1103              	.L83:
 1104              	.LBB53:
 1105              	.LBB54:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1106              		.loc 1 1246 0
 1107 086c 60109FE5 		ldr	r1, .L88+12
 1108 0870 0400A0E3 		mov	r0, #4
 1109 0874 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 1110              		.loc 1 1247 0
 1111 0878 FA0FA0E3 		mov	r0, #1000
 1112 087c FEFFFFEB 		bl	_tx_thread_sleep
 1113 0880 F9FFFFEA 		b	.L83
 1114              	.LVL89:
 1115              	.L86:
 1116              	.LBE54:
 1117              	.LBE53:
1597:../uvc.c      ****                 socket = 1;
 1118              		.loc 1 1597 0
 1119 0884 0110A0E3 		mov	r1, #1
 1120 0888 F0FFFFEA 		b	.L77
 1121              	.L80:
1602:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1122              		.loc 1 1602 0
 1123 088c 44109FE5 		ldr	r1, .L88+16
 1124 0890 0100A0E3 		mov	r0, #1
 1125 0894 FEFFFFEB 		bl	CyU3PDebugPrint
 1126              	.LVL90:
 1127              	.LBE51:
 1128              	.LBE56:
1635:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1129              		.loc 1 1635 0
 1130 0898 3C109FE5 		ldr	r1, .L88+20
 1131 089c 0400A0E3 		mov	r0, #4
1637:../uvc.c      **** }
 1132              		.loc 1 1637 0
 1133 08a0 1040BDE8 		ldmfd	sp!, {r4, lr}
1635:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1134              		.loc 1 1635 0
 1135 08a4 FEFFFFEA 		b	CyU3PDebugPrint
 1136              	.LVL91:
 1137              	.L87:
 1138              	.LBB57:
 1139              	.LBB55:
1532:../uvc.c      ****         switch (stateId)
 1140              		.loc 1 1532 0
 1141 08a8 0B3042E2 		sub	r3, r2, #11
 1142 08ac 030053E3 		cmp	r3, #3
 1143 08b0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1144 08b4 F4FFFFEA 		b	.L80
 1145              	.L78:
 1146 08b8 4C080000 		.word	.L76
 1147 08bc 84080000 		.word	.L86
 1148 08c0 48080000 		.word	.L72
 1149 08c4 48080000 		.word	.L72
 1150              	.L89:
 1151              		.align	2
 1152              	.L88:
 1153 08c8 00000000 		.word	.LANCHOR0
 1154 08cc 00000000 		.word	glChHandleUVCStream
 1155 08d0 A4010000 		.word	.LC11
 1156 08d4 D4010000 		.word	.LC12
 1157 08d8 8C010000 		.word	.LC10
 1158 08dc E8010000 		.word	.LC13
 1159              	.LBE55:
 1160              	.LBE57:
 1161              		.cfi_endproc
 1162              	.LFE12:
 1164              		.align	2
 1165              		.global	I2CCmdHandler
 1167              	I2CCmdHandler:
 1168              	.LFB0:
 323:../uvc.c      **** void I2CCmdHandler(){
 1169              		.loc 1 323 0
 1170              		.cfi_startproc
 1171              		@ args = 0, pretend = 0, frame = 8
 1172              		@ frame_needed = 0, uses_anonymous_args = 0
 1173 08e0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1174              	.LCFI9:
 1175              		.cfi_def_cfa_offset 36
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1176              		.loc 1 326 0
 1177 08e4 08419FE5 		ldr	r4, .L96
 1178              		.cfi_offset 14, -4
 1179              		.cfi_offset 11, -8
 1180              		.cfi_offset 10, -12
 1181              		.cfi_offset 9, -16
 1182              		.cfi_offset 8, -20
 1183              		.cfi_offset 7, -24
 1184              		.cfi_offset 6, -28
 1185              		.cfi_offset 5, -32
 1186              		.cfi_offset 4, -36
 323:../uvc.c      **** void I2CCmdHandler(){
 1187              		.loc 1 323 0
 1188 08e8 34D04DE2 		sub	sp, sp, #52
 1189              	.LCFI10:
 1190              		.cfi_def_cfa_offset 88
 326:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1191              		.loc 1 326 0
 1192 08ec 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1193              	.LVL92:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1194              		.loc 1 331 0
 1195 08f0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 328:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1196              		.loc 1 328 0
 1197 08f4 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1198              	.LVL93:
 331:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1199              		.loc 1 331 0
 1200 08f8 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1201 08fc 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1202 0900 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1203 0904 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1204 0908 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1205 090c 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1206 0910 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1207 0914 1C208DE5 		str	r2, [sp, #28]
 1208 0918 0400A0E3 		mov	r0, #4
 1209 091c 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 1210 0920 D0109FE5 		ldr	r1, .L96+4
 1211 0924 0520A0E1 		mov	r2, r5
 1212 0928 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1213 092c 08808DE5 		str	r8, [sp, #8]
 1214 0930 0CA08DE5 		str	sl, [sp, #12]
 1215 0934 10908DE5 		str	r9, [sp, #16]
 1216 0938 14B08DE5 		str	fp, [sp, #20]
 1217 093c 18608DE5 		str	r6, [sp, #24]
 1218 0940 20C08DE5 		str	ip, [sp, #32]
 1219 0944 FEFFFFEB 		bl	CyU3PDebugPrint
 1220              	.LVL94:
 335:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1221              		.loc 1 335 0
 1222 0948 000055E3 		cmp	r5, #0
 1223 094c 0300000A 		beq	.L94
 360:../uvc.c      **** 	}else if(CmdType == 1){
 1224              		.loc 1 360 0
 1225 0950 010055E3 		cmp	r5, #1
 1226 0954 1600000A 		beq	.L95
 1227              	.LVL95:
 1228              	.L90:
 375:../uvc.c      **** }
 1229              		.loc 1 375 0
 1230 0958 34D08DE2 		add	sp, sp, #52
 1231 095c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1232              	.LVL96:
 1233              	.L94:
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1234              		.loc 1 351 0
 1235 0960 54C0D4E5 		ldrb	ip, [r4, #84]	@ zero_extendqisi2
 1236 0964 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1237 0968 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1238 096c 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1239              		.loc 1 337 0
 1240 0970 0FE0A0E3 		mov	lr, #15
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1241              		.loc 1 351 0
 1242 0974 00C08DE5 		str	ip, [sp, #0]
 1243 0978 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1244 097c 2CC08DE2 		add	ip, sp, #44
 1245 0980 010080E3 		orr	r0, r0, #1
 1246 0984 011081E3 		orr	r1, r1, #1
 337:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1247              		.loc 1 337 0
 1248 0988 57E0C4E5 		strb	lr, [r4, #87]
 351:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1249              		.loc 1 351 0
 1250 098c 04C08DE5 		str	ip, [sp, #4]
 1251 0990 FEFFFFEB 		bl	SensorRead2B
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1252              		.loc 1 352 0
 1253 0994 2C00DDE5 		ldrb	r0, [sp, #44]	@ zero_extendqisi2
 353:../uvc.c      **** 			if(CmdDataLen == 2){
 1254              		.loc 1 353 0
 1255 0998 020056E3 		cmp	r6, #2
 352:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1256              		.loc 1 352 0
 1257 099c 5500C4E5 		strb	r0, [r4, #85]
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1258              		.loc 1 354 0
 1259 09a0 2D00DD05 		ldreqb	r0, [sp, #45]	@ zero_extendqisi2
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1260              		.loc 1 356 0
 1261 09a4 0030E0E3 		mvn	r3, #0
 354:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1262              		.loc 1 354 0
 1263 09a8 5600C405 		streqb	r0, [r4, #86]
 356:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1264              		.loc 1 356 0
 1265 09ac 5730C4E5 		strb	r3, [r4, #87]
 1266 09b0 E8FFFFEA 		b	.L90
 1267              	.L95:
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1268              		.loc 1 369 0
 1269 09b4 54C0D4E5 		ldrb	ip, [r4, #84]	@ zero_extendqisi2
 1270 09b8 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1271 09bc 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 362:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1272              		.loc 1 362 0
 1273 09c0 5550D4E5 		ldrb	r5, [r4, #85]	@ zero_extendqisi2
 1274              	.LVL97:
 363:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1275              		.loc 1 363 0
 1276 09c4 56E0D4E5 		ldrb	lr, [r4, #86]	@ zero_extendqisi2
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1277              		.loc 1 369 0
 1278 09c8 00C08DE5 		str	ip, [sp, #0]
 1279 09cc 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1280 09d0 2CC08DE2 		add	ip, sp, #44
 1281 09d4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1282 09d8 FE1001E2 		and	r1, r1, #254
 1283 09dc FE0000E2 		and	r0, r0, #254
 362:../uvc.c      **** 			buf[0] = I2CCMDArry[9];
 1284              		.loc 1 362 0
 1285 09e0 2C50CDE5 		strb	r5, [sp, #44]
 363:../uvc.c      **** 			buf[1] = I2CCMDArry[10];
 1286              		.loc 1 363 0
 1287 09e4 2DE0CDE5 		strb	lr, [sp, #45]
 369:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1288              		.loc 1 369 0
 1289 09e8 04C08DE5 		str	ip, [sp, #4]
 1290 09ec FEFFFFEB 		bl	SensorWrite2B
 1291 09f0 D8FFFFEA 		b	.L90
 1292              	.L97:
 1293              		.align	2
 1294              	.L96:
 1295 09f4 00000000 		.word	.LANCHOR0
 1296 09f8 FC010000 		.word	.LC14
 1297              		.cfi_endproc
 1298              	.LFE0:
 1300              		.align	2
 1301              		.global	setIrisauto
 1303              	setIrisauto:
 1304              	.LFB1:
 381:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1305              		.loc 1 381 0
 1306              		.cfi_startproc
 1307              		@ args = 0, pretend = 0, frame = 0
 1308              		@ frame_needed = 0, uses_anonymous_args = 0
 1309              	.LVL98:
 1310 09fc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1311              	.LCFI11:
 1312              		.cfi_def_cfa_offset 16
 1313 0a00 0160A0E1 		mov	r6, r1
 1314              		.cfi_offset 14, -4
 1315              		.cfi_offset 6, -8
 1316              		.cfi_offset 5, -12
 1317              		.cfi_offset 4, -16
 1318 0a04 08D04DE2 		sub	sp, sp, #8
 1319              	.LCFI12:
 1320              		.cfi_def_cfa_offset 24
 381:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1321              		.loc 1 381 0
 1322 0a08 0040A0E1 		mov	r4, r0
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1323              		.loc 1 385 0
 1324 0a0c 0050A0E3 		mov	r5, #0
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1325              		.loc 1 384 0
 1326 0a10 0010E0E3 		mvn	r1, #0
 1327              	.LVL99:
 1328 0a14 1C0090E5 		ldr	r0, [r0, #28]
 1329              	.LVL100:
 1330 0a18 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1331              		.loc 1 385 0
 1332 0a1c 060065E0 		rsb	r0, r5, r6
 1333 0a20 00C070E2 		rsbs	ip, r0, #0
 1334 0a24 00C0ACE0 		adc	ip, ip, r0
 1335 0a28 2010A0E3 		mov	r1, #32
 1336 0a2c 2720A0E3 		mov	r2, #39
 1337 0a30 3030A0E3 		mov	r3, #48
 1338 0a34 0400A0E1 		mov	r0, r4
 1339 0a38 00C08DE5 		str	ip, [sp, #0]
 1340 0a3c 04508DE5 		str	r5, [sp, #4]
 1341 0a40 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1342              		.loc 1 386 0
 1343 0a44 050056E1 		cmp	r6, r5
 1344 0a48 0260A003 		moveq	r6, #2
 1345 0a4c 0160A013 		movne	r6, #1
 1346 0a50 0400A0E1 		mov	r0, r4
 1347 0a54 2110A0E3 		mov	r1, #33
 1348 0a58 2520A0E3 		mov	r2, #37
 1349 0a5c 3030A0E3 		mov	r3, #48
 1350 0a60 00608DE5 		str	r6, [sp, #0]
 1351 0a64 04508DE5 		str	r5, [sp, #4]
 1352 0a68 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1353              		.loc 1 387 0
 1354 0a6c 1C0094E5 		ldr	r0, [r4, #28]
 388:../uvc.c      **** }
 1355              		.loc 1 388 0
 1356 0a70 08D08DE2 		add	sp, sp, #8
 1357 0a74 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1358              		.loc 1 387 0
 1359 0a78 FEFFFFEA 		b	_txe_mutex_put
 1360              		.cfi_endproc
 1361              	.LFE1:
 1363              		.align	2
 1364              		.global	ControlHandle
 1366              	ControlHandle:
 1367              	.LFB2:
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1368              		.loc 1 390 0
 1369              		.cfi_startproc
 1370              		@ args = 0, pretend = 0, frame = 24
 1371              		@ frame_needed = 0, uses_anonymous_args = 0
 1372              	.LVL101:
 1373 0a7c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1374              	.LCFI13:
 1375              		.cfi_def_cfa_offset 36
 397:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1376              		.loc 1 397 0
 1377 0a80 230050E3 		cmp	r0, #35
 396:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1378              		.loc 1 396 0
 1379 0a84 207040E2 		sub	r7, r0, #32
 1380              		.cfi_offset 14, -4
 1381              		.cfi_offset 11, -8
 1382              		.cfi_offset 10, -12
 1383              		.cfi_offset 9, -16
 1384              		.cfi_offset 8, -20
 1385              		.cfi_offset 7, -24
 1386              		.cfi_offset 6, -28
 1387              		.cfi_offset 5, -32
 1388              		.cfi_offset 4, -36
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1389              		.loc 1 390 0
 1390 0a88 2CD04DE2 		sub	sp, sp, #44
 1391              	.LCFI14:
 1392              		.cfi_def_cfa_offset 80
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1393              		.loc 1 390 0
 1394 0a8c 0040A0E1 		mov	r4, r0
 396:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1395              		.loc 1 396 0
 1396 0a90 FF7007E2 		and	r7, r7, #255
 1397              	.LVL102:
 397:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1398              		.loc 1 397 0
 1399 0a94 2400009A 		bls	.L102
 398:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1400              		.loc 1 398 0
 1401 0a98 586F9FE5 		ldr	r6, .L211
 1402 0a9c 872087E0 		add	r2, r7, r7, asl #1
 1403 0aa0 8221A0E1 		mov	r2, r2, asl #3
 1404 0aa4 023086E0 		add	r3, r6, r2
 399:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1405              		.loc 1 399 0
 1406 0aa8 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 400:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1407              		.loc 1 400 0
 1408 0aac 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 401:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1409              		.loc 1 401 0
 1410 0ab0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 412:../uvc.c      ****     reqData = bRequest;
 1411              		.loc 1 412 0
 1412 0ab4 403F9FE5 		ldr	r3, .L211+4
 398:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1413              		.loc 1 398 0
 1414 0ab8 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1415              	.LVL103:
 412:../uvc.c      ****     reqData = bRequest;
 1416              		.loc 1 412 0
 1417 0abc 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1418              	.LVL104:
 420:../uvc.c      ****     switch (bRequest)
 1419              		.loc 1 420 0
 1420 0ac0 830055E3 		cmp	r5, #131
 1421 0ac4 2300000A 		beq	.L108
 1422              	.LVL105:
 1423              	.L206:
 1424 0ac8 2C00009A 		bls	.L204
 1425 0acc 850055E3 		cmp	r5, #133
 1426 0ad0 8B00000A 		beq	.L110
 1427 0ad4 7900003A 		bcc	.L109
 1428 0ad8 860055E3 		cmp	r5, #134
 1429 0adc C800000A 		beq	.L111
 1430 0ae0 870055E3 		cmp	r5, #135
 1431 0ae4 BC00000A 		beq	.L205
 1432              	.L104:
 896:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1433              		.loc 1 896 0
 1434 0ae8 0000A0E3 		mov	r0, #0
 1435 0aec 0110A0E3 		mov	r1, #1
 1436 0af0 0020A0E1 		mov	r2, r0
 1437 0af4 FEFFFFEB 		bl	CyU3PUsbStall
 897:../uvc.c      **** 			  break;
 1438              		.loc 1 897 0
 1439 0af8 FFC0A0E3 		mov	ip, #255
 1440 0afc 0C70A0E1 		mov	r7, ip
 1441              	.LVL106:
 1442 0b00 0CE0A0E1 		mov	lr, ip
 1443 0b04 0C40A0E1 		mov	r4, ip
 1444              	.LVL107:
 1445              	.L114:
 899:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1446              		.loc 1 899 0
 1447 0b08 F01E9FE5 		ldr	r1, .L211+8
 1448 0b0c 0520A0E1 		mov	r2, r5
 1449 0b10 0430A0E1 		mov	r3, r4
 1450 0b14 0400A0E3 		mov	r0, #4
 1451 0b18 00E08DE5 		str	lr, [sp, #0]
 1452 0b1c 80108DE9 		stmib	sp, {r7, ip}	@ phole stm
 1453 0b20 FEFFFFEB 		bl	CyU3PDebugPrint
 900:../uvc.c      **** }
 1454              		.loc 1 900 0
 1455 0b24 2CD08DE2 		add	sp, sp, #44
 1456 0b28 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1457              	.LVL108:
 1458              	.L102:
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1459              		.loc 1 403 0
 1460 0b2c C46E9FE5 		ldr	r6, .L211
 412:../uvc.c      ****     reqData = bRequest;
 1461              		.loc 1 412 0
 1462 0b30 C43E9FE5 		ldr	r3, .L211+4
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1463              		.loc 1 403 0
 1464 0b34 805080E0 		add	r5, r0, r0, asl #1
 1465 0b38 850186E0 		add	r0, r6, r5, asl #3
 1466              	.LVL109:
 412:../uvc.c      ****     reqData = bRequest;
 1467              		.loc 1 412 0
 1468 0b3c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 403:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1469              		.loc 1 403 0
 1470 0b40 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1471              	.LVL110:
 420:../uvc.c      ****     switch (bRequest)
 1472              		.loc 1 420 0
 1473 0b44 830055E3 		cmp	r5, #131
 404:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1474              		.loc 1 404 0
 1475 0b48 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1476              	.LVL111:
 405:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1477              		.loc 1 405 0
 1478 0b4c 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1479              	.LVL112:
 406:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1480              		.loc 1 406 0
 1481 0b50 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1482              	.LVL113:
 420:../uvc.c      ****     switch (bRequest)
 1483              		.loc 1 420 0
 1484 0b54 DBFFFF1A 		bne	.L206
 1485              	.LVL114:
 1486              	.L108:
 543:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1487              		.loc 1 543 0
 1488 0b58 230054E3 		cmp	r4, #35
 1489 0b5c C600009A 		bls	.L138
 544:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1490              		.loc 1 544 0
 1491 0b60 870087E0 		add	r0, r7, r7, asl #1
 1492 0b64 806186E0 		add	r6, r6, r0, asl #3
 1493 0b68 94AE9FE5 		ldr	sl, .L211+12
 1494 0b6c 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
 545:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1495              		.loc 1 545 0
 1496 0b70 06E0D6E5 		ldrb	lr, [r6, #6]	@ zero_extendqisi2
 544:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1497              		.loc 1 544 0
 1498 0b74 58C0CAE5 		strb	ip, [sl, #88]
 545:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1499              		.loc 1 545 0
 1500 0b78 59E0CAE5 		strb	lr, [sl, #89]
 1501 0b7c 0B0000EA 		b	.L146
 1502              	.L204:
 420:../uvc.c      ****     switch (bRequest)
 1503              		.loc 1 420 0
 1504 0b80 810055E3 		cmp	r5, #129
 1505 0b84 6A00000A 		beq	.L106
 1506 0b88 1000009A 		bls	.L207
 524:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1507              		.loc 1 524 0
 1508 0b8c 230054E3 		cmp	r4, #35
 1509 0b90 AD00009A 		bls	.L135
 525:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1510              		.loc 1 525 0
 1511 0b94 87A087E0 		add	sl, r7, r7, asl #1
 1512 0b98 8A6186E0 		add	r6, r6, sl, asl #3
 1513 0b9c 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 1514 0ba0 5CAE9FE5 		ldr	sl, .L211+12
 526:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1515              		.loc 1 526 0
 1516 0ba4 0470D6E5 		ldrb	r7, [r6, #4]	@ zero_extendqisi2
 1517              	.LVL115:
 525:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1518              		.loc 1 525 0
 1519 0ba8 5840CAE5 		strb	r4, [sl, #88]
 526:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1520              		.loc 1 526 0
 1521 0bac 5970CAE5 		strb	r7, [sl, #89]
 1522              	.L146:
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1523              		.loc 1 602 0
 1524 0bb0 0800A0E1 		mov	r0, r8
 1525 0bb4 4C1E9FE5 		ldr	r1, .L211+16
 1526 0bb8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1527              	.LVL116:
 604:../uvc.c      **** 			  break;
 1528              		.loc 1 604 0
 1529 0bbc FFC0A0E3 		mov	ip, #255
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1530              		.loc 1 602 0
 1531 0bc0 5870DAE5 		ldrb	r7, [sl, #88]	@ zero_extendqisi2
 604:../uvc.c      **** 			  break;
 1532              		.loc 1 604 0
 1533 0bc4 0CE0A0E1 		mov	lr, ip
 1534 0bc8 0C40A0E1 		mov	r4, ip
 1535 0bcc CDFFFFEA 		b	.L114
 1536              	.LVL117:
 1537              	.L207:
 420:../uvc.c      ****     switch (bRequest)
 1538              		.loc 1 420 0
 1539 0bd0 010055E3 		cmp	r5, #1
 1540 0bd4 C3FFFF1A 		bne	.L104
 606:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1541              		.loc 1 606 0
 1542 0bd8 241E9FE5 		ldr	r1, .L211+12
 1543 0bdc 26208DE2 		add	r2, sp, #38
 1544 0be0 2000A0E3 		mov	r0, #32
 1545 0be4 581081E2 		add	r1, r1, #88
 1546 0be8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1547              	.LVL118:
 608:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1548              		.loc 1 608 0
 1549 0bec 002050E2 		subs	r2, r0, #0
 1550 0bf0 4E03001A 		bne	.L148
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1551              		.loc 1 611 0
 1552 0bf4 08CE9FE5 		ldr	ip, .L211+12
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1553              		.loc 1 610 0
 1554 0bf8 040E9FE5 		ldr	r0, .L211+12
 1555              	.LVL119:
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1556              		.loc 1 611 0
 1557 0bfc 59E0DCE5 		ldrb	lr, [ip, #89]	@ zero_extendqisi2
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1558              		.loc 1 613 0
 1559 0c00 FC2D9FE5 		ldr	r2, .L211+12
 1560              	.LVL120:
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1561              		.loc 1 610 0
 1562 0c04 5830D0E5 		ldrb	r3, [r0, #88]	@ zero_extendqisi2
 611:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1563              		.loc 1 611 0
 1564 0c08 1CE08DE5 		str	lr, [sp, #28]
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1565              		.loc 1 613 0
 1566 0c0c 5AE0D2E5 		ldrb	lr, [r2, #90]	@ zero_extendqisi2
 610:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1567              		.loc 1 610 0
 1568 0c10 14308DE5 		str	r3, [sp, #20]
 1569              	.LVL121:
 613:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1570              		.loc 1 613 0
 1571 0c14 18E08DE5 		str	lr, [sp, #24]
 1572              	.LVL122:
 617:../uvc.c      **** 				  switch(CtrlID)
 1573              		.loc 1 617 0
 1574 0c18 260054E3 		cmp	r4, #38
 1575 0c1c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1576 0c20 B30200EA 		b	.L149
 1577              	.L165:
 1578 0c24 34160000 		.word	.L150
 1579 0c28 70150000 		.word	.L151
 1580 0c2c F4160000 		.word	.L149
 1581 0c30 F4160000 		.word	.L149
 1582 0c34 0C150000 		.word	.L152
 1583 0c38 CC130000 		.word	.L153
 1584 0c3c 50130000 		.word	.L154
 1585 0c40 F4160000 		.word	.L149
 1586 0c44 F4160000 		.word	.L149
 1587 0c48 F4160000 		.word	.L149
 1588 0c4c F4160000 		.word	.L149
 1589 0c50 C8120000 		.word	.L155
 1590 0c54 F4160000 		.word	.L149
 1591 0c58 F4160000 		.word	.L149
 1592 0c5c F4160000 		.word	.L149
 1593 0c60 F4160000 		.word	.L149
 1594 0c64 AC180000 		.word	.L156
 1595 0c68 F4160000 		.word	.L149
 1596 0c6c F4160000 		.word	.L149
 1597 0c70 F4160000 		.word	.L149
 1598 0c74 F4160000 		.word	.L149
 1599 0c78 F4160000 		.word	.L149
 1600 0c7c F4160000 		.word	.L149
 1601 0c80 F4160000 		.word	.L149
 1602 0c84 F4160000 		.word	.L149
 1603 0c88 08180000 		.word	.L157
 1604 0c8c 6C170000 		.word	.L158
 1605 0c90 F4160000 		.word	.L149
 1606 0c94 5C170000 		.word	.L159
 1607 0c98 F4160000 		.word	.L149
 1608 0c9c 6C120000 		.word	.L160
 1609 0ca0 E8110000 		.word	.L161
 1610 0ca4 F4160000 		.word	.L149
 1611 0ca8 F4160000 		.word	.L149
 1612 0cac F4160000 		.word	.L149
 1613 0cb0 F4160000 		.word	.L149
 1614 0cb4 4C110000 		.word	.L162
 1615 0cb8 34110000 		.word	.L163
 1616 0cbc D0100000 		.word	.L164
 1617              	.LVL123:
 1618              	.L109:
 561:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1619              		.loc 1 561 0
 1620 0cc0 230054E3 		cmp	r4, #35
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1621              		.loc 1 562 0
 1622 0cc4 87708780 		addhi	r7, r7, r7, asl #1
 1623              	.LVL124:
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1624              		.loc 1 568 0
 1625 0cc8 84408490 		addls	r4, r4, r4, asl #1
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1626              		.loc 1 562 0
 1627 0ccc 87618680 		addhi	r6, r6, r7, asl #3
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1628              		.loc 1 568 0
 1629 0cd0 84618690 		addls	r6, r6, r4, asl #3
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1630              		.loc 1 562 0
 1631 0cd4 28AD9F85 		ldrhi	sl, .L211+12
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1632              		.loc 1 568 0
 1633 0cd8 24AD9F95 		ldrls	sl, .L211+12
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1634              		.loc 1 562 0
 1635 0cdc 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 563:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1636              		.loc 1 563 0
 1637 0ce0 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1638              		.loc 1 568 0
 1639 0ce4 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 569:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1640              		.loc 1 569 0
 1641 0ce8 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 570:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1642              		.loc 1 570 0
 1643 0cec 0030A0E3 		mov	r3, #0
 568:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1644              		.loc 1 568 0
 1645 0cf0 5810CAE5 		strb	r1, [sl, #88]
 569:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1646              		.loc 1 569 0
 1647 0cf4 5920CAE5 		strb	r2, [sl, #89]
 570:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1648              		.loc 1 570 0
 1649 0cf8 5A30CAE5 		strb	r3, [sl, #90]
 571:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1650              		.loc 1 571 0
 1651 0cfc 5B30CAE5 		strb	r3, [sl, #91]
 1652 0d00 AAFFFFEA 		b	.L146
 1653              	.LVL125:
 1654              	.L110:
 424:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1655              		.loc 1 424 0
 1656 0d04 F84C9FE5 		ldr	r4, .L211+12
 425:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1657              		.loc 1 425 0
 1658 0d08 00C0A0E3 		mov	ip, #0
 1659 0d0c 59C0C4E5 		strb	ip, [r4, #89]
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1660              		.loc 1 426 0
 1661 0d10 581084E2 		add	r1, r4, #88
 424:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1662              		.loc 1 424 0
 1663 0d14 5880C4E5 		strb	r8, [r4, #88]
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1664              		.loc 1 426 0
 1665 0d18 0200A0E3 		mov	r0, #2
 1666 0d1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1667              	.LVL126:
 428:../uvc.c      **** 			  break;
 1668              		.loc 1 428 0
 1669 0d20 FFC0A0E3 		mov	ip, #255
 426:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1670              		.loc 1 426 0
 1671 0d24 5870D4E5 		ldrb	r7, [r4, #88]	@ zero_extendqisi2
 1672              	.LVL127:
 428:../uvc.c      **** 			  break;
 1673              		.loc 1 428 0
 1674 0d28 0CE0A0E1 		mov	lr, ip
 1675 0d2c 0C40A0E1 		mov	r4, ip
 1676 0d30 74FFFFEA 		b	.L114
 1677              	.LVL128:
 1678              	.L106:
 431:../uvc.c      **** 			 switch(CtrlID)
 1679              		.loc 1 431 0
 1680 0d34 011044E2 		sub	r1, r4, #1
 1681 0d38 250051E3 		cmp	r1, #37
 1682 0d3c 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1683 0d40 D00000EA 		b	.L115
 1684              	.L123:
 1685 0d44 58100000 		.word	.L116
 1686 0d48 88100000 		.word	.L115
 1687 0d4c 88100000 		.word	.L115
 1688 0d50 88100000 		.word	.L115
 1689 0d54 38100000 		.word	.L117
 1690 0d58 88100000 		.word	.L115
 1691 0d5c 88100000 		.word	.L115
 1692 0d60 88100000 		.word	.L115
 1693 0d64 88100000 		.word	.L115
 1694 0d68 88100000 		.word	.L115
 1695 0d6c AC100000 		.word	.L118
 1696 0d70 88100000 		.word	.L115
 1697 0d74 88100000 		.word	.L115
 1698 0d78 88100000 		.word	.L115
 1699 0d7c 88100000 		.word	.L115
 1700 0d80 88100000 		.word	.L115
 1701 0d84 88100000 		.word	.L115
 1702 0d88 88100000 		.word	.L115
 1703 0d8c 88100000 		.word	.L115
 1704 0d90 88100000 		.word	.L115
 1705 0d94 88100000 		.word	.L115
 1706 0d98 88100000 		.word	.L115
 1707 0d9c 88100000 		.word	.L115
 1708 0da0 88100000 		.word	.L115
 1709 0da4 FC0F0000 		.word	.L119
 1710 0da8 88100000 		.word	.L115
 1711 0dac 88100000 		.word	.L115
 1712 0db0 D00F0000 		.word	.L120
 1713 0db4 88100000 		.word	.L115
 1714 0db8 88100000 		.word	.L115
 1715 0dbc 340F0000 		.word	.L121
 1716 0dc0 88100000 		.word	.L115
 1717 0dc4 88100000 		.word	.L115
 1718 0dc8 88100000 		.word	.L115
 1719 0dcc 88100000 		.word	.L115
 1720 0dd0 F80E0000 		.word	.L122
 1721 0dd4 F80E0000 		.word	.L122
 1722 0dd8 F80E0000 		.word	.L122
 1723              	.L205:
 588:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1724              		.loc 1 588 0
 1725 0ddc 230054E3 		cmp	r4, #35
 1726 0de0 3100009A 		bls	.L145
 589:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1727              		.loc 1 589 0
 1728 0de4 877087E0 		add	r7, r7, r7, asl #1
 1729              	.LVL129:
 1730 0de8 876186E0 		add	r6, r6, r7, asl #3
 1731 0dec 10AC9FE5 		ldr	sl, .L211+12
 1732 0df0 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 590:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1733              		.loc 1 590 0
 1734 0df4 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 589:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1735              		.loc 1 589 0
 1736 0df8 5820CAE5 		strb	r2, [sl, #88]
 590:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1737              		.loc 1 590 0
 1738 0dfc 5910CAE5 		strb	r1, [sl, #89]
 1739 0e00 6AFFFFEA 		b	.L146
 1740              	.LVL130:
 1741              	.L111:
 577:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1742              		.loc 1 577 0
 1743 0e04 230054E3 		cmp	r4, #35
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1744              		.loc 1 578 0
 1745 0e08 87708780 		addhi	r7, r7, r7, asl #1
 1746              	.LVL131:
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1747              		.loc 1 581 0
 1748 0e0c 84408490 		addls	r4, r4, r4, asl #1
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1749              		.loc 1 578 0
 1750 0e10 87618680 		addhi	r6, r6, r7, asl #3
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1751              		.loc 1 581 0
 1752 0e14 84618690 		addls	r6, r6, r4, asl #3
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1753              		.loc 1 578 0
 1754 0e18 E48B9F85 		ldrhi	r8, .L211+12
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1755              		.loc 1 581 0
 1756 0e1c E08B9F95 		ldrls	r8, .L211+12
 578:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1757              		.loc 1 578 0
 1758 0e20 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1759              		.loc 1 581 0
 1760 0e24 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1761              		.loc 1 583 0
 1762 0e28 0100A0E3 		mov	r0, #1
 581:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1763              		.loc 1 581 0
 1764 0e2c 5830C8E5 		strb	r3, [r8, #88]
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1765              		.loc 1 583 0
 1766 0e30 D01B9FE5 		ldr	r1, .L211+16
 1767 0e34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1768              	.LVL132:
 586:../uvc.c      **** 			  break;
 1769              		.loc 1 586 0
 1770 0e38 FFC0A0E3 		mov	ip, #255
 583:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1771              		.loc 1 583 0
 1772 0e3c 5870D8E5 		ldrb	r7, [r8, #88]	@ zero_extendqisi2
 586:../uvc.c      **** 			  break;
 1773              		.loc 1 586 0
 1774 0e40 0CE0A0E1 		mov	lr, ip
 1775 0e44 0C40A0E1 		mov	r4, ip
 1776 0e48 2EFFFFEA 		b	.L114
 1777              	.LVL133:
 1778              	.L135:
 529:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1779              		.loc 1 529 0
 1780 0e4c 0B0054E3 		cmp	r4, #11
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1781              		.loc 1 536 0
 1782 0e50 84408410 		addne	r4, r4, r4, asl #1
 1783 0e54 84618610 		addne	r6, r6, r4, asl #3
 1784 0e58 A4AB9F15 		ldrne	sl, .L211+12
 530:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1785              		.loc 1 530 0
 1786 0e5c A0AB9F05 		ldreq	sl, .L211+12
 1787 0e60 A43B9F05 		ldreq	r3, .L211+20
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1788              		.loc 1 536 0
 1789 0e64 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 537:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1790              		.loc 1 537 0
 1791 0e68 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 530:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1792              		.loc 1 530 0
 1793 0e6c 58308A05 		streq	r3, [sl, #88]
 536:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1794              		.loc 1 536 0
 1795 0e70 5820CA15 		strneb	r2, [sl, #88]
 537:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1796              		.loc 1 537 0
 1797 0e74 5930CA15 		strneb	r3, [sl, #89]
 1798 0e78 4CFFFFEA 		b	.L146
 1799              	.L138:
 547:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1800              		.loc 1 547 0
 1801 0e7c 0B0054E3 		cmp	r4, #11
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1802              		.loc 1 554 0
 1803 0e80 84408410 		addne	r4, r4, r4, asl #1
 1804 0e84 84618610 		addne	r6, r6, r4, asl #3
 1805 0e88 74AB9F15 		ldrne	sl, .L211+12
 548:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1806              		.loc 1 548 0
 1807 0e8c 70AB9F05 		ldreq	sl, .L211+12
 1808 0e90 783B9F05 		ldreq	r3, .L211+24
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1809              		.loc 1 554 0
 1810 0e94 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 555:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1811              		.loc 1 555 0
 1812 0e98 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 548:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1813              		.loc 1 548 0
 1814 0e9c 58308A05 		streq	r3, [sl, #88]
 554:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1815              		.loc 1 554 0
 1816 0ea0 5820CA15 		strneb	r2, [sl, #88]
 555:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1817              		.loc 1 555 0
 1818 0ea4 5930CA15 		strneb	r3, [sl, #89]
 1819 0ea8 40FFFFEA 		b	.L146
 1820              	.L145:
 593:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1821              		.loc 1 593 0
 1822 0eac 0B0054E3 		cmp	r4, #11
 1823 0eb0 0700000A 		beq	.L208
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1824              		.loc 1 599 0
 1825 0eb4 84A084E0 		add	sl, r4, r4, asl #1
 1826 0eb8 8A6186E0 		add	r6, r6, sl, asl #3
 1827 0ebc 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1828 0ec0 3CAB9FE5 		ldr	sl, .L211+12
 600:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1829              		.loc 1 600 0
 1830 0ec4 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1831              		.loc 1 599 0
 1832 0ec8 5830CAE5 		strb	r3, [sl, #88]
 600:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1833              		.loc 1 600 0
 1834 0ecc 5900CAE5 		strb	r0, [sl, #89]
 1835 0ed0 36FFFFEA 		b	.L146
 1836              	.L208:
 594:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1837              		.loc 1 594 0
 1838 0ed4 28AB9FE5 		ldr	sl, .L211+12
 1839 0ed8 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 596:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1840              		.loc 1 596 0
 1841 0edc 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 595:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1842              		.loc 1 595 0
 1843 0ee0 0040A0E3 		mov	r4, #0
 594:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1844              		.loc 1 594 0
 1845 0ee4 58C0CAE5 		strb	ip, [sl, #88]
 595:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1846              		.loc 1 595 0
 1847 0ee8 5940CAE5 		strb	r4, [sl, #89]
 596:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1848              		.loc 1 596 0
 1849 0eec 5AE0CAE5 		strb	lr, [sl, #90]
 597:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1850              		.loc 1 597 0
 1851 0ef0 5B40CAE5 		strb	r4, [sl, #91]
 1852 0ef4 2DFFFFEA 		b	.L146
 1853              	.L122:
 437:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1854              		.loc 1 437 0
 1855 0ef8 877087E0 		add	r7, r7, r7, asl #1
 1856              	.LVL134:
 1857 0efc 876186E0 		add	r6, r6, r7, asl #3
 1858 0f00 FCEA9FE5 		ldr	lr, .L211+12
 1859 0f04 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 438:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1860              		.loc 1 438 0
 1861 0f08 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 437:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1862              		.loc 1 437 0
 1863 0f0c 5840CEE5 		strb	r4, [lr, #88]
 438:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1864              		.loc 1 438 0
 1865 0f10 5960CEE5 		strb	r6, [lr, #89]
 1866              	.LVL135:
 1867              	.L126:
 517:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1868              		.loc 1 517 0
 1869 0f14 0800A0E1 		mov	r0, r8
 1870 0f18 E81A9FE5 		ldr	r1, .L211+16
 1871 0f1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 522:../uvc.c      **** 			  break;
 1872              		.loc 1 522 0
 1873 0f20 FFE0A0E3 		mov	lr, #255
 517:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1874              		.loc 1 517 0
 1875 0f24 0470A0E1 		mov	r7, r4
 1876 0f28 06C0A0E1 		mov	ip, r6
 522:../uvc.c      **** 			  break;
 1877              		.loc 1 522 0
 1878 0f2c 0E40A0E1 		mov	r4, lr
 1879              	.LVL136:
 1880 0f30 F4FEFFEA 		b	.L114
 1881              	.LVL137:
 1882              	.L121:
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1883              		.loc 1 458 0 discriminator 1
 1884 0f34 000058E3 		cmp	r8, #0
 1885 0f38 A702000A 		beq	.L199
 456:../uvc.c      **** 					 break;
 1886              		.loc 1 456 0
 1887 0f3c 28E1A0E1 		mov	lr, r8, lsr #2
 1888 0f40 00005EE3 		cmp	lr, #0
 1889 0f44 03005813 		cmpne	r8, #3
 1890 0f48 0020A083 		movhi	r2, #0
 1891 0f4c 0120A093 		movls	r2, #1
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1892              		.loc 1 390 0
 1893 0f50 0E31A0E1 		mov	r3, lr, asl #2
 456:../uvc.c      **** 					 break;
 1894              		.loc 1 456 0
 1895 0f54 A402009A 		bls	.L187
 1896 0f58 A81A9FE5 		ldr	r1, .L211+16
 1897 0f5c 0C0041E2 		sub	r0, r1, #12
 1898              	.LVL138:
 1899              	.L130:
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1900              		.loc 1 459 0 discriminator 2
 1901 0f60 044090E4 		ldr	r4, [r0], #4
 1902 0f64 01C082E2 		add	ip, r2, #1
 1903 0f68 FF200CE2 		and	r2, ip, #255
 1904 0f6c 02005EE1 		cmp	lr, r2
 1905 0f70 044081E4 		str	r4, [r1], #4
 1906 0f74 F9FFFF8A 		bhi	.L130
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1907              		.loc 1 459 0 is_stmt 0
 1908 0f78 030058E1 		cmp	r8, r3
 1909 0f7c 800A9F15 		ldrne	r0, .L211+12
 1910 0f80 9502000A 		beq	.L199
 1911              	.L191:
 1912 0f84 03E080E0 		add	lr, r0, r3
 1913 0f88 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1914              		.loc 1 458 0 is_stmt 1
 1915 0f8c 016083E2 		add	r6, r3, #1
 1916 0f90 FF3006E2 		and	r3, r6, #255
 1917              	.LVL139:
 1918 0f94 030058E1 		cmp	r8, r3
 459:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1919              		.loc 1 459 0
 1920 0f98 5810CEE5 		strb	r1, [lr, #88]
 458:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1921              		.loc 1 458 0
 1922 0f9c F8FFFF8A 		bhi	.L191
 1923              	.LVL140:
 1924              	.L125:
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1925              		.loc 1 468 0
 1926 0fa0 5770D0E5 		ldrb	r7, [r0, #87]	@ zero_extendqisi2
 1927              	.LVL141:
 461:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1928              		.loc 1 461 0
 1929 0fa4 583A9FE5 		ldr	r3, .L211+12
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1930              		.loc 1 468 0
 1931 0fa8 FF0057E3 		cmp	r7, #255
 461:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1932              		.loc 1 461 0
 1933 0fac 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1934              	.LVL142:
 462:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1935              		.loc 1 462 0
 1936 0fb0 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 1937              	.LVL143:
 468:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1938              		.loc 1 468 0
 1939 0fb4 D6FFFF0A 		beq	.L126
 470:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1940              		.loc 1 470 0
 1941 0fb8 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1942 0fbc 501A9FE5 		ldr	r1, .L211+28
 1943 0fc0 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1944 0fc4 0400A0E3 		mov	r0, #4
 1945 0fc8 FEFFFFEB 		bl	CyU3PDebugPrint
 1946 0fcc D0FFFFEA 		b	.L126
 1947              	.LVL144:
 1948              	.L120:
 444:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 1949              		.loc 1 444 0
 1950 0fd0 2D34D6E5 		ldrb	r3, [r6, #1069]	@ zero_extendqisi2
 1951              	.LVL145:
 446:../uvc.c      **** 						if(sendData >= 3){
 1952              		.loc 1 446 0
 1953 0fd4 020053E3 		cmp	r3, #2
 1954 0fd8 04308392 		addls	r3, r3, #4
 1955              	.LVL146:
 1956 0fdc FF400392 		andls	r4, r3, #255
 1957 0fe0 7402008A 		bhi	.L209
 1958              	.L134:
 1959              	.LVL147:
 491:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 1960              		.loc 1 491 0
 1961 0fe4 183A9FE5 		ldr	r3, .L211+12
 492:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1962              		.loc 1 492 0
 1963 0fe8 0010A0E3 		mov	r1, #0
 491:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 1964              		.loc 1 491 0
 1965 0fec 5840C3E5 		strb	r4, [r3, #88]
 492:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1966              		.loc 1 492 0
 1967 0ff0 5910C3E5 		strb	r1, [r3, #89]
 1968              	.LVL148:
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 1969              		.loc 1 408 0
 1970 0ff4 FF60A0E3 		mov	r6, #255
 494:../uvc.c      **** 					 break;
 1971              		.loc 1 494 0
 1972 0ff8 C5FFFFEA 		b	.L126
 1973              	.LVL149:
 1974              	.L119:
 474:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1975              		.loc 1 474 0
 1976 0ffc E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 1977 1000 FCC99FE5 		ldr	ip, .L211+12
 476:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1978              		.loc 1 476 0
 1979 1004 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 475:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1980              		.loc 1 475 0
 1981 1008 00E0A0E3 		mov	lr, #0
 474:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1982              		.loc 1 474 0
 1983 100c 5840CCE5 		strb	r4, [ip, #88]
 475:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1984              		.loc 1 475 0
 1985 1010 59E0CCE5 		strb	lr, [ip, #89]
 476:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1986              		.loc 1 476 0
 1987 1014 5A60CCE5 		strb	r6, [ip, #90]
 477:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 1988              		.loc 1 477 0
 1989 1018 5BE0CCE5 		strb	lr, [ip, #91]
 1990              	.LVL150:
 480:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 1991              		.loc 1 480 0
 1992 101c F4199FE5 		ldr	r1, .L211+32
 1993 1020 0420A0E1 		mov	r2, r4
 1994 1024 0E30A0E1 		mov	r3, lr
 1995 1028 0400A0E3 		mov	r0, #4
 1996 102c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 1997 1030 FEFFFFEB 		bl	CyU3PDebugPrint
 481:../uvc.c      **** 					 break;
 1998              		.loc 1 481 0
 1999 1034 B6FFFFEA 		b	.L126
 2000              	.LVL151:
 2001              	.L117:
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2002              		.loc 1 497 0
 2003 1038 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 2004 103c C0799FE5 		ldr	r7, .L211+12
 2005              	.LVL152:
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2006              		.loc 1 498 0
 2007 1040 0060A0E3 		mov	r6, #0
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2008              		.loc 1 497 0
 2009 1044 804024E2 		eor	r4, r4, #128
 498:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2010              		.loc 1 498 0
 2011 1048 5960C7E5 		strb	r6, [r7, #89]
 2012              	.LVL153:
 497:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2013              		.loc 1 497 0
 2014 104c 5840C7E5 		strb	r4, [r7, #88]
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2015              		.loc 1 408 0
 2016 1050 FF60A0E3 		mov	r6, #255
 500:../uvc.c      **** 					 break;
 2017              		.loc 1 500 0
 2018 1054 AEFFFFEA 		b	.L126
 2019              	.LVL154:
 2020              	.L116:
 486:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2021              		.loc 1 486 0
 2022 1058 A601D6E5 		ldrb	r0, [r6, #422]	@ zero_extendqisi2
 484:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2023              		.loc 1 484 0
 2024 105c A521D6E5 		ldrb	r2, [r6, #421]	@ zero_extendqisi2
 2025              	.LVL155:
 486:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2026              		.loc 1 486 0
 2027 1060 020010E3 		tst	r0, #2
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2028              		.loc 1 489 0
 2029 1064 2221A001 		moveq	r2, r2, lsr #2
 2030              	.LVL156:
 2031 1068 822CE001 		mvneq	r2, r2, asl #25
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2032              		.loc 1 487 0
 2033 106c 0003A011 		movne	r0, r0, asl #6
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2034              		.loc 1 489 0
 2035 1070 A22CE001 		mvneq	r2, r2, lsr #25
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2036              		.loc 1 487 0
 2037 1074 40400012 		andne	r4, r0, #64
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2038              		.loc 1 489 0
 2039 1078 00038201 		orreq	r0, r2, r0, asl #6
 487:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2040              		.loc 1 487 0
 2041 107c 22418411 		orrne	r4, r4, r2, lsr #2
 2042              	.LVL157:
 489:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2043              		.loc 1 489 0
 2044 1080 FF400002 		andeq	r4, r0, #255
 2045              	.LVL158:
 2046 1084 D6FFFFEA 		b	.L134
 2047              	.LVL159:
 2048              	.L115:
 511:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2049              		.loc 1 511 0
 2050 1088 843084E0 		add	r3, r4, r4, asl #1
 2051 108c 831186E0 		add	r1, r6, r3, asl #3
 2052 1090 6C299FE5 		ldr	r2, .L211+12
 2053 1094 8D41D1E5 		ldrb	r4, [r1, #397]	@ zero_extendqisi2
 512:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2054              		.loc 1 512 0
 2055 1098 0000A0E3 		mov	r0, #0
 408:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2056              		.loc 1 408 0
 2057 109c FF60A0E3 		mov	r6, #255
 511:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2058              		.loc 1 511 0
 2059 10a0 5840C2E5 		strb	r4, [r2, #88]
 512:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2060              		.loc 1 512 0
 2061 10a4 5900C2E5 		strb	r0, [r2, #89]
 2062              	.LVL160:
 514:../uvc.c      **** 					 break;
 2063              		.loc 1 514 0
 2064 10a8 99FFFFEA 		b	.L126
 2065              	.LVL161:
 2066              	.L118:
 502:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2067              		.loc 1 502 0
 2068 10ac 50C99FE5 		ldr	ip, .L211+12
 2069 10b0 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 504:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2070              		.loc 1 504 0
 2071 10b4 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 503:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2072              		.loc 1 503 0
 2073 10b8 00E0A0E3 		mov	lr, #0
 502:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2074              		.loc 1 502 0
 2075 10bc 5840CCE5 		strb	r4, [ip, #88]
 503:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2076              		.loc 1 503 0
 2077 10c0 59E0CCE5 		strb	lr, [ip, #89]
 504:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2078              		.loc 1 504 0
 2079 10c4 5A60CCE5 		strb	r6, [ip, #90]
 505:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2080              		.loc 1 505 0
 2081 10c8 5BE0CCE5 		strb	lr, [ip, #91]
 2082              	.LVL162:
 508:../uvc.c      **** 					 break;
 2083              		.loc 1 508 0
 2084 10cc 90FFFFEA 		b	.L126
 2085              	.LVL163:
 2086              	.L164:
 761:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2087              		.loc 1 761 0
 2088 10d0 44499FE5 		ldr	r4, .L211+36
 2089 10d4 0010E0E3 		mvn	r1, #0
 2090 10d8 1C0094E5 		ldr	r0, [r4, #28]
 2091 10dc FEFFFFEB 		bl	_txe_mutex_get
 762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2092              		.loc 1 762 0
 2093 10e0 2610A0E3 		mov	r1, #38
 2094              	.L203:
 2095 10e4 14C09DE5 		ldr	ip, [sp, #20]
 2096 10e8 00E0A0E3 		mov	lr, #0
 2097 10ec 0A30A0E1 		mov	r3, sl
 2098 10f0 0920A0E1 		mov	r2, r9
 2099 10f4 0400A0E1 		mov	r0, r4
 2100 10f8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2101 10fc FEFFFFEB 		bl	cmdSet
 763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2102              		.loc 1 763 0
 2103 1100 1C0094E5 		ldr	r0, [r4, #28]
 2104 1104 FEFFFFEB 		bl	_txe_mutex_put
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2105              		.loc 1 764 0
 2106 1108 14109DE5 		ldr	r1, [sp, #20]
 2107 110c 873087E0 		add	r3, r7, r7, asl #1
 2108 1110 836186E0 		add	r6, r6, r3, asl #3
 766:../uvc.c      **** 							 break;
 2109              		.loc 1 766 0
 2110 1114 FFC0A0E3 		mov	ip, #255
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2111              		.loc 1 765 0
 2112 1118 0100A0E3 		mov	r0, #1
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2113              		.loc 1 764 0
 2114 111c 0D10C6E5 		strb	r1, [r6, #13]
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2115              		.loc 1 765 0
 2116 1120 1000C6E5 		strb	r0, [r6, #16]
 2117 1124 0140A0E1 		mov	r4, r1
 2118 1128 18E09DE5 		ldr	lr, [sp, #24]
 766:../uvc.c      **** 							 break;
 2119              		.loc 1 766 0
 2120 112c 0C70A0E1 		mov	r7, ip
 2121              	.LVL164:
 2122 1130 74FEFFEA 		b	.L114
 2123              	.LVL165:
 2124              	.L163:
 753:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2125              		.loc 1 753 0
 2126 1134 E0489FE5 		ldr	r4, .L211+36
 2127 1138 0010E0E3 		mvn	r1, #0
 2128 113c 1C0094E5 		ldr	r0, [r4, #28]
 2129 1140 FEFFFFEB 		bl	_txe_mutex_get
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2130              		.loc 1 754 0
 2131 1144 2510A0E3 		mov	r1, #37
 2132 1148 E5FFFFEA 		b	.L203
 2133              	.LVL166:
 2134              	.L162:
 739:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2135              		.loc 1 739 0
 2136 114c C8489FE5 		ldr	r4, .L211+36
 2137 1150 0010E0E3 		mvn	r1, #0
 2138 1154 1C0094E5 		ldr	r0, [r4, #28]
 2139 1158 FEFFFFEB 		bl	_txe_mutex_get
 738:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2140              		.loc 1 738 0
 2141 115c 14209DE5 		ldr	r2, [sp, #20]
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2142              		.loc 1 741 0
 2143 1160 2410A0E3 		mov	r1, #36
 738:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2144              		.loc 1 738 0
 2145 1164 7F8002E2 		and	r8, r2, #127
 2146 1168 18808DE5 		str	r8, [sp, #24]
 2147              	.LVL167:
 741:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2148              		.loc 1 741 0
 2149 116c 18C09DE5 		ldr	ip, [sp, #24]
 2150 1170 0920A0E1 		mov	r2, r9
 2151 1174 0A30A0E1 		mov	r3, sl
 2152 1178 0400A0E1 		mov	r0, r4
 2153 117c 00C08DE5 		str	ip, [sp, #0]
 2154 1180 00C0A0E3 		mov	ip, #0
 2155 1184 04C08DE5 		str	ip, [sp, #4]
 2156 1188 FEFFFFEB 		bl	cmdSet
 2157              	.LVL168:
 743:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2158              		.loc 1 743 0
 2159 118c 1CE09DE5 		ldr	lr, [sp, #28]
 2160 1190 0180A0E3 		mov	r8, #1
 2161 1194 2410A0E3 		mov	r1, #36
 2162 1198 0B20A0E1 		mov	r2, fp
 2163 119c 0A30A0E1 		mov	r3, sl
 2164 11a0 0400A0E1 		mov	r0, r4
 2165 11a4 00E08DE5 		str	lr, [sp, #0]
 2166 11a8 04808DE5 		str	r8, [sp, #4]
 2167 11ac FEFFFFEB 		bl	cmdSet
 744:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2168              		.loc 1 744 0
 2169 11b0 1C0094E5 		ldr	r0, [r4, #28]
 2170 11b4 FEFFFFEB 		bl	_txe_mutex_put
 2171              	.LVL169:
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2172              		.loc 1 747 0
 2173 11b8 87C087E0 		add	ip, r7, r7, asl #1
 2174 11bc 18409DE5 		ldr	r4, [sp, #24]
 748:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2175              		.loc 1 748 0
 2176 11c0 1C709DE5 		ldr	r7, [sp, #28]
 2177              	.LVL170:
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2178              		.loc 1 747 0
 2179 11c4 8C6186E0 		add	r6, r6, ip, asl #3
 750:../uvc.c      **** 							 break;
 2180              		.loc 1 750 0
 2181 11c8 FFC0A0E3 		mov	ip, #255
 747:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2182              		.loc 1 747 0
 2183 11cc 0D40C6E5 		strb	r4, [r6, #13]
 748:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2184              		.loc 1 748 0
 2185 11d0 0E70C6E5 		strb	r7, [r6, #14]
 749:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2186              		.loc 1 749 0
 2187 11d4 07E0A0E1 		mov	lr, r7
 2188 11d8 1080C6E5 		strb	r8, [r6, #16]
 2189 11dc 14409DE5 		ldr	r4, [sp, #20]
 750:../uvc.c      **** 							 break;
 2190              		.loc 1 750 0
 2191 11e0 0C70A0E1 		mov	r7, ip
 2192 11e4 47FEFFEA 		b	.L114
 2193              	.LVL171:
 2194              	.L161:
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2195              		.loc 1 710 0 discriminator 1
 2196 11e8 000058E3 		cmp	r8, #0
 2197 11ec 1800000A 		beq	.L167
 708:../uvc.c      **** 							 break;
 2198              		.loc 1 708 0
 2199 11f0 28E1A0E1 		mov	lr, r8, lsr #2
 2200 11f4 00005EE3 		cmp	lr, #0
 2201 11f8 03005813 		cmpne	r8, #3
 2202 11fc 0020A083 		movhi	r2, #0
 2203 1200 0120A093 		movls	r2, #1
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2204              		.loc 1 390 0
 2205 1204 0E31A0E1 		mov	r3, lr, asl #2
 708:../uvc.c      **** 							 break;
 2206              		.loc 1 708 0
 2207 1208 F501009A 		bls	.L188
 2208 120c 0C189FE5 		ldr	r1, .L211+40
 2209 1210 0C0081E2 		add	r0, r1, #12
 2210              	.LVL172:
 2211              	.L178:
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2212              		.loc 1 711 0 discriminator 2
 2213 1214 047090E4 		ldr	r7, [r0], #4
 2214 1218 012082E2 		add	r2, r2, #1
 2215 121c FF2002E2 		and	r2, r2, #255
 2216 1220 02005EE1 		cmp	lr, r2
 2217 1224 047081E4 		str	r7, [r1], #4
 2218 1228 F9FFFF8A 		bhi	.L178
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2219              		.loc 1 711 0 is_stmt 0
 2220 122c 030058E1 		cmp	r8, r3
 2221 1230 0700000A 		beq	.L167
 2222              	.L192:
 2223 1234 C8E79FE5 		ldr	lr, .L211+12
 2224 1238 03008EE0 		add	r0, lr, r3
 2225 123c 5810D0E5 		ldrb	r1, [r0, #88]	@ zero_extendqisi2
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2226              		.loc 1 710 0 is_stmt 1
 2227 1240 013083E2 		add	r3, r3, #1
 2228 1244 FF3003E2 		and	r3, r3, #255
 2229              	.LVL173:
 2230 1248 030058E1 		cmp	r8, r3
 711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2231              		.loc 1 711 0
 2232 124c 4C10C0E5 		strb	r1, [r0, #76]
 710:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2233              		.loc 1 710 0
 2234 1250 F7FFFF8A 		bhi	.L192
 2235              	.LVL174:
 2236              	.L167:
 713:../uvc.c      **** 					 		I2CCmdHandler();
 2237              		.loc 1 713 0
 2238 1254 FEFFFFEB 		bl	I2CCmdHandler
 714:../uvc.c      **** 							 break;
 2239              		.loc 1 714 0
 2240 1258 FFC0A0E3 		mov	ip, #255
 713:../uvc.c      **** 					 		I2CCmdHandler();
 2241              		.loc 1 713 0
 2242 125c 14409DE5 		ldr	r4, [sp, #20]
 2243 1260 18E09DE5 		ldr	lr, [sp, #24]
 714:../uvc.c      **** 							 break;
 2244              		.loc 1 714 0
 2245 1264 0C70A0E1 		mov	r7, ip
 2246 1268 26FEFFEA 		b	.L114
 2247              	.LVL175:
 2248              	.L160:
 704:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2249              		.loc 1 704 0
 2250 126c A8779FE5 		ldr	r7, .L211+36
 2251              	.LVL176:
 2252 1270 0010E0E3 		mvn	r1, #0
 2253 1274 1C0097E5 		ldr	r0, [r7, #28]
 2254 1278 FEFFFFEB 		bl	_txe_mutex_get
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2255              		.loc 1 705 0
 2256 127c 14409DE5 		ldr	r4, [sp, #20]
 2257 1280 00E0A0E3 		mov	lr, #0
 2258 1284 01C074E2 		rsbs	ip, r4, #1
 2259 1288 00C0A033 		movcc	ip, #0
 2260 128c 1E10A0E3 		mov	r1, #30
 2261 1290 0920A0E1 		mov	r2, r9
 2262 1294 0A30A0E1 		mov	r3, sl
 2263 1298 0700A0E1 		mov	r0, r7
 2264 129c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2265 12a0 FEFFFFEB 		bl	cmdSet
 706:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2266              		.loc 1 706 0
 2267 12a4 1C0097E5 		ldr	r0, [r7, #28]
 2268 12a8 FEFFFFEB 		bl	_txe_mutex_put
 708:../uvc.c      **** 							 break;
 2269              		.loc 1 708 0
 2270 12ac FFC0A0E3 		mov	ip, #255
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2271              		.loc 1 707 0
 2272 12b0 0100A0E3 		mov	r0, #1
 2273 12b4 6004C6E5 		strb	r0, [r6, #1120]
 2274 12b8 14409DE5 		ldr	r4, [sp, #20]
 2275 12bc 18E09DE5 		ldr	lr, [sp, #24]
 708:../uvc.c      **** 							 break;
 2276              		.loc 1 708 0
 2277 12c0 0C70A0E1 		mov	r7, ip
 2278 12c4 0FFEFFEA 		b	.L114
 2279              	.LVL177:
 2280              	.L155:
 827:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2281              		.loc 1 827 0
 2282 12c8 4C479FE5 		ldr	r4, .L211+36
 2283 12cc 0010E0E3 		mvn	r1, #0
 2284 12d0 1C0094E5 		ldr	r0, [r4, #28]
 2285 12d4 FEFFFFEB 		bl	_txe_mutex_get
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2286              		.loc 1 828 0
 2287 12d8 14C09DE5 		ldr	ip, [sp, #20]
 2288 12dc 0B10A0E3 		mov	r1, #11
 2289 12e0 0920A0E1 		mov	r2, r9
 2290 12e4 0A30A0E1 		mov	r3, sl
 2291 12e8 0400A0E1 		mov	r0, r4
 2292 12ec 00C08DE5 		str	ip, [sp, #0]
 2293 12f0 00C0A0E3 		mov	ip, #0
 2294 12f4 04C08DE5 		str	ip, [sp, #4]
 2295 12f8 FEFFFFEB 		bl	cmdSet
 2296              	.LVL178:
 830:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2297              		.loc 1 830 0
 2298 12fc 18E09DE5 		ldr	lr, [sp, #24]
 2299 1300 0170A0E3 		mov	r7, #1
 2300              	.LVL179:
 2301 1304 0B10A0E3 		mov	r1, #11
 2302 1308 0B20A0E1 		mov	r2, fp
 2303 130c 0A30A0E1 		mov	r3, sl
 2304 1310 0400A0E1 		mov	r0, r4
 2305 1314 00E08DE5 		str	lr, [sp, #0]
 2306 1318 04708DE5 		str	r7, [sp, #4]
 2307 131c FEFFFFEB 		bl	cmdSet
 831:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2308              		.loc 1 831 0
 2309 1320 1C0094E5 		ldr	r0, [r4, #28]
 2310 1324 FEFFFFEB 		bl	_txe_mutex_put
 833:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2311              		.loc 1 833 0
 2312 1328 14109DE5 		ldr	r1, [sp, #20]
 834:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2313              		.loc 1 834 0
 2314 132c 18209DE5 		ldr	r2, [sp, #24]
 836:../uvc.c      **** 							 break;
 2315              		.loc 1 836 0
 2316 1330 FFC0A0E3 		mov	ip, #255
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2317              		.loc 1 835 0
 2318 1334 9872C6E5 		strb	r7, [r6, #664]
 833:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2319              		.loc 1 833 0
 2320 1338 8C14C6E5 		strb	r1, [r6, #1164]
 834:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2321              		.loc 1 834 0
 2322 133c 8E24C6E5 		strb	r2, [r6, #1166]
 835:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2323              		.loc 1 835 0
 2324 1340 0140A0E1 		mov	r4, r1
 2325 1344 02E0A0E1 		mov	lr, r2
 836:../uvc.c      **** 							 break;
 2326              		.loc 1 836 0
 2327 1348 0C70A0E1 		mov	r7, ip
 2328 134c EDFDFFEA 		b	.L114
 2329              	.LVL180:
 2330              	.L154:
 813:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2331              		.loc 1 813 0
 2332 1350 C4469FE5 		ldr	r4, .L211+36
 2333 1354 0010E0E3 		mvn	r1, #0
 2334 1358 1C0094E5 		ldr	r0, [r4, #28]
 2335 135c FEFFFFEB 		bl	_txe_mutex_get
 814:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2336              		.loc 1 814 0
 2337 1360 14C09DE5 		ldr	ip, [sp, #20]
 2338 1364 0610A0E3 		mov	r1, #6
 2339 1368 0920A0E1 		mov	r2, r9
 2340 136c 0A30A0E1 		mov	r3, sl
 2341 1370 0400A0E1 		mov	r0, r4
 2342 1374 00C08DE5 		str	ip, [sp, #0]
 2343 1378 00C0A0E3 		mov	ip, #0
 2344 137c 04C08DE5 		str	ip, [sp, #4]
 2345 1380 FEFFFFEB 		bl	cmdSet
 2346              	.LVL181:
 816:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2347              		.loc 1 816 0
 2348 1384 14E09DE5 		ldr	lr, [sp, #20]
 2349 1388 0170A0E3 		mov	r7, #1
 2350              	.LVL182:
 2351 138c 0610A0E3 		mov	r1, #6
 2352 1390 0B20A0E1 		mov	r2, fp
 2353 1394 0A30A0E1 		mov	r3, sl
 2354 1398 0400A0E1 		mov	r0, r4
 2355 139c 00E08DE5 		str	lr, [sp, #0]
 2356 13a0 04708DE5 		str	r7, [sp, #4]
 2357 13a4 FEFFFFEB 		bl	cmdSet
 817:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2358              		.loc 1 817 0
 2359 13a8 1C0094E5 		ldr	r0, [r4, #28]
 2360 13ac FEFFFFEB 		bl	_txe_mutex_put
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2361              		.loc 1 818 0
 2362 13b0 14409DE5 		ldr	r4, [sp, #20]
 820:../uvc.c      **** 							 break;
 2363              		.loc 1 820 0
 2364 13b4 FFC0A0E3 		mov	ip, #255
 819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2365              		.loc 1 819 0
 2366 13b8 2072C6E5 		strb	r7, [r6, #544]
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2367              		.loc 1 818 0
 2368 13bc 1D42C6E5 		strb	r4, [r6, #541]
 819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2369              		.loc 1 819 0
 2370 13c0 18E09DE5 		ldr	lr, [sp, #24]
 820:../uvc.c      **** 							 break;
 2371              		.loc 1 820 0
 2372 13c4 0C70A0E1 		mov	r7, ip
 2373 13c8 CEFDFFEA 		b	.L114
 2374              	.LVL183:
 2375              	.L153:
 793:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2376              		.loc 1 793 0
 2377 13cc 48469FE5 		ldr	r4, .L211+36
 2378 13d0 0010E0E3 		mvn	r1, #0
 2379 13d4 1C0094E5 		ldr	r0, [r4, #28]
 2380 13d8 FEFFFFEB 		bl	_txe_mutex_get
 794:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2381              		.loc 1 794 0
 2382 13dc 14309DE5 		ldr	r3, [sp, #20]
 2383 13e0 00C0A0E3 		mov	ip, #0
 2384 13e4 800043E2 		sub	r0, r3, #128
 2385 13e8 FF7000E2 		and	r7, r0, #255
 2386              	.LVL184:
 2387 13ec 0510A0E3 		mov	r1, #5
 2388 13f0 0920A0E1 		mov	r2, r9
 2389 13f4 0A30A0E1 		mov	r3, sl
 2390 13f8 0400A0E1 		mov	r0, r4
 2391 13fc 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2392 1400 FEFFFFEB 		bl	cmdSet
 2393              	.LVL185:
 796:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2394              		.loc 1 796 0
 2395 1404 14109DE5 		ldr	r1, [sp, #20]
 2396 1408 DC20A0E3 		mov	r2, #220
 2397 140c 767041E2 		sub	r7, r1, #118
 2398 1410 FFC007E2 		and	ip, r7, #255
 2399 1414 0510A0E3 		mov	r1, #5
 2400 1418 0170A0E3 		mov	r7, #1
 2401 141c 0A30A0E1 		mov	r3, sl
 2402 1420 0400A0E1 		mov	r0, r4
 2403 1424 00C08DE5 		str	ip, [sp, #0]
 2404 1428 04708DE5 		str	r7, [sp, #4]
 2405 142c FEFFFFEB 		bl	cmdSet
 2406              	.LVL186:
 798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2407              		.loc 1 798 0
 2408 1430 14209DE5 		ldr	r2, [sp, #20]
 2409 1434 0510A0E3 		mov	r1, #5
 2410 1438 7E3082E2 		add	r3, r2, #126
 2411 143c FFC003E2 		and	ip, r3, #255
 2412 1440 DE20A0E3 		mov	r2, #222
 2413 1444 0A30A0E1 		mov	r3, sl
 2414 1448 0400A0E1 		mov	r0, r4
 2415 144c 00C08DE5 		str	ip, [sp, #0]
 2416 1450 02C0A0E3 		mov	ip, #2
 2417 1454 04C08DE5 		str	ip, [sp, #4]
 2418 1458 FEFFFFEB 		bl	cmdSet
 2419              	.LVL187:
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2420              		.loc 1 800 0
 2421 145c 14009DE5 		ldr	r0, [sp, #20]
 2422 1460 03E0A0E3 		mov	lr, #3
 2423 1464 721080E2 		add	r1, r0, #114
 2424 1468 FFC001E2 		and	ip, r1, #255
 2425 146c E020A0E3 		mov	r2, #224
 2426 1470 0510A0E3 		mov	r1, #5
 2427 1474 0A30A0E1 		mov	r3, sl
 2428 1478 0400A0E1 		mov	r0, r4
 2429 147c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2430 1480 FEFFFFEB 		bl	cmdSet
 2431              	.LVL188:
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2432              		.loc 1 802 0
 2433 1484 14209DE5 		ldr	r2, [sp, #20]
 2434 1488 0510A0E3 		mov	r1, #5
 2435 148c 6F3042E2 		sub	r3, r2, #111
 2436 1490 FFC003E2 		and	ip, r3, #255
 2437 1494 DD20A0E3 		mov	r2, #221
 2438 1498 0A30A0E1 		mov	r3, sl
 2439 149c 0400A0E1 		mov	r0, r4
 2440 14a0 00C08DE5 		str	ip, [sp, #0]
 2441 14a4 04C0A0E3 		mov	ip, #4
 2442 14a8 04C08DE5 		str	ip, [sp, #4]
 2443 14ac FEFFFFEB 		bl	cmdSet
 2444              	.LVL189:
 804:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2445              		.loc 1 804 0
 2446 14b0 4C059FE5 		ldr	r0, .L211+12
 2447 14b4 05E0A0E3 		mov	lr, #5
 2448 14b8 5810D0E5 		ldrb	r1, [r0, #88]	@ zero_extendqisi2
 2449 14bc 0A30A0E1 		mov	r3, sl
 2450 14c0 7F2081E2 		add	r2, r1, #127
 2451 14c4 FFC002E2 		and	ip, r2, #255
 2452 14c8 0E10A0E1 		mov	r1, lr
 2453 14cc 0B20A0E1 		mov	r2, fp
 2454 14d0 0400A0E1 		mov	r0, r4
 2455 14d4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2456 14d8 FEFFFFEB 		bl	cmdSet
 805:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2457              		.loc 1 805 0
 2458 14dc 1C0094E5 		ldr	r0, [r4, #28]
 2459 14e0 FEFFFFEB 		bl	_txe_mutex_put
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2460              		.loc 1 807 0
 2461 14e4 18359FE5 		ldr	r3, .L211+12
 809:../uvc.c      **** 							 break;
 2462              		.loc 1 809 0
 2463 14e8 FFC0A0E3 		mov	ip, #255
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2464              		.loc 1 807 0
 2465 14ec 5800D3E5 		ldrb	r0, [r3, #88]	@ zero_extendqisi2
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2466              		.loc 1 808 0
 2467 14f0 0872C6E5 		strb	r7, [r6, #520]
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2468              		.loc 1 807 0
 2469 14f4 801040E2 		sub	r1, r0, #128
 2470 14f8 0512C6E5 		strb	r1, [r6, #517]
 808:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2471              		.loc 1 808 0
 2472 14fc 14409DE5 		ldr	r4, [sp, #20]
 2473 1500 18E09DE5 		ldr	lr, [sp, #24]
 809:../uvc.c      **** 							 break;
 2474              		.loc 1 809 0
 2475 1504 0C70A0E1 		mov	r7, ip
 2476 1508 7EFDFFEA 		b	.L114
 2477              	.LVL190:
 2478              	.L152:
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2479              		.loc 1 845 0
 2480 150c 08459FE5 		ldr	r4, .L211+36
 839:../uvc.c      **** 							 Data0 = Data0 - 1;
 2481              		.loc 1 839 0
 2482 1510 013043E2 		sub	r3, r3, #1
 2483 1514 FF7003E2 		and	r7, r3, #255
 2484              	.LVL191:
 843:../uvc.c      **** 								 Data0 = 1;
 2485              		.loc 1 843 0
 2486 1518 020057E3 		cmp	r7, #2
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2487              		.loc 1 845 0
 2488 151c 0010E0E3 		mvn	r1, #0
 2489 1520 1C0094E5 		ldr	r0, [r4, #28]
 843:../uvc.c      **** 								 Data0 = 1;
 2490              		.loc 1 843 0
 2491 1524 0170A083 		movhi	r7, #1
 2492              	.LVL192:
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2493              		.loc 1 845 0
 2494 1528 FEFFFFEB 		bl	_txe_mutex_get
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2495              		.loc 1 846 0
 2496 152c 00C0A0E3 		mov	ip, #0
 2497 1530 0410A0E3 		mov	r1, #4
 2498 1534 0920A0E1 		mov	r2, r9
 2499 1538 0A30A0E1 		mov	r3, sl
 2500 153c 0400A0E1 		mov	r0, r4
 2501 1540 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2502 1544 FEFFFFEB 		bl	cmdSet
 847:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2503              		.loc 1 847 0
 2504 1548 1C0094E5 		ldr	r0, [r4, #28]
 2505 154c FEFFFFEB 		bl	_txe_mutex_put
 851:../uvc.c      **** 							 break;
 2506              		.loc 1 851 0
 2507 1550 FFC0A0E3 		mov	ip, #255
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2508              		.loc 1 850 0
 2509 1554 0100A0E3 		mov	r0, #1
 849:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2510              		.loc 1 849 0
 2511 1558 ED71C6E5 		strb	r7, [r6, #493]
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2512              		.loc 1 850 0
 2513 155c F001C6E5 		strb	r0, [r6, #496]
 2514 1560 14409DE5 		ldr	r4, [sp, #20]
 2515 1564 18E09DE5 		ldr	lr, [sp, #24]
 851:../uvc.c      **** 							 break;
 2516              		.loc 1 851 0
 2517 1568 0C70A0E1 		mov	r7, ip
 2518 156c 65FDFFEA 		b	.L114
 2519              	.LVL193:
 2520              	.L151:
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2521              		.loc 1 769 0
 2522 1570 A4749FE5 		ldr	r7, .L211+36
 2523              	.LVL194:
 2524 1574 0010E0E3 		mvn	r1, #0
 2525 1578 1C0097E5 		ldr	r0, [r7, #28]
 2526 157c FEFFFFEB 		bl	_txe_mutex_get
 771:../uvc.c      **** 							  if(Data0&0x80){
 2527              		.loc 1 771 0
 2528 1580 14C09DE5 		ldr	ip, [sp, #20]
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2529              		.loc 1 772 0
 2530 1584 A641D6E5 		ldrb	r4, [r6, #422]	@ zero_extendqisi2
 771:../uvc.c      **** 							  if(Data0&0x80){
 2531              		.loc 1 771 0
 2532 1588 80001CE3 		tst	ip, #128
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2533              		.loc 1 774 0
 2534 158c 2C23A001 		moveq	r2, ip, lsr #6
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2535              		.loc 1 772 0
 2536 1590 8C2CA011 		movne	r2, ip, asl #25
 2537 1594 0340C413 		bicne	r4, r4, #3
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2538              		.loc 1 774 0
 2539 1598 0340C403 		biceq	r4, r4, #3
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2540              		.loc 1 778 0
 2541 159c 00C0A0E3 		mov	ip, #0
 2542 15a0 04C08DE5 		str	ip, [sp, #4]
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2543              		.loc 1 774 0
 2544 15a4 02208203 		orreq	r2, r2, #2
 772:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2545              		.loc 1 772 0
 2546 15a8 A24F8411 		orrne	r4, r4, r2, lsr #31
 2547              	.LVL195:
 774:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2548              		.loc 1 774 0
 2549 15ac 04408201 		orreq	r4, r2, r4
 2550              	.LVL196:
 776:../uvc.c      **** 							 Data1 |= ~0x03;
 2551              		.loc 1 776 0
 2552 15b0 043FE0E1 		mvn	r3, r4, asl #30
 2553 15b4 230FE0E1 		mvn	r0, r3, lsr #30
 2554              	.LVL197:
 777:../uvc.c      **** 							 Data1 &= 0xC7;
 2555              		.loc 1 777 0
 2556 15b8 C71000E2 		and	r1, r0, #199
 2557 15bc 1C108DE5 		str	r1, [sp, #28]
 2558              	.LVL198:
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2559              		.loc 1 778 0
 2560 15c0 1C809DE5 		ldr	r8, [sp, #28]
 2561 15c4 0110A0E3 		mov	r1, #1
 2562 15c8 0B20A0E1 		mov	r2, fp
 2563 15cc 0A30A0E1 		mov	r3, sl
 2564 15d0 44049FE5 		ldr	r0, .L211+36
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2565              		.loc 1 782 0
 2566 15d4 0140A0E1 		mov	r4, r1
 778:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2567              		.loc 1 778 0
 2568 15d8 00808DE5 		str	r8, [sp, #0]
 2569 15dc FEFFFFEB 		bl	cmdSet
 2570              	.LVL199:
 781:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2571              		.loc 1 781 0
 2572 15e0 14209DE5 		ldr	r2, [sp, #20]
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2573              		.loc 1 782 0
 2574 15e4 0410A0E1 		mov	r1, r4
 781:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2575              		.loc 1 781 0
 2576 15e8 0281A0E1 		mov	r8, r2, asl #2
 2577 15ec FF8008E2 		and	r8, r8, #255
 2578              	.LVL200:
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2579              		.loc 1 782 0
 2580 15f0 0920A0E1 		mov	r2, r9
 2581 15f4 0A30A0E1 		mov	r3, sl
 2582 15f8 1C049FE5 		ldr	r0, .L211+36
 2583 15fc 04408DE5 		str	r4, [sp, #4]
 2584 1600 00808DE5 		str	r8, [sp, #0]
 2585 1604 FEFFFFEB 		bl	cmdSet
 783:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2586              		.loc 1 783 0
 2587 1608 1C0097E5 		ldr	r0, [r7, #28]
 2588 160c FEFFFFEB 		bl	_txe_mutex_put
 786:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2589              		.loc 1 786 0
 2590 1610 1C709DE5 		ldr	r7, [sp, #28]
 789:../uvc.c      **** 							 break;
 2591              		.loc 1 789 0
 2592 1614 FFC0A0E3 		mov	ip, #255
 786:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2593              		.loc 1 786 0
 2594 1618 A671C6E5 		strb	r7, [r6, #422]
 787:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2595              		.loc 1 787 0
 2596 161c A841C6E5 		strb	r4, [r6, #424]
 785:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2597              		.loc 1 785 0
 2598 1620 A581C6E5 		strb	r8, [r6, #421]
 787:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2599              		.loc 1 787 0
 2600 1624 14409DE5 		ldr	r4, [sp, #20]
 2601 1628 18E09DE5 		ldr	lr, [sp, #24]
 789:../uvc.c      **** 							 break;
 2602              		.loc 1 789 0
 2603 162c 0C70A0E1 		mov	r7, ip
 2604 1630 34FDFFEA 		b	.L114
 2605              	.LVL201:
 2606              	.L150:
 2607 1634 03C0A0E1 		mov	ip, r3
 854:../uvc.c      **** 							 if(Data0 == 3)
 2608              		.loc 1 854 0
 2609 1638 030053E3 		cmp	r3, #3
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2610              		.loc 1 853 0
 2611 163c 8DC1C6E5 		strb	ip, [r6, #397]
 2612 1640 B0339FE5 		ldr	r3, .L211
 854:../uvc.c      **** 							 if(Data0 == 3)
 2613              		.loc 1 854 0
 2614 1644 D600000A 		beq	.L210
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 2615              		.loc 1 857 0
 2616 1648 B4E39FE5 		ldr	lr, .L211+12
 861:../uvc.c      **** 								 if(Data0 < 2){
 2617              		.loc 1 861 0
 2618 164c 01005CE3 		cmp	ip, #1
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 2619              		.loc 1 857 0
 2620 1650 0000A0E3 		mov	r0, #0
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2621              		.loc 1 858 0
 2622 1654 0110A0E3 		mov	r1, #1
 857:../uvc.c      **** 								 WDRflag = CyFalse;
 2623              		.loc 1 857 0
 2624 1658 78008EE5 		str	r0, [lr, #120]
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2625              		.loc 1 858 0
 2626 165c 9011C3E5 		strb	r1, [r3, #400]
 861:../uvc.c      **** 								 if(Data0 < 2){
 2627              		.loc 1 861 0
 2628 1660 0C60A091 		movls	r6, ip
 2629 1664 0C70A091 		movls	r7, ip
 2630              	.LVL202:
 2631 1668 0600009A 		bls	.L186
 2632              	.L185:
 864:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 2633              		.loc 1 864 0
 2634 166c 0400A0E3 		mov	r0, #4
 2635 1670 AC139FE5 		ldr	r1, .L211+44
 2636 1674 0120A0E3 		mov	r2, #1
 2637 1678 14309DE5 		ldr	r3, [sp, #20]
 2638 167c FEFFFFEB 		bl	CyU3PDebugPrint
 2639              	.LVL203:
 2640 1680 0060A0E3 		mov	r6, #0
 865:../uvc.c      **** 									Data0 = 0; //set to default.
 2641              		.loc 1 865 0
 2642 1684 0670A0E1 		mov	r7, r6
 2643              	.LVL204:
 2644              	.L186:
 870:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2645              		.loc 1 870 0
 2646 1688 8C439FE5 		ldr	r4, .L211+36
 2647 168c 0010E0E3 		mvn	r1, #0
 2648 1690 1C0094E5 		ldr	r0, [r4, #28]
 2649 1694 FEFFFFEB 		bl	_txe_mutex_get
 871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2650              		.loc 1 871 0
 2651 1698 00C0A0E3 		mov	ip, #0
 2652 169c 0C10A0E1 		mov	r1, ip
 2653 16a0 0920A0E1 		mov	r2, r9
 2654 16a4 0A30A0E1 		mov	r3, sl
 2655 16a8 0400A0E1 		mov	r0, r4
 2656 16ac 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2657 16b0 FEFFFFEB 		bl	cmdSet
 872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2658              		.loc 1 872 0
 2659 16b4 1C0094E5 		ldr	r0, [r4, #28]
 2660 16b8 FEFFFFEB 		bl	_txe_mutex_put
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2661              		.loc 1 873 0
 2662 16bc 40C39FE5 		ldr	ip, .L211+12
 2663 16c0 60139FE5 		ldr	r1, .L211+48
 2664 16c4 5A40DCE5 		ldrb	r4, [ip, #90]	@ zero_extendqisi2
 2665 16c8 5B70DCE5 		ldrb	r7, [ip, #91]	@ zero_extendqisi2
 2666              	.LVL205:
 2667 16cc 0400A0E3 		mov	r0, #4
 2668 16d0 0620A0E1 		mov	r2, r6
 2669 16d4 78309CE5 		ldr	r3, [ip, #120]
 2670 16d8 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2671              	.LVL206:
 2672              	.L202:
 2673 16dc FEFFFFEB 		bl	CyU3PDebugPrint
 875:../uvc.c      **** 					 		 break;
 2674              		.loc 1 875 0
 2675 16e0 FFC0A0E3 		mov	ip, #255
 873:../uvc.c      **** 							 CyU3PDebugPrint (4, "BLC set. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buffe
 2676              		.loc 1 873 0
 2677 16e4 14409DE5 		ldr	r4, [sp, #20]
 2678 16e8 18E09DE5 		ldr	lr, [sp, #24]
 875:../uvc.c      **** 					 		 break;
 2679              		.loc 1 875 0
 2680 16ec 0C70A0E1 		mov	r7, ip
 2681 16f0 04FDFFEA 		b	.L114
 2682              	.LVL207:
 2683              	.L149:
 879:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2684              		.loc 1 879 0
 2685 16f4 20739FE5 		ldr	r7, .L211+36
 2686              	.LVL208:
 2687 16f8 0010E0E3 		mvn	r1, #0
 2688 16fc 1C0097E5 		ldr	r0, [r7, #28]
 2689 1700 FEFFFFEB 		bl	_txe_mutex_get
 880:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2690              		.loc 1 880 0
 2691 1704 14C09DE5 		ldr	ip, [sp, #20]
 2692 1708 0410A0E1 		mov	r1, r4
 2693 170c 0920A0E1 		mov	r2, r9
 2694 1710 0A30A0E1 		mov	r3, sl
 2695 1714 0700A0E1 		mov	r0, r7
 2696 1718 00C08DE5 		str	ip, [sp, #0]
 2697 171c 00C0A0E3 		mov	ip, #0
 2698 1720 04C08DE5 		str	ip, [sp, #4]
 2699 1724 FEFFFFEB 		bl	cmdSet
 881:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2700              		.loc 1 881 0
 2701 1728 1C0097E5 		ldr	r0, [r7, #28]
 2702 172c FEFFFFEB 		bl	_txe_mutex_put
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2703              		.loc 1 883 0
 2704 1730 14209DE5 		ldr	r2, [sp, #20]
 2705 1734 841084E0 		add	r1, r4, r4, asl #1
 2706 1738 816186E0 		add	r6, r6, r1, asl #3
 885:../uvc.c      **** 							 break;
 2707              		.loc 1 885 0
 2708 173c FFC0A0E3 		mov	ip, #255
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2709              		.loc 1 884 0
 2710 1740 0130A0E3 		mov	r3, #1
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2711              		.loc 1 883 0
 2712 1744 8D21C6E5 		strb	r2, [r6, #397]
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2713              		.loc 1 884 0
 2714 1748 9031C6E5 		strb	r3, [r6, #400]
 2715 174c 0240A0E1 		mov	r4, r2
 2716 1750 18E09DE5 		ldr	lr, [sp, #24]
 885:../uvc.c      **** 							 break;
 2717              		.loc 1 885 0
 2718 1754 0C70A0E1 		mov	r7, ip
 2719 1758 EAFCFFEA 		b	.L114
 2720              	.LVL209:
 2721              	.L159:
 617:../uvc.c      **** 				  switch(CtrlID)
 2722              		.loc 1 617 0
 2723 175c FFC0A0E3 		mov	ip, #255
 2724 1760 0340A0E1 		mov	r4, r3
 2725 1764 0C70A0E1 		mov	r7, ip
 2726              	.LVL210:
 2727 1768 E6FCFFEA 		b	.L114
 2728              	.LVL211:
 2729              	.L158:
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2730              		.loc 1 671 0
 2731 176c A8729FE5 		ldr	r7, .L211+36
 2732              	.LVL212:
 669:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2733              		.loc 1 669 0
 2734 1770 FD33C6E5 		strb	r3, [r6, #1021]
 670:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2735              		.loc 1 670 0
 2736 1774 0130A0E3 		mov	r3, #1
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2737              		.loc 1 671 0
 2738 1778 1C0097E5 		ldr	r0, [r7, #28]
 2739 177c 0010E0E3 		mvn	r1, #0
 670:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2740              		.loc 1 670 0
 2741 1780 0034C6E5 		strb	r3, [r6, #1024]
 671:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2742              		.loc 1 671 0
 2743 1784 FEFFFFEB 		bl	_txe_mutex_get
 672:../uvc.c      **** 							 if(WDRflag)
 2744              		.loc 1 672 0
 2745 1788 74329FE5 		ldr	r3, .L211+12
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2746              		.loc 1 673 0
 2747 178c 1A10A0E3 		mov	r1, #26
 672:../uvc.c      **** 							 if(WDRflag)
 2748              		.loc 1 672 0
 2749 1790 784093E5 		ldr	r4, [r3, #120]
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2750              		.loc 1 673 0
 2751 1794 0700A0E1 		mov	r0, r7
 672:../uvc.c      **** 							 if(WDRflag)
 2752              		.loc 1 672 0
 2753 1798 000054E3 		cmp	r4, #0
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2754              		.loc 1 673 0
 2755 179c 14409D15 		ldrne	r4, [sp, #20]
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2756              		.loc 1 675 0
 2757 17a0 14E09D05 		ldreq	lr, [sp, #20]
 673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2758              		.loc 1 673 0
 2759 17a4 00408D15 		strne	r4, [sp, #0]
 2760 17a8 0B20A011 		movne	r2, fp
 2761 17ac 0040A013 		movne	r4, #0
 2762 17b0 0A30A011 		movne	r3, sl
 675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2763              		.loc 1 675 0
 2764 17b4 0920A001 		moveq	r2, r9
 2765 17b8 0A30A001 		moveq	r3, sl
 2766 17bc 04408DE5 		str	r4, [sp, #4]
 2767 17c0 00E08D05 		streq	lr, [sp, #0]
 2768 17c4 FEFFFFEB 		bl	cmdSet
 676:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2769              		.loc 1 676 0
 2770 17c8 1C0097E5 		ldr	r0, [r7, #28]
 2771 17cc FEFFFFEB 		bl	_txe_mutex_put
 677:../uvc.c      **** 							 CyU3PDebugPrint (4, "Exe level. %d %d; %d %d\r\n", Data0, WDRflag, glEp0Buffer[2], glEp0Buf
 2772              		.loc 1 677 0
 2773 17d0 2C229FE5 		ldr	r2, .L211+12
 2774 17d4 14409DE5 		ldr	r4, [sp, #20]
 2775 17d8 5AC0D2E5 		ldrb	ip, [r2, #90]	@ zero_extendqisi2
 2776 17dc 5BE0D2E5 		ldrb	lr, [r2, #91]	@ zero_extendqisi2
 2777 17e0 783092E5 		ldr	r3, [r2, #120]
 2778 17e4 0400A0E3 		mov	r0, #4
 2779 17e8 3C129FE5 		ldr	r1, .L211+52
 2780 17ec 0420A0E1 		mov	r2, r4
 2781 17f0 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2782 17f4 FEFFFFEB 		bl	CyU3PDebugPrint
 2783 17f8 FFC0A0E3 		mov	ip, #255
 2784 17fc 18E09DE5 		ldr	lr, [sp, #24]
 2785 1800 0C70A0E1 		mov	r7, ip
 2786 1804 BFFCFFEA 		b	.L114
 2787              	.LVL213:
 2788              	.L157:
 655:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2789              		.loc 1 655 0
 2790 1808 18209DE5 		ldr	r2, [sp, #24]
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2791              		.loc 1 658 0
 2792 180c 08429FE5 		ldr	r4, .L211+36
 656:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2793              		.loc 1 656 0
 2794 1810 0170A0E3 		mov	r7, #1
 2795              	.LVL214:
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2796              		.loc 1 658 0
 2797 1814 0010E0E3 		mvn	r1, #0
 654:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2798              		.loc 1 654 0
 2799 1818 E533C6E5 		strb	r3, [r6, #997]
 655:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2800              		.loc 1 655 0
 2801 181c E623C6E5 		strb	r2, [r6, #998]
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2802              		.loc 1 658 0
 2803 1820 1C0094E5 		ldr	r0, [r4, #28]
 656:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2804              		.loc 1 656 0
 2805 1824 E873C6E5 		strb	r7, [r6, #1000]
 2806              	.LVL215:
 658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2807              		.loc 1 658 0
 2808 1828 FEFFFFEB 		bl	_txe_mutex_get
 659:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2809              		.loc 1 659 0
 2810 182c 14C09DE5 		ldr	ip, [sp, #20]
 2811 1830 1910A0E3 		mov	r1, #25
 2812 1834 00C08DE5 		str	ip, [sp, #0]
 2813 1838 0400A0E1 		mov	r0, r4
 2814 183c 00C0A0E3 		mov	ip, #0
 2815 1840 0920A0E1 		mov	r2, r9
 2816 1844 0A30A0E1 		mov	r3, sl
 2817 1848 04C08DE5 		str	ip, [sp, #4]
 2818 184c FEFFFFEB 		bl	cmdSet
 660:../uvc.c      **** 							 if(getData != 0){
 2819              		.loc 1 660 0
 2820 1850 14109DE5 		ldr	r1, [sp, #20]
 2821 1854 000051E3 		cmp	r1, #0
 2822 1858 0700000A 		beq	.L174
 2823              	.LVL216:
 662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2824              		.loc 1 662 0
 2825 185c 18E09DE5 		ldr	lr, [sp, #24]
 2826 1860 0400A0E1 		mov	r0, r4
 2827 1864 1910A0E3 		mov	r1, #25
 2828 1868 0B20A0E1 		mov	r2, fp
 2829 186c 0A30A0E1 		mov	r3, sl
 2830 1870 00E08DE5 		str	lr, [sp, #0]
 2831 1874 04708DE5 		str	r7, [sp, #4]
 2832 1878 FEFFFFEB 		bl	cmdSet
 2833              	.LVL217:
 2834              	.L174:
 664:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2835              		.loc 1 664 0
 2836 187c 1C0094E5 		ldr	r0, [r4, #28]
 2837 1880 FEFFFFEB 		bl	_txe_mutex_put
 665:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2838              		.loc 1 665 0
 2839 1884 78119FE5 		ldr	r1, .L211+12
 2840 1888 74019FE5 		ldr	r0, .L211+12
 2841 188c 5A40D1E5 		ldrb	r4, [r1, #90]	@ zero_extendqisi2
 2842 1890 5B70D0E5 		ldrb	r7, [r0, #91]	@ zero_extendqisi2
 2843 1894 5820D1E5 		ldrb	r2, [r1, #88]	@ zero_extendqisi2
 2844 1898 5930D1E5 		ldrb	r3, [r1, #89]	@ zero_extendqisi2
 2845 189c 0400A0E3 		mov	r0, #4
 2846 18a0 88119FE5 		ldr	r1, .L211+56
 2847 18a4 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2848 18a8 8BFFFFEA 		b	.L202
 2849              	.LVL218:
 2850              	.L156:
 621:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2851              		.loc 1 621 0
 2852 18ac 000053E2 		subs	r0, r3, #0
 620:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2853              		.loc 1 620 0
 2854 18b0 0D03C6E5 		strb	r0, [r6, #781]
 2855 18b4 3C319FE5 		ldr	r3, .L211
 621:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2856              		.loc 1 621 0
 2857 18b8 2400001A 		bne	.L168
 622:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2858              		.loc 1 622 0
 2859 18bc B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2860 18c0 020052E3 		cmp	r2, #2
 2861 18c4 08005213 		cmpne	r2, #8
 2862 18c8 0300000A 		beq	.L169
 623:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2863              		.loc 1 623 0
 2864 18cc 010052E3 		cmp	r2, #1
 624:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2865              		.loc 1 624 0
 2866 18d0 07208202 		addeq	r2, r2, #7
 626:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2867              		.loc 1 626 0
 2868 18d4 0220A013 		movne	r2, #2
 2869 18d8 B524C3E5 		strb	r2, [r3, #1205]
 2870              	.LVL219:
 2871              	.L169:
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2872              		.loc 1 648 0
 2873 18dc 38419FE5 		ldr	r4, .L211+36
 646:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2874              		.loc 1 646 0
 2875 18e0 0130A0E3 		mov	r3, #1
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2876              		.loc 1 648 0
 2877 18e4 0010E0E3 		mvn	r1, #0
 2878 18e8 1C0094E5 		ldr	r0, [r4, #28]
 646:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2879              		.loc 1 646 0
 2880 18ec 1033C6E5 		strb	r3, [r6, #784]
 2881              	.LVL220:
 648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2882              		.loc 1 648 0
 2883 18f0 FEFFFFEB 		bl	_txe_mutex_get
 649:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2884              		.loc 1 649 0
 2885 18f4 14C09DE5 		ldr	ip, [sp, #20]
 2886 18f8 00E0A0E3 		mov	lr, #0
 2887 18fc 1010A0E3 		mov	r1, #16
 2888 1900 0920A0E1 		mov	r2, r9
 2889 1904 0A30A0E1 		mov	r3, sl
 2890 1908 0400A0E1 		mov	r0, r4
 2891 190c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2892 1910 FEFFFFEB 		bl	cmdSet
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2893              		.loc 1 650 0
 2894 1914 1C0094E5 		ldr	r0, [r4, #28]
 2895 1918 FEFFFFEB 		bl	_txe_mutex_put
 652:../uvc.c      **** 							 break;
 2896              		.loc 1 652 0
 2897 191c FFC0A0E3 		mov	ip, #255
 650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2898              		.loc 1 650 0
 2899 1920 14409DE5 		ldr	r4, [sp, #20]
 2900 1924 18E09DE5 		ldr	lr, [sp, #24]
 652:../uvc.c      **** 							 break;
 2901              		.loc 1 652 0
 2902 1928 0C70A0E1 		mov	r7, ip
 2903 192c 75FCFFEA 		b	.L114
 2904              	.LVL221:
 2905              	.L148:
 888:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2906              		.loc 1 888 0
 2907 1930 0400A0E3 		mov	r0, #4
 2908              	.LVL222:
 2909 1934 F8109FE5 		ldr	r1, .L211+60
 2910 1938 FEFFFFEB 		bl	CyU3PDebugPrint
 2911              	.LVL223:
 2912 193c FFC0A0E3 		mov	ip, #255
 2913 1940 0C70A0E1 		mov	r7, ip
 2914              	.LVL224:
 2915 1944 0CE0A0E1 		mov	lr, ip
 2916 1948 0C40A0E1 		mov	r4, ip
 2917 194c 6DFCFFEA 		b	.L114
 2918              	.LVL225:
 2919              	.L168:
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2920              		.loc 1 631 0
 2921 1950 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 630:../uvc.c      **** 								 Data1 = Data0 - 1;
 2922              		.loc 1 630 0
 2923 1954 017040E2 		sub	r7, r0, #1
 2924              	.LVL226:
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2925              		.loc 1 631 0
 2926 1958 040052E3 		cmp	r2, #4
 2927 195c 01005213 		cmpne	r2, #1
 630:../uvc.c      **** 								 Data1 = Data0 - 1;
 2928              		.loc 1 630 0
 2929 1960 FF1007E2 		and	r1, r7, #255
 2930              	.LVL227:
 631:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2931              		.loc 1 631 0
 2932 1964 0300000A 		beq	.L171
 632:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2933              		.loc 1 632 0
 2934 1968 080052E3 		cmp	r2, #8
 633:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2935              		.loc 1 633 0
 2936 196c 0120A003 		moveq	r2, #1
 635:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2937              		.loc 1 635 0
 2938 1970 0420A013 		movne	r2, #4
 2939 1974 B524C3E5 		strb	r2, [r3, #1205]
 2940              	.L171:
 638:../uvc.c      **** 								 if(Data1 < 8){
 2941              		.loc 1 638 0
 2942 1978 070051E3 		cmp	r1, #7
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2943              		.loc 1 639 0
 2944 197c B4309F95 		ldrls	r3, .L211+64
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2945              		.loc 1 642 0
 2946 1980 0130A083 		movhi	r3, #1
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2947              		.loc 1 640 0
 2948 1984 81008390 		addls	r0, r3, r1, asl #1
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2949              		.loc 1 639 0
 2950 1988 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 640:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2951              		.loc 1 640 0
 2952 198c 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 642:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2953              		.loc 1 642 0
 2954 1990 E534C685 		strhib	r3, [r6, #1253]
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2955              		.loc 1 643 0
 2956 1994 0030A083 		movhi	r3, #0
 639:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2957              		.loc 1 639 0
 2958 1998 E524C695 		strlsb	r2, [r6, #1253]
 643:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2959              		.loc 1 643 0
 2960 199c E634C6E5 		strb	r3, [r6, #1254]
 2961 19a0 CDFFFFEA 		b	.L169
 2962              	.LVL228:
 2963              	.L210:
 855:../uvc.c      **** 								 WDRflag = CyTrue; //WDR mode
 2964              		.loc 1 855 0
 2965 19a4 58209FE5 		ldr	r2, .L211+12
 2966 19a8 0160A0E3 		mov	r6, #1
 2967 19ac 786082E5 		str	r6, [r2, #120]
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2968              		.loc 1 858 0
 2969 19b0 9061C3E5 		strb	r6, [r3, #400]
 2970 19b4 2CFFFFEA 		b	.L185
 2971              	.LVL229:
 2972              	.L209:
 447:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2973              		.loc 1 447 0
 2974 19b8 0120A0E3 		mov	r2, #1
 2975 19bc 0400A0E3 		mov	r0, #4
 2976 19c0 5C109FE5 		ldr	r1, .L211+44
 2977 19c4 FEFFFFEB 		bl	CyU3PDebugPrint
 2978              	.LVL230:
 449:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2979              		.loc 1 449 0
 2980 19c8 28309FE5 		ldr	r3, .L211
 2981 19cc 0020A0E3 		mov	r2, #0
 2982 19d0 0440A0E3 		mov	r4, #4
 2983 19d4 2D24C3E5 		strb	r2, [r3, #1069]
 2984              	.LVL231:
 2985 19d8 81FDFFEA 		b	.L134
 2986              	.LVL232:
 2987              	.L199:
 2988 19dc 20009FE5 		ldr	r0, .L211+12
 2989 19e0 6EFDFFEA 		b	.L125
 2990              	.LVL233:
 2991              	.L188:
 390:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2992              		.loc 1 390 0
 2993 19e4 0030A0E3 		mov	r3, #0
 2994 19e8 11FEFFEA 		b	.L192
 2995              	.LVL234:
 2996              	.L187:
 2997 19ec 10009FE5 		ldr	r0, .L211+12
 2998 19f0 0030A0E3 		mov	r3, #0
 2999 19f4 62FDFFEA 		b	.L191
 3000              	.L212:
 3001              		.align	2
 3002              	.L211:
 3003 19f8 00000000 		.word	.LANCHOR1
 3004 19fc 00000000 		.word	bRequest
 3005 1a00 74030000 		.word	.LC22
 3006 1a04 00000000 		.word	.LANCHOR0
 3007 1a08 58000000 		.word	.LANCHOR0+88
 3008 1a0c 01000100 		.word	65537
 3009 1a10 FF00FF00 		.word	16711935
 3010 1a14 80020000 		.word	.LC16
 3011 1a18 BC020000 		.word	.LC17
 3012 1a1c 00000000 		.word	cmdQu
 3013 1a20 4C000000 		.word	.LANCHOR0+76
 3014 1a24 48020000 		.word	.LC15
 3015 1a28 2C030000 		.word	.LC20
 3016 1a2c 10030000 		.word	.LC19
 3017 1a30 E4020000 		.word	.LC18
 3018 1a34 44030000 		.word	.LC21
 3019 1a38 00000000 		.word	.LANCHOR2
 3020              		.cfi_endproc
 3021              	.LFE2:
 3023              		.align	2
 3024              		.global	CTControlHandle
 3026              	CTControlHandle:
 3027              	.LFB3:
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3028              		.loc 1 904 0
 3029              		.cfi_startproc
 3030              		@ args = 0, pretend = 0, frame = 64
 3031              		@ frame_needed = 0, uses_anonymous_args = 0
 3032              	.LVL235:
 3033 1a3c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3034              	.LCFI15:
 3035              		.cfi_def_cfa_offset 36
 923:../uvc.c      ****     reqData = bRequest;
 3036              		.loc 1 923 0
 3037 1a40 64A99FE5 		ldr	sl, .L298
 3038              		.cfi_offset 14, -4
 3039              		.cfi_offset 11, -8
 3040              		.cfi_offset 10, -12
 3041              		.cfi_offset 9, -16
 3042              		.cfi_offset 8, -20
 3043              		.cfi_offset 7, -24
 3044              		.cfi_offset 6, -28
 3045              		.cfi_offset 5, -32
 3046              		.cfi_offset 4, -36
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3047              		.loc 1 915 0
 3048 1a44 64899FE5 		ldr	r8, .L298+4
 923:../uvc.c      ****     reqData = bRequest;
 3049              		.loc 1 923 0
 3050 1a48 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3051              		.loc 1 915 0
 3052 1a4c 8090A0E1 		mov	r9, r0, asl #1
 3053 1a50 002089E0 		add	r2, r9, r0
 3054 1a54 822188E0 		add	r2, r8, r2, asl #3
 925:../uvc.c      ****     switch (bRequest)
 3055              		.loc 1 925 0
 3056 1a58 830055E3 		cmp	r5, #131
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3057              		.loc 1 904 0
 3058 1a5c 5CD04DE2 		sub	sp, sp, #92
 3059              	.LCFI16:
 3060              		.cfi_def_cfa_offset 128
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3061              		.loc 1 904 0
 3062 1a60 0060A0E1 		mov	r6, r0
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3063              		.loc 1 915 0
 3064 1a64 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3065              	.LVL236:
 916:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3066              		.loc 1 916 0
 3067 1a68 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3068              	.LVL237:
 918:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3069              		.loc 1 918 0
 3070 1a6c 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3071              	.LVL238:
 925:../uvc.c      ****     switch (bRequest)
 3072              		.loc 1 925 0
 3073 1a70 7600000A 		beq	.L218
 3074 1a74 2100009A 		bls	.L293
 3075 1a78 850055E3 		cmp	r5, #133
 3076 1a7c 5900000A 		beq	.L220
 3077 1a80 4E00003A 		bcc	.L219
 3078 1a84 860055E3 		cmp	r5, #134
 3079 1a88 8000000A 		beq	.L221
 3080 1a8c 870055E3 		cmp	r5, #135
 3081 1a90 7600000A 		beq	.L294
 3082              	.L214:
1132:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3083              		.loc 1 1132 0
 3084 1a94 0000A0E3 		mov	r0, #0
 3085              	.LVL239:
 3086 1a98 0110A0E3 		mov	r1, #1
 3087 1a9c 0020A0E1 		mov	r2, r0
 3088 1aa0 FEFFFFEB 		bl	CyU3PUsbStall
 3089              	.LVL240:
 3090 1aa4 08499FE5 		ldr	r4, .L298+8
1133:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3091              		.loc 1 1133 0
 3092 1aa8 0620A0E1 		mov	r2, r6
 3093 1aac 0400A0E3 		mov	r0, #4
 3094 1ab0 00199FE5 		ldr	r1, .L298+12
 3095 1ab4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3096 1ab8 FEFFFFEB 		bl	CyU3PDebugPrint
1134:../uvc.c      **** 			  break;
 3097              		.loc 1 1134 0
 3098 1abc FFC0A0E3 		mov	ip, #255
 3099 1ac0 0C60A0E1 		mov	r6, ip
 3100 1ac4 0C80A0E1 		mov	r8, ip
 3101              	.LVL241:
 3102              	.L224:
1138:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3103              		.loc 1 1138 0
 3104 1ac8 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3105 1acc 08C08DE5 		str	ip, [sp, #8]
 3106 1ad0 E4189FE5 		ldr	r1, .L298+16
 3107 1ad4 FFC0A0E3 		mov	ip, #255
 3108 1ad8 0520A0E1 		mov	r2, r5
 3109 1adc 0830A0E1 		mov	r3, r8
 3110 1ae0 0400A0E3 		mov	r0, #4
 3111 1ae4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3112 1ae8 0CC08DE5 		str	ip, [sp, #12]
 3113 1aec 10E08DE5 		str	lr, [sp, #16]
 3114 1af0 14708DE5 		str	r7, [sp, #20]
 3115 1af4 FEFFFFEB 		bl	CyU3PDebugPrint
1139:../uvc.c      **** }
 3116              		.loc 1 1139 0
 3117 1af8 5CD08DE2 		add	sp, sp, #92
 3118 1afc F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3119              	.LVL242:
 3120              	.L293:
 925:../uvc.c      ****     switch (bRequest)
 3121              		.loc 1 925 0
 3122 1b00 810055E3 		cmp	r5, #129
 3123 1b04 4200000A 		beq	.L216
 3124 1b08 1100009A 		bls	.L295
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3125              		.loc 1 954 0
 3126 1b0c A0489FE5 		ldr	r4, .L298+8
 3127 1b10 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3128              		.loc 1 955 0
 3129 1b14 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3130              		.loc 1 956 0
 3131 1b18 0A0050E3 		cmp	r0, #10
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3132              		.loc 1 954 0
 3133 1b1c 5810C4E5 		strb	r1, [r4, #88]
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3134              		.loc 1 955 0
 3135 1b20 5960C4E5 		strb	r6, [r4, #89]
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3136              		.loc 1 956 0
 3137 1b24 2C00000A 		beq	.L292
 3138              	.LVL243:
 3139              	.L231:
 990:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3140              		.loc 1 990 0
 3141 1b28 00E0A0E3 		mov	lr, #0
 3142 1b2c 5AE0C4E5 		strb	lr, [r4, #90]
 3143              	.L232:
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3144              		.loc 1 991 0
 3145 1b30 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3146              		.loc 1 992 0
 3147 1b34 0700A0E1 		mov	r0, r7
 3148              	.LVL244:
 3149 1b38 80189FE5 		ldr	r1, .L298+20
 994:../uvc.c      **** 			  break;
 3150              		.loc 1 994 0
 3151 1b3c FF60A0E3 		mov	r6, #255
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3152              		.loc 1 991 0
 3153 1b40 5B30C4E5 		strb	r3, [r4, #91]
 994:../uvc.c      **** 			  break;
 3154              		.loc 1 994 0
 3155 1b44 0680A0E1 		mov	r8, r6
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3156              		.loc 1 992 0
 3157 1b48 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3158              	.LVL245:
 3159 1b4c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 994:../uvc.c      **** 			  break;
 3160              		.loc 1 994 0
 3161 1b50 DCFFFFEA 		b	.L224
 3162              	.LVL246:
 3163              	.L295:
 925:../uvc.c      ****     switch (bRequest)
 3164              		.loc 1 925 0
 3165 1b54 010055E3 		cmp	r5, #1
 3166 1b58 CDFFFF1A 		bne	.L214
 996:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3167              		.loc 1 996 0
 3168 1b5c 50489FE5 		ldr	r4, .L298+8
 3169 1b60 56208DE2 		add	r2, sp, #86
 3170 1b64 2000A0E3 		mov	r0, #32
 3171              	.LVL247:
 3172 1b68 581084E2 		add	r1, r4, #88
 3173 1b6c 2C308DE5 		str	r3, [sp, #44]
 3174 1b70 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3175              	.LVL248:
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3176              		.loc 1 998 0
 3177 1b74 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3178              		.loc 1 999 0
 3179 1b78 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
1002:../uvc.c      **** 			  switch(CtrlID)
 3180              		.loc 1 1002 0
 3181 1b7c 012046E2 		sub	r2, r6, #1
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3182              		.loc 1 998 0
 3183 1b80 30008DE5 		str	r0, [sp, #48]
 3184              	.LVL249:
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3185              		.loc 1 999 0
 3186 1b84 34C08DE5 		str	ip, [sp, #52]
 3187              	.LVL250:
1002:../uvc.c      **** 			  switch(CtrlID)
 3188              		.loc 1 1002 0
 3189 1b88 2C309DE5 		ldr	r3, [sp, #44]
 3190 1b8c 090052E3 		cmp	r2, #9
 3191 1b90 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3192 1b94 550100EA 		b	.L233
 3193              	.L238:
 3194 1b98 AC200000 		.word	.L234
 3195 1b9c F0200000 		.word	.L233
 3196 1ba0 BC1D0000 		.word	.L235
 3197 1ba4 F0200000 		.word	.L233
 3198 1ba8 F0200000 		.word	.L233
 3199 1bac F0200000 		.word	.L233
 3200 1bb0 381D0000 		.word	.L236
 3201 1bb4 F0200000 		.word	.L233
 3202 1bb8 F0200000 		.word	.L233
 3203 1bbc BC1C0000 		.word	.L237
 3204              	.LVL251:
 3205              	.L219:
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3206              		.loc 1 972 0
 3207 1bc0 EC479FE5 		ldr	r4, .L298+8
 3208 1bc4 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3209              		.loc 1 973 0
 3210 1bc8 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3211              		.loc 1 974 0
 3212 1bcc 0A0050E3 		cmp	r0, #10
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3213              		.loc 1 972 0
 3214 1bd0 5880C4E5 		strb	r8, [r4, #88]
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3215              		.loc 1 973 0
 3216 1bd4 5920C4E5 		strb	r2, [r4, #89]
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3217              		.loc 1 974 0
 3218 1bd8 D2FFFF1A 		bne	.L231
 3219              	.LVL252:
 3220              	.L292:
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3221              		.loc 1 989 0 discriminator 1
 3222 1bdc 0110A0E3 		mov	r1, #1
 3223 1be0 5A10C4E5 		strb	r1, [r4, #90]
 3224 1be4 D1FFFFEA 		b	.L232
 3225              	.LVL253:
 3226              	.L220:
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3227              		.loc 1 929 0
 3228 1be8 C4479FE5 		ldr	r4, .L298+8
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3229              		.loc 1 930 0
 3230 1bec 0030A0E3 		mov	r3, #0
 3231              	.LVL254:
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3232              		.loc 1 931 0
 3233 1bf0 0200A0E3 		mov	r0, #2
 3234              	.LVL255:
 3235 1bf4 581084E2 		add	r1, r4, #88
 933:../uvc.c      **** 			  break;
 3236              		.loc 1 933 0
 3237 1bf8 FF60A0E3 		mov	r6, #255
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3238              		.loc 1 929 0
 3239 1bfc 5870C4E5 		strb	r7, [r4, #88]
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3240              		.loc 1 930 0
 3241 1c00 5930C4E5 		strb	r3, [r4, #89]
 933:../uvc.c      **** 			  break;
 3242              		.loc 1 933 0
 3243 1c04 0680A0E1 		mov	r8, r6
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3244              		.loc 1 931 0
 3245 1c08 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3246              	.LVL256:
 3247 1c0c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 933:../uvc.c      **** 			  break;
 3248              		.loc 1 933 0
 3249 1c10 ACFFFFEA 		b	.L224
 3250              	.LVL257:
 3251              	.L216:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3252              		.loc 1 939 0
 3253 1c14 98479FE5 		ldr	r4, .L298+8
 3254 1c18 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3255              		.loc 1 940 0
 3256 1c1c 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3257              		.loc 1 941 0
 3258 1c20 0080A0E3 		mov	r8, #0
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3259              		.loc 1 947 0
 3260 1c24 0700A0E1 		mov	r0, r7
 3261              	.LVL258:
 3262 1c28 581084E2 		add	r1, r4, #88
 952:../uvc.c      **** 			  break;
 3263              		.loc 1 952 0
 3264 1c2c FF60A0E3 		mov	r6, #255
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3265              		.loc 1 940 0
 3266 1c30 59C0C4E5 		strb	ip, [r4, #89]
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3267              		.loc 1 941 0
 3268 1c34 5A80C4E5 		strb	r8, [r4, #90]
 942:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3269              		.loc 1 942 0
 3270 1c38 5B80C4E5 		strb	r8, [r4, #91]
 3271              	.LVL259:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3272              		.loc 1 939 0
 3273 1c3c 58A0C4E5 		strb	sl, [r4, #88]
 952:../uvc.c      **** 			  break;
 3274              		.loc 1 952 0
 3275 1c40 0680A0E1 		mov	r8, r6
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3276              		.loc 1 947 0
 3277 1c44 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3278              	.LVL260:
 3279 1c48 0AC0A0E1 		mov	ip, sl
 952:../uvc.c      **** 			  break;
 3280              		.loc 1 952 0
 3281 1c4c 9DFFFFEA 		b	.L224
 3282              	.LVL261:
 3283              	.L218:
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3284              		.loc 1 963 0
 3285 1c50 5C479FE5 		ldr	r4, .L298+8
 3286 1c54 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3287              	.LVL262:
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3288              		.loc 1 964 0
 3289 1c58 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3290              		.loc 1 965 0
 3291 1c5c 0A0050E3 		cmp	r0, #10
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3292              		.loc 1 963 0
 3293 1c60 5830C4E5 		strb	r3, [r4, #88]
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3294              		.loc 1 964 0
 3295 1c64 59E0C4E5 		strb	lr, [r4, #89]
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3296              		.loc 1 965 0
 3297 1c68 AEFFFF1A 		bne	.L231
 3298 1c6c DAFFFFEA 		b	.L292
 3299              	.LVL263:
 3300              	.L294:
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3301              		.loc 1 987 0
 3302 1c70 3C479FE5 		ldr	r4, .L298+8
 3303 1c74 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3304              		.loc 1 988 0
 3305 1c78 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3306              		.loc 1 989 0
 3307 1c7c 0A0050E3 		cmp	r0, #10
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3308              		.loc 1 987 0
 3309 1c80 5860C4E5 		strb	r6, [r4, #88]
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3310              		.loc 1 988 0
 3311 1c84 59C0C4E5 		strb	ip, [r4, #89]
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3312              		.loc 1 989 0
 3313 1c88 A6FFFF1A 		bne	.L231
 3314 1c8c D2FFFFEA 		b	.L292
 3315              	.L221:
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3316              		.loc 1 981 0
 3317 1c90 1C479FE5 		ldr	r4, .L298+8
 3318 1c94 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3319              	.LVL264:
 3320 1c98 0410A0E1 		mov	r1, r4
 3321 1c9c 5800E1E5 		strb	r0, [r1, #88]!
 985:../uvc.c      **** 			  break;
 3322              		.loc 1 985 0
 3323 1ca0 FF60A0E3 		mov	r6, #255
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3324              		.loc 1 982 0
 3325 1ca4 0100A0E3 		mov	r0, #1
 3326 1ca8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3327              	.LVL265:
 985:../uvc.c      **** 			  break;
 3328              		.loc 1 985 0
 3329 1cac 0680A0E1 		mov	r8, r6
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3330              		.loc 1 982 0
 3331 1cb0 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 985:../uvc.c      **** 			  break;
 3332              		.loc 1 985 0
 3333 1cb4 0170A0E3 		mov	r7, #1
 3334 1cb8 82FFFFEA 		b	.L224
 3335              	.LVL266:
 3336              	.L237:
1111:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3337              		.loc 1 1111 0
 3338 1cbc 00679FE5 		ldr	r6, .L298+24
 3339 1cc0 0010E0E3 		mvn	r1, #0
 3340 1cc4 1C0096E5 		ldr	r0, [r6, #28]
 3341 1cc8 2C308DE5 		str	r3, [sp, #44]
 3342 1ccc FEFFFFEB 		bl	_txe_mutex_get
1112:../uvc.c      **** 					  if(getData == 1)
 3343              		.loc 1 1112 0
 3344 1cd0 30E09DE5 		ldr	lr, [sp, #48]
 3345 1cd4 2C309DE5 		ldr	r3, [sp, #44]
 3346 1cd8 01005EE3 		cmp	lr, #1
 3347 1cdc AA01000A 		beq	.L296
1114:../uvc.c      **** 					  else if(getData == 0xff)
 3348              		.loc 1 1114 0
 3349 1ce0 FF005EE3 		cmp	lr, #255
 3350 1ce4 9F01000A 		beq	.L297
1117:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 3351              		.loc 1 1117 0
 3352 1ce8 0080A0E3 		mov	r8, #0
 3353 1cec 0600A0E1 		mov	r0, r6
 3354 1cf0 2310A0E3 		mov	r1, #35
 3355 1cf4 0B20A0E1 		mov	r2, fp
 3356 1cf8 00808DE5 		str	r8, [sp, #0]
 3357 1cfc 04808DE5 		str	r8, [sp, #4]
 3358 1d00 FEFFFFEB 		bl	cmdSet
 3359              	.L290:
1120:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3360              		.loc 1 1120 0
 3361 1d04 1C0096E5 		ldr	r0, [r6, #28]
 3362 1d08 FEFFFFEB 		bl	_txe_mutex_put
1122:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3363              		.loc 1 1122 0
 3364 1d0c 30809DE5 		ldr	r8, [sp, #48]
 3365 1d10 34609DE5 		ldr	r6, [sp, #52]
 3366 1d14 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3367 1d18 0400A0E3 		mov	r0, #4
 3368 1d1c A4169FE5 		ldr	r1, .L298+28
 3369 1d20 0820A0E1 		mov	r2, r8
 3370 1d24 0630A0E1 		mov	r3, r6
 3371 1d28 00C08DE5 		str	ip, [sp, #0]
 3372 1d2c FEFFFFEB 		bl	CyU3PDebugPrint
1123:../uvc.c      **** 					  break;
 3373              		.loc 1 1123 0
 3374 1d30 FFC0A0E3 		mov	ip, #255
 3375 1d34 63FFFFEA 		b	.L224
 3376              	.LVL267:
 3377              	.L236:
1088:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3378              		.loc 1 1088 0
 3379 1d38 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3380 1d3c 010058E3 		cmp	r8, #1
 3381 1d40 08005813 		cmpne	r8, #8
 3382 1d44 0000A013 		movne	r0, #0
 3383 1d48 0100A003 		moveq	r0, #1
 3384 1d4c 8101001A 		bne	.L287
 3385              	.LVL268:
1091:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3386              		.loc 1 1091 0
 3387 1d50 6C869FE5 		ldr	r8, .L298+24
 3388 1d54 0010E0E3 		mvn	r1, #0
 3389 1d58 1C0098E5 		ldr	r0, [r8, #28]
 3390 1d5c 2C308DE5 		str	r3, [sp, #44]
 3391 1d60 FEFFFFEB 		bl	_txe_mutex_get
1092:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3392              		.loc 1 1092 0
 3393 1d64 30A09DE5 		ldr	sl, [sp, #48]
 3394 1d68 2210A0E3 		mov	r1, #34
 3395 1d6c 0B20A0E1 		mov	r2, fp
 3396 1d70 2C309DE5 		ldr	r3, [sp, #44]
 3397 1d74 00C0A0E3 		mov	ip, #0
 3398 1d78 0800A0E1 		mov	r0, r8
 3399 1d7c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3400 1d80 FEFFFFEB 		bl	cmdSet
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3401              		.loc 1 1093 0
 3402 1d84 1C0098E5 		ldr	r0, [r8, #28]
 3403 1d88 FEFFFFEB 		bl	_txe_mutex_put
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3404              		.loc 1 1096 0
 3405 1d8c 1C069FE5 		ldr	r0, .L298+4
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3406              		.loc 1 1097 0
 3407 1d90 34209DE5 		ldr	r2, [sp, #52]
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3408              		.loc 1 1096 0
 3409 1d94 061089E0 		add	r1, r9, r6
 3410 1d98 813180E0 		add	r3, r0, r1, asl #3
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3411              		.loc 1 1098 0
 3412 1d9c 0160A0E3 		mov	r6, #1
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3413              		.loc 1 1096 0
 3414 1da0 9DA4C3E5 		strb	sl, [r3, #1181]
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3415              		.loc 1 1097 0
 3416 1da4 9E24C3E5 		strb	r2, [r3, #1182]
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3417              		.loc 1 1098 0
 3418 1da8 A064C3E5 		strb	r6, [r3, #1184]
 3419              	.LVL269:
 3420              	.L288:
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3421              		.loc 1 1100 0
 3422 1dac 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3423 1db0 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1105:../uvc.c      **** 					  break;
 3424              		.loc 1 1105 0
 3425 1db4 FFC0A0E3 		mov	ip, #255
 3426 1db8 42FFFFEA 		b	.L224
 3427              	.LVL270:
 3428              	.L235:
1054:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3429              		.loc 1 1054 0
 3430 1dbc B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3431 1dc0 010050E3 		cmp	r0, #1
 3432 1dc4 04005013 		cmpne	r0, #4
 3433 1dc8 5D01001A 		bne	.L245
1053:../uvc.c      **** 					  value = (value << 8)|Data0;
 3434              		.loc 1 1053 0
 3435 1dcc 30109DE5 		ldr	r1, [sp, #48]
 3436 1dd0 34E09DE5 		ldr	lr, [sp, #52]
 3437 1dd4 0E2481E1 		orr	r2, r1, lr, asl #8
1055:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3438              		.loc 1 1055 0
 3439 1dd8 F90052E3 		cmp	r2, #249
 3440 1ddc 5801008A 		bhi	.L245
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3441              		.loc 1 1060 0
 3442 1de0 C8A042E2 		sub	sl, r2, #200
 3443 1de4 0AC8A0E1 		mov	ip, sl, asl #16
 3444 1de8 3CC08DE5 		str	ip, [sp, #60]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3445              		.loc 1 1062 0
 3446 1dec 27A062E2 		rsb	sl, r2, #39
 3447 1df0 38A08DE5 		str	sl, [sp, #56]
 3448 1df4 3CA09DE5 		ldr	sl, [sp, #60]
 3449 1df8 C81062E2 		rsb	r1, r2, #200
 3450 1dfc C80052E3 		cmp	r2, #200
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3451              		.loc 1 1060 0
 3452 1e00 640042E2 		sub	r0, r2, #100
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3453              		.loc 1 1062 0
 3454 1e04 0118A0E1 		mov	r1, r1, asl #16
 3455 1e08 64E062E2 		rsb	lr, r2, #100
 3456 1e0c 2A18A081 		movhi	r1, sl, lsr #16
 3457 1e10 2118A091 		movls	r1, r1, lsr #16
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3458              		.loc 1 1060 0
 3459 1e14 00C8A0E1 		mov	ip, r0, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3460              		.loc 1 1062 0
 3461 1e18 640052E3 		cmp	r2, #100
 3462 1e1c 0E08A0E1 		mov	r0, lr, asl #16
 3463 1e20 2C08A081 		movhi	r0, ip, lsr #16
 3464 1e24 38C09DE5 		ldr	ip, [sp, #56]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3465              		.loc 1 1060 0
 3466 1e28 14A042E2 		sub	sl, r2, #20
 3467 1e2c 38A08DE5 		str	sl, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3468              		.loc 1 1062 0
 3469 1e30 2008A091 		movls	r0, r0, lsr #16
 3470 1e34 14A062E2 		rsb	sl, r2, #20
 3471 1e38 3CA08DE5 		str	sl, [sp, #60]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3472              		.loc 1 1060 0
 3473 1e3c 27E042E2 		sub	lr, r2, #39
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3474              		.loc 1 1062 0
 3475 1e40 000051E1 		cmp	r1, r0
 3476 1e44 01A0A031 		movcc	sl, r1
 3477 1e48 00A0A021 		movcs	sl, r0
 3478 1e4c 0CC8A0E1 		mov	ip, ip, asl #16
 3479 1e50 270052E3 		cmp	r2, #39
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3480              		.loc 1 1060 0
 3481 1e54 0EE8A0E1 		mov	lr, lr, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3482              		.loc 1 1062 0
 3483 1e58 2CE8A091 		movls	lr, ip, lsr #16
 3484 1e5c 68C59FE5 		ldr	ip, .L298+32
 3485 1e60 20A08DE5 		str	sl, [sp, #32]
 3486 1e64 01A06CE0 		rsb	sl, ip, r1
 3487 1e68 2EE8A081 		movhi	lr, lr, lsr #16
 3488 1e6c 00C07AE2 		rsbs	ip, sl, #0
 3489 1e70 0AC0ACE0 		adc	ip, ip, sl
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3490              		.loc 1 1060 0
 3491 1e74 38A09DE5 		ldr	sl, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3492              		.loc 1 1062 0
 3493 1e78 44C08DE5 		str	ip, [sp, #68]
 3494              	.LVL271:
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3495              		.loc 1 1060 0
 3496 1e7c 0AC8A0E1 		mov	ip, sl, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3497              		.loc 1 1062 0
 3498 1e80 3CA09DE5 		ldr	sl, [sp, #60]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3499              		.loc 1 1060 0
 3500 1e84 4CC08DE5 		str	ip, [sp, #76]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3501              		.loc 1 1062 0
 3502 1e88 0AC8A0E1 		mov	ip, sl, asl #16
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3503              		.loc 1 1060 0
 3504 1e8c 0AA042E2 		sub	sl, r2, #10
 3505 1e90 48A08DE5 		str	sl, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3506              		.loc 1 1062 0
 3507 1e94 20A09DE5 		ldr	sl, [sp, #32]
 3508 1e98 3CC08DE5 		str	ip, [sp, #60]
 3509 1e9c 0A005EE1 		cmp	lr, sl
 3510 1ea0 0EA0A031 		movcc	sl, lr
 3511 1ea4 0AC062E2 		rsb	ip, r2, #10
 3512 1ea8 40C08DE5 		str	ip, [sp, #64]
 3513 1eac 38A08DE5 		str	sl, [sp, #56]
 3514 1eb0 3CC09DE5 		ldr	ip, [sp, #60]
 3515 1eb4 4CA09DE5 		ldr	sl, [sp, #76]
 3516 1eb8 140052E3 		cmp	r2, #20
 3517 1ebc 2CA8A091 		movls	sl, ip, lsr #16
 3518 1ec0 2AA8A081 		movhi	sl, sl, lsr #16
 3519 1ec4 44C09DE5 		ldr	ip, [sp, #68]
 3520 1ec8 010050E1 		cmp	r0, r1
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3521              		.loc 1 1060 0
 3522 1ecc 48109DE5 		ldr	r1, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3523              		.loc 1 1062 0
 3524 1ed0 01C0A033 		movcc	ip, #1
 3525 1ed4 3CA08DE5 		str	sl, [sp, #60]
 3526 1ed8 24C08DE5 		str	ip, [sp, #36]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3527              		.loc 1 1060 0
 3528 1edc 01A8A0E1 		mov	sl, r1, asl #16
 3529 1ee0 05C042E2 		sub	ip, r2, #5
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3530              		.loc 1 1062 0
 3531 1ee4 051062E2 		rsb	r1, r2, #5
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3532              		.loc 1 1060 0
 3533 1ee8 48A08DE5 		str	sl, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3534              		.loc 1 1062 0
 3535 1eec 40009DE5 		ldr	r0, [sp, #64]
 3536 1ef0 38A09DE5 		ldr	sl, [sp, #56]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3537              		.loc 1 1060 0
 3538 1ef4 40C08DE5 		str	ip, [sp, #64]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3539              		.loc 1 1062 0
 3540 1ef8 3CC09DE5 		ldr	ip, [sp, #60]
 3541 1efc 4C108DE5 		str	r1, [sp, #76]
 3542 1f00 48109DE5 		ldr	r1, [sp, #72]
 3543 1f04 0008A0E1 		mov	r0, r0, asl #16
 3544 1f08 0A005CE1 		cmp	ip, sl
 3545 1f0c 0AC0A021 		movcs	ip, sl
 3546 1f10 0A0052E3 		cmp	r2, #10
 3547 1f14 20A09DE5 		ldr	sl, [sp, #32]
 3548 1f18 2108A081 		movhi	r0, r1, lsr #16
 3549 1f1c 2008A091 		movls	r0, r0, lsr #16
 3550 1f20 48008DE5 		str	r0, [sp, #72]
 3551 1f24 24009DE5 		ldr	r0, [sp, #36]
 3552 1f28 0A005EE1 		cmp	lr, sl
 3553 1f2c 0200A033 		movcc	r0, #2
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3554              		.loc 1 1060 0
 3555 1f30 02E042E2 		sub	lr, r2, #2
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3556              		.loc 1 1062 0
 3557 1f34 44C08DE5 		str	ip, [sp, #68]
 3558 1f38 24008DE5 		str	r0, [sp, #36]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3559              		.loc 1 1060 0
 3560 1f3c 40C09DE5 		ldr	ip, [sp, #64]
 3561 1f40 1CE08DE5 		str	lr, [sp, #28]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3562              		.loc 1 1062 0
 3563 1f44 44009DE5 		ldr	r0, [sp, #68]
 3564 1f48 48E09DE5 		ldr	lr, [sp, #72]
 3565 1f4c 4C109DE5 		ldr	r1, [sp, #76]
 3566 1f50 02A062E2 		rsb	sl, r2, #2
 3567 1f54 00005EE1 		cmp	lr, r0
 3568 1f58 00E0A021 		movcs	lr, r0
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3569              		.loc 1 1060 0
 3570 1f5c 0CC8A0E1 		mov	ip, ip, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3571              		.loc 1 1062 0
 3572 1f60 050052E3 		cmp	r2, #5
 3573 1f64 40A08DE5 		str	sl, [sp, #64]
 3574 1f68 0118A0E1 		mov	r1, r1, asl #16
 3575 1f6c 3CA09DE5 		ldr	sl, [sp, #60]
 3576 1f70 2C18A081 		movhi	r1, ip, lsr #16
 3577 1f74 38C09DE5 		ldr	ip, [sp, #56]
 3578 1f78 4CE08DE5 		str	lr, [sp, #76]
 3579 1f7c 24009DE5 		ldr	r0, [sp, #36]
 3580 1f80 40E09DE5 		ldr	lr, [sp, #64]
 3581 1f84 2118A091 		movls	r1, r1, lsr #16
 3582 1f88 0C005AE1 		cmp	sl, ip
 3583 1f8c 20108DE5 		str	r1, [sp, #32]
 3584 1f90 0300A033 		movcc	r0, #3
 3585 1f94 38008DE5 		str	r0, [sp, #56]
 3586 1f98 4CA09DE5 		ldr	sl, [sp, #76]
 3587 1f9c 0E08A0E1 		mov	r0, lr, asl #16
 3588 1fa0 20E09DE5 		ldr	lr, [sp, #32]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3589              		.loc 1 1060 0
 3590 1fa4 1C109DE5 		ldr	r1, [sp, #28]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3591              		.loc 1 1062 0
 3592 1fa8 0A005EE1 		cmp	lr, sl
 3593 1fac 0AE0A021 		movcs	lr, sl
 3594 1fb0 44C09DE5 		ldr	ip, [sp, #68]
 3595 1fb4 48A09DE5 		ldr	sl, [sp, #72]
 3596 1fb8 020052E3 		cmp	r2, #2
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3597              		.loc 1 1060 0
 3598 1fbc 0118A0E1 		mov	r1, r1, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3599              		.loc 1 1062 0
 3600 1fc0 2018A091 		movls	r1, r0, lsr #16
 3601 1fc4 38009DE5 		ldr	r0, [sp, #56]
 3602 1fc8 2118A081 		movhi	r1, r1, lsr #16
 3603 1fcc 0C005AE1 		cmp	sl, ip
 3604 1fd0 0400A033 		movcc	r0, #4
 3605 1fd4 40008DE5 		str	r0, [sp, #64]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3606              		.loc 1 1060 0
 3607 1fd8 010042E2 		sub	r0, r2, #1
 3608 1fdc 38008DE5 		str	r0, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3609              		.loc 1 1062 0
 3610 1fe0 4CA09DE5 		ldr	sl, [sp, #76]
 3611 1fe4 20009DE5 		ldr	r0, [sp, #32]
 3612 1fe8 01C062E2 		rsb	ip, r2, #1
 3613 1fec 3CC08DE5 		str	ip, [sp, #60]
 3614 1ff0 0A0050E1 		cmp	r0, sl
1069:../uvc.c      **** 						  shutter = shutter+index;
 3615              		.loc 1 1069 0
 3616 1ff4 38A09DE5 		ldr	sl, [sp, #56]
 3617 1ff8 3C009DE5 		ldr	r0, [sp, #60]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3618              		.loc 1 1062 0
 3619 1ffc 40C09DE5 		ldr	ip, [sp, #64]
 3620 2000 05C0A033 		movcc	ip, #5
1069:../uvc.c      **** 						  shutter = shutter+index;
 3621              		.loc 1 1069 0
 3622 2004 010052E3 		cmp	r2, #1
 3623 2008 0028A091 		movls	r2, r0, asl #16
 3624 200c 0A28A081 		movhi	r2, sl, asl #16
 3625 2010 0E0051E1 		cmp	r1, lr
 3626 2014 01A0A031 		movcc	sl, r1
 3627 2018 0EA0A021 		movcs	sl, lr
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3628              		.loc 1 1062 0
 3629 201c 0E0051E1 		cmp	r1, lr
 3630 2020 0C10A021 		movcs	r1, ip
 3631 2024 0610A033 		movcc	r1, #6
1069:../uvc.c      **** 						  shutter = shutter+index;
 3632              		.loc 1 1069 0
 3633 2028 22085AE1 		cmp	sl, r2, lsr #16
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3634              		.loc 1 1072 0
 3635 202c 90A39FE5 		ldr	sl, .L298+24
1069:../uvc.c      **** 						  shutter = shutter+index;
 3636              		.loc 1 1069 0
 3637 2030 0120A091 		movls	r2, r1
 3638 2034 0720A083 		movhi	r2, #7
 3639 2038 012082E2 		add	r2, r2, #1
 3640 203c FFE002E2 		and	lr, r2, #255
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3641              		.loc 1 1072 0
 3642 2040 0010E0E3 		mvn	r1, #0
 3643 2044 1C009AE5 		ldr	r0, [sl, #28]
1069:../uvc.c      **** 						  shutter = shutter+index;
 3644              		.loc 1 1069 0
 3645 2048 38E08DE5 		str	lr, [sp, #56]
 3646              	.LVL272:
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3647              		.loc 1 1072 0
 3648 204c 2C308DE5 		str	r3, [sp, #44]
 3649 2050 FEFFFFEB 		bl	_txe_mutex_get
1073:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3650              		.loc 1 1073 0
 3651 2054 38C09DE5 		ldr	ip, [sp, #56]
 3652 2058 0310A0E3 		mov	r1, #3
 3653 205c 0B20A0E1 		mov	r2, fp
 3654 2060 2C309DE5 		ldr	r3, [sp, #44]
 3655 2064 00C08DE5 		str	ip, [sp, #0]
 3656 2068 0A00A0E1 		mov	r0, sl
 3657 206c 00C0A0E3 		mov	ip, #0
 3658 2070 04C08DE5 		str	ip, [sp, #4]
 3659 2074 FEFFFFEB 		bl	cmdSet
1074:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3660              		.loc 1 1074 0
 3661 2078 1C009AE5 		ldr	r0, [sl, #28]
 3662 207c FEFFFFEB 		bl	_txe_mutex_put
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3663              		.loc 1 1077 0
 3664 2080 30009DE5 		ldr	r0, [sp, #48]
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3665              		.loc 1 1078 0
 3666 2084 34C09DE5 		ldr	ip, [sp, #52]
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3667              		.loc 1 1080 0
 3668 2088 38309DE5 		ldr	r3, [sp, #56]
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3669              		.loc 1 1077 0
 3670 208c 061089E0 		add	r1, r9, r6
 3671 2090 816188E0 		add	r6, r8, r1, asl #3
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3672              		.loc 1 1079 0
 3673 2094 0120A0E3 		mov	r2, #1
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3674              		.loc 1 1077 0
 3675 2098 9D04C6E5 		strb	r0, [r6, #1181]
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3676              		.loc 1 1078 0
 3677 209c 9EC4C6E5 		strb	ip, [r6, #1182]
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3678              		.loc 1 1079 0
 3679 20a0 A024C6E5 		strb	r2, [r6, #1184]
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3680              		.loc 1 1080 0
 3681 20a4 0D33C8E5 		strb	r3, [r8, #781]
 3682 20a8 3FFFFFEA 		b	.L288
 3683              	.LVL273:
 3684              	.L234:
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3685              		.loc 1 1007 0
 3686 20ac 062089E0 		add	r2, r9, r6
 3687 20b0 826188E0 		add	r6, r8, r2, asl #3
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3688              		.loc 1 1008 0
 3689 20b4 0110A0E3 		mov	r1, #1
1011:../uvc.c      **** 		  		    switch (getData){
 3690              		.loc 1 1011 0
 3691 20b8 01E040E2 		sub	lr, r0, #1
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3692              		.loc 1 1007 0
 3693 20bc 9D04C6E5 		strb	r0, [r6, #1181]
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3694              		.loc 1 1008 0
 3695 20c0 A014C6E5 		strb	r1, [r6, #1184]
 3696              	.LVL274:
1011:../uvc.c      **** 		  		    switch (getData){
 3697              		.loc 1 1011 0
 3698 20c4 07005EE3 		cmp	lr, #7
 3699 20c8 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3700 20cc 980000EA 		b	.L239
 3701              	.L244:
 3702 20d0 C8220000 		.word	.L240
 3703 20d4 2C220000 		.word	.L241
 3704 20d8 34230000 		.word	.L239
 3705 20dc C4210000 		.word	.L242
 3706 20e0 34230000 		.word	.L239
 3707 20e4 34230000 		.word	.L239
 3708 20e8 34230000 		.word	.L239
 3709 20ec 24210000 		.word	.L243
 3710              	.LVL275:
 3711              	.L233:
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3712              		.loc 1 1127 0
 3713 20f0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3714              		.loc 1 1126 0
 3715 20f4 30A09DE5 		ldr	sl, [sp, #48]
 3716 20f8 069089E0 		add	r9, r9, r6
 3717 20fc 89E188E0 		add	lr, r8, r9, asl #3
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3718              		.loc 1 1127 0
 3719 2100 0620A0E1 		mov	r2, r6
 3720 2104 0400A0E3 		mov	r0, #4
 3721 2108 C0129FE5 		ldr	r1, .L298+36
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3722              		.loc 1 1126 0
 3723 210c 9DA4CEE5 		strb	sl, [lr, #1181]
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3724              		.loc 1 1127 0
 3725 2110 FEFFFFEB 		bl	CyU3PDebugPrint
1128:../uvc.c      **** 			  		 break;
 3726              		.loc 1 1128 0
 3727 2114 FFC0A0E3 		mov	ip, #255
 3728 2118 0C60A0E1 		mov	r6, ip
 3729 211c 0C80A0E1 		mov	r8, ip
 3730 2120 68FEFFEA 		b	.L224
 3731              	.LVL276:
 3732              	.L243:
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3733              		.loc 1 1030 0
 3734 2124 98629FE5 		ldr	r6, .L298+24
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3735              		.loc 1 1028 0
 3736 2128 00A0A0E3 		mov	sl, #0
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3737              		.loc 1 1030 0
 3738 212c 1C0096E5 		ldr	r0, [r6, #28]
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3739              		.loc 1 1028 0
 3740 2130 0DA3C8E5 		strb	sl, [r8, #781]
 3741              	.LVL277:
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3742              		.loc 1 1030 0
 3743 2134 0010E0E3 		mvn	r1, #0
 3744 2138 2C308DE5 		str	r3, [sp, #44]
 3745 213c FEFFFFEB 		bl	_txe_mutex_get
1031:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3746              		.loc 1 1031 0
 3747 2140 0B20A0E1 		mov	r2, fp
 3748 2144 2C309DE5 		ldr	r3, [sp, #44]
 3749 2148 1010A0E3 		mov	r1, #16
 3750 214c 0600A0E1 		mov	r0, r6
 3751 2150 00A08DE5 		str	sl, [sp, #0]
 3752 2154 04A08DE5 		str	sl, [sp, #4]
 3753 2158 FEFFFFEB 		bl	cmdSet
1032:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3754              		.loc 1 1032 0
 3755 215c 1C0096E5 		ldr	r0, [r6, #28]
 3756 2160 FEFFFFEB 		bl	_txe_mutex_put
 3757              	.LVL278:
 3758              	.LBB66:
 3759              	.LBB67:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3760              		.loc 1 384 0
 3761 2164 0010E0E3 		mvn	r1, #0
 3762 2168 1C0096E5 		ldr	r0, [r6, #28]
 3763 216c FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3764              		.loc 1 385 0
 3765 2170 01C0A0E3 		mov	ip, #1
 3766 2174 2010A0E3 		mov	r1, #32
 3767 2178 2720A0E3 		mov	r2, #39
 3768 217c 3030A0E3 		mov	r3, #48
 3769 2180 0600A0E1 		mov	r0, r6
 3770 2184 00C08DE5 		str	ip, [sp, #0]
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3771              		.loc 1 386 0
 3772 2188 0280A0E3 		mov	r8, #2
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3773              		.loc 1 385 0
 3774 218c 04A08DE5 		str	sl, [sp, #4]
 3775 2190 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3776              		.loc 1 386 0
 3777 2194 2110A0E3 		mov	r1, #33
 3778 2198 2520A0E3 		mov	r2, #37
 3779 219c 3030A0E3 		mov	r3, #48
 3780 21a0 0600A0E1 		mov	r0, r6
 3781 21a4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3782 21a8 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3783              		.loc 1 387 0
 3784 21ac 1C0096E5 		ldr	r0, [r6, #28]
 3785 21b0 FEFFFFEB 		bl	_txe_mutex_put
 3786              	.LBE67:
 3787              	.LBE66:
1034:../uvc.c      **** 							break;
 3788              		.loc 1 1034 0
 3789 21b4 FFC0A0E3 		mov	ip, #255
 3790 21b8 0C60A0E1 		mov	r6, ip
 3791 21bc 0880A0E3 		mov	r8, #8
 3792 21c0 40FEFFEA 		b	.L224
 3793              	.LVL279:
 3794              	.L242:
 3795              	.LBB68:
 3796              	.LBB69:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3797              		.loc 1 384 0
 3798 21c4 F8619FE5 		ldr	r6, .L298+24
 3799 21c8 0010E0E3 		mvn	r1, #0
 3800 21cc 1C0096E5 		ldr	r0, [r6, #28]
 3801 21d0 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3802              		.loc 1 385 0
 3803 21d4 0080A0E3 		mov	r8, #0
 3804 21d8 2010A0E3 		mov	r1, #32
 3805 21dc 2720A0E3 		mov	r2, #39
 3806 21e0 3030A0E3 		mov	r3, #48
 3807 21e4 0600A0E1 		mov	r0, r6
 3808 21e8 00808DE5 		str	r8, [sp, #0]
 3809 21ec 04808DE5 		str	r8, [sp, #4]
 3810 21f0 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3811              		.loc 1 386 0
 3812 21f4 01C0A0E3 		mov	ip, #1
 3813 21f8 2110A0E3 		mov	r1, #33
 3814 21fc 2520A0E3 		mov	r2, #37
 3815 2200 3030A0E3 		mov	r3, #48
 3816 2204 0600A0E1 		mov	r0, r6
 3817 2208 00C08DE5 		str	ip, [sp, #0]
 3818 220c 04808DE5 		str	r8, [sp, #4]
 3819 2210 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3820              		.loc 1 387 0
 3821 2214 1C0096E5 		ldr	r0, [r6, #28]
 3822 2218 FEFFFFEB 		bl	_txe_mutex_put
 3823 221c FFC0A0E3 		mov	ip, #255
 3824 2220 0C60A0E1 		mov	r6, ip
 3825 2224 0480A0E3 		mov	r8, #4
 3826 2228 26FEFFEA 		b	.L224
 3827              	.LVL280:
 3828              	.L241:
 3829              	.LBE69:
 3830              	.LBE68:
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3831              		.loc 1 1018 0
 3832 222c 90619FE5 		ldr	r6, .L298+24
1016:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3833              		.loc 1 1016 0
 3834 2230 00A0A0E3 		mov	sl, #0
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3835              		.loc 1 1018 0
 3836 2234 1C0096E5 		ldr	r0, [r6, #28]
1016:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3837              		.loc 1 1016 0
 3838 2238 0DA3C8E5 		strb	sl, [r8, #781]
 3839              	.LVL281:
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3840              		.loc 1 1018 0
 3841 223c 0010E0E3 		mvn	r1, #0
 3842 2240 2C308DE5 		str	r3, [sp, #44]
 3843 2244 FEFFFFEB 		bl	_txe_mutex_get
1019:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3844              		.loc 1 1019 0
 3845 2248 0B20A0E1 		mov	r2, fp
 3846 224c 2C309DE5 		ldr	r3, [sp, #44]
 3847 2250 1010A0E3 		mov	r1, #16
 3848 2254 0600A0E1 		mov	r0, r6
 3849 2258 00A08DE5 		str	sl, [sp, #0]
 3850 225c 04A08DE5 		str	sl, [sp, #4]
 3851 2260 FEFFFFEB 		bl	cmdSet
1020:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3852              		.loc 1 1020 0
 3853 2264 1C0096E5 		ldr	r0, [r6, #28]
 3854 2268 FEFFFFEB 		bl	_txe_mutex_put
 3855              	.LVL282:
 3856              	.LBB70:
 3857              	.LBB71:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3858              		.loc 1 384 0
 3859 226c 0010E0E3 		mvn	r1, #0
 3860 2270 1C0096E5 		ldr	r0, [r6, #28]
 3861 2274 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3862              		.loc 1 385 0
 3863 2278 2010A0E3 		mov	r1, #32
 3864 227c 2720A0E3 		mov	r2, #39
 3865 2280 3030A0E3 		mov	r3, #48
 3866 2284 0600A0E1 		mov	r0, r6
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3867              		.loc 1 386 0
 3868 2288 0180A0E3 		mov	r8, #1
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3869              		.loc 1 385 0
 3870 228c 00A08DE5 		str	sl, [sp, #0]
 3871 2290 04A08DE5 		str	sl, [sp, #4]
 3872 2294 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3873              		.loc 1 386 0
 3874 2298 2110A0E3 		mov	r1, #33
 3875 229c 2520A0E3 		mov	r2, #37
 3876 22a0 3030A0E3 		mov	r3, #48
 3877 22a4 0600A0E1 		mov	r0, r6
 3878 22a8 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3879 22ac FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3880              		.loc 1 387 0
 3881 22b0 1C0096E5 		ldr	r0, [r6, #28]
 3882 22b4 FEFFFFEB 		bl	_txe_mutex_put
 3883 22b8 FFC0A0E3 		mov	ip, #255
 3884 22bc 0C60A0E1 		mov	r6, ip
 3885 22c0 0280A0E3 		mov	r8, #2
 3886 22c4 FFFDFFEA 		b	.L224
 3887              	.LVL283:
 3888              	.L240:
 3889              	.LBE71:
 3890              	.LBE70:
 3891              	.LBB72:
 3892              	.LBB73:
 384:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3893              		.loc 1 384 0
 3894 22c8 F4609FE5 		ldr	r6, .L298+24
 3895 22cc 0010E0E3 		mvn	r1, #0
 3896 22d0 1C0096E5 		ldr	r0, [r6, #28]
 3897 22d4 FEFFFFEB 		bl	_txe_mutex_get
 385:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 3898              		.loc 1 385 0
 3899 22d8 0080A0E3 		mov	r8, #0
 3900 22dc 01A0A0E3 		mov	sl, #1
 3901 22e0 2010A0E3 		mov	r1, #32
 3902 22e4 2720A0E3 		mov	r2, #39
 3903 22e8 3030A0E3 		mov	r3, #48
 3904 22ec 0600A0E1 		mov	r0, r6
 3905 22f0 04808DE5 		str	r8, [sp, #4]
 3906 22f4 00A08DE5 		str	sl, [sp, #0]
 3907 22f8 FEFFFFEB 		bl	cmdSet
 386:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 3908              		.loc 1 386 0
 3909 22fc 02C0A0E3 		mov	ip, #2
 3910 2300 2110A0E3 		mov	r1, #33
 3911 2304 2520A0E3 		mov	r2, #37
 3912 2308 3030A0E3 		mov	r3, #48
 3913 230c 0600A0E1 		mov	r0, r6
 3914 2310 00C08DE5 		str	ip, [sp, #0]
 3915 2314 04808DE5 		str	r8, [sp, #4]
 3916 2318 FEFFFFEB 		bl	cmdSet
 387:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3917              		.loc 1 387 0
 3918 231c 1C0096E5 		ldr	r0, [r6, #28]
 3919 2320 FEFFFFEB 		bl	_txe_mutex_put
 3920              	.LBE73:
 3921              	.LBE72:
1014:../uvc.c      **** 							break;
 3922              		.loc 1 1014 0
 3923 2324 FFC0A0E3 		mov	ip, #255
 3924 2328 0C60A0E1 		mov	r6, ip
 3925 232c 0A80A0E1 		mov	r8, sl
 3926 2330 E4FDFFEA 		b	.L224
 3927              	.LVL284:
 3928              	.L239:
1011:../uvc.c      **** 		  		    switch (getData){
 3929              		.loc 1 1011 0
 3930 2334 FFC0A0E3 		mov	ip, #255
 3931 2338 0080A0E1 		mov	r8, r0
 3932 233c 0C60A0E1 		mov	r6, ip
 3933 2340 E0FDFFEA 		b	.L224
 3934              	.LVL285:
 3935              	.L245:
1082:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3936              		.loc 1 1082 0
 3937 2344 0000A0E3 		mov	r0, #0
 3938 2348 0110A0E3 		mov	r1, #1
 3939 234c 0020A0E1 		mov	r2, r0
 3940 2350 FEFFFFEB 		bl	CyU3PUsbStall
 3941              	.LVL286:
 3942 2354 94FEFFEA 		b	.L288
 3943              	.LVL287:
 3944              	.L287:
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3945              		.loc 1 1100 0
 3946 2358 0110A0E3 		mov	r1, #1
 3947 235c 0020A0E1 		mov	r2, r0
 3948 2360 FEFFFFEB 		bl	CyU3PUsbStall
 3949 2364 90FEFFEA 		b	.L288
 3950              	.LVL288:
 3951              	.L297:
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3952              		.loc 1 1115 0
 3953 2368 08E0A0E3 		mov	lr, #8
 3954 236c 00C0A0E3 		mov	ip, #0
 3955 2370 0600A0E1 		mov	r0, r6
 3956 2374 2310A0E3 		mov	r1, #35
 3957 2378 0B20A0E1 		mov	r2, fp
 3958 237c 00E08DE5 		str	lr, [sp, #0]
 3959 2380 04C08DE5 		str	ip, [sp, #4]
 3960 2384 FEFFFFEB 		bl	cmdSet
 3961 2388 5DFEFFEA 		b	.L290
 3962              	.L296:
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3963              		.loc 1 1113 0
 3964 238c 0480A0E3 		mov	r8, #4
 3965 2390 00E0A0E3 		mov	lr, #0
 3966 2394 0600A0E1 		mov	r0, r6
 3967 2398 2310A0E3 		mov	r1, #35
 3968 239c 0B20A0E1 		mov	r2, fp
 3969 23a0 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3970 23a4 FEFFFFEB 		bl	cmdSet
 3971 23a8 55FEFFEA 		b	.L290
 3972              	.L299:
 3973              		.align	2
 3974              	.L298:
 3975 23ac 00000000 		.word	bRequest
 3976 23b0 00000000 		.word	.LANCHOR1
 3977 23b4 00000000 		.word	.LANCHOR0
 3978 23b8 10040000 		.word	.LC25
 3979 23bc 34040000 		.word	.LC26
 3980 23c0 58000000 		.word	.LANCHOR0+88
 3981 23c4 00000000 		.word	cmdQu
 3982 23c8 C4030000 		.word	.LC23
 3983 23cc FFFF0000 		.word	65535
 3984 23d0 EC030000 		.word	.LC24
 3985              		.cfi_endproc
 3986              	.LFE3:
 3988              		.align	2
 3989              		.global	UVCAppEP0Thread_Entry
 3991              	UVCAppEP0Thread_Entry:
 3992              	.LFB24:
3098:../uvc.c      **** {
 3993              		.loc 1 3098 0
 3994              		.cfi_startproc
 3995              		@ args = 0, pretend = 0, frame = 32
 3996              		@ frame_needed = 0, uses_anonymous_args = 0
 3997              	.LVL289:
 3998 23d4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3999              	.LCFI17:
 4000              		.cfi_def_cfa_offset 36
 4001 23d8 DC499FE5 		ldr	r4, .L447
 4002              		.cfi_offset 14, -4
 4003              		.cfi_offset 11, -8
 4004              		.cfi_offset 10, -12
 4005              		.cfi_offset 9, -16
 4006              		.cfi_offset 8, -20
 4007              		.cfi_offset 7, -24
 4008              		.cfi_offset 6, -28
 4009              		.cfi_offset 5, -32
 4010              		.cfi_offset 4, -36
 4011 23dc DC699FE5 		ldr	r6, .L447+4
 4012 23e0 DCA99FE5 		ldr	sl, .L447+8
 4013 23e4 DC999FE5 		ldr	r9, .L447+12
 4014 23e8 DC899FE5 		ldr	r8, .L447+16
 4015 23ec DC799FE5 		ldr	r7, .L447+20
 4016 23f0 3CD04DE2 		sub	sp, sp, #60
 4017              	.LCFI18:
 4018              		.cfi_def_cfa_offset 96
 4019              	.LVL290:
3120:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4020              		.loc 1 3120 0
 4021 23f4 0450A0E1 		mov	r5, r4
 4022              	.LVL291:
 4023              	.L424:
 4024 23f8 00C0E0E3 		mvn	ip, #0
 4025 23fc B8099FE5 		ldr	r0, .L447
 4026 2400 4C10A0E3 		mov	r1, #76
 4027 2404 0120A0E3 		mov	r2, #1
 4028 2408 30308DE2 		add	r3, sp, #48
 4029 240c 00C08DE5 		str	ip, [sp, #0]
 4030 2410 FEFFFFEB 		bl	_txe_event_flags_get
 4031 2414 000050E3 		cmp	r0, #0
 4032 2418 3000001A 		bne	.L301
3124:../uvc.c      ****             if (!isUsbConnected)
 4033              		.loc 1 3124 0
 4034 241c 3C3095E5 		ldr	r3, [r5, #60]
 4035 2420 000053E3 		cmp	r3, #0
 4036 2424 8900000A 		beq	.L438
 4037              	.L302:
3133:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4038              		.loc 1 3133 0
 4039 2428 30309DE5 		ldr	r3, [sp, #48]
 4040 242c 0C0013E3 		tst	r3, #12
 4041 2430 7200001A 		bne	.L439
 4042              	.L303:
3140:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4043              		.loc 1 3140 0
 4044 2434 040013E3 		tst	r3, #4
 4045 2438 1C00000A 		beq	.L304
3142:../uvc.c      ****             	switch ((wIndex >> 8))
 4046              		.loc 1 3142 0
 4047 243c B0E0D8E1 		ldrh	lr, [r8, #0]
 4048 2440 2E24A0E1 		mov	r2, lr, lsr #8
 4049 2444 030052E3 		cmp	r2, #3
 4050 2448 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4051 244c 120000EA 		b	.L305
 4052              	.L310:
 4053 2450 9C240000 		.word	.L305
 4054 2454 80250000 		.word	.L307
 4055 2458 60240000 		.word	.L308
 4056 245c BC250000 		.word	.L309
 4057              	.L308:
 4058              	.LBB88:
 4059              	.LBB90:
2425:../uvc.c      ****     switch (wValue)
 4060              		.loc 1 2425 0
 4061 2460 B020D9E1 		ldrh	r2, [r9, #0]
 4062 2464 060C52E3 		cmp	r2, #1536
 4063 2468 D901000A 		beq	.L316
 4064 246c D000008A 		bhi	.L322
 4065 2470 030C52E3 		cmp	r2, #768
 4066 2474 D201000A 		beq	.L314
 4067 2478 C901008A 		bhi	.L323
 4068 247c 010C52E3 		cmp	r2, #256
 4069 2480 6801000A 		beq	.L312
 4070 2484 020C52E3 		cmp	r2, #512
 4071 2488 6201000A 		beq	.L440
 4072              	.L325:
 4073              	.LBE90:
 4074              	.LBE88:
 4075              	.LBB93:
 4076              	.LBB97:
2557:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4077              		.loc 1 2557 0
 4078 248c 40199FE5 		ldr	r1, .L447+24
 4079 2490 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4080 2494 0400A0E3 		mov	r0, #4
 4081 2498 FEFFFFEB 		bl	CyU3PDebugPrint
 4082              	.L305:
 4083              	.LBE97:
 4084              	.LBE93:
3163:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4085              		.loc 1 3163 0
 4086 249c 0000A0E3 		mov	r0, #0
 4087 24a0 0110A0E3 		mov	r1, #1
 4088 24a4 0020A0E1 		mov	r2, r0
 4089 24a8 FEFFFFEB 		bl	CyU3PUsbStall
 4090 24ac 30309DE5 		ldr	r3, [sp, #48]
 4091              	.L304:
3168:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4092              		.loc 1 3168 0
 4093 24b0 080013E3 		tst	r3, #8
 4094 24b4 0700000A 		beq	.L366
3172:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4095              		.loc 1 3172 0
 4096 24b8 B030D8E1 		ldrh	r3, [r8, #0]
 4097 24bc 010053E3 		cmp	r3, #1
 4098 24c0 6800000A 		beq	.L367
 4099              	.L368:
 4100              	.LBB102:
 4101              	.LBB108:
3087:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4102              		.loc 1 3087 0
 4103 24c4 0000A0E3 		mov	r0, #0
 4104 24c8 0110A0E3 		mov	r1, #1
 4105 24cc 0020A0E1 		mov	r2, r0
 4106 24d0 FEFFFFEB 		bl	CyU3PUsbStall
 4107              	.L428:
 4108 24d4 30309DE5 		ldr	r3, [sp, #48]
 4109              	.L366:
 4110              	.LBE108:
 4111              	.LBE102:
3183:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4112              		.loc 1 3183 0
 4113 24d8 400013E3 		tst	r3, #64
 4114 24dc 0100001A 		bne	.L441
 4115              	.L301:
3396:../uvc.c      ****         CyU3PThreadRelinquish ();
 4116              		.loc 1 3396 0
 4117 24e0 FEFFFFEB 		bl	_txe_thread_relinquish
3397:../uvc.c      ****     }
 4118              		.loc 1 3397 0
 4119 24e4 C3FFFFEA 		b	.L424
 4120              	.L441:
3188:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4121              		.loc 1 3188 0
 4122 24e8 1800A0E3 		mov	r0, #24
 4123 24ec 2C108DE2 		add	r1, sp, #44
 4124 24f0 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3193:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4125              		.loc 1 3193 0
 4126 24f4 2C209DE5 		ldr	r2, [sp, #44]
 4127 24f8 000052E3 		cmp	r2, #0
 4128 24fc 6D00000A 		beq	.L419
3193:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4129              		.loc 1 3193 0 is_stmt 0 discriminator 1
 4130 2500 5F36D6E5 		ldrb	r3, [r6, #1631]	@ zero_extendqisi2
 4131 2504 000053E3 		cmp	r3, #0
 4132 2508 F4FFFF1A 		bne	.L301
3195:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4133              		.loc 1 3195 0 is_stmt 1
 4134 250c 002097E5 		ldr	r2, [r7, #0]
 4135 2510 02B0A0E3 		mov	fp, #2
 4136 2514 00B0C2E5 		strb	fp, [r2, #0]
3196:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4137              		.loc 1 3196 0
 4138 2518 001097E5 		ldr	r1, [r7, #0]
 4139 251c 01B0A0E3 		mov	fp, #1
 4140 2520 01B0C1E5 		strb	fp, [r1, #1]
3197:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4141              		.loc 1 3197 0
 4142 2524 000097E5 		ldr	r0, [r7, #0]
3201:../uvc.c      **** 					interStabuf.size   = 1024;
 4143              		.loc 1 3201 0
 4144 2528 01EBA0E3 		mov	lr, #1024	@ movhi
3197:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4145              		.loc 1 3197 0
 4146 252c 0230C0E5 		strb	r3, [r0, #2]
3198:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4147              		.loc 1 3198 0
 4148 2530 00C097E5 		ldr	ip, [r7, #0]
3207:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4149              		.loc 1 3207 0
 4150 2534 0010E0E3 		mvn	r1, #0
3198:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4151              		.loc 1 3198 0
 4152 2538 0330CCE5 		strb	r3, [ip, #3]
3200:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4153              		.loc 1 3200 0
 4154 253c 002097E5 		ldr	r2, [r7, #0]
3202:../uvc.c      **** 					interStabuf.status = 0;
 4155              		.loc 1 3202 0
 4156 2540 B832CDE1 		strh	r3, [sp, #40]	@ movhi
3207:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4157              		.loc 1 3207 0
 4158 2544 8C089FE5 		ldr	r0, .L447+28
3204:../uvc.c      **** 					interStabuf.count = 4;
 4159              		.loc 1 3204 0
 4160 2548 0430A0E3 		mov	r3, #4	@ movhi
3200:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4161              		.loc 1 3200 0
 4162 254c 20208DE5 		str	r2, [sp, #32]
3201:../uvc.c      **** 					interStabuf.size   = 1024;
 4163              		.loc 1 3201 0
 4164 2550 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3204:../uvc.c      **** 					interStabuf.count = 4;
 4165              		.loc 1 3204 0
 4166 2554 B432CDE1 		strh	r3, [sp, #36]	@ movhi
3207:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4167              		.loc 1 3207 0
 4168 2558 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3210:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4169              		.loc 1 3210 0
 4170 255c 74089FE5 		ldr	r0, .L447+28
 4171 2560 20108DE2 		add	r1, sp, #32
 4172 2564 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4173              	.LVL292:
3211:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4174              		.loc 1 3211 0
 4175 2568 002050E2 		subs	r2, r0, #0
 4176 256c 6701001A 		bne	.L442
3216:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4177              		.loc 1 3216 0
 4178 2570 48389FE5 		ldr	r3, .L447+4
 4179 2574 5FB6C3E5 		strb	fp, [r3, #1631]
3396:../uvc.c      ****         CyU3PThreadRelinquish ();
 4180              		.loc 1 3396 0
 4181 2578 FEFFFFEB 		bl	_txe_thread_relinquish
 4182              	.LVL293:
 4183 257c 9DFFFFEA 		b	.L424
 4184              	.L307:
 4185              	.LBB114:
 4186              	.LBB98:
2500:../uvc.c      ****     switch (wValue)
 4187              		.loc 1 2500 0
 4188 2580 B020D9E1 		ldrh	r2, [r9, #0]
 4189 2584 060C52E3 		cmp	r2, #1536
 4190 2588 D500000A 		beq	.L331
 4191 258c 9300008A 		bhi	.L337
 4192 2590 030C52E3 		cmp	r2, #768
 4193 2594 1701000A 		beq	.L328
 4194 2598 0E01008A 		bhi	.L338
 4195 259c 010C52E3 		cmp	r2, #256
 4196 25a0 5601000A 		beq	.L326
 4197 25a4 020C52E3 		cmp	r2, #512
 4198 25a8 B7FFFF1A 		bne	.L325
 4199              	.LVL294:
2508:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4200              		.loc 1 2508 0
 4201 25ac 0100A0E3 		mov	r0, #1
 4202 25b0 FEFFFFEB 		bl	CTControlHandle
 4203              	.LVL295:
 4204 25b4 30309DE5 		ldr	r3, [sp, #48]
 4205 25b8 BCFFFFEA 		b	.L304
 4206              	.L309:
 4207              	.LBE98:
 4208              	.LBE114:
 4209              	.LBB115:
 4210              	.LBB120:
2725:../uvc.c      ****     switch (wValue)
 4211              		.loc 1 2725 0
 4212 25bc B030D9E1 		ldrh	r3, [r9, #0]
 4213 25c0 090C53E3 		cmp	r3, #2304
 4214 25c4 EE01000A 		beq	.L352
 4215 25c8 8C00008A 		bhi	.L361
 4216 25cc 010B53E3 		cmp	r3, #1024
 4217 25d0 EF01000A 		beq	.L347
 4218 25d4 8701008A 		bhi	.L362
 4219 25d8 020C53E3 		cmp	r3, #512
 4220 25dc E401000A 		beq	.L345
 4221 25e0 030C53E3 		cmp	r3, #768
 4222 25e4 C301000A 		beq	.L346
 4223 25e8 010C53E3 		cmp	r3, #256
 4224 25ec AAFFFF1A 		bne	.L305
 4225              	.LVL296:
2729:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4226              		.loc 1 2729 0
 4227 25f0 1000A0E3 		mov	r0, #16
 4228 25f4 FEFFFFEB 		bl	ControlHandle
 4229              	.LVL297:
 4230 25f8 30309DE5 		ldr	r3, [sp, #48]
 4231 25fc ABFFFFEA 		b	.L304
 4232              	.L439:
 4233              	.LBE120:
 4234              	.LBE115:
3134:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4235              		.loc 1 3134 0
 4236 2600 D4B79FE5 		ldr	fp, .L447+32
 4237 2604 B0C0D9E1 		ldrh	ip, [r9, #0]
 4238 2608 B000D8E1 		ldrh	r0, [r8, #0]
 4239 260c CC179FE5 		ldr	r1, .L447+36
 4240 2610 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4241 2614 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4242 2618 0C008DE5 		str	r0, [sp, #12]
 4243 261c 08C08DE5 		str	ip, [sp, #8]
 4244 2620 B0C0D1E1 		ldrh	ip, [r1, #0]
 4245 2624 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4246 2628 04B08DE5 		str	fp, [sp, #4]
 4247 262c 0400A0E3 		mov	r0, #4
 4248 2630 AC179FE5 		ldr	r1, .L447+40
 4249 2634 00B0A0E3 		mov	fp, #0
 4250 2638 00E08DE5 		str	lr, [sp, #0]
 4251 263c 10C08DE5 		str	ip, [sp, #16]
 4252 2640 14B08DE5 		str	fp, [sp, #20]
 4253 2644 FEFFFFEB 		bl	CyU3PDebugPrint
 4254 2648 30309DE5 		ldr	r3, [sp, #48]
 4255 264c 78FFFFEA 		b	.L303
 4256              	.L438:
3126:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4257              		.loc 1 3126 0
 4258 2650 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3127:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4259              		.loc 1 3127 0
 4260 2654 000050E3 		cmp	r0, #0
3126:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4261              		.loc 1 3126 0
 4262 2658 4800C5E5 		strb	r0, [r5, #72]
3129:../uvc.c      ****                     isUsbConnected = CyTrue;
 4263              		.loc 1 3129 0
 4264 265c 0100A013 		movne	r0, #1
 4265 2660 3C008515 		strne	r0, [r5, #60]
 4266 2664 6FFFFFEA 		b	.L302
 4267              	.L367:
 4268              	.LVL298:
 4269              	.LBB125:
 4270              	.LBB107:
2820:../uvc.c      ****     switch (wValue)
 4271              		.loc 1 2820 0
 4272 2668 B020D9E1 		ldrh	r2, [r9, #0]
 4273 266c 030C52E3 		cmp	r2, #768
 4274 2670 8100000A 		beq	.L371
 4275 2674 3300008A 		bhi	.L374
 4276 2678 010C52E3 		cmp	r2, #256
 4277 267c 8B00000A 		beq	.L369
 4278 2680 020C52E3 		cmp	r2, #512
 4279 2684 8EFFFF1A 		bne	.L368
2872:../uvc.c      ****             switch (bRequest)
 4280              		.loc 1 2872 0
 4281 2688 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4282 268c 810053E3 		cmp	r3, #129
 4283 2690 8B00000A 		beq	.L413
 4284 2694 2601008A 		bhi	.L389
 4285 2698 010053E3 		cmp	r3, #1
 4286 269c 8401000A 		beq	.L443
 4287              	.L393:
2971:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4288              		.loc 1 2971 0
 4289 26a0 0000A0E3 		mov	r0, #0
 4290 26a4 0110A0E3 		mov	r1, #1
 4291 26a8 0020A0E1 		mov	r2, r0
 4292 26ac FEFFFFEB 		bl	CyU3PUsbStall
 4293 26b0 30309DE5 		ldr	r3, [sp, #48]
 4294 26b4 87FFFFEA 		b	.L366
 4295              	.LVL299:
 4296              	.L419:
 4297              	.LBE107:
 4298              	.LBE125:
3217:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4299              		.loc 1 3217 0
 4300 26b8 5FE6D6E5 		ldrb	lr, [r6, #1631]	@ zero_extendqisi2
 4301 26bc 00005EE3 		cmp	lr, #0
 4302 26c0 86FFFF0A 		beq	.L301
3219:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4303              		.loc 1 3219 0
 4304 26c4 003097E5 		ldr	r3, [r7, #0]
 4305 26c8 02B0A0E3 		mov	fp, #2
 4306 26cc 00B0C3E5 		strb	fp, [r3, #0]
3220:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4307              		.loc 1 3220 0
 4308 26d0 001097E5 		ldr	r1, [r7, #0]
 4309 26d4 01B0A0E3 		mov	fp, #1
 4310 26d8 01B0C1E5 		strb	fp, [r1, #1]
3221:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4311              		.loc 1 3221 0
 4312 26dc 000097E5 		ldr	r0, [r7, #0]
3225:../uvc.c      **** 					interStabuf.size   = 1024;
 4313              		.loc 1 3225 0
 4314 26e0 01EBA0E3 		mov	lr, #1024	@ movhi
3221:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4315              		.loc 1 3221 0
 4316 26e4 0220C0E5 		strb	r2, [r0, #2]
3222:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4317              		.loc 1 3222 0
 4318 26e8 00C097E5 		ldr	ip, [r7, #0]
3231:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4319              		.loc 1 3231 0
 4320 26ec 0010E0E3 		mvn	r1, #0
3222:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4321              		.loc 1 3222 0
 4322 26f0 03B0CCE5 		strb	fp, [ip, #3]
3224:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4323              		.loc 1 3224 0
 4324 26f4 003097E5 		ldr	r3, [r7, #0]
3226:../uvc.c      **** 					interStabuf.status = 0;
 4325              		.loc 1 3226 0
 4326 26f8 02C0A0E1 		mov	ip, r2	@ movhi
 4327 26fc B822CDE1 		strh	r2, [sp, #40]	@ movhi
3231:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4328              		.loc 1 3231 0
 4329 2700 D0069FE5 		ldr	r0, .L447+28
3228:../uvc.c      **** 					interStabuf.count = 4;
 4330              		.loc 1 3228 0
 4331 2704 0420A0E3 		mov	r2, #4	@ movhi
3224:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4332              		.loc 1 3224 0
 4333 2708 20308DE5 		str	r3, [sp, #32]
3228:../uvc.c      **** 					interStabuf.count = 4;
 4334              		.loc 1 3228 0
 4335 270c B422CDE1 		strh	r2, [sp, #36]	@ movhi
3225:../uvc.c      **** 					interStabuf.size   = 1024;
 4336              		.loc 1 3225 0
 4337 2710 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3231:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4338              		.loc 1 3231 0
 4339 2714 1CC08DE5 		str	ip, [sp, #28]
 4340 2718 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3234:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4341              		.loc 1 3234 0
 4342 271c B4069FE5 		ldr	r0, .L447+28
 4343 2720 20108DE2 		add	r1, sp, #32
 4344 2724 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4345              	.LVL300:
3235:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4346              		.loc 1 3235 0
 4347 2728 1C309DE5 		ldr	r3, [sp, #28]
 4348 272c 002050E2 		subs	r2, r0, #0
 4349 2730 C000001A 		bne	.L444
3241:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4350              		.loc 1 3241 0
 4351 2734 84269FE5 		ldr	r2, .L447+4
3242:../uvc.c      **** 					stiflag = CyTrue;
 4352              		.loc 1 3242 0
 4353 2738 9CB084E5 		str	fp, [r4, #156]
3241:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4354              		.loc 1 3241 0
 4355 273c 5F36C2E5 		strb	r3, [r2, #1631]
3396:../uvc.c      ****         CyU3PThreadRelinquish ();
 4356              		.loc 1 3396 0
 4357 2740 FEFFFFEB 		bl	_txe_thread_relinquish
 4358              	.LVL301:
 4359 2744 2BFFFFEA 		b	.L424
 4360              	.LVL302:
 4361              	.L374:
 4362              	.LBB126:
 4363              	.LBB109:
2820:../uvc.c      ****     switch (wValue)
 4364              		.loc 1 2820 0
 4365 2748 010B52E3 		cmp	r2, #1024
 4366 274c 3800000A 		beq	.L372
 4367 2750 050C52E3 		cmp	r2, #1280
 4368 2754 5AFFFF1A 		bne	.L368
3032:../uvc.c      ****                 switch (bRequest)
 4369              		.loc 1 3032 0
 4370 2758 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4371 275c 810052E3 		cmp	r2, #129
 4372 2760 5700000A 		beq	.L413
 4373 2764 1E01008A 		bhi	.L416
 4374 2768 010052E3 		cmp	r2, #1
 4375 276c 54FFFF1A 		bne	.L368
3057:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4376              		.loc 1 3057 0
 4377 2770 2000A0E3 		mov	r0, #32
 4378 2774 6C169FE5 		ldr	r1, .L447+44
 4379 2778 36208DE2 		add	r2, sp, #54
 4380 277c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4381              	.LVL303:
3059:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4382              		.loc 1 3059 0
 4383 2780 000050E3 		cmp	r0, #0
 4384 2784 8601001A 		bne	.L418
3073:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 4385              		.loc 1 3073 0
 4386 2788 7DE0D4E5 		ldrb	lr, [r4, #125]	@ zero_extendqisi2
 4387 278c 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
3070:../uvc.c      ****                             stiflag = CyTrue;//set still trigger flag
 4388              		.loc 1 3070 0
 4389 2790 01C0A0E3 		mov	ip, #1
3073:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 4390              		.loc 1 3073 0
 4391 2794 B623DDE1 		ldrh	r2, [sp, #54]
 4392              	.LVL304:
 4393 2798 040080E2 		add	r0, r0, #4
 4394              	.LVL305:
 4395 279c 48169FE5 		ldr	r1, .L447+48
3070:../uvc.c      ****                             stiflag = CyTrue;//set still trigger flag
 4396              		.loc 1 3070 0
 4397 27a0 9CC084E5 		str	ip, [r4, #156]
3073:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 4398              		.loc 1 3073 0
 4399 27a4 00E08DE5 		str	lr, [sp, #0]
 4400 27a8 FEFFFFEB 		bl	CyU3PDebugPrint
 4401              	.LVL306:
 4402 27ac 30309DE5 		ldr	r3, [sp, #48]
 4403 27b0 48FFFFEA 		b	.L366
 4404              	.LVL307:
 4405              	.L322:
 4406              	.LBE109:
 4407              	.LBE126:
 4408              	.LBB127:
 4409              	.LBB91:
2425:../uvc.c      ****     switch (wValue)
 4410              		.loc 1 2425 0
 4411 27b4 0A0C52E3 		cmp	r2, #2560
 4412 27b8 F100000A 		beq	.L319
 4413 27bc E600008A 		bhi	.L324
 4414 27c0 070C52E3 		cmp	r2, #1792
 4415 27c4 E000000A 		beq	.L317
 4416 27c8 020B52E3 		cmp	r2, #2048
 4417 27cc 2EFFFF1A 		bne	.L325
 4418              	.LVL308:
2456:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4419              		.loc 1 2456 0
 4420 27d0 0700A0E3 		mov	r0, #7
 4421 27d4 FEFFFFEB 		bl	ControlHandle
 4422              	.LVL309:
 4423 27d8 30309DE5 		ldr	r3, [sp, #48]
 4424 27dc 33FFFFEA 		b	.L304
 4425              	.L337:
 4426              	.LBE91:
 4427              	.LBE127:
 4428              	.LBB128:
 4429              	.LBB96:
2500:../uvc.c      ****     switch (wValue)
 4430              		.loc 1 2500 0
 4431 27e0 090C52E3 		cmp	r2, #2304
 4432 27e4 2201000A 		beq	.L333
 4433 27e8 1701008A 		bhi	.L339
 4434 27ec 070C52E3 		cmp	r2, #1792
 4435 27f0 0901000A 		beq	.L332
 4436 27f4 020B52E3 		cmp	r2, #2048
 4437 27f8 23FFFF1A 		bne	.L325
 4438 27fc 2BFFFFEA 		b	.L304
 4439              	.L361:
 4440              	.LBE96:
 4441              	.LBE128:
 4442              	.LBB129:
 4443              	.LBB119:
2725:../uvc.c      ****     switch (wValue)
 4444              		.loc 1 2725 0
 4445 2800 0F0C53E3 		cmp	r3, #3840
 4446 2804 5601000A 		beq	.L356
 4447 2808 3900008A 		bhi	.L364
 4448 280c 0B0C53E3 		cmp	r3, #2816
 4449 2810 4F01000A 		beq	.L354
 4450 2814 0D0C53E3 		cmp	r3, #3328
 4451 2818 4901000A 		beq	.L355
 4452 281c 0A0C53E3 		cmp	r3, #2560
 4453 2820 1DFFFF1A 		bne	.L305
 4454              	.LVL310:
2766:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4455              		.loc 1 2766 0
 4456 2824 1900A0E3 		mov	r0, #25
 4457 2828 FEFFFFEB 		bl	ControlHandle
 4458              	.LVL311:
 4459 282c 30309DE5 		ldr	r3, [sp, #48]
 4460 2830 1EFFFFEA 		b	.L304
 4461              	.LVL312:
 4462              	.L372:
 4463              	.LBE119:
 4464              	.LBE129:
 4465              	.LBB130:
 4466              	.LBB106:
2977:../uvc.c      ****                 switch (bRequest)
 4467              		.loc 1 2977 0
 4468 2834 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4469 2838 81005BE3 		cmp	fp, #129
 4470 283c 1300000A 		beq	.L404
 4471 2840 8500008A 		bhi	.L407
 4472 2844 01005BE3 		cmp	fp, #1
 4473 2848 1DFFFF1A 		bne	.L368
3002:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4474              		.loc 1 3002 0
 4475 284c 36208DE2 		add	r2, sp, #54
 4476 2850 2000A0E3 		mov	r0, #32
 4477 2854 8C159FE5 		ldr	r1, .L447+44
 4478 2858 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4479              	.LVL313:
3004:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4480              		.loc 1 3004 0
 4481 285c 002050E2 		subs	r2, r0, #0
 4482 2860 1BFFFF1A 		bne	.L428
3017:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4483              		.loc 1 3017 0
 4484 2864 50059FE5 		ldr	r0, .L447
 4485              	.LVL314:
 4486 2868 0B10A0E1 		mov	r1, fp
 4487 286c FEFFFFEB 		bl	_txe_event_flags_set
 4488              	.LVL315:
3018:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4489              		.loc 1 3018 0
 4490 2870 002050E2 		subs	r2, r0, #0
 4491 2874 16FFFF0A 		beq	.L428
 4492 2878 190100EA 		b	.L410
 4493              	.LVL316:
 4494              	.L371:
2928:../uvc.c      ****                 switch (bRequest)
 4495              		.loc 1 2928 0
 4496 287c 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4497 2880 830052E3 		cmp	r2, #131
 4498 2884 9800008A 		bhi	.L398
 4499 2888 810052E3 		cmp	r2, #129
 4500 288c 7D00003A 		bcc	.L445
 4501              	.L404:
2989:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4502              		.loc 1 2989 0
 4503 2890 48B0D4E5 		ldrb	fp, [r4, #72]	@ zero_extendqisi2
2991:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4504              		.loc 1 2991 0
 4505 2894 0B00A0E3 		mov	r0, #11
2989:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4506              		.loc 1 2989 0
 4507 2898 03005BE3 		cmp	fp, #3
2991:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4508              		.loc 1 2991 0
 4509 289c 4C159F05 		ldreq	r1, .L447+52
2995:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4510              		.loc 1 2995 0
 4511 28a0 4C159F15 		ldrne	r1, .L447+56
 4512 28a4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4513 28a8 30309DE5 		ldr	r3, [sp, #48]
 4514 28ac 09FFFFEA 		b	.L366
 4515              	.L369:
2823:../uvc.c      ****             switch (bRequest)
 4516              		.loc 1 2823 0
 4517 28b0 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4518 28b4 830052E3 		cmp	r2, #131
 4519 28b8 2F00008A 		bhi	.L380
 4520 28bc 810052E3 		cmp	r2, #129
 4521 28c0 1400003A 		bcc	.L446
 4522              	.L413:
3044:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4523              		.loc 1 3044 0
 4524 28c4 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3046:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4525              		.loc 1 3046 0
 4526 28c8 1A00A0E3 		mov	r0, #26
3044:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4527              		.loc 1 3044 0
 4528 28cc 030052E3 		cmp	r2, #3
3046:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4529              		.loc 1 3046 0
 4530 28d0 20159F05 		ldreq	r1, .L447+60
3050:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4531              		.loc 1 3050 0
 4532 28d4 20159F15 		ldrne	r1, .L447+64
 4533 28d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4534 28dc 30309DE5 		ldr	r3, [sp, #48]
 4535 28e0 FCFEFFEA 		b	.L366
 4536              	.LVL317:
 4537              	.L331:
 4538              	.LBE106:
 4539              	.LBE130:
 4540              	.LBB131:
 4541              	.LBB99:
2526:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4542              		.loc 1 2526 0
 4543 28e4 0500A0E3 		mov	r0, #5
 4544 28e8 FEFFFFEB 		bl	CTControlHandle
 4545              	.LVL318:
 4546 28ec 30309DE5 		ldr	r3, [sp, #48]
 4547 28f0 EEFEFFEA 		b	.L304
 4548              	.L364:
 4549              	.LBE99:
 4550              	.LBE131:
 4551              	.LBB132:
 4552              	.LBB121:
2725:../uvc.c      ****     switch (wValue)
 4553              		.loc 1 2725 0
 4554 28f4 110C53E3 		cmp	r3, #4352
 4555 28f8 E900000A 		beq	.L358
 4556 28fc 2D00008A 		bhi	.L365
 4557 2900 010A53E3 		cmp	r3, #4096
 4558 2904 E4FEFF1A 		bne	.L305
 4559              	.LVL319:
2788:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4560              		.loc 1 2788 0
 4561 2908 1F00A0E3 		mov	r0, #31
 4562 290c FEFFFFEB 		bl	ControlHandle
 4563              	.LVL320:
 4564 2910 30309DE5 		ldr	r3, [sp, #48]
 4565 2914 E5FEFFEA 		b	.L304
 4566              	.LVL321:
 4567              	.L446:
 4568              	.LBE121:
 4569              	.LBE132:
 4570              	.LBB133:
 4571              	.LBB110:
2823:../uvc.c      ****             switch (bRequest)
 4572              		.loc 1 2823 0
 4573 2918 010052E3 		cmp	r2, #1
 4574 291c 5FFFFF1A 		bne	.L393
2848:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4575              		.loc 1 2848 0
 4576 2920 2000A0E3 		mov	r0, #32
 4577 2924 BC149FE5 		ldr	r1, .L447+44
 4578 2928 36208DE2 		add	r2, sp, #54
 4579 292c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4580              	.LVL322:
2850:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4581              		.loc 1 2850 0
 4582 2930 000050E3 		cmp	r0, #0
 4583 2934 E6FEFF1A 		bne	.L428
2852:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4584              		.loc 1 2852 0
 4585 2938 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 4586 293c 030053E3 		cmp	r3, #3
 4587 2940 E3FEFF1A 		bne	.L428
2856:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4588              		.loc 1 2856 0
 4589 2944 7EE0D4E5 		ldrb	lr, [r4, #126]	@ zero_extendqisi2
2857:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4590              		.loc 1 2857 0
 4591 2948 7FC0D4E5 		ldrb	ip, [r4, #127]	@ zero_extendqisi2
2858:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4592              		.loc 1 2858 0
 4593 294c 8000D4E5 		ldrb	r0, [r4, #128]	@ zero_extendqisi2
 4594              	.LVL323:
2859:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4595              		.loc 1 2859 0
 4596 2950 8110D4E5 		ldrb	r1, [r4, #129]	@ zero_extendqisi2
2860:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4597              		.loc 1 2860 0
 4598 2954 8220D4E5 		ldrb	r2, [r4, #130]	@ zero_extendqisi2
2861:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4599              		.loc 1 2861 0
 4600 2958 83B0D4E5 		ldrb	fp, [r4, #131]	@ zero_extendqisi2
2856:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4601              		.loc 1 2856 0
 4602 295c 12E6C6E5 		strb	lr, [r6, #1554]
2857:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4603              		.loc 1 2857 0
 4604 2960 13C6C6E5 		strb	ip, [r6, #1555]
2858:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4605              		.loc 1 2858 0
 4606 2964 1406C6E5 		strb	r0, [r6, #1556]
2859:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4607              		.loc 1 2859 0
 4608 2968 1516C6E5 		strb	r1, [r6, #1557]
2860:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4609              		.loc 1 2860 0
 4610 296c 1626C6E5 		strb	r2, [r6, #1558]
2861:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4611              		.loc 1 2861 0
 4612 2970 17B6C6E5 		strb	fp, [r6, #1559]
 4613 2974 30309DE5 		ldr	r3, [sp, #48]
 4614 2978 D6FEFFEA 		b	.L366
 4615              	.LVL324:
 4616              	.L380:
2823:../uvc.c      ****             switch (bRequest)
 4617              		.loc 1 2823 0
 4618 297c 860052E3 		cmp	r2, #134
 4619 2980 3900000A 		beq	.L431
 4620 2984 870052E3 		cmp	r2, #135
 4621 2988 CDFFFF0A 		beq	.L413
 4622              	.L437:
2928:../uvc.c      ****                 switch (bRequest)
 4623              		.loc 1 2928 0
 4624 298c 850052E3 		cmp	r2, #133
 4625 2990 42FFFF1A 		bne	.L393
 4626              	.L405:
2986:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4627              		.loc 1 2986 0
 4628 2994 64149FE5 		ldr	r1, .L447+68
 4629 2998 0200A0E3 		mov	r0, #2
2984:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4630              		.loc 1 2984 0
 4631 299c 1A30A0E3 		mov	r3, #26
 4632              	.L429:
3039:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4633              		.loc 1 3039 0
 4634 29a0 5830C4E5 		strb	r3, [r4, #88]
3040:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4635              		.loc 1 3040 0
 4636 29a4 0030A0E3 		mov	r3, #0
 4637 29a8 5930C4E5 		strb	r3, [r4, #89]
3041:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4638              		.loc 1 3041 0
 4639 29ac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4640 29b0 30309DE5 		ldr	r3, [sp, #48]
 4641 29b4 C7FEFFEA 		b	.L366
 4642              	.LVL325:
 4643              	.L365:
 4644              	.LBE110:
 4645              	.LBE133:
 4646              	.LBB134:
 4647              	.LBB118:
2725:../uvc.c      ****     switch (wValue)
 4648              		.loc 1 2725 0
 4649 29b8 120C53E3 		cmp	r3, #4608
 4650 29bc DC00000A 		beq	.L359
 4651 29c0 130C53E3 		cmp	r3, #4864
 4652 29c4 B4FEFF1A 		bne	.L305
 4653              	.LVL326:
2800:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 4654              		.loc 1 2800 0
 4655 29c8 2600A0E3 		mov	r0, #38
 4656 29cc FEFFFFEB 		bl	ControlHandle
 4657              	.LVL327:
 4658 29d0 30309DE5 		ldr	r3, [sp, #48]
 4659 29d4 B5FEFFEA 		b	.L304
 4660              	.L338:
 4661              	.LBE118:
 4662              	.LBE134:
 4663              	.LBB135:
 4664              	.LBB95:
2500:../uvc.c      ****     switch (wValue)
 4665              		.loc 1 2500 0
 4666 29d8 010B52E3 		cmp	r2, #1024
 4667 29dc 0900000A 		beq	.L329
 4668 29e0 050C52E3 		cmp	r2, #1280
 4669 29e4 A8FEFF1A 		bne	.L325
 4670              	.LVL328:
2522:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4671              		.loc 1 2522 0
 4672 29e8 0400A0E3 		mov	r0, #4
 4673 29ec FEFFFFEB 		bl	CTControlHandle
 4674              	.LVL329:
 4675 29f0 30309DE5 		ldr	r3, [sp, #48]
 4676 29f4 ADFEFFEA 		b	.L304
 4677              	.L328:
 4678              	.LVL330:
2512:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4679              		.loc 1 2512 0
 4680 29f8 0200A0E3 		mov	r0, #2
 4681 29fc FEFFFFEB 		bl	CTControlHandle
 4682              	.LVL331:
 4683 2a00 30309DE5 		ldr	r3, [sp, #48]
 4684 2a04 A9FEFFEA 		b	.L304
 4685              	.L329:
 4686              	.LVL332:
2517:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4687              		.loc 1 2517 0
 4688 2a08 0300A0E3 		mov	r0, #3
 4689 2a0c FEFFFFEB 		bl	CTControlHandle
 4690              	.LVL333:
 4691 2a10 30309DE5 		ldr	r3, [sp, #48]
 4692 2a14 A5FEFFEA 		b	.L304
 4693              	.L440:
 4694              	.LVL334:
 4695              	.LBE95:
 4696              	.LBE135:
 4697              	.LBB136:
 4698              	.LBB89:
2433:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4699              		.loc 1 2433 0
 4700 2a18 0100A0E3 		mov	r0, #1
 4701 2a1c FEFFFFEB 		bl	ControlHandle
 4702              	.LVL335:
 4703 2a20 30309DE5 		ldr	r3, [sp, #48]
 4704 2a24 A1FEFFEA 		b	.L304
 4705              	.L312:
 4706              	.LVL336:
2429:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4707              		.loc 1 2429 0
 4708 2a28 0000A0E3 		mov	r0, #0
 4709 2a2c FEFFFFEB 		bl	ControlHandle
 4710              	.LVL337:
 4711 2a30 30309DE5 		ldr	r3, [sp, #48]
 4712 2a34 9DFEFFEA 		b	.L304
 4713              	.LVL338:
 4714              	.L444:
 4715              	.LBE89:
 4716              	.LBE136:
3237:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4717              		.loc 1 3237 0
 4718 2a38 0400A0E3 		mov	r0, #4
 4719              	.LVL339:
 4720 2a3c C0139FE5 		ldr	r1, .L447+72
 4721 2a40 FEFFFFEB 		bl	CyU3PDebugPrint
 4722              	.LVL340:
 4723              	.L423:
 4724              	.LBB137:
 4725              	.LBB138:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4726              		.loc 1 1246 0
 4727 2a44 BC139FE5 		ldr	r1, .L447+76
 4728 2a48 0400A0E3 		mov	r0, #4
 4729 2a4c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 4730              		.loc 1 1247 0
 4731 2a50 FA0FA0E3 		mov	r0, #1000
 4732 2a54 FEFFFFEB 		bl	_tx_thread_sleep
 4733 2a58 F9FFFFEA 		b	.L423
 4734              	.LVL341:
 4735              	.L407:
 4736              	.LBE138:
 4737              	.LBE137:
 4738              	.LBB139:
 4739              	.LBB105:
2977:../uvc.c      ****                 switch (bRequest)
 4740              		.loc 1 2977 0
 4741 2a5c 85005BE3 		cmp	fp, #133
 4742 2a60 CBFFFF0A 		beq	.L405
 4743 2a64 86005BE3 		cmp	fp, #134
 4744 2a68 95FEFF1A 		bne	.L368
 4745              	.L431:
2981:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4746              		.loc 1 2981 0
 4747 2a6c 0300A0E1 		mov	r0, r3
 4748              	.L426:
2875:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4749              		.loc 1 2875 0
 4750 2a70 0330A0E3 		mov	r3, #3
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4751              		.loc 1 2876 0
 4752 2a74 84139FE5 		ldr	r1, .L447+68
2875:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4753              		.loc 1 2875 0
 4754 2a78 5830C4E5 		strb	r3, [r4, #88]
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4755              		.loc 1 2876 0
 4756 2a7c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4757 2a80 30309DE5 		ldr	r3, [sp, #48]
 4758 2a84 93FEFFEA 		b	.L366
 4759              	.L445:
2928:../uvc.c      ****                 switch (bRequest)
 4760              		.loc 1 2928 0
 4761 2a88 010052E3 		cmp	r2, #1
 4762 2a8c 03FFFF1A 		bne	.L393
2953:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4763              		.loc 1 2953 0
 4764 2a90 2000A0E3 		mov	r0, #32
 4765 2a94 4C139FE5 		ldr	r1, .L447+44
 4766 2a98 36208DE2 		add	r2, sp, #54
 4767 2a9c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4768              	.LVL342:
2955:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4769              		.loc 1 2955 0
 4770 2aa0 000050E3 		cmp	r0, #0
 4771 2aa4 8AFEFF1A 		bne	.L428
2957:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4772              		.loc 1 2957 0
 4773 2aa8 48B0D5E5 		ldrb	fp, [r5, #72]	@ zero_extendqisi2
 4774 2aac 03005BE3 		cmp	fp, #3
 4775 2ab0 87FEFF1A 		bne	.L428
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4776              		.loc 1 2966 0
 4777 2ab4 8230D5E5 		ldrb	r3, [r5, #130]	@ zero_extendqisi2
2961:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4778              		.loc 1 2961 0
 4779 2ab8 7DE0D5E5 		ldrb	lr, [r5, #125]	@ zero_extendqisi2
2962:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4780              		.loc 1 2962 0
 4781 2abc 7EC0D5E5 		ldrb	ip, [r5, #126]	@ zero_extendqisi2
2963:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4782              		.loc 1 2963 0
 4783 2ac0 7F00D5E5 		ldrb	r0, [r5, #127]	@ zero_extendqisi2
 4784              	.LVL343:
2964:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4785              		.loc 1 2964 0
 4786 2ac4 8010D5E5 		ldrb	r1, [r5, #128]	@ zero_extendqisi2
2965:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4787              		.loc 1 2965 0
 4788 2ac8 8120D5E5 		ldrb	r2, [r5, #129]	@ zero_extendqisi2
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4789              		.loc 1 2966 0
 4790 2acc 4E36C6E5 		strb	r3, [r6, #1614]
2961:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4791              		.loc 1 2961 0
 4792 2ad0 49E6C6E5 		strb	lr, [r6, #1609]
2962:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4793              		.loc 1 2962 0
 4794 2ad4 4AC6C6E5 		strb	ip, [r6, #1610]
2963:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4795              		.loc 1 2963 0
 4796 2ad8 4B06C6E5 		strb	r0, [r6, #1611]
2964:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4797              		.loc 1 2964 0
 4798 2adc 4C16C6E5 		strb	r1, [r6, #1612]
2965:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4799              		.loc 1 2965 0
 4800 2ae0 4D26C6E5 		strb	r2, [r6, #1613]
2966:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4801              		.loc 1 2966 0
 4802 2ae4 30309DE5 		ldr	r3, [sp, #48]
 4803 2ae8 7AFEFFEA 		b	.L366
 4804              	.LVL344:
 4805              	.L398:
2928:../uvc.c      ****                 switch (bRequest)
 4806              		.loc 1 2928 0
 4807 2aec 860052E3 		cmp	r2, #134
 4808 2af0 DDFFFF0A 		beq	.L431
 4809 2af4 870052E3 		cmp	r2, #135
 4810 2af8 A3FFFF1A 		bne	.L437
 4811 2afc 63FFFFEA 		b	.L404
 4812              	.LVL345:
 4813              	.L326:
 4814              	.LBE105:
 4815              	.LBE139:
 4816              	.LBB140:
 4817              	.LBB100:
2504:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4818              		.loc 1 2504 0
 4819 2b00 0000A0E3 		mov	r0, #0
 4820 2b04 FEFFFFEB 		bl	CTControlHandle
 4821              	.LVL346:
 4822 2b08 30309DE5 		ldr	r3, [sp, #48]
 4823 2b0c 67FEFFEA 		b	.L304
 4824              	.LVL347:
 4825              	.L442:
 4826              	.LBE100:
 4827              	.LBE140:
3213:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4828              		.loc 1 3213 0
 4829 2b10 0400A0E3 		mov	r0, #4
 4830              	.LVL348:
 4831 2b14 E8129FE5 		ldr	r1, .L447+72
 4832 2b18 FEFFFFEB 		bl	CyU3PDebugPrint
 4833              	.LVL349:
 4834              	.L421:
 4835              	.LBB141:
 4836              	.LBB142:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4837              		.loc 1 1246 0
 4838 2b1c E4129FE5 		ldr	r1, .L447+76
 4839 2b20 0400A0E3 		mov	r0, #4
 4840 2b24 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 4841              		.loc 1 1247 0
 4842 2b28 FA0FA0E3 		mov	r0, #1000
 4843 2b2c FEFFFFEB 		bl	_tx_thread_sleep
 4844 2b30 F9FFFFEA 		b	.L421
 4845              	.LVL350:
 4846              	.L389:
 4847              	.LBE142:
 4848              	.LBE141:
 4849              	.LBB143:
 4850              	.LBB111:
2872:../uvc.c      ****             switch (bRequest)
 4851              		.loc 1 2872 0
 4852 2b34 850053E3 		cmp	r3, #133
 4853 2b38 95FFFF0A 		beq	.L405
 4854 2b3c 860053E3 		cmp	r3, #134
 4855 2b40 D6FEFF1A 		bne	.L393
 4856              	.L432:
2876:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4857              		.loc 1 2876 0
 4858 2b44 0100A0E3 		mov	r0, #1
 4859 2b48 C8FFFFEA 		b	.L426
 4860              	.LVL351:
 4861              	.L317:
 4862              	.LBE111:
 4863              	.LBE143:
 4864              	.LBB144:
 4865              	.LBB92:
2452:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4866              		.loc 1 2452 0
 4867 2b4c 0600A0E3 		mov	r0, #6
 4868 2b50 FEFFFFEB 		bl	ControlHandle
 4869              	.LVL352:
 4870 2b54 30309DE5 		ldr	r3, [sp, #48]
 4871 2b58 54FEFFEA 		b	.L304
 4872              	.L324:
2425:../uvc.c      ****     switch (wValue)
 4873              		.loc 1 2425 0
 4874 2b5c 0D0C52E3 		cmp	r2, #3328
 4875 2b60 0700000A 		beq	.L319
 4876 2b64 0E0C52E3 		cmp	r2, #3584
 4877 2b68 0900000A 		beq	.L321
 4878 2b6c 030B52E3 		cmp	r2, #3072
 4879 2b70 45FEFF1A 		bne	.L325
 4880              	.LVL353:
2466:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4881              		.loc 1 2466 0
 4882 2b74 0B00A0E3 		mov	r0, #11
 4883 2b78 FEFFFFEB 		bl	ControlHandle
 4884              	.LVL354:
 4885 2b7c 30309DE5 		ldr	r3, [sp, #48]
 4886 2b80 4AFEFFEA 		b	.L304
 4887              	.L319:
 4888              	.LVL355:
2462:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4889              		.loc 1 2462 0
 4890 2b84 0900A0E3 		mov	r0, #9
 4891 2b88 FEFFFFEB 		bl	ControlHandle
 4892              	.LVL356:
 4893 2b8c 30309DE5 		ldr	r3, [sp, #48]
 4894 2b90 46FEFFEA 		b	.L304
 4895              	.L321:
 4896              	.LVL357:
2470:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4897              		.loc 1 2470 0
 4898 2b94 0E00A0E3 		mov	r0, #14
 4899 2b98 FEFFFFEB 		bl	ControlHandle
 4900              	.LVL358:
 4901 2b9c 30309DE5 		ldr	r3, [sp, #48]
 4902 2ba0 42FEFFEA 		b	.L304
 4903              	.L323:
2425:../uvc.c      ****     switch (wValue)
 4904              		.loc 1 2425 0
 4905 2ba4 010B52E3 		cmp	r2, #1024
 4906 2ba8 40FEFF0A 		beq	.L304
 4907 2bac 050C52E3 		cmp	r2, #1280
 4908 2bb0 35FEFF1A 		bne	.L325
 4909              	.LVL359:
2444:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4910              		.loc 1 2444 0
 4911 2bb4 0400A0E3 		mov	r0, #4
 4912 2bb8 FEFFFFEB 		bl	ControlHandle
 4913              	.LVL360:
 4914 2bbc 30309DE5 		ldr	r3, [sp, #48]
 4915 2bc0 3AFEFFEA 		b	.L304
 4916              	.L314:
 4917              	.LVL361:
2437:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4918              		.loc 1 2437 0
 4919 2bc4 0200A0E3 		mov	r0, #2
 4920 2bc8 FEFFFFEB 		bl	ControlHandle
 4921              	.LVL362:
 4922 2bcc 30309DE5 		ldr	r3, [sp, #48]
 4923 2bd0 36FEFFEA 		b	.L304
 4924              	.L316:
 4925              	.LVL363:
2448:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4926              		.loc 1 2448 0
 4927 2bd4 0500A0E3 		mov	r0, #5
 4928 2bd8 FEFFFFEB 		bl	ControlHandle
 4929              	.LVL364:
 4930 2bdc 30309DE5 		ldr	r3, [sp, #48]
 4931 2be0 32FEFFEA 		b	.L304
 4932              	.LVL365:
 4933              	.L416:
 4934              	.LBE92:
 4935              	.LBE144:
 4936              	.LBB145:
 4937              	.LBB104:
3032:../uvc.c      ****                 switch (bRequest)
 4938              		.loc 1 3032 0
 4939 2be4 850052E3 		cmp	r2, #133
 4940 2be8 4E00000A 		beq	.L414
 4941 2bec 860052E3 		cmp	r2, #134
 4942 2bf0 33FEFF1A 		bne	.L368
 4943 2bf4 D2FFFFEA 		b	.L432
 4944              	.LVL366:
 4945              	.L362:
 4946              	.LBE104:
 4947              	.LBE145:
 4948              	.LBB146:
 4949              	.LBB122:
2725:../uvc.c      ****     switch (wValue)
 4950              		.loc 1 2725 0
 4951 2bf8 060C53E3 		cmp	r3, #1536
 4952 2bfc 4500000A 		beq	.L349
 4953 2c00 0900008A 		bhi	.L363
 4954 2c04 050C53E3 		cmp	r3, #1280
 4955 2c08 23FEFF1A 		bne	.L305
 4956              	.LVL367:
2745:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4957              		.loc 1 2745 0
 4958 2c0c 1400A0E3 		mov	r0, #20
 4959 2c10 FEFFFFEB 		bl	ControlHandle
 4960              	.LVL368:
 4961 2c14 30309DE5 		ldr	r3, [sp, #48]
 4962 2c18 24FEFFEA 		b	.L304
 4963              	.L332:
 4964              	.LVL369:
 4965              	.LBE122:
 4966              	.LBE146:
 4967              	.LBB147:
 4968              	.LBB94:
2530:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 4969              		.loc 1 2530 0
 4970 2c1c 0600A0E3 		mov	r0, #6
 4971 2c20 FEFFFFEB 		bl	CTControlHandle
 4972              	.LVL370:
 4973 2c24 30309DE5 		ldr	r3, [sp, #48]
 4974 2c28 20FEFFEA 		b	.L304
 4975              	.L363:
 4976              	.LBE94:
 4977              	.LBE147:
 4978              	.LBB148:
 4979              	.LBB117:
2725:../uvc.c      ****     switch (wValue)
 4980              		.loc 1 2725 0
 4981 2c2c 070C53E3 		cmp	r3, #1792
 4982 2c30 3400000A 		beq	.L350
 4983 2c34 020B53E3 		cmp	r3, #2048
 4984 2c38 17FEFF1A 		bne	.L305
 4985              	.LVL371:
2757:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 4986              		.loc 1 2757 0
 4987 2c3c 1700A0E3 		mov	r0, #23
 4988 2c40 FEFFFFEB 		bl	ControlHandle
 4989              	.LVL372:
 4990 2c44 30309DE5 		ldr	r3, [sp, #48]
 4991 2c48 18FEFFEA 		b	.L304
 4992              	.L339:
 4993              	.LBE117:
 4994              	.LBE148:
 4995              	.LBB149:
 4996              	.LBB101:
2500:../uvc.c      ****     switch (wValue)
 4997              		.loc 1 2500 0
 4998 2c4c 0B0C52E3 		cmp	r2, #2816
 4999 2c50 0F00000A 		beq	.L335
 5000 2c54 030B52E3 		cmp	r2, #3072
 5001 2c58 0900000A 		beq	.L336
 5002 2c5c 0A0C52E3 		cmp	r2, #2560
 5003 2c60 09FEFF1A 		bne	.L325
 5004              	.LVL373:
2541:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5005              		.loc 1 2541 0
 5006 2c64 0800A0E3 		mov	r0, #8
 5007 2c68 FEFFFFEB 		bl	CTControlHandle
 5008              	.LVL374:
 5009 2c6c 30309DE5 		ldr	r3, [sp, #48]
 5010 2c70 0EFEFFEA 		b	.L304
 5011              	.L333:
 5012              	.LVL375:
2536:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5013              		.loc 1 2536 0
 5014 2c74 0700A0E3 		mov	r0, #7
 5015 2c78 FEFFFFEB 		bl	CTControlHandle
 5016              	.LVL376:
 5017 2c7c 30309DE5 		ldr	r3, [sp, #48]
 5018 2c80 0AFEFFEA 		b	.L304
 5019              	.L336:
 5020              	.LVL377:
2549:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5021              		.loc 1 2549 0
 5022 2c84 0A00A0E3 		mov	r0, #10
 5023 2c88 FEFFFFEB 		bl	CTControlHandle
 5024              	.LVL378:
 5025 2c8c 30309DE5 		ldr	r3, [sp, #48]
 5026 2c90 06FEFFEA 		b	.L304
 5027              	.L335:
 5028              	.LVL379:
2545:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5029              		.loc 1 2545 0
 5030 2c94 0900A0E3 		mov	r0, #9
 5031 2c98 FEFFFFEB 		bl	CTControlHandle
 5032              	.LVL380:
 5033 2c9c 30309DE5 		ldr	r3, [sp, #48]
 5034 2ca0 02FEFFEA 		b	.L304
 5035              	.L358:
 5036              	.LVL381:
 5037              	.LBE101:
 5038              	.LBE149:
 5039              	.LBB150:
 5040              	.LBB123:
2792:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 5041              		.loc 1 2792 0
 5042 2ca4 2400A0E3 		mov	r0, #36
 5043 2ca8 FEFFFFEB 		bl	ControlHandle
 5044              	.LVL382:
 5045 2cac 30309DE5 		ldr	r3, [sp, #48]
 5046 2cb0 FEFDFFEA 		b	.L304
 5047              	.LVL383:
 5048              	.L443:
 5049              	.LBE123:
 5050              	.LBE150:
 5051              	.LBB151:
 5052              	.LBB112:
2897:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5053              		.loc 1 2897 0
 5054 2cb4 2000A0E3 		mov	r0, #32
 5055 2cb8 28119FE5 		ldr	r1, .L447+44
 5056 2cbc 36208DE2 		add	r2, sp, #54
 5057 2cc0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5058              	.LVL384:
2899:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5059              		.loc 1 2899 0
 5060 2cc4 000050E3 		cmp	r0, #0
 5061 2cc8 01FEFF1A 		bne	.L428
2912:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5062              		.loc 1 2912 0
 5063 2ccc 0020A0E3 		mov	r2, #0
 5064 2cd0 E4009FE5 		ldr	r0, .L447
 5065              	.LVL385:
 5066 2cd4 0110A0E3 		mov	r1, #1
 5067 2cd8 FEFFFFEB 		bl	_txe_event_flags_set
 5068              	.LVL386:
2913:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5069              		.loc 1 2913 0
 5070 2cdc 002050E2 		subs	r2, r0, #0
 5071 2ce0 FBFDFF0A 		beq	.L428
 5072              	.L410:
3020:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5073              		.loc 1 3020 0
 5074 2ce4 0400A0E3 		mov	r0, #4
 5075              	.LVL387:
 5076 2ce8 1C119FE5 		ldr	r1, .L447+80
 5077 2cec FEFFFFEB 		bl	CyU3PDebugPrint
 5078              	.LVL388:
 5079 2cf0 30309DE5 		ldr	r3, [sp, #48]
 5080 2cf4 F7FDFFEA 		b	.L366
 5081              	.L346:
 5082              	.LVL389:
 5083              	.LBE112:
 5084              	.LBE151:
 5085              	.LBB152:
 5086              	.LBB116:
2737:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5087              		.loc 1 2737 0
 5088 2cf8 1200A0E3 		mov	r0, #18
 5089 2cfc FEFFFFEB 		bl	ControlHandle
 5090              	.LVL390:
 5091 2d00 30309DE5 		ldr	r3, [sp, #48]
 5092 2d04 E9FDFFEA 		b	.L304
 5093              	.L350:
 5094              	.LVL391:
2753:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5095              		.loc 1 2753 0
 5096 2d08 1600A0E3 		mov	r0, #22
 5097 2d0c FEFFFFEB 		bl	ControlHandle
 5098              	.LVL392:
 5099 2d10 30309DE5 		ldr	r3, [sp, #48]
 5100 2d14 E5FDFFEA 		b	.L304
 5101              	.L349:
 5102              	.LVL393:
2749:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5103              		.loc 1 2749 0
 5104 2d18 1500A0E3 		mov	r0, #21
 5105 2d1c FEFFFFEB 		bl	ControlHandle
 5106              	.LVL394:
 5107 2d20 30309DE5 		ldr	r3, [sp, #48]
 5108 2d24 E1FDFFEA 		b	.L304
 5109              	.LVL395:
 5110              	.L414:
 5111              	.LBE116:
 5112              	.LBE152:
 5113              	.LBB153:
 5114              	.LBB103:
3041:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5115              		.loc 1 3041 0
 5116 2d28 0200A0E3 		mov	r0, #2
 5117 2d2c CC109FE5 		ldr	r1, .L447+68
 5118 2d30 1AFFFFEA 		b	.L429
 5119              	.LVL396:
 5120              	.L359:
 5121              	.LBE103:
 5122              	.LBE153:
 5123              	.LBB154:
 5124              	.LBB124:
2796:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 5125              		.loc 1 2796 0
 5126 2d34 2500A0E3 		mov	r0, #37
 5127 2d38 FEFFFFEB 		bl	ControlHandle
 5128              	.LVL397:
 5129 2d3c 30309DE5 		ldr	r3, [sp, #48]
 5130 2d40 DAFDFFEA 		b	.L304
 5131              	.L355:
 5132              	.LVL398:
2776:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5133              		.loc 1 2776 0
 5134 2d44 1C00A0E3 		mov	r0, #28
 5135 2d48 FEFFFFEB 		bl	ControlHandle
 5136              	.LVL399:
 5137 2d4c 30309DE5 		ldr	r3, [sp, #48]
 5138 2d50 D6FDFFEA 		b	.L304
 5139              	.L354:
 5140              	.LVL400:
2772:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5141              		.loc 1 2772 0
 5142 2d54 1A00A0E3 		mov	r0, #26
 5143 2d58 FEFFFFEB 		bl	ControlHandle
 5144              	.LVL401:
 5145 2d5c 30309DE5 		ldr	r3, [sp, #48]
 5146 2d60 D2FDFFEA 		b	.L304
 5147              	.L356:
 5148              	.LVL402:
2784:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5149              		.loc 1 2784 0
 5150 2d64 1E00A0E3 		mov	r0, #30
 5151 2d68 FEFFFFEB 		bl	ControlHandle
 5152              	.LVL403:
 5153 2d6c 30309DE5 		ldr	r3, [sp, #48]
 5154 2d70 CEFDFFEA 		b	.L304
 5155              	.L345:
 5156              	.LVL404:
2733:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5157              		.loc 1 2733 0
 5158 2d74 1100A0E3 		mov	r0, #17
 5159 2d78 FEFFFFEB 		bl	ControlHandle
 5160              	.LVL405:
 5161 2d7c 30309DE5 		ldr	r3, [sp, #48]
 5162 2d80 CAFDFFEA 		b	.L304
 5163              	.L352:
 5164              	.LVL406:
2761:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5165              		.loc 1 2761 0
 5166 2d84 1800A0E3 		mov	r0, #24
 5167 2d88 FEFFFFEB 		bl	ControlHandle
 5168              	.LVL407:
 5169 2d8c 30309DE5 		ldr	r3, [sp, #48]
 5170 2d90 C6FDFFEA 		b	.L304
 5171              	.L347:
 5172              	.LVL408:
2741:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5173              		.loc 1 2741 0
 5174 2d94 1300A0E3 		mov	r0, #19
 5175 2d98 FEFFFFEB 		bl	ControlHandle
 5176              	.LVL409:
 5177 2d9c 30309DE5 		ldr	r3, [sp, #48]
 5178 2da0 C2FDFFEA 		b	.L304
 5179              	.LVL410:
 5180              	.L418:
 5181              	.LBE124:
 5182              	.LBE154:
 5183              	.LBB155:
 5184              	.LBB113:
3075:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5185              		.loc 1 3075 0
 5186 2da4 64109FE5 		ldr	r1, .L447+84
 5187 2da8 B623DDE1 		ldrh	r2, [sp, #54]
 5188 2dac 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 5189 2db0 0400A0E3 		mov	r0, #4
 5190              	.LVL411:
 5191 2db4 FEFFFFEB 		bl	CyU3PDebugPrint
 5192 2db8 C1FDFFEA 		b	.L368
 5193              	.L448:
 5194              		.align	2
 5195              	.L447:
 5196 2dbc 00000000 		.word	.LANCHOR0
 5197 2dc0 00000000 		.word	.LANCHOR1
 5198 2dc4 00000000 		.word	bRequest
 5199 2dc8 00000000 		.word	wValue
 5200 2dcc 00000000 		.word	wIndex
 5201 2dd0 00000000 		.word	glInterStaBuffer
 5202 2dd4 14050000 		.word	.LC28
 5203 2dd8 00000000 		.word	glChHandleInterStat
 5204 2ddc 00000000 		.word	bmReqType
 5205 2de0 00000000 		.word	wLength
 5206 2de4 98040000 		.word	.LC27
 5207 2de8 7C000000 		.word	.LANCHOR0+124
 5208 2dec 68050000 		.word	.LC30
 5209 2df0 48060000 		.word	.LANCHOR1+1608
 5210 2df4 54060000 		.word	.LANCHOR1+1620
 5211 2df8 10060000 		.word	.LANCHOR1+1552
 5212 2dfc 2C060000 		.word	.LANCHOR1+1580
 5213 2e00 58000000 		.word	.LANCHOR0+88
 5214 2e04 BC050000 		.word	.LC32
 5215 2e08 D4010000 		.word	.LC12
 5216 2e0c 40050000 		.word	.LC29
 5217 2e10 94050000 		.word	.LC31
 5218              	.LBE113:
 5219              	.LBE155:
 5220              		.cfi_endproc
 5221              	.LFE24:
 5223              		.align	2
 5224              		.global	CamDefSet
 5226              	CamDefSet:
 5227              	.LFB4:
1143:../uvc.c      **** {
 5228              		.loc 1 1143 0
 5229              		.cfi_startproc
 5230              		@ args = 0, pretend = 0, frame = 24
 5231              		@ frame_needed = 0, uses_anonymous_args = 0
 5232              	.LVL412:
 5233 2e14 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5234              	.LCFI19:
 5235              		.cfi_def_cfa_offset 36
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5236              		.loc 1 1149 0
 5237 2e18 AC429FE5 		ldr	r4, .L452
 5238              		.cfi_offset 14, -4
 5239              		.cfi_offset 11, -8
 5240              		.cfi_offset 10, -12
 5241              		.cfi_offset 9, -16
 5242              		.cfi_offset 8, -20
 5243              		.cfi_offset 7, -24
 5244              		.cfi_offset 6, -28
 5245              		.cfi_offset 5, -32
 5246              		.cfi_offset 4, -36
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5247              		.loc 1 1154 0
 5248 2e1c AC229FE5 		ldr	r2, .L452+4
1151:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5249              		.loc 1 1151 0
 5250 2e20 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1143:../uvc.c      **** {
 5251              		.loc 1 1143 0
 5252 2e24 2CD04DE2 		sub	sp, sp, #44
 5253              	.LCFI20:
 5254              		.cfi_def_cfa_offset 80
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5255              		.loc 1 1154 0
 5256 2e28 1C0092E5 		ldr	r0, [r2, #28]
 5257 2e2c 0010E0E3 		mvn	r1, #0
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5258              		.loc 1 1156 0
 5259 2e30 2963A0E1 		mov	r6, r9, lsr #6
1150:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5260              		.loc 1 1150 0
 5261 2e34 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5262              		.loc 1 1149 0
 5263 2e38 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5264              	.LVL413:
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5265              		.loc 1 1154 0
 5266 2e3c FEFFFFEB 		bl	_txe_mutex_get
1155:../uvc.c      ****     if(Data1&0x80){
 5267              		.loc 1 1155 0
 5268 2e40 800019E3 		tst	r9, #128
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5269              		.loc 1 1156 0
 5270 2e44 01600612 		andne	r6, r6, #1
 5271 2e48 0660E011 		mvnne	r6, r6
 5272 2e4c 3B600612 		andne	r6, r6, #59
 5273 2e50 0660E011 		mvnne	r6, r6
 5274 2e54 FF600612 		andne	r6, r6, #255
 5275              	.LVL414:
1158:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5276              		.loc 1 1158 0
 5277 2e58 C6608603 		orreq	r6, r6, #198
 5278              	.LVL415:
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5279              		.loc 1 1162 0
 5280 2e5c 0080A0E3 		mov	r8, #0
 5281 2e60 0A20A0E1 		mov	r2, sl
 5282 2e64 0730A0E1 		mov	r3, r7
 5283 2e68 0110A0E3 		mov	r1, #1
1160:../uvc.c      ****     Data0 = (Data0 << 2);
 5284              		.loc 1 1160 0
 5285 2e6c 0951A0E1 		mov	r5, r9, asl #2
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5286              		.loc 1 1162 0
 5287 2e70 58029FE5 		ldr	r0, .L452+4
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5288              		.loc 1 1165 0
 5289 2e74 0190A0E3 		mov	r9, #1
 5290              	.LVL416:
1160:../uvc.c      ****     Data0 = (Data0 << 2);
 5291              		.loc 1 1160 0
 5292 2e78 FF5005E2 		and	r5, r5, #255
 5293              	.LVL417:
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5294              		.loc 1 1162 0
 5295 2e7c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5296 2e80 FEFFFFEB 		bl	cmdSet
 5297              	.LVL418:
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5298              		.loc 1 1165 0
 5299 2e84 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5300 2e88 0910A0E1 		mov	r1, r9
 5301 2e8c 0730A0E1 		mov	r3, r7
 5302 2e90 38029FE5 		ldr	r0, .L452+4
 5303 2e94 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5304 2e98 FEFFFFEB 		bl	cmdSet
 5305              	.LVL419:
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5306              		.loc 1 1168 0
 5307 2e9c 0620A0E1 		mov	r2, r6
 5308 2ea0 0530A0E1 		mov	r3, r5
 5309 2ea4 28129FE5 		ldr	r1, .L452+8
 5310 2ea8 0400A0E3 		mov	r0, #4
1167:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5311              		.loc 1 1167 0
 5312 2eac A661C4E5 		strb	r6, [r4, #422]
1166:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5313              		.loc 1 1166 0
 5314 2eb0 A551C4E5 		strb	r5, [r4, #421]
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5315              		.loc 1 1168 0
 5316 2eb4 FEFFFFEB 		bl	CyU3PDebugPrint
 5317              	.LVL420:
1173:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5318              		.loc 1 1173 0
 5319 2eb8 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5320              	.LVL421:
1174:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5321              		.loc 1 1174 0
 5322 2ebc B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5323 2ec0 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5324 2ec4 0210A0E3 		mov	r1, #2
 5325 2ec8 00029FE5 		ldr	r0, .L452+4
 5326 2ecc 00B08DE5 		str	fp, [sp, #0]
 5327 2ed0 04808DE5 		str	r8, [sp, #4]
 5328 2ed4 FEFFFFEB 		bl	cmdSet
 5329              	.LVL422:
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5330              		.loc 1 1176 0
 5331 2ed8 0B20A0E1 		mov	r2, fp
 5332 2edc 0530A0E1 		mov	r3, r5
 5333 2ee0 EC119FE5 		ldr	r1, .L452+8
 5334 2ee4 0400A0E3 		mov	r0, #4
1175:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5335              		.loc 1 1175 0
 5336 2ee8 BD51C4E5 		strb	r5, [r4, #445]
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5337              		.loc 1 1176 0
 5338 2eec FEFFFFEB 		bl	CyU3PDebugPrint
 5339              	.LVL423:
1181:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5340              		.loc 1 1181 0
 5341 2ef0 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1180:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5342              		.loc 1 1180 0
 5343 2ef4 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5344              	.LVL424:
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5345              		.loc 1 1182 0
 5346 2ef8 80B047E2 		sub	fp, r7, #128
 5347 2efc FF100BE2 		and	r1, fp, #255
 5348 2f00 14108DE5 		str	r1, [sp, #20]
 5349 2f04 14C09DE5 		ldr	ip, [sp, #20]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5350              		.loc 1 1183 0
 5351 2f08 760047E2 		sub	r0, r7, #118
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5352              		.loc 1 1184 0
 5353 2f0c 7EE087E2 		add	lr, r7, #126
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5354              		.loc 1 1182 0
 5355 2f10 0630A0E1 		mov	r3, r6
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5356              		.loc 1 1183 0
 5357 2f14 18008DE5 		str	r0, [sp, #24]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5358              		.loc 1 1182 0
 5359 2f18 0510A0E3 		mov	r1, #5
 5360 2f1c DF20A0E3 		mov	r2, #223
 5361 2f20 A8019FE5 		ldr	r0, .L452+4
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5362              		.loc 1 1184 0
 5363 2f24 1CE08DE5 		str	lr, [sp, #28]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5364              		.loc 1 1182 0
 5365 2f28 00C08DE5 		str	ip, [sp, #0]
 5366 2f2c 04808DE5 		str	r8, [sp, #4]
 5367 2f30 FEFFFFEB 		bl	cmdSet
 5368              	.LVL425:
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5369              		.loc 1 1183 0
 5370 2f34 18A09DE5 		ldr	sl, [sp, #24]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5371              		.loc 1 1185 0
 5372 2f38 72E087E2 		add	lr, r7, #114
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5373              		.loc 1 1183 0
 5374 2f3c FFC00AE2 		and	ip, sl, #255
 5375 2f40 0630A0E1 		mov	r3, r6
 5376 2f44 0510A0E3 		mov	r1, #5
 5377 2f48 DC20A0E3 		mov	r2, #220
 5378 2f4c 7C019FE5 		ldr	r0, .L452+4
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5379              		.loc 1 1185 0
 5380 2f50 20E08DE5 		str	lr, [sp, #32]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5381              		.loc 1 1183 0
 5382 2f54 00C08DE5 		str	ip, [sp, #0]
 5383 2f58 04908DE5 		str	r9, [sp, #4]
 5384 2f5c FEFFFFEB 		bl	cmdSet
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5385              		.loc 1 1184 0
 5386 2f60 1C009DE5 		ldr	r0, [sp, #28]
 5387 2f64 02E0A0E3 		mov	lr, #2
 5388 2f68 FFC000E2 		and	ip, r0, #255
 5389 2f6c 0630A0E1 		mov	r3, r6
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5390              		.loc 1 1186 0
 5391 2f70 6FA047E2 		sub	sl, r7, #111
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5392              		.loc 1 1184 0
 5393 2f74 0510A0E3 		mov	r1, #5
 5394 2f78 DE20A0E3 		mov	r2, #222
 5395 2f7c 4C019FE5 		ldr	r0, .L452+4
 5396 2f80 04E08DE5 		str	lr, [sp, #4]
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5397              		.loc 1 1186 0
 5398 2f84 24A08DE5 		str	sl, [sp, #36]
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5399              		.loc 1 1184 0
 5400 2f88 00C08DE5 		str	ip, [sp, #0]
 5401 2f8c FEFFFFEB 		bl	cmdSet
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5402              		.loc 1 1185 0
 5403 2f90 20A09DE5 		ldr	sl, [sp, #32]
 5404 2f94 0630A0E1 		mov	r3, r6
 5405 2f98 FFC00AE2 		and	ip, sl, #255
 5406 2f9c 00C08DE5 		str	ip, [sp, #0]
 5407 2fa0 0510A0E3 		mov	r1, #5
 5408 2fa4 03C0A0E3 		mov	ip, #3
 5409 2fa8 E020A0E3 		mov	r2, #224
 5410 2fac 1C019FE5 		ldr	r0, .L452+4
 5411 2fb0 04C08DE5 		str	ip, [sp, #4]
 5412 2fb4 FEFFFFEB 		bl	cmdSet
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5413              		.loc 1 1186 0
 5414 2fb8 24009DE5 		ldr	r0, [sp, #36]
 5415 2fbc 04A0A0E3 		mov	sl, #4
 5416 2fc0 FFC000E2 		and	ip, r0, #255
 5417 2fc4 0630A0E1 		mov	r3, r6
 5418 2fc8 0510A0E3 		mov	r1, #5
 5419 2fcc DD20A0E3 		mov	r2, #221
 5420 2fd0 F8009FE5 		ldr	r0, .L452+4
 5421 2fd4 00C08DE5 		str	ip, [sp, #0]
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5422              		.loc 1 1187 0
 5423 2fd8 7F7087E2 		add	r7, r7, #127
 5424              	.LVL426:
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5425              		.loc 1 1186 0
 5426 2fdc 04A08DE5 		str	sl, [sp, #4]
 5427 2fe0 FEFFFFEB 		bl	cmdSet
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5428              		.loc 1 1187 0
 5429 2fe4 05E0A0E3 		mov	lr, #5
 5430 2fe8 0E10A0E1 		mov	r1, lr
 5431 2fec 0630A0E1 		mov	r3, r6
 5432 2ff0 E120A0E3 		mov	r2, #225
 5433 2ff4 FF6007E2 		and	r6, r7, #255
 5434              	.LVL427:
 5435 2ff8 D0009FE5 		ldr	r0, .L452+4
 5436 2ffc 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5437 3000 FEFFFFEB 		bl	cmdSet
 5438              	.LVL428:
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5439              		.loc 1 1188 0
 5440 3004 14C09DE5 		ldr	ip, [sp, #20]
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5441              		.loc 1 1189 0
 5442 3008 24E09DE5 		ldr	lr, [sp, #36]
 5443 300c 1C609DE5 		ldr	r6, [sp, #28]
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5444              		.loc 1 1188 0
 5445 3010 05C2C4E5 		strb	ip, [r4, #517]
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5446              		.loc 1 1189 0
 5447 3014 20C09DE5 		ldr	ip, [sp, #32]
 5448 3018 0B20A0E1 		mov	r2, fp
 5449 301c 18309DE5 		ldr	r3, [sp, #24]
 5450 3020 B0109FE5 		ldr	r1, .L452+12
 5451 3024 0A00A0E1 		mov	r0, sl
 5452 3028 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5453 302c 0C708DE5 		str	r7, [sp, #12]
 5454 3030 FEFFFFEB 		bl	CyU3PDebugPrint
 5455              	.LVL429:
1193:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5456              		.loc 1 1193 0
 5457 3034 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5458              	.LVL430:
1194:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5459              		.loc 1 1194 0
 5460 3038 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5461              	.LVL431:
1195:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5462              		.loc 1 1195 0
 5463 303c 0730A0E1 		mov	r3, r7
 5464 3040 0610A0E3 		mov	r1, #6
 5465 3044 8520A0E3 		mov	r2, #133
 5466 3048 80009FE5 		ldr	r0, .L452+4
 5467 304c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5468 3050 FEFFFFEB 		bl	cmdSet
1196:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5469              		.loc 1 1196 0
 5470 3054 0730A0E1 		mov	r3, r7
 5471 3058 0610A0E3 		mov	r1, #6
 5472 305c 8620A0E3 		mov	r2, #134
 5473 3060 68009FE5 		ldr	r0, .L452+4
 5474 3064 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5475 3068 FEFFFFEB 		bl	cmdSet
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5476              		.loc 1 1198 0
 5477 306c 0620A0E1 		mov	r2, r6
 5478 3070 0530A0E1 		mov	r3, r5
 5479 3074 58109FE5 		ldr	r1, .L452+8
 5480 3078 0A00A0E1 		mov	r0, sl
1197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5481              		.loc 1 1197 0
 5482 307c 1D62C4E5 		strb	r6, [r4, #541]
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5483              		.loc 1 1198 0
 5484 3080 FEFFFFEB 		bl	CyU3PDebugPrint
 5485              	.LVL432:
1203:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5486              		.loc 1 1203 0
 5487 3084 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5488              	.LVL433:
1204:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5489              		.loc 1 1204 0
 5490 3088 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5491 308c 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5492 3090 0710A0E3 		mov	r1, #7
 5493 3094 34009FE5 		ldr	r0, .L452+4
 5494 3098 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5495 309c FEFFFFEB 		bl	cmdSet
 5496              	.LVL434:
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5497              		.loc 1 1206 0
 5498 30a0 0530A0E1 		mov	r3, r5
 5499 30a4 0A00A0E1 		mov	r0, sl
 5500 30a8 24109FE5 		ldr	r1, .L452+8
 5501 30ac 0620A0E1 		mov	r2, r6
1205:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5502              		.loc 1 1205 0
 5503 30b0 3552C4E5 		strb	r5, [r4, #565]
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5504              		.loc 1 1206 0
 5505 30b4 FEFFFFEB 		bl	CyU3PDebugPrint
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5506              		.loc 1 1208 0
 5507 30b8 10309FE5 		ldr	r3, .L452+4
 5508 30bc 1C0093E5 		ldr	r0, [r3, #28]
1211:../uvc.c      **** }
 5509              		.loc 1 1211 0
 5510 30c0 2CD08DE2 		add	sp, sp, #44
 5511 30c4 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5512              		.loc 1 1208 0
 5513 30c8 FEFFFFEA 		b	_txe_mutex_put
 5514              	.L453:
 5515              		.align	2
 5516              	.L452:
 5517 30cc 00000000 		.word	.LANCHOR1
 5518 30d0 00000000 		.word	cmdQu
 5519 30d4 F0050000 		.word	.LC33
 5520 30d8 10060000 		.word	.LC34
 5521              		.cfi_endproc
 5522              	.LFE4:
 5524              		.align	2
 5525              		.global	CyFxUVCAddHeader
 5527              	CyFxUVCAddHeader:
 5528              	.LFB5:
1219:../uvc.c      **** {
 5529              		.loc 1 1219 0
 5530              		.cfi_startproc
 5531              		@ args = 0, pretend = 0, frame = 0
 5532              		@ frame_needed = 0, uses_anonymous_args = 0
 5533              	.LVL435:
 5534 30dc 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5535              	.LCFI21:
 5536              		.cfi_def_cfa_offset 16
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5537              		.loc 1 1221 0
 5538 30e0 0C20A0E3 		mov	r2, #12
1219:../uvc.c      **** {
 5539              		.loc 1 1219 0
 5540 30e4 0150A0E1 		mov	r5, r1
 5541              		.cfi_offset 14, -4
 5542              		.cfi_offset 5, -8
 5543              		.cfi_offset 4, -12
 5544              		.cfi_offset 3, -16
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5545              		.loc 1 1221 0
 5546 30e8 18109FE5 		ldr	r1, .L456
 5547              	.LVL436:
1219:../uvc.c      **** {
 5548              		.loc 1 1219 0
 5549 30ec 0040A0E1 		mov	r4, r0
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5550              		.loc 1 1221 0
 5551 30f0 FEFFFFEB 		bl	CyU3PMemCopy
 5552              	.LVL437:
1224:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5553              		.loc 1 1224 0
 5554 30f4 020015E3 		tst	r5, #2
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5555              		.loc 1 1226 0
 5556 30f8 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5557 30fc 02308313 		orrne	r3, r3, #2
 5558 3100 0130C415 		strneb	r3, [r4, #1]
 5559 3104 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5560              	.L457:
 5561              		.align	2
 5562              	.L456:
 5563 3108 80040000 		.word	.LANCHOR1+1152
 5564              		.cfi_endproc
 5565              	.LFE5:
 5567              		.align	2
 5568              		.global	CyFxAppErrorHandler
 5570              	CyFxAppErrorHandler:
 5571              	.LFB6:
1236:../uvc.c      **** {
 5572              		.loc 1 1236 0
 5573              		.cfi_startproc
 5574              		@ args = 0, pretend = 0, frame = 0
 5575              		@ frame_needed = 0, uses_anonymous_args = 0
 5576              	.LVL438:
 5577 310c 08402DE9 		stmfd	sp!, {r3, lr}
 5578              	.LCFI22:
 5579              		.cfi_def_cfa_offset 8
 5580              	.LVL439:
 5581              	.L459:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5582              		.loc 1 1246 0 discriminator 1
 5583 3110 10109FE5 		ldr	r1, .L460
 5584 3114 0400A0E3 		mov	r0, #4
 5585              		.cfi_offset 14, -4
 5586              		.cfi_offset 3, -8
 5587 3118 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 5588              		.loc 1 1247 0 discriminator 1
 5589 311c FA0FA0E3 		mov	r0, #1000
 5590 3120 FEFFFFEB 		bl	_tx_thread_sleep
 5591 3124 F9FFFFEA 		b	.L459
 5592              	.L461:
 5593              		.align	2
 5594              	.L460:
 5595 3128 D4010000 		.word	.LC12
 5596              		.cfi_endproc
 5597              	.LFE6:
 5599              		.align	2
 5600              		.global	UVCAppThread_Entry
 5602              	UVCAppThread_Entry:
 5603              	.LFB18:
2191:../uvc.c      **** {
 5604              		.loc 1 2191 0
 5605              		.cfi_startproc
 5606              		@ args = 0, pretend = 0, frame = 176
 5607              		@ frame_needed = 0, uses_anonymous_args = 0
 5608              	.LVL440:
 5609 312c F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5610              	.LCFI23:
 5611              		.cfi_def_cfa_offset 28
 5612 3130 BCD04DE2 		sub	sp, sp, #188
 5613              	.LCFI24:
 5614              		.cfi_def_cfa_offset 216
 5615              	.LBB212:
 5616              	.LBB213:
1648:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5617              		.loc 1 1648 0
 5618              		.cfi_offset 14, -4
 5619              		.cfi_offset 10, -8
 5620              		.cfi_offset 8, -12
 5621              		.cfi_offset 7, -16
 5622              		.cfi_offset 6, -20
 5623              		.cfi_offset 5, -24
 5624              		.cfi_offset 4, -28
 5625 3134 FEFFFFEB 		bl	CyU3PUartInit
 5626              	.LVL441:
1649:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5627              		.loc 1 1649 0
 5628 3138 004050E2 		subs	r4, r0, #0
 5629 313c 0400000A 		beq	.L463
1651:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5630              		.loc 1 1651 0
 5631 3140 0400A0E3 		mov	r0, #4
 5632              	.LVL442:
 5633 3144 A41A9FE5 		ldr	r1, .L557
 5634 3148 FEFFFFEB 		bl	CyU3PDebugPrint
1652:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5635              		.loc 1 1652 0
 5636 314c 0400A0E1 		mov	r0, r4
 5637 3150 FEFFFFEB 		bl	CyFxAppErrorHandler
 5638              	.L463:
1656:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5639              		.loc 1 1656 0
 5640 3154 98CA9FE5 		ldr	ip, .L557+4
1658:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5641              		.loc 1 1658 0
 5642 3158 0030A0E3 		mov	r3, #0
1657:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5643              		.loc 1 1657 0
 5644 315c 0120A0E3 		mov	r2, #1
1665:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5645              		.loc 1 1665 0
 5646 3160 50008DE2 		add	r0, sp, #80
 5647 3164 0310A0E1 		mov	r1, r3
1656:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5648              		.loc 1 1656 0
 5649 3168 60C08DE5 		str	ip, [sp, #96]
1657:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5650              		.loc 1 1657 0
 5651 316c 6420CDE5 		strb	r2, [sp, #100]
1658:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5652              		.loc 1 1658 0
 5653 3170 6530CDE5 		strb	r3, [sp, #101]
1659:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5654              		.loc 1 1659 0
 5655 3174 50208DE5 		str	r2, [sp, #80]
1660:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5656              		.loc 1 1660 0
 5657 3178 54308DE5 		str	r3, [sp, #84]
1661:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5658              		.loc 1 1661 0
 5659 317c 58308DE5 		str	r3, [sp, #88]
1662:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5660              		.loc 1 1662 0
 5661 3180 5C208DE5 		str	r2, [sp, #92]
1665:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5662              		.loc 1 1665 0
 5663 3184 FEFFFFEB 		bl	CyU3PUartSetConfig
 5664              	.LVL443:
1666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5665              		.loc 1 1666 0
 5666 3188 000050E3 		cmp	r0, #0
 5667 318c 0000000A 		beq	.L464
1668:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5668              		.loc 1 1668 0
 5669 3190 FEFFFFEB 		bl	CyFxAppErrorHandler
 5670              	.LVL444:
 5671              	.L464:
1672:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5672              		.loc 1 1672 0
 5673 3194 0000E0E3 		mvn	r0, #0
 5674 3198 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5675              	.LVL445:
1673:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5676              		.loc 1 1673 0
 5677 319c 000050E3 		cmp	r0, #0
 5678 31a0 0000000A 		beq	.L465
1675:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5679              		.loc 1 1675 0
 5680 31a4 FEFFFFEB 		bl	CyFxAppErrorHandler
 5681              	.LVL446:
 5682              	.L465:
1679:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5683              		.loc 1 1679 0
 5684 31a8 0300A0E3 		mov	r0, #3
 5685 31ac 0410A0E3 		mov	r1, #4
 5686 31b0 FEFFFFEB 		bl	CyU3PDebugInit
 5687              	.LVL447:
1680:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5688              		.loc 1 1680 0
 5689 31b4 000050E3 		cmp	r0, #0
 5690 31b8 0000000A 		beq	.L466
1682:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5691              		.loc 1 1682 0
 5692 31bc FEFFFFEB 		bl	CyFxAppErrorHandler
 5693              	.LVL448:
 5694              	.L466:
1686:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5695              		.loc 1 1686 0
 5696 31c0 0000A0E3 		mov	r0, #0
 5697 31c4 FEFFFFEB 		bl	CyU3PDebugPreamble
 5698              	.LVL449:
 5699              	.LBE213:
 5700              	.LBE212:
2206:../uvc.c      **** 		CyU3PThreadSleep(500);
 5701              		.loc 1 2206 0
 5702 31c8 7D0FA0E3 		mov	r0, #500
 5703 31cc FEFFFFEB 		bl	_tx_thread_sleep
 5704              	.LVL450:
 5705 31d0 7D0FA0E3 		mov	r0, #500
 5706 31d4 FEFFFFEB 		bl	_tx_thread_sleep
 5707 31d8 7D0FA0E3 		mov	r0, #500
 5708 31dc FEFFFFEB 		bl	_tx_thread_sleep
 5709 31e0 7D0FA0E3 		mov	r0, #500
 5710 31e4 FEFFFFEB 		bl	_tx_thread_sleep
 5711 31e8 7D0FA0E3 		mov	r0, #500
 5712 31ec FEFFFFEB 		bl	_tx_thread_sleep
 5713 31f0 7D0FA0E3 		mov	r0, #500
 5714 31f4 FEFFFFEB 		bl	_tx_thread_sleep
 5715              	.LBB214:
 5716              	.LBB215:
1697:../uvc.c      ****     status = CyU3PI2cInit ();
 5717              		.loc 1 1697 0
 5718 31f8 FEFFFFEB 		bl	CyU3PI2cInit
 5719              	.LVL451:
1698:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5720              		.loc 1 1698 0
 5721 31fc 002050E2 		subs	r2, r0, #0
 5722 3200 0201001A 		bne	.L532
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5723              		.loc 1 1705 0
 5724 3204 EC599FE5 		ldr	r5, .L557+8
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5725              		.loc 1 1707 0
 5726 3208 0040E0E3 		mvn	r4, #0
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5727              		.loc 1 1710 0
 5728 320c 0210A0E1 		mov	r1, r2
 5729 3210 8C008DE2 		add	r0, sp, #140
 5730              	.LVL452:
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5731              		.loc 1 1705 0
 5732 3214 8C508DE5 		str	r5, [sp, #140]
1706:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5733              		.loc 1 1706 0
 5734 3218 90208DE5 		str	r2, [sp, #144]
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5735              		.loc 1 1707 0
 5736 321c 94408DE5 		str	r4, [sp, #148]
1708:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5737              		.loc 1 1708 0
 5738 3220 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5739              		.loc 1 1710 0
 5740 3224 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5741              	.LVL453:
1711:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5742              		.loc 1 1711 0
 5743 3228 001050E2 		subs	r1, r0, #0
 5744 322c 0001001A 		bne	.L533
 5745              	.LBE215:
 5746              	.LBE214:
 5747              	.LBB221:
 5748              	.LBB224:
1784:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5749              		.loc 1 1784 0
 5750 3230 C4699FE5 		ldr	r6, .L557+12
 5751 3234 2820A0E3 		mov	r2, #40
 5752 3238 0600A0E1 		mov	r0, r6
 5753              	.LVL454:
 5754 323c FEFFFFEB 		bl	_txe_event_flags_create
 5755              	.LVL455:
1785:../uvc.c      ****     if (apiRetStatus != 0)
 5756              		.loc 1 1785 0
 5757 3240 002050E2 		subs	r2, r0, #0
 5758 3244 0301001A 		bne	.L534
1799:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5759              		.loc 1 1799 0
 5760 3248 0280A0E3 		mov	r8, #2
1806:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5761              		.loc 1 1806 0
 5762 324c 0210A0E1 		mov	r1, r2
 5763 3250 9C008DE2 		add	r0, sp, #156
 5764              	.LVL456:
1802:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5765              		.loc 1 1802 0
 5766 3254 017088E2 		add	r7, r8, #1
1795:../uvc.c      ****     isUsbConnected = CyFalse;
 5767              		.loc 1 1795 0
 5768 3258 3C2086E5 		str	r2, [r6, #60]
1796:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5769              		.loc 1 1796 0
 5770 325c 402086E5 		str	r2, [r6, #64]
1801:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5771              		.loc 1 1801 0
 5772 3260 A420CDE5 		strb	r2, [sp, #164]
1803:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5773              		.loc 1 1803 0
 5774 3264 A0208DE5 		str	r2, [sp, #160]
1799:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5775              		.loc 1 1799 0
 5776 3268 9C80CDE5 		strb	r8, [sp, #156]
1800:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5777              		.loc 1 1800 0
 5778 326c 9D80CDE5 		strb	r8, [sp, #157]
1802:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5779              		.loc 1 1802 0
 5780 3270 A570CDE5 		strb	r7, [sp, #165]
1806:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5781              		.loc 1 1806 0
 5782 3274 FEFFFFEB 		bl	CyU3PGpioInit
 5783              	.LVL457:
1807:../uvc.c      ****     if (apiRetStatus != 0)
 5784              		.loc 1 1807 0
 5785 3278 002050E2 		subs	r2, r0, #0
 5786 327c 7B01001A 		bne	.L535
1815:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5787              		.loc 1 1815 0
 5788 3280 1600A0E3 		mov	r0, #22
 5789              	.LVL458:
 5790 3284 0110A0E3 		mov	r1, #1
 5791 3288 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5792              	.LVL459:
1816:../uvc.c      ****     if (apiRetStatus != 0)
 5793              		.loc 1 1816 0
 5794 328c 002050E2 		subs	r2, r0, #0
 5795 3290 6D01001A 		bne	.L536
1821:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5796              		.loc 1 1821 0
 5797 3294 1400A0E3 		mov	r0, #20
 5798              	.LVL460:
 5799 3298 0110A0E3 		mov	r1, #1
 5800 329c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5801              	.LVL461:
1822:../uvc.c      ****     if (apiRetStatus != 0)
 5802              		.loc 1 1822 0
 5803 32a0 002050E2 		subs	r2, r0, #0
 5804 32a4 5F01001A 		bne	.L537
1827:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5805              		.loc 1 1827 0
 5806 32a8 1800A0E3 		mov	r0, #24
 5807              	.LVL462:
 5808 32ac 0110A0E3 		mov	r1, #1
 5809 32b0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5810              	.LVL463:
1828:../uvc.c      ****     if (apiRetStatus != 0)
 5811              		.loc 1 1828 0
 5812 32b4 002050E2 		subs	r2, r0, #0
 5813 32b8 5101001A 		bne	.L538
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5814              		.loc 1 1835 0
 5815 32bc 0140A0E3 		mov	r4, #1
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5816              		.loc 1 1840 0
 5817 32c0 1600A0E3 		mov	r0, #22
 5818              	.LVL464:
 5819 32c4 68108DE2 		add	r1, sp, #104
1838:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5820              		.loc 1 1838 0
 5821 32c8 74208DE5 		str	r2, [sp, #116]
1839:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5822              		.loc 1 1839 0
 5823 32cc 7820CDE5 		strb	r2, [sp, #120]
1835:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5824              		.loc 1 1835 0
 5825 32d0 68408DE5 		str	r4, [sp, #104]
1836:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5826              		.loc 1 1836 0
 5827 32d4 6C408DE5 		str	r4, [sp, #108]
1837:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5828              		.loc 1 1837 0
 5829 32d8 70408DE5 		str	r4, [sp, #112]
1840:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5830              		.loc 1 1840 0
 5831 32dc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5832              	.LVL465:
1841:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5833              		.loc 1 1841 0
 5834 32e0 002050E2 		subs	r2, r0, #0
 5835 32e4 1B01001A 		bne	.L539
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5836              		.loc 1 1854 0
 5837 32e8 1400A0E3 		mov	r0, #20
 5838              	.LVL466:
 5839 32ec 68108DE2 		add	r1, sp, #104
1852:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5840              		.loc 1 1852 0
 5841 32f0 74208DE5 		str	r2, [sp, #116]
1853:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5842              		.loc 1 1853 0
 5843 32f4 7820CDE5 		strb	r2, [sp, #120]
1849:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5844              		.loc 1 1849 0
 5845 32f8 68408DE5 		str	r4, [sp, #104]
1850:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5846              		.loc 1 1850 0
 5847 32fc 6C408DE5 		str	r4, [sp, #108]
1851:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5848              		.loc 1 1851 0
 5849 3300 70408DE5 		str	r4, [sp, #112]
1854:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5850              		.loc 1 1854 0
 5851 3304 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5852              	.LVL467:
1855:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5853              		.loc 1 1855 0
 5854 3308 002050E2 		subs	r2, r0, #0
 5855 330c 0801001A 		bne	.L540
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5856              		.loc 1 1868 0
 5857 3310 1800A0E3 		mov	r0, #24
 5858              	.LVL468:
 5859 3314 68108DE2 		add	r1, sp, #104
1863:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5860              		.loc 1 1863 0
 5861 3318 68208DE5 		str	r2, [sp, #104]
1864:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5862              		.loc 1 1864 0
 5863 331c 6C208DE5 		str	r2, [sp, #108]
1865:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5864              		.loc 1 1865 0
 5865 3320 70208DE5 		str	r2, [sp, #112]
1867:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5866              		.loc 1 1867 0
 5867 3324 7820CDE5 		strb	r2, [sp, #120]
1866:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5868              		.loc 1 1866 0
 5869 3328 74408DE5 		str	r4, [sp, #116]
1868:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5870              		.loc 1 1868 0
 5871 332c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5872              	.LVL469:
1869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5873              		.loc 1 1869 0
 5874 3330 002050E2 		subs	r2, r0, #0
 5875 3334 F500001A 		bne	.L541
1878:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5876              		.loc 1 1878 0
 5877 3338 00A0A0E3 		mov	sl, #0
1876:../uvc.c      ****     pibclock.clkDiv      = 2;
 5878              		.loc 1 1876 0
 5879 333c 0270A0E3 		mov	r7, #2	@ movhi
1877:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5880              		.loc 1 1877 0
 5881 3340 0380A0E3 		mov	r8, #3
1881:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5882              		.loc 1 1881 0
 5883 3344 0100A0E3 		mov	r0, #1
 5884              	.LVL470:
 5885 3348 7C108DE2 		add	r1, sp, #124
1876:../uvc.c      ****     pibclock.clkDiv      = 2;
 5886              		.loc 1 1876 0
 5887 334c BC77CDE1 		strh	r7, [sp, #124]	@ movhi
1877:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5888              		.loc 1 1877 0
 5889 3350 8880CDE5 		strb	r8, [sp, #136]
1878:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5890              		.loc 1 1878 0
 5891 3354 84A08DE5 		str	sl, [sp, #132]
1879:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5892              		.loc 1 1879 0
 5893 3358 80A08DE5 		str	sl, [sp, #128]
1881:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5894              		.loc 1 1881 0
 5895 335c FEFFFFEB 		bl	CyU3PPibInit
 5896              	.LVL471:
1882:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5897              		.loc 1 1882 0
 5898 3360 002050E2 		subs	r2, r0, #0
 5899 3364 7A01001A 		bne	.L542
1889:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5900              		.loc 1 1889 0
 5901 3368 90089FE5 		ldr	r0, .L557+16
 5902              	.LVL472:
 5903 336c FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 5904              	.LVL473:
1897:../uvc.c      ****     SensorReset ();
 5905              		.loc 1 1897 0
 5906 3370 FEFFFFEB 		bl	SensorReset
1898:../uvc.c      ****     SensorInit ();
 5907              		.loc 1 1898 0
 5908 3374 FEFFFFEB 		bl	SensorInit
1901:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5909              		.loc 1 1901 0
 5910 3378 FEFFFFEB 		bl	CyU3PUsbStart
 5911              	.LVL474:
1902:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5912              		.loc 1 1902 0
 5913 337c 004050E2 		subs	r4, r0, #0
 5914 3380 6901001A 		bne	.L543
1908:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 5915              		.loc 1 1908 0
 5916 3384 0410A0E1 		mov	r1, r4
 5917 3388 74089FE5 		ldr	r0, .L557+20
 5918              	.LVL475:
 5919 338c FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 5920              	.LVL476:
1911:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 5921              		.loc 1 1911 0
 5922 3390 70089FE5 		ldr	r0, .L557+24
 5923 3394 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1917:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 5924              		.loc 1 1917 0
 5925 3398 6C289FE5 		ldr	r2, .L557+28
 5926 339c 0410A0E1 		mov	r1, r4
 5927 33a0 0100A0E3 		mov	r0, #1
 5928 33a4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1918:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 5929              		.loc 1 1918 0
 5930 33a8 0410A0E1 		mov	r1, r4
 5931 33ac 5C289FE5 		ldr	r2, .L557+32
 5932 33b0 0400A0E1 		mov	r0, r4
 5933 33b4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1921:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 5934              		.loc 1 1921 0
 5935 33b8 0410A0E1 		mov	r1, r4
 5936 33bc 50289FE5 		ldr	r2, .L557+36
 5937 33c0 0200A0E3 		mov	r0, #2
 5938 33c4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1922:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 5939              		.loc 1 1922 0
 5940 33c8 0410A0E1 		mov	r1, r4
 5941 33cc 44289FE5 		ldr	r2, .L557+40
 5942 33d0 0700A0E3 		mov	r0, #7
 5943 33d4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1925:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 5944              		.loc 1 1925 0
 5945 33d8 3C289FE5 		ldr	r2, .L557+44
 5946 33dc 0410A0E1 		mov	r1, r4
 5947 33e0 0400A0E3 		mov	r0, #4
 5948 33e4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1926:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 5949              		.loc 1 1926 0
 5950 33e8 0410A0E1 		mov	r1, r4
 5951 33ec 2C289FE5 		ldr	r2, .L557+48
 5952 33f0 0800A0E1 		mov	r0, r8
 5953 33f4 FEFFFFEB 		bl	CyU3PUsbSetDesc
1927:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5954              		.loc 1 1927 0
 5955 33f8 0410A0E1 		mov	r1, r4
 5956 33fc 20289FE5 		ldr	r2, .L557+52
 5957 3400 0600A0E3 		mov	r0, #6
 5958 3404 FEFFFFEB 		bl	CyU3PUsbSetDesc
1930:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 5959              		.loc 1 1930 0
 5960 3408 0410A0E1 		mov	r1, r4
 5961 340c 14289FE5 		ldr	r2, .L557+56
 5962 3410 0500A0E3 		mov	r0, #5
 5963 3414 FEFFFFEB 		bl	CyU3PUsbSetDesc
1931:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 5964              		.loc 1 1931 0
 5965 3418 0110A0E3 		mov	r1, #1
 5966 341c 08289FE5 		ldr	r2, .L557+60
 5967 3420 0500A0E3 		mov	r0, #5
 5968 3424 FEFFFFEB 		bl	CyU3PUsbSetDesc
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 5969              		.loc 1 1932 0
 5970 3428 0210A0E3 		mov	r1, #2
 5971 342c FC279FE5 		ldr	r2, .L557+64
 5972 3430 0500A0E3 		mov	r0, #5
 5973 3434 FEFFFFEB 		bl	CyU3PUsbSetDesc
1939:../uvc.c      ****     endPointConfig.enable   = 1;
 5974              		.loc 1 1939 0
 5975 3438 0150A0E3 		mov	r5, #1
1941:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5976              		.loc 1 1941 0
 5977 343c 4020A0E3 		mov	r2, #64	@ movhi
1945:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5978              		.loc 1 1945 0
 5979 3440 8200A0E3 		mov	r0, #130
 5980 3444 A8108DE2 		add	r1, sp, #168
1939:../uvc.c      ****     endPointConfig.enable   = 1;
 5981              		.loc 1 1939 0
 5982 3448 A8508DE5 		str	r5, [sp, #168]
1940:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 5983              		.loc 1 1940 0
 5984 344c AC80CDE5 		strb	r8, [sp, #172]
1941:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5985              		.loc 1 1941 0
 5986 3450 B02BCDE1 		strh	r2, [sp, #176]	@ movhi
1942:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 5987              		.loc 1 1942 0
 5988 3454 B340CDE5 		strb	r4, [sp, #179]
1943:../uvc.c      ****     endPointConfig.streams  = 0;
 5989              		.loc 1 1943 0
 5990 3458 BE4ACDE1 		strh	r4, [sp, #174]	@ movhi
1944:../uvc.c      ****     endPointConfig.burstLen = 1;
 5991              		.loc 1 1944 0
 5992 345c B250CDE5 		strb	r5, [sp, #178]
1945:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5993              		.loc 1 1945 0
 5994 3460 FEFFFFEB 		bl	CyU3PSetEpConfig
 5995              	.LVL477:
1946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5996              		.loc 1 1946 0
 5997 3464 003050E2 		subs	r3, r0, #0
 5998 3468 2501001A 		bne	.L544
1956:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 5999              		.loc 1 1956 0
 6000 346c C0C79FE5 		ldr	ip, .L557+68
1957:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6001              		.loc 1 1957 0
 6002 3470 C0E79FE5 		ldr	lr, .L557+72
1954:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6003              		.loc 1 1954 0
 6004 3474 018BA0E3 		mov	r8, #1024	@ movhi
1963:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6005              		.loc 1 1963 0
 6006 3478 10A0A0E3 		mov	sl, #16
1965:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6007              		.loc 1 1965 0
 6008 347c B8079FE5 		ldr	r0, .L557+76
 6009              	.LVL478:
 6010 3480 0410A0E3 		mov	r1, #4
 6011 3484 34208DE2 		add	r2, sp, #52
1954:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6012              		.loc 1 1954 0
 6013 3488 B483CDE1 		strh	r8, [sp, #52]	@ movhi
1955:../uvc.c      ****     dmaInterConfig.count          = 1;
 6014              		.loc 1 1955 0
 6015 348c B653CDE1 		strh	r5, [sp, #54]	@ movhi
1956:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6016              		.loc 1 1956 0
 6017 3490 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1957:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6018              		.loc 1 1957 0
 6019 3494 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1958:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6020              		.loc 1 1958 0
 6021 3498 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1959:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6022              		.loc 1 1959 0
 6023 349c BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1960:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6024              		.loc 1 1960 0
 6025 34a0 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1961:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6026              		.loc 1 1961 0
 6027 34a4 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1962:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6028              		.loc 1 1962 0
 6029 34a8 4440CDE5 		strb	r4, [sp, #68]
1963:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6030              		.loc 1 1963 0
 6031 34ac 48A08DE5 		str	sl, [sp, #72]
1964:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6032              		.loc 1 1964 0
 6033 34b0 4C308DE5 		str	r3, [sp, #76]
1965:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6034              		.loc 1 1965 0
 6035 34b4 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6036              	.LVL479:
1967:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6037              		.loc 1 1967 0
 6038 34b8 008050E2 		subs	r8, r0, #0
 6039 34bc 0601001A 		bne	.L545
1974:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6040              		.loc 1 1974 0
 6041 34c0 010BA0E3 		mov	r0, #1024
 6042              	.LVL480:
 6043 34c4 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6044 34c8 70179FE5 		ldr	r1, .L557+80
1975:../uvc.c      ****     if (glInterStaBuffer == 0)
 6045              		.loc 1 1975 0
 6046 34cc 000050E3 		cmp	r0, #0
1974:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6047              		.loc 1 1974 0
 6048 34d0 000081E5 		str	r0, [r1, #0]
1975:../uvc.c      ****     if (glInterStaBuffer == 0)
 6049              		.loc 1 1975 0
 6050 34d4 3001000A 		beq	.L546
1983:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6051              		.loc 1 1983 0
 6052 34d8 0430A0E3 		mov	r3, #4	@ movhi
 6053 34dc BE30CDE1 		strh	r3, [sp, #14]	@ movhi
1987:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6054              		.loc 1 1987 0
 6055 34e0 5C379FE5 		ldr	r3, .L557+84
1982:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6056              		.loc 1 1982 0
 6057 34e4 01E9A0E3 		mov	lr, #16384	@ movhi
 6058 34e8 BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
1986:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6059              		.loc 1 1986 0
 6060 34ec 54E79FE5 		ldr	lr, .L557+88
1987:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6061              		.loc 1 1987 0
 6062 34f0 BA31CDE1 		strh	r3, [sp, #26]	@ movhi
1994:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6063              		.loc 1 1994 0
 6064 34f4 50379FE5 		ldr	r3, .L557+92
1985:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6065              		.loc 1 1985 0
 6066 34f8 01CCA0E3 		mov	ip, #256	@ movhi
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6067              		.loc 1 1995 0
 6068 34fc 0C208DE2 		add	r2, sp, #12
1985:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6069              		.loc 1 1985 0
 6070 3500 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
1986:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6071              		.loc 1 1986 0
 6072 3504 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
1989:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6073              		.loc 1 1989 0
 6074 3508 0CC0A0E3 		mov	ip, #12	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6075              		.loc 1 1990 0
 6076 350c 04E0A0E3 		mov	lr, #4	@ movhi
1992:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6077              		.loc 1 1992 0
 6078 3510 2A40CDE5 		strb	r4, [sp, #42]
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6079              		.loc 1 1995 0
 6080 3514 34079FE5 		ldr	r0, .L557+96
 6081 3518 0710A0E3 		mov	r1, #7
1993:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6082              		.loc 1 1993 0
 6083 351c 1840A0E3 		mov	r4, #24
1984:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6084              		.loc 1 1984 0
 6085 3520 B071CDE1 		strh	r7, [sp, #16]	@ movhi
1988:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6086              		.loc 1 1988 0
 6087 3524 B282CDE1 		strh	r8, [sp, #34]	@ movhi
1989:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6088              		.loc 1 1989 0
 6089 3528 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
1990:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6090              		.loc 1 1990 0
 6091 352c B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
1991:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6092              		.loc 1 1991 0
 6093 3530 B882CDE1 		strh	r8, [sp, #40]	@ movhi
1993:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6094              		.loc 1 1993 0
 6095 3534 2C408DE5 		str	r4, [sp, #44]
1994:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6096              		.loc 1 1994 0
 6097 3538 30308DE5 		str	r3, [sp, #48]
1995:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6098              		.loc 1 1995 0
 6099 353c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6100              	.LVL481:
1997:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6101              		.loc 1 1997 0
 6102 3540 002050E2 		subs	r2, r0, #0
 6103 3544 0B01001A 		bne	.L547
2088:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6104              		.loc 1 2088 0
 6105 3548 0500A0E1 		mov	r0, r5
 6106              	.LVL482:
 6107 354c 0510A0E1 		mov	r1, r5
 6108 3550 FEFFFFEB 		bl	CyU3PConnectState
 6109              	.LVL483:
2089:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6110              		.loc 1 2089 0
 6111 3554 002050E2 		subs	r2, r0, #0
 6112 3558 6300001A 		bne	.L548
2095:../uvc.c      ****     CyU3PBusyWait(100);
 6113              		.loc 1 2095 0
 6114 355c 6400A0E3 		mov	r0, #100
 6115              	.LVL484:
 6116 3560 FEFFFFEB 		bl	CyU3PBusyWait
 6117              	.LVL485:
2097:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6118              		.loc 1 2097 0
 6119 3564 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2099:../uvc.c      ****     endPointConfig.enable   = 1;
 6120              		.loc 1 2099 0
 6121 3568 A8508DE5 		str	r5, [sp, #168]
2100:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6122              		.loc 1 2100 0
 6123 356c AC70CDE5 		strb	r7, [sp, #172]
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6124              		.loc 1 2112 0
 6125 3570 A8108DE2 		add	r1, sp, #168
2101:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6126              		.loc 1 2101 0
 6127 3574 030050E3 		cmp	r0, #3
2097:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6128              		.loc 1 2097 0
 6129 3578 4800C6E5 		strb	r0, [r6, #72]
2108:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6130              		.loc 1 2108 0
 6131 357c 020CA013 		movne	r0, #512	@ movhi
2103:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6132              		.loc 1 2103 0
 6133 3580 017BA003 		moveq	r7, #1024	@ movhi
2108:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6134              		.loc 1 2108 0
 6135 3584 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2109:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6136              		.loc 1 2109 0
 6137 3588 B250CD15 		strneb	r5, [sp, #178]
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6138              		.loc 1 2112 0
 6139 358c 8300A0E3 		mov	r0, #131
2111:../uvc.c      ****     endPointConfig.streams  = 0;
 6140              		.loc 1 2111 0
 6141 3590 0050A0E3 		mov	r5, #0	@ movhi
2103:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6142              		.loc 1 2103 0
 6143 3594 B07BCD01 		streqh	r7, [sp, #176]	@ movhi
2104:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6144              		.loc 1 2104 0
 6145 3598 B2A0CD05 		streqb	sl, [sp, #178]
2111:../uvc.c      ****     endPointConfig.streams  = 0;
 6146              		.loc 1 2111 0
 6147 359c BE5ACDE1 		strh	r5, [sp, #174]	@ movhi
2112:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6148              		.loc 1 2112 0
 6149 35a0 FEFFFFEB 		bl	CyU3PSetEpConfig
 6150              	.LVL486:
2113:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6151              		.loc 1 2113 0
 6152 35a4 002050E2 		subs	r2, r0, #0
 6153 35a8 4600001A 		bne	.L529
 6154 35ac A0869FE5 		ldr	r8, .L557+100
 6155              	.LBE224:
 6156              	.LBE221:
2233:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6157              		.loc 1 2233 0
 6158 35b0 44569FE5 		ldr	r5, .L557+12
 6159 35b4 0240A0E1 		mov	r4, r2
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6160              		.loc 1 2304 0
 6161 35b8 0870A0E1 		mov	r7, r8
 6162              	.LVL487:
 6163              	.L503:
2233:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6164              		.loc 1 2233 0
 6165 35bc 38069FE5 		ldr	r0, .L557+12
 6166 35c0 0110A0E3 		mov	r1, #1
 6167 35c4 0220A0E3 		mov	r2, #2
 6168 35c8 B4308DE2 		add	r3, sp, #180
 6169 35cc 00408DE5 		str	r4, [sp, #0]
 6170 35d0 FEFFFFEB 		bl	_txe_event_flags_get
 6171 35d4 000050E3 		cmp	r0, #0
 6172 35d8 2700001A 		bne	.L505
2279:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6173              		.loc 1 2279 0
 6174 35dc 44A095E5 		ldr	sl, [r5, #68]
 6175 35e0 00005AE3 		cmp	sl, #0
 6176 35e4 0300000A 		beq	.L506
2279:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6177              		.loc 1 2279 0 is_stmt 0 discriminator 1
 6178 35e8 BE22D5E1 		ldrh	r2, [r5, #46]
 6179 35ec B013D5E1 		ldrh	r1, [r5, #48]
 6180 35f0 010052E1 		cmp	r2, r1
 6181 35f4 6000000A 		beq	.L549
 6182              	.L506:
2406:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6183              		.loc 1 2406 0 is_stmt 1
 6184 35f8 4010A0E3 		mov	r1, #64
 6185 35fc 0020A0E3 		mov	r2, #0
 6186 3600 F4059FE5 		ldr	r0, .L557+12
 6187 3604 FEFFFFEB 		bl	_txe_event_flags_set
2409:../uvc.c      ****         CyU3PThreadRelinquish ();
 6188              		.loc 1 2409 0
 6189 3608 FEFFFFEB 		bl	_txe_thread_relinquish
2410:../uvc.c      ****     }
 6190              		.loc 1 2410 0
 6191 360c EAFFFFEA 		b	.L503
 6192              	.LVL488:
 6193              	.L532:
 6194              	.LBB259:
 6195              	.LBB220:
1700:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6196              		.loc 1 1700 0
 6197 3610 0400A0E3 		mov	r0, #4
 6198              	.LVL489:
 6199 3614 3C169FE5 		ldr	r1, .L557+104
 6200 3618 FEFFFFEB 		bl	CyU3PDebugPrint
 6201              	.LVL490:
 6202              	.L468:
 6203              	.LBB216:
 6204              	.LBB217:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6205              		.loc 1 1246 0
 6206 361c 38169FE5 		ldr	r1, .L557+108
 6207 3620 0400A0E3 		mov	r0, #4
 6208 3624 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6209              		.loc 1 1247 0
 6210 3628 FA0FA0E3 		mov	r0, #1000
 6211 362c FEFFFFEB 		bl	_tx_thread_sleep
 6212 3630 F9FFFFEA 		b	.L468
 6213              	.LVL491:
 6214              	.L533:
 6215              	.LBE217:
 6216              	.LBE216:
1713:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6217              		.loc 1 1713 0
 6218 3634 0400A0E3 		mov	r0, #4
 6219              	.LVL492:
 6220 3638 20169FE5 		ldr	r1, .L557+112
 6221              	.LVL493:
 6222 363c FEFFFFEB 		bl	CyU3PDebugPrint
 6223              	.L470:
 6224              	.LBB218:
 6225              	.LBB219:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6226              		.loc 1 1246 0
 6227 3640 14169FE5 		ldr	r1, .L557+108
 6228 3644 0400A0E3 		mov	r0, #4
 6229 3648 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6230              		.loc 1 1247 0
 6231 364c FA0FA0E3 		mov	r0, #1000
 6232 3650 FEFFFFEB 		bl	_tx_thread_sleep
 6233 3654 F9FFFFEA 		b	.L470
 6234              	.LVL494:
 6235              	.L534:
 6236              	.LBE219:
 6237              	.LBE218:
 6238              	.LBE220:
 6239              	.LBE259:
 6240              	.LBB260:
 6241              	.LBB223:
1787:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6242              		.loc 1 1787 0
 6243 3658 0400A0E3 		mov	r0, #4
 6244              	.LVL495:
 6245 365c 00169FE5 		ldr	r1, .L557+116
 6246 3660 FEFFFFEB 		bl	CyU3PDebugPrint
 6247              	.LVL496:
 6248              	.L472:
 6249              	.LBB233:
 6250              	.LBB234:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6251              		.loc 1 1246 0
 6252 3664 F0159FE5 		ldr	r1, .L557+108
 6253 3668 0400A0E3 		mov	r0, #4
 6254 366c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6255              		.loc 1 1247 0
 6256 3670 FA0FA0E3 		mov	r0, #1000
 6257 3674 FEFFFFEB 		bl	_tx_thread_sleep
 6258 3678 F9FFFFEA 		b	.L472
 6259              	.LVL497:
 6260              	.L505:
 6261              	.LBE234:
 6262              	.LBE233:
 6263              	.LBE223:
 6264              	.LBE260:
2335:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6265              		.loc 1 2335 0
 6266 367c 78059FE5 		ldr	r0, .L557+12
 6267 3680 0210A0E3 		mov	r1, #2
 6268 3684 0320A0E3 		mov	r2, #3
 6269 3688 B4308DE2 		add	r3, sp, #180
 6270 368c 00408DE5 		str	r4, [sp, #0]
 6271 3690 FEFFFFEB 		bl	_txe_event_flags_get
 6272 3694 000050E3 		cmp	r0, #0
 6273 3698 DA00001A 		bne	.L513
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6274              		.loc 1 2350 0
 6275 369c 402095E5 		ldr	r2, [r5, #64]
2338:../uvc.c      ****                 hitFV     = CyFalse;
 6276              		.loc 1 2338 0
 6277 36a0 444085E5 		str	r4, [r5, #68]
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6278              		.loc 1 2350 0
 6279 36a4 000052E3 		cmp	r2, #0
2339:../uvc.c      ****                 prodCount = 0;
 6280              		.loc 1 2339 0
 6281 36a8 BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2346:../uvc.c      ****                 fb=0;
 6282              		.loc 1 2346 0
 6283 36ac B842C5E1 		strh	r4, [r5, #40]	@ movhi
2340:../uvc.c      ****                 consCount = 0;
 6284              		.loc 1 2340 0
 6285 36b0 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2347:../uvc.c      ****                 pb=0;
 6286              		.loc 1 2347 0
 6287 36b4 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2348:../uvc.c      ****                 pbc=0;
 6288              		.loc 1 2348 0
 6289 36b8 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2350:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6290              		.loc 1 2350 0
 6291 36bc BF00000A 		beq	.L550
 6292              	.L514:
2362:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6293              		.loc 1 2362 0
 6294 36c0 404086E5 		str	r4, [r6, #64]
 6295 36c4 CBFFFFEA 		b	.L506
 6296              	.LVL498:
 6297              	.L529:
 6298              	.LBB261:
 6299              	.LBB257:
2116:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6300              		.loc 1 2116 0
 6301 36c8 0400A0E3 		mov	r0, #4
 6302              	.LVL499:
 6303 36cc 94159FE5 		ldr	r1, .L557+120
 6304 36d0 FEFFFFEB 		bl	CyU3PDebugPrint
 6305              	.LVL500:
 6306              	.L504:
 6307              	.LBB235:
 6308              	.LBB236:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6309              		.loc 1 1246 0
 6310 36d4 80159FE5 		ldr	r1, .L557+108
 6311 36d8 0400A0E3 		mov	r0, #4
 6312 36dc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6313              		.loc 1 1247 0
 6314 36e0 FA0FA0E3 		mov	r0, #1000
 6315 36e4 FEFFFFEB 		bl	_tx_thread_sleep
 6316 36e8 F9FFFFEA 		b	.L504
 6317              	.LVL501:
 6318              	.L548:
 6319              	.LBE236:
 6320              	.LBE235:
2091:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6321              		.loc 1 2091 0
 6322 36ec 0400A0E3 		mov	r0, #4
 6323              	.LVL502:
 6324 36f0 74159FE5 		ldr	r1, .L557+124
 6325 36f4 FEFFFFEB 		bl	CyU3PDebugPrint
 6326              	.LVL503:
 6327              	.L500:
 6328              	.LBB237:
 6329              	.LBB238:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6330              		.loc 1 1246 0
 6331 36f8 5C159FE5 		ldr	r1, .L557+108
 6332 36fc 0400A0E3 		mov	r0, #4
 6333 3700 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6334              		.loc 1 1247 0
 6335 3704 FA0FA0E3 		mov	r0, #1000
 6336 3708 FEFFFFEB 		bl	_tx_thread_sleep
 6337 370c F9FFFFEA 		b	.L500
 6338              	.LVL504:
 6339              	.L541:
 6340              	.LBE238:
 6341              	.LBE237:
1871:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6342              		.loc 1 1871 0
 6343 3710 0400A0E3 		mov	r0, #4
 6344              	.LVL505:
 6345 3714 54159FE5 		ldr	r1, .L557+128
 6346 3718 FEFFFFEB 		bl	CyU3PDebugPrint
 6347              	.LVL506:
 6348              	.L486:
 6349              	.LBB239:
 6350              	.LBB240:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6351              		.loc 1 1246 0
 6352 371c 38159FE5 		ldr	r1, .L557+108
 6353 3720 0400A0E3 		mov	r0, #4
 6354 3724 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6355              		.loc 1 1247 0
 6356 3728 FA0FA0E3 		mov	r0, #1000
 6357 372c FEFFFFEB 		bl	_tx_thread_sleep
 6358 3730 F9FFFFEA 		b	.L486
 6359              	.LVL507:
 6360              	.L540:
 6361              	.LBE240:
 6362              	.LBE239:
1857:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6363              		.loc 1 1857 0
 6364 3734 0400A0E3 		mov	r0, #4
 6365              	.LVL508:
 6366 3738 34159FE5 		ldr	r1, .L557+132
 6367 373c FEFFFFEB 		bl	CyU3PDebugPrint
 6368              	.LVL509:
 6369              	.L484:
 6370              	.LBB241:
 6371              	.LBB242:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6372              		.loc 1 1246 0
 6373 3740 14159FE5 		ldr	r1, .L557+108
 6374 3744 0400A0E3 		mov	r0, #4
 6375 3748 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6376              		.loc 1 1247 0
 6377 374c FA0FA0E3 		mov	r0, #1000
 6378 3750 FEFFFFEB 		bl	_tx_thread_sleep
 6379 3754 F9FFFFEA 		b	.L484
 6380              	.LVL510:
 6381              	.L539:
 6382              	.LBE242:
 6383              	.LBE241:
1843:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6384              		.loc 1 1843 0
 6385 3758 0400A0E3 		mov	r0, #4
 6386              	.LVL511:
 6387 375c 14159FE5 		ldr	r1, .L557+136
 6388 3760 FEFFFFEB 		bl	CyU3PDebugPrint
 6389              	.LVL512:
 6390              	.L482:
 6391              	.LBB243:
 6392              	.LBB244:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6393              		.loc 1 1246 0
 6394 3764 F0149FE5 		ldr	r1, .L557+108
 6395 3768 0400A0E3 		mov	r0, #4
 6396 376c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6397              		.loc 1 1247 0
 6398 3770 FA0FA0E3 		mov	r0, #1000
 6399 3774 FEFFFFEB 		bl	_tx_thread_sleep
 6400 3778 F9FFFFEA 		b	.L482
 6401              	.LVL513:
 6402              	.L549:
 6403              	.LBE244:
 6404              	.LBE243:
 6405              	.LBE257:
 6406              	.LBE261:
2289:../uvc.c      ****                 prodCount = 0;
 6407              		.loc 1 2289 0
 6408 377c BE42C5E1 		strh	r4, [r5, #46]	@ movhi
2290:../uvc.c      ****                 consCount = 0;
 6409              		.loc 1 2290 0
 6410 3780 B043C5E1 		strh	r4, [r5, #48]	@ movhi
2291:../uvc.c      ****                 hitFV     = CyFalse;
 6411              		.loc 1 2291 0
 6412 3784 444085E5 		str	r4, [r5, #68]
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6413              		.loc 1 2304 0
 6414 3788 8104D8E5 		ldrb	r0, [r8, #1153]	@ zero_extendqisi2
2286:../uvc.c      ****             	fb=0;
 6415              		.loc 1 2286 0
 6416 378c B842C5E1 		strh	r4, [r5, #40]	@ movhi
2304:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6417              		.loc 1 2304 0
 6418 3790 01E020E2 		eor	lr, r0, #1
 6419 3794 81E4C8E5 		strb	lr, [r8, #1153]
2305:../uvc.c      ****                 if(stiflag){
 6420              		.loc 1 2305 0
 6421 3798 9C3095E5 		ldr	r3, [r5, #156]
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6422              		.loc 1 2306 0
 6423 379c 81C4D7E5 		ldrb	ip, [r7, #1153]	@ zero_extendqisi2
2305:../uvc.c      ****                 if(stiflag){
 6424              		.loc 1 2305 0
 6425 37a0 000053E3 		cmp	r3, #0
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6426              		.loc 1 2306 0
 6427 37a4 20C08C13 		orrne	ip, ip, #32
2309:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6428              		.loc 1 2309 0
 6429 37a8 DFC00C02 		andeq	ip, ip, #223
2306:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6430              		.loc 1 2306 0
 6431 37ac 81C4C715 		strneb	ip, [r7, #1153]
2309:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6432              		.loc 1 2309 0
 6433 37b0 81C4C705 		streqb	ip, [r7, #1153]
2307:../uvc.c      ****                 	stiflag = CyFalse;
 6434              		.loc 1 2307 0
 6435 37b4 9C408515 		strne	r4, [r5, #156]
2287:../uvc.c      ****             	pb=0;
 6436              		.loc 1 2287 0
 6437 37b8 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2288:../uvc.c      ****             	pbc=0;
 6438              		.loc 1 2288 0
 6439 37bc BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2312:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6440              		.loc 1 2312 0
 6441 37c0 88049FE5 		ldr	r0, .L557+96
 6442 37c4 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6443              	.LVL514:
2313:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6444              		.loc 1 2313 0
 6445 37c8 002050E2 		subs	r2, r0, #0
 6446 37cc 3900001A 		bne	.L551
2320:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6447              		.loc 1 2320 0
 6448 37d0 0210A0E1 		mov	r1, r2
 6449 37d4 74049FE5 		ldr	r0, .L557+96
 6450              	.LVL515:
 6451 37d8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6452              	.LVL516:
2321:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6453              		.loc 1 2321 0
 6454 37dc 002050E2 		subs	r2, r0, #0
 6455 37e0 2B00001A 		bne	.L552
2329:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6456              		.loc 1 2329 0
 6457 37e4 5C049FE5 		ldr	r0, .L557+88
 6458              	.LVL517:
 6459 37e8 0210A0E1 		mov	r1, r2
 6460 37ec 02A0A0E3 		mov	sl, #2
 6461 37f0 0020A0E1 		mov	r2, r0
 6462              	.LVL518:
 6463 37f4 0130A0E1 		mov	r3, r1
 6464 37f8 00A08DE5 		str	sl, [sp, #0]
 6465 37fc FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6466              	.LVL519:
 6467 3800 7CFFFFEA 		b	.L506
 6468              	.LVL520:
 6469              	.L538:
 6470              	.LBB262:
 6471              	.LBB222:
1830:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6472              		.loc 1 1830 0
 6473 3804 0400A0E3 		mov	r0, #4
 6474              	.LVL521:
 6475 3808 6C149FE5 		ldr	r1, .L557+140
 6476 380c FEFFFFEB 		bl	CyU3PDebugPrint
 6477              	.LVL522:
 6478              	.L480:
 6479              	.LBB231:
 6480              	.LBB232:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6481              		.loc 1 1246 0
 6482 3810 44149FE5 		ldr	r1, .L557+108
 6483 3814 0400A0E3 		mov	r0, #4
 6484 3818 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6485              		.loc 1 1247 0
 6486 381c FA0FA0E3 		mov	r0, #1000
 6487 3820 FEFFFFEB 		bl	_tx_thread_sleep
 6488 3824 F9FFFFEA 		b	.L480
 6489              	.LVL523:
 6490              	.L537:
 6491              	.LBE232:
 6492              	.LBE231:
1824:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6493              		.loc 1 1824 0
 6494 3828 0400A0E3 		mov	r0, #4
 6495              	.LVL524:
 6496 382c 4C149FE5 		ldr	r1, .L557+144
 6497 3830 FEFFFFEB 		bl	CyU3PDebugPrint
 6498              	.LVL525:
 6499              	.L478:
 6500              	.LBB229:
 6501              	.LBB230:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6502              		.loc 1 1246 0
 6503 3834 20149FE5 		ldr	r1, .L557+108
 6504 3838 0400A0E3 		mov	r0, #4
 6505 383c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6506              		.loc 1 1247 0
 6507 3840 FA0FA0E3 		mov	r0, #1000
 6508 3844 FEFFFFEB 		bl	_tx_thread_sleep
 6509 3848 F9FFFFEA 		b	.L478
 6510              	.LVL526:
 6511              	.L536:
 6512              	.LBE230:
 6513              	.LBE229:
1818:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6514              		.loc 1 1818 0
 6515 384c 0400A0E3 		mov	r0, #4
 6516              	.LVL527:
 6517 3850 2C149FE5 		ldr	r1, .L557+148
 6518 3854 FEFFFFEB 		bl	CyU3PDebugPrint
 6519              	.LVL528:
 6520              	.L476:
 6521              	.LBB227:
 6522              	.LBB228:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6523              		.loc 1 1246 0
 6524 3858 FC139FE5 		ldr	r1, .L557+108
 6525 385c 0400A0E3 		mov	r0, #4
 6526 3860 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6527              		.loc 1 1247 0
 6528 3864 FA0FA0E3 		mov	r0, #1000
 6529 3868 FEFFFFEB 		bl	_tx_thread_sleep
 6530 386c F9FFFFEA 		b	.L476
 6531              	.LVL529:
 6532              	.L535:
 6533              	.LBE228:
 6534              	.LBE227:
1809:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6535              		.loc 1 1809 0
 6536 3870 0400A0E3 		mov	r0, #4
 6537              	.LVL530:
 6538 3874 0C149FE5 		ldr	r1, .L557+152
 6539 3878 FEFFFFEB 		bl	CyU3PDebugPrint
 6540              	.LVL531:
 6541              	.L474:
 6542              	.LBB225:
 6543              	.LBB226:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6544              		.loc 1 1246 0
 6545 387c D8139FE5 		ldr	r1, .L557+108
 6546 3880 0400A0E3 		mov	r0, #4
 6547 3884 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6548              		.loc 1 1247 0
 6549 3888 FA0FA0E3 		mov	r0, #1000
 6550 388c FEFFFFEB 		bl	_tx_thread_sleep
 6551 3890 F9FFFFEA 		b	.L474
 6552              	.LVL532:
 6553              	.L552:
 6554              	.LBE226:
 6555              	.LBE225:
 6556              	.LBE222:
 6557              	.LBE262:
2323:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6558              		.loc 1 2323 0
 6559 3894 0400A0E3 		mov	r0, #4
 6560              	.LVL533:
 6561 3898 EC139FE5 		ldr	r1, .L557+156
 6562 389c FEFFFFEB 		bl	CyU3PDebugPrint
 6563              	.LVL534:
 6564              	.L512:
 6565              	.LBB263:
 6566              	.LBB264:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6567              		.loc 1 1246 0
 6568 38a0 B4139FE5 		ldr	r1, .L557+108
 6569 38a4 0400A0E3 		mov	r0, #4
 6570 38a8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6571              		.loc 1 1247 0
 6572 38ac FA0FA0E3 		mov	r0, #1000
 6573 38b0 FEFFFFEB 		bl	_tx_thread_sleep
 6574 38b4 F9FFFFEA 		b	.L512
 6575              	.LVL535:
 6576              	.L551:
 6577              	.LBE264:
 6578              	.LBE263:
2315:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6579              		.loc 1 2315 0
 6580 38b8 0400A0E3 		mov	r0, #4
 6581              	.LVL536:
 6582 38bc CC139FE5 		ldr	r1, .L557+160
 6583 38c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6584              	.LVL537:
 6585              	.L510:
 6586              	.LBB265:
 6587              	.LBB266:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6588              		.loc 1 1246 0
 6589 38c4 90139FE5 		ldr	r1, .L557+108
 6590 38c8 0400A0E3 		mov	r0, #4
 6591 38cc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6592              		.loc 1 1247 0
 6593 38d0 FA0FA0E3 		mov	r0, #1000
 6594 38d4 FEFFFFEB 		bl	_tx_thread_sleep
 6595 38d8 F9FFFFEA 		b	.L510
 6596              	.LVL538:
 6597              	.L545:
 6598              	.LBE266:
 6599              	.LBE265:
 6600              	.LBB267:
 6601              	.LBB258:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6602              		.loc 1 1970 0
 6603 38dc 0400A0E3 		mov	r0, #4
 6604              	.LVL539:
 6605 38e0 AC139FE5 		ldr	r1, .L557+164
 6606 38e4 0820A0E1 		mov	r2, r8
 6607 38e8 FEFFFFEB 		bl	CyU3PDebugPrint
 6608              	.L494:
 6609              	.LBB245:
 6610              	.LBB246:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6611              		.loc 1 1246 0
 6612 38ec 68139FE5 		ldr	r1, .L557+108
 6613 38f0 0400A0E3 		mov	r0, #4
 6614 38f4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6615              		.loc 1 1247 0
 6616 38f8 FA0FA0E3 		mov	r0, #1000
 6617 38fc FEFFFFEB 		bl	_tx_thread_sleep
 6618 3900 F9FFFFEA 		b	.L494
 6619              	.LVL540:
 6620              	.L544:
 6621              	.LBE246:
 6622              	.LBE245:
1949:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6623              		.loc 1 1949 0
 6624 3904 0400A0E3 		mov	r0, #4
 6625              	.LVL541:
 6626 3908 58139FE5 		ldr	r1, .L557+120
 6627 390c 0320A0E1 		mov	r2, r3
 6628 3910 FEFFFFEB 		bl	CyU3PDebugPrint
 6629              	.LVL542:
 6630              	.L492:
 6631              	.LBB247:
 6632              	.LBB248:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6633              		.loc 1 1246 0
 6634 3914 40139FE5 		ldr	r1, .L557+108
 6635 3918 0400A0E3 		mov	r0, #4
 6636 391c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6637              		.loc 1 1247 0
 6638 3920 FA0FA0E3 		mov	r0, #1000
 6639 3924 FEFFFFEB 		bl	_tx_thread_sleep
 6640 3928 F9FFFFEA 		b	.L492
 6641              	.LVL543:
 6642              	.L543:
 6643              	.LBE248:
 6644              	.LBE247:
1904:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6645              		.loc 1 1904 0
 6646 392c 0400A0E3 		mov	r0, #4
 6647 3930 60139FE5 		ldr	r1, .L557+168
 6648 3934 0420A0E1 		mov	r2, r4
 6649 3938 FEFFFFEB 		bl	CyU3PDebugPrint
 6650              	.L490:
 6651              	.LBB249:
 6652              	.LBB250:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6653              		.loc 1 1246 0
 6654 393c 18139FE5 		ldr	r1, .L557+108
 6655 3940 0400A0E3 		mov	r0, #4
 6656 3944 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6657              		.loc 1 1247 0
 6658 3948 FA0FA0E3 		mov	r0, #1000
 6659 394c FEFFFFEB 		bl	_tx_thread_sleep
 6660 3950 F9FFFFEA 		b	.L490
 6661              	.LVL544:
 6662              	.L542:
 6663              	.LBE250:
 6664              	.LBE249:
1884:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6665              		.loc 1 1884 0
 6666 3954 0400A0E3 		mov	r0, #4
 6667              	.LVL545:
 6668 3958 3C139FE5 		ldr	r1, .L557+172
 6669 395c FEFFFFEB 		bl	CyU3PDebugPrint
 6670              	.LVL546:
 6671              	.L488:
 6672              	.LBB251:
 6673              	.LBB252:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6674              		.loc 1 1246 0
 6675 3960 F4129FE5 		ldr	r1, .L557+108
 6676 3964 0400A0E3 		mov	r0, #4
 6677 3968 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6678              		.loc 1 1247 0
 6679 396c FA0FA0E3 		mov	r0, #1000
 6680 3970 FEFFFFEB 		bl	_tx_thread_sleep
 6681 3974 F9FFFFEA 		b	.L488
 6682              	.LVL547:
 6683              	.L547:
 6684              	.LBE252:
 6685              	.LBE251:
2000:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6686              		.loc 1 2000 0
 6687 3978 0400A0E3 		mov	r0, #4
 6688              	.LVL548:
 6689 397c 1C139FE5 		ldr	r1, .L557+176
 6690 3980 FEFFFFEB 		bl	CyU3PDebugPrint
 6691              	.LVL549:
 6692              	.L498:
 6693              	.LBB253:
 6694              	.LBB254:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6695              		.loc 1 1246 0
 6696 3984 D0129FE5 		ldr	r1, .L557+108
 6697 3988 0400A0E3 		mov	r0, #4
 6698 398c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6699              		.loc 1 1247 0
 6700 3990 FA0FA0E3 		mov	r0, #1000
 6701 3994 FEFFFFEB 		bl	_tx_thread_sleep
 6702 3998 F9FFFFEA 		b	.L498
 6703              	.LVL550:
 6704              	.L546:
 6705              	.LBE254:
 6706              	.LBE253:
1977:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6707              		.loc 1 1977 0
 6708 399c 040080E2 		add	r0, r0, #4
 6709 39a0 FC129FE5 		ldr	r1, .L557+180
 6710 39a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6711              	.LVL551:
 6712              	.L496:
 6713              	.LBB255:
 6714              	.LBB256:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6715              		.loc 1 1246 0
 6716 39a8 AC129FE5 		ldr	r1, .L557+108
 6717 39ac 0400A0E3 		mov	r0, #4
 6718 39b0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6719              		.loc 1 1247 0
 6720 39b4 FA0FA0E3 		mov	r0, #1000
 6721 39b8 FEFFFFEB 		bl	_tx_thread_sleep
 6722 39bc F9FFFFEA 		b	.L496
 6723              	.LVL552:
 6724              	.L550:
 6725              	.LBE256:
 6726              	.LBE255:
 6727              	.LBE258:
 6728              	.LBE267:
2352:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6729              		.loc 1 2352 0
 6730 39c0 88029FE5 		ldr	r0, .L557+96
 6731 39c4 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6732              	.LVL553:
2353:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6733              		.loc 1 2353 0
 6734 39c8 000050E3 		cmp	r0, #0
 6735 39cc 0200001A 		bne	.L530
2359:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6736              		.loc 1 2359 0
 6737 39d0 8300A0E3 		mov	r0, #131
 6738              	.LVL554:
 6739 39d4 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6740 39d8 38FFFFEA 		b	.L514
 6741              	.L530:
 6742              	.LBB268:
 6743              	.LBB269:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6744              		.loc 1 1246 0
 6745 39dc 78129FE5 		ldr	r1, .L557+108
 6746 39e0 0400A0E3 		mov	r0, #4
 6747 39e4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6748              		.loc 1 1247 0
 6749 39e8 FA0FA0E3 		mov	r0, #1000
 6750 39ec FEFFFFEB 		bl	_tx_thread_sleep
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6751              		.loc 1 1246 0
 6752 39f0 64129FE5 		ldr	r1, .L557+108
 6753 39f4 0400A0E3 		mov	r0, #4
 6754 39f8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6755              		.loc 1 1247 0
 6756 39fc FA0FA0E3 		mov	r0, #1000
 6757 3a00 FEFFFFEB 		bl	_tx_thread_sleep
 6758 3a04 F4FFFFEA 		b	.L530
 6759              	.L513:
 6760              	.LBE269:
 6761              	.LBE268:
2367:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6762              		.loc 1 2367 0
 6763 3a08 00C0E0E3 		mvn	ip, #0
 6764 3a0c 0110A0E3 		mov	r1, #1
 6765 3a10 0220A0E3 		mov	r2, #2
 6766 3a14 B4308DE2 		add	r3, sp, #180
 6767 3a18 DC019FE5 		ldr	r0, .L557+12
 6768 3a1c 00C08DE5 		str	ip, [sp, #0]
 6769 3a20 FEFFFFEB 		bl	_txe_event_flags_get
2371:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6770              		.loc 1 2371 0
 6771 3a24 0420A0E1 		mov	r2, r4
 6772 3a28 20029FE5 		ldr	r0, .L557+96
 6773 3a2c 0410A0E1 		mov	r1, r4
 6774 3a30 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6775              	.LVL555:
2372:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6776              		.loc 1 2372 0
 6777 3a34 002050E2 		subs	r2, r0, #0
 6778 3a38 2F00001A 		bne	.L553
2380:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6779              		.loc 1 2380 0
 6780 3a3c 383095E5 		ldr	r3, [r5, #56]
 6781 3a40 000053E3 		cmp	r3, #0
 6782 3a44 5800001A 		bne	.L519
2383:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6783              		.loc 1 2383 0
 6784 3a48 3010A0E3 		mov	r1, #48
 6785 3a4c 0120A0E3 		mov	r2, #1
 6786 3a50 823083E2 		add	r3, r3, #130
 6787 3a54 2100A0E3 		mov	r0, #33
 6788              	.LVL556:
 6789 3a58 FEFFFFEB 		bl	SensorSetIrisControl
2384:../uvc.c      ****                     CyU3PThreadSleep(500);
 6790              		.loc 1 2384 0
 6791 3a5c 7D0FA0E3 		mov	r0, #500
 6792 3a60 FEFFFFEB 		bl	_tx_thread_sleep
2385:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6793              		.loc 1 2385 0
 6794 3a64 3010A0E3 		mov	r1, #48
 6795 3a68 0220A0E3 		mov	r2, #2
 6796 3a6c 5230A0E3 		mov	r3, #82
 6797 3a70 2500A0E3 		mov	r0, #37
 6798 3a74 FEFFFFEB 		bl	SensorSetIrisControl
2386:../uvc.c      ****                     CyU3PThreadSleep(500);
 6799              		.loc 1 2386 0
 6800 3a78 7D0FA0E3 		mov	r0, #500
 6801 3a7c FEFFFFEB 		bl	_tx_thread_sleep
2387:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
 6802              		.loc 1 2387 0
 6803 3a80 3010A0E3 		mov	r1, #48
 6804 3a84 0A20A0E3 		mov	r2, #10
 6805 3a88 8230A0E3 		mov	r3, #130
 6806 3a8c 2300A0E3 		mov	r0, #35
 6807 3a90 FEFFFFEB 		bl	SensorSetIrisControl
2388:../uvc.c      ****                    	CyU3PThreadSleep(300);
 6808              		.loc 1 2388 0
 6809 3a94 4B0FA0E3 		mov	r0, #300
 6810 3a98 FEFFFFEB 		bl	_tx_thread_sleep
2389:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6811              		.loc 1 2389 0
 6812 3a9c 3010A0E3 		mov	r1, #48
 6813 3aa0 0420A0E1 		mov	r2, r4
 6814 3aa4 8230A0E3 		mov	r3, #130
 6815 3aa8 2100A0E3 		mov	r0, #33
 6816 3aac FEFFFFEB 		bl	SensorSetIrisControl
2390:../uvc.c      ****                     CyU3PThreadSleep(500);
 6817              		.loc 1 2390 0
 6818 3ab0 7D0FA0E3 		mov	r0, #500
 6819 3ab4 FEFFFFEB 		bl	_tx_thread_sleep
2391:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6820              		.loc 1 2391 0
 6821 3ab8 5230A0E3 		mov	r3, #82
 6822 3abc 3010A0E3 		mov	r1, #48
 6823 3ac0 0420A0E1 		mov	r2, r4
 6824 3ac4 2500A0E3 		mov	r0, #37
 6825 3ac8 FEFFFFEB 		bl	SensorSetIrisControl
2392:../uvc.c      ****                     CyU3PThreadSleep(500);
 6826              		.loc 1 2392 0
 6827 3acc 7D0FA0E3 		mov	r0, #500
 6828 3ad0 FEFFFFEB 		bl	_tx_thread_sleep
 6829              	.LVL557:
 6830              	.LBB270:
 6831              	.LBB272:
2141:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6832              		.loc 1 2141 0
 6833 3ad4 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6834 3ad8 030053E3 		cmp	r3, #3
 6835 3adc 2B00000A 		beq	.L554
2146:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6836              		.loc 1 2146 0
 6837 3ae0 020053E3 		cmp	r3, #2
 6838 3ae4 0D00000A 		beq	.L555
 6839              	.LVL558:
 6840              	.L522:
 6841              	.LBE272:
 6842              	.LBE270:
2394:../uvc.c      ****                     gpif_initialized = CyTrue;
 6843              		.loc 1 2394 0
 6844 3ae8 0110A0E3 		mov	r1, #1
2395:../uvc.c      ****                     CyU3PThreadSleep(200);
 6845              		.loc 1 2395 0
 6846 3aec C800A0E3 		mov	r0, #200
2394:../uvc.c      ****                     gpif_initialized = CyTrue;
 6847              		.loc 1 2394 0
 6848 3af0 381086E5 		str	r1, [r6, #56]
2395:../uvc.c      ****                     CyU3PThreadSleep(200);
 6849              		.loc 1 2395 0
 6850 3af4 FEFFFFEB 		bl	_tx_thread_sleep
 6851 3af8 BEFEFFEA 		b	.L506
 6852              	.LVL559:
 6853              	.L553:
2375:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6854              		.loc 1 2375 0
 6855 3afc 0400A0E3 		mov	r0, #4
 6856              	.LVL560:
 6857 3b00 A0119FE5 		ldr	r1, .L557+184
 6858 3b04 FEFFFFEB 		bl	CyU3PDebugPrint
 6859              	.LVL561:
 6860              	.L518:
 6861              	.LBB278:
 6862              	.LBB279:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6863              		.loc 1 1246 0
 6864 3b08 4C119FE5 		ldr	r1, .L557+108
 6865 3b0c 0400A0E3 		mov	r0, #4
 6866 3b10 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6867              		.loc 1 1247 0
 6868 3b14 FA0FA0E3 		mov	r0, #1000
 6869 3b18 FEFFFFEB 		bl	_tx_thread_sleep
 6870 3b1c F9FFFFEA 		b	.L518
 6871              	.LVL562:
 6872              	.L555:
 6873              	.LBE279:
 6874              	.LBE278:
 6875              	.LBB280:
 6876              	.LBB271:
2148:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6877              		.loc 1 2148 0
 6878 3b20 84119FE5 		ldr	r1, .L557+188
 6879 3b24 0100A0E3 		mov	r0, #1
 6880 3b28 FEFFFFEB 		bl	CyU3PDebugPrint
2149:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6881              		.loc 1 2149 0
 6882 3b2c 7C019FE5 		ldr	r0, .L557+192
 6883 3b30 FEFFFFEB 		bl	CyU3PGpifLoad
 6884 3b34 0020A0E1 		mov	r2, r0
 6885              	.LVL563:
 6886              	.L521:
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6887              		.loc 1 2151 0
 6888 3b38 000052E3 		cmp	r2, #0
 6889 3b3c 2200001A 		bne	.L556
2159:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6890              		.loc 1 2159 0
 6891 3b40 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6892 3b44 030053E3 		cmp	r3, #3
 6893 3b48 0100000A 		beq	.L531
2163:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6894              		.loc 1 2163 0
 6895 3b4c 020053E3 		cmp	r3, #2
 6896 3b50 E4FFFF1A 		bne	.L522
 6897              	.L531:
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6898              		.loc 1 2165 0
 6899 3b54 0200A0E1 		mov	r0, r2
 6900              	.LVL564:
 6901 3b58 0210A0E1 		mov	r1, r2
 6902 3b5c FEFFFFEB 		bl	CyU3PGpifSMStart
 6903              	.LVL565:
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6904              		.loc 1 2167 0
 6905 3b60 000050E3 		cmp	r0, #0
2165:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6906              		.loc 1 2165 0
 6907 3b64 0020A0E1 		mov	r2, r0
 6908              	.LVL566:
2167:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6909              		.loc 1 2167 0
 6910 3b68 DEFFFF0A 		beq	.L522
2170:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6911              		.loc 1 2170 0
 6912 3b6c 0400A0E3 		mov	r0, #4
 6913              	.LVL567:
 6914 3b70 3C119FE5 		ldr	r1, .L557+196
 6915 3b74 FEFFFFEB 		bl	CyU3PDebugPrint
 6916              	.LVL568:
 6917              	.L527:
 6918              	.LBB273:
 6919              	.LBB274:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6920              		.loc 1 1246 0
 6921 3b78 DC109FE5 		ldr	r1, .L557+108
 6922 3b7c 0400A0E3 		mov	r0, #4
 6923 3b80 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6924              		.loc 1 1247 0
 6925 3b84 FA0FA0E3 		mov	r0, #1000
 6926 3b88 FEFFFFEB 		bl	_tx_thread_sleep
 6927 3b8c F9FFFFEA 		b	.L527
 6928              	.LVL569:
 6929              	.L554:
 6930              	.LBE274:
 6931              	.LBE273:
2143:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6932              		.loc 1 2143 0
 6933 3b90 20119FE5 		ldr	r1, .L557+200
 6934 3b94 0100A0E3 		mov	r0, #1
 6935 3b98 FEFFFFEB 		bl	CyU3PDebugPrint
2144:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6936              		.loc 1 2144 0
 6937 3b9c 18019FE5 		ldr	r0, .L557+204
 6938 3ba0 FEFFFFEB 		bl	CyU3PGpifLoad
 6939 3ba4 0020A0E1 		mov	r2, r0
 6940              	.LVL570:
 6941 3ba8 E2FFFFEA 		b	.L521
 6942              	.LVL571:
 6943              	.L519:
 6944              	.LBE271:
 6945              	.LBE280:
2402:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6946              		.loc 1 2402 0
 6947 3bac 94009FE5 		ldr	r0, .L557+88
 6948              	.LVL572:
 6949 3bb0 02E0A0E3 		mov	lr, #2
 6950 3bb4 0410A0E1 		mov	r1, r4
 6951 3bb8 0020A0E1 		mov	r2, r0
 6952              	.LVL573:
 6953 3bbc 0430A0E1 		mov	r3, r4
 6954 3bc0 00E08DE5 		str	lr, [sp, #0]
 6955 3bc4 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6956 3bc8 8AFEFFEA 		b	.L506
 6957              	.LVL574:
 6958              	.L556:
 6959              	.LBB281:
 6960              	.LBB277:
2154:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6961              		.loc 1 2154 0
 6962 3bcc 0400A0E3 		mov	r0, #4
 6963              	.LVL575:
 6964 3bd0 E8109FE5 		ldr	r1, .L557+208
 6965 3bd4 FEFFFFEB 		bl	CyU3PDebugPrint
 6966              	.LVL576:
 6967              	.L524:
 6968              	.LBB275:
 6969              	.LBB276:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6970              		.loc 1 1246 0
 6971 3bd8 7C109FE5 		ldr	r1, .L557+108
 6972 3bdc 0400A0E3 		mov	r0, #4
 6973 3be0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6974              		.loc 1 1247 0
 6975 3be4 FA0FA0E3 		mov	r0, #1000
 6976 3be8 FEFFFFEB 		bl	_tx_thread_sleep
 6977 3bec F9FFFFEA 		b	.L524
 6978              	.L558:
 6979              		.align	2
 6980              	.L557:
 6981 3bf0 48060000 		.word	.LC35
 6982 3bf4 00C20100 		.word	115200
 6983 3bf8 A0860100 		.word	100000
 6984 3bfc 00000000 		.word	.LANCHOR0
 6985 3c00 00000000 		.word	CyFxGpifCB
 6986 3c04 00000000 		.word	CyFxUVCApplnUSBSetupCB
 6987 3c08 00000000 		.word	CyFxUVCApplnUSBEventCB
 6988 3c0c 00000000 		.word	CyFxUSBDeviceDscr
 6989 3c10 00000000 		.word	CyFxUSBDeviceDscrSS
 6990 3c14 00000000 		.word	CyFxUSBDeviceQualDscr
 6991 3c18 00000000 		.word	CyFxUSBBOSDscr
 6992 3c1c 00000000 		.word	CyFxUSBHSConfigDscr
 6993 3c20 00000000 		.word	CyFxUSBFSConfigDscr
 6994 3c24 00000000 		.word	CyFxUSBSSConfigDscr
 6995 3c28 00000000 		.word	CyFxUSBStringLangIDDscr
 6996 3c2c 00000000 		.word	CyFxUSBManufactureDscr
 6997 3c30 00000000 		.word	CyFxUSBProductDscr
 6998 3c34 013F0000 		.word	16129
 6999 3c38 02030000 		.word	770
 7000 3c3c 00000000 		.word	glChHandleInterStat
 7001 3c40 00000000 		.word	glInterStaBuffer
 7002 3c44 03030000 		.word	771
 7003 3c48 01010000 		.word	257
 7004 3c4c 00000000 		.word	CyFxUvcApplnDmaCallback
 7005 3c50 00000000 		.word	glChHandleUVCStream
 7006 3c54 00000000 		.word	.LANCHOR1
 7007 3c58 68060000 		.word	.LC36
 7008 3c5c D4010000 		.word	.LC12
 7009 3c60 84060000 		.word	.LC37
 7010 3c64 A0060000 		.word	.LC38
 7011 3c68 70080000 		.word	.LC48
 7012 3c6c 4C090000 		.word	.LC52
 7013 3c70 D8070000 		.word	.LC45
 7014 3c74 A4070000 		.word	.LC44
 7015 3c78 70070000 		.word	.LC43
 7016 3c7c 44070000 		.word	.LC42
 7017 3c80 18070000 		.word	.LC41
 7018 3c84 F0060000 		.word	.LC40
 7019 3c88 CC060000 		.word	.LC39
 7020 3c8c A0090000 		.word	.LC54
 7021 3c90 74090000 		.word	.LC53
 7022 3c94 A4080000 		.word	.LC49
 7023 3c98 40080000 		.word	.LC47
 7024 3c9c 10080000 		.word	.LC46
 7025 3ca0 1C090000 		.word	.LC51
 7026 3ca4 E4080000 		.word	.LC50
 7027 3ca8 D4090000 		.word	.LC55
 7028 3cac 180A0000 		.word	.LC57
 7029 3cb0 2C000000 		.word	.LANCHOR2+44
 7030 3cb4 600A0000 		.word	.LC59
 7031 3cb8 080A0000 		.word	.LC56
 7032 3cbc 10000000 		.word	.LANCHOR2+16
 7033 3cc0 280A0000 		.word	.LC58
 7034              	.LBE276:
 7035              	.LBE275:
 7036              	.LBE277:
 7037              	.LBE281:
 7038              		.cfi_endproc
 7039              	.LFE18:
 7041              		.align	2
 7042              		.global	CyFxUVCApplnI2CInit
 7044              	CyFxUVCApplnI2CInit:
 7045              	.LFB14:
1693:../uvc.c      **** {
 7046              		.loc 1 1693 0
 7047              		.cfi_startproc
 7048              		@ args = 0, pretend = 0, frame = 16
 7049              		@ frame_needed = 0, uses_anonymous_args = 0
 7050 3cc4 04E02DE5 		str	lr, [sp, #-4]!
 7051              	.LCFI25:
 7052              		.cfi_def_cfa_offset 4
 7053 3cc8 14D04DE2 		sub	sp, sp, #20
 7054              	.LCFI26:
 7055              		.cfi_def_cfa_offset 24
1697:../uvc.c      ****     status = CyU3PI2cInit ();
 7056              		.loc 1 1697 0
 7057              		.cfi_offset 14, -4
 7058 3ccc FEFFFFEB 		bl	CyU3PI2cInit
 7059              	.LVL577:
1698:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7060              		.loc 1 1698 0
 7061 3cd0 002050E2 		subs	r2, r0, #0
 7062 3cd4 0B00001A 		bne	.L564
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7063              		.loc 1 1705 0
 7064 3cd8 70C09FE5 		ldr	ip, .L566
1707:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7065              		.loc 1 1707 0
 7066 3cdc 0030E0E3 		mvn	r3, #0
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7067              		.loc 1 1710 0
 7068 3ce0 0D00A0E1 		mov	r0, sp
 7069              	.LVL578:
 7070 3ce4 0210A0E1 		mov	r1, r2
1705:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7071              		.loc 1 1705 0
 7072 3ce8 00C08DE5 		str	ip, [sp, #0]
1706:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7073              		.loc 1 1706 0
 7074 3cec 0C008DE9 		stmib	sp, {r2, r3}	@ phole stm
1708:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7075              		.loc 1 1708 0
 7076 3cf0 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1710:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7077              		.loc 1 1710 0
 7078 3cf4 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7079              	.LVL579:
1711:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7080              		.loc 1 1711 0
 7081 3cf8 000050E3 		cmp	r0, #0
 7082 3cfc 0A00001A 		bne	.L565
1716:../uvc.c      **** }
 7083              		.loc 1 1716 0
 7084 3d00 14D08DE2 		add	sp, sp, #20
 7085 3d04 04F09DE4 		ldmfd	sp!, {pc}
 7086              	.L564:
1700:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7087              		.loc 1 1700 0
 7088 3d08 0400A0E3 		mov	r0, #4
 7089              	.LVL580:
 7090 3d0c 40109FE5 		ldr	r1, .L566+4
 7091 3d10 FEFFFFEB 		bl	CyU3PDebugPrint
 7092              	.LVL581:
 7093              	.L561:
 7094              	.LBB286:
 7095              	.LBB287:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7096              		.loc 1 1246 0
 7097 3d14 3C109FE5 		ldr	r1, .L566+8
 7098 3d18 0400A0E3 		mov	r0, #4
 7099 3d1c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 7100              		.loc 1 1247 0
 7101 3d20 FA0FA0E3 		mov	r0, #1000
 7102 3d24 FEFFFFEB 		bl	_tx_thread_sleep
 7103 3d28 F9FFFFEA 		b	.L561
 7104              	.LVL582:
 7105              	.L565:
 7106              	.LBE287:
 7107              	.LBE286:
1713:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7108              		.loc 1 1713 0
 7109 3d2c 0400A0E3 		mov	r0, #4
 7110              	.LVL583:
 7111 3d30 24109FE5 		ldr	r1, .L566+12
 7112 3d34 FEFFFFEB 		bl	CyU3PDebugPrint
 7113              	.L563:
 7114              	.LBB288:
 7115              	.LBB289:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7116              		.loc 1 1246 0
 7117 3d38 18109FE5 		ldr	r1, .L566+8
 7118 3d3c 0400A0E3 		mov	r0, #4
 7119 3d40 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 7120              		.loc 1 1247 0
 7121 3d44 FA0FA0E3 		mov	r0, #1000
 7122 3d48 FEFFFFEB 		bl	_tx_thread_sleep
 7123 3d4c F9FFFFEA 		b	.L563
 7124              	.L567:
 7125              		.align	2
 7126              	.L566:
 7127 3d50 A0860100 		.word	100000
 7128 3d54 68060000 		.word	.LC36
 7129 3d58 D4010000 		.word	.LC12
 7130 3d5c 84060000 		.word	.LC37
 7131              	.LBE289:
 7132              	.LBE288:
 7133              		.cfi_endproc
 7134              	.LFE14:
 7136              		.align	2
 7137              		.global	CyFxApplicationDefine
 7139              	CyFxApplicationDefine:
 7140              	.LFB26:
3633:../uvc.c      **** }
3634:../uvc.c      **** 
3635:../uvc.c      **** 
3636:../uvc.c      **** /*
3637:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3638:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3639:../uvc.c      ****  */
3640:../uvc.c      **** void
3641:../uvc.c      **** CyFxApplicationDefine (
3642:../uvc.c      ****         void)
3643:../uvc.c      **** {
 7141              		.loc 1 3643 0
 7142              		.cfi_startproc
 7143              		@ args = 0, pretend = 0, frame = 40
 7144              		@ frame_needed = 0, uses_anonymous_args = 0
 7145              	.LVL584:
 7146 3d60 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7147              	.LCFI27:
 7148              		.cfi_def_cfa_offset 36
3644:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3645:../uvc.c      ****     uint32_t retThrdCreate;
3646:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3647:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3648:../uvc.c      **** 
3649:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3650:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7149              		.loc 1 3650 0
 7150 3d64 010AA0E3 		mov	r0, #4096
3643:../uvc.c      **** {
 7151              		.loc 1 3643 0
 7152 3d68 4CD04DE2 		sub	sp, sp, #76
 7153              	.LCFI28:
 7154              		.cfi_def_cfa_offset 112
 7155              		.loc 1 3650 0
 7156              		.cfi_offset 14, -4
 7157              		.cfi_offset 11, -8
 7158              		.cfi_offset 10, -12
 7159              		.cfi_offset 9, -16
 7160              		.cfi_offset 8, -20
 7161              		.cfi_offset 7, -24
 7162              		.cfi_offset 6, -28
 7163              		.cfi_offset 5, -32
 7164              		.cfi_offset 4, -36
 7165 3d6c FEFFFFEB 		bl	CyU3PMemAlloc
 7166 3d70 00A0A0E1 		mov	sl, r0
 7167              	.LVL585:
3651:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7168              		.loc 1 3651 0
 7169 3d74 010AA0E3 		mov	r0, #4096
 7170              	.LVL586:
 7171 3d78 FEFFFFEB 		bl	CyU3PMemAlloc
 7172 3d7c 00B0A0E1 		mov	fp, r0
 7173              	.LVL587:
3652:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7174              		.loc 1 3652 0
 7175 3d80 010AA0E3 		mov	r0, #4096
 7176              	.LVL588:
 7177 3d84 FEFFFFEB 		bl	CyU3PMemAlloc
3653:../uvc.c      **** 
3654:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7178              		.loc 1 3654 0
 7179 3d88 00005AE3 		cmp	sl, #0
 7180 3d8c 00005B13 		cmpne	fp, #0
 7181 3d90 0090A013 		movne	r9, #0
 7182 3d94 0190A003 		moveq	r9, #1
3652:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7183              		.loc 1 3652 0
 7184 3d98 24008DE5 		str	r0, [sp, #36]
 7185              	.LVL589:
 7186              		.loc 1 3654 0
 7187 3d9c 0000001A 		bne	.L572
 7188              	.LVL590:
 7189              	.L569:
 7190              	.L571:
 7191 3da0 FEFFFFEA 		b	.L571
 7192              	.L572:
 7193              		.loc 1 3654 0 is_stmt 0 discriminator 1
 7194 3da4 000050E3 		cmp	r0, #0
 7195 3da8 FCFFFF0A 		beq	.L569
3655:../uvc.c      ****         goto fatalErrorHandler;
3656:../uvc.c      **** 
3657:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3658:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7196              		.loc 1 3658 0 is_stmt 1
 7197 3dac 28408DE2 		add	r4, sp, #40
 7198 3db0 0400A0E1 		mov	r0, r4
 7199 3db4 4010A0E3 		mov	r1, #64
 7200 3db8 18219FE5 		ldr	r2, .L573
 7201 3dbc FEFFFFEB 		bl	cmdbufCreate
 7202 3dc0 0450A0E1 		mov	r5, r4
 7203 3dc4 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7204 3dc8 0C719FE5 		ldr	r7, .L573+4
3659:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7205              		.loc 1 3659 0
 7206 3dcc 0C819FE5 		ldr	r8, .L573+8
3658:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7207              		.loc 1 3658 0
 7208 3dd0 07C0A0E1 		mov	ip, r7
 7209 3dd4 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7210 3dd8 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3660:../uvc.c      **** 
3661:../uvc.c      **** 	/****** initialize command descriptor ***********/
3662:../uvc.c      **** 	cmdquInit(cmdQuptr);
3663:../uvc.c      **** 	cmdquInit(statQuptr);
3664:../uvc.c      **** 
3665:../uvc.c      ****     /* Create the UVC application thread. */
3666:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7211              		.loc 1 3666 0
 7212 3ddc 0860A0E3 		mov	r6, #8
3658:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7213              		.loc 1 3658 0
 7214 3de0 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3659:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7215              		.loc 1 3659 0
 7216 3de4 F8209FE5 		ldr	r2, .L573+12
 7217 3de8 0400A0E1 		mov	r0, r4
 7218 3dec 2010A0E3 		mov	r1, #32
 7219 3df0 FEFFFFEB 		bl	cmdbufCreate
 7220 3df4 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7221 3df8 08C0A0E1 		mov	ip, r8
 7222 3dfc 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7223 3e00 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7224              		.loc 1 3666 0
 7225 3e04 0140A0E3 		mov	r4, #1
3659:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7226              		.loc 1 3659 0
 7227 3e08 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3662:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7228              		.loc 1 3662 0
 7229 3e0c 0700A0E1 		mov	r0, r7
 7230 3e10 FEFFFFEB 		bl	cmdquInit
3663:../uvc.c      **** 	cmdquInit(statQuptr);
 7231              		.loc 1 3663 0
 7232 3e14 0800A0E1 		mov	r0, r8
 7233 3e18 FEFFFFEB 		bl	cmdquInit
 7234              		.loc 1 3666 0
 7235 3e1c A850A0E3 		mov	r5, #168
 7236 3e20 01CAA0E3 		mov	ip, #4096
 7237 3e24 BC009FE5 		ldr	r0, .L573+16
 7238 3e28 BC109FE5 		ldr	r1, .L573+20
 7239 3e2c BC209FE5 		ldr	r2, .L573+24
 7240 3e30 0930A0E1 		mov	r3, r9
 7241 3e34 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7242 3e38 08608DE5 		str	r6, [sp, #8]
 7243 3e3c 0C608DE5 		str	r6, [sp, #12]
 7244 3e40 10908DE5 		str	r9, [sp, #16]
 7245 3e44 14408DE5 		str	r4, [sp, #20]
 7246 3e48 18508DE5 		str	r5, [sp, #24]
 7247 3e4c FEFFFFEB 		bl	_txe_thread_create
 7248              	.LVL591:
3667:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3668:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3669:../uvc.c      ****             0,                                          /* No input parameter to thread */
3670:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3671:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3672:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3673:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3674:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3675:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3676:../uvc.c      ****             );
3677:../uvc.c      ****     if (retThrdCreate != 0)
 7249              		.loc 1 3677 0
 7250 3e50 00C050E2 		subs	ip, r0, #0
 7251 3e54 D1FFFF1A 		bne	.L569
3678:../uvc.c      ****     {
3679:../uvc.c      ****         goto fatalErrorHandler;
3680:../uvc.c      ****     }
3681:../uvc.c      **** 
3682:../uvc.c      ****     /* Create the control request handling thread. */
3683:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7252              		.loc 1 3683 0
 7253 3e58 0C30A0E1 		mov	r3, ip
 7254 3e5c 027BA0E3 		mov	r7, #2048
 7255 3e60 8C009FE5 		ldr	r0, .L573+28
 7256              	.LVL592:
 7257 3e64 8C109FE5 		ldr	r1, .L573+32
 7258 3e68 8C209FE5 		ldr	r2, .L573+36
 7259 3e6c 10C08DE5 		str	ip, [sp, #16]
 7260 3e70 00B08DE5 		str	fp, [sp, #0]
 7261 3e74 04708DE5 		str	r7, [sp, #4]
 7262 3e78 08608DE5 		str	r6, [sp, #8]
 7263 3e7c 0C608DE5 		str	r6, [sp, #12]
 7264 3e80 14408DE5 		str	r4, [sp, #20]
 7265 3e84 18508DE5 		str	r5, [sp, #24]
 7266 3e88 FEFFFFEB 		bl	_txe_thread_create
 7267              	.LVL593:
3684:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3685:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3686:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3687:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3688:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3689:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3690:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3691:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3692:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3693:../uvc.c      ****             );
3694:../uvc.c      ****     if (retThrdCreate != 0)
 7268              		.loc 1 3694 0
 7269 3e8c 00C050E2 		subs	ip, r0, #0
 7270 3e90 C2FFFF1A 		bne	.L569
3695:../uvc.c      ****     {
3696:../uvc.c      ****         goto fatalErrorHandler;
3697:../uvc.c      ****     }
3698:../uvc.c      **** #if 1
3699:../uvc.c      ****     /* Create the I2C control command handling thread. */
3700:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7271              		.loc 1 3700 0
 7272 3e94 24E09DE5 		ldr	lr, [sp, #36]
 7273 3e98 60009FE5 		ldr	r0, .L573+40
 7274              	.LVL594:
 7275 3e9c 60109FE5 		ldr	r1, .L573+44
 7276 3ea0 60209FE5 		ldr	r2, .L573+48
 7277 3ea4 0C30A0E1 		mov	r3, ip
 7278 3ea8 00E08DE5 		str	lr, [sp, #0]
 7279 3eac 04708DE5 		str	r7, [sp, #4]
 7280 3eb0 08608DE5 		str	r6, [sp, #8]
 7281 3eb4 0C608DE5 		str	r6, [sp, #12]
 7282 3eb8 10C08DE5 		str	ip, [sp, #16]
 7283 3ebc 14408DE5 		str	r4, [sp, #20]
 7284 3ec0 18508DE5 		str	r5, [sp, #24]
 7285 3ec4 FEFFFFEB 		bl	_txe_thread_create
 7286              	.LVL595:
3701:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3702:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3703:../uvc.c      ****             0,                                          /* No input parameter to thread */
3704:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3705:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3706:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3707:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3708:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3709:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3710:../uvc.c      ****             );
3711:../uvc.c      ****     if (retThrdCreate != 0)
 7287              		.loc 1 3711 0
 7288 3ec8 000050E3 		cmp	r0, #0
 7289 3ecc B3FFFF1A 		bne	.L569
3712:../uvc.c      ****     {
3713:../uvc.c      ****         goto fatalErrorHandler;
3714:../uvc.c      ****     }
3715:../uvc.c      **** #endif
3716:../uvc.c      **** 
3717:../uvc.c      ****     return;
3718:../uvc.c      **** 
3719:../uvc.c      **** fatalErrorHandler:
3720:../uvc.c      ****     /* Add custom recovery or debug actions here */
3721:../uvc.c      ****     /* Loop indefinitely */
3722:../uvc.c      ****     while (1);
3723:../uvc.c      **** }
 7290              		.loc 1 3723 0
 7291 3ed0 4CD08DE2 		add	sp, sp, #76
 7292 3ed4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7293              	.L574:
 7294              		.align	2
 7295              	.L573:
 7296 3ed8 00000000 		.word	cmdQuMux
 7297 3edc 00000000 		.word	cmdQu
 7298 3ee0 00000000 		.word	statQu
 7299 3ee4 00000000 		.word	staQuMux
 7300 3ee8 A0000000 		.word	.LANCHOR0+160
 7301 3eec 980A0000 		.word	.LC60
 7302 3ef0 00000000 		.word	UVCAppThread_Entry
 7303 3ef4 48010000 		.word	.LANCHOR0+328
 7304 3ef8 AC0A0000 		.word	.LC61
 7305 3efc 00000000 		.word	UVCAppEP0Thread_Entry
 7306 3f00 F0010000 		.word	.LANCHOR0+496
 7307 3f04 C40A0000 		.word	.LC62
 7308 3f08 00000000 		.word	I2cAppThread_Entry
 7309              		.cfi_endproc
 7310              	.LFE26:
 7312              		.align	2
 7313              		.global	main
 7315              	main:
 7316              	.LFB27:
3724:../uvc.c      **** 
3725:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3726:../uvc.c      ****  * the ThreadX RTOS here.
3727:../uvc.c      ****  */
3728:../uvc.c      **** int
3729:../uvc.c      **** main (
3730:../uvc.c      ****         void)
3731:../uvc.c      **** {
 7317              		.loc 1 3731 0
 7318              		.cfi_startproc
 7319              		@ args = 0, pretend = 0, frame = 56
 7320              		@ frame_needed = 0, uses_anonymous_args = 0
 7321 3f0c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7322              	.LCFI29:
 7323              		.cfi_def_cfa_offset 12
3732:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3733:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3734:../uvc.c      **** 
3735:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3736:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3737:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3738:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3739:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3740:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7324              		.loc 1 3740 0
 7325 3f10 0010A0E3 		mov	r1, #0
3731:../uvc.c      **** {
 7326              		.loc 1 3731 0
 7327 3f14 3CD04DE2 		sub	sp, sp, #60
 7328              	.LCFI30:
 7329              		.cfi_def_cfa_offset 72
3737:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7330              		.loc 1 3737 0
 7331 3f18 0220A0E3 		mov	r2, #2
3741:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7332              		.loc 1 3741 0
 7333 3f1c 033081E2 		add	r3, r1, #3
3736:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7334              		.loc 1 3736 0
 7335 3f20 0150A0E3 		mov	r5, #1
 7336              		.cfi_offset 14, -4
 7337              		.cfi_offset 5, -8
 7338              		.cfi_offset 4, -12
3742:../uvc.c      **** 
3743:../uvc.c      ****     /* Initialize the device */
3744:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7339              		.loc 1 3744 0
 7340 3f24 28008DE2 		add	r0, sp, #40
3736:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7341              		.loc 1 3736 0
 7342 3f28 28508DE5 		str	r5, [sp, #40]
3737:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7343              		.loc 1 3737 0
 7344 3f2c 2C20CDE5 		strb	r2, [sp, #44]
3738:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7345              		.loc 1 3738 0
 7346 3f30 2D20CDE5 		strb	r2, [sp, #45]
3739:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7347              		.loc 1 3739 0
 7348 3f34 2E20CDE5 		strb	r2, [sp, #46]
3740:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7349              		.loc 1 3740 0
 7350 3f38 30108DE5 		str	r1, [sp, #48]
3741:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7351              		.loc 1 3741 0
 7352 3f3c 3430CDE5 		strb	r3, [sp, #52]
 7353              		.loc 1 3744 0
 7354 3f40 FEFFFFEB 		bl	CyU3PDeviceInit
 7355              	.LVL596:
3745:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7356              		.loc 1 3745 0
 7357 3f44 004050E2 		subs	r4, r0, #0
 7358 3f48 0000000A 		beq	.L578
 7359              	.L576:
 7360              	.L577:
 7361 3f4c FEFFFFEA 		b	.L577
 7362              	.L578:
3746:../uvc.c      ****     {
3747:../uvc.c      ****         goto handle_fatal_error;
3748:../uvc.c      ****     }
3749:../uvc.c      **** 
3750:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3751:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7363              		.loc 1 3751 0
 7364 3f50 0410A0E1 		mov	r1, r4
 7365 3f54 0420A0E1 		mov	r2, r4
 7366 3f58 0500A0E1 		mov	r0, r5
 7367              	.LVL597:
 7368 3f5c FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7369              	.LVL598:
3752:../uvc.c      **** 
3753:../uvc.c      ****     /* Configure the IO matrix for the device. */
3754:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3755:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3756:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3757:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3758:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3759:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3760:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3761:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3762:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3763:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3764:../uvc.c      **** 
3765:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7370              		.loc 1 3765 0
 7371 3f60 0D00A0E1 		mov	r0, sp
3755:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7372              		.loc 1 3755 0
 7373 3f64 1640CDE5 		strb	r4, [sp, #22]
3756:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7374              		.loc 1 3756 0
 7375 3f68 18408DE5 		str	r4, [sp, #24]
3757:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7376              		.loc 1 3757 0
 7377 3f6c 1C408DE5 		str	r4, [sp, #28]
3758:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7378              		.loc 1 3758 0
 7379 3f70 20408DE5 		str	r4, [sp, #32]
3759:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7380              		.loc 1 3759 0
 7381 3f74 24408DE5 		str	r4, [sp, #36]
3762:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7382              		.loc 1 3762 0
 7383 3f78 0C408DE5 		str	r4, [sp, #12]
3763:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7384              		.loc 1 3763 0
 7385 3f7c 10408DE5 		str	r4, [sp, #16]
3754:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7386              		.loc 1 3754 0
 7387 3f80 00508DE5 		str	r5, [sp, #0]
3760:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7388              		.loc 1 3760 0
 7389 3f84 04508DE5 		str	r5, [sp, #4]
3761:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7390              		.loc 1 3761 0
 7391 3f88 08508DE5 		str	r5, [sp, #8]
 7392              		.loc 1 3765 0
 7393 3f8c FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7394              	.LVL599:
3766:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7395              		.loc 1 3766 0
 7396 3f90 004050E2 		subs	r4, r0, #0
 7397 3f94 ECFFFF1A 		bne	.L576
3767:../uvc.c      ****     {
3768:../uvc.c      ****         goto handle_fatal_error;
3769:../uvc.c      ****     }
3770:../uvc.c      **** 
3771:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3772:../uvc.c      ****     CyU3PKernelEntry ();
 7398              		.loc 1 3772 0
 7399 3f98 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7400              	.LVL600:
3773:../uvc.c      **** 
3774:../uvc.c      ****     /* Dummy return to make the compiler happy */
3775:../uvc.c      ****     return 0;
3776:../uvc.c      **** 
3777:../uvc.c      **** handle_fatal_error:
3778:../uvc.c      ****     /* Cannot recover from this error. */
3779:../uvc.c      ****     while (1);
3780:../uvc.c      **** }
 7401              		.loc 1 3780 0
 7402 3f9c 0400A0E1 		mov	r0, r4
 7403 3fa0 3CD08DE2 		add	sp, sp, #60
 7404 3fa4 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7405              		.cfi_endproc
 7406              	.LFE27:
 7408              		.global	CyFxGpifTransition
 7409              		.global	CyFxGpifWavedata
 7410              		.global	CyFxGpifWavedataPosition
 7411              		.global	CyFxGpifRegValue
 7412              		.global	CyFxGpifConfig
 7413              		.global	CyFxGpifTransition_usb2
 7414              		.global	CyFxGpifWavedata_usb2
 7415              		.global	CyFxGpifWavedataPosition_usb2
 7416              		.global	CyFxGpifRegValue_usb2
 7417              		.global	CyFxGpifConfig_usb2
 7418              		.global	snapButFlag
 7419              		.global	testSnap
 7420              		.global	fb
 7421              		.global	pb
 7422              		.global	pbc
 7423              		.global	fbbak
 7424              		.global	pbbak
 7425              		.global	pbcbak
 7426              		.global	pbcpbak
 7427              		.global	isUsbConnected
 7428              		.global	usbSpeed
 7429              		.global	clearFeatureRqtReceived
 7430              		.global	streamingStarted
 7431              		.global	glProbeCtrl
 7432              		.global	glProbeStilCtrl
 7433              		.global	glProbeCtrl20
 7434              		.global	glProbeStilCtrl20
 7435              		.global	glUVCHeader
 7436              		.comm	glChHandleUVCStream,220,4
 7437              		.comm	glChHandleStillStream,220,4
 7438              		.comm	glChHandleInterStat,160,4
 7439              		.comm	glInterStaBuffer,4,4
 7440              		.comm	cmdQu,32,4
 7441              		.comm	statQu,32,4
 7442              		.comm	cmdQuMux,56,4
 7443              		.comm	staQuMux,56,4
 7444              		.comm	timMux,56,4
 7445              		.comm	bmReqType,1,1
 7446              		.comm	bRequest,1,1
 7447              		.comm	wValue,2,2
 7448              		.comm	wIndex,2,2
 7449              		.comm	wLength,2,2
 7450              		.comm	posTick,4,4
 7451              		.comm	I2CCmdTimer,44,4
 7452              		.section	.rodata
 7453              		.align	2
 7454              		.set	.LANCHOR2,. + 0
 7457              	ExTime:
 7458 0000 9C       		.byte	-100
 7459 0001 00       		.byte	0
 7460 0002 4E       		.byte	78
 7461 0003 00       		.byte	0
 7462 0004 27       		.byte	39
 7463 0005 00       		.byte	0
 7464 0006 14       		.byte	20
 7465 0007 00       		.byte	0
 7466 0008 0A       		.byte	10
 7467 0009 00       		.byte	0
 7468 000a 05       		.byte	5
 7469 000b 00       		.byte	0
 7470 000c 02       		.byte	2
 7471 000d 00       		.byte	0
 7472 000e 01       		.byte	1
 7473 000f 00       		.byte	0
 7476              	CyFxGpifConfig:
 7477 0010 0F00     		.short	15
 7478 0012 0000     		.space	2
 7479 0014 00000000 		.word	CyFxGpifWavedata
 7480 0018 00000000 		.word	CyFxGpifWavedataPosition
 7481 001c 0500     		.short	5
 7482 001e 0000     		.space	2
 7483 0020 00000000 		.word	CyFxGpifTransition
 7484 0024 4C00     		.short	76
 7485 0026 0000     		.space	2
 7486 0028 00000000 		.word	CyFxGpifRegValue
 7489              	CyFxGpifConfig_usb2:
 7490 002c 9300     		.short	147
 7491 002e 0000     		.space	2
 7492 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7493 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7494 0038 0800     		.short	8
 7495 003a 0000     		.space	2
 7496 003c 00000000 		.word	CyFxGpifTransition_usb2
 7497 0040 4C00     		.short	76
 7498 0042 0000     		.space	2
 7499 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7500              		.data
 7501              		.align	2
 7502              		.set	.LANCHOR1,. + 0
 7505              	ExUCtrlParArry:
 7506 0000 00       		.byte	0
 7507 0001 00       		.byte	0
 7508 0002 04       		.byte	4
 7509 0003 01       		.byte	1
 7510 0004 00       		.byte	0
 7511 0005 38       		.byte	56
 7512 0006 01       		.byte	1
 7513 0007 01       		.byte	1
 7514 0008 00       		.byte	0
 7515 0009 03       		.byte	3
 7516 000a 00       		.byte	0
 7517 000b 4E       		.byte	78
 7518 000c 00       		.byte	0
 7519 000d 4E       		.byte	78
 7520 000e 00       		.byte	0
 7521 000f 30       		.byte	48
 7522 0010 01       		.byte	1
 7523 0011 00       		.byte	0
 7524 0012 00       		.byte	0
 7525 0013 00000000 		.space	5
 7525      00
 7526 0018 00       		.byte	0
 7527 0019 00       		.byte	0
 7528 001a 01       		.byte	1
 7529 001b 00       		.byte	0
 7530 001c 00       		.byte	0
 7531 001d 00       		.byte	0
 7532 001e 00       		.byte	0
 7533 001f 01       		.byte	1
 7534 0020 00       		.byte	0
 7535 0021 03       		.byte	3
 7536 0022 00       		.byte	0
 7537 0023 00       		.byte	0
 7538 0024 00       		.byte	0
 7539 0025 00       		.byte	0
 7540 0026 00       		.byte	0
 7541 0027 30       		.byte	48
 7542 0028 01       		.byte	1
 7543 0029 00       		.byte	0
 7544 002a 00       		.byte	0
 7545 002b 00000000 		.space	5
 7545      00
 7546 0030 00       		.byte	0
 7547 0031 00       		.byte	0
 7548 0032 02       		.byte	2
 7549 0033 00       		.byte	0
 7550 0034 00       		.byte	0
 7551 0035 FF       		.byte	-1
 7552 0036 00       		.byte	0
 7553 0037 01       		.byte	1
 7554 0038 00       		.byte	0
 7555 0039 03       		.byte	3
 7556 003a 00       		.byte	0
 7557 003b 01       		.byte	1
 7558 003c 00       		.byte	0
 7559 003d 00       		.byte	0
 7560 003e 00       		.byte	0
 7561 003f 30       		.byte	48
 7562 0040 01       		.byte	1
 7563 0041 01       		.byte	1
 7564 0042 00       		.byte	0
 7565 0043 00000000 		.space	5
 7565      00
 7566 0048 00       		.byte	0
 7567 0049 00       		.byte	0
 7568 004a 02       		.byte	2
 7569 004b 00       		.byte	0
 7570 004c 00       		.byte	0
 7571 004d 00       		.byte	0
 7572 004e 00       		.byte	0
 7573 004f 00       		.byte	0
 7574 0050 00       		.byte	0
 7575 0051 03       		.byte	3
 7576 0052 00       		.byte	0
 7577 0053 00       		.byte	0
 7578 0054 00       		.byte	0
 7579 0055 00       		.byte	0
 7580 0056 00       		.byte	0
 7581 0057 30       		.byte	48
 7582 0058 01       		.byte	1
 7583 0059 01       		.byte	1
 7584 005a 00       		.byte	0
 7585 005b 00000000 		.space	5
 7585      00
 7586 0060 13       		.byte	19
 7587 0061 14       		.byte	20
 7588 0062 02       		.byte	2
 7589 0063 01       		.byte	1
 7590 0064 00       		.byte	0
 7591 0065 03       		.byte	3
 7592 0066 00       		.byte	0
 7593 0067 01       		.byte	1
 7594 0068 00       		.byte	0
 7595 0069 03       		.byte	3
 7596 006a 00       		.byte	0
 7597 006b 23       		.byte	35
 7598 006c 37       		.byte	55
 7599 006d 23       		.byte	35
 7600 006e 37       		.byte	55
 7601 006f 30       		.byte	48
 7602 0070 01       		.byte	1
 7603 0071 00       		.byte	0
 7604 0072 00       		.byte	0
 7605 0073 00000000 		.space	5
 7605      00
 7606 0078 11       		.byte	17
 7607 0079 00       		.byte	0
 7608 007a 02       		.byte	2
 7609 007b 01       		.byte	1
 7610 007c 00       		.byte	0
 7611 007d 03       		.byte	3
 7612 007e 00       		.byte	0
 7613 007f 01       		.byte	1
 7614 0080 00       		.byte	0
 7615 0081 03       		.byte	3
 7616 0082 00       		.byte	0
 7617 0083 01       		.byte	1
 7618 0084 00       		.byte	0
 7619 0085 01       		.byte	1
 7620 0086 00       		.byte	0
 7621 0087 30       		.byte	48
 7622 0088 01       		.byte	1
 7623 0089 01       		.byte	1
 7624 008a 00       		.byte	0
 7625 008b 00000000 		.space	5
 7625      00
 7626 0090 17       		.byte	23
 7627 0091 00       		.byte	0
 7628 0092 01       		.byte	1
 7629 0093 01       		.byte	1
 7630 0094 00       		.byte	0
 7631 0095 02       		.byte	2
 7632 0096 00       		.byte	0
 7633 0097 01       		.byte	1
 7634 0098 00       		.byte	0
 7635 0099 03       		.byte	3
 7636 009a 00       		.byte	0
 7637 009b 00       		.byte	0
 7638 009c 00       		.byte	0
 7639 009d 00       		.byte	0
 7640 009e 00       		.byte	0
 7641 009f 30       		.byte	48
 7642 00a0 01       		.byte	1
 7643 00a1 01       		.byte	1
 7644 00a2 00       		.byte	0
 7645 00a3 00000000 		.space	5
 7645      00
 7646 00a8 00       		.byte	0
 7647 00a9 00       		.byte	0
 7648 00aa 04       		.byte	4
 7649 00ab 01       		.byte	1
 7650 00ac 00       		.byte	0
 7651 00ad 38       		.byte	56
 7652 00ae 01       		.byte	1
 7653 00af 01       		.byte	1
 7654 00b0 00       		.byte	0
 7655 00b1 03       		.byte	3
 7656 00b2 00       		.byte	0
 7657 00b3 4E       		.byte	78
 7658 00b4 00       		.byte	0
 7659 00b5 4E       		.byte	78
 7660 00b6 00       		.byte	0
 7661 00b7 30       		.byte	48
 7662 00b8 01       		.byte	1
 7663 00b9 00       		.byte	0
 7664 00ba 00       		.byte	0
 7665 00bb 00000000 		.space	5
 7665      00
 7666 00c0 00       		.byte	0
 7667 00c1 00       		.byte	0
 7668 00c2 01       		.byte	1
 7669 00c3 00       		.byte	0
 7670 00c4 00       		.byte	0
 7671 00c5 00       		.byte	0
 7672 00c6 00       		.byte	0
 7673 00c7 01       		.byte	1
 7674 00c8 00       		.byte	0
 7675 00c9 03       		.byte	3
 7676 00ca 00       		.byte	0
 7677 00cb 00       		.byte	0
 7678 00cc 00       		.byte	0
 7679 00cd 00       		.byte	0
 7680 00ce 00       		.byte	0
 7681 00cf 30       		.byte	48
 7682 00d0 01       		.byte	1
 7683 00d1 00       		.byte	0
 7684 00d2 00       		.byte	0
 7685 00d3 00000000 		.space	5
 7685      00
 7686 00d8 00       		.byte	0
 7687 00d9 00       		.byte	0
 7688 00da 02       		.byte	2
 7689 00db 00       		.byte	0
 7690 00dc 00       		.byte	0
 7691 00dd 05       		.byte	5
 7692 00de 00       		.byte	0
 7693 00df 01       		.byte	1
 7694 00e0 00       		.byte	0
 7695 00e1 03       		.byte	3
 7696 00e2 00       		.byte	0
 7697 00e3 00       		.byte	0
 7698 00e4 00       		.byte	0
 7699 00e5 00       		.byte	0
 7700 00e6 00       		.byte	0
 7701 00e7 30       		.byte	48
 7702 00e8 01       		.byte	1
 7703 00e9 00       		.byte	0
 7704 00ea 00       		.byte	0
 7705 00eb 00000000 		.space	5
 7705      00
 7706 00f0 00       		.byte	0
 7707 00f1 00       		.byte	0
 7708 00f2 03       		.byte	3
 7709 00f3 00       		.byte	0
 7710 00f4 00       		.byte	0
 7711 00f5 0A       		.byte	10
 7712 00f6 00       		.byte	0
 7713 00f7 01       		.byte	1
 7714 00f8 00       		.byte	0
 7715 00f9 03       		.byte	3
 7716 00fa 00       		.byte	0
 7717 00fb 00       		.byte	0
 7718 00fc 00       		.byte	0
 7719 00fd 00       		.byte	0
 7720 00fe 00       		.byte	0
 7721 00ff 30       		.byte	48
 7722 0100 01       		.byte	1
 7723 0101 00       		.byte	0
 7724 0102 00       		.byte	0
 7725 0103 00000000 		.space	5
 7725      00
 7726 0108 00       		.byte	0
 7727 0109 00       		.byte	0
 7728 010a 02       		.byte	2
 7729 010b 00       		.byte	0
 7730 010c 00       		.byte	0
 7731 010d 40       		.byte	64
 7732 010e 00       		.byte	0
 7733 010f 01       		.byte	1
 7734 0110 00       		.byte	0
 7735 0111 03       		.byte	3
 7736 0112 00       		.byte	0
 7737 0113 0F       		.byte	15
 7738 0114 11       		.byte	17
 7739 0115 00       		.byte	0
 7740 0116 00       		.byte	0
 7741 0117 30       		.byte	48
 7742 0118 01       		.byte	1
 7743 0119 00       		.byte	0
 7744 011a 00       		.byte	0
 7745 011b 00000000 		.space	5
 7745      00
 7746 0120 00       		.byte	0
 7747 0121 00       		.byte	0
 7748 0122 02       		.byte	2
 7749 0123 00       		.byte	0
 7750 0124 00       		.byte	0
 7751 0125 64       		.byte	100
 7752 0126 00       		.byte	0
 7753 0127 01       		.byte	1
 7754 0128 00       		.byte	0
 7755 0129 03       		.byte	3
 7756 012a 00       		.byte	0
 7757 012b 00       		.byte	0
 7758 012c 00       		.byte	0
 7759 012d 00       		.byte	0
 7760 012e 00       		.byte	0
 7761 012f 30       		.byte	48
 7762 0130 01       		.byte	1
 7763 0131 00       		.byte	0
 7764 0132 00       		.byte	0
 7765 0133 00000000 		.space	5
 7765      00
 7766 0138 00       		.byte	0
 7767 0139 00       		.byte	0
 7768 013a 02       		.byte	2
 7769 013b 00       		.byte	0
 7770 013c 00       		.byte	0
 7771 013d 64       		.byte	100
 7772 013e 00       		.byte	0
 7773 013f 01       		.byte	1
 7774 0140 00       		.byte	0
 7775 0141 03       		.byte	3
 7776 0142 00       		.byte	0
 7777 0143 00       		.byte	0
 7778 0144 00       		.byte	0
 7779 0145 00       		.byte	0
 7780 0146 00       		.byte	0
 7781 0147 30       		.byte	48
 7782 0148 01       		.byte	1
 7783 0149 00       		.byte	0
 7784 014a 00       		.byte	0
 7785 014b 00000000 		.space	5
 7785      00
 7786 0150 00       		.byte	0
 7787 0151 00       		.byte	0
 7788 0152 02       		.byte	2
 7789 0153 00       		.byte	0
 7790 0154 00       		.byte	0
 7791 0155 64       		.byte	100
 7792 0156 00       		.byte	0
 7793 0157 01       		.byte	1
 7794 0158 00       		.byte	0
 7795 0159 03       		.byte	3
 7796 015a 00       		.byte	0
 7797 015b 00       		.byte	0
 7798 015c 00       		.byte	0
 7799 015d 00       		.byte	0
 7800 015e 00       		.byte	0
 7801 015f 30       		.byte	48
 7802 0160 01       		.byte	1
 7803 0161 00       		.byte	0
 7804 0162 00       		.byte	0
 7805 0163 00000000 		.space	5
 7805      00
 7806 0168 00       		.byte	0
 7807 0169 00       		.byte	0
 7808 016a 02       		.byte	2
 7809 016b 00       		.byte	0
 7810 016c 00       		.byte	0
 7811 016d 64       		.byte	100
 7812 016e 00       		.byte	0
 7813 016f 01       		.byte	1
 7814 0170 00       		.byte	0
 7815 0171 03       		.byte	3
 7816 0172 00       		.byte	0
 7817 0173 00       		.byte	0
 7818 0174 00       		.byte	0
 7819 0175 00       		.byte	0
 7820 0176 00       		.byte	0
 7821 0177 30       		.byte	48
 7822 0178 01       		.byte	1
 7823 0179 00       		.byte	0
 7824 017a 00       		.byte	0
 7825 017b 00000000 		.space	5
 7825      00
 7828              	CtrlParArry:
 7829 0180 10       		.byte	16
 7830 0181 10       		.byte	16
 7831 0182 02       		.byte	2
 7832 0183 00       		.byte	0
 7833 0184 00       		.byte	0
 7834 0185 03       		.byte	3
 7835 0186 00       		.byte	0
 7836 0187 01       		.byte	1
 7837 0188 00       		.byte	0
 7838 0189 03       		.byte	3
 7839 018a 00       		.byte	0
 7840 018b 00       		.byte	0
 7841 018c 00       		.byte	0
 7842 018d 00       		.byte	0
 7843 018e 00       		.byte	0
 7844 018f 30       		.byte	48
 7845 0190 01       		.byte	1
 7846 0191 00       		.byte	0
 7847 0192 00       		.byte	0
 7848 0193 00000000 		.space	5
 7848      00
 7849 0198 01       		.byte	1
 7850 0199 00       		.byte	0
 7851 019a 02       		.byte	2
 7852 019b 00       		.byte	0
 7853 019c 00       		.byte	0
 7854 019d FF       		.byte	-1
 7855 019e 00       		.byte	0
 7856 019f 01       		.byte	1
 7857 01a0 00       		.byte	0
 7858 01a1 03       		.byte	3
 7859 01a2 00       		.byte	0
 7860 01a3 76       		.byte	118
 7861 01a4 00       		.byte	0
 7862 01a5 76       		.byte	118
 7863 01a6 C7       		.byte	-57
 7864 01a7 C6       		.byte	-58
 7865 01a8 01       		.byte	1
 7866 01a9 01       		.byte	1
 7867 01aa 00       		.byte	0
 7868 01ab 00000000 		.space	5
 7868      00
 7869 01b0 02       		.byte	2
 7870 01b1 02       		.byte	2
 7871 01b2 02       		.byte	2
 7872 01b3 00       		.byte	0
 7873 01b4 00       		.byte	0
 7874 01b5 FF       		.byte	-1
 7875 01b6 00       		.byte	0
 7876 01b7 01       		.byte	1
 7877 01b8 00       		.byte	0
 7878 01b9 03       		.byte	3
 7879 01ba 00       		.byte	0
 7880 01bb 70       		.byte	112
 7881 01bc 00       		.byte	0
 7882 01bd 70       		.byte	112
 7883 01be 00       		.byte	0
 7884 01bf C6       		.byte	-58
 7885 01c0 01       		.byte	1
 7886 01c1 01       		.byte	1
 7887 01c2 00       		.byte	0
 7888 01c3 00000000 		.space	5
 7888      00
 7889 01c8 00       		.byte	0
 7890 01c9 00       		.byte	0
 7891 01ca 02       		.byte	2
 7892 01cb 00       		.byte	0
 7893 01cc 00       		.byte	0
 7894 01cd 64       		.byte	100
 7895 01ce 00       		.byte	0
 7896 01cf 01       		.byte	1
 7897 01d0 00       		.byte	0
 7898 01d1 03       		.byte	3
 7899 01d2 00       		.byte	0
 7900 01d3 00       		.byte	0
 7901 01d4 00       		.byte	0
 7902 01d5 00       		.byte	0
 7903 01d6 00       		.byte	0
 7904 01d7 30       		.byte	48
 7905 01d8 01       		.byte	1
 7906 01d9 00       		.byte	0
 7907 01da 00       		.byte	0
 7908 01db 00000000 		.space	5
 7908      00
 7909 01e0 07       		.byte	7
 7910 01e1 07       		.byte	7
 7911 01e2 02       		.byte	2
 7912 01e3 00       		.byte	0
 7913 01e4 00       		.byte	0
 7914 01e5 01       		.byte	1
 7915 01e6 00       		.byte	0
 7916 01e7 01       		.byte	1
 7917 01e8 00       		.byte	0
 7918 01e9 03       		.byte	3
 7919 01ea 00       		.byte	0
 7920 01eb 01       		.byte	1
 7921 01ec 00       		.byte	0
 7922 01ed 01       		.byte	1
 7923 01ee 00       		.byte	0
 7924 01ef 30       		.byte	48
 7925 01f0 01       		.byte	1
 7926 01f1 00       		.byte	0
 7927 01f2 00       		.byte	0
 7928 01f3 00000000 		.space	5
 7928      00
 7929 01f8 DF       		.byte	-33
 7930 01f9 E1       		.byte	-31
 7931 01fa 02       		.byte	2
 7932 01fb 00       		.byte	0
 7933 01fc 00       		.byte	0
 7934 01fd FF       		.byte	-1
 7935 01fe 00       		.byte	0
 7936 01ff 01       		.byte	1
 7937 0200 00       		.byte	0
 7938 0201 03       		.byte	3
 7939 0202 00       		.byte	0
 7940 0203 80       		.byte	-128
 7941 0204 00       		.byte	0
 7942 0205 00       		.byte	0
 7943 0206 00       		.byte	0
 7944 0207 C6       		.byte	-58
 7945 0208 01       		.byte	1
 7946 0209 01       		.byte	1
 7947 020a 00       		.byte	0
 7948 020b 00000000 		.space	5
 7948      00
 7949 0210 85       		.byte	-123
 7950 0211 86       		.byte	-122
 7951 0212 02       		.byte	2
 7952 0213 00       		.byte	0
 7953 0214 00       		.byte	0
 7954 0215 64       		.byte	100
 7955 0216 00       		.byte	0
 7956 0217 01       		.byte	1
 7957 0218 00       		.byte	0
 7958 0219 03       		.byte	3
 7959 021a 00       		.byte	0
 7960 021b 32       		.byte	50
 7961 021c 00       		.byte	0
 7962 021d 32       		.byte	50
 7963 021e 00       		.byte	0
 7964 021f F2       		.byte	-14
 7965 0220 01       		.byte	1
 7966 0221 01       		.byte	1
 7967 0222 00       		.byte	0
 7968 0223 00000000 		.space	5
 7968      00
 7969 0228 06       		.byte	6
 7970 0229 06       		.byte	6
 7971 022a 02       		.byte	2
 7972 022b 00       		.byte	0
 7973 022c 00       		.byte	0
 7974 022d 40       		.byte	64
 7975 022e 00       		.byte	0
 7976 022f 01       		.byte	1
 7977 0230 00       		.byte	0
 7978 0231 03       		.byte	3
 7979 0232 00       		.byte	0
 7980 0233 20       		.byte	32
 7981 0234 00       		.byte	0
 7982 0235 20       		.byte	32
 7983 0236 00       		.byte	0
 7984 0237 30       		.byte	48
 7985 0238 01       		.byte	1
 7986 0239 01       		.byte	1
 7987 023a 00       		.byte	0
 7988 023b 00000000 		.space	5
 7988      00
 7989 0240 00       		.byte	0
 7990 0241 00       		.byte	0
 7991 0242 02       		.byte	2
 7992 0243 00       		.byte	0
 7993 0244 00       		.byte	0
 7994 0245 64       		.byte	100
 7995 0246 00       		.byte	0
 7996 0247 01       		.byte	1
 7997 0248 00       		.byte	0
 7998 0249 03       		.byte	3
 7999 024a 00       		.byte	0
 8000 024b 00       		.byte	0
 8001 024c 00       		.byte	0
 8002 024d 00       		.byte	0
 8003 024e 00       		.byte	0
 8004 024f 30       		.byte	48
 8005 0250 01       		.byte	1
 8006 0251 00       		.byte	0
 8007 0252 00       		.byte	0
 8008 0253 00000000 		.space	5
 8008      00
 8009 0258 08       		.byte	8
 8010 0259 08       		.byte	8
 8011 025a 02       		.byte	2
 8012 025b 00       		.byte	0
 8013 025c 00       		.byte	0
 8014 025d 05       		.byte	5
 8015 025e 00       		.byte	0
 8016 025f 01       		.byte	1
 8017 0260 00       		.byte	0
 8018 0261 03       		.byte	3
 8019 0262 00       		.byte	0
 8020 0263 00       		.byte	0
 8021 0264 00       		.byte	0
 8022 0265 00       		.byte	0
 8023 0266 00       		.byte	0
 8024 0267 30       		.byte	48
 8025 0268 01       		.byte	1
 8026 0269 00       		.byte	0
 8027 026a 00       		.byte	0
 8028 026b 00000000 		.space	5
 8028      00
 8029 0270 00       		.byte	0
 8030 0271 00       		.byte	0
 8031 0272 02       		.byte	2
 8032 0273 00       		.byte	0
 8033 0274 00       		.byte	0
 8034 0275 40       		.byte	64
 8035 0276 00       		.byte	0
 8036 0277 01       		.byte	1
 8037 0278 00       		.byte	0
 8038 0279 03       		.byte	3
 8039 027a 00       		.byte	0
 8040 027b 00       		.byte	0
 8041 027c 00       		.byte	0
 8042 027d 00       		.byte	0
 8043 027e 00       		.byte	0
 8044 027f 30       		.byte	48
 8045 0280 01       		.byte	1
 8046 0281 00       		.byte	0
 8047 0282 00       		.byte	0
 8048 0283 00000000 		.space	5
 8048      00
 8049 0288 09       		.byte	9
 8050 0289 0A       		.byte	10
 8051 028a 04       		.byte	4
 8052 028b 00       		.byte	0
 8053 028c 00       		.byte	0
 8054 028d 40       		.byte	64
 8055 028e 00       		.byte	0
 8056 028f 01       		.byte	1
 8057 0290 00       		.byte	0
 8058 0291 03       		.byte	3
 8059 0292 00       		.byte	0
 8060 0293 20       		.byte	32
 8061 0294 38       		.byte	56
 8062 0295 20       		.byte	32
 8063 0296 38       		.byte	56
 8064 0297 30       		.byte	48
 8065 0298 01       		.byte	1
 8066 0299 00       		.byte	0
 8067 029a 00       		.byte	0
 8068 029b 00000000 		.space	5
 8068      00
 8069 02a0 00       		.byte	0
 8070 02a1 00       		.byte	0
 8071 02a2 02       		.byte	2
 8072 02a3 00       		.byte	0
 8073 02a4 00       		.byte	0
 8074 02a5 64       		.byte	100
 8075 02a6 00       		.byte	0
 8076 02a7 01       		.byte	1
 8077 02a8 00       		.byte	0
 8078 02a9 03       		.byte	3
 8079 02aa 00       		.byte	0
 8080 02ab 00       		.byte	0
 8081 02ac 00       		.byte	0
 8082 02ad 00       		.byte	0
 8083 02ae 00       		.byte	0
 8084 02af 30       		.byte	48
 8085 02b0 01       		.byte	1
 8086 02b1 00       		.byte	0
 8087 02b2 00       		.byte	0
 8088 02b3 00000000 		.space	5
 8088      00
 8089 02b8 00       		.byte	0
 8090 02b9 00       		.byte	0
 8091 02ba 02       		.byte	2
 8092 02bb 00       		.byte	0
 8093 02bc 00       		.byte	0
 8094 02bd 64       		.byte	100
 8095 02be 00       		.byte	0
 8096 02bf 01       		.byte	1
 8097 02c0 00       		.byte	0
 8098 02c1 03       		.byte	3
 8099 02c2 00       		.byte	0
 8100 02c3 00       		.byte	0
 8101 02c4 00       		.byte	0
 8102 02c5 00       		.byte	0
 8103 02c6 00       		.byte	0
 8104 02c7 30       		.byte	48
 8105 02c8 01       		.byte	1
 8106 02c9 00       		.byte	0
 8107 02ca 00       		.byte	0
 8108 02cb 00000000 		.space	5
 8108      00
 8109 02d0 2A       		.byte	42
 8110 02d1 2A       		.byte	42
 8111 02d2 02       		.byte	2
 8112 02d3 00       		.byte	0
 8113 02d4 00       		.byte	0
 8114 02d5 1B       		.byte	27
 8115 02d6 00       		.byte	0
 8116 02d7 01       		.byte	1
 8117 02d8 00       		.byte	0
 8118 02d9 03       		.byte	3
 8119 02da 00       		.byte	0
 8120 02db 00       		.byte	0
 8121 02dc 00       		.byte	0
 8122 02dd 00       		.byte	0
 8123 02de 00       		.byte	0
 8124 02df 30       		.byte	48
 8125 02e0 01       		.byte	1
 8126 02e1 00       		.byte	0
 8127 02e2 00       		.byte	0
 8128 02e3 00000000 		.space	5
 8128      00
 8129 02e8 00       		.byte	0
 8130 02e9 00       		.byte	0
 8131 02ea 02       		.byte	2
 8132 02eb 00       		.byte	0
 8133 02ec 00       		.byte	0
 8134 02ed 64       		.byte	100
 8135 02ee 00       		.byte	0
 8136 02ef 01       		.byte	1
 8137 02f0 00       		.byte	0
 8138 02f1 03       		.byte	3
 8139 02f2 00       		.byte	0
 8140 02f3 00       		.byte	0
 8141 02f4 00       		.byte	0
 8142 02f5 00       		.byte	0
 8143 02f6 00       		.byte	0
 8144 02f7 30       		.byte	48
 8145 02f8 01       		.byte	1
 8146 02f9 00       		.byte	0
 8147 02fa 00       		.byte	0
 8148 02fb 00000000 		.space	5
 8148      00
 8149 0300 00       		.byte	0
 8150 0301 00       		.byte	0
 8151 0302 02       		.byte	2
 8152 0303 00       		.byte	0
 8153 0304 00       		.byte	0
 8154 0305 12       		.byte	18
 8155 0306 00       		.byte	0
 8156 0307 01       		.byte	1
 8157 0308 00       		.byte	0
 8158 0309 03       		.byte	3
 8159 030a 00       		.byte	0
 8160 030b 00       		.byte	0
 8161 030c 00       		.byte	0
 8162 030d 00       		.byte	0
 8163 030e 00       		.byte	0
 8164 030f 30       		.byte	48
 8165 0310 01       		.byte	1
 8166 0311 00       		.byte	0
 8167 0312 00       		.byte	0
 8168 0313 00000000 		.space	5
 8168      00
 8169 0318 01       		.byte	1
 8170 0319 01       		.byte	1
 8171 031a 02       		.byte	2
 8172 031b 00       		.byte	0
 8173 031c 00       		.byte	0
 8174 031d 09       		.byte	9
 8175 031e 00       		.byte	0
 8176 031f 01       		.byte	1
 8177 0320 00       		.byte	0
 8178 0321 03       		.byte	3
 8179 0322 00       		.byte	0
 8180 0323 00       		.byte	0
 8181 0324 00       		.byte	0
 8182 0325 01       		.byte	1
 8183 0326 00       		.byte	0
 8184 0327 30       		.byte	48
 8185 0328 01       		.byte	1
 8186 0329 00       		.byte	0
 8187 032a 00       		.byte	0
 8188 032b 00000000 		.space	5
 8188      00
 8189 0330 05       		.byte	5
 8190 0331 05       		.byte	5
 8191 0332 02       		.byte	2
 8192 0333 00       		.byte	0
 8193 0334 00       		.byte	0
 8194 0335 03       		.byte	3
 8195 0336 00       		.byte	0
 8196 0337 01       		.byte	1
 8197 0338 00       		.byte	0
 8198 0339 03       		.byte	3
 8199 033a 00       		.byte	0
 8200 033b 00       		.byte	0
 8201 033c 00       		.byte	0
 8202 033d 00       		.byte	0
 8203 033e 00       		.byte	0
 8204 033f 30       		.byte	48
 8205 0340 01       		.byte	1
 8206 0341 00       		.byte	0
 8207 0342 00       		.byte	0
 8208 0343 00000000 		.space	5
 8208      00
 8209 0348 18       		.byte	24
 8210 0349 18       		.byte	24
 8211 034a 02       		.byte	2
 8212 034b 00       		.byte	0
 8213 034c 00       		.byte	0
 8214 034d 01       		.byte	1
 8215 034e 00       		.byte	0
 8216 034f 01       		.byte	1
 8217 0350 00       		.byte	0
 8218 0351 03       		.byte	3
 8219 0352 00       		.byte	0
 8220 0353 00       		.byte	0
 8221 0354 00       		.byte	0
 8222 0355 00       		.byte	0
 8223 0356 00       		.byte	0
 8224 0357 30       		.byte	48
 8225 0358 01       		.byte	1
 8226 0359 00       		.byte	0
 8227 035a 00       		.byte	0
 8228 035b 00000000 		.space	5
 8228      00
 8229 0360 19       		.byte	25
 8230 0361 19       		.byte	25
 8231 0362 01       		.byte	1
 8232 0363 00       		.byte	0
 8233 0364 00       		.byte	0
 8234 0365 40       		.byte	64
 8235 0366 00       		.byte	0
 8236 0367 01       		.byte	1
 8237 0368 00       		.byte	0
 8238 0369 03       		.byte	3
 8239 036a 00       		.byte	0
 8240 036b 20       		.byte	32
 8241 036c 00       		.byte	0
 8242 036d 20       		.byte	32
 8243 036e 00       		.byte	0
 8244 036f 30       		.byte	48
 8245 0370 01       		.byte	1
 8246 0371 00       		.byte	0
 8247 0372 00       		.byte	0
 8248 0373 00000000 		.space	5
 8248      00
 8249 0378 20       		.byte	32
 8250 0379 20       		.byte	32
 8251 037a 02       		.byte	2
 8252 037b 00       		.byte	0
 8253 037c 00       		.byte	0
 8254 037d 02       		.byte	2
 8255 037e 00       		.byte	0
 8256 037f 01       		.byte	1
 8257 0380 00       		.byte	0
 8258 0381 03       		.byte	3
 8259 0382 00       		.byte	0
 8260 0383 00       		.byte	0
 8261 0384 00       		.byte	0
 8262 0385 00       		.byte	0
 8263 0386 00       		.byte	0
 8264 0387 30       		.byte	48
 8265 0388 01       		.byte	1
 8266 0389 00       		.byte	0
 8267 038a 00       		.byte	0
 8268 038b 00000000 		.space	5
 8268      00
 8269 0390 22       		.byte	34
 8270 0391 22       		.byte	34
 8271 0392 02       		.byte	2
 8272 0393 00       		.byte	0
 8273 0394 00       		.byte	0
 8274 0395 3F       		.byte	63
 8275 0396 00       		.byte	0
 8276 0397 01       		.byte	1
 8277 0398 00       		.byte	0
 8278 0399 03       		.byte	3
 8279 039a 00       		.byte	0
 8280 039b 00       		.byte	0
 8281 039c 00       		.byte	0
 8282 039d 00       		.byte	0
 8283 039e 00       		.byte	0
 8284 039f 30       		.byte	48
 8285 03a0 01       		.byte	1
 8286 03a1 00       		.byte	0
 8287 03a2 00       		.byte	0
 8288 03a3 00000000 		.space	5
 8288      00
 8289 03a8 23       		.byte	35
 8290 03a9 23       		.byte	35
 8291 03aa 02       		.byte	2
 8292 03ab 00       		.byte	0
 8293 03ac 00       		.byte	0
 8294 03ad 64       		.byte	100
 8295 03ae 00       		.byte	0
 8296 03af 01       		.byte	1
 8297 03b0 00       		.byte	0
 8298 03b1 03       		.byte	3
 8299 03b2 00       		.byte	0
 8300 03b3 10       		.byte	16
 8301 03b4 00       		.byte	0
 8302 03b5 10       		.byte	16
 8303 03b6 00       		.byte	0
 8304 03b7 30       		.byte	48
 8305 03b8 01       		.byte	1
 8306 03b9 00       		.byte	0
 8307 03ba 00       		.byte	0
 8308 03bb 00000000 		.space	5
 8308      00
 8309 03c0 24       		.byte	36
 8310 03c1 24       		.byte	36
 8311 03c2 02       		.byte	2
 8312 03c3 00       		.byte	0
 8313 03c4 00       		.byte	0
 8314 03c5 64       		.byte	100
 8315 03c6 00       		.byte	0
 8316 03c7 01       		.byte	1
 8317 03c8 00       		.byte	0
 8318 03c9 03       		.byte	3
 8319 03ca 00       		.byte	0
 8320 03cb 10       		.byte	16
 8321 03cc 00       		.byte	0
 8322 03cd 10       		.byte	16
 8323 03ce 00       		.byte	0
 8324 03cf 30       		.byte	48
 8325 03d0 01       		.byte	1
 8326 03d1 00       		.byte	0
 8327 03d2 00       		.byte	0
 8328 03d3 00000000 		.space	5
 8328      00
 8329 03d8 02       		.byte	2
 8330 03d9 03       		.byte	3
 8331 03da 04       		.byte	4
 8332 03db 00       		.byte	0
 8333 03dc 00       		.byte	0
 8334 03dd 7F       		.byte	127
 8335 03de 00       		.byte	0
 8336 03df 01       		.byte	1
 8337 03e0 00       		.byte	0
 8338 03e1 03       		.byte	3
 8339 03e2 00       		.byte	0
 8340 03e3 00       		.byte	0
 8341 03e4 20       		.byte	32
 8342 03e5 00       		.byte	0
 8343 03e6 20       		.byte	32
 8344 03e7 30       		.byte	48
 8345 03e8 01       		.byte	1
 8346 03e9 00       		.byte	0
 8347 03ea 00       		.byte	0
 8348 03eb 00000000 		.space	5
 8348      00
 8349 03f0 04       		.byte	4
 8350 03f1 0C       		.byte	12
 8351 03f2 02       		.byte	2
 8352 03f3 00       		.byte	0
 8353 03f4 00       		.byte	0
 8354 03f5 40       		.byte	64
 8355 03f6 00       		.byte	0
 8356 03f7 01       		.byte	1
 8357 03f8 00       		.byte	0
 8358 03f9 03       		.byte	3
 8359 03fa 00       		.byte	0
 8360 03fb 20       		.byte	32
 8361 03fc 00       		.byte	0
 8362 03fd 20       		.byte	32
 8363 03fe 00       		.byte	0
 8364 03ff 30       		.byte	48
 8365 0400 01       		.byte	1
 8366 0401 00       		.byte	0
 8367 0402 00       		.byte	0
 8368 0403 00000000 		.space	5
 8368      00
 8369 0408 00       		.byte	0
 8370 0409 00       		.byte	0
 8371 040a 02       		.byte	2
 8372 040b 00       		.byte	0
 8373 040c 00       		.byte	0
 8374 040d 19       		.byte	25
 8375 040e 00       		.byte	0
 8376 040f 01       		.byte	1
 8377 0410 00       		.byte	0
 8378 0411 03       		.byte	3
 8379 0412 00       		.byte	0
 8380 0413 00       		.byte	0
 8381 0414 00       		.byte	0
 8382 0415 00       		.byte	0
 8383 0416 00       		.byte	0
 8384 0417 30       		.byte	48
 8385 0418 01       		.byte	1
 8386 0419 00       		.byte	0
 8387 041a 00       		.byte	0
 8388 041b 00000000 		.space	5
 8388      00
 8389 0420 10       		.byte	16
 8390 0421 10       		.byte	16
 8391 0422 02       		.byte	2
 8392 0423 00       		.byte	0
 8393 0424 00       		.byte	0
 8394 0425 06       		.byte	6
 8395 0426 00       		.byte	0
 8396 0427 01       		.byte	1
 8397 0428 00       		.byte	0
 8398 0429 03       		.byte	3
 8399 042a 00       		.byte	0
 8400 042b 00       		.byte	0
 8401 042c 00       		.byte	0
 8402 042d 00       		.byte	0
 8403 042e 00       		.byte	0
 8404 042f 30       		.byte	48
 8405 0430 01       		.byte	1
 8406 0431 00       		.byte	0
 8407 0432 00       		.byte	0
 8408 0433 00000000 		.space	5
 8408      00
 8409 0438 00       		.byte	0
 8410 0439 00       		.byte	0
 8411 043a 02       		.byte	2
 8412 043b 00       		.byte	0
 8413 043c 00       		.byte	0
 8414 043d 03       		.byte	3
 8415 043e 00       		.byte	0
 8416 043f 01       		.byte	1
 8417 0440 00       		.byte	0
 8418 0441 03       		.byte	3
 8419 0442 00       		.byte	0
 8420 0443 00       		.byte	0
 8421 0444 00       		.byte	0
 8422 0445 00       		.byte	0
 8423 0446 00       		.byte	0
 8424 0447 30       		.byte	48
 8425 0448 01       		.byte	1
 8426 0449 00       		.byte	0
 8427 044a 00       		.byte	0
 8428 044b 00000000 		.space	5
 8428      00
 8429 0450 50       		.byte	80
 8430 0451 50       		.byte	80
 8431 0452 01       		.byte	1
 8432 0453 00       		.byte	0
 8433 0454 00       		.byte	0
 8434 0455 03       		.byte	3
 8435 0456 00       		.byte	0
 8436 0457 01       		.byte	1
 8437 0458 00       		.byte	0
 8438 0459 03       		.byte	3
 8439 045a 00       		.byte	0
 8440 045b 00       		.byte	0
 8441 045c 00       		.byte	0
 8442 045d 00       		.byte	0
 8443 045e 00       		.byte	0
 8444 045f 30       		.byte	48
 8445 0460 01       		.byte	1
 8446 0461 00       		.byte	0
 8447 0462 00       		.byte	0
 8448 0463 00000000 		.space	5
 8448      00
 8449 0468 00       		.byte	0
 8450 0469 00       		.byte	0
 8451 046a 0B       		.byte	11
 8452 046b 00       		.byte	0
 8453 046c 00       		.byte	0
 8454 046d FF       		.byte	-1
 8455 046e FF       		.byte	-1
 8456 046f 01       		.byte	1
 8457 0470 00       		.byte	0
 8458 0471 03       		.byte	3
 8459 0472 00       		.byte	0
 8460 0473 00       		.byte	0
 8461 0474 00       		.byte	0
 8462 0475 00       		.byte	0
 8463 0476 00       		.byte	0
 8464 0477 00       		.byte	0
 8465 0478 01       		.byte	1
 8466 0479 00       		.byte	0
 8467 047a 00       		.byte	0
 8468 047b 00000000 		.space	5
 8468      00
 8471              	glUVCHeader:
 8472 0480 0C       		.byte	12
 8473 0481 8C       		.byte	-116
 8474 0482 00       		.byte	0
 8475 0483 00       		.byte	0
 8476 0484 00       		.byte	0
 8477 0485 00       		.byte	0
 8478 0486 00       		.byte	0
 8479 0487 00       		.byte	0
 8480 0488 00       		.byte	0
 8481 0489 00       		.byte	0
 8482 048a 00       		.byte	0
 8483 048b 00       		.byte	0
 8486              	WBMenuCmpArry:
 8487 048c 20       		.byte	32
 8488 048d 0F       		.byte	15
 8489 048e 38       		.byte	56
 8490 048f F0       		.byte	-16
 8493              	CTCtrlParArry:
 8494 0490 00       		.byte	0
 8495 0491 00       		.byte	0
 8496 0492 01       		.byte	1
 8497 0493 00       		.byte	0
 8498 0494 00       		.byte	0
 8499 0495 03       		.byte	3
 8500 0496 00       		.byte	0
 8501 0497 01       		.byte	1
 8502 0498 00       		.byte	0
 8503 0499 03       		.byte	3
 8504 049a 00       		.byte	0
 8505 049b 03       		.byte	3
 8506 049c 00       		.byte	0
 8507 049d 03       		.byte	3
 8508 049e 00       		.byte	0
 8509 049f 30       		.byte	48
 8510 04a0 01       		.byte	1
 8511 04a1 00       		.byte	0
 8512 04a2 00       		.byte	0
 8513 04a3 00000000 		.space	5
 8513      00
 8514 04a8 00       		.byte	0
 8515 04a9 00       		.byte	0
 8516 04aa 01       		.byte	1
 8517 04ab 01       		.byte	1
 8518 04ac 00       		.byte	0
 8519 04ad 0F       		.byte	15
 8520 04ae 00       		.byte	0
 8521 04af 0F       		.byte	15
 8522 04b0 00       		.byte	0
 8523 04b1 03       		.byte	3
 8524 04b2 00       		.byte	0
 8525 04b3 02       		.byte	2
 8526 04b4 00       		.byte	0
 8527 04b5 02       		.byte	2
 8528 04b6 00       		.byte	0
 8529 04b7 30       		.byte	48
 8530 04b8 01       		.byte	1
 8531 04b9 01       		.byte	1
 8532 04ba 00       		.byte	0
 8533 04bb 00000000 		.space	5
 8533      00
 8534 04c0 02       		.byte	2
 8535 04c1 00       		.byte	0
 8536 04c2 01       		.byte	1
 8537 04c3 00       		.byte	0
 8538 04c4 00       		.byte	0
 8539 04c5 01       		.byte	1
 8540 04c6 00       		.byte	0
 8541 04c7 01       		.byte	1
 8542 04c8 00       		.byte	0
 8543 04c9 03       		.byte	3
 8544 04ca 00       		.byte	0
 8545 04cb 00       		.byte	0
 8546 04cc 00       		.byte	0
 8547 04cd 00       		.byte	0
 8548 04ce 00       		.byte	0
 8549 04cf 30       		.byte	48
 8550 04d0 01       		.byte	1
 8551 04d1 01       		.byte	1
 8552 04d2 00       		.byte	0
 8553 04d3 00000000 		.space	5
 8553      00
 8554 04d8 00       		.byte	0
 8555 04d9 00       		.byte	0
 8556 04da 04       		.byte	4
 8557 04db 01       		.byte	1
 8558 04dc 00       		.byte	0
 8559 04dd 38       		.byte	56
 8560 04de 01       		.byte	1
 8561 04df 01       		.byte	1
 8562 04e0 00       		.byte	0
 8563 04e1 03       		.byte	3
 8564 04e2 00       		.byte	0
 8565 04e3 4E       		.byte	78
 8566 04e4 00       		.byte	0
 8567 04e5 4E       		.byte	78
 8568 04e6 00       		.byte	0
 8569 04e7 30       		.byte	48
 8570 04e8 01       		.byte	1
 8571 04e9 00       		.byte	0
 8572 04ea 00       		.byte	0
 8573 04eb 00000000 		.space	5
 8573      00
 8574 04f0 04       		.byte	4
 8575 04f1 00       		.byte	0
 8576 04f2 01       		.byte	1
 8577 04f3 00       		.byte	0
 8578 04f4 00       		.byte	0
 8579 04f5 00       		.byte	0
 8580 04f6 00       		.byte	0
 8581 04f7 01       		.byte	1
 8582 04f8 00       		.byte	0
 8583 04f9 03       		.byte	3
 8584 04fa 00       		.byte	0
 8585 04fb 00       		.byte	0
 8586 04fc 00       		.byte	0
 8587 04fd 00       		.byte	0
 8588 04fe 00       		.byte	0
 8589 04ff 30       		.byte	48
 8590 0500 01       		.byte	1
 8591 0501 00       		.byte	0
 8592 0502 00       		.byte	0
 8593 0503 00000000 		.space	5
 8593      00
 8594 0508 05       		.byte	5
 8595 0509 00       		.byte	0
 8596 050a 02       		.byte	2
 8597 050b 00       		.byte	0
 8598 050c 00       		.byte	0
 8599 050d FF       		.byte	-1
 8600 050e 00       		.byte	0
 8601 050f 01       		.byte	1
 8602 0510 00       		.byte	0
 8603 0511 03       		.byte	3
 8604 0512 00       		.byte	0
 8605 0513 01       		.byte	1
 8606 0514 00       		.byte	0
 8607 0515 00       		.byte	0
 8608 0516 00       		.byte	0
 8609 0517 30       		.byte	48
 8610 0518 01       		.byte	1
 8611 0519 01       		.byte	1
 8612 051a 00       		.byte	0
 8613 051b 00000000 		.space	5
 8613      00
 8614 0520 06       		.byte	6
 8615 0521 00       		.byte	0
 8616 0522 02       		.byte	2
 8617 0523 00       		.byte	0
 8618 0524 00       		.byte	0
 8619 0525 00       		.byte	0
 8620 0526 00       		.byte	0
 8621 0527 00       		.byte	0
 8622 0528 00       		.byte	0
 8623 0529 03       		.byte	3
 8624 052a 00       		.byte	0
 8625 052b 00       		.byte	0
 8626 052c 00       		.byte	0
 8627 052d 00       		.byte	0
 8628 052e 00       		.byte	0
 8629 052f 30       		.byte	48
 8630 0530 01       		.byte	1
 8631 0531 01       		.byte	1
 8632 0532 00       		.byte	0
 8633 0533 00000000 		.space	5
 8633      00
 8634 0538 23       		.byte	35
 8635 0539 00       		.byte	0
 8636 053a 02       		.byte	2
 8637 053b 00       		.byte	0
 8638 053c 00       		.byte	0
 8639 053d 30       		.byte	48
 8640 053e 00       		.byte	0
 8641 053f 01       		.byte	1
 8642 0540 00       		.byte	0
 8643 0541 03       		.byte	3
 8644 0542 0A       		.byte	10
 8645 0543 00       		.byte	0
 8646 0544 00       		.byte	0
 8647 0545 0A       		.byte	10
 8648 0546 00       		.byte	0
 8649 0547 30       		.byte	48
 8650 0548 01       		.byte	1
 8651 0549 01       		.byte	1
 8652 054a 00       		.byte	0
 8653 054b 00000000 		.space	5
 8653      00
 8654 0550 08       		.byte	8
 8655 0551 00       		.byte	0
 8656 0552 01       		.byte	1
 8657 0553 00       		.byte	0
 8658 0554 00       		.byte	0
 8659 0555 7F       		.byte	127
 8660 0556 00       		.byte	0
 8661 0557 01       		.byte	1
 8662 0558 00       		.byte	0
 8663 0559 03       		.byte	3
 8664 055a 00       		.byte	0
 8665 055b 00       		.byte	0
 8666 055c 00       		.byte	0
 8667 055d 00       		.byte	0
 8668 055e 00       		.byte	0
 8669 055f 30       		.byte	48
 8670 0560 01       		.byte	1
 8671 0561 00       		.byte	0
 8672 0562 00       		.byte	0
 8673 0563 00000000 		.space	5
 8673      00
 8674 0568 09       		.byte	9
 8675 0569 00       		.byte	0
 8676 056a 02       		.byte	2
 8677 056b 00       		.byte	0
 8678 056c 00       		.byte	0
 8679 056d 05       		.byte	5
 8680 056e 00       		.byte	0
 8681 056f 01       		.byte	1
 8682 0570 00       		.byte	0
 8683 0571 03       		.byte	3
 8684 0572 00       		.byte	0
 8685 0573 00       		.byte	0
 8686 0574 00       		.byte	0
 8687 0575 00       		.byte	0
 8688 0576 00       		.byte	0
 8689 0577 30       		.byte	48
 8690 0578 01       		.byte	1
 8691 0579 00       		.byte	0
 8692 057a 00       		.byte	0
 8693 057b 00000000 		.space	5
 8693      00
 8694 0580 10       		.byte	16
 8695 0581 00       		.byte	0
 8696 0582 03       		.byte	3
 8697 0583 00       		.byte	0
 8698 0584 00       		.byte	0
 8699 0585 00       		.byte	0
 8700 0586 00       		.byte	0
 8701 0587 00       		.byte	0
 8702 0588 00       		.byte	0
 8703 0589 03       		.byte	3
 8704 058a 00       		.byte	0
 8705 058b 00       		.byte	0
 8706 058c 00       		.byte	0
 8707 058d 00       		.byte	0
 8708 058e 00       		.byte	0
 8709 058f 30       		.byte	48
 8710 0590 01       		.byte	1
 8711 0591 00       		.byte	0
 8712 0592 00       		.byte	0
 8713 0593 00000000 		.space	5
 8713      00
 8714 0598 00       		.byte	0
 8715 0599 00       		.byte	0
 8716 059a 02       		.byte	2
 8717 059b 00       		.byte	0
 8718 059c 00       		.byte	0
 8719 059d 40       		.byte	64
 8720 059e 00       		.byte	0
 8721 059f 01       		.byte	1
 8722 05a0 00       		.byte	0
 8723 05a1 03       		.byte	3
 8724 05a2 00       		.byte	0
 8725 05a3 0F       		.byte	15
 8726 05a4 11       		.byte	17
 8727 05a5 00       		.byte	0
 8728 05a6 00       		.byte	0
 8729 05a7 30       		.byte	48
 8730 05a8 01       		.byte	1
 8731 05a9 00       		.byte	0
 8732 05aa 00       		.byte	0
 8733 05ab 00000000 		.space	5
 8733      00
 8734 05b0 00       		.byte	0
 8735 05b1 00       		.byte	0
 8736 05b2 02       		.byte	2
 8737 05b3 00       		.byte	0
 8738 05b4 00       		.byte	0
 8739 05b5 64       		.byte	100
 8740 05b6 00       		.byte	0
 8741 05b7 01       		.byte	1
 8742 05b8 00       		.byte	0
 8743 05b9 03       		.byte	3
 8744 05ba 00       		.byte	0
 8745 05bb 00       		.byte	0
 8746 05bc 00       		.byte	0
 8747 05bd 00       		.byte	0
 8748 05be 00       		.byte	0
 8749 05bf 30       		.byte	48
 8750 05c0 01       		.byte	1
 8751 05c1 00       		.byte	0
 8752 05c2 00       		.byte	0
 8753 05c3 00000000 		.space	5
 8753      00
 8754 05c8 00       		.byte	0
 8755 05c9 00       		.byte	0
 8756 05ca 02       		.byte	2
 8757 05cb 00       		.byte	0
 8758 05cc 00       		.byte	0
 8759 05cd 64       		.byte	100
 8760 05ce 00       		.byte	0
 8761 05cf 01       		.byte	1
 8762 05d0 00       		.byte	0
 8763 05d1 03       		.byte	3
 8764 05d2 00       		.byte	0
 8765 05d3 00       		.byte	0
 8766 05d4 00       		.byte	0
 8767 05d5 00       		.byte	0
 8768 05d6 00       		.byte	0
 8769 05d7 30       		.byte	48
 8770 05d8 01       		.byte	1
 8771 05d9 00       		.byte	0
 8772 05da 00       		.byte	0
 8773 05db 00000000 		.space	5
 8773      00
 8774 05e0 00       		.byte	0
 8775 05e1 00       		.byte	0
 8776 05e2 02       		.byte	2
 8777 05e3 00       		.byte	0
 8778 05e4 00       		.byte	0
 8779 05e5 64       		.byte	100
 8780 05e6 00       		.byte	0
 8781 05e7 01       		.byte	1
 8782 05e8 00       		.byte	0
 8783 05e9 03       		.byte	3
 8784 05ea 00       		.byte	0
 8785 05eb 00       		.byte	0
 8786 05ec 00       		.byte	0
 8787 05ed 00       		.byte	0
 8788 05ee 00       		.byte	0
 8789 05ef 30       		.byte	48
 8790 05f0 01       		.byte	1
 8791 05f1 00       		.byte	0
 8792 05f2 00       		.byte	0
 8793 05f3 00000000 		.space	5
 8793      00
 8794 05f8 00       		.byte	0
 8795 05f9 00       		.byte	0
 8796 05fa 02       		.byte	2
 8797 05fb 00       		.byte	0
 8798 05fc 00       		.byte	0
 8799 05fd 64       		.byte	100
 8800 05fe 00       		.byte	0
 8801 05ff 01       		.byte	1
 8802 0600 00       		.byte	0
 8803 0601 03       		.byte	3
 8804 0602 00       		.byte	0
 8805 0603 00       		.byte	0
 8806 0604 00       		.byte	0
 8807 0605 00       		.byte	0
 8808 0606 00       		.byte	0
 8809 0607 30       		.byte	48
 8810 0608 01       		.byte	1
 8811 0609 00       		.byte	0
 8812 060a 00       		.byte	0
 8813 060b 00000000 		.space	5
 8813      00
 8816              	glProbeCtrl:
 8817 0610 00       		.byte	0
 8818 0611 00       		.byte	0
 8819 0612 01       		.byte	1
 8820 0613 01       		.byte	1
 8821 0614 15       		.byte	21
 8822 0615 16       		.byte	22
 8823 0616 05       		.byte	5
 8824 0617 00       		.byte	0
 8825 0618 00       		.byte	0
 8826 0619 00       		.byte	0
 8827 061a 00       		.byte	0
 8828 061b 00       		.byte	0
 8829 061c 00       		.byte	0
 8830 061d 00       		.byte	0
 8831 061e 00       		.byte	0
 8832 061f 00       		.byte	0
 8833 0620 00       		.byte	0
 8834 0621 00       		.byte	0
 8835 0622 00       		.byte	0
 8836 0623 48       		.byte	72
 8837 0624 3F       		.byte	63
 8838 0625 00       		.byte	0
 8839 0626 00       		.byte	0
 8840 0627 40       		.byte	64
 8841 0628 00       		.byte	0
 8842 0629 00       		.byte	0
 8843 062a 0000     		.space	2
 8846              	glProbeCtrl20:
 8847 062c 00       		.byte	0
 8848 062d 00       		.byte	0
 8849 062e 01       		.byte	1
 8850 062f 01       		.byte	1
 8851 0630 80       		.byte	-128
 8852 0631 1A       		.byte	26
 8853 0632 06       		.byte	6
 8854 0633 00       		.byte	0
 8855 0634 00       		.byte	0
 8856 0635 00       		.byte	0
 8857 0636 00       		.byte	0
 8858 0637 00       		.byte	0
 8859 0638 00       		.byte	0
 8860 0639 00       		.byte	0
 8861 063a 00       		.byte	0
 8862 063b 00       		.byte	0
 8863 063c 00       		.byte	0
 8864 063d 00       		.byte	0
 8865 063e 00       		.byte	0
 8866 063f D2       		.byte	-46
 8867 0640 0F       		.byte	15
 8868 0641 00       		.byte	0
 8869 0642 00       		.byte	0
 8870 0643 40       		.byte	64
 8871 0644 00       		.byte	0
 8872 0645 00       		.byte	0
 8873 0646 0000     		.space	2
 8876              	glProbeStilCtrl:
 8877 0648 01       		.byte	1
 8878 0649 01       		.byte	1
 8879 064a 00       		.byte	0
 8880 064b 00       		.byte	0
 8881 064c 48       		.byte	72
 8882 064d 3F       		.byte	63
 8883 064e 00       		.byte	0
 8884 064f 00       		.byte	0
 8885 0650 40       		.byte	64
 8886 0651 00       		.byte	0
 8887 0652 00       		.byte	0
 8888 0653 00       		.space	1
 8891              	glProbeStilCtrl20:
 8892 0654 01       		.byte	1
 8893 0655 01       		.byte	1
 8894 0656 00       		.byte	0
 8895 0657 00       		.byte	0
 8896 0658 D2       		.byte	-46
 8897 0659 0F       		.byte	15
 8898 065a 00       		.byte	0
 8899 065b 00       		.byte	0
 8900 065c 40       		.byte	64
 8901 065d 00       		.byte	0
 8902 065e 00       		.byte	0
 8905              	snapButFlag:
 8906 065f 01       		.byte	1
 8909              	CyFxGpifTransition:
 8910 0660 0000     		.short	0
 8911 0662 5555     		.short	21845
 8912 0664 8888     		.short	-30584
 8913 0666 AAAA     		.short	-21846
 8914 0668 3333     		.short	13107
 8915 066a 0000     		.space	2
 8918              	CyFxGpifWavedata:
 8919 066c 0181731E 		.word	510886145
 8920 0670 00000000 		.word	0
 8921 0674 00000080 		.word	-2147483648
 8922 0678 00000000 		.word	0
 8923 067c 00000000 		.word	0
 8924 0680 00000000 		.word	0
 8925 0684 0201702E 		.word	779092226
 8926 0688 00010000 		.word	256
 8927 068c A0000080 		.word	-2147483488
 8928 0690 00000000 		.word	0
 8929 0694 00000000 		.word	0
 8930 0698 00000000 		.word	0
 8931 069c 0380722E 		.word	779255811
 8932 06a0 02010020 		.word	536871170
 8933 06a4 60000080 		.word	-2147483552
 8934 06a8 00000000 		.word	0
 8935 06ac 00000000 		.word	0
 8936 06b0 00000000 		.word	0
 8937 06b4 0460722E 		.word	779247620
 8938 06b8 02010024 		.word	603980034
 8939 06bc 90000080 		.word	-2147483504
 8940 06c0 0594731E 		.word	510891013
 8941 06c4 06000000 		.word	6
 8942 06c8 00000080 		.word	-2147483648
 8943 06cc 0380722E 		.word	779255811
 8944 06d0 02010020 		.word	536871170
 8945 06d4 60000080 		.word	-2147483552
 8946 06d8 0693731E 		.word	510890758
 8947 06dc 06000000 		.word	6
 8948 06e0 00000080 		.word	-2147483648
 8949 06e4 0720703E 		.word	1047535623
 8950 06e8 08010000 		.word	264
 8951 06ec 00000080 		.word	-2147483648
 8952 06f0 0820703E 		.word	1047535624
 8953 06f4 08010000 		.word	264
 8954 06f8 00000080 		.word	-2147483648
 8955 06fc 0920703E 		.word	1047535625
 8956 0700 08010000 		.word	264
 8957 0704 00000080 		.word	-2147483648
 8958 0708 0A20703E 		.word	1047535626
 8959 070c 08010000 		.word	264
 8960 0710 00000080 		.word	-2147483648
 8961 0714 0380722E 		.word	779255811
 8962 0718 02010020 		.word	536871170
 8963 071c 60000080 		.word	-2147483552
 8964 0720 0B000000 		.word	11
 8965 0724 00000000 		.word	0
 8966 0728 00010080 		.word	-2147483392
 8967 072c 0460722E 		.word	779247620
 8968 0730 02010024 		.word	603980034
 8969 0734 90000080 		.word	-2147483504
 8970 0738 0D000000 		.word	13
 8971 073c 00000000 		.word	0
 8972 0740 00010080 		.word	-2147483392
 8973 0744 0460722E 		.word	779247620
 8974 0748 02010024 		.word	603980034
 8975 074c 90000080 		.word	-2147483504
 8976 0750 0C000000 		.word	12
 8977 0754 00000000 		.word	0
 8978 0758 00010080 		.word	-2147483392
 8979 075c 0380722E 		.word	779255811
 8980 0760 02010020 		.word	536871170
 8981 0764 60000080 		.word	-2147483552
 8982 0768 0E000000 		.word	14
 8983 076c 00000000 		.word	0
 8984 0770 00010080 		.word	-2147483392
 8985 0774 00000000 		.word	0
 8986 0778 00000000 		.word	0
 8987 077c 00000000 		.word	0
 8988 0780 00000000 		.word	0
 8989 0784 00000000 		.word	0
 8990 0788 00000000 		.word	0
 8993              	CyFxGpifWavedataPosition:
 8994 078c 00       		.byte	0
 8995 078d 01       		.byte	1
 8996 078e 02       		.byte	2
 8997 078f 03       		.byte	3
 8998 0790 04       		.byte	4
 8999 0791 05       		.byte	5
 9000 0792 06       		.byte	6
 9001 0793 07       		.byte	7
 9002 0794 08       		.byte	8
 9003 0795 09       		.byte	9
 9004 0796 0A       		.byte	10
 9005 0797 0B       		.byte	11
 9006 0798 0B       		.byte	11
 9007 0799 0B       		.byte	11
 9008 079a 0B       		.byte	11
 9009 079b 00       		.space	1
 9012              	CyFxGpifRegValue:
 9013 079c 08830080 		.word	-2147450104
 9014 07a0 67000000 		.word	103
 9015 07a4 00000000 		.word	0
 9016 07a8 46000000 		.word	70
 9017 07ac 00000000 		.word	0
 9018 07b0 00000000 		.word	0
 9019 07b4 02000000 		.word	2
 9020 07b8 82000000 		.word	130
 9021 07bc 82070000 		.word	1922
 9022 07c0 40040000 		.word	1088
 9023 07c4 FCFF0000 		.word	65532
 9024 07c8 28000000 		.word	40
 9025 07cc 00000000 		.word	0
 9026 07d0 00000000 		.word	0
 9027 07d4 00000000 		.word	0
 9028 07d8 00000000 		.word	0
 9029 07dc 01000000 		.word	1
 9030 07e0 00000000 		.word	0
 9031 07e4 00000000 		.word	0
 9032 07e8 00000000 		.word	0
 9033 07ec 00000000 		.word	0
 9034 07f0 00000000 		.word	0
 9035 07f4 00000000 		.word	0
 9036 07f8 00000000 		.word	0
 9037 07fc 00000000 		.word	0
 9038 0800 00000000 		.word	0
 9039 0804 00000000 		.word	0
 9040 0808 00000000 		.word	0
 9041 080c 00000000 		.word	0
 9042 0810 06000000 		.word	6
 9043 0814 00000000 		.word	0
 9044 0818 FFFF0000 		.word	65535
 9045 081c 09010000 		.word	265
 9046 0820 00000000 		.word	0
 9047 0824 F71F0000 		.word	8183
 9048 0828 00000000 		.word	0
 9049 082c FFFF0000 		.word	65535
 9050 0830 09010000 		.word	265
 9051 0834 00000000 		.word	0
 9052 0838 F71F0000 		.word	8183
 9053 083c 00000000 		.word	0
 9054 0840 00000000 		.word	0
 9055 0844 00000000 		.word	0
 9056 0848 00000000 		.word	0
 9057 084c 00000000 		.word	0
 9058 0850 00000000 		.word	0
 9059 0854 00000000 		.word	0
 9060 0858 00000000 		.word	0
 9061 085c 00000000 		.word	0
 9062 0860 00000000 		.word	0
 9063 0864 00000000 		.word	0
 9064 0868 00000000 		.word	0
 9065 086c 00000000 		.word	0
 9066 0870 00000000 		.word	0
 9067 0874 00000000 		.word	0
 9068 0878 00000000 		.word	0
 9069 087c 00000000 		.word	0
 9070 0880 00000000 		.word	0
 9071 0884 00000000 		.word	0
 9072 0888 00000000 		.word	0
 9073 088c 00000000 		.word	0
 9074 0890 00000000 		.word	0
 9075 0894 00000000 		.word	0
 9076 0898 00040180 		.word	-2147417088
 9077 089c 01040180 		.word	-2147417087
 9078 08a0 02040180 		.word	-2147417086
 9079 08a4 03040180 		.word	-2147417085
 9080 08a8 00000000 		.word	0
 9081 08ac 00000000 		.word	0
 9082 08b0 00000000 		.word	0
 9083 08b4 00000000 		.word	0
 9084 08b8 00000000 		.word	0
 9085 08bc 00000000 		.word	0
 9086 08c0 00000000 		.word	0
 9087 08c4 00000000 		.word	0
 9088 08c8 C1FFFFFF 		.word	-63
 9091              	CyFxGpifTransition_usb2:
 9092 08cc 0000     		.short	0
 9093 08ce 5555     		.short	21845
 9094 08d0 AAAA     		.short	-21846
 9095 08d2 8888     		.short	-30584
 9096 08d4 1111     		.short	4369
 9097 08d6 4444     		.short	17476
 9098 08d8 3333     		.short	13107
 9099 08da CCCC     		.short	-13108
 9102              	CyFxGpifWavedata_usb2:
 9103 08dc 0181731E 		.word	510886145
 9104 08e0 00000000 		.word	0
 9105 08e4 00000080 		.word	-2147483648
 9106 08e8 00000000 		.word	0
 9107 08ec 00000000 		.word	0
 9108 08f0 00000000 		.word	0
 9109 08f4 0201703E 		.word	1047527682
 9110 08f8 00010000 		.word	256
 9111 08fc A00000C0 		.word	-1073741664
 9112 0900 00000000 		.word	0
 9113 0904 00000000 		.word	0
 9114 0908 00000000 		.word	0
 9115 090c 0394731E 		.word	510891011
 9116 0910 04000020 		.word	536870916
 9117 0914 60004080 		.word	-2143289248
 9118 0918 00000000 		.word	0
 9119 091c 00000000 		.word	0
 9120 0920 00000000 		.word	0
 9121 0924 0620702E 		.word	779100166
 9122 0928 0C000000 		.word	12
 9123 092c 00000080 		.word	-2147483648
 9124 0930 0620702E 		.word	779100166
 9125 0934 0C000000 		.word	12
 9126 0938 00000080 		.word	-2147483648
 9127 093c 0394731E 		.word	510891011
 9128 0940 04000020 		.word	536870916
 9129 0944 60004080 		.word	-2143289248
 9130 0948 0620702E 		.word	779100166
 9131 094c 0C000000 		.word	12
 9132 0950 00000080 		.word	-2147483648
 9133 0954 0C93731E 		.word	510890764
 9134 0958 04000024 		.word	603979780
 9135 095c 90004080 		.word	-2143289200
 9136 0960 0D20702E 		.word	779100173
 9137 0964 0C000000 		.word	12
 9138 0968 00000080 		.word	-2147483648
 9139 096c 0780724E 		.word	1316126727
 9140 0970 0A000000 		.word	10
 9141 0974 00000080 		.word	-2147483648
 9142 0978 08000000 		.word	8
 9143 097c 00000000 		.word	0
 9144 0980 00010080 		.word	-2147483392
 9145 0984 0920702E 		.word	779100169
 9146 0988 0C010000 		.word	268
 9147 098c 00000080 		.word	-2147483648
 9148 0990 0A01701E 		.word	510656778
 9149 0994 0E000100 		.word	65550
 9150 0998 00000080 		.word	-2147483648
 9151 099c 00000000 		.word	0
 9152 09a0 00000000 		.word	0
 9153 09a4 00000000 		.word	0
 9154 09a8 00000000 		.word	0
 9155 09ac 00000000 		.word	0
 9156 09b0 00000000 		.word	0
 9157 09b4 0394731E 		.word	510891011
 9158 09b8 04000020 		.word	536870916
 9159 09bc 60004080 		.word	-2143289248
 9160 09c0 08000000 		.word	8
 9161 09c4 00000000 		.word	0
 9162 09c8 00010080 		.word	-2147483392
 9163 09cc 0B000000 		.word	11
 9164 09d0 00000000 		.word	0
 9165 09d4 00010080 		.word	-2147483392
 9166 09d8 0C93731E 		.word	510890764
 9167 09dc 04000024 		.word	603979780
 9168 09e0 90004080 		.word	-2143289200
 9169 09e4 0D20702E 		.word	779100173
 9170 09e8 0C000000 		.word	12
 9171 09ec 00000080 		.word	-2147483648
 9172 09f0 0D20702E 		.word	779100173
 9173 09f4 0C000000 		.word	12
 9174 09f8 00000080 		.word	-2147483648
 9175 09fc 0E60724E 		.word	1316118542
 9176 0a00 0A000000 		.word	10
 9177 0a04 00000080 		.word	-2147483648
 9178 0a08 0F000000 		.word	15
 9179 0a0c 00000000 		.word	0
 9180 0a10 00010080 		.word	-2147483392
 9181 0a14 1020702E 		.word	779100176
 9182 0a18 0C010000 		.word	268
 9183 0a1c 00000080 		.word	-2147483648
 9184 0a20 1101701E 		.word	510656785
 9185 0a24 0E000100 		.word	65550
 9186 0a28 00000080 		.word	-2147483648
 9187 0a2c 0C93731E 		.word	510890764
 9188 0a30 04000024 		.word	603979780
 9189 0a34 90004080 		.word	-2143289200
 9190 0a38 0F000000 		.word	15
 9191 0a3c 00000000 		.word	0
 9192 0a40 00010080 		.word	-2147483392
 9193 0a44 12000000 		.word	18
 9194 0a48 00000000 		.word	0
 9195 0a4c 00010080 		.word	-2147483392
 9196 0a50 0394731E 		.word	510891011
 9197 0a54 04000020 		.word	536870916
 9198 0a58 60004080 		.word	-2143289248
 9199 0a5c 0480732E 		.word	779321348
 9200 0a60 02010000 		.word	258
 9201 0a64 000040C0 		.word	-1069547520
 9202 0a68 0580732E 		.word	779321349
 9203 0a6c 02010000 		.word	258
 9204 0a70 000040C0 		.word	-1069547520
 9205 0a74 0580732E 		.word	779321349
 9206 0a78 02010000 		.word	258
 9207 0a7c 000040C0 		.word	-1069547520
 9208 0a80 0480732E 		.word	779321348
 9209 0a84 02010000 		.word	258
 9210 0a88 000040C0 		.word	-1069547520
 9213              	CyFxGpifWavedataPosition_usb2:
 9214 0a8c 00       		.byte	0
 9215 0a8d 01       		.byte	1
 9216 0a8e 02       		.byte	2
 9217 0a8f 03       		.byte	3
 9218 0a90 04       		.byte	4
 9219 0a91 05       		.byte	5
 9220 0a92 06       		.byte	6
 9221 0a93 07       		.byte	7
 9222 0a94 08       		.byte	8
 9223 0a95 09       		.byte	9
 9224 0a96 0A       		.byte	10
 9225 0a97 08       		.byte	8
 9226 0a98 0B       		.byte	11
 9227 0a99 0C       		.byte	12
 9228 0a9a 0D       		.byte	13
 9229 0a9b 08       		.byte	8
 9230 0a9c 0E       		.byte	14
 9231 0a9d 0F       		.byte	15
 9232 0a9e 08       		.byte	8
 9233 0a9f 08       		.byte	8
 9234 0aa0 08       		.byte	8
 9235 0aa1 08       		.byte	8
 9236 0aa2 08       		.byte	8
 9237 0aa3 08       		.byte	8
 9238 0aa4 08       		.byte	8
 9239 0aa5 08       		.byte	8
 9240 0aa6 08       		.byte	8
 9241 0aa7 08       		.byte	8
 9242 0aa8 08       		.byte	8
 9243 0aa9 08       		.byte	8
 9244 0aaa 08       		.byte	8
 9245 0aab 08       		.byte	8
 9246 0aac 08       		.byte	8
 9247 0aad 08       		.byte	8
 9248 0aae 08       		.byte	8
 9249 0aaf 08       		.byte	8
 9250 0ab0 08       		.byte	8
 9251 0ab1 08       		.byte	8
 9252 0ab2 08       		.byte	8
 9253 0ab3 08       		.byte	8
 9254 0ab4 08       		.byte	8
 9255 0ab5 08       		.byte	8
 9256 0ab6 08       		.byte	8
 9257 0ab7 08       		.byte	8
 9258 0ab8 08       		.byte	8
 9259 0ab9 08       		.byte	8
 9260 0aba 08       		.byte	8
 9261 0abb 08       		.byte	8
 9262 0abc 08       		.byte	8
 9263 0abd 08       		.byte	8
 9264 0abe 08       		.byte	8
 9265 0abf 08       		.byte	8
 9266 0ac0 08       		.byte	8
 9267 0ac1 08       		.byte	8
 9268 0ac2 08       		.byte	8
 9269 0ac3 08       		.byte	8
 9270 0ac4 08       		.byte	8
 9271 0ac5 08       		.byte	8
 9272 0ac6 08       		.byte	8
 9273 0ac7 08       		.byte	8
 9274 0ac8 08       		.byte	8
 9275 0ac9 08       		.byte	8
 9276 0aca 08       		.byte	8
 9277 0acb 08       		.byte	8
 9278 0acc 08       		.byte	8
 9279 0acd 08       		.byte	8
 9280 0ace 08       		.byte	8
 9281 0acf 08       		.byte	8
 9282 0ad0 08       		.byte	8
 9283 0ad1 08       		.byte	8
 9284 0ad2 08       		.byte	8
 9285 0ad3 08       		.byte	8
 9286 0ad4 08       		.byte	8
 9287 0ad5 08       		.byte	8
 9288 0ad6 08       		.byte	8
 9289 0ad7 08       		.byte	8
 9290 0ad8 08       		.byte	8
 9291 0ad9 08       		.byte	8
 9292 0ada 08       		.byte	8
 9293 0adb 08       		.byte	8
 9294 0adc 08       		.byte	8
 9295 0add 08       		.byte	8
 9296 0ade 08       		.byte	8
 9297 0adf 08       		.byte	8
 9298 0ae0 08       		.byte	8
 9299 0ae1 08       		.byte	8
 9300 0ae2 08       		.byte	8
 9301 0ae3 08       		.byte	8
 9302 0ae4 08       		.byte	8
 9303 0ae5 08       		.byte	8
 9304 0ae6 08       		.byte	8
 9305 0ae7 08       		.byte	8
 9306 0ae8 08       		.byte	8
 9307 0ae9 08       		.byte	8
 9308 0aea 08       		.byte	8
 9309 0aeb 08       		.byte	8
 9310 0aec 08       		.byte	8
 9311 0aed 08       		.byte	8
 9312 0aee 08       		.byte	8
 9313 0aef 08       		.byte	8
 9314 0af0 08       		.byte	8
 9315 0af1 08       		.byte	8
 9316 0af2 08       		.byte	8
 9317 0af3 08       		.byte	8
 9318 0af4 08       		.byte	8
 9319 0af5 08       		.byte	8
 9320 0af6 08       		.byte	8
 9321 0af7 08       		.byte	8
 9322 0af8 08       		.byte	8
 9323 0af9 08       		.byte	8
 9324 0afa 08       		.byte	8
 9325 0afb 08       		.byte	8
 9326 0afc 08       		.byte	8
 9327 0afd 08       		.byte	8
 9328 0afe 08       		.byte	8
 9329 0aff 08       		.byte	8
 9330 0b00 08       		.byte	8
 9331 0b01 08       		.byte	8
 9332 0b02 08       		.byte	8
 9333 0b03 08       		.byte	8
 9334 0b04 08       		.byte	8
 9335 0b05 08       		.byte	8
 9336 0b06 08       		.byte	8
 9337 0b07 08       		.byte	8
 9338 0b08 08       		.byte	8
 9339 0b09 08       		.byte	8
 9340 0b0a 08       		.byte	8
 9341 0b0b 08       		.byte	8
 9342 0b0c 00       		.byte	0
 9343 0b0d 01       		.byte	1
 9344 0b0e 02       		.byte	2
 9345 0b0f 10       		.byte	16
 9346 0b10 04       		.byte	4
 9347 0b11 05       		.byte	5
 9348 0b12 06       		.byte	6
 9349 0b13 07       		.byte	7
 9350 0b14 08       		.byte	8
 9351 0b15 09       		.byte	9
 9352 0b16 0A       		.byte	10
 9353 0b17 08       		.byte	8
 9354 0b18 11       		.byte	17
 9355 0b19 0C       		.byte	12
 9356 0b1a 0D       		.byte	13
 9357 0b1b 08       		.byte	8
 9358 0b1c 0E       		.byte	14
 9359 0b1d 0F       		.byte	15
 9360 0b1e 08       		.byte	8
 9361 0b1f 00       		.space	1
 9364              	CyFxGpifRegValue_usb2:
 9365 0b20 08830080 		.word	-2147450104
 9366 0b24 67000000 		.word	103
 9367 0b28 01000000 		.word	1
 9368 0b2c 46000000 		.word	70
 9369 0b30 00000000 		.word	0
 9370 0b34 00000000 		.word	0
 9371 0b38 02000000 		.word	2
 9372 0b3c 82000000 		.word	130
 9373 0b40 82070000 		.word	1922
 9374 0b44 40040000 		.word	1088
 9375 0b48 FCFF0000 		.word	65532
 9376 0b4c 28000000 		.word	40
 9377 0b50 00000000 		.word	0
 9378 0b54 00000000 		.word	0
 9379 0b58 00000000 		.word	0
 9380 0b5c 00000000 		.word	0
 9381 0b60 01000000 		.word	1
 9382 0b64 00000000 		.word	0
 9383 0b68 00000000 		.word	0
 9384 0b6c 00000000 		.word	0
 9385 0b70 00000000 		.word	0
 9386 0b74 00000000 		.word	0
 9387 0b78 00000000 		.word	0
 9388 0b7c 00000000 		.word	0
 9389 0b80 00000000 		.word	0
 9390 0b84 00000000 		.word	0
 9391 0b88 00000000 		.word	0
 9392 0b8c 00000000 		.word	0
 9393 0b90 00000000 		.word	0
 9394 0b94 06000000 		.word	6
 9395 0b98 00000000 		.word	0
 9396 0b9c FFFF0000 		.word	65535
 9397 0ba0 09010000 		.word	265
 9398 0ba4 00000000 		.word	0
 9399 0ba8 F71F0000 		.word	8183
 9400 0bac 00000000 		.word	0
 9401 0bb0 FFFF0000 		.word	65535
 9402 0bb4 09010000 		.word	265
 9403 0bb8 00000000 		.word	0
 9404 0bbc F71F0000 		.word	8183
 9405 0bc0 00000000 		.word	0
 9406 0bc4 00000000 		.word	0
 9407 0bc8 00000000 		.word	0
 9408 0bcc 00000000 		.word	0
 9409 0bd0 00000000 		.word	0
 9410 0bd4 00000000 		.word	0
 9411 0bd8 00000000 		.word	0
 9412 0bdc 00000000 		.word	0
 9413 0be0 00000000 		.word	0
 9414 0be4 00000000 		.word	0
 9415 0be8 00000000 		.word	0
 9416 0bec 00000000 		.word	0
 9417 0bf0 00000000 		.word	0
 9418 0bf4 00000000 		.word	0
 9419 0bf8 00000000 		.word	0
 9420 0bfc 00000000 		.word	0
 9421 0c00 00000000 		.word	0
 9422 0c04 00000000 		.word	0
 9423 0c08 00000000 		.word	0
 9424 0c0c 00000000 		.word	0
 9425 0c10 00000000 		.word	0
 9426 0c14 00000000 		.word	0
 9427 0c18 00000000 		.word	0
 9428 0c1c 00040180 		.word	-2147417088
 9429 0c20 01040180 		.word	-2147417087
 9430 0c24 02040180 		.word	-2147417086
 9431 0c28 03040180 		.word	-2147417085
 9432 0c2c 00000000 		.word	0
 9433 0c30 00000000 		.word	0
 9434 0c34 00000000 		.word	0
 9435 0c38 00000000 		.word	0
 9436 0c3c 00000000 		.word	0
 9437 0c40 00000000 		.word	0
 9438 0c44 00000000 		.word	0
 9439 0c48 00000000 		.word	0
 9440 0c4c C1FFFFFF 		.word	-63
 9441              		.section	.rodata.str1.4,"aMS",%progbits,1
 9442              		.align	2
 9443              	.LC0:
 9444 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9444      7065722D 
 9444      74696D65 
 9444      72202564 
 9444      0D0A00
 9445 0013 00       		.space	1
 9446              	.LC1:
 9447 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9447      636F6D6D 
 9447      616E6420 
 9447      71756575 
 9447      65206973 
 9448 0037 00       		.space	1
 9449              	.LC2:
 9450 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9450      7220696E 
 9450      206D756C 
 9450      74696368 
 9450      616E6E65 
 9451 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 9451      2C20646D 
 9451      61446F6E 
 9451      65202578 
 9451      0D0A00
 9452 007e 0000     		.space	2
 9453              	.LC3:
 9454 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9454      5420656E 
 9454      636F756E 
 9454      74657265 
 9454      642E2E2E 
 9455              	.LC4:
 9456 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9456      454E4420 
 9456      656E636F 
 9456      756E7465 
 9456      7265642E 
 9457 00c2 0000     		.space	2
 9458              	.LC5:
 9459 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9459      64697363 
 9459      6F6E6E65 
 9459      63746564 
 9459      2E2E2E30 
 9460 00e3 00       		.space	1
 9461              	.LC6:
 9462 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9462      43595F46 
 9462      585F5556 
 9462      435F5649 
 9462      44454F5F 
 9463 0117 0A00     		.ascii	"\012\000"
 9464 0119 000000   		.space	3
 9465              	.LC7:
 9466 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9466      43595F46 
 9466      585F5556 
 9466      435F5649 
 9466      44454F5F 
 9467 014f 00       		.ascii	"\000"
 9468              	.LC8:
 9469 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9469      726E6174 
 9469      65207365 
 9469      7474696E 
 9469      6720302E 
 9470              	.LC9:
 9471 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9471      72206665 
 9471      61747572 
 9471      65207265 
 9471      71756573 
 9472 018b 00       		.space	1
 9473              	.LC10:
 9474 018c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9474      6F6D6D69 
 9474      74656F66 
 9474      20737461 
 9474      7465203D 
 9475              	.LC11:
 9476 01a4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9476      6E656C20 
 9476      53657420 
 9476      57726170 
 9476      55702066 
 9477 01d1 000000   		.space	3
 9478              	.LC12:
 9479 01d4 4572726F 		.ascii	"Error handler...\015\012\000"
 9479      72206861 
 9479      6E646C65 
 9479      722E2E2E 
 9479      0D0A00
 9480 01e7 00       		.space	1
 9481              	.LC13:
 9482 01e8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9482      69742045 
 9482      4F462066 
 9482      61696C65 
 9482      64210A00 
 9483              	.LC14:
 9484 01fc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9484      49324320 
 9484      636F6D6D 
 9484      616E6420 
 9484      69732030 
 9485 022f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9485      78257820 
 9485      30782578 
 9485      20307825 
 9485      78203078 
 9486              	.LC15:
 9487 0248 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9487      206C6967 
 9487      68742063 
 9487      6F6D7065 
 9487      6E736174 
 9488 027b 25640D0A 		.ascii	"%d\015\012\000"
 9488      00
 9489              	.LC16:
 9490 0280 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9490      49324320 
 9490      63757272 
 9490      656E7420 
 9490      64617461 
 9491 02b3 64202564 		.ascii	"d %d\015\012\000"
 9491      0D0A00
 9492 02ba 0000     		.space	2
 9493              	.LC17:
 9494 02bc 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9494      26414743 
 9494      2073656E 
 9494      7420746F 
 9494      20686F73 
 9495 02e2 0000     		.space	2
 9496              	.LC18:
 9497 02e4 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9497      26414743 
 9497      20676F74 
 9497      74656E20 
 9497      66726F6D 
 9498 030e 0000     		.space	2
 9499              	.LC19:
 9500 0310 45786520 		.ascii	"Exe level. %d %d; %d %d\015\012\000"
 9500      6C657665 
 9500      6C2E2025 
 9500      64202564 
 9500      3B202564 
 9501 032a 0000     		.space	2
 9502              	.LC20:
 9503 032c 424C4320 		.ascii	"BLC set. %d %d; %d %d\015\012\000"
 9503      7365742E 
 9503      20256420 
 9503      25643B20 
 9503      25642025 
 9504              	.LC21:
 9505 0344 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9505      67657420 
 9505      64617461 
 9505      2066726F 
 9505      6D20686F 
 9506 0371 000000   		.space	3
 9507              	.LC22:
 9508 0374 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9508      52657175 
 9508      65737420 
 9508      30782578 
 9508      20706172 
 9509 03a7 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9509      6E642074 
 9509      6F20686F 
 9509      73742030 
 9509      78257820 
 9510 03c2 0000     		.space	2
 9511              	.LC23:
 9512 03c4 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9512      204F7020 
 9512      72656365 
 9512      69766573 
 9512      20284354 
 9513 03eb 00       		.space	1
 9514              	.LC24:
 9515 03ec 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9515      756C7420 
 9515      73656C65 
 9515      63746F72 
 9515      20284354 
 9516 040e 0000     		.space	2
 9517              	.LC25:
 9518 0410 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9518      756C7420 
 9518      72657175 
 9518      65737420 
 9518      28435429 
 9519 0431 000000   		.space	3
 9520              	.LC26:
 9521 0434 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9521      52657175 
 9521      65737420 
 9521      30782578 
 9521      20706172 
 9522 0467 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9522      20307825 
 9522      78202F20 
 9522      73656E64 
 9522      20746F20 
 9523 0494 00       		.ascii	"\000"
 9524 0495 000000   		.space	3
 9525              	.LC27:
 9526 0498 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9526      73706565 
 9526      64203D20 
 9526      25642065 
 9526      76656E66 
 9527 04c8 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9527      71756573 
 9527      74203D20 
 9527      30782578 
 9527      20775661 
 9528 04f8 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9528      203D2030 
 9528      78257820 
 9528      6973666C 
 9528      61672030 
 9529 0512 0000     		.space	2
 9530              	.LC28:
 9531 0514 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9531      64656661 
 9531      756C7420 
 9531      73657475 
 9531      70207265 
 9532              	.LC29:
 9533 0540 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9533      43595F46 
 9533      585F5556 
 9533      435F5354 
 9533      5245414D 
 9534 0566 0000     		.space	2
 9535              	.LC30:
 9536 0568 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 9536      55564320 
 9536      7374696C 
 9536      6C207472 
 9536      69676765 
 9537 0591 000000   		.space	3
 9538              	.LC31:
 9539 0594 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9539      7374696C 
 9539      6C207472 
 9539      69676765 
 9539      7220636F 
 9540 05bb 00       		.space	1
 9541              	.LC32:
 9542 05bc 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9542      65642074 
 9542      6F207365 
 9542      6E642069 
 9542      6E746572 
 9543 05ed 0A00     		.ascii	"\012\000"
 9544 05ef 00       		.space	1
 9545              	.LC33:
 9546 05f0 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9546      73657420 
 9546      64656620 
 9546      64617461 
 9546      20307825 
 9547 060f 00       		.space	1
 9548              	.LC34:
 9549 0610 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9549      73657420 
 9549      64656620 
 9549      64617461 
 9549      20307825 
 9550 0643 2E0D0A00 		.ascii	".\015\012\000"
 9551 0647 00       		.space	1
 9552              	.LC35:
 9553 0648 55415254 		.ascii	"UART initialization failed!\012\000"
 9553      20696E69 
 9553      7469616C 
 9553      697A6174 
 9553      696F6E20 
 9554 0665 000000   		.space	3
 9555              	.LC36:
 9556 0668 49324320 		.ascii	"I2C initialization failed!\012\000"
 9556      696E6974 
 9556      69616C69 
 9556      7A617469 
 9556      6F6E2066 
 9557              	.LC37:
 9558 0684 49324320 		.ascii	"I2C configuration failed!\012\000"
 9558      636F6E66 
 9558      69677572 
 9558      6174696F 
 9558      6E206661 
 9559 069f 00       		.space	1
 9560              	.LC38:
 9561 06a0 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9561      43726561 
 9561      74652045 
 9561      76656E74 
 9561      20666169 
 9562 06ca 0000     		.space	2
 9563              	.LC39:
 9564 06cc 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9564      20496E69 
 9564      74206661 
 9564      696C6564 
 9564      2C204572 
 9565 06ef 00       		.space	1
 9566              	.LC40:
 9567 06f0 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9567      204F7665 
 9567      72726964 
 9567      65206661 
 9567      696C6564 
 9568 0717 00       		.space	1
 9569              	.LC41:
 9570 0718 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9570      28323029 
 9570      204F7665 
 9570      72726964 
 9570      65206661 
 9571 0743 00       		.space	1
 9572              	.LC42:
 9573 0744 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9573      28323429 
 9573      204F7665 
 9573      72726964 
 9573      65206661 
 9574 076f 00       		.space	1
 9575              	.LC43:
 9576 0770 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9576      20536574 
 9576      20287265 
 9576      73657420 
 9576      32322920 
 9577 07a2 00       		.ascii	"\000"
 9578 07a3 00       		.space	1
 9579              	.LC44:
 9580 07a4 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9580      20536574 
 9580      2028706F 
 9580      77657220 
 9580      32302920 
 9581 07d6 00       		.ascii	"\000"
 9582 07d7 00       		.space	1
 9583              	.LC45:
 9584 07d8 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9584      20536574 
 9584      2028736E 
 9584      61702073 
 9584      686F7420 
 9585 080b 25640A00 		.ascii	"%d\012\000"
 9586 080f 00       		.space	1
 9587              	.LC46:
 9588 0810 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9588      46756E63 
 9588      74696F6E 
 9588      20466169 
 9588      6C656420 
 9589 083f 00       		.space	1
 9590              	.LC47:
 9591 0840 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9591      46756E63 
 9591      74696F6E 
 9591      20466169 
 9591      6C656420 
 9592 086f 00       		.space	1
 9593              	.LC48:
 9594 0870 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9594      53657420 
 9594      456E6470 
 9594      6F696E74 
 9594      20636F6E 
 9595 08a0 00       		.ascii	"\000"
 9596 08a1 000000   		.space	3
 9597              	.LC49:
 9598 08a4 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9598      496E7465 
 9598      72727570 
 9598      74205374 
 9598      61747573 
 9599 08d7 20436F64 		.ascii	" Code = %d\012\000"
 9599      65203D20 
 9599      25640A00 
 9600 08e3 00       		.space	1
 9601              	.LC50:
 9602 08e4 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9602      65642074 
 9602      6F20616C 
 9602      6C6F6361 
 9602      7465206D 
 9603 0917 65720D0A 		.ascii	"er\015\012\000"
 9603      00
 9604              	.LC51:
 9605 091c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9605      4368616E 
 9605      6E656C20 
 9605      43726561 
 9605      74696F6E 
 9606 094a 0000     		.space	2
 9607              	.LC52:
 9608 094c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9608      436F6E6E 
 9608      65637420 
 9608      6661696C 
 9608      65642C20 
 9609 0971 000000   		.space	3
 9610              	.LC53:
 9611 0974 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9611      4368616E 
 9611      6E656C20 
 9611      52657365 
 9611      74204661 
 9612 099f 00       		.space	1
 9613              	.LC54:
 9614 09a0 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9614      4368616E 
 9614      6E656C20 
 9614      53657420 
 9614      5472616E 
 9615 09d1 00       		.ascii	"\000"
 9616 09d2 0000     		.space	2
 9617              	.LC55:
 9618 09d4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9618      4368616E 
 9618      6E656C20 
 9618      53657420 
 9618      5472616E 
 9619 0a05 0A00     		.ascii	"\012\000"
 9620 0a07 00       		.space	1
 9621              	.LC56:
 9622 0a08 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9622      75706572 
 9622      20677069 
 9622      6600
 9623 0a16 0000     		.space	2
 9624              	.LC57:
 9625 0a18 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9625      69676820 
 9625      67706966 
 9625      00
 9626 0a25 000000   		.space	3
 9627              	.LC58:
 9628 0a28 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9628      696E6720 
 9628      47504946 
 9628      20436F6E 
 9628      66696775 
 9629 0a5b 0A00     		.ascii	"\012\000"
 9630 0a5d 000000   		.space	3
 9631              	.LC59:
 9632 0a60 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9632      74696E67 
 9632      20475049 
 9632      46207374 
 9632      61746520 
 9633 0a93 0D0A00   		.ascii	"\015\012\000"
 9634 0a96 0000     		.space	2
 9635              	.LC60:
 9636 0a98 33303A55 		.ascii	"30:UVC App Thread\000"
 9636      56432041 
 9636      70702054 
 9636      68726561 
 9636      6400
 9637 0aaa 0000     		.space	2
 9638              	.LC61:
 9639 0aac 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9639      56432041 
 9639      70702045 
 9639      50302054 
 9639      68726561 
 9640 0ac2 0000     		.space	2
 9641              	.LC62:
 9642 0ac4 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9642      32432041 
 9642      70702043 
 9642      54524C20 
 9642      54687265 
 9643 0adb 00       		.bss
 9644              		.align	2
 9645              		.set	.LANCHOR0,. + 0
 9648              	glFxUVCEvent:
 9649 0000 00000000 		.space	40
 9649      00000000 
 9649      00000000 
 9649      00000000 
 9649      00000000 
 9652              	fb:
 9653 0028 0000     		.space	2
 9656              	pb:
 9657 002a 0000     		.space	2
 9660              	pbc:
 9661 002c 0000     		.space	2
 9664              	prodCount:
 9665 002e 0000     		.space	2
 9668              	consCount:
 9669 0030 0000     		.space	2
 9670 0032 0000     		.space	2
 9673              	streamingStarted:
 9674 0034 00000000 		.space	4
 9677              	gpif_initialized:
 9678 0038 00000000 		.space	4
 9681              	isUsbConnected:
 9682 003c 00000000 		.space	4
 9685              	clearFeatureRqtReceived:
 9686 0040 00000000 		.space	4
 9689              	hitFV:
 9690 0044 00000000 		.space	4
 9693              	usbSpeed:
 9694 0048 00       		.space	1
 9695 0049 000000   		.space	3
 9698              	I2CCMDArry:
 9699 004c 00000000 		.space	12
 9699      00000000 
 9699      00000000 
 9702              	glEp0Buffer:
 9703 0058 00000000 		.space	32
 9703      00000000 
 9703      00000000 
 9703      00000000 
 9703      00000000 
 9706              	WDRflag:
 9707 0078 00000000 		.space	4
 9710              	glCommitCtrl:
 9711 007c 00000000 		.space	32
 9711      00000000 
 9711      00000000 
 9711      00000000 
 9711      00000000 
 9714              	stiflag:
 9715 009c 00000000 		.space	4
 9718              	uvcAppThread:
 9719 00a0 00000000 		.space	168
 9719      00000000 
 9719      00000000 
 9719      00000000 
 9719      00000000 
 9722              	uvcAppEP0Thread:
 9723 0148 00000000 		.space	168
 9723      00000000 
 9723      00000000 
 9723      00000000 
 9723      00000000 
 9726              	i2cAppThread:
 9727 01f0 00000000 		.space	168
 9727      00000000 
 9727      00000000 
 9727      00000000 
 9727      00000000 
 9730              	testSnap:
 9731 0298 00       		.space	1
 9732 0299 00       		.space	1
 9735              	fbbak:
 9736 029a 0000     		.space	2
 9739              	pbbak:
 9740 029c 0000     		.space	2
 9743              	pbcbak:
 9744 029e 0000     		.space	2
 9747              	pbcpbak:
 9748 02a0 0000     		.space	2
 9749 02a2 0000     		.text
 9750              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:282    .text:0000020c $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:296    .text:0000022c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:293    .text:0000022c $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:315    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:319    .text:00000240 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:322    .text:00000240 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:480    .text:00000368 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:488    .text:0000037c $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:490    .text:0000037c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:669    .text:000004dc $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:678    .text:000004ec $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:680    .text:000004ec CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1005   .text:000007b4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1021   .text:000007e0 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1024   .text:000007e0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1070   .text:0000081c $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1083   .text:00000848 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1146   .text:000008b8 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1153   .text:000008c8 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1164   .text:000008e0 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1167   .text:000008e0 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1295   .text:000009f4 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1300   .text:000009fc $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1303   .text:000009fc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1366   .text:00000a7c ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1578   .text:00000c24 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1620   .text:00000cc0 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1685   .text:00000d44 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:1725   .text:00000ddc $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3003   .text:000019f8 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3023   .text:00001a3c $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3026   .text:00001a3c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3194   .text:00001b98 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3207   .text:00001bc0 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3702   .text:000020d0 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3713   .text:000020f0 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3975   .text:000023ac $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3988   .text:000023d4 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:3991   .text:000023d4 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:4053   .text:00002450 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:4061   .text:00002460 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5196   .text:00002dbc $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5223   .text:00002e14 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5226   .text:00002e14 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5517   .text:000030cc $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5524   .text:000030dc $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5527   .text:000030dc CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5563   .text:00003108 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5567   .text:0000310c $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5570   .text:0000310c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5595   .text:00003128 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5599   .text:0000312c $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:5602   .text:0000312c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:6981   .text:00003bf0 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7041   .text:00003cc4 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7044   .text:00003cc4 CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7127   .text:00003d50 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7136   .text:00003d60 $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7139   .text:00003d60 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7296   .text:00003ed8 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7312   .text:00003f0c $a
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7315   .text:00003f0c main
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8909   .data:00000660 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8918   .data:0000066c CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8993   .data:0000078c CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9012   .data:0000079c CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7476   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9091   .data:000008cc CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9102   .data:000008dc CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9213   .data:00000a8c CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9364   .data:00000b20 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7489   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8905   .data:0000065f snapButFlag
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9730   .bss:00000298 testSnap
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9652   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9656   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9660   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9735   .bss:0000029a fbbak
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9739   .bss:0000029c pbbak
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9743   .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9747   .bss:000002a0 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9681   .bss:0000003c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9693   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9685   .bss:00000040 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9673   .bss:00000034 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8816   .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8876   .data:00000648 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8846   .data:0000062c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8891   .data:00000654 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8471   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7453   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7457   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7501   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7505   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:7828   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8486   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:8493   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9442   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9644   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9648   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9664   .bss:0000002e prodCount
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9668   .bss:00000030 consCount
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9677   .bss:00000038 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9689   .bss:00000044 hitFV
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9698   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9702   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9706   .bss:00000078 WDRflag
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9710   .bss:0000007c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9714   .bss:0000009c stiflag
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9718   .bss:000000a0 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9722   .bss:00000148 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cc7NMJqc.s:9726   .bss:000001f0 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
